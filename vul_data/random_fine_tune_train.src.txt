CWE-476 void * sspi_SecureHandleGetLowerPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwLower ) ; return pointer ; }
CWE-119 SQLWCHAR * _single_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 1 ) ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; return chr ; }
CWE-125 u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , "IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "seq<S2SV_blank>%02x<S2SV_blank>" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_StartBug> ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p + 2 ) ) ) ; <S2SV_EndBug> p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<<S2SV_blank>" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }
CWE-399 static int dcbnl_getperm_hwaddr ( struct net_device * netdev , struct nlmsghdr * nlh , u32 seq , struct nlattr * * tb , struct sk_buff * skb ) { u8 perm_addr [ MAX_ADDR_LEN ] ; if ( ! netdev -> dcbnl_ops -> getpermhwaddr ) return - EOPNOTSUPP ; <S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ; }
CWE-476 static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> cluster -> cl_local_node != node -> nd_num ) <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> ret = o2net_start_listening ( node ) ; if ( ret ) <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } <S2SV_StartBug> return count ; <S2SV_EndBug> }
CWE-119 CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) { ssize_t i ; ssize_t si ; struct Curl_easy * data = conn -> data ; struct SMTP * smtp = data -> req . protop ; char * scratch = data -> state . scratch ; char * newscratch = NULL ; char * oldscratch = NULL ; size_t eob_sent ; if ( ! scratch || data -> set . crlf ) { oldscratch = scratch ; <S2SV_StartBug> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <S2SV_EndBug> if ( ! newscratch ) { failf ( data , "Failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>scratch<S2SV_blank>buffer!" ) ; return CURLE_OUT_OF_MEMORY ; } <S2SV_StartBug> } <S2SV_EndBug> eob_sent = smtp -> eob ; for ( i = 0 , si = 0 ; i < nread ; i ++ ) { if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { smtp -> eob ++ ; if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) smtp -> trailing_crlf = TRUE ; else smtp -> trailing_crlf = FALSE ; } else if ( smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) smtp -> eob = 1 ; else smtp -> eob = 0 ; eob_sent = 0 ; smtp -> trailing_crlf = FALSE ; } if ( SMTP_EOB_FIND_LEN == smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB_REPL [ eob_sent ] , SMTP_EOB_REPL_LEN - eob_sent ) ; si += SMTP_EOB_REPL_LEN - eob_sent ; smtp -> eob = 0 ; eob_sent = 0 ; } else if ( ! smtp -> eob ) scratch [ si ++ ] = data -> req . upload_fromhere [ i ] ; } if ( smtp -> eob - eob_sent ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; } if ( si != nread ) { data -> req . upload_fromhere = scratch ; data -> state . scratch = scratch ; free ( oldscratch ) ; data -> req . upload_present = si ; } else free ( newscratch ) ; return CURLE_OK ; }
CWE-362 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( "%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\n" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <S2SV_StartBug> BUG_ON ( sk != asoc -> base . sk ) ; <S2SV_EndBug> lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }
CWE-119 <S2SV_StartBug> static void update_mv_probs ( vp9_prob * p , int n , vp9_reader * r ) { <S2SV_EndBug> int i ; for ( i = 0 ; i < n ; ++ i ) <S2SV_StartBug> if ( vp9_read ( r , MV_UPDATE_PROB ) ) <S2SV_EndBug> <S2SV_StartBug> p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ; <S2SV_EndBug> }
CWE-264 static int walk_pmd_range ( pud_t * pud , unsigned long addr , unsigned long end , struct mm_walk * walk ) { pmd_t * pmd ; unsigned long next ; int err = 0 ; pmd = pmd_offset ( pud , addr ) ; do { again : next = pmd_addr_end ( addr , end ) ; if ( pmd_none ( * pmd ) ) { if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ; if ( err ) break ; continue ; } if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ; if ( err ) break ; if ( ! walk -> pte_entry ) continue ; split_huge_page_pmd ( walk -> mm , pmd ) ; <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err ) break ; } while ( pmd ++ , addr = next , addr != end ) ; return err ; }
CWE-20 int vp9_alloc_context_buffers ( VP9_COMMON * cm , int width , int height ) { int new_mi_size ; vp9_set_mb_mi ( cm , width , height ) ; new_mi_size = cm -> mi_stride * calc_mi_size ( cm -> mi_rows ) ; if ( cm -> mi_alloc_size < new_mi_size ) { cm -> free_mi ( cm ) ; if ( cm -> alloc_mi ( cm , new_mi_size ) ) goto fail ; } if ( cm -> seg_map_alloc_size < cm -> mi_rows * cm -> mi_cols ) { free_seg_map ( cm ) ; if ( alloc_seg_map ( cm , cm -> mi_rows * cm -> mi_cols ) ) goto fail ; } if ( cm -> above_context_alloc_cols < cm -> mi_cols ) { vpx_free ( cm -> above_context ) ; cm -> above_context = ( ENTROPY_CONTEXT * ) vpx_calloc ( 2 * mi_cols_aligned_to_sb ( cm -> mi_cols ) * MAX_MB_PLANE , sizeof ( * cm -> above_context ) ) ; if ( ! cm -> above_context ) goto fail ; vpx_free ( cm -> above_seg_context ) ; cm -> above_seg_context = ( PARTITION_CONTEXT * ) vpx_calloc ( mi_cols_aligned_to_sb ( cm -> mi_cols ) , sizeof ( * cm -> above_seg_context ) ) ; if ( ! cm -> above_seg_context ) goto fail ; cm -> above_context_alloc_cols = cm -> mi_cols ; } return 0 ; fail : <S2SV_StartBug> vp9_free_context_buffers ( cm ) ; <S2SV_EndBug> return 1 ; }
CWE-20 static int irda_recvmsg_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied = 0 ; int target , err ; long timeo ; IRDA_DEBUG ( 3 , "%s()\\n" , __func__ ) ; if ( ( err = sock_error ( sk ) ) < 0 ) return err ; if ( sock -> flags & __SO_ACCEPTCON ) return - EINVAL ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; err = 0 ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , noblock ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> do { int chunk ; struct sk_buff * skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( skb == NULL ) { DEFINE_WAIT ( wait ) ; err = 0 ; if ( copied >= target ) break ; prepare_to_wait_exclusive ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; err = sock_error ( sk ) ; if ( err ) ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) ; else if ( noblock ) err = - EAGAIN ; else if ( signal_pending ( current ) ) err = sock_intr_errno ( timeo ) ; else if ( sk -> sk_state != TCP_ESTABLISHED ) err = - ENOTCONN ; else if ( skb_peek ( & sk -> sk_receive_queue ) == NULL ) schedule ( ) ; finish_wait ( sk_sleep ( sk ) , & wait ) ; if ( err ) return err ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { skb_pull ( skb , chunk ) ; if ( skb -> len ) { IRDA_DEBUG ( 1 , "%s(),<S2SV_blank>back<S2SV_blank>on<S2SV_blank>q!\\n" , __func__ ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { IRDA_DEBUG ( 0 , "%s()<S2SV_blank>questionable!?\\n" , __func__ ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , "%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\n" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }
CWE-399 static void call_bind_status ( struct rpc_task * task ) { int status = - EIO ; if ( task -> tk_status >= 0 ) { dprint_status ( task ) ; task -> tk_status = 0 ; task -> tk_action = call_connect ; return ; } switch ( task -> tk_status ) { case - ENOMEM : dprintk ( "RPC:<S2SV_blank>%5u<S2SV_blank>rpcbind<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n" , task -> tk_pid ) ; rpc_delay ( task , HZ >> 2 ) ; goto retry_timeout ; case - EACCES : dprintk ( "RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind:<S2SV_blank>RPC<S2SV_blank>program/version<S2SV_blank>" "unavailable\\n" , task -> tk_pid ) ; if ( task -> tk_msg . rpc_proc -> p_proc == 0 ) { status = - EOPNOTSUPP ; break ; } <S2SV_StartBug> rpc_delay ( task , 3 * HZ ) ; <S2SV_EndBug> goto retry_timeout ; case - ETIMEDOUT : dprintk ( "RPC:<S2SV_blank>%5u<S2SV_blank>rpcbind<S2SV_blank>request<S2SV_blank>timed<S2SV_blank>out\\n" , task -> tk_pid ) ; goto retry_timeout ; case - EPFNOSUPPORT : dprintk ( "RPC:<S2SV_blank>%5u<S2SV_blank>unrecognized<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>service\\n" , task -> tk_pid ) ; break ; case - EPROTONOSUPPORT : dprintk ( "RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>version<S2SV_blank>unavailable,<S2SV_blank>retrying\\n" , task -> tk_pid ) ; task -> tk_status = 0 ; task -> tk_action = call_bind ; return ; case - ECONNREFUSED : case - ECONNRESET : case - ENOTCONN : case - EHOSTDOWN : case - EHOSTUNREACH : case - ENETUNREACH : case - EPIPE : dprintk ( "RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>unreachable:<S2SV_blank>%d\\n" , task -> tk_pid , task -> tk_status ) ; if ( ! RPC_IS_SOFTCONN ( task ) ) { rpc_delay ( task , 5 * HZ ) ; goto retry_timeout ; } status = task -> tk_status ; break ; default : dprintk ( "RPC:<S2SV_blank>%5u<S2SV_blank>unrecognized<S2SV_blank>rpcbind<S2SV_blank>error<S2SV_blank>(%d)\\n" , task -> tk_pid , - task -> tk_status ) ; } rpc_exit ( task , status ) ; return ; retry_timeout : task -> tk_action = call_timeout ; }
CWE-264 static int server_input_global_request ( int type , u_int32_t seq , void * ctxt ) { char * rtype ; int want_reply ; int r , success = 0 , allocated_listen_port = 0 ; struct sshbuf * resp = NULL ; rtype = packet_get_string ( NULL ) ; want_reply = packet_get_char ( ) ; debug ( "server_input_global_request:<S2SV_blank>rtype<S2SV_blank>%s<S2SV_blank>want_reply<S2SV_blank>%d" , rtype , want_reply ) ; if ( strcmp ( rtype , "tcpip-forward" ) == 0 ) { struct passwd * pw ; struct Forward fwd ; pw = the_authctxt -> pw ; if ( pw == NULL || ! the_authctxt -> valid ) fatal ( "server_input_global_request:<S2SV_blank>no/invalid<S2SV_blank>user" ) ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( "server_input_global_request:<S2SV_blank>tcpip-forward<S2SV_blank>listen<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d" , fwd . listen_host , fwd . listen_port ) ; if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) { success = 0 ; packet_send_debug ( "Server<S2SV_blank>has<S2SV_blank>disabled<S2SV_blank>port<S2SV_blank>forwarding." ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , & allocated_listen_port , & options . fwd_opts ) ; } free ( fwd . listen_host ) ; if ( ( resp = sshbuf_new ( ) ) == NULL ) fatal ( "%s:<S2SV_blank>sshbuf_new" , __func__ ) ; if ( allocated_listen_port != 0 && ( r = sshbuf_put_u32 ( resp , allocated_listen_port ) ) != 0 ) fatal ( "%s:<S2SV_blank>sshbuf_put_u32:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; } else if ( strcmp ( rtype , "cancel-tcpip-forward" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( "%s:<S2SV_blank>cancel-tcpip-forward<S2SV_blank>addr<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d" , __func__ , fwd . listen_host , fwd . listen_port ) ; success = channel_cancel_rport_listener ( & fwd ) ; free ( fwd . listen_host ) ; } else if ( strcmp ( rtype , "streamlocal-forward@openssh.com" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_path = packet_get_string ( NULL ) ; debug ( "server_input_global_request:<S2SV_blank>streamlocal-forward<S2SV_blank>listen<S2SV_blank>path<S2SV_blank>%s" , fwd . listen_path ) ; if ( ( options . allow_streamlocal_forwarding & FORWARD_REMOTE ) == 0 <S2SV_StartBug> || no_port_forwarding_flag || options . disable_forwarding ) { <S2SV_EndBug> success = 0 ; packet_send_debug ( "Server<S2SV_blank>has<S2SV_blank>disabled<S2SV_blank>port<S2SV_blank>forwarding." ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , NULL , & options . fwd_opts ) ; } free ( fwd . listen_path ) ; } else if ( strcmp ( rtype , "cancel-streamlocal-forward@openssh.com" ) == 0 ) { struct Forward fwd ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_path = packet_get_string ( NULL ) ; debug ( "%s:<S2SV_blank>cancel-streamlocal-forward<S2SV_blank>path<S2SV_blank>%s" , __func__ , fwd . listen_path ) ; success = channel_cancel_rport_listener ( & fwd ) ; free ( fwd . listen_path ) ; } else if ( strcmp ( rtype , "no-more-sessions@openssh.com" ) == 0 ) { no_more_sessions = 1 ; success = 1 ; } else if ( strcmp ( rtype , "hostkeys-prove-00@openssh.com" ) == 0 ) { success = server_input_hostkeys_prove ( & resp ) ; } if ( want_reply ) { packet_start ( success ? SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE ) ; if ( success && resp != NULL ) ssh_packet_put_raw ( active_state , sshbuf_ptr ( resp ) , sshbuf_len ( resp ) ) ; packet_send ( ) ; packet_write_wait ( ) ; } free ( rtype ) ; sshbuf_free ( resp ) ; return 0 ; }
CWE-119 void uwbd_start ( struct uwb_rc * rc ) { <S2SV_StartBug> rc -> uwbd . task = kthread_run ( uwbd , rc , "uwbd" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rc -> uwbd . task == NULL ) <S2SV_EndBug> printk ( KERN_ERR "UWB:<S2SV_blank>Cannot<S2SV_blank>start<S2SV_blank>management<S2SV_blank>daemon;<S2SV_blank>" "UWB<S2SV_blank>won\'t<S2SV_blank>work\\n" ) ; <S2SV_StartBug> else <S2SV_EndBug> rc -> uwbd . pid = rc -> uwbd . task -> pid ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static int get_default_root ( pool * p , int allow_symlinks , char * * root ) { config_rec * c = NULL ; char * dir = NULL ; int res ; c = find_config ( main_server -> conf , CONF_PARAM , "DefaultRoot" , FALSE ) ; while ( c ) { pr_signals_handle ( ) ; if ( c -> argc < 2 ) { dir = c -> argv [ 0 ] ; break ; } res = pr_expr_eval_group_and ( ( ( char * * ) c -> argv ) + 1 ) ; if ( res ) { dir = c -> argv [ 0 ] ; break ; } c = find_config_next ( c , c -> next , CONF_PARAM , "DefaultRoot" , FALSE ) ; } if ( dir ) { char * new_dir ; new_dir = path_subst_uservar ( p , & dir ) ; if ( new_dir != NULL ) { dir = new_dir ; } if ( strncmp ( dir , "/" , 2 ) == 0 ) { dir = NULL ; } else { char * realdir ; int xerrno = 0 ; if ( allow_symlinks == FALSE ) { char * path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ; <S2SV_StartBug> struct stat st ; <S2SV_EndBug> size_t pathlen ; path = dir ; if ( * path != '/' ) { if ( * path == '~' ) { if ( pr_fs_interpolate ( dir , target_path , sizeof ( target_path ) - 1 ) < 0 ) { return - 1 ; } path = target_path ; } } pathlen = strlen ( path ) ; if ( pathlen > 1 && path [ pathlen - 1 ] == '/' ) { path [ pathlen - 1 ] = '\\0' ; } <S2SV_StartBug> pr_fs_clear_cache ( ) ; <S2SV_EndBug> res = pr_fsio_lstat ( path , & st ) ; if ( res < 0 ) { <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , "error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s" , path , <S2SV_EndBug> strerror ( xerrno ) ) ; errno = xerrno ; return - 1 ; } if ( S_ISLNK ( st . st_mode ) ) { pr_log_pri ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>" "config)" , path ) ; errno = EPERM ; return - 1 ; } } PRIVS_USER realdir = dir_realpath ( p , dir ) ; xerrno = errno ; PRIVS_RELINQUISH if ( realdir ) { dir = realdir ; } else { char interp_dir [ PR_TUNABLE_PATH_MAX + 1 ] ; memset ( interp_dir , '\\0' , sizeof ( interp_dir ) ) ; ( void ) pr_fs_interpolate ( dir , interp_dir , sizeof ( interp_dir ) - 1 ) ; pr_log_pri ( PR_LOG_NOTICE , "notice:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>DefaultRoot<S2SV_blank>\'%s\'<S2SV_blank>[resolved<S2SV_blank>to<S2SV_blank>\'%s\']:<S2SV_blank>%s" , dir , interp_dir , strerror ( xerrno ) ) ; errno = xerrno ; } } } * root = dir ; return 0 ; }
CWE-119 static vpx_codec_err_t decoder_set_fb_fn ( vpx_codec_alg_priv_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { if ( cb_get == NULL || cb_release == NULL ) { return VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> } else if ( ctx -> pbi == NULL ) { <S2SV_EndBug> ctx -> get_ext_fb_cb = cb_get ; ctx -> release_ext_fb_cb = cb_release ; ctx -> ext_priv = cb_priv ; return VPX_CODEC_OK ; } return VPX_CODEC_ERROR ; }
CWE-000 static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }
CWE-119 WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( "\\nForbidden<S2SV_blank>bit<S2SV_blank>set<S2SV_blank>in<S2SV_blank>Nal<S2SV_blank>Unit,<S2SV_blank>Let\'s<S2SV_blank>try\\n" ) ; } <S2SV_StartBug> u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; <S2SV_EndBug> ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( "Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\n" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) { ps_dec -> u4_first_slice_in_pic = 1 ; } if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( "\\nSlice<S2SV_blank>NAL<S2SV_blank>Supplied<S2SV_blank>but<S2SV_blank>no<S2SV_blank>header<S2SV_blank>has<S2SV_blank>been<S2SV_blank>supplied\\n" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( "\\nUnknown<S2SV_blank>NAL<S2SV_blank>type<S2SV_blank>%d\\n" , u1_nal_unit_type ) ; break ; } } } return i_status ; }
CWE-119 <S2SV_StartBug> static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , <S2SV_EndBug> <S2SV_StartBug> MODEL_NODES * sizeof ( vp9_prob ) ) ; <S2SV_EndBug> }
CWE-119 void read_boot ( DOS_FS * fs ) { struct boot_sector b ; unsigned total_sectors ; unsigned short logical_sector_size , sectors ; <S2SV_StartBug> unsigned fat_length ; <S2SV_EndBug> unsigned total_fat_entries ; off_t data_size ; fs_read ( 0 , sizeof ( b ) , & b ) ; logical_sector_size = GET_UNALIGNED_W ( b . sector_size ) ; if ( ! logical_sector_size ) die ( "Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero." ) ; if ( logical_sector_size & ( SECTOR_SIZE - 1 ) ) die ( "Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>physical<S2SV_blank>" "sector<S2SV_blank>size." , logical_sector_size ) ; fs -> cluster_size = b . cluster_size * logical_sector_size ; if ( ! fs -> cluster_size ) die ( "Cluster<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero." ) ; if ( b . fats != 2 && b . fats != 1 ) die ( "Currently,<S2SV_blank>only<S2SV_blank>1<S2SV_blank>or<S2SV_blank>2<S2SV_blank>FATs<S2SV_blank>are<S2SV_blank>supported,<S2SV_blank>not<S2SV_blank>%d.\\n" , b . fats ) ; fs -> nfats = b . fats ; sectors = GET_UNALIGNED_W ( b . sectors ) ; total_sectors = sectors ? sectors : le32toh ( b . total_sect ) ; if ( verbose ) printf ( "Checking<S2SV_blank>we<S2SV_blank>can<S2SV_blank>access<S2SV_blank>the<S2SV_blank>last<S2SV_blank>sector<S2SV_blank>of<S2SV_blank>the<S2SV_blank>filesystem\\n" ) ; fs_test ( ( off_t ) ( ( total_sectors & ~ 1 ) - 1 ) * logical_sector_size , logical_sector_size ) ; fat_length = le16toh ( b . fat_length ) ? le16toh ( b . fat_length ) : le32toh ( b . fat32_length ) ; <S2SV_StartBug> fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ; <S2SV_EndBug> fs -> root_start = ( ( off_t ) le16toh ( b . reserved ) + b . fats * fat_length ) * logical_sector_size ; fs -> root_entries = GET_UNALIGNED_W ( b . dir_entries ) ; fs -> data_start = fs -> root_start + ROUND_TO_MULTIPLE ( fs -> root_entries << MSDOS_DIR_BITS , logical_sector_size ) ; <S2SV_StartBug> data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ; <S2SV_EndBug> fs -> data_clusters = data_size / fs -> cluster_size ; fs -> root_cluster = 0 ; fs -> fsinfo_start = 0 ; fs -> free_clusters = - 1 ; if ( ! b . fat_length && b . fat32_length ) { fs -> fat_bits = 32 ; fs -> root_cluster = le32toh ( b . root_cluster ) ; if ( ! fs -> root_cluster && fs -> root_entries ) printf ( "Warning:<S2SV_blank>FAT32<S2SV_blank>root<S2SV_blank>dir<S2SV_blank>not<S2SV_blank>in<S2SV_blank>cluster<S2SV_blank>chain!<S2SV_blank>" "Compatibility<S2SV_blank>mode...\\n" ) ; else if ( ! fs -> root_cluster && ! fs -> root_entries ) die ( "No<S2SV_blank>root<S2SV_blank>directory!" ) ; else if ( fs -> root_cluster && fs -> root_entries ) printf ( "Warning:<S2SV_blank>FAT32<S2SV_blank>root<S2SV_blank>dir<S2SV_blank>is<S2SV_blank>in<S2SV_blank>a<S2SV_blank>cluster<S2SV_blank>chain,<S2SV_blank>but<S2SV_blank>" "a<S2SV_blank>separate<S2SV_blank>root<S2SV_blank>dir\\n" "<S2SV_blank><S2SV_blank>area<S2SV_blank>is<S2SV_blank>defined.<S2SV_blank>Cannot<S2SV_blank>fix<S2SV_blank>this<S2SV_blank>easily.\\n" ) ; if ( fs -> data_clusters < FAT16_THRESHOLD ) printf ( "Warning:<S2SV_blank>Filesystem<S2SV_blank>is<S2SV_blank>FAT32<S2SV_blank>according<S2SV_blank>to<S2SV_blank>fat_length<S2SV_blank>" "and<S2SV_blank>fat32_length<S2SV_blank>fields,\\n" "<S2SV_blank><S2SV_blank>but<S2SV_blank>has<S2SV_blank>only<S2SV_blank>%lu<S2SV_blank>clusters,<S2SV_blank>less<S2SV_blank>than<S2SV_blank>the<S2SV_blank>required<S2SV_blank>" "minimum<S2SV_blank>of<S2SV_blank>%d.\\n" "<S2SV_blank><S2SV_blank>This<S2SV_blank>may<S2SV_blank>lead<S2SV_blank>to<S2SV_blank>problems<S2SV_blank>on<S2SV_blank>some<S2SV_blank>systems.\\n" , ( unsigned long ) fs -> data_clusters , FAT16_THRESHOLD ) ; check_fat_state_bit ( fs , & b ) ; fs -> backupboot_start = le16toh ( b . backup_boot ) * logical_sector_size ; check_backup_boot ( fs , & b , logical_sector_size ) ; read_fsinfo ( fs , & b , logical_sector_size ) ; } else if ( ! atari_format ) { fs -> fat_bits = ( fs -> data_clusters >= FAT12_THRESHOLD ) ? 16 : 12 ; if ( fs -> data_clusters >= FAT16_THRESHOLD ) die ( "Too<S2SV_blank>many<S2SV_blank>clusters<S2SV_blank>(%lu)<S2SV_blank>for<S2SV_blank>FAT16<S2SV_blank>filesystem." , fs -> data_clusters ) ; check_fat_state_bit ( fs , & b ) ; } else { fs -> fat_bits = 16 ; if ( fs -> data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 || ( total_sectors == 720 || total_sectors == 1440 || total_sectors == 2880 ) ) fs -> fat_bits = 12 ; } fs -> eff_fat_bits = ( fs -> fat_bits == 32 ) ? 28 : fs -> fat_bits ; fs -> fat_size = fat_length * logical_sector_size ; fs -> label = calloc ( 12 , sizeof ( uint8_t ) ) ; if ( fs -> fat_bits == 12 || fs -> fat_bits == 16 ) { struct boot_sector_16 * b16 = ( struct boot_sector_16 * ) & b ; if ( b16 -> extended_sig == 0x29 ) memmove ( fs -> label , b16 -> label , 11 ) ; else fs -> label = NULL ; } else if ( fs -> fat_bits == 32 ) { if ( b . extended_sig == 0x29 ) memmove ( fs -> label , & b . label , 11 ) ; else fs -> label = NULL ; } total_fat_entries = ( uint64_t ) fs -> fat_size * 8 / fs -> fat_bits ; if ( fs -> data_clusters > total_fat_entries - 2 ) die ( "Filesystem<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>clusters<S2SV_blank>but<S2SV_blank>only<S2SV_blank>space<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>FAT<S2SV_blank>entries." , fs -> data_clusters , total_fat_entries - 2 ) ; if ( ! fs -> root_entries && ! fs -> root_cluster ) die ( "Root<S2SV_blank>directory<S2SV_blank>has<S2SV_blank>zero<S2SV_blank>size." ) ; if ( fs -> root_entries & ( MSDOS_DPS - 1 ) ) die ( "Root<S2SV_blank>directory<S2SV_blank>(%d<S2SV_blank>entries)<S2SV_blank>doesn\'t<S2SV_blank>span<S2SV_blank>an<S2SV_blank>integral<S2SV_blank>number<S2SV_blank>of<S2SV_blank>" "sectors." , fs -> root_entries ) ; if ( logical_sector_size & ( SECTOR_SIZE - 1 ) ) die ( "Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>physical<S2SV_blank>" "sector<S2SV_blank>size." , logical_sector_size ) ; # if 0 if ( ! atari_format && ( ! b . secs_track || ! b . heads ) ) die ( "Invalid<S2SV_blank>disk<S2SV_blank>format<S2SV_blank>in<S2SV_blank>boot<S2SV_blank>sector." ) ; # endif if ( verbose ) dump_boot ( fs , & b , logical_sector_size ) ; }
CWE-476 static int mcryptd_create_hash ( struct crypto_template * tmpl , struct rtattr * * tb , struct mcryptd_queue * queue ) { struct hashd_instance_ctx * ctx ; struct ahash_instance * inst ; struct hash_alg_common * halg ; struct crypto_alg * alg ; u32 type = 0 ; u32 mask = 0 ; int err ; <S2SV_StartBug> mcryptd_check_internal ( tb , & type , & mask ) ; <S2SV_EndBug> halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ; if ( IS_ERR ( halg ) ) return PTR_ERR ( halg ) ; alg = & halg -> base ; pr_debug ( "crypto:<S2SV_blank>mcryptd<S2SV_blank>hash<S2SV_blank>alg:<S2SV_blank>%s\\n" , alg -> cra_name ) ; inst = mcryptd_alloc_instance ( alg , ahash_instance_headroom ( ) , sizeof ( * ctx ) ) ; err = PTR_ERR ( inst ) ; if ( IS_ERR ( inst ) ) goto out_put_alg ; ctx = ahash_instance_ctx ( inst ) ; ctx -> queue = queue ; err = crypto_init_ahash_spawn ( & ctx -> spawn , halg , ahash_crypto_instance ( inst ) ) ; if ( err ) goto out_free_inst ; type = CRYPTO_ALG_ASYNC ; if ( alg -> cra_flags & CRYPTO_ALG_INTERNAL ) type |= CRYPTO_ALG_INTERNAL ; inst -> alg . halg . base . cra_flags = type ; inst -> alg . halg . digestsize = halg -> digestsize ; inst -> alg . halg . statesize = halg -> statesize ; inst -> alg . halg . base . cra_ctxsize = sizeof ( struct mcryptd_hash_ctx ) ; inst -> alg . halg . base . cra_init = mcryptd_hash_init_tfm ; inst -> alg . halg . base . cra_exit = mcryptd_hash_exit_tfm ; inst -> alg . init = mcryptd_hash_init_enqueue ; inst -> alg . update = mcryptd_hash_update_enqueue ; inst -> alg . final = mcryptd_hash_final_enqueue ; inst -> alg . finup = mcryptd_hash_finup_enqueue ; inst -> alg . export = mcryptd_hash_export ; inst -> alg . import = mcryptd_hash_import ; inst -> alg . setkey = mcryptd_hash_setkey ; inst -> alg . digest = mcryptd_hash_digest_enqueue ; err = ahash_register_instance ( tmpl , inst ) ; if ( err ) { crypto_drop_ahash ( & ctx -> spawn ) ; out_free_inst : kfree ( inst ) ; } out_put_alg : crypto_mod_put ( alg ) ; return err ; }
CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><N-M|N/M>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
CWE-119 static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) GetMagickPixelPacket ( images , & pixels [ i ] [ j ] ) ; } return ( pixels ) ; }
CWE-125 <S2SV_StartBug> static void <S2SV_EndBug> ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; if ( length < 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , length ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } if ( ( length + 1 ) & 3 ) <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , length ) ) ; <S2SV_EndBug> ptr = cp [ 2 ] - 1 ; if ( ptr < 3 || ( ( ptr + 1 ) & 3 ) || ptr > length + 1 ) ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>ptr<S2SV_blank>%u]" , cp [ 2 ] ) ) ; for ( len = 3 ; len < length ; len += 4 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; <S2SV_EndBug> if ( ptr > len ) ND_PRINT ( ( ndo , "," ) ) ; <S2SV_StartBug> } <S2SV_EndBug> }
CWE-000 static void feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } else if ( indent == - 1 ) { mode -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; } <S2SV_StartBug> offset = tbl -> indent ; <S2SV_EndBug> if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; <S2SV_StartBug> } <S2SV_EndBug> if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }
CWE-189 static void recalculate_apic_map ( struct kvm * kvm ) { struct kvm_apic_map * new , * old = NULL ; struct kvm_vcpu * vcpu ; int i ; new = kzalloc ( sizeof ( struct kvm_apic_map ) , GFP_KERNEL ) ; mutex_lock ( & kvm -> arch . apic_map_lock ) ; if ( ! new ) goto out ; new -> ldr_bits = 8 ; new -> cid_shift = 8 ; new -> cid_mask = 0 ; new -> lid_mask = 0xff ; kvm_for_each_vcpu ( i , vcpu , kvm ) { struct kvm_lapic * apic = vcpu -> arch . apic ; u16 cid , lid ; u32 ldr ; if ( ! kvm_apic_present ( vcpu ) ) continue ; if ( apic_x2apic_mode ( apic ) ) { new -> ldr_bits = 32 ; new -> cid_shift = 16 ; <S2SV_StartBug> new -> cid_mask = new -> lid_mask = 0xffff ; <S2SV_EndBug> } else if ( kvm_apic_sw_enabled ( apic ) && ! new -> cid_mask && kvm_apic_get_reg ( apic , APIC_DFR ) == APIC_DFR_CLUSTER ) { new -> cid_shift = 4 ; new -> cid_mask = 0xf ; new -> lid_mask = 0xf ; } new -> phys_map [ kvm_apic_id ( apic ) ] = apic ; ldr = kvm_apic_get_reg ( apic , APIC_LDR ) ; cid = apic_cluster_id ( new , ldr ) ; lid = apic_logical_id ( new , ldr ) ; if ( lid ) new -> logical_map [ cid ] [ ffs ( lid ) - 1 ] = apic ; } out : old = rcu_dereference_protected ( kvm -> arch . apic_map , lockdep_is_held ( & kvm -> arch . apic_map_lock ) ) ; rcu_assign_pointer ( kvm -> arch . apic_map , new ) ; mutex_unlock ( & kvm -> arch . apic_map_lock ) ; if ( old ) kfree_rcu ( old , rcu ) ; kvm_vcpu_request_scan_ioapic ( kvm ) ; }
CWE-119 static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-20 static int ipx_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct ipx_sock * ipxs = ipx_sk ( sk ) ; struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; struct ipxhdr * ipx = NULL ; struct sk_buff * skb ; int copied , rc ; lock_sock ( sk ) ; if ( ! ipxs -> port ) { struct sockaddr_ipx uaddr ; uaddr . sipx_port = 0 ; uaddr . sipx_network = 0 ; # ifdef CONFIG_IPX_INTERN rc = - ENETDOWN ; if ( ! ipxs -> intrfc ) goto out ; memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ) ; # endif rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ) ; if ( rc ) goto out ; } rc = - ENOTCONN ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ) ; if ( ! skb ) goto out ; ipx = ipx_hdr ( skb ) ; copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ) ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ) ; if ( rc ) goto out_free ; if ( skb -> tstamp . tv64 ) sk -> sk_stamp = skb -> tstamp ; <S2SV_StartBug> msg -> msg_namelen = sizeof ( * sipx ) ; <S2SV_EndBug> if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; } rc = copied ; out_free : skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return rc ; }
CWE-284 static void inbound_data_waiting ( void * context ) { eager_reader_t * reader = ( eager_reader_t * ) context ; data_buffer_t * buffer = ( data_buffer_t * ) reader -> allocator -> alloc ( reader -> buffer_size + sizeof ( data_buffer_t ) ) ; if ( ! buffer ) { LOG_ERROR ( "%s<S2SV_blank>couldn\'t<S2SV_blank>aquire<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>inbound<S2SV_blank>data<S2SV_blank>buffer." , __func__ ) ; return ; } buffer -> length = 0 ; buffer -> offset = 0 ; <S2SV_StartBug> int bytes_read = read ( reader -> inbound_fd , buffer -> data , reader -> buffer_size ) ; <S2SV_EndBug> if ( bytes_read > 0 ) { buffer -> length = bytes_read ; fixed_queue_enqueue ( reader -> buffers , buffer ) ; eventfd_write ( reader -> bytes_available_fd , bytes_read ) ; } else { if ( bytes_read == 0 ) LOG_WARN ( "%s<S2SV_blank>fd<S2SV_blank>said<S2SV_blank>bytes<S2SV_blank>existed,<S2SV_blank>but<S2SV_blank>none<S2SV_blank>were<S2SV_blank>found." , __func__ ) ; else LOG_WARN ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>file<S2SV_blank>descriptor:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; reader -> allocator -> free ( buffer ) ; } }
CWE-119 <S2SV_StartBug> static TX_MODE read_tx_mode ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ; <S2SV_EndBug> if ( tx_mode == ALLOW_32X32 ) <S2SV_StartBug> tx_mode += vp9_read_bit ( r ) ; <S2SV_EndBug> return tx_mode ; }
CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
CWE-000 const u_char * smb_fdata ( netdissect_options * ndo , const u_char * buf , const char * fmt , const u_char * maxbuf , int unicodestr ) { static int depth = 0 ; char s [ 128 ] ; char * p ; while ( * fmt ) { switch ( * fmt ) { case '*' : fmt ++ ; while ( buf < maxbuf ) { const u_char * buf2 ; depth ++ ; <S2SV_StartBug> buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ; <S2SV_EndBug> depth -- ; if ( buf2 == NULL ) return ( NULL ) ; if ( buf2 == buf ) return ( buf ) ; buf = buf2 ; } return ( buf ) ; case '|' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; break ; case '%' : fmt ++ ; buf = maxbuf ; break ; case '#' : fmt ++ ; return ( buf ) ; break ; case '[' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; memset ( s , 0 , sizeof ( s ) ) ; p = strchr ( fmt , ']' ) ; if ( ( size_t ) ( p - fmt + 1 ) > sizeof ( s ) ) { return ( buf ) ; } strncpy ( s , fmt , p - fmt ) ; s [ p - fmt ] = '\\0' ; fmt = p + 1 ; buf = smb_fdata1 ( ndo , buf , s , maxbuf , unicodestr ) ; if ( buf == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , "%c" , * fmt ) ) ; fmt ++ ; break ; } } if ( ! depth && buf < maxbuf ) { size_t len = PTR_DIFF ( maxbuf , buf ) ; ND_PRINT ( ( ndo , "Data:<S2SV_blank>(%lu<S2SV_blank>bytes)\\n" , ( unsigned long ) len ) ) ; smb_print_data ( ndo , buf , len ) ; return ( buf + len ) ; } return ( buf ) ; }
CWE-189 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ; <S2SV_StartBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; <S2SV_EndBug> acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }
CWE-476 key_ref_t keyring_search ( key_ref_t keyring , struct key_type * type , const char * description ) { struct keyring_search_context ctx = { . index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , <S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , } ; key_ref_t key ; <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ; if ( type -> match_preparse ) { ret = type -> match_preparse ( & ctx . match_data ) ; if ( ret < 0 ) return ERR_PTR ( ret ) ; } key = keyring_search_aux ( keyring , & ctx ) ; if ( type -> match_free ) type -> match_free ( & ctx . match_data ) ; return key ; }
CWE-119 static void down2_symeven ( const uint8_t * const input , int length , uint8_t * output ) { <S2SV_StartBug> static const int16_t * filter = vp9_down2_symeven_half_filter ; <S2SV_EndBug> const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) / 2 ; int i , j ; uint8_t * optr = output ; int l1 = filter_len_half ; int l2 = ( length - filter_len_half ) ; l1 += ( l1 & 1 ) ; l2 += ( l2 & 1 ) ; if ( l1 > l2 ) { for ( i = 0 ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ ( i + 1 + j >= length ? length - 1 : i + 1 + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } else { for ( i = 0 ; i < l1 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ i + 1 + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < l2 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ i + 1 + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ ( i + 1 + j >= length ? length - 1 : i + 1 + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } }
CWE-119 static vpx_codec_err_t ctrl_use_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> const int reference_flag = va_arg ( args , int ) ; vp9_use_as_reference ( ctx -> cpi , reference_flag ) ; return VPX_CODEC_OK ; }
CWE-119 u32 h264bsdInitDpb ( dpbStorage_t * dpb , u32 picSizeInMbs , u32 dpbSize , u32 maxRefFrames , u32 maxFrameNum , u32 noReordering ) { u32 i ; ASSERT ( picSizeInMbs ) ; ASSERT ( maxRefFrames <= MAX_NUM_REF_PICS ) ; ASSERT ( maxRefFrames <= dpbSize ) ; ASSERT ( maxFrameNum ) ; <S2SV_StartBug> ASSERT ( dpbSize ) ; <S2SV_EndBug> dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ; dpb -> maxRefFrames = MAX ( maxRefFrames , 1 ) ; if ( noReordering ) dpb -> dpbSize = dpb -> maxRefFrames ; else dpb -> dpbSize = dpbSize ; dpb -> maxFrameNum = maxFrameNum ; dpb -> noReordering = noReordering ; dpb -> fullness = 0 ; dpb -> numRefFrames = 0 ; dpb -> prevRefFrameNum = 0 ; ALLOCATE ( dpb -> buffer , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t ) ; if ( dpb -> buffer == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> buffer , 0 , ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t ) ) ; for ( i = 0 ; i < dpb -> dpbSize + 1 ; i ++ ) { ALLOCATE ( dpb -> buffer [ i ] . pAllocatedData , ( picSizeInMbs * 384 + 32 + 15 ) , u8 ) ; if ( dpb -> buffer [ i ] . pAllocatedData == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; dpb -> buffer [ i ] . data = ALIGN ( dpb -> buffer [ i ] . pAllocatedData , 16 ) ; } ALLOCATE ( dpb -> list , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t * ) ; ALLOCATE ( dpb -> outBuf , dpb -> dpbSize + 1 , dpbOutPicture_t ) ; if ( dpb -> list == NULL || dpb -> outBuf == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> list , 0 , ( ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t * ) ) ) ; dpb -> numOut = dpb -> outIndex = 0 ; return ( HANTRO_OK ) ; }
CWE-476 int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , "PACK" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { <S2SV_StartBug> * head = NULL ; <S2SV_EndBug> * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ACK" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "NAK" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , "ERR<S2SV_blank>" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ok" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ng" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "unpack" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }
CWE-119 <S2SV_StartBug> void vp9_idct4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> if ( eob > 1 ) <S2SV_StartBug> vp9_idct4x4_16_add ( input , dest , stride ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_idct4x4_1_add ( input , dest , stride ) ; <S2SV_EndBug> }
CWE-119 int my_csr_reader ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , REALTYPE * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , "r" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , "cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n" ) ; return - 1 ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n" ) ; return - 1 ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( REALTYPE * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n" ) ; return - 1 ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n" ) ; return - 1 ; } } else { unsigned int l_row , l_column ; REALTYPE l_value ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n" ) ; return - 1 ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , "we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n" ) ; return - 1 ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } return 0 ; }
CWE-119 static int update_fragments ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , vpx_codec_err_t * res ) { * res = VPX_CODEC_OK ; if ( ctx -> fragments . count == 0 ) { <S2SV_StartBug> vpx_memset ( ( void * ) ctx -> fragments . ptrs , 0 , sizeof ( ctx -> fragments . ptrs ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ctx -> fragments . sizes , 0 , sizeof ( ctx -> fragments . sizes ) ) ; <S2SV_EndBug> } if ( ctx -> fragments . enabled && ! ( data == NULL && data_sz == 0 ) ) { ctx -> fragments . ptrs [ ctx -> fragments . count ] = data ; ctx -> fragments . sizes [ ctx -> fragments . count ] = data_sz ; ctx -> fragments . count ++ ; if ( ctx -> fragments . count > ( 1 << EIGHT_PARTITION ) + 1 ) { ctx -> fragments . count = 0 ; * res = VPX_CODEC_INVALID_PARAM ; return - 1 ; } return 0 ; } <S2SV_StartBug> if ( ! ctx -> fragments . enabled ) <S2SV_EndBug> { ctx -> fragments . ptrs [ 0 ] = data ; ctx -> fragments . sizes [ 0 ] = data_sz ; ctx -> fragments . count = 1 ; } return 1 ; }
CWE-362 static void rds_tcp_kill_sock ( struct net * net ) { struct rds_tcp_connection * tc , * _tc ; LIST_HEAD ( tmp_list ) ; struct rds_tcp_net * rtn = net_generic ( net , rds_tcp_netid ) ; struct socket * lsock = rtn -> rds_tcp_listen_sock ; rtn -> rds_tcp_listen_sock = NULL ; rds_tcp_listen_stop ( lsock , & rtn -> rds_tcp_accept_w ) ; spin_lock_irq ( & rds_tcp_conn_lock ) ; list_for_each_entry_safe ( tc , _tc , & rds_tcp_conn_list , t_tcp_node ) { struct net * c_net = read_pnet ( & tc -> t_cpath -> cp_conn -> c_net ) ; <S2SV_StartBug> if ( net != c_net || ! tc -> t_sock ) <S2SV_EndBug> continue ; if ( ! list_has_conn ( & tmp_list , tc -> t_cpath -> cp_conn ) ) { list_move_tail ( & tc -> t_tcp_node , & tmp_list ) ; } else { list_del ( & tc -> t_tcp_node ) ; tc -> t_tcp_node_detached = true ; } } spin_unlock_irq ( & rds_tcp_conn_lock ) ; list_for_each_entry_safe ( tc , _tc , & tmp_list , t_tcp_node ) rds_conn_destroy ( tc -> t_cpath -> cp_conn ) ; }
CWE-125 static int java_switch_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { ut8 op_byte = data [ 0 ] ; ut64 offset = addr - java_get_method_start ( ) ; ut8 pos = ( offset + 1 ) % 4 ? 1 + 4 - ( offset + 1 ) % 4 : 1 ; if ( op_byte == 0xaa ) { <S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> return op -> size ; } <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug> max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ; ut32 default_loc = ( ut32 ) ( UINT ( data , pos ) ) , cur_case = 0 ; op -> switch_op = r_anal_switch_op_new ( addr , min_val , default_loc ) ; RAnalCaseOp * caseop = NULL ; pos += 12 ; if ( max_val > min_val && ( ( max_val - min_val ) < ( UT16_MAX / 4 ) ) ) { for ( cur_case = 0 ; cur_case <= max_val - min_val ; pos += 4 , cur_case ++ ) { if ( pos + 4 >= len ) { break ; } int offset = ( int ) ( ut32 ) ( R_BIN_JAVA_UINT ( data , pos ) ) ; caseop = r_anal_switch_op_add_case ( op -> switch_op , addr + pos , cur_case + min_val , addr + offset ) ; if ( caseop ) { caseop -> bb_ref_to = addr + offset ; caseop -> bb_ref_from = addr ; } } } else { eprintf ( "Invalid<S2SV_blank>switch<S2SV_blank>boundaries<S2SV_blank>at<S2SV_blank>0x%" PFMT64x "\\n" , addr ) ; } } op -> size = pos ; return op -> size ; }
CWE-200 static int hci_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct hci_ufilter uf ; struct sock * sk = sock -> sk ; int len , opt , err = 0 ; BT_DBG ( "sk<S2SV_blank>%p,<S2SV_blank>opt<S2SV_blank>%d" , sk , optname ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; if ( hci_pi ( sk ) -> channel != HCI_CHANNEL_RAW ) { err = - EINVAL ; goto done ; } switch ( optname ) { case HCI_DATA_DIR : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_DIR ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_TIME_STAMP : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_TSTAMP ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_FILTER : { <S2SV_StartBug> struct hci_filter * f = & hci_pi ( sk ) -> filter ; <S2SV_EndBug> uf . type_mask = f -> type_mask ; uf . opcode = f -> opcode ; uf . event_mask [ 0 ] = * ( ( u32 * ) f -> event_mask + 0 ) ; uf . event_mask [ 1 ] = * ( ( u32 * ) f -> event_mask + 1 ) ; } len = min_t ( unsigned int , len , sizeof ( uf ) ) ; if ( copy_to_user ( optval , & uf , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } done : release_sock ( sk ) ; return err ; }
CWE-119 void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; <S2SV_StartBug> vpx_memcpy ( dest , source , dest_width ) ; <S2SV_EndBug> }
CWE-264 bool inode_owner_or_capable ( const struct inode * inode ) <S2SV_StartBug> { <S2SV_EndBug> if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ; <S2SV_StartBug> if ( inode_capable ( inode , CAP_FOWNER ) ) <S2SV_EndBug> return true ; return false ; }
CWE-189 MagickExport const char * GetMagickFeatures ( void ) { return "DPC" <S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> "<S2SV_blank>Modules" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) <S2SV_StartBug> "<S2SV_blank>HDRI" <S2SV_EndBug> # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) "<S2SV_blank>OpenCL" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) "<S2SV_blank>OpenMP" # endif <S2SV_StartBug> ; <S2SV_EndBug> }
CWE-200 int raptor_turtle_writer_get_option ( raptor_turtle_writer * turtle_writer , raptor_option option ) { int result = - 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : result = TURTLE_WRITER_AUTO_INDENT ( turtle_writer ) ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : result = turtle_writer -> indent ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : <S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : break ; } return result ; }
CWE-000 static Browser_Window * window_create ( const char * url ) { Browser_Window * app_data = malloc ( sizeof ( Browser_Window ) ) ; if ( ! app_data ) { info ( "ERROR:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>browser<S2SV_blank>window.\\n" ) ; return NULL ; } app_data -> window = elm_win_add ( NULL , "minibrowser-window" , ELM_WIN_BASIC ) ; elm_win_title_set ( app_data -> window , APP_NAME ) ; evas_object_smart_callback_add ( app_data -> window , "delete,request" , on_window_deletion , & app_data ) ; Evas_Object * bg = elm_bg_add ( app_data -> window ) ; elm_bg_color_set ( bg , 193 , 192 , 191 ) ; evas_object_size_hint_weight_set ( bg , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ; elm_win_resize_object_add ( app_data -> window , bg ) ; evas_object_show ( bg ) ; Evas_Object * vertical_layout = elm_box_add ( app_data -> window ) ; elm_box_padding_set ( vertical_layout , 0 , 2 ) ; evas_object_size_hint_weight_set ( vertical_layout , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ; elm_win_resize_object_add ( app_data -> window , vertical_layout ) ; evas_object_show ( vertical_layout ) ; Evas_Object * horizontal_layout = elm_box_add ( app_data -> window ) ; elm_box_horizontal_set ( horizontal_layout , EINA_TRUE ) ; evas_object_size_hint_weight_set ( horizontal_layout , EVAS_HINT_EXPAND , 0.0 ) ; evas_object_size_hint_align_set ( horizontal_layout , EVAS_HINT_FILL , 0.0 ) ; elm_box_pack_end ( vertical_layout , horizontal_layout ) ; evas_object_show ( horizontal_layout ) ; app_data -> back_button = create_toolbar_button ( app_data -> window , "arrow_left" ) ; evas_object_smart_callback_add ( app_data -> back_button , "clicked" , on_back_button_clicked , app_data ) ; elm_object_disabled_set ( app_data -> back_button , EINA_TRUE ) ; evas_object_size_hint_weight_set ( app_data -> back_button , 0.0 , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( app_data -> back_button , 0.0 , 0.5 ) ; elm_box_pack_end ( horizontal_layout , app_data -> back_button ) ; evas_object_show ( app_data -> back_button ) ; app_data -> forward_button = create_toolbar_button ( app_data -> window , "arrow_right" ) ; evas_object_smart_callback_add ( app_data -> forward_button , "clicked" , on_forward_button_clicked , app_data ) ; elm_object_disabled_set ( app_data -> forward_button , EINA_TRUE ) ; evas_object_size_hint_weight_set ( app_data -> forward_button , 0.0 , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( app_data -> forward_button , 0.0 , 0.5 ) ; elm_box_pack_end ( horizontal_layout , app_data -> forward_button ) ; evas_object_show ( app_data -> forward_button ) ; app_data -> url_bar = elm_entry_add ( app_data -> window ) ; elm_entry_scrollable_set ( app_data -> url_bar , EINA_TRUE ) ; elm_entry_scrollbar_policy_set ( app_data -> url_bar , ELM_SCROLLER_POLICY_OFF , ELM_SCROLLER_POLICY_OFF ) ; elm_entry_single_line_set ( app_data -> url_bar , EINA_TRUE ) ; elm_entry_cnp_mode_set ( app_data -> url_bar , ELM_CNP_MODE_PLAINTEXT ) ; elm_entry_text_style_user_push ( app_data -> url_bar , "DEFAULT=\'font_size=18\'" ) ; evas_object_smart_callback_add ( app_data -> url_bar , "activated" , on_url_bar_activated , app_data ) ; evas_object_smart_callback_add ( app_data -> url_bar , "clicked" , on_url_bar_clicked , app_data ) ; evas_object_size_hint_weight_set ( app_data -> url_bar , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( app_data -> url_bar , EVAS_HINT_FILL , EVAS_HINT_FILL ) ; elm_box_pack_end ( horizontal_layout , app_data -> url_bar ) ; evas_object_show ( app_data -> url_bar ) ; Evas_Object * refresh_button = create_toolbar_button ( app_data -> window , "refresh" ) ; evas_object_smart_callback_add ( refresh_button , "clicked" , on_refresh_button_clicked , app_data ) ; evas_object_size_hint_weight_set ( refresh_button , 0.0 , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( refresh_button , 1.0 , 0.5 ) ; elm_box_pack_end ( horizontal_layout , refresh_button ) ; evas_object_show ( refresh_button ) ; Evas_Object * home_button = create_toolbar_button ( app_data -> window , "home" ) ; evas_object_smart_callback_add ( home_button , "clicked" , on_home_button_clicked , app_data ) ; evas_object_size_hint_weight_set ( home_button , 0.0 , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( home_button , 1.0 , 0.5 ) ; elm_box_pack_end ( horizontal_layout , home_button ) ; evas_object_show ( home_button ) ; Ewk_View_Smart_Class * ewkViewClass = miniBrowserViewSmartClass ( ) ; ewkViewClass -> run_javascript_alert = on_javascript_alert ; ewkViewClass -> run_javascript_confirm = on_javascript_confirm ; ewkViewClass -> run_javascript_prompt = on_javascript_prompt ; Evas * evas = evas_object_evas_get ( app_data -> window ) ; Evas_Smart * smart = evas_smart_class_new ( & ewkViewClass -> sc ) ; app_data -> webview = ewk_view_smart_add ( evas , smart , ewk_context_default_get ( ) ) ; ewk_view_theme_set ( app_data -> webview , THEME_DIR "/default.edj" ) ; Ewk_Settings * settings = ewk_view_settings_get ( app_data -> webview ) ; ewk_settings_file_access_from_file_urls_allowed_set ( settings , EINA_TRUE ) ; ewk_settings_frame_flattening_enabled_set ( settings , frame_flattening_enabled ) ; ewk_settings_developer_extras_enabled_set ( settings , EINA_TRUE ) ; evas_object_smart_callback_add ( app_data -> webview , "authentication,request" , on_authentication_request , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "close,window" , on_close_window , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "create,window" , on_new_window , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "download,failed" , on_download_failed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "download,finished" , on_download_finished , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "download,request" , on_download_request , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "file,chooser,request" , on_file_chooser_request , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "icon,changed" , on_view_icon_changed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "load,error" , on_error , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "load,progress" , on_progress , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "title,changed" , on_title_changed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "url,changed" , on_url_changed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "back,forward,list,changed" , on_back_forward_list_changed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "tooltip,text,set" , on_tooltip_text_set , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , "tooltip,text,unset" , on_tooltip_text_unset , app_data ) ; evas_object_event_callback_add ( app_data -> webview , EVAS_CALLBACK_KEY_DOWN , on_key_down , app_data ) ; evas_object_event_callback_add ( app_data -> webview , EVAS_CALLBACK_MOUSE_DOWN , on_mouse_down , app_data ) ; evas_object_size_hint_weight_set ( app_data -> webview , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( app_data -> webview , EVAS_HINT_FILL , EVAS_HINT_FILL ) ; elm_box_pack_end ( vertical_layout , app_data -> webview ) ; evas_object_show ( app_data -> webview ) ; if ( url ) ewk_view_url_set ( app_data -> webview , url ) ; <S2SV_StartBug> evas_object_resize ( app_data -> window , DEFAULT_WIDTH , DEFAULT_HEIGHT ) ; <S2SV_EndBug> evas_object_show ( app_data -> window ) ; view_focus_set ( app_data , EINA_TRUE ) ; return app_data ; }
CWE-200 static int pptp_bind ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; int error = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> opt -> src_addr = sp -> sa_addr . pptp ; if ( add_chan ( po ) ) error = - EBUSY ; release_sock ( sk ) ; return error ; }
CWE-119 static int calc_partial_ssl_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) { int i , j ; int Total = 0 ; int srcoffset , dstoffset ; unsigned char * src = source -> y_buffer ; unsigned char * dst = dest -> y_buffer ; int linestocopy ; linestocopy = ( source -> y_height >> 4 ) / PARTIAL_FRAME_FRACTION ; linestocopy = linestocopy ? linestocopy << 4 : 16 ; srcoffset = source -> y_stride * ( ( dest -> y_height >> 5 ) * 16 ) ; dstoffset = dest -> y_stride * ( ( dest -> y_height >> 5 ) * 16 ) ; src += srcoffset ; dst += dstoffset ; for ( i = 0 ; i < linestocopy ; i += 16 ) { for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ; <S2SV_StartBug> Total += vp8_mse16x16 ( src + j , source -> y_stride , <S2SV_EndBug> dst + j , dest -> y_stride , & sse ) ; } src += 16 * source -> y_stride ; dst += 16 * dest -> y_stride ; } return Total ; }
CWE-125 <S2SV_StartBug> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Write ( s , fields -> Buffer , fields -> Len ) ; } }
CWE-476 int build_ntlmssp_auth_blob ( unsigned char * * pbuffer , u16 * buflen , struct cifs_ses * ses , const struct nls_table * nls_cp ) { int rc ; AUTHENTICATE_MESSAGE * sec_blob ; __u32 flags ; unsigned char * tmp ; rc = setup_ntlmv2_rsp ( ses , nls_cp ) ; if ( rc ) { cifs_dbg ( VFS , "Error<S2SV_blank>%d<S2SV_blank>during<S2SV_blank>NTLMSSP<S2SV_blank>authentication\\n" , rc ) ; * buflen = 0 ; goto setup_ntlmv2_ret ; } * pbuffer = kmalloc ( size_of_ntlmssp_blob ( ses ) , GFP_KERNEL ) ; sec_blob = ( AUTHENTICATE_MESSAGE * ) * pbuffer ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmAuthenticate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_StartBug> } <S2SV_EndBug> tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ; sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> LmChallengeResponse . BufferOffset = cpu_to_le32 ( sizeof ( AUTHENTICATE_MESSAGE ) ) ; sec_blob -> LmChallengeResponse . Length = 0 ; sec_blob -> LmChallengeResponse . MaximumLength = 0 ; sec_blob -> NtChallengeResponse . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; if ( ses -> user_name != NULL ) { memcpy ( tmp , ses -> auth_key . response + CIFS_SESS_KEY_SIZE , ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; tmp += ses -> auth_key . len - CIFS_SESS_KEY_SIZE ; sec_blob -> NtChallengeResponse . Length = cpu_to_le16 ( ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; sec_blob -> NtChallengeResponse . MaximumLength = cpu_to_le16 ( ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; } else { sec_blob -> NtChallengeResponse . Length = 0 ; sec_blob -> NtChallengeResponse . MaximumLength = 0 ; } if ( ses -> domainName == NULL ) { sec_blob -> DomainName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; tmp += 2 ; } else { int len ; len = cifs_strtoUTF16 ( ( __le16 * ) tmp , ses -> domainName , CIFS_MAX_DOMAINNAME_LEN , nls_cp ) ; len *= 2 ; sec_blob -> DomainName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> DomainName . Length = cpu_to_le16 ( len ) ; sec_blob -> DomainName . MaximumLength = cpu_to_le16 ( len ) ; tmp += len ; } if ( ses -> user_name == NULL ) { sec_blob -> UserName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> UserName . Length = 0 ; sec_blob -> UserName . MaximumLength = 0 ; tmp += 2 ; } else { int len ; len = cifs_strtoUTF16 ( ( __le16 * ) tmp , ses -> user_name , CIFS_MAX_USERNAME_LEN , nls_cp ) ; len *= 2 ; sec_blob -> UserName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> UserName . Length = cpu_to_le16 ( len ) ; sec_blob -> UserName . MaximumLength = cpu_to_le16 ( len ) ; tmp += len ; } sec_blob -> WorkstationName . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; tmp += 2 ; if ( ( ( ses -> ntlmssp -> server_flags & NTLMSSP_NEGOTIATE_KEY_XCH ) || ( ses -> ntlmssp -> server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC ) ) && ! calc_seckey ( ses ) ) { memcpy ( tmp , ses -> ntlmssp -> ciphertext , CIFS_CPHTXT_SIZE ) ; sec_blob -> SessionKey . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> SessionKey . Length = cpu_to_le16 ( CIFS_CPHTXT_SIZE ) ; sec_blob -> SessionKey . MaximumLength = cpu_to_le16 ( CIFS_CPHTXT_SIZE ) ; tmp += CIFS_CPHTXT_SIZE ; } else { sec_blob -> SessionKey . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; sec_blob -> SessionKey . Length = 0 ; sec_blob -> SessionKey . MaximumLength = 0 ; } * buflen = tmp - * pbuffer ; setup_ntlmv2_ret : return rc ; }
CWE-119 <S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { PixelChannels * * pixels ; register ssize_t i ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
CWE-000 int snd_ctl_replace ( struct snd_card * card , struct snd_kcontrol * kcontrol , bool add_on_replace ) { <S2SV_StartBug> struct snd_ctl_elem_id id ; <S2SV_EndBug> unsigned int idx ; struct snd_kcontrol * old ; int ret ; if ( ! kcontrol ) return - EINVAL ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) { ret = - EINVAL ; goto error ; } id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; old = snd_ctl_find_id ( card , & id ) ; if ( ! old ) { if ( add_on_replace ) goto add ; up_write ( & card -> controls_rwsem ) ; ret = - EINVAL ; goto error ; } ret = snd_ctl_remove ( card , old ) ; if ( ret < 0 ) { up_write ( & card -> controls_rwsem ) ; goto error ; } add : if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; ret = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return ret ; }
CWE-000 int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }
CWE-200 __be32 ipv6_select_ident ( struct net * net , const struct in6_addr * daddr , const struct in6_addr * saddr ) { <S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 id ; net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> return htonl ( id ) ; }
CWE-476 <S2SV_StartBug> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> { s -> avctx -> profile = get_bits ( gb , 4 ) ; <S2SV_StartBug> s -> avctx -> level = get_bits ( gb , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <S2SV_EndBug> <S2SV_StartBug> s -> avctx -> level = 0 ; <S2SV_EndBug> } return 0 ; }
CWE-119 static int kempf_decode_tile ( G2MContext * c , int tile_x , int tile_y , const uint8_t * src , int src_size ) { int width , height ; int hdr , zsize , npal , tidx = - 1 , ret ; int i , j ; const uint8_t * src_end = src + src_size ; uint8_t pal [ 768 ] , transp [ 3 ] ; uLongf dlen = ( c -> tile_width + 1 ) * c -> tile_height ; int sub_type ; int nblocks , cblocks , bstride ; int bits , bitbuf , coded ; uint8_t * dst = c -> framebuf + tile_x * c -> tile_width * 3 + tile_y * c -> tile_height * c -> framebuf_stride ; if ( src_size < 2 ) return AVERROR_INVALIDDATA ; width = FFMIN ( c -> width - tile_x * c -> tile_width , c -> tile_width ) ; height = FFMIN ( c -> height - tile_y * c -> tile_height , c -> tile_height ) ; hdr = * src ++ ; sub_type = hdr >> 5 ; if ( sub_type == 0 ) { int j ; memcpy ( transp , src , 3 ) ; src += 3 ; for ( j = 0 ; j < height ; j ++ , dst += c -> framebuf_stride ) for ( i = 0 ; i < width ; i ++ ) memcpy ( dst + i * 3 , transp , 3 ) ; return 0 ; } else if ( sub_type == 1 ) { return jpg_decode_data ( & c -> jc , width , height , src , src_end - src , dst , c -> framebuf_stride , NULL , 0 , 0 , 0 ) ; } if ( sub_type != 2 ) { memcpy ( transp , src , 3 ) ; src += 3 ; } npal = * src ++ + 1 ; memcpy ( pal , src , npal * 3 ) ; src += npal * 3 ; if ( sub_type != 2 ) { for ( i = 0 ; i < npal ; i ++ ) { if ( ! memcmp ( pal + i * 3 , transp , 3 ) ) { tidx = i ; break ; } } } if ( src_end - src < 2 ) return 0 ; zsize = ( src [ 0 ] << 8 ) | src [ 1 ] ; src += 2 ; <S2SV_StartBug> if ( src_end - src < zsize ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; ret = uncompress ( c -> kempf_buf , & dlen , src , zsize ) ; if ( ret ) return AVERROR_INVALIDDATA ; src += zsize ; if ( sub_type == 2 ) { kempf_restore_buf ( c -> kempf_buf , dlen , dst , c -> framebuf_stride , NULL , 0 , width , height , pal , npal , tidx ) ; return 0 ; } nblocks = * src ++ + 1 ; cblocks = 0 ; bstride = FFALIGN ( width , 16 ) >> 4 ; bits = 0 ; for ( i = 0 ; i < ( FFALIGN ( height , 16 ) >> 4 ) ; i ++ ) { for ( j = 0 ; j < ( FFALIGN ( width , 16 ) >> 4 ) ; j ++ ) { if ( ! bits ) { <S2SV_StartBug> bitbuf = * src ++ ; <S2SV_EndBug> bits = 8 ; } coded = bitbuf & 1 ; bits -- ; bitbuf >>= 1 ; cblocks += coded ; if ( cblocks > nblocks ) return AVERROR_INVALIDDATA ; c -> kempf_flags [ j + i * bstride ] = coded ; } } memset ( c -> jpeg_tile , 0 , c -> tile_stride * height ) ; jpg_decode_data ( & c -> jc , width , height , src , src_end - src , c -> jpeg_tile , c -> tile_stride , c -> kempf_flags , bstride , nblocks , 0 ) ; kempf_restore_buf ( c -> kempf_buf , dlen , dst , c -> framebuf_stride , c -> jpeg_tile , c -> tile_stride , width , height , pal , npal , tidx ) ; return 0 ; }
CWE-119 vpx_codec_err_t vpx_codec_enc_config_default ( vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , unsigned int usage ) { vpx_codec_err_t res ; <S2SV_StartBug> vpx_codec_enc_cfg_map_t * map ; <S2SV_EndBug> if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { res = VPX_CODEC_INVALID_PARAM ; <S2SV_StartBug> for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) { <S2SV_EndBug> if ( map -> usage == ( int ) usage ) { * cfg = map -> cfg ; cfg -> g_usage = usage ; res = VPX_CODEC_OK ; break ; } } } return res ; }
CWE-125 struct r_bin_dyldcache_obj_t * r_bin_dyldcache_from_bytes_new ( const ut8 * buf , ut64 size ) { <S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> return NULL ; } <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> if ( ! buf ) { return r_bin_dyldcache_free ( bin ) ; } bin -> b = r_buf_new ( ) ; <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> return r_bin_dyldcache_free ( bin ) ; } if ( ! r_bin_dyldcache_init ( bin ) ) { return r_bin_dyldcache_free ( bin ) ; } bin -> size = size ; return bin ; }
CWE-119 static vpx_codec_err_t ctrl_get_display_size ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> int * const display_size = va_arg ( args , int * ) ; <S2SV_StartBug> if ( display_size ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) { <S2SV_EndBug> <S2SV_StartBug> const VP9_COMMON * const cm = & ctx -> pbi -> common ; <S2SV_EndBug> display_size [ 0 ] = cm -> display_width ; display_size [ 1 ] = cm -> display_height ; <S2SV_StartBug> } else { <S2SV_EndBug> return VPX_CODEC_ERROR ; } <S2SV_StartBug> return VPX_CODEC_OK ; <S2SV_EndBug> } else { return VPX_CODEC_INVALID_PARAM ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-476 static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st [ 2 ] = { NULL , NULL } ; NSVStream * nst ; AVPacket * pkt ; int i , err = 0 ; uint8_t auxcount ; uint32_t vsize ; uint16_t asize ; <S2SV_StartBug> uint16_t auxsize ; <S2SV_EndBug> if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ; null_chunk_retry : if ( pb -> eof_reached ) return - 1 ; for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) err = nsv_resync ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ; auxcount = avio_r8 ( pb ) ; vsize = avio_rl16 ( pb ) ; asize = avio_rl16 ( pb ) ; vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; auxcount &= 0x0f ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>CHUNK<S2SV_blank>%" PRIu8 "<S2SV_blank>aux,<S2SV_blank>%" PRIu32 "<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%" PRIu16 "<S2SV_blank>bytes<S2SV_blank>audio\\n" , auxcount , vsize , asize ) ; for ( i = 0 ; i < auxcount ; i ++ ) { uint32_t av_unused auxtag ; auxsize = avio_rl16 ( pb ) ; auxtag = avio_rl32 ( pb ) ; avio_skip ( pb , auxsize ) ; vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; } if ( pb -> eof_reached ) return - 1 ; if ( ! vsize && ! asize ) { nsv -> state = NSV_UNSYNC ; goto null_chunk_retry ; } if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; if ( vsize && st [ NSV_ST_VIDEO ] ) { nst = st [ NSV_ST_VIDEO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ; <S2SV_StartBug> av_get_packet ( pb , pkt , vsize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; pkt -> dts = nst -> frame_offset ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02" PRIx8 "\\n" , i , pkt -> data [ i ] ) ; } if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; if ( asize && st [ NSV_ST_AUDIO ] ) { nst = st [ NSV_ST_AUDIO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { uint8_t bps ; uint8_t channels ; uint16_t samplerate ; bps = avio_r8 ( pb ) ; channels = avio_r8 ( pb ) ; samplerate = avio_rl16 ( pb ) ; if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ; asize -= 4 ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%" PRIu8 ",<S2SV_blank>nchan<S2SV_blank>%" PRIu8 ",<S2SV_blank>srate<S2SV_blank>%" PRIu16 "\\n" , bps , channels , samplerate ) ; if ( fill_header ) { st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; if ( bps != 16 ) { av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%" PRIu8 ")!!!\\n" , bps ) ; } bps /= channels ; if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; samplerate /= 4 ; channels = 1 ; st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%" PRIu8 ",<S2SV_blank>nchan<S2SV_blank>%" PRIu8 ",<S2SV_blank>srate<S2SV_blank>%" PRIu16 "\\n" , bps , channels , samplerate ) ; } } <S2SV_StartBug> av_get_packet ( pb , pkt , asize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%" PRId16 ",<S2SV_blank>dts:%" PRId64 , nsv -> avsync , pkt -> dts ) ; } nst -> frame_offset ++ ; } nsv -> state = NSV_UNSYNC ; return 0 ; }
CWE-284 static int accept_server_socket ( int sfd ) { struct sockaddr_un remote ; struct pollfd pfd ; int fd ; socklen_t len = sizeof ( struct sockaddr_un ) ; BTIF_TRACE_EVENT ( "accept<S2SV_blank>fd<S2SV_blank>%d" , sfd ) ; pfd . fd = sfd ; pfd . events = POLLIN ; <S2SV_StartBug> if ( poll ( & pfd , 1 , 0 ) == 0 ) <S2SV_EndBug> { BTIF_TRACE_EVENT ( "accept<S2SV_blank>poll<S2SV_blank>timeout" ) ; return - 1 ; } <S2SV_StartBug> if ( ( fd = accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) == - 1 ) <S2SV_EndBug> { BTIF_TRACE_ERROR ( "sock<S2SV_blank>accept<S2SV_blank>failed<S2SV_blank>(%s)" , strerror ( errno ) ) ; return - 1 ; } return fd ; }
CWE-125 static MagickBooleanType ReadPSDChannelPixels ( Image * image , const size_t channels , const size_t row , const ssize_t type , const unsigned char * pixels , ExceptionInfo * exception ) { Quantum pixel ; register const unsigned char * p ; register Quantum * q ; register ssize_t x ; size_t packet_size ; unsigned short nibble ; p = pixels ; q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return MagickFalse ; packet_size = GetPSDPacketSize ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( packet_size == 1 ) pixel = ScaleCharToQuantum ( * p ++ ) ; else { p = PushShortPixel ( MSBEndian , p , & nibble ) ; pixel = ScaleShortToQuantum ( nibble ) ; } <S2SV_StartBug> switch ( type ) <S2SV_EndBug> { case - 1 : { SetPixelAlpha ( image , pixel , q ) ; break ; } case - 2 : case 0 : { SetPixelRed ( image , pixel , q ) ; if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ; if ( image -> storage_class == PseudoClass ) { if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ; else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; if ( image -> depth == 1 ) { ssize_t bit , number_bits ; number_bits = image -> columns - x ; if ( number_bits > 8 ) number_bits = 8 ; for ( bit = 0 ; bit < number_bits ; bit ++ ) { <S2SV_StartBug> SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & <S2SV_EndBug> <S2SV_StartBug> ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; <S2SV_EndBug> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; q += GetPixelChannels ( image ) ; x ++ ; } <S2SV_StartBug> x -- ; <S2SV_EndBug> continue ; } } <S2SV_StartBug> break ; <S2SV_EndBug> } case 1 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelGreen ( image , pixel , q ) ; break ; } case 2 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelBlue ( image , pixel , q ) ; break ; } case 3 : { if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ; else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } case 4 : { if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } return ( SyncAuthenticPixels ( image , exception ) ) ; }
CWE-264 static ssize_t get_node_path_locked ( struct node * node , char * buf , size_t bufsize ) { const char * name ; size_t namelen ; if ( node -> graft_path ) { name = node -> graft_path ; namelen = node -> graft_pathlen ; } else if ( node -> actual_name ) { name = node -> actual_name ; namelen = node -> namelen ; } else { name = node -> name ; namelen = node -> namelen ; } if ( bufsize < namelen + 1 ) { return - 1 ; } ssize_t pathlen = 0 ; if ( node -> parent && node -> graft_path == NULL ) { <S2SV_StartBug> pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 2 ) ; <S2SV_EndBug> if ( pathlen < 0 ) { return - 1 ; } buf [ pathlen ++ ] = '/' ; } memcpy ( buf + pathlen , name , namelen + 1 ) ; return pathlen + namelen ; }
CWE-119 void show_object_with_name ( FILE * out , struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component ) <S2SV_EndBug> { char * name = path_name ( path , component ) ; char * p ; fprintf ( out , "%s<S2SV_blank>" , oid_to_hex ( & obj -> oid ) ) ; for ( p = name ; * p && * p != '\\n' ; p ++ ) fputc ( * p , out ) ; fputc ( '\\n' , out ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> }
CWE-264 static void on_response ( void * data , krb5_error_code retval , otp_response response ) { struct request_state rs = * ( struct request_state * ) data ; free ( data ) ; if ( retval == 0 && response != otp_response_success ) retval = KRB5_PREAUTH_FAILED ; <S2SV_StartBug> rs . respond ( rs . arg , retval , NULL , NULL , NULL ) ; <S2SV_EndBug> }
CWE-190 <S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , "Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
CWE-200 unsigned paravirt_patch_jmp ( void * insnbuf , const void * target , unsigned long addr , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ; <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> <S2SV_StartBug> return len ; <S2SV_EndBug> b -> opcode = 0xe9 ; b -> delta = delta ; return 5 ; }
CWE-119 static __u8 * sp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 107 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && <S2SV_EndBug> rdesc [ 106 ] == 0x03 ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Sunplus<S2SV_blank>Wireless<S2SV_blank>Desktop<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc [ 105 ] = rdesc [ 110 ] = 0x03 ; rdesc [ 106 ] = rdesc [ 111 ] = 0x21 ; } return rdesc ; }
CWE-284 static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( "check_rpcsec_auth:<S2SV_blank>failed<S2SV_blank>" "inquire_context,<S2SV_blank>stat=%u" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ; <S2SV_StartBug> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <S2SV_EndBug> && strncmp ( "kadmin" , c1 -> data , c1 -> length ) == 0 ) { if ( strncmp ( "history" , c2 -> data , c2 -> length ) == 0 ) goto fail_princ ; else success = 1 ; } fail_princ : if ( ! success ) { krb5_klog_syslog ( LOG_ERR , _ ( "bad<S2SV_blank>service<S2SV_blank>principal<S2SV_blank>%.*s%s" ) , ( int ) slen , ( char * ) gss_str . value , sdots ) ; } gss_release_buffer ( & min_stat , & gss_str ) ; krb5_free_principal ( kctx , princ ) ; fail_name : gss_release_name ( & min_stat , & name ) ; return success ; }
CWE-119 static int handle_packet ( unsigned char * data , int data_len ) { struct mt_mactelnet_hdr pkthdr ; if ( data_len < MT_HEADER_LEN ) { return - 1 ; } parse_packet ( data , & pkthdr ) ; if ( pkthdr . seskey != sessionkey ) { return - 1 ; } if ( pkthdr . ptype == MT_PTYPE_DATA ) { struct mt_packet odata ; struct mt_mactelnet_control_hdr cpkt ; int success = 0 ; init_packet ( & odata , MT_PTYPE_ACK , srcmac , dstmac , sessionkey , pkthdr . counter + ( data_len - MT_HEADER_LEN ) ) ; send_udp ( & odata , 0 ) ; if ( pkthdr . counter > incounter || ( incounter - pkthdr . counter ) > 65535 ) { incounter = pkthdr . counter ; } else { return - 1 ; } success = parse_control_packet ( data + MT_HEADER_LEN , data_len - MT_HEADER_LEN , & cpkt ) ; while ( success ) { if ( cpkt . cptype == MT_CPTYPE_PASSSALT ) { <S2SV_StartBug> memcpy ( pass_salt , cpkt . data , cpkt . length ) ; <S2SV_EndBug> send_auth ( username , password ) ; } else if ( cpkt . cptype == MT_CPTYPE_PLAINDATA ) { fwrite ( ( const void * ) cpkt . data , 1 , cpkt . length , stdout ) ; } else if ( cpkt . cptype == MT_CPTYPE_END_AUTH ) { terminal_mode = 1 ; if ( is_a_tty ) { raw_term ( ) ; setvbuf ( stdin , ( char * ) NULL , _IONBF , 0 ) ; signal ( SIGWINCH , sig_winch ) ; } } success = parse_control_packet ( NULL , 0 , & cpkt ) ; } } else if ( pkthdr . ptype == MT_PTYPE_ACK ) { } else if ( pkthdr . ptype == MT_PTYPE_END ) { struct mt_packet odata ; init_packet ( & odata , MT_PTYPE_END , srcmac , dstmac , pkthdr . seskey , 0 ) ; send_udp ( & odata , 0 ) ; if ( ! quiet_mode ) { fprintf ( stderr , _ ( "Connection<S2SV_blank>closed.\\n" ) ) ; } running = 0 ; } else { fprintf ( stderr , _ ( "Unhandeled<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\n" ) , pkthdr . ptype , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; return - 1 ; } return pkthdr . ptype ; }
CWE-20 static void settings_init ( void ) { settings . use_cas = true ; settings . access = 0700 ; settings . port = 11211 ; <S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> settings . inter = NULL ; settings . maxbytes = 64 * 1024 * 1024 ; settings . maxconns = 1024 ; settings . verbose = 0 ; settings . oldest_live = 0 ; settings . oldest_cas = 0 ; settings . evict_to_free = 1 ; settings . socketpath = NULL ; settings . factor = 1.25 ; settings . chunk_size = 48 ; settings . num_threads = 4 ; settings . num_threads_per_udp = 0 ; settings . prefix_delimiter = ':' ; settings . detail_enabled = 0 ; settings . reqs_per_event = 20 ; settings . backlog = 1024 ; settings . binding_protocol = negotiating_prot ; settings . item_size_max = 1024 * 1024 ; settings . slab_page_size = 1024 * 1024 ; settings . slab_chunk_size_max = settings . slab_page_size / 2 ; settings . sasl = false ; settings . maxconns_fast = true ; settings . lru_crawler = false ; settings . lru_crawler_sleep = 100 ; settings . lru_crawler_tocrawl = 0 ; settings . lru_maintainer_thread = false ; settings . lru_segmented = true ; settings . hot_lru_pct = 20 ; settings . warm_lru_pct = 40 ; settings . hot_max_factor = 0.2 ; settings . warm_max_factor = 2.0 ; settings . inline_ascii_response = false ; settings . temp_lru = false ; settings . temporary_ttl = 61 ; settings . idle_timeout = 0 ; settings . hashpower_init = 0 ; settings . slab_reassign = true ; settings . slab_automove = 1 ; settings . slab_automove_ratio = 0.8 ; settings . slab_automove_window = 30 ; settings . shutdown_command = false ; settings . tail_repair_time = TAIL_REPAIR_TIME_DEFAULT ; settings . flush_enabled = true ; settings . dump_enabled = true ; settings . crawls_persleep = 1000 ; settings . logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE ; settings . logger_buf_size = LOGGER_BUF_SIZE ; settings . drop_privileges = true ; # ifdef MEMCACHED_DEBUG settings . relaxed_privileges = false ; # endif }
CWE-416 static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; if ( ret < 0 ) { <S2SV_StartBug> ops -> destroy ( dev ) ; <S2SV_EndBug> mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; return ret ; } kvm_get_kvm ( kvm ) ; cd -> fd = ret ; return 0 ; }
CWE-20 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } } } else { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) { <S2SV_StartBug> AcquireNextImage ( image_info , image ) ; <S2SV_EndBug> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 static RList * relocs ( RBinFile * arch ) { struct r_bin_bflt_obj * obj = ( struct r_bin_bflt_obj * ) arch -> o -> bin_obj ; RList * list = r_list_newf ( ( RListFree ) free ) ; int i , len , n_got , amount ; if ( ! list || ! obj ) { r_list_free ( list ) ; return NULL ; } if ( obj -> hdr -> flags & FLAT_FLAG_GOTPIC ) { n_got = get_ngot_entries ( obj ) ; if ( n_got ) { amount = n_got * sizeof ( ut32 ) ; if ( amount < n_got || amount > UT32_MAX ) { goto out_error ; } <S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> if ( got_table ) { ut32 offset = 0 ; for ( i = 0 ; i < n_got ; offset += 4 , i ++ ) { ut32 got_entry ; if ( obj -> hdr -> data_start + offset + 4 > obj -> size || obj -> hdr -> data_start + offset + 4 < offset ) { break ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> data_start + offset , ( ut8 * ) & got_entry , sizeof ( ut32 ) ) ; if ( ! VALID_GOT_ENTRY ( got_entry ) || len != sizeof ( ut32 ) ) { break ; } got_table [ i ] . addr_to_patch = got_entry ; got_table [ i ] . data_offset = got_entry + BFLT_HDR_SIZE ; } obj -> n_got = n_got ; obj -> got_table = got_table ; } } } if ( obj -> hdr -> reloc_count > 0 ) { int n_reloc = obj -> hdr -> reloc_count ; amount = n_reloc * sizeof ( struct reloc_struct_t ) ; if ( amount < n_reloc || amount > UT32_MAX ) { goto out_error ; } struct reloc_struct_t * reloc_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_table ) { goto out_error ; } amount = n_reloc * sizeof ( ut32 ) ; if ( amount < n_reloc || amount > UT32_MAX ) { free ( reloc_table ) ; goto out_error ; } ut32 * reloc_pointer_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_pointer_table ) { free ( reloc_table ) ; goto out_error ; } if ( obj -> hdr -> reloc_start + amount > obj -> size || obj -> hdr -> reloc_start + amount < amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> reloc_start , ( ut8 * ) reloc_pointer_table , amount ) ; if ( len != amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } for ( i = 0 ; i < obj -> hdr -> reloc_count ; i ++ ) { ut32 reloc_offset = r_swap_ut32 ( reloc_pointer_table [ i ] ) + BFLT_HDR_SIZE ; if ( reloc_offset < obj -> hdr -> bss_end && reloc_offset < obj -> size ) { ut32 reloc_fixed , reloc_data_offset ; if ( reloc_offset + sizeof ( ut32 ) > obj -> size || reloc_offset + sizeof ( ut32 ) < reloc_offset ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , reloc_offset , ( ut8 * ) & reloc_fixed , sizeof ( ut32 ) ) ; if ( len != sizeof ( ut32 ) ) { eprintf ( "problem<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>relocation<S2SV_blank>entries\\n" ) ; free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } reloc_data_offset = r_swap_ut32 ( reloc_fixed ) + BFLT_HDR_SIZE ; reloc_table [ i ] . addr_to_patch = reloc_offset ; reloc_table [ i ] . data_offset = reloc_data_offset ; RBinReloc * reloc = R_NEW0 ( RBinReloc ) ; if ( reloc ) { reloc -> type = R_BIN_RELOC_32 ; reloc -> paddr = reloc_table [ i ] . addr_to_patch ; reloc -> vaddr = reloc -> paddr ; r_list_append ( list , reloc ) ; } } } free ( reloc_pointer_table ) ; obj -> reloc_table = reloc_table ; } return list ; out_error : r_list_free ( list ) ; return NULL ; }
CWE-399 <S2SV_StartBug> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <S2SV_EndBug> { struct fsnotify_group * group ; group = fsnotify_alloc_group ( & inotify_fsnotify_ops ) ; if ( IS_ERR ( group ) ) return group ; group -> max_events = max_events ; spin_lock_init ( & group -> inotify_data . idr_lock ) ; idr_init ( & group -> inotify_data . idr ) ; group -> inotify_data . last_wd = 0 ; <S2SV_StartBug> group -> inotify_data . user = user ; <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . fa = NULL ; <S2SV_EndBug> return group ; }
CWE-125 const char * le64addr_string ( netdissect_options * ndo , const u_char * ep ) { const unsigned int len = 8 ; register u_int i ; register char * cp ; <S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> char buf [ BUFSIZE ] ; tp = lookup_bytestring ( ndo , ep , len ) ; <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> cp = buf ; for ( i = len ; i > 0 ; -- i ) { * cp ++ = hex [ * ( ep + i - 1 ) >> 4 ] ; * cp ++ = hex [ * ( ep + i - 1 ) & 0xf ] ; * cp ++ = ':' ; } cp -- ; * cp = '\\0' ; <S2SV_StartBug> tp -> e_name = strdup ( buf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , "le64addr_string:<S2SV_blank>strdup(buf)" ) ; <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> }
CWE-000 STATIC int xfs_attr3_leaf_add_work ( struct xfs_buf * bp , struct xfs_attr3_icleaf_hdr * ichdr , struct xfs_da_args * args , int mapindex ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_mount * mp ; int tmp ; int i ; trace_xfs_attr_leaf_add_work ( args ) ; leaf = bp -> b_addr ; ASSERT ( mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE ) ; ASSERT ( args -> index >= 0 && args -> index <= ichdr -> count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( args -> index < ichdr -> count ) { tmp = ichdr -> count - args -> index ; tmp *= sizeof ( xfs_attr_leaf_entry_t ) ; memmove ( entry + 1 , entry , tmp ) ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , tmp + sizeof ( * entry ) ) ) ; } ichdr -> count ++ ; mp = args -> trans -> t_mountp ; ASSERT ( ichdr -> freemap [ mapindex ] . base < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . base & 0x3 ) == 0 ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size >= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , NULL ) ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . size & 0x3 ) == 0 ) ; ichdr -> freemap [ mapindex ] . size -= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , & tmp ) ; entry -> nameidx = cpu_to_be16 ( ichdr -> freemap [ mapindex ] . base + ichdr -> freemap [ mapindex ] . size ) ; entry -> hashval = cpu_to_be32 ( args -> hashval ) ; entry -> flags = tmp ? XFS_ATTR_LOCAL : 0 ; entry -> flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK ( args -> flags ) ; if ( args -> op_flags & XFS_DA_OP_RENAME ) { entry -> flags |= XFS_ATTR_INCOMPLETE ; if ( ( args -> blkno2 == args -> blkno ) && ( args -> index2 <= args -> index ) ) { args -> index2 ++ ; } } xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; ASSERT ( ( args -> index == 0 ) || ( be32_to_cpu ( entry -> hashval ) >= be32_to_cpu ( ( entry - 1 ) -> hashval ) ) ) ; ASSERT ( ( args -> index == ichdr -> count - 1 ) || ( be32_to_cpu ( entry -> hashval ) <= be32_to_cpu ( ( entry + 1 ) -> hashval ) ) ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; name_loc -> namelen = args -> namelen ; name_loc -> valuelen = cpu_to_be16 ( args -> valuelen ) ; memcpy ( ( char * ) name_loc -> nameval , args -> name , args -> namelen ) ; memcpy ( ( char * ) & name_loc -> nameval [ args -> namelen ] , args -> value , be16_to_cpu ( name_loc -> valuelen ) ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> namelen = args -> namelen ; memcpy ( ( char * ) name_rmt -> name , args -> name , args -> namelen ) ; entry -> flags |= XFS_ATTR_INCOMPLETE ; name_rmt -> valuelen = 0 ; name_rmt -> valueblk = 0 ; args -> rmtblkno = 1 ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <S2SV_StartBug> } <S2SV_EndBug> xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , xfs_attr3_leaf_name ( leaf , args -> index ) , xfs_attr_leaf_entsize ( leaf , args -> index ) ) ) ; if ( be16_to_cpu ( entry -> nameidx ) < ichdr -> firstused ) ichdr -> firstused = be16_to_cpu ( entry -> nameidx ) ; ASSERT ( ichdr -> firstused >= ichdr -> count * sizeof ( xfs_attr_leaf_entry_t ) + xfs_attr3_leaf_hdr_size ( leaf ) ) ; tmp = ( ichdr -> count - 1 ) * sizeof ( xfs_attr_leaf_entry_t ) + xfs_attr3_leaf_hdr_size ( leaf ) ; for ( i = 0 ; i < XFS_ATTR_LEAF_MAPSIZE ; i ++ ) { if ( ichdr -> freemap [ i ] . base == tmp ) { ichdr -> freemap [ i ] . base += sizeof ( xfs_attr_leaf_entry_t ) ; ichdr -> freemap [ i ] . size -= sizeof ( xfs_attr_leaf_entry_t ) ; } } ichdr -> usedbytes += xfs_attr_leaf_entsize ( leaf , args -> index ) ; return 0 ; }
CWE-362 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ; <S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break ; } } err = - EINVAL ; if ( match && match -> flags != flags ) goto out ; if ( ! match ) { err = - ENOMEM ; match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) goto out ; write_pnet ( & match -> net , sock_net ( sk ) ) ; match -> id = id ; match -> type = type ; match -> flags = flags ; INIT_LIST_HEAD ( & match -> list ) ; spin_lock_init ( & match -> lock ) ; refcount_set ( & match -> sk_ref , 0 ) ; fanout_init_data ( match ) ; match -> prot_hook . type = po -> prot_hook . type ; match -> prot_hook . dev = po -> prot_hook . dev ; match -> prot_hook . func = packet_rcv_fanout ; match -> prot_hook . af_packet_priv = match ; match -> prot_hook . id_match = match_fanout_group ; list_add ( & match -> list , & fanout_list ) ; } err = - EINVAL ; <S2SV_StartBug> if ( match -> type == type && <S2SV_EndBug> match -> prot_hook . type == po -> prot_hook . type && match -> prot_hook . dev == po -> prot_hook . dev ) { err = - ENOSPC ; if ( refcount_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { __dev_remove_pack ( & po -> prot_hook ) ; po -> fanout = match ; refcount_set ( & match -> sk_ref , refcount_read ( & match -> sk_ref ) + 1 ) ; __fanout_link ( sk , po ) ; err = 0 ; } } <S2SV_StartBug> out : <S2SV_EndBug> if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } mutex_unlock ( & fanout_mutex ) ; return err ; }
CWE-000 kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ; <S2SV_StartBug> int ret , last_pwd ; <S2SV_EndBug> krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; if ( keyblocks ) * keyblocks = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( principal == NULL ) return EINVAL ; if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ; ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto done ; if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) { if ( keepold ) return KADM5_PROTECT_PRINCIPAL ; new_n_ks_tuple = 1 ; } ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto done ; ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ; if ( ret ) goto done ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto done ; kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ; ret = krb5_timeofday ( handle -> context , & now ) ; if ( ret ) goto done ; if ( ( adb . aux_attributes & KADM5_POLICY ) ) { ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ; if ( ret ) goto done ; } if ( have_pol ) { ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ; if ( ret ) goto done ; # if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) { ret = KADM5_PASS_TOOSOON ; goto done ; } # endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ; else kdb -> pw_expiration = 0 ; } else { kdb -> pw_expiration = 0 ; } ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ; if ( ret ) goto done ; kdb -> fail_auth_count = 0 ; if ( keyblocks ) { <S2SV_StartBug> ret = decrypt_key_data ( handle -> context , <S2SV_EndBug> <S2SV_StartBug> kdb -> n_key_data , kdb -> key_data , <S2SV_EndBug> keyblocks , n_keys ) ; if ( ret ) goto done ; } kdb -> mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT ; ; ret = k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; if ( ret ) goto done ; if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ; ( void ) k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; ret = KADM5_OK ; done : free ( new_ks_tuple ) ; kdb_free_entry ( handle , kdb , & adb ) ; if ( have_pol ) kadm5_free_policy_ent ( handle -> lhandle , & pol ) ; return ret ; }
CWE-189 static inline void x86_assign_hw_event ( struct perf_event * event , struct cpu_hw_events * cpuc , int i ) { struct hw_perf_event * hwc = & event -> hw ; hwc -> idx = cpuc -> assign [ i ] ; hwc -> last_cpu = smp_processor_id ( ) ; hwc -> last_tag = ++ cpuc -> tags [ i ] ; if ( hwc -> idx == X86_PMC_IDX_FIXED_BTS ) { hwc -> config_base = 0 ; hwc -> event_base = 0 ; } else if ( hwc -> idx >= X86_PMC_IDX_FIXED ) { hwc -> config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL ; <S2SV_StartBug> hwc -> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 ; <S2SV_EndBug> } else { hwc -> config_base = x86_pmu_config_addr ( hwc -> idx ) ; hwc -> event_base = x86_pmu_event_addr ( hwc -> idx ) ; } }
CWE-20 static ssize_t generic_perform_write ( struct file * file , struct iov_iter * i , loff_t pos ) { struct address_space * mapping = file -> f_mapping ; const struct address_space_operations * a_ops = mapping -> a_ops ; long status = 0 ; ssize_t written = 0 ; unsigned int flags = 0 ; if ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) flags |= AOP_FLAG_UNINTERRUPTIBLE ; do { struct page * page ; pgoff_t index ; unsigned long offset ; unsigned long bytes ; size_t copied ; void * fsdata ; offset = ( pos & ( PAGE_CACHE_SIZE - 1 ) ) ; index = pos >> PAGE_CACHE_SHIFT ; bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_count ( i ) ) ; again : if ( unlikely ( iov_iter_fault_in_readable ( i , bytes ) ) ) { status = - EFAULT ; break ; } status = a_ops -> write_begin ( file , mapping , pos , bytes , flags , & page , & fsdata ) ; if ( unlikely ( status ) ) break ; pagefault_disable ( ) ; copied = iov_iter_copy_from_user_atomic ( page , i , offset , bytes ) ; pagefault_enable ( ) ; flush_dcache_page ( page ) ; status = a_ops -> write_end ( file , mapping , pos , bytes , copied , page , fsdata ) ; if ( unlikely ( status < 0 ) ) break ; copied = status ; cond_resched ( ) ; <S2SV_StartBug> if ( unlikely ( copied == 0 ) ) { <S2SV_EndBug> bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ; goto again ; } <S2SV_StartBug> iov_iter_advance ( i , copied ) ; <S2SV_EndBug> pos += copied ; written += copied ; balance_dirty_pages_ratelimited ( mapping ) ; } while ( iov_iter_count ( i ) ) ; return written ? written : status ; }
CWE-000 static int cypress_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct cypress_private * priv = usb_get_serial_port_data ( port ) ; struct usb_serial * serial = port -> serial ; unsigned long flags ; int result = 0 ; if ( ! priv -> comm_is_ok ) return - EIO ; usb_clear_halt ( serial -> dev , 0x81 ) ; usb_clear_halt ( serial -> dev , 0x02 ) ; spin_lock_irqsave ( & priv -> lock , flags ) ; priv -> bytes_in = 0 ; priv -> bytes_out = 0 ; priv -> cmd_count = 0 ; priv -> rx_flags = 0 ; spin_unlock_irqrestore ( & priv -> lock , flags ) ; cypress_send ( port ) ; if ( tty ) cypress_set_termios ( tty , port , & priv -> tmp_termios ) ; <S2SV_StartBug> if ( ! port -> interrupt_in_urb ) { <S2SV_EndBug> dev_err ( & port -> dev , "%s<S2SV_blank>-<S2SV_blank>interrupt_in_urb<S2SV_blank>is<S2SV_blank>empty!\\n" , __func__ ) ; return - 1 ; } usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointAddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , GFP_KERNEL ) ; if ( result ) { dev_err ( & port -> dev , "%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>submitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n" , __func__ , result ) ; cypress_set_dead ( port ) ; } return result ; }
CWE-125 static int mp_join_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_join * mpj = ( const struct mp_join * ) opt ; <S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) && <S2SV_StartBug> ! ( opt_len == 24 && flags & TH_ACK ) ) <S2SV_EndBug> return 0 ; if ( opt_len != 24 ) { if ( mpj -> sub_b & MP_JOIN_B ) ND_PRINT ( ( ndo , "<S2SV_blank>backup" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>id<S2SV_blank>%u" , mpj -> addr_id ) ) ; } switch ( opt_len ) { case 12 : ND_PRINT ( ( ndo , "<S2SV_blank>token<S2SV_blank>0x%x" "<S2SV_blank>nonce<S2SV_blank>0x%x" , EXTRACT_32BITS ( mpj -> u . syn . token ) , EXTRACT_32BITS ( mpj -> u . syn . nonce ) ) ) ; break ; case 16 : ND_PRINT ( ( ndo , "<S2SV_blank>hmac<S2SV_blank>0x%" PRIx64 "<S2SV_blank>nonce<S2SV_blank>0x%x" , EXTRACT_64BITS ( mpj -> u . synack . mac ) , EXTRACT_32BITS ( mpj -> u . synack . nonce ) ) ) ; break ; case 24 : { size_t i ; ND_PRINT ( ( ndo , "<S2SV_blank>hmac<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < sizeof ( mpj -> u . ack . mac ) ; ++ i ) ND_PRINT ( ( ndo , "%02x" , mpj -> u . ack . mac [ i ] ) ) ; } default : break ; } return 1 ; }
CWE-119 static void adapt_coef_probs ( VP9_COMMON * cm , TX_SIZE tx_size , unsigned int count_sat , unsigned int update_factor ) { const FRAME_CONTEXT * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] ; <S2SV_StartBug> vp9_coeff_probs_model * const probs = cm -> fc . coef_probs [ tx_size ] ; <S2SV_EndBug> const vp9_coeff_probs_model * const pre_probs = pre_fc -> coef_probs [ tx_size ] ; vp9_coeff_count_model * counts = cm -> counts . coef [ tx_size ] ; unsigned int ( * eob_counts ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cm -> counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) for ( j = 0 ; j < REF_TYPES ; ++ j ) for ( k = 0 ; k < COEF_BANDS ; ++ k ) for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { const int n0 = counts [ i ] [ j ] [ k ] [ l ] [ ZERO_TOKEN ] ; const int n1 = counts [ i ] [ j ] [ k ] [ l ] [ ONE_TOKEN ] ; const int n2 = counts [ i ] [ j ] [ k ] [ l ] [ TWO_TOKEN ] ; const int neob = counts [ i ] [ j ] [ k ] [ l ] [ EOB_MODEL_TOKEN ] ; const unsigned int branch_ct [ UNCONSTRAINED_NODES ] [ 2 ] = { { neob , eob_counts [ i ] [ j ] [ k ] [ l ] - neob } , { n0 , n1 + n2 } , { n1 , n2 } } ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) probs [ i ] [ j ] [ k ] [ l ] [ m ] = merge_probs ( pre_probs [ i ] [ j ] [ k ] [ l ] [ m ] , branch_ct [ m ] , count_sat , update_factor ) ; } }
CWE-000 static int mv_read_header ( AVFormatContext * avctx ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * ast = NULL , * vst = NULL ; int version , i ; int ret ; avio_skip ( pb , 4 ) ; version = avio_rb16 ( pb ) ; if ( version == 2 ) { uint64_t timestamp ; int v ; avio_skip ( pb , 22 ) ; ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; vst -> nb_frames = avio_rb32 ( pb ) ; v = avio_rb32 ( pb ) ; switch ( v ) { case 1 : vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; break ; case 2 : vst -> codecpar -> format = AV_PIX_FMT_ARGB ; vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; break ; default : avpriv_request_sample ( avctx , "Video<S2SV_blank>compression<S2SV_blank>%i" , v ) ; break ; } vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rb32 ( pb ) ; vst -> codecpar -> height = avio_rb32 ( pb ) ; avio_skip ( pb , 12 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast -> nb_frames = vst -> nb_frames ; ast -> codecpar -> sample_rate = avio_rb32 ( pb ) ; if ( ast -> codecpar -> sample_rate <= 0 ) { av_log ( avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>%d\\n" , ast -> codecpar -> sample_rate ) ; return AVERROR_INVALIDDATA ; } avpriv_set_pts_info ( ast , 33 , 1 , ast -> codecpar -> sample_rate ) ; if ( set_channels ( avctx , ast , avio_rb32 ( pb ) ) < 0 ) return AVERROR_INVALIDDATA ; v = avio_rb32 ( pb ) ; if ( v == AUDIO_FORMAT_SIGNED ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , "Audio<S2SV_blank>compression<S2SV_blank>(format<S2SV_blank>%i)" , v ) ; } avio_skip ( pb , 12 ) ; var_read_metadata ( avctx , "title" , 0x80 ) ; var_read_metadata ( avctx , "comment" , 0x100 ) ; avio_skip ( pb , 0x80 ) ; timestamp = 0 ; for ( i = 0 ; i < vst -> nb_frames ; i ++ ) { uint32_t pos = avio_rb32 ( pb ) ; uint32_t asize = avio_rb32 ( pb ) ; <S2SV_StartBug> uint32_t vsize = avio_rb32 ( pb ) ; <S2SV_EndBug> avio_skip ( pb , 8 ) ; av_add_index_entry ( ast , pos , timestamp , asize , 0 , AVINDEX_KEYFRAME ) ; av_add_index_entry ( vst , pos + asize , i , vsize , 0 , AVINDEX_KEYFRAME ) ; timestamp += asize / ( ast -> codecpar -> channels * 2 ) ; } } else if ( ! version && avio_rb16 ( pb ) == 3 ) { avio_skip ( pb , 4 ) ; if ( ( ret = read_table ( avctx , NULL , parse_global_var ) ) < 0 ) return ret ; if ( mv -> nb_audio_tracks > 1 ) { avpriv_request_sample ( avctx , "Multiple<S2SV_blank>audio<S2SV_blank>streams<S2SV_blank>support" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_audio_tracks ) { ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; if ( ( read_table ( avctx , ast , parse_audio_var ) ) < 0 ) return ret ; if ( mv -> acompression == 100 && mv -> aformat == AUDIO_FORMAT_SIGNED && ast -> codecpar -> bits_per_coded_sample == 16 ) { ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; } else { avpriv_request_sample ( avctx , "Audio<S2SV_blank>compression<S2SV_blank>%i<S2SV_blank>(format<S2SV_blank>%i,<S2SV_blank>sr<S2SV_blank>%i)" , mv -> acompression , mv -> aformat , ast -> codecpar -> bits_per_coded_sample ) ; ast -> codecpar -> codec_id = AV_CODEC_ID_NONE ; } if ( ast -> codecpar -> channels <= 0 ) { av_log ( avctx , AV_LOG_ERROR , "No<S2SV_blank>valid<S2SV_blank>channel<S2SV_blank>count<S2SV_blank>found.\\n" ) ; return AVERROR_INVALIDDATA ; } } if ( mv -> nb_video_tracks > 1 ) { avpriv_request_sample ( avctx , "Multiple<S2SV_blank>video<S2SV_blank>streams<S2SV_blank>support" ) ; return AVERROR_PATCHWELCOME ; } else if ( mv -> nb_video_tracks ) { vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; if ( ( ret = read_table ( avctx , vst , parse_video_var ) ) < 0 ) return ret ; } if ( mv -> nb_audio_tracks ) read_index ( pb , ast ) ; if ( mv -> nb_video_tracks ) read_index ( pb , vst ) ; } else { avpriv_request_sample ( avctx , "Version<S2SV_blank>%i" , version ) ; return AVERROR_PATCHWELCOME ; } return 0 ; }
CWE-190 <S2SV_StartBug> static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { <S2SV_EndBug> <S2SV_StartBug> int nBytes = sizeof ( char * ) * ( 2 + pTable -> nModuleArg ) ; <S2SV_EndBug> <S2SV_StartBug> char * * azModuleArg ; <S2SV_EndBug> azModuleArg = sqlite3DbRealloc ( db , pTable -> azModuleArg , nBytes ) ; if ( azModuleArg == 0 ) { sqlite3DbFree ( db , zArg ) ; } else { int i = pTable -> nModuleArg ++ ; azModuleArg [ i ] = zArg ; azModuleArg [ i + 1 ] = 0 ; pTable -> azModuleArg = azModuleArg ; } }
CWE-119 static bool check_underflow ( const struct ipt_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ip ) ) <S2SV_EndBug> return false ; t = ipt_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }
CWE-119 static Image * ReadGRAYImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , "MustSpecifyImageSize" ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( size_t ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; SetImageColorspace ( image , GRAYColorspace ) ; canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_type = GrayQuantum ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = GetQuantumPixels ( quantum_info ) ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } scene = 0 ; count = 0 ; length = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register ssize_t x ; register PixelPacket * restrict q ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-476 static int hash_accept ( struct socket * sock , struct socket * newsock , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; struct ahash_request * req = & ctx -> req ; char state [ crypto_ahash_statesize ( crypto_ahash_reqtfm ( req ) ) ] ; struct sock * sk2 ; struct alg_sock * ask2 ; struct hash_ctx * ctx2 ; <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> err = crypto_ahash_export ( req , state ) ; <S2SV_EndBug> if ( err ) return err ; err = af_alg_accept ( ask -> parent , newsock ) ; if ( err ) return err ; sk2 = newsock -> sk ; ask2 = alg_sk ( sk2 ) ; ctx2 = ask2 -> private ; <S2SV_StartBug> ctx2 -> more = 1 ; <S2SV_EndBug> err = crypto_ahash_import ( & ctx2 -> req , state ) ; if ( err ) { sock_orphan ( sk2 ) ; sock_put ( sk2 ) ; } return err ; }
CWE-000 <S2SV_StartBug> static void follow_dotdot ( struct nameidata * nd ) <S2SV_EndBug> { if ( ! nd -> root . mnt ) set_root ( nd ) ; while ( 1 ) { struct dentry * old = nd -> path . dentry ; if ( nd -> path . dentry == nd -> root . dentry && nd -> path . mnt == nd -> root . mnt ) { break ; } if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { nd -> path . dentry = dget_parent ( nd -> path . dentry ) ; dput ( old ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } if ( ! follow_up ( & nd -> path ) ) break ; } follow_mount ( & nd -> path ) ; nd -> inode = nd -> path . dentry -> d_inode ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = EXT2_SB ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ; <S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> if ( ! ( sb -> s_flags & MS_RDONLY ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }
CWE-119 static inline void queue_unlock ( struct futex_q * q , struct futex_hash_bucket * hb ) { spin_unlock ( & hb -> lock ) ; <S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> }
CWE-20 static int keyring_search_iterator ( const void * object , void * iterator_data ) { struct keyring_search_context * ctx = iterator_data ; const struct key * key = keyring_ptr_to_key ( object ) ; <S2SV_StartBug> unsigned long kflags = key -> flags ; <S2SV_EndBug> kenter ( "{%d}" , key -> serial ) ; if ( key -> type != ctx -> index_key . type ) { kleave ( "<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[!type]" ) ; return 0 ; } if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { if ( kflags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) ) ) { ctx -> result = ERR_PTR ( - EKEYREVOKED ) ; kleave ( "<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[invrev]" , ctx -> skipped_ret ) ; goto skipped ; } if ( key -> expiry && ctx -> now . tv_sec >= key -> expiry ) { if ( ! ( ctx -> flags & KEYRING_SEARCH_SKIP_EXPIRED ) ) ctx -> result = ERR_PTR ( - EKEYEXPIRED ) ; kleave ( "<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[expire]" , ctx -> skipped_ret ) ; goto skipped ; } } if ( ! ctx -> match_data . cmp ( key , & ctx -> match_data ) ) { kleave ( "<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[!match]" ) ; return 0 ; } if ( ! ( ctx -> flags & KEYRING_SEARCH_NO_CHECK_PERM ) && key_task_permission ( make_key_ref ( key , ctx -> possessed ) , ctx -> cred , KEY_NEED_SEARCH ) < 0 ) { ctx -> result = ERR_PTR ( - EACCES ) ; kleave ( "<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[!perm]" , ctx -> skipped_ret ) ; goto skipped ; } if ( ctx -> flags & KEYRING_SEARCH_DO_STATE_CHECK ) { <S2SV_StartBug> if ( kflags & ( 1 << KEY_FLAG_NEGATIVE ) ) { <S2SV_EndBug> smp_rmb ( ) ; <S2SV_StartBug> ctx -> result = ERR_PTR ( key -> reject_error ) ; <S2SV_EndBug> kleave ( "<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[neg]" , ctx -> skipped_ret ) ; goto skipped ; } } ctx -> result = make_key_ref ( key , ctx -> possessed ) ; kleave ( "<S2SV_blank>=<S2SV_blank>1<S2SV_blank>[found]" ) ; return 1 ; skipped : return ctx -> skipped_ret ; }
CWE-264 int cg_write ( const char * path , const char * buf , size_t size , off_t offset , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; char * localbuf = NULL ; struct cgfs_files * k = NULL ; struct file_info * f = ( struct file_info * ) fi -> fh ; bool r ; if ( f -> type != LXC_TYPE_CGFILE ) { fprintf ( stderr , "Internal<S2SV_blank>error:<S2SV_blank>directory<S2SV_blank>cache<S2SV_blank>info<S2SV_blank>used<S2SV_blank>in<S2SV_blank>cg_write\\n" ) ; return - EIO ; } if ( offset ) return 0 ; if ( ! fc ) return - EIO ; localbuf = alloca ( size + 1 ) ; localbuf [ size ] = '\\0' ; memcpy ( localbuf , buf , size ) ; if ( ( k = cgfs_get_key ( f -> controller , f -> cgroup , f -> file ) ) == NULL ) { size = - EINVAL ; goto out ; } if ( ! fc_may_access ( fc , f -> controller , f -> cgroup , f -> file , O_WRONLY ) ) { size = - EACCES ; goto out ; } if ( strcmp ( f -> file , "tasks" ) == 0 || strcmp ( f -> file , "/tasks" ) == 0 || strcmp ( f -> file , "/cgroup.procs" ) == 0 || strcmp ( f -> file , "cgroup.procs" ) == 0 ) <S2SV_StartBug> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file , localbuf ) ; <S2SV_EndBug> else r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ; if ( ! r ) size = - EINVAL ; out : free_key ( k ) ; return size ; }
CWE-119 static void svc_log_reset ( SvcContext * svc_ctx ) { <S2SV_StartBug> SvcInternal * const si = ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> si -> message_buffer [ 0 ] = '\\0' ; }
CWE-119 <S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> { <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }
CWE-125 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( "nfnetlink-subsys-%d" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ; <S2SV_StartBug> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <S2SV_EndBug> skb -> len < nlh -> nlmsg_len ) { err = - EINVAL ; goto ack ; } if ( ! ( nlh -> nlmsg_flags & NLM_F_REQUEST ) ) { err = - EINVAL ; goto ack ; } type = nlh -> nlmsg_type ; if ( type == NFNL_MSG_BATCH_BEGIN ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } else if ( type == NFNL_MSG_BATCH_END ) { status |= NFNL_BATCH_DONE ; goto done ; } else if ( type < NLMSG_MIN_TYPE ) { err = - EINVAL ; goto ack ; } if ( NFNL_SUBSYS_ID ( type ) != subsys_id ) { err = - EINVAL ; goto ack ; } nc = nfnetlink_find_client ( type , ss ) ; if ( ! nc ) { err = - EINVAL ; goto ack ; } { int min_len = nlmsg_total_size ( sizeof ( struct nfgenmsg ) ) ; u_int8_t cb_id = NFNL_MSG_TYPE ( nlh -> nlmsg_type ) ; struct nlattr * cda [ ss -> cb [ cb_id ] . attr_count + 1 ] ; struct nlattr * attr = ( void * ) nlh + min_len ; int attrlen = nlh -> nlmsg_len - min_len ; err = nla_parse ( cda , ss -> cb [ cb_id ] . attr_count , attr , attrlen , ss -> cb [ cb_id ] . policy ) ; if ( err < 0 ) goto ack ; if ( nc -> call_batch ) { err = nc -> call_batch ( net , net -> nfnl , skb , nlh , ( const struct nlattr * * ) cda ) ; } if ( err == - EAGAIN ) { status |= NFNL_BATCH_REPLAY ; goto next ; } } ack : if ( nlh -> nlmsg_flags & NLM_F_ACK || err ) { if ( nfnl_err_add ( & err_list , nlh , err ) < 0 ) { nfnl_err_reset ( & err_list ) ; netlink_ack ( oskb , nlmsg_hdr ( oskb ) , - ENOMEM ) ; status |= NFNL_BATCH_FAILURE ; goto done ; } if ( err ) status |= NFNL_BATCH_FAILURE ; } next : msglen = NLMSG_ALIGN ( nlh -> nlmsg_len ) ; if ( msglen > skb -> len ) msglen = skb -> len ; skb_pull ( skb , msglen ) ; } done : if ( status & NFNL_BATCH_REPLAY ) { ss -> abort ( net , oskb ) ; nfnl_err_reset ( & err_list ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; goto replay ; } else if ( status == NFNL_BATCH_DONE ) { ss -> commit ( net , oskb ) ; } else { ss -> abort ( net , oskb ) ; } nfnl_err_deliver ( & err_list , oskb ) ; nfnl_unlock ( subsys_id ) ; kfree_skb ( skb ) ; }
CWE-119 <S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , "Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame." ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame." ) ; printf ( keyframe ? "K" : "." ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static int msg_cache_check ( const char * id , struct BodyCache * bcache , void * data ) { struct Context * ctx = ( struct Context * ) data ; if ( ! ctx ) return - 1 ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; if ( ! pop_data ) return - 1 ; # ifdef USE_HCACHE if ( strcmp ( HC_FNAME "." HC_FEXT , id ) == 0 ) return 0 ; # endif for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> data && ( mutt_str_strcmp ( ctx -> hdrs [ i ] -> data , id ) == 0 ) ) return 0 ; } <S2SV_StartBug> return mutt_bcache_del ( bcache , id ) ; <S2SV_EndBug> }
CWE-200 static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) { if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , "GAB2" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) { uint8_t desc [ 256 ] ; int score = AVPROBE_SCORE_EXTENSION , ret ; AVIStream * ast = st -> priv_data ; AVInputFormat * sub_demuxer ; AVRational time_base ; int size ; AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ; AVProbeData pd ; unsigned int desc_len = avio_rl32 ( pb ) ; if ( desc_len > pb -> buf_end - pb -> buf_ptr ) goto error ; ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ; avio_skip ( pb , desc_len - ret ) ; if ( * desc ) av_dict_set ( & st -> metadata , "title" , desc , 0 ) ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; size = pb -> buf_end - pb -> buf_ptr ; pd = ( AVProbeData ) { . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , . buf_size = size } ; if ( ! pd . buf ) goto error ; memcpy ( pd . buf , pb -> buf_ptr , size ) ; sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ; av_freep ( & pd . buf ) ; if ( ! sub_demuxer ) goto error ; <S2SV_StartBug> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) <S2SV_EndBug> goto error ; ast -> sub_ctx -> pb = pb ; if ( ff_copy_whiteblacklists ( ast -> sub_ctx , s ) < 0 ) goto error ; if ( ! avformat_open_input ( & ast -> sub_ctx , "" , sub_demuxer , NULL ) ) { if ( ast -> sub_ctx -> nb_streams != 1 ) goto error ; ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) ; avcodec_parameters_copy ( st -> codecpar , ast -> sub_ctx -> streams [ 0 ] -> codecpar ) ; time_base = ast -> sub_ctx -> streams [ 0 ] -> time_base ; avpriv_set_pts_info ( st , 64 , time_base . num , time_base . den ) ; } ast -> sub_buffer = pkt -> data ; memset ( pkt , 0 , sizeof ( * pkt ) ) ; return 1 ; error : av_freep ( & ast -> sub_ctx ) ; av_freep ( & pb ) ; } return 0 ; }
CWE-125 static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ; <S2SV_StartBug> size_t <S2SV_EndBug> value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] << 16 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 2 ] << 8 ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 3 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffffffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
CWE-000 static int init_nss_hash ( struct crypto_instance * instance ) { PK11SlotInfo * hash_slot = NULL ; SECItem hash_param ; if ( ! hash_to_nss [ instance -> crypto_hash_type ] ) { return 0 ; } hash_param . type = siBuffer ; <S2SV_StartBug> hash_param . data = 0 ; <S2SV_EndBug> <S2SV_StartBug> hash_param . len = 0 ; <S2SV_EndBug> hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ; if ( hash_slot == NULL ) { log_printf ( instance -> log_level_security , "Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>security<S2SV_blank>slot<S2SV_blank>(err<S2SV_blank>%d)" , PR_GetError ( ) ) ; return - 1 ; } instance -> nss_sym_key_sign = PK11_ImportSymKey ( hash_slot , hash_to_nss [ instance -> crypto_hash_type ] , PK11_OriginUnwrap , CKA_SIGN , & hash_param , NULL ) ; if ( instance -> nss_sym_key_sign == NULL ) { log_printf ( instance -> log_level_security , "Failure<S2SV_blank>to<S2SV_blank>import<S2SV_blank>key<S2SV_blank>into<S2SV_blank>NSS<S2SV_blank>(err<S2SV_blank>%d)" , PR_GetError ( ) ) ; return - 1 ; } PK11_FreeSlot ( hash_slot ) ; return 0 ; }
CWE-772 static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * image ; QuantumInfo * quantum_info ; QuantumType quantum_type ; MagickBooleanType status ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 1 ; image -> endian = MSBEndian ; ( void ) ReadBlobLSBShort ( image ) ; image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ; ( void ) ReadBlobLSBShort ( image ) ; image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } SetImageColorspace ( image , GRAYColorspace ) ; quantum_type = IndexQuantum ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register PixelPacket * magick_restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) <S2SV_StartBug> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; <S2SV_EndBug> ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; ( void ) ReadBlobStream ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , GetQuantumPixels ( quantum_info ) , & count ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-190 int jas_memdump ( FILE * out , void * data , size_t len ) { size_t i ; size_t j ; <S2SV_StartBug> uchar * dp ; <S2SV_EndBug> dp = data ; for ( i = 0 ; i < len ; i += 16 ) { fprintf ( out , "%04zx:" , i ) ; for ( j = 0 ; j < 16 ; ++ j ) { if ( i + j < len ) { fprintf ( out , "<S2SV_blank>%02x" , dp [ i + j ] ) ; } } fprintf ( out , "\\n" ) ; } return 0 ; }
CWE-119 static void opl3_panning ( int dev , int voice , int value ) { <S2SV_StartBug> devc -> voc [ voice ] . panning = value ; <S2SV_EndBug> }
CWE-787 static int hmac_create ( struct crypto_template * tmpl , struct rtattr * * tb ) { struct shash_instance * inst ; struct crypto_alg * alg ; struct shash_alg * salg ; int err ; int ds ; int ss ; err = crypto_check_attr_type ( tb , CRYPTO_ALG_TYPE_SHASH ) ; if ( err ) return err ; salg = shash_attr_alg ( tb [ 1 ] , 0 , 0 ) ; if ( IS_ERR ( salg ) ) return PTR_ERR ( salg ) ; <S2SV_StartBug> err = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> ds = salg -> digestsize ; <S2SV_EndBug> <S2SV_StartBug> ss = salg -> statesize ; <S2SV_EndBug> alg = & salg -> base ; if ( ds > alg -> cra_blocksize || ss < alg -> cra_blocksize ) goto out_put_alg ; inst = shash_alloc_instance ( "hmac" , alg ) ; err = PTR_ERR ( inst ) ; if ( IS_ERR ( inst ) ) goto out_put_alg ; err = crypto_init_shash_spawn ( shash_instance_ctx ( inst ) , salg , shash_crypto_instance ( inst ) ) ; if ( err ) goto out_free_inst ; inst -> alg . base . cra_priority = alg -> cra_priority ; inst -> alg . base . cra_blocksize = alg -> cra_blocksize ; inst -> alg . base . cra_alignmask = alg -> cra_alignmask ; ss = ALIGN ( ss , alg -> cra_alignmask + 1 ) ; inst -> alg . digestsize = ds ; inst -> alg . statesize = ss ; inst -> alg . base . cra_ctxsize = sizeof ( struct hmac_ctx ) + ALIGN ( ss * 2 , crypto_tfm_ctx_alignment ( ) ) ; inst -> alg . base . cra_init = hmac_init_tfm ; inst -> alg . base . cra_exit = hmac_exit_tfm ; inst -> alg . init = hmac_init ; inst -> alg . update = hmac_update ; inst -> alg . final = hmac_final ; inst -> alg . finup = hmac_finup ; inst -> alg . export = hmac_export ; inst -> alg . import = hmac_import ; inst -> alg . setkey = hmac_setkey ; err = shash_register_instance ( tmpl , inst ) ; if ( err ) { out_free_inst : shash_free_instance ( shash_crypto_instance ( inst ) ) ; } out_put_alg : crypto_mod_put ( alg ) ; return err ; }
CWE-000 int ocfs2_set_acl ( handle_t * handle , struct inode * inode , struct buffer_head * di_bh , int type , struct posix_acl * acl , struct ocfs2_alloc_context * meta_ac , struct ocfs2_alloc_context * data_ac ) { int name_index ; void * value = NULL ; size_t size = 0 ; int ret ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; ret = ocfs2_acl_set_mode ( inode , di_bh , handle , mode ) ; if ( ret ) return ret ; } break ; case ACL_TYPE_DEFAULT : name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ocfs2_acl_to_xattr ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } if ( handle ) ret = ocfs2_xattr_set_handle ( handle , inode , di_bh , name_index , "" , value , size , 0 , meta_ac , data_ac ) ; else ret = ocfs2_xattr_set ( inode , name_index , "" , value , size , 0 ) ; kfree ( value ) ; return ret ; }
CWE-20 static int __key_instantiate_and_link ( struct key * key , struct key_preparsed_payload * prep , struct key * keyring , struct key * authkey , struct assoc_array_edit * * _edit ) { int ret , awaken ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; mutex_lock ( & key_construction_mutex ) ; <S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> ret = key -> type -> instantiate ( key , prep ) ; if ( ret == 0 ) { atomic_inc ( & key -> user -> nikeys ) ; <S2SV_StartBug> set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; <S2SV_EndBug> if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; if ( keyring ) { if ( test_bit ( KEY_FLAG_KEEP , & keyring -> flags ) ) set_bit ( KEY_FLAG_KEEP , & key -> flags ) ; __key_link ( key , _edit ) ; } if ( authkey ) key_revoke ( authkey ) ; if ( prep -> expiry != TIME_T_MAX ) { key -> expiry = prep -> expiry ; key_schedule_gc ( prep -> expiry + key_gc_delay ) ; } } } mutex_unlock ( & key_construction_mutex ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret ; }
CWE-119 <S2SV_StartBug> void fdct4_sse2 ( __m128i * in ) { <S2SV_EndBug> <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u [ 4 ] , v [ 4 ] ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 1 ] = _mm_unpacklo_epi16 ( in [ 3 ] , in [ 2 ] ) ; v [ 0 ] = _mm_add_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_sub_epi16 ( u [ 0 ] , u [ 1 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p08_p24 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p24_m08 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 1 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; transpose_4x4 ( in ) ; }
CWE-000 static int unix_dgram_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct sockaddr_un * sunaddr = ( struct sockaddr_un * ) addr ; struct sock * other ; unsigned int hash ; int err ; if ( addr -> sa_family != AF_UNSPEC ) { err = unix_mkname ( sunaddr , alen , & hash ) ; if ( err < 0 ) goto out ; alen = err ; if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! unix_sk ( sk ) -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; restart : other = unix_find_other ( net , sunaddr , alen , sock -> type , hash , & err ) ; if ( ! other ) goto out ; unix_state_double_lock ( sk , other ) ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; goto restart ; } err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } else { other = NULL ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) ) { struct sock * old_peer = unix_peer ( sk ) ; unix_peer ( sk ) = other ; <S2SV_StartBug> unix_state_double_unlock ( sk , other ) ; <S2SV_EndBug> if ( other != old_peer ) unix_dgram_disconnected ( sk , old_peer ) ; sock_put ( old_peer ) ; } else { unix_peer ( sk ) = other ; unix_state_double_unlock ( sk , other ) ; } return 0 ; out_unlock : unix_state_double_unlock ( sk , other ) ; sock_put ( other ) ; out : return err ; }
CWE-000 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return false ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( "%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return true ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : <S2SV_StartBug> if ( ! is_exception ( intr_info ) ) <S2SV_EndBug> return false ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return false ; else if ( is_debug ( intr_info ) && vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) return false ; else if ( is_breakpoint ( intr_info ) && vcpu -> guest_debug & KVM_GUESTDBG_USE_SW_BP ) return false ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return false ; case EXIT_REASON_TRIPLE_FAULT : return true ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return true ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return false ; return true ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return true ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : case EXIT_REASON_RDTSCP : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : return true ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_GDTR_IDTR : case EXIT_REASON_LDTR_TR : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_DESC ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return true ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_TRAP_FLAG : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_TRAP_FLAG ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return false ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_APIC_WRITE : case EXIT_REASON_EOI_INDUCED : return true ; case EXIT_REASON_EPT_VIOLATION : return false ; case EXIT_REASON_EPT_MISCONFIG : return false ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return true ; case EXIT_REASON_XSAVES : case EXIT_REASON_XRSTORS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_XSAVES ) ; case EXIT_REASON_PREEMPTION_TIMER : return false ; default : return true ; } }
CWE-119 void vp8_mbpost_proc_down_c ( unsigned char * dst , int pitch , int rows , int cols , int flimit ) { int r , c , i ; const short * rv3 = & vp8_rv [ 63 & rand ( ) ] ; for ( c = 0 ; c < cols ; c ++ ) { unsigned char * s = & dst [ c ] ; int sumsq = 0 ; int sum = 0 ; unsigned char d [ 16 ] ; const short * rv2 = rv3 + ( ( c * 17 ) & 127 ) ; for ( i = - 8 ; i < 0 ; i ++ ) s [ i * pitch ] = s [ 0 ] ; <S2SV_StartBug> for ( i = rows ; i < rows + 17 ; i ++ ) <S2SV_EndBug> s [ i * pitch ] = s [ ( rows - 1 ) * pitch ] ; for ( i = - 8 ; i <= 6 ; i ++ ) { sumsq += s [ i * pitch ] * s [ i * pitch ] ; sum += s [ i * pitch ] ; } for ( r = 0 ; r < rows + 8 ; r ++ ) { sumsq += s [ 7 * pitch ] * s [ 7 * pitch ] - s [ - 8 * pitch ] * s [ - 8 * pitch ] ; sum += s [ 7 * pitch ] - s [ - 8 * pitch ] ; d [ r & 15 ] = s [ 0 ] ; if ( sumsq * 15 - sum * sum < flimit ) { d [ r & 15 ] = ( rv2 [ r & 127 ] + sum + s [ 0 ] ) >> 4 ; } if ( r >= 8 ) s [ - 8 * pitch ] = d [ ( r - 8 ) & 15 ] ; s += pitch ; } } }
CWE-284 void _modinit ( module_t * m ) { service_named_bind_command ( "chanserv" , & cs_flags ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-284 int bta_co_rfc_data_outgoing_size ( void * user_data , int * size ) { pthread_mutex_lock ( & slot_lock ) ; uint32_t id = ( uintptr_t ) user_data ; int ret = false ; * size = 0 ; rfc_slot_t * slot = find_rfc_slot_by_id ( id ) ; if ( ! slot ) goto out ; <S2SV_StartBug> if ( ioctl ( slot -> fd , FIONREAD , size ) == 0 ) { <S2SV_EndBug> ret = true ; } else { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>determine<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>to<S2SV_blank>be<S2SV_blank>read<S2SV_blank>on<S2SV_blank>fd<S2SV_blank>%d:<S2SV_blank>%s" , __func__ , slot -> fd , strerror ( errno ) ) ; cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; return ret ; }
CWE-20 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; list_del ( & key -> graveyard_link ) ; kdebug ( "-<S2SV_blank>%u" , key -> serial ) ; key_check ( key ) ; <S2SV_StartBug> if ( key -> type -> destroy ) <S2SV_EndBug> key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; # ifdef KEY_DEBUGGING key -> magic = KEY_DEBUG_MAGIC_X ; # endif kmem_cache_free ( key_jar , key ) ; } }
CWE-416 static int l2tp_ip6_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_l2tpip6 * addr = ( struct sockaddr_l2tpip6 * ) uaddr ; struct net * net = sock_net ( sk ) ; __be32 v4addr = 0 ; int addr_type ; int err ; <S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> return - EINVAL ; if ( addr -> l2tp_family != AF_INET6 ) return - EINVAL ; if ( addr_len < sizeof ( * addr ) ) return - EINVAL ; addr_type = ipv6_addr_type ( & addr -> l2tp_addr ) ; if ( addr_type == IPV6_ADDR_MAPPED ) return - EADDRNOTAVAIL ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - EADDRNOTAVAIL ; err = - EADDRINUSE ; read_lock_bh ( & l2tp_ip6_lock ) ; if ( __l2tp_ip6_bind_lookup ( net , & addr -> l2tp_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip6_lock ) ; lock_sock ( sk ) ; err = - EINVAL ; <S2SV_StartBug> if ( sk -> sk_state != TCP_CLOSE ) <S2SV_EndBug> goto out_unlock ; rcu_read_lock ( ) ; if ( addr_type != IPV6_ADDR_ANY ) { struct net_device * dev = NULL ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && addr -> l2tp_scope_id ) { sk -> sk_bound_dev_if = addr -> l2tp_scope_id ; } if ( ! sk -> sk_bound_dev_if ) goto out_unlock_rcu ; err = - ENODEV ; dev = dev_get_by_index_rcu ( sock_net ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! dev ) goto out_unlock_rcu ; } v4addr = LOOPBACK4_IPV6 ; err = - EADDRNOTAVAIL ; if ( ! ipv6_chk_addr ( sock_net ( sk ) , & addr -> l2tp_addr , dev , 0 ) ) goto out_unlock_rcu ; } rcu_read_unlock ( ) ; inet -> inet_rcv_saddr = inet -> inet_saddr = v4addr ; sk -> sk_v6_rcv_saddr = addr -> l2tp_addr ; np -> saddr = addr -> l2tp_addr ; l2tp_ip6_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip6_lock ) ; sk_add_bind_node ( sk , & l2tp_ip6_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip6_lock ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; release_sock ( sk ) ; return 0 ; out_unlock_rcu : rcu_read_unlock ( ) ; out_unlock : release_sock ( sk ) ; return err ; out_in_use : read_unlock_bh ( & l2tp_ip6_lock ) ; return err ; }
CWE-119 void vp9_default_coef_probs ( VP9_COMMON * cm ) { <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ; <S2SV_EndBug> }
CWE-399 xmlAttrPtr xsltAttrTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attr ) { const xmlChar * value ; xmlAttrPtr ret ; if ( ( ctxt == NULL ) || ( attr == NULL ) || ( target == NULL ) ) return ( NULL ) ; if ( attr -> type != XML_ATTRIBUTE_NODE ) return ( NULL ) ; # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) return ( NULL ) ; # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) return ( NULL ) ; # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>The<S2SV_blank>children<S2SV_blank>of<S2SV_blank>an<S2SV_blank>attribute<S2SV_blank>node<S2SV_blank>of<S2SV_blank>a<S2SV_blank>" "literal<S2SV_blank>result<S2SV_blank>element<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>expected<S2SV_blank>form.\\n" ) ; return ( NULL ) ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST "" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST "" , 0 ) ; ret = target -> properties ; while ( ret != NULL ) { if ( ( ( attr -> ns != NULL ) == ( ret -> ns != NULL ) ) && xmlStrEqual ( ret -> name , attr -> name ) && ( ( attr -> ns == NULL ) || xmlStrEqual ( ret -> ns -> href , attr -> ns -> href ) ) ) { break ; } ret = ret -> next ; } if ( ret != NULL ) { xmlFreeNodeList ( ret -> children ) ; ret -> children = ret -> last = NULL ; if ( ( ret -> ns != NULL ) && ( ! xmlStrEqual ( ret -> ns -> prefix , attr -> ns -> prefix ) ) ) { ret -> ns = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ; } } else { if ( attr -> ns != NULL ) ret = xmlNewNsProp ( target , xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) , attr -> name , NULL ) ; else ret = xmlNewNsProp ( target , NULL , attr -> name , NULL ) ; } if ( ret != NULL ) { xmlNodePtr text ; text = xmlNewText ( NULL ) ; if ( text != NULL ) { ret -> last = ret -> children = text ; text -> parent = ( xmlNodePtr ) ret ; text -> doc = ret -> doc ; if ( attr -> psvi != NULL ) { xmlChar * val ; val = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ; if ( val == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>" "of<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>" "of<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n" , attr -> name ) ; } text -> content = xmlStrdup ( BAD_CAST "" ) ; } else { text -> content = val ; } } else if ( ( ctxt -> internalized ) && ( target != NULL ) && ( target -> doc != NULL ) && <S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) { <S2SV_EndBug> text -> content = ( xmlChar * ) value ; } else { text -> content = xmlStrdup ( value ) ; } } } else { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n" , attr -> name ) ; } } return ( ret ) ; }
CWE-000 static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; <S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> struct hlist_node * n ; int err ; <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out : <S2SV_StartBug> return err ; <S2SV_EndBug> }
CWE-000 <S2SV_StartBug> static void sas_destruct_devices ( struct work_struct * work ) <S2SV_EndBug> { <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DESTRUCT , & port -> disc . pending ) ; list_for_each_entry_safe ( dev , n , & port -> destroy_list , disco_list_node ) { list_del_init ( & dev -> disco_list_node ) ; sas_remove_children ( & dev -> rphy -> dev ) ; sas_rphy_delete ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; } }
CWE-119 <S2SV_StartBug> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , <S2SV_EndBug> vpx_codec_frame_buffer_t * fb ) { int i ; struct ExternalFrameBufferList * const ext_fb_list = ( struct ExternalFrameBufferList * ) cb_priv ; if ( ext_fb_list == NULL ) return - 1 ; for ( i = 0 ; i < ext_fb_list -> num_external_frame_buffers ; ++ i ) { if ( ! ext_fb_list -> ext_fb [ i ] . in_use ) break ; } if ( i == ext_fb_list -> num_external_frame_buffers ) return - 1 ; if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) { free ( ext_fb_list -> ext_fb [ i ] . data ) ; <S2SV_StartBug> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; <S2SV_EndBug> if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ; ext_fb_list -> ext_fb [ i ] . size = min_size ; } fb -> data = ext_fb_list -> ext_fb [ i ] . data ; fb -> size = ext_fb_list -> ext_fb [ i ] . size ; ext_fb_list -> ext_fb [ i ] . in_use = 1 ; fb -> priv = & ext_fb_list -> ext_fb [ i ] ; return 0 ; }
CWE-119 int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; const int fps = 30 ; const int bitrate = 200 ; int keyframe_interval = 0 ; const char * codec_arg = NULL ; const char * width_arg = NULL ; const char * height_arg = NULL ; const char * infile_arg = NULL ; const char * outfile_arg = NULL ; const char * keyframe_interval_arg = NULL ; exec_name = argv [ 0 ] ; if ( argc < 7 ) die ( "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments" ) ; codec_arg = argv [ 1 ] ; width_arg = argv [ 2 ] ; height_arg = argv [ 3 ] ; infile_arg = argv [ 4 ] ; outfile_arg = argv [ 5 ] ; keyframe_interval_arg = argv [ 6 ] ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( "Unsupported<S2SV_blank>codec." ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( width_arg , NULL , 0 ) ; info . frame_height = strtol ( height_arg , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( "Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image." ) ; } keyframe_interval = strtol ( keyframe_interval_arg , NULL , 0 ) ; if ( keyframe_interval < 0 ) die ( "Invalid<S2SV_blank>keyframe<S2SV_blank>interval<S2SV_blank>value." ) ; <S2SV_StartBug> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> if ( res ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config." ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; cfg . g_error_resilient = argc > 7 ? strtol ( argv [ 7 ] , NULL , 0 ) : 0 ; writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing." , outfile_arg ) ; if ( ! ( infile = fopen ( infile_arg , "rb" ) ) ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading." , infile_arg ) ; <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder" ) ; while ( vpx_img_read ( & raw , infile ) ) { int flags = 0 ; if ( keyframe_interval > 0 && frame_count % keyframe_interval == 0 ) flags |= VPX_EFLAG_FORCE_KF ; encode_frame ( & codec , & raw , frame_count ++ , flags , writer ) ; } <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , 0 , writer ) ; <S2SV_EndBug> printf ( "\\n" ) ; fclose ( infile ) ; printf ( "Processed<S2SV_blank>%d<S2SV_blank>frames.\\n" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec." ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
CWE-119 void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }
CWE-119 static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) { <S2SV_StartBug> int mi_row ; <S2SV_EndBug> int mi_col ; int mi_index = 0 ; <S2SV_StartBug> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible ; <S2SV_EndBug> int rows = cm -> mi_rows ; int cols = cm -> mi_cols ; char prefix = descriptor [ 0 ] ; <S2SV_StartBug> log_frame_info ( cm , descriptor , file ) ; <S2SV_EndBug> mi_index = 0 ; for ( mi_row = 0 ; mi_row < rows ; mi_row ++ ) { fprintf ( file , "%c<S2SV_blank>" , prefix ) ; for ( mi_col = 0 ; mi_col < cols ; mi_col ++ ) { fprintf ( file , "%2d<S2SV_blank>" , <S2SV_StartBug> * ( ( int * ) ( ( char * ) ( & mi_8x8 [ mi_index ] -> mbmi ) + <S2SV_EndBug> member_offset ) ) ) ; <S2SV_StartBug> mi_index ++ ; <S2SV_EndBug> } fprintf ( file , "\\n" ) ; <S2SV_StartBug> mi_index += 8 ; <S2SV_EndBug> } fprintf ( file , "\\n" ) ; }
CWE-000 <S2SV_StartBug> static ssize_t aio_setup_single_vector ( struct kiocb * kiocb ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> kiocb -> ki_iovec = & kiocb -> ki_inline_vec ; kiocb -> ki_iovec -> iov_base = kiocb -> ki_buf ; <S2SV_StartBug> kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ; <S2SV_EndBug> kiocb -> ki_nr_segs = 1 ; kiocb -> ki_cur_seg = 0 ; return 0 ; }
CWE-772 int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> return res ; }
CWE-119 <S2SV_StartBug> static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) { <S2SV_EndBug> const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ; const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ; const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ; segment_tree_probs [ 0 ] = get_binary_prob ( c01 + c23 , c45 + c67 ) ; segment_tree_probs [ 1 ] = get_binary_prob ( c01 , c23 ) ; segment_tree_probs [ 2 ] = get_binary_prob ( c45 , c67 ) ; segment_tree_probs [ 3 ] = get_binary_prob ( segcounts [ 0 ] , segcounts [ 1 ] ) ; segment_tree_probs [ 4 ] = get_binary_prob ( segcounts [ 2 ] , segcounts [ 3 ] ) ; segment_tree_probs [ 5 ] = get_binary_prob ( segcounts [ 4 ] , segcounts [ 5 ] ) ; segment_tree_probs [ 6 ] = get_binary_prob ( segcounts [ 6 ] , segcounts [ 7 ] ) ; }
CWE-190 static int jpc_dec_process_siz ( jpc_dec_t * dec , jpc_ms_t * ms ) { jpc_siz_t * siz = & ms -> parms . siz ; int compno ; int tileno ; jpc_dec_tile_t * tile ; jpc_dec_tcomp_t * tcomp ; int htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ; <S2SV_StartBug> dec -> xstart = siz -> xoff ; <S2SV_EndBug> dec -> ystart = siz -> yoff ; dec -> xend = siz -> width ; dec -> yend = siz -> height ; dec -> tilewidth = siz -> tilewidth ; dec -> tileheight = siz -> tileheight ; dec -> tilexoff = siz -> tilexoff ; dec -> tileyoff = siz -> tileyoff ; dec -> numcomps = siz -> numcomps ; if ( ! ( dec -> cp = jpc_dec_cp_create ( dec -> numcomps ) ) ) { return - 1 ; } if ( ! ( dec -> cmpts = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_cmpt_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ cmpt ) { cmpt -> prec = siz -> comps [ compno ] . prec ; cmpt -> sgnd = siz -> comps [ compno ] . sgnd ; cmpt -> hstep = siz -> comps [ compno ] . hsamp ; cmpt -> vstep = siz -> comps [ compno ] . vsamp ; cmpt -> width = JPC_CEILDIV ( dec -> xend , cmpt -> hstep ) - JPC_CEILDIV ( dec -> xstart , cmpt -> hstep ) ; cmpt -> height = JPC_CEILDIV ( dec -> yend , cmpt -> vstep ) - JPC_CEILDIV ( dec -> ystart , cmpt -> vstep ) ; cmpt -> hsubstep = 0 ; cmpt -> vsubstep = 0 ; } dec -> image = 0 ; dec -> numhtiles = JPC_CEILDIV ( dec -> xend - dec -> tilexoff , dec -> tilewidth ) ; dec -> numvtiles = JPC_CEILDIV ( dec -> yend - dec -> tileyoff , dec -> tileheight ) ; <S2SV_StartBug> dec -> numtiles = dec -> numhtiles * dec -> numvtiles ; <S2SV_EndBug> JAS_DBGLOG ( 10 , ( "numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; } <S2SV_StartBug> for ( tileno = 0 , tile = dec -> tiles ; tileno < dec -> numtiles ; ++ tileno , <S2SV_EndBug> ++ tile ) { htileno = tileno % dec -> numhtiles ; vtileno = tileno / dec -> numhtiles ; tile -> realmode = 0 ; tile -> state = JPC_TILE_INIT ; tile -> xstart = JAS_MAX ( dec -> tilexoff + htileno * dec -> tilewidth , dec -> xstart ) ; tile -> ystart = JAS_MAX ( dec -> tileyoff + vtileno * dec -> tileheight , dec -> ystart ) ; tile -> xend = JAS_MIN ( dec -> tilexoff + ( htileno + 1 ) * dec -> tilewidth , dec -> xend ) ; tile -> yend = JAS_MIN ( dec -> tileyoff + ( vtileno + 1 ) * dec -> tileheight , dec -> yend ) ; tile -> numparts = 0 ; tile -> partno = 0 ; tile -> pkthdrstream = 0 ; tile -> pkthdrstreampos = 0 ; tile -> pptstab = 0 ; tile -> cp = 0 ; tile -> pi = 0 ; if ( ! ( tile -> tcomps = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_tcomp_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ cmpt , ++ tcomp ) { tcomp -> rlvls = 0 ; tcomp -> numrlvls = 0 ; tcomp -> data = 0 ; tcomp -> xstart = JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) ; tcomp -> ystart = JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) ; tcomp -> xend = JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) ; tcomp -> yend = JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ; tcomp -> tsfb = 0 ; } } dec -> pkthdrstreams = 0 ; dec -> state = JPC_MH ; return 0 ; }
CWE-264 int create_user_ns ( struct cred * new ) { struct user_namespace * ns , * parent_ns = new -> user_ns ; kuid_t owner = new -> euid ; kgid_t group = new -> egid ; <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ; ns = kmem_cache_zalloc ( user_ns_cachep , GFP_KERNEL ) ; if ( ! ns ) return - ENOMEM ; ret = proc_alloc_inum ( & ns -> proc_inum ) ; if ( ret ) { kmem_cache_free ( user_ns_cachep , ns ) ; return ret ; } atomic_set ( & ns -> count , 1 ) ; ns -> parent = parent_ns ; ns -> owner = owner ; ns -> group = group ; set_cred_user_ns ( new , ns ) ; return 0 ; }
CWE-119 void vp8_setup_intra_recon ( YV12_BUFFER_CONFIG * ybf ) { int i ; <S2SV_StartBug> vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; <S2SV_EndBug> for ( i = 0 ; i < ybf -> y_height ; i ++ ) ybf -> y_buffer [ ybf -> y_stride * i - 1 ] = ( unsigned char ) 129 ; <S2SV_StartBug> vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> for ( i = 0 ; i < ybf -> uv_height ; i ++ ) ybf -> u_buffer [ ybf -> uv_stride * i - 1 ] = ( unsigned char ) 129 ; <S2SV_StartBug> vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> for ( i = 0 ; i < ybf -> uv_height ; i ++ ) ybf -> v_buffer [ ybf -> uv_stride * i - 1 ] = ( unsigned char ) 129 ; }
CWE-000 static gboolean comics_check_decompress_command ( gchar * mime_type , ComicsDocument * comics_document , GError * * error ) { gboolean success ; gchar * std_out , * std_err ; gint retval ; GError * err = NULL ; if ( g_content_type_is_a ( mime_type , "application/x-cbr" ) || g_content_type_is_a ( mime_type , "application/x-rar" ) ) { comics_document -> selected_command = g_find_program_in_path ( "unrar" ) ; if ( comics_document -> selected_command ) { success = g_spawn_command_line_sync ( comics_document -> selected_command , & std_out , & std_err , & retval , & err ) ; if ( ! success ) { g_propagate_error ( error , err ) ; g_error_free ( err ) ; return FALSE ; } else if ( WIFEXITED ( retval ) ) { if ( g_strrstr ( std_out , "freeware" ) != NULL ) comics_document -> command_usage = RARLABS ; else comics_document -> command_usage = GNAUNRAR ; g_free ( std_out ) ; g_free ( std_err ) ; return TRUE ; } } comics_document -> selected_command = g_find_program_in_path ( "unrar-free" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = GNAUNRAR ; return TRUE ; } <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> g_find_program_in_path ( "bsdtar" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } } else if ( g_content_type_is_a ( mime_type , "application/x-cbz" ) || g_content_type_is_a ( mime_type , "application/zip" ) ) { comics_document -> selected_command = g_find_program_in_path ( "unzip" ) ; comics_document -> alternative_command = g_find_program_in_path ( "zipnote" ) ; if ( comics_document -> selected_command && comics_document -> alternative_command ) { comics_document -> command_usage = UNZIP ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( "7za" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( "7z" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; } <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> g_find_program_in_path ( "bsdtar" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } } else if ( g_content_type_is_a ( mime_type , "application/x-cb7" ) || g_content_type_is_a ( mime_type , "application/x-7z-compressed" ) ) { comics_document -> selected_command = g_find_program_in_path ( "7zr" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( "7za" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( "7z" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = P7ZIP ; return TRUE ; } <S2SV_StartBug> comics_document -> selected_command = <S2SV_EndBug> g_find_program_in_path ( "bsdtar" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } } else if ( g_content_type_is_a ( mime_type , "application/x-cbt" ) || g_content_type_is_a ( mime_type , "application/x-tar" ) ) { comics_document -> selected_command = g_find_program_in_path ( "tar" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } comics_document -> selected_command = g_find_program_in_path ( "bsdtar" ) ; if ( comics_document -> selected_command ) { comics_document -> command_usage = TAR ; return TRUE ; } } else { g_set_error ( error , EV_DOCUMENT_ERROR , EV_DOCUMENT_ERROR_INVALID , _ ( "Not<S2SV_blank>a<S2SV_blank>comic<S2SV_blank>book<S2SV_blank>MIME<S2SV_blank>type:<S2SV_blank>%s" ) , mime_type ) ; return FALSE ; } g_set_error_literal ( error , EV_DOCUMENT_ERROR , EV_DOCUMENT_ERROR_INVALID , _ ( "Can’t<S2SV_blank>find<S2SV_blank>an<S2SV_blank>appropriate<S2SV_blank>command<S2SV_blank>to<S2SV_blank>" "decompress<S2SV_blank>this<S2SV_blank>type<S2SV_blank>of<S2SV_blank>comic<S2SV_blank>book" ) ) ; return FALSE ; }
CWE-119 <S2SV_StartBug> void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) { <S2SV_EndBug> const MODE_INFO * mi = xd -> mi [ 0 ] ; <S2SV_StartBug> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; <S2SV_EndBug> if ( mbmi -> sb_type < BLOCK_8X8 ) { const int num_4x4_w = num_4x4_blocks_wide_lookup [ mbmi -> sb_type ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ mbmi -> sb_type ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int i = idy * 2 + idx ; if ( mi -> bmi [ i ] . as_mode == NEWMV ) <S2SV_StartBug> inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ; <S2SV_EndBug> } } } else { if ( mbmi -> mode == NEWMV ) <S2SV_StartBug> inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ; <S2SV_EndBug> } }
CWE-000 struct mnt_namespace * copy_mnt_ns ( unsigned long flags , struct mnt_namespace * ns , struct user_namespace * user_ns , struct fs_struct * new_fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old ; struct mount * new ; int copy_flags ; BUG_ON ( ! ns ) ; if ( likely ( ! ( flags & CLONE_NEWNS ) ) ) { get_mnt_ns ( ns ) ; return ns ; } old = ns -> root ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; namespace_lock ( ) ; copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE ; if ( user_ns != ns -> user_ns ) copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED ; new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { namespace_unlock ( ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; <S2SV_StartBug> if ( new_fs ) { <S2SV_EndBug> if ( & p -> mnt == new_fs -> root . mnt ) { new_fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == new_fs -> pwd . mnt ) { new_fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; if ( ! q ) break ; while ( p -> mnt . mnt_root != q -> mnt . mnt_root ) p = next_mnt ( p , old ) ; } namespace_unlock ( ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> if ( cc > stride ) { if ( stride == 3 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; cc -= 3 ; cp += 3 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cc -= 3 ; cp += 3 ; } } else if ( stride == 4 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; unsigned int ca = cp [ 3 ] ; cc -= 4 ; cp += 4 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cp [ 3 ] = ( unsigned char ) ( ( ca += cp [ 3 ] ) & 0xff ) ; cc -= 4 ; cp += 4 ; } } else { cc -= stride ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + * cp ) & 0xff ) ; cp ++ ) cc -= stride ; } while ( cc > 0 ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-476 int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 1 ] == EOF ) <S2SV_EndBug> return 0 ; if ( text [ 1 ] == 'x' ) { text [ 2 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 2 ] == EOF ) <S2SV_EndBug> return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ; <S2SV_StartBug> if ( text [ 3 ] == EOF ) <S2SV_EndBug> return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }
CWE-119 static int http_receive_data ( HTTPContext * c ) { HTTPContext * c1 ; int len , loop_run = 0 ; while ( c -> chunked_encoding && ! c -> chunk_size && c -> buffer_end > c -> buffer_ptr ) { len = recv ( c -> fd , c -> buffer_ptr , 1 , 0 ) ; if ( len < 0 ) { if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && ff_neterrno ( ) != AVERROR ( EINTR ) ) goto fail ; return 0 ; } else if ( len == 0 ) { goto fail ; } else if ( c -> buffer_ptr - c -> buffer >= 2 && ! memcmp ( c -> buffer_ptr - 1 , "\\r\\n" , 2 ) ) { c -> chunk_size = strtol ( c -> buffer , 0 , 16 ) ; <S2SV_StartBug> if ( c -> chunk_size == 0 ) <S2SV_EndBug> goto fail ; c -> buffer_ptr = c -> buffer ; break ; } else if ( ++ loop_run > 10 ) goto fail ; else c -> buffer_ptr ++ ; } if ( c -> buffer_end > c -> buffer_ptr ) { len = recv ( c -> fd , c -> buffer_ptr , FFMIN ( c -> chunk_size , c -> buffer_end - c -> buffer_ptr ) , 0 ) ; if ( len < 0 ) { if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && ff_neterrno ( ) != AVERROR ( EINTR ) ) goto fail ; } else if ( len == 0 ) goto fail ; <S2SV_StartBug> else { <S2SV_EndBug> c -> chunk_size -= len ; c -> buffer_ptr += len ; c -> data_count += len ; update_datarate ( & c -> datarate , c -> data_count ) ; } } if ( c -> buffer_ptr - c -> buffer >= 2 && c -> data_count > FFM_PACKET_SIZE ) { if ( c -> buffer [ 0 ] != 'f' || c -> buffer [ 1 ] != 'm' ) { http_log ( "Feed<S2SV_blank>stream<S2SV_blank>has<S2SV_blank>become<S2SV_blank>desynchronized<S2SV_blank>--<S2SV_blank>disconnecting\\n" ) ; goto fail ; } } if ( c -> buffer_ptr >= c -> buffer_end ) { FFServerStream * feed = c -> stream ; if ( c -> data_count > FFM_PACKET_SIZE ) { if ( lseek ( c -> feed_fd , feed -> feed_write_index , SEEK_SET ) == - 1 ) http_log ( "Seek<S2SV_blank>to<S2SV_blank>%" PRId64 "<S2SV_blank>failed\\n" , feed -> feed_write_index ) ; if ( write ( c -> feed_fd , c -> buffer , FFM_PACKET_SIZE ) < 0 ) { http_log ( "Error<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>feed<S2SV_blank>file:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; goto fail ; } feed -> feed_write_index += FFM_PACKET_SIZE ; if ( feed -> feed_write_index > c -> stream -> feed_size ) feed -> feed_size = feed -> feed_write_index ; if ( c -> stream -> feed_max_size && feed -> feed_write_index >= c -> stream -> feed_max_size ) feed -> feed_write_index = FFM_PACKET_SIZE ; if ( ffm_write_write_index ( c -> feed_fd , feed -> feed_write_index ) < 0 ) { http_log ( "Error<S2SV_blank>writing<S2SV_blank>index<S2SV_blank>to<S2SV_blank>feed<S2SV_blank>file:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; goto fail ; } for ( c1 = first_http_ctx ; c1 ; c1 = c1 -> next ) { if ( c1 -> state == HTTPSTATE_WAIT_FEED && c1 -> stream -> feed == c -> stream -> feed ) c1 -> state = HTTPSTATE_SEND_DATA ; } } else { AVFormatContext * s = avformat_alloc_context ( ) ; AVIOContext * pb ; AVInputFormat * fmt_in ; int i ; if ( ! s ) goto fail ; fmt_in = av_find_input_format ( feed -> fmt -> name ) ; if ( ! fmt_in ) goto fail ; pb = avio_alloc_context ( c -> buffer , c -> buffer_end - c -> buffer , 0 , NULL , NULL , NULL , NULL ) ; if ( ! pb ) goto fail ; pb -> seekable = 0 ; s -> pb = pb ; if ( avformat_open_input ( & s , c -> stream -> feed_filename , fmt_in , NULL ) < 0 ) { av_freep ( & pb ) ; goto fail ; } if ( s -> nb_streams != feed -> nb_streams ) { avformat_close_input ( & s ) ; av_freep ( & pb ) ; http_log ( "Feed<S2SV_blank>\'%s\'<S2SV_blank>stream<S2SV_blank>number<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>registered<S2SV_blank>feed\\n" , c -> stream -> feed_filename ) ; goto fail ; } for ( i = 0 ; i < s -> nb_streams ; i ++ ) { LayeredAVStream * fst = feed -> streams [ i ] ; AVStream * st = s -> streams [ i ] ; avcodec_parameters_to_context ( fst -> codec , st -> codecpar ) ; avcodec_parameters_from_context ( fst -> codecpar , fst -> codec ) ; } avformat_close_input ( & s ) ; av_freep ( & pb ) ; } c -> buffer_ptr = c -> buffer ; } return 0 ; fail : c -> stream -> feed_opened = 0 ; close ( c -> feed_fd ) ; for ( c1 = first_http_ctx ; c1 ; c1 = c1 -> next ) { if ( c1 -> state == HTTPSTATE_WAIT_FEED && c1 -> stream -> feed == c -> stream -> feed ) c1 -> state = HTTPSTATE_SEND_DATA_TRAILER ; } return - 1 ; }
CWE-000 void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , <S2SV_StartBug> [ DISCE_PROBE ] = sas_probe_devices , <S2SV_EndBug> [ DISCE_SUSPEND ] = sas_suspend_devices , <S2SV_StartBug> [ DISCE_RESUME ] = sas_resume_devices , <S2SV_EndBug> [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }
CWE-189 Datum hstore_from_record ( PG_FUNCTION_ARGS ) { HeapTupleHeader rec ; int32 buflen ; HStore * out ; Pairs * pairs ; Oid tupType ; int32 tupTypmod ; TupleDesc tupdesc ; HeapTupleData tuple ; RecordIOData * my_extra ; int ncolumns ; int i , j ; Datum * values ; bool * nulls ; if ( PG_ARGISNULL ( 0 ) ) { Oid argtype = get_fn_expr_argtype ( fcinfo -> flinfo , 0 ) ; tupType = argtype ; tupTypmod = - 1 ; rec = NULL ; } else { rec = PG_GETARG_HEAPTUPLEHEADER ( 0 ) ; tupType = HeapTupleHeaderGetTypeId ( rec ) ; tupTypmod = HeapTupleHeaderGetTypMod ( rec ) ; } tupdesc = lookup_rowtype_tupdesc ( tupType , tupTypmod ) ; ncolumns = tupdesc -> natts ; my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; if ( my_extra == NULL || my_extra -> ncolumns != ncolumns ) { fcinfo -> flinfo -> fn_extra = MemoryContextAlloc ( fcinfo -> flinfo -> fn_mcxt , sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) + ncolumns * sizeof ( ColumnIOData ) ) ; my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; my_extra -> record_type = InvalidOid ; my_extra -> record_typmod = 0 ; } if ( my_extra -> record_type != tupType || my_extra -> record_typmod != tupTypmod ) { MemSet ( my_extra , 0 , sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) + ncolumns * sizeof ( ColumnIOData ) ) ; my_extra -> record_type = tupType ; my_extra -> record_typmod = tupTypmod ; my_extra -> ncolumns = ncolumns ; } <S2SV_StartBug> pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ; <S2SV_EndBug> if ( rec ) { tuple . t_len = HeapTupleHeaderGetDatumLength ( rec ) ; ItemPointerSetInvalid ( & ( tuple . t_self ) ) ; tuple . t_tableOid = InvalidOid ; tuple . t_data = rec ; values = ( Datum * ) palloc ( ncolumns * sizeof ( Datum ) ) ; nulls = ( bool * ) palloc ( ncolumns * sizeof ( bool ) ) ; heap_deform_tuple ( & tuple , tupdesc , values , nulls ) ; } else { values = NULL ; nulls = NULL ; } for ( i = 0 , j = 0 ; i < ncolumns ; ++ i ) { ColumnIOData * column_info = & my_extra -> columns [ i ] ; Oid column_type = tupdesc -> attrs [ i ] -> atttypid ; char * value ; if ( tupdesc -> attrs [ i ] -> attisdropped ) continue ; pairs [ j ] . key = NameStr ( tupdesc -> attrs [ i ] -> attname ) ; pairs [ j ] . keylen = hstoreCheckKeyLen ( strlen ( NameStr ( tupdesc -> attrs [ i ] -> attname ) ) ) ; if ( ! nulls || nulls [ i ] ) { pairs [ j ] . val = NULL ; pairs [ j ] . vallen = 4 ; pairs [ j ] . isnull = true ; pairs [ j ] . needfree = false ; ++ j ; continue ; } if ( column_info -> column_type != column_type ) { bool typIsVarlena ; getTypeOutputInfo ( column_type , & column_info -> typiofunc , & typIsVarlena ) ; fmgr_info_cxt ( column_info -> typiofunc , & column_info -> proc , fcinfo -> flinfo -> fn_mcxt ) ; column_info -> column_type = column_type ; } value = OutputFunctionCall ( & column_info -> proc , values [ i ] ) ; pairs [ j ] . val = value ; pairs [ j ] . vallen = hstoreCheckValLen ( strlen ( value ) ) ; pairs [ j ] . isnull = false ; pairs [ j ] . needfree = false ; ++ j ; } ncolumns = hstoreUniquePairs ( pairs , j , & buflen ) ; out = hstorePairs ( pairs , ncolumns , buflen ) ; ReleaseTupleDesc ( tupdesc ) ; PG_RETURN_POINTER ( out ) ; }
CWE-125 int main ( int argc , char * argv [ ] ) { <S2SV_StartBug> libettercap_init ( ) ; <S2SV_EndBug> ef_globals_alloc ( ) ; select_text_interface ( ) ; libettercap_ui_init ( ) ; fprintf ( stdout , "\\n" EC_COLOR_BOLD "%s<S2SV_blank>%s" EC_COLOR_END "<S2SV_blank>copyright<S2SV_blank>%s<S2SV_blank>%s\\n\\n" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ; EF_GBL -> lineno = 1 ; parse_options ( argc , argv ) ; if ( EF_GBL_OPTIONS -> source_file ) { yyin = fopen ( EF_GBL_OPTIONS -> source_file , "r" ) ; if ( yyin == NULL ) FATAL_ERROR ( "Input<S2SV_blank>file<S2SV_blank>not<S2SV_blank>found<S2SV_blank>!" ) ; } else { FATAL_ERROR ( "No<S2SV_blank>source<S2SV_blank>file." ) ; } setbuf ( yyin , NULL ) ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; load_tables ( ) ; load_constants ( ) ; fprintf ( stdout , "\\n<S2SV_blank>Parsing<S2SV_blank>source<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>" , EF_GBL_OPTIONS -> source_file ) ; fflush ( stdout ) ; ef_debug ( 1 , "\\n" ) ; if ( yyparse ( ) == 0 ) fprintf ( stdout , "<S2SV_blank>done.\\n\\n" ) ; else fprintf ( stdout , "\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n" ) ; <S2SV_StartBug> if ( write_output ( ) != E_SUCCESS ) <S2SV_EndBug> FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)" , EF_GBL_OPTIONS -> output_file ) ; ef_globals_free ( ) ; return 0 ; }
CWE-284 void close_uinput ( void ) { BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { <S2SV_StartBug> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <S2SV_EndBug> close ( uinput_fd ) ; uinput_fd = - 1 ; } }
CWE-399 static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ; <S2SV_StartBug> } <S2SV_EndBug> fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; } <S2SV_StartBug> return num ; <S2SV_EndBug> }
CWE-264 static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = packet_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; if ( sock -> type == SOCK_PACKET ) msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; else msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ) ; if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } <S2SV_StartBug> put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; <S2SV_EndBug> } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
CWE-20 static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ; <S2SV_StartBug> u8 smac [ ETH_ALEN ] ; <S2SV_EndBug> u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev ( conn_id , listen_id ) ; if ( ret ) goto err2 ; conn_id -> cm_id . ib = cm_id ; cm_id -> context = conn_id ; cm_id -> cm_handler = cma_ib_handler ; atomic_inc ( & conn_id -> refcount ) ; ret = conn_id -> id . event_handler ( & conn_id -> id , & event ) ; if ( ret ) goto err3 ; <S2SV_StartBug> if ( is_iboe ) { <S2SV_EndBug> if ( ib_event -> param . req_rcvd . primary_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . primary_path -> sgid , psmac , NULL ) ; else psmac = NULL ; if ( ib_event -> param . req_rcvd . alternate_path != NULL ) rdma_addr_find_smac_by_sgid ( & ib_event -> param . req_rcvd . alternate_path -> sgid , palt_smac , NULL ) ; else palt_smac = NULL ; } <S2SV_StartBug> mutex_lock ( & lock ) ; <S2SV_EndBug> if ( is_iboe ) ib_update_cm_av ( cm_id , psmac , palt_smac ) ; if ( cma_comp ( conn_id , RDMA_CM_CONNECT ) && ( conn_id -> id . qp_type != IB_QPT_UD ) ) ib_send_cm_mra ( cm_id , CMA_CM_MRA_SETTING , NULL , 0 ) ; mutex_unlock ( & lock ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; mutex_unlock ( & listen_id -> handler_mutex ) ; cma_deref_id ( conn_id ) ; return 0 ; err3 : cma_deref_id ( conn_id ) ; conn_id -> cm_id . ib = NULL ; err2 : cma_exch ( conn_id , RDMA_CM_DESTROYING ) ; mutex_unlock ( & conn_id -> handler_mutex ) ; err1 : mutex_unlock ( & listen_id -> handler_mutex ) ; if ( conn_id ) rdma_destroy_id ( & conn_id -> id ) ; return ret ; }
CWE-000 static struct ib_ucontext * hns_roce_alloc_ucontext ( struct ib_device * ib_dev , struct ib_udata * udata ) { int ret = 0 ; struct hns_roce_ucontext * context ; <S2SV_StartBug> struct hns_roce_ib_alloc_ucontext_resp resp ; <S2SV_EndBug> struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ; resp . qp_tab_size = hr_dev -> caps . num_qps ; context = kmalloc ( sizeof ( * context ) , GFP_KERNEL ) ; if ( ! context ) return ERR_PTR ( - ENOMEM ) ; ret = hns_roce_uar_alloc ( hr_dev , & context -> uar ) ; if ( ret ) goto error_fail_uar_alloc ; if ( hr_dev -> caps . flags & HNS_ROCE_CAP_FLAG_RECORD_DB ) { INIT_LIST_HEAD ( & context -> page_list ) ; mutex_init ( & context -> page_mutex ) ; } ret = ib_copy_to_udata ( udata , & resp , sizeof ( resp ) ) ; if ( ret ) goto error_fail_copy_to_udata ; return & context -> ibucontext ; error_fail_copy_to_udata : hns_roce_uar_free ( hr_dev , & context -> uar ) ; error_fail_uar_alloc : kfree ( context ) ; return ERR_PTR ( ret ) ; }
CWE-399 long do_io_submit ( aio_context_t ctx_id , long nr , struct iocb __user * __user * iocbpp , bool compat ) { struct kioctx * ctx ; long ret = 0 ; int i = 0 ; struct blk_plug plug ; struct kiocb_batch batch ; if ( unlikely ( nr < 0 ) ) return - EINVAL ; if ( unlikely ( nr > LONG_MAX / sizeof ( * iocbpp ) ) ) nr = LONG_MAX / sizeof ( * iocbpp ) ; if ( unlikely ( ! access_ok ( VERIFY_READ , iocbpp , ( nr * sizeof ( * iocbpp ) ) ) ) ) return - EFAULT ; ctx = lookup_ioctx ( ctx_id ) ; if ( unlikely ( ! ctx ) ) { pr_debug ( "EINVAL:<S2SV_blank>io_submit:<S2SV_blank>invalid<S2SV_blank>context<S2SV_blank>id\\n" ) ; return - EINVAL ; } kiocb_batch_init ( & batch , nr ) ; blk_start_plug ( & plug ) ; for ( i = 0 ; i < nr ; i ++ ) { struct iocb __user * user_iocb ; struct iocb tmp ; if ( unlikely ( __get_user ( user_iocb , iocbpp + i ) ) ) { ret = - EFAULT ; break ; } if ( unlikely ( copy_from_user ( & tmp , user_iocb , sizeof ( tmp ) ) ) ) { ret = - EFAULT ; break ; } ret = io_submit_one ( ctx , user_iocb , & tmp , & batch , compat ) ; if ( ret ) break ; } blk_finish_plug ( & plug ) ; <S2SV_StartBug> kiocb_batch_free ( & batch ) ; <S2SV_EndBug> put_ioctx ( ctx ) ; return i ? i : ret ; }
CWE-200 static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ; <S2SV_StartBug> BT_DBG ( "sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; <S2SV_EndBug> sa -> rc_family = AF_BLUETOOTH ; sa -> rc_channel = rfcomm_pi ( sk ) -> channel ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }
CWE-119 static void init_frame ( VP8D_COMP * pbi ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; if ( pc -> frame_type == KEY_FRAME ) { <S2SV_StartBug> vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> vp8_init_mbmode_probs ( pc ) ; vp8_default_coef_probs ( pc ) ; <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ; <S2SV_StartBug> vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> pc -> refresh_golden_frame = 1 ; pc -> refresh_alt_ref_frame = 1 ; pc -> copy_buffer_to_gf = 0 ; pc -> copy_buffer_to_arf = 0 ; pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = 0 ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ; } else { if ( ! pc -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; } if ( pbi -> decoded_key_frame && pbi -> ec_enabled && ! pbi -> ec_active ) pbi -> ec_active = 1 ; } xd -> left_context = & pc -> left_context ; xd -> mode_info_context = pc -> mi ; xd -> frame_type = pc -> frame_type ; xd -> mode_info_context -> mbmi . mode = DC_PRED ; xd -> mode_info_stride = pc -> mode_info_stride ; xd -> corrupted = 0 ; xd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) xd -> fullpixel_mask = 0xfffffff8 ; }
CWE-119 vpx_image_t * vpx_codec_get_frame ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) { vpx_image_t * img ; if ( ! ctx || ! iter || ! ctx -> iface || ! ctx -> priv ) img = NULL ; else <S2SV_StartBug> img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ; <S2SV_EndBug> return img ; }
CWE-476 static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; if ( tmp >= O2NM_MAX_NODES ) return - ERANGE ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> write_lock ( & cluster -> cl_nodes_lock ) ; <S2SV_EndBug> if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> return ret ; return count ; }
CWE-399 static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; } <S2SV_StartBug> if ( iph -> ihl == 5 ) { <S2SV_EndBug> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! IN_DEV_SOURCE_ROUTE ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INHDRERRORS ) ; drop : return - 1 ; }
CWE-000 void mwifiex_set_uap_rates ( struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { struct ieee_types_header * rate_ie ; int var_offset = offsetof ( struct ieee80211_mgmt , u . beacon . variable ) ; const u8 * var_pos = params -> beacon . head + var_offset ; int len = params -> beacon . head_len - var_offset ; u8 rate_len = 0 ; rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_SUPP_RATES , var_pos , len ) ; if ( rate_ie ) { <S2SV_StartBug> memcpy ( bss_cfg -> rates , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> rate_len = rate_ie -> len ; } rate_ie = ( void * ) cfg80211_find_ie ( WLAN_EID_EXT_SUPP_RATES , params -> beacon . tail , params -> beacon . tail_len ) ; <S2SV_StartBug> if ( rate_ie ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( bss_cfg -> rates + rate_len , rate_ie + 1 , rate_ie -> len ) ; <S2SV_EndBug> return ; }
CWE-119 void vp8_alloc_compressor_data ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int width = cm -> Width ; int height = cm -> Height ; if ( vp8_alloc_frame_buffers ( cm , width , height ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame<S2SV_blank>buffers" ) ; if ( vp8_alloc_partition_data ( cpi ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>partition<S2SV_blank>data" ) ; if ( ( width & 0xf ) != 0 ) width += 16 - ( width & 0xf ) ; if ( ( height & 0xf ) != 0 ) height += 16 - ( height & 0xf ) ; if ( vp8_yv12_alloc_frame_buffer ( & cpi -> pick_lf_lvl_frame , width , height , VP8BORDERINPIXELS ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>last<S2SV_blank>frame<S2SV_blank>buffer" ) ; if ( vp8_yv12_alloc_frame_buffer ( & cpi -> scaled_source , width , height , VP8BORDERINPIXELS ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scaled<S2SV_blank>source<S2SV_blank>buffer" ) ; vpx_free ( cpi -> tok ) ; { # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING unsigned int tokens = 8 * 24 * 16 ; # else unsigned int tokens = cm -> mb_rows * cm -> mb_cols * 24 * 16 ; # endif CHECK_MEM_ERROR ( cpi -> tok , vpx_calloc ( tokens , sizeof ( * cpi -> tok ) ) ) ; } cpi -> zeromv_count = 0 ; vpx_free ( cpi -> gf_active_flags ) ; CHECK_MEM_ERROR ( cpi -> gf_active_flags , vpx_calloc ( sizeof ( * cpi -> gf_active_flags ) , cm -> mb_rows * cm -> mb_cols ) ) ; cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; vpx_free ( cpi -> mb_activity_map ) ; CHECK_MEM_ERROR ( cpi -> mb_activity_map , vpx_calloc ( sizeof ( * cpi -> mb_activity_map ) , cm -> mb_rows * cm -> mb_cols ) ) ; vpx_free ( cpi -> lfmv ) ; CHECK_MEM_ERROR ( cpi -> lfmv , vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , sizeof ( * cpi -> lfmv ) ) ) ; vpx_free ( cpi -> lf_ref_frame_sign_bias ) ; CHECK_MEM_ERROR ( cpi -> lf_ref_frame_sign_bias , vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , sizeof ( * cpi -> lf_ref_frame_sign_bias ) ) ) ; vpx_free ( cpi -> lf_ref_frame ) ; CHECK_MEM_ERROR ( cpi -> lf_ref_frame , vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , sizeof ( * cpi -> lf_ref_frame ) ) ) ; vpx_free ( cpi -> segmentation_map ) ; CHECK_MEM_ERROR ( cpi -> segmentation_map , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , sizeof ( * cpi -> segmentation_map ) ) ) ; cpi -> cyclic_refresh_mode_index = 0 ; vpx_free ( cpi -> active_map ) ; CHECK_MEM_ERROR ( cpi -> active_map , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , sizeof ( * cpi -> active_map ) ) ) ; <S2SV_StartBug> vpx_memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> # if CONFIG_MULTITHREAD if ( width < 640 ) cpi -> mt_sync_range = 1 ; else if ( width <= 1280 ) cpi -> mt_sync_range = 4 ; else if ( width <= 2560 ) cpi -> mt_sync_range = 8 ; else cpi -> mt_sync_range = 16 ; if ( cpi -> oxcf . multi_threaded > 1 ) { vpx_free ( cpi -> mt_current_mb_col ) ; CHECK_MEM_ERROR ( cpi -> mt_current_mb_col , vpx_malloc ( sizeof ( * cpi -> mt_current_mb_col ) * cm -> mb_rows ) ) ; } # endif vpx_free ( cpi -> tplist ) ; CHECK_MEM_ERROR ( cpi -> tplist , vpx_malloc ( sizeof ( TOKENLIST ) * cm -> mb_rows ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[]}" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[\\"" PACKAGE "/" VERSION "\\",<S2SV_blank>\\"%s\\"]}" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[\\"" PACKAGE "/" VERSION "\\"]}" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , "Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , "JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , "result" ) ; err_val = json_object_get ( val , "error" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( "(unknown<S2SV_blank>reason)" ) ; applog ( LOG_INFO , "JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; nonce1 = json_array_string ( res_val , 1 ) ; <S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; <S2SV_EndBug> free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; <S2SV_EndBug> free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , "Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , "Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> sdiff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , "Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , "Initiate<S2SV_blank>stratum<S2SV_blank>failed" ) ; if ( sockd ) suspend_stratum ( pool ) ; } json_decref ( val ) ; return ret ; }
CWE-000 static void Sp_replace_regexp ( js_State * J ) { js_Regexp * re ; const char * source , * s , * r ; js_Buffer * sb = NULL ; int n , x ; Resub m ; source = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; <S2SV_StartBug> if ( js_regexec ( re -> prog , source , & m , 0 ) ) { <S2SV_EndBug> js_copy ( J , 0 ) ; return ; } re -> last = 0 ; loop : s = m . sub [ 0 ] . sp ; n = m . sub [ 0 ] . ep - m . sub [ 0 ] . sp ; if ( js_iscallable ( J , 2 ) ) { js_copy ( J , 2 ) ; js_pushundefined ( J ) ; for ( x = 0 ; m . sub [ x ] . sp ; ++ x ) js_pushlstring ( J , m . sub [ x ] . sp , m . sub [ x ] . ep - m . sub [ x ] . sp ) ; js_pushnumber ( J , s - source ) ; js_copy ( J , 0 ) ; js_call ( J , 2 + x ) ; r = js_tostring ( J , - 1 ) ; js_putm ( J , & sb , source , s ) ; js_puts ( J , & sb , r ) ; js_pop ( J , 1 ) ; } else { r = js_tostring ( J , 2 ) ; js_putm ( J , & sb , source , s ) ; while ( * r ) { if ( * r == '$' ) { switch ( * ( ++ r ) ) { case 0 : -- r ; case '$' : js_putc ( J , & sb , '$' ) ; break ; case '`' : js_putm ( J , & sb , source , s ) ; break ; case '\\'' : js_puts ( J , & sb , s + n ) ; break ; case '&' : js_putm ( J , & sb , s , s + n ) ; break ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : x = * r - '0' ; if ( r [ 1 ] >= '0' && r [ 1 ] <= '9' ) x = x * 10 + * ( ++ r ) - '0' ; if ( x > 0 && x < m . nsub ) { js_putm ( J , & sb , m . sub [ x ] . sp , m . sub [ x ] . ep ) ; } else { js_putc ( J , & sb , '$' ) ; if ( x > 10 ) { js_putc ( J , & sb , '0' + x / 10 ) ; js_putc ( J , & sb , '0' + x % 10 ) ; } else { js_putc ( J , & sb , '0' + x ) ; } } break ; default : js_putc ( J , & sb , '$' ) ; js_putc ( J , & sb , * r ) ; break ; } ++ r ; } else { js_putc ( J , & sb , * r ++ ) ; } } } if ( re -> flags & JS_REGEXP_G ) { source = m . sub [ 0 ] . ep ; if ( n == 0 ) { if ( * source ) js_putc ( J , & sb , * source ++ ) ; else goto end ; } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , source , & m , REG_NOTBOL ) ) <S2SV_EndBug> goto loop ; } end : js_puts ( J , & sb , s + n ) ; js_putc ( J , & sb , 0 ) ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } js_pushstring ( J , sb ? sb -> s : "" ) ; js_endtry ( J ) ; js_free ( J , sb ) ; }
CWE-200 <S2SV_StartBug> static inline int <S2SV_EndBug> addrs_in_same_network_family ( const tor_addr_t * a1 , const tor_addr_t * a2 ) { return 0 == tor_addr_compare_masked ( a1 , a2 , 16 , CMP_SEMANTIC ) ; }
CWE-119 static int dtls1_process_record ( SSL * s ) { int i , al ; int enc_err ; SSL_SESSION * sess ; SSL3_RECORD * rr ; unsigned int mac_size ; unsigned char md [ EVP_MAX_MD_SIZE ] ; rr = & ( s -> s3 -> rrec ) ; sess = s -> session ; rr -> input = & ( s -> packet [ DTLS1_RT_HEADER_LENGTH ] ) ; if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_ENCRYPTED_LENGTH_TOO_LONG ) ; goto f_err ; } rr -> data = rr -> input ; rr -> orig_len = rr -> length ; enc_err = s -> method -> ssl3_enc -> enc ( s , 0 ) ; if ( enc_err == 0 ) { rr -> length = 0 ; s -> packet_length = 0 ; goto err ; } # ifdef TLS_DEBUG printf ( "dec<S2SV_blank>%d\\n" , rr -> length ) ; { unsigned int z ; for ( z = 0 ; z < rr -> length ; z ++ ) printf ( "%02X%c" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } printf ( "\\n" ) ; # endif if ( ( sess != NULL ) && ( s -> enc_read_ctx != NULL ) && ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) ) { unsigned char * mac = NULL ; unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ; mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; if ( rr -> orig_len < mac_size || ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && rr -> orig_len < mac_size + 1 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) { mac = mac_tmp ; ssl3_cbc_copy_mac ( mac_tmp , rr , mac_size ) ; rr -> length -= mac_size ; } else { rr -> length -= mac_size ; mac = & rr -> data [ rr -> length ] ; } i = s -> method -> ssl3_enc -> mac ( s , md , 0 ) ; if ( i < 0 || mac == NULL || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) enc_err = - 1 ; if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) enc_err = - 1 ; } if ( enc_err < 0 ) { rr -> length = 0 ; s -> packet_length = 0 ; goto err ; } if ( s -> expand != NULL ) { if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ; goto f_err ; } if ( ! ssl3_do_uncompress ( s ) ) { al = SSL_AD_DECOMPRESSION_FAILURE ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_BAD_DECOMPRESSION ) ; goto f_err ; } } if ( rr -> length > SSL3_RT_MAX_PLAIN_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } rr -> off = 0 ; s -> packet_length = 0 ; <S2SV_StartBug> dtls1_record_bitmap_update ( s , & ( s -> d1 -> bitmap ) ) ; <S2SV_EndBug> return ( 1 ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( 0 ) ; }
CWE-000 void ff_h264_free_tables ( H264Context * h , int free_rbsp ) { int i ; H264Context * hx ; av_freep ( & h -> intra4x4_pred_mode ) ; av_freep ( & h -> chroma_pred_mode_table ) ; av_freep ( & h -> cbp_table ) ; av_freep ( & h -> mvd_table [ 0 ] ) ; av_freep ( & h -> mvd_table [ 1 ] ) ; av_freep ( & h -> direct_table ) ; av_freep ( & h -> non_zero_count ) ; av_freep ( & h -> slice_table_base ) ; h -> slice_table = NULL ; av_freep ( & h -> list_counts ) ; av_freep ( & h -> mb2b_xy ) ; av_freep ( & h -> mb2br_xy ) ; av_buffer_pool_uninit ( & h -> qscale_table_pool ) ; av_buffer_pool_uninit ( & h -> mb_type_pool ) ; av_buffer_pool_uninit ( & h -> motion_val_pool ) ; av_buffer_pool_uninit ( & h -> ref_index_pool ) ; if ( free_rbsp && h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) ff_h264_unref_picture ( h , & h -> DPB [ i ] ) ; <S2SV_StartBug> av_freep ( & h -> DPB ) ; <S2SV_EndBug> } else if ( h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) h -> DPB [ i ] . needs_realloc = 1 ; } h -> cur_pic_ptr = NULL ; for ( i = 0 ; i < H264_MAX_THREADS ; i ++ ) { hx = h -> thread_context [ i ] ; if ( ! hx ) continue ; av_freep ( & hx -> top_borders [ 1 ] ) ; av_freep ( & hx -> top_borders [ 0 ] ) ; av_freep ( & hx -> bipred_scratchpad ) ; av_freep ( & hx -> edge_emu_buffer ) ; av_freep ( & hx -> dc_val_base ) ; av_freep ( & hx -> er . mb_index2xy ) ; av_freep ( & hx -> er . error_status_table ) ; av_freep ( & hx -> er . er_temp_buffer ) ; av_freep ( & hx -> er . mbintra_table ) ; av_freep ( & hx -> er . mbskip_table ) ; if ( free_rbsp ) { av_freep ( & hx -> rbsp_buffer [ 1 ] ) ; av_freep ( & hx -> rbsp_buffer [ 0 ] ) ; hx -> rbsp_buffer_size [ 0 ] = 0 ; hx -> rbsp_buffer_size [ 1 ] = 0 ; } if ( i ) av_freep ( & h -> thread_context [ i ] ) ; } }
CWE-000 static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , <S2SV_StartBug> struct iovec * iovec ) <S2SV_EndBug> { if ( unlikely ( ! access_ok ( ! rw , buf , len ) ) ) return - EFAULT ; iovec -> iov_base = buf ; iovec -> iov_len = len ; * nr_segs = 1 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-119 int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) <S2SV_StartBug> return luaL_argerror ( L , 0 , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; <S2SV_EndBug> buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { lua_pushvalue ( L , i ) ; mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }
CWE-264 struct crypto_template * crypto_lookup_template ( const char * name ) { <S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , "%s" , <S2SV_EndBug> name ) ; }
CWE-20 static int do_anonymous_page ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags ) { struct mem_cgroup * memcg ; struct page * page ; spinlock_t * ptl ; pte_t entry ; pte_unmap ( page_table ) ; <S2SV_StartBug> if ( check_stack_guard_page ( vma , address ) < 0 ) <S2SV_EndBug> return VM_FAULT_SIGSEGV ; if ( ! ( flags & FAULT_FLAG_WRITE ) && ! mm_forbids_zeropage ( mm ) ) { entry = pte_mkspecial ( pfn_pte ( my_zero_pfn ( address ) , vma -> vm_page_prot ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto unlock ; goto setpte ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) goto oom ; page = alloc_zeroed_user_highpage_movable ( vma , address ) ; if ( ! page ) goto oom ; if ( mem_cgroup_try_charge ( page , mm , GFP_KERNEL , & memcg ) ) goto oom_free_page ; __SetPageUptodate ( page ) ; entry = mk_pte ( page , vma -> vm_page_prot ) ; if ( vma -> vm_flags & VM_WRITE ) entry = pte_mkwrite ( pte_mkdirty ( entry ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto release ; inc_mm_counter_fast ( mm , MM_ANONPAGES ) ; page_add_new_anon_rmap ( page , vma , address ) ; mem_cgroup_commit_charge ( page , memcg , false ) ; lru_cache_add_active_or_unevictable ( page , vma ) ; setpte : set_pte_at ( mm , address , page_table , entry ) ; update_mmu_cache ( vma , address , page_table ) ; unlock : pte_unmap_unlock ( page_table , ptl ) ; return 0 ; release : mem_cgroup_cancel_charge ( page , memcg ) ; page_cache_release ( page ) ; goto unlock ; oom_free_page : page_cache_release ( page ) ; oom : return VM_FAULT_OOM ; }
CWE-125 int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { <S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> if ( bytes_matched + i >= max_bytes_matched ) <S2SV_StartBug> break ; <S2SV_EndBug> if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug> break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
CWE-000 static void * bpf_obj_do_get ( const struct filename * pathname , enum bpf_type * type ) { struct inode * inode ; struct path path ; void * raw ; int ret ; ret = kern_path ( pathname -> name , LOOKUP_FOLLOW , & path ) ; if ( ret ) return ERR_PTR ( ret ) ; inode = d_backing_inode ( path . dentry ) ; ret = inode_permission ( inode , MAY_WRITE ) ; if ( ret ) goto out ; ret = bpf_inode_type ( inode , type ) ; if ( ret ) goto out ; raw = bpf_any_get ( inode -> i_private , * type ) ; <S2SV_StartBug> touch_atime ( & path ) ; <S2SV_EndBug> path_put ( & path ) ; return raw ; out : path_put ( & path ) ; return ERR_PTR ( ret ) ; }
CWE-476 static int peer_recv_callback ( rdpTransport * transport , wStream * s , void * extra ) { freerdp_peer * client = ( freerdp_peer * ) extra ; rdpRdp * rdp = client -> context -> rdp ; switch ( rdp -> state ) { case CONNECTION_STATE_INITIAL : if ( ! rdp_server_accept_nego ( rdp , s ) ) return - 1 ; if ( rdp -> nego -> selected_protocol & PROTOCOL_NLA ) { sspi_CopyAuthIdentity ( & client -> identity , & ( rdp -> nego -> transport -> credssp -> identity ) ) ; IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , TRUE ) ; credssp_free ( rdp -> nego -> transport -> credssp ) ; <S2SV_StartBug> } <S2SV_EndBug> else { IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , FALSE ) ; } break ; case CONNECTION_STATE_NEGO : if ( ! rdp_server_accept_mcs_connect_initial ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CONNECT : if ( ! rdp_server_accept_mcs_erect_domain_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ERECT_DOMAIN : if ( ! rdp_server_accept_mcs_attach_user_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ATTACH_USER : if ( ! rdp_server_accept_mcs_channel_join_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CHANNEL_JOIN : if ( rdp -> settings -> DisableEncryption ) { if ( ! rdp_server_accept_client_keys ( rdp , s ) ) return - 1 ; break ; } rdp -> state = CONNECTION_STATE_ESTABLISH_KEYS ; case CONNECTION_STATE_ESTABLISH_KEYS : if ( ! rdp_server_accept_client_info ( rdp , s ) ) return - 1 ; IFCALL ( client -> Capabilities , client ) ; if ( ! rdp_send_demand_active ( rdp ) ) return - 1 ; break ; case CONNECTION_STATE_LICENSE : if ( ! rdp_server_accept_confirm_active ( rdp , s ) ) { Stream_SetPosition ( s , 0 ) ; return peer_recv_pdu ( client , s ) ; } break ; case CONNECTION_STATE_ACTIVE : if ( peer_recv_pdu ( client , s ) < 0 ) return - 1 ; break ; default : fprintf ( stderr , "Invalid<S2SV_blank>state<S2SV_blank>%d\\n" , rdp -> state ) ; return - 1 ; } return 0 ; }
CWE-119 static int nci_extract_activation_params_iso_dep ( struct nci_dev * ndev , struct nci_rf_intf_activated_ntf * ntf , __u8 * data ) { struct activation_params_nfca_poll_iso_dep * nfca_poll ; struct activation_params_nfcb_poll_iso_dep * nfcb_poll ; switch ( ntf -> activation_rf_tech_and_mode ) { case NCI_NFC_A_PASSIVE_POLL_MODE : nfca_poll = & ntf -> activation_params . nfca_poll_iso_dep ; <S2SV_StartBug> nfca_poll -> rats_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( "rats_res_len<S2SV_blank>%d\\n" , nfca_poll -> rats_res_len ) ; if ( nfca_poll -> rats_res_len > 0 ) { memcpy ( nfca_poll -> rats_res , data , nfca_poll -> rats_res_len ) ; } break ; case NCI_NFC_B_PASSIVE_POLL_MODE : nfcb_poll = & ntf -> activation_params . nfcb_poll_iso_dep ; <S2SV_StartBug> nfcb_poll -> attrib_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( "attrib_res_len<S2SV_blank>%d\\n" , nfcb_poll -> attrib_res_len ) ; if ( nfcb_poll -> attrib_res_len > 0 ) { memcpy ( nfcb_poll -> attrib_res , data , nfcb_poll -> attrib_res_len ) ; } break ; default : pr_err ( "unsupported<S2SV_blank>activation_rf_tech_and_mode<S2SV_blank>0x%x\\n" , ntf -> activation_rf_tech_and_mode ) ; return NCI_STATUS_RF_PROTOCOL_ERROR ; } return NCI_STATUS_OK ; }
CWE-362 int snd_card_new ( struct device * parent , int idx , const char * xid , struct module * module , int extra_size , struct snd_card * * card_ret ) { struct snd_card * card ; int err ; if ( snd_BUG_ON ( ! card_ret ) ) return - EINVAL ; * card_ret = NULL ; if ( extra_size < 0 ) extra_size = 0 ; card = kzalloc ( sizeof ( * card ) + extra_size , GFP_KERNEL ) ; if ( ! card ) return - ENOMEM ; if ( extra_size > 0 ) card -> private_data = ( char * ) card + sizeof ( struct snd_card ) ; if ( xid ) strlcpy ( card -> id , xid , sizeof ( card -> id ) ) ; err = 0 ; mutex_lock ( & snd_card_mutex ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , module_slot_match , module ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , check_empty_slot , module ) ; if ( idx < 0 ) err = - ENODEV ; else if ( idx < snd_ecards_limit ) { if ( test_bit ( idx , snd_cards_lock ) ) err = - EBUSY ; } else if ( idx >= SNDRV_CARDS ) err = - ENODEV ; if ( err < 0 ) { mutex_unlock ( & snd_card_mutex ) ; dev_err ( parent , "cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>slot<S2SV_blank>for<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>(range<S2SV_blank>0-%i),<S2SV_blank>error:<S2SV_blank>%d\\n" , idx , snd_ecards_limit - 1 , err ) ; kfree ( card ) ; return err ; } set_bit ( idx , snd_cards_lock ) ; if ( idx >= snd_ecards_limit ) snd_ecards_limit = idx + 1 ; mutex_unlock ( & snd_card_mutex ) ; card -> dev = parent ; card -> number = idx ; card -> module = module ; INIT_LIST_HEAD ( & card -> devices ) ; init_rwsem ( & card -> controls_rwsem ) ; rwlock_init ( & card -> ctl_files_rwlock ) ; <S2SV_StartBug> INIT_LIST_HEAD ( & card -> controls ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & card -> ctl_files ) ; spin_lock_init ( & card -> files_lock ) ; INIT_LIST_HEAD ( & card -> files_list ) ; # ifdef CONFIG_PM mutex_init ( & card -> power_lock ) ; init_waitqueue_head ( & card -> power_sleep ) ; # endif device_initialize ( & card -> card_dev ) ; card -> card_dev . parent = parent ; card -> card_dev . class = sound_class ; card -> card_dev . release = release_card_device ; card -> card_dev . groups = card_dev_attr_groups ; err = kobject_set_name ( & card -> card_dev . kobj , "card%d" , idx ) ; if ( err < 0 ) goto __error ; err = snd_ctl_create ( card ) ; if ( err < 0 ) { dev_err ( parent , "unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>control<S2SV_blank>minors\\n" ) ; goto __error ; } err = snd_info_card_create ( card ) ; if ( err < 0 ) { dev_err ( parent , "unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>card<S2SV_blank>info\\n" ) ; goto __error_ctl ; } * card_ret = card ; return 0 ; __error_ctl : snd_device_free_all ( card ) ; __error : put_device ( & card -> card_dev ) ; return err ; }
CWE-264 void eval_js ( WebKitWebView * web_view , gchar * script , GString * result ) { WebKitWebFrame * frame ; JSGlobalContextRef context ; <S2SV_StartBug> JSObjectRef globalobject ; <S2SV_EndBug> JSStringRef var_name ; JSStringRef js_script ; JSValueRef js_result ; JSStringRef js_result_string ; size_t js_result_size ; js_init ( ) ; frame = webkit_web_view_get_main_frame ( WEBKIT_WEB_VIEW ( web_view ) ) ; context = webkit_web_frame_get_global_context ( frame ) ; <S2SV_StartBug> globalobject = JSContextGetGlobalObject ( context ) ; <S2SV_EndBug> var_name = JSStringCreateWithUTF8CString ( "Uzbl" ) ; JSObjectSetProperty ( context , globalobject , var_name , JSObjectMake ( context , uzbl . js . classref , NULL ) , kJSClassAttributeNone , NULL ) ; js_script = JSStringCreateWithUTF8CString ( script ) ; js_result = JSEvaluateScript ( context , js_script , globalobject , NULL , 0 , NULL ) ; if ( js_result && ! JSValueIsUndefined ( context , js_result ) ) { js_result_string = JSValueToStringCopy ( context , js_result , NULL ) ; js_result_size = JSStringGetMaximumUTF8CStringSize ( js_result_string ) ; if ( js_result_size ) { char js_result_utf8 [ js_result_size ] ; JSStringGetUTF8CString ( js_result_string , js_result_utf8 , js_result_size ) ; g_string_assign ( result , js_result_utf8 ) ; } JSStringRelease ( js_result_string ) ; } <S2SV_StartBug> JSObjectDeleteProperty ( context , globalobject , var_name , NULL ) ; <S2SV_EndBug> JSStringRelease ( var_name ) ; JSStringRelease ( js_script ) ; }
CWE-125 static void ip_optprint ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int option_len ; const char * sep = "" ; for ( ; length > 0 ; cp += option_len , length -= option_len ) { u_int option_code ; ND_PRINT ( ( ndo , "%s" , sep ) ) ; sep = "," ; ND_TCHECK ( * cp ) ; option_code = * cp ; ND_PRINT ( ( ndo , "%s" , tok2str ( ip_option_values , "unknown<S2SV_blank>%u" , option_code ) ) ) ; if ( option_code == IPOPT_NOP || option_code == IPOPT_EOL ) option_len = 1 ; else { ND_TCHECK ( cp [ 1 ] ) ; option_len = cp [ 1 ] ; if ( option_len < 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; return ; } } if ( option_len > length ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; return ; } ND_TCHECK2 ( * cp , option_len ) ; switch ( option_code ) { case IPOPT_EOL : return ; case IPOPT_TS : <S2SV_StartBug> ip_printts ( ndo , cp , option_len ) ; <S2SV_EndBug> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; <S2SV_StartBug> case IPOPT_RA : <S2SV_EndBug> if ( option_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; break ; } ND_TCHECK ( cp [ 3 ] ) ; if ( EXTRACT_16BITS ( & cp [ 2 ] ) != 0 ) ND_PRINT ( ( ndo , "<S2SV_blank>value<S2SV_blank>%u" , EXTRACT_16BITS ( & cp [ 2 ] ) ) ) ; break ; case IPOPT_NOP : case IPOPT_SECURITY : default : break ; } } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-200 static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; <S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }
CWE-119 static void t1mac_output_ascii ( char * s , int len ) { if ( blocktyp == POST_BINARY ) { output_current_post ( ) ; blocktyp = POST_ASCII ; } if ( len > 0 && s [ len - 1 ] == '\\n' ) s [ len - 1 ] = '\\r' ; t1mac_output_data ( ( byte * ) s , len ) ; if ( strncmp ( s , "/FontName" , 9 ) == 0 ) { <S2SV_StartBug> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <S2SV_EndBug> if ( * s == '/' ) { const char * t = ++ s ; <S2SV_StartBug> while ( * t && ! isspace ( * t ) ) t ++ ; <S2SV_EndBug> free ( font_name ) ; font_name = ( char * ) malloc ( t - s + 1 ) ; memcpy ( font_name , s , t - s ) ; font_name [ t - s ] = 0 ; } } }
CWE-264 static void vmx_set_msr_bitmap ( struct kvm_vcpu * vcpu ) { unsigned long * msr_bitmap ; if ( is_guest_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_nested ; <S2SV_StartBug> else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) { <S2SV_EndBug> if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode_x2apic ; else msr_bitmap = vmx_msr_bitmap_legacy_x2apic ; } else { if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode ; else msr_bitmap = vmx_msr_bitmap_legacy ; } vmcs_write64 ( MSR_BITMAP , __pa ( msr_bitmap ) ) ; }
CWE-000 static struct sock * tcp_v6_syn_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif struct flowi6 fl6 ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( ! newsk ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif <S2SV_StartBug> newnp -> ipv6_ac_list = NULL ; <S2SV_EndBug> newnp -> ipv6_fl_list = NULL ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } ireq = inet_rsk ( req ) ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_TCP ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( ! newsk ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; inet6_sk_rx_dst_set ( newsk , skb ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; <S2SV_StartBug> newinet -> inet_opt = NULL ; <S2SV_EndBug> newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; tcp_ca_openreq_child ( newsk , dst ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = tcp_mss_clamp ( tcp_sk ( sk ) , dst_metric_advmss ( dst ) ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG key = tcp_v6_md5_do_lookup ( sk , & newsk -> sk_v6_daddr ) ; if ( key ) { tcp_md5_do_add ( newsk , ( union tcp_md5_addr * ) & newsk -> sk_v6_daddr , AF_INET6 , key -> key , key -> keylen , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; tcp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req ) { tcp_move_syn ( newtp , req ) ; if ( ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) { tcp_v6_restore_cb ( newnp -> pktoptions ) ; skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } } } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : tcp_listendrop ( sk ) ; return NULL ; }
CWE-20 WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; <S2SV_StartBug> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <S2SV_EndBug> dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; WORD32 j ; UWORD8 u1_buf_mode ; struct MMCParams * ps_mmc_params ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst ; ps_slice -> u1_mmco_equalto5 = 0 ; { if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_slice -> u1_no_output_of_prior_pics_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>no_output_of_prior_pics_flag" , ps_slice -> u1_no_output_of_prior_pics_flag ) ; ps_slice -> u1_long_term_reference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>long_term_reference_flag" , ps_slice -> u1_long_term_reference_flag ) ; ps_dpb_cmds -> u1_idr_pic = 1 ; ps_dpb_cmds -> u1_no_output_of_prior_pics_flag = ps_slice -> u1_no_output_of_prior_pics_flag ; ps_dpb_cmds -> u1_long_term_reference_flag = ps_slice -> u1_long_term_reference_flag ; } else { u1_buf_mode = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>adaptive_ref_pic_buffering_flag" , u1_buf_mode ) ; ps_dpb_cmds -> u1_buf_mode = u1_buf_mode ; j = 0 ; if ( u1_buf_mode == 1 ) { UWORD32 u4_mmco ; UWORD32 u4_diff_pic_num ; UWORD32 u4_lt_idx , u4_max_lt_idx ; u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; while ( u4_mmco != END_OF_MMCO ) { if ( j >= MAX_REF_BUFS ) { # ifdef __ANDROID__ ALOGE ( "b/25818142" ) ; android_errorWriteLog ( 0x534e4554 , "25818142" ) ; # endif ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; } ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ; ps_mmc_params -> u4_mmco = u4_mmco ; switch ( u4_mmco ) { case MARK_ST_PICNUM_AS_NONREF : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; break ; case MARK_LT_INDEX_AS_NONREF : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case MARK_ST_PICNUM_AS_LT_INDEX : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case SET_MAX_LT_INDEX : { u4_max_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_max_lt_idx_plus1 = u4_max_lt_idx ; break ; } case RESET_REF_PICTURES : { ps_slice -> u1_mmco_equalto5 = 1 ; break ; } case SET_LT_INDEX : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; default : break ; } u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; j ++ ; } ps_dpb_cmds -> u1_num_of_commands = j ; } } ps_dpb_cmds -> u1_dpb_commands_read = 1 ; ps_dpb_cmds -> u1_dpb_commands_read_slc = 1 ; } u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst - u4_bit_ofst ; return u4_bit_ofst ; }
CWE-416 static long ion_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) { struct ion_client * client = filp -> private_data ; struct ion_device * dev = client -> dev ; struct ion_handle * cleanup_handle = NULL ; int ret = 0 ; unsigned int dir ; union { struct ion_fd_data fd ; struct ion_allocation_data allocation ; struct ion_handle_data handle ; struct ion_custom_data custom ; } data ; dir = ion_ioctl_dir ( cmd ) ; if ( _IOC_SIZE ( cmd ) > sizeof ( data ) ) return - EINVAL ; if ( dir & _IOC_WRITE ) if ( copy_from_user ( & data , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) return - EFAULT ; switch ( cmd ) { case ION_IOC_ALLOC : { struct ion_handle * handle ; handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . allocation . handle = handle -> id ; cleanup_handle = handle ; break ; } case ION_IOC_FREE : { struct ion_handle * handle ; <S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> return PTR_ERR ( handle ) ; <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ion_handle_put ( handle ) ; break ; } case ION_IOC_SHARE : case ION_IOC_MAP : { struct ion_handle * handle ; handle = ion_handle_get_by_id ( client , data . handle . handle ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . fd . fd = ion_share_dma_buf_fd ( client , handle ) ; ion_handle_put ( handle ) ; if ( data . fd . fd < 0 ) ret = data . fd . fd ; break ; } case ION_IOC_IMPORT : { struct ion_handle * handle ; handle = ion_import_dma_buf_fd ( client , data . fd . fd ) ; if ( IS_ERR ( handle ) ) ret = PTR_ERR ( handle ) ; else data . handle . handle = handle -> id ; break ; } case ION_IOC_SYNC : { ret = ion_sync_for_device ( client , data . fd . fd ) ; break ; } case ION_IOC_CUSTOM : { if ( ! dev -> custom_ioctl ) return - ENOTTY ; ret = dev -> custom_ioctl ( client , data . custom . cmd , data . custom . arg ) ; break ; } default : return - ENOTTY ; } if ( dir & _IOC_READ ) { if ( copy_to_user ( ( void __user * ) arg , & data , _IOC_SIZE ( cmd ) ) ) { if ( cleanup_handle ) ion_free ( client , cleanup_handle ) ; return - EFAULT ; } } return ret ; }
CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { size_t ss = CDF_SHORT_SEC_SIZE ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; <S2SV_StartBug> if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) { <S2SV_EndBug> DPRINTF ( ( "Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%" SIZE_T_FORMAT "u<S2SV_blank>><S2SV_blank>%" SIZE_T_FORMAT "u\\n" , <S2SV_StartBug> pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ; <S2SV_EndBug> return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }
CWE-000 static int pop_fetch_message ( struct Context * ctx , struct Message * msg , int msgno ) { void * uidl = NULL ; char buf [ LONG_STRING ] ; char path [ PATH_MAX ] ; struct Progress progressbar ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct PopCache * cache = NULL ; struct Header * h = ctx -> hdrs [ msgno ] ; unsigned short bcache = 1 ; <S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( msg -> fp ) return 0 ; cache = & pop_data -> cache [ h -> index % POP_CACHE_LEN ] ; if ( cache -> path ) { if ( cache -> index == h -> index ) { msg -> fp = fopen ( cache -> path , "r" ) ; if ( msg -> fp ) return 0 ; mutt_perror ( cache -> path ) ; return - 1 ; } else { unlink ( cache -> path ) ; FREE ( & cache -> path ) ; } } while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; if ( h -> refno < 0 ) { mutt_error ( _ ( "The<S2SV_blank>message<S2SV_blank>index<S2SV_blank>is<S2SV_blank>incorrect.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." ) ) ; return - 1 ; } mutt_progress_init ( & progressbar , _ ( "Fetching<S2SV_blank>message..." ) , MUTT_PROGRESS_SIZE , NetInc , h -> content -> length + h -> content -> offset - 1 ) ; <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( ! msg -> fp ) { bcache = 0 ; mutt_mktemp ( path , sizeof ( path ) ) ; msg -> fp = mutt_file_fopen ( path , "w+" ) ; if ( ! msg -> fp ) { mutt_perror ( path ) ; return - 1 ; } } snprintf ( buf , sizeof ( buf ) , "RETR<S2SV_blank>%d\\r\\n" , h -> refno ) ; const int ret = pop_fetch_data ( pop_data , buf , & progressbar , fetch_message , msg -> fp ) ; if ( ret == 0 ) break ; mutt_file_fclose ( & msg -> fp ) ; if ( ! bcache ) unlink ( path ) ; if ( ret == - 2 ) { mutt_error ( "%s" , pop_data -> err_msg ) ; return - 1 ; } if ( ret == - 3 ) { mutt_error ( _ ( "Can\'t<S2SV_blank>write<S2SV_blank>message<S2SV_blank>to<S2SV_blank>temporary<S2SV_blank>file!" ) ) ; return - 1 ; } } if ( bcache ) <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> else { cache -> index = h -> index ; cache -> path = mutt_str_strdup ( path ) ; } rewind ( msg -> fp ) ; uidl = h -> data ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_delete ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_remove ( ctx , h ) ; mutt_env_free ( & h -> env ) ; h -> env = mutt_rfc822_read_header ( msg -> fp , h , 0 , 0 ) ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_insert ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_add ( ctx , h ) ; h -> data = uidl ; h -> lines = 0 ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; while ( ! feof ( msg -> fp ) ) { ctx -> hdrs [ msgno ] -> lines ++ ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; } h -> content -> length = ftello ( msg -> fp ) - h -> content -> offset ; if ( ! WithCrypto ) h -> security = crypt_query ( h -> content ) ; mutt_clear_error ( ) ; rewind ( msg -> fp ) ; return 0 ; }
CWE-416 void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ; <S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 vpx_fixed_buf_t * vpx_codec_get_global_headers ( vpx_codec_ctx_t * ctx ) { vpx_fixed_buf_t * buf = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_glob_hdrs ) ctx -> err = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> buf = ctx -> iface -> enc . get_glob_hdrs ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> } return buf ; }
CWE-20 int bnep_add_connection ( struct bnep_connadd_req * req , struct socket * sock ) { struct net_device * dev ; struct bnep_session * s , * ss ; u8 dst [ ETH_ALEN ] , src [ ETH_ALEN ] ; int err ; BT_DBG ( "" ) ; <S2SV_StartBug> baswap ( ( void * ) dst , & l2cap_pi ( sock -> sk ) -> chan -> dst ) ; <S2SV_EndBug> baswap ( ( void * ) src , & l2cap_pi ( sock -> sk ) -> chan -> src ) ; dev = alloc_netdev ( sizeof ( struct bnep_session ) , ( * req -> device ) ? req -> device : "bnep%d" , NET_NAME_UNKNOWN , bnep_net_setup ) ; if ( ! dev ) return - ENOMEM ; down_write ( & bnep_session_sem ) ; ss = __bnep_get_session ( dst ) ; if ( ss && ss -> state == BT_CONNECTED ) { err = - EEXIST ; goto failed ; } s = netdev_priv ( dev ) ; memcpy ( s -> eh . h_dest , & src , ETH_ALEN ) ; memcpy ( s -> eh . h_source , & dst , ETH_ALEN ) ; memcpy ( dev -> dev_addr , s -> eh . h_dest , ETH_ALEN ) ; s -> dev = dev ; s -> sock = sock ; s -> role = req -> role ; s -> state = BT_CONNECTED ; s -> msg . msg_flags = MSG_NOSIGNAL ; # ifdef CONFIG_BT_BNEP_MC_FILTER set_bit ( bnep_mc_hash ( dev -> broadcast ) , ( ulong * ) & s -> mc_filter ) ; # endif # ifdef CONFIG_BT_BNEP_PROTO_FILTER bnep_set_default_proto_filter ( s ) ; # endif SET_NETDEV_DEV ( dev , bnep_get_device ( s ) ) ; SET_NETDEV_DEVTYPE ( dev , & bnep_type ) ; err = register_netdev ( dev ) ; if ( err ) goto failed ; __bnep_link_session ( s ) ; __module_get ( THIS_MODULE ) ; s -> task = kthread_run ( bnep_session , s , "kbnepd<S2SV_blank>%s" , dev -> name ) ; if ( IS_ERR ( s -> task ) ) { module_put ( THIS_MODULE ) ; unregister_netdev ( dev ) ; __bnep_unlink_session ( s ) ; err = PTR_ERR ( s -> task ) ; goto failed ; } up_write ( & bnep_session_sem ) ; strcpy ( req -> device , dev -> name ) ; return 0 ; failed : up_write ( & bnep_session_sem ) ; free_netdev ( dev ) ; return err ; }
CWE-190 static int fts3tokFilterMethod ( sqlite3_vtab_cursor * pCursor , int idxNum , const char * idxStr , int nVal , sqlite3_value * * apVal ) { int rc = SQLITE_ERROR ; Fts3tokCursor * pCsr = ( Fts3tokCursor * ) pCursor ; Fts3tokTable * pTab = ( Fts3tokTable * ) ( pCursor -> pVtab ) ; UNUSED_PARAMETER ( idxStr ) ; UNUSED_PARAMETER ( nVal ) ; fts3tokResetCursor ( pCsr ) ; if ( idxNum == 1 ) { const char * zByte = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nByte = sqlite3_value_bytes ( apVal [ 0 ] ) ; <S2SV_StartBug> pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; <S2SV_EndBug> if ( pCsr -> zInput == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pCsr -> zInput , zByte , nByte ) ; pCsr -> zInput [ nByte ] = 0 ; rc = pTab -> pMod -> xOpen ( pTab -> pTok , pCsr -> zInput , nByte , & pCsr -> pCsr ) ; if ( rc == SQLITE_OK ) { pCsr -> pCsr -> pTokenizer = pTab -> pTok ; } } } if ( rc != SQLITE_OK ) return rc ; return fts3tokNextMethod ( pCursor ) ; }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FieldOrderContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int h , plane , line_step , line_size , line ; uint8_t * data ; if ( ! frame -> interlaced_frame || frame -> top_field_first == s -> dst_tff ) return ff_filter_frame ( outlink , frame ) ; av_dlog ( ctx , "picture<S2SV_blank>will<S2SV_blank>move<S2SV_blank>%s<S2SV_blank>one<S2SV_blank>line\\n" , s -> dst_tff ? "up" : "down" ) ; h = frame -> height ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ; if ( s -> dst_tff ) { for ( line = 0 ; line < h ; line ++ ) { if ( 1 + line < frame -> height ) { memcpy ( data , data + line_step , line_size ) ; } else { memcpy ( data , data - line_step - line_step , line_size ) ; } data += line_step ; } } else { data += ( h - 1 ) * line_step ; for ( line = h - 1 ; line >= 0 ; line -- ) { if ( line > 0 ) { memcpy ( data , data - line_step , line_size ) ; } else { memcpy ( data , data + line_step + line_step , line_size ) ; } data -= line_step ; } } } frame -> top_field_first = s -> dst_tff ; return ff_filter_frame ( outlink , frame ) ; }
CWE-416 void fe_netjoin_deinit ( void ) { while ( joinservers != NULL ) netjoin_server_remove ( joinservers -> data ) ; if ( join_tag != - 1 ) { g_source_remove ( join_tag ) ; signal_remove ( "print<S2SV_blank>starting" , ( SIGNAL_FUNC ) sig_print_starting ) ; } signal_remove ( "setup<S2SV_blank>changed" , ( SIGNAL_FUNC ) read_settings ) ; <S2SV_StartBug> signal_remove ( "message<S2SV_blank>quit" , ( SIGNAL_FUNC ) msg_quit ) ; <S2SV_EndBug> signal_remove ( "message<S2SV_blank>join" , ( SIGNAL_FUNC ) msg_join ) ; signal_remove ( "message<S2SV_blank>irc<S2SV_blank>mode" , ( SIGNAL_FUNC ) msg_mode ) ; }
CWE-362 int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ; int shrink = ( attr -> ia_size <= inode -> i_size ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) return - EFBIG ; } if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( IS_I_VERSION ( inode ) && attr -> ia_size != inode -> i_size ) inode_inc_iversion ( inode ) ; if ( ext4_should_order_data ( inode ) && ( attr -> ia_size < inode -> i_size ) ) { error = ext4_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( error ) goto err_out ; } if ( attr -> ia_size != inode -> i_size ) { handle = ext4_journal_start ( inode , EXT4_HT_INODE , 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } if ( ext4_handle_valid ( handle ) && shrink ) { error = ext4_orphan_add ( handle , inode ) ; orphan = 1 ; } if ( ! shrink ) { inode -> i_mtime = ext4_current_time ( inode ) ; inode -> i_ctime = inode -> i_mtime ; } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; EXT4_I ( inode ) -> i_disksize = attr -> ia_size ; rc = ext4_mark_inode_dirty ( handle , inode ) ; if ( ! error ) error = rc ; if ( ! error ) i_size_write ( inode , attr -> ia_size ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_journal_stop ( handle ) ; if ( error ) { if ( orphan ) ext4_orphan_del ( NULL , inode ) ; goto err_out ; } } if ( ! shrink ) pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; if ( orphan ) { if ( ! ext4_should_journal_data ( inode ) ) { ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ext4_inode_resume_unlocked_dio ( inode ) ; } else ext4_wait_for_tail_page_commit ( inode ) ; } <S2SV_StartBug> truncate_pagecache ( inode , inode -> i_size ) ; <S2SV_EndBug> if ( shrink ) <S2SV_StartBug> ext4_truncate ( inode ) ; <S2SV_EndBug> } if ( ! rc ) { setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; } if ( orphan && inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; if ( ! rc && ( ia_valid & ATTR_MODE ) ) rc = posix_acl_chmod ( inode , inode -> i_mode ) ; err_out : ext4_std_error ( inode -> i_sb , error ) ; if ( ! error ) error = rc ; return error ; }
CWE-20 static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , "<S2SV_blank>wb-id:" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "\\"" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , "\\"" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , "%c%s:%u" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , ">" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }
CWE-476 static int dissect_usb_video_control_interface_descriptor ( proto_tree * parent_tree , tvbuff_t * tvb , guint8 descriptor_len , packet_info * pinfo , usb_conv_info_t * usb_conv_info ) { video_conv_info_t * video_conv_info = NULL ; video_entity_t * entity = NULL ; proto_item * item = NULL ; proto_item * subtype_item = NULL ; proto_tree * tree = NULL ; guint8 entity_id = 0 ; guint16 terminal_type = 0 ; int offset = 0 ; guint8 subtype ; subtype = tvb_get_guint8 ( tvb , offset + 2 ) ; if ( parent_tree ) { const gchar * subtype_str ; subtype_str = val_to_str_ext ( subtype , & vc_if_descriptor_subtypes_ext , "Unknown<S2SV_blank>(0x%x)" ) ; tree = proto_tree_add_subtree_format ( parent_tree , tvb , offset , descriptor_len , ett_descriptor_video_control , & item , "VIDEO<S2SV_blank>CONTROL<S2SV_blank>INTERFACE<S2SV_blank>DESCRIPTOR<S2SV_blank>[%s]" , subtype_str ) ; } dissect_usb_descriptor_header ( tree , tvb , offset , & vid_descriptor_type_vals_ext ) ; subtype_item = proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_subtype , tvb , offset + 2 , 1 , ENC_LITTLE_ENDIAN ) ; offset += 3 ; if ( subtype == VC_HEADER ) { guint8 num_vs_interfaces ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_bcdUVC , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_ifdesc_wTotalLength , tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_dwClockFrequency , tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; num_vs_interfaces = tvb_get_guint8 ( tvb , offset + 8 ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_bInCollection , tvb , offset + 8 , 1 , ENC_LITTLE_ENDIAN ) ; if ( num_vs_interfaces > 0 ) { proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_baInterfaceNr , tvb , offset + 9 , num_vs_interfaces , ENC_NA ) ; } offset += 9 + num_vs_interfaces ; } else if ( ( subtype == VC_INPUT_TERMINAL ) || ( subtype == VC_OUTPUT_TERMINAL ) ) { entity_id = tvb_get_guint8 ( tvb , offset ) ; terminal_type = tvb_get_letohs ( tvb , offset + 1 ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_terminal_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_terminal_type , tvb , offset + 1 , 2 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_assoc_terminal , tvb , offset + 3 , 1 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; if ( subtype == VC_OUTPUT_TERMINAL ) { proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_src_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; } proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_iTerminal , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; if ( subtype == VC_INPUT_TERMINAL ) { if ( terminal_type == ITT_CAMERA ) { offset = dissect_usb_video_camera_terminal ( tree , tvb , offset ) ; } else if ( terminal_type == ITT_MEDIA_TRANSPORT_INPUT ) { } } if ( subtype == VC_OUTPUT_TERMINAL ) { if ( terminal_type == OTT_MEDIA_TRANSPORT_OUTPUT ) { } } } else { entity_id = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_usb_vid_control_ifdesc_unit_id , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ++ offset ; if ( subtype == VC_PROCESSING_UNIT ) { offset = dissect_usb_video_processing_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_SELECTOR_UNIT ) { offset = dissect_usb_video_selector_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_EXTENSION_UNIT ) { offset = dissect_usb_video_extension_unit ( tree , tvb , offset ) ; } else if ( subtype == VC_ENCODING_UNIT ) { } else { expert_add_info_format ( pinfo , subtype_item , & ei_usb_vid_subtype_unknown , "Unknown<S2SV_blank>VC<S2SV_blank>subtype<S2SV_blank>%u" , subtype ) ; } } if ( offset < descriptor_len ) { proto_tree_add_item ( tree , hf_usb_vid_descriptor_data , tvb , offset , descriptor_len - offset , ENC_NA ) ; } if ( entity_id != 0 ) proto_item_append_text ( item , "<S2SV_blank>(Entity<S2SV_blank>%d)" , entity_id ) ; if ( subtype != VC_HEADER && usb_conv_info ) { usb_conv_info = get_usb_iface_conv_info ( pinfo , usb_conv_info -> interfaceNum ) ; video_conv_info = ( video_conv_info_t * ) usb_conv_info -> class_data ; if ( ! video_conv_info ) { video_conv_info = wmem_new ( wmem_file_scope ( ) , video_conv_info_t ) ; video_conv_info -> entities = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = video_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> entity = ( video_entity_t * ) wmem_tree_lookup32 ( video_conv_info -> entities , entity_id ) ; if ( ! entity ) { entity = wmem_new ( wmem_file_scope ( ) , video_entity_t ) ; entity -> entityID = entity_id ; entity -> subtype = subtype ; entity -> terminalType = terminal_type ; wmem_tree_insert32 ( video_conv_info -> entities , entity_id , entity ) ; } } return descriptor_len ; }
CWE-000 static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , "w" ) ; if ( fp ) { fprintf ( fp , "\\n" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , "%s/.Xauthority" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { <S2SV_StartBug> fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n" ) ; <S2SV_EndBug> exit ( 1 ) ; } pid_t child = fork ( ) ; if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> if ( rv ) fprintf ( stderr , "Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n" ) ; else { fs_logger2 ( "clone" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) <S2SV_EndBug> errExit ( "fchown" ) ; if ( chmod ( dest , 0600 ) == - 1 ) errExit ( "fchmod" ) ; return 1 ; } return 0 ; }
CWE-119 static int http_read_header ( URLContext * h , int * new_location ) { HTTPContext * s = h -> priv_data ; char line [ MAX_URL_SIZE ] ; int err = 0 ; <S2SV_StartBug> s -> chunksize = - 1 ; <S2SV_EndBug> for ( ; ; ) { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; av_log ( h , AV_LOG_TRACE , "header=\'%s\'\\n" , line ) ; err = process_line ( h , line , s -> line_count , new_location ) ; if ( err < 0 ) return err ; if ( err == 0 ) break ; s -> line_count ++ ; } if ( s -> seekable == - 1 && s -> is_mediagateway && s -> filesize == 2000000000 ) h -> is_streamed = 1 ; cookie_string ( s -> cookie_dict , & s -> cookies ) ; av_dict_free ( & s -> cookie_dict ) ; return err ; }
CWE-119 static int set_register ( pegasus_t * pegasus , __u16 indx , __u8 data ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data , <S2SV_StartBug> indx , & data , 1 , 1000 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , "%s<S2SV_blank>returned<S2SV_blank>%d\\n" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-200 static int llc_ui_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddrlen , int peer ) { struct sockaddr_llc sllc ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; <S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> memset ( & sllc , 0 , sizeof ( sllc ) ) ; lock_sock ( sk ) ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; <S2SV_StartBug> * uaddrlen = sizeof ( sllc ) ; <S2SV_EndBug> memset ( uaddr , 0 , * uaddrlen ) ; if ( peer ) { rc = - ENOTCONN ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; if ( llc -> dev ) sllc . sllc_arphrd = llc -> dev -> type ; sllc . sllc_sap = llc -> daddr . lsap ; memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ) ; } else { rc = - EINVAL ; if ( ! llc -> sap ) goto out ; sllc . sllc_sap = llc -> sap -> laddr . lsap ; if ( llc -> dev ) { sllc . sllc_arphrd = llc -> dev -> type ; memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ) ; } } rc = 0 ; sllc . sllc_family = AF_LLC ; memcpy ( uaddr , & sllc , sizeof ( sllc ) ) ; out : release_sock ( sk ) ; return rc ; }
CWE-20 static int net_ctl_permissions ( struct ctl_table_header * head , struct ctl_table * table ) { struct net * net = container_of ( head -> set , struct net , sysctls ) ; kuid_t root_uid = make_kuid ( net -> user_ns , 0 ) ; kgid_t root_gid = make_kgid ( net -> user_ns , 0 ) ; if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || <S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 6 ) & 7 ; return ( mode << 6 ) | ( mode << 3 ) | mode ; } <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 3 ) & 7 ; return ( mode << 3 ) | mode ; } return table -> mode ; }
CWE-200 static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }
CWE-119 void vpx_img_write ( const vpx_image_t * img , FILE * file ) { int plane ; for ( plane = 0 ; plane < 3 ; ++ plane ) { const unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; <S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> const int h = vpx_img_plane_height ( img , plane ) ; int y ; for ( y = 0 ; y < h ; ++ y ) { fwrite ( buf , 1 , w , file ) ; buf += stride ; } } }
CWE-125 static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s" , tok2str ( ubik_req , "op#%d" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , "<S2SV_blank>syncsite<S2SV_blank>%s" , temp ? "yes" : "no" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>votestart" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>dbversion" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , "<S2SV_blank>site" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>pos" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>length" ) ) ; INTOUT ( ) ; <S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , "type<S2SV_blank>%d" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>pos" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>length" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>dbversion" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>length" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>oldversion" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>newversion" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|ubik]" ) ) ; }
CWE-000 static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || <S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }
CWE-284 ssize_t socket_write_and_transfer_fd ( const socket_t * socket , const void * buf , size_t count , int fd ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; if ( fd == INVALID_FD ) return socket_write ( socket , buf , count ) ; struct msghdr msg ; struct iovec iov ; char control_buf [ CMSG_SPACE ( sizeof ( int ) ) ] ; iov . iov_base = ( void * ) buf ; iov . iov_len = count ; msg . msg_iov = & iov ; msg . msg_iovlen = 1 ; msg . msg_control = control_buf ; msg . msg_controllen = sizeof ( control_buf ) ; msg . msg_name = NULL ; msg . msg_namelen = 0 ; struct cmsghdr * header = CMSG_FIRSTHDR ( & msg ) ; header -> cmsg_level = SOL_SOCKET ; header -> cmsg_type = SCM_RIGHTS ; header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; * ( int * ) CMSG_DATA ( header ) = fd ; <S2SV_StartBug> ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ; <S2SV_EndBug> close ( fd ) ; return ret ; }
CWE-416 static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) <S2SV_StartBug> { <S2SV_EndBug> if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) { if ( ! ctx -> might_cancel ) { ctx -> might_cancel = true ; spin_lock ( & cancel_lock ) ; list_add_rcu ( & ctx -> clist , & cancel_list ) ; spin_unlock ( & cancel_lock ) ; } <S2SV_StartBug> } else if ( ctx -> might_cancel ) { <S2SV_EndBug> timerfd_remove_cancel ( ctx ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-362 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
CWE-200 static int isofs_export_encode_fh ( struct inode * inode , __u32 * fh32 , int * max_len , struct inode * parent ) { struct iso_inode_info * ei = ISOFS_I ( inode ) ; int len = * max_len ; int type = 1 ; __u16 * fh16 = ( __u16 * ) fh32 ; if ( parent && ( len < 5 ) ) { * max_len = 5 ; return 255 ; } else if ( len < 3 ) { * max_len = 3 ; return 255 ; } len = 3 ; fh32 [ 0 ] = ei -> i_iget5_block ; fh16 [ 2 ] = ( __u16 ) ei -> i_iget5_offset ; <S2SV_StartBug> fh32 [ 2 ] = inode -> i_generation ; <S2SV_EndBug> if ( parent ) { struct iso_inode_info * eparent ; eparent = ISOFS_I ( parent ) ; fh32 [ 3 ] = eparent -> i_iget5_block ; fh16 [ 3 ] = ( __u16 ) eparent -> i_iget5_offset ; fh32 [ 4 ] = parent -> i_generation ; len = 5 ; type = 2 ; } * max_len = len ; return type ; }
CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
CWE-119 <S2SV_StartBug> int mutt_b64_decode ( char * out , const char * in ) <S2SV_EndBug> { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ; <S2SV_StartBug> * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; <S2SV_EndBug> len ++ ; if ( digit3 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; <S2SV_EndBug> len ++ ; if ( digit4 != '=' ) { <S2SV_StartBug> * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; <S2SV_EndBug> len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }
CWE-264 static struct cifsSesInfo * <S2SV_StartBug> cifs_find_smb_ses ( struct TCP_Server_Info * server , char * username ) <S2SV_EndBug> { struct list_head * tmp ; struct cifsSesInfo * ses ; write_lock ( & cifs_tcp_ses_lock ) ; <S2SV_StartBug> list_for_each ( tmp , & server -> smb_ses_list ) { <S2SV_EndBug> ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ; <S2SV_StartBug> if ( strncmp ( ses -> userName , username , MAX_USERNAME_SIZE ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> ++ ses -> ses_count ; write_unlock ( & cifs_tcp_ses_lock ) ; return ses ; } write_unlock ( & cifs_tcp_ses_lock ) ; return NULL ; }
CWE-119 static __u8 * mr_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <S2SV_EndBug> hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc [ 30 ] = 0x0c ; } return rdesc ; }
CWE-119 void vp8_default_bmode_probs ( vp8_prob p [ VP8_BINTRAMODES - 1 ] ) { <S2SV_StartBug> vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ; <S2SV_EndBug> }
CWE-20 static unsigned long ioapic_read_indirect ( struct kvm_ioapic * ioapic , unsigned long addr , unsigned long length ) { unsigned long result = 0 ; switch ( ioapic -> ioregsel ) { case IOAPIC_REG_VERSION : result = ( ( ( ( IOAPIC_NUM_PINS - 1 ) & 0xff ) << 16 ) | ( IOAPIC_VERSION_ID & 0xff ) ) ; break ; case IOAPIC_REG_APIC_ID : case IOAPIC_REG_ARB_ID : result = ( ( ioapic -> id & 0xf ) << 24 ) ; break ; default : { u32 redir_index = ( ioapic -> ioregsel - 0x10 ) >> 1 ; u64 redir_content ; <S2SV_StartBug> ASSERT ( redir_index < IOAPIC_NUM_PINS ) ; <S2SV_EndBug> <S2SV_StartBug> redir_content = ioapic -> redirtbl [ redir_index ] . bits ; <S2SV_EndBug> result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ; break ; } } return result ; }
CWE-200 int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_StartBug> bool slow ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
CWE-416 struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) { struct tcp_options_received tcp_opt ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct dst_entry * dst ; __u8 rcv_wscale ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) ) goto out ; mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; if ( mss == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; if ( ! cookie_timestamp_decode ( & tcp_opt ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> tfo_listener = false ; if ( security_inet_conn_request ( sk , skb , req ) ) goto out_free ; req -> mss = mss ; ireq -> ir_rmt_port = th -> source ; ireq -> ir_num = ntohs ( th -> dest ) ; ireq -> ir_v6_rmt_addr = ipv6_hdr ( skb ) -> saddr ; ireq -> ir_v6_loc_addr = ipv6_hdr ( skb ) -> daddr ; if ( ipv6_opt_accepted ( sk , skb , & TCP_SKB_CB ( skb ) -> header . h6 ) || np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo || np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) { atomic_inc ( & skb -> users ) ; ireq -> pktopts = skb ; } ireq -> ir_iif = sk -> sk_bound_dev_if ; if ( ! sk -> sk_bound_dev_if && ipv6_addr_type ( & ireq -> ir_v6_rmt_addr ) & IPV6_ADDR_LINKLOCAL ) ireq -> ir_iif = tcp_v6_iif ( skb ) ; ireq -> ir_mark = inet_request_mark ( sk , skb ) ; req -> num_retrans = 0 ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; treq -> snt_synack . v64 = 0 ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_TCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = ireq -> ir_mark ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = inet_sk ( sk ) -> inet_sport ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) goto out_free ; } req -> rsk_window_clamp = tp -> window_clamp ? : dst_metric ( dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rsk_rcv_wnd , & req -> rsk_window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ireq -> ecn_ok = cookie_ecn_ok ( & tcp_opt , sock_net ( sk ) , dst ) ; ret = tcp_get_cookie_sock ( sk , skb , req , dst ) ; out : return ret ; out_free : reqsk_free ( req ) ; return NULL ; }
CWE-119 void mp_encode_lua_table_as_array ( lua_State * L , mp_buf * buf , int level ) { # if LUA_VERSION_NUM < 502 size_t len = lua_objlen ( L , - 1 ) , j ; # else size_t len = lua_rawlen ( L , - 1 ) , j ; # endif mp_encode_array ( L , buf , len ) ; <S2SV_StartBug> for ( j = 1 ; j <= len ; j ++ ) { <S2SV_EndBug> lua_pushnumber ( L , j ) ; lua_gettable ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }
CWE-125 void wb_print ( netdissect_options * ndo , register const void * hdr , register u_int len ) { register const struct pkt_hdr * ph ; ph = ( const struct pkt_hdr * ) hdr ; if ( len < sizeof ( * ph ) || ! ND_TTEST ( * ph ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; } len -= sizeof ( * ph ) ; if ( ph -> ph_flags ) ND_PRINT ( ( ndo , "*" ) ) ; switch ( ph -> ph_type ) { case PT_KILL : ND_PRINT ( ( ndo , "<S2SV_blank>wb-kill" ) ) ; return ; case PT_ID : if ( wb_id ( ndo , ( const struct pkt_id * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_RREQ : if ( wb_rreq ( ndo , ( const struct pkt_rreq * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_RREP : if ( wb_rrep ( ndo , ( const struct pkt_rrep * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_DRAWOP : if ( wb_drawop ( ndo , ( const struct pkt_dop * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_PREQ : if ( wb_preq ( ndo , ( const struct pkt_preq * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_PREP : if ( wb_prep ( ndo , ( const struct pkt_prep * ) ( ph + 1 ) , len ) >= 0 ) <S2SV_StartBug> return ; <S2SV_EndBug> break ; default : ND_PRINT ( ( ndo , "<S2SV_blank>wb-%d!" , ph -> ph_type ) ) ; return ; } }
CWE-416 static int dccp_v6_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; <S2SV_StartBug> struct in6_addr * saddr = NULL , * final_p , final ; <S2SV_EndBug> struct flowi6 fl6 ; struct dst_entry * dst ; int addr_type ; int err ; dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; IP6_ECN_flow_init ( fl6 . flowlabel ) ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { struct ip6_flowlabel * flowlabel ; flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; fl6_sock_release ( flowlabel ) ; } } if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ; addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) return - EINVAL ; sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if ) return - EINVAL ; } sk -> sk_v6_daddr = usin -> sin6_addr ; np -> flow_label = fl6 . flowlabel ; if ( addr_type == IPV6_ADDR_MAPPED ) { u32 exthdrlen = icsk -> icsk_ext_hdr_len ; struct sockaddr_in sin ; SOCK_DEBUG ( sk , "connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\n" ) ; if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ; sin . sin_family = AF_INET ; sin . sin_port = usin -> sin6_port ; sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ; icsk -> icsk_af_ops = & dccp_ipv6_mapped ; sk -> sk_backlog_rcv = dccp_v4_do_rcv ; err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; if ( err ) { icsk -> icsk_ext_hdr_len = exthdrlen ; icsk -> icsk_af_ops = & dccp_ipv6_af_ops ; sk -> sk_backlog_rcv = dccp_v6_do_rcv ; goto failure ; } np -> saddr = sk -> sk_v6_rcv_saddr ; return err ; } if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) saddr = & sk -> sk_v6_rcv_saddr ; fl6 . flowi6_proto = IPPROTO_DCCP ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = saddr ? * saddr : np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = usin -> sin6_port ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto failure ; } if ( saddr == NULL ) { saddr = & fl6 . saddr ; sk -> sk_v6_rcv_saddr = * saddr ; } np -> saddr = * saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; __ip6_dst_store ( sk , dst , NULL , NULL ) ; icsk -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> icsk -> icsk_ext_hdr_len = ( np -> opt -> opt_flen + <S2SV_EndBug> <S2SV_StartBug> np -> opt -> opt_nflen ) ; <S2SV_EndBug> inet -> inet_dport = usin -> sin6_port ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet6_hash_connect ( & dccp_death_row , sk ) ; if ( err ) goto late_failure ; dp -> dccps_iss = secure_dccpv6_sequence_number ( np -> saddr . s6_addr32 , sk -> sk_v6_daddr . s6_addr32 , inet -> inet_sport , inet -> inet_dport ) ; err = dccp_connect ( sk ) ; if ( err ) goto late_failure ; return 0 ; late_failure : dccp_set_state ( sk , DCCP_CLOSED ) ; __sk_dst_reset ( sk ) ; failure : inet -> inet_dport = 0 ; sk -> sk_route_caps = 0 ; return err ; }
CWE-125 static INT AirPDcapDecryptWPABroadcastKey ( const EAPOL_RSN_KEY * pEAPKey , guint8 * decryption_key , PAIRPDCAP_SEC_ASSOCIATION sa , guint eapol_len ) { guint8 key_version ; guint8 * key_data ; guint8 * szEncryptedKey ; guint16 key_bytes_len = 0 ; guint16 key_len ; static AIRPDCAP_KEY_ITEM dummy_key ; AIRPDCAP_SEC_ASSOCIATION * tmp_sa ; key_version = AIRPDCAP_EAP_KEY_DESCR_VER ( pEAPKey -> key_information [ 1 ] ) ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_length ) ; } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_data_len ) ; if ( key_bytes_len < 16 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } } <S2SV_StartBug> if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) { <S2SV_EndBug> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } key_data = ( guint8 * ) pEAPKey + sizeof ( EAPOL_RSN_KEY ) ; szEncryptedKey = ( guint8 * ) g_memdup ( key_data , key_bytes_len ) ; DEBUG_DUMP ( "Encrypted<S2SV_blank>Broadcast<S2SV_blank>key:" , szEncryptedKey , key_bytes_len ) ; DEBUG_DUMP ( "KeyIV:" , pEAPKey -> key_iv , 16 ) ; DEBUG_DUMP ( "decryption_key:" , decryption_key , 16 ) ; tmp_sa = ( AIRPDCAP_SEC_ASSOCIATION * ) g_malloc ( sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { guint8 new_key [ 32 ] ; guint8 dummy [ 256 ] ; rc4_state_struct rc4_state ; sa -> wpa . key_ver = ( key_bytes_len >= TKIP_GROUP_KEY_LEN ) ? AIRPDCAP_WPA_KEY_VER_NOT_CCMP : AIRPDCAP_WPA_KEY_VER_AES_CCMP ; memcpy ( new_key , pEAPKey -> key_iv , 16 ) ; memcpy ( new_key + 16 , decryption_key , 16 ) ; DEBUG_DUMP ( "FullDecrKey:" , new_key , 32 ) ; crypt_rc4_init ( & rc4_state , new_key , sizeof ( new_key ) ) ; crypt_rc4 ( & rc4_state , dummy , 256 ) ; crypt_rc4 ( & rc4_state , szEncryptedKey , key_bytes_len ) ; } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { guint8 key_found ; guint8 key_length ; guint16 key_index ; guint8 * decrypted_data ; decrypted_data = AES_unwrap ( decryption_key , 16 , szEncryptedKey , key_bytes_len ) ; key_found = FALSE ; key_index = 0 ; while ( key_index < ( key_bytes_len - 6 ) && ! key_found ) { guint8 rsn_id ; guint32 type ; rsn_id = decrypted_data [ key_index ] ; type = ( ( decrypted_data [ key_index + 2 ] << 24 ) + ( decrypted_data [ key_index + 3 ] << 16 ) + ( decrypted_data [ key_index + 4 ] << 8 ) + ( decrypted_data [ key_index + 5 ] ) ) ; if ( rsn_id == 0xdd && type == 0x000fac01 ) { key_found = TRUE ; } else { key_index += decrypted_data [ key_index + 1 ] + 2 ; } } if ( key_found ) { key_length = decrypted_data [ key_index + 1 ] - 6 ; if ( key_index + 8 >= key_bytes_len || key_length > key_bytes_len - key_index - 8 ) { g_free ( decrypted_data ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( szEncryptedKey , decrypted_data + key_index + 8 , key_length ) ; } else { g_free ( decrypted_data ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( key_length == TKIP_GROUP_KEY_LEN ) sa -> wpa . key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP ; else sa -> wpa . key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP ; g_free ( decrypted_data ) ; } key_len = ( sa -> wpa . key_ver == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) ? TKIP_GROUP_KEY_LEN : CCMP_GROUP_KEY_LEN ; if ( key_len > key_bytes_len ) { g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } DEBUG_DUMP ( "Broadcast<S2SV_blank>key:" , szEncryptedKey , key_len ) ; sa -> key = & dummy_key ; sa -> validKey = TRUE ; memset ( sa -> wpa . ptk , 0 , sizeof ( sa -> wpa . ptk ) ) ; memcpy ( sa -> wpa . ptk + 32 , szEncryptedKey , key_len ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; }
CWE-125 static inline signed short ReadPropertySignedShort ( const EndianType endian , const unsigned char * buffer ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; unsigned short value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; } <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
CWE-000 static inline int handle_dots ( struct nameidata * nd , int type ) { if ( type == LAST_DOTDOT ) { if ( nd -> flags & LOOKUP_RCU ) { return follow_dotdot_rcu ( nd ) ; } else <S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> } return 0 ; }
CWE-416 static int packet_set_ring ( struct sock * sk , union tpacket_req_u * req_u , int closing , int tx_ring ) { struct pgv * pg_vec = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; int was_running , order = 0 ; struct packet_ring_buffer * rb ; struct sk_buff_head * rb_queue ; __be16 num ; int err = - EINVAL ; <S2SV_StartBug> struct tpacket_req * req = & req_u -> req ; <S2SV_EndBug> if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) { net_warn_ratelimited ( "Tx-ring<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported.\\n" ) ; goto out ; } rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ; rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ; err = - EBUSY ; if ( ! closing ) { if ( atomic_read ( & po -> mapped ) ) goto out ; if ( packet_read_pending ( rb ) ) goto out ; } if ( req -> tp_block_nr ) { err = - EBUSY ; if ( unlikely ( rb -> pg_vec ) ) goto out ; switch ( po -> tp_version ) { case TPACKET_V1 : po -> tp_hdrlen = TPACKET_HDRLEN ; break ; case TPACKET_V2 : po -> tp_hdrlen = TPACKET2_HDRLEN ; break ; case TPACKET_V3 : po -> tp_hdrlen = TPACKET3_HDRLEN ; break ; } err = - EINVAL ; if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) goto out ; if ( unlikely ( ! PAGE_ALIGNED ( req -> tp_block_size ) ) ) goto out ; if ( po -> tp_version >= TPACKET_V3 && ( int ) ( req -> tp_block_size - BLK_PLUS_PRIV ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) goto out ; if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + po -> tp_reserve ) ) goto out ; if ( unlikely ( req -> tp_frame_size & ( TPACKET_ALIGNMENT - 1 ) ) ) goto out ; rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ; if ( unlikely ( rb -> frames_per_block == 0 ) ) goto out ; if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != req -> tp_frame_nr ) ) goto out ; err = - ENOMEM ; order = get_order ( req -> tp_block_size ) ; pg_vec = alloc_pg_vec ( req , order ) ; if ( unlikely ( ! pg_vec ) ) goto out ; switch ( po -> tp_version ) { case TPACKET_V3 : if ( ! tx_ring ) init_prb_bdqc ( po , rb , pg_vec , req_u ) ; break ; default : break ; } } else { err = - EINVAL ; if ( unlikely ( req -> tp_frame_nr ) ) goto out ; } <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> spin_lock ( & po -> bind_lock ) ; was_running = po -> running ; num = po -> num ; if ( was_running ) { po -> num = 0 ; __unregister_prot_hook ( sk , false ) ; } spin_unlock ( & po -> bind_lock ) ; synchronize_net ( ) ; err = - EBUSY ; mutex_lock ( & po -> pg_vec_lock ) ; if ( closing || atomic_read ( & po -> mapped ) == 0 ) { err = 0 ; spin_lock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec , pg_vec ) ; rb -> frame_max = ( req -> tp_frame_nr - 1 ) ; rb -> head = 0 ; rb -> frame_size = req -> tp_frame_size ; spin_unlock_bh ( & rb_queue -> lock ) ; swap ( rb -> pg_vec_order , order ) ; swap ( rb -> pg_vec_len , req -> tp_block_nr ) ; rb -> pg_vec_pages = req -> tp_block_size / PAGE_SIZE ; po -> prot_hook . func = ( po -> rx_ring . pg_vec ) ? tpacket_rcv : packet_rcv ; skb_queue_purge ( rb_queue ) ; if ( atomic_read ( & po -> mapped ) ) pr_err ( "packet_mmap:<S2SV_blank>vma<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>%d\\n" , atomic_read ( & po -> mapped ) ) ; } mutex_unlock ( & po -> pg_vec_lock ) ; spin_lock ( & po -> bind_lock ) ; if ( was_running ) { po -> num = num ; register_prot_hook ( sk ) ; } spin_unlock ( & po -> bind_lock ) ; if ( closing && ( po -> tp_version > TPACKET_V2 ) ) { if ( ! tx_ring ) prb_shutdown_retire_blk_timer ( po , rb_queue ) ; } <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( pg_vec ) <S2SV_EndBug> free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : return err ; }
CWE-000 static void set_own_dir ( const char * argv0 ) { size_t l = strlen ( argv0 ) ; while ( l && argv0 [ l - 1 ] != '/' ) l -- ; if ( l == 0 ) <S2SV_StartBug> memcpy ( own_dir , "." , 2 ) ; <S2SV_EndBug> else { memcpy ( own_dir , argv0 , l - 1 ) ; own_dir [ l ] = 0 ; } }
CWE-200 static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) { <S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ; <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ; <S2SV_StartBug> } <S2SV_EndBug> blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }
CWE-119 <S2SV_StartBug> static void write_delta_q ( struct vp9_write_bit_buffer * wb , int delta_q ) { <S2SV_EndBug> if ( delta_q != 0 ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta_q < 0 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> } }
CWE-119 int vp8_yv12_realloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf , int width , int height , int border ) { if ( ybf ) { int aligned_width = ( width + 15 ) & ~ 15 ; int aligned_height = ( height + 15 ) & ~ 15 ; int y_stride = ( ( aligned_width + 2 * border ) + 31 ) & ~ 31 ; int yplane_size = ( aligned_height + 2 * border ) * y_stride ; int uv_width = aligned_width >> 1 ; int uv_height = aligned_height >> 1 ; int uv_stride = y_stride >> 1 ; int uvplane_size = ( uv_height + border ) * uv_stride ; const int frame_size = yplane_size + 2 * uvplane_size ; if ( ! ybf -> buffer_alloc ) { ybf -> buffer_alloc = ( uint8_t * ) vpx_memalign ( 32 , frame_size ) ; ybf -> buffer_alloc_sz = frame_size ; } if ( ! ybf -> buffer_alloc || ybf -> buffer_alloc_sz < frame_size ) return - 1 ; if ( border & 0x1f ) return - 3 ; ybf -> y_crop_width = width ; ybf -> y_crop_height = height ; ybf -> y_width = aligned_width ; ybf -> y_height = aligned_height ; ybf -> y_stride = y_stride ; <S2SV_StartBug> ybf -> uv_width = uv_width ; <S2SV_EndBug> ybf -> uv_height = uv_height ; ybf -> uv_stride = uv_stride ; ybf -> alpha_width = 0 ; ybf -> alpha_height = 0 ; ybf -> alpha_stride = 0 ; ybf -> border = border ; ybf -> frame_size = frame_size ; ybf -> y_buffer = ybf -> buffer_alloc + ( border * y_stride ) + border ; ybf -> u_buffer = ybf -> buffer_alloc + yplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> v_buffer = ybf -> buffer_alloc + yplane_size + uvplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> alpha_buffer = NULL ; ybf -> corrupted = 0 ; return 0 ; } return - 2 ; }
CWE-119 static int do_ip_vs_set_ctl ( struct sock * sk , int cmd , void __user * user , unsigned int len ) { int ret ; unsigned char arg [ MAX_ARG_LEN ] ; struct ip_vs_service_user * usvc_compat ; struct ip_vs_service_user_kern usvc ; struct ip_vs_service * svc ; struct ip_vs_dest_user * udest_compat ; struct ip_vs_dest_user_kern udest ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_StartBug> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <S2SV_EndBug> pr_err ( "set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , len , set_arglen [ SET_CMDID ( cmd ) ] ) ; return - EINVAL ; } if ( copy_from_user ( arg , user , len ) != 0 ) return - EFAULT ; ip_vs_use_count_inc ( ) ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) { ret = - ERESTARTSYS ; goto out_dec ; } if ( cmd == IP_VS_SO_SET_FLUSH ) { ret = ip_vs_flush ( ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_TIMEOUT ) { ret = ip_vs_set_timeout ( ( struct ip_vs_timeout_user * ) arg ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STARTDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = start_sync_thread ( dm -> state , dm -> mcast_ifn , dm -> syncid ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STOPDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = stop_sync_thread ( dm -> state ) ; goto out_unlock ; } usvc_compat = ( struct ip_vs_service_user * ) arg ; udest_compat = ( struct ip_vs_dest_user * ) ( usvc_compat + 1 ) ; ip_vs_copy_usvc_compat ( & usvc , usvc_compat ) ; ip_vs_copy_udest_compat ( & udest , udest_compat ) ; if ( cmd == IP_VS_SO_SET_ZERO ) { if ( ! usvc . fwmark && ! usvc . addr . ip && ! usvc . port ) { ret = ip_vs_zero_all ( ) ; goto out_unlock ; } } if ( usvc . protocol != IPPROTO_TCP && usvc . protocol != IPPROTO_UDP ) { pr_err ( "set_ctl:<S2SV_blank>invalid<S2SV_blank>protocol:<S2SV_blank>%d<S2SV_blank>%pI4:%d<S2SV_blank>%s\\n" , usvc . protocol , & usvc . addr . ip , ntohs ( usvc . port ) , usvc . sched_name ) ; ret = - EFAULT ; goto out_unlock ; } if ( usvc . fwmark == 0 ) svc = __ip_vs_service_get ( usvc . af , usvc . protocol , & usvc . addr , usvc . port ) ; else svc = __ip_vs_svc_fwm_get ( usvc . af , usvc . fwmark ) ; if ( cmd != IP_VS_SO_SET_ADD && ( svc == NULL || svc -> protocol != usvc . protocol ) ) { ret = - ESRCH ; goto out_unlock ; } switch ( cmd ) { case IP_VS_SO_SET_ADD : if ( svc != NULL ) ret = - EEXIST ; else ret = ip_vs_add_service ( & usvc , & svc ) ; break ; case IP_VS_SO_SET_EDIT : ret = ip_vs_edit_service ( svc , & usvc ) ; break ; case IP_VS_SO_SET_DEL : ret = ip_vs_del_service ( svc ) ; if ( ! ret ) goto out_unlock ; break ; case IP_VS_SO_SET_ZERO : ret = ip_vs_zero_service ( svc ) ; break ; case IP_VS_SO_SET_ADDDEST : ret = ip_vs_add_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_EDITDEST : ret = ip_vs_edit_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_DELDEST : ret = ip_vs_del_dest ( svc , & udest ) ; break ; default : ret = - EINVAL ; } if ( svc ) ip_vs_service_put ( svc ) ; out_unlock : mutex_unlock ( & __ip_vs_mutex ) ; out_dec : ip_vs_use_count_dec ( ) ; return ret ; }
CWE-119 void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) <S2SV_StartBug> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <S2SV_EndBug> free ( ctx -> buf ) ; } free ( ctx ) ; } }
CWE-476 static void i8042_stop ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = false ; <S2SV_EndBug> synchronize_irq ( I8042_AUX_IRQ ) ; synchronize_irq ( I8042_KBD_IRQ ) ; <S2SV_StartBug> port -> serio = NULL ; <S2SV_EndBug> }
CWE-000 static int php_handler ( request_rec * r ) { php_struct * volatile ctx ; void * conf ; apr_bucket_brigade * volatile brigade ; apr_bucket * bucket ; apr_status_t rv ; request_rec * volatile parent_req = NULL ; TSRMLS_FETCH ( ) ; # define PHPAP_INI_OFF php_apache_ini_dtor ( r , parent_req TSRMLS_CC ) ; conf = ap_get_module_config ( r -> per_dir_config , & php5_module ) ; ctx = SG ( server_context ) ; if ( ctx == NULL || ( ctx && ctx -> request_processed && ! strcmp ( r -> protocol , "INCLUDED" ) ) ) { normal : ctx = SG ( server_context ) = apr_pcalloc ( r -> pool , sizeof ( * ctx ) ) ; apr_pool_cleanup_register ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup , apr_pool_cleanup_null ) ; ctx -> r = r ; ctx = NULL ; } else { parent_req = ctx -> r ; ctx -> r = r ; } apply_config ( conf ) ; if ( strcmp ( r -> handler , PHP_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SCRIPT ) ) { if ( ! AP2 ( xbithack ) || strcmp ( r -> handler , "text/html" ) || ! ( r -> finfo . protection & APR_UEXECUTE ) ) { PHPAP_INI_OFF ; return DECLINED ; } } if ( r -> used_path_info == AP_REQ_REJECT_PATH_INFO && r -> path_info && r -> path_info [ 0 ] ) { PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( ! AP2 ( engine ) ) { PHPAP_INI_OFF ; return DECLINED ; } if ( r -> finfo . filetype == 0 ) { php_apache_sapi_log_message_ex ( "script<S2SV_blank>\'%s\'<S2SV_blank>not<S2SV_blank>found<S2SV_blank>or<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>stat" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( r -> finfo . filetype == APR_DIR ) { php_apache_sapi_log_message_ex ( "attempt<S2SV_blank>to<S2SV_blank>invoke<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>as<S2SV_blank>script" , r TSRMLS_CC ) ; PHPAP_INI_OFF ; return HTTP_FORBIDDEN ; } if ( r -> main == NULL || r -> subprocess_env != r -> main -> subprocess_env ) { ap_add_common_vars ( r ) ; ap_add_cgi_vars ( r ) ; } zend_first_try { if ( ctx == NULL ) { brigade = apr_brigade_create ( r -> pool , r -> connection -> bucket_alloc ) ; ctx = SG ( server_context ) ; ctx -> brigade = brigade ; if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } else { if ( ! parent_req ) { parent_req = ctx -> r ; } if ( parent_req && parent_req -> handler && strcmp ( parent_req -> handler , PHP_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( parent_req -> handler , PHP_SCRIPT ) ) { if ( php_apache_request_ctor ( r , ctx TSRMLS_CC ) != SUCCESS ) { zend_bailout ( ) ; } } if ( parent_req && parent_req -> status != HTTP_OK && parent_req -> status != 413 && strcmp ( r -> protocol , "INCLUDED" ) ) { parent_req = NULL ; goto normal ; } ctx -> r = r ; brigade = ctx -> brigade ; } if ( AP2 ( last_modified ) ) { ap_update_mtime ( r , r -> finfo . mtime ) ; ap_set_last_modified ( r ) ; } if ( strncmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE , sizeof ( PHP_SOURCE_MAGIC_TYPE ) - 1 ) == 0 ) { zend_syntax_highlighter_ini syntax_highlighter_ini ; php_get_highlight_struct ( & syntax_highlighter_ini ) ; highlight_file ( ( char * ) r -> filename , & syntax_highlighter_ini TSRMLS_CC ) ; } else { zend_file_handle zfd ; zfd . type = ZEND_HANDLE_FILENAME ; zfd . filename = ( char * ) r -> filename ; zfd . free_filename = 0 ; zfd . opened_path = NULL ; if ( ! parent_req ) { php_execute_script ( & zfd TSRMLS_CC ) ; } else { zend_execute_scripts ( ZEND_INCLUDE TSRMLS_CC , NULL , 1 , & zfd ) ; } apr_table_set ( r -> notes , "mod_php_memory_usage" , apr_psprintf ( ctx -> r -> pool , "%" APR_SIZE_T_FMT , zend_memory_peak_usage ( 1 TSRMLS_CC ) ) ) ; } } zend_end_try ( ) ; if ( ! parent_req ) { php_apache_request_dtor ( r TSRMLS_CC ) ; ctx -> request_processed = 1 ; <S2SV_StartBug> bucket = apr_bucket_eos_create ( r -> connection -> bucket_alloc ) ; <S2SV_EndBug> APR_BRIGADE_INSERT_TAIL ( brigade , bucket ) ; rv = ap_pass_brigade ( r -> output_filters , brigade ) ; if ( rv != APR_SUCCESS || r -> connection -> aborted ) { zend_first_try { php_handle_aborted_connection ( ) ; } zend_end_try ( ) ; } apr_brigade_cleanup ( brigade ) ; apr_pool_cleanup_run ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup ) ; } else { ctx -> r = parent_req ; } return OK ; }
CWE-125 int main ( int argc , char * * argv ) { const char command0 [ ] = { 0x00 , 0x00 } ; char command1 [ ] = "\\x01\\x00urn:schemas-upnp-org:device:InternetGatewayDevice" ; char command2 [ ] = "\\x02\\x00uuid:fc4ec57e-b051-11db-88f8-0060085db3f6::upnp:rootdevice" ; const char command3 [ ] = { 0x03 , 0x00 } ; char command3compat [ ] = "\\x03\\x00ssdp:all" ; char command4 [ ] = "\\x04\\x00test:test:test" ; const char bad_command [ ] = { 0xff , 0xff } ; const char overflow [ ] = { 0x01 , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff } ; <S2SV_StartBug> const char command5 [ ] = { 0x05 , 0x00 } ; <S2SV_EndBug> int s ; int i ; void * tmp ; unsigned char * resp = NULL ; size_t respsize = 0 ; unsigned char buf [ 4096 ] ; ssize_t n ; int total = 0 ; const char * sockpath = "/var/run/minissdpd.sock" ; for ( i = 0 ; i < argc - 1 ; i ++ ) { if ( 0 == strcmp ( argv [ i ] , "-s" ) ) sockpath = argv [ ++ i ] ; } command1 [ 1 ] = sizeof ( command1 ) - 3 ; command2 [ 1 ] = sizeof ( command2 ) - 3 ; command3compat [ 1 ] = sizeof ( command3compat ) - 3 ; command4 [ 1 ] = sizeof ( command4 ) - 3 ; s = connect_unix_socket ( sockpath ) ; n = SENDCOMMAND ( command0 , sizeof ( command0 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; if ( n > 0 ) { printversion ( buf , n ) ; } else { printf ( "Command<S2SV_blank>0<S2SV_blank>(get<S2SV_blank>version)<S2SV_blank>not<S2SV_blank>supported\\n" ) ; close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command1 , sizeof ( command1 ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command2 , sizeof ( command2 ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } buf [ 0 ] = 0 ; n = SENDCOMMAND ( command3 , sizeof ( command3 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; if ( n == 0 ) { printf ( "command3<S2SV_blank>failed,<S2SV_blank>testing<S2SV_blank>compatible<S2SV_blank>one\\n" ) ; close ( s ) ; s = connect_unix_socket ( sockpath ) ; n = SENDCOMMAND ( command3compat , sizeof ( command3compat ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; } printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printf ( "Number<S2SV_blank>of<S2SV_blank>devices<S2SV_blank>%d\\n" , ( int ) buf [ 0 ] ) ; while ( n > 0 ) { tmp = realloc ( resp , respsize + n ) ; if ( tmp == NULL ) { fprintf ( stderr , "memory<S2SV_blank>allocation<S2SV_blank>error\\n" ) ; break ; } resp = tmp ; respsize += n ; if ( n > 0 ) { memcpy ( resp + total , buf , n ) ; total += n ; } if ( n < ( ssize_t ) sizeof ( buf ) ) { break ; } n = read ( s , buf , sizeof ( buf ) ) ; printf ( "response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; } if ( resp != NULL ) { printresponse ( resp , total ) ; free ( resp ) ; resp = NULL ; } if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command4 , sizeof ( command4 ) ) ; n = SENDCOMMAND ( bad_command , sizeof ( bad_command ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( overflow , sizeof ( overflow ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command5 , sizeof ( command5 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printresponse ( buf , n ) ; <S2SV_StartBug> close ( s ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-264 const char * string_of_NPNVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPNVxDisplay ) ; _ ( NPNVxtAppContext ) ; _ ( NPNVnetscapeWindow ) ; _ ( NPNVjavascriptEnabledBool ) ; _ ( NPNVasdEnabledBool ) ; _ ( NPNVisOfflineBool ) ; _ ( NPNVserviceManager ) ; _ ( NPNVDOMElement ) ; _ ( NPNVDOMWindow ) ; _ ( NPNVToolkit ) ; _ ( NPNVSupportsXEmbedBool ) ; _ ( NPNVWindowNPObject ) ; _ ( NPNVPluginElementNPObject ) ; _ ( NPNVSupportsWindowless ) ; <S2SV_StartBug> # undef _ <S2SV_EndBug> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPNVserviceManager ) ; _ ( 11 , NPNVDOMElement ) ; _ ( 12 , NPNVDOMWindow ) ; _ ( 13 , NPNVToolkit ) ; # undef _ default : str = "<unknown<S2SV_blank>variable>" ; break ; } break ; } return str ; }
CWE-000 STATIC int xfs_attr_node_addname ( xfs_da_args_t * args ) { xfs_da_state_t * state ; xfs_da_state_blk_t * blk ; xfs_inode_t * dp ; xfs_mount_t * mp ; int committed , retval , error ; trace_xfs_attr_node_addname ( args ) ; dp = args -> dp ; mp = dp -> i_mount ; restart : state = xfs_da_state_alloc ( ) ; state -> args = args ; state -> mp = mp ; state -> blocksize = state -> mp -> m_sb . sb_blocksize ; state -> node_ents = state -> mp -> m_attr_node_ents ; error = xfs_da3_node_lookup_int ( state , & retval ) ; if ( error ) goto out ; blk = & state -> path . blk [ state -> path . active - 1 ] ; ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { goto out ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) goto out ; trace_xfs_attr_node_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; <S2SV_StartBug> args -> rmtblkno = 0 ; <S2SV_EndBug> <S2SV_StartBug> args -> rmtblkcnt = 0 ; <S2SV_EndBug> } retval = xfs_attr3_leaf_add ( blk -> bp , state -> args ) ; if ( retval == ENOSPC ) { if ( state -> path . active == 1 ) { xfs_da_state_free ( state ) ; state = NULL ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; goto restart ; } xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_da3_split ( state ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } else { xfs_da3_fixhashpath ( state , & state -> path ) ; } xfs_da_state_free ( state ) ; state = NULL ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) goto out ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; <S2SV_StartBug> args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_EndBug> if ( args -> rmtblkno ) { error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } args -> flags |= XFS_ATTR_INCOMPLETE ; state = xfs_da_state_alloc ( ) ; state -> args = args ; state -> mp = mp ; state -> blocksize = state -> mp -> m_sb . sb_blocksize ; state -> node_ents = state -> mp -> m_attr_node_ents ; state -> inleaf = 0 ; error = xfs_da3_node_lookup_int ( state , & retval ) ; if ( error ) goto out ; blk = & state -> path . blk [ state -> path . active - 1 ] ; ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; error = xfs_attr3_leaf_remove ( blk -> bp , args ) ; xfs_da3_fixhashpath ( state , & state -> path ) ; if ( retval && ( state -> path . active > 1 ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_da3_join ( state ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; if ( error ) goto out ; } retval = error = 0 ; out : if ( state ) xfs_da_state_free ( state ) ; if ( error ) return ( error ) ; return ( retval ) ; }
CWE-119 int vp8_skip_fractional_mv_step ( MACROBLOCK * mb , BLOCK * b , BLOCKD * d , int_mv * bestmv , int_mv * ref_mv , int error_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvcost [ 2 ] , int * distortion , unsigned int * sse ) { ( void ) b ; ( void ) d ; ( void ) ref_mv ; ( void ) error_per_bit ; ( void ) vfp ; <S2SV_StartBug> ( void ) mvcost ; <S2SV_EndBug> ( void ) distortion ; ( void ) sse ; bestmv -> as_mv . row <<= 3 ; bestmv -> as_mv . col <<= 3 ; return 0 ; }
CWE-119 <S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> { static const struct ipt_ip uncond ; <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> # undef FWINV }
CWE-119 static int get_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) { <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> RTL8150_REQ_GET_REGS , RTL8150_REQT_READ , <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static void accumulate_frame_motion_stats ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame , double * this_frame_mv_in_out , double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) { double this_frame_mvr_ratio ; double this_frame_mvc_ratio ; double motion_pct ; <S2SV_StartBug> motion_pct = this_frame -> pcnt_motion ; <S2SV_EndBug> * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ; * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ; * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ; if ( motion_pct > 0.05 ) { this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ; this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ; * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs ) ? ( this_frame_mvr_ratio * motion_pct ) : this_frame -> mvr_abs * motion_pct ; * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) ? ( this_frame_mvc_ratio * motion_pct ) : this_frame -> mvc_abs * motion_pct ; } }
CWE-119 static int rd_pick_intra4x4block ( MACROBLOCK * x , BLOCK * be , BLOCKD * b , B_PREDICTION_MODE * best_mode , const int * bmode_costs , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , int * bestrate , int * bestratey , int * bestdistortion ) { B_PREDICTION_MODE mode ; int best_rd = INT_MAX ; int rate = 0 ; int distortion ; ENTROPY_CONTEXT ta = * a , tempa = * a ; ENTROPY_CONTEXT tl = * l , templ = * l ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ; <S2SV_EndBug> int dst_stride = x -> e_mbd . dst . y_stride ; unsigned char * dst = x -> e_mbd . dst . y_buffer + b -> offset ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; unsigned char top_left = Above [ - 1 ] ; for ( mode = B_DC_PRED ; mode <= B_HU_PRED ; mode ++ ) { int this_rd ; int ratey ; rate = bmode_costs [ mode ] ; vp8_intra4x4_predict ( Above , yleft , dst_stride , mode , b -> predictor , 16 , top_left ) ; vp8_subtract_b ( be , b , 16 ) ; x -> short_fdct4x4 ( be -> src_diff , be -> coeff , 32 ) ; x -> quantize_b ( be , b ) ; tempa = ta ; templ = tl ; ratey = cost_coeffs ( x , b , PLANE_TYPE_Y_WITH_DC , & tempa , & templ ) ; rate += ratey ; distortion = vp8_block_error ( be -> coeff , b -> dqcoeff ) >> 2 ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; * a = tempa ; * l = templ ; copy_predictor ( best_predictor , b -> predictor ) ; <S2SV_StartBug> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <S2SV_EndBug> } } b -> bmi . as_mode = * best_mode ; vp8_short_idct4x4llm ( best_dqcoeff , best_predictor , 16 , dst , dst_stride ) ; return best_rd ; }
CWE-000 enum ImapAuthRes imap_auth_login ( struct ImapData * idata , const char * method ) { char q_user [ SHORT_STRING ] , q_pass [ SHORT_STRING ] ; char buf [ STRING ] ; int rc ; if ( mutt_bit_isset ( idata -> capabilities , LOGINDISABLED ) ) { mutt_message ( _ ( "LOGIN<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>this<S2SV_blank>server." ) ) ; return IMAP_AUTH_UNAVAIL ; } if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; mutt_message ( _ ( "Logging<S2SV_blank>in..." ) ) ; <S2SV_StartBug> imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ; <S2SV_EndBug> if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , "Sending<S2SV_blank>LOGIN<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s...\\n" , idata -> conn -> account . user ) ; snprintf ( buf , sizeof ( buf ) , "LOGIN<S2SV_blank>%s<S2SV_blank>%s" , q_user , q_pass ) ; rc = imap_exec ( idata , buf , IMAP_CMD_FAIL_OK | IMAP_CMD_PASS ) ; if ( ! rc ) { mutt_clear_error ( ) ; return IMAP_AUTH_SUCCESS ; } mutt_error ( _ ( "Login<S2SV_blank>failed." ) ) ; return IMAP_AUTH_FAILURE ; }
CWE-119 static int decode_cblk ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * codsty , Jpeg2000T1Context * t1 , Jpeg2000Cblk * cblk , int width , int height , int bandpos ) { int passno = cblk -> npasses , pass_t = 2 , bpno = cblk -> nonzerobits - 1 , y ; int clnpass_cnt = 0 ; int bpass_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_BYPASS ; <S2SV_StartBug> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <S2SV_EndBug> for ( y = 0 ; y < height ; y ++ ) memset ( t1 -> data [ y ] , 0 , width * sizeof ( * * t1 -> data ) ) ; if ( ! cblk -> length ) return 0 ; for ( y = 0 ; y < height + 2 ; y ++ ) memset ( t1 -> flags [ y ] , 0 , ( width + 2 ) * sizeof ( * * t1 -> flags ) ) ; cblk -> data [ cblk -> length ] = 0xff ; cblk -> data [ cblk -> length + 1 ] = 0xff ; ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; while ( passno -- ) { switch ( pass_t ) { case 0 : decode_sigpass ( t1 , width , height , bpno + 1 , bandpos , bpass_csty_symbol && ( clnpass_cnt >= 4 ) , vert_causal_ctx_csty_symbol ) ; break ; case 1 : decode_refpass ( t1 , width , height , bpno + 1 ) ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; case 2 : decode_clnpass ( s , t1 , width , height , bpno + 1 , bandpos , codsty -> cblk_style & JPEG2000_CBLK_SEGSYM , vert_causal_ctx_csty_symbol ) ; clnpass_cnt = clnpass_cnt + 1 ; if ( bpass_csty_symbol && clnpass_cnt >= 4 ) ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; break ; } pass_t ++ ; if ( pass_t == 3 ) { bpno -- ; pass_t = 0 ; } } return 0 ; }
CWE-200 __visible __notrace_funcgraph struct task_struct * __switch_to ( struct task_struct * prev_p , struct task_struct * next_p ) { struct thread_struct * prev = & prev_p -> thread ; struct thread_struct * next = & next_p -> thread ; int cpu = smp_processor_id ( ) ; struct tss_struct * tss = & per_cpu ( init_tss , cpu ) ; unsigned fsindex , gsindex ; fpu_switch_t fpu ; fpu = switch_fpu_prepare ( prev_p , next_p , cpu ) ; load_sp0 ( tss , next ) ; <S2SV_StartBug> savesegment ( es , prev -> es ) ; <S2SV_EndBug> if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ; savesegment ( ds , prev -> ds ) ; if ( unlikely ( next -> ds | prev -> ds ) ) <S2SV_StartBug> loadsegment ( ds , next -> ds ) ; <S2SV_EndBug> savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; if ( unlikely ( fsindex | next -> fsindex | prev -> fs ) ) { loadsegment ( fs , next -> fsindex ) ; if ( fsindex ) prev -> fs = 0 ; } if ( next -> fs ) wrmsrl ( MSR_FS_BASE , next -> fs ) ; prev -> fsindex = fsindex ; if ( unlikely ( gsindex | next -> gsindex | prev -> gs ) ) { load_gs_index ( next -> gsindex ) ; if ( gsindex ) prev -> gs = 0 ; } if ( next -> gs ) wrmsrl ( MSR_KERNEL_GS_BASE , next -> gs ) ; prev -> gsindex = gsindex ; switch_fpu_finish ( next_p , fpu ) ; prev -> usersp = this_cpu_read ( old_rsp ) ; this_cpu_write ( old_rsp , next -> usersp ) ; this_cpu_write ( current_task , next_p ) ; task_thread_info ( prev_p ) -> saved_preempt_count = this_cpu_read ( __preempt_count ) ; this_cpu_write ( __preempt_count , task_thread_info ( next_p ) -> saved_preempt_count ) ; this_cpu_write ( kernel_stack , ( unsigned long ) task_stack_page ( next_p ) + THREAD_SIZE - KERNEL_STACK_OFFSET ) ; if ( unlikely ( task_thread_info ( next_p ) -> flags & _TIF_WORK_CTXSW_NEXT || task_thread_info ( prev_p ) -> flags & _TIF_WORK_CTXSW_PREV ) ) __switch_to_xtra ( prev_p , next_p , tss ) ; return prev_p ; }
CWE-200 static int do_devinfo_ioctl ( struct comedi_device * dev , struct comedi_devinfo __user * arg , struct file * file ) { struct comedi_devinfo devinfo ; const unsigned minor = iminor ( file -> f_dentry -> d_inode ) ; struct comedi_device_file_info * dev_file_info = comedi_get_device_file_info ( minor ) ; struct comedi_subdevice * read_subdev = comedi_get_read_subdevice ( dev_file_info ) ; struct comedi_subdevice * write_subdev = comedi_get_write_subdevice ( dev_file_info ) ; memset ( & devinfo , 0 , sizeof ( devinfo ) ) ; devinfo . version_code = COMEDI_VERSION_CODE ; devinfo . n_subdevs = dev -> n_subdevices ; <S2SV_StartBug> memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ; else devinfo . read_subdevice = - 1 ; if ( write_subdev ) devinfo . write_subdevice = write_subdev - dev -> subdevices ; else devinfo . write_subdevice = - 1 ; if ( copy_to_user ( arg , & devinfo , sizeof ( struct comedi_devinfo ) ) ) return - EFAULT ; return 0 ; }
CWE-119 static vpx_codec_err_t ctrl_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> int * const update_info = va_arg ( args , int * ) ; <S2SV_StartBug> if ( update_info ) { <S2SV_EndBug> <S2SV_StartBug> if ( ctx -> pbi ) <S2SV_EndBug> <S2SV_StartBug> * update_info = ctx -> pbi -> refresh_frame_flags ; <S2SV_EndBug> else return VPX_CODEC_ERROR ; return VPX_CODEC_OK ; } else { <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
CWE-772 int virtio_gpu_object_create ( struct virtio_gpu_device * vgdev , unsigned long size , bool kernel , bool pinned , struct virtio_gpu_object * * bo_ptr ) { struct virtio_gpu_object * bo ; enum ttm_bo_type type ; size_t acc_size ; int ret ; if ( kernel ) type = ttm_bo_type_kernel ; else type = ttm_bo_type_device ; * bo_ptr = NULL ; acc_size = ttm_bo_dma_acc_size ( & vgdev -> mman . bdev , size , sizeof ( struct virtio_gpu_object ) ) ; bo = kzalloc ( sizeof ( struct virtio_gpu_object ) , GFP_KERNEL ) ; if ( bo == NULL ) return - ENOMEM ; size = roundup ( size , PAGE_SIZE ) ; ret = drm_gem_object_init ( vgdev -> ddev , & bo -> gem_base , size ) ; if ( ret != 0 ) <S2SV_StartBug> return ret ; <S2SV_EndBug> bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo , pinned ) ; ret = ttm_bo_init ( & vgdev -> mman . bdev , & bo -> tbo , size , type , & bo -> placement , 0 , ! kernel , NULL , acc_size , NULL , NULL , & virtio_gpu_ttm_bo_destroy ) ; if ( ret != 0 ) return ret ; * bo_ptr = bo ; return 0 ; }
CWE-476 int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; if ( ! sm_info ) return - ENOMEM ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ; sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ; sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ; INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ; <S2SV_StartBug> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <S2SV_EndBug> err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ; } err = create_discard_cmd_control ( sbi ) ; if ( err ) return err ; err = build_sit_info ( sbi ) ; if ( err ) return err ; err = build_free_segmap ( sbi ) ; if ( err ) return err ; err = build_curseg ( sbi ) ; if ( err ) return err ; build_sit_entries ( sbi ) ; init_free_segmap ( sbi ) ; err = build_dirty_segmap ( sbi ) ; if ( err ) return err ; init_min_max_mtime ( sbi ) ; return 0 ; }
CWE-119 static void set_fixed_partitioning ( VP9_COMP * cpi , const TileInfo * const tile , MODE_INFO * * mi_8x8 , int mi_row , int mi_col , BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; const int mis = cm -> mi_stride ; <S2SV_StartBug> int row8x8_remaining = tile -> mi_row_end - mi_row ; <S2SV_EndBug> <S2SV_StartBug> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_EndBug> int block_row , block_col ; MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ; int bh = num_8x8_blocks_high_lookup [ bsize ] ; int bw = num_8x8_blocks_wide_lookup [ bsize ] ; assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ; if ( ( col8x8_remaining >= MI_BLOCK_SIZE ) && ( row8x8_remaining >= MI_BLOCK_SIZE ) ) { for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) { for ( block_col = 0 ; block_col < MI_BLOCK_SIZE ; block_col += bw ) { int index = block_row * mis + block_col ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = bsize ; } } } else { <S2SV_StartBug> for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) { <S2SV_EndBug> for ( block_col = 0 ; block_col < MI_BLOCK_SIZE ; block_col += bw ) { int index = block_row * mis + block_col ; bsize = find_partition_size ( bsize , ( row8x8_remaining - block_row ) , ( col8x8_remaining - block_col ) , & bh , & bw ) ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = bsize ; } } } }
CWE-000 int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) { int ret = 0 ; struct btrfs_key key ; struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; u64 ino = btrfs_ino ( inode ) ; u64 parent_ino = btrfs_ino ( parent_inode ) ; if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; } else { key . objectid = ino ; btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; key . offset = 0 ; } if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , index , name , name_len ) ; } else if ( add_backref ) { ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , parent_ino , index ) ; } if ( ret ) return ret ; ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ; <S2SV_StartBug> if ( ret == - EEXIST ) <S2SV_EndBug> goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; return ret ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + name_len * 2 ) ; inode_inc_iversion ( parent_inode ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode ( trans , root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; return ret ; fail_dir_item : if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { u64 local_index ; int err ; err = btrfs_del_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , & local_index , name , name_len ) ; } else if ( add_backref ) { u64 local_index ; int err ; err = btrfs_del_inode_ref ( trans , root , name , name_len , ino , parent_ino , & local_index ) ; } return ret ; }
CWE-119 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <S2SV_EndBug> duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-000 static int snd_seq_ioctl_remove_events ( struct snd_seq_client * client , void __user * arg ) { struct snd_seq_remove_events info ; if ( copy_from_user ( & info , arg , sizeof ( info ) ) ) return - EFAULT ; if ( info . remove_mode & SNDRV_SEQ_REMOVE_INPUT ) { <S2SV_StartBug> if ( client -> type == USER_CLIENT ) <S2SV_EndBug> snd_seq_fifo_clear ( client -> data . user . fifo ) ; } if ( info . remove_mode & SNDRV_SEQ_REMOVE_OUTPUT ) snd_seq_queue_remove_cells ( client -> number , & info ) ; return 0 ; }
CWE-119 static int http_buf_read ( URLContext * h , uint8_t * buf , int size ) { HTTPContext * s = h -> priv_data ; int len ; len = s -> buf_end - s -> buf_ptr ; if ( len > 0 ) { if ( len > size ) len = size ; memcpy ( buf , s -> buf_ptr , len ) ; s -> buf_ptr += len ; } else { <S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off >= target_end ) return AVERROR_EOF ; len = ffurl_read ( s -> hd , buf , size ) ; <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off < target_end ) { av_log ( h , AV_LOG_ERROR , <S2SV_StartBug> "Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%" PRId64 ",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%" PRId64 "\\n" , <S2SV_EndBug> s -> off , target_end ) ; return AVERROR ( EIO ) ; } } if ( len > 0 ) { s -> off += len ; if ( s -> chunksize > 0 ) s -> chunksize -= len ; } return len ; }
CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , "Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , "Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , "Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , "Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>" "resource.\\n" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , "Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , "Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , "%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , "%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
CWE-264 static authz_status lua_authz_check ( request_rec * r , const char * require_line , const void * parsed_require_line ) { apr_pool_t * pool ; ap_lua_vm_spec * spec ; lua_State * L ; ap_lua_server_cfg * server_cfg = ap_get_module_config ( r -> server -> module_config , & lua_module ) ; const ap_lua_dir_cfg * cfg = ap_get_module_config ( r -> per_dir_config , & lua_module ) ; <S2SV_StartBug> const lua_authz_provider_spec * prov_spec = parsed_require_line ; <S2SV_EndBug> int result ; int nargs = 0 ; spec = create_vm_spec ( & pool , r , cfg , server_cfg , prov_spec -> file_name , NULL , 0 , prov_spec -> function_name , "authz<S2SV_blank>provider" ) ; L = ap_lua_get_lua_state ( pool , spec , r ) ; if ( L == NULL ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02314 ) "Unable<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>VM<S2SV_blank>for<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s" , prov_spec -> name ) ; return AUTHZ_GENERAL_ERROR ; } lua_getglobal ( L , prov_spec -> function_name ) ; if ( ! lua_isfunction ( L , - 1 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_CRIT , 0 , r , APLOGNO ( 02319 ) "Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>entry<S2SV_blank>function<S2SV_blank>\'%s\'<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>function)" , prov_spec -> function_name , prov_spec -> file_name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } ap_lua_run_lua_request ( L , r ) ; <S2SV_StartBug> if ( prov_spec -> args ) { <S2SV_EndBug> int i ; <S2SV_StartBug> if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) { <S2SV_EndBug> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02315 ) "Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>arguments" , prov_spec -> name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } <S2SV_StartBug> for ( i = 0 ; i < prov_spec -> args -> nelts ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ; <S2SV_EndBug> lua_pushstring ( L , arg ) ; } <S2SV_StartBug> nargs = prov_spec -> args -> nelts ; <S2SV_EndBug> } if ( lua_pcall ( L , 1 + nargs , 1 , 0 ) ) { const char * err = lua_tostring ( L , - 1 ) ; ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02316 ) "Error<S2SV_blank>executing<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>%s" , prov_spec -> name , err ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } if ( ! lua_isnumber ( L , - 1 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02317 ) "Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s<S2SV_blank>did<S2SV_blank>not<S2SV_blank>return<S2SV_blank>integer" , prov_spec -> name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } result = lua_tointeger ( L , - 1 ) ; ap_lua_release_state ( L , spec , r ) ; switch ( result ) { case AUTHZ_DENIED : case AUTHZ_GRANTED : case AUTHZ_NEUTRAL : case AUTHZ_GENERAL_ERROR : case AUTHZ_DENIED_NO_USER : return result ; default : ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02318 ) "Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>invalid<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d" , prov_spec -> name , result ) ; } return AUTHZ_GENERAL_ERROR ; }
CWE-362 static long ec_device_ioctl_xcmd ( struct cros_ec_dev * ec , void __user * arg ) { long ret ; struct cros_ec_command u_cmd ; struct cros_ec_command * s_cmd ; if ( copy_from_user ( & u_cmd , arg , sizeof ( u_cmd ) ) ) return - EFAULT ; if ( ( u_cmd . outsize > EC_MAX_MSG_BYTES ) || ( u_cmd . insize > EC_MAX_MSG_BYTES ) ) return - EINVAL ; s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , GFP_KERNEL ) ; if ( ! s_cmd ) return - ENOMEM ; if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) { ret = - EFAULT ; goto exit ; } <S2SV_StartBug> s_cmd -> command += ec -> cmd_offset ; <S2SV_EndBug> ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ; if ( ret < 0 ) goto exit ; <S2SV_StartBug> if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) ) <S2SV_EndBug> ret = - EFAULT ; exit : kfree ( s_cmd ) ; return ret ; }
CWE-125 int main ( ) { <S2SV_StartBug> gdImagePtr im ; <S2SV_EndBug> char * buffer ; size_t size ; size = read_test_file ( & buffer , "heap_overflow.tga" ) ; im = gdImageCreateFromTgaPtr ( size , ( void * ) buffer ) ; gdTestAssert ( im == NULL ) ; free ( buffer ) ; return gdNumFailures ( ) ; }
CWE-119 RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; <S2SV_StartBug> s = tcp_recv ( NULL , 4 ) ; <S2SV_EndBug> if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , "cssp_read_tsrequest(),<S2SV_blank>expected<S2SV_blank>BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,<S2SV_blank>got<S2SV_blank>%x" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; <S2SV_StartBug> if ( ! ber_in_header ( s , & tagval , & length ) || <S2SV_EndBug> tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; <S2SV_StartBug> in_uint8s ( s , length ) ; <S2SV_EndBug> if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; <S2SV_StartBug> token -> end = token -> p = token -> data ; <S2SV_EndBug> out_uint8p ( token , s -> p , length ) ; s_mark_end ( token ) ; } if ( pubkey ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != BER_TAG_OCTET_STRING ) return False ; pubkey -> data = pubkey -> p = s -> p ; pubkey -> end = pubkey -> data + length ; pubkey -> size = length ; } return True ; }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; wp += wc - 1 ; do { REPEAT4 ( stride , wp [ stride ] -= wp [ 0 ] ; wp -- ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-20 static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>load<S2SV_blank>config<S2SV_blank>file;<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file." , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file,<S2SV_blank>starting<S2SV_blank>unconfigured." , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>config<S2SV_blank>object." , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } btif_config_remove_unpaired ( config ) ; <S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> if ( ! alarm_timer ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alarm." , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }
CWE-190 void * jas_realloc ( void * ptr , size_t size ) { void * result ; <S2SV_StartBug> JAS_DBGLOG ( 101 , ( "jas_realloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%x,%zu\\n" , ptr , size ) ) ; <S2SV_EndBug> result = realloc ( ptr , size ) ; JAS_DBGLOG ( 100 , ( "jas_realloc(%p,<S2SV_blank>%zu)<S2SV_blank>-><S2SV_blank>%p\\n" , ptr , size , result ) ) ; return result ; }
CWE-119 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { <S2SV_StartBug> token ++ ; <S2SV_EndBug> } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , "lsl" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , "lsr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , "asr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
CWE-190 int sqlite3Fts3InitTokenizer ( Fts3Hash * pHash , const char * zArg , sqlite3_tokenizer * * ppTok , char * * pzErr ) { int rc ; char * z = ( char * ) zArg ; int n = 0 ; char * zCopy ; char * zEnd ; sqlite3_tokenizer_module * m ; zCopy = sqlite3_mprintf ( "%s" , zArg ) ; if ( ! zCopy ) return SQLITE_NOMEM ; zEnd = & zCopy [ strlen ( zCopy ) ] ; z = ( char * ) sqlite3Fts3NextToken ( zCopy , & n ) ; if ( z == 0 ) { assert ( n == 0 ) ; z = zCopy ; } z [ n ] = '\\0' ; sqlite3Fts3Dequote ( z ) ; m = ( sqlite3_tokenizer_module * ) sqlite3Fts3HashFind ( pHash , z , ( int ) strlen ( z ) + 1 ) ; if ( ! m ) { sqlite3Fts3ErrMsg ( pzErr , "unknown<S2SV_blank>tokenizer:<S2SV_blank>%s" , z ) ; rc = SQLITE_ERROR ; } else { char const * * aArg = 0 ; int iArg = 0 ; z = & z [ n + 1 ] ; while ( z < zEnd && ( NULL != ( z = ( char * ) sqlite3Fts3NextToken ( z , & n ) ) ) ) { <S2SV_StartBug> int nNew = sizeof ( char * ) * ( iArg + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ; <S2SV_EndBug> if ( ! aNew ) { sqlite3_free ( zCopy ) ; sqlite3_free ( ( void * ) aArg ) ; return SQLITE_NOMEM ; } aArg = aNew ; aArg [ iArg ++ ] = z ; z [ n ] = '\\0' ; sqlite3Fts3Dequote ( z ) ; z = & z [ n + 1 ] ; } rc = m -> xCreate ( iArg , aArg , ppTok ) ; assert ( rc != SQLITE_OK || * ppTok ) ; if ( rc != SQLITE_OK ) { sqlite3Fts3ErrMsg ( pzErr , "unknown<S2SV_blank>tokenizer" ) ; } else { ( * ppTok ) -> pModule = m ; } sqlite3_free ( ( void * ) aArg ) ; } sqlite3_free ( zCopy ) ; return rc ; }
CWE-119 void impeg2d_dec_pic_data_thread ( dec_state_t * ps_dec ) { WORD32 i4_continue_decode ; WORD32 i4_cur_row , temp ; UWORD32 u4_bits_read ; WORD32 i4_dequeue_job ; IMPEG2D_ERROR_CODES_T e_error ; i4_cur_row = ps_dec -> u2_mb_y + 1 ; i4_continue_decode = 1 ; i4_dequeue_job = 1 ; do { if ( i4_cur_row > ps_dec -> u2_num_vert_mb ) { i4_continue_decode = 0 ; break ; } { if ( ( ps_dec -> i4_num_cores > 1 ) && ( i4_dequeue_job ) ) { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; UWORD8 * pu1_buf ; e_ret = impeg2_jobq_dequeue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 1 ) ; if ( e_ret != IV_SUCCESS ) break ; if ( CMD_PROCESS == s_job . i4_cmd ) { pu1_buf = ps_dec -> pu1_inp_bits_buf + s_job . i4_bistream_ofst ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , pu1_buf , ( ps_dec -> u4_num_inp_bytes - s_job . i4_bistream_ofst ) + 8 ) ; i4_cur_row = s_job . i2_start_mb_y ; ps_dec -> i4_start_mb_y = s_job . i2_start_mb_y ; ps_dec -> i4_end_mb_y = s_job . i2_end_mb_y ; ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y = ps_dec -> i4_start_mb_y ; ps_dec -> u2_num_mbs_left = ( ps_dec -> i4_end_mb_y - ps_dec -> i4_start_mb_y ) * ps_dec -> u2_num_horiz_mb ; } else { WORD32 start_row ; WORD32 num_rows ; start_row = s_job . i2_start_mb_y << 4 ; num_rows = MIN ( ( s_job . i2_end_mb_y << 4 ) , ps_dec -> u2_vertical_size ) ; num_rows -= start_row ; impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; break ; } } e_error = impeg2d_dec_slice ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { impeg2d_next_start_code ( ps_dec ) ; } } while ( 1 ) { u4_bits_read = impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , START_CODE_LEN ) ; temp = u4_bits_read & 0xFF ; i4_continue_decode = ( ( ( u4_bits_read >> 8 ) == 0x01 ) && ( temp ) && ( temp <= 0xAF ) ) ; <S2SV_StartBug> if ( i4_continue_decode ) <S2SV_EndBug> { if ( ( temp - 1 ) == i4_cur_row ) { i4_dequeue_job = 0 ; break ; } if ( temp < ps_dec -> i4_end_mb_y ) { i4_cur_row = ps_dec -> u2_mb_y ; } else { i4_dequeue_job = 1 ; } break ; } else break ; } } while ( i4_continue_decode ) ; if ( ps_dec -> i4_num_cores > 1 ) { while ( 1 ) { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; e_ret = impeg2_jobq_dequeue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 1 ) ; if ( e_ret != IV_SUCCESS ) break ; if ( CMD_FMTCONV == s_job . i4_cmd ) { WORD32 start_row ; WORD32 num_rows ; start_row = s_job . i2_start_mb_y << 4 ; num_rows = MIN ( ( s_job . i2_end_mb_y << 4 ) , ps_dec -> u2_vertical_size ) ; num_rows -= start_row ; impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; } } } else { if ( ( NULL != ps_dec -> ps_disp_pic ) && ( ( 0 == ps_dec -> u4_share_disp_buf ) || ( IV_YUV_420P != ps_dec -> i4_chromaFormat ) ) ) impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , 0 , ps_dec -> u2_vertical_size ) ; } }
CWE-119 <S2SV_StartBug> void Huff_transmit ( huff_t * huff , int ch , byte * fout ) { <S2SV_EndBug> int i ; if ( huff -> loc [ ch ] == NULL ) { <S2SV_StartBug> Huff_transmit ( huff , NYT , fout ) ; <S2SV_EndBug> for ( i = 7 ; i >= 0 ; i -- ) { add_bit ( ( char ) ( ( ch >> i ) & 0x1 ) , fout ) ; } } else { <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> } }
CWE-189 static void sgi_timer_get ( struct k_itimer * timr , struct itimerspec * cur_setting ) { if ( timr -> it . mmtimer . clock == TIMER_OFF ) { cur_setting -> it_interval . tv_nsec = 0 ; cur_setting -> it_interval . tv_sec = 0 ; cur_setting -> it_value . tv_nsec = 0 ; cur_setting -> it_value . tv_sec = 0 ; return ; } <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> }
CWE-000 static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL ; client . realm = in_creds -> server -> realm ; client . data = NULL ; client . length = 0 ; client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ; } code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ; <S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug> * canon_user = userid . user ; userid . user = NULL ; code = 0 ; } cleanup : krb5_free_cred_contents ( context , & creds ) ; if ( opts != NULL ) krb5_get_init_creds_opt_free ( context , opts ) ; if ( userid . user != NULL ) krb5_free_principal ( context , userid . user ) ; return code ; }
CWE-000 static int btrfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) { struct btrfs_trans_handle * trans ; struct btrfs_root * root = BTRFS_I ( old_dir ) -> root ; struct btrfs_root * dest = BTRFS_I ( new_dir ) -> root ; struct inode * new_inode = new_dentry -> d_inode ; struct inode * old_inode = old_dentry -> d_inode ; struct timespec ctime = CURRENT_TIME ; u64 index = 0 ; u64 root_objectid ; int ret ; u64 old_ino = btrfs_ino ( old_inode ) ; if ( btrfs_ino ( new_dir ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) return - EPERM ; if ( old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest ) return - EXDEV ; if ( old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID || ( new_inode && btrfs_ino ( new_inode ) == BTRFS_FIRST_FREE_OBJECTID ) ) return - ENOTEMPTY ; if ( S_ISDIR ( old_inode -> i_mode ) && new_inode && new_inode -> i_size > BTRFS_EMPTY_DIR_SIZE ) return - ENOTEMPTY ; <S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug> old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ; if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) down_read ( & root -> fs_info -> subvol_sem ) ; trans = btrfs_start_transaction ( root , 20 ) ; if ( IS_ERR ( trans ) ) { ret = PTR_ERR ( trans ) ; goto out_notrans ; } if ( dest != root ) btrfs_record_root_in_trans ( trans , dest ) ; ret = btrfs_set_inode_index ( new_dir , & index ) ; if ( ret ) goto out_fail ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root -> fs_info -> last_trans_log_full_commit = trans -> transid ; } else { ret = btrfs_insert_inode_ref ( trans , dest , new_dentry -> d_name . name , new_dentry -> d_name . len , old_ino , btrfs_ino ( new_dir ) , index ) ; if ( ret ) goto out_fail ; btrfs_pin_log_trans ( root ) ; } if ( new_inode && new_inode -> i_size && S_ISREG ( old_inode -> i_mode ) ) btrfs_add_ordered_operation ( trans , root , old_inode ) ; inode_inc_iversion ( old_dir ) ; inode_inc_iversion ( new_dir ) ; inode_inc_iversion ( old_inode ) ; old_dir -> i_ctime = old_dir -> i_mtime = ctime ; new_dir -> i_ctime = new_dir -> i_mtime = ctime ; old_inode -> i_ctime = ctime ; if ( old_dentry -> d_parent != new_dentry -> d_parent ) btrfs_record_unlink_dir ( trans , old_dir , old_inode , 1 ) ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root_objectid = BTRFS_I ( old_inode ) -> root -> root_key . objectid ; ret = btrfs_unlink_subvol ( trans , root , old_dir , root_objectid , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; } else { ret = __btrfs_unlink_inode ( trans , root , old_dir , old_dentry -> d_inode , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; if ( ! ret ) ret = btrfs_update_inode ( trans , root , old_inode ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( new_inode ) { inode_inc_iversion ( new_inode ) ; new_inode -> i_ctime = CURRENT_TIME ; if ( unlikely ( btrfs_ino ( new_inode ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) ) { root_objectid = BTRFS_I ( new_inode ) -> location . objectid ; ret = btrfs_unlink_subvol ( trans , dest , new_dir , root_objectid , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; BUG_ON ( new_inode -> i_nlink == 0 ) ; } else { ret = btrfs_unlink_inode ( trans , dest , new_dir , new_dentry -> d_inode , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; } if ( ! ret && new_inode -> i_nlink == 0 ) { ret = btrfs_orphan_add ( trans , new_dentry -> d_inode ) ; BUG_ON ( ret ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } } fixup_inode_flags ( new_dir , old_inode ) ; ret = btrfs_add_link ( trans , new_dir , old_inode , new_dentry -> d_name . name , new_dentry -> d_name . len , 0 , index ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( old_ino != BTRFS_FIRST_FREE_OBJECTID ) { struct dentry * parent = new_dentry -> d_parent ; btrfs_log_new_name ( trans , old_inode , old_dir , parent ) ; btrfs_end_log_trans ( root ) ; } out_fail : btrfs_end_transaction ( trans , root ) ; out_notrans : if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) up_read ( & root -> fs_info -> subvol_sem ) ; return ret ; }
CWE-125 void bootp_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register const struct bootp * bp ; static const u_char vm_cmu [ 4 ] = VM_CMU ; static const u_char vm_rfc1048 [ 4 ] = VM_RFC1048 ; bp = ( const struct bootp * ) cp ; ND_TCHECK ( bp -> bp_op ) ; ND_PRINT ( ( ndo , "BOOTP/DHCP,<S2SV_blank>%s" , tok2str ( bootp_op_values , "unknown<S2SV_blank>(0x%02x)" , bp -> bp_op ) ) ) ; ND_TCHECK ( bp -> bp_hlen ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 && bp -> bp_op == BOOTPREQUEST ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>from<S2SV_blank>%s" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_TCHECK ( bp -> bp_secs ) ; if ( bp -> bp_htype != 1 ) ND_PRINT ( ( ndo , ",<S2SV_blank>htype<S2SV_blank>%d" , bp -> bp_htype ) ) ; if ( bp -> bp_htype != 1 || bp -> bp_hlen != 6 ) ND_PRINT ( ( ndo , ",<S2SV_blank>hlen<S2SV_blank>%d" , bp -> bp_hlen ) ) ; if ( bp -> bp_hops ) ND_PRINT ( ( ndo , ",<S2SV_blank>hops<S2SV_blank>%d" , bp -> bp_hops ) ) ; if ( EXTRACT_32BITS ( & bp -> bp_xid ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>xid<S2SV_blank>0x%x" , EXTRACT_32BITS ( & bp -> bp_xid ) ) ) ; if ( EXTRACT_16BITS ( & bp -> bp_secs ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>secs<S2SV_blank>%d" , EXTRACT_16BITS ( & bp -> bp_secs ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s]" , <S2SV_EndBug> bittok2str ( bootp_flag_values , "none" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "<S2SV_blank>(0x%04x)" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ; ND_TCHECK ( bp -> bp_ciaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_ciaddr . s_addr ) ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Client-IP<S2SV_blank>%s" , ipaddr_string ( ndo , & bp -> bp_ciaddr ) ) ) ; ND_TCHECK ( bp -> bp_yiaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_yiaddr . s_addr ) ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Your-IP<S2SV_blank>%s" , ipaddr_string ( ndo , & bp -> bp_yiaddr ) ) ) ; ND_TCHECK ( bp -> bp_siaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_siaddr . s_addr ) ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Server-IP<S2SV_blank>%s" , ipaddr_string ( ndo , & bp -> bp_siaddr ) ) ) ; ND_TCHECK ( bp -> bp_giaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_giaddr . s_addr ) ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Gateway-IP<S2SV_blank>%s" , ipaddr_string ( ndo , & bp -> bp_giaddr ) ) ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Client-Ethernet-Address<S2SV_blank>%s" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_TCHECK2 ( bp -> bp_sname [ 0 ] , 1 ) ; if ( * bp -> bp_sname ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>sname<S2SV_blank>\\"" ) ) ; if ( fn_printztn ( ndo , bp -> bp_sname , ( u_int ) sizeof bp -> bp_sname , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , "\\"" ) ) ; ND_PRINT ( ( ndo , "%s" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } ND_TCHECK2 ( bp -> bp_file [ 0 ] , 1 ) ; if ( * bp -> bp_file ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>file<S2SV_blank>\\"" ) ) ; if ( fn_printztn ( ndo , bp -> bp_file , ( u_int ) sizeof bp -> bp_file , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , "\\"" ) ) ; ND_PRINT ( ( ndo , "%s" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } ND_TCHECK ( bp -> bp_vend [ 0 ] ) ; if ( memcmp ( ( const char * ) bp -> bp_vend , vm_rfc1048 , sizeof ( uint32_t ) ) == 0 ) rfc1048_print ( ndo , bp -> bp_vend ) ; else if ( memcmp ( ( const char * ) bp -> bp_vend , vm_cmu , sizeof ( uint32_t ) ) == 0 ) cmu_print ( ndo , bp -> bp_vend ) ; else { uint32_t ul ; ul = EXTRACT_32BITS ( & bp -> bp_vend ) ; if ( ul != 0 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Vendor-#0x%x" , ul ) ) ; } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-20 static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) { MXFContext * mxf = arg ; int item_num = avio_rb32 ( pb ) ; int item_len = avio_rb32 ( pb ) ; if ( item_len != 18 ) { avpriv_request_sample ( pb , "Primer<S2SV_blank>pack<S2SV_blank>item<S2SV_blank>length<S2SV_blank>%d" , item_len ) ; return AVERROR_PATCHWELCOME ; } <S2SV_StartBug> if ( item_num > 65536 ) { <S2SV_EndBug> av_log ( mxf -> fc , AV_LOG_ERROR , "item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\n" , item_num ) ; return AVERROR_INVALIDDATA ; } if ( mxf -> local_tags ) av_log ( mxf -> fc , AV_LOG_VERBOSE , "Multiple<S2SV_blank>primer<S2SV_blank>packs\\n" ) ; av_free ( mxf -> local_tags ) ; mxf -> local_tags_count = 0 ; mxf -> local_tags = av_calloc ( item_num , item_len ) ; if ( ! mxf -> local_tags ) return AVERROR ( ENOMEM ) ; mxf -> local_tags_count = item_num ; avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; return 0 ; }
CWE-399 void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; <S2SV_StartBug> kfree ( fpl ) ; <S2SV_EndBug> } }
CWE-362 static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) { int r = EMULATE_DONE ; ++ vcpu -> stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ; r = EMULATE_FAIL ; } kvm_queue_exception ( vcpu , UD_VECTOR ) ; return r ; }
CWE-125 int common_timer_set ( struct k_itimer * timr , int flags , struct itimerspec64 * new_setting , struct itimerspec64 * old_setting ) { const struct k_clock * kc = timr -> kclock ; bool sigev_none ; ktime_t expires ; if ( old_setting ) common_timer_get ( timr , old_setting ) ; timr -> it_interval = 0 ; if ( kc -> timer_try_to_cancel ( timr ) < 0 ) return TIMER_RETRY ; timr -> it_active = 0 ; timr -> it_requeue_pending = ( timr -> it_requeue_pending + 2 ) & ~ REQUEUE_PENDING ; timr -> it_overrun_last = 0 ; if ( ! new_setting -> it_value . tv_sec && ! new_setting -> it_value . tv_nsec ) return 0 ; timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; expires = timespec64_to_ktime ( new_setting -> it_value ) ; <S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr -> it_active = ! sigev_none ; return 0 ; }
CWE-119 <S2SV_StartBug> static void vp8_init_ctx ( vpx_codec_ctx_t * ctx , const vpx_codec_mmap_t * mmap ) <S2SV_EndBug> { int i ; <S2SV_StartBug> ctx -> priv = mmap -> base ; <S2SV_EndBug> ctx -> priv -> sz = sizeof ( * ctx -> priv ) ; ctx -> priv -> iface = ctx -> iface ; ctx -> priv -> alg_priv = mmap -> base ; for ( i = 0 ; i < NELEMENTS ( ctx -> priv -> alg_priv -> mmaps ) ; i ++ ) ctx -> priv -> alg_priv -> mmaps [ i ] . id = vp8_mem_req_segs [ i ] . id ; ctx -> priv -> alg_priv -> mmaps [ 0 ] = * mmap ; ctx -> priv -> alg_priv -> si . sz = sizeof ( ctx -> priv -> alg_priv -> si ) ; ctx -> priv -> alg_priv -> decrypt_cb = NULL ; ctx -> priv -> alg_priv -> decrypt_state = NULL ; ctx -> priv -> init_flags = ctx -> init_flags ; <S2SV_StartBug> if ( ctx -> config . dec ) <S2SV_EndBug> { <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> } }
CWE-476 static int asymmetric_key_match_preparse ( struct key_match_data * match_data ) { match_data -> lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-399 static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; <S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> } }
CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; proto = EXTRACT_16BITS ( & p [ 2 ] ) ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , "%s,<S2SV_blank>ethertype<S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>" , tok2str ( chdlc_cast_values , "0x%02x" , p [ 0 ] ) , tok2str ( ethertype_values , "Unknown" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( * ( p + 1 ) == 0x81 || * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; <S2SV_EndBug> else <S2SV_StartBug> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; <S2SV_EndBug> break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "unknown<S2SV_blank>CHDLC<S2SV_blank>protocol<S2SV_blank>(0x%04x)" , proto ) ) ; break ; } return ( CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , "[|chdlc]" ) ) ; return ndo -> ndo_snapend - bp ; }
CWE-119 void Strgrow ( Str x ) { char * old = x -> ptr ; int newlen ; <S2SV_StartBug> newlen = x -> length * 6 / 5 ; <S2SV_EndBug> <S2SV_StartBug> if ( newlen == x -> length ) <S2SV_EndBug> newlen += 2 ; x -> ptr = GC_MALLOC_ATOMIC ( newlen ) ; x -> area_size = newlen ; bcopy ( ( void * ) old , ( void * ) x -> ptr , x -> length ) ; GC_free ( old ) ; }
CWE-20 static void cmd_parse_status ( struct ImapData * idata , char * s ) { char * value = NULL ; struct Buffy * inc = NULL ; struct ImapMbox mx ; struct ImapStatus * status = NULL ; unsigned int olduv , oldun ; unsigned int litlen ; short new = 0 ; short new_msg_count = 0 ; char * mailbox = imap_next_word ( s ) ; if ( imap_get_literal_count ( mailbox , & litlen ) == 0 ) { if ( imap_cmd_step ( idata ) != IMAP_CMD_CONTINUE ) { <S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> return ; } mailbox = idata -> buf ; s = mailbox + litlen ; * s = '\\0' ; s ++ ; SKIPWS ( s ) ; } else { s = imap_next_word ( mailbox ) ; * ( s - 1 ) = '\\0' ; imap_unmunge_mbox_name ( idata , mailbox ) ; } status = imap_mboxcache_get ( idata , mailbox , 1 ) ; olduv = status -> uidvalidity ; oldun = status -> uidnext ; if ( * s ++ != '(' ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS\\n" ) ; return ; } while ( * s && * s != ')' ) { value = imap_next_word ( s ) ; errno = 0 ; const unsigned long ulcount = strtoul ( value , & value , 10 ) ; if ( ( ( errno == ERANGE ) && ( ulcount == ULONG_MAX ) ) || ( ( unsigned int ) ulcount != ulcount ) ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>number\\n" ) ; return ; } const unsigned int count = ( unsigned int ) ulcount ; if ( mutt_str_strncmp ( "MESSAGES" , s , 8 ) == 0 ) { status -> messages = count ; new_msg_count = 1 ; } else if ( mutt_str_strncmp ( "RECENT" , s , 6 ) == 0 ) status -> recent = count ; else if ( mutt_str_strncmp ( "UIDNEXT" , s , 7 ) == 0 ) status -> uidnext = count ; else if ( mutt_str_strncmp ( "UIDVALIDITY" , s , 11 ) == 0 ) status -> uidvalidity = count ; else if ( mutt_str_strncmp ( "UNSEEN" , s , 6 ) == 0 ) status -> unseen = count ; s = value ; if ( * s && * s != ')' ) s = imap_next_word ( s ) ; } mutt_debug ( 3 , "%s<S2SV_blank>(UIDVALIDITY:<S2SV_blank>%u,<S2SV_blank>UIDNEXT:<S2SV_blank>%u)<S2SV_blank>%d<S2SV_blank>messages,<S2SV_blank>%d<S2SV_blank>recent,<S2SV_blank>%d<S2SV_blank>unseen\\n" , status -> name , status -> uidvalidity , status -> uidnext , status -> messages , status -> recent , status -> unseen ) ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_STATUS ) { memcpy ( idata -> cmddata , status , sizeof ( struct ImapStatus ) ) ; return ; } mutt_debug ( 3 , "Running<S2SV_blank>default<S2SV_blank>STATUS<S2SV_blank>handler\\n" ) ; for ( inc = Incoming ; inc ; inc = inc -> next ) { if ( inc -> magic != MUTT_IMAP ) continue ; if ( imap_parse_path ( inc -> path , & mx ) < 0 ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>mailbox<S2SV_blank>%s,<S2SV_blank>skipping\\n" , inc -> path ) ; continue ; } if ( imap_account_match ( & idata -> conn -> account , & mx . account ) ) { if ( mx . mbox ) { value = mutt_str_strdup ( mx . mbox ) ; imap_fix_path ( idata , mx . mbox , value , mutt_str_strlen ( value ) + 1 ) ; FREE ( & mx . mbox ) ; } else value = mutt_str_strdup ( "INBOX" ) ; if ( value && ( imap_mxcmp ( mailbox , value ) == 0 ) ) { mutt_debug ( 3 , "Found<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>buffy<S2SV_blank>list<S2SV_blank>(OV:<S2SV_blank>%u<S2SV_blank>ON:<S2SV_blank>%u<S2SV_blank>U:<S2SV_blank>%d)\\n" , mailbox , olduv , oldun , status -> unseen ) ; if ( MailCheckRecent ) { if ( olduv && olduv == status -> uidvalidity ) { if ( oldun < status -> uidnext ) new = ( status -> unseen > 0 ) ; } else if ( ! olduv && ! oldun ) { new = ( status -> recent > 0 ) ; } else new = ( status -> unseen > 0 ) ; } else new = ( status -> unseen > 0 ) ; # ifdef USE_SIDEBAR if ( ( inc -> new != new ) || ( inc -> msg_count != status -> messages ) || ( inc -> msg_unread != status -> unseen ) ) { mutt_menu_set_current_redraw ( REDRAW_SIDEBAR ) ; } # endif inc -> new = new ; if ( new_msg_count ) inc -> msg_count = status -> messages ; inc -> msg_unread = status -> unseen ; if ( inc -> new ) { status -> uidnext = oldun ; } FREE ( & value ) ; return ; } FREE ( & value ) ; } FREE ( & mx . mbox ) ; } }
CWE-000 int ssl3_read_n ( SSL * s , int n , int max , int extend ) { int i , len , left ; long align = 0 ; unsigned char * pkt ; SSL3_BUFFER * rb ; if ( n <= 0 ) return n ; rb = & ( s -> s3 -> rbuf ) ; if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ; left = rb -> left ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( long ) rb -> buf + SSL3_RT_HEADER_LENGTH ; align = ( - align ) & ( SSL3_ALIGN_PAYLOAD - 1 ) ; # endif if ( ! extend ) { if ( left == 0 ) rb -> offset = align ; else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) { pkt = rb -> buf + rb -> offset ; if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) { memmove ( rb -> buf + align , pkt , left ) ; rb -> offset = align ; } } s -> packet = rb -> buf + rb -> offset ; s -> packet_length = 0 ; } if ( SSL_IS_DTLS ( s ) ) { <S2SV_StartBug> if ( left > 0 && n > left ) <S2SV_EndBug> n = left ; } if ( left >= n ) { s -> packet_length += n ; rb -> left = left - n ; rb -> offset += n ; return ( n ) ; } len = s -> packet_length ; pkt = rb -> buf + align ; if ( s -> packet != pkt ) { memmove ( pkt , s -> packet , len + left ) ; s -> packet = pkt ; rb -> offset = len + align ; } if ( n > ( int ) ( rb -> len - rb -> offset ) ) { SSLerr ( SSL_F_SSL3_READ_N , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! s -> read_ahead ) max = n ; else { if ( max < n ) max = n ; if ( max > ( int ) ( rb -> len - rb -> offset ) ) max = rb -> len - rb -> offset ; } while ( left < n ) { clear_sys_error ( ) ; if ( s -> rbio != NULL ) { s -> rwstate = SSL_READING ; i = BIO_read ( s -> rbio , pkt + len + left , max - left ) ; } else { SSLerr ( SSL_F_SSL3_READ_N , SSL_R_READ_BIO_NOT_SET ) ; i = - 1 ; } if ( i <= 0 ) { rb -> left = left ; if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) if ( len + left == 0 ) ssl3_release_read_buffer ( s ) ; return ( i ) ; } left += i ; if ( SSL_IS_DTLS ( s ) ) { if ( n > left ) n = left ; } } rb -> offset += n ; rb -> left = left - n ; s -> packet_length += n ; s -> rwstate = SSL_NOTHING ; return ( n ) ; }
CWE-399 static int asf_build_simple_index ( AVFormatContext * s , int stream_index ) { ff_asf_guid g ; ASFContext * asf = s -> priv_data ; int64_t current_pos = avio_tell ( s -> pb ) ; int64_t ret ; if ( ( ret = avio_seek ( s -> pb , asf -> data_object_offset + asf -> data_object_size , SEEK_SET ) ) < 0 ) { return ret ; } if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; while ( ff_guidcmp ( & g , & ff_asf_simple_index_header ) ) { int64_t gsize = avio_rl64 ( s -> pb ) ; if ( gsize < 24 || avio_feof ( s -> pb ) ) { goto end ; } avio_skip ( s -> pb , gsize - 24 ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; } { int64_t itime , last_pos = - 1 ; int pct , ict ; int i ; int64_t av_unused gsize = avio_rl64 ( s -> pb ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; itime = avio_rl64 ( s -> pb ) ; pct = avio_rl32 ( s -> pb ) ; ict = avio_rl32 ( s -> pb ) ; av_log ( s , AV_LOG_DEBUG , "itime:0x%" PRIx64 ",<S2SV_blank>pct:%d,<S2SV_blank>ict:%d\\n" , itime , pct , ict ) ; for ( i = 0 ; i < ict ; i ++ ) { int pktnum = avio_rl32 ( s -> pb ) ; int pktct = avio_rl16 ( s -> pb ) ; int64_t pos = s -> internal -> data_offset + s -> packet_size * ( int64_t ) pktnum ; <S2SV_StartBug> int64_t index_pts = FFMAX ( av_rescale ( itime , i , 10000 ) - asf -> hdr . preroll , 0 ) ; <S2SV_EndBug> if ( pos != last_pos ) { av_log ( s , AV_LOG_DEBUG , "pktnum:%d,<S2SV_blank>pktct:%d<S2SV_blank><S2SV_blank>pts:<S2SV_blank>%" PRId64 "\\n" , pktnum , pktct , index_pts ) ; av_add_index_entry ( s -> streams [ stream_index ] , pos , index_pts , s -> packet_size , 0 , AVINDEX_KEYFRAME ) ; last_pos = pos ; } } asf -> index_read = ict > 1 ; } end : avio_seek ( s -> pb , current_pos , SEEK_SET ) ; return ret ; }
CWE-190 static int do_timer_create ( clockid_t which_clock , struct sigevent * event , timer_t __user * created_timer_id ) { const struct k_clock * kc = clockid_to_kclock ( which_clock ) ; struct k_itimer * new_timer ; int error , new_timer_id ; int it_id_set = IT_ID_NOT_SET ; if ( ! kc ) return - EINVAL ; if ( ! kc -> timer_create ) return - EOPNOTSUPP ; new_timer = alloc_posix_timer ( ) ; if ( unlikely ( ! new_timer ) ) return - EAGAIN ; spin_lock_init ( & new_timer -> it_lock ) ; new_timer_id = posix_timer_add ( new_timer ) ; if ( new_timer_id < 0 ) { error = new_timer_id ; goto out ; } it_id_set = IT_ID_SET ; new_timer -> it_id = ( timer_t ) new_timer_id ; new_timer -> it_clock = which_clock ; new_timer -> kclock = kc ; <S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> if ( event ) { rcu_read_lock ( ) ; new_timer -> it_pid = get_pid ( good_sigevent ( event ) ) ; rcu_read_unlock ( ) ; if ( ! new_timer -> it_pid ) { error = - EINVAL ; goto out ; } new_timer -> it_sigev_notify = event -> sigev_notify ; new_timer -> sigq -> info . si_signo = event -> sigev_signo ; new_timer -> sigq -> info . si_value = event -> sigev_value ; } else { new_timer -> it_sigev_notify = SIGEV_SIGNAL ; new_timer -> sigq -> info . si_signo = SIGALRM ; memset ( & new_timer -> sigq -> info . si_value , 0 , sizeof ( sigval_t ) ) ; new_timer -> sigq -> info . si_value . sival_int = new_timer -> it_id ; new_timer -> it_pid = get_pid ( task_tgid ( current ) ) ; } new_timer -> sigq -> info . si_tid = new_timer -> it_id ; new_timer -> sigq -> info . si_code = SI_TIMER ; if ( copy_to_user ( created_timer_id , & new_timer_id , sizeof ( new_timer_id ) ) ) { error = - EFAULT ; goto out ; } error = kc -> timer_create ( new_timer ) ; if ( error ) goto out ; spin_lock_irq ( & current -> sighand -> siglock ) ; new_timer -> it_signal = current -> signal ; list_add ( & new_timer -> list , & current -> signal -> posix_timers ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return 0 ; out : release_posix_timer ( new_timer , it_id_set ) ; return error ; }
CWE-264 static bool caller_is_in_ancestor ( pid_t pid , const char * contrl , const char * cg , char * * nextcg ) { <S2SV_StartBug> char fnam [ PROCLEN ] ; <S2SV_EndBug> FILE * f ; bool answer = false ; <S2SV_StartBug> char * line = NULL ; <S2SV_EndBug> size_t len = 0 ; int ret ; ret = snprintf ( fnam , PROCLEN , "/proc/%d/cgroup" , pid ) ; if ( ret < 0 || ret >= PROCLEN ) return false ; if ( ! ( f = fopen ( fnam , "r" ) ) ) return false ; while ( getline ( & line , & len , f ) != - 1 ) { char * c1 , * c2 , * linecmp ; if ( ! line [ 0 ] ) continue ; c1 = strchr ( line , ':' ) ; if ( ! c1 ) goto out ; c1 ++ ; c2 = strchr ( c1 , ':' ) ; if ( ! c2 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> * c2 = '\\0' ; if ( strcmp ( c1 , contrl ) != 0 ) continue ; c2 ++ ; stripnewline ( c2 ) ; prune_init_slice ( c2 ) ; linecmp = * cg == '/' ? c2 : c2 + 1 ; if ( strncmp ( linecmp , cg , strlen ( linecmp ) ) != 0 ) { <S2SV_StartBug> if ( nextcg ) <S2SV_EndBug> * nextcg = get_next_cgroup_dir ( linecmp , cg ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } answer = true ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } out : fclose ( f ) ; free ( line ) ; return answer ; }
CWE-190 PHPAPI PHP_FUNCTION ( fread ) { zval * arg1 ; long len ; php_stream * stream ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "rl" , & arg1 , & len ) == FAILURE ) { RETURN_FALSE ; } PHP_STREAM_TO_ZVAL ( stream , & arg1 ) ; if ( len <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }
CWE-200 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
CWE-119 bool radeon_atom_get_tv_timings ( struct radeon_device * rdev , int index , struct drm_display_mode * mode ) { struct radeon_mode_info * mode_info = & rdev -> mode_info ; ATOM_ANALOG_TV_INFO * tv_info ; ATOM_ANALOG_TV_INFO_V1_2 * tv_info_v1_2 ; ATOM_DTD_FORMAT * dtd_timings ; int data_index = GetIndexIntoMasterTable ( DATA , AnalogTV_Info ) ; u8 frev , crev ; u16 data_offset , misc ; if ( ! atom_parse_data_header ( mode_info -> atom_context , data_index , NULL , & frev , & crev , & data_offset ) ) return false ; switch ( crev ) { case 1 : tv_info = ( ATOM_ANALOG_TV_INFO * ) ( mode_info -> atom_context -> bios + data_offset ) ; <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING ) <S2SV_EndBug> return false ; mode -> crtc_htotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Total ) ; mode -> crtc_hdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Disp ) ; mode -> crtc_hsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) ; mode -> crtc_hsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Total ) ; mode -> crtc_vdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Disp ) ; mode -> crtc_vsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) ; mode -> crtc_vsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) + le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( tv_info -> aModeTimings [ index ] . susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usPixelClock ) * 10 ; if ( index == 1 ) { mode -> crtc_htotal -= 1 ; mode -> crtc_vtotal -= 1 ; } break ; case 2 : tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ; <S2SV_StartBug> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) <S2SV_EndBug> return false ; dtd_timings = & tv_info_v1_2 -> aModeTimings [ index ] ; mode -> crtc_htotal = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHBlanking_Time ) ; mode -> crtc_hdisplay = le16_to_cpu ( dtd_timings -> usHActive ) ; mode -> crtc_hsync_start = le16_to_cpu ( dtd_timings -> usHActive ) + le16_to_cpu ( dtd_timings -> usHSyncOffset ) ; mode -> crtc_hsync_end = mode -> crtc_hsync_start + le16_to_cpu ( dtd_timings -> usHSyncWidth ) ; mode -> crtc_vtotal = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVBlanking_Time ) ; mode -> crtc_vdisplay = le16_to_cpu ( dtd_timings -> usVActive ) ; mode -> crtc_vsync_start = le16_to_cpu ( dtd_timings -> usVActive ) + le16_to_cpu ( dtd_timings -> usVSyncOffset ) ; mode -> crtc_vsync_end = mode -> crtc_vsync_start + le16_to_cpu ( dtd_timings -> usVSyncWidth ) ; mode -> flags = 0 ; misc = le16_to_cpu ( dtd_timings -> susModeMiscInfo . usAccess ) ; if ( misc & ATOM_VSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NVSYNC ; if ( misc & ATOM_HSYNC_POLARITY ) mode -> flags |= DRM_MODE_FLAG_NHSYNC ; if ( misc & ATOM_COMPOSITESYNC ) mode -> flags |= DRM_MODE_FLAG_CSYNC ; if ( misc & ATOM_INTERLACE ) mode -> flags |= DRM_MODE_FLAG_INTERLACE ; if ( misc & ATOM_DOUBLE_CLOCK_MODE ) mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; mode -> clock = le16_to_cpu ( dtd_timings -> usPixClk ) * 10 ; break ; } return true ; }
CWE-119 static int calc_pframe_target_size_one_pass_vbr ( const VP9_COMP * const cpi ) { static const int af_ratio = 10 ; const RATE_CONTROL * const rc = & cpi -> rc ; int target ; # if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ? <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / <S2SV_EndBug> ( rc -> baseline_gf_interval + af_ratio - 1 ) : <S2SV_StartBug> ( rc -> av_per_frame_bandwidth * rc -> baseline_gf_interval ) / <S2SV_EndBug> ( rc -> baseline_gf_interval + af_ratio - 1 ) ; # else <S2SV_StartBug> target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> # endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ; }
CWE-20 NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( "Aiee,<S2SV_blank>killing<S2SV_blank>interrupt<S2SV_blank>handler!" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( "Attempted<S2SV_blank>to<S2SV_blank>kill<S2SV_blank>the<S2SV_blank>idle<S2SV_blank>task!" ) ; tracehook_report_exit ( & code ) ; validate_creds_for_do_exit ( tsk ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT "Fixing<S2SV_blank>recursive<S2SV_blank>fault<S2SV_blank>but<S2SV_blank>reboot<S2SV_blank>is<S2SV_blank>needed!\\n" ) ; tsk -> flags |= PF_EXITPIDONE ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_irq_thread ( ) ; exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO "note:<S2SV_blank>%s[%d]<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>preempt_count<S2SV_blank>%d\\n" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; if ( tsk -> mm ) setmax_mm_hiwater_rss ( & tsk -> signal -> maxrss , tsk -> mm ) ; } acct_collect ( code , group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; proc_exit_connector ( tsk ) ; perf_event_exit_task ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif # ifdef CONFIG_FUTEX if ( unlikely ( current -> pi_state_cache ) ) kfree ( current -> pi_state_cache ) ; # endif debug_check_no_locks_held ( tsk ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context ) <S2SV_StartBug> exit_io_context ( ) ; <S2SV_EndBug> if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ; validate_creds_for_do_exit ( tsk ) ; preempt_disable ( ) ; exit_rcu ( ) ; tsk -> state = TASK_DEAD ; schedule ( ) ; BUG ( ) ; for ( ; ; ) cpu_relax ( ) ; }
CWE-416 R_API int r_core_bin_set_env ( RCore * r , RBinFile * binfile ) { RBinObject * binobj = binfile ? binfile -> o : NULL ; RBinInfo * info = binobj ? binobj -> info : NULL ; if ( info ) { int va = info -> has_va ; <S2SV_StartBug> const char * arch = info -> arch ; <S2SV_EndBug> ut16 bits = info -> bits ; ut64 baseaddr = r_bin_get_baddr ( r -> bin ) ; r_config_set_i ( r -> config , "io.va" , ( binobj -> info ) ? binobj -> info -> has_va : 0 ) ; r_config_set_i ( r -> config , "bin.baddr" , baseaddr ) ; r_config_set ( r -> config , "asm.arch" , arch ) ; r_config_set_i ( r -> config , "asm.bits" , bits ) ; r_config_set ( r -> config , "anal.arch" , arch ) ; <S2SV_StartBug> if ( info -> cpu && * info -> cpu ) { <S2SV_EndBug> <S2SV_StartBug> r_config_set ( r -> config , "anal.cpu" , info -> cpu ) ; <S2SV_EndBug> } else { r_config_set ( r -> config , "anal.cpu" , arch ) ; } r_asm_use ( r -> assembler , arch ) ; r_core_bin_info ( r , R_CORE_BIN_ACC_ALL , R_CORE_BIN_SET , va , NULL , NULL ) ; <S2SV_StartBug> r_core_bin_set_cur ( r , binfile ) ; <S2SV_EndBug> return true ; } return false ; }
CWE-000 const char * WinPKIErrorString ( void ) { static char error_string [ 64 ] ; DWORD error_code = GetLastError ( ) ; <S2SV_StartBug> if ( ( error_code >> 16 ) != 0x8009 ) <S2SV_EndBug> return WindowsErrorString ( ) ; switch ( error_code ) { case NTE_BAD_UID : return "Bad<S2SV_blank>UID." ; case CRYPT_E_MSG_ERROR : return "An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>performing<S2SV_blank>an<S2SV_blank>operation<S2SV_blank>on<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message." ; case CRYPT_E_UNKNOWN_ALGO : return "Unknown<S2SV_blank>cryptographic<S2SV_blank>algorithm." ; case CRYPT_E_INVALID_MSG_TYPE : return "Invalid<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>type." ; case CRYPT_E_HASH_VALUE : return "The<S2SV_blank>hash<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct" ; case CRYPT_E_ISSUER_SERIALNUMBER : return "Invalid<S2SV_blank>issuer<S2SV_blank>and/or<S2SV_blank>serial<S2SV_blank>number." ; case CRYPT_E_BAD_LEN : return "The<S2SV_blank>length<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>data<S2SV_blank>was<S2SV_blank>insufficient." ; case CRYPT_E_BAD_ENCODE : return "An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>during<S2SV_blank>encode<S2SV_blank>or<S2SV_blank>decode<S2SV_blank>operation." ; case CRYPT_E_FILE_ERROR : return "An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>or<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file." ; case CRYPT_E_NOT_FOUND : return "Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property." ; case CRYPT_E_EXISTS : return "The<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property<S2SV_blank>already<S2SV_blank>exists." ; case CRYPT_E_NO_PROVIDER : return "No<S2SV_blank>provider<S2SV_blank>was<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>store<S2SV_blank>or<S2SV_blank>object." ; case CRYPT_E_DELETED_PREV : return "The<S2SV_blank>previous<S2SV_blank>certificate<S2SV_blank>or<S2SV_blank>CRL<S2SV_blank>context<S2SV_blank>was<S2SV_blank>deleted." ; case CRYPT_E_NO_MATCH : return "Cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>requested<S2SV_blank>object." ; case CRYPT_E_UNEXPECTED_MSG_TYPE : case CRYPT_E_NO_KEY_PROPERTY : case CRYPT_E_NO_DECRYPT_CERT : return "Private<S2SV_blank>key<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>issue" ; case CRYPT_E_BAD_MSG : return "Not<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message." ; case CRYPT_E_NO_SIGNER : return "The<S2SV_blank>signed<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>a<S2SV_blank>signer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>signer<S2SV_blank>index." ; case CRYPT_E_REVOKED : return "The<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>revoked." ; case CRYPT_E_NO_REVOCATION_DLL : case CRYPT_E_NO_REVOCATION_CHECK : case CRYPT_E_REVOCATION_OFFLINE : case CRYPT_E_NOT_IN_REVOCATION_DATABASE : return "Cannot<S2SV_blank>check<S2SV_blank>certificate<S2SV_blank>revocation." ; case CRYPT_E_INVALID_NUMERIC_STRING : case CRYPT_E_INVALID_PRINTABLE_STRING : case CRYPT_E_INVALID_IA5_STRING : case CRYPT_E_INVALID_X500_STRING : case CRYPT_E_NOT_CHAR_STRING : return "Invalid<S2SV_blank>string." ; case CRYPT_E_SECURITY_SETTINGS : return "The<S2SV_blank>cryptographic<S2SV_blank>operation<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>a<S2SV_blank>local<S2SV_blank>security<S2SV_blank>option<S2SV_blank>setting." ; case CRYPT_E_NO_VERIFY_USAGE_CHECK : case CRYPT_E_VERIFY_USAGE_OFFLINE : return "Cannot<S2SV_blank>complete<S2SV_blank>usage<S2SV_blank>check." ; case CRYPT_E_NO_TRUSTED_SIGNER : <S2SV_StartBug> return "None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted." ; <S2SV_EndBug> default : static_sprintf ( error_string , "Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX" , error_code ) ; return error_string ; } }
CWE-476 int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( "Sending<S2SV_blank>CC\\n" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( "error<S2SV_blank>%d\\n" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
CWE-119 int read_file ( struct sc_card * card , char * str_path , unsigned char * * data , size_t * data_len ) { struct sc_path path ; struct sc_file * file ; unsigned char * p ; int ok = 0 ; int r ; size_t len ; sc_format_path ( str_path , & path ) ; if ( SC_SUCCESS != sc_select_file ( card , & path , & file ) ) { goto err ; } <S2SV_StartBug> len = file ? file -> size : 4096 ; <S2SV_EndBug> p = realloc ( * data , len ) ; if ( ! p ) { goto err ; } * data = p ; * data_len = len ; r = sc_read_binary ( card , 0 , p , len , 0 ) ; if ( r < 0 ) goto err ; * data_len = r ; ok = 1 ; err : sc_file_free ( file ) ; return ok ; }
CWE-190 SPL_METHOD ( SplFileObject , fread ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long length = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "l" , & length ) == FAILURE ) { return ; } if ( length <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }
CWE-000 <S2SV_StartBug> static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs ) <S2SV_EndBug> { FILE * fp = fopen ( dest_filename , "w" ) ; if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , "fd/%u" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , "%u:%s\\n" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , "fdinfo/%u" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , "r" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; } <S2SV_StartBug> fclose ( fp ) ; <S2SV_EndBug> return true ; }
CWE-264 static int pppol2tp_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; int val , len ; int err ; struct pppol2tp_session * ps ; if ( level != SOL_PPPOL2TP ) <S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> if ( get_user ( len , optlen ) ) return - EFAULT ; len = min_t ( unsigned int , len , sizeof ( int ) ) ; if ( len < 0 ) return - EINVAL ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_getsockopt ( sk , tunnel , optname , & val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_getsockopt ( sk , session , optname , & val ) ; err = - EFAULT ; if ( put_user ( len , optlen ) ) goto end_put_sess ; if ( copy_to_user ( ( void __user * ) optval , & val , len ) ) goto end_put_sess ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }
CWE-119 static float * get_window ( vorb * f , int len ) { len <<= 1 ; if ( len == f -> blocksize_0 ) return f -> window [ 0 ] ; if ( len == f -> blocksize_1 ) return f -> window [ 1 ] ; <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return NULL ; }
CWE-000 static int __sys_sendmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned flags , struct used_address * used_address ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct sockaddr_storage address ; struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; unsigned char ctl [ sizeof ( struct cmsghdr ) + 20 ] __attribute__ ( ( aligned ( sizeof ( __kernel_size_t ) ) ) ) ; unsigned char * ctl_buf = ctl ; int err , ctl_len , iov_size , total_len ; err = - EFAULT ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) ) return - EFAULT ; err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) ; if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ) ; if ( ! iov ) goto out ; } if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; } else err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; err = - ENOBUFS ; if ( msg_sys -> msg_controllen > INT_MAX ) goto out_freeiov ; ctl_len = msg_sys -> msg_controllen ; if ( ( MSG_CMSG_COMPAT & flags ) && ctl_len ) { err = cmsghdr_from_user_compat_to_kern ( msg_sys , sock -> sk , ctl , sizeof ( ctl ) ) ; if ( err ) goto out_freeiov ; ctl_buf = msg_sys -> msg_control ; ctl_len = msg_sys -> msg_controllen ; } else if ( ctl_len ) { if ( ctl_len > sizeof ( ctl ) ) { ctl_buf = sock_kmalloc ( sock -> sk , ctl_len , GFP_KERNEL ) ; if ( ctl_buf == NULL ) goto out_freeiov ; } err = - EFAULT ; if ( copy_from_user ( ctl_buf , ( void __user __force * ) msg_sys -> msg_control , ctl_len ) ) goto out_freectl ; msg_sys -> msg_control = ctl_buf ; } msg_sys -> msg_flags = flags ; if ( sock -> file -> f_flags & O_NONBLOCK ) msg_sys -> msg_flags |= MSG_DONTWAIT ; <S2SV_StartBug> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && <S2SV_EndBug> <S2SV_StartBug> ! memcmp ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> used_address -> name_len ) ) { err = sock_sendmsg_nosec ( sock , msg_sys , total_len ) ; goto out_freectl ; } err = sock_sendmsg ( sock , msg_sys , total_len ) ; if ( used_address && err >= 0 ) { used_address -> name_len = msg_sys -> msg_namelen ; <S2SV_StartBug> memcpy ( & used_address -> name , msg -> msg_name , <S2SV_EndBug> used_address -> name_len ) ; } out_freectl : if ( ctl_buf != ctl ) sock_kfree_s ( sock -> sk , ctl_buf , ctl_len ) ; out_freeiov : if ( iov != iovstack ) sock_kfree_s ( sock -> sk , iov , iov_size ) ; out : return err ; }
CWE-284 static void sync_lockstate_on_connect ( btif_hh_device_t * p_dev ) { int keylockstates ; BTIF_TRACE_EVENT ( "%s:<S2SV_blank>Syncing<S2SV_blank>keyboard<S2SV_blank>lock<S2SV_blank>states<S2SV_blank>after<S2SV_blank>" "reconnect..." , __FUNCTION__ ) ; update_keyboard_lockstates ( p_dev ) ; keylockstates = get_keylockstates ( ) ; if ( keylockstates ) { BTIF_TRACE_DEBUG ( "%s:<S2SV_blank>Sending<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>to<S2SV_blank>kernel<S2SV_blank>" "indicating<S2SV_blank>lock<S2SV_blank>key<S2SV_blank>state<S2SV_blank>0x%x" , __FUNCTION__ , keylockstates ) ; <S2SV_StartBug> usleep ( 200000 ) ; <S2SV_EndBug> toggle_os_keylockstates ( p_dev -> fd , keylockstates ) ; } else { BTIF_TRACE_DEBUG ( "%s:<S2SV_blank>NOT<S2SV_blank>sending<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>to<S2SV_blank>kernel<S2SV_blank>" "indicating<S2SV_blank>lock<S2SV_blank>key<S2SV_blank>state<S2SV_blank>0x%x" , __FUNCTION__ , keylockstates ) ; } }
CWE-119 int test ( char * URL ) { int errors = 0 ; ( void ) URL ; errors += test_weird_arguments ( ) ; errors += test_unsigned_short_formatting ( ) ; errors += test_signed_short_formatting ( ) ; errors += test_unsigned_int_formatting ( ) ; errors += test_signed_int_formatting ( ) ; errors += test_unsigned_long_formatting ( ) ; errors += test_signed_long_formatting ( ) ; errors += test_curl_off_t_formatting ( ) ; errors += test_string_formatting ( ) ; <S2SV_StartBug> if ( errors ) <S2SV_EndBug> return TEST_ERR_MAJOR_BAD ; else return 0 ; }
CWE-000 static int crypto_report_akcipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_akcipher rakcipher ; <S2SV_StartBug> strlcpy ( rakcipher . type , "akcipher" , sizeof ( rakcipher . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-125 static int print_ccp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)" , tok2str ( ccpconfopts_values , "Unknown" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( ccpconfopts_values , "Unknown" , opt ) , opt , len ) ) ; switch ( opt ) { case CCPOPT_BSDCOMP : if ( len < 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ; break ; case CCPOPT_MVRCA : if ( len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? "Enabled" : "Disabled" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ; break ; case CCPOPT_DEFLATE : if ( len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? "zlib" : "unknown" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ; break ; # if 0 case CCPOPT_OUI : case CCPOPT_PRED1 : case CCPOPT_PRED2 : case CCPOPT_PJUMP : case CCPOPT_HPPPC : case CCPOPT_STACLZS : case CCPOPT_MPPC : case CCPOPT_GFZA : case CCPOPT_V42BIS : case CCPOPT_LZSDCP : case CCPOPT_DEC : case CCPOPT_RESV : break ; # endif default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , "[|ccp]" ) ) ; return 0 ; }
CWE-119 static void first_pass_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * ref_mv , MV * best_mv , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; int num00 ; int_mv tmp_mv ; int_mv ref_mv_full ; int tmp_err ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int n ; vp8_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; int new_mv_mode_penalty = 256 ; <S2SV_StartBug> v_fn_ptr . vf = vp8_mse16x16 ; <S2SV_EndBug> xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; tmp_mv . as_int = 0 ; ref_mv_full . as_mv . col = ref_mv -> as_mv . col >> 3 ; ref_mv_full . as_mv . row = ref_mv -> as_mv . row >> 3 ; tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } } } }
CWE-000 static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ; <S2SV_StartBug> other = unix_peer_get ( sk ) ; <S2SV_EndBug> if ( other ) { <S2SV_StartBug> if ( unix_peer ( other ) != sk ) { <S2SV_EndBug> sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; <S2SV_StartBug> if ( unix_recvq_full ( other ) ) <S2SV_EndBug> writable = 0 ; <S2SV_StartBug> } <S2SV_EndBug> sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; else set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; return mask ; }
CWE-000 static int cp2112_gpio_get_all ( struct gpio_chip * chip ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_GET_LENGTH ) { hid_err ( hdev , "error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>values:<S2SV_blank>%d\\n" , ret ) ; ret = ret < 0 ? ret : - EIO ; goto exit ; } ret = buf [ 1 ] ; exit : <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> return ret ; }
CWE-119 static void scsi_write_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; <S2SV_StartBug> uint32_t len ; <S2SV_EndBug> uint32_t n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_WRITE ) ) { return ; } } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; if ( r -> sector_count == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } else { <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> if ( len > SCSI_DMA_BUF_SIZE ) { len = SCSI_DMA_BUF_SIZE ; } r -> iov . iov_len = len ; <S2SV_StartBug> DPRINTF ( "Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug> } }
CWE-200 static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; <S2SV_StartBug> pr_debug ( "%p<S2SV_blank>%zu\\n" , sk , len ) ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( "Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( "Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n" , ui_cb -> dsap , ui_cb -> ssap ) ; <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug> sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
CWE-284 __be32 nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct nfs4_acl * acl ) { __be32 error ; int host_error ; struct dentry * dentry ; struct inode * inode ; struct posix_acl * pacl = NULL , * dpacl = NULL ; unsigned int flags = 0 ; error = fh_verify ( rqstp , fhp , 0 , NFSD_MAY_SATTR ) ; if ( error ) return error ; dentry = fhp -> fh_dentry ; inode = d_inode ( dentry ) ; <S2SV_StartBug> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <S2SV_EndBug> return nfserr_attrnotsupp ; if ( S_ISDIR ( inode -> i_mode ) ) flags = NFS4_ACL_DIR ; host_error = nfs4_acl_nfsv4_to_posix ( acl , & pacl , & dpacl , flags ) ; if ( host_error == - EINVAL ) return nfserr_attrnotsupp ; if ( host_error < 0 ) goto out_nfserr ; <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> if ( host_error < 0 ) <S2SV_StartBug> goto out_release ; <S2SV_EndBug> if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , dpacl , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; } <S2SV_StartBug> out_release : <S2SV_EndBug> posix_acl_release ( pacl ) ; posix_acl_release ( dpacl ) ; out_nfserr : if ( host_error == - EOPNOTSUPP ) return nfserr_attrnotsupp ; else return nfserrno ( host_error ) ; }
CWE-416 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-20 static void rose_loopback_timer ( unsigned long param ) { struct sk_buff * skb ; struct net_device * dev ; rose_address * dest ; struct sock * sk ; unsigned short frametype ; unsigned int lci_i , lci_o ; <S2SV_StartBug> while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { <S2SV_EndBug> lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ; frametype = skb -> data [ 2 ] ; <S2SV_StartBug> dest = ( rose_address * ) ( skb -> data + 4 ) ; <S2SV_EndBug> lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ; skb_reset_transport_header ( skb ) ; sk = rose_find_socket ( lci_o , rose_loopback_neigh ) ; if ( sk ) { if ( rose_process_rx_frame ( sk , skb ) == 0 ) kfree_skb ( skb ) ; continue ; } if ( frametype == ROSE_CALL_REQUEST ) { if ( ( dev = rose_dev_get ( dest ) ) != NULL ) { if ( rose_rx_call_request ( skb , dev , rose_loopback_neigh , lci_o ) == 0 ) kfree_skb ( skb ) ; } else { kfree_skb ( skb ) ; } } else { kfree_skb ( skb ) ; } } }
CWE-399 static int do_tkill ( pid_t tgid , pid_t pid , int sig ) { <S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> info . si_signo = sig ; info . si_errno = 0 ; info . si_code = SI_TKILL ; info . si_pid = task_tgid_vnr ( current ) ; info . si_uid = from_kuid_munged ( current_user_ns ( ) , current_uid ( ) ) ; return do_send_specific ( tgid , pid , sig , & info ) ; }
CWE-119 static void set_entropy_context_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; <S2SV_StartBug> MACROBLOCKD * const xd = args -> xd ; <S2SV_EndBug> <S2SV_StartBug> struct macroblock_plane * p = & args -> cpi -> mb . plane [ plane ] ; <S2SV_EndBug> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; int aoff , loff ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; vp9_set_contexts ( xd , pd , plane_bsize , tx_size , p -> eobs [ block ] > 0 , aoff , loff ) ; }
CWE-119 l_int32 gplotAddPlot ( GPLOT * gplot , NUMA * nax , NUMA * nay , l_int32 plotstyle , const char * plottitle ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char emptystring [ ] = "" ; char * datastr , * title ; l_int32 n , i ; l_float32 valx , valy , startx , delx ; SARRAY * sa ; PROCNAME ( "gplotAddPlot" ) ; if ( ! gplot ) return ERROR_INT ( "gplot<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( ! nay ) return ERROR_INT ( "nay<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES ) return ERROR_INT ( "invalid<S2SV_blank>plotstyle" , procName , 1 ) ; if ( ( n = numaGetCount ( nay ) ) == 0 ) return ERROR_INT ( "no<S2SV_blank>points<S2SV_blank>to<S2SV_blank>plot" , procName , 1 ) ; if ( nax && ( n != numaGetCount ( nax ) ) ) return ERROR_INT ( "nax<S2SV_blank>and<S2SV_blank>nay<S2SV_blank>sizes<S2SV_blank>differ" , procName , 1 ) ; if ( n == 1 && plotstyle == GPLOT_LINES ) { L_INFO ( "only<S2SV_blank>1<S2SV_blank>pt;<S2SV_blank>changing<S2SV_blank>style<S2SV_blank>to<S2SV_blank>points\\n" , procName ) ; plotstyle = GPLOT_POINTS ; } numaGetParameters ( nay , & startx , & delx ) ; numaAddNumber ( gplot -> plotstyles , plotstyle ) ; if ( plottitle ) { title = stringNew ( plottitle ) ; sarrayAddString ( gplot -> plottitles , title , L_INSERT ) ; } else { sarrayAddString ( gplot -> plottitles , emptystring , L_COPY ) ; } gplot -> nplots ++ ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.data.%d" , gplot -> rootname , gplot -> nplots ) ; <S2SV_EndBug> sarrayAddString ( gplot -> datanames , buf , L_COPY ) ; sa = sarrayCreate ( n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( nax ) numaGetFValue ( nax , i , & valx ) ; else valx = startx + i * delx ; numaGetFValue ( nay , i , & valy ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%f<S2SV_blank>%f\\n" , valx , valy ) ; <S2SV_EndBug> sarrayAddString ( sa , buf , L_COPY ) ; } datastr = sarrayToString ( sa , 0 ) ; sarrayAddString ( gplot -> plotdata , datastr , L_INSERT ) ; sarrayDestroy ( & sa ) ; return 0 ; }
CWE-284 static ssize_t in_read ( struct audio_stream_in * stream , void * buffer , size_t bytes ) { struct a2dp_stream_in * in = ( struct a2dp_stream_in * ) stream ; int read ; DEBUG ( "read<S2SV_blank>%zu<S2SV_blank>bytes,<S2SV_blank>state:<S2SV_blank>%d" , bytes , in -> common . state ) ; if ( in -> common . state == AUDIO_A2DP_STATE_SUSPENDED ) { DEBUG ( "stream<S2SV_blank>suspended" ) ; return - 1 ; } if ( ( in -> common . state == AUDIO_A2DP_STATE_STOPPED ) || ( in -> common . state == AUDIO_A2DP_STATE_STANDBY ) ) { pthread_mutex_lock ( & in -> common . lock ) ; if ( start_audio_datapath ( & in -> common ) < 0 ) { int us_delay = calc_audiotime ( in -> common . cfg , bytes ) ; DEBUG ( "emulate<S2SV_blank>a2dp<S2SV_blank>read<S2SV_blank>delay<S2SV_blank>(%d<S2SV_blank>us)" , us_delay ) ; <S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug> pthread_mutex_unlock ( & in -> common . lock ) ; return - 1 ; } pthread_mutex_unlock ( & in -> common . lock ) ; } else if ( in -> common . state != AUDIO_A2DP_STATE_STARTED ) { ERROR ( "stream<S2SV_blank>not<S2SV_blank>in<S2SV_blank>stopped<S2SV_blank>or<S2SV_blank>standby" ) ; return - 1 ; } read = skt_read ( in -> common . audio_fd , buffer , bytes ) ; if ( read == - 1 ) { skt_disconnect ( in -> common . audio_fd ) ; in -> common . audio_fd = AUDIO_SKT_DISCONNECTED ; in -> common . state = AUDIO_A2DP_STATE_STOPPED ; } else if ( read == 0 ) { DEBUG ( "read<S2SV_blank>time<S2SV_blank>out<S2SV_blank>-<S2SV_blank>return<S2SV_blank>zeros" ) ; memset ( buffer , 0 , bytes ) ; read = bytes ; } DEBUG ( "read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes" , read , bytes ) ; return read ; }
CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = "" ; const char * link_section_name = "" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , "section_name" , section_name , 0 ) ; sdb_num_set ( sdb , "entries" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , "idx" , i , 0 ) ; sdb_num_set ( sdb_verdef , "vd_version" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , "vd_ndx" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , "vd_cnt" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , "flags" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , "idx" , isum , 0 ) ; sdb_num_set ( sdb_parent , "parent" , j , 0 ) ; sdb_set ( sdb_parent , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , "parent%d" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , "verdef%d" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
CWE-119 static int check_line_charstring ( void ) { char * p = line ; <S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , "(pad1)" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , "(padn:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(padn)" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , "(refresh:<S2SV_blank>trunc)" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , "(refresh:<S2SV_blank>%u)" , <S2SV_EndBug> EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , "(altcoa:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(alt-CoA:<S2SV_blank>%s)" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , "(ni:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , "(auth:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(auth)" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , "(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(type-0x%02x:<S2SV_blank>len=%u)" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
CWE-787 <S2SV_StartBug> static void nsc_rle_decompress_data ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; <S2SV_StartBug> rle = context -> Planes ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) <S2SV_StartBug> FillMemory ( context -> priv -> PlaneBuffers [ i ] , originalSize , 0xFF ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( planeSize < originalSize ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decode ( rle , context -> priv -> PlaneBuffers [ i ] , originalSize ) ; <S2SV_EndBug> else CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; <S2SV_StartBug> rle += planeSize ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
CWE-264 <S2SV_StartBug> static unsigned int stack_maxrandom_size ( void ) <S2SV_EndBug> { <S2SV_StartBug> unsigned int max = 0 ; <S2SV_EndBug> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <S2SV_StartBug> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <S2SV_EndBug> } return max ; }
CWE-284 int vfs_open ( const struct path * path , struct file * file , const struct cred * cred ) { <S2SV_StartBug> struct dentry * dentry = path -> dentry ; <S2SV_EndBug> <S2SV_StartBug> struct inode * inode = dentry -> d_inode ; <S2SV_EndBug> file -> f_path = * path ; if ( dentry -> d_flags & DCACHE_OP_SELECT_INODE ) { inode = dentry -> d_op -> d_select_inode ( dentry , file -> f_flags ) ; if ( IS_ERR ( inode ) ) return PTR_ERR ( inode ) ; <S2SV_StartBug> } <S2SV_EndBug> return do_dentry_open ( file , inode , NULL , cred ) ; }
CWE-119 void * vpx_calloc ( size_t num , size_t size ) { void * x ; x = vpx_memalign ( DEFAULT_ALIGNMENT , num * size ) ; if ( x ) <S2SV_StartBug> VPX_MEMSET_L ( x , 0 , num * size ) ; <S2SV_EndBug> return x ; }
CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
CWE-200 static int mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <S2SV_StartBug> struct serial_icounter_struct icount ; <S2SV_EndBug> struct sb_uart_icount cnow ; struct sb_uart_port * port = state -> port ; spin_lock_irq ( & port -> lock ) ; memcpy ( & cnow , & port -> icount , sizeof ( struct sb_uart_icount ) ) ; spin_unlock_irq ( & port -> lock ) ; icount . cts = cnow . cts ; icount . dsr = cnow . dsr ; icount . rng = cnow . rng ; icount . dcd = cnow . dcd ; icount . rx = cnow . rx ; icount . tx = cnow . tx ; icount . frame = cnow . frame ; icount . overrun = cnow . overrun ; icount . parity = cnow . parity ; icount . brk = cnow . brk ; icount . buf_overrun = cnow . buf_overrun ; return copy_to_user ( icnt , & icount , sizeof ( icount ) ) ? - EFAULT : 0 ; }
CWE-000 static int rds_loop_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) { <S2SV_StartBug> if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { <S2SV_EndBug> rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> } BUG_ON ( hdr_off || sg || off ) ; rds_inc_init ( & rm -> m_inc , conn , conn -> c_laddr ) ; rds_message_addref ( rm ) ; rds_recv_incoming ( conn , conn -> c_laddr , conn -> c_faddr , & rm -> m_inc , GFP_KERNEL , KM_USER0 ) ; rds_send_drop_acked ( conn , be64_to_cpu ( rm -> m_inc . i_hdr . h_sequence ) , NULL ) ; rds_inc_put ( & rm -> m_inc ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_EndBug> }
CWE-284 static int skt_read ( int fd , void * p , size_t len ) { int read ; struct pollfd pfd ; struct timespec ts ; FNLOG ( ) ; ts_log ( "skt_read<S2SV_blank>recv" , len , NULL ) ; <S2SV_StartBug> if ( ( read = recv ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <S2SV_EndBug> { ERROR ( "write<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>errno=%d\\n" , errno ) ; return - 1 ; } return read ; }
CWE-20 static int atalk_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ; struct ddpehdr * ddp ; int copied = 0 ; int offset = 0 ; int err = 0 ; struct sk_buff * skb ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; ddp = ddp_hdr ( skb ) ; copied = ntohs ( ddp -> deh_len_hops ) & 1023 ; if ( sk -> sk_type != SOCK_RAW ) { offset = sizeof ( * ddp ) ; copied -= offset ; } if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> if ( sat ) { sat -> sat_family = AF_APPLETALK ; sat -> sat_port = ddp -> deh_sport ; sat -> sat_addr . s_node = ddp -> deh_snode ; sat -> sat_addr . s_net = ddp -> deh_snet ; <S2SV_StartBug> } <S2SV_EndBug> msg -> msg_namelen = sizeof ( * sat ) ; } skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return err ? : copied ; }
CWE-000 static void sas_unregister_devs_sas_addr ( struct domain_device * parent , int phy_id , bool last ) { struct expander_device * ex_dev = & parent -> ex_dev ; struct ex_phy * phy = & ex_dev -> ex_phy [ phy_id ] ; struct domain_device * child , * n , * found = NULL ; if ( last ) { list_for_each_entry_safe ( child , n , & ex_dev -> children , siblings ) { if ( SAS_ADDR ( child -> sas_addr ) == SAS_ADDR ( phy -> attached_sas_addr ) ) { set_bit ( SAS_DEV_GONE , & child -> state ) ; if ( child -> dev_type == SAS_EDGE_EXPANDER_DEVICE || child -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) sas_unregister_ex_tree ( parent -> port , child ) ; else sas_unregister_dev ( parent -> port , child ) ; found = child ; break ; } } sas_disable_routing ( parent , phy -> attached_sas_addr ) ; } memset ( phy -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; if ( phy -> port ) { sas_port_delete_phy ( phy -> port , phy -> phy ) ; sas_device_set_phy ( found , phy -> port ) ; if ( phy -> port -> num_phys == 0 ) <S2SV_StartBug> sas_port_delete ( phy -> port ) ; <S2SV_EndBug> phy -> port = NULL ; } }
CWE-119 int add_packetdata ( struct mt_packet * packet , unsigned char * data , unsigned short length ) { <S2SV_StartBug> if ( packet -> size + length > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( "add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n" ) , MT_PACKET_LEN ) ; return - 1 ; } memcpy ( packet -> data + packet -> size , data , length ) ; packet -> size += length ; return length ; }
CWE-119 static int read_public_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( "I1012" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>select<S2SV_blank>public<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n" , sc_strerror ( r ) ) ; return 2 ; } <S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>public<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( "Key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found.\\n" , opt_key_num ) ; return 2 ; } return parse_public_key ( p , keysize , rsa ) ; }
CWE-284 static int ndp_sock_open ( struct ndp * ndp ) { int sock ; int ret ; int err ; int val ; sock = socket ( PF_INET6 , SOCK_RAW , IPPROTO_ICMPV6 ) ; if ( sock == - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>ICMP6<S2SV_blank>socket." ) ; return - errno ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVPKTINFO , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVPKTINFO." ) ; err = - errno ; goto close_sock ; } val = 255 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_MULTICAST_HOPS , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { <S2SV_StartBug> err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS." ) ; <S2SV_EndBug> err = - errno ; goto close_sock ; } ndp -> sock = sock ; return 0 ; close_sock : close ( sock ) ; return err ; }
CWE-000 static void edge_bulk_in_callback ( struct urb * urb ) { struct edgeport_port * edge_port = urb -> context ; struct device * dev = & edge_port -> port -> dev ; unsigned char * data = urb -> transfer_buffer ; int retval = 0 ; int port_number ; int status = urb -> status ; switch ( status ) { case 0 : break ; case - ECONNRESET : case - ENOENT : case - ESHUTDOWN : dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>urb<S2SV_blank>shutting<S2SV_blank>down<S2SV_blank>with<S2SV_blank>status:<S2SV_blank>%d\\n" , __func__ , status ) ; return ; default : dev_err ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>read<S2SV_blank>bulk<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>%d\\n" , __func__ , status ) ; } if ( status == - EPIPE ) goto exit ; if ( status ) { dev_err ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>stopping<S2SV_blank>read!\\n" , __func__ ) ; return ; } port_number = edge_port -> port -> port_number ; <S2SV_StartBug> if ( edge_port -> lsr_event ) { <S2SV_EndBug> edge_port -> lsr_event = 0 ; dev_dbg ( dev , "%s<S2SV_blank>=====<S2SV_blank>Port<S2SV_blank>%u<S2SV_blank>LSR<S2SV_blank>Status<S2SV_blank>=<S2SV_blank>%02x,<S2SV_blank>Data<S2SV_blank>=<S2SV_blank>%02x<S2SV_blank>======\\n" , __func__ , port_number , edge_port -> lsr_mask , * data ) ; handle_new_lsr ( edge_port , 1 , edge_port -> lsr_mask , * data ) ; -- urb -> actual_length ; ++ data ; } if ( urb -> actual_length ) { usb_serial_debug_data ( dev , __func__ , urb -> actual_length , data ) ; if ( edge_port -> close_pending ) dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>close<S2SV_blank>pending,<S2SV_blank>dropping<S2SV_blank>data<S2SV_blank>on<S2SV_blank>the<S2SV_blank>floor\\n" , __func__ ) ; else edge_tty_recv ( edge_port -> port , data , urb -> actual_length ) ; edge_port -> port -> icount . rx += urb -> actual_length ; } exit : spin_lock ( & edge_port -> ep_lock ) ; if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_RUNNING ) retval = usb_submit_urb ( urb , GFP_ATOMIC ) ; else if ( edge_port -> ep_read_urb_state == EDGE_READ_URB_STOPPING ) edge_port -> ep_read_urb_state = EDGE_READ_URB_STOPPED ; spin_unlock ( & edge_port -> ep_lock ) ; if ( retval ) dev_err ( dev , "%s<S2SV_blank>-<S2SV_blank>usb_submit_urb<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>result<S2SV_blank>%d\\n" , __func__ , retval ) ; }
CWE-787 static OPJ_BOOL opj_j2k_write_all_tile_parts ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , opj_stream_private_t * p_stream , struct opj_event_mgr * p_manager ) { OPJ_UINT32 tilepartno = 0 ; OPJ_UINT32 l_nb_bytes_written = 0 ; OPJ_UINT32 l_current_nb_bytes_written ; OPJ_UINT32 l_part_tile_size ; OPJ_UINT32 tot_num_tp ; OPJ_UINT32 pino ; OPJ_BYTE * l_begin_data ; opj_tcp_t * l_tcp = 00 ; opj_tcd_t * l_tcd = 00 ; opj_cp_t * l_cp = 00 ; l_tcd = p_j2k -> m_tcd ; l_cp = & ( p_j2k -> m_cp ) ; l_tcp = l_cp -> tcps + p_j2k -> m_current_tile_number ; tot_num_tp = opj_j2k_get_num_tp ( l_cp , 0 , p_j2k -> m_current_tile_number ) ; ++ p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; for ( tilepartno = 1 ; tilepartno < tot_num_tp ; ++ tilepartno ) { p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number = tilepartno ; l_current_nb_bytes_written = 0 ; l_part_tile_size = 0 ; l_begin_data = p_data ; <S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_part_tile_size += l_current_nb_bytes_written ; l_current_nb_bytes_written = 0 ; if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) { return OPJ_FALSE ; } p_data += l_current_nb_bytes_written ; l_nb_bytes_written += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_part_tile_size += l_current_nb_bytes_written ; opj_write_bytes ( l_begin_data + 6 , l_part_tile_size , 4 ) ; if ( OPJ_IS_CINEMA ( l_cp -> rsiz ) ) { opj_j2k_update_tlm ( p_j2k , l_part_tile_size ) ; } ++ p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; } for ( pino = 1 ; pino <= l_tcp -> numpocs ; ++ pino ) { l_tcd -> cur_pino = pino ; tot_num_tp = opj_j2k_get_num_tp ( l_cp , pino , p_j2k -> m_current_tile_number ) ; for ( tilepartno = 0 ; tilepartno < tot_num_tp ; ++ tilepartno ) { p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number = tilepartno ; l_current_nb_bytes_written = 0 ; l_part_tile_size = 0 ; l_begin_data = p_data ; <S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_part_tile_size += l_current_nb_bytes_written ; l_current_nb_bytes_written = 0 ; if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_part_tile_size += l_current_nb_bytes_written ; opj_write_bytes ( l_begin_data + 6 , l_part_tile_size , 4 ) ; if ( OPJ_IS_CINEMA ( l_cp -> rsiz ) ) { opj_j2k_update_tlm ( p_j2k , l_part_tile_size ) ; } ++ p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; } } * p_data_written = l_nb_bytes_written ; return OPJ_TRUE ; }
CWE-362 long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { if ( shmflg & SHM_RND ) addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; <S2SV_StartBug> ipc_lock_object ( & shp -> shm_perm ) ; <S2SV_EndBug> path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( path . dentry -> d_inode ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; down_write ( & current -> mm -> mmap_sem ) ; if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; if ( addr < current -> mm -> start_stack && addr > current -> mm -> start_stack - size - PAGE_SIZE * 5 ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; BUG_ON ( IS_ERR ( shp ) ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }
CWE-362 int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ; <S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ; <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }
CWE-190 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; <S2SV_StartBug> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <S2SV_EndBug> uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( "" , "TIFF<S2SV_blank>scanline<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero!" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( "" , "Strip<S2SV_blank>%d:<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>strip<S2SV_blank>size<S2SV_blank>%lu" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( "" , "Error<S2SV_blank>reading<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>after<S2SV_blank>%lu<S2SV_blank>rows" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } bufp += bytes_read ; } return 1 ; }
CWE-119 static void set_default_lf_deltas ( VP8_COMP * cpi ) { cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 1 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ LAST_FRAME ] = 0 ; cpi -> mb . e_mbd . ref_lf_deltas [ GOLDEN_FRAME ] = - 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ ALTREF_FRAME ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 0 ] = 4 ; if ( cpi -> oxcf . Mode == MODE_REALTIME ) cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 12 ; else cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 2 ] = 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 3 ] = 4 ; }
CWE-000 static int snd_ctl_tlv_ioctl ( struct snd_ctl_file * file , struct snd_ctl_tlv __user * _tlv , int op_flag ) { struct snd_card * card = file -> card ; struct snd_ctl_tlv tlv ; struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int len ; int err = 0 ; if ( copy_from_user ( & tlv , _tlv , sizeof ( tlv ) ) ) return - EFAULT ; if ( tlv . length < sizeof ( unsigned int ) * 2 ) return - EINVAL ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_numid ( card , tlv . numid ) ; if ( kctl == NULL ) { err = - ENOENT ; goto __kctl_end ; } if ( kctl -> tlv . p == NULL ) { err = - ENXIO ; goto __kctl_end ; } vd = & kctl -> vd [ tlv . numid - kctl -> id . numid ] ; if ( ( op_flag == 0 && ( vd -> access & SNDRV_CTL_ELEM_ACCESS_TLV_READ ) == 0 ) || ( op_flag > 0 && ( vd -> access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE ) == 0 ) || ( op_flag < 0 && ( vd -> access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND ) == 0 ) ) { err = - ENXIO ; goto __kctl_end ; } if ( vd -> access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ) { if ( vd -> owner != NULL && vd -> owner != file ) { err = - EPERM ; goto __kctl_end ; } err = kctl -> tlv . c ( kctl , op_flag , tlv . length , _tlv -> tlv ) ; if ( err > 0 ) { <S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_TLV , & kctl -> id ) ; <S2SV_EndBug> return 0 ; } } else { if ( op_flag ) { err = - ENXIO ; goto __kctl_end ; } len = kctl -> tlv . p [ 1 ] + 2 * sizeof ( unsigned int ) ; if ( tlv . length < len ) { err = - ENOMEM ; goto __kctl_end ; } if ( copy_to_user ( _tlv -> tlv , kctl -> tlv . p , len ) ) err = - EFAULT ; } __kctl_end : up_read ( & card -> controls_rwsem ) ; return err ; }
CWE-000 static ssize_t aio_run_iocb ( struct kiocb * req , unsigned opcode , char __user * buf , size_t len , bool compat ) { struct file * file = req -> ki_filp ; ssize_t ret ; unsigned long nr_segs ; int rw ; fmode_t mode ; aio_rw_op * rw_op ; rw_iter_op * iter_op ; struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; struct iov_iter iter ; switch ( opcode ) { case IOCB_CMD_PREAD : case IOCB_CMD_PREADV : mode = FMODE_READ ; rw = READ ; rw_op = file -> f_op -> aio_read ; iter_op = file -> f_op -> read_iter ; goto rw_common ; case IOCB_CMD_PWRITE : case IOCB_CMD_PWRITEV : mode = FMODE_WRITE ; rw = WRITE ; rw_op = file -> f_op -> aio_write ; iter_op = file -> f_op -> write_iter ; goto rw_common ; rw_common : if ( unlikely ( ! ( file -> f_mode & mode ) ) ) return - EBADF ; if ( ! rw_op && ! iter_op ) return - EINVAL ; if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , <S2SV_StartBug> & len , & iovec , compat ) ; <S2SV_EndBug> else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , <S2SV_StartBug> len , iovec ) ; <S2SV_EndBug> if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ; if ( ret < 0 ) { if ( iovec != inline_vecs ) kfree ( iovec ) ; return ret ; } len = ret ; if ( req -> ki_pos < 0 ) { ret = - EINVAL ; break ; } if ( rw == WRITE ) file_start_write ( file ) ; if ( iter_op ) { <S2SV_StartBug> iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ; <S2SV_EndBug> ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ; } if ( rw == WRITE ) file_end_write ( file ) ; break ; case IOCB_CMD_FDSYNC : if ( ! file -> f_op -> aio_fsync ) return - EINVAL ; ret = file -> f_op -> aio_fsync ( req , 1 ) ; break ; case IOCB_CMD_FSYNC : if ( ! file -> f_op -> aio_fsync ) return - EINVAL ; ret = file -> f_op -> aio_fsync ( req , 0 ) ; break ; default : pr_debug ( "EINVAL:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n" ) ; return - EINVAL ; } if ( iovec != inline_vecs ) kfree ( iovec ) ; if ( ret != - EIOCBQUEUED ) { if ( unlikely ( ret == - ERESTARTSYS || ret == - ERESTARTNOINTR || ret == - ERESTARTNOHAND || ret == - ERESTART_RESTARTBLOCK ) ) ret = - EINTR ; aio_complete ( req , ret , 0 ) ; } return 0 ; }
CWE-119 static int muscle_list_files ( sc_card_t * card , u8 * buf , size_t bufLen ) { muscle_private_t * priv = MUSCLE_DATA ( card ) ; mscfs_t * fs = priv -> fs ; int x ; int count = 0 ; mscfs_check_cache ( priv -> fs ) ; for ( x = 0 ; x < fs -> cache . size ; x ++ ) { u8 * oid = fs -> cache . array [ x ] . objectId . id ; <S2SV_StartBug> sc_debug ( card -> ctx , SC_LOG_DEBUG_NORMAL , <S2SV_EndBug> "FILE:<S2SV_blank>%02X%02X%02X%02X\\n" , oid [ 0 ] , oid [ 1 ] , oid [ 2 ] , oid [ 3 ] ) ; if ( 0 == memcmp ( fs -> currentPath , oid , 2 ) ) { buf [ 0 ] = oid [ 2 ] ; buf [ 1 ] = oid [ 3 ] ; if ( buf [ 0 ] == 0x00 && buf [ 1 ] == 0x00 ) continue ; buf += 2 ; count += 2 ; <S2SV_StartBug> } <S2SV_EndBug> } return count ; }
CWE-476 void migrate_page_copy ( struct page * newpage , struct page * page ) { int cpupid ; if ( PageHuge ( page ) || PageTransHuge ( page ) ) copy_huge_page ( newpage , page ) ; else copy_highpage ( newpage , page ) ; if ( PageError ( page ) ) SetPageError ( newpage ) ; if ( PageReferenced ( page ) ) SetPageReferenced ( newpage ) ; if ( PageUptodate ( page ) ) SetPageUptodate ( newpage ) ; if ( TestClearPageActive ( page ) ) { VM_BUG_ON_PAGE ( PageUnevictable ( page ) , page ) ; SetPageActive ( newpage ) ; } else if ( TestClearPageUnevictable ( page ) ) SetPageUnevictable ( newpage ) ; if ( PageChecked ( page ) ) SetPageChecked ( newpage ) ; if ( PageMappedToDisk ( page ) ) SetPageMappedToDisk ( newpage ) ; <S2SV_StartBug> if ( PageDirty ( page ) ) { <S2SV_EndBug> clear_page_dirty_for_io ( page ) ; if ( PageSwapBacked ( page ) ) SetPageDirty ( newpage ) ; <S2SV_StartBug> else <S2SV_EndBug> __set_page_dirty_nobuffers ( newpage ) ; } if ( page_is_young ( page ) ) set_page_young ( newpage ) ; if ( page_is_idle ( page ) ) set_page_idle ( newpage ) ; cpupid = page_cpupid_xchg_last ( page , - 1 ) ; page_cpupid_xchg_last ( newpage , cpupid ) ; ksm_migrate_page ( newpage , page ) ; if ( PageSwapCache ( page ) ) ClearPageSwapCache ( page ) ; ClearPagePrivate ( page ) ; set_page_private ( page , 0 ) ; if ( PageWriteback ( newpage ) ) end_page_writeback ( newpage ) ; }
CWE-125 static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; <S2SV_StartBug> int ret , n ; <S2SV_EndBug> quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( "class<S2SV_blank>descriptor<S2SV_blank>not<S2SV_blank>present\\n" ) ; return - ENODEV ; } <S2SV_StartBug> hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; <S2SV_EndBug> <S2SV_StartBug> hid -> country = hdesc -> bCountryCode ; <S2SV_EndBug> <S2SV_StartBug> for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) <S2SV_EndBug> if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( "weird<S2SV_blank>size<S2SV_blank>of<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>(%u)\\n" , rsize ) ; return - EINVAL ; } rdesc = kmalloc ( rsize , GFP_KERNEL ) ; if ( ! rdesc ) return - ENOMEM ; hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , HID_DT_REPORT , rdesc , rsize ) ; if ( ret < 0 ) { dbg_hid ( "reading<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>failed\\n" ) ; kfree ( rdesc ) ; goto err ; } ret = hid_parse_report ( hid , rdesc , rsize ) ; kfree ( rdesc ) ; if ( ret ) { dbg_hid ( "parsing<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>failed\\n" ) ; goto err ; } hid -> quirks |= quirks ; return 0 ; err : return ret ; }
CWE-284 static reactor_status_t run_reactor ( reactor_t * reactor , int iterations ) { assert ( reactor != NULL ) ; reactor -> run_thread = pthread_self ( ) ; reactor -> is_running = true ; struct epoll_event events [ MAX_EVENTS ] ; for ( int i = 0 ; iterations == 0 || i < iterations ; ++ i ) { pthread_mutex_lock ( & reactor -> list_lock ) ; list_clear ( reactor -> invalidation_list ) ; pthread_mutex_unlock ( & reactor -> list_lock ) ; int ret ; do { <S2SV_StartBug> ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ; <S2SV_EndBug> } while ( ret == - 1 && errno == EINTR ) ; if ( ret == - 1 ) { LOG_ERROR ( "%s<S2SV_blank>error<S2SV_blank>in<S2SV_blank>epoll_wait:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; reactor -> is_running = false ; return REACTOR_STATUS_ERROR ; } for ( int j = 0 ; j < ret ; ++ j ) { if ( events [ j ] . data . ptr == NULL ) { eventfd_t value ; eventfd_read ( reactor -> event_fd , & value ) ; reactor -> is_running = false ; return REACTOR_STATUS_STOP ; } reactor_object_t * object = ( reactor_object_t * ) events [ j ] . data . ptr ; pthread_mutex_lock ( & reactor -> list_lock ) ; if ( list_contains ( reactor -> invalidation_list , object ) ) { pthread_mutex_unlock ( & reactor -> list_lock ) ; continue ; } pthread_mutex_lock ( & object -> lock ) ; pthread_mutex_unlock ( & reactor -> list_lock ) ; reactor -> object_removed = false ; if ( events [ j ] . events & ( EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR ) && object -> read_ready ) object -> read_ready ( object -> context ) ; if ( ! reactor -> object_removed && events [ j ] . events & EPOLLOUT && object -> write_ready ) object -> write_ready ( object -> context ) ; pthread_mutex_unlock ( & object -> lock ) ; if ( reactor -> object_removed ) { pthread_mutex_destroy ( & object -> lock ) ; osi_free ( object ) ; } } } reactor -> is_running = false ; return REACTOR_STATUS_DONE ; }
CWE-362 static void userfaultfd_event_wait_completion ( struct userfaultfd_ctx * ctx , struct userfaultfd_wait_queue * ewq ) { struct userfaultfd_ctx * release_new_ctx ; if ( WARN_ON_ONCE ( current -> flags & PF_EXITING ) ) goto out ; ewq -> ctx = ctx ; init_waitqueue_entry ( & ewq -> wq , current ) ; release_new_ctx = NULL ; spin_lock ( & ctx -> event_wqh . lock ) ; __add_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; for ( ; ; ) { set_current_state ( TASK_KILLABLE ) ; if ( ewq -> msg . event == 0 ) break ; if ( READ_ONCE ( ctx -> released ) || fatal_signal_pending ( current ) ) { __remove_wait_queue ( & ctx -> event_wqh , & ewq -> wq ) ; if ( ewq -> msg . event == UFFD_EVENT_FORK ) { struct userfaultfd_ctx * new ; new = ( struct userfaultfd_ctx * ) ( unsigned long ) ewq -> msg . arg . reserved . reserved1 ; release_new_ctx = new ; } break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLIN ) ; schedule ( ) ; spin_lock ( & ctx -> event_wqh . lock ) ; } __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; if ( release_new_ctx ) { struct vm_area_struct * vma ; struct mm_struct * mm = release_new_ctx -> mm ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) <S2SV_EndBug> if ( vma -> vm_userfaultfd_ctx . ctx == release_new_ctx ) { vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; vma -> vm_flags &= ~ ( VM_UFFD_WP | VM_UFFD_MISSING ) ; } up_write ( & mm -> mmap_sem ) ; userfaultfd_ctx_put ( release_new_ctx ) ; } out : WRITE_ONCE ( ctx -> mmap_changing , false ) ; userfaultfd_ctx_put ( ctx ) ; }
CWE-119 static void txfm_rd_in_plane ( MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , int64_t ref_best_rd , int plane , BLOCK_SIZE bsize , TX_SIZE tx_size , int use_fast_coef_casting ) { MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> struct rdcost_block_args args = { 0 } ; <S2SV_EndBug> args . x = x ; args . best_rd = ref_best_rd ; <S2SV_StartBug> args . use_fast_coef_costing = use_fast_coef_casting ; <S2SV_EndBug> if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ; vp9_get_entropy_contexts ( bsize , tx_size , pd , args . t_above , args . t_left ) ; args . so = get_scan ( xd , tx_size , pd -> plane_type , 0 ) ; vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , block_rd_txfm , & args ) ; <S2SV_StartBug> if ( args . skip ) { <S2SV_EndBug> * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } else { * distortion = args . this_dist ; * rate = args . this_rate ; * sse = args . this_sse ; <S2SV_StartBug> * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ; <S2SV_EndBug> } }
CWE-264 static int em_grp45 ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; switch ( ctxt -> modrm_reg ) { case 2 : { long int old_eip ; old_eip = ctxt -> _eip ; <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; break ; } case 4 : <S2SV_StartBug> ctxt -> _eip = ctxt -> src . val ; <S2SV_EndBug> break ; case 5 : rc = em_jmp_far ( ctxt ) ; break ; case 6 : rc = em_push ( ctxt ) ; break ; } return rc ; }
CWE-399 static int misaligned_fpu_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo = 0xffffffffUL , bufhi = 0xffffffffUL ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } switch ( width_shift ) { case 2 : buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; break ; case 3 : if ( do_paired_load ) { buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; # else buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; # endif } break ; default : printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_store,<S2SV_blank>PC=%08lx\\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } * ( __u32 * ) & buffer = buflo ; * ( 1 + ( __u32 * ) & buffer ) = bufhi ; if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } return 0 ; } else { die ( "Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel" , regs , 0 ) ; return - 1 ; } }
CWE-20 int wait_for_key_construction ( struct key * key , bool intr ) { int ret ; ret = wait_on_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT , intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE ) ; if ( ret ) return - ERESTARTSYS ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> smp_rmb ( ) ; return key -> reject_error ; } return key_validate ( key ) ; }
CWE-264 int cg_mkdir ( const char * path , mode_t mode ) { struct fuse_context * fc = fuse_get_context ( ) ; <S2SV_StartBug> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <S2SV_EndBug> const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) path1 = "/" ; else path1 = cgdir ; <S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = - EACCES ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { <S2SV_EndBug> ret = - EACCES ; goto out ; } ret = cgfs_create ( controller , cgroup , fc -> uid , fc -> gid ) ; printf ( "cgfs_create<S2SV_blank>returned<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>%s\\n" , ret , controller , cgroup ) ; out : free ( cgdir ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-476 int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = "INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = "CLIENT<S2SV_blank>EXPIRED" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = "CLIENT<S2SV_blank>KEY<S2SV_blank>EXPIRED" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = "SERVICE<S2SV_blank>EXPIRED" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = "REQUIRED<S2SV_blank>PWCHANGE" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = "POSTDATE<S2SV_blank>NOT<S2SV_blank>ALLOWED" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) ) ) { * status = "PROXIABLE<S2SV_blank>NOT<S2SV_blank>ALLOWED" ; return ( KDC_ERR_POLICY ) ; } if ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = "CLIENT<S2SV_blank>LOCKED<S2SV_blank>OUT" ; return ( KDC_ERR_CLIENT_REVOKED ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { * status = "SERVICE<S2SV_blank>LOCKED<S2SV_blank>OUT" ; return ( KDC_ERR_S_PRINCIPAL_UNKNOWN ) ; } if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_SVR ) ) { * status = "SERVICE<S2SV_blank>NOT<S2SV_blank>ALLOWED" ; return ( KDC_ERR_MUST_USE_USER2USER ) ; } <S2SV_StartBug> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { <S2SV_EndBug> * status = "ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED" ; return ( KDC_ERR_POLICY ) ; } ret = krb5_db_check_policy_as ( kdc_context , request , & client , & server , kdc_time , status , e_data ) ; if ( ret && ret != KRB5_PLUGIN_OP_NOTSUPP ) return errcode_to_protocol ( ret ) ; errcode = against_local_policy_as ( request , client , server , kdc_time , status , e_data ) ; if ( errcode ) return errcode ; return 0 ; }
CWE-119 <S2SV_StartBug> double vp9_convert_qindex_to_q ( int qindex ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_ac_quant ( qindex , 0 ) / 4.0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> sock_put ( sk ) ; } }
CWE-476 SYSCALL_DEFINE5 ( add_key , const char __user * , _type , const char __user * , _description , const void __user * , _payload , size_t , plen , key_serial_t , ringid ) { key_ref_t keyring_ref , key_ref ; char type [ 32 ] , * description ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > 1024 * 1024 - 1 ) goto error ; ret = key_get_type_from_user ( type , _type , sizeof ( type ) ) ; if ( ret < 0 ) goto error ; description = NULL ; if ( _description ) { description = strndup_user ( _description , KEY_MAX_DESC_SIZE ) ; if ( IS_ERR ( description ) ) { ret = PTR_ERR ( description ) ; goto error ; } if ( ! * description ) { kfree ( description ) ; description = NULL ; } else if ( ( description [ 0 ] == '.' ) && ( strncmp ( type , "keyring" , 7 ) == 0 ) ) { ret = - EPERM ; goto error2 ; } } payload = NULL ; <S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ret = - ENOMEM ; payload = kvmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error2 ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error3 ; } keyring_ref = lookup_user_key ( ringid , KEY_LOOKUP_CREATE , KEY_NEED_WRITE ) ; if ( IS_ERR ( keyring_ref ) ) { ret = PTR_ERR ( keyring_ref ) ; goto error3 ; } key_ref = key_create_or_update ( keyring_ref , type , description , payload , plen , KEY_PERM_UNDEF , KEY_ALLOC_IN_QUOTA ) ; if ( ! IS_ERR ( key_ref ) ) { ret = key_ref_to_ptr ( key_ref ) -> serial ; key_ref_put ( key_ref ) ; } else { ret = PTR_ERR ( key_ref ) ; } key_ref_put ( keyring_ref ) ; error3 : kvfree ( payload ) ; error2 : kfree ( description ) ; error : return ret ; }
CWE-119 void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ; <S2SV_StartBug> data -> l_head = NULL ; <S2SV_EndBug> data -> portListing = NULL ; data -> portListingLength = 0 ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }
CWE-189 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ; <S2SV_StartBug> if ( skb_headroom ( skb ) < ( tnl_hlen + frag_hdr_sz ) ) { <S2SV_EndBug> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
CWE-119 static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_StartBug> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> return 0 ; }
CWE-362 void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ; <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; } }
CWE-119 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" <S2SV_EndBug> "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-787 static pdf_creator_t * new_creator ( int * n_elements ) { pdf_creator_t * daddy ; static const pdf_creator_t creator_template [ ] = { { "Title" , "" } , { "Author" , "" } , { "Subject" , "" } , { "Keywords" , "" } , { "Creator" , "" } , { "Producer" , "" } , { "CreationDate" , "" } , { "ModDate" , "" } , { "Trapped" , "" } , } ; <S2SV_StartBug> daddy = malloc ( sizeof ( creator_template ) ) ; <S2SV_EndBug> memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; if ( n_elements ) * n_elements = sizeof ( creator_template ) / sizeof ( creator_template [ 0 ] ) ; return daddy ; }
CWE-200 char * problem_data_save ( problem_data_t * pd ) { load_abrt_conf ( ) ; <S2SV_StartBug> struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ; <S2SV_EndBug> char * problem_id = NULL ; if ( dd ) { problem_id = xstrdup ( dd -> dd_dirname ) ; dd_close ( dd ) ; } log_info ( "problem<S2SV_blank>id:<S2SV_blank>\'%s\'" , problem_id ) ; return problem_id ; }
CWE-189 PHP_FUNCTION ( imageaffinematrixconcat ) { double m1 [ 6 ] ; double m2 [ 6 ] ; double mr [ 6 ] ; zval * * tmp ; zval * z_m1 ; zval * z_m2 ; int i , nelems ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "aa" , & z_m1 , & z_m2 ) == FAILURE ) { return ; } if ( ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_m1 ) ) ) != 6 ) || ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_m2 ) ) ) != 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Affine<S2SV_blank>arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>six<S2SV_blank>elements" ) ; RETURN_FALSE ; } for ( i = 0 ; i < 6 ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( z_m1 ) , i , ( void * * ) & tmp ) == SUCCESS ) { switch ( Z_TYPE_PP ( tmp ) ) { case IS_LONG : m1 [ i ] = Z_LVAL_PP ( tmp ) ; break ; case IS_DOUBLE : m1 [ i ] = Z_DVAL_PP ( tmp ) ; break ; case IS_STRING : <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m1 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i" , i ) ; RETURN_FALSE ; } } if ( zend_hash_index_find ( Z_ARRVAL_P ( z_m2 ) , i , ( void * * ) & tmp ) == SUCCESS ) { switch ( Z_TYPE_PP ( tmp ) ) { case IS_LONG : m2 [ i ] = Z_LVAL_PP ( tmp ) ; break ; case IS_DOUBLE : m2 [ i ] = Z_DVAL_PP ( tmp ) ; break ; case IS_STRING : <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m2 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i" , i ) ; RETURN_FALSE ; } } } if ( gdAffineConcat ( mr , m1 , m2 ) != GD_TRUE ) { RETURN_FALSE ; } array_init ( return_value ) ; for ( i = 0 ; i < 6 ; i ++ ) { add_index_double ( return_value , i , mr [ i ] ) ; } }
CWE-000 static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct ext4_ext_path * path , int flags , unsigned int allocated , struct buffer_head * bh_result , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; ext_debug ( "ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical" "block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%d,<S2SV_blank>allocated<S2SV_blank>%u" , inode -> i_ino , ( unsigned long long ) iblock , max_blocks , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ; if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { set_buffer_unwritten ( bh_result ) ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , path , iblock , max_blocks ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; set_buffer_new ( bh_result ) ; if ( allocated > max_blocks ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + max_blocks , allocated - max_blocks ) ; allocated = max_blocks ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ext4_da_update_reserve_space ( inode , allocated , 0 ) ; map_out : set_buffer_mapped ( bh_result ) ; out1 : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }
CWE-125 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = "" ; const char * link_section_name = "" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , "section_name" , section_name , 0 ) ; sdb_num_set ( sdb , "entries" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) <S2SV_StartBug> vstart += verdef -> vd_aux ; <S2SV_EndBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , "idx" , i , 0 ) ; sdb_num_set ( sdb_verdef , "vd_version" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , "vd_ndx" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , "vd_cnt" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , "flags" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , "idx" , isum , 0 ) ; sdb_num_set ( sdb_parent , "parent" , j , 0 ) ; sdb_set ( sdb_parent , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , "parent%d" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , "verdef%d" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> if ( ! tmp ) <S2SV_StartBug> return ; <S2SV_EndBug> while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static void filter_selectively_vert ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= 1 ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ; <S2SV_EndBug> } else if ( mask_8x8 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> } else if ( mask_4x4 & 1 ) { <S2SV_StartBug> vp9_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; <S2SV_EndBug> } } if ( mask_4x4_int & 1 ) vp9_lpf_vertical_4 ( s + 4 , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; s += 8 ; lfl += 1 ; mask_16x16 >>= 1 ; mask_8x8 >>= 1 ; mask_4x4 >>= 1 ; mask_4x4_int >>= 1 ; } }
CWE-264 static ssize_t ucma_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ucma_file * file = filp -> private_data ; struct rdma_ucm_cmd_hdr hdr ; <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucma_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; if ( ! ucma_cmd_table [ hdr . cmd ] ) return - ENOSYS ; ret = ucma_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! ret ) ret = len ; return ret ; }
CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_capcode_values , "Unknown" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { <S2SV_StartBug> case BGP_CAPCODE_MP : <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ; ND_PRINT ( ( ndo , "\\n\\t\\tRestart<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>Restart<S2SV_blank>Time<S2SV_blank>%us" , ( ( opt [ i + 2 ] ) & 0x80 ) ? "R" : "none" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>AFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Forwarding<S2SV_blank>state<S2SV_blank>preserved:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , ( ( opt [ i + cap_offset + 3 ] ) & 0x80 ) ? "yes" : "no" ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; case BGP_CAPCODE_RR : case BGP_CAPCODE_RR_CISCO : break ; case BGP_CAPCODE_AS_NEW : if ( cap_len == 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>4<S2SV_blank>Byte<S2SV_blank>AS<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( opt + i + 2 ) ) ) ) ; } break ; case BGP_CAPCODE_ADD_PATH : cap_offset = 2 ; if ( tcap_len == 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(bogus)" ) ) ; break ; } while ( tcap_len > 0 ) { if ( tcap_len < 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t(invalid)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Send/Receive:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , tok2str ( bgp_add_path_recvsend , "Bogus<S2SV_blank>(0x%02x)" , opt [ i + cap_offset + 3 ] ) ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; default : ND_PRINT ( ( ndo , "\\n\\t\\tno<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>Capability<S2SV_blank>%u" , cap_type ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; break ; } if ( ndo -> ndo_vflag > 1 && cap_len > 0 ) { print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; } i += BGP_CAP_HEADER_SIZE + cap_len ; } return ; trunc : ND_PRINT ( ( ndo , "[|BGP]" ) ) ; }
CWE-125 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; <S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ; remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
CWE-119 static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { const int ctx = vp9_get_reference_mode_context ( cm , xd ) ; const REFERENCE_MODE mode = <S2SV_StartBug> ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . comp_inter [ ctx ] [ mode ] ; return mode ; } else { return cm -> reference_mode ; } }
CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; } <S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }
CWE-476 static gint dissect_ac_if_hdr_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) { gint offset_start ; guint16 bcdADC ; guint8 ver_major ; double ver ; guint8 if_in_collection , i ; audio_conv_info_t * audio_conv_info ; offset_start = offset ; bcdADC = tvb_get_letohs ( tvb , offset ) ; ver_major = USB_AUDIO_BCD44_TO_DEC ( bcdADC >> 8 ) ; ver = ver_major + USB_AUDIO_BCD44_TO_DEC ( bcdADC & 0xFF ) / 100.0 ; proto_tree_add_double_format_value ( tree , hf_ac_if_hdr_ver , tvb , offset , 2 , ver , "%2.2f" , ver ) ; audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ; if ( ! audio_conv_info ) { audio_conv_info = wmem_new ( wmem_file_scope ( ) , audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> audio_conv_info -> ver_major = ver_major ; offset += 2 ; if ( ver_major == 1 ) { proto_tree_add_item ( tree , hf_ac_if_hdr_total_len , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; if_in_collection = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_ac_if_hdr_bInCollection , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; for ( i = 0 ; i < if_in_collection ; i ++ ) { proto_tree_add_item ( tree , hf_ac_if_hdr_if_num , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; } } return offset - offset_start ; }
CWE-476 int jp2_box_put ( jp2_box_t * box , jas_stream_t * out ) { jas_stream_t * tmpstream ; bool extlen ; bool dataflag ; tmpstream = 0 ; dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( box -> ops -> putdata ) { if ( ( * box -> ops -> putdata ) ( box , tmpstream ) ) { goto error ; } } box -> len = jas_stream_tell ( tmpstream ) + JP2_BOX_HDRLEN ( false ) ; jas_stream_rewind ( tmpstream ) ; } extlen = ( box -> len >= ( ( ( uint_fast64_t ) 1 ) << 32 ) ) != 0 ; if ( jp2_putuint32 ( out , extlen ? 1 : box -> len ) ) { goto error ; } if ( jp2_putuint32 ( out , box -> type ) ) { goto error ; } if ( extlen ) { if ( jp2_putuint64 ( out , box -> len ) ) { goto error ; } } if ( dataflag ) { <S2SV_StartBug> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <S2SV_EndBug> goto error ; } jas_stream_close ( tmpstream ) ; } return 0 ; error : if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return - 1 ; }
CWE-362 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , "tty_ioctl" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }
CWE-119 int vp8_set_active_map ( VP8_COMP * cpi , unsigned char * map , unsigned int rows , unsigned int cols ) { if ( rows == cpi -> common . mb_rows && cols == cpi -> common . mb_cols ) { if ( map ) { <S2SV_StartBug> vpx_memcpy ( cpi -> active_map , map , rows * cols ) ; <S2SV_EndBug> cpi -> active_map_enabled = 1 ; } else cpi -> active_map_enabled = 0 ; return 0 ; } else { return - 1 ; } }
CWE-284 int sock_send_all ( int sock_fd , const uint8_t * buf , int len ) { int s = len ; int ret ; while ( s ) { <S2SV_StartBug> do ret = send ( sock_fd , buf , s , 0 ) ; <S2SV_EndBug> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( "sock<S2SV_blank>fd:%d<S2SV_blank>send<S2SV_blank>errno:%d,<S2SV_blank>ret:%d" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; s -= ret ; } return len ; }
CWE-190 int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }
CWE-119 <S2SV_StartBug> static void write_mv_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> const unsigned int counts [ ] , <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug> int i ; unsigned int branch_ct [ 32 ] [ 2 ] ; assert ( n <= 32 ) ; vp9_tree_probs_from_distribution ( tree , branch_ct , counts ) ; for ( i = 0 ; i < n - 1 ; ++ i ) update_mv ( w , branch_ct [ i ] , & probs [ i ] , MV_UPDATE_PROB ) ; }
CWE-119 void vp8_build_intra_predictors_mby_s_c ( MACROBLOCKD * x , unsigned char * yabove_row , unsigned char * yleft , int left_stride , unsigned char * ypred_ptr , int y_stride ) { unsigned char yleft_col [ 16 ] ; unsigned char ytop_left = yabove_row [ - 1 ] ; int r , c , i ; for ( i = 0 ; i < 16 ; i ++ ) { yleft_col [ i ] = yleft [ i * left_stride ] ; } switch ( x -> mode_info_context -> mbmi . mode ) { case DC_PRED : { int expected_dc ; int shift ; int average = 0 ; if ( x -> up_available || x -> left_available ) { if ( x -> up_available ) { for ( i = 0 ; i < 16 ; i ++ ) { average += yabove_row [ i ] ; } } if ( x -> left_available ) { for ( i = 0 ; i < 16 ; i ++ ) { average += yleft_col [ i ] ; } } shift = 3 + x -> up_available + x -> left_available ; expected_dc = ( average + ( 1 << ( shift - 1 ) ) ) >> shift ; } else { expected_dc = 128 ; } for ( r = 0 ; r < 16 ; r ++ ) { <S2SV_StartBug> vpx_memset ( ypred_ptr , expected_dc , 16 ) ; <S2SV_EndBug> ypred_ptr += y_stride ; } } break ; case V_PRED : { for ( r = 0 ; r < 16 ; r ++ ) { ( ( int * ) ypred_ptr ) [ 0 ] = ( ( int * ) yabove_row ) [ 0 ] ; ( ( int * ) ypred_ptr ) [ 1 ] = ( ( int * ) yabove_row ) [ 1 ] ; ( ( int * ) ypred_ptr ) [ 2 ] = ( ( int * ) yabove_row ) [ 2 ] ; ( ( int * ) ypred_ptr ) [ 3 ] = ( ( int * ) yabove_row ) [ 3 ] ; ypred_ptr += y_stride ; } } break ; case H_PRED : { for ( r = 0 ; r < 16 ; r ++ ) { <S2SV_StartBug> vpx_memset ( ypred_ptr , yleft_col [ r ] , 16 ) ; <S2SV_EndBug> ypred_ptr += y_stride ; } } break ; case TM_PRED : { for ( r = 0 ; r < 16 ; r ++ ) { for ( c = 0 ; c < 16 ; c ++ ) { int pred = yleft_col [ r ] + yabove_row [ c ] - ytop_left ; if ( pred < 0 ) pred = 0 ; if ( pred > 255 ) pred = 255 ; ypred_ptr [ c ] = pred ; } ypred_ptr += y_stride ; } } break ; case B_PRED : case NEARESTMV : case NEARMV : case ZEROMV : case NEWMV : case SPLITMV : case MB_MODE_COUNT : break ; } }
CWE-125 static void ip_optprint ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int option_len ; const char * sep = "" ; for ( ; length > 0 ; cp += option_len , length -= option_len ) { u_int option_code ; ND_PRINT ( ( ndo , "%s" , sep ) ) ; sep = "," ; ND_TCHECK ( * cp ) ; option_code = * cp ; ND_PRINT ( ( ndo , "%s" , tok2str ( ip_option_values , "unknown<S2SV_blank>%u" , option_code ) ) ) ; if ( option_code == IPOPT_NOP || option_code == IPOPT_EOL ) option_len = 1 ; else { ND_TCHECK ( cp [ 1 ] ) ; option_len = cp [ 1 ] ; if ( option_len < 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; return ; } } if ( option_len > length ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; return ; } ND_TCHECK2 ( * cp , option_len ) ; switch ( option_code ) { case IPOPT_EOL : return ; case IPOPT_TS : ip_printts ( ndo , cp , option_len ) ; break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : <S2SV_StartBug> ip_printroute ( ndo , cp , option_len ) ; <S2SV_EndBug> break ; case IPOPT_RA : if ( option_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; break ; } ND_TCHECK ( cp [ 3 ] ) ; if ( EXTRACT_16BITS ( & cp [ 2 ] ) != 0 ) ND_PRINT ( ( ndo , "<S2SV_blank>value<S2SV_blank>%u" , EXTRACT_16BITS ( & cp [ 2 ] ) ) ) ; break ; case IPOPT_NOP : case IPOPT_SECURITY : default : break ; } } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-284 static void btif_fetch_local_bdaddr ( bt_bdaddr_t * local_addr ) { char val [ PROPERTY_VALUE_MAX ] = { 0 } ; uint8_t valid_bda = FALSE ; int val_size = 0 ; const uint8_t null_bdaddr [ BD_ADDR_LEN ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; if ( property_get ( PROPERTY_BT_BDADDR_PATH , val , NULL ) ) { int addr_fd ; BTIF_TRACE_DEBUG ( "%s,<S2SV_blank>local<S2SV_blank>bdaddr<S2SV_blank>is<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%s" , __func__ , val ) ; <S2SV_StartBug> if ( ( addr_fd = open ( val , O_RDONLY ) ) != - 1 ) <S2SV_EndBug> { memset ( val , 0 , sizeof ( val ) ) ; <S2SV_StartBug> read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ; <S2SV_EndBug> if ( ( string_to_bdaddr ( val , local_addr ) ) && ( memcmp ( local_addr -> address , null_bdaddr , BD_ADDR_LEN ) != 0 ) ) { valid_bda = TRUE ; BTIF_TRACE_DEBUG ( "%s:<S2SV_blank>Got<S2SV_blank>Factory<S2SV_blank>BDA<S2SV_blank>%s" , __func__ , val ) ; } close ( addr_fd ) ; } } if ( ! valid_bda ) { val_size = sizeof ( val ) ; if ( btif_config_get_str ( "Adapter" , "Address" , val , & val_size ) ) { string_to_bdaddr ( val , local_addr ) ; BTIF_TRACE_DEBUG ( "local<S2SV_blank>bdaddr<S2SV_blank>from<S2SV_blank>bt_config.xml<S2SV_blank>is<S2SV_blank><S2SV_blank>%s" , val ) ; return ; } } if ( ! valid_bda ) { valid_bda = btif_fetch_property ( PERSIST_BDADDR_PROPERTY , local_addr ) ; } if ( ! valid_bda ) { valid_bda = btif_fetch_property ( FACTORY_BT_ADDR_PROPERTY , local_addr ) ; } if ( ! valid_bda ) { bdstr_t bdstr ; srand ( ( unsigned int ) ( time ( 0 ) ) ) ; local_addr -> address [ 0 ] = 0x22 ; local_addr -> address [ 1 ] = 0x22 ; local_addr -> address [ 2 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 3 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 4 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 5 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; bdaddr_to_string ( local_addr , bdstr , sizeof ( bdstr ) ) ; BTIF_TRACE_DEBUG ( "No<S2SV_blank>preset<S2SV_blank>BDA.<S2SV_blank>Generating<S2SV_blank>BDA:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>prop<S2SV_blank>%s" , ( char * ) bdstr , PERSIST_BDADDR_PROPERTY ) ; if ( property_set ( PERSIST_BDADDR_PROPERTY , ( char * ) bdstr ) < 0 ) BTIF_TRACE_ERROR ( "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>random<S2SV_blank>BDA<S2SV_blank>in<S2SV_blank>prop<S2SV_blank>%s" , PERSIST_BDADDR_PROPERTY ) ; } bdstr_t bdstr ; bdaddr_to_string ( local_addr , bdstr , sizeof ( bdstr ) ) ; val_size = sizeof ( val ) ; if ( btif_config_get_str ( "Adapter" , "Address" , val , & val_size ) ) { if ( strcmp ( bdstr , val ) == 0 ) { return ; } } btif_config_set_str ( "Adapter" , "Address" , bdstr ) ; }
CWE-284 static int tcp_v6_rcv ( struct sk_buff * skb ) { const struct tcphdr * th ; const struct ipv6hdr * hdr ; bool refcounted ; struct sock * sk ; int ret ; struct net * net = dev_net ( skb -> dev ) ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; __TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ; if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ; th = ( const struct tcphdr * ) skb -> data ; if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ; if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ; if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) ; lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ; if ( ! sk ) goto no_tcp_socket ; process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ; if ( sk -> sk_state == TCP_NEW_SYN_RECV ) { struct request_sock * req = inet_reqsk ( sk ) ; struct sock * nsk ; sk = req -> rsk_listener ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) { sk_drops_add ( sk , skb ) ; reqsk_put ( req ) ; goto discard_it ; } if ( unlikely ( sk -> sk_state != TCP_LISTEN ) ) { inet_csk_reqsk_queue_drop_and_put ( sk , req ) ; goto lookup ; } sock_hold ( sk ) ; refcounted = true ; nsk = tcp_check_req ( sk , skb , req , false ) ; if ( ! nsk ) { reqsk_put ( req ) ; goto discard_and_relse ; } if ( nsk == sk ) { reqsk_put ( req ) ; tcp_v6_restore_cb ( skb ) ; } else if ( tcp_child_process ( sk , nsk , skb ) ) { tcp_v6_send_reset ( nsk , skb ) ; goto discard_and_relse ; } else { sock_put ( sk ) ; return 0 ; } } if ( hdr -> hop_limit < inet6_sk ( sk ) -> min_hopcount ) { __NET_INC_STATS ( net , LINUX_MIB_TCPMINTTLDROP ) ; goto discard_and_relse ; } if ( ! xfrm6_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto discard_and_relse ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) goto discard_and_relse ; <S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> skb -> dev = NULL ; if ( sk -> sk_state == TCP_LISTEN ) { ret = tcp_v6_do_rcv ( sk , skb ) ; goto put_and_return ; } sk_incoming_cpu_update ( sk ) ; bh_lock_sock_nested ( sk ) ; tcp_segs_in ( tcp_sk ( sk ) , skb ) ; ret = 0 ; if ( ! sock_owned_by_user ( sk ) ) { if ( ! tcp_prequeue ( sk , skb ) ) ret = tcp_v6_do_rcv ( sk , skb ) ; } else if ( tcp_add_backlog ( sk , skb ) ) { goto discard_and_relse ; } bh_unlock_sock ( sk ) ; put_and_return : if ( refcounted ) sock_put ( sk ) ; return ret ? - 1 : 0 ; no_tcp_socket : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) goto discard_it ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { csum_error : __TCP_INC_STATS ( net , TCP_MIB_CSUMERRORS ) ; bad_packet : __TCP_INC_STATS ( net , TCP_MIB_INERRS ) ; } else { tcp_v6_send_reset ( NULL , skb ) ; } discard_it : kfree_skb ( skb ) ; return 0 ; discard_and_relse : sk_drops_add ( sk , skb ) ; if ( refcounted ) sock_put ( sk ) ; goto discard_it ; do_time_wait : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto discard_it ; } tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto csum_error ; } switch ( tcp_timewait_state_process ( inet_twsk ( sk ) , skb , th ) ) { case TCP_TW_SYN : { struct sock * sk2 ; sk2 = inet6_lookup_listener ( dev_net ( skb -> dev ) , & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , & ipv6_hdr ( skb ) -> saddr , th -> source , & ipv6_hdr ( skb ) -> daddr , ntohs ( th -> dest ) , tcp_v6_iif ( skb ) ) ; if ( sk2 ) { struct inet_timewait_sock * tw = inet_twsk ( sk ) ; inet_twsk_deschedule_put ( tw ) ; sk = sk2 ; tcp_v6_restore_cb ( skb ) ; refcounted = false ; goto process ; } } case TCP_TW_ACK : tcp_v6_timewait_ack ( sk , skb ) ; break ; case TCP_TW_RST : tcp_v6_restore_cb ( skb ) ; tcp_v6_send_reset ( sk , skb ) ; inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; goto discard_it ; case TCP_TW_SUCCESS : ; } goto discard_it ; }
CWE-125 static int name_len ( netdissect_options * ndo , const unsigned char * s , const unsigned char * maxbuf ) { const unsigned char * s0 = s ; unsigned char c ; if ( s >= maxbuf ) return ( - 1 ) ; ND_TCHECK2 ( * s , 1 ) ; c = * s ; if ( ( c & 0xC0 ) == 0xC0 ) return ( 2 ) ; while ( * s ) { if ( s >= maxbuf ) return ( - 1 ) ; ND_TCHECK2 ( * s , 1 ) ; s += ( * s ) + 1 ; <S2SV_StartBug> } <S2SV_EndBug> return ( PTR_DIFF ( s , s0 ) + 1 ) ; trunc : return ( - 1 ) ; }
CWE-000 void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , "xmlParsePEReference:<S2SV_blank>no<S2SV_blank>name\\n" ) ; return ; } if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_ENTITYREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , name ) ; } else { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , "Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\n" , name , NULL ) ; } else if ( ctxt -> input -> free != deallocblankswrapper ) { input = xmlNewBlanksWrapperInputStream ( ctxt , entity ) ; if ( xmlPushInput ( ctxt , input ) < 0 ) return ; } else { <S2SV_StartBug> input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_EndBug> if ( xmlPushInput ( ctxt , input ) < 0 ) return ; if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { xmlParseTextDecl ( ctxt ) ; if ( ctxt -> errNo == XML_ERR_UNSUPPORTED_ENCODING ) { xmlHaltParser ( ctxt ) ; return ; } } } } ctxt -> hasPErefs = 1 ; }
CWE-119 <S2SV_StartBug> int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) { <S2SV_EndBug> int start_index = rc -> worst_quality ; int target_index = rc -> worst_quality ; int i ; for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { start_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qstart ) <S2SV_EndBug> break ; } for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { target_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) <S2SV_EndBug> break ; } return target_index - start_index ; }
CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> DPRINTF ( ( "Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%" SIZE_T_FORMAT "u<S2SV_blank>><S2SV_blank>%" SIZE_T_FORMAT "u\\n" , <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }
CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } <S2SV_StartBug> if ( dst_reg -> smin_value < 0 ) { <S2SV_EndBug> if ( umin_val ) { dst_reg -> smin_value = 0 ; } else { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; <S2SV_StartBug> } <S2SV_EndBug> } else { dst_reg -> smin_value = ( u64 ) ( dst_reg -> smin_value ) >> umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
CWE-264 static __inline__ int scm_check_creds ( struct ucred * creds ) { const struct cred * cred = current_cred ( ) ; kuid_t uid = make_kuid ( cred -> user_ns , creds -> uid ) ; kgid_t gid = make_kgid ( cred -> user_ns , creds -> gid ) ; if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) return - EINVAL ; if ( ( creds -> pid == task_tgid_vnr ( current ) || <S2SV_StartBug> ns_capable ( current -> nsproxy -> pid_ns -> user_ns , CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) { return 0 ; } return - EPERM ; }
CWE-119 <S2SV_StartBug> int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <S2SV_EndBug> FILE * f = input_ctx -> file ; y4m_input * y4m = & input_ctx -> y4m ; int shortread = 0 ; if ( input_ctx -> file_type == FILE_TYPE_Y4M ) { if ( y4m_input_fetch_frame ( y4m , f , img ) < 1 ) return 0 ; } else { shortread = read_yuv_frame ( input_ctx , img ) ; } return ! shortread ; }
CWE-119 <S2SV_StartBug> void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int frame_filter_level , int y_only , int partial_frame ) { int start_mi_row , end_mi_row , mi_rows_to_filter ; if ( ! frame_filter_level ) return ; start_mi_row = 0 ; mi_rows_to_filter = cm -> mi_rows ; if ( partial_frame && cm -> mi_rows > 8 ) { start_mi_row = cm -> mi_rows >> 1 ; start_mi_row &= 0xfffffff8 ; mi_rows_to_filter = MAX ( cm -> mi_rows / 8 , 8 ) ; } end_mi_row = start_mi_row + mi_rows_to_filter ; vp9_loop_filter_frame_init ( cm , frame_filter_level ) ; <S2SV_StartBug> vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd , <S2SV_EndBug> start_mi_row , end_mi_row , y_only ) ; }
CWE-264 static int ovl_fill_super ( struct super_block * sb , void * data , int silent ) { struct path lowerpath ; struct path upperpath ; struct path workpath ; struct inode * root_inode ; struct dentry * root_dentry ; struct ovl_entry * oe ; struct ovl_fs * ufs ; struct kstatfs statfs ; int err ; err = - ENOMEM ; ufs = kzalloc ( sizeof ( struct ovl_fs ) , GFP_KERNEL ) ; if ( ! ufs ) goto out ; err = ovl_parse_opt ( ( char * ) data , & ufs -> config ) ; if ( err ) goto out_free_config ; err = - EINVAL ; if ( ! ufs -> config . upperdir || ! ufs -> config . lowerdir || ! ufs -> config . workdir ) { pr_err ( "overlayfs:<S2SV_blank>missing<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir\\n" ) ; goto out_free_config ; } err = - ENOMEM ; oe = ovl_alloc_entry ( ) ; if ( oe == NULL ) goto out_free_config ; err = ovl_mount_dir ( ufs -> config . upperdir , & upperpath ) ; if ( err ) goto out_free_oe ; err = ovl_mount_dir ( ufs -> config . lowerdir , & lowerpath ) ; if ( err ) goto out_put_upperpath ; err = ovl_mount_dir ( ufs -> config . workdir , & workpath ) ; if ( err ) goto out_put_lowerpath ; err = - EINVAL ; if ( ! S_ISDIR ( upperpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( lowerpath . dentry -> d_inode -> i_mode ) || ! S_ISDIR ( workpath . dentry -> d_inode -> i_mode ) ) { pr_err ( "overlayfs:<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir<S2SV_blank>not<S2SV_blank>a<S2SV_blank>directory\\n" ) ; goto out_put_workpath ; } if ( upperpath . mnt != workpath . mnt ) { pr_err ( "overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>reside<S2SV_blank>under<S2SV_blank>the<S2SV_blank>same<S2SV_blank>mount\\n" ) ; goto out_put_workpath ; } if ( ! ovl_workdir_ok ( workpath . dentry , upperpath . dentry ) ) { pr_err ( "overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>be<S2SV_blank>separate<S2SV_blank>subtrees\\n" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( upperpath . dentry ) ) { pr_err ( "overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>upperdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; goto out_put_workpath ; } if ( ! ovl_is_allowed_fs_type ( lowerpath . dentry ) ) { pr_err ( "overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>lowerdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; goto out_put_workpath ; } err = vfs_statfs ( & lowerpath , & statfs ) ; if ( err ) { pr_err ( "overlayfs:<S2SV_blank>statfs<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>lowerpath\\n" ) ; goto out_put_workpath ; } ufs -> lower_namelen = statfs . f_namelen ; <S2SV_StartBug> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; <S2SV_EndBug> err = PTR_ERR ( ufs -> upper_mnt ) ; if ( IS_ERR ( ufs -> upper_mnt ) ) { pr_err ( "overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>upperpath\\n" ) ; goto out_put_workpath ; } ufs -> lower_mnt = clone_private_mount ( & lowerpath ) ; err = PTR_ERR ( ufs -> lower_mnt ) ; if ( IS_ERR ( ufs -> lower_mnt ) ) { pr_err ( "overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>lowerpath\\n" ) ; goto out_put_upper_mnt ; } ufs -> workdir = ovl_workdir_create ( ufs -> upper_mnt , workpath . dentry ) ; err = PTR_ERR ( ufs -> workdir ) ; if ( IS_ERR ( ufs -> workdir ) ) { pr_err ( "overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>directory<S2SV_blank>%s/%s\\n" , ufs -> config . workdir , OVL_WORKDIR_NAME ) ; goto out_put_lower_mnt ; } ufs -> lower_mnt -> mnt_flags |= MNT_READONLY ; if ( ufs -> upper_mnt -> mnt_sb -> s_flags & MS_RDONLY ) sb -> s_flags |= MS_RDONLY ; sb -> s_d_op = & ovl_dentry_operations ; err = - ENOMEM ; root_inode = ovl_new_inode ( sb , S_IFDIR , oe ) ; if ( ! root_inode ) goto out_put_workdir ; root_dentry = d_make_root ( root_inode ) ; if ( ! root_dentry ) goto out_put_workdir ; mntput ( upperpath . mnt ) ; mntput ( lowerpath . mnt ) ; path_put ( & workpath ) ; oe -> __upperdentry = upperpath . dentry ; oe -> lowerdentry = lowerpath . dentry ; root_dentry -> d_fsdata = oe ; sb -> s_magic = OVERLAYFS_SUPER_MAGIC ; sb -> s_op = & ovl_super_operations ; sb -> s_root = root_dentry ; sb -> s_fs_info = ufs ; return 0 ; out_put_workdir : dput ( ufs -> workdir ) ; out_put_lower_mnt : mntput ( ufs -> lower_mnt ) ; out_put_upper_mnt : mntput ( ufs -> upper_mnt ) ; out_put_workpath : path_put ( & workpath ) ; out_put_lowerpath : path_put ( & lowerpath ) ; out_put_upperpath : path_put ( & upperpath ) ; out_free_oe : kfree ( oe ) ; out_free_config : kfree ( ufs -> config . lowerdir ) ; kfree ( ufs -> config . upperdir ) ; kfree ( ufs -> config . workdir ) ; kfree ( ufs ) ; out : return err ; }
CWE-399 static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }
CWE-399 int cdf_unpack_summary_info ( const cdf_stream_t * sst , const cdf_header_t * h , cdf_summary_info_header_t * ssi , cdf_property_info_t * * info , size_t * count ) { <S2SV_StartBug> size_t i , maxcount ; <S2SV_EndBug> const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ; const cdf_section_declaration_t * sd = CAST ( const cdf_section_declaration_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + CDF_SECTION_DECLARATION_OFFSET ) ) ; if ( cdf_check_stream_offset ( sst , h , si , sizeof ( * si ) , __LINE__ ) == - 1 || cdf_check_stream_offset ( sst , h , sd , sizeof ( * sd ) , __LINE__ ) == - 1 ) return - 1 ; ssi -> si_byte_order = CDF_TOLE2 ( si -> si_byte_order ) ; ssi -> si_os_version = CDF_TOLE2 ( si -> si_os_version ) ; ssi -> si_os = CDF_TOLE2 ( si -> si_os ) ; ssi -> si_class = si -> si_class ; cdf_swap_class ( & ssi -> si_class ) ; <S2SV_StartBug> ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ; <S2SV_EndBug> * count = 0 ; maxcount = 0 ; * info = NULL ; <S2SV_StartBug> for ( i = 0 ; i < CDF_TOLE4 ( si -> si_count ) ; i ++ ) { <S2SV_EndBug> if ( i >= CDF_LOOP_LIMIT ) { DPRINTF ( ( "Unpack<S2SV_blank>summary<S2SV_blank>info<S2SV_blank>loop<S2SV_blank>limit" ) ) ; errno = EFTYPE ; return - 1 ; } if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) , <S2SV_StartBug> info , count , & maxcount ) == - 1 ) { <S2SV_EndBug> return - 1 ; <S2SV_StartBug> } <S2SV_EndBug> } return 0 ; }
CWE-399 static int br_mdb_fill_info ( struct sk_buff * skb , struct netlink_callback * cb , struct net_device * dev ) { struct net_bridge * br = netdev_priv ( dev ) ; struct net_bridge_mdb_htable * mdb ; struct nlattr * nest , * nest2 ; int i , err = 0 ; int idx = 0 , s_idx = cb -> args [ 1 ] ; if ( br -> multicast_disabled ) return 0 ; mdb = rcu_dereference ( br -> mdb ) ; if ( ! mdb ) return 0 ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) return - EMSGSIZE ; for ( i = 0 ; i < mdb -> max ; i ++ ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p , * * pp ; struct net_bridge_port * port ; hlist_for_each_entry_rcu ( mp , & mdb -> mhash [ i ] , hlist [ mdb -> ver ] ) { if ( idx < s_idx ) goto skip ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) { err = - EMSGSIZE ; goto out ; } for ( pp = & mp -> ports ; ( p = rcu_dereference ( * pp ) ) != NULL ; pp = & p -> next ) { port = p -> port ; if ( port ) { struct br_mdb_entry e ; <S2SV_StartBug> e . ifindex = port -> dev -> ifindex ; <S2SV_EndBug> e . state = p -> state ; if ( p -> addr . proto == htons ( ETH_P_IP ) ) e . addr . u . ip4 = p -> addr . u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) if ( p -> addr . proto == htons ( ETH_P_IPV6 ) ) e . addr . u . ip6 = p -> addr . u . ip6 ; # endif e . addr . proto = p -> addr . proto ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( e ) , & e ) ) { nla_nest_cancel ( skb , nest2 ) ; err = - EMSGSIZE ; goto out ; } } } nla_nest_end ( skb , nest2 ) ; skip : idx ++ ; } } out : cb -> args [ 1 ] = idx ; nla_nest_end ( skb , nest ) ; return err ; }
CWE-416 static void free_user ( struct kref * ref ) { struct ipmi_user * user = container_of ( ref , struct ipmi_user , refcount ) ; <S2SV_StartBug> kfree ( user ) ; <S2SV_EndBug> }
CWE-000 static void <S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , "%s/.shadowsocks_%s.conf" , prefix , server -> port ) ; FILE * f = fopen ( path , "w+" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( "unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file" ) ; } ss_free ( path ) ; return ; } fprintf ( f , "{\\n" ) ; fprintf ( f , "\\"server_port\\":%d,\\n" , atoi ( server -> port ) ) ; <S2SV_StartBug> fprintf ( f , "\\"password\\":\\"%s\\"" , server -> password ) ; <S2SV_EndBug> if ( server -> fast_open [ 0 ] ) fprintf ( f , ",\\n\\"fast_open\\":<S2SV_blank>%s" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , ",\\n\\"mode\\":\\"%s\\"" , server -> mode ) ; <S2SV_StartBug> if ( server -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , server -> method ) ; <S2SV_EndBug> if ( server -> plugin ) fprintf ( f , ",\\n\\"plugin\\":\\"%s\\"" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , ",\\n\\"plugin_opts\\":\\"%s\\"" , server -> plugin_opts ) ; fprintf ( f , "\\n}\\n" ) ; fclose ( f ) ; ss_free ( path ) ; }
CWE-399 protected struct magic_set * file_ms_alloc ( int flags ) { struct magic_set * ms ; size_t i , len ; if ( ( ms = CAST ( struct magic_set * , calloc ( ( size_t ) 1 , sizeof ( struct magic_set ) ) ) ) == NULL ) return NULL ; if ( magic_setflags ( ms , flags ) == - 1 ) { errno = EINVAL ; goto free ; } ms -> o . buf = ms -> o . pbuf = NULL ; len = ( ms -> c . len = 10 ) * sizeof ( * ms -> c . li ) ; if ( ( ms -> c . li = CAST ( struct level_info * , malloc ( len ) ) ) == NULL ) goto free ; ms -> event_flags = 0 ; ms -> error = - 1 ; for ( i = 0 ; i < MAGIC_SETS ; i ++ ) ms -> mlist [ i ] = NULL ; ms -> file = "unknown" ; ms -> line = 0 ; ms -> indir_max = FILE_INDIR_MAX ; ms -> name_max = FILE_NAME_MAX ; ms -> elf_shnum_max = FILE_ELF_SHNUM_MAX ; ms -> elf_phnum_max = FILE_ELF_PHNUM_MAX ; <S2SV_StartBug> return ms ; <S2SV_EndBug> free : free ( ms ) ; return NULL ; }
CWE-000 static OPJ_BOOL opj_pi_next_rpcl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < pi -> poc . resno1 ; pi -> resno ++ ) { for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; comp = & pi -> comps [ pi -> compno ] ; if ( pi -> resno >= comp -> numresolutions ) { continue ; } res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
CWE-189 static int opl3_load_patch ( int dev , int format , const char __user * addr , <S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> { struct sbi_instrument ins ; if ( count < sizeof ( ins ) ) { printk ( KERN_WARNING "FM<S2SV_blank>Error:<S2SV_blank>Patch<S2SV_blank>record<S2SV_blank>too<S2SV_blank>short\\n" ) ; return - EINVAL ; } <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & ins ) [ offs ] , addr + offs , sizeof ( ins ) - offs ) ) <S2SV_EndBug> return - EFAULT ; if ( ins . channel < 0 || ins . channel >= SBFM_MAXINSTR ) { printk ( KERN_WARNING "FM<S2SV_blank>Error:<S2SV_blank>Invalid<S2SV_blank>instrument<S2SV_blank>number<S2SV_blank>%d\\n" , ins . channel ) ; return - EINVAL ; } ins . key = format ; return store_instr ( ins . channel , & ins ) ; }
CWE-000 static int mount_entry_on_absolute_rootfs ( struct mntent * mntent , const struct lxc_rootfs * rootfs , const char * lxc_name ) { char * aux ; char path [ MAXPATHLEN ] ; int r , ret = 0 , offset ; const char * lxcpath ; lxcpath = lxc_global_config_value ( "lxc.lxcpath" ) ; if ( ! lxcpath ) { ERROR ( "Out<S2SV_blank>of<S2SV_blank>memory" ) ; return - 1 ; } r = snprintf ( path , MAXPATHLEN , "%s/%s/rootfs" , lxcpath , lxc_name ) ; if ( r < 0 || r >= MAXPATHLEN ) goto skipvarlib ; aux = strstr ( mntent -> mnt_dir , path ) ; if ( aux ) { offset = strlen ( path ) ; goto skipabs ; } skipvarlib : aux = strstr ( mntent -> mnt_dir , rootfs -> path ) ; if ( ! aux ) { WARN ( "ignoring<S2SV_blank>mount<S2SV_blank>point<S2SV_blank>\'%s\'" , mntent -> mnt_dir ) ; return ret ; } offset = strlen ( rootfs -> path ) ; skipabs : r = snprintf ( path , MAXPATHLEN , "%s/%s" , rootfs -> mount , aux + offset ) ; if ( r < 0 || r >= MAXPATHLEN ) { WARN ( "pathnme<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>\'%s\'" , mntent -> mnt_dir ) ; return - 1 ; } <S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> }
CWE-20 long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { <S2SV_StartBug> if ( shmflg & SHM_RND ) <S2SV_EndBug> addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr , shmflg ) ; if ( err ) goto out_unlock ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ipc_valid_object ( & shp -> shm_perm ) ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; } path = shp -> shm_file -> f_path ; path_get ( & path ) ; shp -> shm_nattch ++ ; size = i_size_read ( d_inode ( path . dentry ) ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; err = - ENOMEM ; sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; if ( ! sfd ) { path_put ( & path ) ; goto out_nattch ; } file = alloc_file ( & path , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge : & shm_file_operations ) ; err = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) { kfree ( sfd ) ; path_put ( & path ) ; goto out_nattch ; } file -> private_data = sfd ; file -> f_mapping = shp -> shm_file -> f_mapping ; sfd -> id = shp -> shm_perm . id ; sfd -> ns = get_ipc_ns ( ns ) ; sfd -> file = shp -> shm_file ; sfd -> vm_ops = NULL ; err = security_mmap_file ( file , prot , flags ) ; if ( err ) goto out_fput ; if ( down_write_killable ( & current -> mm -> mmap_sem ) ) { err = - EINTR ; goto out_fput ; } if ( addr && ! ( shmflg & SHM_REMAP ) ) { err = - EINVAL ; if ( addr + size < addr ) goto invalid ; if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) goto invalid ; } addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate , NULL ) ; * raddr = addr ; err = 0 ; if ( IS_ERR_VALUE ( addr ) ) err = ( long ) addr ; invalid : up_write ( & current -> mm -> mmap_sem ) ; if ( populate ) mm_populate ( addr , populate ) ; out_fput : fput ( file ) ; out_nattch : down_write ( & shm_ids ( ns ) . rwsem ) ; shp = shm_lock ( ns , shmid ) ; shp -> shm_nattch -- ; if ( shm_may_destroy ( ns , shp ) ) shm_destroy ( ns , shp ) ; else shm_unlock ( shp ) ; up_write ( & shm_ids ( ns ) . rwsem ) ; return err ; out_unlock : rcu_read_unlock ( ) ; out : return err ; }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , "n:%" PRId64 "<S2SV_blank>pts:%s<S2SV_blank>pts_time:%s<S2SV_blank>pos:%" PRId64 "<S2SV_blank>" "fmt:%s<S2SV_blank>sar:%d/%d<S2SV_blank>s:%dx%d<S2SV_blank>i:%c<S2SV_blank>iskey:%d<S2SV_blank>type:%c<S2SV_blank>" "checksum:%08X<S2SV_blank>plane_checksum:[%08X" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame -> width , frame -> height , ! frame -> interlaced_frame ? 'P' : frame -> top_field_first ? 'T' : 'B' , frame -> key_frame , av_get_picture_type_char ( frame -> pict_type ) , checksum , plane_checksum [ 0 ] ) ; <S2SV_StartBug> for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) <S2SV_EndBug> av_log ( ctx , AV_LOG_INFO , "<S2SV_blank>%08X" , plane_checksum [ plane ] ) ; av_log ( ctx , AV_LOG_INFO , "]\\n" ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , frame ) ; }
CWE-476 jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; <S2SV_StartBug> box -> len = len ; <S2SV_EndBug> if ( box -> len == 1 ) { if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( "warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { <S2SV_StartBug> jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ; <S2SV_EndBug> goto error ; } jas_stream_rewind ( tmpstream ) ; if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( "cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }
CWE-125 static void aodv_extension ( netdissect_options * ndo , const struct aodv_ext * ep , u_int length ) { <S2SV_StartBug> const struct aodv_hello * ah ; <S2SV_EndBug> switch ( ep -> type ) { case AODV_EXT_HELLO : ah = ( const struct aodv_hello * ) ( const void * ) ep ; ND_TCHECK ( * ah ) ; if ( length < sizeof ( struct aodv_hello ) ) <S2SV_StartBug> goto trunc ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>HELLO<S2SV_blank>%ld<S2SV_blank>ms" , ( unsigned long ) EXTRACT_32BITS ( & ah -> interval ) ) ) ; break ; default : ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>%u<S2SV_blank>%u" , ep -> type , ep -> length ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|hello]" ) ) ; }
CWE-284 int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , "WSAStartup<S2SV_blank>failed!\\n" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( "socket()" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( "setsockopt()" ) ; socket_close ( sfd ) ; return - 1 ; } # ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( "setsockopt()" ) ; socket_close ( sfd ) ; return - 1 ; } # endif memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( "bind()" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( "listen()" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
CWE-415 static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) { struct f_midi * midi = func_to_midi ( f ) ; unsigned i ; int err ; if ( intf != midi -> ms_id ) return 0 ; err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; if ( err ) return err ; err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; if ( err ) return err ; while ( kfifo_avail ( & midi -> in_req_fifo ) ) { struct usb_request * req = midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> length = 0 ; req -> complete = f_midi_complete ; kfifo_put ( & midi -> in_req_fifo , req ) ; } for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { struct usb_request * req = midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> complete = f_midi_complete ; err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; if ( err ) { ERROR ( midi , "%s:<S2SV_blank>couldn\'t<S2SV_blank>enqueue<S2SV_blank>request:<S2SV_blank>%d\\n" , midi -> out_ep -> name , err ) ; <S2SV_StartBug> free_ep_req ( midi -> out_ep , req ) ; <S2SV_EndBug> return err ; } } return 0 ; }
CWE-119 static int get_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_rcvctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_GET_REGS , PEGASUS_REQT_READ , 0 , <S2SV_StartBug> indx , data , size , 1000 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , "%s<S2SV_blank>returned<S2SV_blank>%d\\n" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-20 <S2SV_StartBug> int rose_parse_facilities ( unsigned char * p , <S2SV_EndBug> struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; <S2SV_StartBug> if ( facilities_len == 0 ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> while ( facilities_len > 0 ) { <S2SV_EndBug> if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> return 0 ; facilities_len -= len + 1 ; p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> return 0 ; facilities_len -= len + 1 ; p += len + 1 ; <S2SV_StartBug> break ; <S2SV_EndBug> default : printk ( KERN_DEBUG "ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }
CWE-119 static unsigned long vp8_priv_sz ( const vpx_codec_dec_cfg_t * si , vpx_codec_flags_t flags ) { ( void ) si ; <S2SV_StartBug> return sizeof ( vpx_codec_alg_priv_t ) ; <S2SV_EndBug> }
CWE-189 static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; <S2SV_StartBug> int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }
CWE-119 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <S2SV_StartBug> if ( debug ) { <S2SV_EndBug> printk ( KERN_INFO "cx24116:<S2SV_blank>%s(" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO "0x%02x" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO ",<S2SV_blank>" ) ; } printk ( ")<S2SV_blank>toneburst=%d\\n" , toneburst ) ; } <S2SV_StartBug> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <S2SV_EndBug> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( "%s<S2SV_blank>burst=%d\\n" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb ( fe ) ; if ( ret != 0 ) return ret ; msleep ( 100 ) ; ret = cx24116_cmd_execute ( fe , & state -> dsec_cmd ) ; if ( ret != 0 ) return ret ; msleep ( ( state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] << 4 ) + ( ( toneburst == CX24116_DISEQC_TONEOFF ) ? 30 : 60 ) ) ; return 0 ; }
CWE-200 static int dgram_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sk_buff * skb ; struct sockaddr_ieee802154 * saddr ; saddr = ( struct sockaddr_ieee802154 * ) msg -> msg_name ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( saddr ) { saddr -> family = AF_IEEE802154 ; saddr -> addr = mac_cb ( skb ) -> sa ; <S2SV_StartBug> } <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * saddr ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }
CWE-787 static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { # ifndef _MSC_VER char buf [ EXT2_BLOCK_SIZE ( data ) ] ; # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { grub_error ( GRUB_ERR_BAD_FS , "invalid<S2SV_blank>extent" ) ; return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) return 0 ; else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; return fileblock + start ; } } else { grub_error ( GRUB_ERR_BAD_FS , "something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent" ) ; return - 1 ; } } <S2SV_StartBug> if ( fileblock < INDIRECT_BLOCKS ) <S2SV_EndBug> blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; <S2SV_StartBug> else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) <S2SV_EndBug> { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; if ( ! indir ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , 0 , blksz , indir ) ) return grub_errno ; blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , "ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks" ) ; } return blknr ; }
CWE-000 bool_t xdr_krb5_tl_data ( XDR * xdrs , krb5_tl_data * * tl_data_head ) { krb5_tl_data * tl , * tl2 ; bool_t more ; unsigned int len ; switch ( xdrs -> x_op ) { case XDR_FREE : tl = tl2 = * tl_data_head ; while ( tl ) { tl2 = tl -> tl_data_next ; free ( tl -> tl_data_contents ) ; free ( tl ) ; tl = tl2 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case XDR_ENCODE : tl = * tl_data_head ; while ( 1 ) { more = ( tl != NULL ) ; if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( tl == NULL ) break ; if ( ! xdr_krb5_int16 ( xdrs , & tl -> tl_data_type ) ) return FALSE ; len = tl -> tl_data_length ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl = tl -> tl_data_next ; } break ; case XDR_DECODE : tl = NULL ; while ( 1 ) { if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( more == FALSE ) break ; tl2 = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ; if ( tl2 == NULL ) return FALSE ; memset ( tl2 , 0 , sizeof ( krb5_tl_data ) ) ; if ( ! xdr_krb5_int16 ( xdrs , & tl2 -> tl_data_type ) ) return FALSE ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl2 -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl2 -> tl_data_length = len ; tl2 -> tl_data_next = tl ; tl = tl2 ; } * tl_data_head = tl ; break ; } return TRUE ; }
CWE-20 void mk_request_free ( struct session_request * sr ) { if ( sr -> fd_file > 0 ) { <S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> } if ( sr -> headers . location ) { mk_mem_free ( sr -> headers . location ) ; } if ( sr -> uri_processed . data != sr -> uri . data ) { mk_ptr_free ( & sr -> uri_processed ) ; } if ( sr -> real_path . data != sr -> real_path_static ) { mk_ptr_free ( & sr -> real_path ) ; } }
CWE-190 static void php_zip_get_from ( INTERNAL_FUNCTION_PARAMETERS , int type ) { struct zip * intern ; zval * self = getThis ( ) ; struct zip_stat sb ; struct zip_file * zf ; zend_long index = - 1 ; zend_long flags = 0 ; zend_long len = 0 ; zend_string * filename ; zend_string * buffer ; int n = 0 ; if ( ! self ) { RETURN_FALSE ; } ZIP_FROM_OBJECT ( intern , self ) ; if ( type == 1 ) { if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "P|ll" , & filename , & len , & flags ) == FAILURE ) { return ; } PHP_ZIP_STAT_PATH ( intern , ZSTR_VAL ( filename ) , ZSTR_LEN ( filename ) , flags , sb ) ; } else { if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "l|ll" , & index , & len , & flags ) == FAILURE ) { return ; } PHP_ZIP_STAT_INDEX ( intern , index , 0 , sb ) ; } if ( sb . size < 1 ) { RETURN_EMPTY_STRING ( ) ; } if ( len < 1 ) { len = sb . size ; } if ( index >= 0 ) { zf = zip_fopen_index ( intern , index , flags ) ; } else { zf = zip_fopen ( intern , ZSTR_VAL ( filename ) , flags ) ; } if ( zf == NULL ) { RETURN_FALSE ; } <S2SV_StartBug> buffer = zend_string_alloc ( len , 0 ) ; <S2SV_EndBug> n = zip_fread ( zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; if ( n < 1 ) { zend_string_free ( buffer ) ; RETURN_EMPTY_STRING ( ) ; } zip_fclose ( zf ) ; ZSTR_VAL ( buffer ) [ n ] = '\\0' ; ZSTR_LEN ( buffer ) = n ; RETURN_NEW_STR ( buffer ) ; }
CWE-189 static void sample_to_timespec ( const clockid_t which_clock , union cpu_time_count cpu , struct timespec * tp ) { <S2SV_StartBug> if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) { <S2SV_EndBug> <S2SV_StartBug> tp -> tv_sec = div_long_long_rem ( cpu . sched , <S2SV_EndBug> NSEC_PER_SEC , & tp -> tv_nsec ) ; } else { cputime_to_timespec ( cpu . cpu , tp ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-189 Image * AutoResizeImage ( const Image * image , const char * option , MagickOffsetType * count , ExceptionInfo * exception ) { # define MAX_SIZES 16 char * q ; const char * p ; Image * resized , * images ; register ssize_t i ; size_t sizes [ MAX_SIZES ] = { 256 , 192 , 128 , 96 , 64 , 48 , 40 , 32 , 24 , 16 } ; images = NULL ; * count = 0 ; i = 0 ; p = option ; while ( * p != '\\0' && i < MAX_SIZES ) { size_t size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) ) p ++ ; size = ( size_t ) strtol ( p , & q , 10 ) ; <S2SV_StartBug> if ( p == q || size < 16 || size > 256 ) <S2SV_EndBug> return ( ( Image * ) NULL ) ; p = q ; sizes [ i ++ ] = size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) || ( * p == ',' ) ) p ++ ; } if ( i == 0 ) i = 10 ; * count = i ; for ( i = 0 ; i < * count ; i ++ ) { resized = ResizeImage ( image , sizes [ i ] , sizes [ i ] , image -> filter , exception ) ; if ( resized == ( Image * ) NULL ) return ( DestroyImageList ( images ) ) ; if ( images == ( Image * ) NULL ) images = resized ; else AppendImageToList ( & images , resized ) ; } return ( images ) ; }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <S2SV_StartBug> horDiff16 ( tif , cp0 , cc ) ; <S2SV_EndBug> TIFFSwabArrayOfShort ( wp , wc ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 int id3_skip ( SF_PRIVATE * psf ) { unsigned char buf [ 10 ] ; memset ( buf , 0 , sizeof ( buf ) ) ; psf_binheader_readf ( psf , "pb" , 0 , buf , 10 ) ; if ( buf [ 0 ] == 'I' && buf [ 1 ] == 'D' && buf [ 2 ] == '3' ) { int offset = buf [ 6 ] & 0x7f ; offset = ( offset << 7 ) | ( buf [ 7 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 8 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 9 ] & 0x7f ) ; psf_log_printf ( psf , "ID3<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d\\n--------------------\\n" , offset ) ; if ( offset < 0 ) return 0 ; psf -> fileoffset += offset + 10 ; <S2SV_StartBug> psf_binheader_readf ( psf , "p" , psf -> fileoffset ) ; <S2SV_EndBug> return 1 ; } ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-125 <S2SV_StartBug> INST_HANDLER ( sts ) { <S2SV_EndBug> int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; ESIL_A ( "r%d," , r ) ; __generic_ld_st ( op , "ram" , 0 , 1 , 0 , k , 1 ) ; op -> cycles = 2 ; }
CWE-119 static void yuvconfig2image ( vpx_image_t * img , const YV12_BUFFER_CONFIG * yv12 , void * user_priv ) { img -> fmt = VPX_IMG_FMT_I420 ; img -> w = yv12 -> y_stride ; img -> h = ( yv12 -> y_height + 2 * VP8BORDERINPIXELS + 15 ) & ~ 15 ; img -> d_w = yv12 -> y_width ; img -> d_h = yv12 -> y_height ; img -> x_chroma_shift = 1 ; img -> y_chroma_shift = 1 ; img -> planes [ VPX_PLANE_Y ] = yv12 -> y_buffer ; img -> planes [ VPX_PLANE_U ] = yv12 -> u_buffer ; img -> planes [ VPX_PLANE_V ] = yv12 -> v_buffer ; img -> planes [ VPX_PLANE_ALPHA ] = NULL ; img -> stride [ VPX_PLANE_Y ] = yv12 -> y_stride ; img -> stride [ VPX_PLANE_U ] = yv12 -> uv_stride ; img -> stride [ VPX_PLANE_V ] = yv12 -> uv_stride ; img -> stride [ VPX_PLANE_ALPHA ] = yv12 -> y_stride ; <S2SV_StartBug> img -> bps = 12 ; <S2SV_EndBug> img -> user_priv = user_priv ; img -> img_data = yv12 -> buffer_alloc ; img -> img_data_owner = 0 ; img -> self_allocd = 0 ; }
CWE-000 static int create_fixed_stream_quirk ( struct snd_usb_audio * chip , struct usb_interface * iface , struct usb_driver * driver , const struct snd_usb_audio_quirk * quirk ) { struct audioformat * fp ; struct usb_host_interface * alts ; struct usb_interface_descriptor * altsd ; int stream , err ; unsigned * rate_table = NULL ; fp = kmemdup ( quirk -> data , sizeof ( * fp ) , GFP_KERNEL ) ; if ( ! fp ) { usb_audio_err ( chip , "cannot<S2SV_blank>memdup\\n" ) ; return - ENOMEM ; } if ( fp -> nr_rates > MAX_NR_RATES ) { kfree ( fp ) ; return - EINVAL ; } if ( fp -> nr_rates > 0 ) { rate_table = kmemdup ( fp -> rate_table , sizeof ( int ) * fp -> nr_rates , GFP_KERNEL ) ; if ( ! rate_table ) { kfree ( fp ) ; return - ENOMEM ; } fp -> rate_table = rate_table ; } stream = ( fp -> endpoint & USB_DIR_IN ) ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK ; err = snd_usb_add_audio_stream ( chip , stream , fp ) ; if ( err < 0 ) { kfree ( fp ) ; kfree ( rate_table ) ; return err ; } if ( fp -> iface != get_iface_desc ( & iface -> altsetting [ 0 ] ) -> bInterfaceNumber || fp -> altset_idx >= iface -> num_altsetting ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; } alts = & iface -> altsetting [ fp -> altset_idx ] ; altsd = get_iface_desc ( alts ) ; <S2SV_StartBug> fp -> protocol = altsd -> bInterfaceProtocol ; <S2SV_EndBug> if ( fp -> datainterval == 0 ) fp -> datainterval = snd_usb_parse_datainterval ( chip , alts ) ; if ( fp -> maxpacksize == 0 ) fp -> maxpacksize = le16_to_cpu ( get_endpoint ( alts , 0 ) -> wMaxPacketSize ) ; usb_set_interface ( chip -> dev , fp -> iface , 0 ) ; snd_usb_init_pitch ( chip , fp -> iface , alts , fp ) ; snd_usb_init_sample_rate ( chip , fp -> iface , alts , fp , fp -> rate_max ) ; return 0 ; }
CWE-190 int jas_stream_read ( jas_stream_t * stream , void * buf , int cnt ) { int n ; int c ; <S2SV_StartBug> char * bufptr ; <S2SV_EndBug> bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( ( c = jas_stream_getc ( stream ) ) == EOF ) { return n ; } * bufptr ++ = c ; ++ n ; } return n ; }
CWE-20 static void _out_verify ( conn_t out , nad_t nad ) { int attr , ns ; jid_t from , to ; conn_t in ; char * rkey ; int valid ; attr = nad_find_attr ( nad , 0 , - 1 , "from" , NULL ) ; if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , "missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>from<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet" ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , "to" , NULL ) ; if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , "missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>to<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet" ) ; jid_free ( from ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , "id" , NULL ) ; if ( attr < 0 ) { log_debug ( ZONE , "missing<S2SV_blank>id<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet" ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } in = xhash_getx ( out -> s2s -> in , NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ; if ( in == NULL ) { log_debug ( ZONE , "got<S2SV_blank>a<S2SV_blank>verify<S2SV_blank>for<S2SV_blank>incoming<S2SV_blank>conn<S2SV_blank>%.*s,<S2SV_blank>but<S2SV_blank>it<S2SV_blank>doesn\'t<S2SV_blank>exist,<S2SV_blank>dropping<S2SV_blank>the<S2SV_blank>packet" , NAD_AVAL_L ( nad , attr ) , NAD_AVAL ( nad , attr ) ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; attr = nad_find_attr ( nad , 0 , - 1 , "type" , "valid" ) ; <S2SV_StartBug> if ( attr >= 0 ) { <S2SV_EndBug> xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ; log_write ( in -> s2s -> log , LOG_NOTICE , "[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>incoming<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s" , in -> fd -> fd , in -> ip , in -> port , rkey , ( in -> s -> flags & SX_SSL_WRAPPER ) ? ",<S2SV_blank>TLS<S2SV_blank>negotiated" : "" , in -> s -> compressed ? ",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled" : "" ) ; valid = 1 ; } else { log_write ( in -> s2s -> log , LOG_NOTICE , "[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>incoming<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>invalid" , in -> fd -> fd , in -> ip , in -> port , rkey ) ; valid = 0 ; } free ( rkey ) ; nad_free ( nad ) ; -- out -> verify ; nad = nad_new ( ) ; ns = nad_add_namespace ( nad , uri_DIALBACK , "db" ) ; nad_append_elem ( nad , ns , "result" , 0 ) ; nad_append_attr ( nad , - 1 , "to" , from -> domain ) ; nad_append_attr ( nad , - 1 , "from" , to -> domain ) ; nad_append_attr ( nad , - 1 , "type" , valid ? "valid" : "invalid" ) ; sx_nad_write ( in -> s , nad ) ; if ( ! valid ) { sx_error ( in -> s , stream_err_INVALID_ID , "dialback<S2SV_blank>negotiation<S2SV_blank>failed" ) ; sx_close ( in -> s ) ; } jid_free ( from ) ; jid_free ( to ) ; }
CWE-125 static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x03 ) & 0x03 ) ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0xff ) ; * pixels ++ = ( unsigned char ) ( ( pixel & 0x0f ) & 0xff ) ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( unsigned char ) pixel ; break ; } } } continue ; } length ++ ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { <S2SV_StartBug> switch ( depth ) <S2SV_EndBug> { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( * compact_pixels >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( * compact_pixels >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( * compact_pixels >> 6 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 4 ) & 0x03 ; * pixels ++ = ( * compact_pixels >> 2 ) & 0x03 ; * pixels ++ = ( * compact_pixels & 0x03 ) & 0x03 ; break ; } case 4 : { CheckNumberPixels ( 2 ) ; * pixels ++ = ( * compact_pixels >> 4 ) & 0xff ; * pixels ++ = ( * compact_pixels & 0x0f ) & 0xff ; break ; } default : { CheckNumberPixels ( 1 ) ; * pixels ++ = ( * compact_pixels ) ; break ; } } <S2SV_StartBug> CheckNumberCompactPixels ; <S2SV_EndBug> compact_pixels ++ ; } } return ( i ) ; }
CWE-125 void ip6_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { register const struct ip6_hdr * ip6 ; register int advance ; u_int len ; const u_char * ipend ; register const u_char * cp ; register u_int payload_len ; int nh ; int fragmented = 0 ; u_int flow ; ip6 = ( const struct ip6_hdr * ) bp ; ND_TCHECK ( * ip6 ) ; if ( length < sizeof ( struct ip6_hdr ) ) { ND_PRINT ( ( ndo , "truncated-ip6<S2SV_blank>%u" , length ) ) ; return ; } if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "IP6<S2SV_blank>" ) ) ; if ( IP6_VERSION ( ip6 ) != 6 ) { ND_PRINT ( ( ndo , "version<S2SV_blank>error:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>6" , IP6_VERSION ( ip6 ) ) ) ; return ; } payload_len = EXTRACT_16BITS ( & ip6 -> ip6_plen ) ; len = payload_len + sizeof ( struct ip6_hdr ) ; if ( length < len ) ND_PRINT ( ( ndo , "truncated-ip6<S2SV_blank>-<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>missing!" , len - length ) ) ; if ( ndo -> ndo_vflag ) { flow = EXTRACT_32BITS ( & ip6 -> ip6_flow ) ; ND_PRINT ( ( ndo , "(" ) ) ; # if 0 if ( flow & 0x0f000000 ) ND_PRINT ( ( ndo , "pri<S2SV_blank>0x%02x,<S2SV_blank>" , ( flow & 0x0f000000 ) >> 24 ) ) ; if ( flow & 0x00ffffff ) ND_PRINT ( ( ndo , "flowlabel<S2SV_blank>0x%06x,<S2SV_blank>" , flow & 0x00ffffff ) ) ; # else if ( flow & 0x0ff00000 ) ND_PRINT ( ( ndo , "class<S2SV_blank>0x%02x,<S2SV_blank>" , ( flow & 0x0ff00000 ) >> 20 ) ) ; if ( flow & 0x000fffff ) ND_PRINT ( ( ndo , "flowlabel<S2SV_blank>0x%05x,<S2SV_blank>" , flow & 0x000fffff ) ) ; # endif ND_PRINT ( ( ndo , "hlim<S2SV_blank>%u,<S2SV_blank>next-header<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>payload<S2SV_blank>length:<S2SV_blank>%u)<S2SV_blank>" , ip6 -> ip6_hlim , tok2str ( ipproto_values , "unknown" , ip6 -> ip6_nxt ) , ip6 -> ip6_nxt , payload_len ) ) ; } ipend = bp + len ; if ( ipend < ndo -> ndo_snapend ) ndo -> ndo_snapend = ipend ; cp = ( const u_char * ) ip6 ; advance = sizeof ( struct ip6_hdr ) ; nh = ip6 -> ip6_nxt ; while ( cp < ndo -> ndo_snapend && advance > 0 ) { <S2SV_StartBug> cp += advance ; <S2SV_EndBug> len -= advance ; if ( cp == ( const u_char * ) ( ip6 + 1 ) && nh != IPPROTO_TCP && nh != IPPROTO_UDP && nh != IPPROTO_DCCP && nh != IPPROTO_SCTP ) { ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; } switch ( nh ) { case IPPROTO_HOPOPTS : advance = hbhopt_print ( ndo , cp ) ; if ( advance < 0 ) return ; nh = * cp ; break ; case IPPROTO_DSTOPTS : advance = dstopt_print ( ndo , cp ) ; if ( advance < 0 ) return ; nh = * cp ; break ; case IPPROTO_FRAGMENT : advance = frag6_print ( ndo , cp , ( const u_char * ) ip6 ) ; if ( advance < 0 || ndo -> ndo_snapend <= cp + advance ) return ; nh = * cp ; fragmented = 1 ; break ; case IPPROTO_MOBILITY_OLD : case IPPROTO_MOBILITY : advance = mobility_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> return ; case IPPROTO_ROUTING : <S2SV_StartBug> advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ; <S2SV_EndBug> <S2SV_StartBug> nh = * cp ; <S2SV_EndBug> break ; case IPPROTO_SCTP : sctp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; return ; case IPPROTO_DCCP : dccp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; return ; case IPPROTO_TCP : tcp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_UDP : udp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_ICMPV6 : icmp6_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; return ; case IPPROTO_AH : <S2SV_StartBug> advance = ah_print ( ndo , cp ) ; <S2SV_EndBug> nh = * cp ; break ; case IPPROTO_ESP : { int enh , padlen ; advance = esp_print ( ndo , cp , len , ( const u_char * ) ip6 , & enh , & padlen ) ; <S2SV_StartBug> nh = enh & 0xff ; <S2SV_EndBug> len -= padlen ; break ; } case IPPROTO_IPCOMP : { ipcomp_print ( ndo , cp ) ; advance = - 1 ; break ; } case IPPROTO_PIM : pim_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; return ; case IPPROTO_OSPF : ospf6_print ( ndo , cp , len ) ; return ; case IPPROTO_IPV6 : ip6_print ( ndo , cp , len ) ; return ; case IPPROTO_IPV4 : ip_print ( ndo , cp , len ) ; return ; case IPPROTO_PGM : pgm_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; return ; case IPPROTO_GRE : gre_print ( ndo , cp , len ) ; return ; case IPPROTO_RSVP : rsvp_print ( ndo , cp , len ) ; return ; case IPPROTO_NONE : ND_PRINT ( ( ndo , "no<S2SV_blank>next<S2SV_blank>header" ) ) ; return ; default : ND_PRINT ( ( ndo , "ip-proto-%d<S2SV_blank>%d" , nh , len ) ) ; return ; } } return ; trunc : ND_PRINT ( ( ndo , "[|ip6]" ) ) ; }
CWE-000 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { <S2SV_StartBug> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <S2SV_EndBug> return - 1 ; } EVP_MD_CTX_init ( & ctx ) ; if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }
CWE-119 int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( "%s:<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>null!" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = "camera_metadata" , . alignment = METADATA_ALIGNMENT } , { . name = "camera_metadata_buffer_entry" , . alignment = ENTRY_ALIGNMENT } , { . name = "camera_metadata_data" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( "%s:<S2SV_blank>Metadata<S2SV_blank>pointer<S2SV_blank>is<S2SV_blank>not<S2SV_blank>aligned<S2SV_blank>(actual<S2SV_blank>%p,<S2SV_blank>" "expected<S2SV_blank>%p)<S2SV_blank>to<S2SV_blank>type<S2SV_blank>%s" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( "%s:<S2SV_blank>Metadata<S2SV_blank>size<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>expected<S2SV_blank>size<S2SV_blank>(%zu)" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>count<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>entry<S2SV_blank>capacity<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity ) ; return ERROR ; } const metadata_uptrdiff_t entries_end = metadata -> entries_start + metadata -> entry_capacity ; if ( entries_end < metadata -> entries_start || entries_end > metadata -> data_start ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>start<S2SV_blank>+<S2SV_blank>capacity<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>data<S2SV_blank>start<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , ( metadata -> entries_start + metadata -> entry_capacity ) , metadata -> data_start ) ; return ERROR ; } const metadata_uptrdiff_t data_end = metadata -> data_start + metadata -> data_capacity ; if ( data_end < metadata -> data_start || data_end > metadata -> size ) { ALOGE ( "%s:<S2SV_blank>Data<S2SV_blank>start<S2SV_blank>+<S2SV_blank>capacity<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>total<S2SV_blank>size<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , ( metadata -> data_start + metadata -> data_capacity ) , metadata -> size ) ; return ERROR ; } const metadata_size_t entry_count = metadata -> entry_count ; camera_metadata_buffer_entry_t * entries = get_entries ( metadata ) ; for ( size_t i = 0 ; i < entry_count ; ++ i ) { if ( ( uintptr_t ) & entries [ i ] != ALIGN_TO ( & entries [ i ] , ENTRY_ALIGNMENT ) ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>bad<S2SV_blank>alignment<S2SV_blank>(address<S2SV_blank>%p)," "<S2SV_blank>expected<S2SV_blank>alignment<S2SV_blank>%zu" , __FUNCTION__ , i , & entries [ i ] , ENTRY_ALIGNMENT ) ; return ERROR ; } camera_metadata_buffer_entry_t entry = entries [ i ] ; if ( entry . type >= NUM_TYPES ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>a<S2SV_blank>bad<S2SV_blank>type<S2SV_blank>%d" , __FUNCTION__ , i , entry . type ) ; return ERROR ; } uint32_t tag_section = entry . tag >> 16 ; int tag_type = get_camera_metadata_tag_type ( entry . tag ) ; if ( tag_type != ( int ) entry . type && tag_section < VENDOR_SECTION ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>tag<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%d" , __FUNCTION__ , i , tag_type , entry . type ) ; return ERROR ; } <S2SV_StartBug> size_t data_size = <S2SV_EndBug> calculate_camera_metadata_entry_data_size ( entry . type , <S2SV_StartBug> entry . count ) ; <S2SV_EndBug> if ( data_size != 0 ) { camera_metadata_data_t * data = ( camera_metadata_data_t * ) ( get_data ( metadata ) + entry . data . offset ) ; if ( ( uintptr_t ) data != ALIGN_TO ( data , DATA_ALIGNMENT ) ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>bad<S2SV_blank>data<S2SV_blank>alignment<S2SV_blank>(address<S2SV_blank>%p)," "<S2SV_blank>expected<S2SV_blank>align<S2SV_blank>%zu,<S2SV_blank>(tag<S2SV_blank>name<S2SV_blank>%s,<S2SV_blank>data<S2SV_blank>size<S2SV_blank>%zu)" , __FUNCTION__ , i , data , DATA_ALIGNMENT , get_camera_metadata_tag_name ( entry . tag ) ? : "unknown" , data_size ) ; return ERROR ; } size_t data_entry_end = entry . data . offset + data_size ; if ( data_entry_end < entry . data . offset || data_entry_end > metadata -> data_capacity ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>(%zu)<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>capacity<S2SV_blank>" "%" PRIu32 , __FUNCTION__ , i , data_entry_end , metadata -> data_capacity ) ; return ERROR ; } } else if ( entry . count == 0 ) { if ( entry . data . offset != 0 ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>0<S2SV_blank>items,<S2SV_blank>but<S2SV_blank>offset<S2SV_blank>was<S2SV_blank>non-0<S2SV_blank>" "(%" PRIu32 "),<S2SV_blank>tag<S2SV_blank>name:<S2SV_blank>%s" , __FUNCTION__ , i , entry . data . offset , get_camera_metadata_tag_name ( entry . tag ) ? : "unknown" ) ; return ERROR ; } } } return OK ; }
CWE-119 static int complete_emulated_mmio ( struct kvm_vcpu * vcpu ) { struct kvm_run * run = vcpu -> run ; struct kvm_mmio_fragment * frag ; unsigned len ; BUG_ON ( ! vcpu -> mmio_needed ) ; frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ; len = min ( 8u , frag -> len ) ; if ( ! vcpu -> mmio_is_write ) memcpy ( frag -> data , run -> mmio . data , len ) ; if ( frag -> len <= 8 ) { frag ++ ; vcpu -> mmio_cur_fragment ++ ; } else { frag -> data += len ; frag -> gpa += len ; frag -> len -= len ; } <S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug> vcpu -> mmio_needed = 0 ; if ( vcpu -> mmio_is_write ) return 1 ; vcpu -> mmio_read_completed = 1 ; return complete_emulated_io ( vcpu ) ; } run -> exit_reason = KVM_EXIT_MMIO ; run -> mmio . phys_addr = frag -> gpa ; if ( vcpu -> mmio_is_write ) memcpy ( run -> mmio . data , frag -> data , min ( 8u , frag -> len ) ) ; run -> mmio . len = min ( 8u , frag -> len ) ; run -> mmio . is_write = vcpu -> mmio_is_write ; vcpu -> arch . complete_userspace_io = complete_emulated_mmio ; return 0 ; }
CWE-399 static int unmap_ref_private ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * page , unsigned long address ) { struct hstate * h = hstate_vma ( vma ) ; struct vm_area_struct * iter_vma ; struct address_space * mapping ; struct prio_tree_iter iter ; pgoff_t pgoff ; address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ; <S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> mutex_lock ( & mapping -> i_mmap_mutex ) ; vma_prio_tree_foreach ( iter_vma , & iter , & mapping -> i_mmap , pgoff , pgoff ) { if ( iter_vma == vma ) continue ; if ( ! is_vma_resv_set ( iter_vma , HPAGE_RESV_OWNER ) ) __unmap_hugepage_range ( iter_vma , address , address + huge_page_size ( h ) , page ) ; } mutex_unlock ( & mapping -> i_mmap_mutex ) ; return 1 ; }
CWE-399 int kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( "SSH2_MSG_KEXINIT<S2SV_blank>received" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ; <S2SV_StartBug> ptr = sshpkt_ptr ( ssh , & dlen ) ; <S2SV_EndBug> if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex -> kex [ kex -> kex_type ] ) ( ssh ) ; return SSH_ERR_INTERNAL_ERROR ; }
CWE-000 PS_SERIALIZER_DECODE_FUNC ( php ) { const char * p , * q ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ; <S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> p = val ; while ( p < endptr ) { zval * * tmp ; <S2SV_StartBug> q = p ; <S2SV_EndBug> while ( * q != PS_DELIMITER ) { if ( ++ q >= endptr ) goto break_outer_loop ; } if ( p [ 0 ] == PS_UNDEF_MARKER ) { p ++ ; has_value = 0 ; } else { has_value = 1 ; } namelen = q - p ; name = estrndup ( p , namelen ) ; q ++ ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) { <S2SV_StartBug> goto skip ; <S2SV_EndBug> } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & q , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) { <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> } else { var_push_dtor_no_addref ( & var_hash , & current ) ; efree ( name ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; } <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> skip : efree ( name ) ; p = q ; } break_outer_loop : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }
CWE-190 static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) { struct iso9660 * iso9660 ; struct isoent * np ; unsigned char * p ; size_t l ; int r ; <S2SV_StartBug> int ffmax , parent_len ; <S2SV_EndBug> static const struct archive_rb_tree_ops rb_ops = { isoent_cmp_node_joliet , isoent_cmp_key_joliet } ; if ( isoent -> children . cnt == 0 ) return ( 0 ) ; iso9660 = a -> format_data ; if ( iso9660 -> opt . joliet == OPT_JOLIET_LONGNAME ) ffmax = 206 ; else ffmax = 128 ; <S2SV_StartBug> r = idr_start ( a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ; <S2SV_EndBug> if ( r < 0 ) return ( r ) ; parent_len = 1 ; for ( np = isoent ; np -> parent != np ; np = np -> parent ) parent_len += np -> mb_len + 1 ; for ( np = isoent -> children . first ; np != NULL ; np = np -> chnext ) { unsigned char * dot ; int ext_off , noff , weight ; size_t lt ; <S2SV_StartBug> if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) <S2SV_EndBug> l = ffmax ; p = malloc ( ( l + 1 ) * 2 ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ENOMEM , "Can\'t<S2SV_blank>allocate<S2SV_blank>memory" ) ; return ( ARCHIVE_FATAL ) ; } memcpy ( p , np -> file -> basename_utf16 . s , l ) ; p [ l ] = 0 ; p [ l + 1 ] = 0 ; np -> identifier = ( char * ) p ; lt = l ; dot = p + l ; weight = 0 ; while ( lt > 0 ) { if ( ! joliet_allowed_char ( p [ 0 ] , p [ 1 ] ) ) archive_be16enc ( p , 0x005F ) ; else if ( p [ 0 ] == 0 && p [ 1 ] == 0x2E ) dot = p ; p += 2 ; lt -= 2 ; } ext_off = ( int ) ( dot - ( unsigned char * ) np -> identifier ) ; np -> ext_off = ext_off ; np -> ext_len = ( int ) l - ext_off ; np -> id_len = ( int ) l ; <S2SV_StartBug> if ( ( int ) np -> file -> basename_utf16 . length > ffmax ) { <S2SV_EndBug> if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) { archive_set_error ( & a -> archive , errno , "No<S2SV_blank>memory" ) ; return ( ARCHIVE_FATAL ) ; } np -> mb_len = ( int ) iso9660 -> mbs . length ; if ( np -> mb_len != ( int ) np -> file -> basename . length ) weight = np -> mb_len ; } else np -> mb_len = ( int ) np -> file -> basename . length ; <S2SV_StartBug> if ( parent_len + np -> mb_len > 240 ) { <S2SV_EndBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "The<S2SV_blank>regulation<S2SV_blank>of<S2SV_blank>Joliet<S2SV_blank>extensions;" "<S2SV_blank>A<S2SV_blank>length<S2SV_blank>of<S2SV_blank>a<S2SV_blank>full-pathname<S2SV_blank>of<S2SV_blank>`%s\'<S2SV_blank>is<S2SV_blank>" "longer<S2SV_blank>than<S2SV_blank>240<S2SV_blank>bytes,<S2SV_blank>(p=%d,<S2SV_blank>b=%d)" , archive_entry_pathname ( np -> file -> entry ) , ( int ) parent_len , ( int ) np -> mb_len ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_StartBug> if ( ( int ) l == ffmax ) <S2SV_EndBug> noff = ext_off - 6 ; <S2SV_StartBug> else if ( ( int ) l == ffmax - 2 ) <S2SV_EndBug> noff = ext_off - 4 ; <S2SV_StartBug> else if ( ( int ) l == ffmax - 4 ) <S2SV_EndBug> noff = ext_off - 2 ; else noff = ext_off ; idr_register ( idr , np , weight , noff ) ; } idr_resolve ( idr , idr_set_num_beutf16 ) ; return ( ARCHIVE_OK ) ; }
CWE-20 void sctp_association_free ( struct sctp_association * asoc ) { struct sock * sk = asoc -> base . sk ; struct sctp_transport * transport ; struct list_head * pos , * temp ; int i ; <S2SV_StartBug> if ( ! asoc -> temp ) { <S2SV_EndBug> list_del ( & asoc -> asocs ) ; if ( sctp_style ( sk , TCP ) && sctp_sstate ( sk , LISTENING ) ) sk -> sk_ack_backlog -- ; } asoc -> base . dead = true ; sctp_outq_free ( & asoc -> outqueue ) ; sctp_ulpq_free ( & asoc -> ulpq ) ; sctp_inq_free ( & asoc -> base . inqueue ) ; sctp_tsnmap_free ( & asoc -> peer . tsn_map ) ; sctp_ssnmap_free ( asoc -> ssnmap ) ; sctp_bind_addr_free ( & asoc -> base . bind_addr ) ; for ( i = SCTP_EVENT_TIMEOUT_NONE ; i < SCTP_NUM_TIMEOUT_TYPES ; ++ i ) { if ( del_timer ( & asoc -> timers [ i ] ) ) sctp_association_put ( asoc ) ; } kfree ( asoc -> peer . cookie ) ; kfree ( asoc -> peer . peer_random ) ; kfree ( asoc -> peer . peer_chunks ) ; kfree ( asoc -> peer . peer_hmacs ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { transport = list_entry ( pos , struct sctp_transport , transports ) ; list_del_rcu ( pos ) ; sctp_transport_free ( transport ) ; } asoc -> peer . transport_count = 0 ; sctp_asconf_queue_teardown ( asoc ) ; if ( asoc -> asconf_addr_del_pending != NULL ) kfree ( asoc -> asconf_addr_del_pending ) ; sctp_auth_destroy_keys ( & asoc -> endpoint_shared_keys ) ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_association_put ( asoc ) ; }
CWE-264 <S2SV_StartBug> int xmkstemp ( char * * tmpname , char * dir ) <S2SV_EndBug> { char * localtmp ; <S2SV_StartBug> char * tmpenv ; <S2SV_EndBug> mode_t old_mode ; int fd , rc ; <S2SV_StartBug> if ( dir != NULL ) <S2SV_EndBug> <S2SV_StartBug> tmpenv = dir ; <S2SV_EndBug> else tmpenv = getenv ( "TMPDIR" ) ; <S2SV_StartBug> if ( tmpenv ) <S2SV_EndBug> rc = asprintf ( & localtmp , "%s/%s.XXXXXX" , tmpenv , <S2SV_StartBug> program_invocation_short_name ) ; <S2SV_EndBug> else rc = asprintf ( & localtmp , "%s/%s.XXXXXX" , _PATH_TMP , program_invocation_short_name ) ; if ( rc < 0 ) return - 1 ; old_mode = umask ( 077 ) ; fd = mkostemp ( localtmp , O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC ) ; umask ( old_mode ) ; if ( fd == - 1 ) { free ( localtmp ) ; localtmp = NULL ; } * tmpname = localtmp ; return fd ; }
CWE-119 void vp8_pick_intra_mode ( MACROBLOCK * x , int * rate_ ) { int error4x4 , error16x16 = INT_MAX ; int rate , best_rate = 0 , distortion , best_sse ; MB_PREDICTION_MODE mode , best_mode = DC_PRED ; int this_rd ; unsigned int sse ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; xd -> mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; pick_intra_mbuv_mode ( x ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { xd -> mode_info_context -> mbmi . mode = mode ; vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; <S2SV_StartBug> distortion = vp8_variance16x16 <S2SV_EndBug> ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ; rate = x -> mbmode_cost [ xd -> frame_type ] [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( error16x16 > this_rd ) { error16x16 = this_rd ; best_mode = mode ; best_sse = sse ; best_rate = rate ; } } xd -> mode_info_context -> mbmi . mode = best_mode ; error4x4 = pick_intra4x4mby_modes ( x , & rate , & best_sse ) ; if ( error4x4 < error16x16 ) { xd -> mode_info_context -> mbmi . mode = B_PRED ; best_rate = rate ; } * rate_ = best_rate ; }
CWE-000 <S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> { int rc ; int saveerrno = errno ; struct stat dsb ; mode_t mode = rpmfiFMode ( fi ) ; rc = fsmStat ( path , 1 , & dsb ) ; if ( rc ) return rc ; if ( S_ISREG ( mode ) ) { char * rmpath = rstrscat ( NULL , path , "-RPMDELETE" , NULL ) ; rc = fsmRename ( path , rmpath ) ; if ( ! rc ) ( void ) fsmUnlink ( rmpath ) ; else rc = RPMERR_UNLINK_FAILED ; free ( rmpath ) ; return ( rc ? rc : RPMERR_ENOENT ) ; } else if ( S_ISDIR ( mode ) ) { if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; if ( S_ISLNK ( dsb . st_mode ) ) { <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> if ( rc == RPMERR_ENOENT ) rc = 0 ; if ( rc ) return rc ; errno = saveerrno ; <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug> } } else if ( S_ISLNK ( mode ) ) { if ( S_ISLNK ( dsb . st_mode ) ) { char buf [ 8 * BUFSIZ ] ; size_t len ; rc = fsmReadLink ( path , buf , 8 * BUFSIZ , & len ) ; errno = saveerrno ; if ( rc ) return rc ; if ( rstreq ( rpmfiFLink ( fi ) , buf ) ) return 0 ; } } else if ( S_ISFIFO ( mode ) ) { if ( S_ISFIFO ( dsb . st_mode ) ) return 0 ; } else if ( S_ISCHR ( mode ) || S_ISBLK ( mode ) ) { if ( ( S_ISCHR ( dsb . st_mode ) || S_ISBLK ( dsb . st_mode ) ) && ( dsb . st_rdev == rpmfiFRdev ( fi ) ) ) return 0 ; } else if ( S_ISSOCK ( mode ) ) { if ( S_ISSOCK ( dsb . st_mode ) ) return 0 ; } rc = fsmUnlink ( path ) ; if ( rc == 0 ) rc = RPMERR_ENOENT ; return ( rc ? rc : RPMERR_ENOENT ) ; }
CWE-119 GPLOT * gplotCreate ( const char * rootname , l_int32 outformat , const char * title , const char * xlabel , const char * ylabel ) { char * newroot ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 badchar ; GPLOT * gplot ; PROCNAME ( "gplotCreate" ) ; if ( ! rootname ) return ( GPLOT * ) ERROR_PTR ( "rootname<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( outformat != GPLOT_PNG && outformat != GPLOT_PS && outformat != GPLOT_EPS && outformat != GPLOT_LATEX ) return ( GPLOT * ) ERROR_PTR ( "outformat<S2SV_blank>invalid" , procName , NULL ) ; stringCheckForChars ( rootname , "`;&|><\\"?*" , & badchar ) ; if ( badchar ) return ( GPLOT * ) ERROR_PTR ( "invalid<S2SV_blank>rootname" , procName , NULL ) ; if ( ( gplot = ( GPLOT * ) LEPT_CALLOC ( 1 , sizeof ( GPLOT ) ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( "gplot<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; gplot -> cmddata = sarrayCreate ( 0 ) ; gplot -> datanames = sarrayCreate ( 0 ) ; gplot -> plotdata = sarrayCreate ( 0 ) ; gplot -> plottitles = sarrayCreate ( 0 ) ; gplot -> plotstyles = numaCreate ( 0 ) ; newroot = genPathname ( rootname , NULL ) ; gplot -> rootname = newroot ; gplot -> outformat = outformat ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.cmd" , rootname ) ; <S2SV_EndBug> gplot -> cmdname = stringNew ( buf ) ; if ( outformat == GPLOT_PNG ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.png" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_PS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.ps" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_EPS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.eps" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_LATEX ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "%s.tex" , newroot ) ; <S2SV_EndBug> gplot -> outname = stringNew ( buf ) ; if ( title ) gplot -> title = stringNew ( title ) ; if ( xlabel ) gplot -> xlabel = stringNew ( xlabel ) ; if ( ylabel ) gplot -> ylabel = stringNew ( ylabel ) ; return gplot ; }
CWE-119 static int __videobuf_mmap_mapper ( struct videobuf_queue * q , struct vm_area_struct * vma ) { struct videbuf_vmalloc_memory * mem ; struct videobuf_mapping * map ; unsigned int first ; int retval ; unsigned long offset = vma -> vm_pgoff << PAGE_SHIFT ; if ( ! ( vma -> vm_flags & VM_WRITE ) || ! ( vma -> vm_flags & VM_SHARED ) ) return - EINVAL ; for ( first = 0 ; first < VIDEO_MAX_FRAME ; first ++ ) { if ( NULL == q -> bufs [ first ] ) continue ; if ( V4L2_MEMORY_MMAP != q -> bufs [ first ] -> memory ) continue ; if ( q -> bufs [ first ] -> boff == offset ) break ; } if ( VIDEO_MAX_FRAME == first ) { dprintk ( 1 , "mmap<S2SV_blank>app<S2SV_blank>bug:<S2SV_blank>offset<S2SV_blank>invalid<S2SV_blank>[offset=0x%lx]\\n" , ( vma -> vm_pgoff << PAGE_SHIFT ) ) ; return - EINVAL ; } <S2SV_StartBug> map = q -> bufs [ first ] -> map = kmalloc ( sizeof ( struct videobuf_mapping ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( NULL == map ) return - ENOMEM ; map -> start = vma -> vm_start ; map -> end = vma -> vm_end ; map -> q = q ; q -> bufs [ first ] -> baddr = vma -> vm_start ; vma -> vm_ops = & videobuf_vm_ops ; vma -> vm_flags |= VM_DONTEXPAND | VM_RESERVED ; vma -> vm_private_data = map ; mem = q -> bufs [ first ] -> priv ; BUG_ON ( ! mem ) ; MAGIC_CHECK ( mem -> magic , MAGIC_VMAL_MEM ) ; retval = remap_vmalloc_range ( vma , mem -> vmalloc , 0 ) ; if ( retval < 0 ) { dprintk ( 1 , "mmap:<S2SV_blank>postponing<S2SV_blank>remap_vmalloc_range\\n" ) ; mem -> vma = kmalloc ( sizeof ( * vma ) , GFP_KERNEL ) ; if ( ! mem -> vma ) { kfree ( map ) ; q -> bufs [ first ] -> map = NULL ; return - ENOMEM ; } memcpy ( mem -> vma , vma , sizeof ( * vma ) ) ; } dprintk ( 1 , "mmap<S2SV_blank>%p:<S2SV_blank>q=%p<S2SV_blank>%08lx-%08lx<S2SV_blank>(%lx)<S2SV_blank>pgoff<S2SV_blank>%08lx<S2SV_blank>buf<S2SV_blank>%d\\n" , map , q , vma -> vm_start , vma -> vm_end , ( long int ) q -> bufs [ first ] -> bsize , vma -> vm_pgoff , first ) ; videobuf_vm_open ( vma ) ; return ( 0 ) ; }
CWE-200 static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , "%s()\\n" , __func__ ) ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , <S2SV_EndBug> flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , "%s(),<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>frame<S2SV_blank>(%zd<S2SV_blank><<S2SV_blank>%zd)!\\n" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , "%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\n" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }
CWE-399 static int sctp_process_param ( struct sctp_association * asoc , union sctp_params param , const union sctp_addr * peer_addr , gfp_t gfp ) { struct net * net = sock_net ( asoc -> base . sk ) ; union sctp_addr addr ; int i ; __u16 sat ; int retval = 1 ; sctp_scope_t scope ; time_t stale ; struct sctp_af * af ; union sctp_addr_param * addr_param ; struct sctp_transport * t ; struct sctp_endpoint * ep = asoc -> ep ; switch ( param . p -> type ) { case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 != asoc -> base . sk -> sk_family ) break ; goto do_addr_param ; case SCTP_PARAM_IPV4_ADDRESS : if ( ipv6_only_sock ( asoc -> base . sk ) ) break ; do_addr_param : af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; af -> from_addr_param ( & addr , param . addr , htons ( asoc -> peer . port ) , 0 ) ; scope = sctp_scope ( peer_addr ) ; if ( sctp_in_scope ( net , & addr , scope ) ) if ( ! sctp_assoc_add_peer ( asoc , & addr , gfp , SCTP_UNCONFIRMED ) ) return 0 ; break ; case SCTP_PARAM_COOKIE_PRESERVATIVE : if ( ! net -> sctp . cookie_preserve_enable ) break ; stale = ntohl ( param . life -> lifespan_increment ) ; asoc -> cookie_life = ktime_add_ms ( asoc -> cookie_life , stale ) ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : pr_debug ( "%s:<S2SV_blank>unimplemented<S2SV_blank>SCTP_HOST_NAME_ADDRESS\\n" , __func__ ) ; break ; case SCTP_PARAM_SUPPORTED_ADDRESS_TYPES : asoc -> peer . ipv4_address = 0 ; asoc -> peer . ipv6_address = 0 ; if ( peer_addr -> sa . sa_family == AF_INET6 ) asoc -> peer . ipv6_address = 1 ; else if ( peer_addr -> sa . sa_family == AF_INET ) asoc -> peer . ipv4_address = 1 ; sat = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; if ( sat ) sat /= sizeof ( __u16 ) ; for ( i = 0 ; i < sat ; ++ i ) { switch ( param . sat -> types [ i ] ) { case SCTP_PARAM_IPV4_ADDRESS : asoc -> peer . ipv4_address = 1 ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 == asoc -> base . sk -> sk_family ) asoc -> peer . ipv6_address = 1 ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : asoc -> peer . hostname_address = 1 ; break ; default : break ; } } break ; case SCTP_PARAM_STATE_COOKIE : asoc -> peer . cookie_len = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; asoc -> peer . cookie = param . cookie -> body ; break ; case SCTP_PARAM_HEARTBEAT_INFO : break ; case SCTP_PARAM_UNRECOGNIZED_PARAMETERS : break ; case SCTP_PARAM_ECN_CAPABLE : asoc -> peer . ecn_capable = 1 ; break ; case SCTP_PARAM_ADAPTATION_LAYER_IND : asoc -> peer . adaptation_ind = ntohl ( param . aind -> adaptation_ind ) ; break ; case SCTP_PARAM_SET_PRIMARY : if ( ! net -> sctp . addip_enable ) goto fall_through ; addr_param = param . v + sizeof ( sctp_addip_param_t ) ; af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; <S2SV_StartBug> af -> from_addr_param ( & addr , addr_param , <S2SV_EndBug> htons ( asoc -> peer . port ) , 0 ) ; if ( ! af -> addr_valid ( & addr , NULL , NULL ) ) break ; t = sctp_assoc_lookup_paddr ( asoc , & addr ) ; if ( ! t ) break ; sctp_assoc_set_primary ( asoc , t ) ; break ; case SCTP_PARAM_SUPPORTED_EXT : sctp_process_ext_param ( asoc , param ) ; break ; case SCTP_PARAM_FWD_TSN_SUPPORT : if ( net -> sctp . prsctp_enable ) { asoc -> peer . prsctp_capable = 1 ; break ; } goto fall_through ; case SCTP_PARAM_RANDOM : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_random = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_random ) { retval = 0 ; break ; } break ; case SCTP_PARAM_HMAC_ALGO : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_hmacs = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_hmacs ) { retval = 0 ; break ; } sctp_auth_asoc_set_default_hmac ( asoc , param . hmac_algo ) ; break ; case SCTP_PARAM_CHUNKS : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_chunks = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_chunks ) retval = 0 ; break ; fall_through : default : pr_debug ( "%s:<S2SV_blank>ignoring<S2SV_blank>param:%d<S2SV_blank>for<S2SV_blank>association:%p.\\n" , __func__ , ntohs ( param . p -> type ) , asoc ) ; break ; } return retval ; }
CWE-399 static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; } <S2SV_StartBug> while ( offset < end_offset ) <S2SV_EndBug> offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ; <S2SV_StartBug> return offset ; <S2SV_EndBug> }
CWE-125 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { "invalid" , "rsasig" , "shared-secret" , "dsssig" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%u<S2SV_blank>method=%s" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>authdata=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , ")<S2SV_blank>" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( tpay ) ) ) ; return NULL ; }
CWE-416 PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; <S2SV_StartBug> zval * options = NULL , * classes = NULL ; <S2SV_EndBug> HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "s|a" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , "allowed_classes" , sizeof ( "allowed_classes" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } <S2SV_StartBug> if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { <S2SV_EndBug> PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } <S2SV_StartBug> zval_ptr_dtor ( return_value ) ; <S2SV_EndBug> if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , "Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>" ZEND_LONG_FMT "<S2SV_blank>of<S2SV_blank>%zd<S2SV_blank>bytes" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } <S2SV_StartBug> var_push_dtor ( & var_hash , return_value ) ; <S2SV_EndBug> PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
CWE-476 static bool check_client_passwd ( PgSocket * client , const char * passwd ) { char md5 [ MD5_PASSWD_LEN + 1 ] ; const char * correct ; PgUser * user = client -> auth_user ; <S2SV_StartBug> if ( ! * passwd || ! * user -> passwd ) <S2SV_EndBug> return false ; switch ( cf_auth_type ) { case AUTH_PLAIN : return strcmp ( user -> passwd , passwd ) == 0 ; case AUTH_CRYPT : correct = crypt ( user -> passwd , ( char * ) client -> tmp_login_salt ) ; return correct && strcmp ( correct , passwd ) == 0 ; case AUTH_MD5 : if ( strlen ( passwd ) != MD5_PASSWD_LEN ) return false ; if ( ! isMD5 ( user -> passwd ) ) pg_md5_encrypt ( user -> passwd , user -> name , strlen ( user -> name ) , user -> passwd ) ; pg_md5_encrypt ( user -> passwd + 3 , ( char * ) client -> tmp_login_salt , 4 , md5 ) ; return strcmp ( md5 , passwd ) == 0 ; } return false ; }
CWE-119 static void copy_and_extend_plane ( const uint8_t * src , int src_pitch , uint8_t * dst , int dst_pitch , int w , int h , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i , linesize ; const uint8_t * src_ptr1 = src ; const uint8_t * src_ptr2 = src + w - 1 ; uint8_t * dst_ptr1 = dst - extend_left ; uint8_t * dst_ptr2 = dst + w ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; <S2SV_EndBug> vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; src_ptr1 += src_pitch ; src_ptr2 += src_pitch ; dst_ptr1 += dst_pitch ; dst_ptr2 += dst_pitch ; } src_ptr1 = dst - extend_left ; src_ptr2 = dst + dst_pitch * ( h - 1 ) - extend_left ; dst_ptr1 = dst + dst_pitch * ( - extend_top ) - extend_left ; dst_ptr2 = dst + dst_pitch * ( h ) - extend_left ; linesize = extend_left + extend_right + w ; for ( i = 0 ; i < extend_top ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> dst_ptr1 += dst_pitch ; } for ( i = 0 ; i < extend_bottom ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> dst_ptr2 += dst_pitch ; } }
CWE-125 u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , "IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "seq<S2SV_blank>%02x<S2SV_blank>" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_StartBug> ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug> p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "<<S2SV_blank>" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }
CWE-20 static int sctp_getsockopt_assoc_stats ( struct sock * sk , int len , char __user * optval , int __user * optlen ) { struct sctp_assoc_stats sas ; struct sctp_association * asoc = NULL ; if ( len < sizeof ( sctp_assoc_t ) ) return - EINVAL ; <S2SV_StartBug> if ( copy_from_user ( & sas , optval , len ) ) <S2SV_EndBug> return - EFAULT ; asoc = sctp_id2assoc ( sk , sas . sas_assoc_id ) ; if ( ! asoc ) return - EINVAL ; sas . sas_rtxchunks = asoc -> stats . rtxchunks ; sas . sas_gapcnt = asoc -> stats . gapcnt ; sas . sas_outofseqtsns = asoc -> stats . outofseqtsns ; sas . sas_osacks = asoc -> stats . osacks ; sas . sas_isacks = asoc -> stats . isacks ; sas . sas_octrlchunks = asoc -> stats . octrlchunks ; sas . sas_ictrlchunks = asoc -> stats . ictrlchunks ; sas . sas_oodchunks = asoc -> stats . oodchunks ; sas . sas_iodchunks = asoc -> stats . iodchunks ; sas . sas_ouodchunks = asoc -> stats . ouodchunks ; sas . sas_iuodchunks = asoc -> stats . iuodchunks ; sas . sas_idupchunks = asoc -> stats . idupchunks ; sas . sas_opackets = asoc -> stats . opackets ; sas . sas_ipackets = asoc -> stats . ipackets ; sas . sas_maxrto = asoc -> stats . max_obs_rto ; memcpy ( & sas . sas_obs_rto_ipaddr , & asoc -> stats . obs_rto_ipaddr , sizeof ( struct sockaddr_storage ) ) ; asoc -> stats . max_obs_rto = asoc -> rto_min ; <S2SV_StartBug> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_EndBug> if ( put_user ( len , optlen ) ) return - EFAULT ; SCTP_DEBUG_PRINTK ( "sctp_getsockopt_assoc_stat(%d):<S2SV_blank>%d\\n" , len , sas . sas_assoc_id ) ; if ( copy_to_user ( optval , & sas , len ) ) return - EFAULT ; return 0 ; }
CWE-20 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header ) { case 'R' : case 'r' : { if ( LocaleNCompare ( header , "rdensty:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu" , & density ) ; break ; } if ( LocaleNCompare ( header , "rpelcnt:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu,%lu" , & width , & height ) ; break ; } if ( LocaleNCompare ( header , "rorient:" , 8 ) == 0 ) { ( void ) sscanf ( header + 8 , "%lu,%lu" , & pel_path , & direction ) ; if ( pel_path == 90 ) orientation = 5 ; else if ( pel_path == 180 ) orientation = 3 ; else if ( pel_path == 270 ) orientation = 7 ; if ( direction == 90 ) orientation ++ ; break ; } if ( LocaleNCompare ( header , "rtype:" , 6 ) == 0 ) { ( void ) sscanf ( header + 6 , "%lu" , & type ) ; break ; } break ; } } } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) ThrowImageException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; while ( ( c = ReadBlobByte ( image ) ) != EOF ) <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> ( void ) fclose ( file ) ; ( void ) CloseBlob ( image ) ; image = DestroyImage ( image ) ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "group4:%s" , filename ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , "%lux%lu" , width , height ) ; ( void ) CloneString ( & read_info -> size , message ) ; ( void ) FormatLocaleString ( message , MagickPathExtent , "%lu" , density ) ; ( void ) CloneString ( & read_info -> density , message ) ; read_info -> orientation = ( OrientationType ) orientation ; image = ReadImage ( read_info , exception ) ; if ( image != ( Image * ) NULL ) { ( void ) CopyMagickString ( image -> filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , MagickPathExtent ) ; ( void ) CopyMagickString ( image -> magick , "CALS" , MagickPathExtent ) ; } read_info = DestroyImageInfo ( read_info ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; return ( image ) ; }
CWE-200 void iov_iter_pipe ( struct iov_iter * i , int direction , struct pipe_inode_info * pipe , size_t count ) { <S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug> i -> type = direction ; i -> pipe = pipe ; i -> idx = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ; i -> iov_offset = 0 ; i -> count = count ; }
CWE-000 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { <S2SV_StartBug> bool disconnect ; <S2SV_EndBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; <S2SV_StartBug> __touch_mnt_namespace ( p -> mnt_ns ) ; <S2SV_EndBug> p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; disconnect = disconnect_mount ( p , how ) ; pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , MS_PRIVATE ) ; } }
CWE-119 bool extract_sockaddr ( struct pool * pool , char * url ) { char * url_begin , * url_end , * ipv6_begin , * ipv6_end , * port_start = NULL ; char url_address [ 256 ] , port [ 6 ] ; int url_len , port_len = 0 ; url_begin = strstr ( url , "//" ) ; if ( ! url_begin ) url_begin = url ; else url_begin += 2 ; ipv6_begin = strstr ( url_begin , "[" ) ; ipv6_end = strstr ( url_begin , "]" ) ; if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin ) url_end = strstr ( ipv6_end , ":" ) ; else url_end = strstr ( url_begin , ":" ) ; if ( url_end ) { url_len = url_end - url_begin ; port_len = strlen ( url_begin ) - url_len - 1 ; if ( port_len < 1 ) return false ; port_start = url_end + 1 ; } else url_len = strlen ( url_begin ) ; if ( url_len < 1 ) return false ; <S2SV_StartBug> sprintf ( url_address , "%.*s" , url_len , url_begin ) ; <S2SV_EndBug> if ( port_len ) snprintf ( port , 6 , "%.*s" , port_len , port_start ) ; else strcpy ( port , "80" ) ; free ( pool -> stratum_port ) ; pool -> stratum_port = strdup ( port ) ; free ( pool -> sockaddr_url ) ; pool -> sockaddr_url = strdup ( url_address ) ; return true ; }
CWE-200 static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) { <S2SV_StartBug> struct usbdevfs_connectinfo ci = { <S2SV_EndBug> <S2SV_StartBug> . devnum = ps -> dev -> devnum , <S2SV_EndBug> . slow = ps -> dev -> speed == USB_SPEED_LOW <S2SV_StartBug> } ; <S2SV_EndBug> if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ; return 0 ; }
CWE-119 static void write_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end ) { <S2SV_EndBug> <S2SV_StartBug> int mi_row , mi_col ; <S2SV_EndBug> for ( mi_row = tile -> mi_row_start ; mi_row < tile -> mi_row_end ; mi_row += MI_BLOCK_SIZE ) { <S2SV_StartBug> vp9_zero ( cpi -> mb . e_mbd . left_seg_context ) ; <S2SV_EndBug> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col , BLOCK_64X64 ) ; } }
CWE-399 static int rds_ib_laddr_check ( __be32 addr ) { int ret ; struct rdma_cm_id * cm_id ; struct sockaddr_in sin ; cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ) ; if ( IS_ERR ( cm_id ) ) return PTR_ERR ( cm_id ) ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = addr ; ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ) ; <S2SV_StartBug> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <S2SV_EndBug> ret = - EADDRNOTAVAIL ; rdsdebug ( "addr<S2SV_blank>%pI4<S2SV_blank>ret<S2SV_blank>%d<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d\\n" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ) ; rdma_destroy_id ( cm_id ) ; return ret ; }
CWE-284 static bool msr_mtrr_valid ( unsigned msr ) { switch ( msr ) { case 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1 : case MSR_MTRRfix64K_00000 : case MSR_MTRRfix16K_80000 : case MSR_MTRRfix16K_A0000 : case MSR_MTRRfix4K_C0000 : case MSR_MTRRfix4K_C8000 : case MSR_MTRRfix4K_D0000 : case MSR_MTRRfix4K_D8000 : case MSR_MTRRfix4K_E0000 : case MSR_MTRRfix4K_E8000 : case MSR_MTRRfix4K_F0000 : case MSR_MTRRfix4K_F8000 : case MSR_MTRRdefType : case MSR_IA32_CR_PAT : return true ; <S2SV_StartBug> case 0x2f8 : <S2SV_EndBug> return true ; } return false ; }
CWE-264 int perf_pmu_register ( struct pmu * pmu , const char * name , int type ) { int cpu , ret ; mutex_lock ( & pmus_lock ) ; ret = - ENOMEM ; pmu -> pmu_disable_count = alloc_percpu ( int ) ; if ( ! pmu -> pmu_disable_count ) goto unlock ; pmu -> type = - 1 ; if ( ! name ) goto skip_type ; pmu -> name = name ; if ( type < 0 ) { type = idr_alloc ( & pmu_idr , pmu , PERF_TYPE_MAX , 0 , GFP_KERNEL ) ; if ( type < 0 ) { ret = type ; goto free_pdc ; } } pmu -> type = type ; if ( pmu_bus_running ) { ret = pmu_dev_alloc ( pmu ) ; if ( ret ) goto free_idr ; } skip_type : pmu -> pmu_cpu_context = find_pmu_context ( pmu -> task_ctx_nr ) ; if ( pmu -> pmu_cpu_context ) goto got_cpu_context ; ret = - ENOMEM ; pmu -> pmu_cpu_context = alloc_percpu ( struct perf_cpu_context ) ; if ( ! pmu -> pmu_cpu_context ) goto free_dev ; for_each_possible_cpu ( cpu ) { struct perf_cpu_context * cpuctx ; cpuctx = per_cpu_ptr ( pmu -> pmu_cpu_context , cpu ) ; __perf_event_init_context ( & cpuctx -> ctx ) ; lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ; lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ; <S2SV_StartBug> cpuctx -> ctx . type = cpu_context ; <S2SV_EndBug> cpuctx -> ctx . pmu = pmu ; __perf_cpu_hrtimer_init ( cpuctx , cpu ) ; INIT_LIST_HEAD ( & cpuctx -> rotation_list ) ; cpuctx -> unique_pmu = pmu ; } got_cpu_context : if ( ! pmu -> start_txn ) { if ( pmu -> pmu_enable ) { pmu -> start_txn = perf_pmu_start_txn ; pmu -> commit_txn = perf_pmu_commit_txn ; pmu -> cancel_txn = perf_pmu_cancel_txn ; } else { pmu -> start_txn = perf_pmu_nop_void ; pmu -> commit_txn = perf_pmu_nop_int ; pmu -> cancel_txn = perf_pmu_nop_void ; } } if ( ! pmu -> pmu_enable ) { pmu -> pmu_enable = perf_pmu_nop_void ; pmu -> pmu_disable = perf_pmu_nop_void ; } if ( ! pmu -> event_idx ) pmu -> event_idx = perf_event_idx_default ; list_add_rcu ( & pmu -> entry , & pmus ) ; ret = 0 ; unlock : mutex_unlock ( & pmus_lock ) ; return ret ; free_dev : device_del ( pmu -> dev ) ; put_device ( pmu -> dev ) ; free_idr : if ( pmu -> type >= PERF_TYPE_MAX ) idr_remove ( & pmu_idr , pmu -> type ) ; free_pdc : free_percpu ( pmu -> pmu_disable_count ) ; goto unlock ; }
CWE-264 int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { <S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> }
CWE-119 vpx_codec_err_t vpx_codec_enc_init_multi_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , int num_enc , vpx_codec_flags_t flags , vpx_rational_t * dsf , int ver ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg || ( num_enc > 16 || num_enc < 1 ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { int i ; void * mem_loc = NULL ; if ( ! ( res = iface -> enc . mr_get_mem_loc ( cfg , & mem_loc ) ) ) { for ( i = 0 ; i < num_enc ; i ++ ) { vpx_codec_priv_enc_mr_cfg_t mr_cfg ; if ( dsf -> num < 1 || dsf -> num > 4096 || dsf -> den < 1 || dsf -> den > dsf -> num ) { res = VPX_CODEC_INVALID_PARAM ; break ; } mr_cfg . mr_low_res_mode_info = mem_loc ; mr_cfg . mr_total_resolutions = num_enc ; mr_cfg . mr_encoder_id = num_enc - 1 - i ; mr_cfg . mr_down_sampling_factor . num = dsf -> num ; mr_cfg . mr_down_sampling_factor . den = dsf -> den ; if ( mr_cfg . mr_encoder_id ) cfg -> kf_mode = VPX_KF_DISABLED ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , & mr_cfg ) ; if ( res ) { const char * error_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; while ( i ) { ctx -- ; ctx -> err_detail = error_detail ; vpx_codec_destroy ( ctx ) ; i -- ; } } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; if ( res ) break ; ctx ++ ; cfg ++ ; dsf ++ ; } ctx -- ; } } return SAVE_STATUS ( ctx , res ) ; }
CWE-20 static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; <S2SV_StartBug> int res , ret ; <S2SV_EndBug> if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }
CWE-000 static char * __filterQuotedShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { switch ( * arg ) { case '<S2SV_blank>' : case '=' : <S2SV_StartBug> case '\\r' : <S2SV_EndBug> case '\\n' : break ; default : * b ++ = * arg ; break ; } arg ++ ; } * b = 0 ; return a ; }
CWE-200 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }
CWE-20 static void dissect_pktap ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * pktap_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint32 pkt_len , rectype , dlt ; <S2SV_StartBug> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "PKTAP" ) ; <S2SV_EndBug> col_clear ( pinfo -> cinfo , COL_INFO ) ; pkt_len = tvb_get_letohl ( tvb , offset ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , "PKTAP,<S2SV_blank>%u<S2SV_blank>byte<S2SV_blank>header" , pkt_len ) ; ti = proto_tree_add_item ( tree , proto_pktap , tvb , offset , pkt_len , ENC_NA ) ; pktap_tree = proto_item_add_subtree ( ti , ett_pktap ) ; proto_tree_add_item ( pktap_tree , hf_pktap_hdrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; if ( pkt_len < MIN_PKTAP_HDR_LEN ) { proto_tree_add_expert ( tree , pinfo , & ei_pktap_hdrlen_too_short , tvb , offset , 4 ) ; return ; } offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_rectype , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; rectype = tvb_get_letohl ( tvb , offset ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_dlt , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; dlt = tvb_get_letohl ( tvb , offset ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_ifname , tvb , offset , 24 , ENC_ASCII | ENC_NA ) ; offset += 24 ; proto_tree_add_item ( pktap_tree , hf_pktap_flags , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_pfamily , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_llhdrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_lltrlrlen , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_pid , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_cmdname , tvb , offset , 20 , ENC_UTF_8 | ENC_NA ) ; offset += 20 ; proto_tree_add_item ( pktap_tree , hf_pktap_svc_class , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_iftype , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; proto_tree_add_item ( pktap_tree , hf_pktap_ifunit , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; proto_tree_add_item ( pktap_tree , hf_pktap_epid , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( pktap_tree , hf_pktap_ecmdname , tvb , offset , 20 , ENC_UTF_8 | ENC_NA ) ; if ( rectype == PKT_REC_PACKET ) { next_tvb = tvb_new_subset_remaining ( tvb , pkt_len ) ; <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , <S2SV_EndBug> <S2SV_StartBug> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; <S2SV_EndBug> } }
CWE-416 static void smp_task_timedout ( struct timer_list * t ) { struct sas_task_slow * slow = from_timer ( slow , t , timer ) ; struct sas_task * task = slow -> task ; unsigned long flags ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; <S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; complete ( & task -> slow_task -> completion ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 void * vpx_realloc ( void * memblk , size_t size ) { void * addr , * new_addr = NULL ; int align = DEFAULT_ALIGNMENT ; if ( ! memblk ) new_addr = vpx_malloc ( size ) ; else if ( ! size ) vpx_free ( memblk ) ; else { addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ; memblk = NULL ; <S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> new_addr = vpx_mm_realloc ( addr , size + align + ADDRESS_STORAGE_SIZE ) ; <S2SV_StartBug> # else <S2SV_EndBug> new_addr = VPX_REALLOC_L ( addr , size + align + ADDRESS_STORAGE_SIZE ) ; # endif if ( new_addr ) { addr = new_addr ; new_addr = ( void * ) ( ( ( size_t ) ( ( unsigned char * ) new_addr + ADDRESS_STORAGE_SIZE ) + ( align - 1 ) ) & ( size_t ) - align ) ; ( ( size_t * ) new_addr ) [ - 1 ] = ( size_t ) addr ; } } return new_addr ; }
CWE-000 static gboolean side_in_cb ( GSocket * socket , GIOCondition condition , gpointer user_data ) { ProxySide * side = user_data ; FlatpakProxyClient * client = side -> client ; GError * error = NULL ; Buffer * buffer ; gboolean retval = G_SOURCE_CONTINUE ; g_object_ref ( client ) ; while ( ! side -> closed ) { if ( ! side -> got_first_byte ) buffer = buffer_new ( 1 , NULL ) ; else if ( ! client -> authenticated ) buffer = buffer_new ( 64 , NULL ) ; else buffer = side -> current_read_buffer ; if ( ! buffer_read ( side , buffer , socket ) ) { if ( buffer != side -> current_read_buffer ) buffer_unref ( buffer ) ; break ; } if ( ! client -> authenticated ) { if ( buffer -> pos > 0 ) { gboolean found_auth_end = FALSE ; gsize extra_data ; buffer -> size = buffer -> pos ; if ( ! side -> got_first_byte ) { buffer -> send_credentials = TRUE ; side -> got_first_byte = TRUE ; } else if ( side == & client -> client_side ) { gssize auth_end = find_auth_end ( client , buffer ) ; if ( auth_end >= 0 ) { found_auth_end = TRUE ; buffer -> size = auth_end ; extra_data = buffer -> pos - buffer -> size ; if ( extra_data > 0 ) side -> extra_input_data = g_bytes_new ( buffer -> data + buffer -> size , extra_data ) ; } <S2SV_StartBug> } <S2SV_EndBug> got_buffer_from_side ( side , buffer ) ; if ( found_auth_end ) client -> authenticated = TRUE ; } else { buffer_unref ( buffer ) ; } } else if ( buffer -> pos == buffer -> size ) { if ( buffer == & side -> header_buffer ) { gssize required ; required = g_dbus_message_bytes_needed ( buffer -> data , buffer -> size , & error ) ; if ( required < 0 ) { g_warning ( "Invalid<S2SV_blank>message<S2SV_blank>header<S2SV_blank>read" ) ; side_closed ( side ) ; } else { side -> current_read_buffer = buffer_new ( required , buffer ) ; } } else { got_buffer_from_side ( side , buffer ) ; side -> header_buffer . pos = 0 ; side -> current_read_buffer = & side -> header_buffer ; } } } if ( side -> closed ) { side -> in_source = NULL ; retval = G_SOURCE_REMOVE ; } g_object_unref ( client ) ; return retval ; }
CWE-362 static int faultin_page ( struct task_struct * tsk , struct vm_area_struct * vma , unsigned long address , unsigned int * flags , int * nonblocking ) { unsigned int fault_flags = 0 ; int ret ; if ( ( * flags & ( FOLL_POPULATE | FOLL_MLOCK ) ) == FOLL_MLOCK ) return - ENOENT ; if ( ( * flags & FOLL_POPULATE ) && ( stack_guard_page_start ( vma , address ) || stack_guard_page_end ( vma , address + PAGE_SIZE ) ) ) return - ENOENT ; if ( * flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( * flags & FOLL_REMOTE ) fault_flags |= FAULT_FLAG_REMOTE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( * flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( * flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = handle_mm_fault ( vma , address , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { if ( ret & VM_FAULT_OOM ) return - ENOMEM ; if ( ret & ( VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE ) ) return * flags & FOLL_HWPOISON ? - EHWPOISON : - EFAULT ; if ( ret & ( VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV ) ) return - EFAULT ; BUG ( ) ; } if ( tsk ) { if ( ret & VM_FAULT_MAJOR ) tsk -> maj_flt ++ ; else tsk -> min_flt ++ ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking ) * nonblocking = 0 ; return - EBUSY ; } if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) <S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug> return 0 ; }
CWE-119 static void videobuf_vm_close ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; struct videobuf_queue * q = map -> q ; int i ; <S2SV_StartBug> dprintk ( 2 , "vm_close<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n" , map , <S2SV_EndBug> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count -- ; if ( 0 == map -> count ) { dprintk ( 1 , "munmap<S2SV_blank>%p<S2SV_blank>q=%p\\n" , map , q ) ; mutex_lock ( & q -> lock ) ; for ( i = 0 ; i < VIDEO_MAX_FRAME ; i ++ ) { if ( NULL == q -> bufs [ i ] ) continue ; if ( q -> bufs [ i ] -> map != map ) continue ; q -> ops -> buf_release ( q , q -> bufs [ i ] ) ; q -> bufs [ i ] -> map = NULL ; q -> bufs [ i ] -> baddr = 0 ; } mutex_unlock ( & q -> lock ) ; kfree ( map ) ; } return ; }
CWE-119 int process ( register int code , unsigned char * * fill ) { int incode ; static unsigned char firstchar ; if ( code == clear ) { codesize = datasize + 1 ; codemask = ( 1 << codesize ) - 1 ; avail = clear + 2 ; oldcode = - 1 ; return 1 ; } if ( oldcode == - 1 ) { <S2SV_StartBug> * ( * fill ) ++ = suffix [ code ] ; <S2SV_EndBug> firstchar = oldcode = code ; return 1 ; } if ( code > avail ) { fprintf ( stderr , "code<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>%d\\n" , code , avail ) ; return 0 ; } incode = code ; if ( code == avail ) { * stackp ++ = firstchar ; code = oldcode ; } while ( code > clear ) { * stackp ++ = suffix [ code ] ; code = prefix [ code ] ; } * stackp ++ = firstchar = suffix [ code ] ; prefix [ avail ] = oldcode ; suffix [ avail ] = firstchar ; avail ++ ; if ( ( ( avail & codemask ) == 0 ) && ( avail < 4096 ) ) { codesize ++ ; codemask += avail ; } oldcode = incode ; do { * ( * fill ) ++ = * -- stackp ; } while ( stackp > stack ) ; return 1 ; }
CWE-119 void vp9_end_first_pass ( VP9_COMP * cpi ) { <S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> int i ; for ( i = 0 ; i < cpi -> svc . number_spatial_layers ; ++ i ) { output_stats ( & cpi -> svc . layer_context [ i ] . twopass . total_stats , cpi -> output_pkt_list ) ; } } else { output_stats ( & cpi -> twopass . total_stats , cpi -> output_pkt_list ) ; } }
CWE-476 <S2SV_StartBug> static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type , <S2SV_EndBug> u32 * mask ) { struct crypto_attr_type * algt ; algt = crypto_get_attr_type ( tb ) ; if ( IS_ERR ( algt ) ) <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> * type |= CRYPTO_ALG_INTERNAL ; <S2SV_StartBug> if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> * mask |= CRYPTO_ALG_INTERNAL ; }
CWE-125 u_int fr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { int ret ; uint16_t extracted_ethertype ; u_int dlci ; u_int addr_len ; uint16_t nlpid ; u_int hdr_len ; uint8_t flags [ 4 ] ; ret = parse_q922_addr ( ndo , p , & dlci , & addr_len , flags , length ) ; if ( ret == - 1 ) goto trunc ; if ( ret == 0 ) { ND_PRINT ( ( ndo , "Q.922,<S2SV_blank>invalid<S2SV_blank>address" ) ) ; return 0 ; } ND_TCHECK ( p [ addr_len ] ) ; if ( length < addr_len + 1 ) goto trunc ; if ( p [ addr_len ] != LLC_UI && dlci != 0 ) { if ( ! ND_TTEST2 ( p [ addr_len ] , 2 ) || length < addr_len + 2 ) { ND_PRINT ( ( ndo , "UI<S2SV_blank>%02x!<S2SV_blank>" , p [ addr_len ] ) ) ; } else { extracted_ethertype = EXTRACT_16BITS ( p + addr_len ) ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , extracted_ethertype ) ; if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , "UI<S2SV_blank>%02x!<S2SV_blank>" , p [ addr_len ] ) ) ; else return addr_len + 2 ; } } ND_TCHECK ( p [ addr_len + 1 ] ) ; if ( length < addr_len + 2 ) goto trunc ; if ( p [ addr_len + 1 ] == 0 ) { if ( addr_len != 3 ) ND_PRINT ( ( ndo , "Pad!<S2SV_blank>" ) ) ; hdr_len = addr_len + 1 + 1 + 1 ; } else { if ( addr_len == 3 ) ND_PRINT ( ( ndo , "No<S2SV_blank>pad!<S2SV_blank>" ) ) ; hdr_len = addr_len + 1 + 1 ; } ND_TCHECK ( p [ hdr_len - 1 ] ) ; if ( length < hdr_len ) goto trunc ; nlpid = p [ hdr_len - 1 ] ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , nlpid ) ; p += hdr_len ; length -= hdr_len ; switch ( nlpid ) { case NLPID_IP : ip_print ( ndo , p , length ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p , length ) ; break ; case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS : <S2SV_StartBug> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <S2SV_EndBug> break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p , NULL , NULL , 0 ) == 0 ) { if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , hdr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p - hdr_len , length + hdr_len ) ; } break ; case NLPID_Q933 : q933_print ( ndo , p , length ) ; break ; case NLPID_MFR : frf15_print ( ndo , p , length ) ; break ; case NLPID_PPP : ppp_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , addr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_xflag ) ND_DEFAULTPRINT ( p , length ) ; } return hdr_len ; trunc : ND_PRINT ( ( ndo , "[|fr]" ) ) ; return 0 ; }
CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" <S2SV_EndBug> "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-284 static bool write_hci_command ( hci_packet_t type , const void * packet , size_t length ) { int sock = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( sock == INVALID_FD ) goto error ; struct sockaddr_in addr ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = htonl ( 0x7F000001 ) ; addr . sin_port = htons ( 8873 ) ; <S2SV_StartBug> if ( connect ( sock , ( const struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) <S2SV_EndBug> goto error ; <S2SV_StartBug> if ( send ( sock , & type , 1 , 0 ) != 1 ) <S2SV_EndBug> goto error ; <S2SV_StartBug> if ( send ( sock , & length , 2 , 0 ) != 2 ) <S2SV_EndBug> goto error ; <S2SV_StartBug> if ( send ( sock , packet , length , 0 ) != ( ssize_t ) length ) <S2SV_EndBug> goto error ; close ( sock ) ; return true ; error : ; close ( sock ) ; return false ; }
CWE-119 static void build_masks ( const loop_filter_info_n * const lfi_n , const MODE_INFO * mi , const int shift_y , const int shift_uv , LOOP_FILTER_MASK * lfm ) { const MB_MODE_INFO * mbmi = & mi -> mbmi ; const BLOCK_SIZE block_size = mbmi -> sb_type ; const TX_SIZE tx_size_y = mbmi -> tx_size ; <S2SV_StartBug> const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> const int filter_level = get_filter_level ( lfi_n , mbmi ) ; uint64_t * const left_y = & lfm -> left_y [ tx_size_y ] ; uint64_t * const above_y = & lfm -> above_y [ tx_size_y ] ; uint64_t * const int_4x4_y = & lfm -> int_4x4_y ; uint16_t * const left_uv = & lfm -> left_uv [ tx_size_uv ] ; uint16_t * const above_uv = & lfm -> above_uv [ tx_size_uv ] ; uint16_t * const int_4x4_uv = & lfm -> int_4x4_uv ; int i ; if ( ! filter_level ) { return ; } else { const int w = num_8x8_blocks_wide_lookup [ block_size ] ; const int h = num_8x8_blocks_high_lookup [ block_size ] ; int index = shift_y ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; <S2SV_EndBug> index += 8 ; } } * above_y |= above_prediction_mask [ block_size ] << shift_y ; * above_uv |= above_prediction_mask_uv [ block_size ] << shift_uv ; * left_y |= left_prediction_mask [ block_size ] << shift_y ; * left_uv |= left_prediction_mask_uv [ block_size ] << shift_uv ; if ( mbmi -> skip && is_inter_block ( mbmi ) ) return ; * above_y |= ( size_mask [ block_size ] & above_64x64_txform_mask [ tx_size_y ] ) << shift_y ; * above_uv |= ( size_mask_uv [ block_size ] & above_64x64_txform_mask_uv [ tx_size_uv ] ) << shift_uv ; * left_y |= ( size_mask [ block_size ] & left_64x64_txform_mask [ tx_size_y ] ) << shift_y ; * left_uv |= ( size_mask_uv [ block_size ] & left_64x64_txform_mask_uv [ tx_size_uv ] ) << shift_uv ; if ( tx_size_y == TX_4X4 ) <S2SV_StartBug> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ; <S2SV_EndBug> if ( tx_size_uv == TX_4X4 ) * int_4x4_uv |= ( size_mask_uv [ block_size ] & 0xffff ) << shift_uv ; }
CWE-476 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , "forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { <S2SV_StartBug> * low = p - reg -> dmax ; <S2SV_EndBug> if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , <S2SV_StartBug> ( pprev ? pprev : str ) , * low ) ; <S2SV_EndBug> } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , "forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
CWE-000 <S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> { static const char quote [ ] = "\\"\\\\" ; char * pt = dest ; const char * s = src ; * pt ++ = \'"\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'"\' ; * pt = '\\0' ; }
CWE-119 void unix_notinflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
CWE-416 long follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , unsigned long * nr_pages , long i , unsigned int flags , int * nonblocking ) { unsigned long pfn_offset ; unsigned long vaddr = * position ; unsigned long remainder = * nr_pages ; struct hstate * h = hstate_vma ( vma ) ; int err = - EFAULT ; while ( vaddr < vma -> vm_end && remainder ) { pte_t * pte ; spinlock_t * ptl = NULL ; int absent ; struct page * page ; if ( fatal_signal_pending ( current ) ) { remainder = 0 ; break ; } pte = huge_pte_offset ( mm , vaddr & huge_page_mask ( h ) , huge_page_size ( h ) ) ; if ( pte ) ptl = huge_pte_lock ( h , mm , pte ) ; absent = ! pte || huge_pte_none ( huge_ptep_get ( pte ) ) ; if ( absent && ( flags & FOLL_DUMP ) && ! hugetlbfs_pagecache_present ( h , vma , vaddr ) ) { if ( pte ) spin_unlock ( ptl ) ; remainder = 0 ; break ; } if ( absent || is_swap_pte ( huge_ptep_get ( pte ) ) || ( ( flags & FOLL_WRITE ) && ! huge_pte_write ( huge_ptep_get ( pte ) ) ) ) { vm_fault_t ret ; unsigned int fault_flags = 0 ; if ( pte ) spin_unlock ( ptl ) ; if ( flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = hugetlb_fault ( mm , vma , vaddr , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { err = vm_fault_to_errno ( ret , flags ) ; remainder = 0 ; break ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking && ! ( fault_flags & FAULT_FLAG_RETRY_NOWAIT ) ) * nonblocking = 0 ; * nr_pages = 0 ; return i ; } continue ; } pfn_offset = ( vaddr & ~ huge_page_mask ( h ) ) >> PAGE_SHIFT ; page = pte_page ( huge_ptep_get ( pte ) ) ; <S2SV_StartBug> same_page : <S2SV_EndBug> if ( pages ) { pages [ i ] = mem_map_offset ( page , pfn_offset ) ; get_page ( pages [ i ] ) ; } if ( vmas ) vmas [ i ] = vma ; vaddr += PAGE_SIZE ; ++ pfn_offset ; -- remainder ; ++ i ; if ( vaddr < vma -> vm_end && remainder && pfn_offset < pages_per_huge_page ( h ) ) { goto same_page ; } spin_unlock ( ptl ) ; } * nr_pages = remainder ; * position = vaddr ; return i ? i : err ; }
CWE-000 static void cmd_parse_lsub ( struct ImapData * idata , char * s ) { char buf [ STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct Url url ; struct ImapList list ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_LIST ) { cmd_parse_list ( idata , s ) ; return ; } if ( ! ImapCheckSubscribed ) return ; idata -> cmdtype = IMAP_CT_LIST ; idata -> cmddata = & list ; cmd_parse_list ( idata , s ) ; idata -> cmddata = NULL ; if ( ! list . name || list . noselect ) return ; mutt_debug ( 3 , "Subscribing<S2SV_blank>to<S2SV_blank>%s\\n" , list . name ) ; mutt_str_strfcpy ( buf , "mailboxes<S2SV_blank>\\"" , sizeof ( buf ) ) ; mutt_account_tourl ( & idata -> conn -> account , & url ) ; <S2SV_StartBug> imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; <S2SV_EndBug> url . path = errstr + 1 ; url . path [ strlen ( url . path ) - 1 ] = '\\0' ; if ( mutt_str_strcmp ( url . user , ImapUser ) == 0 ) url . user = NULL ; url_tostring ( & url , buf + 11 , sizeof ( buf ) - 11 , 0 ) ; mutt_str_strcat ( buf , sizeof ( buf ) , "\\"" ) ; mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; if ( mutt_parse_rc_line ( buf , & token , & err ) ) mutt_debug ( 1 , "Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n" , errstr ) ; FREE ( & token . data ) ; }
CWE-476 void ipv4_pktinfo_prepare ( const struct sock * sk , struct sk_buff * skb ) { struct in_pktinfo * pktinfo = PKTINFO_SKB_CB ( skb ) ; bool prepare = ( inet_sk ( sk ) -> cmsg_flags & IP_CMSG_PKTINFO ) || ipv6_sk_rxinfo ( sk ) ; if ( prepare && skb_rtable ( skb ) ) { if ( pktinfo -> ipi_ifindex == LOOPBACK_IFINDEX ) pktinfo -> ipi_ifindex = inet_iif ( skb ) ; pktinfo -> ipi_spec_dst . s_addr = fib_compute_spec_dst ( skb ) ; } else { pktinfo -> ipi_ifindex = 0 ; pktinfo -> ipi_spec_dst . s_addr = 0 ; } <S2SV_StartBug> skb_dst_drop ( skb ) ; <S2SV_EndBug> }
CWE-399 <S2SV_StartBug> void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ; attr = bp -> attr ; attr . disabled = true ; modify_user_hw_breakpoint ( bp , & attr ) ; }
CWE-264 static int persistent_prepare_exception ( struct dm_exception_store * store , struct dm_exception * e ) { <S2SV_StartBug> struct pstore * ps = get_info ( store ) ; <S2SV_EndBug> uint32_t stride ; chunk_t next_free ; sector_t size = get_dev_size ( dm_snap_cow ( store -> snap ) -> bdev ) ; if ( size < ( ( ps -> next_free + 1 ) * store -> chunk_size ) ) return - ENOSPC ; e -> new_chunk = ps -> next_free ; <S2SV_StartBug> stride = ( ps -> exceptions_per_area + 1 ) ; <S2SV_EndBug> next_free = ++ ps -> next_free ; if ( sector_div ( next_free , stride ) == 1 ) <S2SV_StartBug> ps -> next_free ++ ; <S2SV_EndBug> atomic_inc ( & ps -> pending_count ) ; return 0 ; }
CWE-20 int dns_packet_is_reply_for ( DnsPacket * p , const DnsResourceKey * key ) { int r ; assert ( p ) ; assert ( key ) ; if ( DNS_PACKET_QR ( p ) != 1 ) return 0 ; r = dns_packet_extract ( p ) ; if ( r < 0 ) return r ; <S2SV_StartBug> if ( p -> question -> n_keys != 1 ) <S2SV_EndBug> return 0 ; return dns_resource_key_equal ( p -> question -> keys [ 0 ] , key ) ; }
CWE-000 static int install_thread_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> BUG_ON ( new -> thread_keyring ) ; ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; return ret ; } return commit_creds ( new ) ; }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; BoxBlurContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int plane ; int cw = FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) , ch = FF_CEIL_RSHIFT ( in -> height , s -> vsub ) ; int w [ 4 ] = { inlink -> w , cw , cw , inlink -> w } ; int h [ 4 ] = { in -> height , ch , ch , in -> height } ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ; <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ; av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
CWE-000 static VALUE ossl_cipher_pkcs5_keyivgen ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; const EVP_MD * digest ; VALUE vpass , vsalt , viter , vdigest ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , iv [ EVP_MAX_IV_LENGTH ] , * salt = NULL ; int iter ; rb_scan_args ( argc , argv , "13" , & vpass , & vsalt , & viter , & vdigest ) ; StringValue ( vpass ) ; if ( ! NIL_P ( vsalt ) ) { StringValue ( vsalt ) ; if ( RSTRING_LEN ( vsalt ) != PKCS5_SALT_LEN ) ossl_raise ( eCipherError , "salt<S2SV_blank>must<S2SV_blank>be<S2SV_blank>an<S2SV_blank>8-octet<S2SV_blank>string" ) ; salt = ( unsigned char * ) RSTRING_PTR ( vsalt ) ; } iter = NIL_P ( viter ) ? 2048 : NUM2INT ( viter ) ; digest = NIL_P ( vdigest ) ? EVP_md5 ( ) : GetDigestPtr ( vdigest ) ; GetCipher ( self , ctx ) ; EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , digest , salt , ( unsigned char * ) RSTRING_PTR ( vpass ) , RSTRING_LENINT ( vpass ) , iter , key , iv ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , key , iv , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; OPENSSL_cleanse ( key , sizeof key ) ; OPENSSL_cleanse ( iv , sizeof iv ) ; <S2SV_StartBug> return Qnil ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static int cost_segmap ( int * segcounts , vp9_prob * probs ) { <S2SV_EndBug> const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ; const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ; const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ; const int c0123 = c01 + c23 ; const int c4567 = c45 + c67 ; int cost = c0123 * vp9_cost_zero ( probs [ 0 ] ) + c4567 * vp9_cost_one ( probs [ 0 ] ) ; if ( c0123 > 0 ) { cost += c01 * vp9_cost_zero ( probs [ 1 ] ) + c23 * vp9_cost_one ( probs [ 1 ] ) ; if ( c01 > 0 ) cost += segcounts [ 0 ] * vp9_cost_zero ( probs [ 3 ] ) + segcounts [ 1 ] * vp9_cost_one ( probs [ 3 ] ) ; if ( c23 > 0 ) cost += segcounts [ 2 ] * vp9_cost_zero ( probs [ 4 ] ) + segcounts [ 3 ] * vp9_cost_one ( probs [ 4 ] ) ; } if ( c4567 > 0 ) { cost += c45 * vp9_cost_zero ( probs [ 2 ] ) + c67 * vp9_cost_one ( probs [ 2 ] ) ; if ( c45 > 0 ) cost += segcounts [ 4 ] * vp9_cost_zero ( probs [ 5 ] ) + segcounts [ 5 ] * vp9_cost_one ( probs [ 5 ] ) ; if ( c67 > 0 ) cost += segcounts [ 6 ] * vp9_cost_zero ( probs [ 6 ] ) + segcounts [ 7 ] * vp9_cost_one ( probs [ 6 ] ) ; } return cost ; }
CWE-20 static int proc_sys_readdir ( struct file * file , struct dir_context * ctx ) { struct ctl_table_header * head = grab_header ( file_inode ( file ) ) ; struct ctl_table_header * h = NULL ; struct ctl_table * entry ; struct ctl_dir * ctl_dir ; unsigned long pos ; if ( IS_ERR ( head ) ) return PTR_ERR ( head ) ; ctl_dir = container_of ( head , struct ctl_dir , header ) ; if ( ! dir_emit_dots ( file , ctx ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pos = 2 ; for ( first_entry ( ctl_dir , & h , & entry ) ; h ; next_entry ( & h , & entry ) ) { if ( ! scan ( h , entry , & pos , file , ctx ) ) { sysctl_head_finish ( h ) ; break ; } } <S2SV_StartBug> sysctl_head_finish ( head ) ; <S2SV_EndBug> return 0 ; }
CWE-415 static int amd_gpio_probe ( struct platform_device * pdev ) { int ret = 0 ; int irq_base ; struct resource * res ; struct amd_gpio * gpio_dev ; gpio_dev = devm_kzalloc ( & pdev -> dev , sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; if ( ! gpio_dev ) return - ENOMEM ; spin_lock_init ( & gpio_dev -> lock ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>io<S2SV_blank>resource.\\n" ) ; return - EINVAL ; } gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , resource_size ( res ) ) ; if ( ! gpio_dev -> base ) return - ENOMEM ; irq_base = platform_get_irq ( pdev , 0 ) ; if ( irq_base < 0 ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>IRQ.\\n" ) ; return - EINVAL ; } gpio_dev -> pdev = pdev ; gpio_dev -> gc . direction_input = amd_gpio_direction_input ; gpio_dev -> gc . direction_output = amd_gpio_direction_output ; gpio_dev -> gc . get = amd_gpio_get_value ; gpio_dev -> gc . set = amd_gpio_set_value ; gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; gpio_dev -> gc . base = 0 ; gpio_dev -> gc . label = pdev -> name ; gpio_dev -> gc . owner = THIS_MODULE ; gpio_dev -> gc . parent = & pdev -> dev ; gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS ; # if defined ( CONFIG_OF_GPIO ) gpio_dev -> gc . of_node = pdev -> dev . of_node ; # endif gpio_dev -> groups = kerncz_groups ; gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; <S2SV_StartBug> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <S2SV_EndBug> <S2SV_StartBug> & pdev -> dev , gpio_dev ) ; <S2SV_EndBug> if ( IS_ERR ( gpio_dev -> pctrl ) ) { dev_err ( & pdev -> dev , "Couldn\'t<S2SV_blank>register<S2SV_blank>pinctrl<S2SV_blank>driver\\n" ) ; return PTR_ERR ( gpio_dev -> pctrl ) ; } ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; if ( ret ) <S2SV_StartBug> goto out1 ; <S2SV_EndBug> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ; if ( ret ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>pin<S2SV_blank>range\\n" ) ; goto out2 ; } ret = gpiochip_irqchip_add ( & gpio_dev -> gc , & amd_gpio_irqchip , 0 , handle_simple_irq , IRQ_TYPE_NONE ) ; if ( ret ) { dev_err ( & pdev -> dev , "could<S2SV_blank>not<S2SV_blank>add<S2SV_blank>irqchip\\n" ) ; ret = - ENODEV ; goto out2 ; } gpiochip_set_chained_irqchip ( & gpio_dev -> gc , & amd_gpio_irqchip , irq_base , amd_gpio_irq_handler ) ; platform_set_drvdata ( pdev , gpio_dev ) ; dev_dbg ( & pdev -> dev , "amd<S2SV_blank>gpio<S2SV_blank>driver<S2SV_blank>loaded\\n" ) ; return ret ; out2 : gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> out1 : <S2SV_EndBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; return ret ; }
CWE-000 static struct mnt_namespace * alloc_mnt_ns ( struct user_namespace * user_ns ) { struct mnt_namespace * new_ns ; struct ucounts * ucounts ; int ret ; ucounts = inc_mnt_namespaces ( user_ns ) ; if ( ! ucounts ) return ERR_PTR ( - ENOSPC ) ; new_ns = kmalloc ( sizeof ( struct mnt_namespace ) , GFP_KERNEL ) ; if ( ! new_ns ) { dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( - ENOMEM ) ; } ret = ns_alloc_inum ( & new_ns -> ns ) ; if ( ret ) { kfree ( new_ns ) ; dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( ret ) ; } new_ns -> ns . ops = & mntns_operations ; new_ns -> seq = atomic64_add_return ( 1 , & mnt_ns_seq ) ; atomic_set ( & new_ns -> count , 1 ) ; new_ns -> root = NULL ; INIT_LIST_HEAD ( & new_ns -> list ) ; init_waitqueue_head ( & new_ns -> poll ) ; new_ns -> event = 0 ; new_ns -> user_ns = get_user_ns ( user_ns ) ; new_ns -> ucounts = ucounts ; <S2SV_StartBug> return new_ns ; <S2SV_EndBug> }
CWE-399 static int fst_get_iface ( struct fst_card_info * card , struct fst_port_info * port , struct ifreq * ifr ) { sync_serial_settings sync ; int i ; switch ( port -> hwif ) { case E1 : ifr -> ifr_settings . type = IF_IFACE_E1 ; break ; case T1 : ifr -> ifr_settings . type = IF_IFACE_T1 ; break ; case V35 : ifr -> ifr_settings . type = IF_IFACE_V35 ; break ; case V24 : ifr -> ifr_settings . type = IF_IFACE_V24 ; break ; case X21D : ifr -> ifr_settings . type = IF_IFACE_X21D ; break ; case X21 : default : ifr -> ifr_settings . type = IF_IFACE_X21 ; break ; } if ( ifr -> ifr_settings . size == 0 ) { return 0 ; } if ( ifr -> ifr_settings . size < sizeof ( sync ) ) { return - ENOMEM ; } i = port -> index ; <S2SV_StartBug> sync . clock_rate = FST_RDL ( card , portConfig [ i ] . lineSpeed ) ; <S2SV_EndBug> sync . clock_type = FST_RDB ( card , portConfig [ i ] . internalClock ) == INTCLK ? CLOCK_INT : CLOCK_EXT ; sync . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & sync , sizeof ( sync ) ) ) { return - EFAULT ; } ifr -> ifr_settings . size = sizeof ( sync ) ; return 0 ; }
CWE-000 int nfsd_cross_mnt ( struct svc_rqst * rqstp , struct dentry * * dpp , struct svc_export * * expp ) { struct svc_export * exp = * expp , * exp2 = NULL ; struct dentry * dentry = * dpp ; struct path path = { . mnt = mntget ( exp -> ex_path . mnt ) , . dentry = dget ( dentry ) } ; int err = 0 ; err = follow_down ( & path ) ; if ( err < 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> exp2 = rqst_exp_get_by_name ( rqstp , & path ) ; if ( IS_ERR ( exp2 ) ) { err = PTR_ERR ( exp2 ) ; if ( err == - ENOENT && ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) err = 0 ; path_put ( & path ) ; goto out ; } if ( nfsd_v4client ( rqstp ) || ( exp -> ex_flags & NFSEXP_CROSSMOUNT ) || EX_NOHIDE ( exp2 ) ) { * dpp = path . dentry ; path . dentry = dentry ; * expp = exp2 ; exp2 = exp ; } path_put ( & path ) ; exp_put ( exp2 ) ; out : return err ; }
CWE-119 static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , "Pixel<S2SV_blank>format<S2SV_blank>0x%0x" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; <S2SV_StartBug> if ( ! encoding && c -> palette_size && c -> bpp <= 8 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , "Encoding<S2SV_blank>%d,<S2SV_blank>bpp<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>format<S2SV_blank>0x%x" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }
CWE-200 static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ; <S2SV_StartBug> long timeo ; <S2SV_EndBug> lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ! timeo || ( flags & MSG_PEEK ) ) break ; } else { if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { copied = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) { copied = - ENOTCONN ; break ; } break ; } if ( ! timeo ) { copied = - EAGAIN ; break ; } } if ( copied >= target ) { release_sock ( sk ) ; lock_sock ( sk ) ; } else sk_wait_data ( sk , & timeo ) ; if ( ( flags & MSG_PEEK ) && peek_seq != llc -> copied_seq ) { net_dbg_ratelimited ( "LLC(%s:%d):<S2SV_blank>Application<S2SV_blank>bug,<S2SV_blank>race<S2SV_blank>in<S2SV_blank>MSG_PEEK\\n" , current -> comm , task_pid_nr ( current ) ) ; peek_seq = llc -> copied_seq ; } continue ; found_ok_skb : used = skb -> len - offset ; if ( len < used ) used = len ; if ( ! ( flags & MSG_TRUNC ) ) { int rc = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , used ) ; if ( rc ) { if ( ! copied ) copied = - EFAULT ; break ; } } * seq += used ; copied += used ; len -= used ; if ( sk -> sk_type != SOCK_STREAM ) goto copy_uaddr ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } if ( used + offset < skb -> len ) continue ; } while ( len > 0 ) ; out : release_sock ( sk ) ; return copied ; copy_uaddr : if ( uaddr != NULL && skb != NULL ) { memcpy ( uaddr , llc_ui_skb_cb ( skb ) , sizeof ( * uaddr ) ) ; msg -> msg_namelen = sizeof ( * uaddr ) ; } if ( llc_sk ( sk ) -> cmsg_flags ) llc_cmsg_rcv ( msg , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } goto out ; }
CWE-189 static ssize_t _archive_write_data ( struct archive * _a , const void * buff , size_t s ) { struct archive_write * a = ( struct archive_write * ) _a ; <S2SV_StartBug> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <S2SV_EndBug> <S2SV_StartBug> ARCHIVE_STATE_DATA , "archive_write_data" ) ; <S2SV_EndBug> archive_clear_error ( & a -> archive ) ; return ( ( a -> format_write_data ) ( a , buff , s ) ) ; }
CWE-119 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; WORD32 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : 2 ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 64 ] = ( const UWORD8 ( * ) [ 64 ] ) gau1_ih264d_table_total_zero_2to10 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 6 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 2 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; while ( ( u4_zeroes_left > 6 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; if ( u4_code != 0 ) { FLUSHBITS ( u4_bitstream_offset , 3 ) ; u4_run = ( 7 - u4_code ) ; } else { FIND_ONE_IN_STREAM_LEN ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 11 ) ; u4_run = ( 4 + u4_code ) ; } SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }
CWE-000 sctp_disposition_t sctp_sf_do_5_2_4_dupcook ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { sctp_disposition_t retval ; struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; int error = 0 ; char action ; struct sctp_chunk * err_chk_p ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } action = sctp_tietags_compare ( new_asoc , asoc ) ; switch ( action ) { case 'A' : retval = sctp_sf_do_dupcook_a ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'B' : retval = sctp_sf_do_dupcook_b ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'C' : retval = sctp_sf_do_dupcook_c ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'D' : retval = sctp_sf_do_dupcook_d ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; default : retval = sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; break ; } <S2SV_StartBug> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <S2SV_EndBug> sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_ASOC , SCTP_ASOC ( ( struct sctp_association * ) asoc ) ) ; return retval ; nomem : return SCTP_DISPOSITION_NOMEM ; }
CWE-119 int encode_msg ( struct sip_msg * msg , char * payload , int len ) { int i , j , k , u , request ; unsigned short int h ; struct hdr_field * hf ; struct msg_start * ms ; struct sip_uri miuri ; char * myerror = NULL ; ptrdiff_t diff ; if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ; if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { myerror = "in<S2SV_blank>parse_headers" ; goto error ; } memset ( payload , 0 , len ) ; ms = & msg -> first_line ; if ( ms -> type == SIP_REQUEST ) request = 1 ; else if ( ms -> type == SIP_REPLY ) request = 0 ; else { myerror = "message<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>request<S2SV_blank>nor<S2SV_blank>response" ; goto error ; } if ( request ) { for ( h = 0 ; h < 32 ; j = ( 0x01 << h ) , h ++ ) if ( j & ms -> u . request . method_value ) break ; } else { h = ( unsigned short ) ( ms -> u . reply . statuscode ) ; } if ( h == 32 ) { myerror = "unknown<S2SV_blank>message<S2SV_blank>type\\n" ; goto error ; } h = htons ( h ) ; memcpy ( payload , & h , 2 ) ; h = htons ( ( unsigned short int ) msg -> len ) ; memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ; if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) { myerror = "body<S2SV_blank>starts<S2SV_blank>before<S2SV_blank>the<S2SV_blank>message<S2SV_blank>(uh<S2SV_blank>?)" ; goto error ; } else h = htons ( ( unsigned short int ) diff ) ; memcpy ( payload + CONTENT_IDX , & h , 2 ) ; payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ; payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ; payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ; payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ; payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ; if ( request ) { if ( parse_uri ( ms -> u . request . uri . s , ms -> u . request . uri . len , & miuri ) < 0 ) { LM_ERR ( "<%.*s>\\n" , ms -> u . request . uri . len , ms -> u . request . uri . s ) ; myerror = "while<S2SV_blank>parsing<S2SV_blank>the<S2SV_blank>R-URI" ; goto error ; } if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) { myerror = "ENCODE_MSG:<S2SV_blank>ERROR<S2SV_blank>while<S2SV_blank>encoding<S2SV_blank>the<S2SV_blank>R-URI" ; goto error ; } payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ; k = REQUEST_URI_IDX + 1 + j ; } else k = REQUEST_URI_IDX ; u = k ; k ++ ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , i ++ ) ; i ++ ; j = k + 3 * i ; for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , k += 3 ) { payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ; h = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & h , 2 ) ; if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) { LM_ERR ( "encoding<S2SV_blank>header<S2SV_blank>%.*s\\n" , hf -> name . len , hf -> name . s ) ; goto error ; k -= 3 ; continue ; } j += ( unsigned short int ) i ; } payload [ u ] = ( unsigned char ) ( ( k - u - 1 ) / 3 ) ; j = htons ( j ) ; memcpy ( & payload [ k + 1 ] , & j , 2 ) ; k += 3 ; j = ntohs ( j ) ; <S2SV_StartBug> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; <S2SV_EndBug> LM_DBG ( "msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n" , msg -> len , j ) ; j = htons ( j ) ; memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ; return GET_PAY_SIZE ( payload ) ; error : LM_ERR ( "%s\\n" , myerror ) ; return - 1 ; }
CWE-125 int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "et1<S2SV_blank>" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , "(NOV-ETHII)<S2SV_blank>" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[|osi]" ) ) ; return ( 1 ) ; } <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { ND_PRINT ( ( ndo , ":<S2SV_blank>" ) ) ; ppp_print ( ndo , p , length ) ; } return ( 1 ) ; case ETHERTYPE_MPCP : mpcp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_SLOW : slow_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_CFM : case ETHERTYPE_CFM_OLD : cfm_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LLDP : lldp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_NSH : nsh_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_LOOPBACK : loopback_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_TIPC : tipc_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_MS_NLB_HB : msnlb_print ( ndo , p ) ; return ( 1 ) ; case ETHERTYPE_GEONET_OLD : case ETHERTYPE_GEONET : geonet_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_CALM_FAST : calm_fast_print ( ndo , p , length , src ) ; return ( 1 ) ; case ETHERTYPE_AOE : aoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_MEDSA : medsa_print ( ndo , p , length , caplen , src , dst ) ; return ( 1 ) ; case ETHERTYPE_LAT : case ETHERTYPE_SCA : case ETHERTYPE_MOPRC : case ETHERTYPE_MOPDL : case ETHERTYPE_IEEE1905_1 : default : return ( 0 ) ; } }
CWE-189 static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; <S2SV_StartBug> } <S2SV_EndBug> dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }
CWE-125 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; <S2SV_StartBug> if ( g -> sect <= 0 || <S2SV_EndBug> <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = "user<S2SV_blank>format" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
CWE-000 void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( "usage:<S2SV_blank>condump<S2SV_blank><filename>\\n" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; <S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , ".txt" ) ; <S2SV_EndBug> f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( "ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n" , filename ) ; return ; } Com_Printf ( "Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) { buffer [ x ] = 0 ; } else { break ; } } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , "\\r\\n" ) ; # else Q_strcat ( buffer , bufferlen , "\\n" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }
CWE-20 static int ovl_remove_upper ( struct dentry * dentry , bool is_dir ) { struct dentry * upperdir = ovl_dentry_upper ( dentry -> d_parent ) ; struct inode * dir = upperdir -> d_inode ; <S2SV_StartBug> struct dentry * upper = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> int err ; inode_lock_nested ( dir , I_MUTEX_PARENT ) ; <S2SV_StartBug> err = - ESTALE ; <S2SV_EndBug> <S2SV_StartBug> if ( upper -> d_parent == upperdir ) { <S2SV_EndBug> dget ( upper ) ; if ( is_dir ) err = vfs_rmdir ( dir , upper ) ; else err = vfs_unlink ( dir , upper , NULL ) ; <S2SV_StartBug> dput ( upper ) ; <S2SV_EndBug> ovl_dentry_version_inc ( dentry -> d_parent ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! err ) d_drop ( dentry ) ; <S2SV_StartBug> inode_unlock ( dir ) ; <S2SV_EndBug> return err ; }
CWE-200 void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } <S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static INLINE void read_mv ( vp9_reader * r , MV * mv , const MV * ref , <S2SV_EndBug> const nmv_context * ctx , nmv_context_counts * counts , int allow_hp ) { const MV_JOINT_TYPE joint_type = <S2SV_StartBug> ( MV_JOINT_TYPE ) vp9_read_tree ( r , vp9_mv_joint_tree , ctx -> joints ) ; <S2SV_EndBug> const int use_hp = allow_hp && vp9_use_mv_hp ( ref ) ; MV diff = { 0 , 0 } ; if ( mv_joint_vertical ( joint_type ) ) diff . row = read_mv_component ( r , & ctx -> comps [ 0 ] , use_hp ) ; if ( mv_joint_horizontal ( joint_type ) ) diff . col = read_mv_component ( r , & ctx -> comps [ 1 ] , use_hp ) ; vp9_inc_mv ( & diff , counts ) ; mv -> row = ref -> row + diff . row ; mv -> col = ref -> col + diff . col ; }
CWE-119 static void output_stats ( FIRSTPASS_STATS * stats , struct vpx_codec_pkt_list * pktlist ) { struct vpx_codec_cx_pkt pkt ; pkt . kind = VPX_CODEC_STATS_PKT ; pkt . data . twopass_stats . buf = stats ; pkt . data . twopass_stats . sz = sizeof ( FIRSTPASS_STATS ) ; vpx_codec_pkt_list_add ( pktlist , & pkt ) ; # if OUTPUT_FPF { FILE * fpfile ; fpfile = fopen ( "firstpass.stt" , "a" ) ; <S2SV_StartBug> fprintf ( fpfile , "%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f" <S2SV_EndBug> "%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f" "%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f\\n" , stats -> frame , <S2SV_StartBug> stats -> intra_error , <S2SV_EndBug> stats -> coded_error , stats -> sr_coded_error , <S2SV_StartBug> stats -> ssim_weighted_pred_err , <S2SV_EndBug> stats -> pcnt_inter , stats -> pcnt_motion , stats -> pcnt_second_ref , <S2SV_StartBug> stats -> pcnt_neutral , <S2SV_EndBug> stats -> MVr , stats -> mvr_abs , stats -> MVc , stats -> mvc_abs , stats -> MVrv , stats -> MVcv , stats -> mv_in_out_count , stats -> new_mv_count , stats -> count , stats -> duration ) ; fclose ( fpfile ) ; } # endif }
CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
CWE-119 void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , "r" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , "cannot<S2SV_blank>open<S2SV_blank>CSR<S2SV_blank>file!\\n" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>file<S2SV_blank>length!\\n" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>sp<S2SV_blank>data!\\n" ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i < ( * o_row_count + 1 ) ; l_i ++ ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>csr<S2SV_blank>description!\\n" ) ; return ; } } else { unsigned int l_row , l_column ; double l_value ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>element!\\n" ) ; return ; } l_row -- ; l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { fprintf ( stderr , "we<S2SV_blank>were<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>elements!\\n" ) ; return ; } for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } if ( l_row_idx_id != NULL ) { free ( l_row_idx_id ) ; } }
CWE-189 static pfn_t kvm_pin_pages ( struct kvm_memory_slot * slot , gfn_t gfn , <S2SV_StartBug> unsigned long size ) <S2SV_EndBug> { gfn_t end_gfn ; pfn_t pfn ; pfn = gfn_to_pfn_memslot ( slot , gfn ) ; <S2SV_StartBug> end_gfn = gfn + ( size >> PAGE_SHIFT ) ; <S2SV_EndBug> gfn += 1 ; if ( is_error_noslot_pfn ( pfn ) ) return pfn ; while ( gfn < end_gfn ) gfn_to_pfn_memslot ( slot , gfn ++ ) ; return pfn ; }
CWE-119 int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) { struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; int i , err = 0 ; int free = - 1 ; mlx4_dbg ( dev , "Registering<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n" , ( unsigned long long ) mac ) ; mutex_lock ( & table -> mutex ) ; for ( i = 0 ; i < MLX4_MAX_MAC_NUM - 1 ; i ++ ) { if ( free < 0 && ! table -> refs [ i ] ) { free = i ; continue ; } if ( mac == ( MLX4_MAC_MASK & be64_to_cpu ( table -> entries [ i ] ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } <S2SV_StartBug> mlx4_dbg ( dev , "Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n" , free ) ; <S2SV_EndBug> if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be64 ( mac | MLX4_MAC_VALID ) ; err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_err ( dev , "Failed<S2SV_blank>adding<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n" , ( unsigned long long ) mac ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
CWE-000 int virDomainGetTime ( virDomainPtr dom , long long * seconds , unsigned int * nseconds , unsigned int flags ) { VIR_DOMAIN_DEBUG ( dom , "seconds=%p,<S2SV_blank>nseconds=%p,<S2SV_blank>flags=%x" , seconds , nseconds , flags ) ; virResetLastError ( ) ; <S2SV_StartBug> virCheckDomainReturn ( dom , - 1 ) ; <S2SV_EndBug> if ( dom -> conn -> driver -> domainGetTime ) { int ret = dom -> conn -> driver -> domainGetTime ( dom , seconds , nseconds , flags ) ; if ( ret < 0 ) goto error ; return ret ; } virReportUnsupportedError ( ) ; error : virDispatchError ( dom -> conn ) ; return - 1 ; }
CWE-200 int res_unpack ( vorbis_info_residue * info , vorbis_info * vi , oggpack_buffer * opb ) { int j , k ; codec_setup_info * ci = ( codec_setup_info * ) vi -> codec_setup ; memset ( info , 0 , sizeof ( * info ) ) ; info -> type = oggpack_read ( opb , 16 ) ; if ( info -> type > 2 || info -> type < 0 ) goto errout ; info -> begin = oggpack_read ( opb , 24 ) ; info -> end = oggpack_read ( opb , 24 ) ; info -> grouping = oggpack_read ( opb , 24 ) + 1 ; info -> partitions = ( char ) ( oggpack_read ( opb , 6 ) + 1 ) ; info -> groupbook = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( info -> groupbook >= ci -> books ) goto errout ; info -> stagemasks = _ogg_malloc ( info -> partitions * sizeof ( * info -> stagemasks ) ) ; info -> stagebooks = _ogg_malloc ( info -> partitions * 8 * sizeof ( * info -> stagebooks ) ) ; for ( j = 0 ; j < info -> partitions ; j ++ ) { int cascade = oggpack_read ( opb , 3 ) ; if ( oggpack_read ( opb , 1 ) ) cascade |= ( oggpack_read ( opb , 5 ) << 3 ) ; info -> stagemasks [ j ] = cascade ; } for ( j = 0 ; j < info -> partitions ; j ++ ) { for ( k = 0 ; k < 8 ; k ++ ) { if ( ( info -> stagemasks [ j ] >> k ) & 1 ) { unsigned char book = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( book >= ci -> books ) goto errout ; info -> stagebooks [ j * 8 + k ] = book ; if ( k + 1 > info -> stages ) info -> stages = k + 1 ; } else info -> stagebooks [ j * 8 + k ] = 0xff ; } } if ( oggpack_eop ( opb ) ) goto errout ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> errout : res_clear_info ( info ) ; return 1 ; }
CWE-000 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> goto csum_copy_err ; } <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; cond_resched ( ) ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
CWE-200 static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }
CWE-119 static int apply_cyclic_refresh_bitrate ( const VP9_COMMON * cm , const RATE_CONTROL * rc ) { <S2SV_StartBug> const float factor = 0.5 ; <S2SV_EndBug> const int number_blocks = cm -> mi_rows * cm -> mi_cols ; <S2SV_StartBug> if ( rc -> av_per_frame_bandwidth < factor * number_blocks || <S2SV_EndBug> number_blocks / 64 < 5 ) return 0 ; else return 1 ; }
CWE-476 static MagickBooleanType ReadPSDChannel ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , LayerInfo * layer_info , const size_t channel , const PSDCompressionType compression , ExceptionInfo * exception ) { Image * channel_image , * mask ; MagickOffsetType offset ; MagickBooleanType status ; channel_image = image ; mask = ( Image * ) NULL ; if ( layer_info -> channel_info [ channel ] . type < - 1 ) { const char * option ; option = GetImageOption ( image_info , "psd:preserve-opacity-mask" ) ; if ( ( layer_info -> channel_info [ channel ] . type != - 2 ) || ( layer_info -> mask . flags > 2 ) || ( ( layer_info -> mask . flags & 0x02 ) && ( IsStringTrue ( option ) == MagickFalse ) ) ) { SeekBlob ( image , layer_info -> channel_info [ channel ] . size - 2 , SEEK_CUR ) ; return ( MagickTrue ) ; } mask = CloneImage ( image , layer_info -> mask . page . width , layer_info -> mask . page . height , MagickFalse , exception ) ; <S2SV_StartBug> mask -> matte = MagickFalse ; <S2SV_EndBug> <S2SV_StartBug> channel_image = mask ; <S2SV_EndBug> } offset = TellBlob ( image ) ; status = MagickTrue ; switch ( compression ) { case Raw : status = ReadPSDChannelRaw ( channel_image , psd_info -> channels , layer_info -> channel_info [ channel ] . type , exception ) ; break ; case RLE : { MagickOffsetType * sizes ; sizes = ReadPSDRLESizes ( channel_image , psd_info , channel_image -> rows ) ; if ( sizes == ( MagickOffsetType * ) NULL ) ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , image -> filename ) ; status = ReadPSDChannelRLE ( channel_image , psd_info , layer_info -> channel_info [ channel ] . type , sizes , exception ) ; sizes = ( MagickOffsetType * ) RelinquishMagickMemory ( sizes ) ; } break ; case ZipWithPrediction : case ZipWithoutPrediction : # ifdef MAGICKCORE_ZLIB_DELEGATE status = ReadPSDChannelZip ( channel_image , layer_info -> channels , layer_info -> channel_info [ channel ] . type , compression , layer_info -> channel_info [ channel ] . size - 2 , exception ) ; # else ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , MissingDelegateWarning , "DelegateLibrarySupportNotBuiltIn" , "\'%s\'<S2SV_blank>(ZLIB)" , image -> filename ) ; # endif break ; default : ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , TypeWarning , "CompressionNotSupported" , "\'%.20g\'" , ( double ) compression ) ; break ; } SeekBlob ( image , offset + layer_info -> channel_info [ channel ] . size - 2 , SEEK_SET ) ; if ( status == MagickFalse ) { if ( mask != ( Image * ) NULL ) DestroyImage ( mask ) ; ThrowBinaryException ( CoderError , "UnableToDecompressImage" , image -> filename ) ; } layer_info -> mask . image = mask ; return ( status ) ; }
CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><frame>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
CWE-20 static void print_maps ( struct pid_info_t * info ) { FILE * maps ; size_t offset ; char device [ 10 ] ; long int inode ; <S2SV_StartBug> char file [ PATH_MAX ] ; <S2SV_EndBug> strlcat ( info -> path , "maps" , sizeof ( info -> path ) ) ; maps = fopen ( info -> path , "r" ) ; if ( ! maps ) goto out ; <S2SV_StartBug> while ( fscanf ( maps , "%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%s<S2SV_blank>%ld<S2SV_blank>%s\\n" , & offset , device , & inode , <S2SV_EndBug> file ) == 4 ) { if ( inode == 0 || ! strcmp ( device , "00:00" ) ) continue ; printf ( "%-9s<S2SV_blank>%5d<S2SV_blank>%10s<S2SV_blank>%4s<S2SV_blank>%9s<S2SV_blank>%18s<S2SV_blank>%9zd<S2SV_blank>%10ld<S2SV_blank>%s\\n" , info -> cmdline , info -> pid , info -> user , "mem" , "???" , device , offset , inode , file ) ; } fclose ( maps ) ; out : info -> path [ info -> parent_length ] = '\\0' ; }
CWE-125 static MagickBooleanType Get8BIMProperty ( const Image * image , const char * key , ExceptionInfo * exception ) { char * attribute , format [ MagickPathExtent ] , name [ MagickPathExtent ] , * resource ; const StringInfo * profile ; const unsigned char * info ; long start , stop ; MagickBooleanType status ; register ssize_t i ; size_t length ; ssize_t count , id , sub_number ; profile = GetImageProfile ( image , "8bim" ) ; if ( profile == ( StringInfo * ) NULL ) return ( MagickFalse ) ; count = ( ssize_t ) sscanf ( key , "8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]" , & start , & stop , name , format ) ; if ( ( count != 2 ) && ( count != 3 ) && ( count != 4 ) ) return ( MagickFalse ) ; if ( count < 4 ) ( void ) CopyMagickString ( format , "SVG" , MagickPathExtent ) ; if ( count < 3 ) * name = '\\0' ; sub_number = 1 ; if ( * name == '#' ) sub_number = ( ssize_t ) StringToLong ( & name [ 1 ] ) ; sub_number = MagickMax ( sub_number , 1L ) ; resource = ( char * ) NULL ; status = MagickFalse ; length = GetStringInfoLength ( profile ) ; info = GetStringInfoDatum ( profile ) ; while ( ( length > 0 ) && ( status == MagickFalse ) ) { if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) '8' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'B' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'I' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'M' ) continue ; id = ( ssize_t ) ReadPropertyMSBShort ( & info , & length ) ; if ( id < ( ssize_t ) start ) continue ; if ( id > ( ssize_t ) stop ) continue ; if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; count = ( ssize_t ) ReadPropertyByte ( & info , & length ) ; if ( ( count != 0 ) && ( ( size_t ) count <= length ) ) { resource = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) resource = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * resource ) ) ; if ( resource != ( char * ) NULL ) { for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) resource [ i ] = ( char ) ReadPropertyByte ( & info , & length ) ; resource [ count ] = '\\0' ; } } if ( ( count & 0x01 ) == 0 ) ( void ) ReadPropertyByte ( & info , & length ) ; count = ( ssize_t ) ReadPropertyMSBLong ( & info , & length ) ; <S2SV_StartBug> if ( ( * name != '\\0' ) && ( * name != '#' ) ) <S2SV_EndBug> if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) { info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } if ( ( * name == '#' ) && ( sub_number != 1 ) ) { sub_number -- ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } attribute = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) attribute = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * attribute ) ) ; if ( attribute != ( char * ) NULL ) { ( void ) CopyMagickMemory ( attribute , ( char * ) info , ( size_t ) count ) ; attribute [ count ] = '\\0' ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; if ( ( id <= 1999 ) || ( id >= 2999 ) ) ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) attribute , exception ) ; else { char * path ; if ( LocaleCompare ( format , "svg" ) == 0 ) path = TraceSVGClippath ( ( unsigned char * ) attribute , ( size_t ) count , image -> columns , image -> rows ) ; else path = TracePSClippath ( ( unsigned char * ) attribute , ( size_t ) count ) ; ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) path , exception ) ; path = DestroyString ( path ) ; } attribute = DestroyString ( attribute ) ; status = MagickTrue ; } } if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; return ( status ) ; }
CWE-119 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" <S2SV_EndBug> "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-119 static void lspci_process ( STREAM s ) { unsigned int pkglen ; static char * rest = NULL ; <S2SV_StartBug> char * buf ; <S2SV_EndBug> pkglen = s -> end - s -> p ; buf = xmalloc ( pkglen + 1 ) ; STRNCPY ( buf , ( char * ) s -> p , pkglen + 1 ) ; str_handle_lines ( buf , & rest , lspci_process_line , NULL ) ; xfree ( buf ) ; }
CWE-20 static ssize_t yurex_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { struct usb_yurex * dev ; <S2SV_StartBug> int retval = 0 ; <S2SV_EndBug> int bytes_read = 0 ; char in_buffer [ 20 ] ; unsigned long flags ; dev = file -> private_data ; mutex_lock ( & dev -> io_mutex ) ; if ( ! dev -> interface ) { <S2SV_StartBug> retval = - ENODEV ; <S2SV_EndBug> goto exit ; } spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_StartBug> bytes_read = snprintf ( in_buffer , 20 , "%lld\\n" , dev -> bbu ) ; <S2SV_EndBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_StartBug> if ( * ppos < bytes_read ) { <S2SV_EndBug> if ( copy_to_user ( buffer , in_buffer + * ppos , bytes_read - * ppos ) ) retval = - EFAULT ; else { retval = bytes_read - * ppos ; * ppos += bytes_read ; } } exit : mutex_unlock ( & dev -> io_mutex ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
CWE-190 int mem_check_range ( struct rxe_mem * mem , u64 iova , size_t length ) { switch ( mem -> type ) { case RXE_MEM_TYPE_DMA : return 0 ; case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : <S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> - EFAULT : 0 ; default : return - EFAULT ; } }
CWE-119 void vp9_init_mv_probs ( VP9_COMMON * cm ) { <S2SV_StartBug> cm -> fc . nmvc = default_nmv_context ; <S2SV_EndBug> }
CWE-000 long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ; <S2SV_StartBug> if ( info -> si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }
CWE-119 static int key_notify_sa_flush ( const struct km_event * c ) { struct sk_buff * skb ; struct sadb_msg * hdr ; skb = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_satype = pfkey_proto2satype ( c -> data . proto ) ; hdr -> sadb_msg_type = SADB_FLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_StartBug> pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> return 0 ; }
CWE-000 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( "Marking<S2SV_blank>messages<S2SV_blank>deleted..." ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , "DELE<S2SV_blank>%d\\r\\n" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , "QUIT\\r\\n" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( "%s" , pop_data -> err_msg ) ; return - 1 ; } } }
CWE-125 static void get_nb10 ( ut8 * dbg_data , SCV_NB10_HEADER * res ) { const int nb10sz = 16 ; <S2SV_StartBug> memcpy ( res , dbg_data , nb10sz ) ; <S2SV_EndBug> res -> file_name = ( ut8 * ) strdup ( ( const char * ) dbg_data + nb10sz ) ; }
CWE-125 static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) { EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ; switch ( type ) { case EVP_CTRL_INIT : gctx -> key_set = 0 ; gctx -> iv_set = 0 ; gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ; gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ; gctx -> taglen = - 1 ; gctx -> iv_gen = 0 ; gctx -> tls_aad_len = - 1 ; return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ; if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) { if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ; gctx -> iv = OPENSSL_malloc ( arg ) ; if ( gctx -> iv == NULL ) return 0 ; } gctx -> ivlen = arg ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; gctx -> taglen = arg ; return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ; memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ; return 1 ; case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) { memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ; gctx -> iv_gen = 1 ; return 1 ; } if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ; if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ; if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ; gctx -> iv_gen = 1 ; return 1 ; case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ; CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ; if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ; memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ; ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ; gctx -> iv_set = 1 ; return 1 ; case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ; memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ; CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ; gctx -> iv_set = 1 ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; gctx -> tls_aad_len = arg ; { unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; <S2SV_StartBug> len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= EVP_GCM_TLS_TAG_LEN ; <S2SV_EndBug> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return EVP_GCM_TLS_TAG_LEN ; case EVP_CTRL_COPY : { EVP_CIPHER_CTX * out = ptr ; EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ; if ( gctx -> gcm . key ) { if ( gctx -> gcm . key != & gctx -> ks ) return 0 ; gctx_out -> gcm . key = & gctx_out -> ks ; } if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ; else { gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ; if ( gctx_out -> iv == NULL ) return 0 ; memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ; } return 1 ; } default : return - 1 ; } }
CWE-119 void vp9_subtract_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { struct macroblock_plane * const p = & x -> plane [ plane ] ; const struct macroblockd_plane * const pd = & x -> e_mbd . plane [ plane ] ; const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , pd ) ; const int bw = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; const int bh = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ; <S2SV_StartBug> vp9_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , <S2SV_EndBug> pd -> dst . buf , pd -> dst . stride ) ; }
CWE-000 static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }
CWE-284 bool btsock_thread_remove_fd_and_close ( int thread_handle , int fd ) { if ( thread_handle < 0 || thread_handle >= MAX_THREAD ) { APPL_TRACE_ERROR ( "%s<S2SV_blank>invalid<S2SV_blank>thread<S2SV_blank>handle:<S2SV_blank>%d" , __func__ , thread_handle ) ; return false ; } if ( fd == - 1 ) { APPL_TRACE_ERROR ( "%s<S2SV_blank>invalid<S2SV_blank>file<S2SV_blank>descriptor." , __func__ ) ; return false ; } sock_cmd_t cmd = { CMD_REMOVE_FD , fd , 0 , 0 , 0 } ; <S2SV_StartBug> return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> }
CWE-362 struct dentry * debugfs_rename ( struct dentry * old_dir , struct dentry * old_dentry , struct dentry * new_dir , const char * new_name ) { int error ; struct dentry * dentry = NULL , * trap ; <S2SV_StartBug> const char * old_name ; <S2SV_EndBug> trap = lock_rename ( new_dir , old_dir ) ; if ( d_really_is_negative ( old_dir ) || d_really_is_negative ( new_dir ) ) goto exit ; if ( d_really_is_negative ( old_dentry ) || old_dentry == trap || d_mountpoint ( old_dentry ) ) goto exit ; dentry = lookup_one_len ( new_name , new_dir , strlen ( new_name ) ) ; if ( IS_ERR ( dentry ) || dentry == trap || d_really_is_positive ( dentry ) ) goto exit ; <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { fsnotify_oldname_free ( old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ; <S2SV_StartBug> fsnotify_oldname_free ( old_name ) ; <S2SV_EndBug> unlock_rename ( new_dir , old_dir ) ; dput ( dentry ) ; return old_dentry ; exit : if ( dentry && ! IS_ERR ( dentry ) ) dput ( dentry ) ; unlock_rename ( new_dir , old_dir ) ; return NULL ; }
CWE-119 static void write_modes_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) ; <S2SV_EndBug> const int bs = ( 1 << bsl ) / 4 ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; <S2SV_StartBug> MODE_INFO * m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ; <S2SV_EndBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; partition = partition_lookup [ bsl ] [ m -> mbmi . sb_type ] ; write_partition ( cm , xd , bs , mi_row , mi_col , partition , bsize , w ) ; subsize = get_subsize ( bsize , partition ) ; if ( subsize < BLOCK_8X8 ) { write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; } else { switch ( partition ) { case PARTITION_NONE : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; break ; case PARTITION_HORZ : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; if ( mi_row + bs < cm -> mi_rows ) write_modes_b ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col ) ; break ; case PARTITION_VERT : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; if ( mi_col + bs < cm -> mi_cols ) write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs ) ; break ; case PARTITION_SPLIT : write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col + bs , subsize ) ; break ; default : assert ( 0 ) ; } } if ( bsize >= BLOCK_8X8 && ( bsize == BLOCK_8X8 || partition != PARTITION_SPLIT ) ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }
CWE-189 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; <S2SV_StartBug> int count , i ; <S2SV_EndBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ; acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }
CWE-119 static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; <S2SV_StartBug> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; <S2SV_EndBug> u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ; <S2SV_StartBug> const unsigned end_of_metadata = height - 1 ; <S2SV_EndBug> int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ; iblks = height - ip -> i_height ; branch_start = metapath_branch_start ( mp ) ; iblks += ( height - branch_start ) ; } } blks = dblks + iblks ; i = sheight ; do { int error ; n = blks - alloced ; error = gfs2_alloc_block ( ip , & bn , & n ) ; if ( error ) return error ; alloced += n ; if ( state != ALLOC_DATA || gfs2_is_jdata ( ip ) ) gfs2_trans_add_unrevoke ( sdp , bn , n ) ; switch ( state ) { case ALLOC_GROW_HEIGHT : if ( i == 1 ) { ptr = ( __be64 * ) ( dibh -> b_data + sizeof ( struct gfs2_dinode ) ) ; zero_bn = * ptr ; } for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; if ( i - 1 == height - ip -> i_height ) { i -- ; gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , sizeof ( struct gfs2_meta_header ) , dibh , sizeof ( struct gfs2_dinode ) ) ; gfs2_buffer_clear_tail ( dibh , sizeof ( struct gfs2_dinode ) + sizeof ( __be64 ) ) ; ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + sizeof ( struct gfs2_meta_header ) ) ; * ptr = zero_bn ; state = ALLOC_GROW_DEPTH ; for ( i = branch_start ; i < height ; i ++ ) { if ( mp -> mp_bh [ i ] == NULL ) break ; brelse ( mp -> mp_bh [ i ] ) ; mp -> mp_bh [ i ] = NULL ; } i = branch_start ; } if ( n == 0 ) break ; case ALLOC_GROW_DEPTH : if ( i > 1 && i < height ) gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; for ( ; i < height && n > 0 ; i ++ , n -- ) gfs2_indirect_init ( mp , ip -> i_gl , i , mp -> mp_list [ i - 1 ] , bn ++ ) ; if ( i == height ) state = ALLOC_DATA ; if ( n == 0 ) break ; case ALLOC_DATA : BUG_ON ( n > dblks ) ; BUG_ON ( mp -> mp_bh [ end_of_metadata ] == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; dblks = n ; ptr = metapointer ( end_of_metadata , mp ) ; dblock = bn ; while ( n -- > 0 ) * ptr ++ = cpu_to_be64 ( bn ++ ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } } while ( ( state != ALLOC_DATA ) || ! dblock ) ; ip -> i_height = height ; gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; map_bh ( bh_map , inode -> i_sb , dblock ) ; bh_map -> b_size = dblks << inode -> i_blkbits ; set_buffer_new ( bh_map ) ; return 0 ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp8_get_reference ( ctx -> cpi , frame -> frame_type , & sd ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-20 static int rawsock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied ; int rc ; pr_debug ( "sock=%p<S2SV_blank>sk=%p<S2SV_blank>len=%zu<S2SV_blank>flags=%d\\n" , sock , sk , len , flags ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rc ) ; if ( ! skb ) return rc ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; return rc ? : copied ; }
CWE-399 static int xfrm6_tunnel_rcv ( struct sk_buff * skb ) { struct ipv6hdr * iph = ipv6_hdr ( skb ) ; __be32 spi ; spi = xfrm6_tunnel_spi_lookup ( ( xfrm_address_t * ) & iph -> saddr ) ; <S2SV_StartBug> return xfrm6_rcv_spi ( skb , spi ) ; <S2SV_EndBug> }
CWE-399 static int ceph_x_proc_ticket_reply ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * buf , void * end ) { void * p = buf ; <S2SV_StartBug> char * dbuf ; <S2SV_EndBug> char * ticket_buf ; u8 reply_struct_v ; u32 num ; <S2SV_StartBug> int ret ; <S2SV_EndBug> dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! dbuf ) return - ENOMEM ; ret = - ENOMEM ; ticket_buf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! ticket_buf ) goto out_dbuf ; ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ; if ( reply_struct_v != 1 ) return - EINVAL ; ceph_decode_32_safe ( & p , end , num , bad ) ; dout ( "%d<S2SV_blank>tickets\\n" , num ) ; while ( num -- ) { <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> dbuf , ticket_buf ) ; if ( ret ) <S2SV_StartBug> goto out ; <S2SV_EndBug> } ret = 0 ; out : kfree ( ticket_buf ) ; out_dbuf : kfree ( dbuf ) ; return ret ; bad : <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> }
CWE-119 static uint32_t color_string_to_rgba ( const char * p , int len ) { uint32_t ret = 0xFF000000 ; const ColorEntry * entry ; char color_name [ 100 ] ; <S2SV_StartBug> if ( * p == '#' ) { <S2SV_EndBug> p ++ ; len -- ; if ( len == 3 ) { ret |= ( hex_char_to_number ( p [ 2 ] ) << 4 ) | ( hex_char_to_number ( p [ 1 ] ) << 12 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 4 ) { ret = ( hex_char_to_number ( p [ 3 ] ) << 4 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 20 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } else if ( len == 6 ) { ret |= hex_char_to_number ( p [ 5 ] ) | ( hex_char_to_number ( p [ 4 ] ) << 4 ) | ( hex_char_to_number ( p [ 3 ] ) << 8 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 16 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 8 ) { ret = hex_char_to_number ( p [ 7 ] ) | ( hex_char_to_number ( p [ 6 ] ) << 4 ) | ( hex_char_to_number ( p [ 5 ] ) << 8 ) | ( hex_char_to_number ( p [ 4 ] ) << 12 ) | ( hex_char_to_number ( p [ 3 ] ) << 16 ) | ( hex_char_to_number ( p [ 2 ] ) << 20 ) | ( hex_char_to_number ( p [ 1 ] ) << 24 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } } else { strncpy ( color_name , p , len ) ; color_name [ len ] = '\\0' ; entry = bsearch ( color_name , color_table , FF_ARRAY_ELEMS ( color_table ) , sizeof ( ColorEntry ) , color_table_compare ) ; if ( ! entry ) return ret ; ret = entry -> rgb_color ; } return ret ; }
CWE-476 int kvm_vm_ioctl_check_extension ( struct kvm * kvm , long ext ) { int r ; int hv_enabled = kvmppc_hv_ops ? 1 : 0 ; if ( kvm ) { hv_enabled = is_kvmppc_hv_enabled ( kvm ) ; } switch ( ext ) { # ifdef CONFIG_BOOKE case KVM_CAP_PPC_BOOKE_SREGS : case KVM_CAP_PPC_BOOKE_WATCHDOG : case KVM_CAP_PPC_EPR : # else case KVM_CAP_PPC_SEGSTATE : case KVM_CAP_PPC_HIOR : case KVM_CAP_PPC_PAPR : # endif case KVM_CAP_PPC_UNSET_IRQ : case KVM_CAP_PPC_IRQ_LEVEL : case KVM_CAP_ENABLE_CAP : case KVM_CAP_ENABLE_CAP_VM : case KVM_CAP_ONE_REG : case KVM_CAP_IOEVENTFD : case KVM_CAP_DEVICE_CTRL : case KVM_CAP_IMMEDIATE_EXIT : r = 1 ; break ; case KVM_CAP_PPC_PAIRED_SINGLES : case KVM_CAP_PPC_OSI : case KVM_CAP_PPC_GET_PVINFO : # if defined ( CONFIG_KVM_E500V2 ) || defined ( CONFIG_KVM_E500MC ) case KVM_CAP_SW_TLB : # endif r = ! hv_enabled ; break ; # ifdef CONFIG_KVM_MPIC case KVM_CAP_IRQ_MPIC : r = 1 ; break ; # endif # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_SPAPR_TCE : case KVM_CAP_SPAPR_TCE_64 : case KVM_CAP_SPAPR_TCE_VFIO : case KVM_CAP_PPC_RTAS : case KVM_CAP_PPC_FIXUP_HCALL : case KVM_CAP_PPC_ENABLE_HCALL : # ifdef CONFIG_KVM_XICS case KVM_CAP_IRQ_XICS : # endif r = 1 ; break ; case KVM_CAP_PPC_ALLOC_HTAB : r = hv_enabled ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_SMT : r = 0 ; if ( kvm ) { if ( kvm -> arch . emul_smt_mode > 1 ) r = kvm -> arch . emul_smt_mode ; else r = kvm -> arch . smt_mode ; } else if ( hv_enabled ) { if ( cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = 1 ; else r = threads_per_subcore ; } break ; case KVM_CAP_PPC_SMT_POSSIBLE : r = 1 ; if ( hv_enabled ) { if ( ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ) r = ( ( threads_per_subcore << 1 ) - 1 ) ; else r = 8 | 4 | 2 | 1 ; } break ; case KVM_CAP_PPC_RMA : r = 0 ; break ; case KVM_CAP_PPC_HWRNG : r = kvmppc_hwrng_present ( ) ; break ; case KVM_CAP_PPC_MMU_RADIX : r = ! ! ( hv_enabled && radix_enabled ( ) ) ; break ; case KVM_CAP_PPC_MMU_HASH_V3 : r = ! ! ( hv_enabled && ! radix_enabled ( ) && cpu_has_feature ( CPU_FTR_ARCH_300 ) ) ; break ; # endif case KVM_CAP_SYNC_MMU : # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE r = hv_enabled ; # elif defined ( KVM_ARCH_WANT_MMU_NOTIFIER ) r = 1 ; # else r = 0 ; # endif break ; # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_HTAB_FD : r = hv_enabled ; break ; # endif case KVM_CAP_NR_VCPUS : if ( hv_enabled ) r = num_present_cpus ( ) ; else r = num_online_cpus ( ) ; break ; case KVM_CAP_NR_MEMSLOTS : r = KVM_USER_MEM_SLOTS ; break ; case KVM_CAP_MAX_VCPUS : r = KVM_MAX_VCPUS ; break ; # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_PPC_GET_SMMU_INFO : r = 1 ; break ; case KVM_CAP_SPAPR_MULTITCE : r = 1 ; break ; case KVM_CAP_SPAPR_RESIZE_HPT : r = ! ! hv_enabled && ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ; break ; # endif # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE case KVM_CAP_PPC_FWNMI : r = hv_enabled ; break ; # endif case KVM_CAP_PPC_HTM : r = cpu_has_feature ( CPU_FTR_TM_COMP ) && <S2SV_StartBug> is_kvmppc_hv_enabled ( kvm ) ; <S2SV_EndBug> break ; default : r = 0 ; break ; } return r ; }
CWE-000 ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <S2SV_StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <S2SV_EndBug> return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , "*()" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : "" ) ; return ret_error ; } TRACE ( ENTRIES , "subtree<S2SV_blank>search<S2SV_blank>(%s):<S2SV_blank>done\\n" , ldap -> filter . buf ? ldap -> filter . buf : "" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , "Access<S2SV_blank>to<S2SV_blank>use<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>been<S2SV_blank>granted\\n" , conn -> validator -> user . buf ) ; return ret_ok ; }
CWE-119 void vp9_rc_postencode_update_drop_frame ( VP9_COMP * cpi ) { update_buffer_level ( cpi , 0 ) ; <S2SV_StartBug> cpi -> common . last_frame_type = cpi -> common . frame_type ; <S2SV_EndBug> cpi -> rc . frames_since_key ++ ; cpi -> rc . frames_to_key -- ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-264 static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; <S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ; if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ; return false ; }
CWE-20 static int validate_event ( struct pmu_hw_events * hw_events , struct perf_event * event ) { struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_StartBug> struct pmu * leader_pmu = event -> group_leader -> pmu ; <S2SV_EndBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; return armpmu -> get_event_idx ( hw_events , event ) >= 0 ; }
CWE-20 void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , ":<S2SV_blank>%zu<S2SV_blank>[%s]" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? "file" : "buff" ) ; }
CWE-200 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; <S2SV_StartBug> if ( ! replay_esn || ! rp ) <S2SV_EndBug> return 0 ; up = nla_data ( rp ) ; <S2SV_StartBug> if ( xfrm_replay_state_esn_len ( replay_esn ) != <S2SV_EndBug> <S2SV_StartBug> xfrm_replay_state_esn_len ( up ) ) <S2SV_EndBug> return - EINVAL ; return 0 ; }
CWE-119 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { <S2SV_StartBug> c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> aligned_height = FFALIGN ( c -> height , 16 ) ; <S2SV_EndBug> av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { c -> tile_stride = FFALIGN ( c -> tile_width , 16 ) * 3 ; aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }
CWE-000 IHEVCD_ERROR_T ihevcd_mv_buf_mgr_add_bufs ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 i ; WORD32 max_dpb_size ; WORD32 mv_bank_size_allocated ; WORD32 pic_mv_bank_size ; sps_t * ps_sps ; UWORD8 * pu1_buf ; mv_buf_t * ps_mv_buf ; ps_sps = ps_codec -> s_parse . ps_sps ; max_dpb_size = ps_sps -> ai1_sps_max_dec_pic_buffering [ ps_sps -> i1_sps_max_sub_layers - 1 ] ; max_dpb_size ++ ; <S2SV_StartBug> pu1_buf = ( UWORD8 * ) ps_codec -> pv_mv_bank_buf_base ; <S2SV_EndBug> ps_mv_buf = ( mv_buf_t * ) pu1_buf ; pu1_buf += max_dpb_size * sizeof ( mv_buf_t ) ; ps_codec -> ps_mv_buf = ps_mv_buf ; mv_bank_size_allocated = ps_codec -> i4_total_mv_bank_size - max_dpb_size * sizeof ( mv_buf_t ) ; pic_mv_bank_size = ihevcd_get_pic_mv_bank_size ( ALIGN64 ( ps_sps -> i2_pic_width_in_luma_samples ) * ALIGN64 ( ps_sps -> i2_pic_height_in_luma_samples ) ) ; for ( i = 0 ; i < max_dpb_size ; i ++ ) { WORD32 buf_ret ; WORD32 num_pu ; WORD32 num_ctb ; WORD32 pic_size ; pic_size = ALIGN64 ( ps_sps -> i2_pic_width_in_luma_samples ) * ALIGN64 ( ps_sps -> i2_pic_height_in_luma_samples ) ; num_pu = pic_size / ( MIN_PU_SIZE * MIN_PU_SIZE ) ; num_ctb = pic_size / ( MIN_CTB_SIZE * MIN_CTB_SIZE ) ; mv_bank_size_allocated -= pic_mv_bank_size ; if ( mv_bank_size_allocated < 0 ) { ps_codec -> s_parse . i4_error_code = IHEVCD_INSUFFICIENT_MEM_MVBANK ; return IHEVCD_INSUFFICIENT_MEM_MVBANK ; } ps_mv_buf -> pu4_pic_pu_idx = ( UWORD32 * ) pu1_buf ; pu1_buf += ( num_ctb + 1 ) * sizeof ( WORD32 ) ; ps_mv_buf -> pu1_pic_pu_map = pu1_buf ; pu1_buf += num_pu ; ps_mv_buf -> pu1_pic_slice_map = ( UWORD16 * ) pu1_buf ; pu1_buf += ALIGN4 ( num_ctb * sizeof ( UWORD16 ) ) ; ps_mv_buf -> ps_pic_pu = ( pu_t * ) pu1_buf ; pu1_buf += num_pu * sizeof ( pu_t ) ; buf_ret = ihevc_buf_mgr_add ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , ps_mv_buf , i ) ; if ( 0 != buf_ret ) { ps_codec -> s_parse . i4_error_code = IHEVCD_BUF_MGR_ERROR ; return IHEVCD_BUF_MGR_ERROR ; } ps_mv_buf ++ ; } return ret ; }
CWE-476 static int pcd_detect ( void ) { char id [ 18 ] ; int k , unit ; struct pcd_unit * cd ; printk ( "%s:<S2SV_blank>%s<S2SV_blank>version<S2SV_blank>%s,<S2SV_blank>major<S2SV_blank>%d,<S2SV_blank>nice<S2SV_blank>%d\\n" , name , name , PCD_VERSION , major , nice ) ; par_drv = pi_register_driver ( name ) ; if ( ! par_drv ) { pr_err ( "failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>%s<S2SV_blank>driver\\n" , name ) ; return - 1 ; } k = 0 ; if ( pcd_drive_count == 0 ) { cd = pcd ; if ( pi_init ( cd -> pi , 1 , - 1 , - 1 , - 1 , - 1 , - 1 , pcd_buffer , PI_PCD , verbose , cd -> name ) ) { if ( ! pcd_probe ( cd , - 1 , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } else { for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { int * conf = * drives [ unit ] ; if ( ! conf [ D_PRT ] ) continue ; if ( ! pi_init ( cd -> pi , 0 , conf [ D_PRT ] , conf [ D_MOD ] , conf [ D_UNI ] , conf [ D_PRO ] , conf [ D_DLY ] , pcd_buffer , PI_PCD , verbose , cd -> name ) ) continue ; if ( ! pcd_probe ( cd , conf [ D_SLV ] , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } if ( k ) return 0 ; printk ( "%s:<S2SV_blank>No<S2SV_blank>CD-ROM<S2SV_blank>drive<S2SV_blank>found\\n" , name ) ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { <S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> cd -> disk -> queue = NULL ; blk_mq_free_tag_set ( & cd -> tag_set ) ; put_disk ( cd -> disk ) ; } pi_unregister_driver ( par_drv ) ; return - 1 ; }
CWE-119 static int check_dual_ref_flags ( VP9_COMP * cpi ) { const int ref_flags = cpi -> ref_frame_flags ; <S2SV_StartBug> if ( vp9_segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> return 0 ; } else { return ( ! ! ( ref_flags & VP9_GOLD_FLAG ) + ! ! ( ref_flags & VP9_LAST_FLAG ) + ! ! ( ref_flags & VP9_ALT_FLAG ) ) >= 2 ; } }
CWE-416 static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if ( ! ( cmpt -> data = jas_strdup ( jas_tvparser_getval ( tvp ) ) ) ) { return - 1 ; } break ; } } <S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { goto error ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> error : if ( cmpt ) { mif_cmpt_destroy ( cmpt ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return - 1 ; }
CWE-125 static struct pid * good_sigevent ( sigevent_t * event ) { struct task_struct * rtn = current -> group_leader ; <S2SV_StartBug> if ( ( event -> sigev_notify & SIGEV_THREAD_ID ) && <S2SV_EndBug> <S2SV_StartBug> ( ! ( rtn = find_task_by_vpid ( event -> sigev_notify_thread_id ) ) || <S2SV_EndBug> <S2SV_StartBug> ! same_thread_group ( rtn , current ) || <S2SV_EndBug> ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_SIGNAL ) ) return NULL ; <S2SV_StartBug> if ( ( ( event -> sigev_notify & ~ SIGEV_THREAD_ID ) != SIGEV_NONE ) && <S2SV_EndBug> <S2SV_StartBug> ( ( event -> sigev_signo <= 0 ) || ( event -> sigev_signo > SIGRTMAX ) ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> return task_pid ( rtn ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static ssize_t macvtap_get_user ( struct macvtap_queue * q , struct msghdr * m , const struct iovec * iv , unsigned long total_len , size_t count , int noblock ) { struct sk_buff * skb ; struct macvlan_dev * vlan ; unsigned long len = total_len ; int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ; <S2SV_StartBug> int copylen ; <S2SV_EndBug> bool zerocopy = false ; if ( q -> flags & IFF_VNET_HDR ) { vnet_hdr_len = q -> vnet_hdr_sz ; err = - EINVAL ; if ( len < vnet_hdr_len ) goto err ; len -= vnet_hdr_len ; err = memcpy_fromiovecend ( ( void * ) & vnet_hdr , iv , 0 , sizeof ( vnet_hdr ) ) ; if ( err < 0 ) goto err ; if ( ( vnet_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) && vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 > vnet_hdr . hdr_len ) vnet_hdr . hdr_len = vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 ; err = - EINVAL ; if ( vnet_hdr . hdr_len > len ) goto err ; } err = - EINVAL ; if ( unlikely ( len < ETH_HLEN ) ) goto err ; <S2SV_StartBug> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) <S2SV_EndBug> zerocopy = true ; if ( zerocopy ) { <S2SV_StartBug> copylen = vnet_hdr . hdr_len ; <S2SV_EndBug> if ( ! copylen ) copylen = GOODCOPY_LEN ; } else copylen = len ; skb = macvtap_alloc_skb ( & q -> sk , NET_IP_ALIGN , copylen , vnet_hdr . hdr_len , noblock , & err ) ; if ( ! skb ) goto err ; if ( zerocopy ) err = zerocopy_sg_from_iovec ( skb , iv , vnet_hdr_len , count ) ; else err = skb_copy_datagram_from_iovec ( skb , 0 , iv , vnet_hdr_len , len ) ; if ( err ) goto err_kfree ; skb_set_network_header ( skb , ETH_HLEN ) ; skb_reset_mac_header ( skb ) ; skb -> protocol = eth_hdr ( skb ) -> h_proto ; if ( vnet_hdr_len ) { err = macvtap_skb_from_vnet_hdr ( skb , & vnet_hdr ) ; if ( err ) goto err_kfree ; } rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( zerocopy ) { skb_shinfo ( skb ) -> destructor_arg = m -> msg_control ; skb_shinfo ( skb ) -> tx_flags |= SKBTX_DEV_ZEROCOPY ; } if ( vlan ) macvlan_start_xmit ( skb , vlan -> dev ) ; else kfree_skb ( skb ) ; rcu_read_unlock_bh ( ) ; return total_len ; err_kfree : kfree_skb ( skb ) ; err : rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( vlan ) vlan -> dev -> stats . tx_dropped ++ ; rcu_read_unlock_bh ( ) ; return err ; }
CWE-000 static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { struct mount * n , * p ; bool done ; for ( n = m ; ; n = p ) { p = n -> mnt_master ; if ( p == dest_master || IS_MNT_MARKED ( p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-119 static void update_layer_contexts ( VP8_COMP * cpi ) { VP8_CONFIG * oxcf = & cpi -> oxcf ; if ( oxcf -> number_of_layers > 1 ) { unsigned int i ; double prev_layer_framerate = 0 ; assert ( oxcf -> number_of_layers <= VPX_TS_MAX_LAYERS ) ; <S2SV_StartBug> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <S2SV_EndBug> { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / oxcf -> rate_decimator [ i ] ; lc -> target_bandwidth = oxcf -> target_bitrate [ i ] * 1000 ; lc -> starting_buffer_level = rescale ( ( int ) oxcf -> starting_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> optimal_buffer_level == 0 ) lc -> optimal_buffer_level = lc -> target_bandwidth / 8 ; else lc -> optimal_buffer_level = rescale ( ( int ) oxcf -> optimal_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> maximum_buffer_size == 0 ) lc -> maximum_buffer_size = lc -> target_bandwidth / 8 ; else lc -> maximum_buffer_size = rescale ( ( int ) oxcf -> maximum_buffer_size_in_ms , lc -> target_bandwidth , 1000 ) ; if ( i > 0 ) lc -> avg_frame_size_for_layer = ( int ) ( ( oxcf -> target_bitrate [ i ] - oxcf -> target_bitrate [ i - 1 ] ) * 1000 / ( lc -> framerate - prev_layer_framerate ) ) ; prev_layer_framerate = lc -> framerate ; } } }
CWE-362 int insn_get_code_seg_params ( struct pt_regs * regs ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; if ( v8086_mode ( regs ) ) return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; sel = get_segment_selector ( regs , INAT_SEG_REG_CS ) ; if ( sel < 0 ) return sel ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; case 1 : return INSN_CODE_SEG_PARAMS ( 4 , 4 ) ; case 2 : return INSN_CODE_SEG_PARAMS ( 4 , 8 ) ; case 3 : default : return - EINVAL ; } }
CWE-20 static int mISDN_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sk_buff * skb ; <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_mISDN * maddr ; int copied , err ; if ( * debug & DEBUG_SOCKET ) printk ( KERN_DEBUG "%s:<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>flags<S2SV_blank>%x<S2SV_blank>ch.nr<S2SV_blank>%d,<S2SV_blank>proto<S2SV_blank>%x\\n" , __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , sk -> sk_protocol ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; if ( sk -> sk_state == MISDN_CLOSED ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; maddr -> family = AF_ISDN ; maddr -> dev = _pms ( sk ) -> dev -> id ; if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) || ( sk -> sk_protocol == ISDN_P_LAPD_NT ) ) { maddr -> channel = ( mISDN_HEAD_ID ( skb ) >> 16 ) & 0xff ; maddr -> tei = ( mISDN_HEAD_ID ( skb ) >> 8 ) & 0xff ; maddr -> sapi = mISDN_HEAD_ID ( skb ) & 0xff ; } else { maddr -> channel = _pms ( sk ) -> ch . nr ; maddr -> sapi = _pms ( sk ) -> ch . addr & 0xFF ; maddr -> tei = ( _pms ( sk ) -> ch . addr >> 8 ) & 0xFF ; } <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug> printk ( KERN_WARNING "%s:<S2SV_blank>too<S2SV_blank>small<S2SV_blank>namelen<S2SV_blank>%d\\n" , __func__ , msg -> msg_namelen ) ; msg -> msg_namelen = 0 ; } copied = skb -> len + MISDN_HEADER_LEN ; if ( len < copied ) { if ( flags & MSG_PEEK ) atomic_dec ( & skb -> users ) ; else skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - ENOSPC ; } memcpy ( skb_push ( skb , MISDN_HEADER_LEN ) , mISDN_HEAD_P ( skb ) , MISDN_HEADER_LEN ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; mISDN_sock_cmsg ( sk , msg , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
CWE-190 static enum hrtimer_restart posix_timer_fn ( struct hrtimer * timer ) { struct k_itimer * timr ; unsigned long flags ; int si_private = 0 ; enum hrtimer_restart ret = HRTIMER_NORESTART ; timr = container_of ( timer , struct k_itimer , it . real . timer ) ; spin_lock_irqsave ( & timr -> it_lock , flags ) ; timr -> it_active = 0 ; if ( timr -> it_interval != 0 ) si_private = ++ timr -> it_requeue_pending ; if ( posix_timer_event ( timr , si_private ) ) { if ( timr -> it_interval != 0 ) { ktime_t now = hrtimer_cb_get_time ( timer ) ; # ifdef CONFIG_HIGH_RES_TIMERS { ktime_t kj = NSEC_PER_SEC / HZ ; if ( timr -> it_interval < kj ) now = ktime_add ( now , kj ) ; } # endif <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) <S2SV_EndBug> hrtimer_forward ( timer , now , timr -> it_interval ) ; ret = HRTIMER_RESTART ; ++ timr -> it_requeue_pending ; timr -> it_active = 1 ; } } unlock_timer ( timr , flags ) ; return ret ; }
CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
CWE-476 static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { <S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-20 static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; if ( colors . a [ code ] && image -> matte == MagickFalse ) image -> matte = MagickTrue ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 8 ) ; <S2SV_EndBug> return MagickTrue ; }
CWE-125 void beep_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { <S2SV_StartBug> if ( l_strnstart ( "MSG" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>BEEP<S2SV_blank>MSG" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( "RPY<S2SV_blank>" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>BEEP<S2SV_blank>RPY" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( "ERR<S2SV_blank>" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>BEEP<S2SV_blank>ERR" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( "ANS<S2SV_blank>" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>BEEP<S2SV_blank>ANS" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( "NUL<S2SV_blank>" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>BEEP<S2SV_blank>NUL" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( "SEQ<S2SV_blank>" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>BEEP<S2SV_blank>SEQ" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( "END" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>BEEP<S2SV_blank>END" ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>BEEP<S2SV_blank>(payload<S2SV_blank>or<S2SV_blank>undecoded)" ) ) ; }
CWE-000 static struct fileIdentDesc * udf_find_entry ( struct inode * dir , const struct qstr * child , struct udf_fileident_bh * fibh , struct fileIdentDesc * cfi ) { struct fileIdentDesc * fi = NULL ; loff_t f_pos ; int block , flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint8_t lfi ; uint16_t liu ; loff_t size ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; struct extent_position epos = { } ; struct udf_inode_info * dinfo = UDF_I ( dir ) ; int isdotdot = child -> len == 2 && child -> name [ 0 ] == '.' && child -> name [ 1 ] == '.' ; size = udf_ext0_offset ( dir ) + dir -> i_size ; f_pos = udf_ext0_offset ( dir ) ; fibh -> sbh = fibh -> ebh = NULL ; fibh -> soffset = fibh -> eoffset = f_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( dinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , f_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) goto out_err ; block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else offset = 0 ; fibh -> sbh = fibh -> ebh = udf_tread ( dir -> i_sb , block ) ; if ( ! fibh -> sbh ) goto out_err ; } fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) goto out_err ; while ( f_pos < size ) { fi = udf_fileident_read ( dir , & f_pos , fibh , cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out_err ; liu = le16_to_cpu ( cfi -> lengthOfImpUse ) ; lfi = cfi -> lengthFileIdent ; if ( fibh -> sbh == fibh -> ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh -> soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) nameptr = ( uint8_t * ) ( fibh -> ebh -> b_data + poffset - lfi ) ; else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh -> ebh -> b_data , poffset ) ; } } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_PARENT ) && isdotdot ) goto out_ok ; if ( ! lfi ) continue ; <S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ; } out_err : fi = NULL ; if ( fibh -> sbh != fibh -> ebh ) brelse ( fibh -> ebh ) ; brelse ( fibh -> sbh ) ; out_ok : brelse ( epos . bh ) ; kfree ( fname ) ; return fi ; }
CWE-000 int jpc_bitstream_putbits ( jpc_bitstream_t * bitstream , int n , long v ) { int m ; <S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ; m = n - 1 ; while ( -- n >= 0 ) { if ( jpc_bitstream_putbit ( bitstream , ( v >> m ) & 1 ) == EOF ) { return EOF ; } v <<= 1 ; } return 0 ; }
CWE-200 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , CB_TRGCLS_LEN , CB_TRGCLS ( skb ) ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
CWE-119 static void update_image_md5 ( const vpx_image_t * img , const int planes [ 3 ] , MD5Context * md5 ) { int i , y ; for ( i = 0 ; i < 3 ; ++ i ) { const int plane = planes [ i ] ; const unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; <S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> const int h = vpx_img_plane_height ( img , plane ) ; for ( y = 0 ; y < h ; ++ y ) { MD5Update ( md5 , buf , w ) ; buf += stride ; } } }
CWE-119 int vp9_release_frame_buffer ( void * cb_priv , vpx_codec_frame_buffer_t * fb ) { InternalFrameBuffer * const int_fb = ( InternalFrameBuffer * ) fb -> priv ; ( void ) cb_priv ; <S2SV_StartBug> int_fb -> in_use = 0 ; <S2SV_EndBug> return 0 ; }
CWE-119 <S2SV_StartBug> void vp9_fht16x16_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { __m128i in0 [ 16 ] , in1 [ 16 ] ; switch ( tx_type ) { case DCT_DCT : <S2SV_StartBug> vp9_fdct16x16_sse2 ( input , output , stride ) ; <S2SV_EndBug> break ; case ADST_DCT : load_buffer_16x16 ( input , in0 , in1 , stride ) ; fadst16_sse2 ( in0 , in1 ) ; right_shift_16x16 ( in0 , in1 ) ; fdct16_sse2 ( in0 , in1 ) ; write_buffer_16x16 ( output , in0 , in1 , 16 ) ; break ; case DCT_ADST : load_buffer_16x16 ( input , in0 , in1 , stride ) ; fdct16_sse2 ( in0 , in1 ) ; right_shift_16x16 ( in0 , in1 ) ; fadst16_sse2 ( in0 , in1 ) ; write_buffer_16x16 ( output , in0 , in1 , 16 ) ; break ; case ADST_ADST : load_buffer_16x16 ( input , in0 , in1 , stride ) ; fadst16_sse2 ( in0 , in1 ) ; right_shift_16x16 ( in0 , in1 ) ; fadst16_sse2 ( in0 , in1 ) ; write_buffer_16x16 ( output , in0 , in1 , 16 ) ; break ; default : assert ( 0 ) ; break ; } }
CWE-20 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( "%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> return 1 ; <S2SV_EndBug> case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return 1 ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_PREEMPTION_TIMER : return vmcs12 -> pin_based_vm_exec_control & PIN_BASED_VMX_PREEMPTION_TIMER ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }
CWE-119 <S2SV_StartBug> void vp9_fht4x4_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { __m128i in [ 4 ] ; switch ( tx_type ) { case DCT_DCT : <S2SV_StartBug> vp9_fdct4x4_sse2 ( input , output , stride ) ; <S2SV_EndBug> break ; case ADST_DCT : load_buffer_4x4 ( input , in , stride ) ; fadst4_sse2 ( in ) ; fdct4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; case DCT_ADST : load_buffer_4x4 ( input , in , stride ) ; fdct4_sse2 ( in ) ; fadst4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; case ADST_ADST : load_buffer_4x4 ( input , in , stride ) ; fadst4_sse2 ( in ) ; fadst4_sse2 ( in ) ; write_buffer_4x4 ( output , in ) ; break ; default : assert ( 0 ) ; break ; } }
CWE-189 static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , "invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }
CWE-000 static int hwahc_security_create ( struct hwahc * hwahc ) { int result ; struct wusbhc * wusbhc = & hwahc -> wusbhc ; struct usb_device * usb_dev = hwahc -> wa . usb_dev ; struct device * dev = & usb_dev -> dev ; struct usb_security_descriptor * secd ; struct usb_encryption_descriptor * etd ; void * itr , * top ; size_t itr_size , needed , bytes ; u8 index ; char buf [ 64 ] ; index = ( usb_dev -> actconfig - usb_dev -> config ) / sizeof ( usb_dev -> config [ 0 ] ) ; itr = usb_dev -> rawdescriptors [ index ] ; itr_size = le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ; top = itr + itr_size ; result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , <S2SV_StartBug> USB_DT_SECURITY , ( void * * ) & secd ) ; <S2SV_EndBug> if ( result == - 1 ) { dev_warn ( dev , "BUG?<S2SV_blank>WUSB<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>security<S2SV_blank>descriptors\\n" ) ; return 0 ; } needed = sizeof ( * secd ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , "BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>" "descriptor<S2SV_blank>header<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , top - ( void * ) secd , needed ) ; return 0 ; } needed = le16_to_cpu ( secd -> wTotalLength ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , "BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>" "descriptors<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , top - ( void * ) secd , needed ) ; return 0 ; } itr = ( void * ) secd + sizeof ( * secd ) ; top = ( void * ) secd + le16_to_cpu ( secd -> wTotalLength ) ; index = 0 ; bytes = 0 ; while ( itr < top ) { etd = itr ; if ( top - itr < sizeof ( * etd ) ) { dev_err ( dev , "BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>security<S2SV_blank>descriptor;<S2SV_blank>" "not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>left)\\n" , top - itr , sizeof ( * etd ) ) ; break ; } if ( etd -> bLength < sizeof ( * etd ) ) { dev_err ( dev , "BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>encryption<S2SV_blank>descriptor;<S2SV_blank>" "descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short<S2SV_blank>" "(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , ( size_t ) etd -> bLength , sizeof ( * etd ) ) ; break ; } itr += etd -> bLength ; bytes += snprintf ( buf + bytes , sizeof ( buf ) - bytes , "%s<S2SV_blank>(0x%02x)<S2SV_blank>" , wusb_et_name ( etd -> bEncryptionType ) , etd -> bEncryptionValue ) ; wusbhc -> ccm1_etd = etd ; } dev_info ( dev , "supported<S2SV_blank>encryption<S2SV_blank>types:<S2SV_blank>%s\\n" , buf ) ; if ( wusbhc -> ccm1_etd == NULL ) { dev_err ( dev , "E:<S2SV_blank>host<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>CCM-1<S2SV_blank>crypto\\n" ) ; return 0 ; } return 0 ; }
CWE-119 <S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> fadst16_8col ( in0 ) ; fadst16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }
CWE-264 static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }
CWE-000 struct key * key_alloc ( struct key_type * type , const char * desc , kuid_t uid , kgid_t gid , const struct cred * cred , key_perm_t perm , unsigned long flags , struct key_restriction * restrict_link ) { struct key_user * user = NULL ; struct key * key ; size_t desclen , quotalen ; int ret ; key = ERR_PTR ( - EINVAL ) ; if ( ! desc || ! * desc ) goto error ; if ( type -> vet_description ) { ret = type -> vet_description ( desc ) ; if ( ret < 0 ) { key = ERR_PTR ( ret ) ; goto error ; } } desclen = strlen ( desc ) ; quotalen = desclen + 1 + type -> def_datalen ; user = key_user_lookup ( uid ) ; if ( ! user ) goto no_memory_1 ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & user -> lock ) ; if ( ! ( flags & KEY_ALLOC_QUOTA_OVERRUN ) ) { if ( user -> qnkeys + 1 >= maxkeys || user -> qnbytes + quotalen >= maxbytes || user -> qnbytes + quotalen < user -> qnbytes ) goto no_quota ; } user -> qnkeys ++ ; user -> qnbytes += quotalen ; spin_unlock ( & user -> lock ) ; } key = kmem_cache_zalloc ( key_jar , GFP_KERNEL ) ; if ( ! key ) goto no_memory_2 ; key -> index_key . desc_len = desclen ; key -> index_key . description = kmemdup ( desc , desclen + 1 , GFP_KERNEL ) ; if ( ! key -> index_key . description ) goto no_memory_3 ; refcount_set ( & key -> usage , 1 ) ; init_rwsem ( & key -> sem ) ; lockdep_set_class ( & key -> sem , & type -> lock_class ) ; key -> index_key . type = type ; key -> user = user ; key -> quotalen = quotalen ; key -> datalen = type -> def_datalen ; key -> uid = uid ; key -> gid = gid ; key -> perm = perm ; key -> restrict_link = restrict_link ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) key -> flags |= 1 << KEY_FLAG_IN_QUOTA ; if ( flags & KEY_ALLOC_BUILT_IN ) key -> flags |= 1 << KEY_FLAG_BUILTIN ; <S2SV_StartBug> # ifdef KEY_DEBUGGING <S2SV_EndBug> key -> magic = KEY_DEBUG_MAGIC ; # endif ret = security_key_alloc ( key , cred , flags ) ; if ( ret < 0 ) goto security_error ; atomic_inc ( & user -> nkeys ) ; key_alloc_serial ( key ) ; error : return key ; security_error : kfree ( key -> description ) ; kmem_cache_free ( key_jar , key ) ; if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { spin_lock ( & user -> lock ) ; user -> qnkeys -- ; user -> qnbytes -= quotalen ; spin_unlock ( & user -> lock ) ; } key_user_put ( user ) ; key = ERR_PTR ( ret ) ; goto error ; no_memory_3 : kmem_cache_free ( key_jar , key ) ; no_memory_2 : if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { spin_lock ( & user -> lock ) ; user -> qnkeys -- ; user -> qnbytes -= quotalen ; spin_unlock ( & user -> lock ) ; } key_user_put ( user ) ; no_memory_1 : key = ERR_PTR ( - ENOMEM ) ; goto error ; no_quota : spin_unlock ( & user -> lock ) ; key_user_put ( user ) ; key = ERR_PTR ( - EDQUOT ) ; goto error ; }
CWE-264 static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , "/cgroup" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = "/" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) { <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IFDIR | 00755 ; k = cgfs_get_key ( controller , cgroup , "tasks" ) ; if ( ! k ) { sb -> st_uid = sb -> st_gid = 0 ; } else { sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; } free_key ( k ) ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { sb -> st_mode = S_IFREG | k -> mode ; sb -> st_nlink = 1 ; sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; sb -> st_size = 0 ; free_key ( k ) ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { ret = - EACCES ; goto out ; } ret = 0 ; } out : free ( cgdir ) ; return ret ; }
CWE-190 static void Process_ipfix_template_add ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { input_translation_t * translation_table ; ipfix_template_record_t * ipfix_template_record ; ipfix_template_elements_std_t * NextElement ; int i ; while ( size_left ) { uint32_t table_id , count , size_required ; uint32_t num_extensions = 0 ; <S2SV_StartBug> if ( size_left && size_left < 4 ) { <S2SV_EndBug> LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; table_id = ntohs ( ipfix_template_record -> TemplateID ) ; count = ntohs ( ipfix_template_record -> FieldCount ) ; dbg_printf ( "\\n[%u]<S2SV_blank>Template<S2SV_blank>ID:<S2SV_blank>%u\\n" , exporter -> info . id , table_id ) ; dbg_printf ( "FieldCount:<S2SV_blank>%u<S2SV_blank>buffersize:<S2SV_blank>%u\\n" , count , size_left ) ; memset ( ( void * ) cache . common_extensions , 0 , ( Max_num_extensions + 1 ) * sizeof ( uint32_t ) ) ; memset ( ( void * ) cache . lookup_info , 0 , 65536 * sizeof ( struct element_param_s ) ) ; for ( i = 1 ; ipfix_element_map [ i ] . id != 0 ; i ++ ) { uint32_t Type = ipfix_element_map [ i ] . id ; if ( ipfix_element_map [ i ] . id == ipfix_element_map [ i - 1 ] . id ) continue ; cache . lookup_info [ Type ] . index = i ; } cache . input_order = calloc ( count , sizeof ( struct order_s ) ) ; if ( ! cache . input_order ) { LogError ( "Process_ipfix:<S2SV_blank>Panic!<S2SV_blank>malloc():<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d:<S2SV_blank>%s" , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } cache . input_count = count ; size_required = 4 * count ; if ( size_left < size_required ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , exporter -> info . id , size_required , size_left ) ; dbg_printf ( "ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , size_required , size_left ) ; return ; } NextElement = ( ipfix_template_elements_std_t * ) ipfix_template_record -> elements ; for ( i = 0 ; i < count ; i ++ ) { uint16_t Type , Length ; uint32_t ext_id ; int Enterprise ; Type = ntohs ( NextElement -> Type ) ; Length = ntohs ( NextElement -> Length ) ; Enterprise = Type & 0x8000 ? 1 : 0 ; Type = Type & 0x7FFF ; ext_id = MapElement ( Type , Length , i ) ; if ( ext_id && extension_descriptor [ ext_id ] . enabled ) { if ( cache . common_extensions [ ext_id ] == 0 ) { cache . common_extensions [ ext_id ] = 1 ; num_extensions ++ ; } } if ( Enterprise ) { ipfix_template_elements_e_t * e = ( ipfix_template_elements_e_t * ) NextElement ; size_required += 4 ; if ( size_left < size_required ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , exporter -> info . id , size_required , size_left ) ; dbg_printf ( "ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , size_required , size_left ) ; return ; } if ( ntohl ( e -> EnterpriseNumber ) == IPFIX_ReverseInformationElement ) { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>Reverse<S2SV_blank>Information<S2SV_blank>Element:<S2SV_blank>%u\\n" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; } else { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>EnterpriseNumber:<S2SV_blank>%u\\n" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; } e ++ ; NextElement = ( ipfix_template_elements_std_t * ) e ; } else { dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>0,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u\\n" , i , Type , Length ) ; NextElement ++ ; } } dbg_printf ( "Processed:<S2SV_blank>%u\\n" , size_required ) ; if ( compact_input_order ( ) ) { if ( extension_descriptor [ EX_ROUTER_IP_v4 ] . enabled ) { if ( cache . common_extensions [ EX_ROUTER_IP_v4 ] == 0 ) { cache . common_extensions [ EX_ROUTER_IP_v4 ] = 1 ; num_extensions ++ ; } dbg_printf ( "Add<S2SV_blank>sending<S2SV_blank>router<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>(%s)<S2SV_blank>=><S2SV_blank>Extension:<S2SV_blank>%u\\n" , fs -> sa_family == PF_INET6 ? "ipv6" : "ipv4" , EX_ROUTER_IP_v4 ) ; } extension_descriptor [ EX_ROUTER_ID ] . enabled = 0 ; if ( extension_descriptor [ EX_RECEIVED ] . enabled ) { if ( cache . common_extensions [ EX_RECEIVED ] == 0 ) { cache . common_extensions [ EX_RECEIVED ] = 1 ; num_extensions ++ ; } dbg_printf ( "Force<S2SV_blank>add<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>time,<S2SV_blank>Extension:<S2SV_blank>%u\\n" , EX_RECEIVED ) ; } # ifdef DEVEL { int i ; for ( i = 4 ; extension_descriptor [ i ] . id ; i ++ ) { if ( cache . common_extensions [ i ] ) { printf ( "Enabled<S2SV_blank>extension:<S2SV_blank>%i\\n" , i ) ; } } } # endif translation_table = setup_translation_table ( exporter , table_id ) ; if ( translation_table -> extension_map_changed ) { dbg_printf ( "Translation<S2SV_blank>Table<S2SV_blank>changed!<S2SV_blank>Add<S2SV_blank>extension<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n" , translation_table -> extension_info . map -> map_id ) ; AddExtensionMap ( fs , translation_table -> extension_info . map ) ; translation_table -> extension_map_changed = 0 ; dbg_printf ( "Translation<S2SV_blank>Table<S2SV_blank>added!<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n" , translation_table -> extension_info . map -> map_id ) ; } if ( ! reorder_sequencer ( translation_table ) ) { LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>reorder<S2SV_blank>sequencer.<S2SV_blank>Remove<S2SV_blank>table<S2SV_blank>id:<S2SV_blank>%u" , exporter -> info . id , table_id ) ; remove_translation_table ( fs , exporter , table_id ) ; } } else { dbg_printf ( "Template<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>any<S2SV_blank>common<S2SV_blank>fields<S2SV_blank>-<S2SV_blank>skip\\n" ) ; } size_left -= size_required ; DataPtr = DataPtr + size_required + 4 ; if ( size_left < 4 ) { dbg_printf ( "Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n" , size_left ) ; size_left = 0 ; } free ( cache . input_order ) ; cache . input_order = NULL ; } }
CWE-119 int VP8_UVSSE ( MACROBLOCK * x ) { unsigned char * uptr , * vptr ; unsigned char * upred_ptr = ( * ( x -> block [ 16 ] . base_src ) + x -> block [ 16 ] . src ) ; unsigned char * vpred_ptr = ( * ( x -> block [ 20 ] . base_src ) + x -> block [ 20 ] . src ) ; int uv_stride = x -> block [ 16 ] . src_stride ; unsigned int sse1 = 0 ; unsigned int sse2 = 0 ; int mv_row = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . row ; int mv_col = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . col ; int offset ; int pre_stride = x -> e_mbd . pre . uv_stride ; if ( mv_row < 0 ) mv_row -= 1 ; else mv_row += 1 ; if ( mv_col < 0 ) mv_col -= 1 ; else mv_col += 1 ; mv_row /= 2 ; mv_col /= 2 ; offset = ( mv_row >> 3 ) * pre_stride + ( mv_col >> 3 ) ; uptr = x -> e_mbd . pre . u_buffer + offset ; vptr = x -> e_mbd . pre . v_buffer + offset ; if ( ( mv_row | mv_col ) & 7 ) { <S2SV_StartBug> vp8_sub_pixel_variance8x8 ( uptr , pre_stride , <S2SV_EndBug> mv_col & 7 , mv_row & 7 , upred_ptr , uv_stride , & sse2 ) ; <S2SV_StartBug> vp8_sub_pixel_variance8x8 ( vptr , pre_stride , <S2SV_EndBug> mv_col & 7 , mv_row & 7 , vpred_ptr , uv_stride , & sse1 ) ; sse2 += sse1 ; } else { <S2SV_StartBug> vp8_variance8x8 ( uptr , pre_stride , <S2SV_EndBug> upred_ptr , uv_stride , & sse2 ) ; <S2SV_StartBug> vp8_variance8x8 ( vptr , pre_stride , <S2SV_EndBug> vpred_ptr , uv_stride , & sse1 ) ; sse2 += sse1 ; } return sse2 ; }
CWE-119 static int64_t rd_pick_intra_sbuv_mode ( VP9_COMP * cpi , MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , TX_SIZE max_tx_size ) { MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> MB_PREDICTION_MODE mode_selected = DC_PRED ; int64_t best_rd = INT64_MAX , this_rd ; int this_rate_tokenonly , this_rate , s ; <S2SV_StartBug> int64_t this_distortion , this_sse ; <S2SV_EndBug> for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { if ( ! ( cpi -> sf . intra_uv_mode_mask [ max_tx_size ] & ( 1 << mode ) ) ) continue ; xd -> mi [ 0 ] -> mbmi . uv_mode = mode ; <S2SV_StartBug> super_block_uvrd ( cpi , x , & this_rate_tokenonly , <S2SV_EndBug> <S2SV_StartBug> & this_distortion , & s , & this_sse , bsize , best_rd ) ; <S2SV_EndBug> if ( this_rate_tokenonly == INT_MAX ) continue ; this_rate = this_rate_tokenonly + <S2SV_StartBug> x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ; <S2SV_EndBug> this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * distortion = this_distortion ; * skippable = s ; <S2SV_StartBug> if ( ! x -> select_txfm_size ) { <S2SV_EndBug> int i ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; for ( i = 1 ; i < MAX_MB_PLANE ; ++ i ) { p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 2 ] ; p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 2 ] ; pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 2 ] ; p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 2 ] ; ctx -> coeff_pbuf [ i ] [ 2 ] = ctx -> coeff_pbuf [ i ] [ 0 ] ; ctx -> qcoeff_pbuf [ i ] [ 2 ] = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; ctx -> dqcoeff_pbuf [ i ] [ 2 ] = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; ctx -> eobs_pbuf [ i ] [ 2 ] = ctx -> eobs_pbuf [ i ] [ 0 ] ; ctx -> coeff_pbuf [ i ] [ 0 ] = p [ i ] . coeff ; ctx -> qcoeff_pbuf [ i ] [ 0 ] = p [ i ] . qcoeff ; ctx -> dqcoeff_pbuf [ i ] [ 0 ] = pd [ i ] . dqcoeff ; ctx -> eobs_pbuf [ i ] [ 0 ] = p [ i ] . eobs ; } } } } xd -> mi [ 0 ] -> mbmi . uv_mode = mode_selected ; return best_rd ; }
CWE-20 static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr -> saddr ) ; if ( __ipv6_addr_needs_scope_id ( addr_type ) ) iif = skb -> dev -> ifindex ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) { net_dbg_ratelimited ( "icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; return ; } if ( is_ineligible ( skb ) ) { net_dbg_ratelimited ( "icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; return ; } mip6_addr_swap ( skb ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_ICMPV6 ; fl6 . daddr = hdr -> saddr ; if ( force_saddr ) saddr = force_saddr ; if ( saddr ) fl6 . saddr = * saddr ; fl6 . flowi6_mark = mark ; fl6 . flowi6_oif = iif ; fl6 . fl6_icmp_type = type ; fl6 . fl6_icmp_code = code ; security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; sk = icmpv6_xmit_lock ( net ) ; if ( ! sk ) return ; sk -> sk_mark = mark ; np = inet6_sk ( sk ) ; if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) goto out ; tmp_hdr . icmp6_type = type ; tmp_hdr . icmp6_code = code ; tmp_hdr . icmp6_cksum = 0 ; tmp_hdr . icmp6_pointer = htonl ( info ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; ipc6 . tclass = np -> tclass ; fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; if ( IS_ERR ( dst ) ) goto out ; ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; ipc6 . dontfrag = np -> dontfrag ; ipc6 . opt = NULL ; msg . skb = skb ; msg . offset = skb_network_offset ( skb ) ; msg . type = type ; len = skb -> len - msg . offset ; len = min_t ( unsigned int , len , IPV6_MIN_MTU - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; if ( len < 0 ) { net_dbg_ratelimited ( "icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; goto out_dst_release ; } rcu_read_lock ( ) ; idev = __in6_dev_get ( skb -> dev ) ; err = ip6_append_data ( sk , icmpv6_getfrag , & msg , len + sizeof ( struct icmp6hdr ) , sizeof ( struct icmp6hdr ) , & ipc6 , & fl6 , ( struct rt6_info * ) dst , MSG_DONTWAIT , & sockc_unused ) ; if ( err ) { ICMP6_INC_STATS ( net , idev , ICMP6_MIB_OUTERRORS ) ; ip6_flush_pending_frames ( sk ) ; } else { err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , len + sizeof ( struct icmp6hdr ) ) ; } rcu_read_unlock ( ) ; out_dst_release : dst_release ( dst ) ; out : icmpv6_xmit_unlock ( sk ) ; }
CWE-476 av_cold void ff_mpv_idct_init ( MpegEncContext * s ) <S2SV_StartBug> { <S2SV_EndBug> ff_idctdsp_init ( & s -> idsp , s -> avctx ) ; if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; } ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }
CWE-000 <S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> { <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }
CWE-284 static bool has_byte ( const eager_reader_t * reader ) { assert ( reader != NULL ) ; fd_set read_fds ; FD_ZERO ( & read_fds ) ; FD_SET ( reader -> bytes_available_fd , & read_fds ) ; struct timeval timeout ; timeout . tv_sec = 0 ; timeout . tv_usec = 0 ; <S2SV_StartBug> select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout ) ; <S2SV_EndBug> return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ; }
CWE-264 static int hfsplus_readdir ( struct file * filp , void * dirent , filldir_t filldir ) { struct inode * inode = filp -> f_path . dentry -> d_inode ; struct super_block * sb = inode -> i_sb ; int len , err ; char strbuf [ HFSPLUS_MAX_STRLEN + 1 ] ; hfsplus_cat_entry entry ; struct hfs_find_data fd ; struct hfsplus_readdir_data * rd ; u16 type ; if ( filp -> f_pos >= inode -> i_size ) return 0 ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & fd ) ; if ( err ) return err ; hfsplus_cat_build_key ( sb , fd . search_key , inode -> i_ino , NULL ) ; err = hfs_brec_find ( & fd ) ; if ( err ) goto out ; switch ( ( u32 ) filp -> f_pos ) { case 0 : if ( filldir ( dirent , "." , 1 , 0 , inode -> i_ino , DT_DIR ) ) goto out ; filp -> f_pos ++ ; case 1 : <S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> fd . entrylength ) ; if ( be16_to_cpu ( entry . type ) != HFSPLUS_FOLDER_THREAD ) { printk ( KERN_ERR "hfs:<S2SV_blank>bad<S2SV_blank>catalog<S2SV_blank>folder<S2SV_blank>thread\\n" ) ; err = - EIO ; goto out ; } if ( fd . entrylength < HFSPLUS_MIN_THREAD_SZ ) { printk ( KERN_ERR "hfs:<S2SV_blank>truncated<S2SV_blank>catalog<S2SV_blank>thread\\n" ) ; err = - EIO ; goto out ; } if ( filldir ( dirent , ".." , 2 , 1 , be32_to_cpu ( entry . thread . parentID ) , DT_DIR ) ) goto out ; filp -> f_pos ++ ; default : if ( filp -> f_pos >= inode -> i_size ) goto out ; err = hfs_brec_goto ( & fd , filp -> f_pos - 1 ) ; if ( err ) goto out ; } for ( ; ; ) { if ( be32_to_cpu ( fd . key -> cat . parent ) != inode -> i_ino ) { printk ( KERN_ERR "hfs:<S2SV_blank>walked<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>dir\\n" ) ; err = - EIO ; goto out ; } <S2SV_StartBug> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <S2SV_EndBug> fd . entrylength ) ; type = be16_to_cpu ( entry . type ) ; len = HFSPLUS_MAX_STRLEN ; err = hfsplus_uni2asc ( sb , & fd . key -> cat . name , strbuf , & len ) ; if ( err ) goto out ; if ( type == HFSPLUS_FOLDER ) { if ( fd . entrylength < sizeof ( struct hfsplus_cat_folder ) ) { printk ( KERN_ERR "hfs:<S2SV_blank>small<S2SV_blank>dir<S2SV_blank>entry\\n" ) ; err = - EIO ; goto out ; } if ( HFSPLUS_SB ( sb ) -> hidden_dir && HFSPLUS_SB ( sb ) -> hidden_dir -> i_ino == be32_to_cpu ( entry . folder . id ) ) goto next ; if ( filldir ( dirent , strbuf , len , filp -> f_pos , be32_to_cpu ( entry . folder . id ) , DT_DIR ) ) break ; } else if ( type == HFSPLUS_FILE ) { if ( fd . entrylength < sizeof ( struct hfsplus_cat_file ) ) { printk ( KERN_ERR "hfs:<S2SV_blank>small<S2SV_blank>file<S2SV_blank>entry\\n" ) ; err = - EIO ; goto out ; } if ( filldir ( dirent , strbuf , len , filp -> f_pos , be32_to_cpu ( entry . file . id ) , DT_REG ) ) break ; } else { printk ( KERN_ERR "hfs:<S2SV_blank>bad<S2SV_blank>catalog<S2SV_blank>entry<S2SV_blank>type\\n" ) ; err = - EIO ; goto out ; } next : filp -> f_pos ++ ; if ( filp -> f_pos >= inode -> i_size ) goto out ; err = hfs_brec_goto ( & fd , 1 ) ; if ( err ) goto out ; } rd = filp -> private_data ; if ( ! rd ) { rd = kmalloc ( sizeof ( struct hfsplus_readdir_data ) , GFP_KERNEL ) ; if ( ! rd ) { err = - ENOMEM ; goto out ; } filp -> private_data = rd ; rd -> file = filp ; list_add ( & rd -> list , & HFSPLUS_I ( inode ) -> open_dir_list ) ; } memcpy ( & rd -> key , fd . key , sizeof ( struct hfsplus_cat_key ) ) ; out : hfs_find_exit ( & fd ) ; return err ; }
CWE-190 <S2SV_StartBug> static int jas_iccgetuint ( jas_stream_t * in , int n , ulonglong * val ) <S2SV_EndBug> { int i ; int c ; <S2SV_StartBug> ulonglong v ; <S2SV_EndBug> v = 0 ; for ( i = n ; i > 0 ; -- i ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) return - 1 ; v = ( v << 8 ) | c ; } * val = v ; return 0 ; }
CWE-264 <S2SV_StartBug> static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options ) <S2SV_EndBug> { char * p ; int rc = 0 ; int sig_set = 0 ; int cipher_name_set = 0 ; int fn_cipher_name_set = 0 ; int cipher_key_bytes ; int cipher_key_bytes_set = 0 ; int fn_cipher_key_bytes ; int fn_cipher_key_bytes_set = 0 ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ MAX_OPT_ARGS ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * fn_cipher_name_dst ; char * fn_cipher_name_src ; char * fnek_dst ; char * fnek_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ; <S2SV_StartBug> if ( ! options ) { <S2SV_EndBug> rc = - EINVAL ; goto out ; } ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; while ( ( p = strsep ( & options , "," ) ) != NULL ) { if ( ! * p ) continue ; token = match_token ( p , tokens , args ) ; switch ( token ) { case ecryptfs_opt_sig : case ecryptfs_opt_ecryptfs_sig : sig_src = args [ 0 ] . from ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ) ; if ( rc ) { printk ( KERN_ERR "Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>" "global<S2SV_blank>sig;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , rc ) ; goto out ; } sig_set = 1 ; break ; case ecryptfs_opt_cipher : case ecryptfs_opt_ecryptfs_cipher : cipher_name_src = args [ 0 ] . from ; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name ; strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; cipher_name_set = 1 ; break ; case ecryptfs_opt_ecryptfs_key_bytes : cipher_key_bytes_src = args [ 0 ] . from ; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes ; cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_passthrough : mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED ; break ; case ecryptfs_opt_xattr_metadata : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; break ; case ecryptfs_opt_encrypted_view : mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED ; mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED ; break ; case ecryptfs_opt_fnek_sig : fnek_src = args [ 0 ] . from ; fnek_dst = mount_crypt_stat -> global_default_fnek_sig ; strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ) ; mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\\0' ; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ) ; if ( rc ) { printk ( KERN_ERR "Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>" "global<S2SV_blank>fnek<S2SV_blank>sig<S2SV_blank>[%s];<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , mount_crypt_stat -> global_default_fnek_sig , rc ) ; goto out ; } mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ) ; break ; case ecryptfs_opt_fn_cipher : fn_cipher_name_src = args [ 0 ] . from ; fn_cipher_name_dst = mount_crypt_stat -> global_default_fn_cipher_name ; strncpy ( fn_cipher_name_dst , fn_cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; fn_cipher_name_set = 1 ; break ; case ecryptfs_opt_fn_cipher_key_bytes : fn_cipher_key_bytes_src = args [ 0 ] . from ; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ) ; mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes ; fn_cipher_key_bytes_set = 1 ; break ; case ecryptfs_opt_unlink_sigs : mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS ; break ; case ecryptfs_opt_mount_auth_tok_only : mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; break ; <S2SV_StartBug> case ecryptfs_opt_err : <S2SV_EndBug> default : printk ( KERN_WARNING "%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\n" , __func__ , p ) ; } } if ( ! sig_set ) { rc = - EINVAL ; ecryptfs_printk ( KERN_ERR , "You<S2SV_blank>must<S2SV_blank>supply<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>valid<S2SV_blank>" "auth<S2SV_blank>tok<S2SV_blank>signature<S2SV_blank>as<S2SV_blank>a<S2SV_blank>mount<S2SV_blank>" "parameter;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>eCryptfs<S2SV_blank>README\\n" ) ; goto out ; } if ( ! cipher_name_set ) { int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ) ; } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set ) strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ) ; if ( ! cipher_key_bytes_set ) mount_crypt_stat -> global_default_cipher_key_size = 0 ; if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set ) mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size ; mutex_lock ( & key_tfm_list_mutex ) ; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ) ; if ( rc ) { printk ( KERN_ERR "Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>" "cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>" "rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) ) { rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; if ( rc ) { printk ( KERN_ERR "Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>" "cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>" "rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes , rc ) ; rc = - EINVAL ; mutex_unlock ( & key_tfm_list_mutex ) ; goto out ; } } mutex_unlock ( & key_tfm_list_mutex ) ; rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; if ( rc ) printk ( KERN_WARNING "One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>global<S2SV_blank>auth<S2SV_blank>toks<S2SV_blank>could<S2SV_blank>not<S2SV_blank>" "properly<S2SV_blank>register;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , rc ) ; out : return rc ; }
CWE-000 static void Sp_split_regexp ( js_State * J ) { js_Regexp * re ; const char * text ; int limit , len , k ; const char * p , * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; re = js_toregexp ( J , 1 ) ; limit = js_isdefined ( J , 2 ) ? js_tointeger ( J , 2 ) : 1 << 30 ; js_newarray ( J ) ; len = 0 ; e = text + strlen ( text ) ; if ( e == text ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , text , & m , 0 ) ) { <S2SV_EndBug> if ( len == limit ) return ; js_pushliteral ( J , "" ) ; js_setindex ( J , - 2 , 0 ) ; } return ; } p = a = text ; while ( a < e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; if ( b == p ) { ++ a ; continue ; } if ( len == limit ) return ; js_pushlstring ( J , p , b - p ) ; js_setindex ( J , - 2 , len ++ ) ; for ( k = 1 ; k < m . nsub ; ++ k ) { if ( len == limit ) return ; js_pushlstring ( J , m . sub [ k ] . sp , m . sub [ k ] . ep - m . sub [ k ] . sp ) ; js_setindex ( J , - 2 , len ++ ) ; } a = p = c ; } if ( len == limit ) return ; js_pushstring ( J , p ) ; js_setindex ( J , - 2 , len ) ; }
CWE-20 static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) { <S2SV_StartBug> case 0 : <S2SV_EndBug> # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Unsupported<S2SV_blank>ZIP<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(%s)" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes" , <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , "Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Mac<S2SV_blank>metadata" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0 ) ; __archive_read_consume ( a , hsize ) ; remaining_bytes = ( size_t ) rsrc -> compressed_size ; metadata_bytes = ( size_t ) rsrc -> uncompressed_size ; mp = metadata ; eof = 0 ; while ( ! eof && remaining_bytes ) { const unsigned char * p ; ssize_t bytes_avail ; size_t bytes_used ; p = __archive_read_ahead ( a , 1 , & bytes_avail ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Truncated<S2SV_blank>ZIP<S2SV_blank>file<S2SV_blank>header" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } if ( ( size_t ) bytes_avail > remaining_bytes ) bytes_avail = remaining_bytes ; switch ( rsrc -> compression ) { case 0 : <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> bytes_used = ( size_t ) bytes_avail ; metadata_bytes -= bytes_used ; mp += bytes_used ; if ( metadata_bytes == 0 ) eof = 1 ; break ; # ifdef HAVE_ZLIB_H case 8 : { int r ; ret = zip_deflate_init ( a , zip ) ; if ( ret != ARCHIVE_OK ) goto exit_mac_metadata ; zip -> stream . next_in = ( Bytef * ) ( uintptr_t ) ( const void * ) p ; zip -> stream . avail_in = ( uInt ) bytes_avail ; zip -> stream . total_in = 0 ; zip -> stream . next_out = mp ; zip -> stream . avail_out = ( uInt ) metadata_bytes ; zip -> stream . total_out = 0 ; r = inflate ( & zip -> stream , 0 ) ; switch ( r ) { case Z_OK : break ; case Z_STREAM_END : eof = 1 ; break ; case Z_MEM_ERROR : archive_set_error ( & a -> archive , ENOMEM , "Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>ZIP<S2SV_blank>decompression" ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "ZIP<S2SV_blank>decompression<S2SV_blank>failed<S2SV_blank>(%d)" , r ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; } bytes_used = zip -> stream . total_in ; metadata_bytes -= zip -> stream . total_out ; mp += zip -> stream . total_out ; break ; } # endif default : bytes_used = 0 ; break ; } __archive_read_consume ( a , bytes_used ) ; remaining_bytes -= bytes_used ; } archive_entry_copy_mac_metadata ( entry , metadata , ( size_t ) rsrc -> uncompressed_size - metadata_bytes ) ; exit_mac_metadata : __archive_read_seek ( a , offset , SEEK_SET ) ; zip -> decompress_init = 0 ; free ( metadata ) ; return ( ret ) ; }
CWE-119 static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - ERESTARTSYS ; cntr = ACCESS_ONCE ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } <S2SV_StartBug> i ++ ; <S2SV_EndBug> if ( file -> f_flags & O_NONBLOCK ) { if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { rv = cntr ? cntr : - EAGAIN ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( WDM_READ , & desc -> flags ) ) ; } if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } if ( test_bit ( WDM_RESETTING , & desc -> flags ) ) { rv = - EIO ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - ERESTARTSYS ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - EIO ; goto err ; } if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , "%s:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>-<S2SV_blank>clearing<S2SV_blank>WDM_READ\\n" , __func__ ) ; clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - EFAULT ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }
CWE-119 int vp9_prob_diff_update_savings_search ( const unsigned int * ct , <S2SV_StartBug> vp9_prob oldp , vp9_prob * bestp , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> const int old_b = cost_branch256 ( ct , oldp ) ; int bestsavings = 0 ; <S2SV_StartBug> vp9_prob newp , bestnewp = oldp ; <S2SV_EndBug> const int step = * bestp > oldp ? - 1 : 1 ; for ( newp = * bestp ; newp != oldp ; newp += step ) { const int new_b = cost_branch256 ( ct , newp ) ; const int update_b = prob_diff_update_cost ( newp , oldp ) + vp9_cost_upd256 ; const int savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } * bestp = bestnewp ; return bestsavings ; }
CWE-399 int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv_offset ( msg , skb , sizeof ( struct udphdr ) ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
CWE-119 static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ; <S2SV_StartBug> if ( ! capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( "get_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u\\n" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; } <S2SV_StartBug> if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 ) <S2SV_EndBug> return - EFAULT ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) return - ERESTARTSYS ; switch ( cmd ) { case IP_VS_SO_GET_VERSION : { char buf [ 64 ] ; sprintf ( buf , "IP<S2SV_blank>Virtual<S2SV_blank>Server<S2SV_blank>version<S2SV_blank>%d.%d.%d<S2SV_blank>(size=%d)" , NVERSION ( IP_VS_VERSION_CODE ) , IP_VS_CONN_TAB_SIZE ) ; if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { ret = - EFAULT ; goto out ; } * len = strlen ( buf ) + 1 ; } break ; case IP_VS_SO_GET_INFO : { struct ip_vs_getinfo info ; info . version = IP_VS_VERSION_CODE ; info . size = IP_VS_CONN_TAB_SIZE ; info . num_services = ip_vs_num_services ; if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_get_services * get ; int size ; get = ( struct ip_vs_get_services * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_service_entry ) * get -> num_services ; if ( * len != size ) { pr_err ( "length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_service_entries ( get , user ) ; } break ; case IP_VS_SO_GET_SERVICE : { struct ip_vs_service_entry * entry ; struct ip_vs_service * svc ; union nf_inet_addr addr ; entry = ( struct ip_vs_service_entry * ) arg ; addr . ip = entry -> addr ; if ( entry -> fwmark ) svc = __ip_vs_svc_fwm_get ( AF_INET , entry -> fwmark ) ; else svc = __ip_vs_service_get ( AF_INET , entry -> protocol , & addr , entry -> port ) ; if ( svc ) { ip_vs_copy_service ( entry , svc ) ; if ( copy_to_user ( user , entry , sizeof ( * entry ) ) != 0 ) ret = - EFAULT ; ip_vs_service_put ( svc ) ; } else ret = - ESRCH ; } break ; case IP_VS_SO_GET_DESTS : { struct ip_vs_get_dests * get ; int size ; get = ( struct ip_vs_get_dests * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_dest_entry ) * get -> num_dests ; if ( * len != size ) { pr_err ( "length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_dest_entries ( get , user ) ; } break ; case IP_VS_SO_GET_TIMEOUT : { struct ip_vs_timeout_user t ; __ip_vs_get_timeouts ( & t ) ; if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_DAEMON : { struct ip_vs_daemon_user d [ 2 ] ; memset ( & d , 0 , sizeof ( d ) ) ; if ( ip_vs_sync_state & IP_VS_STATE_MASTER ) { d [ 0 ] . state = IP_VS_STATE_MASTER ; strlcpy ( d [ 0 ] . mcast_ifn , ip_vs_master_mcast_ifn , sizeof ( d [ 0 ] . mcast_ifn ) ) ; d [ 0 ] . syncid = ip_vs_master_syncid ; } if ( ip_vs_sync_state & IP_VS_STATE_BACKUP ) { d [ 1 ] . state = IP_VS_STATE_BACKUP ; strlcpy ( d [ 1 ] . mcast_ifn , ip_vs_backup_mcast_ifn , sizeof ( d [ 1 ] . mcast_ifn ) ) ; d [ 1 ] . syncid = ip_vs_backup_syncid ; } if ( copy_to_user ( user , & d , sizeof ( d ) ) != 0 ) ret = - EFAULT ; } break ; default : ret = - EINVAL ; } out : mutex_unlock ( & __ip_vs_mutex ) ; return ret ; }
CWE-000 static int ras_getcmap ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap ) { int i ; int j ; int x ; int c ; int numcolors ; int actualnumcolors ; switch ( hdr -> maptype ) { case RAS_MT_NONE : break ; case RAS_MT_EQUALRGB : { jas_eprintf ( "warning:<S2SV_blank>palettized<S2SV_blank>images<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>supported\\n" ) ; numcolors = 1 << hdr -> depth ; <S2SV_StartBug> assert ( numcolors <= RAS_CMAP_MAXSIZ ) ; <S2SV_EndBug> actualnumcolors = hdr -> maplength / 3 ; for ( i = 0 ; i < numcolors ; i ++ ) { cmap -> data [ i ] = 0 ; } if ( ( hdr -> maplength % 3 ) || hdr -> maplength < 0 || hdr -> maplength > 3 * numcolors ) { return - 1 ; } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < actualnumcolors ; j ++ ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } x = 0 ; switch ( i ) { case 0 : x = RAS_RED ( c ) ; break ; case 1 : x = RAS_GREEN ( c ) ; break ; case 2 : x = RAS_BLUE ( c ) ; break ; } cmap -> data [ j ] |= x ; } } } break ; default : return - 1 ; break ; } return 0 ; }
CWE-20 int bt_sock_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int err = 0 ; size_t target , copied = 0 ; long timeo ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> msg -> msg_namelen = 0 ; BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu" , sk , size ) ; lock_sock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { struct sk_buff * skb ; int chunk ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( ! skb ) { if ( copied >= target ) break ; err = sock_error ( sk ) ; if ( err ) break ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; err = - EAGAIN ; if ( ! timeo ) break ; timeo = bt_sock_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( ! copied ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { int skb_len = skb_headlen ( skb ) ; if ( chunk <= skb_len ) { __skb_pull ( skb , chunk ) ; } else { struct sk_buff * frag ; __skb_pull ( skb , skb_len ) ; chunk -= skb_len ; skb_walk_frags ( skb , frag ) { if ( chunk <= frag -> len ) { skb -> len -= chunk ; skb -> data_len -= chunk ; __skb_pull ( frag , chunk ) ; break ; } else if ( frag -> len ) { chunk -= frag -> len ; skb -> len -= frag -> len ; skb -> data_len -= frag -> len ; __skb_pull ( frag , frag -> len ) ; } } } if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; out : release_sock ( sk ) ; return copied ? : err ; }
CWE-000 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; <S2SV_StartBug> goto fail ; <S2SV_EndBug> } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>" "in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( "Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }
CWE-20 xfs_buf_t * _xfs_buf_find ( struct xfs_buftarg * btp , struct xfs_buf_map * map , int nmaps , xfs_buf_flags_t flags , xfs_buf_t * new_bp ) { size_t numbytes ; struct xfs_perag * pag ; struct rb_node * * rbp ; struct rb_node * parent ; xfs_buf_t * bp ; <S2SV_StartBug> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; <S2SV_EndBug> int numblks = 0 ; int i ; for ( i = 0 ; i < nmaps ; i ++ ) numblks += map [ i ] . bm_len ; numbytes = BBTOB ( numblks ) ; ASSERT ( ! ( numbytes < ( 1 << btp -> bt_sshift ) ) ) ; ASSERT ( ! ( BBTOB ( blkno ) & ( xfs_off_t ) btp -> bt_smask ) ) ; <S2SV_StartBug> pag = xfs_perag_get ( btp -> bt_mount , <S2SV_EndBug> xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ; spin_lock ( & pag -> pag_buf_lock ) ; rbp = & pag -> pag_buf_tree . rb_node ; parent = NULL ; bp = NULL ; while ( * rbp ) { parent = * rbp ; bp = rb_entry ( parent , struct xfs_buf , b_rbnode ) ; if ( blkno < bp -> b_bn ) rbp = & ( * rbp ) -> rb_left ; else if ( blkno > bp -> b_bn ) rbp = & ( * rbp ) -> rb_right ; else { if ( bp -> b_length != numblks ) { ASSERT ( bp -> b_flags & XBF_STALE ) ; rbp = & ( * rbp ) -> rb_right ; continue ; } atomic_inc ( & bp -> b_hold ) ; goto found ; } } if ( new_bp ) { rb_link_node ( & new_bp -> b_rbnode , parent , rbp ) ; rb_insert_color ( & new_bp -> b_rbnode , & pag -> pag_buf_tree ) ; new_bp -> b_pag = pag ; spin_unlock ( & pag -> pag_buf_lock ) ; } else { XFS_STATS_INC ( xb_miss_locked ) ; spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; } return new_bp ; found : spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; if ( ! xfs_buf_trylock ( bp ) ) { if ( flags & XBF_TRYLOCK ) { xfs_buf_rele ( bp ) ; XFS_STATS_INC ( xb_busy_locked ) ; return NULL ; } xfs_buf_lock ( bp ) ; XFS_STATS_INC ( xb_get_locked_waited ) ; } if ( bp -> b_flags & XBF_STALE ) { ASSERT ( ( bp -> b_flags & _XBF_DELWRI_Q ) == 0 ) ; ASSERT ( bp -> b_iodone == NULL ) ; bp -> b_flags &= _XBF_KMEM | _XBF_PAGES ; bp -> b_ops = NULL ; } trace_xfs_buf_find ( bp , flags , _RET_IP_ ) ; XFS_STATS_INC ( xb_get_locked ) ; return bp ; }
CWE-476 BOOL rdp_decrypt ( rdpRdp * rdp , STREAM * s , int length , UINT16 securityFlags ) { BYTE cmac [ 8 ] ; BYTE wmac [ 8 ] ; if ( rdp -> settings -> EncryptionMethods == ENCRYPTION_METHOD_FIPS ) { UINT16 len ; BYTE version , pad ; BYTE * sig ; if ( stream_get_left ( s ) < 12 ) return FALSE ; stream_read_UINT16 ( s , len ) ; stream_read_BYTE ( s , version ) ; stream_read_BYTE ( s , pad ) ; sig = s -> p ; stream_seek ( s , 8 ) ; length -= 12 ; if ( ! security_fips_decrypt ( s -> p , length , rdp ) ) { printf ( "FATAL:<S2SV_blank>cannot<S2SV_blank>decrypt\\n" ) ; return FALSE ; } if ( ! security_fips_check_signature ( s -> p , length - pad , sig , rdp ) ) { printf ( "FATAL:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>signature\\n" ) ; return FALSE ; } s -> size -= pad ; return TRUE ; } if ( stream_get_left ( s ) < 8 ) return FALSE ; stream_read ( s , wmac , sizeof ( wmac ) ) ; length -= sizeof ( wmac ) ; <S2SV_StartBug> security_decrypt ( s -> p , length , rdp ) ; <S2SV_EndBug> if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ; else security_mac_signature ( rdp , s -> p , length , cmac ) ; if ( memcmp ( wmac , cmac , sizeof ( wmac ) ) != 0 ) { printf ( "WARNING:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>signature\\n" ) ; } return TRUE ; }
CWE-200 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug> restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }
CWE-189 BOOL license_read_scope_list ( wStream * s , SCOPE_LIST * scopeList ) { UINT32 i ; UINT32 scopeCount ; if ( Stream_GetRemainingLength ( s ) < 4 ) return FALSE ; <S2SV_StartBug> Stream_Read_UINT32 ( s , scopeCount ) ; <S2SV_EndBug> scopeList -> count = scopeCount ; scopeList -> array = ( LICENSE_BLOB * ) malloc ( sizeof ( LICENSE_BLOB ) * scopeCount ) ; for ( i = 0 ; i < scopeCount ; i ++ ) { scopeList -> array [ i ] . type = BB_SCOPE_BLOB ; if ( ! license_read_binary_blob ( s , & scopeList -> array [ i ] ) ) return FALSE ; } return TRUE ; }
CWE-20 void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> u32 data ; <S2SV_EndBug> void * vapic ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; kunmap_atomic ( vapic ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }
CWE-284 int socket_accept ( int fd , uint16_t port ) { # ifdef WIN32 int addr_len ; # else socklen_t addr_len ; # endif int result ; struct sockaddr_in addr ; memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; <S2SV_StartBug> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> addr . sin_port = htons ( port ) ; addr_len = sizeof ( addr ) ; result = accept ( fd , ( struct sockaddr * ) & addr , & addr_len ) ; return result ; }
CWE-200 int x25_negotiate_facilities ( struct sk_buff * skb , struct sock * sk , struct x25_facilities * new , struct x25_dte_facilities * dte ) { struct x25_sock * x25 = x25_sk ( sk ) ; struct x25_facilities * ours = & x25 -> facilities ; struct x25_facilities theirs ; int len ; memset ( & theirs , 0 , sizeof ( theirs ) ) ; <S2SV_StartBug> memcpy ( new , ours , sizeof ( * new ) ) ; <S2SV_EndBug> len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ; if ( len < 0 ) return len ; if ( ( theirs . reverse & 0x01 ) && ( ours -> reverse & 0x01 ) ) { SOCK_DEBUG ( sk , "X.25:<S2SV_blank>rejecting<S2SV_blank>reverse<S2SV_blank>charging<S2SV_blank>request\\n" ) ; return - 1 ; } new -> reverse = theirs . reverse ; if ( theirs . throughput ) { int theirs_in = theirs . throughput & 0x0f ; int theirs_out = theirs . throughput & 0xf0 ; int ours_in = ours -> throughput & 0x0f ; int ours_out = ours -> throughput & 0xf0 ; if ( ! ours_in || theirs_in < ours_in ) { SOCK_DEBUG ( sk , "X.25:<S2SV_blank>inbound<S2SV_blank>throughput<S2SV_blank>negotiated\\n" ) ; new -> throughput = ( new -> throughput & 0xf0 ) | theirs_in ; } if ( ! ours_out || theirs_out < ours_out ) { SOCK_DEBUG ( sk , "X.25:<S2SV_blank>outbound<S2SV_blank>throughput<S2SV_blank>negotiated\\n" ) ; new -> throughput = ( new -> throughput & 0x0f ) | theirs_out ; } } if ( theirs . pacsize_in && theirs . pacsize_out ) { if ( theirs . pacsize_in < ours -> pacsize_in ) { SOCK_DEBUG ( sk , "X.25:<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>inwards<S2SV_blank>negotiated<S2SV_blank>down\\n" ) ; new -> pacsize_in = theirs . pacsize_in ; } if ( theirs . pacsize_out < ours -> pacsize_out ) { SOCK_DEBUG ( sk , "X.25:<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>outwards<S2SV_blank>negotiated<S2SV_blank>down\\n" ) ; new -> pacsize_out = theirs . pacsize_out ; } } if ( theirs . winsize_in && theirs . winsize_out ) { if ( theirs . winsize_in < ours -> winsize_in ) { SOCK_DEBUG ( sk , "X.25:<S2SV_blank>window<S2SV_blank>size<S2SV_blank>inwards<S2SV_blank>negotiated<S2SV_blank>down\\n" ) ; new -> winsize_in = theirs . winsize_in ; } if ( theirs . winsize_out < ours -> winsize_out ) { SOCK_DEBUG ( sk , "X.25:<S2SV_blank>window<S2SV_blank>size<S2SV_blank>outwards<S2SV_blank>negotiated<S2SV_blank>down\\n" ) ; new -> winsize_out = theirs . winsize_out ; } } return len ; }
CWE-416 void snd_usb_mixer_disconnect ( struct usb_mixer_interface * mixer ) { <S2SV_StartBug> usb_kill_urb ( mixer -> urb ) ; <S2SV_EndBug> usb_kill_urb ( mixer -> rc_urb ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-284 socket_t * socket_accept ( const socket_t * socket ) { assert ( socket != NULL ) ; <S2SV_StartBug> int fd = accept ( socket -> fd , NULL , NULL ) ; <S2SV_EndBug> if ( fd == INVALID_FD ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>accept<S2SV_blank>socket:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; return NULL ; } socket_t * ret = ( socket_t * ) osi_calloc ( sizeof ( socket_t ) ) ; if ( ! ret ) { close ( fd ) ; LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>socket." , __func__ ) ; return NULL ; } ret -> fd = fd ; return ret ; }
CWE-000 static int gtco_probe ( struct usb_interface * usbinterface , const struct usb_device_id * id ) { struct gtco * gtco ; struct input_dev * input_dev ; struct hid_descriptor * hid_desc ; char * report ; int result = 0 , retry ; int error ; struct usb_endpoint_descriptor * endpoint ; gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! gtco || ! input_dev ) { dev_err ( & usbinterface -> dev , "No<S2SV_blank>more<S2SV_blank>memory\\n" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> inputdevice = input_dev ; gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; gtco -> intf = usbinterface ; gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , GFP_KERNEL , & gtco -> buf_dma ) ; if ( ! gtco -> buffer ) { dev_err ( & usbinterface -> dev , "No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>us<S2SV_blank>buffers\\n" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! gtco -> urbinfo ) { dev_err ( & usbinterface -> dev , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>URB\\n" ) ; error = - ENOMEM ; goto err_free_buf ; } <S2SV_StartBug> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> dev_dbg ( & usbinterface -> dev , "gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\n" , usbinterface -> num_altsetting ) ; dev_dbg ( & usbinterface -> dev , "num<S2SV_blank>endpoints:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; dev_dbg ( & usbinterface -> dev , "interface<S2SV_blank>class:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; dev_dbg ( & usbinterface -> dev , "endpoint:<S2SV_blank>attribute:0x%x<S2SV_blank>type:0x%x\\n" , endpoint -> bmAttributes , endpoint -> bDescriptorType ) ; if ( usb_endpoint_xfer_int ( endpoint ) ) dev_dbg ( & usbinterface -> dev , "endpoint:<S2SV_blank>we<S2SV_blank>have<S2SV_blank>interrupt<S2SV_blank>endpoint\\n" ) ; dev_dbg ( & usbinterface -> dev , "endpoint<S2SV_blank>extra<S2SV_blank>len:%d\\n" , usbinterface -> altsetting [ 0 ] . extralen ) ; if ( usb_get_extra_descriptor ( usbinterface -> cur_altsetting , HID_DEVICE_TYPE , & hid_desc ) != 0 ) { dev_err ( & usbinterface -> dev , "Can\'t<S2SV_blank>retrieve<S2SV_blank>exta<S2SV_blank>USB<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>get<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>length\\n" ) ; error = - EIO ; goto err_free_urb ; } dev_dbg ( & usbinterface -> dev , "Extra<S2SV_blank>descriptor<S2SV_blank>success:<S2SV_blank>type:%d<S2SV_blank><S2SV_blank>len:%d\\n" , hid_desc -> bDescriptorType , hid_desc -> wDescriptorLength ) ; report = kzalloc ( le16_to_cpu ( hid_desc -> wDescriptorLength ) , GFP_KERNEL ) ; if ( ! report ) { dev_err ( & usbinterface -> dev , "No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>report\\n" ) ; error = - ENOMEM ; goto err_free_urb ; } for ( retry = 0 ; retry < 3 ; retry ++ ) { result = usb_control_msg ( gtco -> usbdev , usb_rcvctrlpipe ( gtco -> usbdev , 0 ) , USB_REQ_GET_DESCRIPTOR , USB_RECIP_INTERFACE | USB_DIR_IN , REPORT_DEVICE_TYPE << 8 , 0 , report , le16_to_cpu ( hid_desc -> wDescriptorLength ) , 5000 ) ; dev_dbg ( & usbinterface -> dev , "usb_control_msg<S2SV_blank>result:<S2SV_blank>%d\\n" , result ) ; if ( result == le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { parse_hid_report_descriptor ( gtco , report , result ) ; break ; } } kfree ( report ) ; if ( result != le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { dev_err ( & usbinterface -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>HID<S2SV_blank>Report<S2SV_blank>Descriptor<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%d\\n" , hid_desc -> wDescriptorLength ) ; error = - EIO ; goto err_free_urb ; } usb_make_path ( gtco -> usbdev , gtco -> usbpath , sizeof ( gtco -> usbpath ) ) ; strlcat ( gtco -> usbpath , "/input0" , sizeof ( gtco -> usbpath ) ) ; input_dev -> open = gtco_input_open ; input_dev -> close = gtco_input_close ; input_dev -> name = "GTCO_CalComp" ; input_dev -> phys = gtco -> usbpath ; input_set_drvdata ( input_dev , gtco ) ; gtco_setup_caps ( input_dev ) ; usb_to_input_id ( gtco -> usbdev , & input_dev -> id ) ; input_dev -> dev . parent = & usbinterface -> dev ; endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; usb_fill_int_urb ( gtco -> urbinfo , gtco -> usbdev , usb_rcvintpipe ( gtco -> usbdev , endpoint -> bEndpointAddress ) , gtco -> buffer , REPORT_MAX_SIZE , gtco_urb_callback , gtco , endpoint -> bInterval ) ; gtco -> urbinfo -> transfer_dma = gtco -> buf_dma ; gtco -> urbinfo -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_set_intfdata ( usbinterface , gtco ) ; error = input_register_device ( input_dev ) ; if ( error ) goto err_free_urb ; return 0 ; err_free_urb : usb_free_urb ( gtco -> urbinfo ) ; err_free_buf : usb_free_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , gtco -> buffer , gtco -> buf_dma ) ; err_free_devs : input_free_device ( input_dev ) ; kfree ( gtco ) ; return error ; }
CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <S2SV_StartBug> memmove ( s + j , s + qs , blen - qs ) ; <S2SV_EndBug> <S2SV_StartBug> j += blen - qs ; <S2SV_EndBug> } buffer_string_set_length ( b , j ) ; return qs ; }
CWE-189 void jiffies_to_timeval ( const unsigned long jiffies , struct timeval * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> long tv_usec ; <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ; <S2SV_EndBug> tv_usec /= NSEC_PER_USEC ; <S2SV_StartBug> value -> tv_usec = tv_usec ; <S2SV_EndBug> }
CWE-476 jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; <S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> return 0 ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = numrows * numcols ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; }
CWE-190 SQLITE_PRIVATE SrcList * sqlite3SrcListEnlarge ( Parse * pParse , SrcList * pSrc , int nExtra , int iStart ) { int i ; assert ( iStart >= 0 ) ; assert ( nExtra >= 1 ) ; assert ( pSrc != 0 ) ; assert ( iStart <= pSrc -> nSrc ) ; if ( ( u32 ) pSrc -> nSrc + nExtra > pSrc -> nAlloc ) { SrcList * pNew ; <S2SV_StartBug> int nAlloc = pSrc -> nSrc * 2 + nExtra ; <S2SV_EndBug> sqlite3 * db = pParse -> db ; if ( pSrc -> nSrc + nExtra >= SQLITE_MAX_SRCLIST ) { sqlite3ErrorMsg ( pParse , "too<S2SV_blank>many<S2SV_blank>FROM<S2SV_blank>clause<S2SV_blank>terms,<S2SV_blank>max:<S2SV_blank>%d" , SQLITE_MAX_SRCLIST ) ; return 0 ; } if ( nAlloc > SQLITE_MAX_SRCLIST ) nAlloc = SQLITE_MAX_SRCLIST ; pNew = sqlite3DbRealloc ( db , pSrc , sizeof ( * pSrc ) + ( nAlloc - 1 ) * sizeof ( pSrc -> a [ 0 ] ) ) ; if ( pNew == 0 ) { assert ( db -> mallocFailed ) ; return 0 ; } pSrc = pNew ; pSrc -> nAlloc = nAlloc ; } for ( i = pSrc -> nSrc - 1 ; i >= iStart ; i -- ) { pSrc -> a [ i + nExtra ] = pSrc -> a [ i ] ; } pSrc -> nSrc += nExtra ; memset ( & pSrc -> a [ iStart ] , 0 , sizeof ( pSrc -> a [ 0 ] ) * nExtra ) ; for ( i = iStart ; i < iStart + nExtra ; i ++ ) { pSrc -> a [ i ] . iCursor = - 1 ; } return pSrc ; }
CWE-190 static int setupLookaside ( sqlite3 * db , void * pBuf , int sz , int cnt ) { # ifndef SQLITE_OMIT_LOOKASIDE void * pStart ; if ( sqlite3LookasideUsed ( db , 0 ) > 0 ) { return SQLITE_BUSY ; } if ( db -> lookaside . bMalloced ) { sqlite3_free ( db -> lookaside . pStart ) ; } sz = ROUNDDOWN8 ( sz ) ; if ( sz <= ( int ) sizeof ( LookasideSlot * ) ) sz = 0 ; if ( cnt < 0 ) cnt = 0 ; if ( sz == 0 || cnt == 0 ) { sz = 0 ; pStart = 0 ; } else if ( pBuf == 0 ) { sqlite3BeginBenignMalloc ( ) ; <S2SV_StartBug> pStart = sqlite3Malloc ( sz * cnt ) ; <S2SV_EndBug> sqlite3EndBenignMalloc ( ) ; if ( pStart ) cnt = sqlite3MallocSize ( pStart ) / sz ; } else { pStart = pBuf ; } db -> lookaside . pStart = pStart ; db -> lookaside . pInit = 0 ; db -> lookaside . pFree = 0 ; db -> lookaside . sz = ( u16 ) sz ; if ( pStart ) { int i ; LookasideSlot * p ; assert ( sz > ( int ) sizeof ( LookasideSlot * ) ) ; db -> lookaside . nSlot = cnt ; p = ( LookasideSlot * ) pStart ; for ( i = cnt - 1 ; i >= 0 ; i -- ) { p -> pNext = db -> lookaside . pInit ; db -> lookaside . pInit = p ; p = ( LookasideSlot * ) & ( ( u8 * ) p ) [ sz ] ; } db -> lookaside . pEnd = p ; db -> lookaside . bDisable = 0 ; db -> lookaside . bMalloced = pBuf == 0 ? 1 : 0 ; } else { db -> lookaside . pStart = db ; db -> lookaside . pEnd = db ; db -> lookaside . bDisable = 1 ; db -> lookaside . bMalloced = 0 ; db -> lookaside . nSlot = 0 ; } # endif return SQLITE_OK ; }
CWE-362 SYSCALL_DEFINE3 ( shmctl , int , shmid , int , cmd , struct shmid_ds __user * , buf ) { struct shmid_kernel * shp ; int err , version ; struct ipc_namespace * ns ; if ( cmd < 0 || shmid < 0 ) return - EINVAL ; version = ipc_parse_version ( & cmd ) ; ns = current -> nsproxy -> ipc_ns ; switch ( cmd ) { case IPC_INFO : case SHM_INFO : case SHM_STAT : case IPC_STAT : return shmctl_nolock ( ns , shmid , cmd , version , buf ) ; case IPC_RMID : case IPC_SET : return shmctl_down ( ns , shmid , cmd , buf , version ) ; case SHM_LOCK : case SHM_UNLOCK : { struct file * shm_file ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock1 ; } audit_ipc_obj ( & ( shp -> shm_perm ) ) ; err = security_shm_shmctl ( shp , cmd ) ; if ( err ) goto out_unlock1 ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ns_capable ( ns -> user_ns , CAP_IPC_LOCK ) ) { kuid_t euid = current_euid ( ) ; err = - EPERM ; if ( ! uid_eq ( euid , shp -> shm_perm . uid ) && ! uid_eq ( euid , shp -> shm_perm . cuid ) ) goto out_unlock0 ; if ( cmd == SHM_LOCK && ! rlimit ( RLIMIT_MEMLOCK ) ) goto out_unlock0 ; } shm_file = shp -> shm_file ; <S2SV_StartBug> if ( is_file_hugepages ( shm_file ) ) <S2SV_EndBug> goto out_unlock0 ; if ( cmd == SHM_LOCK ) { struct user_struct * user = current_user ( ) ; err = shmem_lock ( shm_file , 1 , user ) ; if ( ! err && ! ( shp -> shm_perm . mode & SHM_LOCKED ) ) { shp -> shm_perm . mode |= SHM_LOCKED ; shp -> mlock_user = user ; } goto out_unlock0 ; } if ( ! ( shp -> shm_perm . mode & SHM_LOCKED ) ) goto out_unlock0 ; shmem_lock ( shm_file , 0 , shp -> mlock_user ) ; shp -> shm_perm . mode &= ~ SHM_LOCKED ; shp -> mlock_user = NULL ; get_file ( shm_file ) ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; shmem_unlock_mapping ( shm_file -> f_mapping ) ; fput ( shm_file ) ; return err ; } default : return - EINVAL ; } out_unlock0 : ipc_unlock_object ( & shp -> shm_perm ) ; out_unlock1 : rcu_read_unlock ( ) ; return err ; }
CWE-000 void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> file_free ( file ) ; } }
CWE-000 int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; struct xfs_mount * mp = context -> dp -> i_mount ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( mp -> m_attr_geo , & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . geo = context -> dp -> i_mount -> m_attr_geo ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; <S2SV_StartBug> if ( retval ) <S2SV_EndBug> return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }
CWE-119 static Image * ReadFAXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> storage_class = PseudoClass ; if ( image -> columns == 0 ) image -> columns = 2592 ; if ( image -> rows == 0 ) image -> rows = 3508 ; image -> depth = 8 ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> status = HuffmanDecodeImage ( image ) ; <S2SV_EndBug> if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-362 static void queue_delete ( struct snd_seq_queue * q ) { <S2SV_StartBug> snd_seq_timer_stop ( q -> timer ) ; <S2SV_EndBug> <S2SV_StartBug> snd_seq_timer_close ( q ) ; <S2SV_EndBug> snd_use_lock_sync ( & q -> use_lock ) ; snd_seq_prioq_delete ( & q -> tickq ) ; snd_seq_prioq_delete ( & q -> timeq ) ; snd_seq_timer_delete ( & q -> timer ) ; kfree ( q ) ; }
CWE-000 static void check_preempt_curr ( struct rq * rq , struct task_struct * p , int flags ) { const struct sched_class * class ; if ( p -> sched_class == rq -> curr -> sched_class ) { rq -> curr -> sched_class -> check_preempt_curr ( rq , p , flags ) ; } else { for_each_class ( class ) { if ( class == rq -> curr -> sched_class ) break ; if ( class == p -> sched_class ) { resched_task ( rq -> curr ) ; break ; } } } <S2SV_StartBug> if ( test_tsk_need_resched ( rq -> curr ) ) <S2SV_EndBug> rq -> skip_clock_update = 1 ; }
CWE-119 SPL_METHOD ( SplObjectStorage , unserialize ) { spl_SplObjectStorage * intern = Z_SPLOBJSTORAGE_P ( getThis ( ) ) ; char * buf ; size_t buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval entry , inf ; zval * pcount , * pmembers ; spl_SplObjectStorageElement * element ; zend_long count ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "s" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pcount = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) { goto outexcept ; } -- p ; <S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> while ( count -- > 0 ) { spl_SplObjectStorageElement * pelement ; zend_string * hash ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) { goto outexcept ; } <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> zval_ptr_dtor ( & entry ) ; goto outexcept ; } if ( * p == ',' ) { ++ p ; if ( ! php_var_unserialize ( & inf , & p , s + buf_len , & var_hash ) ) { zval_ptr_dtor ( & entry ) ; goto outexcept ; } <S2SV_StartBug> } else { <S2SV_EndBug> ZVAL_UNDEF ( & inf ) ; } hash = spl_object_storage_get_hash ( intern , getThis ( ) , & entry ) ; if ( ! hash ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept ; } pelement = spl_object_storage_get ( intern , hash ) ; spl_object_storage_free_hash ( intern , hash ) ; if ( pelement ) { if ( ! Z_ISUNDEF ( pelement -> inf ) ) { var_push_dtor ( & var_hash , & pelement -> inf ) ; } if ( ! Z_ISUNDEF ( pelement -> obj ) ) { var_push_dtor ( & var_hash , & pelement -> obj ) ; } } element = spl_object_storage_attach ( intern , getThis ( ) , & entry , Z_ISUNDEF ( inf ) ? NULL : & inf ) ; var_replace ( & var_hash , & entry , & element -> obj ) ; var_replace ( & var_hash , & inf , & element -> inf ) ; zval_ptr_dtor ( & entry ) ; ZVAL_UNDEF ( & entry ) ; zval_ptr_dtor ( & inf ) ; ZVAL_UNDEF ( & inf ) ; } if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pmembers = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pmembers , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pmembers ) != IS_ARRAY ) { goto outexcept ; } object_properties_load ( & intern -> std , Z_ARRVAL_P ( pmembers ) ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return ; outexcept : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 , "Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%pd<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; return ; }
CWE-119 <S2SV_StartBug> static void duplicate_mode_info_in_sb ( VP9_COMMON * const cm , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int block_height = num_8x8_blocks_high_lookup [ bsize ] ; int i , j ; for ( j = 0 ; j < block_height ; ++ j ) for ( i = 0 ; i < block_width ; ++ i ) { if ( mi_row + j < cm -> mi_rows && mi_col + i < cm -> mi_cols ) xd -> mi [ j * xd -> mi_stride + i ] = xd -> mi [ 0 ] ; } }
CWE-119 int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( "Usage:<S2SV_blank>%s<S2SV_blank>mj2filename<S2SV_blank>output_location\\n" , argv [ 0 ] ) ; printf ( "Example:<S2SV_blank>%s<S2SV_blank>foreman.mj2<S2SV_blank>output/foreman\\n" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , "rb" ) ; if ( ! file ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading\\n" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf ( stdout , "Extracting<S2SV_blank>%d<S2SV_blank>frames<S2SV_blank>from<S2SV_blank>file...\\n" , track -> num_samples ) ; for ( snum = 0 ; snum < track -> num_samples ; snum ++ ) { sample = & track -> sample [ snum ] ; frame_codestream = ( unsigned char * ) malloc ( sample -> sample_size - 8 ) ; fseek ( file , sample -> offset + 8 , SEEK_SET ) ; fread ( frame_codestream , sample -> sample_size - 8 , 1 , file ) ; <S2SV_StartBug> sprintf ( outfilename , "%s_%05d.j2k" , argv [ 2 ] , snum ) ; <S2SV_EndBug> outfile = fopen ( outfilename , "wb" ) ; if ( ! outfile ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n" , outfilename ) ; return 1 ; } fwrite ( frame_codestream , sample -> sample_size - 8 , 1 , outfile ) ; fclose ( outfile ) ; free ( frame_codestream ) ; } fclose ( file ) ; fprintf ( stdout , "%d<S2SV_blank>frames<S2SV_blank>correctly<S2SV_blank>extracted\\n" , snum ) ; if ( dinfo ) { mj2_destroy_decompress ( ( opj_mj2_t * ) dinfo -> mj2_handle ) ; } return 0 ; }
CWE-189 struct xt_table_info * xt_alloc_table_info ( unsigned int size ) { struct xt_table_info * info = NULL ; <S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ; if ( sz <= ( PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER ) ) info = kmalloc ( sz , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( ! info ) { info = vmalloc ( sz ) ; if ( ! info ) return NULL ; } memset ( info , 0 , sizeof ( * info ) ) ; info -> size = size ; return info ; }
CWE-264 static void ifb_setup ( struct net_device * dev ) { dev -> destructor = free_netdev ; dev -> netdev_ops = & ifb_netdev_ops ; ether_setup ( dev ) ; dev -> tx_queue_len = TX_Q_LIMIT ; dev -> features |= IFB_FEATURES ; dev -> vlan_features |= IFB_FEATURES ; dev -> flags |= IFF_NOARP ; dev -> flags &= ~ IFF_MULTICAST ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> random_ether_addr ( dev -> dev_addr ) ; }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; FlipContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AVFrame * out ; uint8_t * inrow , * outrow ; int i , j , plane , step ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( av_pix_fmt_desc_get ( inlink -> format ) -> flags & AV_PIX_FMT_FLAG_PAL ) memcpy ( out -> data [ 1 ] , in -> data [ 1 ] , AVPALETTE_SIZE ) ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ; const int height = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> h , s -> vsub ) : inlink -> h ; step = s -> max_step [ plane ] ; outrow = out -> data [ plane ] ; inrow = in -> data [ plane ] + ( width - 1 ) * step ; for ( i = 0 ; i < height ; i ++ ) { switch ( step ) { case 1 : for ( j = 0 ; j < width ; j ++ ) outrow [ j ] = inrow [ - j ] ; break ; case 2 : { uint16_t * outrow16 = ( uint16_t * ) outrow ; uint16_t * inrow16 = ( uint16_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow16 [ j ] = inrow16 [ - j ] ; } break ; case 3 : { uint8_t * in = inrow ; uint8_t * out = outrow ; for ( j = 0 ; j < width ; j ++ , out += 3 , in -= 3 ) { int32_t v = AV_RB24 ( in ) ; AV_WB24 ( out , v ) ; } } break ; case 4 : { uint32_t * outrow32 = ( uint32_t * ) outrow ; uint32_t * inrow32 = ( uint32_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow32 [ j ] = inrow32 [ - j ] ; } break ; default : for ( j = 0 ; j < width ; j ++ ) memcpy ( outrow + j * step , inrow - j * step , step ) ; } inrow += in -> linesize [ plane ] ; outrow += out -> linesize [ plane ] ; } } av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
CWE-119 <S2SV_StartBug> static unsigned int convert_distribution ( unsigned int i , vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { unsigned int left , right ; if ( tree [ i ] <= 0 ) left = num_events [ - tree [ i ] ] ; else left = convert_distribution ( tree [ i ] , tree , branch_ct , num_events ) ; if ( tree [ i + 1 ] <= 0 ) right = num_events [ - tree [ i + 1 ] ] ; else right = convert_distribution ( tree [ i + 1 ] , tree , branch_ct , num_events ) ; branch_ct [ i >> 1 ] [ 0 ] = left ; branch_ct [ i >> 1 ] [ 1 ] = right ; return left + right ; }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { DelogoContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; AVFrame * out ; int hsub0 = desc -> log2_chroma_w ; int vsub0 = desc -> log2_chroma_h ; int direct = 0 ; int plane ; AVRational sar ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } sar = in -> sample_aspect_ratio ; if ( ! sar . num ) sar . num = sar . den = 1 ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ; apply_delogo ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , FF_CEIL_RSHIFT ( inlink -> w , hsub ) , FF_CEIL_RSHIFT ( inlink -> h , vsub ) , sar , s -> x >> hsub , s -> y >> vsub , FF_CEIL_RSHIFT ( s -> w + ( s -> x & ( ( 1 << hsub ) - 1 ) ) , hsub ) , FF_CEIL_RSHIFT ( s -> h + ( s -> y & ( ( 1 << vsub ) - 1 ) ) , vsub ) , s -> band >> FFMIN ( hsub , vsub ) , s -> show , direct ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; <S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }
CWE-362 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> vma = find_vma_prev ( mm , start , & prev ) ; <S2SV_EndBug> if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; if ( ! vma -> vm_userfaultfd_ctx . ctx ) goto skip ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }
CWE-189 int midi_synth_load_patch ( int dev , int format , const char __user * addr , <S2SV_StartBug> int offs , int count , int pmgr_flag ) <S2SV_EndBug> { int orig_dev = synth_devs [ dev ] -> midi_dev ; struct sysex_info sysex ; int i ; unsigned long left , src_offs , eox_seen = 0 ; int first_byte = 1 ; int hdr_size = ( unsigned long ) & sysex . data [ 0 ] - ( unsigned long ) & sysex ; leave_sysex ( dev ) ; if ( ! prefix_cmd ( orig_dev , 0xf0 ) ) return 0 ; if ( format != SYSEX_PATCH ) <S2SV_StartBug> { <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> if ( count < hdr_size ) <S2SV_StartBug> { <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> count -= hdr_size ; <S2SV_StartBug> if ( copy_from_user ( & ( ( char * ) & sysex ) [ offs ] , & ( addr ) [ offs ] , hdr_size - offs ) ) <S2SV_EndBug> return - EFAULT ; <S2SV_StartBug> if ( count < sysex . len ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> sysex . len = count ; <S2SV_StartBug> } <S2SV_EndBug> left = sysex . len ; src_offs = 0 ; for ( i = 0 ; i < left && ! signal_pending ( current ) ; i ++ ) { unsigned char data ; if ( get_user ( data , ( unsigned char __user * ) ( addr + hdr_size + i ) ) ) return - EFAULT ; eox_seen = ( i > 0 && data & 0x80 ) ; if ( eox_seen && data != 0xf7 ) data = 0xf7 ; if ( i == 0 ) { if ( data != 0xf0 ) { printk ( KERN_WARNING "midi_synth:<S2SV_blank>Sysex<S2SV_blank>start<S2SV_blank>missing\\n" ) ; return - EINVAL ; } } while ( ! midi_devs [ orig_dev ] -> outputc ( orig_dev , ( unsigned char ) ( data & 0xff ) ) && ! signal_pending ( current ) ) schedule ( ) ; if ( ! first_byte && data & 0x80 ) return 0 ; first_byte = 0 ; } if ( ! eox_seen ) midi_outc ( orig_dev , 0xf7 ) ; return 0 ; }
CWE-119 static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpDiff" , "%s" , "(cc%(bps*stride))!=0" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) return 1 ; }
CWE-399 public int magic_setparam ( struct magic_set * ms , int param , const void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : ms -> indir_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_NAME_MAX : ms -> name_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : ms -> elf_phnum_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : ms -> elf_shnum_max = * ( const size_t * ) val ; return 0 ; <S2SV_StartBug> default : <S2SV_EndBug> errno = EINVAL ; return - 1 ; } }
CWE-119 static int64_t rd_sbuv_dcpred ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ) { const VP9_COMMON * cm = & cpi -> common ; int64_t unused ; x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode = DC_PRED ; <S2SV_StartBug> super_block_uvrd ( cpi , x , rate_tokenonly , distortion , <S2SV_EndBug> skippable , & unused , bsize , INT64_MAX ) ; <S2SV_StartBug> * rate = * rate_tokenonly + x -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED ] ; <S2SV_EndBug> return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ; }
CWE-119 static void init_encode_frame_mb_context ( VP8_COMP * cpi ) { MACROBLOCK * const x = & cpi -> mb ; VP8_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; x -> mb_activity_ptr = cpi -> mb_activity_map ; x -> act_zbin_adj = 0 ; x -> partition_info = x -> pi ; xd -> mode_info_context = cm -> mi ; xd -> mode_info_stride = cm -> mode_info_stride ; xd -> frame_type = cm -> frame_type ; if ( cm -> frame_type == KEY_FRAME ) vp8_init_mbmode_probs ( cm ) ; x -> src = * cpi -> Source ; xd -> pre = cm -> yv12_fb [ cm -> lst_fb_idx ] ; xd -> dst = cm -> yv12_fb [ cm -> new_fb_idx ] ; vp8_setup_intra_recon ( & cm -> yv12_fb [ cm -> new_fb_idx ] ) ; vp8_build_block_offsets ( x ) ; xd -> mode_info_context -> mbmi . mode = DC_PRED ; xd -> mode_info_context -> mbmi . uv_mode = DC_PRED ; xd -> left_context = & cm -> left_context ; x -> mvc = cm -> fc . mvc ; <S2SV_StartBug> vpx_memset ( cm -> above_context , 0 , <S2SV_EndBug> sizeof ( ENTROPY_CONTEXT_PLANES ) * cm -> mb_cols ) ; if ( cpi -> ref_frame_flags == VP8_LAST_FRAME ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 255 , 128 ) ; else if ( ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags == VP8_GOLD_FRAME ) ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 1 , 255 ) ; else if ( ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags == VP8_ALTR_FRAME ) ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 1 , 1 ) ; else vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , cpi -> prob_last_coded , cpi -> prob_gf_coded ) ; xd -> fullpixel_mask = 0xffffffff ; if ( cm -> full_pixel ) xd -> fullpixel_mask = 0xfffffff8 ; vp8_zero ( x -> coef_counts ) ; vp8_zero ( x -> ymode_count ) ; vp8_zero ( x -> uv_mode_count ) x -> prediction_error = 0 ; x -> intra_error = 0 ; vp8_zero ( x -> count_mb_ref_frame_usage ) ; }
CWE-20 bt_status_t btif_storage_add_bonded_device ( bt_bdaddr_t * remote_bd_addr , LINK_KEY link_key , uint8_t key_type , uint8_t pin_length ) { bdstr_t bdstr ; bdaddr_to_string ( remote_bd_addr , bdstr , sizeof ( bdstr ) ) ; int ret = btif_config_set_int ( bdstr , "LinkKeyType" , ( int ) key_type ) ; ret &= btif_config_set_int ( bdstr , "PinLength" , ( int ) pin_length ) ; ret &= btif_config_set_bin ( bdstr , "LinkKey" , link_key , sizeof ( LINK_KEY ) ) ; <S2SV_StartBug> btif_config_flush ( ) ; <S2SV_EndBug> return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ; }
CWE-264 int fpm_unix_resolve_socket_premissions ( struct fpm_worker_pool_s * wp ) { struct fpm_worker_pool_config_s * c = wp -> config ; wp -> socket_uid = - 1 ; wp -> socket_gid = - 1 ; <S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> if ( ! c ) { return 0 ; } if ( c -> listen_owner && * c -> listen_owner ) { struct passwd * pwd ; pwd = getpwnam ( c -> listen_owner ) ; if ( ! pwd ) { zlog ( ZLOG_SYSERROR , "[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>\'%s\'" , wp -> config -> name , c -> listen_owner ) ; return - 1 ; } wp -> socket_uid = pwd -> pw_uid ; wp -> socket_gid = pwd -> pw_gid ; } if ( c -> listen_group && * c -> listen_group ) { struct group * grp ; grp = getgrnam ( c -> listen_group ) ; if ( ! grp ) { zlog ( ZLOG_SYSERROR , "[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>\'%s\'" , wp -> config -> name , c -> listen_group ) ; return - 1 ; } wp -> socket_gid = grp -> gr_gid ; } if ( c -> listen_mode && * c -> listen_mode ) { wp -> socket_mode = strtoul ( c -> listen_mode , 0 , 8 ) ; } return 0 ; }
CWE-119 int vp8_full_search_sadx3 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) { <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
CWE-119 void vp9_loop_filter_frame_init ( VP9_COMMON * cm , int default_filt_lvl ) { int seg_id ; const int scale = 1 << ( default_filt_lvl >> 5 ) ; loop_filter_info_n * const lfi = & cm -> lf_info ; struct loopfilter * const lf = & cm -> lf ; const struct segmentation * const seg = & cm -> seg ; if ( lf -> last_sharpness_level != lf -> sharpness_level ) { update_sharpness ( lfi , lf -> sharpness_level ) ; lf -> last_sharpness_level = lf -> sharpness_level ; } for ( seg_id = 0 ; seg_id < MAX_SEGMENTS ; seg_id ++ ) { int lvl_seg = default_filt_lvl ; <S2SV_StartBug> if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; <S2SV_EndBug> lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ; } if ( ! lf -> mode_ref_delta_enabled ) { <S2SV_StartBug> vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <S2SV_EndBug> } else { int ref , mode ; const int intra_lvl = lvl_seg + lf -> ref_deltas [ INTRA_FRAME ] * scale ; lfi -> lvl [ seg_id ] [ INTRA_FRAME ] [ 0 ] = clamp ( intra_lvl , 0 , MAX_LOOP_FILTER ) ; for ( ref = LAST_FRAME ; ref < MAX_REF_FRAMES ; ++ ref ) { for ( mode = 0 ; mode < MAX_MODE_LF_DELTAS ; ++ mode ) { const int inter_lvl = lvl_seg + lf -> ref_deltas [ ref ] * scale + lf -> mode_deltas [ mode ] * scale ; lfi -> lvl [ seg_id ] [ ref ] [ mode ] = clamp ( inter_lvl , 0 , MAX_LOOP_FILTER ) ; } } } } }
CWE-000 static int crypto_report_comp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_comp rcomp ; <S2SV_StartBug> snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , "%s" , "compression" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-125 static int xid_map_enter ( netdissect_options * ndo , const struct sunrpc_msg * rp , const u_char * bp ) { const struct ip * ip = NULL ; const struct ip6_hdr * ip6 = NULL ; struct xid_map_entry * xmep ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 ) ; switch ( IP_V ( ( const struct ip * ) bp ) ) { case 4 : ip = ( const struct ip * ) bp ; break ; case 6 : ip6 = ( const struct ip6_hdr * ) bp ; break ; default : return ( 1 ) ; } xmep = & xid_map [ xid_map_next ] ; if ( ++ xid_map_next >= XIDMAPSIZE ) xid_map_next = 0 ; UNALIGNED_MEMCPY ( & xmep -> xid , & rp -> rm_xid , sizeof ( xmep -> xid ) ) ; if ( ip ) { xmep -> ipver = 4 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip -> ip_src , sizeof ( ip -> ip_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip -> ip_dst , sizeof ( ip -> ip_dst ) ) ; } else if ( ip6 ) { xmep -> ipver = 6 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip6 -> ip6_src , sizeof ( ip6 -> ip6_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip6 -> ip6_dst , sizeof ( ip6 -> ip6_dst ) ) ; } <S2SV_StartBug> xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; <S2SV_EndBug> xmep -> vers = EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) ; return ( 1 ) ; }
CWE-284 static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ; err = scm_send ( sock , msg , siocb -> scm , true ) ; if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; <S2SV_StartBug> if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) <S2SV_EndBug> goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL ) goto out ; NETLINK_CB ( skb ) . pid = nlk -> pid ; NETLINK_CB ( skb ) . dst_group = dst_group ; memcpy ( NETLINK_CREDS ( skb ) , & siocb -> scm -> creds , sizeof ( struct ucred ) ) ; err = - EFAULT ; if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) { kfree_skb ( skb ) ; goto out ; } err = security_netlink_send ( sk , skb ) ; if ( err ) { kfree_skb ( skb ) ; goto out ; } if ( dst_group ) { atomic_inc ( & skb -> users ) ; netlink_broadcast ( sk , skb , dst_pid , dst_group , GFP_KERNEL ) ; } err = netlink_unicast ( sk , skb , dst_pid , msg -> msg_flags & MSG_DONTWAIT ) ; out : scm_destroy ( siocb -> scm ) ; return err ; }
CWE-119 static int futex_wait ( u32 __user * uaddr , int fshared , u32 val , ktime_t * abs_time , u32 bitset , int clockrt ) { struct hrtimer_sleeper timeout , * to = NULL ; struct restart_block * restart ; struct futex_hash_bucket * hb ; struct futex_q q ; int ret ; if ( ! bitset ) return - EINVAL ; q . pi_state = NULL ; q . bitset = bitset ; q . rt_waiter = NULL ; q . requeue_pi_key = NULL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } retry : ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; if ( ret ) goto out ; futex_wait_queue_me ( hb , & q , to ) ; ret = 0 ; if ( ! unqueue_me ( & q ) ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> ret = - ETIMEDOUT ; if ( to && ! to -> task ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> <S2SV_StartBug> if ( ! signal_pending ( current ) ) { <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; goto retry ; <S2SV_StartBug> } <S2SV_EndBug> ret = - ERESTARTSYS ; if ( ! abs_time ) <S2SV_StartBug> goto out_put_key ; <S2SV_EndBug> restart = & current_thread_info ( ) -> restart_block ; restart -> fn = futex_wait_restart ; restart -> futex . uaddr = ( u32 * ) uaddr ; restart -> futex . val = val ; restart -> futex . time = abs_time -> tv64 ; restart -> futex . bitset = bitset ; restart -> futex . flags = FLAGS_HAS_TIMEOUT ; if ( fshared ) restart -> futex . flags |= FLAGS_SHARED ; if ( clockrt ) restart -> futex . flags |= FLAGS_CLOCKRT ; ret = - ERESTART_RESTARTBLOCK ; <S2SV_StartBug> out_put_key : <S2SV_EndBug> put_futex_key ( fshared , & q . key ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }
CWE-000 static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) { struct Client * agent_p = NULL ; struct Client * saslserv_p = NULL ; if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ; if ( strlen ( client_p -> id ) == 3 ) { <S2SV_StartBug> exit_client ( client_p , client_p , client_p , "Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol" ) ; <S2SV_EndBug> return 0 ; } saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ; if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) { sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? "*" : source_p -> name ) ; return 0 ; } if ( source_p -> localClient -> sasl_complete ) { * source_p -> localClient -> sasl_agent = '\\0' ; source_p -> localClient -> sasl_complete = 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? "*" : source_p -> name ) ; return 0 ; } if ( ! * source_p -> id ) { strcpy ( source_p -> id , generate_uid ( ) ) ; add_to_id_hash ( source_p -> id , source_p ) ; } if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ; if ( agent_p == NULL ) { sendto_one ( saslserv_p , ":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>H<S2SV_blank>%s<S2SV_blank>%s" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , source_p -> host , source_p -> sockhost ) ; if ( ! strcmp ( parv [ 1 ] , "EXTERNAL" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , ":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>%s" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ; else sendto_one ( saslserv_p , ":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ; rb_strlcpy ( source_p -> localClient -> sasl_agent , saslserv_p -> id , IDLEN ) ; } else sendto_one ( agent_p , ":%s<S2SV_blank>ENCAP<S2SV_blank>%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>C<S2SV_blank>%s" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ; source_p -> localClient -> sasl_out ++ ; return 0 ; }
CWE-200 int ext4_map_blocks ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , int flags ) { struct extent_status es ; int retval ; int ret = 0 ; # ifdef ES_AGGRESSIVE_TEST struct ext4_map_blocks orig_map ; memcpy ( & orig_map , map , sizeof ( * map ) ) ; # endif map -> m_flags = 0 ; ext_debug ( "ext4_map_blocks():<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>flag<S2SV_blank>%d,<S2SV_blank>max_blocks<S2SV_blank>%u," "logical<S2SV_blank>block<S2SV_blank>%lu\\n" , inode -> i_ino , flags , map -> m_len , ( unsigned long ) map -> m_lblk ) ; if ( unlikely ( map -> m_len > INT_MAX ) ) map -> m_len = INT_MAX ; if ( unlikely ( map -> m_lblk >= EXT_MAX_BLOCKS ) ) return - EFSCORRUPTED ; if ( ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) || ext4_es_is_unwritten ( & es ) ) { map -> m_pblk = ext4_es_pblock ( & es ) + map -> m_lblk - es . es_lblk ; map -> m_flags |= ext4_es_is_written ( & es ) ? EXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; } else if ( ext4_es_is_delayed ( & es ) || ext4_es_is_hole ( & es ) ) { map -> m_pblk = 0 ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; retval = 0 ; } else { BUG_ON ( 1 ) ; } # ifdef ES_AGGRESSIVE_TEST ext4_map_blocks_es_recheck ( handle , inode , map , & orig_map , flags ) ; # endif goto found ; } down_read ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , "ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>" "%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) retval = ret ; } up_read ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; found : if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; } if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ; map -> m_flags &= ~ EXT4_MAP_FLAGS ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) { ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ; } if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , "ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>" "%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) { ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ; if ( ret ) { retval = ret ; goto out_sem ; } } if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) ) goto out_sem ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) { retval = ret ; goto out_sem ; } } out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; <S2SV_StartBug> } <S2SV_EndBug> return retval ; }
CWE-000 static void flatpak_proxy_client_init ( FlatpakProxyClient * client ) { init_side ( client , & client -> client_side ) ; init_side ( client , & client -> bus_side ) ; <S2SV_StartBug> client -> auth_end_offset = AUTH_END_INIT_OFFSET ; <S2SV_EndBug> client -> rewrite_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_object_unref ) ; client -> get_owner_reply = g_hash_table_new_full ( g_direct_hash , g_direct_equal , NULL , g_free ) ; client -> unique_id_policy = g_hash_table_new_full ( g_str_hash , g_str_equal , g_free , NULL ) ; }
CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }
CWE-20 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ; <S2SV_StartBug> nd -> last_type = LAST_BIND ; <S2SV_EndBug> out : return ERR_PTR ( error ) ; }
CWE-200 static int rfcomm_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct bt_security sec ; int len , err = 0 ; BT_DBG ( "sk<S2SV_blank>%p" , sk ) ; if ( level == SOL_RFCOMM ) return rfcomm_sock_getsockopt_old ( sock , optname , optval , optlen ) ; if ( level != SOL_BLUETOOTH ) return - ENOPROTOOPT ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case BT_SECURITY : if ( sk -> sk_type != SOCK_STREAM ) { err = - EINVAL ; break ; } sec . level = rfcomm_pi ( sk ) -> sec_level ; <S2SV_StartBug> len = min_t ( unsigned int , len , sizeof ( sec ) ) ; <S2SV_EndBug> if ( copy_to_user ( optval , ( char * ) & sec , len ) ) err = - EFAULT ; break ; case BT_DEFER_SETUP : if ( sk -> sk_state != BT_BOUND && sk -> sk_state != BT_LISTEN ) { err = - EINVAL ; break ; } if ( put_user ( test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) , ( u32 __user * ) optval ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return err ; }
CWE-119 MagickExport void * AcquireQuantumMemory ( const size_t count , const size_t quantum ) { size_t extent ; <S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> return ( ( void * ) NULL ) ; extent = count * quantum ; return ( AcquireMagickMemory ( extent ) ) ; }
CWE-399 int BN_GF2m_mod_inv ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) { BIGNUM * b , * c = NULL , * u = NULL , * v = NULL , * tmp ; int ret = 0 ; bn_check_top ( a ) ; bn_check_top ( p ) ; BN_CTX_start ( ctx ) ; if ( ( b = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( c = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( u = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( v = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ! BN_GF2m_mod ( u , a , p ) ) goto err ; if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_copy ( v , p ) ) goto err ; # if 0 if ( ! BN_one ( b ) ) goto err ; while ( 1 ) { while ( ! BN_is_odd ( u ) ) { if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_rshift1 ( u , u ) ) goto err ; if ( BN_is_odd ( b ) ) { if ( ! BN_GF2m_add ( b , b , p ) ) goto err ; } if ( ! BN_rshift1 ( b , b ) ) goto err ; } if ( BN_abs_is_word ( u , 1 ) ) break ; if ( BN_num_bits ( u ) < BN_num_bits ( v ) ) { tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; } if ( ! BN_GF2m_add ( u , u , v ) ) goto err ; if ( ! BN_GF2m_add ( b , b , c ) ) goto err ; } # else { <S2SV_StartBug> int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) , <S2SV_EndBug> top = p -> top ; BN_ULONG * udp , * bdp , * vdp , * cdp ; bn_wexpand ( u , top ) ; udp = u -> d ; for ( i = u -> top ; i < top ; i ++ ) udp [ i ] = 0 ; u -> top = top ; bn_wexpand ( b , top ) ; bdp = b -> d ; bdp [ 0 ] = 1 ; for ( i = 1 ; i < top ; i ++ ) bdp [ i ] = 0 ; b -> top = top ; bn_wexpand ( c , top ) ; cdp = c -> d ; for ( i = 0 ; i < top ; i ++ ) cdp [ i ] = 0 ; c -> top = top ; vdp = v -> d ; while ( 1 ) { while ( ubits && ! ( udp [ 0 ] & 1 ) ) { BN_ULONG u0 , u1 , b0 , b1 , mask ; u0 = udp [ 0 ] ; b0 = bdp [ 0 ] ; mask = ( BN_ULONG ) 0 - ( b0 & 1 ) ; b0 ^= p -> d [ 0 ] & mask ; for ( i = 0 ; i < top - 1 ; i ++ ) { u1 = udp [ i + 1 ] ; udp [ i ] = ( ( u0 >> 1 ) | ( u1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; u0 = u1 ; b1 = bdp [ i + 1 ] ^ ( p -> d [ i + 1 ] & mask ) ; bdp [ i ] = ( ( b0 >> 1 ) | ( b1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; b0 = b1 ; } udp [ i ] = u0 >> 1 ; bdp [ i ] = b0 >> 1 ; ubits -- ; } <S2SV_StartBug> if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> if ( ubits < vbits ) { i = ubits ; ubits = vbits ; vbits = i ; tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; udp = vdp ; vdp = v -> d ; bdp = cdp ; cdp = c -> d ; } for ( i = 0 ; i < top ; i ++ ) { udp [ i ] ^= vdp [ i ] ; bdp [ i ] ^= cdp [ i ] ; } if ( ubits == vbits ) { BN_ULONG ul ; int utop = ( ubits - 1 ) / BN_BITS2 ; while ( ( ul = udp [ utop ] ) == 0 && utop ) utop -- ; ubits = utop * BN_BITS2 + BN_num_bits_word ( ul ) ; } } bn_correct_top ( b ) ; } # endif if ( ! BN_copy ( r , b ) ) goto err ; bn_check_top ( r ) ; ret = 1 ; err : # ifdef BN_DEBUG bn_correct_top ( c ) ; bn_correct_top ( u ) ; bn_correct_top ( v ) ; # endif BN_CTX_end ( ctx ) ; return ret ; }
CWE-189 int sysMapFile ( const char * fn , MemMapping * pMap ) { memset ( pMap , 0 , sizeof ( * pMap ) ) ; if ( fn && fn [ 0 ] == '@' ) { FILE * mapf = fopen ( fn + 1 , "r" ) ; if ( mapf == NULL ) { LOGV ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s\\n" , fn + 1 , strerror ( errno ) ) ; return - 1 ; } if ( sysMapBlockFile ( mapf , pMap ) != 0 ) { LOGW ( "Map<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>failed\\n" , fn ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } fclose ( mapf ) ; } else { int fd = open ( fn , O_RDONLY , 0 ) ; if ( fd < 0 ) { LOGE ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s\\n" , fn , strerror ( errno ) ) ; return - 1 ; } if ( sysMapFD ( fd , pMap ) != 0 ) { LOGE ( "Map<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>failed\\n" , fn ) ; close ( fd ) ; return - 1 ; } close ( fd ) ; } return 0 ; }
CWE-200 enum auth_stat gssrpc__svcauth_gss ( struct svc_req * rqst , struct rpc_msg * msg , bool_t * no_dispatch ) { enum auth_stat retstat ; XDR xdrs ; SVCAUTH * auth ; struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; struct rpc_gss_init_res gr ; int call_stat , offset ; OM_uint32 min_stat ; log_debug ( "in<S2SV_blank>svcauth_gss()" ) ; rqst -> rq_xprt -> xp_verf = gssrpc__null_auth ; if ( rqst -> rq_xprt -> xp_auth == NULL || rqst -> rq_xprt -> xp_auth == & svc_auth_none ) { if ( ( auth = calloc ( sizeof ( * auth ) , 1 ) ) == NULL ) { fprintf ( stderr , "svcauth_gss:<S2SV_blank>out_of_memory\\n" ) ; return ( AUTH_FAILED ) ; } if ( ( gd = calloc ( sizeof ( * gd ) , 1 ) ) == NULL ) { fprintf ( stderr , "svcauth_gss:<S2SV_blank>out_of_memory\\n" ) ; return ( AUTH_FAILED ) ; } auth -> svc_ah_ops = & svc_auth_gss_ops ; SVCAUTH_PRIVATE ( auth ) = gd ; rqst -> rq_xprt -> xp_auth = auth ; } else gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; log_debug ( "xp_auth=%p,<S2SV_blank>gd=%p" , rqst -> rq_xprt -> xp_auth , gd ) ; if ( rqst -> rq_cred . oa_length <= 0 ) return ( AUTH_BADCRED ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gc , 0 , sizeof ( * gc ) ) ; log_debug ( "calling<S2SV_blank>xdrmem_create()" ) ; log_debug ( "oa_base=%p,<S2SV_blank>oa_length=%u" , rqst -> rq_cred . oa_base , rqst -> rq_cred . oa_length ) ; xdrmem_create ( & xdrs , rqst -> rq_cred . oa_base , rqst -> rq_cred . oa_length , XDR_DECODE ) ; log_debug ( "xdrmem_create()<S2SV_blank>returned" ) ; if ( ! xdr_rpc_gss_cred ( & xdrs , gc ) ) { log_debug ( "xdr_rpc_gss_cred()<S2SV_blank>failed" ) ; XDR_DESTROY ( & xdrs ) ; return ( AUTH_BADCRED ) ; } XDR_DESTROY ( & xdrs ) ; retstat = AUTH_FAILED ; # define ret_freegc ( code ) do { retstat = code ; goto freegc ; } while ( 0 ) if ( gc -> gc_v != RPCSEC_GSS_VERSION ) ret_freegc ( AUTH_BADCRED ) ; if ( gc -> gc_svc != RPCSEC_GSS_SVC_NONE && gc -> gc_svc != RPCSEC_GSS_SVC_INTEGRITY && gc -> gc_svc != RPCSEC_GSS_SVC_PRIVACY ) ret_freegc ( AUTH_BADCRED ) ; if ( gd -> established ) { if ( gc -> gc_seq > MAXSEQ ) ret_freegc ( RPCSEC_GSS_CTXPROBLEM ) ; if ( ( offset = gd -> seqlast - gc -> gc_seq ) < 0 ) { gd -> seqlast = gc -> gc_seq ; offset = 0 - offset ; gd -> seqmask <<= offset ; offset = 0 ; } else if ( ( u_int ) offset >= gd -> win || ( gd -> seqmask & ( 1 << offset ) ) ) { * no_dispatch = 1 ; ret_freegc ( RPCSEC_GSS_CTXPROBLEM ) ; } gd -> seq = gc -> gc_seq ; gd -> seqmask |= ( 1 << offset ) ; } if ( gd -> established ) { rqst -> rq_clntname = ( char * ) gd -> client_name ; rqst -> rq_svccred = ( char * ) gd -> ctx ; } switch ( gc -> gc_proc ) { case RPCSEC_GSS_INIT : case RPCSEC_GSS_CONTINUE_INIT : if ( rqst -> rq_proc != NULLPROC ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_acquire_cred ( ) ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_accept_sec_context ( rqst , & gr ) ) ret_freegc ( AUTH_REJECTEDCRED ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gr . gr_win ) ) ) { gss_release_buffer ( & min_stat , & gr . gr_token ) ; <S2SV_StartBug> mem_free ( gr . gr_ctx . value , <S2SV_EndBug> sizeof ( gss_union_ctx_id_desc ) ) ; ret_freegc ( AUTH_FAILED ) ; } * no_dispatch = TRUE ; call_stat = svc_sendreply ( rqst -> rq_xprt , xdr_rpc_gss_init_res , ( caddr_t ) & gr ) ; gss_release_buffer ( & min_stat , & gr . gr_token ) ; <S2SV_StartBug> gss_release_buffer ( & min_stat , & gd -> checksum ) ; <S2SV_EndBug> mem_free ( gr . gr_ctx . value , sizeof ( gss_union_ctx_id_desc ) ) ; if ( ! call_stat ) ret_freegc ( AUTH_FAILED ) ; if ( gr . gr_major == GSS_S_COMPLETE ) gd -> established = TRUE ; break ; case RPCSEC_GSS_DATA : if ( ! svcauth_gss_validate ( rqst , gd , msg ) ) ret_freegc ( RPCSEC_GSS_CREDPROBLEM ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gc -> gc_seq ) ) ) ret_freegc ( AUTH_FAILED ) ; break ; case RPCSEC_GSS_DESTROY : if ( rqst -> rq_proc != NULLPROC ) ret_freegc ( AUTH_FAILED ) ; if ( ! svcauth_gss_validate ( rqst , gd , msg ) ) ret_freegc ( RPCSEC_GSS_CREDPROBLEM ) ; if ( ! svcauth_gss_nextverf ( rqst , htonl ( gc -> gc_seq ) ) ) ret_freegc ( AUTH_FAILED ) ; * no_dispatch = TRUE ; call_stat = svc_sendreply ( rqst -> rq_xprt , xdr_void , ( caddr_t ) NULL ) ; log_debug ( "sendreply<S2SV_blank>in<S2SV_blank>destroy:<S2SV_blank>%d" , call_stat ) ; if ( ! svcauth_gss_release_cred ( ) ) ret_freegc ( AUTH_FAILED ) ; SVCAUTH_DESTROY ( rqst -> rq_xprt -> xp_auth ) ; rqst -> rq_xprt -> xp_auth = & svc_auth_none ; break ; default : ret_freegc ( AUTH_REJECTEDCRED ) ; break ; } retstat = AUTH_OK ; freegc : xdr_free ( xdr_rpc_gss_cred , gc ) ; log_debug ( "returning<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>svcauth_gss()" , retstat ) ; return ( retstat ) ; }
CWE-000 static int __mkroute_input ( struct sk_buff * skb , const struct fib_result * res , struct in_device * in_dev , __be32 daddr , __be32 saddr , u32 tos ) { struct fib_nh_exception * fnhe ; struct rtable * rth ; int err ; struct in_device * out_dev ; unsigned int flags = 0 ; bool do_cache ; u32 itag = 0 ; out_dev = __in_dev_get_rcu ( FIB_RES_DEV ( * res ) ) ; if ( out_dev == NULL ) { net_crit_ratelimited ( "Bug<S2SV_blank>in<S2SV_blank>ip_route_input_slow().<S2SV_blank>Please<S2SV_blank>report.\\n" ) ; return - EINVAL ; } err = fib_validate_source ( skb , saddr , daddr , tos , FIB_RES_OIF ( * res ) , in_dev -> dev , in_dev , & itag ) ; if ( err < 0 ) { ip_handle_martian_source ( in_dev -> dev , in_dev , skb , daddr , saddr ) ; goto cleanup ; } do_cache = res -> fi && ! itag ; if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) && <S2SV_StartBug> ( IN_DEV_SHARED_MEDIA ( out_dev ) || <S2SV_EndBug> <S2SV_StartBug> inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) { <S2SV_EndBug> flags |= RTCF_DOREDIRECT ; do_cache = false ; } if ( skb -> protocol != htons ( ETH_P_IP ) ) { if ( out_dev == in_dev && IN_DEV_PROXY_ARP_PVLAN ( in_dev ) == 0 ) { err = - EINVAL ; goto cleanup ; } } fnhe = find_exception ( & FIB_RES_NH ( * res ) , daddr ) ; if ( do_cache ) { if ( fnhe != NULL ) rth = rcu_dereference ( fnhe -> fnhe_rth_input ) ; else rth = rcu_dereference ( FIB_RES_NH ( * res ) . nh_rth_input ) ; if ( rt_cache_valid ( rth ) ) { skb_dst_set_noref ( skb , & rth -> dst ) ; goto out ; } } rth = rt_dst_alloc ( out_dev -> dev , IN_DEV_CONF_GET ( in_dev , NOPOLICY ) , IN_DEV_CONF_GET ( out_dev , NOXFRM ) , do_cache ) ; if ( ! rth ) { err = - ENOBUFS ; goto cleanup ; } rth -> rt_genid = rt_genid_ipv4 ( dev_net ( rth -> dst . dev ) ) ; rth -> rt_flags = flags ; rth -> rt_type = res -> type ; rth -> rt_is_input = 1 ; rth -> rt_iif = 0 ; rth -> rt_pmtu = 0 ; rth -> rt_gateway = 0 ; rth -> rt_uses_gateway = 0 ; INIT_LIST_HEAD ( & rth -> rt_uncached ) ; RT_CACHE_STAT_INC ( in_slow_tot ) ; rth -> dst . input = ip_forward ; rth -> dst . output = ip_output ; rt_set_nexthop ( rth , daddr , res , fnhe , res -> fi , res -> type , itag ) ; skb_dst_set ( skb , & rth -> dst ) ; out : err = 0 ; cleanup : return err ; }
CWE-119 <S2SV_StartBug> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> vpx_fixed_buf_t * stats ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>frame<S2SV_blank>stats." ) ; while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_StartBug> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <S2SV_EndBug> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ; const size_t pkt_size = pkt -> data . twopass_stats . sz ; stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ; memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ; stats -> sz += pkt_size ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }
CWE-125 static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && <S2SV_StartBug> rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && <S2SV_EndBug> rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
CWE-000 int jffs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int rc , xprefix ; switch ( type ) { case ACL_TYPE_ACCESS : xprefix = JFFS2_XPREFIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( rc < 0 ) return rc ; if ( inode -> i_mode != mode ) { struct iattr attr ; attr . ia_valid = ATTR_MODE | ATTR_CTIME ; attr . ia_mode = mode ; attr . ia_ctime = CURRENT_TIME_SEC ; rc = jffs2_do_setattr ( inode , & attr ) ; if ( rc < 0 ) return rc ; } <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug> acl = NULL ; } break ; case ACL_TYPE_DEFAULT : xprefix = JFFS2_XPREFIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } rc = __jffs2_set_acl ( inode , xprefix , acl ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }
CWE-119 static void update_best_mode ( BEST_MODE * best_mode , int this_rd , RATE_DISTORTION * rd , int other_cost , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; other_cost += x -> ref_frame_cost [ x -> e_mbd . mode_info_context -> mbmi . ref_frame ] ; best_mode -> yrd = RDCOST ( x -> rdmult , x -> rddiv , ( rd -> rate2 - rd -> rate_uv - other_cost ) , ( rd -> distortion2 - rd -> distortion_uv ) ) ; best_mode -> rd = this_rd ; <S2SV_StartBug> vpx_memcpy ( & best_mode -> mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & best_mode -> partition , x -> partition_info , sizeof ( PARTITION_INFO ) ) ; <S2SV_EndBug> if ( ( this_mode == B_PRED ) || ( this_mode == SPLITMV ) ) { int i ; for ( i = 0 ; i < 16 ; i ++ ) { best_mode -> bmodes [ i ] = x -> e_mbd . block [ i ] . bmi ; } } }
CWE-000 static int crypto_report_kpp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_kpp rkpp ; <S2SV_StartBug> strlcpy ( rkpp . type , "kpp" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-416 static int ipxitf_ioctl ( unsigned int cmd , void __user * arg ) { int rc = - EINVAL ; struct ifreq ifr ; int val ; switch ( cmd ) { case SIOCSIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface_definition f ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; rc = - EINVAL ; if ( sipx -> sipx_family != AF_IPX ) break ; f . ipx_network = sipx -> sipx_network ; memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ; memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ; f . ipx_dlink_type = sipx -> sipx_type ; f . ipx_special = sipx -> sipx_special ; if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ; else rc = ipxitf_create ( & f ) ; break ; } case SIOCGIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface * ipxif ; struct net_device * dev ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ; rc = - ENODEV ; if ( ! dev ) break ; ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type ) ) ; rc = - EADDRNOTAVAIL ; if ( ! ipxif ) break ; sipx -> sipx_family = AF_IPX ; sipx -> sipx_network = ipxif -> if_netnum ; memcpy ( sipx -> sipx_node , ipxif -> if_node , sizeof ( sipx -> sipx_node ) ) ; <S2SV_StartBug> rc = - EFAULT ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) <S2SV_EndBug> break ; <S2SV_StartBug> ipxitf_put ( ipxif ) ; <S2SV_EndBug> rc = 0 ; break ; } case SIOCAIPXITFCRT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_auto_create_interfaces = val ; break ; case SIOCAIPXPRISLT : rc = - EFAULT ; if ( get_user ( val , ( unsigned char __user * ) arg ) ) break ; rc = 0 ; ipxcfg_set_auto_select ( val ) ; break ; } return rc ; }
CWE-000 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }
CWE-000 SYSCALL_DEFINE3 ( rt_sigqueueinfo , pid_t , pid , int , sig , siginfo_t __user * , uinfo ) { siginfo_t info ; if ( copy_from_user ( & info , uinfo , sizeof ( siginfo_t ) ) ) return - EFAULT ; <S2SV_StartBug> if ( info . si_code >= 0 ) <S2SV_EndBug> <S2SV_StartBug> return - EPERM ; <S2SV_EndBug> info . si_signo = sig ; return kill_proc_info ( sig , & info , pid ) ; }
CWE-284 int bta_co_rfc_data_outgoing ( void * user_data , uint8_t * buf , uint16_t size ) { pthread_mutex_lock ( & slot_lock ) ; uint32_t id = ( uintptr_t ) user_data ; int ret = false ; rfc_slot_t * slot = find_rfc_slot_by_id ( id ) ; if ( ! slot ) goto out ; <S2SV_StartBug> int received = recv ( slot -> fd , buf , size , 0 ) ; <S2SV_EndBug> if ( received == size ) { ret = true ; } else { LOG_ERROR ( "%s<S2SV_blank>error<S2SV_blank>receiving<S2SV_blank>RFCOMM<S2SV_blank>data<S2SV_blank>from<S2SV_blank>app:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; return ret ; }
CWE-119 <S2SV_StartBug> void open_input_file ( struct VpxInputContext * input ) { <S2SV_EndBug> input -> file = strcmp ( input -> filename , "-" ) ? fopen ( input -> filename , "rb" ) : set_binary_mode ( stdin ) ; if ( ! input -> file ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file" ) ; if ( ! fseeko ( input -> file , 0 , SEEK_END ) ) { input -> length = ftello ( input -> file ) ; rewind ( input -> file ) ; } <S2SV_StartBug> input -> detect . buf_read = fread ( input -> detect . buf , 1 , 4 , input -> file ) ; <S2SV_EndBug> input -> detect . position = 0 ; if ( input -> detect . buf_read == 4 && file_is_y4m ( input -> detect . buf ) ) { if ( y4m_input_open ( & input -> y4m , input -> file , input -> detect . buf , 4 , input -> only_i420 ) >= 0 ) { input -> file_type = FILE_TYPE_Y4M ; input -> width = input -> y4m . pic_w ; input -> height = input -> y4m . pic_h ; <S2SV_StartBug> input -> framerate . numerator = input -> y4m . fps_n ; <S2SV_EndBug> input -> framerate . denominator = input -> y4m . fps_d ; <S2SV_StartBug> input -> use_i420 = 0 ; <S2SV_EndBug> } else fatal ( "Unsupported<S2SV_blank>Y4M<S2SV_blank>stream." ) ; } else if ( input -> detect . buf_read == 4 && fourcc_is_ivf ( input -> detect . buf ) ) { fatal ( "IVF<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>as<S2SV_blank>input." ) ; } else { input -> file_type = FILE_TYPE_RAW ; } }
CWE-125 static void sycc444_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max , i ; <S2SV_EndBug> int offset , upb ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < max ; ++ i ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ cb ; ++ cr ; ++ r ; ++ g ; ++ b ; } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> return ; <S2SV_EndBug> fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> if ( g ) free ( g ) ; if ( b ) free ( b ) ; }
CWE-190 bool layer_resize ( int layer , int x_size , int y_size ) { int old_height ; int old_width ; struct map_tile * tile ; int tile_width ; int tile_height ; struct map_tile * tilemap ; struct map_trigger * trigger ; struct map_zone * zone ; <S2SV_StartBug> int x , y , i ; <S2SV_EndBug> old_width = s_map -> layers [ layer ] . width ; old_height = s_map -> layers [ layer ] . height ; <S2SV_StartBug> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <S2SV_EndBug> return false ; for ( x = 0 ; x < x_size ; ++ x ) { for ( y = 0 ; y < y_size ; ++ y ) { if ( x < old_width && y < old_height ) { tilemap [ x + y * x_size ] = s_map -> layers [ layer ] . tilemap [ x + y * old_width ] ; } else { tile = & tilemap [ x + y * x_size ] ; tile -> frames_left = tileset_get_delay ( s_map -> tileset , 0 ) ; tile -> tile_index = 0 ; } } } free ( s_map -> layers [ layer ] . tilemap ) ; s_map -> layers [ layer ] . tilemap = tilemap ; s_map -> layers [ layer ] . width = x_size ; s_map -> layers [ layer ] . height = y_size ; tileset_get_size ( s_map -> tileset , & tile_width , & tile_height ) ; s_map -> width = 0 ; s_map -> height = 0 ; for ( i = 0 ; i < s_map -> num_layers ; ++ i ) { if ( ! s_map -> layers [ i ] . is_parallax ) { s_map -> width = fmax ( s_map -> width , s_map -> layers [ i ] . width * tile_width ) ; s_map -> height = fmax ( s_map -> height , s_map -> layers [ i ] . height * tile_height ) ; } } for ( i = ( int ) vector_len ( s_map -> zones ) - 1 ; i >= 0 ; -- i ) { zone = vector_get ( s_map -> zones , i ) ; if ( zone -> bounds . x1 >= s_map -> width || zone -> bounds . y1 >= s_map -> height ) vector_remove ( s_map -> zones , i ) ; else { if ( zone -> bounds . x2 > s_map -> width ) zone -> bounds . x2 = s_map -> width ; if ( zone -> bounds . y2 > s_map -> height ) zone -> bounds . y2 = s_map -> height ; } } for ( i = ( int ) vector_len ( s_map -> triggers ) - 1 ; i >= 0 ; -- i ) { trigger = vector_get ( s_map -> triggers , i ) ; if ( trigger -> x >= s_map -> width || trigger -> y >= s_map -> height ) vector_remove ( s_map -> triggers , i ) ; } return true ; }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> }
CWE-000 tmsize_t TIFFReadEncodedStrip ( TIFF * tif , uint32 strip , void * buf , tmsize_t size ) { static const char module [ ] = "TIFFReadEncodedStrip" ; TIFFDirectory * td = & tif -> tif_dir ; uint32 rowsperstrip ; uint32 stripsperplane ; uint32 stripinplane ; uint16 plane ; uint32 rows ; tmsize_t stripsize ; if ( ! TIFFCheckRead ( tif , 0 ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( strip >= td -> td_nstrips ) { TIFFErrorExt ( tif -> tif_clientdata , module , "%lu:<S2SV_blank>Strip<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>max<S2SV_blank>%lu" , ( unsigned long ) strip , ( unsigned long ) td -> td_nstrips ) ; return ( ( tmsize_t ) ( - 1 ) ) ; } rowsperstrip = td -> td_rowsperstrip ; if ( rowsperstrip > td -> td_imagelength ) rowsperstrip = td -> td_imagelength ; <S2SV_StartBug> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; <S2SV_EndBug> stripinplane = ( strip % stripsperplane ) ; plane = ( uint16 ) ( strip / stripsperplane ) ; rows = td -> td_imagelength - stripinplane * rowsperstrip ; if ( rows > rowsperstrip ) rows = rowsperstrip ; stripsize = TIFFVStripSize ( tif , rows ) ; if ( stripsize == 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( td -> td_compression == COMPRESSION_NONE && size != ( tmsize_t ) ( - 1 ) && size >= stripsize && ! isMapped ( tif ) && ( ( tif -> tif_flags & TIFF_NOREADRAW ) == 0 ) ) { if ( TIFFReadRawStrip1 ( tif , strip , buf , stripsize , module ) != stripsize ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( ! isFillOrder ( tif , td -> td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( buf , stripsize ) ; ( * tif -> tif_postdecode ) ( tif , buf , stripsize ) ; return ( stripsize ) ; } if ( ( size != ( tmsize_t ) ( - 1 ) ) && ( size < stripsize ) ) stripsize = size ; if ( ! TIFFFillStrip ( tif , strip ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( ( * tif -> tif_decodestrip ) ( tif , buf , stripsize , plane ) <= 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; ( * tif -> tif_postdecode ) ( tif , buf , stripsize ) ; return ( stripsize ) ; }
CWE-264 void vlan_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags |= IFF_802_1Q_VLAN ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> ethtool_ops = & vlan_ethtool_ops ; memset ( dev -> broadcast , 0 , ETH_ALEN ) ; }
CWE-415 void gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) { <S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> int interlace , BitsPerPixel ; interlace = im -> interlace ; if ( im -> trueColor ) { <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> if ( ! pim ) { return ; } tim = pim ; } BitsPerPixel = colorstobpp ( tim -> colorsTotal ) ; GIFEncode ( out , tim -> sx , tim -> sy , tim -> interlace , 0 , tim -> transparent , BitsPerPixel , tim -> red , tim -> green , tim -> blue , tim ) ; if ( pim ) { gdImageDestroy ( pim ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-264 int main ( int argc , char * * argv ) { char * oldshell ; int nullshell = 0 ; const uid_t uid = getuid ( ) ; struct sinfo info = { 0 } ; struct passwd * pw ; sanitize_env ( ) ; setlocale ( LC_ALL , "" ) ; bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; atexit ( close_stdout ) ; parse_argv ( argc , argv , & info ) ; if ( ! info . username ) { pw = getpwuid ( uid ) ; if ( ! pw ) errx ( EXIT_FAILURE , _ ( "you<S2SV_blank>(user<S2SV_blank>%d)<S2SV_blank>don\'t<S2SV_blank>exist." ) , uid ) ; } else { pw = getpwnam ( info . username ) ; if ( ! pw ) errx ( EXIT_FAILURE , _ ( "user<S2SV_blank>\\"%s\\"<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist." ) , info . username ) ; } # ifndef HAVE_LIBUSER if ( ! ( is_local ( pw -> pw_name ) ) ) errx ( EXIT_FAILURE , _ ( "can<S2SV_blank>only<S2SV_blank>change<S2SV_blank>local<S2SV_blank>entries" ) ) ; # endif # ifdef HAVE_LIBSELINUX if ( is_selinux_enabled ( ) > 0 ) { if ( uid == 0 ) { if ( checkAccess ( pw -> pw_name , PASSWD__CHSH ) != 0 ) { security_context_t user_context ; if ( getprevcon ( & user_context ) < 0 ) user_context = ( security_context_t ) NULL ; errx ( EXIT_FAILURE , _ ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>change<S2SV_blank>the<S2SV_blank>shell<S2SV_blank>of<S2SV_blank>%s" ) , user_context ? : _ ( "Unknown<S2SV_blank>user<S2SV_blank>context" ) , pw -> pw_name ) ; } } if ( setupDefaultContext ( _PATH_PASSWD ) != 0 ) errx ( EXIT_FAILURE , _ ( "can\'t<S2SV_blank>set<S2SV_blank>default<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%s" ) , _PATH_PASSWD ) ; } # endif oldshell = pw -> pw_shell ; if ( oldshell == NULL || * oldshell == '\\0' ) { oldshell = _PATH_BSHELL ; nullshell = 1 ; } # ifdef HAVE_LIBUSER if ( geteuid ( ) != getuid ( ) && uid != pw -> pw_uid ) { # else if ( uid != 0 && uid != pw -> pw_uid ) { # endif errno = EACCES ; err ( EXIT_FAILURE , _ ( "running<S2SV_blank>UID<S2SV_blank>doesn\'t<S2SV_blank>match<S2SV_blank>UID<S2SV_blank>of<S2SV_blank>user<S2SV_blank>we\'re<S2SV_blank>" "altering,<S2SV_blank>shell<S2SV_blank>change<S2SV_blank>denied" ) ) ; } if ( uid != 0 && ! get_shell_list ( oldshell ) ) { errno = EACCES ; err ( EXIT_FAILURE , _ ( "your<S2SV_blank>shell<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>%s,<S2SV_blank>" "shell<S2SV_blank>change<S2SV_blank>denied" ) , _PATH_SHELLS ) ; } printf ( _ ( "Changing<S2SV_blank>shell<S2SV_blank>for<S2SV_blank>%s.\\n" ) , pw -> pw_name ) ; # if ! defined ( HAVE_LIBUSER ) && defined ( CHFN_CHSH_PASSWORD ) if ( ! auth_pam ( "chsh" , uid , pw -> pw_name ) ) { return EXIT_FAILURE ; } # endif if ( ! info . shell ) { info . shell = ask_new_shell ( _ ( "New<S2SV_blank>shell" ) , oldshell ) ; if ( ! info . shell ) return EXIT_SUCCESS ; } check_shell ( info . shell ) ; if ( ! nullshell && strcmp ( oldshell , info . shell ) == 0 ) errx ( EXIT_SUCCESS , _ ( "Shell<S2SV_blank>not<S2SV_blank>changed." ) ) ; # ifdef HAVE_LIBUSER if ( set_value_libuser ( "chsh" , pw -> pw_name , uid , LU_LOGINSHELL , info . shell ) < 0 ) errx ( EXIT_FAILURE , _ ( "Shell<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later." ) ) ; # else pw -> pw_shell = info . shell ; <S2SV_StartBug> if ( setpwnam ( pw ) < 0 ) <S2SV_EndBug> err ( EXIT_FAILURE , _ ( "setpwnam<S2SV_blank>failed\\n" "Shell<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later." ) ) ; # endif printf ( _ ( "Shell<S2SV_blank>changed.\\n" ) ) ; return EXIT_SUCCESS ; }
CWE-000 static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ; <S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL ) goto out ; NETLINK_CB ( skb ) . pid = nlk -> pid ; NETLINK_CB ( skb ) . dst_group = dst_group ; memcpy ( NETLINK_CREDS ( skb ) , & siocb -> scm -> creds , sizeof ( struct ucred ) ) ; err = - EFAULT ; if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) { kfree_skb ( skb ) ; goto out ; } err = security_netlink_send ( sk , skb ) ; if ( err ) { kfree_skb ( skb ) ; goto out ; } if ( dst_group ) { atomic_inc ( & skb -> users ) ; netlink_broadcast ( sk , skb , dst_pid , dst_group , GFP_KERNEL ) ; } err = netlink_unicast ( sk , skb , dst_pid , msg -> msg_flags & MSG_DONTWAIT ) ; out : scm_destroy ( siocb -> scm ) ; return err ; }
CWE-20 int rose_parse_facilities ( unsigned char * p , struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; if ( facilities_len == 0 ) return 0 ; while ( facilities_len > 0 ) { if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> facilities_len -= len + 1 ; <S2SV_EndBug> p += len + 1 ; break ; default : printk ( KERN_DEBUG "ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }
CWE-125 static u_int ldp_pdu_print ( netdissect_options * ndo , register const u_char * pptr ) { const struct ldp_common_header * ldp_com_header ; const struct ldp_msg_header * ldp_msg_header ; const u_char * tptr , * msg_tptr ; u_short tlen ; u_short pdu_len , msg_len , msg_type , msg_tlen ; int hexdump , processed ; ldp_com_header = ( const struct ldp_common_header * ) pptr ; ND_TCHECK ( * ldp_com_header ) ; if ( EXTRACT_16BITS ( & ldp_com_header -> version ) != LDP_VERSION ) { ND_PRINT ( ( ndo , "%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , EXTRACT_16BITS ( & ldp_com_header -> version ) ) ) ; return 0 ; } pdu_len = EXTRACT_16BITS ( & ldp_com_header -> pdu_length ) ; if ( pdu_len < sizeof ( const struct ldp_common_header ) - 4 ) { ND_PRINT ( ( ndo , "%sLDP,<S2SV_blank>pdu-length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , pdu_len , ( u_int ) ( sizeof ( const struct ldp_common_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , "%sLDP,<S2SV_blank>Label-Space-ID:<S2SV_blank>%s:%u,<S2SV_blank>pdu-length:<S2SV_blank>%u" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , ipaddr_string ( ndo , & ldp_com_header -> lsr_id ) , EXTRACT_16BITS ( & ldp_com_header -> label_space ) , pdu_len ) ) ; if ( ndo -> ndo_vflag < 1 ) return 0 ; tptr = pptr + sizeof ( const struct ldp_common_header ) ; tlen = pdu_len - ( sizeof ( const struct ldp_common_header ) - 4 ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct ldp_msg_header ) ) ; ldp_msg_header = ( const struct ldp_msg_header * ) tptr ; msg_len = EXTRACT_16BITS ( ldp_msg_header -> length ) ; msg_type = LDP_MASK_MSG_TYPE ( EXTRACT_16BITS ( ldp_msg_header -> type ) ) ; if ( msg_len < sizeof ( struct ldp_msg_header ) - 4 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , tok2str ( ldp_msg_values , "Unknown" , msg_type ) , msg_type , msg_len , ( u_int ) ( sizeof ( struct ldp_msg_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>if<S2SV_blank>unknown]" , tok2str ( ldp_msg_values , "Unknown" , msg_type ) , msg_type , msg_len , EXTRACT_32BITS ( & ldp_msg_header -> id ) , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_msg_header -> type ) ) ? "continue<S2SV_blank>processing" : "ignore" ) ) ; msg_tptr = tptr + sizeof ( struct ldp_msg_header ) ; msg_tlen = msg_len - ( sizeof ( struct ldp_msg_header ) - 4 ) ; ND_TCHECK2 ( * tptr , msg_len ) ; hexdump = FALSE ; switch ( msg_type ) { case LDP_MSG_NOTIF : case LDP_MSG_HELLO : case LDP_MSG_INIT : case LDP_MSG_KEEPALIVE : case LDP_MSG_ADDRESS : case LDP_MSG_LABEL_MAPPING : case LDP_MSG_ADDRESS_WITHDRAW : case LDP_MSG_LABEL_WITHDRAW : while ( msg_tlen >= 4 ) { processed = ldp_tlv_print ( ndo , msg_tptr , msg_tlen ) ; if ( processed == 0 ) break ; msg_tlen -= processed ; msg_tptr += processed ; } break ; case LDP_MSG_LABEL_REQUEST : case LDP_MSG_LABEL_RELEASE : case LDP_MSG_LABEL_ABORT_REQUEST : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , msg_tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , msg_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct ldp_msg_header ) , "\\n\\t<S2SV_blank><S2SV_blank>" , msg_len ) ; tptr += msg_len + 4 ; tlen -= msg_len + 4 ; } return pdu_len + 4 ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; <S2SV_EndBug> return 0 ; }
CWE-000 PS_SERIALIZER_DECODE_FUNC ( php_binary ) { const char * p ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ; <S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> for ( p = val ; p < endptr ; ) { <S2SV_StartBug> zval * * tmp ; <S2SV_EndBug> namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ; if ( namelen < 0 || namelen > PS_BIN_MAX || ( p + namelen ) >= endptr ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } has_value = * p & PS_BIN_UNDEF ? 0 : 1 ; name = estrndup ( p + 1 , namelen ) ; p += namelen + 1 ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) { <S2SV_StartBug> efree ( name ) ; <S2SV_EndBug> continue ; } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & p , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) { <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> } else { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; } <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> efree ( name ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }
CWE-000 static void commit_tree ( struct mount * mnt , struct mount * shadows ) { struct mount * parent = mnt -> mnt_parent ; struct mount * m ; LIST_HEAD ( head ) ; struct mnt_namespace * n = parent -> mnt_ns ; BUG_ON ( parent == mnt ) ; list_add_tail ( & head , & mnt -> mnt_list ) ; list_for_each_entry ( m , & head , mnt_list ) m -> mnt_ns = n ; list_splice ( & head , n -> list . prev ) ; <S2SV_StartBug> attach_shadowed ( mnt , parent , shadows ) ; <S2SV_EndBug> touch_mnt_namespace ( n ) ; }
CWE-000 static struct mnt_namespace * create_mnt_ns ( struct vfsmount * m ) { struct mnt_namespace * new_ns = alloc_mnt_ns ( & init_user_ns ) ; if ( ! IS_ERR ( new_ns ) ) { struct mount * mnt = real_mount ( m ) ; mnt -> mnt_ns = new_ns ; new_ns -> root = mnt ; <S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug> } else { mntput ( m ) ; } return new_ns ; }
CWE-200 static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { hci_conn_accept ( pi -> conn -> hcon , 0 ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }
CWE-20 static int lz4_uncompress ( const char * source , char * dest , int osize ) { const BYTE * ip = ( const BYTE * ) source ; const BYTE * ref ; BYTE * op = ( BYTE * ) dest ; BYTE * const oend = op + osize ; BYTE * cpy ; unsigned token ; size_t length ; size_t dec32table [ ] = { 0 , 3 , 2 , 3 , 0 , 0 , 0 , 0 } ; # if LZ4_ARCH64 size_t dec64table [ ] = { 0 , 0 , 0 , - 1 , 0 , 1 , 2 , 3 } ; # endif while ( 1 ) { token = * ip ++ ; length = ( token >> ML_BITS ) ; if ( length == RUN_MASK ) { size_t len ; len = * ip ++ ; for ( ; len == 255 ; length += 255 ) len = * ip ++ ; <S2SV_StartBug> length += len ; <S2SV_EndBug> } cpy = op + length ; if ( unlikely ( cpy > oend - COPYLENGTH ) ) { if ( cpy != oend ) goto _output_error ; memcpy ( op , ip , length ) ; ip += length ; break ; } LZ4_WILDCOPY ( ip , op , cpy ) ; ip -= ( op - cpy ) ; op = cpy ; LZ4_READ_LITTLEENDIAN_16 ( ref , cpy , ip ) ; ip += 2 ; if ( unlikely ( ref < ( BYTE * const ) dest ) ) goto _output_error ; length = token & ML_MASK ; if ( length == ML_MASK ) { for ( ; * ip == 255 ; length += 255 ) ip ++ ; length += * ip ++ ; } if ( unlikely ( ( op - ref ) < STEPSIZE ) ) { # if LZ4_ARCH64 size_t dec64 = dec64table [ op - ref ] ; # else const int dec64 = 0 ; # endif op [ 0 ] = ref [ 0 ] ; op [ 1 ] = ref [ 1 ] ; op [ 2 ] = ref [ 2 ] ; op [ 3 ] = ref [ 3 ] ; op += 4 ; ref += 4 ; ref -= dec32table [ op - ref ] ; PUT4 ( ref , op ) ; op += STEPSIZE - 4 ; ref -= dec64 ; } else { LZ4_COPYSTEP ( ref , op ) ; } cpy = op + length - ( STEPSIZE - 4 ) ; if ( cpy > ( oend - COPYLENGTH ) ) { if ( cpy > oend ) goto _output_error ; LZ4_SECURECOPY ( ref , op , ( oend - COPYLENGTH ) ) ; while ( op < cpy ) * op ++ = * ref ++ ; op = cpy ; if ( op == oend ) goto _output_error ; continue ; } LZ4_SECURECOPY ( ref , op , cpy ) ; op = cpy ; } return ( int ) ( ( ( char * ) ip ) - source ) ; _output_error : return ( int ) ( - ( ( ( char * ) ip ) - source ) ) ; }
CWE-125 static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s]" , bittok2str ( gre_flag_values , "none" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>sum<S2SV_blank>0x%x" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>off<S2SV_blank>0x%x" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>key=0x%x" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>seq<S2SV_blank>%u" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)" , tok2str ( ethertype_values , "unknown" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , ":<S2SV_blank>" ) ) ; else ND_PRINT ( ( ndo , "\\n\\t" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , "gre-proto-0x%x" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-125 static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , "test%u.bson" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( "codewscope.bson" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( "empty_key.bson" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( "overflow2.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "trailingnull.bson" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "dollarquery.bson" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$query\\"" ) ; VALIDATE_TEST ( "dotquery.bson" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOT_KEYS , "keys<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\".\\":<S2SV_blank>\\"abc.def\\"" ) ; VALIDATE_TEST ( "overflow3.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "overflow3.bson" , BSON_VALIDATE_UTF8 , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "overflow4.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "empty_key.bson" , BSON_VALIDATE_EMPTY_KEYS , 4 , BSON_VALIDATE_EMPTY_KEYS , "empty<S2SV_blank>key" ) ; VALIDATE_TEST ( "test40.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test41.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test42.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test43.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test44.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test45.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test46.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test47.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test48.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test49.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test50.bson" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>code-with-scope" ) ; VALIDATE_TEST ( "test51.bson" , BSON_VALIDATE_NONE , 10 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>code-with-scope" ) ; VALIDATE_TEST ( "test52.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test53.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test54.bson" , BSON_VALIDATE_NONE , 12 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; <S2SV_StartBug> b = BCON_NEW ( "my_dbref" , <S2SV_EndBug> "{" , "$ref" , BCON_UTF8 ( "collection" ) , "$id" , BCON_INT32 ( 1 ) , "}" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; bson_destroy ( b ) ; b = BCON_NEW ( "my_dbref" , "{" , "$id" , BCON_INT32 ( 1 ) , "}" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$id\\"" ) ; bson_destroy ( b ) ; b = BCON_NEW ( "my_dbref" , "{" , "$ref" , BCON_UTF8 ( "collection" ) , "$ref" , BCON_UTF8 ( "collection" ) , "}" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$ref\\"" ) ; bson_destroy ( b ) ; b = BCON_NEW ( "my_dbref" , "{" , "$ref" , BCON_UTF8 ( "collection" ) , "extra" , BCON_INT32 ( 2 ) , "$id" , BCON_INT32 ( 1 ) , "}" ) ; BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , BSON_VALIDATE_DOLLAR_KEYS , "invalid<S2SV_blank>key<S2SV_blank>within<S2SV_blank>DBRef<S2SV_blank>subdocument:<S2SV_blank>\\"extra\\"" ) ; bson_destroy ( b ) ; # undef VALIDATE_TEST }
CWE-20 static int handle_pte_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * pte , pmd_t * pmd , unsigned int flags ) { pte_t entry ; spinlock_t * ptl ; entry = * pte ; barrier ( ) ; if ( ! pte_present ( entry ) ) { if ( pte_none ( entry ) ) { <S2SV_StartBug> if ( vma -> vm_ops ) { <S2SV_EndBug> if ( likely ( vma -> vm_ops -> fault ) ) return do_fault ( mm , vma , address , pte , <S2SV_StartBug> pmd , flags , entry ) ; <S2SV_EndBug> } return do_anonymous_page ( mm , vma , address , <S2SV_StartBug> pte , pmd , flags ) ; <S2SV_EndBug> } return do_swap_page ( mm , vma , address , pte , pmd , flags , entry ) ; } if ( pte_protnone ( entry ) ) return do_numa_page ( mm , vma , address , entry , pte , pmd ) ; ptl = pte_lockptr ( mm , pmd ) ; spin_lock ( ptl ) ; if ( unlikely ( ! pte_same ( * pte , entry ) ) ) goto unlock ; if ( flags & FAULT_FLAG_WRITE ) { if ( ! pte_write ( entry ) ) return do_wp_page ( mm , vma , address , pte , pmd , ptl , entry ) ; entry = pte_mkdirty ( entry ) ; } entry = pte_mkyoung ( entry ) ; if ( ptep_set_access_flags ( vma , address , pte , entry , flags & FAULT_FLAG_WRITE ) ) { update_mmu_cache ( vma , address , pte ) ; } else { if ( flags & FAULT_FLAG_WRITE ) flush_tlb_fix_spurious_fault ( vma , address ) ; } unlock : pte_unmap_unlock ( pte , ptl ) ; return 0 ; }
CWE-264 static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , "Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_add_pvc()\\n" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ; <S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> dev = alloc_netdev ( 0 , "pvceth%d" , ether_setup ) ; <S2SV_StartBug> else <S2SV_EndBug> dev = alloc_netdev ( 0 , "pvc%d" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , "Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_pvc()\\n" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }
CWE-399 int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; if ( vm_flags & VM_NORESERVE ) return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) <S2SV_StartBug> return chg ; <S2SV_EndBug> if ( hugepage_subpool_get_pages ( spool , chg ) ) <S2SV_StartBug> return - ENOSPC ; <S2SV_EndBug> <S2SV_StartBug> ret = hugetlb_acct_memory ( h , chg ) ; <S2SV_EndBug> if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 int cdf_read_short_sector_chain ( const cdf_header_t * h , const cdf_sat_t * ssat , const cdf_stream_t * sst , cdf_secid_t sid , size_t len , cdf_stream_t * scn ) { <S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) , i , j ; <S2SV_EndBug> scn -> sst_len = cdf_count_chain ( ssat , sid , CDF_SEC_SIZE ( h ) ) ; scn -> sst_dirlen = len ; if ( sst -> sst_tab == NULL || scn -> sst_len == ( size_t ) - 1 ) return - 1 ; scn -> sst_tab = calloc ( scn -> sst_len , ss ) ; if ( scn -> sst_tab == NULL ) return - 1 ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( "Read<S2SV_blank>short<S2SV_blank>sector<S2SV_blank>chain<S2SV_blank>loop<S2SV_blank>limit" ) ) ; errno = EFTYPE ; goto out ; } if ( i >= scn -> sst_len ) { DPRINTF ( ( "Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>reading<S2SV_blank>short<S2SV_blank>sector<S2SV_blank>chain<S2SV_blank>" "%" SIZE_T_FORMAT "u<S2SV_blank>><S2SV_blank>%" SIZE_T_FORMAT "u\\n" , i , scn -> sst_len ) ) ; errno = EFTYPE ; goto out ; } if ( cdf_read_short_sector ( sst , scn -> sst_tab , i * ss , ss , h , sid ) != ( ssize_t ) ss ) { DPRINTF ( ( "Reading<S2SV_blank>short<S2SV_blank>sector<S2SV_blank>chain<S2SV_blank>%d" , sid ) ) ; goto out ; } sid = CDF_TOLE4 ( ( uint32_t ) ssat -> sat_tab [ sid ] ) ; } return 0 ; out : free ( scn -> sst_tab ) ; return - 1 ; }
CWE-119 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; <S2SV_StartBug> switch ( pc -> componentType ) { <S2SV_EndBug> case 1 : if ( pc -> lengthComponentIdent > 0 ) <S2SV_StartBug> break ; <S2SV_EndBug> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , "../" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , "./" , 2 ) ; p += 2 ; tolen -= 2 ; break ; <S2SV_StartBug> case 5 : <S2SV_EndBug> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; } <S2SV_StartBug> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <S2SV_EndBug> } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ; return 0 ; }
CWE-200 static void snd_timer_user_ccallback ( struct snd_timer_instance * timeri , int event , struct timespec * tstamp , unsigned long resolution ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread r1 ; unsigned long flags ; if ( event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE ) tu -> tstamp = * tstamp ; if ( ( tu -> filter & ( 1 << event ) ) == 0 || ! tu -> tread ) return ; <S2SV_StartBug> r1 . event = event ; <S2SV_EndBug> r1 . tstamp = * tstamp ; r1 . val = resolution ; spin_lock_irqsave ( & tu -> qlock , flags ) ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; spin_unlock_irqrestore ( & tu -> qlock , flags ) ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }
CWE-125 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , "forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; <S2SV_StartBug> while ( p < q ) p += enclen ( reg -> enc , p ) ; <S2SV_EndBug> } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { * low = p - reg -> dmax ; if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , * low ) ; } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , "forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
CWE-000 static enum rules_token lex ( struct scanner * s , union lvalue * val ) { skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == '\\n' ) return TOK_END_OF_LINE ; if ( chr ( s , '#' ) ) { skip_to_eol ( s ) ; goto skip_more_whitespace_and_comments ; } if ( eof ( s ) ) return TOK_END_OF_FILE ; s -> token_line = s -> line ; s -> token_column = s -> column ; s -> buf_pos = 0 ; if ( chr ( s , '<' ) ) { <S2SV_StartBug> while ( peek ( s ) != '>' && ! eol ( s ) ) <S2SV_EndBug> buf_append ( s , next ( s ) ) ; if ( ! chr ( s , '>' ) ) { scanner_err ( s , "unterminated<S2SV_blank>keysym<S2SV_blank>literal" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "keysym<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_LHS_KEYSYM ; } if ( chr ( s , ':' ) ) return TOK_COLON ; if ( chr ( s , '!' ) ) return TOK_BANG ; if ( chr ( s , '~' ) ) return TOK_TILDE ; if ( chr ( s , \'\\"\' ) ) { while ( ! eof ( s ) && ! eol ( s ) && peek ( s ) != \'\\"\' ) { if ( chr ( s , '\\\\' ) ) { uint8_t o ; if ( chr ( s , '\\\\' ) ) { buf_append ( s , '\\\\' ) ; } else if ( chr ( s , \'"\' ) ) { buf_append ( s , \'"\' ) ; } else if ( chr ( s , 'x' ) || chr ( s , 'X' ) ) { if ( hex ( s , & o ) ) buf_append ( s , ( char ) o ) ; else scanner_warn ( s , "illegal<S2SV_blank>hexadecimal<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal" ) ; } else if ( oct ( s , & o ) ) { buf_append ( s , ( char ) o ) ; } else { scanner_warn ( s , "unknown<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>(%c)<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal" , peek ( s ) ) ; } } else { buf_append ( s , next ( s ) ) ; } } if ( ! chr ( s , \'\\"\' ) ) { scanner_err ( s , "unterminated<S2SV_blank>string<S2SV_blank>literal" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } if ( ! is_valid_utf8 ( s -> buf , s -> buf_pos - 1 ) ) { scanner_err ( s , "string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>UTF-8<S2SV_blank>string" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_STRING ; } if ( is_alpha ( peek ( s ) ) || peek ( s ) == '_' ) { s -> buf_pos = 0 ; while ( is_alnum ( peek ( s ) ) || peek ( s ) == '_' ) buf_append ( s , next ( s ) ) ; if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "identifier<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } if ( streq ( s -> buf , "include" ) ) return TOK_INCLUDE ; val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_IDENT ; } skip_to_eol ( s ) ; scanner_err ( s , "unrecognized<S2SV_blank>token" ) ; return TOK_ERROR ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_entropy ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
CWE-200 WORD32 ih264d_parse_sei_message ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD32 ui4_payload_type , ui4_payload_size ; UWORD32 u4_bits ; WORD32 i4_status = 0 ; do { ui4_payload_type = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_type += 255 ; } ui4_payload_type += u4_bits ; ui4_payload_size = 0 ; u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; <S2SV_StartBug> while ( 0xff == u4_bits ) <S2SV_EndBug> { u4_bits = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; ui4_payload_size += 255 ; } ui4_payload_size += u4_bits ; i4_status = ih264d_parse_sei_payload ( ps_bitstrm , ui4_payload_type , ui4_payload_size , ps_dec ) ; if ( i4_status == - 1 ) { i4_status = 0 ; break ; } if ( i4_status != OK ) return i4_status ; if ( ih264d_check_byte_aligned ( ps_bitstrm ) == 0 ) { u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( 0 == u4_bits ) { H264_DEC_DEBUG_PRINT ( "\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message" ) ; } <S2SV_StartBug> while ( 0 == ih264d_check_byte_aligned ( ps_bitstrm ) ) <S2SV_EndBug> { u4_bits = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( u4_bits ) { H264_DEC_DEBUG_PRINT ( "\\nError<S2SV_blank>in<S2SV_blank>parsing<S2SV_blank>SEI<S2SV_blank>message" ) ; } } } } while ( ps_bitstrm -> u4_ofst < ps_bitstrm -> u4_max_ofst ) ; return ( i4_status ) ; }
CWE-119 void vp9_loop_filter_init ( VP9_COMMON * cm ) { loop_filter_info_n * lfi = & cm -> lf_info ; struct loopfilter * lf = & cm -> lf ; int lvl ; update_sharpness ( lfi , lf -> sharpness_level ) ; lf -> last_sharpness_level = lf -> sharpness_level ; for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . hev_thr , ( lvl >> 4 ) , SIMD_WIDTH ) ; <S2SV_EndBug> }
CWE-190 size_t jsuGetFreeStack ( ) { # ifdef ARM void * frame = __builtin_frame_address ( 0 ) ; size_t stackPos = ( size_t ) ( ( char * ) frame ) ; size_t stackEnd = ( size_t ) ( ( char * ) & LINKER_END_VAR ) ; if ( stackPos < stackEnd ) return 0 ; return stackPos - stackEnd ; # elif defined ( LINUX ) char ptr ; extern void * STACK_BASE ; uint32_t count = ( uint32_t ) ( ( size_t ) STACK_BASE - ( size_t ) & ptr ) ; <S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> # else return 1000000 ; # endif }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] += wp [ 0 ] ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-200 static int sco_sock_getsockopt_old ( struct socket * sock , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct sco_options opts ; struct sco_conninfo cinfo ; int len , err = 0 ; BT_DBG ( "sk<S2SV_blank>%p" , sk ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case SCO_OPTIONS : if ( sk -> sk_state != BT_CONNECTED ) { err = - ENOTCONN ; break ; } opts . mtu = sco_pi ( sk ) -> conn -> mtu ; BT_DBG ( "mtu<S2SV_blank>%d" , opts . mtu ) ; len = min_t ( unsigned int , len , sizeof ( opts ) ) ; if ( copy_to_user ( optval , ( char * ) & opts , len ) ) err = - EFAULT ; break ; case SCO_CONNINFO : if ( sk -> sk_state != BT_CONNECTED ) { err = - ENOTCONN ; break ; } <S2SV_StartBug> cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ; <S2SV_EndBug> memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ; len = min_t ( unsigned int , len , sizeof ( cinfo ) ) ; if ( copy_to_user ( optval , ( char * ) & cinfo , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return err ; }
CWE-264 STATIC int xfs_ioctl_setattr ( xfs_inode_t * ip , struct fsxattr * fa , int mask ) { struct xfs_mount * mp = ip -> i_mount ; struct xfs_trans * tp ; unsigned int lock_flags = 0 ; struct xfs_dquot * udqp = NULL ; struct xfs_dquot * pdqp = NULL ; struct xfs_dquot * olddquot = NULL ; int code ; trace_xfs_ioctl_setattr ( ip ) ; if ( mp -> m_flags & XFS_MOUNT_RDONLY ) return XFS_ERROR ( EROFS ) ; if ( XFS_FORCED_SHUTDOWN ( mp ) ) return XFS_ERROR ( EIO ) ; if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) { code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ; if ( code ) return code ; } tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ; code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ; if ( code ) goto error_return ; lock_flags = XFS_ILOCK_EXCL ; xfs_ilock ( ip , lock_flags ) ; if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } if ( mask & FSX_PROJID ) { if ( current_user_ns ( ) != & init_user_ns ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) && xfs_get_projid ( ip ) != fa -> fsx_projid ) { ASSERT ( tp ) ; code = xfs_qm_vop_chown_reserve ( tp , ip , udqp , NULL , pdqp , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( code ) goto error_return ; } } if ( mask & FSX_EXTSIZE ) { if ( ip -> i_d . di_nextents && ( ( ip -> i_d . di_extsize << mp -> m_sb . sb_blocklog ) != fa -> fsx_extsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( fa -> fsx_extsize != 0 ) { xfs_extlen_t size ; xfs_fsblock_t extsize_fsb ; extsize_fsb = XFS_B_TO_FSB ( mp , fa -> fsx_extsize ) ; if ( extsize_fsb > MAXEXTLEN ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_REALTIME_INODE ( ip ) || ( ( mask & FSX_XFLAGS ) && ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) ) { size = mp -> m_sb . sb_rextsize << mp -> m_sb . sb_blocklog ; } else { size = mp -> m_sb . sb_blocksize ; if ( extsize_fsb > mp -> m_sb . sb_agblocks / 2 ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( fa -> fsx_extsize % size ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } } if ( mask & FSX_XFLAGS ) { if ( ( ip -> i_d . di_nextents || ip -> i_delayed_blks ) && ( XFS_IS_REALTIME_INODE ( ip ) ) != ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { if ( ( mp -> m_sb . sb_rblocks == 0 ) || ( mp -> m_sb . sb_rextsize == 0 ) || ( ip -> i_d . di_extsize % mp -> m_sb . sb_rextsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( ( ip -> i_d . di_flags & ( XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND ) || ( fa -> fsx_xflags & ( XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND ) ) ) && ! capable ( CAP_LINUX_IMMUTABLE ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } } xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & FSX_PROJID ) { if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && <S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( xfs_get_projid ( ip ) != fa -> fsx_projid ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) ) { olddquot = xfs_qm_vop_chown ( tp , ip , & ip -> i_pdquot , pdqp ) ; } xfs_set_projid ( ip , fa -> fsx_projid ) ; if ( ip -> i_d . di_version == 1 ) xfs_bump_ino_vers2 ( tp , ip ) ; } } if ( mask & FSX_EXTSIZE ) ip -> i_d . di_extsize = fa -> fsx_extsize >> mp -> m_sb . sb_blocklog ; if ( mask & FSX_XFLAGS ) { xfs_set_diflags ( ip , fa -> fsx_xflags ) ; xfs_diflags_to_linux ( ip ) ; } xfs_trans_ichgtime ( tp , ip , XFS_ICHGTIME_CHG ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; code = xfs_trans_commit ( tp , 0 ) ; xfs_iunlock ( ip , lock_flags ) ; xfs_qm_dqrele ( olddquot ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; return code ; error_return : xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; xfs_trans_cancel ( tp , 0 ) ; if ( lock_flags ) xfs_iunlock ( ip , lock_flags ) ; return code ; }
CWE-000 static void setup_token_decoder ( VP8D_COMP * pbi , const unsigned char * token_part_sizes ) { vp8_reader * bool_decoder = & pbi -> mbc [ 0 ] ; unsigned int partition_idx ; unsigned int fragment_idx ; unsigned int num_token_partitions ; const unsigned char * first_fragment_end = pbi -> fragments . ptrs [ 0 ] + pbi -> fragments . sizes [ 0 ] ; TOKEN_PARTITION multi_token_partition = ( TOKEN_PARTITION ) vp8_read_literal ( & pbi -> mbc [ 8 ] , 2 ) ; if ( ! vp8dx_bool_error ( & pbi -> mbc [ 8 ] ) ) pbi -> common . multi_token_partition = multi_token_partition ; num_token_partitions = 1 << pbi -> common . multi_token_partition ; for ( fragment_idx = 0 ; fragment_idx < pbi -> fragments . count ; ++ fragment_idx ) { unsigned int fragment_size = pbi -> fragments . sizes [ fragment_idx ] ; const unsigned char * fragment_end = pbi -> fragments . ptrs [ fragment_idx ] + fragment_size ; if ( fragment_idx == 0 ) { ptrdiff_t ext_first_part_size = token_part_sizes - pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) ; fragment_size -= ( unsigned int ) ext_first_part_size ; if ( fragment_size > 0 ) { pbi -> fragments . sizes [ 0 ] = ( unsigned int ) ext_first_part_size ; fragment_idx ++ ; pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ 0 ] + pbi -> fragments . sizes [ 0 ] ; } } while ( fragment_size > 0 ) { ptrdiff_t partition_size = read_available_partition_size ( pbi , token_part_sizes , pbi -> fragments . ptrs [ fragment_idx ] , first_fragment_end , fragment_end , fragment_idx - 1 , num_token_partitions ) ; pbi -> fragments . sizes [ fragment_idx ] = ( unsigned int ) partition_size ; fragment_size -= ( unsigned int ) partition_size ; assert ( fragment_idx <= num_token_partitions ) ; if ( fragment_size > 0 ) { fragment_idx ++ ; pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ fragment_idx - 1 ] + partition_size ; } } } pbi -> fragments . count = num_token_partitions + 1 ; for ( partition_idx = 1 ; partition_idx < pbi -> fragments . count ; ++ partition_idx ) { if ( vp8dx_start_decode ( bool_decoder , pbi -> fragments . ptrs [ partition_idx ] , pbi -> fragments . sizes [ partition_idx ] , pbi -> decrypt_cb , pbi -> decrypt_state ) ) vpx_internal_error ( & pbi -> common . error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>%d" , partition_idx ) ; bool_decoder ++ ; } # if CONFIG_MULTITHREAD <S2SV_StartBug> if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) <S2SV_EndBug> <S2SV_StartBug> pbi -> decoding_thread_count = num_token_partitions - 1 ; <S2SV_EndBug> # endif }
CWE-189 void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ; <S2SV_StartBug> req -> started = false ; <S2SV_EndBug> list_del ( & req -> list ) ; req -> remaining = 0 ; if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ; if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ; req -> trb = NULL ; trace_dwc3_gadget_giveback ( req ) ; spin_unlock ( & dwc -> lock ) ; usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ; spin_lock ( & dwc -> lock ) ; <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> pm_runtime_put ( dwc -> dev ) ; }
CWE-264 void setattr_copy ( struct inode * inode , const struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; if ( ia_valid & ATTR_ATIME ) inode -> i_atime = timespec_trunc ( attr -> ia_atime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MTIME ) inode -> i_mtime = timespec_trunc ( attr -> ia_mtime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_CTIME ) inode -> i_ctime = timespec_trunc ( attr -> ia_ctime , inode -> i_sb -> s_time_gran ) ; if ( ia_valid & ATTR_MODE ) { umode_t mode = attr -> ia_mode ; if ( ! in_group_p ( inode -> i_gid ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> mode &= ~ S_ISGID ; inode -> i_mode = mode ; } }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; LutContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AVFrame * out ; uint8_t * inrow , * outrow , * inrow0 , * outrow0 ; int i , j , plane , direct = 0 ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } if ( s -> is_rgb ) { inrow0 = in -> data [ 0 ] ; outrow0 = out -> data [ 0 ] ; for ( i = 0 ; i < in -> height ; i ++ ) { int w = inlink -> w ; const uint8_t ( * tab ) [ 256 ] = ( const uint8_t ( * ) [ 256 ] ) s -> lut ; inrow = inrow0 ; outrow = outrow0 ; for ( j = 0 ; j < w ; j ++ ) { switch ( s -> step ) { case 4 : outrow [ 3 ] = tab [ 3 ] [ inrow [ 3 ] ] ; case 3 : outrow [ 2 ] = tab [ 2 ] [ inrow [ 2 ] ] ; case 2 : outrow [ 1 ] = tab [ 1 ] [ inrow [ 1 ] ] ; default : outrow [ 0 ] = tab [ 0 ] [ inrow [ 0 ] ] ; } outrow += s -> step ; inrow += s -> step ; } inrow0 += in -> linesize [ 0 ] ; outrow0 += out -> linesize [ 0 ] ; } } else { <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ; int hsub = plane == 1 || plane == 2 ? s -> hsub : 0 ; int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; inrow = in -> data [ plane ] ; outrow = out -> data [ plane ] ; for ( i = 0 ; i < h ; i ++ ) { const uint8_t * tab = s -> lut [ plane ] ; for ( j = 0 ; j < w ; j ++ ) outrow [ j ] = tab [ inrow [ j ] ] ; inrow += in -> linesize [ plane ] ; outrow += out -> linesize [ plane ] ; } } } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
CWE-125 static char * search_make_new ( const struct search_state * const state , int n , const char * const base_name ) { const size_t base_len = strlen ( base_name ) ; <S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> for ( dom = state -> head ; dom ; dom = dom -> next ) { if ( ! n -- ) { const u8 * const postfix = ( ( u8 * ) dom ) + sizeof ( struct search_domain ) ; const int postfix_len = dom -> len ; char * const newname = ( char * ) mm_malloc ( base_len + need_to_append_dot + postfix_len + 1 ) ; if ( ! newname ) return NULL ; memcpy ( newname , base_name , base_len ) ; if ( need_to_append_dot ) newname [ base_len ] = '.' ; memcpy ( newname + base_len + need_to_append_dot , postfix , postfix_len ) ; newname [ base_len + need_to_append_dot + postfix_len ] = 0 ; return newname ; } } EVUTIL_ASSERT ( 0 ) ; return NULL ; }
CWE-119 static struct dentry * proc_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { int err ; struct super_block * sb ; struct pid_namespace * ns ; char * options ; if ( flags & MS_KERNMOUNT ) { ns = ( struct pid_namespace * ) data ; options = NULL ; } else { ns = task_active_pid_ns ( current ) ; options = data ; if ( ! ns_capable ( ns -> user_ns , CAP_SYS_ADMIN ) ) return ERR_PTR ( - EPERM ) ; } sb = sget ( fs_type , proc_test_super , proc_set_super , flags , ns ) ; if ( IS_ERR ( sb ) ) return ERR_CAST ( sb ) ; <S2SV_StartBug> if ( ! proc_parse_options ( options , ns ) ) { <S2SV_EndBug> deactivate_locked_super ( sb ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! sb -> s_root ) { err = proc_fill_super ( sb ) ; if ( err ) { deactivate_locked_super ( sb ) ; return ERR_PTR ( err ) ; } sb -> s_flags |= MS_ACTIVE ; sb -> s_iflags |= SB_I_NOEXEC ; } return dget ( sb -> s_root ) ; }
CWE-000 long keyctl_set_reqkey_keyring ( int reqkey_defl ) { struct cred * new ; int ret , old_setting ; old_setting = current_cred_xxx ( jit_keyring ) ; if ( reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE ) return old_setting ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; switch ( reqkey_defl ) { case KEY_REQKEY_DEFL_THREAD_KEYRING : ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) goto error ; goto set ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : ret = install_process_keyring_to_cred ( new ) ; <S2SV_StartBug> if ( ret < 0 ) { <S2SV_EndBug> if ( ret != - EEXIST ) goto error ; ret = 0 ; } goto set ; case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_SESSION_KEYRING : case KEY_REQKEY_DEFL_USER_KEYRING : case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : goto set ; case KEY_REQKEY_DEFL_NO_CHANGE : case KEY_REQKEY_DEFL_GROUP_KEYRING : default : ret = - EINVAL ; goto error ; } set : new -> jit_keyring = reqkey_defl ; commit_creds ( new ) ; return old_setting ; error : abort_creds ( new ) ; return ret ; }
CWE-20 int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; <S2SV_StartBug> if ( handle && ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , "remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; <S2SV_StartBug> if ( sbi -> s_journal && ! handle ) <S2SV_EndBug> goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , "superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , "get_write_access" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , "orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; NEXT_ORPHAN ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; NEXT_ORPHAN ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }
CWE-119 int vp9_get_qindex ( const struct segmentation * seg , int segment_id , int base_qindex ) { <S2SV_StartBug> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_ALT_Q ) ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , segment_id , SEG_LVL_ALT_Q ) ; <S2SV_EndBug> const int seg_qindex = seg -> abs_delta == SEGMENT_ABSDATA ? data : base_qindex + data ; return clamp ( seg_qindex , 0 , MAXQ ) ; } else { return base_qindex ; } }
CWE-125 static int dex_loadcode ( RBinFile * arch , RBinDexObj * bin ) { struct r_bin_t * rbin = arch -> rbin ; int i ; int * methods = NULL ; int sym_count = 0 ; if ( ! bin || bin -> methods_list ) { return false ; } bin -> code_from = UT64_MAX ; bin -> code_to = 0 ; bin -> methods_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> methods_list ) { return false ; } bin -> imports_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> imports_list ) { r_list_free ( bin -> methods_list ) ; return false ; } bin -> classes_list = r_list_newf ( ( RListFree ) __r_bin_class_free ) ; if ( ! bin -> classes_list ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; return false ; } if ( bin -> header . method_size > bin -> size ) { bin -> header . method_size = 0 ; return false ; } bin -> header . method_size = R_MIN ( bin -> header . method_size , bin -> size ) ; bin -> header . class_size = R_MIN ( bin -> header . class_size , bin -> size ) ; bin -> header . strings_size = R_MIN ( bin -> header . strings_size , bin -> size ) ; if ( bin -> header . strings_size > bin -> size ) { eprintf ( "Invalid<S2SV_blank>strings<S2SV_blank>size\\n" ) ; return false ; } if ( bin -> classes ) { ut64 amount = sizeof ( int ) * bin -> header . method_size ; if ( amount > UT32_MAX || amount < bin -> header . method_size ) { return false ; } methods = calloc ( 1 , amount + 1 ) ; for ( i = 0 ; i < bin -> header . class_size ; i ++ ) { char * super_name , * class_name ; struct dex_class_t * c = & bin -> classes [ i ] ; class_name = dex_class_name ( bin , c ) ; super_name = dex_class_super_name ( bin , c ) ; if ( dexdump ) { rbin -> cb_printf ( "Class<S2SV_blank>#%d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-\\n" , i ) ; } parse_class ( arch , bin , c , i , methods , & sym_count ) ; free ( class_name ) ; free ( super_name ) ; } } if ( methods ) { int import_count = 0 ; int sym_count = bin -> methods_list -> length ; for ( i = 0 ; i < bin -> header . method_size ; i ++ ) { int len = 0 ; if ( methods [ i ] ) { continue ; } <S2SV_StartBug> if ( bin -> methods [ i ] . class_id > bin -> header . types_size - 1 ) { <S2SV_EndBug> continue ; } if ( is_class_idx_in_code_classes ( bin , bin -> methods [ i ] . class_id ) ) { continue ; } char * class_name = getstr ( bin , bin -> types [ bin -> methods [ i ] . class_id ] . descriptor_id ) ; if ( ! class_name ) { free ( class_name ) ; continue ; } len = strlen ( class_name ) ; if ( len < 1 ) { continue ; } class_name [ len - 1 ] = 0 ; char * method_name = dex_method_name ( bin , i ) ; char * signature = dex_method_signature ( bin , i ) ; if ( method_name && * method_name ) { RBinImport * imp = R_NEW0 ( RBinImport ) ; imp -> name = r_str_newf ( "%s.method.%s%s" , class_name , method_name , signature ) ; imp -> type = r_str_const ( "FUNC" ) ; imp -> bind = r_str_const ( "NONE" ) ; imp -> ordinal = import_count ++ ; r_list_append ( bin -> imports_list , imp ) ; RBinSymbol * sym = R_NEW0 ( RBinSymbol ) ; sym -> name = r_str_newf ( "imp.%s" , imp -> name ) ; sym -> type = r_str_const ( "FUNC" ) ; sym -> bind = r_str_const ( "NONE" ) ; sym -> paddr = sym -> vaddr = bin -> b -> base + bin -> header . method_offset + ( sizeof ( struct dex_method_t ) * i ) ; sym -> ordinal = sym_count ++ ; r_list_append ( bin -> methods_list , sym ) ; sdb_num_set ( mdb , sdb_fmt ( 0 , "method.%d" , i ) , sym -> paddr , 0 ) ; } free ( method_name ) ; free ( signature ) ; free ( class_name ) ; } free ( methods ) ; } return true ; }
CWE-264 int _fep_open_control_socket ( Fep * fep ) { struct sockaddr_un sun ; char * path ; int fd ; ssize_t sun_len ; fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; if ( fd < 0 ) { perror ( "socket" ) ; return - 1 ; } path = create_socket_name ( "fep-XXXXXX/control" ) ; if ( strlen ( path ) + 1 >= sizeof ( sun . sun_path ) ) { fep_log ( FEP_LOG_LEVEL_WARNING , "unix<S2SV_blank>domain<S2SV_blank>socket<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>%d<S2SV_blank>+<S2SV_blank>1<S2SV_blank>>=<S2SV_blank>%d" , strlen ( path ) , sizeof ( sun . sun_path ) ) ; free ( path ) ; return - 1 ; } memset ( & sun , 0 , sizeof ( sun ) ) ; sun . sun_family = AF_UNIX ; <S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> memcpy ( sun . sun_path + 1 , path , strlen ( path ) ) ; <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ; <S2SV_EndBug> remove_control_socket ( path ) ; # else memcpy ( sun . sun_path , path , strlen ( path ) ) ; sun_len = sizeof ( struct sockaddr_un ) ; # endif if ( bind ( fd , ( const struct sockaddr * ) & sun , sun_len ) < 0 ) { perror ( "bind" ) ; free ( path ) ; close ( fd ) ; return - 1 ; } if ( listen ( fd , 5 ) < 0 ) { perror ( "listen" ) ; free ( path ) ; close ( fd ) ; return - 1 ; } fep -> server = fd ; fep -> control_socket_path = path ; return 0 ; }
CWE-125 static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , "compressed<S2SV_blank>PPP<S2SV_blank>data" ) ) ; break ; default : ND_PRINT ( ( ndo , "%s<S2SV_blank>" , tok2str ( ppptype2str , "unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)" , proto ) ) ) ; print_unknown_data ( ndo , p , "\\n\\t" , length ) ; break ; } }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_frame ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctrl_id , va_list args ) { int * ref_info = va_arg ( args , int * ) ; if ( ref_info && ! ctx -> yv12_frame_buffers . use_frame_threads ) { VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; VP8_COMMON * oci = & pbi -> common ; * ref_info = ( vp8dx_references_buffer ( oci , ALTREF_FRAME ) ? VP8_ALTR_FRAME : 0 ) | ( vp8dx_references_buffer ( oci , GOLDEN_FRAME ) ? VP8_GOLD_FRAME : 0 ) | ( vp8dx_references_buffer ( oci , LAST_FRAME ) ? VP8_LAST_FRAME : 0 ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-189 static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; <S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> return 0 ; if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
CWE-284 static void toggle_os_keylockstates ( int fd , int changedlockstates ) { BTIF_TRACE_EVENT ( "%s:<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>changedlockstates<S2SV_blank>=<S2SV_blank>0x%x" , __FUNCTION__ , fd , changedlockstates ) ; UINT8 hidreport [ 9 ] ; int reportIndex ; memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; reportIndex = 4 ; if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK ) { BTIF_TRACE_DEBUG ( "%s<S2SV_blank>Setting<S2SV_blank>CAPSLOCK" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_CAPSLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK ) { BTIF_TRACE_DEBUG ( "%s<S2SV_blank>Setting<S2SV_blank>NUMLOCK" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_NUMLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK ) { BTIF_TRACE_DEBUG ( "%s<S2SV_blank>Setting<S2SV_blank>SCROLLLOCK" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_SCROLLLOCK ; } BTIF_TRACE_DEBUG ( "Writing<S2SV_blank>hidreport<S2SV_blank>#1<S2SV_blank>to<S2SV_blank>os:<S2SV_blank>" "%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( "%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( "%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; <S2SV_StartBug> usleep ( 200000 ) ; <S2SV_EndBug> memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; BTIF_TRACE_DEBUG ( "Writing<S2SV_blank>hidreport<S2SV_blank>#2<S2SV_blank>to<S2SV_blank>os:<S2SV_blank>" "%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( "%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( "%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; }
CWE-416 struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , int port ) { unsigned long flags ; struct snd_seq_client_port * new_port , * p ; int num = - 1 ; if ( snd_BUG_ON ( ! client ) ) return NULL ; if ( client -> num_ports >= SNDRV_SEQ_MAX_PORTS ) { pr_warn ( "ALSA:<S2SV_blank>seq:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>ports<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%d\\n" , client -> number ) ; return NULL ; } new_port = kzalloc ( sizeof ( * new_port ) , GFP_KERNEL ) ; if ( ! new_port ) return NULL ; new_port -> addr . client = client -> number ; new_port -> addr . port = - 1 ; new_port -> owner = THIS_MODULE ; sprintf ( new_port -> name , "port-%d" , num ) ; snd_use_lock_init ( & new_port -> use_lock ) ; port_subs_info_init ( & new_port -> c_src ) ; port_subs_info_init ( & new_port -> c_dest ) ; <S2SV_StartBug> num = port >= 0 ? port : 0 ; <S2SV_EndBug> mutex_lock ( & client -> ports_mutex ) ; write_lock_irqsave ( & client -> ports_lock , flags ) ; list_for_each_entry ( p , & client -> ports_list_head , list ) { if ( p -> addr . port > num ) break ; if ( port < 0 ) num = p -> addr . port + 1 ; } list_add_tail ( & new_port -> list , & p -> list ) ; client -> num_ports ++ ; new_port -> addr . port = num ; <S2SV_StartBug> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <S2SV_EndBug> <S2SV_StartBug> mutex_unlock ( & client -> ports_mutex ) ; <S2SV_EndBug> sprintf ( new_port -> name , "port-%d" , num ) ; return new_port ; }
CWE-125 static void rx_cache_insert ( netdissect_options * ndo , const u_char * bp , const struct ip * ip , int dport ) { struct rx_cache_entry * rxent ; const struct rx_header * rxh = ( const struct rx_header * ) bp ; if ( ndo -> ndo_snapend - bp + 1 <= ( int ) ( sizeof ( struct rx_header ) + sizeof ( int32_t ) ) ) return ; rxent = & rx_cache [ rx_cache_next ] ; if ( ++ rx_cache_next >= RX_CACHE_SIZE ) rx_cache_next = 0 ; rxent -> callnum = EXTRACT_32BITS ( & rxh -> callNumber ) ; UNALIGNED_MEMCPY ( & rxent -> client , & ip -> ip_src , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & rxent -> server , & ip -> ip_dst , sizeof ( uint32_t ) ) ; rxent -> dport = dport ; <S2SV_StartBug> rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ; <S2SV_EndBug> rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; }
CWE-189 sf_count_t psf_fwrite ( const void * ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE * psf ) { sf_count_t total = 0 ; <S2SV_StartBug> ssize_t count ; <S2SV_EndBug> if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ; items *= bytes ; if ( items <= 0 ) return 0 ; while ( items > 0 ) { count = ( items > SENSIBLE_SIZE ) ? SENSIBLE_SIZE : items ; count = write ( psf -> file . filedes , ( ( const char * ) ptr ) + total , count ) ; if ( count == - 1 ) { if ( errno == EINTR ) continue ; psf_log_syserr ( psf , errno ) ; break ; } ; if ( count == 0 ) break ; total += count ; items -= count ; } ; if ( psf -> is_pipe ) psf -> pipeoffset += total ; return total / bytes ; }
CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <S2SV_StartBug> if ( size_bmp > BMP_HEADER_SIZE ) { <S2SV_EndBug> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }
CWE-264 static int cg_opendir ( const char * path , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; const char * cgroup ; struct file_info * dir_info ; char * controller = NULL ; if ( ! fc ) return - EIO ; if ( strcmp ( path , "/cgroup" ) == 0 ) { cgroup = NULL ; controller = NULL ; } else { controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { cgroup = "/" ; } } <S2SV_StartBug> if ( cgroup && ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { <S2SV_EndBug> return - EACCES ; } dir_info = malloc ( sizeof ( * dir_info ) ) ; if ( ! dir_info ) return - ENOMEM ; dir_info -> controller = must_copy_string ( controller ) ; dir_info -> cgroup = must_copy_string ( cgroup ) ; dir_info -> type = LXC_TYPE_CGDIR ; dir_info -> buf = NULL ; dir_info -> file = NULL ; dir_info -> buflen = 0 ; fi -> fh = ( unsigned long ) dir_info ; return 0 ; }
CWE-399 static ssize_t fuse_fill_write_pages ( struct fuse_req * req , struct address_space * mapping , struct iov_iter * ii , loff_t pos ) { struct fuse_conn * fc = get_fuse_conn ( mapping -> host ) ; unsigned offset = pos & ( PAGE_CACHE_SIZE - 1 ) ; size_t count = 0 ; int err ; req -> in . argpages = 1 ; req -> page_descs [ 0 ] . offset = offset ; do { size_t tmp ; struct page * page ; pgoff_t index = pos >> PAGE_CACHE_SHIFT ; size_t bytes = min_t ( size_t , PAGE_CACHE_SIZE - offset , iov_iter_count ( ii ) ) ; bytes = min_t ( size_t , bytes , fc -> max_write - count ) ; again : err = - EFAULT ; if ( iov_iter_fault_in_readable ( ii , bytes ) ) break ; err = - ENOMEM ; page = grab_cache_page_write_begin ( mapping , index , 0 ) ; if ( ! page ) break ; if ( mapping_writably_mapped ( mapping ) ) flush_dcache_page ( page ) ; tmp = iov_iter_copy_from_user_atomic ( page , ii , offset , bytes ) ; <S2SV_StartBug> flush_dcache_page ( page ) ; <S2SV_EndBug> if ( ! tmp ) { unlock_page ( page ) ; page_cache_release ( page ) ; bytes = min ( bytes , iov_iter_single_seg_count ( ii ) ) ; goto again ; } err = 0 ; req -> pages [ req -> num_pages ] = page ; req -> page_descs [ req -> num_pages ] . length = tmp ; req -> num_pages ++ ; <S2SV_StartBug> iov_iter_advance ( ii , tmp ) ; <S2SV_EndBug> count += tmp ; pos += tmp ; offset += tmp ; if ( offset == PAGE_CACHE_SIZE ) offset = 0 ; if ( ! fc -> big_writes ) break ; } while ( iov_iter_count ( ii ) && count < fc -> max_write && req -> num_pages < req -> max_pages && offset == 0 ) ; return count > 0 ? count : err ; }
CWE-416 struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr __user * newopt , int newoptlen ) { int tot_len = 0 ; char * p ; struct ipv6_txoptions * opt2 ; int err ; if ( opt ) { if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; if ( newtype != IPV6_RTHDR && opt -> srcrt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; } if ( newopt && newoptlen ) tot_len += CMSG_ALIGN ( newoptlen ) ; if ( ! tot_len ) return NULL ; tot_len += sizeof ( * opt2 ) ; opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; if ( ! opt2 ) return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ; <S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> p = ( char * ) ( opt2 + 1 ) ; err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , newtype != IPV6_HOPOPTS , & opt2 -> hopopt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , newtype != IPV6_RTHDRDSTOPTS , & opt2 -> dst0opt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> srcrt : NULL , newopt , newoptlen , newtype != IPV6_RTHDR , ( struct ipv6_opt_hdr * * ) & opt2 -> srcrt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst1opt : NULL , newopt , newoptlen , newtype != IPV6_DSTOPTS , & opt2 -> dst1opt , & p ) ; if ( err ) goto out ; opt2 -> opt_nflen = ( opt2 -> hopopt ? ipv6_optlen ( opt2 -> hopopt ) : 0 ) + ( opt2 -> dst0opt ? ipv6_optlen ( opt2 -> dst0opt ) : 0 ) + ( opt2 -> srcrt ? ipv6_optlen ( opt2 -> srcrt ) : 0 ) ; opt2 -> opt_flen = ( opt2 -> dst1opt ? ipv6_optlen ( opt2 -> dst1opt ) : 0 ) ; return opt2 ; out : sock_kfree_s ( sk , opt2 , opt2 -> tot_len ) ; return ERR_PTR ( err ) ; }
CWE-476 static int jp2_cdef_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cdef_t * cdef = & box -> data . cdef ; jp2_cdefchan_t * chan ; <S2SV_StartBug> unsigned int channo ; <S2SV_EndBug> if ( jp2_getuint16 ( in , & cdef -> numchans ) ) { return - 1 ; } if ( ! ( cdef -> ents = jas_alloc2 ( cdef -> numchans , sizeof ( jp2_cdefchan_t ) ) ) ) { return - 1 ; } for ( channo = 0 ; channo < cdef -> numchans ; ++ channo ) { chan = & cdef -> ents [ channo ] ; if ( jp2_getuint16 ( in , & chan -> channo ) || jp2_getuint16 ( in , & chan -> type ) || jp2_getuint16 ( in , & chan -> assoc ) ) { return - 1 ; } } return 0 ; }
CWE-119 char * selaGetCombName ( SELA * sela , l_int32 size , l_int32 direction ) { char * selname ; <S2SV_StartBug> char combname [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 i , nsels , sx , sy , found ; SEL * sel ; PROCNAME ( "selaGetCombName" ) ; if ( ! sela ) return ( char * ) ERROR_PTR ( "sela<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( direction != L_HORIZ && direction != L_VERT ) return ( char * ) ERROR_PTR ( "invalid<S2SV_blank>direction" , procName , NULL ) ; if ( direction == L_HORIZ ) <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , "sel_comb_%dh" , size ) ; <S2SV_EndBug> else <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , "sel_comb_%dv" , size ) ; <S2SV_EndBug> found = FALSE ; nsels = selaGetCount ( sela ) ; for ( i = 0 ; i < nsels ; i ++ ) { sel = selaGetSel ( sela , i ) ; selGetParameters ( sel , & sy , & sx , NULL , NULL ) ; if ( sy != 1 && sx != 1 ) continue ; selname = selGetName ( sel ) ; if ( ! strcmp ( selname , combname ) ) { found = TRUE ; break ; } } if ( found ) return stringNew ( selname ) ; else return ( char * ) ERROR_PTR ( "sel<S2SV_blank>not<S2SV_blank>found" , procName , NULL ) ; }
CWE-000 static int snd_compress_check_input ( struct snd_compr_params * params ) { if ( params -> buffer . fragment_size == 0 || <S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> return - EINVAL ; if ( params -> codec . id == 0 || params -> codec . id > SND_AUDIOCODEC_MAX ) return - EINVAL ; if ( params -> codec . ch_in == 0 || params -> codec . ch_out == 0 ) return - EINVAL ; return 0 ; }
CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( "ping_unhash(isk=%p,isk->num=%u)\\n" , isk , isk -> inet_num ) ; if ( sk_hashed ( sk ) ) { write_lock_bh ( & ping_table . lock ) ; hlist_nulls_del ( & sk -> sk_nulls_node ) ; <S2SV_StartBug> sock_put ( sk ) ; <S2SV_EndBug> isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; write_unlock_bh ( & ping_table . lock ) ; } }
CWE-125 static int print_prefix ( netdissect_options * ndo , const u_char * prefix , u_int max_length ) { int plenbytes ; char buf [ sizeof ( "xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128" ) ] ; if ( prefix [ 0 ] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 && is_ipv4_mapped_address ( & prefix [ 1 ] ) ) { struct in_addr addr ; u_int plen ; plen = prefix [ 0 ] - 96 ; if ( 32 < plen ) return - 1 ; max_length -= 1 ; memset ( & addr , 0 , sizeof ( addr ) ) ; plenbytes = ( plen + 7 ) / 8 ; if ( max_length < ( u_int ) plenbytes + IPV4_MAPPED_HEADING_LEN ) return - 3 ; memcpy ( & addr , & prefix [ 1 + IPV4_MAPPED_HEADING_LEN ] , plenbytes ) ; if ( plen % 8 ) { ( ( u_char * ) & addr ) [ plenbytes - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , sizeof ( buf ) , "%s/%d" , ipaddr_string ( ndo , & addr ) , plen ) ; plenbytes += 1 + IPV4_MAPPED_HEADING_LEN ; } else { plenbytes = decode_prefix6 ( ndo , prefix , max_length , buf , sizeof ( buf ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , "%s" , buf ) ) ; return plenbytes ; }
CWE-119 <S2SV_StartBug> void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }
CWE-119 static const xmlChar * xmlParseNameComplex ( xmlParserCtxtPtr ctxt ) { int len = 0 , l ; int c ; int count = 0 ; # ifdef DEBUG nbParseNameComplex ++ ; # endif GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; c = CUR_CHAR ( l ) ; if ( ( ctxt -> options & XML_PARSE_OLD10 ) == 0 ) { if ( ( c == '<S2SV_blank>' ) || ( c == '>' ) || ( c == '/' ) || ( ! ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) || ( c == '_' ) || ( c == ':' ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) ) { return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; while ( ( c != '<S2SV_blank>' ) && ( c != '>' ) && ( c != '/' ) && ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) || ( ( c >= '0' ) && ( c <= '9' ) ) || ( c == '_' ) || ( c == ':' ) || ( c == '-' ) || ( c == '.' ) || ( c == 0xB7 ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x300 ) && ( c <= 0x36F ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x203F ) && ( c <= 0x2040 ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) { if ( count ++ > XML_PARSER_CHUNK_SIZE ) { count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; } } else { if ( ( c == '<S2SV_blank>' ) || ( c == '>' ) || ( c == '/' ) || ( ! IS_LETTER ( c ) && ( c != '_' ) && ( c != ':' ) ) ) { return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; while ( ( c != '<S2SV_blank>' ) && ( c != '>' ) && ( c != '/' ) && ( ( IS_LETTER ( c ) ) || ( IS_DIGIT ( c ) ) || ( c == '.' ) || ( c == '-' ) || ( c == '_' ) || ( c == ':' ) || ( IS_COMBINING ( c ) ) || ( IS_EXTENDER ( c ) ) ) ) { if ( count ++ > XML_PARSER_CHUNK_SIZE ) { count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; <S2SV_StartBug> if ( c == 0 ) { <S2SV_EndBug> count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; c = CUR_CHAR ( l ) ; } } } if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { <S2SV_StartBug> xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , "Name" ) ; <S2SV_EndBug> return ( NULL ) ; } if ( ( * ctxt -> input -> cur == '\\n' ) && ( ctxt -> input -> cur [ - 1 ] == '\\r' ) ) return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - ( len + 1 ) , len ) ) ; return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - len , len ) ) ; }
CWE-200 static void adjust_branches ( struct bpf_prog * prog , int pos , int delta ) { struct bpf_insn * insn = prog -> insnsi ; int insn_cnt = prog -> len ; int i ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) != BPF_JMP || BPF_OP ( insn -> code ) == BPF_CALL || BPF_OP ( insn -> code ) == BPF_EXIT ) continue ; if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ; <S2SV_StartBug> else if ( i > pos && i + insn -> off + 1 < pos ) <S2SV_EndBug> insn -> off -= delta ; } }
CWE-189 static inline void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }
CWE-119 void vp8_build_intra_predictors_mbuv_s_c ( MACROBLOCKD * x , unsigned char * uabove_row , unsigned char * vabove_row , unsigned char * uleft , unsigned char * vleft , int left_stride , unsigned char * upred_ptr , unsigned char * vpred_ptr , int pred_stride ) { unsigned char uleft_col [ 8 ] ; unsigned char utop_left = uabove_row [ - 1 ] ; unsigned char vleft_col [ 8 ] ; unsigned char vtop_left = vabove_row [ - 1 ] ; int i , j ; for ( i = 0 ; i < 8 ; i ++ ) { uleft_col [ i ] = uleft [ i * left_stride ] ; vleft_col [ i ] = vleft [ i * left_stride ] ; } switch ( x -> mode_info_context -> mbmi . uv_mode ) { case DC_PRED : { int expected_udc ; int expected_vdc ; int shift ; int Uaverage = 0 ; int Vaverage = 0 ; if ( x -> up_available ) { for ( i = 0 ; i < 8 ; i ++ ) { Uaverage += uabove_row [ i ] ; Vaverage += vabove_row [ i ] ; } } if ( x -> left_available ) { for ( i = 0 ; i < 8 ; i ++ ) { Uaverage += uleft_col [ i ] ; Vaverage += vleft_col [ i ] ; } } if ( ! x -> up_available && ! x -> left_available ) { expected_udc = 128 ; expected_vdc = 128 ; } else { shift = 2 + x -> up_available + x -> left_available ; expected_udc = ( Uaverage + ( 1 << ( shift - 1 ) ) ) >> shift ; expected_vdc = ( Vaverage + ( 1 << ( shift - 1 ) ) ) >> shift ; } for ( i = 0 ; i < 8 ; i ++ ) { <S2SV_StartBug> vpx_memset ( upred_ptr , expected_udc , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( vpred_ptr , expected_vdc , 8 ) ; <S2SV_EndBug> upred_ptr += pred_stride ; vpred_ptr += pred_stride ; } } break ; case V_PRED : { for ( i = 0 ; i < 8 ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( upred_ptr , uabove_row , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vpred_ptr , vabove_row , 8 ) ; <S2SV_EndBug> upred_ptr += pred_stride ; vpred_ptr += pred_stride ; } } break ; case H_PRED : { for ( i = 0 ; i < 8 ; i ++ ) { <S2SV_StartBug> vpx_memset ( upred_ptr , uleft_col [ i ] , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( vpred_ptr , vleft_col [ i ] , 8 ) ; <S2SV_EndBug> upred_ptr += pred_stride ; vpred_ptr += pred_stride ; } } break ; case TM_PRED : { for ( i = 0 ; i < 8 ; i ++ ) { for ( j = 0 ; j < 8 ; j ++ ) { int predu = uleft_col [ i ] + uabove_row [ j ] - utop_left ; int predv = vleft_col [ i ] + vabove_row [ j ] - vtop_left ; if ( predu < 0 ) predu = 0 ; if ( predu > 255 ) predu = 255 ; if ( predv < 0 ) predv = 0 ; if ( predv > 255 ) predv = 255 ; upred_ptr [ j ] = predu ; vpred_ptr [ j ] = predv ; } upred_ptr += pred_stride ; vpred_ptr += pred_stride ; } } break ; case B_PRED : case NEARESTMV : case NEARMV : case ZEROMV : case NEWMV : case SPLITMV : case MB_MODE_COUNT : break ; } }
CWE-119 static void ssdp_recv ( int sd ) { ssize_t len ; struct sockaddr sa ; socklen_t salen ; <S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> memset ( buf , 0 , sizeof ( buf ) ) ; <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> if ( len > 0 ) { <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> if ( sa . sa_family != AF_INET ) return ; if ( strstr ( buf , "M-SEARCH<S2SV_blank>*" ) ) { size_t i ; char * ptr , * type ; struct ifsock * ifs ; struct sockaddr_in * sin = ( struct sockaddr_in * ) & sa ; ifs = find_outbound ( & sa ) ; if ( ! ifs ) { logit ( LOG_DEBUG , "No<S2SV_blank>matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s" , inet_ntoa ( sin -> sin_addr ) ) ; return ; } logit ( LOG_DEBUG , "Matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s" , inet_ntoa ( sin -> sin_addr ) ) ; type = strcasestr ( buf , "\\r\\nST:" ) ; if ( ! type ) { logit ( LOG_DEBUG , "No<S2SV_blank>Search<S2SV_blank>Type<S2SV_blank>(ST:)<S2SV_blank>found<S2SV_blank>in<S2SV_blank>M-SEARCH<S2SV_blank>*,<S2SV_blank>assuming<S2SV_blank>" SSDP_ST_ALL ) ; type = SSDP_ST_ALL ; send_message ( ifs , type , & sa ) ; return ; } type = strchr ( type , ':' ) ; if ( ! type ) return ; type ++ ; while ( isspace ( * type ) ) type ++ ; ptr = strstr ( type , "\\r\\n" ) ; if ( ! ptr ) return ; * ptr = 0 ; for ( i = 0 ; supported_types [ i ] ; i ++ ) { if ( ! strcmp ( supported_types [ i ] , type ) ) { logit ( LOG_DEBUG , "M-SEARCH<S2SV_blank>*<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d" , type , inet_ntoa ( sin -> sin_addr ) , ntohs ( sin -> sin_port ) ) ; send_message ( ifs , type , & sa ) ; return ; } } logit ( LOG_DEBUG , "M-SEARCH<S2SV_blank>*<S2SV_blank>for<S2SV_blank>unsupported<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s" , type , inet_ntoa ( sin -> sin_addr ) ) ; } } }
CWE-119 void vp8_dequant_idct_add_y_block_c ( short * q , short * dq , unsigned char * dst , int stride , char * eobs ) { int i , j ; for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) { if ( * eobs ++ > 1 ) vp8_dequant_idct_add_c ( q , dq , dst , stride ) ; else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 16 ; dst += 4 ; } dst += 4 * stride - 16 ; } }
CWE-189 void set_fat ( DOS_FS * fs , uint32_t cluster , int32_t new ) { unsigned char * data = NULL ; int size ; loff_t offs ; if ( new == - 1 ) new = FAT_EOF ( fs ) ; else if ( ( long ) new == - 2 ) new = FAT_BAD ( fs ) ; switch ( fs -> fat_bits ) { case 12 : data = fs -> fat + cluster * 3 / 2 ; offs = fs -> fat_start + cluster * 3 / 2 ; if ( cluster & 1 ) { FAT_ENTRY prevEntry ; get_fat ( & prevEntry , fs -> fat , cluster - 1 , fs ) ; data [ 0 ] = ( ( new & 0xf ) << 4 ) | ( prevEntry . value >> 8 ) ; data [ 1 ] = new >> 4 ; } else { FAT_ENTRY subseqEntry ; <S2SV_StartBug> if ( cluster != fs -> clusters - 1 ) <S2SV_EndBug> get_fat ( & subseqEntry , fs -> fat , cluster + 1 , fs ) ; else subseqEntry . value = 0 ; data [ 0 ] = new & 0xff ; data [ 1 ] = ( new >> 8 ) | ( ( 0xff & subseqEntry . value ) << 4 ) ; } size = 2 ; break ; case 16 : data = fs -> fat + cluster * 2 ; offs = fs -> fat_start + cluster * 2 ; * ( unsigned short * ) data = htole16 ( new ) ; size = 2 ; break ; case 32 : { FAT_ENTRY curEntry ; get_fat ( & curEntry , fs -> fat , cluster , fs ) ; data = fs -> fat + cluster * 4 ; offs = fs -> fat_start + cluster * 4 ; * ( uint32_t * ) data = htole32 ( ( new & 0xfffffff ) | ( curEntry . reserved << 28 ) ) ; size = 4 ; } break ; default : die ( "Bad<S2SV_blank>FAT<S2SV_blank>entry<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>bits." , fs -> fat_bits ) ; } fs_write ( offs , size , data ) ; if ( fs -> nfats > 1 ) { fs_write ( offs + fs -> fat_size , size , data ) ; } }
CWE-119 <S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) { <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }
CWE-772 struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; struct iovec iov ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int local_nr_pages = end - start ; const int page_limit = cur_page + local_nr_pages ; ret = get_user_pages_fast ( uaddr , local_nr_pages , ( iter -> type & WRITE ) != WRITE , & pages [ cur_page ] ) ; if ( ret < local_nr_pages ) { ret = - EFAULT ; goto out_unmap ; } offset = offset_in_page ( uaddr ) ; for ( j = cur_page ; j < page_limit ; j ++ ) { unsigned int bytes = PAGE_SIZE - offset ; <S2SV_StartBug> if ( len <= 0 ) <S2SV_EndBug> break ; if ( bytes > len ) bytes = len ; if ( bio_add_pc_page ( q , bio , pages [ j ] , bytes , offset ) < bytes ) break ; <S2SV_StartBug> len -= bytes ; <S2SV_EndBug> offset = 0 ; } cur_page = j ; while ( j < page_limit ) put_page ( pages [ j ++ ] ) ; } kfree ( pages ) ; bio_set_flag ( bio , BIO_USER_MAPPED ) ; bio_get ( bio ) ; return bio ; out_unmap : for ( j = 0 ; j < nr_pages ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } out : kfree ( pages ) ; bio_put ( bio ) ; return ERR_PTR ( ret ) ; }
CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
CWE-416 static struct dst_entry * inet6_csk_route_socket ( struct sock * sk , struct flowi6 * fl6 ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = sk -> sk_protocol ; fl6 -> daddr = sk -> sk_v6_daddr ; fl6 -> saddr = np -> saddr ; fl6 -> flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel ) ; fl6 -> flowi6_oif = sk -> sk_bound_dev_if ; fl6 -> flowi6_mark = sk -> sk_mark ; fl6 -> fl6_sport = inet -> inet_sport ; fl6 -> fl6_dport = inet -> inet_dport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <S2SV_EndBug> if ( ! dst ) { dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( ! IS_ERR ( dst ) ) __inet6_csk_dst_store ( sk , dst , NULL , NULL ) ; } return dst ; }
CWE-119 <S2SV_StartBug> void vp9_cond_prob_diff_update ( vp9_writer * w , vp9_prob * oldp , <S2SV_EndBug> const unsigned int ct [ 2 ] ) { <S2SV_StartBug> const vp9_prob upd = DIFF_UPDATE_PROB ; <S2SV_EndBug> <S2SV_StartBug> vp9_prob newp = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) ; <S2SV_EndBug> const int savings = vp9_prob_diff_update_savings_search ( ct , * oldp , & newp , upd ) ; assert ( newp >= 1 ) ; if ( savings > 0 ) { <S2SV_StartBug> vp9_write ( w , 1 , upd ) ; <S2SV_EndBug> vp9_write_prob_diff_update ( w , newp , * oldp ) ; * oldp = newp ; } else { <S2SV_StartBug> vp9_write ( w , 0 , upd ) ; <S2SV_EndBug> } }
CWE-119 protected int file_trycdf ( struct magic_set * ms , int fd , const unsigned char * buf , size_t nbytes ) { cdf_info_t info ; cdf_header_t h ; cdf_sat_t sat , ssat ; cdf_stream_t sst , scn ; cdf_dir_t dir ; int i ; const char * expn = "" ; const char * corrupt = "corrupt:<S2SV_blank>" ; info . i_fd = fd ; info . i_buf = buf ; info . i_len = nbytes ; if ( ms -> flags & MAGIC_APPLE ) return 0 ; if ( cdf_read_header ( & info , & h ) == - 1 ) return 0 ; # ifdef CDF_DEBUG cdf_dump_header ( & h ) ; # endif if ( ( i = cdf_read_sat ( & info , & h , & sat ) ) == - 1 ) { expn = "Can\'t<S2SV_blank>read<S2SV_blank>SAT" ; goto out0 ; } # ifdef CDF_DEBUG cdf_dump_sat ( "SAT" , & sat , CDF_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_ssat ( & info , & h , & sat , & ssat ) ) == - 1 ) { expn = "Can\'t<S2SV_blank>read<S2SV_blank>SSAT" ; goto out1 ; } # ifdef CDF_DEBUG cdf_dump_sat ( "SSAT" , & ssat , CDF_SHORT_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_dir ( & info , & h , & sat , & dir ) ) == - 1 ) { expn = "Can\'t<S2SV_blank>read<S2SV_blank>directory" ; goto out2 ; } const cdf_directory_t * root_storage ; if ( ( i = cdf_read_short_stream ( & info , & h , & sat , & dir , & sst , & root_storage ) ) == - 1 ) { expn = "Cannot<S2SV_blank>read<S2SV_blank>short<S2SV_blank>stream" ; goto out3 ; } # ifdef CDF_DEBUG cdf_dump_dir ( & info , & h , & sat , & ssat , & sst , & dir ) ; # endif # ifdef notdef if ( root_storage ) { if ( NOTMIME ( ms ) ) { char clsbuf [ 128 ] ; if ( file_printf ( ms , "CLSID<S2SV_blank>%s,<S2SV_blank>" , format_clsid ( clsbuf , sizeof ( clsbuf ) , root_storage -> d_storage_uuid ) ) == - 1 ) return - 1 ; } } # endif if ( ( i = cdf_read_summary_info ( & info , & h , & sat , & ssat , & sst , & dir , & scn ) ) == - 1 ) { if ( errno == ESRCH ) { corrupt = expn ; expn = "No<S2SV_blank>summary<S2SV_blank>info" ; } else { expn = "Cannot<S2SV_blank>read<S2SV_blank>summary<S2SV_blank>info" ; } goto out4 ; } # ifdef CDF_DEBUG cdf_dump_summary_info ( & h , & scn ) ; # endif if ( ( i = cdf_file_summary_info ( ms , & h , & scn , <S2SV_StartBug> root_storage -> d_storage_uuid ) ) < 0 ) <S2SV_EndBug> expn = "Can\'t<S2SV_blank>expand<S2SV_blank>summary_info" ; if ( i == 0 ) { const char * str = NULL ; cdf_directory_t * d ; char name [ __arraycount ( d -> d_name ) ] ; size_t j , k ; for ( j = 0 ; str == NULL && j < dir . dir_len ; j ++ ) { d = & dir . dir_tab [ j ] ; for ( k = 0 ; k < sizeof ( name ) ; k ++ ) name [ k ] = ( char ) cdf_tole2 ( d -> d_name [ k ] ) ; str = cdf_app_to_mime ( name , NOTMIME ( ms ) ? name2desc : name2mime ) ; } if ( NOTMIME ( ms ) ) { if ( str != NULL ) { if ( file_printf ( ms , "%s" , str ) == - 1 ) return - 1 ; i = 1 ; } } else { if ( str == NULL ) str = "vnd.ms-office" ; if ( file_printf ( ms , "application/%s" , str ) == - 1 ) return - 1 ; i = 1 ; } } free ( scn . sst_tab ) ; out4 : free ( sst . sst_tab ) ; out3 : free ( dir . dir_tab ) ; out2 : free ( ssat . sat_tab ) ; out1 : free ( sat . sat_tab ) ; out0 : if ( i == - 1 ) { if ( NOTMIME ( ms ) ) { if ( file_printf ( ms , "Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document" ) == - 1 ) return - 1 ; if ( * expn ) if ( file_printf ( ms , ",<S2SV_blank>%s%s" , corrupt , expn ) == - 1 ) return - 1 ; } else { if ( file_printf ( ms , "application/CDFV2-corrupt" ) == - 1 ) return - 1 ; } i = 1 ; } return i ; }
CWE-362 static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; get_block_t * get_block ; if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) return 0 ; if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && ! ocfs2_supports_append_dio ( osb ) ) return 0 ; if ( iov_iter_rw ( iter ) == READ ) <S2SV_StartBug> get_block = ocfs2_get_block ; <S2SV_EndBug> else <S2SV_StartBug> get_block = ocfs2_dio_get_block ; <S2SV_EndBug> return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ; }
CWE-000 static int em_syscall ( struct x86_emulate_ctxt * ctxt ) { struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_ud ( ctxt ) ; <S2SV_StartBug> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; <S2SV_EndBug> <S2SV_StartBug> setup_syscalls_segments ( ctxt , & cs , & ss ) ; <S2SV_EndBug> ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ; msr_data >>= 32 ; cs_sel = ( u16 ) ( msr_data & 0xfffc ) ; ss_sel = ( u16 ) ( msr_data + 8 ) ; if ( efer & EFER_LMA ) { cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ctxt -> regs [ VCPU_REGS_RCX ] = ctxt -> _eip ; if ( efer & EFER_LMA ) { # ifdef CONFIG_X86_64 ctxt -> regs [ VCPU_REGS_R11 ] = ctxt -> eflags & ~ EFLG_RF ; ops -> get_msr ( ctxt , ctxt -> mode == X86EMUL_MODE_PROT64 ? MSR_LSTAR : MSR_CSTAR , & msr_data ) ; ctxt -> _eip = msr_data ; ops -> get_msr ( ctxt , MSR_SYSCALL_MASK , & msr_data ) ; ctxt -> eflags &= ~ ( msr_data | EFLG_RF ) ; # endif } else { ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ; ctxt -> _eip = ( u32 ) msr_data ; ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF | EFLG_RF ) ; } return X86EMUL_CONTINUE ; }
CWE-787 PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "rdd" , & IM , & input , & output ) == FAILURE ) { return ; } <S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , "Image" , le_gd ) ; <S2SV_EndBug> if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++ ) { im -> red [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> red [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> green [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> green [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> blue [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> blue [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; } RETURN_TRUE ; }
CWE-119 static __init int sctp_init ( void ) { int i ; int status = - EINVAL ; unsigned long goal ; unsigned long limit ; int max_share ; int order ; sock_skb_cb_check_size ( sizeof ( struct sctp_ulpevent ) ) ; status = - ENOBUFS ; sctp_bucket_cachep = kmem_cache_create ( "sctp_bind_bucket" , sizeof ( struct sctp_bind_bucket ) , 0 , SLAB_HWCACHE_ALIGN , NULL ) ; if ( ! sctp_bucket_cachep ) goto out ; sctp_chunk_cachep = kmem_cache_create ( "sctp_chunk" , sizeof ( struct sctp_chunk ) , 0 , SLAB_HWCACHE_ALIGN , NULL ) ; if ( ! sctp_chunk_cachep ) goto err_chunk_cachep ; status = percpu_counter_init ( & sctp_sockets_allocated , 0 , GFP_KERNEL ) ; if ( status ) goto err_percpu_counter_init ; sctp_max_instreams = SCTP_DEFAULT_INSTREAMS ; sctp_max_outstreams = SCTP_DEFAULT_OUTSTREAMS ; idr_init ( & sctp_assocs_id ) ; limit = nr_free_buffer_pages ( ) / 8 ; limit = max ( limit , 128UL ) ; sysctl_sctp_mem [ 0 ] = limit / 4 * 3 ; sysctl_sctp_mem [ 1 ] = limit ; sysctl_sctp_mem [ 2 ] = sysctl_sctp_mem [ 0 ] * 2 ; limit = ( sysctl_sctp_mem [ 1 ] ) << ( PAGE_SHIFT - 7 ) ; max_share = min ( 4UL * 1024 * 1024 , limit ) ; sysctl_sctp_rmem [ 0 ] = SK_MEM_QUANTUM ; sysctl_sctp_rmem [ 1 ] = 1500 * SKB_TRUESIZE ( 1 ) ; sysctl_sctp_rmem [ 2 ] = max ( sysctl_sctp_rmem [ 1 ] , max_share ) ; sysctl_sctp_wmem [ 0 ] = SK_MEM_QUANTUM ; sysctl_sctp_wmem [ 1 ] = 16 * 1024 ; sysctl_sctp_wmem [ 2 ] = max ( 64 * 1024 , max_share ) ; if ( totalram_pages >= ( 128 * 1024 ) ) goal = totalram_pages >> ( 22 - PAGE_SHIFT ) ; else goal = totalram_pages >> ( 24 - PAGE_SHIFT ) ; for ( order = 0 ; ( 1UL << order ) < goal ; order ++ ) ; do { sctp_assoc_hashsize = ( 1UL << order ) * PAGE_SIZE / sizeof ( struct sctp_hashbucket ) ; if ( ( sctp_assoc_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_assoc_hashtable = ( struct sctp_hashbucket * ) __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; } while ( ! sctp_assoc_hashtable && -- order > 0 ) ; if ( ! sctp_assoc_hashtable ) { pr_err ( "Failed<S2SV_blank>association<S2SV_blank>hash<S2SV_blank>alloc\\n" ) ; status = - ENOMEM ; goto err_ahash_alloc ; } for ( i = 0 ; i < sctp_assoc_hashsize ; i ++ ) { rwlock_init ( & sctp_assoc_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_assoc_hashtable [ i ] . chain ) ; } sctp_ep_hashsize = 64 ; sctp_ep_hashtable = kmalloc ( 64 * sizeof ( struct sctp_hashbucket ) , GFP_KERNEL ) ; if ( ! sctp_ep_hashtable ) { pr_err ( "Failed<S2SV_blank>endpoint_hash<S2SV_blank>alloc\\n" ) ; status = - ENOMEM ; goto err_ehash_alloc ; } for ( i = 0 ; i < sctp_ep_hashsize ; i ++ ) { rwlock_init ( & sctp_ep_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_ep_hashtable [ i ] . chain ) ; } do { sctp_port_hashsize = ( 1UL << order ) * PAGE_SIZE / sizeof ( struct sctp_bind_hashbucket ) ; if ( ( sctp_port_hashsize > ( 64 * 1024 ) ) && order > 0 ) continue ; sctp_port_hashtable = ( struct sctp_bind_hashbucket * ) __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; } while ( ! sctp_port_hashtable && -- order > 0 ) ; if ( ! sctp_port_hashtable ) { pr_err ( "Failed<S2SV_blank>bind<S2SV_blank>hash<S2SV_blank>alloc\\n" ) ; status = - ENOMEM ; goto err_bhash_alloc ; } for ( i = 0 ; i < sctp_port_hashsize ; i ++ ) { spin_lock_init ( & sctp_port_hashtable [ i ] . lock ) ; INIT_HLIST_HEAD ( & sctp_port_hashtable [ i ] . chain ) ; } pr_info ( "Hash<S2SV_blank>tables<S2SV_blank>configured<S2SV_blank>(established<S2SV_blank>%d<S2SV_blank>bind<S2SV_blank>%d)\\n" , sctp_assoc_hashsize , sctp_port_hashsize ) ; sctp_sysctl_register ( ) ; INIT_LIST_HEAD ( & sctp_address_families ) ; sctp_v4_pf_init ( ) ; sctp_v6_pf_init ( ) ; <S2SV_StartBug> status = sctp_v4_protosw_init ( ) ; <S2SV_EndBug> if ( status ) goto err_protosw_init ; status = sctp_v6_protosw_init ( ) ; if ( status ) goto err_v6_protosw_init ; <S2SV_StartBug> status = register_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> if ( status ) goto err_register_pernet_subsys ; status = sctp_v4_add_protocol ( ) ; if ( status ) goto err_add_protocol ; status = sctp_v6_add_protocol ( ) ; if ( status ) goto err_v6_add_protocol ; out : return status ; err_v6_add_protocol : sctp_v4_del_protocol ( ) ; err_add_protocol : <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> err_register_pernet_subsys : sctp_v6_protosw_exit ( ) ; err_v6_protosw_init : sctp_v4_protosw_exit ( ) ; <S2SV_StartBug> err_protosw_init : <S2SV_EndBug> sctp_v4_pf_exit ( ) ; sctp_v6_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; err_bhash_alloc : kfree ( sctp_ep_hashtable ) ; err_ehash_alloc : free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; err_ahash_alloc : percpu_counter_destroy ( & sctp_sockets_allocated ) ; err_percpu_counter_init : kmem_cache_destroy ( sctp_chunk_cachep ) ; err_chunk_cachep : kmem_cache_destroy ( sctp_bucket_cachep ) ; goto out ; }
CWE-119 enum nss_status _nss_mymachines_getpwnam_r ( const char * name , struct passwd * pwd , char * buffer , size_t buflen , int * errnop ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; _cleanup_bus_message_unref_ sd_bus_message * reply = NULL ; _cleanup_bus_flush_close_unref_ sd_bus * bus = NULL ; const char * p , * e , * machine ; uint32_t mapped ; uid_t uid ; size_t l ; int r ; assert ( name ) ; assert ( pwd ) ; p = startswith ( name , "vu-" ) ; if ( ! p ) goto not_found ; e = strrchr ( p , '-' ) ; <S2SV_StartBug> if ( ! e || e == p ) <S2SV_EndBug> goto not_found ; r = parse_uid ( e + 1 , & uid ) ; if ( r < 0 ) goto not_found ; machine = strndupa ( p , e - p ) ; if ( ! machine_name_is_valid ( machine ) ) goto not_found ; r = sd_bus_open_system ( & bus ) ; if ( r < 0 ) goto fail ; r = sd_bus_call_method ( bus , "org.freedesktop.machine1" , "/org/freedesktop/machine1" , "org.freedesktop.machine1.Manager" , "MapFromMachineUser" , & error , & reply , "su" , machine , ( uint32_t ) uid ) ; if ( r < 0 ) { if ( sd_bus_error_has_name ( & error , BUS_ERROR_NO_SUCH_USER_MAPPING ) ) goto not_found ; goto fail ; } r = sd_bus_message_read ( reply , "u" , & mapped ) ; if ( r < 0 ) goto fail ; l = strlen ( name ) ; if ( buflen < l + 1 ) { * errnop = ENOMEM ; return NSS_STATUS_TRYAGAIN ; } memcpy ( buffer , name , l + 1 ) ; pwd -> pw_name = buffer ; pwd -> pw_uid = mapped ; pwd -> pw_gid = 65534 ; pwd -> pw_gecos = buffer ; pwd -> pw_passwd = ( char * ) "*" ; pwd -> pw_dir = ( char * ) "/" ; pwd -> pw_shell = ( char * ) "/sbin/nologin" ; * errnop = 0 ; return NSS_STATUS_SUCCESS ; not_found : * errnop = 0 ; return NSS_STATUS_NOTFOUND ; fail : * errnop = - r ; return NSS_STATUS_UNAVAIL ; }
CWE-119 static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) { <S2SV_StartBug> u_char * b , * s , * t , c ; <S2SV_EndBug> int i , proto ; const void * se ; if ( length <= 0 ) return ; <S2SV_StartBug> b = ( uint8_t * ) malloc ( length ) ; <S2SV_EndBug> if ( b == NULL ) return ; <S2SV_StartBug> for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) { <S2SV_EndBug> c = * s ++ ; if ( c == 0x7d ) { <S2SV_StartBug> if ( i > 1 ) { <S2SV_EndBug> i -- ; <S2SV_StartBug> c = * s ++ ^ 0x20 ; <S2SV_EndBug> } else continue ; } * t ++ = c ; } se = ndo -> ndo_snapend ; ndo -> ndo_snapend = t ; length = t - b ; if ( length < 1 ) goto trunc ; proto = * b ; switch ( proto ) { case PPP_IP : ip_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; case PPP_IPV6 : ip6_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; default : break ; } if ( length < 2 ) goto trunc ; proto = EXTRACT_16BITS ( b ) ; switch ( proto ) { case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ; proto = EXTRACT_16BITS ( b + 2 ) ; handle_ppp ( ndo , proto , b + 4 , length - 4 ) ; break ; default : handle_ppp ( ndo , proto , b + 2 , length - 2 ) ; break ; } cleanup : ndo -> ndo_snapend = se ; free ( b ) ; return ; trunc : ndo -> ndo_snapend = se ; free ( b ) ; ND_PRINT ( ( ndo , "[|ppp]" ) ) ; }
CWE-119 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , "disc<S2SV_blank>change<S2SV_blank>detected.\\n" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , "CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , "CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>" "is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }
CWE-264 static int flakey_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct flakey_c * fc = ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }
CWE-119 void gdImageFillToBorder ( gdImagePtr im , int x , int y , int border , int color ) { int lastBorder ; int leftLimit = - 1 , rightLimit ; int i , restoreAlphaBlending = 0 ; <S2SV_StartBug> if ( border < 0 ) { <S2SV_EndBug> return ; } if ( ! im -> trueColor ) { if ( ( color > ( im -> colorsTotal - 1 ) ) || ( border > ( im -> colorsTotal - 1 ) ) || ( color < 0 ) ) { return ; } } restoreAlphaBlending = im -> alphaBlendingFlag ; im -> alphaBlendingFlag = 0 ; if ( x >= im -> sx ) { x = im -> sx - 1 ; } else if ( x < 0 ) { x = 0 ; } if ( y >= im -> sy ) { y = im -> sy - 1 ; } else if ( y < 0 ) { y = 0 ; } for ( i = x ; i >= 0 ; i -- ) { if ( gdImageGetPixel ( im , i , y ) == border ) { break ; } gdImageSetPixel ( im , i , y , color ) ; leftLimit = i ; } if ( leftLimit == - 1 ) { im -> alphaBlendingFlag = restoreAlphaBlending ; return ; } rightLimit = x ; for ( i = ( x + 1 ) ; i < im -> sx ; i ++ ) { if ( gdImageGetPixel ( im , i , y ) == border ) { break ; } gdImageSetPixel ( im , i , y , color ) ; rightLimit = i ; } if ( y > 0 ) { lastBorder = 1 ; for ( i = leftLimit ; i <= rightLimit ; i ++ ) { int c = gdImageGetPixel ( im , i , y - 1 ) ; if ( lastBorder ) { if ( ( c != border ) && ( c != color ) ) { gdImageFillToBorder ( im , i , y - 1 , border , color ) ; lastBorder = 0 ; } } else if ( ( c == border ) || ( c == color ) ) { lastBorder = 1 ; } } } if ( y < ( ( im -> sy ) - 1 ) ) { lastBorder = 1 ; for ( i = leftLimit ; i <= rightLimit ; i ++ ) { int c = gdImageGetPixel ( im , i , y + 1 ) ; if ( lastBorder ) { if ( ( c != border ) && ( c != color ) ) { gdImageFillToBorder ( im , i , y + 1 , border , color ) ; lastBorder = 0 ; } } else if ( ( c == border ) || ( c == color ) ) { lastBorder = 1 ; } } } im -> alphaBlendingFlag = restoreAlphaBlending ; }
CWE-362 int prepare_binprm ( struct linux_binprm * bprm ) { <S2SV_StartBug> struct inode * inode = file_inode ( bprm -> file ) ; <S2SV_EndBug> umode_t mode = inode -> i_mode ; int retval ; <S2SV_StartBug> bprm -> cred -> euid = current_euid ( ) ; <S2SV_EndBug> bprm -> cred -> egid = current_egid ( ) ; if ( ! ( bprm -> file -> f_path . mnt -> mnt_flags & MNT_NOSUID ) && ! task_no_new_privs ( current ) && kuid_has_mapping ( bprm -> cred -> user_ns , inode -> i_uid ) && kgid_has_mapping ( bprm -> cred -> user_ns , inode -> i_gid ) ) { if ( mode & S_ISUID ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> euid = inode -> i_uid ; } if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> egid = inode -> i_gid ; } } retval = security_bprm_set_creds ( bprm ) ; if ( retval ) return retval ; bprm -> cred_prepared = 1 ; memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; }
CWE-119 static struct nvmet_fc_tgt_queue * nvmet_fc_find_target_queue ( struct nvmet_fc_tgtport * tgtport , u64 connection_id ) { struct nvmet_fc_tgt_assoc * assoc ; struct nvmet_fc_tgt_queue * queue ; u64 association_id = nvmet_fc_getassociationid ( connection_id ) ; u16 qid = nvmet_fc_getqueueid ( connection_id ) ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> spin_lock_irqsave ( & tgtport -> lock , flags ) ; list_for_each_entry ( assoc , & tgtport -> assoc_list , a_list ) { if ( association_id == assoc -> association_id ) { queue = assoc -> queues [ qid ] ; if ( queue && ( ! atomic_read ( & queue -> connected ) || ! nvmet_fc_tgt_q_get ( queue ) ) ) queue = NULL ; spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return queue ; } } spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return NULL ; }
CWE-119 static bool regsafe ( struct bpf_reg_state * rold , struct bpf_reg_state * rcur , struct idpair * idmap ) { if ( ! ( rold -> live & REG_LIVE_READ ) ) return true ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , live ) ) == 0 ) return true ; if ( rold -> type == NOT_INIT ) return true ; if ( rcur -> type == NOT_INIT ) return false ; switch ( rold -> type ) { case SCALAR_VALUE : if ( rcur -> type == SCALAR_VALUE ) { return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; } else { <S2SV_StartBug> return rold -> umin_value == 0 && <S2SV_EndBug> rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ; } case PTR_TO_MAP_VALUE : return memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) == 0 && range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_MAP_VALUE_OR_NULL : if ( rcur -> type != PTR_TO_MAP_VALUE_OR_NULL ) return false ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) ) return false ; return check_ids ( rold -> id , rcur -> id , idmap ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET : if ( rcur -> type != rold -> type ) return false ; if ( rold -> range > rcur -> range ) return false ; if ( rold -> off != rcur -> off ) return false ; if ( rold -> id && ! check_ids ( rold -> id , rcur -> id , idmap ) ) return false ; return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_CTX : case CONST_PTR_TO_MAP : case PTR_TO_STACK : case PTR_TO_PACKET_END : default : return false ; } WARN_ON_ONCE ( 1 ) ; return false ; }
CWE-119 static void dtls1_clear_queues ( SSL * s ) { pitem * item = NULL ; hm_fragment * frag = NULL ; DTLS1_RECORD_DATA * rdata ; while ( ( item = pqueue_pop ( s -> d1 -> unprocessed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> processed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> sent_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ) != NULL ) { <S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } }
CWE-119 static enum led_brightness k90_backlight_get ( struct led_classdev * led_cdev ) { int ret ; struct k90_led * led = container_of ( led_cdev , struct k90_led , cdev ) ; struct device * dev = led -> cdev . dev -> parent ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int brightness ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> } brightness = data [ 4 ] ; if ( brightness < 0 || brightness > 3 ) { dev_warn ( dev , "Read<S2SV_blank>invalid<S2SV_blank>backlight<S2SV_blank>brightness:<S2SV_blank>%02hhx.\\n" , data [ 4 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return brightness ; }
CWE-119 static int32_t scsi_send_command ( SCSIRequest * req , uint8_t * buf ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; int32_t len ; uint8_t command ; <S2SV_StartBug> uint8_t * outbuf ; <S2SV_EndBug> int rc ; <S2SV_StartBug> command = buf [ 0 ] ; <S2SV_EndBug> outbuf = ( uint8_t * ) r -> iov . iov_base ; DPRINTF ( "Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x" , req -> lun , req -> tag , buf [ 0 ] ) ; # ifdef DEBUG_SCSI { int i ; for ( i = 1 ; i < r -> req . cmd . len ; i ++ ) { printf ( "<S2SV_blank>0x%02x" , buf [ i ] ) ; } printf ( "\\n" ) ; } # endif switch ( command ) { case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 : <S2SV_StartBug> rc = scsi_disk_emulate_command ( r , outbuf ) ; <S2SV_EndBug> if ( rc < 0 ) { return 0 ; } r -> iov . iov_len = rc ; break ; case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ; r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_flush_complete ( r , - EIO ) ; } return 0 ; case READ_6 : case READ_10 : case READ_12 : case READ_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( "Read<S2SV_blank>(sector<S2SV_blank>%" PRId64 ",<S2SV_blank>count<S2SV_blank>%d)\\n" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) goto illegal_lba ; r -> sector = r -> req . cmd . lba * s -> cluster_size ; r -> sector_count = len * s -> cluster_size ; break ; case WRITE_6 : case WRITE_10 : case WRITE_12 : case WRITE_16 : case WRITE_VERIFY_10 : case WRITE_VERIFY_12 : case WRITE_VERIFY_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( "Write<S2SV_blank>%s(sector<S2SV_blank>%" PRId64 ",<S2SV_blank>count<S2SV_blank>%d)\\n" , ( command & 0xe ) == 0xe ? "And<S2SV_blank>Verify<S2SV_blank>" : "" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) goto illegal_lba ; r -> sector = r -> req . cmd . lba * s -> cluster_size ; r -> sector_count = len * s -> cluster_size ; break ; case MODE_SELECT : DPRINTF ( "Mode<S2SV_blank>Select(6)<S2SV_blank>(len<S2SV_blank>%lu)\\n" , ( long ) r -> req . cmd . xfer ) ; if ( r -> req . cmd . xfer > 12 ) { goto fail ; } break ; case MODE_SELECT_10 : DPRINTF ( "Mode<S2SV_blank>Select(10)<S2SV_blank>(len<S2SV_blank>%lu)\\n" , ( long ) r -> req . cmd . xfer ) ; if ( r -> req . cmd . xfer > 16 ) { goto fail ; } break ; case SEEK_6 : case SEEK_10 : DPRINTF ( "Seek(%d)<S2SV_blank>(sector<S2SV_blank>%" PRId64 ")\\n" , command == SEEK_6 ? 6 : 10 , r -> req . cmd . lba ) ; if ( r -> req . cmd . lba > s -> max_lba ) { goto illegal_lba ; } break ; case WRITE_SAME_16 : len = r -> req . cmd . xfer / s -> qdev . blocksize ; DPRINTF ( "WRITE<S2SV_blank>SAME(16)<S2SV_blank>(sector<S2SV_blank>%" PRId64 ",<S2SV_blank>count<S2SV_blank>%d)\\n" , r -> req . cmd . lba , len ) ; if ( r -> req . cmd . lba > s -> max_lba ) { goto illegal_lba ; } if ( ! ( buf [ 1 ] & 0x8 ) ) { goto fail ; } rc = bdrv_discard ( s -> bs , r -> req . cmd . lba * s -> cluster_size , len * s -> cluster_size ) ; if ( rc < 0 ) { goto fail ; } break ; case REQUEST_SENSE : abort ( ) ; default : DPRINTF ( "Unknown<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>(%2.2x)\\n" , buf [ 0 ] ) ; scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; return 0 ; fail : scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; return 0 ; illegal_lba : scsi_check_condition ( r , SENSE_CODE ( LBA_OUT_OF_RANGE ) ) ; return 0 ; } if ( r -> sector_count == 0 && r -> iov . iov_len == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } len = r -> sector_count * 512 + r -> iov . iov_len ; if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) { return - len ; } else { if ( ! r -> sector_count ) r -> sector_count = - 1 ; return len ; } }
CWE-000 void __fput_sync ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { struct task_struct * task = current ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ; __fput ( file ) ; } }
CWE-125 static bool r_bin_mdmp_init_directory ( struct r_bin_mdmp_obj * obj ) { int i ; <S2SV_StartBug> ut8 * directory_base ; <S2SV_EndBug> struct minidump_directory * entry ; directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; sdb_num_set ( obj -> kv , "mdmp_directory.offset" , obj -> hdr -> stream_directory_rva , 0 ) ; sdb_set ( obj -> kv , "mdmp_directory.format" , "[4]E?<S2SV_blank>" "(mdmp_stream_type)StreamType<S2SV_blank>" "(mdmp_location_descriptor)Location" , 0 ) ; <S2SV_StartBug> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <S2SV_EndBug> } return true ; }
CWE-416 static void destroy_server_connect ( SERVER_CONNECT_REC * conn ) { IRC_SERVER_CONNECT_REC * ircconn ; ircconn = IRC_SERVER_CONNECT ( conn ) ; if ( ircconn == NULL ) return ; g_free_not_null ( ircconn -> usermode ) ; g_free_not_null ( ircconn -> alternate_nick ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; asoc -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer . i = new -> peer . i ; sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; <S2SV_StartBug> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; <S2SV_EndBug> sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }
CWE-416 static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) <S2SV_StartBug> { <S2SV_EndBug> kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }
CWE-119 static int parse_device ( dev_t * pdev , struct archive * a , char * val ) { # define MAX_PACK_ARGS 3 unsigned long numbers [ MAX_PACK_ARGS ] ; char * p , * dev ; int argc ; pack_t * pack ; dev_t result ; const char * error = NULL ; memset ( pdev , 0 , sizeof ( * pdev ) ) ; if ( ( dev = strchr ( val , ',' ) ) != NULL ) { * dev ++ = '\\0' ; if ( ( pack = pack_find ( val ) ) == NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "Unknown<S2SV_blank>format<S2SV_blank>`%s\'" , val ) ; return ARCHIVE_WARN ; } argc = 0 ; while ( ( p = la_strsep ( & dev , "," ) ) != NULL ) { if ( * p == '\\0' ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "Missing<S2SV_blank>number" ) ; return ARCHIVE_WARN ; } <S2SV_StartBug> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argc > MAX_PACK_ARGS ) { <S2SV_EndBug> archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "Too<S2SV_blank>many<S2SV_blank>arguments" ) ; return ARCHIVE_WARN ; } } if ( argc < 2 ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "Not<S2SV_blank>enough<S2SV_blank>arguments" ) ; return ARCHIVE_WARN ; } result = ( * pack ) ( argc , numbers , & error ) ; if ( error != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "%s" , error ) ; return ARCHIVE_WARN ; } } else { result = ( dev_t ) mtree_atol ( & val ) ; } * pdev = result ; return ARCHIVE_OK ; # undef MAX_PACK_ARGS }
CWE-000 static void Rp_test ( js_State * J ) { js_Regexp * re ; const char * text ; <S2SV_StartBug> int opts ; <S2SV_EndBug> Resub m ; re = js_toregexp ( J , 0 ) ; text = js_tostring ( J , 1 ) ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushboolean ( J , 0 ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; js_pushboolean ( J , 1 ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushboolean ( J , 0 ) ; }
CWE-000 static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; <S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = "localhost" ; } <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ; state ( conn , SMTP_SERVERGREET ) ; if ( data -> state . used_interface == Curl_if_multi ) result = smtp_multi_statemach ( conn , done ) ; else { result = smtp_easy_statemach ( conn ) ; if ( ! result ) * done = TRUE ; } return result ; }
CWE-416 static int get_gate_page ( struct mm_struct * mm , unsigned long address , unsigned int gup_flags , struct vm_area_struct * * vma , struct page * * page ) { pgd_t * pgd ; p4d_t * p4d ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; int ret = - EFAULT ; if ( gup_flags & FOLL_WRITE ) return - EFAULT ; if ( address > TASK_SIZE ) pgd = pgd_offset_k ( address ) ; else pgd = pgd_offset_gate ( mm , address ) ; BUG_ON ( pgd_none ( * pgd ) ) ; p4d = p4d_offset ( pgd , address ) ; BUG_ON ( p4d_none ( * p4d ) ) ; pud = pud_offset ( p4d , address ) ; BUG_ON ( pud_none ( * pud ) ) ; pmd = pmd_offset ( pud , address ) ; if ( ! pmd_present ( * pmd ) ) return - EFAULT ; VM_BUG_ON ( pmd_trans_huge ( * pmd ) ) ; pte = pte_offset_map ( pmd , address ) ; if ( pte_none ( * pte ) ) goto unmap ; * vma = get_gate_vma ( mm ) ; if ( ! page ) goto out ; * page = vm_normal_page ( * vma , address , * pte ) ; if ( ! * page ) { if ( ( gup_flags & FOLL_DUMP ) || ! is_zero_pfn ( pte_pfn ( * pte ) ) ) goto unmap ; * page = pte_page ( * pte ) ; if ( is_device_public_page ( * page ) ) goto unmap ; } <S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> out : ret = 0 ; unmap : pte_unmap ( pte ) ; return ret ; }
CWE-20 <S2SV_StartBug> int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode ) <S2SV_EndBug> { <S2SV_StartBug> int result = parse_rock_ridge_inode_internal ( de , inode , 0 ) ; <S2SV_EndBug> if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) { <S2SV_StartBug> result = parse_rock_ridge_inode_internal ( de , inode , 14 ) ; <S2SV_EndBug> } return result ; }
CWE-416 void snd_pcm_period_elapsed ( struct snd_pcm_substream * substream ) { struct snd_pcm_runtime * runtime ; unsigned long flags ; if ( PCM_RUNTIME_CHECK ( substream ) ) return ; runtime = substream -> runtime ; snd_pcm_stream_lock_irqsave ( substream , flags ) ; if ( ! snd_pcm_running ( substream ) || snd_pcm_update_hw_ptr0 ( substream , 1 ) < 0 ) goto _end ; # ifdef CONFIG_SND_PCM_TIMER if ( substream -> timer_running ) snd_timer_interrupt ( substream -> timer , 1 ) ; # endif _end : <S2SV_StartBug> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; <S2SV_EndBug> kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 int vp8_regulate_q ( VP8_COMP * cpi , int target_bits_per_frame ) { <S2SV_StartBug> int Q = cpi -> active_worst_quality ; <S2SV_EndBug> cpi -> mb . zbin_over_quant = 0 ; if ( cpi -> oxcf . fixed_q >= 0 ) { Q = cpi -> oxcf . fixed_q ; if ( cpi -> common . frame_type == KEY_FRAME ) { Q = cpi -> oxcf . key_q ; } else if ( cpi -> oxcf . number_of_layers == 1 && cpi -> common . refresh_alt_ref_frame ) { Q = cpi -> oxcf . alt_q ; } else if ( cpi -> oxcf . number_of_layers == 1 && cpi -> common . refresh_golden_frame ) { Q = cpi -> oxcf . gold_q ; } } else { int i ; int last_error = INT_MAX ; int target_bits_per_mb ; int bits_per_mb_at_this_q ; double correction_factor ; if ( cpi -> common . frame_type == KEY_FRAME ) correction_factor = cpi -> key_frame_rate_correction_factor ; else { if ( cpi -> oxcf . number_of_layers == 1 && ( cpi -> common . refresh_alt_ref_frame || cpi -> common . refresh_golden_frame ) ) correction_factor = cpi -> gf_rate_correction_factor ; else correction_factor = cpi -> rate_correction_factor ; } if ( target_bits_per_frame >= ( INT_MAX >> BPER_MB_NORMBITS ) ) target_bits_per_mb = ( target_bits_per_frame / cpi -> common . MBs ) << BPER_MB_NORMBITS ; else target_bits_per_mb = ( target_bits_per_frame << BPER_MB_NORMBITS ) / cpi -> common . MBs ; i = cpi -> active_best_quality ; do { bits_per_mb_at_this_q = ( int ) ( .5 + correction_factor * vp8_bits_per_mb [ cpi -> common . frame_type ] [ i ] ) ; if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) Q = i ; else Q = i - 1 ; break ; } else last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } while ( ++ i <= cpi -> active_worst_quality ) ; if ( Q >= MAXQ ) { int zbin_oqmax ; double Factor = 0.99 ; double factor_adjustment = 0.01 / 256.0 ; if ( cpi -> common . frame_type == KEY_FRAME ) zbin_oqmax = 0 ; else if ( cpi -> oxcf . number_of_layers == 1 && ( cpi -> common . refresh_alt_ref_frame || ( cpi -> common . refresh_golden_frame && ! cpi -> source_alt_ref_active ) ) ) zbin_oqmax = 16 ; else zbin_oqmax = ZBIN_OQ_MAX ; while ( cpi -> mb . zbin_over_quant < zbin_oqmax ) { cpi -> mb . zbin_over_quant ++ ; if ( cpi -> mb . zbin_over_quant > zbin_oqmax ) cpi -> mb . zbin_over_quant = zbin_oqmax ; bits_per_mb_at_this_q = ( int ) ( Factor * bits_per_mb_at_this_q ) ; Factor += factor_adjustment ; if ( Factor >= 0.999 ) Factor = 0.999 ; if ( bits_per_mb_at_this_q <= target_bits_per_mb ) break ; } } } return Q ; }
CWE-284 static void mntput_no_expire ( struct mount * mnt ) { rcu_read_lock ( ) ; mnt_add_count ( mnt , - 1 ) ; if ( likely ( mnt -> mnt_ns ) ) { rcu_read_unlock ( ) ; return ; } lock_mount_hash ( ) ; if ( mnt_get_count ( mnt ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } if ( unlikely ( mnt -> mnt . mnt_flags & MNT_DOOMED ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } mnt -> mnt . mnt_flags |= MNT_DOOMED ; rcu_read_unlock ( ) ; list_del ( & mnt -> mnt_instance ) ; <S2SV_StartBug> unlock_mount_hash ( ) ; <S2SV_EndBug> if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) { struct task_struct * task = current ; if ( likely ( ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & mnt -> mnt_rcu , __cleanup_mnt ) ; if ( ! task_work_add ( task , & mnt -> mnt_rcu , true ) ) return ; } if ( llist_add ( & mnt -> mnt_llist , & delayed_mntput_list ) ) schedule_delayed_work ( & delayed_mntput_work , 1 ) ; return ; } cleanup_mnt ( mnt ) ; }
CWE-200 static int ext4_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) { handle_t * handle = ext4_journal_current_handle ( ) ; struct inode * inode = mapping -> host ; loff_t old_size = inode -> i_size ; int ret = 0 , ret2 ; int i_size_changed = 0 ; trace_ext4_write_end ( inode , pos , len , copied ) ; <S2SV_StartBug> if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) { <S2SV_EndBug> ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) { unlock_page ( page ) ; put_page ( page ) ; goto errout ; } } if ( ext4_has_inline_data ( inode ) ) { ret = ext4_write_inline_data_end ( inode , pos , len , copied , page ) ; if ( ret < 0 ) goto errout ; copied = ret ; } else copied = block_write_end ( file , mapping , pos , len , copied , page , fsdata ) ; i_size_changed = ext4_update_inode_size ( inode , pos + copied ) ; unlock_page ( page ) ; put_page ( page ) ; if ( old_size < pos ) pagecache_isize_extended ( inode , old_size , pos ) ; if ( i_size_changed ) ext4_mark_inode_dirty ( handle , inode ) ; if ( pos + len > inode -> i_size && ext4_can_truncate ( inode ) ) ext4_orphan_add ( handle , inode ) ; errout : ret2 = ext4_journal_stop ( handle ) ; if ( ! ret ) ret = ret2 ; if ( pos + len > inode -> i_size ) { ext4_truncate_failed_write ( inode ) ; if ( inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; } return ret ? ret : copied ; }
CWE-264 int hfsplus_rename_cat ( u32 cnid , struct inode * src_dir , struct qstr * src_name , struct inode * dst_dir , struct qstr * dst_name ) { struct super_block * sb = src_dir -> i_sb ; struct hfs_find_data src_fd , dst_fd ; hfsplus_cat_entry entry ; int entry_size , type ; int err ; dprint ( DBG_CAT_MOD , "rename_cat:<S2SV_blank>%u<S2SV_blank>-<S2SV_blank>%lu,%s<S2SV_blank>-<S2SV_blank>%lu,%s\\n" , cnid , src_dir -> i_ino , src_name -> name , dst_dir -> i_ino , dst_name -> name ) ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & src_fd ) ; if ( err ) return err ; dst_fd = src_fd ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; <S2SV_StartBug> hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , <S2SV_EndBug> src_fd . entrylength ) ; hfsplus_cat_build_key ( sb , dst_fd . search_key , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , src_fd . entrylength ) ; if ( err ) goto out ; dst_dir -> i_size ++ ; dst_dir -> i_mtime = dst_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; src_dir -> i_size -- ; src_dir -> i_mtime = src_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , cnid , NULL ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; type = hfs_bnode_read_u16 ( src_fd . bnode , src_fd . entryoffset ) ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; hfsplus_cat_build_key ( sb , dst_fd . search_key , cnid , NULL ) ; entry_size = hfsplus_fill_cat_thread ( sb , & entry , type , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , entry_size ) ; hfsplus_mark_inode_dirty ( dst_dir , HFSPLUS_I_CAT_DIRTY ) ; hfsplus_mark_inode_dirty ( src_dir , HFSPLUS_I_CAT_DIRTY ) ; out : hfs_bnode_put ( dst_fd . bnode ) ; hfs_find_exit ( & src_fd ) ; return err ; }
CWE-000 static void vrrp_tfile_end_handler ( void ) { vrrp_tracked_file_t * tfile = LIST_TAIL_DATA ( vrrp_data -> vrrp_track_files ) ; struct stat statb ; FILE * tf ; int ret ; if ( ! tfile -> file_path ) { report_config_error ( CONFIG_GENERAL_ERROR , "No<S2SV_blank>file<S2SV_blank>set<S2SV_blank>for<S2SV_blank>track_file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>removing" , tfile -> fname ) ; free_list_element ( vrrp_data -> vrrp_track_files , vrrp_data -> vrrp_track_files -> tail ) ; return ; } if ( track_file_init == TRACK_FILE_NO_INIT ) return ; ret = stat ( tfile -> file_path , & statb ) ; if ( ! ret ) { if ( track_file_init == TRACK_FILE_CREATE ) { return ; } if ( ( statb . st_mode & S_IFMT ) != S_IFREG ) { report_config_error ( CONFIG_GENERAL_ERROR , "Cannot<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>it<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file" , tfile -> fname ) ; return ; } if ( reload ) return ; } if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { <S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , "w" ) ) ) { <S2SV_EndBug> fprintf ( tf , "%d\\n" , track_file_init_value ) ; fclose ( tf ) ; } else report_config_error ( CONFIG_GENERAL_ERROR , "Unable<S2SV_blank>to<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s" , tfile -> fname ) ; } }
CWE-476 long keyctl_update_key ( key_serial_t id , const void __user * _payload , size_t plen ) { key_ref_t key_ref ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > PAGE_SIZE ) goto error ; payload = NULL ; <S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ret = - ENOMEM ; payload = kmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error2 ; } key_ref = lookup_user_key ( id , 0 , KEY_NEED_WRITE ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error2 ; } ret = key_update ( key_ref , payload , plen ) ; key_ref_put ( key_ref ) ; error2 : kfree ( payload ) ; error : return ret ; }
CWE-284 int tcp_v4_rcv ( struct sk_buff * skb ) { struct net * net = dev_net ( skb -> dev ) ; const struct iphdr * iph ; const struct tcphdr * th ; bool refcounted ; struct sock * sk ; int ret ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; __TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ; if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ; th = ( const struct tcphdr * ) skb -> data ; if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ; if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ; if ( skb_checksum_init ( skb , IPPROTO_TCP , inet_compute_pseudo ) ) goto csum_error ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb ) ; memmove ( & TCP_SKB_CB ( skb ) -> header . h4 , IPCB ( skb ) , sizeof ( struct inet_skb_parm ) ) ; barrier ( ) ; TCP_SKB_CB ( skb ) -> seq = ntohl ( th -> seq ) ; TCP_SKB_CB ( skb ) -> end_seq = ( TCP_SKB_CB ( skb ) -> seq + th -> syn + th -> fin + skb -> len - th -> doff * 4 ) ; TCP_SKB_CB ( skb ) -> ack_seq = ntohl ( th -> ack_seq ) ; TCP_SKB_CB ( skb ) -> tcp_flags = tcp_flag_byte ( th ) ; TCP_SKB_CB ( skb ) -> tcp_tw_isn = 0 ; TCP_SKB_CB ( skb ) -> ip_dsfield = ipv4_get_dsfield ( iph ) ; TCP_SKB_CB ( skb ) -> sacked = 0 ; lookup : sk = __inet_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , & refcounted ) ; if ( ! sk ) goto no_tcp_socket ; process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ; if ( sk -> sk_state == TCP_NEW_SYN_RECV ) { struct request_sock * req = inet_reqsk ( sk ) ; struct sock * nsk ; sk = req -> rsk_listener ; if ( unlikely ( tcp_v4_inbound_md5_hash ( sk , skb ) ) ) { sk_drops_add ( sk , skb ) ; reqsk_put ( req ) ; goto discard_it ; } if ( unlikely ( sk -> sk_state != TCP_LISTEN ) ) { inet_csk_reqsk_queue_drop_and_put ( sk , req ) ; goto lookup ; } sock_hold ( sk ) ; refcounted = true ; nsk = tcp_check_req ( sk , skb , req , false ) ; if ( ! nsk ) { reqsk_put ( req ) ; goto discard_and_relse ; } if ( nsk == sk ) { reqsk_put ( req ) ; } else if ( tcp_child_process ( sk , nsk , skb ) ) { tcp_v4_send_reset ( nsk , skb ) ; goto discard_and_relse ; } else { sock_put ( sk ) ; return 0 ; } } if ( unlikely ( iph -> ttl < inet_sk ( sk ) -> min_ttl ) ) { __NET_INC_STATS ( net , LINUX_MIB_TCPMINTTLDROP ) ; goto discard_and_relse ; } if ( ! xfrm4_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto discard_and_relse ; if ( tcp_v4_inbound_md5_hash ( sk , skb ) ) goto discard_and_relse ; nf_reset ( skb ) ; <S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> skb -> dev = NULL ; if ( sk -> sk_state == TCP_LISTEN ) { ret = tcp_v4_do_rcv ( sk , skb ) ; goto put_and_return ; } sk_incoming_cpu_update ( sk ) ; bh_lock_sock_nested ( sk ) ; tcp_segs_in ( tcp_sk ( sk ) , skb ) ; ret = 0 ; if ( ! sock_owned_by_user ( sk ) ) { if ( ! tcp_prequeue ( sk , skb ) ) ret = tcp_v4_do_rcv ( sk , skb ) ; } else if ( tcp_add_backlog ( sk , skb ) ) { goto discard_and_relse ; } bh_unlock_sock ( sk ) ; put_and_return : if ( refcounted ) sock_put ( sk ) ; return ret ; no_tcp_socket : if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) goto discard_it ; if ( tcp_checksum_complete ( skb ) ) { csum_error : __TCP_INC_STATS ( net , TCP_MIB_CSUMERRORS ) ; bad_packet : __TCP_INC_STATS ( net , TCP_MIB_INERRS ) ; } else { tcp_v4_send_reset ( NULL , skb ) ; } discard_it : kfree_skb ( skb ) ; return 0 ; discard_and_relse : sk_drops_add ( sk , skb ) ; if ( refcounted ) sock_put ( sk ) ; goto discard_it ; do_time_wait : if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto discard_it ; } if ( tcp_checksum_complete ( skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto csum_error ; } switch ( tcp_timewait_state_process ( inet_twsk ( sk ) , skb , th ) ) { case TCP_TW_SYN : { struct sock * sk2 = inet_lookup_listener ( dev_net ( skb -> dev ) , & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , iph -> saddr , th -> source , iph -> daddr , th -> dest , inet_iif ( skb ) ) ; if ( sk2 ) { inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; sk = sk2 ; refcounted = false ; goto process ; } } case TCP_TW_ACK : tcp_v4_timewait_ack ( sk , skb ) ; break ; case TCP_TW_RST : tcp_v4_send_reset ( sk , skb ) ; inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; goto discard_it ; case TCP_TW_SUCCESS : ; } goto discard_it ; }
CWE-190 static int growOpArray ( Vdbe * v , int nOp ) { VdbeOp * pNew ; Parse * p = v -> pParse ; # ifdef SQLITE_TEST_REALLOC_STRESS <S2SV_StartBug> int nNew = ( v -> nOpAlloc >= 512 ? v -> nOpAlloc * 2 : v -> nOpAlloc + nOp ) ; <S2SV_EndBug> # else <S2SV_StartBug> int nNew = ( v -> nOpAlloc ? v -> nOpAlloc * 2 : ( int ) ( 1024 / sizeof ( Op ) ) ) ; <S2SV_EndBug> UNUSED_PARAMETER ( nOp ) ; # endif if ( nNew > p -> db -> aLimit [ SQLITE_LIMIT_VDBE_OP ] ) { sqlite3OomFault ( p -> db ) ; return SQLITE_NOMEM ; } assert ( nOp <= ( 1024 / sizeof ( Op ) ) ) ; assert ( nNew >= ( v -> nOpAlloc + nOp ) ) ; pNew = sqlite3DbRealloc ( p -> db , v -> aOp , nNew * sizeof ( Op ) ) ; if ( pNew ) { p -> szOpAlloc = sqlite3DbMallocSize ( p -> db , pNew ) ; v -> nOpAlloc = p -> szOpAlloc / sizeof ( Op ) ; v -> aOp = pNew ; } return ( pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT ) ; }
CWE-119 void pid_ns_release_proc ( struct pid_namespace * ns ) { <S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug> }
CWE-000 int sas_ex_revalidate_domain ( struct domain_device * port_dev ) { int res ; struct domain_device * dev = NULL ; res = sas_find_bcast_dev ( port_dev , & dev ) ; <S2SV_StartBug> while ( res == 0 && dev ) { <S2SV_EndBug> struct expander_device * ex = & dev -> ex_dev ; int i = 0 , phy_id ; do { phy_id = - 1 ; res = sas_find_bcast_phy ( dev , & phy_id , i , true ) ; if ( phy_id == - 1 ) break ; res = sas_rediscover ( dev , phy_id ) ; i = phy_id + 1 ; } while ( i < ex -> num_phys ) ; <S2SV_StartBug> dev = NULL ; <S2SV_EndBug> res = sas_find_bcast_dev ( port_dev , & dev ) ; } return res ; }
CWE-264 void dev_load ( struct net * net , const char * name ) { struct net_device * dev ; <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> dev = dev_get_by_name_rcu ( net , name ) ; rcu_read_unlock ( ) ; <S2SV_StartBug> if ( ! dev && capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> request_module ( "%s" , name ) ; <S2SV_EndBug> }
CWE-264 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! arp_checkentry ( & e -> arp ) ) return - EINVAL ; <S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-200 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { bool disconnect ; p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , MS_PRIVATE ) ; } }
CWE-20 long keyctl_chown_key ( key_serial_t id , uid_t user , gid_t group ) { struct key_user * newowner , * zapowner = NULL ; struct key * key ; key_ref_t key_ref ; long ret ; kuid_t uid ; kgid_t gid ; uid = make_kuid ( current_user_ns ( ) , user ) ; gid = make_kgid ( current_user_ns ( ) , group ) ; ret = - EINVAL ; if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ; if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ; ret = 0 ; if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ; key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = - EACCES ; down_write ( & key -> sem ) ; if ( ! capable ( CAP_SYS_ADMIN ) ) { if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ; if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ; } if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) { ret = - ENOMEM ; newowner = key_user_lookup ( uid ) ; if ( ! newowner ) goto error_put ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & newowner -> lock ) ; if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ; newowner -> qnkeys ++ ; newowner -> qnbytes += key -> quotalen ; spin_unlock ( & newowner -> lock ) ; spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; atomic_inc ( & newowner -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; atomic_inc ( & newowner -> nikeys ) ; } zapowner = key -> user ; key -> user = newowner ; key -> uid = uid ; } if ( group != ( gid_t ) - 1 ) key -> gid = gid ; ret = 0 ; error_put : up_write ( & key -> sem ) ; key_put ( key ) ; if ( zapowner ) key_user_put ( zapowner ) ; error : return ret ; quota_overrun : spin_unlock ( & newowner -> lock ) ; zapowner = newowner ; ret = - EDQUOT ; goto error_put ; }
CWE-119 void vpx_free ( void * memblk ) { if ( memblk ) { void * addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ; <S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> hmm_free ( & hmm_d , addr ) ; # else VPX_FREE_L ( addr ) ; <S2SV_StartBug> # endif <S2SV_EndBug> } }
CWE-119 static int su3000_power_ctrl ( struct dvb_usb_device * d , int i ) { struct dw2102_state * state = ( struct dw2102_state * ) d -> priv ; <S2SV_StartBug> u8 obuf [ ] = { 0xde , 0 } ; <S2SV_EndBug> info ( "%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d" , __func__ , i , state -> initialized ) ; if ( i && ! state -> initialized ) { <S2SV_StartBug> state -> initialized = 1 ; <S2SV_EndBug> <S2SV_StartBug> return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
CWE-362 static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; <S2SV_StartBug> struct address_space * mapping = inode -> i_mapping ; <S2SV_EndBug> unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } <S2SV_StartBug> if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { <S2SV_EndBug> ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex ; } if ( max_blocks > 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ; <S2SV_StartBug> truncate_pagecache_range ( inode , start , end - 1 ) ; <S2SV_EndBug> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , <S2SV_StartBug> flags , mode ) ; <S2SV_EndBug> if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
CWE-190 void nw_cache_free ( nw_cache * cache , void * obj ) { if ( cache -> free < cache -> free_total ) { cache -> free_arr [ cache -> free ++ ] = obj ; <S2SV_StartBug> } else { <S2SV_EndBug> uint32_t new_free_total = cache -> free_total * 2 ; void * new_arr = realloc ( cache -> free_arr , new_free_total * sizeof ( void * ) ) ; if ( new_arr ) { cache -> free_total = new_free_total ; cache -> free_arr = new_arr ; cache -> free_arr [ cache -> free ++ ] = obj ; } else { free ( obj ) ; } <S2SV_StartBug> } <S2SV_EndBug> }
CWE-000 static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ; <S2SV_StartBug> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <S2SV_EndBug> & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }
CWE-119 int <S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> { struct vendor_attribute * attr ; <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> * data = attr -> attrib_data ; * len = attr -> attrib_len - 2 ; <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> }
CWE-000 static int store_asoundrc ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_ASOUNDRC_FILE ; FILE * fp = fopen ( dest , "w" ) ; if ( fp ) { fprintf ( fp , "\\n" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0644 ) ; fclose ( fp ) ; } if ( asprintf ( & src , "%s/.asoundrc" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) { fprintf ( stderr , "Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\n" , src ) ; exit ( 1 ) ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { fprintf ( stderr , "Error:<S2SV_blank>.asoundrc<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file<S2SV_blank>outside<S2SV_blank>home<S2SV_blank>directory\\n" ) ; exit ( 1 ) ; } free ( rp ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; <S2SV_StartBug> if ( rv ) <S2SV_EndBug> fprintf ( stderr , "Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n" ) ; else { <S2SV_StartBug> fs_logger2 ( "clone" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; return 1 ; } return 0 ; }
CWE-000 static void setup_remaining_vcs ( int src_fd , unsigned src_idx , bool utf8 ) { struct console_font_op cfo = { . op = KD_FONT_OP_GET , . width = UINT_MAX , . height = UINT_MAX , . charcount = UINT_MAX , } ; struct unimapinit adv = { } ; struct unimapdesc unimapd ; _cleanup_free_ struct unipair * unipairs = NULL ; _cleanup_free_ void * fontbuf = NULL ; unsigned i ; int r ; unipairs = new ( struct unipair , USHRT_MAX ) ; if ( ! unipairs ) { log_oom ( ) ; return ; } r = ioctl ( src_fd , KDFONTOP , & cfo ) ; if ( r < 0 ) log_warning_errno ( errno , "KD_FONT_OP_GET<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>font<S2SV_blank>metadata:<S2SV_blank>%m" ) ; else { if ( cfo . width > 32 || cfo . height > 32 || cfo . charcount > 512 ) log_warning ( "Invalid<S2SV_blank>font<S2SV_blank>metadata<S2SV_blank>-<S2SV_blank>width:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>32),<S2SV_blank>height:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>32),<S2SV_blank>count:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>512)" , cfo . width , cfo . height , cfo . charcount ) ; else { fontbuf = malloc_multiply ( ( cfo . width + 7 ) / 8 * 32 , cfo . charcount ) ; if ( ! fontbuf ) { log_oom ( ) ; return ; } cfo . data = fontbuf ; r = ioctl ( src_fd , KDFONTOP , & cfo ) ; if ( r < 0 ) log_warning_errno ( errno , "KD_FONT_OP_GET<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>font<S2SV_blank>data:<S2SV_blank>%m" ) ; else { unimapd . entries = unipairs ; unimapd . entry_ct = USHRT_MAX ; r = ioctl ( src_fd , GIO_UNIMAP , & unimapd ) ; if ( r < 0 ) log_warning_errno ( errno , "GIO_UNIMAP<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>read<S2SV_blank>unicode<S2SV_blank>mappings:<S2SV_blank>%m" ) ; else cfo . op = KD_FONT_OP_SET ; } } } if ( cfo . op != KD_FONT_OP_SET ) log_warning ( "Fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>remaining<S2SV_blank>consoles" ) ; for ( i = 1 ; i <= 63 ; i ++ ) { char ttyname [ sizeof ( "/dev/tty63" ) ] ; _cleanup_close_ int fd_d = - 1 ; if ( i == src_idx || verify_vc_allocation ( i ) < 0 ) continue ; xsprintf ( ttyname , "/dev/tty%u" , i ) ; fd_d = open_terminal ( ttyname , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd_d < 0 ) { log_warning_errno ( fd_d , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>tty%u,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied:<S2SV_blank>%m" , i ) ; continue ; } <S2SV_StartBug> if ( verify_vc_kbmode ( fd_d ) < 0 ) <S2SV_EndBug> continue ; toggle_utf8 ( ttyname , fd_d , utf8 ) ; if ( cfo . op != KD_FONT_OP_SET ) continue ; r = ioctl ( fd_d , KDFONTOP , & cfo ) ; if ( r < 0 ) { int last_errno , mode ; last_errno = errno ; if ( ioctl ( fd_d , KDGETMODE , & mode ) >= 0 && mode != KD_TEXT ) log_debug ( "KD_FONT_OP_SET<S2SV_blank>skipped:<S2SV_blank>tty%u<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>text<S2SV_blank>mode" , i ) ; else log_warning_errno ( last_errno , "KD_FONT_OP_SET<S2SV_blank>failed,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } r = ioctl ( fd_d , PIO_UNIMAPCLR , & adv ) ; if ( r < 0 ) { log_warning_errno ( errno , "PIO_UNIMAPCLR<S2SV_blank>failed,<S2SV_blank>unimaps<S2SV_blank>might<S2SV_blank>be<S2SV_blank>incorrect<S2SV_blank>for<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } r = ioctl ( fd_d , PIO_UNIMAP , & unimapd ) ; if ( r < 0 ) { log_warning_errno ( errno , "PIO_UNIMAP<S2SV_blank>failed,<S2SV_blank>unimaps<S2SV_blank>might<S2SV_blank>be<S2SV_blank>incorrect<S2SV_blank>for<S2SV_blank>tty%u:<S2SV_blank>%m" , i ) ; continue ; } log_debug ( "Font<S2SV_blank>and<S2SV_blank>unimap<S2SV_blank>successfully<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>%s" , ttyname ) ; } }
CWE-476 static int mailimf_group_parse ( const char * message , size_t length , size_t * indx , struct mailimf_group * * result ) { size_t cur_token ; char * display_name ; struct mailimf_mailbox_list * mailbox_list ; struct mailimf_group * group ; int r ; int res ; <S2SV_StartBug> cur_token = * indx ; <S2SV_EndBug> mailbox_list = NULL ; r = mailimf_display_name_parse ( message , length , & cur_token , & display_name ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto err ; } r = mailimf_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_display_name ; } r = mailimf_mailbox_list_parse ( message , length , & cur_token , & mailbox_list ) ; switch ( r ) { case MAILIMF_NO_ERROR : break ; case MAILIMF_ERROR_PARSE : r = mailimf_cfws_parse ( message , length , & cur_token ) ; if ( ( r != MAILIMF_NO_ERROR ) && ( r != MAILIMF_ERROR_PARSE ) ) { <S2SV_StartBug> res = r ; <S2SV_EndBug> goto free_display_name ; } break ; default : res = r ; goto free_display_name ; } r = mailimf_semi_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_mailbox_list ; } group = mailimf_group_new ( display_name , mailbox_list ) ; if ( group == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_mailbox_list ; } * indx = cur_token ; * result = group ; return MAILIMF_NO_ERROR ; free_mailbox_list : if ( mailbox_list != NULL ) { mailimf_mailbox_list_free ( mailbox_list ) ; } free_display_name : mailimf_display_name_free ( display_name ) ; err : return res ; }
CWE-119 void vp8_create_common ( VP8_COMMON * oci ) { vp8_machine_specific_config ( oci ) ; vp8_init_mbmode_probs ( oci ) ; vp8_default_bmode_probs ( oci -> fc . bmode_prob ) ; oci -> mb_no_coeff_skip = 1 ; oci -> no_lpf = 0 ; oci -> filter_type = NORMAL_LOOPFILTER ; oci -> use_bilinear_mc_filter = 0 ; oci -> full_pixel = 0 ; oci -> multi_token_partition = ONE_PARTITION ; oci -> clamp_type = RECON_CLAMP_REQUIRED ; <S2SV_StartBug> vpx_memset ( oci -> ref_frame_sign_bias , 0 , sizeof ( oci -> ref_frame_sign_bias ) ) ; <S2SV_EndBug> oci -> copy_buffer_to_gf = 0 ; oci -> copy_buffer_to_arf = 0 ; }
CWE-119 char * _single_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( len + 1 ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; return chr ; }
CWE-787 <S2SV_StartBug> void nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) <S2SV_EndBug> { <S2SV_StartBug> nsc_encode_argb_to_aycocg ( context , bmpdata , rowstride ) ; <S2SV_EndBug> if ( context -> ChromaSubsamplingLevel ) { <S2SV_StartBug> nsc_encode_subsampling ( context ) ; <S2SV_EndBug> } }
CWE-362 static int snd_ctl_elem_user_put ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { int change ; <S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ; if ( change ) memcpy ( ue -> elem_data , & ucontrol -> value , ue -> elem_data_size ) ; <S2SV_StartBug> return change ; <S2SV_EndBug> }
CWE-190 static int choose_volume ( struct archive_read * a , struct iso9660 * iso9660 ) { struct file_info * file ; int64_t skipsize ; struct vd * vd ; const void * block ; char seenJoliet ; vd = & ( iso9660 -> primary ) ; if ( ! iso9660 -> opt_support_joliet ) iso9660 -> seenJoliet = 0 ; if ( iso9660 -> seenJoliet && vd -> location > iso9660 -> joliet . location ) vd = & ( iso9660 -> joliet ) ; <S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position = skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>full<S2SV_blank>block<S2SV_blank>when<S2SV_blank>scanning<S2SV_blank>" "ISO9660<S2SV_blank>directory<S2SV_blank>list" ) ; return ( ARCHIVE_FATAL ) ; } seenJoliet = iso9660 -> seenJoliet ; iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; if ( vd == & ( iso9660 -> primary ) && iso9660 -> seenRockridge && iso9660 -> seenJoliet ) iso9660 -> seenJoliet = 0 ; if ( vd == & ( iso9660 -> primary ) && ! iso9660 -> seenRockridge && iso9660 -> seenJoliet ) { vd = & ( iso9660 -> joliet ) ; <S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> skipsize -= iso9660 -> current_position ; skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position += skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>full<S2SV_blank>block<S2SV_blank>when<S2SV_blank>scanning<S2SV_blank>" "ISO9660<S2SV_blank>directory<S2SV_blank>list" ) ; return ( ARCHIVE_FATAL ) ; } iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; } if ( add_entry ( a , iso9660 , file ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ; if ( iso9660 -> seenRockridge ) { a -> archive . archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE ; a -> archive . archive_format_name = "ISO9660<S2SV_blank>with<S2SV_blank>Rockridge<S2SV_blank>extensions" ; } return ( ARCHIVE_OK ) ; }
CWE-200 void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } <S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> return data > max ? max : data ; }
CWE-119 int nfs3svc_decode_symlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_symlinkargs * args ) { unsigned int len , avail ; char * old , * new ; struct kvec * vec ; if ( ! ( p = decode_fh ( p , & args -> ffh ) ) || ! ( p = decode_filename ( p , & args -> fname , & args -> flen ) ) ) return 0 ; p = decode_sattr3 ( p , & args -> attrs ) ; len = ntohl ( * p ++ ) ; if ( len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE ) return 0 ; args -> tname = new = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; args -> tlen = len ; old = ( char * ) p ; vec = & rqstp -> rq_arg . head [ 0 ] ; <S2SV_StartBug> avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ; <S2SV_EndBug> while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } if ( len && ! avail && rqstp -> rq_arg . page_len ) { avail = min_t ( unsigned int , rqstp -> rq_arg . page_len , PAGE_SIZE ) ; old = page_address ( rqstp -> rq_arg . pages [ 0 ] ) ; } while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } * new = '\\0' ; if ( len ) return 0 ; return 1 ; }
CWE-119 static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = "PredictorEncodeTile" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , "Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>allocating<S2SV_blank>" TIFF_SSIZE_FORMAT "<S2SV_blank>byte<S2SV_blank>temp<S2SV_blank>buffer." , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }
CWE-189 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; aligned_height = FFALIGN ( c -> height , 16 ) ; av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { <S2SV_StartBug> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <S2SV_EndBug> aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }
CWE-119 int main ( void ) { <S2SV_StartBug> # line 52 "dt_test2.pgc" <S2SV_EndBug> date date1 ; <S2SV_StartBug> # line 53 "dt_test2.pgc" <S2SV_EndBug> timestamp ts1 , ts2 ; <S2SV_StartBug> # line 54 "dt_test2.pgc" <S2SV_EndBug> char * text ; <S2SV_StartBug> # line 55 "dt_test2.pgc" <S2SV_EndBug> interval * i1 ; <S2SV_StartBug> # line 56 "dt_test2.pgc" <S2SV_EndBug> date * dc ; <S2SV_StartBug> # line 57 "dt_test2.pgc" <S2SV_EndBug> int i , j ; char * endptr ; ECPGdebug ( 1 , stderr ) ; ts1 = PGTYPEStimestamp_from_asc ( "2003-12-04<S2SV_blank>17:34:29" , NULL ) ; text = PGTYPEStimestamp_to_asc ( ts1 ) ; printf ( "timestamp:<S2SV_blank>%s\\n" , text ) ; free ( text ) ; date1 = PGTYPESdate_from_timestamp ( ts1 ) ; dc = PGTYPESdate_new ( ) ; * dc = date1 ; text = PGTYPESdate_to_asc ( * dc ) ; printf ( "Date<S2SV_blank>of<S2SV_blank>timestamp:<S2SV_blank>%s\\n" , text ) ; free ( text ) ; PGTYPESdate_free ( dc ) ; for ( i = 0 ; dates [ i ] ; i ++ ) { bool err = false ; date1 = PGTYPESdate_from_asc ( dates [ i ] , & endptr ) ; if ( date1 == INT_MIN ) { err = true ; } text = PGTYPESdate_to_asc ( date1 ) ; printf ( "Date[%d]:<S2SV_blank>%s<S2SV_blank>(%c<S2SV_blank>-<S2SV_blank>%c)\\n" , i , err ? "-" : text , endptr ? 'N' : 'Y' , err ? 'T' : 'F' ) ; free ( text ) ; if ( ! err ) { for ( j = 0 ; times [ j ] ; j ++ ) { int length = strlen ( dates [ i ] ) + 1 + strlen ( times [ j ] ) + 1 ; char * t = malloc ( length ) ; sprintf ( t , "%s<S2SV_blank>%s" , dates [ i ] , times [ j ] ) ; ts1 = PGTYPEStimestamp_from_asc ( t , NULL ) ; text = PGTYPEStimestamp_to_asc ( ts1 ) ; if ( i != 19 || j != 3 ) printf ( "TS[%d,%d]:<S2SV_blank>%s\\n" , i , j , errno ? "-" : text ) ; free ( text ) ; free ( t ) ; } } } ts1 = PGTYPEStimestamp_from_asc ( "2004-04-04<S2SV_blank>23:23:23" , NULL ) ; for ( i = 0 ; intervals [ i ] ; i ++ ) { interval * ic ; i1 = PGTYPESinterval_from_asc ( intervals [ i ] , & endptr ) ; if ( * endptr ) printf ( "endptr<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s\\n" , endptr ) ; if ( ! i1 ) { printf ( "Error<S2SV_blank>parsing<S2SV_blank>interval<S2SV_blank>%d\\n" , i ) ; continue ; } j = PGTYPEStimestamp_add_interval ( & ts1 , i1 , & ts2 ) ; if ( j < 0 ) continue ; text = PGTYPESinterval_to_asc ( i1 ) ; printf ( "interval[%d]:<S2SV_blank>%s\\n" , i , text ? text : "-" ) ; free ( text ) ; ic = PGTYPESinterval_new ( ) ; PGTYPESinterval_copy ( i1 , ic ) ; text = PGTYPESinterval_to_asc ( i1 ) ; printf ( "interval_copy[%d]:<S2SV_blank>%s\\n" , i , text ? text : "-" ) ; free ( text ) ; PGTYPESinterval_free ( ic ) ; PGTYPESinterval_free ( i1 ) ; } return ( 0 ) ; }
CWE-190 void nw_buf_free ( nw_buf_pool * pool , nw_buf * buf ) { if ( pool -> free < pool -> free_total ) { pool -> free_arr [ pool -> free ++ ] = buf ; <S2SV_StartBug> } else { <S2SV_EndBug> uint32_t new_free_total = pool -> free_total * 2 ; void * new_arr = realloc ( pool -> free_arr , new_free_total * sizeof ( nw_buf * ) ) ; if ( new_arr ) { pool -> free_total = new_free_total ; pool -> free_arr = new_arr ; pool -> free_arr [ pool -> free ++ ] = buf ; } else { free ( buf ) ; } <S2SV_StartBug> } <S2SV_EndBug> }
CWE-200 unsigned paravirt_patch_call ( void * insnbuf , const void * target , u16 tgt_clobbers , unsigned long addr , u16 site_clobbers , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ; <S2SV_StartBug> if ( tgt_clobbers & ~ site_clobbers ) <S2SV_EndBug> return len ; <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> return len ; b -> opcode = 0xe8 ; b -> delta = delta ; BUILD_BUG_ON ( sizeof ( * b ) != 5 ) ; return 5 ; }
CWE-416 void ppp_unregister_channel ( struct ppp_channel * chan ) { struct channel * pch = chan -> ppp ; struct ppp_net * pn ; if ( ! pch ) return ; chan -> ppp = NULL ; down_write ( & pch -> chan_sem ) ; spin_lock_bh ( & pch -> downl ) ; pch -> chan = NULL ; spin_unlock_bh ( & pch -> downl ) ; up_write ( & pch -> chan_sem ) ; ppp_disconnect_channel ( pch ) ; pn = ppp_pernet ( pch -> chan_net ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; list_del ( & pch -> list ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; <S2SV_StartBug> pch -> file . dead = 1 ; <S2SV_EndBug> wake_up_interruptible ( & pch -> file . rwait ) ; if ( atomic_dec_and_test ( & pch -> file . refcnt ) ) ppp_destroy_channel ( pch ) ; }
CWE-000 static struct sk_buff * nf_ct_frag6_reasm ( struct nf_ct_frag6_queue * fq , struct net_device * dev ) { struct sk_buff * fp , * op , * head = fq -> q . fragments ; int payload_len ; fq_kill ( fq ) ; WARN_ON ( head == NULL ) ; WARN_ON ( NFCT_FRAG6_CB ( head ) -> offset != 0 ) ; payload_len = ( ( head -> data - skb_network_header ( head ) ) - sizeof ( struct ipv6hdr ) + fq -> q . len - sizeof ( struct frag_hdr ) ) ; if ( payload_len > IPV6_MAXPLEN ) { pr_debug ( "payload<S2SV_blank>len<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\n" ) ; goto out_oversize ; } if ( skb_cloned ( head ) && pskb_expand_head ( head , 0 , 0 , GFP_ATOMIC ) ) { pr_debug ( "skb<S2SV_blank>is<S2SV_blank>cloned<S2SV_blank>but<S2SV_blank>can\'t<S2SV_blank>expand<S2SV_blank>head" ) ; goto out_oom ; } if ( skb_has_frags ( head ) ) { struct sk_buff * clone ; int i , plen = 0 ; if ( ( clone = alloc_skb ( 0 , GFP_ATOMIC ) ) == NULL ) { pr_debug ( "Can\'t<S2SV_blank>alloc<S2SV_blank>skb\\n" ) ; goto out_oom ; } clone -> next = head -> next ; head -> next = clone ; skb_shinfo ( clone ) -> frag_list = skb_shinfo ( head ) -> frag_list ; skb_frag_list_init ( head ) ; for ( i = 0 ; i < skb_shinfo ( head ) -> nr_frags ; i ++ ) plen += skb_shinfo ( head ) -> frags [ i ] . size ; clone -> len = clone -> data_len = head -> data_len - plen ; head -> data_len -= clone -> len ; head -> len -= clone -> len ; clone -> csum = 0 ; clone -> ip_summed = head -> ip_summed ; NFCT_FRAG6_CB ( clone ) -> orig = NULL ; atomic_add ( clone -> truesize , & nf_init_frags . mem ) ; } skb_network_header ( head ) [ fq -> nhoffset ] = skb_transport_header ( head ) [ 0 ] ; memmove ( head -> head + sizeof ( struct frag_hdr ) , head -> head , ( head -> data - head -> head ) - sizeof ( struct frag_hdr ) ) ; head -> mac_header += sizeof ( struct frag_hdr ) ; head -> network_header += sizeof ( struct frag_hdr ) ; skb_shinfo ( head ) -> frag_list = head -> next ; skb_reset_transport_header ( head ) ; skb_push ( head , head -> data - skb_network_header ( head ) ) ; atomic_sub ( head -> truesize , & nf_init_frags . mem ) ; for ( fp = head -> next ; fp ; fp = fp -> next ) { head -> data_len += fp -> len ; head -> len += fp -> len ; if ( head -> ip_summed != fp -> ip_summed ) head -> ip_summed = CHECKSUM_NONE ; else if ( head -> ip_summed == CHECKSUM_COMPLETE ) head -> csum = csum_add ( head -> csum , fp -> csum ) ; head -> truesize += fp -> truesize ; atomic_sub ( fp -> truesize , & nf_init_frags . mem ) ; } head -> next = NULL ; head -> dev = dev ; head -> tstamp = fq -> q . stamp ; ipv6_hdr ( head ) -> payload_len = htons ( payload_len ) ; if ( head -> ip_summed == CHECKSUM_COMPLETE ) head -> csum = csum_partial ( skb_network_header ( head ) , skb_network_header_len ( head ) , head -> csum ) ; fq -> q . fragments = NULL ; fp = skb_shinfo ( head ) -> frag_list ; <S2SV_StartBug> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) <S2SV_EndBug> fp = fp -> next ; op = NFCT_FRAG6_CB ( head ) -> orig ; for ( ; fp ; fp = fp -> next ) { struct sk_buff * orig = NFCT_FRAG6_CB ( fp ) -> orig ; op -> next = orig ; op = orig ; NFCT_FRAG6_CB ( fp ) -> orig = NULL ; } return head ; out_oversize : if ( net_ratelimit ( ) ) printk ( KERN_DEBUG "nf_ct_frag6_reasm:<S2SV_blank>payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%d\\n" , payload_len ) ; goto out_fail ; out_oom : if ( net_ratelimit ( ) ) printk ( KERN_DEBUG "nf_ct_frag6_reasm:<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>reassembly\\n" ) ; out_fail : return NULL ; }
CWE-119 void vp8_default_coef_probs ( VP8_COMMON * pc ) { <S2SV_StartBug> vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs , <S2SV_EndBug> sizeof ( default_coef_probs ) ) ; }
CWE-125 static int matchCurrentInput ( const InString * input , int pos , const widechar * passInstructions , int passIC ) { int k ; int kk = pos ; <S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ; return 1 ; }
CWE-119 <S2SV_StartBug> void generate_filename ( const char * pattern , char * out , size_t q_len , <S2SV_EndBug> unsigned int d_w , unsigned int d_h , unsigned int frame_in ) { const char * p = pattern ; char * q = out ; do { char * next_pat = strchr ( p , '%' ) ; if ( p == next_pat ) { size_t pat_len ; q [ q_len - 1 ] = '\\0' ; switch ( p [ 1 ] ) { case 'w' : snprintf ( q , q_len - 1 , "%d" , d_w ) ; break ; case 'h' : snprintf ( q , q_len - 1 , "%d" , d_h ) ; break ; case '1' : snprintf ( q , q_len - 1 , "%d" , frame_in ) ; break ; case '2' : snprintf ( q , q_len - 1 , "%02d" , frame_in ) ; break ; case '3' : snprintf ( q , q_len - 1 , "%03d" , frame_in ) ; break ; case '4' : snprintf ( q , q_len - 1 , "%04d" , frame_in ) ; break ; case '5' : snprintf ( q , q_len - 1 , "%05d" , frame_in ) ; break ; case '6' : snprintf ( q , q_len - 1 , "%06d" , frame_in ) ; break ; case '7' : snprintf ( q , q_len - 1 , "%07d" , frame_in ) ; break ; case '8' : snprintf ( q , q_len - 1 , "%08d" , frame_in ) ; break ; case '9' : snprintf ( q , q_len - 1 , "%09d" , frame_in ) ; break ; default : die ( "Unrecognized<S2SV_blank>pattern<S2SV_blank>%%%c\\n" , p [ 1 ] ) ; <S2SV_StartBug> } <S2SV_EndBug> pat_len = strlen ( q ) ; if ( pat_len >= q_len - 1 ) die ( "Output<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long.\\n" ) ; q += pat_len ; p += 2 ; q_len -= pat_len ; } else { size_t copy_len ; if ( ! next_pat ) copy_len = strlen ( p ) ; else copy_len = next_pat - p ; if ( copy_len >= q_len - 1 ) die ( "Output<S2SV_blank>filename<S2SV_blank>too<S2SV_blank>long.\\n" ) ; memcpy ( q , p , copy_len ) ; q [ copy_len ] = '\\0' ; q += copy_len ; p += copy_len ; q_len -= copy_len ; } } while ( * p ) ; }
CWE-399 int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = VFS_I ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; struct xfs_dquot * udqp = NULL , * gdqp = NULL ; struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { uint qflags = 0 ; if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { uid = iattr -> ia_uid ; qflags |= XFS_QMOPT_UQUOTA ; } else { uid = inode -> i_uid ; } if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { gid = iattr -> ia_gid ; qflags |= XFS_QMOPT_GQUOTA ; } else { gid = inode -> i_gid ; } ASSERT ( udqp == NULL ) ; ASSERT ( gdqp == NULL ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , NULL ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 , 0 , & tp ) ; if ( error ) goto out_dqrele ; xfs_ilock ( ip , XFS_ILOCK_EXCL ) ; xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & ( ATTR_UID | ATTR_GID ) ) { iuid = inode -> i_uid ; igid = inode -> i_gid ; gid = ( mask & ATTR_GID ) ? iattr -> ia_gid : igid ; uid = ( mask & ATTR_UID ) ? iattr -> ia_uid : iuid ; if ( XFS_IS_QUOTA_RUNNING ( mp ) && ( ( XFS_IS_UQUOTA_ON ( mp ) && ! uid_eq ( iuid , uid ) ) || ( XFS_IS_GQUOTA_ON ( mp ) && ! gid_eq ( igid , gid ) ) ) ) { ASSERT ( tp ) ; error = xfs_qm_vop_chown_reserve ( tp , ip , udqp , gdqp , NULL , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( error ) goto out_cancel ; } } if ( mask & ( ATTR_UID | ATTR_GID ) ) { if ( ( inode -> i_mode & ( S_ISUID | S_ISGID ) ) && ! capable ( CAP_FSETID ) ) inode -> i_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( ! uid_eq ( iuid , uid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_UQUOTA_ON ( mp ) ) { ASSERT ( mask & ATTR_UID ) ; ASSERT ( udqp ) ; olddquot1 = xfs_qm_vop_chown ( tp , ip , & ip -> i_udquot , udqp ) ; } ip -> i_d . di_uid = xfs_kuid_to_uid ( uid ) ; inode -> i_uid = uid ; } if ( ! gid_eq ( igid , gid ) ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_GQUOTA_ON ( mp ) ) { ASSERT ( xfs_sb_version_has_pquotino ( & mp -> m_sb ) || ! XFS_IS_PQUOTA_ON ( mp ) ) ; ASSERT ( mask & ATTR_GID ) ; ASSERT ( gdqp ) ; olddquot2 = xfs_qm_vop_chown ( tp , ip , & ip -> i_gdquot , gdqp ) ; } ip -> i_d . di_gid = xfs_kgid_to_gid ( gid ) ; inode -> i_gid = gid ; } } if ( mask & ATTR_MODE ) xfs_setattr_mode ( ip , iattr ) ; if ( mask & ( ATTR_ATIME | ATTR_CTIME | ATTR_MTIME ) ) xfs_setattr_time ( ip , iattr ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( mp , xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; error = xfs_trans_commit ( tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; xfs_qm_dqrele ( olddquot1 ) ; xfs_qm_dqrele ( olddquot2 ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; if ( error ) return error ; if ( ( mask & ATTR_MODE ) && ! ( flags & XFS_ATTR_NOACL ) ) { error = posix_acl_chmod ( inode , inode -> i_mode ) ; if ( error ) return error ; } return 0 ; out_cancel : xfs_trans_cancel ( tp ) ; <S2SV_StartBug> out_dqrele : <S2SV_EndBug> xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( gdqp ) ; return error ; }
CWE-362 static int snd_timer_user_open ( struct inode * inode , struct file * file ) { struct snd_timer_user * tu ; int err ; err = nonseekable_open ( inode , file ) ; if ( err < 0 ) return err ; tu = kzalloc ( sizeof ( * tu ) , GFP_KERNEL ) ; if ( tu == NULL ) return - ENOMEM ; spin_lock_init ( & tu -> qlock ) ; init_waitqueue_head ( & tu -> qchange_sleep ) ; <S2SV_StartBug> mutex_init ( & tu -> tread_sem ) ; <S2SV_EndBug> tu -> ticks = 1 ; tu -> queue_size = 128 ; tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) { kfree ( tu ) ; return - ENOMEM ; } file -> private_data = tu ; return 0 ; }
CWE-415 void gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { <S2SV_StartBug> int x , y , pos ; <S2SV_EndBug> Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>WBMP" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { <S2SV_StartBug> if ( gdImageGetPixel ( image , x , y ) == fg ) { <S2SV_EndBug> wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( "Could<S2SV_blank>not<S2SV_blank>save<S2SV_blank>WBMP" ) ; } freewbmp ( wbmp ) ; }
CWE-000 void vp8_decoder_remove_threads ( VP8D_COMP * pbi ) { if ( pbi -> b_multithreaded_rd ) { int i ; pbi -> b_multithreaded_rd = 0 ; <S2SV_StartBug> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) <S2SV_EndBug> { sem_post ( & pbi -> h_event_start_decoding [ i ] ) ; pthread_join ( pbi -> h_decoding_thread [ i ] , NULL ) ; } <S2SV_StartBug> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) <S2SV_EndBug> { sem_destroy ( & pbi -> h_event_start_decoding [ i ] ) ; } sem_destroy ( & pbi -> h_event_end_decoding ) ; vpx_free ( pbi -> h_decoding_thread ) ; pbi -> h_decoding_thread = NULL ; vpx_free ( pbi -> h_event_start_decoding ) ; pbi -> h_event_start_decoding = NULL ; vpx_free ( pbi -> mb_row_di ) ; pbi -> mb_row_di = NULL ; vpx_free ( pbi -> de_thread_data ) ; pbi -> de_thread_data = NULL ; <S2SV_StartBug> } <S2SV_EndBug> }
CWE-20 static int hci_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; BT_DBG ( "sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; if ( sk -> sk_state == BT_CLOSED ) return 0 ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) return err ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; switch ( hci_pi ( sk ) -> channel ) { case HCI_CHANNEL_RAW : hci_sock_cmsg ( sk , msg , skb ) ; break ; case HCI_CHANNEL_USER : case HCI_CHANNEL_CONTROL : case HCI_CHANNEL_MONITOR : sock_recv_timestamp ( msg , sk , skb ) ; break ; } skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc ( vpx_codec_alg_priv_t * ctx , int ctr_id , <S2SV_EndBug> va_list args ) { int data = va_arg ( args , int ) ; const vpx_codec_enc_cfg_t * cfg = & ctx -> cfg ; vp9_set_svc ( ctx -> cpi , data ) ; if ( data == 1 && <S2SV_StartBug> ( cfg -> rc_end_usage == VPX_CBR || <S2SV_EndBug> cfg -> g_pass == VPX_RC_FIRST_PASS || cfg -> g_pass == VPX_RC_LAST_PASS ) && cfg -> ss_number_layers > 1 && cfg -> ts_number_layers > 1 ) { return VPX_CODEC_INVALID_PARAM ; } return VPX_CODEC_OK ; }
CWE-476 static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end = NULL ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ; <S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> continue ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }
CWE-264 void test_js ( void ) { GString * result = g_string_new ( "" ) ; parse_cmd_line ( "js<S2SV_blank>(\'x\'<S2SV_blank>+<S2SV_blank>345).toUpperCase()" , result ) ; g_assert_cmpstr ( "X345" , == , result -> str ) ; <S2SV_StartBug> uzbl . net . useragent = "Test<S2SV_blank>useragent" ; <S2SV_EndBug> parse_cmd_line ( "js<S2SV_blank>Uzbl.run(\'print<S2SV_blank>@useragent\').toUpperCase();" , result ) ; g_assert_cmpstr ( "TEST<S2SV_blank>USERAGENT" , == , result -> str ) ; g_string_free ( result , TRUE ) ; }
CWE-119 H264SwDecRet H264SwDecInit ( H264SwDecInst * decInst , u32 noOutputReordering ) { u32 rv = 0 ; decContainer_t * pDecCont ; DEC_API_TRC ( "H264SwDecInit#" ) ; if ( ( ( - 1 ) >> 1 ) != ( - 1 ) ) { DEC_API_TRC ( "H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>Right<S2SV_blank>shift<S2SV_blank>is<S2SV_blank>not<S2SV_blank>signed" ) ; return ( H264SWDEC_INITFAIL ) ; } if ( decInst == NULL ) { DEC_API_TRC ( "H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>decInst<S2SV_blank>==<S2SV_blank>NULL" ) ; return ( H264SWDEC_PARAM_ERR ) ; } <S2SV_StartBug> pDecCont = ( decContainer_t * ) H264SwDecMalloc ( sizeof ( decContainer_t ) ) ; <S2SV_EndBug> if ( pDecCont == NULL ) { DEC_API_TRC ( "H264SwDecInit#<S2SV_blank>ERROR:<S2SV_blank>Memory<S2SV_blank>allocation<S2SV_blank>failed" ) ; return ( H264SWDEC_MEMFAIL ) ; } # ifdef H264DEC_TRACE sprintf ( pDecCont -> str , "H264SwDecInit#<S2SV_blank>decInst<S2SV_blank>%p<S2SV_blank>noOutputReordering<S2SV_blank>%d" , ( void * ) decInst , noOutputReordering ) ; DEC_API_TRC ( pDecCont -> str ) ; # endif rv = h264bsdInit ( & pDecCont -> storage , noOutputReordering ) ; if ( rv != HANTRO_OK ) { H264SwDecRelease ( pDecCont ) ; return ( H264SWDEC_MEMFAIL ) ; } pDecCont -> decStat = INITIALIZED ; pDecCont -> picNumber = 0 ; # ifdef H264DEC_TRACE sprintf ( pDecCont -> str , "H264SwDecInit#<S2SV_blank>OK:<S2SV_blank>return<S2SV_blank>%p" , ( void * ) pDecCont ) ; DEC_API_TRC ( pDecCont -> str ) ; # endif * decInst = ( decContainer_t * ) pDecCont ; return ( H264SWDEC_OK ) ; }
CWE-362 static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }
CWE-20 struct sk_buff * __skb_recv_datagram ( struct sock * sk , unsigned int flags , int * peeked , int * off , int * err ) { struct sk_buff * skb ; long timeo ; int error = sock_error ( sk ) ; if ( error ) goto no_packet ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { unsigned long cpu_flags ; struct sk_buff_head * queue = & sk -> sk_receive_queue ; spin_lock_irqsave ( & queue -> lock , cpu_flags ) ; skb_queue_walk ( queue , skb ) { * peeked = skb -> peeked ; if ( flags & MSG_PEEK ) { <S2SV_StartBug> if ( * off >= skb -> len ) { <S2SV_EndBug> * off -= skb -> len ; continue ; } skb -> peeked = 1 ; atomic_inc ( & skb -> users ) ; } else __skb_unlink ( skb , queue ) ; spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; return skb ; } spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; error = - EAGAIN ; if ( ! timeo ) goto no_packet ; } while ( ! wait_for_packet ( sk , err , & timeo ) ) ; return NULL ; no_packet : * err = error ; return NULL ; }
CWE-264 void macvlan_common_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> netdev_ops = & macvlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> header_ops = & macvlan_hard_header_ops , dev -> ethtool_ops = & macvlan_ethtool_ops ; }
CWE-189 static int32 makepol ( QPRS_STATE * state ) { int32 val = 0 , type ; int32 lenval = 0 ; char * strval = NULL ; int32 stack [ STACKDEPTH ] ; int32 lenstack = 0 ; uint16 flag = 0 ; <S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug> { switch ( type ) { case VAL : pushval_asis ( state , VAL , strval , lenval , flag ) ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case OPR : if ( lenstack && val == ( int32 ) '|' ) pushquery ( state , OPR , val , 0 , 0 , 0 ) ; else { if ( lenstack == STACKDEPTH ) elog ( ERROR , "stack<S2SV_blank>too<S2SV_blank>short" ) ; stack [ lenstack ] = val ; lenstack ++ ; } break ; case OPEN : if ( makepol ( state ) == ERR ) return ERR ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case CLOSE : while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; break ; case ERR : default : ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( "syntax<S2SV_blank>error" ) ) ) ; return ERR ; } } while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; }
CWE-284 static void command_timed_out ( UNUSED_ATTR void * context ) { pthread_mutex_lock ( & commands_pending_response_lock ) ; if ( list_is_empty ( commands_pending_response ) ) { LOG_ERROR ( "%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>commands<S2SV_blank>pending<S2SV_blank>response" , __func__ ) ; } else { waiting_command_t * wait_entry = list_front ( commands_pending_response ) ; pthread_mutex_unlock ( & commands_pending_response_lock ) ; LOG_ERROR ( "%s<S2SV_blank>hci<S2SV_blank>layer<S2SV_blank>timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>to<S2SV_blank>a<S2SV_blank>command.<S2SV_blank>opcode:<S2SV_blank>0x%x" , __func__ , wait_entry -> opcode ) ; } LOG_ERROR ( "%s<S2SV_blank>restarting<S2SV_blank>the<S2SV_blank>bluetooth<S2SV_blank>process." , __func__ ) ; <S2SV_StartBug> usleep ( 10000 ) ; <S2SV_EndBug> kill ( getpid ( ) , SIGKILL ) ; }
CWE-200 static int l2tp_ip6_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) uaddr ; struct sock * sk = sock -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct l2tp_ip6_sock * lsk = l2tp_ip6_sk ( sk ) ; lsa -> l2tp_family = AF_INET6 ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ; <S2SV_StartBug> if ( peer ) { <S2SV_EndBug> if ( ! lsk -> peer_conn_id ) return - ENOTCONN ; lsa -> l2tp_conn_id = lsk -> peer_conn_id ; lsa -> l2tp_addr = np -> daddr ; if ( np -> sndflow ) lsa -> l2tp_flowinfo = np -> flow_label ; } else { if ( ipv6_addr_any ( & np -> rcv_saddr ) ) lsa -> l2tp_addr = np -> saddr ; else lsa -> l2tp_addr = np -> rcv_saddr ; lsa -> l2tp_conn_id = lsk -> conn_id ; } if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) lsa -> l2tp_scope_id = sk -> sk_bound_dev_if ; * uaddr_len = sizeof ( * lsa ) ; return 0 ; }
CWE-125 static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , "%s:" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "<S2SV_blank>#%d<S2SV_blank>id=%s<S2SV_blank>" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>#%d<S2SV_blank>id=%d<S2SV_blank>" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { <S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , "..." ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
CWE-119 static int get_prediction_error ( BLOCK * be , BLOCKD * b ) { unsigned char * sptr ; unsigned char * dptr ; sptr = ( * ( be -> base_src ) + be -> src ) ; dptr = b -> predictor ; <S2SV_StartBug> return vp8_get4x4sse_cs ( sptr , be -> src_stride , dptr , 16 ) ; <S2SV_EndBug> }
CWE-264 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) <S2SV_StartBug> size = INT_MAX ; <S2SV_EndBug> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; iov . iov_len = size ; iov . iov_base = ubuf ; iov_iter_init ( & msg . msg_iter , READ , & iov , 1 , size ) ; msg . msg_name = addr ? ( struct sockaddr * ) & address : NULL ; msg . msg_namelen = 0 ; if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }
CWE-119 vpx_codec_err_t vpx_codec_decode ( vpx_codec_ctx_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res ; <S2SV_StartBug> if ( ! ctx || ( ! data && data_sz ) ) <S2SV_EndBug> res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { <S2SV_StartBug> res = ctx -> iface -> dec . decode ( ctx -> priv -> alg_priv , data , data_sz , <S2SV_EndBug> user_priv , deadline ) ; } return SAVE_STATUS ( ctx , res ) ; }
CWE-399 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
CWE-416 static void sig_server_setup_fill_chatnet ( IRC_SERVER_CONNECT_REC * conn , IRC_CHATNET_REC * ircnet ) { if ( ! IS_IRC_SERVER_CONNECT ( conn ) ) return ; g_return_if_fail ( IS_IRCNET ( ircnet ) ) ; if ( ircnet -> alternate_nick != NULL ) { g_free_and_null ( conn -> alternate_nick ) ; conn -> alternate_nick = g_strdup ( ircnet -> alternate_nick ) ; } if ( ircnet -> usermode != NULL ) { g_free_and_null ( conn -> usermode ) ; conn -> usermode = g_strdup ( ircnet -> usermode ) ; } if ( ircnet -> max_kicks > 0 ) conn -> max_kicks = ircnet -> max_kicks ; if ( ircnet -> max_msgs > 0 ) conn -> max_msgs = ircnet -> max_msgs ; if ( ircnet -> max_modes > 0 ) conn -> max_modes = ircnet -> max_modes ; if ( ircnet -> max_whois > 0 ) conn -> max_whois = ircnet -> max_whois ; if ( ircnet -> max_cmds_at_once > 0 ) conn -> max_cmds_at_once = ircnet -> max_cmds_at_once ; if ( ircnet -> cmd_queue_speed > 0 ) conn -> cmd_queue_speed = ircnet -> cmd_queue_speed ; if ( ircnet -> max_query_chans > 0 ) conn -> max_query_chans = ircnet -> max_query_chans ; conn -> sasl_mechanism = SASL_MECHANISM_NONE ; conn -> sasl_username = NULL ; conn -> sasl_password = NULL ; if ( ircnet -> sasl_mechanism != NULL ) { if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , "plain" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ; if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && ircnet -> sasl_password != NULL && * ircnet -> sasl_password ) { <S2SV_StartBug> conn -> sasl_username = ircnet -> sasl_username ; <S2SV_EndBug> conn -> sasl_password = ircnet -> sasl_password ; } else g_warning ( "The<S2SV_blank>fields<S2SV_blank>sasl_username<S2SV_blank>and<S2SV_blank>sasl_password<S2SV_blank>are<S2SV_blank>either<S2SV_blank>missing<S2SV_blank>or<S2SV_blank>empty" ) ; } else if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , "external" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_EXTERNAL ; } else g_warning ( "Unsupported<S2SV_blank>SASL<S2SV_blank>mechanism<S2SV_blank>\\"%s\\"<S2SV_blank>selected" , ircnet -> sasl_mechanism ) ; } }
CWE-20 int kvm_read_guest_page ( struct kvm * kvm , gfn_t gfn , void * data , int offset , int len ) { int r ; unsigned long addr ; addr = gfn_to_hva ( kvm , gfn ) ; if ( kvm_is_error_hva ( addr ) ) return - EFAULT ; <S2SV_StartBug> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <S2SV_EndBug> if ( r ) return - EFAULT ; return 0 ; }
CWE-416 struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer ) <S2SV_StartBug> get_net ( peer ) ; <S2SV_EndBug> spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }
CWE-284 static inline void set_socket_blocking ( int s , int blocking ) { int opts ; <S2SV_StartBug> opts = fcntl ( s , F_GETFL ) ; <S2SV_EndBug> if ( opts < 0 ) APPL_TRACE_ERROR ( "set<S2SV_blank>blocking<S2SV_blank>(%s)" , strerror ( errno ) ) ; if ( blocking ) opts &= ~ O_NONBLOCK ; else opts |= O_NONBLOCK ; <S2SV_StartBug> if ( fcntl ( s , F_SETFL , opts ) < 0 ) <S2SV_EndBug> APPL_TRACE_ERROR ( "set<S2SV_blank>blocking<S2SV_blank>(%s)" , strerror ( errno ) ) ; }
CWE-119 static int inv_recenter_nonneg ( int v , int m ) { if ( v > 2 * m ) return v ; <S2SV_StartBug> return v % 2 ? m - ( v + 1 ) / 2 : m + v / 2 ; <S2SV_EndBug> }
CWE-000 static void DefragTrackerInit ( DefragTracker * dt , Packet * p ) { COPY_ADDRESS ( & p -> src , & dt -> src_addr ) ; COPY_ADDRESS ( & p -> dst , & dt -> dst_addr ) ; if ( PKT_IS_IPV4 ( p ) ) { dt -> id = ( int32_t ) IPV4_GET_IPID ( p ) ; dt -> af = AF_INET ; } else { dt -> id = ( int32_t ) IPV6_EXTHDR_GET_FH_ID ( p ) ; dt -> af = AF_INET6 ; } <S2SV_StartBug> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <S2SV_EndBug> dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ; dt -> policy = DefragGetOsPolicy ( p ) ; dt -> host_timeout = DefragPolicyGetHostTimeout ( p ) ; dt -> remove = 0 ; dt -> seen_last = 0 ; TAILQ_INIT ( & dt -> frags ) ; ( void ) DefragTrackerIncrUsecnt ( dt ) ; }
CWE-125 static int jpc_pi_nextrpcl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; uint_fast32_t trx0 ; uint_fast32_t try0 ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> JAS_UINTFAST32_NUMBITS - 2 || <S2SV_StartBug> pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > <S2SV_EndBug> JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pchg -> rlvlnoend && pi -> rlvlno < pi -> maxrlvls ; ++ pi -> rlvlno ) { for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) || ! ( pi -> x % ( JAS_CAST ( uint_fast32_t , 1 ) << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) || ! ( pi -> y % ( JAS_CAST ( uint_fast32_t , 1 ) << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
CWE-125 int write_output ( void ) { int fd ; struct filter_op * fop ; struct filter_header fh ; size_t ninst , i ; u_char * data ; ninst = compile_tree ( & fop ) ; if ( fop == NULL ) <S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ; ON_ERROR ( fd , - 1 , "Can\'t<S2SV_blank>create<S2SV_blank>file<S2SV_blank>%s" , EF_GBL_OPTIONS -> output_file ) ; fprintf ( stdout , "<S2SV_blank>Writing<S2SV_blank>output<S2SV_blank>to<S2SV_blank>\\\'%s\\\'<S2SV_blank>" , EF_GBL_OPTIONS -> output_file ) ; fflush ( stdout ) ; fh . magic = htons ( EC_FILTER_MAGIC ) ; strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ; fh . data = sizeof ( fh ) ; data = create_data_segment ( & fh , fop , ninst ) ; write ( fd , & fh , sizeof ( struct filter_header ) ) ; write ( fd , data , fh . code - fh . data ) ; for ( i = 0 ; i <= ninst ; i ++ ) { print_progress_bar ( & fop [ i ] ) ; write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ; } close ( fd ) ; fprintf ( stdout , "<S2SV_blank>done.\\n\\n" ) ; fprintf ( stdout , "<S2SV_blank>-><S2SV_blank>Script<S2SV_blank>encoded<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>instructions.\\n\\n" , ( int ) ( i - 1 ) ) ; return E_SUCCESS ; }
CWE-119 static void fillrd ( struct postproc_state * state , int q , int a ) { char char_dist [ 300 ] ; double sigma ; int i ; vp8_clear_system_state ( ) ; sigma = a + .5 + .6 * ( 63 - q ) / 63.0 ; { int next , j ; next = 0 ; for ( i = - 32 ; i < 32 ; i ++ ) { <S2SV_StartBug> const int v = ( int ) ( .5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ; <S2SV_EndBug> if ( v ) { for ( j = 0 ; j < v ; j ++ ) { char_dist [ next + j ] = ( char ) i ; } next = next + j ; } } for ( ; next < 256 ; next ++ ) char_dist [ next ] = 0 ; } for ( i = 0 ; i < 3072 ; i ++ ) { state -> noise [ i ] = char_dist [ rand ( ) & 0xff ] ; } for ( i = 0 ; i < 16 ; i ++ ) { state -> blackclamp [ i ] = - char_dist [ 0 ] ; state -> whiteclamp [ i ] = - char_dist [ 0 ] ; state -> bothclamp [ i ] = - 2 * char_dist [ 0 ] ; } state -> last_q = q ; state -> last_noise = a ; }
CWE-000 bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } return TRUE ; }
CWE-000 static int clie_5_attach ( struct usb_serial * serial ) { struct usb_serial_port * port ; unsigned int pipe ; int j ; <S2SV_StartBug> if ( serial -> num_ports < 2 ) <S2SV_EndBug> return - 1 ; port = serial -> port [ 0 ] ; port -> bulk_out_endpointAddress = serial -> port [ 1 ] -> bulk_out_endpointAddress ; pipe = usb_sndbulkpipe ( serial -> dev , port -> bulk_out_endpointAddress ) ; for ( j = 0 ; j < ARRAY_SIZE ( port -> write_urbs ) ; ++ j ) port -> write_urbs [ j ] -> pipe = pipe ; return 0 ; }
CWE-000 int __usb_get_extra_descriptor ( char * buffer , unsigned size , <S2SV_StartBug> unsigned char type , void * * ptr ) <S2SV_EndBug> { struct usb_descriptor_header * header ; while ( size >= sizeof ( struct usb_descriptor_header ) ) { header = ( struct usb_descriptor_header * ) buffer ; <S2SV_StartBug> if ( header -> bLength < 2 ) { <S2SV_EndBug> printk ( KERN_ERR "%s:<S2SV_blank>bogus<S2SV_blank>descriptor,<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d\\n" , usbcore_name , header -> bDescriptorType , header -> bLength ) ; return - 1 ; } <S2SV_StartBug> if ( header -> bDescriptorType == type ) { <S2SV_EndBug> * ptr = header ; return 0 ; } buffer += header -> bLength ; size -= header -> bLength ; } return - 1 ; }
CWE-000 static int get_default_root ( pool * p , int allow_symlinks , const char * * root ) { config_rec * c = NULL ; const char * dir = NULL ; int res ; c = find_config ( main_server -> conf , CONF_PARAM , "DefaultRoot" , FALSE ) ; while ( c != NULL ) { pr_signals_handle ( ) ; if ( c -> argc < 2 ) { dir = c -> argv [ 0 ] ; break ; } res = pr_expr_eval_group_and ( ( ( char * * ) c -> argv ) + 1 ) ; if ( res ) { dir = c -> argv [ 0 ] ; break ; } c = find_config_next ( c , c -> next , CONF_PARAM , "DefaultRoot" , FALSE ) ; } if ( dir != NULL ) { const char * new_dir ; new_dir = path_subst_uservar ( p , & dir ) ; if ( new_dir != NULL ) { dir = new_dir ; } if ( strncmp ( dir , "/" , 2 ) == 0 ) { dir = NULL ; } else { char * realdir ; int xerrno = 0 ; if ( allow_symlinks == FALSE ) { char * path , target_path [ PR_TUNABLE_PATH_MAX + 1 ] ; <S2SV_StartBug> struct stat st ; <S2SV_EndBug> size_t pathlen ; path = pstrdup ( p , dir ) ; if ( * path != '/' ) { if ( * path == '~' ) { if ( pr_fs_interpolate ( dir , target_path , sizeof ( target_path ) - 1 ) < 0 ) { return - 1 ; } path = target_path ; } } pathlen = strlen ( path ) ; if ( pathlen > 1 && path [ pathlen - 1 ] == '/' ) { path [ pathlen - 1 ] = '\\0' ; } <S2SV_StartBug> pr_fs_clear_cache2 ( path ) ; <S2SV_EndBug> res = pr_fsio_lstat ( path , & st ) ; if ( res < 0 ) { <S2SV_StartBug> xerrno = errno ; <S2SV_EndBug> <S2SV_StartBug> pr_log_pri ( PR_LOG_WARNING , "error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>check<S2SV_blank>%s:<S2SV_blank>%s" , path , <S2SV_EndBug> strerror ( xerrno ) ) ; errno = xerrno ; return - 1 ; } if ( S_ISLNK ( st . st_mode ) ) { pr_log_pri ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>" "config)" , path ) ; errno = EPERM ; return - 1 ; } } pr_fs_clear_cache2 ( dir ) ; PRIVS_USER realdir = dir_realpath ( p , dir ) ; xerrno = errno ; PRIVS_RELINQUISH if ( realdir ) { dir = realdir ; } else { char interp_dir [ PR_TUNABLE_PATH_MAX + 1 ] ; memset ( interp_dir , '\\0' , sizeof ( interp_dir ) ) ; ( void ) pr_fs_interpolate ( dir , interp_dir , sizeof ( interp_dir ) - 1 ) ; pr_log_pri ( PR_LOG_NOTICE , "notice:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>use<S2SV_blank>DefaultRoot<S2SV_blank>\'%s\'<S2SV_blank>[resolved<S2SV_blank>to<S2SV_blank>\'%s\']:<S2SV_blank>%s" , dir , interp_dir , strerror ( xerrno ) ) ; errno = xerrno ; } } } * root = dir ; return 0 ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp8_set_reference ( ctx -> cpi , frame -> frame_type , & sd ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-000 static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( "cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%p" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <S2SV_StartBug> } <S2SV_EndBug> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case HIDPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; } return - EINVAL ; }
CWE-119 static void handle_data_packet ( struct mt_connection * curconn , struct mt_mactelnet_hdr * pkthdr , int data_len ) { struct mt_mactelnet_control_hdr cpkt ; struct mt_packet pdata ; unsigned char * data = pkthdr -> data ; unsigned int act_size = 0 ; int got_user_packet = 0 ; int got_pass_packet = 0 ; int got_width_packet = 0 ; int got_height_packet = 0 ; int success ; success = parse_control_packet ( data , data_len - MT_HEADER_LEN , & cpkt ) ; while ( success ) { if ( cpkt . cptype == MT_CPTYPE_BEGINAUTH ) { int plen , i ; if ( ! curconn -> have_pass_salt ) { for ( i = 0 ; i < 16 ; ++ i ) { curconn -> pass_salt [ i ] = rand ( ) % 256 ; } curconn -> have_pass_salt = 1 ; memset ( curconn -> trypassword , 0 , sizeof ( curconn -> trypassword ) ) ; } init_packet ( & pdata , MT_PTYPE_DATA , pkthdr -> dstaddr , pkthdr -> srcaddr , pkthdr -> seskey , curconn -> outcounter ) ; plen = add_control_packet ( & pdata , MT_CPTYPE_PASSSALT , ( curconn -> pass_salt ) , 16 ) ; curconn -> outcounter += plen ; send_udp ( curconn , & pdata ) ; } else if ( cpkt . cptype == MT_CPTYPE_USERNAME && curconn -> state != STATE_ACTIVE ) { memcpy ( curconn -> username , cpkt . data , act_size = ( cpkt . length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt . length ) ) ; curconn -> username [ act_size ] = 0 ; got_user_packet = 1 ; } else if ( cpkt . cptype == MT_CPTYPE_TERM_WIDTH && cpkt . length >= 2 ) { unsigned short width ; memcpy ( & width , cpkt . data , 2 ) ; curconn -> terminal_width = le16toh ( width ) ; got_width_packet = 1 ; } else if ( cpkt . cptype == MT_CPTYPE_TERM_HEIGHT && cpkt . length >= 2 ) { unsigned short height ; memcpy ( & height , cpkt . data , 2 ) ; curconn -> terminal_height = le16toh ( height ) ; got_height_packet = 1 ; } else if ( cpkt . cptype == MT_CPTYPE_TERM_TYPE ) { memcpy ( curconn -> terminal_type , cpkt . data , act_size = ( cpkt . length > 30 - 1 ? 30 - 1 : cpkt . length ) ) ; curconn -> terminal_type [ act_size ] = 0 ; <S2SV_StartBug> } else if ( cpkt . cptype == MT_CPTYPE_PASSWORD ) { <S2SV_EndBug> # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( curconn -> trypassword , 17 ) ; # endif memcpy ( curconn -> trypassword , cpkt . data , 17 ) ; got_pass_packet = 1 ; } else if ( cpkt . cptype == MT_CPTYPE_PLAINDATA ) { if ( curconn -> state == STATE_ACTIVE && curconn -> ptsfd != - 1 ) { write ( curconn -> ptsfd , cpkt . data , cpkt . length ) ; } } else { <S2SV_StartBug> syslog ( LOG_WARNING , _ ( "(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d" ) , curconn -> seskey , cpkt . cptype ) ; <S2SV_EndBug> } success = parse_control_packet ( NULL , 0 , & cpkt ) ; } if ( got_user_packet && got_pass_packet ) { user_login ( curconn , pkthdr ) ; } if ( curconn -> state == STATE_ACTIVE && ( got_width_packet || got_height_packet ) ) { set_terminal_size ( curconn -> ptsfd , curconn -> terminal_width , curconn -> terminal_height ) ; } }
CWE-119 static av_cold int xpm_decode_close ( AVCodecContext * avctx ) { XPMDecContext * x = avctx -> priv_data ; av_freep ( & x -> pixels ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-20 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } <S2SV_StartBug> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <S2SV_EndBug> return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }
CWE-000 static void prefetch_dec ( void ) <S2SV_StartBug> { <S2SV_EndBug> prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ; }
CWE-119 vpx_codec_err_t vpx_codec_destroy ( vpx_codec_ctx_t * ctx ) { vpx_codec_err_t res ; if ( ! ctx ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { <S2SV_StartBug> if ( ctx -> priv -> alg_priv ) <S2SV_EndBug> <S2SV_StartBug> ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> ctx -> iface = NULL ; ctx -> name = NULL ; ctx -> priv = NULL ; res = VPX_CODEC_OK ; } return SAVE_STATUS ( ctx , res ) ; }
CWE-119 static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ; <S2SV_StartBug> char buf [ DN_BUF_LEN ] ; <S2SV_EndBug> unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ; <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <S2SV_EndBug> XN_FLAG_SEP_COMMA_PLUS ) ; <S2SV_StartBug> md -> subject_dn = strdup ( buf ) ; <S2SV_EndBug> if ( md -> subject_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } <S2SV_StartBug> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <S2SV_EndBug> XN_FLAG_SEP_COMMA_PLUS ) ; <S2SV_StartBug> md -> issuer_dn = strdup ( buf ) ; <S2SV_EndBug> if ( md -> issuer_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( j != 0 ) { md -> sans = calloc ( ( size_t ) j + 1 , sizeof ( * md -> sans ) ) ; if ( md -> sans == NULL ) { ret = ENOMEM ; goto cleanup ; } j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = pkinit_sans [ i ] ; free ( pkinit_sans ) ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) md -> sans [ j ++ ] = upn_sans [ i ] ; free ( upn_sans ) ; } md -> sans [ j ] = NULL ; } else md -> sans = NULL ; ret = crypto_retrieve_X509_key_usage ( context , plg_cryptoctx , req_cryptoctx , cert , & md -> ku_bits , & md -> eku_bits ) ; if ( ret ) goto cleanup ; * md_out = md ; md = NULL ; cleanup : crypto_cert_free_matching_data ( context , md ) ; return ret ; }
CWE-119 void vp9_rtcd ( ) { <S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> once ( setup_rtcd_internal ) ; }
CWE-119 static ssize_t k90_show_current_profile ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int current_profile ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> } current_profile = data [ 7 ] ; if ( current_profile < 1 || current_profile > 3 ) { dev_warn ( dev , "Read<S2SV_blank>invalid<S2SV_blank>current<S2SV_blank>profile:<S2SV_blank>%02hhx.\\n" , data [ 7 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , "%d\\n" , current_profile ) ; }
CWE-119 static int rd_pick_intra4x4mby_modes ( MACROBLOCK * mb , int * Rate , int * rate_y , int * Distortion , int best_rd ) { MACROBLOCKD * const xd = & mb -> e_mbd ; int i ; int cost = mb -> mbmode_cost [ xd -> frame_type ] [ B_PRED ] ; int distortion = 0 ; int tot_rate_y = 0 ; int64_t total_rd = 0 ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; const int * bmode_costs ; <S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; intra_prediction_down_copy ( xd , xd -> dst . y_buffer - xd -> dst . y_stride + 16 ) ; bmode_costs = mb -> inter_bmode_costs ; for ( i = 0 ; i < 16 ; i ++ ) { MODE_INFO * const mic = xd -> mode_info_context ; const int mis = xd -> mode_info_stride ; B_PREDICTION_MODE UNINITIALIZED_IS_SAFE ( best_mode ) ; int UNINITIALIZED_IS_SAFE ( r ) , UNINITIALIZED_IS_SAFE ( ry ) , UNINITIALIZED_IS_SAFE ( d ) ; if ( mb -> e_mbd . frame_type == KEY_FRAME ) { const B_PREDICTION_MODE A = above_block_mode ( mic , i , mis ) ; const B_PREDICTION_MODE L = left_block_mode ( mic , i ) ; bmode_costs = mb -> bmode_costs [ A ] [ L ] ; } total_rd += rd_pick_intra4x4block ( mb , mb -> block + i , xd -> block + i , & best_mode , bmode_costs , ta + vp8_block2above [ i ] , tl + vp8_block2left [ i ] , & r , & ry , & d ) ; cost += r ; distortion += d ; tot_rate_y += ry ; mic -> bmi [ i ] . as_mode = best_mode ; if ( total_rd >= ( int64_t ) best_rd ) break ; } if ( total_rd >= ( int64_t ) best_rd ) return INT_MAX ; * Rate = cost ; * rate_y = tot_rate_y ; * Distortion = distortion ; return RDCOST ( mb -> rdmult , mb -> rddiv , cost , distortion ) ; }
CWE-119 <S2SV_StartBug> void vp9_idct16x16_add ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> int eob ) { if ( eob == 1 ) <S2SV_StartBug> vp9_idct16x16_1_add ( input , dest , stride ) ; <S2SV_EndBug> else if ( eob <= 10 ) <S2SV_StartBug> vp9_idct16x16_10_add ( input , dest , stride ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_idct16x16_256_add ( input , dest , stride ) ; <S2SV_EndBug> }
CWE-189 static int perf_swevent_init ( struct perf_event * event ) { <S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; }
CWE-20 bool adapter_enable_disable ( ) { int error ; <S2SV_StartBug> CALL_AND_WAIT ( error = bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> TASSERT ( error == BT_STATUS_SUCCESS , "Error<S2SV_blank>enabling<S2SV_blank>Bluetooth:<S2SV_blank>%d" , error ) ; TASSERT ( adapter_get_state ( ) == BT_STATE_ON , "Adapter<S2SV_blank>did<S2SV_blank>not<S2SV_blank>turn<S2SV_blank>on." ) ; CALL_AND_WAIT ( error = bt_interface -> disable ( ) , adapter_state_changed ) ; TASSERT ( error == BT_STATUS_SUCCESS , "Error<S2SV_blank>disabling<S2SV_blank>Bluetooth:<S2SV_blank>%d" , error ) ; TASSERT ( adapter_get_state ( ) == BT_STATE_OFF , "Adapter<S2SV_blank>did<S2SV_blank>not<S2SV_blank>turn<S2SV_blank>off." ) ; return true ; }
CWE-476 static int jp2_bpcc_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_bpcc_t * bpcc = & box -> data . bpcc ; <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> bpcc -> numcmpts = box -> datalen ; if ( ! ( bpcc -> bpcs = jas_alloc2 ( bpcc -> numcmpts , sizeof ( uint_fast8_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < bpcc -> numcmpts ; ++ i ) { if ( jp2_getuint8 ( in , & bpcc -> bpcs [ i ] ) ) { return - 1 ; } } return 0 ; }
CWE-20 static void dns_resolver_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) { <S2SV_EndBug> int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ; if ( err ) seq_printf ( m , ":<S2SV_blank>%d" , err ) ; else seq_printf ( m , ":<S2SV_blank>%u" , key -> datalen ) ; } }
CWE-119 int mainloop ( CLIENT * client ) { struct nbd_request request ; struct nbd_reply reply ; gboolean go_on = TRUE ; # ifdef DODBG int i = 0 ; # endif negotiate ( client -> net , client , NULL ) ; DEBUG ( "Entering<S2SV_blank>request<S2SV_blank>loop!\\n" ) ; reply . magic = htonl ( NBD_REPLY_MAGIC ) ; reply . error = 0 ; while ( go_on ) { char buf [ BUFSIZE ] ; size_t len ; # ifdef DODBG i ++ ; printf ( "%d:<S2SV_blank>" , i ) ; # endif readit ( client -> net , & request , sizeof ( request ) ) ; request . from = ntohll ( request . from ) ; request . type = ntohl ( request . type ) ; if ( request . type == NBD_CMD_DISC ) { msg2 ( LOG_INFO , "Disconnect<S2SV_blank>request<S2SV_blank>received." ) ; if ( client -> server -> flags & F_COPYONWRITE ) { if ( client -> difmap ) g_free ( client -> difmap ) ; close ( client -> difffile ) ; unlink ( client -> difffilename ) ; free ( client -> difffilename ) ; } go_on = FALSE ; continue ; } len = ntohl ( request . len ) ; if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( "Not<S2SV_blank>enough<S2SV_blank>magic." ) ; <S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug> err ( "Request<S2SV_blank>too<S2SV_blank>big!" ) ; # ifdef DODBG printf ( "%s<S2SV_blank>from<S2SV_blank>%llu<S2SV_blank>(%llu)<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>" , request . type ? "WRITE" : "READ" , ( unsigned long long ) request . from , ( unsigned long long ) request . from / 512 , len ) ; # endif memcpy ( reply . handle , request . handle , sizeof ( reply . handle ) ) ; if ( ( request . from + len ) > ( OFFT_MAX ) ) { DEBUG ( "[Number<S2SV_blank>too<S2SV_blank>large!]" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( ( ( ssize_t ) ( ( off_t ) request . from + len ) > client -> exportsize ) ) { DEBUG ( "[RANGE!]" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( request . type == NBD_CMD_WRITE ) { DEBUG ( "wr:<S2SV_blank>net->buf,<S2SV_blank>" ) ; readit ( client -> net , buf , len ) ; DEBUG ( "buf->exp,<S2SV_blank>" ) ; if ( ( client -> server -> flags & F_READONLY ) || ( client -> server -> flags & F_AUTOREADONLY ) ) { DEBUG ( "[WRITE<S2SV_blank>to<S2SV_blank>READONLY!]" ) ; ERROR ( client , reply , EPERM ) ; continue ; } if ( expwrite ( request . from , buf , len , client ) ) { DEBUG ( "Write<S2SV_blank>failed:<S2SV_blank>%m" ) ; ERROR ( client , reply , errno ) ; continue ; } SEND ( client -> net , reply ) ; DEBUG ( "OK!\\n" ) ; continue ; } DEBUG ( "exp->buf,<S2SV_blank>" ) ; if ( expread ( request . from , buf + sizeof ( struct nbd_reply ) , len , client ) ) { DEBUG ( "Read<S2SV_blank>failed:<S2SV_blank>%m" ) ; ERROR ( client , reply , errno ) ; continue ; } DEBUG ( "buf->net,<S2SV_blank>" ) ; memcpy ( buf , & reply , sizeof ( struct nbd_reply ) ) ; writeit ( client -> net , buf , len + sizeof ( struct nbd_reply ) ) ; DEBUG ( "OK!\\n" ) ; } return 0 ; }
CWE-125 static int mpeg4_decode_studio_block ( MpegEncContext * s , int32_t block [ 64 ] , int n ) { Mpeg4DecContext * ctx = s -> avctx -> priv_data ; int cc , dct_dc_size , dct_diff , code , j , idx = 1 , group = 0 , run = 0 , additional_code_len , sign , mismatch ; VLC * cur_vlc = & ctx -> studio_intra_tab [ 0 ] ; uint8_t * const scantable = s -> intra_scantable . permutated ; const uint16_t * quant_matrix ; uint32_t flc ; const int min = - 1 * ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) ; const int max = ( ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) - 1 ) ; mismatch = 1 ; memset ( block , 0 , 64 * sizeof ( int32_t ) ) ; if ( n < 4 ) { cc = 0 ; dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> intra_matrix ; } else { cc = ( n & 1 ) + 1 ; if ( ctx -> rgb ) dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; else dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_chroma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> chroma_intra_matrix ; } if ( dct_dc_size < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "illegal<S2SV_blank>dct_dc_size<S2SV_blank>vlc\\n" ) ; return AVERROR_INVALIDDATA ; } else if ( dct_dc_size == 0 ) { dct_diff = 0 ; } else { dct_diff = get_xbits ( & s -> gb , dct_dc_size ) ; if ( dct_dc_size > 8 ) { if ( ! check_marker ( s -> avctx , & s -> gb , "dct_dc_size<S2SV_blank>><S2SV_blank>8" ) ) return AVERROR_INVALIDDATA ; } } s -> last_dc [ cc ] += dct_diff ; if ( s -> mpeg_quant ) block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) ; else block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) * ( 8 >> s -> dct_precision ) ; block [ 0 ] = av_clip ( block [ 0 ] , min , max ) ; mismatch ^= block [ 0 ] ; while ( 1 ) { group = get_vlc2 ( & s -> gb , cur_vlc -> table , STUDIO_INTRA_BITS , 2 ) ; if ( group < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "illegal<S2SV_blank>ac<S2SV_blank>coefficient<S2SV_blank>group<S2SV_blank>vlc\\n" ) ; return AVERROR_INVALIDDATA ; } additional_code_len = ac_state_tab [ group ] [ 0 ] ; cur_vlc = & ctx -> studio_intra_tab [ ac_state_tab [ group ] [ 1 ] ] ; if ( group == 0 ) { break ; } else if ( group >= 1 && group <= 6 ) { run = 1 << additional_code_len ; if ( additional_code_len ) run += get_bits ( & s -> gb , additional_code_len ) ; idx += run ; continue ; } else if ( group >= 7 && group <= 12 ) { code = get_bits ( & s -> gb , additional_code_len ) ; sign = code & 1 ; code >>= 1 ; run = ( 1 << ( additional_code_len - 1 ) ) + code ; idx += run ; <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = sign ? 1 : - 1 ; } else if ( group >= 13 && group <= 20 ) { <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ; <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> j = scantable [ idx ++ ] ; additional_code_len = s -> avctx -> bits_per_raw_sample + s -> dct_precision + 4 ; flc = get_bits ( & s -> gb , additional_code_len ) ; if ( flc >> ( additional_code_len - 1 ) ) block [ j ] = - 1 * ( ( flc ^ ( ( 1 << additional_code_len ) - 1 ) ) + 1 ) ; else block [ j ] = flc ; } block [ j ] = ( ( 8 * 2 * block [ j ] * quant_matrix [ j ] * s -> qscale ) >> s -> dct_precision ) / 32 ; block [ j ] = av_clip ( block [ j ] , min , max ) ; mismatch ^= block [ j ] ; } block [ 63 ] ^= mismatch & 1 ; return 0 ; }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { PadContext * s = inlink -> dst -> priv ; AVFrame * out ; int needs_copy = frame_needs_copy ( s , in ) ; if ( needs_copy ) { av_log ( inlink -> dst , AV_LOG_DEBUG , "Direct<S2SV_blank>padding<S2SV_blank>impossible<S2SV_blank>allocating<S2SV_blank>new<S2SV_blank>frame\\n" ) ; out = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , FFMAX ( inlink -> w , s -> w ) , FFMAX ( inlink -> h , s -> h ) ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } else { int i ; out = in ; <S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ i ] ; int vsub = s -> draw . vsub [ i ] ; out -> data [ i ] -= ( s -> x >> hsub ) * s -> draw . pixelstep [ i ] + ( s -> y >> vsub ) * out -> linesize [ i ] ; } } if ( s -> y ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , 0 , s -> w , s -> y ) ; } if ( s -> h > s -> y + s -> in_h ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y + s -> in_h , s -> w , s -> h - s -> y - s -> in_h ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y , s -> x , in -> height ) ; if ( needs_copy ) { ff_copy_rectangle2 ( & s -> draw , out -> data , out -> linesize , in -> data , in -> linesize , s -> x , s -> y , 0 , 0 , in -> width , in -> height ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , s -> x + s -> in_w , s -> y , s -> w - s -> x - s -> in_w , in -> height ) ; out -> width = s -> w ; out -> height = s -> h ; if ( in != out ) av_frame_free ( & in ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , out ) ; }
CWE-119 <S2SV_StartBug> static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word >= test , 1 ) ; <S2SV_EndBug> return word >= test ; }
CWE-119 int vp9_rc_drop_frame ( VP9_COMP * cpi ) { <S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> RATE_CONTROL * const rc = & cpi -> rc ; if ( ! oxcf -> drop_frames_water_mark ) { return 0 ; } else { if ( rc -> buffer_level < 0 ) { return 1 ; } else { int drop_mark = ( int ) ( oxcf -> drop_frames_water_mark * <S2SV_StartBug> oxcf -> optimal_buffer_level / 100 ) ; <S2SV_EndBug> if ( ( rc -> buffer_level > drop_mark ) && ( rc -> decimation_factor > 0 ) ) { -- rc -> decimation_factor ; } else if ( rc -> buffer_level <= drop_mark && rc -> decimation_factor == 0 ) { rc -> decimation_factor = 1 ; } if ( rc -> decimation_factor > 0 ) { if ( rc -> decimation_count > 0 ) { -- rc -> decimation_count ; return 1 ; } else { rc -> decimation_count = rc -> decimation_factor ; return 0 ; } } else { rc -> decimation_count = 0 ; return 0 ; } } } }
CWE-787 GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { <S2SV_StartBug> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <S2SV_EndBug> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
CWE-200 static void tv_details_row_activated ( GtkTreeView * tree_view , GtkTreePath * tree_path_UNUSED , GtkTreeViewColumn * column , gpointer user_data ) { gchar * item_name ; struct problem_item * item = get_current_problem_item_or_NULL ( tree_view , & item_name ) ; if ( ! item || ! ( item -> flags & CD_FLAG_TXT ) ) goto ret ; if ( ! strchr ( item -> content , '\\n' ) ) goto ret ; gint exitcode ; gchar * arg [ 3 ] ; arg [ 0 ] = ( char * ) "xdg-open" ; arg [ 1 ] = concat_path_file ( g_dump_dir_name , item_name ) ; arg [ 2 ] = NULL ; const gboolean spawn_ret = g_spawn_sync ( NULL , arg , NULL , G_SPAWN_SEARCH_PATH | G_SPAWN_STDOUT_TO_DEV_NULL , NULL , NULL , NULL , NULL , & exitcode , NULL ) ; if ( spawn_ret == FALSE || exitcode != EXIT_SUCCESS ) { GtkWidget * dialog = gtk_dialog_new_with_buttons ( _ ( "View/edit<S2SV_blank>a<S2SV_blank>text<S2SV_blank>file" ) , GTK_WINDOW ( g_wnd_assistant ) , GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT , NULL , NULL ) ; GtkWidget * vbox = gtk_dialog_get_content_area ( GTK_DIALOG ( dialog ) ) ; GtkWidget * scrolled = gtk_scrolled_window_new ( NULL , NULL ) ; GtkWidget * textview = gtk_text_view_new ( ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( "_Save" ) , GTK_RESPONSE_OK ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( "_Cancel" ) , GTK_RESPONSE_CANCEL ) ; gtk_box_pack_start ( GTK_BOX ( vbox ) , scrolled , TRUE , TRUE , 0 ) ; gtk_widget_set_size_request ( scrolled , 640 , 480 ) ; gtk_widget_show ( scrolled ) ; # if ( ( GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION < 7 ) || ( GTK_MAJOR_VERSION == 3 && GTK_MINOR_VERSION == 7 && GTK_MICRO_VERSION < 8 ) ) gtk_scrolled_window_add_with_viewport ( GTK_SCROLLED_WINDOW ( scrolled ) , textview ) ; # else gtk_container_add ( GTK_CONTAINER ( scrolled ) , textview ) ; # endif gtk_widget_show ( textview ) ; load_text_to_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; if ( gtk_dialog_run ( GTK_DIALOG ( dialog ) ) == GTK_RESPONSE_OK ) <S2SV_StartBug> save_text_from_text_view ( GTK_TEXT_VIEW ( textview ) , item_name ) ; <S2SV_EndBug> gtk_widget_destroy ( textview ) ; gtk_widget_destroy ( scrolled ) ; gtk_widget_destroy ( dialog ) ; } free ( arg [ 1 ] ) ; ret : g_free ( item_name ) ; }
CWE-000 void impeg2d_flush_ext_and_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; <S2SV_StartBug> while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }
CWE-119 static void init_config ( VP8_COMP * cpi , VP8_CONFIG * oxcf ) { VP8_COMMON * cm = & cpi -> common ; cpi -> oxcf = * oxcf ; cpi -> auto_gold = 1 ; cpi -> auto_adjust_gold_quantizer = 1 ; cm -> version = oxcf -> Version ; vp8_setup_version ( cm ) ; <S2SV_StartBug> cpi -> framerate = ( double ) ( oxcf -> timebase . den ) / <S2SV_EndBug> <S2SV_StartBug> ( double ) ( oxcf -> timebase . num ) ; <S2SV_EndBug> if ( cpi -> framerate > 180 ) cpi -> framerate = 30 ; cpi -> ref_framerate = cpi -> framerate ; <S2SV_StartBug> vp8_change_config ( cpi , oxcf ) ; <S2SV_EndBug> cpi -> active_worst_quality = cpi -> oxcf . worst_allowed_q ; cpi -> active_best_quality = cpi -> oxcf . best_allowed_q ; cpi -> avg_frame_qindex = cpi -> oxcf . worst_allowed_q ; cpi -> buffer_level = cpi -> oxcf . starting_buffer_level ; cpi -> bits_off_target = cpi -> oxcf . starting_buffer_level ; cpi -> rolling_target_bits = cpi -> av_per_frame_bandwidth ; cpi -> rolling_actual_bits = cpi -> av_per_frame_bandwidth ; cpi -> long_rolling_target_bits = cpi -> av_per_frame_bandwidth ; cpi -> long_rolling_actual_bits = cpi -> av_per_frame_bandwidth ; cpi -> total_actual_bits = 0 ; cpi -> total_target_vs_actual = 0 ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; double prev_layer_framerate = 0 ; for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { init_temporal_layer_context ( cpi , oxcf , i , prev_layer_framerate ) ; prev_layer_framerate = cpi -> output_framerate / cpi -> oxcf . rate_decimator [ i ] ; } } # if VP8_TEMPORAL_ALT_REF { int i ; cpi -> fixed_divide [ 0 ] = 0 ; for ( i = 1 ; i < 512 ; i ++ ) cpi -> fixed_divide [ i ] = 0x80000 / i ; } # endif }
CWE-000 static int rt_fill_info ( struct net * net , __be32 dst , __be32 src , struct flowi4 * fl4 , struct sk_buff * skb , u32 portid , u32 seq , int event , int nowait , unsigned int flags ) { struct rtable * rt = skb_rtable ( skb ) ; struct rtmsg * r ; struct nlmsghdr * nlh ; unsigned long expires = 0 ; u32 error ; u32 metrics [ RTAX_MAX ] ; nlh = nlmsg_put ( skb , portid , seq , event , sizeof ( * r ) , flags ) ; if ( nlh == NULL ) return - EMSGSIZE ; r = nlmsg_data ( nlh ) ; r -> rtm_family = AF_INET ; r -> rtm_dst_len = 32 ; r -> rtm_src_len = 0 ; r -> rtm_tos = fl4 -> flowi4_tos ; r -> rtm_table = RT_TABLE_MAIN ; if ( nla_put_u32 ( skb , RTA_TABLE , RT_TABLE_MAIN ) ) goto nla_put_failure ; r -> rtm_type = rt -> rt_type ; r -> rtm_scope = RT_SCOPE_UNIVERSE ; r -> rtm_protocol = RTPROT_UNSPEC ; r -> rtm_flags = ( rt -> rt_flags & ~ 0xFFFF ) | RTM_F_CLONED ; if ( rt -> rt_flags & RTCF_NOTIFY ) <S2SV_StartBug> r -> rtm_flags |= RTM_F_NOTIFY ; <S2SV_EndBug> if ( nla_put_be32 ( skb , RTA_DST , dst ) ) goto nla_put_failure ; if ( src ) { r -> rtm_src_len = 32 ; if ( nla_put_be32 ( skb , RTA_SRC , src ) ) goto nla_put_failure ; } if ( rt -> dst . dev && nla_put_u32 ( skb , RTA_OIF , rt -> dst . dev -> ifindex ) ) goto nla_put_failure ; # ifdef CONFIG_IP_ROUTE_CLASSID if ( rt -> dst . tclassid && nla_put_u32 ( skb , RTA_FLOW , rt -> dst . tclassid ) ) goto nla_put_failure ; # endif if ( ! rt_is_input_route ( rt ) && fl4 -> saddr != src ) { if ( nla_put_be32 ( skb , RTA_PREFSRC , fl4 -> saddr ) ) goto nla_put_failure ; } if ( rt -> rt_uses_gateway && nla_put_be32 ( skb , RTA_GATEWAY , rt -> rt_gateway ) ) goto nla_put_failure ; expires = rt -> dst . expires ; if ( expires ) { unsigned long now = jiffies ; if ( time_before ( now , expires ) ) expires -= now ; else expires = 0 ; } memcpy ( metrics , dst_metrics_ptr ( & rt -> dst ) , sizeof ( metrics ) ) ; if ( rt -> rt_pmtu && expires ) metrics [ RTAX_MTU - 1 ] = rt -> rt_pmtu ; if ( rtnetlink_put_metrics ( skb , metrics ) < 0 ) goto nla_put_failure ; if ( fl4 -> flowi4_mark && nla_put_u32 ( skb , RTA_MARK , fl4 -> flowi4_mark ) ) goto nla_put_failure ; error = rt -> dst . error ; if ( rt_is_input_route ( rt ) ) { # ifdef CONFIG_IP_MROUTE if ( ipv4_is_multicast ( dst ) && ! ipv4_is_local_multicast ( dst ) && IPV4_DEVCONF_ALL ( net , MC_FORWARDING ) ) { int err = ipmr_get_route ( net , skb , fl4 -> saddr , fl4 -> daddr , r , nowait ) ; if ( err <= 0 ) { if ( ! nowait ) { if ( err == 0 ) return 0 ; goto nla_put_failure ; } else { if ( err == - EMSGSIZE ) goto nla_put_failure ; error = err ; } } } else # endif if ( nla_put_u32 ( skb , RTA_IIF , skb -> dev -> ifindex ) ) goto nla_put_failure ; } if ( rtnl_put_cacheinfo ( skb , & rt -> dst , 0 , expires , error ) < 0 ) goto nla_put_failure ; return nlmsg_end ( skb , nlh ) ; nla_put_failure : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }
CWE-119 static void write_profile ( BITSTREAM_PROFILE profile , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> assert ( profile < MAX_PROFILES ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , profile & 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , profile >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 bt_status_t btif_dm_pin_reply ( const bt_bdaddr_t * bd_addr , uint8_t accept , uint8_t pin_len , bt_pin_code_t * pin_code ) { BTIF_TRACE_EVENT ( "%s:<S2SV_blank>accept=%d" , __FUNCTION__ , accept ) ; <S2SV_StartBug> if ( pin_code == NULL ) <S2SV_EndBug> return BT_STATUS_FAIL ; # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) if ( pairing_cb . is_le_only ) { int i ; UINT32 passkey = 0 ; int multi [ ] = { 100000 , 10000 , 1000 , 100 , 10 , 1 } ; BD_ADDR remote_bd_addr ; bdcpy ( remote_bd_addr , bd_addr -> address ) ; for ( i = 0 ; i < 6 ; i ++ ) { passkey += ( multi [ i ] * ( pin_code -> pin [ i ] - '0' ) ) ; } BTIF_TRACE_DEBUG ( "btif_dm_pin_reply:<S2SV_blank>passkey:<S2SV_blank>%d" , passkey ) ; BTA_DmBlePasskeyReply ( remote_bd_addr , accept , passkey ) ; } else { BTA_DmPinReply ( ( UINT8 * ) bd_addr -> address , accept , pin_len , pin_code -> pin ) ; if ( accept ) pairing_cb . pin_code_len = pin_len ; } # else BTA_DmPinReply ( ( UINT8 * ) bd_addr -> address , accept , pin_len , pin_code -> pin ) ; if ( accept ) pairing_cb . pin_code_len = pin_len ; # endif return BT_STATUS_SUCCESS ; }
CWE-200 int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; <S2SV_StartBug> int family = sk -> sk_family ; <S2SV_EndBug> struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; struct sk_buff * skb ; int copied , err ; pr_debug ( "ping_recvmsg(sk=%p,sk->num=%u)\\n" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; <S2SV_StartBug> if ( addr_len ) { <S2SV_EndBug> if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ; else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) { <S2SV_StartBug> sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_EndBug> sin -> sin_family = AF_INET ; sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ; <S2SV_StartBug> sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_EndBug> sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( "ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n" , err ) ; return err ; }
CWE-20 sctp_disposition_t sctp_sf_do_5_1D_ce ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; sctp_init_chunk_t * peer_init ; struct sctp_chunk * repl ; struct sctp_ulpevent * ev , * ai_ev = NULL ; int error = 0 ; struct sctp_chunk * err_chk_p ; struct sock * sk ; if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; sk = ep -> base . sk ; if ( ! sctp_sstate ( sk , LISTENING ) || ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; if ( ! sctp_process_init ( new_asoc , chunk , & chunk -> subh . cookie_hdr -> c . peer_addr , peer_init , GFP_ATOMIC ) ) goto nomem_init ; error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; if ( error ) goto nomem_init ; if ( chunk -> auth_chunk ) { struct sctp_chunk auth ; sctp_ierror_t ret ; <S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> auth . asoc = chunk -> asoc ; auth . sctp_hdr = chunk -> sctp_hdr ; auth . chunk_hdr = ( sctp_chunkhdr_t * ) skb_push ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; skb_pull ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; auth . transport = chunk -> transport ; ret = sctp_sf_authenticate ( net , ep , new_asoc , type , & auth ) ; kfree_skb ( chunk -> auth_chunk ) ; if ( ret != SCTP_IERROR_NO_ERROR ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; if ( ! repl ) goto nomem_init ; ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , new_asoc -> c . sinit_num_ostreams , new_asoc -> c . sinit_max_instreams , NULL , GFP_ATOMIC ) ; if ( ! ev ) goto nomem_ev ; if ( new_asoc -> peer . adaptation_ind ) { ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , GFP_ATOMIC ) ; if ( ! ai_ev ) goto nomem_aiev ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; if ( ai_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ai_ev ) ) ; return SCTP_DISPOSITION_CONSUME ; nomem_aiev : sctp_ulpevent_free ( ev ) ; nomem_ev : sctp_chunk_free ( repl ) ; nomem_init : sctp_association_free ( new_asoc ) ; nomem : return SCTP_DISPOSITION_NOMEM ; }
CWE-476 static void skcipher_release ( void * private ) { <S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> }
CWE-000 static krb5_error_code recvauth_common ( krb5_context context , krb5_auth_context * auth_context , krb5_pointer fd , char * appl_version , krb5_principal server , krb5_int32 flags , krb5_keytab keytab , krb5_ticket * * ticket , krb5_data * version ) { krb5_auth_context new_auth_context ; krb5_flags ap_option = 0 ; krb5_error_code retval , problem ; krb5_data inbuf ; krb5_data outbuf ; krb5_rcache rcache = 0 ; krb5_octet response ; krb5_data null_server ; <S2SV_StartBug> int need_error_free = 0 ; <S2SV_EndBug> int local_rcache = 0 , local_authcon = 0 ; problem = 0 ; response = 0 ; if ( ! ( flags & KRB5_RECVAUTH_SKIP_VERSION ) ) { if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ; <S2SV_StartBug> if ( strcmp ( inbuf . data , sendauth_version ) ) { <S2SV_EndBug> problem = KRB5_SENDAUTH_BADAUTHVERS ; response = 1 ; } free ( inbuf . data ) ; } if ( flags & KRB5_RECVAUTH_BADAUTHVERS ) { problem = KRB5_SENDAUTH_BADAUTHVERS ; response = 1 ; } if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ; <S2SV_StartBug> if ( appl_version && strcmp ( inbuf . data , appl_version ) ) { <S2SV_EndBug> if ( ! problem ) { problem = KRB5_SENDAUTH_BADAPPLVERS ; response = 2 ; } } if ( version && ! problem ) * version = inbuf ; else free ( inbuf . data ) ; if ( ( krb5_net_write ( context , * ( ( int * ) fd ) , ( char * ) & response , 1 ) ) < 0 ) { return ( problem ) ; } if ( problem ) return ( problem ) ; if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return retval ; if ( * auth_context == NULL ) { problem = krb5_auth_con_init ( context , & new_auth_context ) ; * auth_context = new_auth_context ; local_authcon = 1 ; } krb5_auth_con_getrcache ( context , * auth_context , & rcache ) ; if ( ( ! problem ) && rcache == NULL ) { if ( server != NULL && server -> length > 0 ) { problem = krb5_get_server_rcache ( context , & server -> data [ 0 ] , & rcache ) ; } else { null_server . length = 7 ; null_server . data = "default" ; problem = krb5_get_server_rcache ( context , & null_server , & rcache ) ; } if ( ! problem ) problem = krb5_auth_con_setrcache ( context , * auth_context , rcache ) ; local_rcache = 1 ; } if ( ! problem ) { problem = krb5_rd_req ( context , auth_context , & inbuf , server , keytab , & ap_option , ticket ) ; free ( inbuf . data ) ; } if ( problem ) { krb5_error error ; const char * message ; memset ( & error , 0 , sizeof ( error ) ) ; krb5_us_timeofday ( context , & error . stime , & error . susec ) ; if ( server ) error . server = server ; else { ( void ) krb5_parse_name ( context , "????" , & error . server ) ; need_error_free = 1 ; } error . error = problem - ERROR_TABLE_BASE_krb5 ; if ( error . error > 127 ) error . error = KRB_ERR_GENERIC ; message = error_message ( problem ) ; error . text . length = strlen ( message ) + 1 ; error . text . data = strdup ( message ) ; if ( ! error . text . data ) { retval = ENOMEM ; goto cleanup ; } if ( ( retval = krb5_mk_error ( context , & error , & outbuf ) ) ) { free ( error . text . data ) ; goto cleanup ; } free ( error . text . data ) ; if ( need_error_free ) krb5_free_principal ( context , error . server ) ; } else { outbuf . length = 0 ; outbuf . data = 0 ; } retval = krb5_write_message ( context , fd , & outbuf ) ; if ( outbuf . data ) { free ( outbuf . data ) ; retval = problem ; goto cleanup ; } if ( retval ) goto cleanup ; if ( ( ap_option & AP_OPTS_MUTUAL_REQUIRED ) ) { if ( ( retval = krb5_mk_rep ( context , * auth_context , & outbuf ) ) ) { return ( retval ) ; } retval = krb5_write_message ( context , fd , & outbuf ) ; free ( outbuf . data ) ; } cleanup : ; if ( retval ) { if ( local_authcon ) { krb5_auth_con_free ( context , * auth_context ) ; } else if ( local_rcache && rcache != NULL ) { krb5_rc_close ( context , rcache ) ; krb5_auth_con_setrcache ( context , * auth_context , NULL ) ; } } return retval ; }
CWE-119 static __u8 * nci_extract_rf_params_nfcb_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcb_poll * nfcb_poll , __u8 * data ) { <S2SV_StartBug> nfcb_poll -> sensb_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( "sensb_res_len<S2SV_blank>%d\\n" , nfcb_poll -> sensb_res_len ) ; memcpy ( nfcb_poll -> sensb_res , data , nfcb_poll -> sensb_res_len ) ; data += nfcb_poll -> sensb_res_len ; return data ; }
CWE-264 static void mark_screen_rdonly ( struct mm_struct * mm ) { pgd_t * pgd ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; int i ; <S2SV_StartBug> pgd = pgd_offset ( mm , 0xA0000 ) ; <S2SV_EndBug> if ( pgd_none_or_clear_bad ( pgd ) ) goto out ; pud = pud_offset ( pgd , 0xA0000 ) ; if ( pud_none_or_clear_bad ( pud ) ) goto out ; pmd = pmd_offset ( pud , 0xA0000 ) ; split_huge_page_pmd ( mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto out ; pte = pte_offset_map_lock ( mm , pmd , 0xA0000 , & ptl ) ; for ( i = 0 ; i < 32 ; i ++ ) { if ( pte_present ( * pte ) ) set_pte ( pte , pte_wrprotect ( * pte ) ) ; pte ++ ; } pte_unmap_unlock ( pte , ptl ) ; out : <S2SV_StartBug> flush_tlb ( ) ; <S2SV_EndBug> }
CWE-000 gchar * _rsvg_io_get_file_path ( const gchar * filename , const gchar * base_uri ) { gchar * absolute_filename ; <S2SV_StartBug> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <S2SV_EndBug> absolute_filename = g_strdup ( filename ) ; } else { gchar * tmpcdir ; gchar * base_filename ; if ( base_uri ) { base_filename = g_filename_from_uri ( base_uri , NULL , NULL ) ; if ( base_filename != NULL ) { tmpcdir = g_path_get_dirname ( base_filename ) ; g_free ( base_filename ) ; } else return NULL ; } else tmpcdir = g_get_current_dir ( ) ; absolute_filename = g_build_filename ( tmpcdir , filename , NULL ) ; g_free ( tmpcdir ) ; } return absolute_filename ; }
CWE-000 static int find_low_bit ( unsigned int x ) { int i ; for ( i = 0 ; i <= 31 ; i ++ ) { <S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> } return 0 ; }
CWE-264 static void tun_net_init ( struct net_device * dev ) { struct tun_struct * tun = netdev_priv ( dev ) ; switch ( tun -> flags & TUN_TYPE_MASK ) { case TUN_TUN_DEV : dev -> netdev_ops = & tun_netdev_ops ; dev -> hard_header_len = 0 ; dev -> addr_len = 0 ; dev -> mtu = 1500 ; dev -> type = ARPHRD_NONE ; dev -> flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST ; dev -> tx_queue_len = TUN_READQ_SIZE ; break ; case TUN_TAP_DEV : dev -> netdev_ops = & tap_netdev_ops ; ether_setup ( dev ) ; <S2SV_StartBug> random_ether_addr ( dev -> dev_addr ) ; <S2SV_EndBug> dev -> tx_queue_len = TUN_READQ_SIZE ; break ; } }
CWE-119 static void decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ; <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; int left_stride = dst_stride ; unsigned char top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }
CWE-000 static const u_char * ikev1_nonce_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct isakmp_gen e ; ND_PRINT ( ( ndo , "%s:" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & e , ext , sizeof ( e ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>n<S2SV_blank>len=%d" , ntohs ( e . len ) - 4 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( 2 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , ntohs ( e . len ) - 4 ) ) goto trunc ; <S2SV_StartBug> } else if ( 1 < ndo -> ndo_vflag && 4 < ntohs ( e . len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , ( const u_char * ) ( const uint8_t * ) ( ext + 1 ) , ep ) ) <S2SV_EndBug> goto trunc ; } <S2SV_StartBug> return ( const u_char * ) ext + ntohs ( e . len ) ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( ISAKMP_NPTYPE_NONCE ) ) ) ; return NULL ; }
CWE-264 static ssize_t ib_ucm_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ib_ucm_file * file = filp -> private_data ; struct ib_ucm_cmd_hdr hdr ; <S2SV_StartBug> ssize_t result ; <S2SV_EndBug> if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucm_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; result = ucm_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! result ) result = len ; return result ; }
CWE-125 static int decode_rt_routing_info ( netdissect_options * ndo , const u_char * pptr , char * buf , u_int buflen ) { uint8_t route_target [ 8 ] ; u_int plen ; <S2SV_StartBug> ND_TCHECK ( pptr [ 0 ] ) ; <S2SV_EndBug> plen = pptr [ 0 ] ; if ( 0 == plen ) { snprintf ( buf , buflen , "default<S2SV_blank>route<S2SV_blank>target" ) ; return 1 ; } if ( 32 > plen ) return - 1 ; <S2SV_StartBug> plen -= 32 ; <S2SV_EndBug> if ( 64 < plen ) return - 1 ; memset ( & route_target , 0 , sizeof ( route_target ) ) ; <S2SV_StartBug> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <S2SV_EndBug> if ( plen % 8 ) { ( ( u_char * ) & route_target ) [ ( plen + 7 ) / 8 - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , buflen , "origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s" , <S2SV_StartBug> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <S2SV_EndBug> bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ; return 5 + ( plen + 7 ) / 8 ; trunc : return - 2 ; }
CWE-000 static rsRetVal initZMQ ( instanceData * pData ) { DEFiRet ; if ( NULL == s_context ) { zsys_handler_set ( NULL ) ; s_context = zctx_new ( ) ; if ( s_workerThreads > 0 ) zctx_set_iothreads ( s_context , s_workerThreads ) ; } pData -> socket = zsocket_new ( s_context , pData -> type ) ; if ( NULL == pData -> socket ) { errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , "omzmq3:<S2SV_blank>zsocket_new<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ( char * ) pData -> identity ) ; if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> sndBuf ) ; if ( pData -> rcvBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> rcvBuf ) ; if ( pData -> linger > - 1 ) zsocket_set_linger ( pData -> socket , pData -> linger ) ; if ( pData -> backlog > - 1 ) zsocket_set_backlog ( pData -> socket , pData -> backlog ) ; if ( pData -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( pData -> socket , pData -> sndTimeout ) ; if ( pData -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( pData -> socket , pData -> rcvTimeout ) ; if ( pData -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( pData -> socket , pData -> maxMsgSize ) ; if ( pData -> rate > - 1 ) zsocket_set_rate ( pData -> socket , pData -> rate ) ; if ( pData -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( pData -> socket , pData -> recoveryIVL ) ; if ( pData -> multicastHops > - 1 ) zsocket_set_multicast_hops ( pData -> socket , pData -> multicastHops ) ; if ( pData -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( pData -> socket , pData -> reconnectIVL ) ; if ( pData -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( pData -> socket , pData -> reconnectIVLMax ) ; if ( pData -> ipv4Only > - 1 ) zsocket_set_ipv4only ( pData -> socket , pData -> ipv4Only ) ; if ( pData -> affinity != 1 ) zsocket_set_affinity ( pData -> socket , pData -> affinity ) ; if ( pData -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( pData -> socket , pData -> rcvHWM ) ; if ( pData -> sndHWM > - 1 ) zsocket_set_sndhwm ( pData -> socket , pData -> sndHWM ) ; if ( pData -> action == ACTION_BIND ) { <S2SV_StartBug> if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , "omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( "omzmq3:<S2SV_blank>bind<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful\\n" , pData -> description ) ; } else { <S2SV_StartBug> if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , "omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( "omzmq3:<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful" , pData -> description ) ; } finalize_it : RETiRet ; }
CWE-119 void WT_InterpolateNoLoop ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = ( EAS_I32 ) pWTVoice -> phaseFrac ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
CWE-000 static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; <S2SV_StartBug> if ( ! vma -> vm_userfaultfd_ctx . ctx ) <S2SV_EndBug> goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; if ( userfaultfd_missing ( vma ) ) { struct userfaultfd_wake_range range ; range . start = start ; range . len = vma_end - start ; wake_userfault ( vma -> vm_userfaultfd_ctx . ctx , & range ) ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; out : return ret ; }
CWE-284 void bta_hl_co_put_rx_data ( UINT8 app_id , tBTA_HL_MDL_HANDLE mdl_handle , UINT16 data_size , UINT8 * p_data , UINT16 evt ) { UINT8 app_idx , mcl_idx , mdl_idx ; btif_hl_mdl_cb_t * p_dcb ; tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL ; int r ; BTIF_TRACE_DEBUG ( "%s<S2SV_blank>app_id=%d<S2SV_blank>mdl_handle=0x%x<S2SV_blank>data_size=%d" , __FUNCTION__ , app_id , mdl_handle , data_size ) ; if ( btif_hl_find_mdl_idx_using_handle ( mdl_handle , & app_idx , & mcl_idx , & mdl_idx ) ) { p_dcb = BTIF_HL_GET_MDL_CB_PTR ( app_idx , mcl_idx , mdl_idx ) ; if ( ( p_dcb -> p_rx_pkt = ( UINT8 * ) btif_hl_get_buf ( data_size ) ) != NULL ) { memcpy ( p_dcb -> p_rx_pkt , p_data , data_size ) ; if ( p_dcb -> p_scb ) { BTIF_TRACE_DEBUG ( "app_idx=%d<S2SV_blank>mcl_idx=0x%x<S2SV_blank>mdl_idx=0x%x<S2SV_blank>data_size=%d" , app_idx , mcl_idx , mdl_idx , data_size ) ; <S2SV_StartBug> r = send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ; <S2SV_EndBug> if ( r == data_size ) { BTIF_TRACE_DEBUG ( "socket<S2SV_blank>send<S2SV_blank>success<S2SV_blank>data_size=%d" , data_size ) ; status = BTA_HL_STATUS_OK ; } else { BTIF_TRACE_ERROR ( "socket<S2SV_blank>send<S2SV_blank>failed<S2SV_blank>r=%d<S2SV_blank>data_size=%d" , r , data_size ) ; } } btif_hl_free_buf ( ( void * * ) & p_dcb -> p_rx_pkt ) ; } } bta_hl_ci_put_rx_data ( mdl_handle , status , evt ) ; }
CWE-119 static void decode_mb_mode_mvs ( VP8D_COMP * pbi , MODE_INFO * mi , MB_MODE_INFO * mbmi ) <S2SV_StartBug> { <S2SV_EndBug> if ( pbi -> mb . update_mb_segmentation_map ) read_mb_features ( & pbi -> mbc [ 8 ] , & mi -> mbmi , & pbi -> mb ) ; else if ( pbi -> common . frame_type == KEY_FRAME ) mi -> mbmi . segment_id = 0 ; if ( pbi -> common . mb_no_coeff_skip ) mi -> mbmi . mb_skip_coeff = vp8_read ( & pbi -> mbc [ 8 ] , pbi -> prob_skip_false ) ; else mi -> mbmi . mb_skip_coeff = 0 ; mi -> mbmi . is_4x4 = 0 ; if ( pbi -> common . frame_type == KEY_FRAME ) read_kf_modes ( pbi , mi ) ; else read_mb_modes_mv ( pbi , mi , & mi -> mbmi ) ; }
CWE-119 <S2SV_StartBug> void Huff_offsetReceive ( node_t * node , int * ch , byte * fin , int * offset ) { <S2SV_EndBug> bloc = * offset ; <S2SV_StartBug> while ( node && node -> symbol == INTERNAL_NODE ) { <S2SV_EndBug> if ( get_bit ( fin ) ) { node = node -> right ; } else { node = node -> left ; } } if ( ! node ) { * ch = 0 ; return ; } * ch = node -> symbol ; * offset = bloc ; }
CWE-119 static void process_blob ( struct rev_info * revs , struct blob * blob , show_object_fn show , struct strbuf * path , const char * name , void * cb_data ) { struct object * obj = & blob -> object ; <S2SV_StartBug> if ( ! revs -> blob_objects ) <S2SV_EndBug> return ; if ( ! obj ) die ( "bad<S2SV_blank>blob<S2SV_blank>object" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; obj -> flags |= SEEN ; <S2SV_StartBug> show ( obj , path , name , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static void <S2SV_StartBug> ext4_xattr_cache_insert ( struct mb_cache * ext4_mb_cache , struct buffer_head * bh ) <S2SV_EndBug> { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> int error ; <S2SV_StartBug> ce = mb_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; <S2SV_EndBug> if ( ! ce ) { ea_bdebug ( bh , "out<S2SV_blank>of<S2SV_blank>memory" ) ; return ; } <S2SV_StartBug> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <S2SV_EndBug> if ( error ) { <S2SV_StartBug> mb_cache_entry_free ( ce ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error == - EBUSY ) { <S2SV_EndBug> ea_bdebug ( bh , "already<S2SV_blank>in<S2SV_blank>cache" ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> } } else { ea_bdebug ( bh , "inserting<S2SV_blank>[%x]" , ( int ) hash ) ; <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> } }
CWE-200 void init_global_keywords ( bool global_active ) { install_keyword_root ( "linkbeat_use_polling" , use_polling_handler , global_active ) ; # if HAVE_DECL_CLONE_NEWNET install_keyword_root ( "net_namespace" , & net_namespace_handler , global_active ) ; install_keyword_root ( "namespace_with_ipsets" , & namespace_ipsets_handler , global_active ) ; # endif install_keyword_root ( "use_pid_dir" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( "instance" , & instance_handler , global_active ) ; install_keyword_root ( "child_wait_time" , & child_wait_handler , global_active ) ; install_keyword_root ( "global_defs" , NULL , global_active ) ; install_keyword ( "router_id" , & routerid_handler ) ; install_keyword ( "notification_email_from" , & emailfrom_handler ) ; install_keyword ( "smtp_server" , & smtpserver_handler ) ; install_keyword ( "smtp_helo_name" , & smtphelo_handler ) ; install_keyword ( "smtp_connect_timeout" , & smtpto_handler ) ; install_keyword ( "notification_email" , & email_handler ) ; install_keyword ( "smtp_alert" , & smtp_alert_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( "smtp_alert_vrrp" , & smtp_alert_vrrp_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "smtp_alert_checker" , & smtp_alert_checker_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( "dynamic_interfaces" , & dynamic_interfaces_handler ) ; install_keyword ( "no_email_faults" , & no_email_faults_handler ) ; install_keyword ( "default_interface" , & default_interface_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "lvs_timeouts" , & lvs_timeouts ) ; install_keyword ( "lvs_flush" , & lvs_flush_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( "lvs_sync_daemon" , & lvs_syncd_handler ) ; # endif # endif # ifdef _WITH_VRRP_ install_keyword ( "vrrp_mcast_group4" , & vrrp_mcast_group4_handler ) ; install_keyword ( "vrrp_mcast_group6" , & vrrp_mcast_group6_handler ) ; install_keyword ( "vrrp_garp_master_delay" , & vrrp_garp_delay_handler ) ; install_keyword ( "vrrp_garp_master_repeat" , & vrrp_garp_rep_handler ) ; install_keyword ( "vrrp_garp_master_refresh" , & vrrp_garp_refresh_handler ) ; install_keyword ( "vrrp_garp_master_refresh_repeat" , & vrrp_garp_refresh_rep_handler ) ; install_keyword ( "vrrp_garp_lower_prio_delay" , & vrrp_garp_lower_prio_delay_handler ) ; install_keyword ( "vrrp_garp_lower_prio_repeat" , & vrrp_garp_lower_prio_rep_handler ) ; install_keyword ( "vrrp_garp_interval" , & vrrp_garp_interval_handler ) ; install_keyword ( "vrrp_gna_interval" , & vrrp_gna_interval_handler ) ; install_keyword ( "vrrp_lower_prio_no_advert" , & vrrp_lower_prio_no_advert_handler ) ; install_keyword ( "vrrp_higher_prio_send_advert" , & vrrp_higher_prio_send_advert_handler ) ; install_keyword ( "vrrp_version" , & vrrp_version_handler ) ; install_keyword ( "vrrp_iptables" , & vrrp_iptables_handler ) ; # ifdef _HAVE_LIBIPSET_ install_keyword ( "vrrp_ipsets" , & vrrp_ipsets_handler ) ; # endif install_keyword ( "vrrp_check_unicast_src" , & vrrp_check_unicast_src_handler ) ; install_keyword ( "vrrp_skip_check_adv_addr" , & vrrp_check_adv_addr_handler ) ; install_keyword ( "vrrp_strict" , & vrrp_strict_handler ) ; install_keyword ( "vrrp_priority" , & vrrp_prio_handler ) ; install_keyword ( "vrrp_no_swap" , & vrrp_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( "vrrp_rt_priority" , & vrrp_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "vrrp_rlimit_rtime" , & vrrp_rt_rlimit_handler ) ; # endif # endif # endif install_keyword ( "notify_fifo" , & global_notify_fifo ) ; install_keyword ( "notify_fifo_script" , & global_notify_fifo_script ) ; # ifdef _WITH_VRRP_ install_keyword ( "vrrp_notify_fifo" , & vrrp_notify_fifo ) ; install_keyword ( "vrrp_notify_fifo_script" , & vrrp_notify_fifo_script ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "lvs_notify_fifo" , & lvs_notify_fifo ) ; install_keyword ( "lvs_notify_fifo_script" , & lvs_notify_fifo_script ) ; install_keyword ( "checker_priority" , & checker_prio_handler ) ; install_keyword ( "checker_no_swap" , & checker_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( "checker_rt_priority" , & checker_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "checker_rlimit_rtime" , & checker_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_BFD_ install_keyword ( "bfd_priority" , & bfd_prio_handler ) ; install_keyword ( "bfd_no_swap" , & bfd_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( "bfd_rt_priority" , & bfd_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( "bfd_rlimit_rtime" , & bfd_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_SNMP_ install_keyword ( "snmp_socket" , & snmp_socket_handler ) ; install_keyword ( "enable_traps" , & trap_handler ) ; # ifdef _WITH_SNMP_VRRP_ install_keyword ( "enable_snmp_vrrp" , & snmp_vrrp_handler ) ; install_keyword ( "enable_snmp_keepalived" , & snmp_vrrp_handler ) ; # endif # ifdef _WITH_SNMP_RFC_ install_keyword ( "enable_snmp_rfc" , & snmp_rfc_handler ) ; # endif # ifdef _WITH_SNMP_RFCV2_ install_keyword ( "enable_snmp_rfcv2" , & snmp_rfcv2_handler ) ; # endif # ifdef _WITH_SNMP_RFCV3_ install_keyword ( "enable_snmp_rfcv3" , & snmp_rfcv3_handler ) ; # endif # ifdef _WITH_SNMP_CHECKER_ install_keyword ( "enable_snmp_checker" , & snmp_checker_handler ) ; # endif # endif # ifdef _WITH_DBUS_ install_keyword ( "enable_dbus" , & enable_dbus_handler ) ; install_keyword ( "dbus_service_name" , & dbus_service_name_handler ) ; # endif install_keyword ( "script_user" , & script_user_handler ) ; install_keyword ( "enable_script_security" , & script_security_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( "vrrp_netlink_cmd_rcv_bufs" , & vrrp_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( "vrrp_netlink_cmd_rcv_bufs_force" , & vrrp_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( "vrrp_netlink_monitor_rcv_bufs" , & vrrp_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( "vrrp_netlink_monitor_rcv_bufs_force" , & vrrp_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "lvs_netlink_cmd_rcv_bufs" , & lvs_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( "lvs_netlink_cmd_rcv_bufs_force" , & lvs_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( "lvs_netlink_monitor_rcv_bufs" , & lvs_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( "lvs_netlink_monitor_rcv_bufs_force" , & lvs_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( "rs_init_notifies" , & rs_init_notifies_handler ) ; install_keyword ( "no_checker_emails" , & no_checker_emails_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( "vrrp_rx_bufs_policy" , & vrrp_rx_bufs_policy_handler ) ; install_keyword ( "vrrp_rx_bufs_multiplier" , & vrrp_rx_bufs_multiplier_handler ) ; # endif <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static guint32 parse_wbxml_attribute_list ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> guint32 len ; guint str_len ; guint32 ent ; guint32 idx ; guint8 peek ; <S2SV_StartBug> DebugLog ( ( "parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n" , level , offset ) ) ; <S2SV_EndBug> while ( off < tvb_len ) { peek = tvb_get_guint8 ( tvb , off ) ; DebugLog ( ( "ATTR:<S2SV_blank>(top<S2SV_blank>of<S2SV_blank>while)<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%3u,<S2SV_blank>peek<S2SV_blank>=<S2SV_blank>0x%02X,<S2SV_blank>" "off<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>tvb_len<S2SV_blank>=<S2SV_blank>%u\\n" , level , peek , off , tvb_len ) ) ; if ( ( peek & 0x3F ) < 5 ) switch ( peek ) { case 0x00 : * codepage_attr = tvb_get_guint8 ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 2 , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>-->%3d<S2SV_blank>" "|<S2SV_blank>SWITCH_PAGE<S2SV_blank>(Attr<S2SV_blank>code<S2SV_blank>page)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|" , * codepage_attr ) ; off += 2 ; break ; case 0x01 : off ++ ; DebugLog ( ( "ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n" , level , off - offset ) ) ; return ( off - offset ) ; case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>ENTITY<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\'&#%u;\'" , level , * codepage_attr , Indent ( level ) , ent ) ; off += 1 + len ; break ; case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>STR_I<S2SV_blank>(Inline<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x04 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>LITERAL<S2SV_blank>(Literal<S2SV_blank>Attribute)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank>%s<%s<S2SV_blank>/>" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>EXT_I_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Inline<S2SV_blank>string<S2SV_blank>extension:<S2SV_blank>\\\'%s\\\')" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>EXT_T_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Extension<S2SV_blank>Token,<S2SV_blank>integer<S2SV_blank>value:<S2SV_blank>%u)" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , idx ) ; off += 1 + len ; break ; case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>STR_T<S2SV_blank>(Tableref<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>EXT_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Single-byte<S2SV_blank>extension)" , level , * codepage_attr , peek & 0x0f , Indent ( level ) ) ; off ++ ; break ; case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) { idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len + idx , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>OPAQUE<S2SV_blank>(Opaque<S2SV_blank>data)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>opaque<S2SV_blank>data)" , level , * codepage_attr , Indent ( level ) , idx ) ; off += 1 + len + idx ; } else { proto_tree_add_text ( tree , tvb , off , 1 , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>RESERVED_2<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>" "|<S2SV_blank>WBXML<S2SV_blank>1.0<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here." , level , * codepage_attr ) ; off = tvb_len ; DebugLog ( ( "ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n" , level , off - offset ) ) ; return ( off - offset ) ; } break ; default : proto_tree_add_text ( tree , tvb , off , 1 , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank>%-10s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>" "|<S2SV_blank>WBXML<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here." , level , * codepage_attr , val_to_str_ext ( peek , & vals_wbxml1x_global_tokens_ext , "(unknown<S2SV_blank>0x%x)" ) ) ; off = tvb_len ; break ; } else { if ( peek & 0x80 ) { proto_tree_add_text ( tree , tvb , off , 1 , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrValue<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%sattrValue_0x%02X" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , peek ) ; off ++ ; } else { proto_tree_add_text ( tree , tvb , off , 1 , "<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrStart<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "|<S2SV_blank><S2SV_blank><S2SV_blank>%sattrStart_0x%02X" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , peek ) ; off ++ ; } } <S2SV_StartBug> } <S2SV_EndBug> DebugLog ( ( "ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\n" , level , off - offset ) ) ; return ( off - offset ) ; }
CWE-787 void pdf_load_pages_kids ( FILE * fp , pdf_t * pdf ) { int i , id , dummy ; char * buf , * c ; long start , sz ; start = ftell ( fp ) ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . version && ( pdf -> xrefs [ i ] . end != 0 ) ) { fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; while ( SAFE_F ( fp , ( fgetc ( fp ) != 't' ) ) ) ; sz = pdf -> xrefs [ i ] . end - ftell ( fp ) ; <S2SV_StartBug> buf = malloc ( sz + 1 ) ; <S2SV_EndBug> SAFE_E ( fread ( buf , 1 , sz , fp ) , sz , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>/Root.\\n" ) ; buf [ sz ] = '\\0' ; if ( ! ( c = strstr ( buf , "/Root" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( "/Root" ) + 1 ) ; free ( buf ) ; buf = get_object ( fp , id , & pdf -> xrefs [ i ] , NULL , & dummy ) ; if ( ! buf || ! ( c = strstr ( buf , "/Pages" ) ) ) { free ( buf ) ; continue ; } id = atoi ( c + strlen ( "/Pages" ) + 1 ) ; load_kids ( fp , id , & pdf -> xrefs [ i ] ) ; free ( buf ) ; } } fseek ( fp , start , SEEK_SET ) ; }
CWE-119 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
CWE-399 long vhost_dev_ioctl ( struct vhost_dev * d , unsigned int ioctl , void __user * argp ) { struct file * eventfp , * filep = NULL ; struct eventfd_ctx * ctx = NULL ; u64 p ; long r ; int i , fd ; if ( ioctl == VHOST_SET_OWNER ) { r = vhost_dev_set_owner ( d ) ; goto done ; } r = vhost_dev_check_owner ( d ) ; if ( r ) goto done ; switch ( ioctl ) { case VHOST_SET_MEM_TABLE : r = vhost_set_memory ( d , argp ) ; break ; case VHOST_SET_LOG_BASE : if ( copy_from_user ( & p , argp , sizeof p ) ) { r = - EFAULT ; break ; } if ( ( u64 ) ( unsigned long ) p != p ) { r = - EFAULT ; break ; } for ( i = 0 ; i < d -> nvqs ; ++ i ) { struct vhost_virtqueue * vq ; void __user * base = ( void __user * ) ( unsigned long ) p ; vq = d -> vqs [ i ] ; mutex_lock ( & vq -> mutex ) ; if ( vq -> private_data && ! vq_log_access_ok ( vq , base ) ) r = - EFAULT ; else vq -> log_base = base ; mutex_unlock ( & vq -> mutex ) ; } break ; case VHOST_SET_LOG_FD : r = get_user ( fd , ( int __user * ) argp ) ; if ( r < 0 ) break ; eventfp = fd == - 1 ? NULL : eventfd_fget ( fd ) ; if ( IS_ERR ( eventfp ) ) { r = PTR_ERR ( eventfp ) ; break ; } if ( eventfp != d -> log_file ) { filep = d -> log_file ; <S2SV_StartBug> ctx = d -> log_ctx ; <S2SV_EndBug> d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ; } else filep = eventfp ; for ( i = 0 ; i < d -> nvqs ; ++ i ) { mutex_lock ( & d -> vqs [ i ] -> mutex ) ; d -> vqs [ i ] -> log_ctx = d -> log_ctx ; mutex_unlock ( & d -> vqs [ i ] -> mutex ) ; } if ( ctx ) eventfd_ctx_put ( ctx ) ; if ( filep ) fput ( filep ) ; break ; default : r = - ENOIOCTLCMD ; break ; } done : return r ; }
CWE-000 static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , struct dentry * dentry , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { int retval ; struct posix_acl * acl ; struct v9fs_session_info * v9ses ; v9ses = v9fs_dentry2v9ses ( dentry ) ; if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) return v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( value ) { acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; if ( IS_ERR ( acl ) ) return PTR_ERR ( acl ) ; else if ( acl ) { retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; if ( retval ) goto err_out ; } } else acl = NULL ; switch ( handler -> flags ) { case ACL_TYPE_ACCESS : if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> retval = posix_acl_equiv_mode ( acl , & mode ) ; if ( retval < 0 ) goto err_out ; <S2SV_StartBug> else { <S2SV_EndBug> struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ; iattr . ia_valid = ATTR_MODE ; v9fs_vfs_setattr_dotl ( dentry , & iattr ) ; <S2SV_StartBug> } <S2SV_EndBug> } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { retval = acl ? - EINVAL : 0 ; goto err_out ; } break ; default : BUG ( ) ; } retval = v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( ! retval ) set_cached_acl ( inode , handler -> flags , acl ) ; err_out : posix_acl_release ( acl ) ; return retval ; }
CWE-119 static bool check_underflow ( const struct arpt_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> arp ) ) <S2SV_EndBug> return false ; t = arpt_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }
CWE-20 key_ref_t lookup_user_key ( key_serial_t id , unsigned long lflags , key_perm_t perm ) { struct keyring_search_context ctx = { . match_data . cmp = lookup_user_key_possessed , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_NO_STATE_CHECK , } ; struct request_key_auth * rka ; struct key * key ; key_ref_t key_ref , skey_ref ; int ret ; try_again : ctx . cred = get_current_cred ( ) ; key_ref = ERR_PTR ( - ENOKEY ) ; switch ( id ) { case KEY_SPEC_THREAD_KEYRING : if ( ! ctx . cred -> thread_keyring ) { if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) goto error ; ret = install_thread_keyring ( ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error ; } goto reget_creds ; } key = ctx . cred -> thread_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_PROCESS_KEYRING : if ( ! ctx . cred -> process_keyring ) { if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) goto error ; ret = install_process_keyring ( ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error ; } goto reget_creds ; } key = ctx . cred -> process_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_SESSION_KEYRING : if ( ! ctx . cred -> session_keyring ) { ret = install_user_keyrings ( ) ; if ( ret < 0 ) goto error ; if ( lflags & KEY_LOOKUP_CREATE ) ret = join_session_keyring ( NULL ) ; else ret = install_session_keyring ( ctx . cred -> user -> session_keyring ) ; if ( ret < 0 ) goto error ; goto reget_creds ; } else if ( ctx . cred -> session_keyring == ctx . cred -> user -> session_keyring && lflags & KEY_LOOKUP_CREATE ) { ret = join_session_keyring ( NULL ) ; if ( ret < 0 ) goto error ; goto reget_creds ; } rcu_read_lock ( ) ; key = rcu_dereference ( ctx . cred -> session_keyring ) ; __key_get ( key ) ; rcu_read_unlock ( ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_USER_KEYRING : if ( ! ctx . cred -> user -> uid_keyring ) { ret = install_user_keyrings ( ) ; if ( ret < 0 ) goto error ; } key = ctx . cred -> user -> uid_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_USER_SESSION_KEYRING : if ( ! ctx . cred -> user -> session_keyring ) { ret = install_user_keyrings ( ) ; if ( ret < 0 ) goto error ; } key = ctx . cred -> user -> session_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_GROUP_KEYRING : key_ref = ERR_PTR ( - EINVAL ) ; goto error ; case KEY_SPEC_REQKEY_AUTH_KEY : key = ctx . cred -> request_key_auth ; if ( ! key ) goto error ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_REQUESTOR_KEYRING : if ( ! ctx . cred -> request_key_auth ) goto error ; down_read ( & ctx . cred -> request_key_auth -> sem ) ; if ( test_bit ( KEY_FLAG_REVOKED , & ctx . cred -> request_key_auth -> flags ) ) { key_ref = ERR_PTR ( - EKEYREVOKED ) ; key = NULL ; } else { rka = ctx . cred -> request_key_auth -> payload . data [ 0 ] ; key = rka -> dest_keyring ; __key_get ( key ) ; } up_read ( & ctx . cred -> request_key_auth -> sem ) ; if ( ! key ) goto error ; key_ref = make_key_ref ( key , 1 ) ; break ; default : key_ref = ERR_PTR ( - EINVAL ) ; if ( id < 1 ) goto error ; key = key_lookup ( id ) ; if ( IS_ERR ( key ) ) { key_ref = ERR_CAST ( key ) ; goto error ; } key_ref = make_key_ref ( key , 0 ) ; ctx . index_key . type = key -> type ; ctx . index_key . description = key -> description ; ctx . index_key . desc_len = strlen ( key -> description ) ; ctx . match_data . raw_data = key ; kdebug ( "check<S2SV_blank>possessed" ) ; skey_ref = search_process_keyrings ( & ctx ) ; kdebug ( "possessed=%p" , skey_ref ) ; if ( ! IS_ERR ( skey_ref ) ) { key_put ( key ) ; key_ref = skey_ref ; } break ; } if ( lflags & KEY_LOOKUP_FOR_UNLINK ) { ret = 0 ; goto error ; } if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) ) { ret = wait_for_key_construction ( key , true ) ; switch ( ret ) { case - ERESTARTSYS : goto invalid_key ; default : if ( perm ) goto invalid_key ; case 0 : break ; } } else if ( perm ) { ret = key_validate ( key ) ; if ( ret < 0 ) goto invalid_key ; } ret = - EIO ; if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && <S2SV_StartBug> ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> goto invalid_key ; ret = key_task_permission ( key_ref , ctx . cred , perm ) ; if ( ret < 0 ) goto invalid_key ; key -> last_used_at = current_kernel_time ( ) . tv_sec ; error : put_cred ( ctx . cred ) ; return key_ref ; invalid_key : key_ref_put ( key_ref ) ; key_ref = ERR_PTR ( ret ) ; goto error ; reget_creds : put_cred ( ctx . cred ) ; goto try_again ; }
CWE-284 static int tap_if_down ( const char * devname ) { struct ifreq ifr ; int sk ; sk = socket ( AF_INET , SOCK_DGRAM , 0 ) ; if ( sk < 0 ) return - 1 ; memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IF_NAMESIZE - 1 ) ; ifr . ifr_flags &= ~ IFF_UP ; <S2SV_StartBug> ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug> close ( sk ) ; return 0 ; }
CWE-119 static int evaluate_inter_mode_rd ( int mdcounts [ 4 ] , RATE_DISTORTION * rd , int * disable_skip , VP8_COMP * cpi , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int distortion ; vp8_build_inter16x16_predictors_mby ( & x -> e_mbd , x -> e_mbd . predictor , 16 ) ; if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { x -> skip = 1 ; } else if ( x -> encode_breakout ) { unsigned int sse ; unsigned int var ; unsigned int threshold = ( xd -> block [ 0 ] . dequant [ 1 ] * xd -> block [ 0 ] . dequant [ 1 ] >> 4 ) ; if ( threshold < x -> encode_breakout ) threshold = x -> encode_breakout ; <S2SV_StartBug> var = vp8_variance16x16 <S2SV_EndBug> ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; if ( sse < threshold ) { unsigned int q2dc = xd -> block [ 24 ] . dequant [ 0 ] ; if ( ( sse - var < q2dc * q2dc >> 4 ) || ( sse / 2 > var && sse - var < 64 ) ) { unsigned int sse2 = VP8_UVSSE ( x ) ; if ( sse2 * 2 < threshold ) { x -> skip = 1 ; rd -> distortion2 = sse + sse2 ; rd -> rate2 = 500 ; rd -> rate_uv = 0 ; rd -> distortion_uv = sse2 ; * disable_skip = 1 ; return RDCOST ( x -> rdmult , x -> rddiv , rd -> rate2 , rd -> distortion2 ) ; } } } } rd -> rate2 += vp8_cost_mv_ref ( this_mode , mdcounts ) ; macro_block_yrd ( x , & rd -> rate_y , & distortion ) ; rd -> rate2 += rd -> rate_y ; rd -> distortion2 += distortion ; rd_inter16x16_uv ( cpi , x , & rd -> rate_uv , & rd -> distortion_uv , cpi -> common . full_pixel ) ; rd -> rate2 += rd -> rate_uv ; rd -> distortion2 += rd -> distortion_uv ; return INT_MAX ; }
CWE-362 static int ext4_split_unwritten_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len ; int split_flag = 0 , depth ; ext_debug ( "ext4_split_unwritten_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical" "block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; <S2SV_StartBug> flags |= EXT4_GET_BLOCKS_PRE_IO ; <S2SV_EndBug> return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ; }
CWE-476 static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i + 47 >= dctx -> remaining ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; return END_NOT_FOUND ; }
CWE-264 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent * extent = NULL ; unsigned long page = 0 ; char * kbuf , * pos , * next_line ; ssize_t ret = - EINVAL ; mutex_lock ( & id_map_mutex ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! ns_capable ( ns , cap_setid ) ) goto out ; ret = - ENOMEM ; page = __get_free_page ( GFP_TEMPORARY ) ; kbuf = ( char * ) page ; if ( ! page ) goto out ; ret = - EINVAL ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) goto out ; ret = - EFAULT ; if ( copy_from_user ( kbuf , buf , count ) ) goto out ; kbuf [ count ] = '\\0' ; ret = - EINVAL ; pos = kbuf ; new_map . nr_extents = 0 ; for ( ; pos ; pos = next_line ) { extent = & new_map . extent [ new_map . nr_extents ] ; next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent -> first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent -> lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent -> count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent -> first == ( u32 ) - 1 ) || ( extent -> lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent -> first + extent -> count ) <= extent -> first ) goto out ; if ( ( extent -> lower_first + extent -> count ) <= extent -> lower_first ) goto out ; if ( mappings_overlap ( & new_map , extent ) ) goto out ; new_map . nr_extents ++ ; if ( ( new_map . nr_extents == UID_GID_MAP_MAX_EXTENTS ) && ( next_line != NULL ) ) goto out ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { u32 lower_first ; extent = & new_map . extent [ idx ] ; lower_first = map_id_range_down ( parent_map , extent -> lower_first , extent -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; extent -> lower_first = lower_first ; } memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : mutex_unlock ( & id_map_mutex ) ; if ( page ) free_page ( page ) ; return ret ; }
CWE-119 vpx_codec_err_t vpx_codec_get_stream_info ( vpx_codec_ctx_t * ctx , vpx_codec_stream_info_t * si ) { vpx_codec_err_t res ; if ( ! ctx || ! si || si -> sz < sizeof ( vpx_codec_stream_info_t ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { si -> w = 0 ; si -> h = 0 ; <S2SV_StartBug> res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ; <S2SV_EndBug> } return SAVE_STATUS ( ctx , res ) ; }
CWE-264 static ssize_t qib_write ( struct file * fp , const char __user * data , size_t count , loff_t * off ) { const struct qib_cmd __user * ucmd ; struct qib_ctxtdata * rcd ; const void __user * src ; size_t consumed , copy = 0 ; struct qib_cmd cmd ; ssize_t ret = 0 ; void * dest ; <S2SV_StartBug> if ( count < sizeof ( cmd . type ) ) { <S2SV_EndBug> ret = - EINVAL ; goto bail ; } ucmd = ( const struct qib_cmd __user * ) data ; if ( copy_from_user ( & cmd . type , & ucmd -> type , sizeof ( cmd . type ) ) ) { ret = - EFAULT ; goto bail ; } consumed = sizeof ( cmd . type ) ; switch ( cmd . type ) { case QIB_CMD_ASSIGN_CTXT : case QIB_CMD_USER_INIT : copy = sizeof ( cmd . cmd . user_info ) ; dest = & cmd . cmd . user_info ; src = & ucmd -> cmd . user_info ; break ; case QIB_CMD_RECV_CTRL : copy = sizeof ( cmd . cmd . recv_ctrl ) ; dest = & cmd . cmd . recv_ctrl ; src = & ucmd -> cmd . recv_ctrl ; break ; case QIB_CMD_CTXT_INFO : copy = sizeof ( cmd . cmd . ctxt_info ) ; dest = & cmd . cmd . ctxt_info ; src = & ucmd -> cmd . ctxt_info ; break ; case QIB_CMD_TID_UPDATE : case QIB_CMD_TID_FREE : copy = sizeof ( cmd . cmd . tid_info ) ; dest = & cmd . cmd . tid_info ; src = & ucmd -> cmd . tid_info ; break ; case QIB_CMD_SET_PART_KEY : copy = sizeof ( cmd . cmd . part_key ) ; dest = & cmd . cmd . part_key ; src = & ucmd -> cmd . part_key ; break ; case QIB_CMD_DISARM_BUFS : case QIB_CMD_PIOAVAILUPD : copy = 0 ; src = NULL ; dest = NULL ; break ; case QIB_CMD_POLL_TYPE : copy = sizeof ( cmd . cmd . poll_type ) ; dest = & cmd . cmd . poll_type ; src = & ucmd -> cmd . poll_type ; break ; case QIB_CMD_ARMLAUNCH_CTRL : copy = sizeof ( cmd . cmd . armlaunch_ctrl ) ; dest = & cmd . cmd . armlaunch_ctrl ; src = & ucmd -> cmd . armlaunch_ctrl ; break ; case QIB_CMD_SDMA_INFLIGHT : copy = sizeof ( cmd . cmd . sdma_inflight ) ; dest = & cmd . cmd . sdma_inflight ; src = & ucmd -> cmd . sdma_inflight ; break ; case QIB_CMD_SDMA_COMPLETE : copy = sizeof ( cmd . cmd . sdma_complete ) ; dest = & cmd . cmd . sdma_complete ; src = & ucmd -> cmd . sdma_complete ; break ; case QIB_CMD_ACK_EVENT : copy = sizeof ( cmd . cmd . event_mask ) ; dest = & cmd . cmd . event_mask ; src = & ucmd -> cmd . event_mask ; break ; default : ret = - EINVAL ; goto bail ; } if ( copy ) { if ( ( count - consumed ) < copy ) { ret = - EINVAL ; goto bail ; } if ( copy_from_user ( dest , src , copy ) ) { ret = - EFAULT ; goto bail ; } consumed += copy ; } rcd = ctxt_fp ( fp ) ; if ( ! rcd && cmd . type != QIB_CMD_ASSIGN_CTXT ) { ret = - EINVAL ; goto bail ; } switch ( cmd . type ) { case QIB_CMD_ASSIGN_CTXT : ret = qib_assign_ctxt ( fp , & cmd . cmd . user_info ) ; if ( ret ) goto bail ; break ; case QIB_CMD_USER_INIT : ret = qib_do_user_init ( fp , & cmd . cmd . user_info ) ; if ( ret ) goto bail ; ret = qib_get_base_info ( fp , ( void __user * ) ( unsigned long ) cmd . cmd . user_info . spu_base_info , cmd . cmd . user_info . spu_base_info_size ) ; break ; case QIB_CMD_RECV_CTRL : ret = qib_manage_rcvq ( rcd , subctxt_fp ( fp ) , cmd . cmd . recv_ctrl ) ; break ; case QIB_CMD_CTXT_INFO : ret = qib_ctxt_info ( fp , ( struct qib_ctxt_info __user * ) ( unsigned long ) cmd . cmd . ctxt_info ) ; break ; case QIB_CMD_TID_UPDATE : ret = qib_tid_update ( rcd , fp , & cmd . cmd . tid_info ) ; break ; case QIB_CMD_TID_FREE : ret = qib_tid_free ( rcd , subctxt_fp ( fp ) , & cmd . cmd . tid_info ) ; break ; case QIB_CMD_SET_PART_KEY : ret = qib_set_part_key ( rcd , cmd . cmd . part_key ) ; break ; case QIB_CMD_DISARM_BUFS : ( void ) qib_disarm_piobufs_ifneeded ( rcd ) ; ret = disarm_req_delay ( rcd ) ; break ; case QIB_CMD_PIOAVAILUPD : qib_force_pio_avail_update ( rcd -> dd ) ; break ; case QIB_CMD_POLL_TYPE : rcd -> poll_type = cmd . cmd . poll_type ; break ; case QIB_CMD_ARMLAUNCH_CTRL : rcd -> dd -> f_set_armlaunch ( rcd -> dd , cmd . cmd . armlaunch_ctrl ) ; break ; case QIB_CMD_SDMA_INFLIGHT : ret = qib_sdma_get_inflight ( user_sdma_queue_fp ( fp ) , ( u32 __user * ) ( unsigned long ) cmd . cmd . sdma_inflight ) ; break ; case QIB_CMD_SDMA_COMPLETE : ret = qib_sdma_get_complete ( rcd -> ppd , user_sdma_queue_fp ( fp ) , ( u32 __user * ) ( unsigned long ) cmd . cmd . sdma_complete ) ; break ; case QIB_CMD_ACK_EVENT : ret = qib_user_event_ack ( rcd , subctxt_fp ( fp ) , cmd . cmd . event_mask ) ; break ; } if ( ret >= 0 ) ret = consumed ; bail : return ret ; }
CWE-399 static int cuse_channel_release ( struct inode * inode , struct file * file ) { struct fuse_dev * fud = file -> private_data ; struct cuse_conn * cc = fc_to_cc ( fud -> fc ) ; int rc ; mutex_lock ( & cuse_lock ) ; list_del_init ( & cc -> list ) ; mutex_unlock ( & cuse_lock ) ; if ( cc -> dev ) device_unregister ( cc -> dev ) ; if ( cc -> cdev ) { unregister_chrdev_region ( cc -> cdev -> dev , 1 ) ; cdev_del ( cc -> cdev ) ; } <S2SV_StartBug> rc = fuse_dev_release ( inode , file ) ; <S2SV_EndBug> return rc ; }
CWE-119 static long ioctl_file_dedupe_range ( struct file * file , void __user * arg ) { struct file_dedupe_range __user * argp = arg ; struct file_dedupe_range * same = NULL ; int ret ; unsigned long size ; u16 count ; if ( get_user ( count , & argp -> dest_count ) ) { ret = - EFAULT ; goto out ; } size = offsetof ( struct file_dedupe_range __user , info [ count ] ) ; same = memdup_user ( argp , size ) ; if ( IS_ERR ( same ) ) { ret = PTR_ERR ( same ) ; same = NULL ; goto out ; } <S2SV_StartBug> ret = vfs_dedupe_file_range ( file , same ) ; <S2SV_EndBug> if ( ret ) goto out ; ret = copy_to_user ( argp , same , size ) ; if ( ret ) ret = - EFAULT ; out : kfree ( same ) ; return ret ; }
CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; return ( * field_rtrn != NULL ) ; case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; <S2SV_StartBug> return true ; <S2SV_EndBug> default : break ; } log_wsgo ( ctx , "Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n" , expr -> expr . op ) ; return false ; }
CWE-264 static void setup_test_dir ( char * tmp_dir , const char * files , ... ) { va_list ap ; assert_se ( mkdtemp ( tmp_dir ) != NULL ) ; va_start ( ap , files ) ; while ( files != NULL ) { _cleanup_free_ char * path = strappend ( tmp_dir , files ) ; <S2SV_StartBug> assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ; <S2SV_EndBug> files = va_arg ( ap , const char * ) ; } va_end ( ap ) ; }
CWE-125 static int uas_switch_interface ( struct usb_device * udev , struct usb_interface * intf ) { <S2SV_StartBug> int alt ; <S2SV_EndBug> alt = uas_find_uas_alt_setting ( intf ) ; <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> return alt ; return usb_set_interface ( udev , <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> }
CWE-000 err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return "2" "exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( "verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( "pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return "3" "SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out" ; } <S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> return NULL ; }
CWE-119 static inline struct futex_hash_bucket * queue_lock ( struct futex_q * q ) { <S2SV_StartBug> struct futex_hash_bucket * hb ; <S2SV_EndBug> get_futex_key_refs ( & q -> key ) ; hb = hash_futex ( & q -> key ) ; q -> lock_ptr = & hb -> lock ; spin_lock ( & hb -> lock ) ; return hb ; }
CWE-000 void * _TIFFmalloc ( tmsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
CWE-119 <S2SV_StartBug> static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , <S2SV_EndBug> int mi_row , int mi_col ) { <S2SV_StartBug> unsigned int var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb , <S2SV_EndBug> mi_row , mi_col , BLOCK_64X64 ) ; if ( var < 8 ) return BLOCK_64X64 ; else if ( var < 128 ) return BLOCK_32X32 ; else if ( var < 2048 ) return BLOCK_16X16 ; else return BLOCK_8X8 ; }
CWE-000 <S2SV_StartBug> WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec , <S2SV_EndBug> UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num ) { dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; <S2SV_StartBug> WORD32 ret ; <S2SV_EndBug> ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } } H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ret = ih264d_end_of_pic_processing ( ps_dec ) ; if ( ret != OK ) return ret ; <S2SV_StartBug> ps_dec -> u2_total_mbs_coded = 0 ; <S2SV_EndBug> { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ret = ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; if ( ret != OK ) return ret ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } } H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }
CWE-119 int vp8_yv12_de_alloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf ) { if ( ybf ) { if ( ybf -> buffer_alloc_sz > 0 ) { vpx_free ( ybf -> buffer_alloc ) ; } <S2SV_StartBug> vpx_memset ( ybf , 0 , sizeof ( YV12_BUFFER_CONFIG ) ) ; <S2SV_EndBug> } else { return - 1 ; } return 0 ; }
CWE-000 static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! * path ) path = "INBOX" ; <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
CWE-200 static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; BT_DBG ( "" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - EFAULT ; if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) return - EINVAL ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; <S2SV_StartBug> dl = kmalloc ( size , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! dl ) return - ENOMEM ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof ( * dl ) + n * sizeof ( * di ) ; err = copy_to_user ( arg , dl , size ) ; kfree ( dl ) ; return err ? - EFAULT : 0 ; }
CWE-20 <S2SV_StartBug> static int enable ( void ) { <S2SV_EndBug> <S2SV_StartBug> LOG_INFO ( "%s" , __func__ ) ; <S2SV_EndBug> if ( ! interface_ready ( ) ) return BT_STATUS_NOT_READY ; stack_manager_get_interface ( ) -> start_up_stack_async ( ) ; return BT_STATUS_SUCCESS ; }
CWE-119 <S2SV_StartBug> static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) { <S2SV_EndBug> if ( svc_ctx == NULL ) return NULL ; <S2SV_StartBug> return ( const SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> }
CWE-119 static void encode_block_pass1 ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { MACROBLOCK * const x = ( MACROBLOCK * ) arg ; MACROBLOCKD * const xd = & x -> e_mbd ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> int i , j ; uint8_t * dst ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ; vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; if ( p -> eobs [ block ] > 0 ) <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> }
CWE-362 static int newque ( struct ipc_namespace * ns , struct ipc_params * params ) { struct msg_queue * msq ; int id , retval ; key_t key = params -> key ; int msgflg = params -> flg ; msq = ipc_rcu_alloc ( sizeof ( * msq ) ) ; if ( ! msq ) return - ENOMEM ; msq -> q_perm . mode = msgflg & S_IRWXUGO ; msq -> q_perm . key = key ; msq -> q_perm . security = NULL ; retval = security_msg_queue_alloc ( msq ) ; if ( retval ) { ipc_rcu_putref ( msq , ipc_rcu_free ) ; return retval ; } <S2SV_StartBug> id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; <S2SV_EndBug> if ( id < 0 ) { ipc_rcu_putref ( msq , msg_rcu_free ) ; return id ; } <S2SV_StartBug> msq -> q_stime = msq -> q_rtime = 0 ; <S2SV_EndBug> msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; ipc_unlock_object ( & msq -> q_perm ) ; rcu_read_unlock ( ) ; return msq -> q_perm . id ; }
CWE-416 int __mdiobus_register ( struct mii_bus * bus , struct module * owner ) { struct mdio_device * mdiodev ; int i , err ; struct gpio_desc * gpiod ; if ( NULL == bus || NULL == bus -> name || NULL == bus -> read || NULL == bus -> write ) return - EINVAL ; BUG_ON ( bus -> state != MDIOBUS_ALLOCATED && bus -> state != MDIOBUS_UNREGISTERED ) ; bus -> owner = owner ; bus -> dev . parent = bus -> parent ; bus -> dev . class = & mdio_bus_class ; bus -> dev . groups = NULL ; dev_set_name ( & bus -> dev , "%s" , bus -> id ) ; err = device_register ( & bus -> dev ) ; if ( err ) { pr_err ( "mii_bus<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register\\n" , bus -> id ) ; <S2SV_StartBug> put_device ( & bus -> dev ) ; <S2SV_EndBug> return - EINVAL ; } mutex_init ( & bus -> mdio_lock ) ; gpiod = devm_gpiod_get_optional ( & bus -> dev , "reset" , GPIOD_OUT_LOW ) ; if ( IS_ERR ( gpiod ) ) { dev_err ( & bus -> dev , "mii_bus<S2SV_blank>%s<S2SV_blank>couldn\'t<S2SV_blank>get<S2SV_blank>reset<S2SV_blank>GPIO\\n" , bus -> id ) ; device_del ( & bus -> dev ) ; return PTR_ERR ( gpiod ) ; } else if ( gpiod ) { bus -> reset_gpiod = gpiod ; gpiod_set_value_cansleep ( gpiod , 1 ) ; udelay ( bus -> reset_delay_us ) ; gpiod_set_value_cansleep ( gpiod , 0 ) ; } if ( bus -> reset ) bus -> reset ( bus ) ; for ( i = 0 ; i < PHY_MAX_ADDR ; i ++ ) { if ( ( bus -> phy_mask & ( 1 << i ) ) == 0 ) { struct phy_device * phydev ; phydev = mdiobus_scan ( bus , i ) ; if ( IS_ERR ( phydev ) && ( PTR_ERR ( phydev ) != - ENODEV ) ) { err = PTR_ERR ( phydev ) ; goto error ; } } } mdiobus_setup_mdiodev_from_board_info ( bus , mdiobus_create_device ) ; bus -> state = MDIOBUS_REGISTERED ; pr_info ( "%s:<S2SV_blank>probed\\n" , bus -> name ) ; return 0 ; error : while ( -- i >= 0 ) { mdiodev = bus -> mdio_map [ i ] ; if ( ! mdiodev ) continue ; mdiodev -> device_remove ( mdiodev ) ; mdiodev -> device_free ( mdiodev ) ; } if ( bus -> reset_gpiod ) gpiod_set_value_cansleep ( bus -> reset_gpiod , 1 ) ; device_del ( & bus -> dev ) ; return err ; }
CWE-000 <S2SV_StartBug> static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <S2SV_EndBug> { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; <S2SV_StartBug> kenter ( "%p" , dest_keyring ) ; <S2SV_EndBug> if ( dest_keyring ) { key_get ( dest_keyring ) ; <S2SV_StartBug> } else { <S2SV_EndBug> switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <S2SV_StartBug> break ; <S2SV_EndBug> } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } <S2SV_StartBug> } <S2SV_EndBug> * _dest_keyring = dest_keyring ; kleave ( "<S2SV_blank>[dk<S2SV_blank>%d]" , key_serial ( dest_keyring ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> }
CWE-119 IHEVCD_ERROR_T ihevcd_cabac_init ( cab_ctxt_t * ps_cabac , bitstrm_t * ps_bitstrm , WORD32 qp , WORD32 cabac_init_idc , const UWORD8 * pu1_init_ctxt ) { ASSERT ( ps_cabac != NULL ) ; ASSERT ( ps_bitstrm != NULL ) ; ASSERT ( ( qp >= 0 ) && ( qp < 52 ) ) ; ASSERT ( ( cabac_init_idc >= 0 ) && ( cabac_init_idc < 3 ) ) ; UNUSED ( qp ) ; UNUSED ( cabac_init_idc ) ; # if FULLRANGE ps_cabac -> u4_range = ( UWORD32 ) 510 << RANGE_SHIFT ; BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , ( 9 + RANGE_SHIFT ) ) ; # else ps_cabac -> u4_range = ( UWORD32 ) 510 ; BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , 9 ) ; # endif memcpy ( ps_cabac -> au1_ctxt_models , pu1_init_ctxt , IHEVC_CAB_CTXT_END ) ; DEBUG_RANGE_OFST ( "init" , ps_cabac -> u4_range , ps_cabac -> u4_ofst ) ; <S2SV_StartBug> return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ; <S2SV_EndBug> }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { unsigned x , y ; AVFilterContext * ctx = inlink -> dst ; VignetteContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( s -> eval_mode == EVAL_MODE_FRAME ) update_context ( s , inlink , in ) ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_RGB ) { uint8_t * dst = out -> data [ 0 ] ; const uint8_t * src = in -> data [ 0 ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ 0 ] ; const int src_linesize = in -> linesize [ 0 ] ; const int fmap_linesize = s -> fmap_linesize ; for ( y = 0 ; y < inlink -> h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < inlink -> w ; x ++ , dstp += 3 , srcp += 3 ) { const float f = fmap [ x ] ; dstp [ 0 ] = av_clip_uint8 ( srcp [ 0 ] * f + get_dither_value ( s ) ) ; dstp [ 1 ] = av_clip_uint8 ( srcp [ 1 ] * f + get_dither_value ( s ) ) ; dstp [ 2 ] = av_clip_uint8 ( srcp [ 2 ] * f + get_dither_value ( s ) ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize ; } } else { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> uint8_t * dst = out -> data [ plane ] ; const uint8_t * src = in -> data [ plane ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ plane ] ; const int src_linesize = in -> linesize [ plane ] ; const int fmap_linesize = s -> fmap_linesize ; const int chroma = plane == 1 || plane == 2 ; const int hsub = chroma ? s -> desc -> log2_chroma_w : 0 ; const int vsub = chroma ? s -> desc -> log2_chroma_h : 0 ; const int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; const int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; for ( y = 0 ; y < h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < w ; x ++ ) { const double dv = get_dither_value ( s ) ; if ( chroma ) * dstp ++ = av_clip_uint8 ( fmap [ x << hsub ] * ( * srcp ++ - 127 ) + 127 + dv ) ; else * dstp ++ = av_clip_uint8 ( fmap [ x ] * * srcp ++ + dv ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize << vsub ; } } } return ff_filter_frame ( outlink , out ) ; }
CWE-119 static int atusb_get_and_show_revision ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ; <S2SV_StartBug> unsigned char buffer [ 3 ] ; <S2SV_EndBug> int ret ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_ID , ATUSB_REQ_FROM_DEV , 0 , 0 , buffer , 3 , 1000 ) ; if ( ret >= 0 ) { atusb -> fw_ver_maj = buffer [ 0 ] ; atusb -> fw_ver_min = buffer [ 1 ] ; atusb -> fw_hw_type = buffer [ 2 ] ; dev_info ( & usb_dev -> dev , "Firmware:<S2SV_blank>major:<S2SV_blank>%u,<S2SV_blank>minor:<S2SV_blank>%u,<S2SV_blank>hardware<S2SV_blank>type:<S2SV_blank>%u\\n" , atusb -> fw_ver_maj , atusb -> fw_ver_min , atusb -> fw_hw_type ) ; } if ( atusb -> fw_ver_maj == 0 && atusb -> fw_ver_min < 2 ) { dev_info ( & usb_dev -> dev , "Firmware<S2SV_blank>version<S2SV_blank>(%u.%u)<S2SV_blank>predates<S2SV_blank>our<S2SV_blank>first<S2SV_blank>public<S2SV_blank>release." , atusb -> fw_ver_maj , atusb -> fw_ver_min ) ; dev_info ( & usb_dev -> dev , "Please<S2SV_blank>update<S2SV_blank>to<S2SV_blank>version<S2SV_blank>0.2<S2SV_blank>or<S2SV_blank>newer" ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-284 void btsock_l2cap_signaled ( int fd , int flags , uint32_t user_id ) { l2cap_socket * sock ; char drop_it = FALSE ; pthread_mutex_lock ( & state_lock ) ; sock = btsock_l2cap_find_by_id_l ( user_id ) ; if ( sock ) { if ( ( flags & SOCK_THREAD_FD_RD ) && ! sock -> server ) { if ( sock -> connected ) { int size = 0 ; <S2SV_StartBug> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( sock -> our_fd , FIONREAD , & size ) <S2SV_EndBug> == 0 && size ) ) { uint8_t * buffer = osi_malloc ( L2CAP_MAX_SDU_LENGTH ) ; if ( buffer != NULL ) { <S2SV_StartBug> int count = recv ( fd , buffer , L2CAP_MAX_SDU_LENGTH , <S2SV_EndBug> <S2SV_StartBug> MSG_NOSIGNAL | MSG_DONTWAIT ) ; <S2SV_EndBug> APPL_TRACE_DEBUG ( "btsock_l2cap_signaled<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>received<S2SV_blank>from<S2SV_blank>socket" , count ) ; if ( sock -> fixed_chan ) { if ( BTA_JvL2capWriteFixed ( sock -> channel , ( BD_ADDR * ) & sock -> addr , ( UINT32 ) buffer , btsock_l2cap_cbk , buffer , count , ( void * ) user_id ) != BTA_JV_SUCCESS ) { on_l2cap_write_fixed_done ( buffer , user_id ) ; } } else { if ( BTA_JvL2capWrite ( sock -> handle , ( UINT32 ) buffer , buffer , count , ( void * ) user_id ) != BTA_JV_SUCCESS ) { on_l2cap_write_done ( buffer , user_id ) ; } } } else { APPL_TRACE_ERROR ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>data<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>JAVA..." ) } } } else drop_it = TRUE ; } if ( flags & SOCK_THREAD_FD_WR ) { if ( flush_incoming_que_on_wr_signal_l ( sock ) && sock -> connected ) btsock_thread_add_fd ( pth , sock -> our_fd , BTSOCK_L2CAP , SOCK_THREAD_FD_WR , sock -> id ) ; } if ( drop_it || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; <S2SV_StartBug> if ( drop_it || ioctl ( sock -> our_fd , FIONREAD , & size ) != 0 || size == 0 ) <S2SV_EndBug> btsock_l2cap_free_l ( sock ) ; } } pthread_mutex_unlock ( & state_lock ) ; }
CWE-000 static int ghash_update ( struct shash_desc * desc , const u8 * src , unsigned int srclen ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * dst = dctx -> buffer ; <S2SV_StartBug> if ( dctx -> bytes ) { <S2SV_EndBug> int n = min ( srclen , dctx -> bytes ) ; u8 * pos = dst + ( GHASH_BLOCK_SIZE - dctx -> bytes ) ; dctx -> bytes -= n ; srclen -= n ; while ( n -- ) * pos ++ ^= * src ++ ; if ( ! dctx -> bytes ) gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; } while ( srclen >= GHASH_BLOCK_SIZE ) { crypto_xor ( dst , src , GHASH_BLOCK_SIZE ) ; gf128mul_4k_lle ( ( be128 * ) dst , ctx -> gf128 ) ; src += GHASH_BLOCK_SIZE ; srclen -= GHASH_BLOCK_SIZE ; } if ( srclen ) { dctx -> bytes = GHASH_BLOCK_SIZE - srclen ; while ( srclen -- ) * dst ++ ^= * src ++ ; } return 0 ; }
CWE-119 int disrsi_ ( int stream , int * negate , unsigned * value , unsigned count ) { int c ; unsigned locval ; unsigned ndigs ; char * cp ; char scratch [ DIS_BUFSIZ + 1 ] ; assert ( negate != NULL ) ; assert ( value != NULL ) ; assert ( count ) ; assert ( stream >= 0 ) ; assert ( dis_getc != NULL ) ; assert ( dis_gets != NULL ) ; memset ( scratch , 0 , DIS_BUFSIZ + 1 ) ; if ( dis_umaxd == 0 ) disiui_ ( ) ; <S2SV_StartBug> switch ( c = ( * dis_getc ) ( stream ) ) <S2SV_EndBug> { case '-' : case '+' : * negate = c == '-' ; if ( ( * dis_gets ) ( stream , scratch , count ) != ( int ) count ) { return ( DIS_EOD ) ; } if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; } cp = scratch ; locval = 0 ; do { if ( ( ( c = * cp ++ ) < '0' ) || ( c > '9' ) ) { return ( DIS_NONDIGIT ) ; } locval = 10 * locval + c - '0' ; } while ( -- count ) ; * value = locval ; return ( DIS_SUCCESS ) ; break ; case '0' : return ( DIS_LEADZRO ) ; break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : ndigs = c - '0' ; if ( count > 1 ) { if ( ( * dis_gets ) ( stream , scratch + 1 , count - 1 ) != ( int ) count - 1 ) { return ( DIS_EOD ) ; } cp = scratch ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) break ; * cp = c ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) break ; } while ( -- count ) { if ( ( ( c = * ++ cp ) < '0' ) || ( c > '9' ) ) { return ( DIS_NONDIGIT ) ; } ndigs = 10 * ndigs + c - '0' ; } } return ( disrsi_ ( stream , negate , value , ndigs ) ) ; break ; case - 1 : return ( DIS_EOD ) ; break ; case - 2 : return ( DIS_EOF ) ; break ; default : return ( DIS_NONDIGIT ) ; break ; } * negate = FALSE ; overflow : * value = UINT_MAX ; return ( DIS_OVERFLOW ) ; }
CWE-119 static void set_segment_data ( VP8_COMP * cpi , signed char * feature_data , unsigned char abs_delta ) { cpi -> mb . e_mbd . mb_segement_abs_delta = abs_delta ; <S2SV_StartBug> vpx_memcpy ( cpi -> segment_feature_data , feature_data , sizeof ( cpi -> segment_feature_data ) ) ; <S2SV_EndBug> }
CWE-000 static zend_bool add_post_var ( zval * arr , post_var_data_t * var , zend_bool eof TSRMLS_DC ) { <S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> size_t klen , vlen ; unsigned int new_vlen ; if ( var -> ptr >= var -> end ) { return 0 ; } <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> if ( ! vsep ) { <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> return 0 ; } else { vsep = var -> end ; } } ksep = memchr ( var -> ptr , '=' , vsep - var -> ptr ) ; if ( ksep ) { * ksep = '\\0' ; klen = ksep - var -> ptr ; vlen = vsep - ++ ksep ; } else { ksep = "" ; klen = vsep - var -> ptr ; vlen = 0 ; } php_url_decode ( var -> ptr , klen ) ; val = estrndup ( ksep , vlen ) ; if ( vlen ) { vlen = php_url_decode ( val , vlen ) ; } if ( sapi_module . input_filter ( PARSE_POST , var -> ptr , & val , vlen , & new_vlen TSRMLS_CC ) ) { php_register_variable_safe ( var -> ptr , val , new_vlen , arr TSRMLS_CC ) ; } efree ( val ) ; var -> ptr = vsep + ( vsep != var -> end ) ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
CWE-119 static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) { ssize_t l , ll , o ; double now ; uint8_t * ptr ; struct vsb * synth_body ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; assert ( bo -> director_state == DIR_S_NULL ) ; wrk -> stats -> fetch_failed ++ ; now = W_TIM_real ( wrk ) ; VSLb_ts_busyobj ( bo , "Error" , now ) ; if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; http_PutResponse ( bo -> beresp , "HTTP/1.1" , 503 , "Backend<S2SV_blank>fetch<S2SV_blank>failed" ) ; http_TimeHeader ( bo -> beresp , "Date:<S2SV_blank>" , now ) ; http_SetHeader ( bo -> beresp , "Server:<S2SV_blank>Varnish" ) ; bo -> fetch_objcore -> t_origin = now ; if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { bo -> fetch_objcore -> ttl = 1 ; bo -> fetch_objcore -> grace = 5 ; bo -> fetch_objcore -> keep = 5 ; } else { bo -> fetch_objcore -> ttl = 0 ; bo -> fetch_objcore -> grace = 0 ; bo -> fetch_objcore -> keep = 0 ; } synth_body = VSB_new_auto ( ) ; AN ( synth_body ) ; VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; AZ ( VSB_finish ( synth_body ) ) ; if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) { VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } if ( wrk -> handling == VCL_RET_RETRY ) { VSB_destroy ( & synth_body ) ; if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ; VSLb ( bo -> vsl , SLT_VCL_Error , "Too<S2SV_blank>many<S2SV_blank>retries,<S2SV_blank>failing" ) ; return ( F_STP_FAIL ) ; } assert ( wrk -> handling == VCL_RET_DELIVER ) ; bo -> vfc -> bo = bo ; bo -> vfc -> wrk = bo -> wrk ; bo -> vfc -> oc = bo -> fetch_objcore ; bo -> vfc -> http = bo -> beresp ; bo -> vfc -> esi_req = bo -> bereq ; if ( vbf_beresp2obj ( bo ) ) { ( void ) VFP_Error ( bo -> vfc , "Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>storage" ) ; VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } ll = VSB_len ( synth_body ) ; o = 0 ; while ( ll > 0 ) { l = ll ; if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ; <S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> VFP_Extend ( bo -> vfc , l ) ; ll -= l ; o += l ; } AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ; VSB_destroy ( & synth_body ) ; HSH_Unbusy ( wrk , bo -> fetch_objcore ) ; ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ; return ( F_STP_DONE ) ; }
CWE-264 static int em_ret ( struct x86_emulate_ctxt * ctxt ) { <S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> ctxt -> dst . addr . reg = & ctxt -> _eip ; <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> return em_pop ( ctxt ) ; }
CWE-119 static void copy_and_extend_plane ( unsigned char * s , int sp , unsigned char * d , int dp , int h , int w , int et , int el , int eb , int er ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr1 , * dest_ptr2 ; int linesize ; src_ptr1 = s ; src_ptr2 = s + w - 1 ; dest_ptr1 = d - el ; dest_ptr2 = d + w ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , el ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , er ) ; src_ptr1 += sp ; src_ptr2 += sp ; dest_ptr1 += dp ; dest_ptr2 += dp ; } src_ptr1 = d - el ; src_ptr2 = d + dp * ( h - 1 ) - el ; dest_ptr1 = d + dp * ( - et ) - el ; dest_ptr2 = d + dp * ( h ) - el ; linesize = el + er + w ; for ( i = 0 ; i < et ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> dest_ptr1 += dp ; } for ( i = 0 ; i < eb ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> dest_ptr2 += dp ; } }
CWE-190 static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; <S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> bitmap -> format = gdi -> dstFormat ; <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }
CWE-416 static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) { int number_of_streams = avio_rb16 ( pb ) ; int number_of_mdpr ; int i , ret ; unsigned size2 ; for ( i = 0 ; i < number_of_streams ; i ++ ) avio_rb16 ( pb ) ; number_of_mdpr = avio_rb16 ( pb ) ; if ( number_of_mdpr != 1 ) { avpriv_request_sample ( s , "MLTI<S2SV_blank>with<S2SV_blank>multiple<S2SV_blank>(%d)<S2SV_blank>MDPR" , number_of_mdpr ) ; } for ( i = 0 ; i < number_of_mdpr ; i ++ ) { AVStream * st2 ; if ( i > 0 ) { st2 = avformat_new_stream ( s , NULL ) ; if ( ! st2 ) { ret = AVERROR ( ENOMEM ) ; return ret ; } st2 -> id = st -> id + ( i << 16 ) ; st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ; st2 -> start_time = st -> start_time ; st2 -> duration = st -> duration ; st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ; st2 -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ; } else st2 = st ; size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , <S2SV_StartBug> size2 , mime ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; } return 0 ; }
CWE-20 static void br_multicast_del_pg ( struct net_bridge * br , struct net_bridge_port_group * pg ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & pg -> addr ) ; if ( WARN_ON ( ! mp ) ) return ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p != pg ) continue ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ; call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; <S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ; return ; } WARN_ON ( 1 ) ; }
CWE-362 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; <S2SV_StartBug> ue -> info = * info ; <S2SV_EndBug> ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }
CWE-000 static enum ofperr decode_bundle ( bool load , const struct nx_action_bundle * nab , const struct vl_mff_map * vl_mff_map , uint64_t * tlv_bitmap , struct ofpbuf * ofpacts ) { static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT ( 1 , 5 ) ; struct ofpact_bundle * bundle ; uint32_t slave_type ; size_t slaves_size , i ; enum ofperr error ; bundle = ofpact_put_BUNDLE ( ofpacts ) ; bundle -> n_slaves = ntohs ( nab -> n_slaves ) ; bundle -> basis = ntohs ( nab -> basis ) ; bundle -> fields = ntohs ( nab -> fields ) ; bundle -> algorithm = ntohs ( nab -> algorithm ) ; slave_type = ntohl ( nab -> slave_type ) ; slaves_size = ntohs ( nab -> len ) - sizeof * nab ; error = OFPERR_OFPBAC_BAD_ARGUMENT ; if ( ! flow_hash_fields_valid ( bundle -> fields ) ) { VLOG_WARN_RL ( & rl , "unsupported<S2SV_blank>fields<S2SV_blank>%d" , ( int ) bundle -> fields ) ; } else if ( bundle -> n_slaves > BUNDLE_MAX_SLAVES ) { VLOG_WARN_RL ( & rl , "too<S2SV_blank>many<S2SV_blank>slaves" ) ; } else if ( bundle -> algorithm != NX_BD_ALG_HRW && bundle -> algorithm != NX_BD_ALG_ACTIVE_BACKUP ) { VLOG_WARN_RL ( & rl , "unsupported<S2SV_blank>algorithm<S2SV_blank>%d" , ( int ) bundle -> algorithm ) ; } else if ( slave_type != mf_nxm_header ( MFF_IN_PORT ) ) { VLOG_WARN_RL ( & rl , "unsupported<S2SV_blank>slave<S2SV_blank>type<S2SV_blank>%" PRIu16 , slave_type ) ; } else { error = 0 ; } if ( ! is_all_zeros ( nab -> zero , sizeof nab -> zero ) ) { VLOG_WARN_RL ( & rl , "reserved<S2SV_blank>field<S2SV_blank>is<S2SV_blank>nonzero" ) ; error = OFPERR_OFPBAC_BAD_ARGUMENT ; } if ( load ) { bundle -> dst . ofs = nxm_decode_ofs ( nab -> ofs_nbits ) ; bundle -> dst . n_bits = nxm_decode_n_bits ( nab -> ofs_nbits ) ; error = mf_vl_mff_mf_from_nxm_header ( ntohl ( nab -> dst ) , vl_mff_map , & bundle -> dst . field , tlv_bitmap ) ; if ( error ) { return error ; } if ( bundle -> dst . n_bits < 16 ) { VLOG_WARN_RL ( & rl , "bundle_load<S2SV_blank>action<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>16<S2SV_blank>bit<S2SV_blank>" "destination." ) ; error = OFPERR_OFPBAC_BAD_ARGUMENT ; } } else { if ( nab -> ofs_nbits || nab -> dst ) { VLOG_WARN_RL ( & rl , "bundle<S2SV_blank>action<S2SV_blank>has<S2SV_blank>nonzero<S2SV_blank>reserved<S2SV_blank>fields" ) ; error = OFPERR_OFPBAC_BAD_ARGUMENT ; } } if ( slaves_size < bundle -> n_slaves * sizeof ( ovs_be16 ) ) { VLOG_WARN_RL ( & rl , "Nicira<S2SV_blank>action<S2SV_blank>%s<S2SV_blank>only<S2SV_blank>has<S2SV_blank>%" PRIuSIZE "<S2SV_blank>bytes<S2SV_blank>" "allocated<S2SV_blank>for<S2SV_blank>slaves.<S2SV_blank><S2SV_blank>%" PRIuSIZE "<S2SV_blank>bytes<S2SV_blank>are<S2SV_blank>required<S2SV_blank>" "for<S2SV_blank>%" PRIu16 "<S2SV_blank>slaves." , load ? "bundle_load" : "bundle" , slaves_size , bundle -> n_slaves * sizeof ( ovs_be16 ) , bundle -> n_slaves ) ; error = OFPERR_OFPBAC_BAD_LEN ; <S2SV_StartBug> } <S2SV_EndBug> for ( i = 0 ; i < bundle -> n_slaves ; i ++ ) { ofp_port_t ofp_port = u16_to_ofp ( ntohs ( ( ( ovs_be16 * ) ( nab + 1 ) ) [ i ] ) ) ; ofpbuf_put ( ofpacts , & ofp_port , sizeof ofp_port ) ; bundle = ofpacts -> header ; } <S2SV_StartBug> ofpact_finish_BUNDLE ( ofpacts , & bundle ) ; <S2SV_EndBug> if ( ! error ) { error = bundle_check ( bundle , OFPP_MAX , NULL ) ; } return error ; }
CWE-119 <S2SV_StartBug> static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> BLOCK_SIZE bsize , TX_SIZE max_tx_size , int * rate_uv , int * rate_uv_tokenonly , int64_t * dist_uv , int * skip_uv , <S2SV_StartBug> MB_PREDICTION_MODE * mode_uv ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> if ( cpi -> sf . use_uv_intra_rd_estimate ) { rd_sbuv_dcpred ( cpi , x , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize ) ; } else { rd_pick_intra_sbuv_mode ( cpi , x , ctx , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , max_tx_size ) ; } * mode_uv = x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode ; }
CWE-119 static int atusb_read_reg ( struct atusb * atusb , uint8_t reg ) { struct usb_device * usb_dev = atusb -> usb_dev ; int ret ; <S2SV_StartBug> uint8_t value ; <S2SV_EndBug> dev_dbg ( & usb_dev -> dev , "atusb:<S2SV_blank>reg<S2SV_blank>=<S2SV_blank>0x%x\\n" , reg ) ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , <S2SV_StartBug> 0 , reg , & value , 1 , 1000 ) ; <S2SV_EndBug> <S2SV_StartBug> return ret >= 0 ? value : ret ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) { static char cmd [ BUF_SIZE ] ; <S2SV_StartBug> char * method = manager -> method ; <S2SV_EndBug> int i ; <S2SV_StartBug> build_config ( working_dir , server ) ; <S2SV_EndBug> if ( server -> method ) method = server -> method ; memset ( cmd , 0 , BUF_SIZE ) ; snprintf ( cmd , BUF_SIZE , <S2SV_StartBug> "%s<S2SV_blank>-m<S2SV_blank>%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%s.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%s.conf" , <S2SV_EndBug> <S2SV_StartBug> executable , method , manager -> manager_address , <S2SV_EndBug> <S2SV_StartBug> working_dir , server -> port , working_dir , server -> port ) ; <S2SV_EndBug> if ( manager -> acl != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>--acl<S2SV_blank>%s" , manager -> acl ) ; } if ( manager -> timeout != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-t<S2SV_blank>%s" , manager -> timeout ) ; } # ifdef HAVE_SETRLIMIT if ( manager -> nofile ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-n<S2SV_blank>%d" , manager -> nofile ) ; } # endif if ( manager -> user != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-a<S2SV_blank>%s" , manager -> user ) ; } if ( manager -> verbose ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-v" ) ; } if ( server -> mode == NULL && manager -> mode == UDP_ONLY ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-U" ) ; } if ( server -> mode == NULL && manager -> mode == TCP_AND_UDP ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-u" ) ; } if ( server -> fast_open [ 0 ] == 0 && manager -> fast_open ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>--fast-open" ) ; } if ( manager -> ipv6first ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-6" ) ; } if ( manager -> mtu ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>--mtu<S2SV_blank>%d" , manager -> mtu ) ; } if ( server -> plugin == NULL && manager -> plugin ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>--plugin<S2SV_blank>\\"%s\\"" , manager -> plugin ) ; } if ( server -> plugin_opts == NULL && manager -> plugin_opts ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>--plugin-opts<S2SV_blank>\\"%s\\"" , manager -> plugin_opts ) ; } for ( i = 0 ; i < manager -> nameserver_num ; i ++ ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-d<S2SV_blank>%s" , manager -> nameservers [ i ] ) ; } for ( i = 0 ; i < manager -> host_num ; i ++ ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>-s<S2SV_blank>%s" , manager -> hosts [ i ] ) ; } { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , "<S2SV_blank>--reuse-port" ) ; } if ( verbose ) { LOGI ( "cmd:<S2SV_blank>%s" , cmd ) ; } return cmd ; }
CWE-362 static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , "application<S2SV_blank>%i" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; } __err : <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> return err ; }
CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; struct kvm_memory_slot * memslot , * slot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; if ( ! npages && ! old . npages ) goto out_free ; r = - EEXIST ; kvm_for_each_memslot ( slot , kvm -> memslots ) { if ( slot -> id >= KVM_MEMORY_SLOTS || slot == memslot ) continue ; if ( ! ( ( base_gfn + npages <= slot -> base_gfn ) || ( base_gfn >= slot -> base_gfn + slot -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } else if ( npages && mem -> userspace_addr != old . userspace_addr ) { r = - EINVAL ; goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } if ( ! npages || base_gfn != old . base_gfn ) { struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; <S2SV_StartBug> kvm_arch_flush_shadow_memslot ( kvm , slot ) ; <S2SV_EndBug> kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) <S2SV_StartBug> goto out_free ; <S2SV_EndBug> if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; <S2SV_StartBug> out_free : <S2SV_EndBug> kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
CWE-119 static int calc_iframe_target_size_one_pass_vbr ( const VP9_COMP * const cpi ) { static const int kf_ratio = 25 ; const RATE_CONTROL * rc = & cpi -> rc ; <S2SV_StartBug> int target = rc -> av_per_frame_bandwidth * kf_ratio ; <S2SV_EndBug> return vp9_rc_clamp_iframe_target_size ( cpi , target ) ; }
CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len && <S2SV_StartBug> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }
CWE-119 <S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> } return ( pixels ) ; }
CWE-787 void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; UWORD32 u4_size = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; if ( u4_size > MAX_BITSTREAM_BUFFER_SIZE ) { u4_size = MAX_BITSTREAM_BUFFER_SIZE ; } memcpy ( ps_dec -> pu1_input_buffer , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , u4_size ) ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_dec -> pu1_input_buffer , u4_size ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; } impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; <S2SV_StartBug> ps_dec -> u2_header_done = 1 ; <S2SV_EndBug> } }
CWE-000 static int mct_u232_port_probe ( struct usb_serial_port * port ) { <S2SV_StartBug> struct mct_u232_private * priv ; <S2SV_EndBug> priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; <S2SV_StartBug> priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ; <S2SV_EndBug> priv -> read_urb -> context = port ; spin_lock_init ( & priv -> lock ) ; usb_set_serial_port_data ( port , priv ) ; return 0 ; }
CWE-000 OM_uint32 gss_krb5int_export_lucid_sec_context ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object , gss_buffer_set_t * data_set ) { krb5_error_code kret = 0 ; OM_uint32 retval ; krb5_gss_ctx_id_t ctx = ( krb5_gss_ctx_id_t ) context_handle ; void * lctx = NULL ; int version = 0 ; gss_buffer_desc rep ; retval = GSS_S_FAILURE ; * minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ; <S2SV_StartBug> retval = generic_gss_oid_decompose ( minor_status , <S2SV_EndBug> GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ; if ( GSS_ERROR ( retval ) ) return retval ; switch ( version ) { case 1 : kret = make_external_lucid_ctx_v1 ( ( krb5_pointer ) ctx , version , & lctx ) ; break ; default : kret = ( OM_uint32 ) KG_LUCID_VERSION ; break ; } if ( kret ) goto error_out ; rep . value = & lctx ; rep . length = sizeof ( lctx ) ; retval = generic_gss_add_buffer_set_member ( minor_status , & rep , data_set ) ; if ( GSS_ERROR ( retval ) ) goto error_out ; error_out : if ( * minor_status == 0 ) * minor_status = ( OM_uint32 ) kret ; return ( retval ) ; }
CWE-264 static const char * lua_authz_parse ( cmd_parms * cmd , const char * require_line , const void * * parsed_require_line ) { const char * provider_name ; <S2SV_StartBug> lua_authz_provider_spec * spec ; <S2SV_EndBug> apr_pool_userdata_get ( ( void * * ) & provider_name , AUTHZ_PROVIDER_NAME_NOTE , cmd -> temp_pool ) ; ap_assert ( provider_name != NULL ) ; spec = apr_hash_get ( lua_authz_providers , provider_name , APR_HASH_KEY_STRING ) ; ap_assert ( spec != NULL ) ; <S2SV_StartBug> if ( require_line && * require_line ) { <S2SV_EndBug> const char * arg ; <S2SV_StartBug> spec -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ; <S2SV_EndBug> while ( ( arg = ap_getword_conf ( cmd -> pool , & require_line ) ) && * arg ) { <S2SV_StartBug> APR_ARRAY_PUSH ( spec -> args , const char * ) = arg ; <S2SV_EndBug> } } <S2SV_StartBug> * parsed_require_line = spec ; <S2SV_EndBug> return NULL ; }
CWE-362 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; list_del ( & key -> graveyard_link ) ; kdebug ( "-<S2SV_blank>%u" , key -> serial ) ; key_check ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ; <S2SV_StartBug> key_user_put ( key -> user ) ; <S2SV_EndBug> if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; kfree ( key -> description ) ; # ifdef KEY_DEBUGGING key -> magic = KEY_DEBUG_MAGIC_X ; # endif kmem_cache_free ( key_jar , key ) ; } }
CWE-000 CMD_FUNC ( m_authenticate ) { aClient * agent_p = NULL ; if ( ! SASL_SERVER || ! MyConnect ( sptr ) || BadPtr ( parv [ 1 ] ) || ! CHECKPROTO ( sptr , PROTO_SASL ) ) return 0 ; if ( sptr -> local -> sasl_complete ) { sendto_one ( sptr , err_str ( ERR_SASLALREADY ) , me . name , BadPtr ( sptr -> name ) ? "*" : sptr -> name ) ; return 0 ; } <S2SV_StartBug> if ( strlen ( parv [ 1 ] ) > 400 ) <S2SV_EndBug> { sendto_one ( sptr , err_str ( ERR_SASLTOOLONG ) , me . name , BadPtr ( sptr -> name ) ? "*" : sptr -> name ) ; return 0 ; } if ( * sptr -> local -> sasl_agent ) agent_p = find_client ( sptr -> local -> sasl_agent , NULL ) ; if ( agent_p == NULL ) { char * addr = BadPtr ( sptr -> ip ) ? "0" : sptr -> ip ; char * certfp = moddata_client_get ( sptr , "certfp" ) ; sendto_server ( NULL , 0 , 0 , ":%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>H<S2SV_blank>%s<S2SV_blank>%s" , me . name , SASL_SERVER , encode_puid ( sptr ) , addr , addr ) ; if ( certfp ) sendto_server ( NULL , 0 , 0 , ":%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>%s" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] , certfp ) ; else sendto_server ( NULL , 0 , 0 , ":%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] ) ; } else sendto_server ( NULL , 0 , 0 , ":%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>C<S2SV_blank>%s" , me . name , AGENT_SID ( agent_p ) , encode_puid ( sptr ) , parv [ 1 ] ) ; sptr -> local -> sasl_out ++ ; return 0 ; }
CWE-787 void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { <S2SV_StartBug> dst_name = malloc ( strlen ( name ) * 2 + 16 ) ; <S2SV_EndBug> sprintf ( dst_name , "%s/%s" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , ".pdf" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , ".summary" ) ; if ( ! ( dst = fopen ( dst_name , "w" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , "%s:<S2SV_blank>--%c--<S2SV_blank>Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>Object<S2SV_blank>%d<S2SV_blank>(%s)" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp , pdf -> xrefs [ i ] . entries [ j ] . obj_id , & pdf -> xrefs [ i ] ) ) ; if ( 0 ) fprintf ( out , "<S2SV_blank>Page(%d)\\n" , page ) ; else fprintf ( out , "\\n" ) ; } } if ( ! ( flags & PDF_FLAG_QUIET ) ) { if ( pdf -> has_xref_streams || ! n_entries ) fprintf ( out , "%s:<S2SV_blank>This<S2SV_blank>PDF<S2SV_blank>contains<S2SV_blank>potential<S2SV_blank>cross<S2SV_blank>reference<S2SV_blank>streams.\\n" "%s:<S2SV_blank>An<S2SV_blank>object<S2SV_blank>summary<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available.\\n" , pdf -> name , pdf -> name ) ; fprintf ( out , "----------<S2SV_blank>%s<S2SV_blank>----------\\n" "Versions:<S2SV_blank>%d\\n" , pdf -> name , n_versions ) ; if ( ! pdf -> has_xref_streams ) for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( pdf -> xrefs [ i ] . is_linear ) continue ; n_entries = pdf -> xrefs [ i ] . n_entries ; if ( pdf -> xrefs [ 0 ] . is_linear ) n_entries += pdf -> xrefs [ 0 ] . n_entries ; if ( pdf -> xrefs [ i ] . version && n_entries ) fprintf ( out , "Version<S2SV_blank>%d<S2SV_blank>--<S2SV_blank>%d<S2SV_blank>objects\\n" , pdf -> xrefs [ i ] . version , n_entries ) ; } } else fprintf ( out , "%s:<S2SV_blank>%d\\n" , pdf -> name , n_versions ) ; if ( dst ) { fclose ( dst ) ; free ( dst_name ) ; } }
CWE-200 static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { <S2SV_StartBug> memset ( sax , 0 , sizeof ( sax ) ) ; <S2SV_EndBug> sax -> sax25_family = AF_NETROM ; skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ; } msg -> msg_namelen = sizeof ( * sax ) ; skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return copied ; }
CWE-284 static void * btif_hl_select_thread ( void * arg ) { fd_set org_set , curr_set ; int r , max_curr_s , max_org_s ; UNUSED ( arg ) ; BTIF_TRACE_DEBUG ( "entered<S2SV_blank>btif_hl_select_thread" ) ; FD_ZERO ( & org_set ) ; max_org_s = btif_hl_select_wakeup_init ( & org_set ) ; BTIF_TRACE_DEBUG ( "max_s=%d<S2SV_blank>" , max_org_s ) ; for ( ; ; ) { r = 0 ; BTIF_TRACE_DEBUG ( "set<S2SV_blank>curr_set<S2SV_blank>=<S2SV_blank>org_set<S2SV_blank>" ) ; curr_set = org_set ; max_curr_s = max_org_s ; <S2SV_StartBug> int ret = select ( ( max_curr_s + 1 ) , & curr_set , NULL , NULL , NULL ) ; <S2SV_EndBug> BTIF_TRACE_DEBUG ( "select<S2SV_blank>unblocked<S2SV_blank>ret=%d" , ret ) ; if ( ret == - 1 ) { BTIF_TRACE_DEBUG ( "select()<S2SV_blank>ret<S2SV_blank>-1,<S2SV_blank>exit<S2SV_blank>the<S2SV_blank>thread" ) ; btif_hl_thread_cleanup ( ) ; select_thread_id = - 1 ; return 0 ; } else if ( ret ) { BTIF_TRACE_DEBUG ( "btif_hl_select_wake_signaled,<S2SV_blank>signal<S2SV_blank>ret=%d" , ret ) ; if ( btif_hl_select_wake_signaled ( & curr_set ) ) { r = btif_hl_select_wake_reset ( ) ; BTIF_TRACE_DEBUG ( "btif_hl_select_wake_signaled,<S2SV_blank>signal:%d" , r ) ; if ( r == btif_hl_signal_select_wakeup || r == btif_hl_signal_select_close_connected ) { btif_hl_select_wakeup_callback ( & org_set , r ) ; } else if ( r == btif_hl_signal_select_exit ) { btif_hl_thread_cleanup ( ) ; BTIF_TRACE_DEBUG ( "Exit<S2SV_blank>hl_select_thread<S2SV_blank>for<S2SV_blank>btif_hl_signal_select_exit" ) ; return 0 ; } } btif_hl_select_monitor_callback ( & curr_set , & org_set ) ; max_org_s = btif_hl_update_maxfd ( max_org_s ) ; } else BTIF_TRACE_DEBUG ( "no<S2SV_blank>data,<S2SV_blank>select<S2SV_blank>ret:<S2SV_blank>%d\\n" , ret ) ; } BTIF_TRACE_DEBUG ( "leaving<S2SV_blank>hl_select_thread" ) ; return 0 ; }
CWE-200 static int pptp_connect ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; struct rtable * rt ; struct flowi4 fl4 ; int error = 0 ; <S2SV_StartBug> if ( sp -> sa_protocol != PX_PROTO_PPTP ) <S2SV_EndBug> return - EINVAL ; if ( lookup_chan_dst ( sp -> sa_addr . pptp . call_id , sp -> sa_addr . pptp . sin_addr . s_addr ) ) return - EALREADY ; lock_sock ( sk ) ; if ( sk -> sk_state & PPPOX_CONNECTED ) { error = - EBUSY ; goto end ; } if ( sk -> sk_state & PPPOX_DEAD ) { error = - EALREADY ; goto end ; } if ( ! opt -> src_addr . sin_addr . s_addr || ! sp -> sa_addr . pptp . sin_addr . s_addr ) { error = - EINVAL ; goto end ; } po -> chan . private = sk ; po -> chan . ops = & pptp_chan_ops ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , opt -> dst_addr . sin_addr . s_addr , opt -> src_addr . sin_addr . s_addr , 0 , 0 , IPPROTO_GRE , RT_CONN_FLAGS ( sk ) , 0 ) ; if ( IS_ERR ( rt ) ) { error = - EHOSTUNREACH ; goto end ; } sk_setup_caps ( sk , & rt -> dst ) ; po -> chan . mtu = dst_mtu ( & rt -> dst ) ; if ( ! po -> chan . mtu ) po -> chan . mtu = PPP_MRU ; ip_rt_put ( rt ) ; po -> chan . mtu -= PPTP_HEADER_OVERHEAD ; po -> chan . hdrlen = 2 + sizeof ( struct pptp_gre_header ) ; error = ppp_register_channel ( & po -> chan ) ; if ( error ) { pr_err ( "PPTP:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>PPP<S2SV_blank>channel<S2SV_blank>(%d)\\n" , error ) ; goto end ; } opt -> dst_addr = sp -> sa_addr . pptp ; sk -> sk_state = PPPOX_CONNECTED ; end : release_sock ( sk ) ; return error ; }
CWE-200 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { <S2SV_StartBug> ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; <S2SV_EndBug> ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-000 static int jpc_dec_tiledecode ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { int i ; int j ; jpc_dec_tcomp_t * tcomp ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; int compno ; int rlvlno ; int bandno ; int adjust ; int v ; jpc_dec_ccp_t * ccp ; jpc_dec_cmpt_t * cmpt ; if ( jpc_dec_decodecblks ( dec , tile ) ) { jas_eprintf ( "jpc_dec_decodecblks<S2SV_blank>failed\\n" ) ; return - 1 ; } for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { ccp = & tile -> cp -> ccps [ compno ] ; for ( rlvlno = 0 , rlvl = tcomp -> rlvls ; rlvlno < tcomp -> numrlvls ; ++ rlvlno , ++ rlvl ) { if ( ! rlvl -> bands ) { continue ; } for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { if ( ! band -> data ) { continue ; } jpc_undo_roi ( band -> data , band -> roishift , ccp -> roishift - band -> roishift , band -> numbps ) ; if ( tile -> realmode ) { jas_matrix_asl ( band -> data , JPC_FIX_FRACBITS ) ; jpc_dequantize ( band -> data , band -> absstepsize ) ; } } } } for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { ccp = & tile -> cp -> ccps [ compno ] ; jpc_tsfb_synthesize ( tcomp -> tsfb , tcomp -> data ) ; } switch ( tile -> cp -> mctid ) { case JPC_MCT_RCT : if ( dec -> numcomps < 3 ) { <S2SV_StartBug> jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n" ) ; <S2SV_EndBug> return - 1 ; } jpc_irct ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , tile -> tcomps [ 2 ] . data ) ; break ; case JPC_MCT_ICT : if ( dec -> numcomps < 3 ) { jas_eprintf ( "ICT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n" ) ; return - 1 ; } <S2SV_StartBug> jpc_iict ( tile -> tcomps [ 0 ] . data , tile -> tcomps [ 1 ] . data , <S2SV_EndBug> tile -> tcomps [ 2 ] . data ) ; break ; } if ( tile -> realmode ) { for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { for ( i = 0 ; i < jas_matrix_numrows ( tcomp -> data ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( tcomp -> data ) ; ++ j ) { v = jas_matrix_get ( tcomp -> data , i , j ) ; v = jpc_fix_round ( v ) ; jas_matrix_set ( tcomp -> data , i , j , jpc_fixtoint ( v ) ) ; } } } } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { adjust = cmpt -> sgnd ? 0 : ( 1 << ( cmpt -> prec - 1 ) ) ; for ( i = 0 ; i < jas_matrix_numrows ( tcomp -> data ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( tcomp -> data ) ; ++ j ) { * jas_matrix_getref ( tcomp -> data , i , j ) += adjust ; } } } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { jpc_fix_t mn ; jpc_fix_t mx ; mn = cmpt -> sgnd ? ( - ( 1 << ( cmpt -> prec - 1 ) ) ) : ( 0 ) ; mx = cmpt -> sgnd ? ( ( 1 << ( cmpt -> prec - 1 ) ) - 1 ) : ( ( 1 << cmpt -> prec ) - 1 ) ; jas_matrix_clip ( tcomp -> data , mn , mx ) ; } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { if ( jas_image_writecmpt ( dec -> image , compno , tcomp -> xstart - JPC_CEILDIV ( dec -> xstart , cmpt -> hstep ) , tcomp -> ystart - JPC_CEILDIV ( dec -> ystart , cmpt -> vstep ) , jas_matrix_numcols ( tcomp -> data ) , jas_matrix_numrows ( tcomp -> data ) , tcomp -> data ) ) { jas_eprintf ( "write<S2SV_blank>component<S2SV_blank>failed\\n" ) ; return - 1 ; } } return 0 ; }
CWE-200 static void snd_timer_user_tinterrupt ( struct snd_timer_instance * timeri , unsigned long resolution , unsigned long ticks ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread * r , r1 ; struct timespec tstamp ; int prev , append = 0 ; memset ( & tstamp , 0 , sizeof ( tstamp ) ) ; spin_lock ( & tu -> qlock ) ; if ( ( tu -> filter & ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) ) ) == 0 ) { spin_unlock ( & tu -> qlock ) ; return ; } if ( tu -> last_resolution != resolution || ticks > 0 ) { if ( timer_tstamp_monotonic ) ktime_get_ts ( & tstamp ) ; else getnstimeofday ( & tstamp ) ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) ) && tu -> last_resolution != resolution ) { <S2SV_StartBug> r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ; <S2SV_EndBug> r1 . tstamp = tstamp ; r1 . val = resolution ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; tu -> last_resolution = resolution ; append ++ ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_TICK ) ) == 0 ) goto __wake ; if ( ticks == 0 ) goto __wake ; if ( tu -> qused > 0 ) { prev = tu -> qtail == 0 ? tu -> queue_size - 1 : tu -> qtail - 1 ; r = & tu -> tqueue [ prev ] ; if ( r -> event == SNDRV_TIMER_EVENT_TICK ) { r -> tstamp = tstamp ; r -> val += ticks ; append ++ ; goto __wake ; } } r1 . event = SNDRV_TIMER_EVENT_TICK ; r1 . tstamp = tstamp ; r1 . val = ticks ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; append ++ ; __wake : spin_unlock ( & tu -> qlock ) ; if ( append == 0 ) return ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }
CWE-119 static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpAcc" , "%s" , "cc%(bps*stride))!=0" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; return 1 ; }
CWE-200 static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { <S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> walk -> vma , walk -> private ) ; return 0 ; }
CWE-119 static vpx_codec_err_t decoder_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , int * is_intra_only , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) { int intra_only_flag = 0 ; <S2SV_StartBug> uint8_t clear_buffer [ 9 ] ; <S2SV_EndBug> if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ; si -> is_kf = 0 ; si -> w = si -> h = 0 ; if ( decrypt_cb ) { data_sz = VPXMIN ( sizeof ( clear_buffer ) , data_sz ) ; decrypt_cb ( decrypt_state , data , clear_buffer , data_sz ) ; data = clear_buffer ; <S2SV_StartBug> } <S2SV_EndBug> { int show_frame ; int error_resilient ; struct vpx_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; const int frame_marker = vpx_rb_read_literal ( & rb , 2 ) ; const BITSTREAM_PROFILE profile = vp9_read_profile ( & rb ) ; if ( frame_marker != VP9_FRAME_MARKER ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( profile >= MAX_PROFILES ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_StartBug> if ( ( profile >= 2 && data_sz <= 1 ) || data_sz < 1 ) <S2SV_EndBug> return VPX_CODEC_UNSUP_BITSTREAM ; if ( vpx_rb_read_bit ( & rb ) ) { vpx_rb_read_literal ( & rb , 3 ) ; return VPX_CODEC_OK ; } <S2SV_StartBug> if ( data_sz <= 8 ) <S2SV_EndBug> return VPX_CODEC_UNSUP_BITSTREAM ; si -> is_kf = ! vpx_rb_read_bit ( & rb ) ; show_frame = vpx_rb_read_bit ( & rb ) ; error_resilient = vpx_rb_read_bit ( & rb ) ; if ( si -> is_kf ) { if ( ! vp9_read_sync_code ( & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( ! parse_bitdepth_colorspace_sampling ( profile , & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; vp9_read_frame_size ( & rb , ( int * ) & si -> w , ( int * ) & si -> h ) ; } else { intra_only_flag = show_frame ? 0 : vpx_rb_read_bit ( & rb ) ; rb . bit_offset += error_resilient ? 0 : 2 ; if ( intra_only_flag ) { if ( ! vp9_read_sync_code ( & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( profile > PROFILE_0 ) { if ( ! parse_bitdepth_colorspace_sampling ( profile , & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; } rb . bit_offset += REF_FRAMES ; vp9_read_frame_size ( & rb , ( int * ) & si -> w , ( int * ) & si -> h ) ; } } } if ( is_intra_only != NULL ) * is_intra_only = intra_only_flag ; return VPX_CODEC_OK ; }
CWE-000 WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num ) { dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; <S2SV_StartBug> WORD32 ret ; <S2SV_EndBug> ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } } H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ret = ih264d_end_of_pic_processing ( ps_dec ) ; if ( ret != OK ) return ret ; ps_dec -> u2_total_mbs_coded = 0 ; { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ret = ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; if ( ret != OK ) return ret ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } } H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }
CWE-119 static int uio_mmap_physical ( struct vm_area_struct * vma ) { struct uio_device * idev = vma -> vm_private_data ; int mi = uio_find_mem_index ( vma ) ; <S2SV_StartBug> if ( mi < 0 ) <S2SV_EndBug> return - EINVAL ; vma -> vm_ops = & uio_physical_vm_ops ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; return remap_pfn_range ( vma , vma -> vm_start , <S2SV_StartBug> idev -> info -> mem [ mi ] . addr >> PAGE_SHIFT , <S2SV_EndBug> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }
CWE-20 static void dissect_rpcap_packet ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * top_tree , proto_tree * parent_tree , gint offset , proto_item * top_item ) { proto_tree * tree ; proto_item * ti ; nstime_t ts ; tvbuff_t * new_tvb ; guint caplen , len , frame_no ; <S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ; tree = proto_item_add_subtree ( ti , ett_packet ) ; ts . secs = tvb_get_ntohl ( tvb , offset ) ; ts . nsecs = tvb_get_ntohl ( tvb , offset + 4 ) * 1000 ; proto_tree_add_time ( tree , hf_timestamp , tvb , offset , 8 , & ts ) ; offset += 8 ; caplen = tvb_get_ntohl ( tvb , offset ) ; ti = proto_tree_add_item ( tree , hf_caplen , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; len = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_len , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; frame_no = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_npkt , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; proto_item_append_text ( ti , ",<S2SV_blank>Frame<S2SV_blank>%u" , frame_no ) ; proto_item_append_text ( top_item , "<S2SV_blank>Frame<S2SV_blank>%u" , frame_no ) ; reported_length_remaining = tvb_reported_length_remaining ( tvb , offset ) ; if ( caplen > ( guint ) reported_length_remaining ) { expert_add_info ( pinfo , ti , & ei_caplen_too_big ) ; return ; } new_tvb = tvb_new_subset ( tvb , offset , caplen , len ) ; if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug> if ( ! info_added ) { col_prepend_fence_fstr ( pinfo -> cinfo , COL_PROTOCOL , "R|" ) ; col_prepend_fence_fstr ( pinfo -> cinfo , COL_INFO , "Remote<S2SV_blank>|<S2SV_blank>" ) ; info_added = TRUE ; register_frame_end_routine ( pinfo , rpcap_frame_end ) ; } } else { if ( linktype == WTAP_ENCAP_UNKNOWN ) { proto_item_append_text ( ti , ",<S2SV_blank>Unknown<S2SV_blank>link-layer<S2SV_blank>type" ) ; } call_dissector ( data_handle , new_tvb , pinfo , top_tree ) ; } }
CWE-264 int propagate_mnt ( struct mount * dest_mnt , struct dentry * dest_dentry , struct mount * source_mnt , struct list_head * tree_list ) { <S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> int ret = 0 ; struct mount * prev_dest_mnt = dest_mnt ; struct mount * prev_src_mnt = source_mnt ; LIST_HEAD ( tmp_list ) ; LIST_HEAD ( umount_list ) ; for ( m = propagation_next ( dest_mnt , dest_mnt ) ; m ; m = propagation_next ( m , dest_mnt ) ) { int type ; struct mount * source ; if ( IS_MNT_NEW ( m ) ) continue ; <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug> child = copy_tree ( source , source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) { ret = PTR_ERR ( child ) ; list_splice ( tree_list , tmp_list . prev ) ; goto out ; } if ( is_subdir ( dest_dentry , m -> mnt . mnt_root ) ) { mnt_set_mountpoint ( m , dest_dentry , child ) ; list_add_tail ( & child -> mnt_hash , tree_list ) ; } else { list_add_tail ( & child -> mnt_hash , & tmp_list ) ; } prev_dest_mnt = m ; prev_src_mnt = child ; } out : br_write_lock ( & vfsmount_lock ) ; while ( ! list_empty ( & tmp_list ) ) { child = list_first_entry ( & tmp_list , struct mount , mnt_hash ) ; umount_tree ( child , 0 , & umount_list ) ; } br_write_unlock ( & vfsmount_lock ) ; release_mounts ( & umount_list ) ; return ret ; }
CWE-416 int blk_init_allocated_queue ( struct request_queue * q ) { WARN_ON_ONCE ( q -> mq_ops ) ; q -> fq = blk_alloc_flush_queue ( q , NUMA_NO_NODE , q -> cmd_size ) ; if ( ! q -> fq ) return - ENOMEM ; if ( q -> init_rq_fn && q -> init_rq_fn ( q , q -> fq -> flush_rq , GFP_KERNEL ) ) goto out_free_flush_queue ; if ( blk_init_rl ( & q -> root_rl , q , GFP_KERNEL ) ) goto out_exit_flush_rq ; INIT_WORK ( & q -> timeout_work , blk_timeout_work ) ; q -> queue_flags |= QUEUE_FLAG_DEFAULT ; blk_queue_make_request ( q , blk_queue_bio ) ; q -> sg_reserved_size = INT_MAX ; if ( elevator_init ( q ) ) goto out_exit_flush_rq ; return 0 ; out_exit_flush_rq : if ( q -> exit_rq_fn ) q -> exit_rq_fn ( q , q -> fq -> flush_rq ) ; out_free_flush_queue : blk_free_flush_queue ( q -> fq ) ; <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }
CWE-119 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-119 struct monitor * monitor_init ( void ) { <S2SV_StartBug> struct ssh * ssh = active_state ; <S2SV_EndBug> struct monitor * mon ; mon = xcalloc ( 1 , sizeof ( * mon ) ) ; monitor_openfds ( mon , 1 ) ; <S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ; mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ; ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } return mon ; }
CWE-125 static int print_ipcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; u_int compproto , ipcomp_subopttotallen , ipcomp_subopt , ipcomp_suboptlen ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)" , tok2str ( ipcpopt_values , "unknown" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( ipcpopt_values , "unknown" , opt ) , opt , len ) ) ; switch ( opt ) { case IPCPOPT_2ADDR : if ( len != 10 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)" ) ) ; return len ; } ND_TCHECK2 ( * ( p + 6 ) , 4 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ; break ; case IPCPOPT_IPCOMP : if ( len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>%s<S2SV_blank>(0x%02x):" , tok2str ( ipcpopt_compproto_values , "Unknown" , compproto ) , compproto ) ) ; switch ( compproto ) { case PPP_VJC : break ; case IPCPOPT_IPCOMP_HDRCOMP : if ( len < IPCPOPT_IPCOMP_MINLEN ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%u)" , IPCPOPT_IPCOMP_MINLEN ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , IPCPOPT_IPCOMP_MINLEN ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>Space<S2SV_blank>%u,<S2SV_blank>non-TCP<S2SV_blank>Space<S2SV_blank>%u" ",<S2SV_blank>maxPeriod<S2SV_blank>%u,<S2SV_blank>maxTime<S2SV_blank>%u,<S2SV_blank>maxHdr<S2SV_blank>%u" , EXTRACT_16BITS ( p + 4 ) , EXTRACT_16BITS ( p + 6 ) , EXTRACT_16BITS ( p + 8 ) , EXTRACT_16BITS ( p + 10 ) , EXTRACT_16BITS ( p + 12 ) ) ) ; if ( len > IPCPOPT_IPCOMP_MINLEN ) { ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN ; p += IPCPOPT_IPCOMP_MINLEN ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Suboptions,<S2SV_blank>length<S2SV_blank>%u" , ipcomp_subopttotallen ) ) ; while ( ipcomp_subopttotallen >= 2 ) { ND_TCHECK2 ( * p , 2 ) ; ipcomp_subopt = * p ; ipcomp_suboptlen = * ( p + 1 ) ; if ( ipcomp_subopt == 0 || ipcomp_suboptlen == 0 ) break ; ND_PRINT ( ( ndo , "\\n\\t\\t%s<S2SV_blank>Suboption<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u" , tok2str ( ipcpopt_compproto_subopt_values , "Unknown" , ipcomp_subopt ) , ipcomp_subopt , ipcomp_suboptlen ) ) ; ipcomp_subopttotallen -= ipcomp_suboptlen ; p += ipcomp_suboptlen ; } } break ; default : break ; } break ; case IPCPOPT_ADDR : case IPCPOPT_MOBILE4 : case IPCPOPT_PRIDNS : case IPCPOPT_PRINBNS : case IPCPOPT_SECDNS : case IPCPOPT_SECNBNS : if ( len != 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>%s" , ipaddr_string ( ndo , p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , "[|ipcp]" ) ) ; return 0 ; }
CWE-119 u32 h264bsdInit ( storage_t * pStorage , u32 noOutputReordering ) { u32 size ; ASSERT ( pStorage ) ; h264bsdInitStorage ( pStorage ) ; size = ( sizeof ( macroblockLayer_t ) + 63 ) & ~ 0x3F ; <S2SV_StartBug> pStorage -> mbLayer = ( macroblockLayer_t * ) H264SwDecMalloc ( size ) ; <S2SV_EndBug> if ( ! pStorage -> mbLayer ) return HANTRO_NOK ; if ( noOutputReordering ) pStorage -> noReordering = HANTRO_TRUE ; return HANTRO_OK ; }
CWE-125 static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }
CWE-362 int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } <S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> } inode -> i_size += len ; EXT4_I ( inode ) -> i_disksize += len ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ret = ext4_mark_inode_dirty ( handle , inode ) ; if ( ret ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; path = ext4_find_extent ( inode , offset_lblk , NULL , 0 ) ; if ( IS_ERR ( path ) ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } depth = ext_depth ( inode ) ; extent = path [ depth ] . p_ext ; if ( extent ) { ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( extent ) ; if ( ( offset_lblk > ee_start_lblk ) && ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { if ( ext4_ext_is_unwritten ( extent ) ) split_flag = EXT4_EXT_MARK_UNWRIT1 | EXT4_EXT_MARK_UNWRIT2 ; ret = ext4_split_extent_at ( handle , inode , & path , offset_lblk , split_flag , EXT4_EX_NOCACHE | EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_METADATA_NOFAIL ) ; } ext4_ext_drop_refs ( path ) ; kfree ( path ) ; if ( ret < 0 ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } } ret = ext4_es_remove_extent ( inode , offset_lblk , EXT_MAX_BLOCKS - offset_lblk ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_shift_extents ( inode , handle , ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , len_lblk , SHIFT_RIGHT ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; out_stop : ext4_journal_stop ( handle ) ; <S2SV_StartBug> out_dio : <S2SV_EndBug> ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
CWE-264 <S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> unsigned int target_offset , unsigned int next_offset ) { <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ; t = ( void * ) ( e + target_offset ) ; if ( t -> u . target_size < sizeof ( * t ) ) return - EINVAL ; if ( target_offset + t -> u . target_size > next_offset ) return - EINVAL ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) == 0 && target_offset + sizeof ( struct xt_standard_target ) != next_offset ) return - EINVAL ; return 0 ; }
CWE-125 static const uint32_t * parserep ( netdissect_options * ndo , register const struct sunrpc_msg * rp , register u_int length ) { register const uint32_t * dp ; u_int len ; enum sunrpc_accept_stat astat ; dp = ( ( const uint32_t * ) & rp -> rm_reply ) + 1 ; ND_TCHECK ( dp [ 1 ] ) ; len = EXTRACT_32BITS ( & dp [ 1 ] ) ; if ( len >= length ) return ( NULL ) ; dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) / sizeof ( uint32_t ) ; <S2SV_StartBug> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <S2SV_EndBug> astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; if ( astat != SUNRPC_SUCCESS ) { ND_PRINT ( ( ndo , "<S2SV_blank>%s" , tok2str ( sunrpc_str , "ar_stat<S2SV_blank>%d" , astat ) ) ) ; nfserr = 1 ; return ( NULL ) ; } ND_TCHECK2 ( * dp , sizeof ( astat ) ) ; return ( ( const uint32_t * ) ( sizeof ( astat ) + ( ( const char * ) dp ) ) ) ; trunc : return ( 0 ) ; }
CWE-119 vpx_codec_err_t vp9_copy_reference_dec ( VP9Decoder * pbi , VP9_REFFRAME ref_frame_flag , YV12_BUFFER_CONFIG * sd ) { VP9_COMMON * cm = & pbi -> common ; if ( ref_frame_flag == VP9_LAST_FLAG ) { <S2SV_StartBug> const YV12_BUFFER_CONFIG * const cfg = <S2SV_EndBug> <S2SV_StartBug> & cm -> frame_bufs [ cm -> ref_frame_map [ 0 ] ] . buf ; <S2SV_EndBug> if ( ! equal_dimensions ( cfg , sd ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , "Incorrect<S2SV_blank>buffer<S2SV_blank>dimensions" ) ; else vp8_yv12_copy_frame ( cfg , sd ) ; } else { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , "Invalid<S2SV_blank>reference<S2SV_blank>frame" ) ; } return cm -> error . error_code ; }
CWE-125 static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; <S2SV_StartBug> ND_TCHECK ( lshp -> ls_type ) ; <S2SV_EndBug> ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>age<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
CWE-119 void mp_encode_lua_table_as_map ( lua_State * L , mp_buf * buf , int level ) { <S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug> lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pop ( L , 1 ) ; len ++ ; } mp_encode_map ( L , buf , len ) ; lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pushvalue ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }
CWE-264 static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ; <S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - EFAULT ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - EIO ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( IB_USER_VERBS_CMD_FLAGS_MASK | IB_USER_VERBS_CMD_COMMAND_MASK ) ) { ret = - EINVAL ; goto out ; } command = hdr . command & IB_USER_VERBS_CMD_COMMAND_MASK ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( ! file -> ucontext && command != IB_USER_VERBS_CMD_GET_CONTEXT ) { ret = - EINVAL ; goto out ; } flags = ( hdr . command & IB_USER_VERBS_CMD_FLAGS_MASK ) >> IB_USER_VERBS_CMD_FLAGS_SHIFT ; if ( ! flags ) { if ( command >= ARRAY_SIZE ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - EINVAL ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - EINVAL ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == IB_USER_VERBS_CMD_FLAG_EXTENDED ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= ARRAY_SIZE ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - ENOSYS ; goto out ; } if ( ! file -> ucontext ) { ret = - EINVAL ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - EINVAL ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - EFAULT ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } if ( ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - EFAULT ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } } INIT_UDATA_BUF_OR_NULL ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; INIT_UDATA_BUF_OR_NULL ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - ENOSYS ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }
CWE-000 static int mov_write_audio_tag ( AVFormatContext * s , AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) { int64_t pos = avio_tell ( pb ) ; int version = 0 ; uint32_t tag = track -> tag ; if ( track -> mode == MODE_MOV ) { <S2SV_StartBug> if ( track -> timescale > UINT16_MAX ) { <S2SV_EndBug> if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( "lpcm" ) ; version = 2 ; } else if ( track -> audio_vbr || mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 ) { version = 1 ; } } avio_wb32 ( pb , 0 ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ffio_wfourcc ( pb , "enca" ) ; } else { avio_wl32 ( pb , tag ) ; } avio_wb32 ( pb , 0 ) ; avio_wb16 ( pb , 0 ) ; avio_wb16 ( pb , 1 ) ; avio_wb16 ( pb , version ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0 ) ; if ( version == 2 ) { avio_wb16 ( pb , 3 ) ; avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , 0xfffe ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0x00010000 ) ; avio_wb32 ( pb , 72 ) ; avio_wb64 ( pb , av_double2int ( track -> par -> sample_rate ) ) ; avio_wb32 ( pb , track -> par -> channels ) ; avio_wb32 ( pb , 0x7F000000 ) ; avio_wb32 ( pb , av_get_bits_per_sample ( track -> par -> codec_id ) ) ; avio_wb32 ( pb , mov_get_lpcm_flags ( track -> par -> codec_id ) ) ; avio_wb32 ( pb , track -> sample_size ) ; avio_wb32 ( pb , get_samples_per_packet ( track ) ) ; } else { if ( track -> mode == MODE_MOV ) { avio_wb16 ( pb , track -> par -> channels ) ; if ( track -> par -> codec_id == AV_CODEC_ID_PCM_U8 || track -> par -> codec_id == AV_CODEC_ID_PCM_S8 ) avio_wb16 ( pb , 8 ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_ADPCM_G726 ) avio_wb16 ( pb , track -> par -> bits_per_coded_sample ) ; else avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , track -> audio_vbr ? - 2 : 0 ) ; } else { if ( track -> par -> codec_id == AV_CODEC_ID_FLAC || track -> par -> codec_id == AV_CODEC_ID_OPUS ) { avio_wb16 ( pb , track -> par -> channels ) ; } else { avio_wb16 ( pb , 2 ) ; } if ( track -> par -> codec_id == AV_CODEC_ID_FLAC ) { avio_wb16 ( pb , track -> par -> bits_per_raw_sample ) ; } else { avio_wb16 ( pb , 16 ) ; } avio_wb16 ( pb , 0 ) ; } avio_wb16 ( pb , 0 ) ; if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) avio_wb16 ( pb , 48000 ) ; else avio_wb16 ( pb , track -> par -> sample_rate <= UINT16_MAX ? track -> par -> sample_rate : 0 ) ; avio_wb16 ( pb , 0 ) ; } if ( version == 1 ) { if ( mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) ) avio_wb32 ( pb , 1 ) ; else avio_wb32 ( pb , track -> par -> frame_size ) ; avio_wb32 ( pb , track -> sample_size / track -> par -> channels ) ; avio_wb32 ( pb , track -> sample_size ) ; avio_wb32 ( pb , 2 ) ; } if ( track -> mode == MODE_MOV && ( track -> par -> codec_id == AV_CODEC_ID_AAC || track -> par -> codec_id == AV_CODEC_ID_AC3 || track -> par -> codec_id == AV_CODEC_ID_EAC3 || track -> par -> codec_id == AV_CODEC_ID_AMR_NB || track -> par -> codec_id == AV_CODEC_ID_ALAC || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 || ( mov_pcm_le_gt16 ( track -> par -> codec_id ) && version == 1 ) || ( mov_pcm_be_gt16 ( track -> par -> codec_id ) && version == 1 ) ) ) mov_write_wave_tag ( s , pb , track ) ; else if ( track -> tag == MKTAG ( 'm' , 'p' , '4' , 'a' ) ) mov_write_esds_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_AMR_NB ) mov_write_amr_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_AC3 ) mov_write_ac3_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_EAC3 ) mov_write_eac3_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_ALAC ) mov_write_extradata_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_WMAPRO ) mov_write_wfex_tag ( s , pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_FLAC ) mov_write_dfla_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) mov_write_dops_tag ( pb , track ) ; else if ( track -> vos_len > 0 ) mov_write_glbl_tag ( pb , track ) ; if ( track -> mode == MODE_MOV && track -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) mov_write_chan_tag ( s , pb , track ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ff_mov_cenc_write_sinf_tag ( track , pb , mov -> encryption_kid ) ; } return update_size ( pb , pos ) ; }
CWE-284 static void uipc_check_interrupt_locked ( void ) { if ( SAFE_FD_ISSET ( uipc_main . signal_fds [ 0 ] , & uipc_main . read_set ) ) { char sig_recv = 0 ; <S2SV_StartBug> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> } }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_previewpp ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { # if CONFIG_POSTPROC <S2SV_StartBug> vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; <S2SV_EndBug> ( void ) ctr_id ; if ( data ) { ctx -> preview_ppcfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; # else ( void ) ctx ; <S2SV_StartBug> ( void ) ctr_id ; <S2SV_EndBug> ( void ) args ; return VPX_CODEC_INCAPABLE ; # endif }
CWE-119 WORD32 impeg2d_get_slice_pos ( dec_state_multi_core_t * ps_dec_state_multi_core ) { WORD32 u4_bits ; WORD32 i4_row ; dec_state_t * ps_dec = ps_dec_state_multi_core -> ps_dec_state [ 0 ] ; WORD32 i4_prev_row ; stream_t s_bitstrm ; WORD32 i4_start_row ; WORD32 i4_slice_bistream_ofst ; WORD32 i ; s_bitstrm = ps_dec -> s_bit_stream ; i4_prev_row = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 0 ] -> i4_start_mb_y = 0 ; ps_dec_state_multi_core -> ps_dec_state [ 1 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 2 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 3 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 0 ] -> i4_end_mb_y = ps_dec -> u2_num_vert_mb ; ps_dec_state_multi_core -> ps_dec_state [ 1 ] -> i4_end_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 2 ] -> i4_end_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 3 ] -> i4_end_mb_y = - 1 ; if ( ps_dec -> i4_num_cores == 1 ) return 0 ; impeg2_jobq_reset ( ( jobq_t * ) ps_dec -> pv_jobq ) ; i4_start_row = - 1 ; i4_slice_bistream_ofst = 0 ; while ( 1 ) { WORD32 i4_is_slice ; if ( s_bitstrm . u4_offset + START_CODE_LEN >= s_bitstrm . u4_max_offset ) { break ; } u4_bits = impeg2d_bit_stream_nxt ( & s_bitstrm , START_CODE_LEN ) ; i4_row = u4_bits & 0xFF ; i4_is_slice = ( ( ( u4_bits >> 8 ) == 0x01 ) && ( i4_row ) && ( i4_row <= ps_dec -> u2_num_vert_mb ) ) ; if ( ! i4_is_slice ) break ; i4_row -= 1 ; <S2SV_StartBug> if ( i4_prev_row != i4_row ) <S2SV_EndBug> { if ( i4_start_row != - 1 ) { job_t s_job ; IV_API_CALL_STATUS_T ret ; s_job . i2_start_mb_y = i4_start_row ; s_job . i2_end_mb_y = i4_row ; s_job . i4_cmd = CMD_PROCESS ; s_job . i4_bistream_ofst = i4_slice_bistream_ofst ; ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( ret != IV_SUCCESS ) return ret ; } i4_slice_bistream_ofst = s_bitstrm . u4_offset >> 3 ; i4_slice_bistream_ofst -= ( size_t ) s_bitstrm . pv_bs_buf & 3 ; i4_prev_row = i4_row ; i4_start_row = i4_row ; <S2SV_StartBug> } <S2SV_EndBug> impeg2d_bit_stream_flush ( & s_bitstrm , START_CODE_LEN ) ; while ( impeg2d_bit_stream_nxt ( & s_bitstrm , 24 ) != START_CODE_PREFIX ) { impeg2d_bit_stream_get ( & s_bitstrm , 8 ) ; if ( s_bitstrm . u4_offset >= s_bitstrm . u4_max_offset ) { break ; } } } { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; s_job . i2_start_mb_y = i4_start_row ; s_job . i2_end_mb_y = ps_dec -> u2_num_vert_mb ; s_job . i4_cmd = CMD_PROCESS ; s_job . i4_bistream_ofst = i4_slice_bistream_ofst ; e_ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( e_ret != IV_SUCCESS ) return e_ret ; } if ( ( NULL != ps_dec -> ps_disp_pic ) && ( ( 0 == ps_dec -> u4_share_disp_buf ) || ( IV_YUV_420P != ps_dec -> i4_chromaFormat ) ) ) { for ( i = 0 ; i < ps_dec -> u2_vertical_size ; i += 64 ) { job_t s_job ; IV_API_CALL_STATUS_T ret ; s_job . i2_start_mb_y = i ; s_job . i2_start_mb_y >>= 4 ; s_job . i2_end_mb_y = ( i + 64 ) ; s_job . i2_end_mb_y >>= 4 ; s_job . i4_cmd = CMD_FMTCONV ; s_job . i4_bistream_ofst = 0 ; ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( ret != IV_SUCCESS ) return ret ; } } impeg2_jobq_terminate ( ps_dec -> pv_jobq ) ; ps_dec -> i4_bytes_consumed = s_bitstrm . u4_offset >> 3 ; ps_dec -> i4_bytes_consumed -= ( ( size_t ) s_bitstrm . pv_bs_buf & 3 ) ; return 0 ; }
CWE-264 static int load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg ) { u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; <S2SV_StartBug> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctrl_id , va_list args ) { int * corrupted = va_arg ( args , int * ) ; VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; if ( corrupted && pbi ) { <S2SV_StartBug> * corrupted = pbi -> common . frame_to_show -> corrupted ; <S2SV_EndBug> return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-362 struct request * blk_mq_tag_to_rq ( struct blk_mq_tags * tags , unsigned int tag ) { <S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug> if ( ! is_flush_request ( rq , fq , tag ) ) return rq ; return fq -> flush_rq ; }
CWE-000 static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ; <S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ; <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> }
CWE-20 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , "submodule" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , "disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
CWE-125 <S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }
CWE-772 int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) <S2SV_StartBug> return res ; <S2SV_EndBug> res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }
CWE-416 static ssize_t bsg_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos ) { struct bsg_device * bd = file -> private_data ; ssize_t bytes_written ; int ret ; <S2SV_StartBug> dprintk ( "%s:<S2SV_blank>write<S2SV_blank>%Zd<S2SV_blank>bytes\\n" , bd -> name , count ) ; <S2SV_EndBug> bsg_set_block ( bd , file ) ; bytes_written = 0 ; ret = __bsg_write ( bd , buf , count , & bytes_written , file -> f_mode & FMODE_WRITE ) ; * ppos = bytes_written ; if ( ! bytes_written || err_block_err ( ret ) ) bytes_written = ret ; dprintk ( "%s:<S2SV_blank>returning<S2SV_blank>%Zd\\n" , bd -> name , bytes_written ) ; return bytes_written ; }
CWE-200 int vcc_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct atm_vcc * vcc ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( __SO_LEVEL_MATCH ( optname , level ) && len != __SO_SIZE ( optname ) ) return - EINVAL ; vcc = ATM_SD ( sock ) ; switch ( optname ) { case SO_ATMQOS : if ( ! test_bit ( ATM_VF_HASQOS , & vcc -> flags ) ) return - EINVAL ; return copy_to_user ( optval , & vcc -> qos , sizeof ( vcc -> qos ) ) ? - EFAULT : 0 ; case SO_SETCLP : return put_user ( vcc -> atm_options & ATM_ATMOPT_CLP ? 1 : 0 , ( unsigned long __user * ) optval ) ? - EFAULT : 0 ; case SO_ATMPVC : { struct sockaddr_atmpvc pvc ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ; <S2SV_StartBug> pvc . sap_family = AF_ATMPVC ; <S2SV_EndBug> pvc . sap_addr . itf = vcc -> dev -> number ; pvc . sap_addr . vpi = vcc -> vpi ; pvc . sap_addr . vci = vcc -> vci ; return copy_to_user ( optval , & pvc , sizeof ( pvc ) ) ? - EFAULT : 0 ; } default : if ( level == SOL_SOCKET ) return - EINVAL ; break ; } if ( ! vcc -> dev || ! vcc -> dev -> ops -> getsockopt ) return - EINVAL ; return vcc -> dev -> ops -> getsockopt ( vcc , level , optname , optval , len ) ; }
CWE-119 int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec = { 0 } ; vpx_codec_enc_cfg_t cfg = { 0 } ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; int update_frame_num = 0 ; const int fps = 30 ; const int bitrate = 200 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments" ) ; encoder = get_vpx_encoder_by_name ( "vp8" ) ; if ( ! encoder ) die ( "Unsupported<S2SV_blank>codec." ) ; update_frame_num = atoi ( argv [ 5 ] ) ; if ( ! update_frame_num ) die ( "Couldn\'t<S2SV_blank>parse<S2SV_blank>frame<S2SV_blank>number<S2SV_blank>\'%s\'\\n" , argv [ 5 ] ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 1 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 2 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( "Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image." ) ; } <S2SV_StartBug> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; <S2SV_EndBug> if ( res ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config." ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; writer = vpx_video_writer_open ( argv [ 4 ] , kContainerIVF , & info ) ; if ( ! writer ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing." , argv [ 4 ] ) ; if ( ! ( infile = fopen ( argv [ 3 ] , "rb" ) ) ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading." , argv [ 3 ] ) ; <S2SV_StartBug> if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) <S2SV_EndBug> die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder" ) ; while ( vpx_img_read ( & raw , infile ) ) { if ( frame_count + 1 == update_frame_num ) { vpx_ref_frame_t ref ; ref . frame_type = VP8_LAST_FRAME ; ref . img = raw ; if ( vpx_codec_control ( & codec , VP8_SET_REFERENCE , & ref ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>reference<S2SV_blank>frame" ) ; } encode_frame ( & codec , & raw , frame_count ++ , writer ) ; } <S2SV_StartBug> encode_frame ( & codec , NULL , - 1 , writer ) ; <S2SV_EndBug> printf ( "\\n" ) ; fclose ( infile ) ; printf ( "Processed<S2SV_blank>%d<S2SV_blank>frames.\\n" , frame_count ) ; vpx_img_free ( & raw ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec." ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
CWE-190 void * jas_malloc ( size_t size ) { void * result ; <S2SV_StartBug> JAS_DBGLOG ( 101 , ( "jas_malloc<S2SV_blank>called<S2SV_blank>with<S2SV_blank>%zu\\n" , size ) ) ; <S2SV_EndBug> result = malloc ( size ) ; JAS_DBGLOG ( 100 , ( "jas_malloc(%zu)<S2SV_blank>-><S2SV_blank>%p\\n" , size , result ) ) ; return result ; }
CWE-000 void Init_ossl_cipher ( void ) { # if 0 mOSSL = rb_define_module ( "OpenSSL" ) ; eOSSLError = rb_define_class_under ( mOSSL , "OpenSSLError" , rb_eStandardError ) ; # endif cCipher = rb_define_class_under ( mOSSL , "Cipher" , rb_cObject ) ; eCipherError = rb_define_class_under ( cCipher , "CipherError" , eOSSLError ) ; rb_define_alloc_func ( cCipher , ossl_cipher_alloc ) ; rb_define_copy_func ( cCipher , ossl_cipher_copy ) ; rb_define_module_function ( cCipher , "ciphers" , ossl_s_ciphers , 0 ) ; rb_define_method ( cCipher , "initialize" , ossl_cipher_initialize , 1 ) ; rb_define_method ( cCipher , "reset" , ossl_cipher_reset , 0 ) ; rb_define_method ( cCipher , "encrypt" , ossl_cipher_encrypt , - 1 ) ; rb_define_method ( cCipher , "decrypt" , ossl_cipher_decrypt , - 1 ) ; rb_define_method ( cCipher , "pkcs5_keyivgen" , ossl_cipher_pkcs5_keyivgen , - 1 ) ; rb_define_method ( cCipher , "update" , ossl_cipher_update , - 1 ) ; rb_define_method ( cCipher , "final" , ossl_cipher_final , 0 ) ; rb_define_method ( cCipher , "name" , ossl_cipher_name , 0 ) ; rb_define_method ( cCipher , "key=" , ossl_cipher_set_key , 1 ) ; rb_define_method ( cCipher , "auth_data=" , ossl_cipher_set_auth_data , 1 ) ; rb_define_method ( cCipher , "auth_tag=" , ossl_cipher_set_auth_tag , 1 ) ; rb_define_method ( cCipher , "auth_tag" , ossl_cipher_get_auth_tag , - 1 ) ; rb_define_method ( cCipher , "auth_tag_len=" , ossl_cipher_set_auth_tag_len , 1 ) ; rb_define_method ( cCipher , "authenticated?" , ossl_cipher_is_authenticated , 0 ) ; rb_define_method ( cCipher , "key_len=" , ossl_cipher_set_key_length , 1 ) ; rb_define_method ( cCipher , "key_len" , ossl_cipher_key_length , 0 ) ; rb_define_method ( cCipher , "iv=" , ossl_cipher_set_iv , 1 ) ; rb_define_method ( cCipher , "iv_len=" , ossl_cipher_set_iv_length , 1 ) ; rb_define_method ( cCipher , "iv_len" , ossl_cipher_iv_length , 0 ) ; rb_define_method ( cCipher , "block_size" , ossl_cipher_block_size , 0 ) ; rb_define_method ( cCipher , "padding=" , ossl_cipher_set_padding , 1 ) ; id_auth_tag_len = rb_intern_const ( "auth_tag_len" ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 <S2SV_StartBug> static void rate_block ( int plane , int block , BLOCK_SIZE plane_bsize , <S2SV_EndBug> TX_SIZE tx_size , struct rdcost_block_args * args ) { int x_idx , y_idx ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x_idx , & y_idx ) ; <S2SV_StartBug> args -> rate = cost_coeffs ( args -> x , plane , block , args -> t_above + x_idx , <S2SV_EndBug> args -> t_left + y_idx , tx_size , args -> so -> scan , args -> so -> neighbors , args -> use_fast_coef_costing ) ; }
CWE-190 int perf_cpu_time_max_percent_handler ( struct ctl_table * table , int write , void __user * buffer , size_t * lenp , loff_t * ppos ) { <S2SV_StartBug> int ret = proc_dointvec ( table , write , buffer , lenp , ppos ) ; <S2SV_EndBug> if ( ret || ! write ) return ret ; if ( sysctl_perf_cpu_time_max_percent == 100 || sysctl_perf_cpu_time_max_percent == 0 ) { printk ( KERN_WARNING "perf:<S2SV_blank>Dynamic<S2SV_blank>interrupt<S2SV_blank>throttling<S2SV_blank>disabled,<S2SV_blank>can<S2SV_blank>hang<S2SV_blank>your<S2SV_blank>system!\\n" ) ; WRITE_ONCE ( perf_sample_allowed_ns , 0 ) ; } else { update_perf_cpu_limits ( ) ; } return 0 ; }
CWE-20 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } <S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } } } else { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> { if ( n != 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-000 static void print_value ( int output , int num , const char * devname , const char * value , const char * name , size_t valsz ) { if ( output & OUTPUT_VALUE_ONLY ) { fputs ( value , stdout ) ; fputc ( '\\n' , stdout ) ; } else if ( output & OUTPUT_UDEV_LIST ) { print_udev_format ( name , value ) ; } else if ( output & OUTPUT_EXPORT_LIST ) { if ( num == 1 && devname ) printf ( "DEVNAME=%s\\n" , devname ) ; fputs ( name , stdout ) ; fputs ( "=" , stdout ) ; <S2SV_StartBug> safe_print ( value , valsz , NULL ) ; <S2SV_EndBug> fputs ( "\\n" , stdout ) ; } else { if ( num == 1 && devname ) printf ( "%s:" , devname ) ; fputs ( "<S2SV_blank>" , stdout ) ; fputs ( name , stdout ) ; fputs ( "=\\"" , stdout ) ; <S2SV_StartBug> safe_print ( value , valsz , "\\"" ) ; <S2SV_EndBug> fputs ( "\\"" , stdout ) ; } }
CWE-119 static int DecodeNumberField ( int len , char * str , int fmask , int * tmask , struct tm * tm , fsec_t * fsec , int * is2digits ) { char * cp ; if ( ( cp = strchr ( str , '.' ) ) != NULL ) { # ifdef HAVE_INT64_TIMESTAMP <S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> strcpy ( fstr , ( cp + 1 ) ) ; strcpy ( fstr + strlen ( fstr ) , "000000" ) ; * ( fstr + 6 ) = '\\0' ; * fsec = strtol ( fstr , NULL , 10 ) ; # else * fsec = strtod ( cp , NULL ) ; # endif * cp = '\\0' ; len = strlen ( str ) ; } else if ( ( fmask & DTK_DATE_M ) != DTK_DATE_M ) { if ( len == 8 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 6 ) ; * ( str + 6 ) = '\\0' ; tm -> tm_mon = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_year = atoi ( str + 0 ) ; return DTK_DATE ; } else if ( len == 6 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_mon = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } else if ( len == 5 ) { * tmask = DTK_DATE_M ; tm -> tm_mday = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_mon = 1 ; tm -> tm_year = atoi ( str + 0 ) ; * is2digits = TRUE ; return DTK_DATE ; } } if ( ( fmask & DTK_TIME_M ) != DTK_TIME_M ) { if ( len == 6 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = atoi ( str + 4 ) ; * ( str + 4 ) = '\\0' ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } else if ( len == 4 ) { * tmask = DTK_TIME_M ; tm -> tm_sec = 0 ; tm -> tm_min = atoi ( str + 2 ) ; * ( str + 2 ) = '\\0' ; tm -> tm_hour = atoi ( str + 0 ) ; return DTK_TIME ; } } return - 1 ; }
CWE-399 static int br_multicast_add_group ( struct net_bridge * br , struct net_bridge_port * port , struct br_ip * group ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; unsigned long now = jiffies ; int err ; spin_lock ( & br -> multicast_lock ) ; if ( ! netif_running ( br -> dev ) || ( port && port -> state == BR_STATE_DISABLED ) ) goto out ; mp = br_multicast_new_group ( br , port , group ) ; err = PTR_ERR ( mp ) ; if ( IS_ERR ( mp ) ) goto err ; if ( ! port ) { <S2SV_StartBug> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <S2SV_EndBug> mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ; goto out ; } for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p -> port == port ) goto found ; if ( ( unsigned long ) p -> port < ( unsigned long ) port ) break ; } p = kzalloc ( sizeof ( * p ) , GFP_ATOMIC ) ; err = - ENOMEM ; if ( unlikely ( ! p ) ) goto err ; p -> addr = * group ; p -> port = port ; p -> next = * pp ; hlist_add_head ( & p -> mglist , & port -> mglist ) ; setup_timer ( & p -> timer , br_multicast_port_group_expired , ( unsigned long ) p ) ; setup_timer ( & p -> query_timer , br_multicast_port_group_query_expired , ( unsigned long ) p ) ; rcu_assign_pointer ( * pp , p ) ; found : mod_timer ( & p -> timer , now + br -> multicast_membership_interval ) ; out : err = 0 ; err : spin_unlock ( & br -> multicast_lock ) ; return err ; }
CWE-125 void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ; <S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }
CWE-264 static inline unsigned long zap_pmd_range ( struct mmu_gather * tlb , struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , struct zap_details * details ) { pmd_t * pmd ; unsigned long next ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( next - addr != HPAGE_PMD_SIZE ) { VM_BUG_ON ( ! rwsem_is_locked ( & tlb -> mm -> mmap_sem ) ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; } else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) ) <S2SV_StartBug> continue ; <S2SV_EndBug> } <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; <S2SV_EndBug> cond_resched ( ) ; } while ( pmd ++ , addr = next , addr != end ) ; return addr ; }
CWE-119 static int store_icy ( URLContext * h , int size ) { HTTPContext * s = h -> priv_data ; <S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> if ( remaining < 0 ) return AVERROR_INVALIDDATA ; if ( ! remaining ) { uint8_t ch ; int len = http_read_stream_all ( h , & ch , 1 ) ; if ( len < 0 ) return len ; if ( ch > 0 ) { char data [ 255 * 16 + 1 ] ; int ret ; len = ch * 16 ; ret = http_read_stream_all ( h , data , len ) ; if ( ret < 0 ) return ret ; data [ len + 1 ] = 0 ; if ( ( ret = av_opt_set ( s , "icy_metadata_packet" , data , 0 ) ) < 0 ) return ret ; update_metadata ( s , data ) ; } s -> icy_data_read = 0 ; remaining = s -> icy_metaint ; } return FFMIN ( size , remaining ) ; }
CWE-200 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
CWE-000 <S2SV_StartBug> void ext4_xattr_destroy_cache ( struct mb_cache * cache ) <S2SV_EndBug> { if ( cache ) <S2SV_StartBug> mb_cache_destroy ( cache ) ; <S2SV_EndBug> }
CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , "vCont;c;s" ) ; } if ( ! ( action = strtok ( g -> data , ";" ) ) ) { return send_msg ( g , "E01" ) ; } while ( action = strtok ( NULL , ";" ) ) { eprintf ( "action:<S2SV_blank>%s\\n" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , "ds" , NULL , 0 ) < 0 ) { send_msg ( g , "E01" ) ; return - 1 ; } return send_msg ( g , "OK" ) ; case 'c' : if ( cmd_cb ( core_ptr , "dc" , NULL , 0 ) < 0 ) { send_msg ( g , "E01" ) ; return - 1 ; } return send_msg ( g , "OK" ) ; default : return send_msg ( g , "E01" ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-264 static void veth_setup ( struct net_device * dev ) { <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> dev -> netdev_ops = & veth_netdev_ops ; dev -> ethtool_ops = & veth_ethtool_ops ; dev -> features |= NETIF_F_LLTX ; dev -> destructor = veth_dev_free ; dev -> hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM ; }
CWE-000 void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , "page/get" ) ) { char * page = http_request_param_get ( req , "page" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , "%s" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , "page/set" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , "text" ) ) != NULL ) && ( ( page = http_request_param_get ( req , "page" ) ) != NULL ) ) { <S2SV_StartBug> file_write ( page , wikitext ) ; <S2SV_EndBug> http_response_printf ( res , "success" ) ; http_response_send ( res ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } else if ( ! strcmp ( func , "page/delete" ) ) { char * page = http_request_param_get ( req , "page" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( unlink ( page ) > 0 ) ) <S2SV_EndBug> { http_response_printf ( res , "success" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , "page/exists" ) ) { char * page = http_request_param_get ( req , "page" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; <S2SV_StartBug> if ( page && ( access ( page , R_OK ) == 0 ) ) <S2SV_EndBug> { http_response_printf ( res , "success" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , "pages" ) || ! strcmp ( func , "search" ) ) { WikiPageList * * pages = NULL ; int n_pages , i ; char * expr = http_request_param_get ( req , "expr" ) ; if ( expr == NULL ) expr = http_request_get_query_string ( req ) ; pages = wiki_get_pages ( & n_pages , expr ) ; if ( pages ) { for ( i = 0 ; i < n_pages ; i ++ ) { struct tm * pTm ; char datebuf [ 64 ] ; pTm = localtime ( & pages [ i ] -> mtime ) ; strftime ( datebuf , sizeof ( datebuf ) , "%Y-%m-%d<S2SV_blank>%H:%M" , pTm ) ; http_response_printf ( res , "%s\\t%s\\n" , pages [ i ] -> name , datebuf ) ; } http_response_send ( res ) ; return ; } } } http_response_set_status ( res , 500 , "Error" ) ; http_response_printf ( res , "<html><body>Failed</body></html>\\n" ) ; http_response_send ( res ) ; return ; }
CWE-399 int do_fpu_inst ( unsigned short inst , struct pt_regs * regs ) { struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & ( tsk -> thread . xstate -> softfpu ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) { fpu_init ( fpu ) ; task_thread_info ( tsk ) -> status |= TS_USEDFPU ; } return fpu_emulate ( inst , fpu , regs ) ; }
CWE-264 int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * upayload , * zap ; size_t datalen = prep -> datalen ; int ret ; ret = - EINVAL ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) goto error ; ret = - ENOMEM ; upayload = kmalloc ( sizeof ( * upayload ) + datalen , GFP_KERNEL ) ; if ( ! upayload ) goto error ; upayload -> datalen = datalen ; memcpy ( upayload -> data , prep -> data , datalen ) ; zap = upayload ; ret = key_payload_reserve ( key , datalen ) ; if ( ret == 0 ) { <S2SV_StartBug> zap = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> rcu_assign_keypointer ( key , upayload ) ; <S2SV_EndBug> key -> expiry = 0 ; } if ( zap ) kfree_rcu ( zap , rcu ) ; error : return ret ; }
CWE-119 <S2SV_StartBug> void vp9_write_prob_diff_update ( vp9_writer * w , vp9_prob newp , vp9_prob oldp ) { <S2SV_EndBug> const int delp = remap_prob ( newp , oldp ) ; encode_term_subexp ( w , delp ) ; }
CWE-119 int vp8_diamond_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , int * num00 , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { int i , j , step ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * best_address ; int tot_steps ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int best_site = 0 ; int last_site = 0 ; int ref_row ; int ref_col ; int this_row_offset ; int this_col_offset ; search_site * ss ; unsigned char * check_here ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; ref_row = ref_mv -> as_mv . row ; ref_col = ref_mv -> as_mv . col ; * num00 = 0 ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; in_what = ( unsigned char * ) ( base_pre + d -> offset + ( ref_row * pre_stride ) + ref_col ) ; best_address = in_what ; <S2SV_StartBug> bestsad = fn_ptr -> sdf ( what , what_stride , in_what , in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; ss = & x -> ss [ search_param * x -> searches_per_step ] ; tot_steps = ( x -> ss_count / x -> searches_per_step ) - search_param ; i = 1 ; for ( step = 0 ; step < tot_steps ; step ++ ) { for ( j = 0 ; j < x -> searches_per_step ; j ++ ) { this_row_offset = best_mv -> as_mv . row + ss [ i ] . mv . row ; this_col_offset = best_mv -> as_mv . col + ss [ i ] . mv . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ss [ i ] . offset + best_address ; <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = i ; } } } i ++ ; } if ( best_site != last_site ) { best_mv -> as_mv . row += ss [ best_site ] . mv . row ; best_mv -> as_mv . col += ss [ best_site ] . mv . col ; best_address += ss [ best_site ] . offset ; last_site = best_site ; } else if ( best_address == in_what ) ( * num00 ) ++ ; } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
CWE-000 struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }
CWE-000 long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> Com_Error ( ERR_FATAL , "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , "%s\\n" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }
CWE-416 SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; <S2SV_StartBug> ctx -> clockid = clockid ; <S2SV_EndBug> if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( "[timerfd]" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }
CWE-190 static MatchinfoBuffer * fts3MIBufferNew ( int nElem , const char * zMatchinfo ) { MatchinfoBuffer * pRet ; <S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> if ( pRet ) { memset ( pRet , 0 , nByte ) ; pRet -> aMatchinfo [ 0 ] = ( u8 * ) ( & pRet -> aMatchinfo [ 1 ] ) - ( u8 * ) pRet ; pRet -> aMatchinfo [ 1 + nElem ] = pRet -> aMatchinfo [ 0 ] + sizeof ( u32 ) * ( nElem + 1 ) ; pRet -> nElem = nElem ; pRet -> zMatchinfo = ( ( char * ) pRet ) + nByte ; memcpy ( pRet -> zMatchinfo , zMatchinfo , nStr + 1 ) ; pRet -> aRef [ 0 ] = 1 ; } return pRet ; }
CWE-399 int unshare_userns ( unsigned long unshare_flags , struct cred * * new_cred ) { <S2SV_StartBug> struct cred * cred ; <S2SV_EndBug> if ( ! ( unshare_flags & CLONE_NEWUSER ) ) return 0 ; cred = prepare_creds ( ) ; <S2SV_StartBug> if ( ! cred ) <S2SV_EndBug> return - ENOMEM ; * new_cred = cred ; <S2SV_StartBug> return create_user_ns ( cred ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> extra = extra ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }
CWE-264 static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> if ( ses ) { cFYI ( 1 , "Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , "Session<S2SV_blank>needs<S2SV_blank>reconnect" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , "Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , "%pI6" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses -> serverName , "%pI4" , & server -> addr . sockAddr . sin_addr . s_addr ) ; if ( volume_info -> username ) strncpy ( ses -> userName , volume_info -> username , MAX_USERNAME_SIZE ) ; if ( volume_info -> password ) { ses -> password = kstrdup ( volume_info -> password , GFP_KERNEL ) ; if ( ! ses -> password ) goto get_ses_fail ; } if ( volume_info -> domainname ) { int len = strlen ( volume_info -> domainname ) ; ses -> domainName = kmalloc ( len + 1 , GFP_KERNEL ) ; if ( ses -> domainName ) strcpy ( ses -> domainName , volume_info -> domainname ) ; } ses -> linux_uid = volume_info -> linux_uid ; ses -> overrideSecFlg = volume_info -> secFlg ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( ! rc ) rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; mutex_unlock ( & ses -> session_mutex ) ; if ( rc ) goto get_ses_fail ; write_lock ( & cifs_tcp_ses_lock ) ; list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; write_unlock ( & cifs_tcp_ses_lock ) ; FreeXid ( xid ) ; return ses ; get_ses_fail : sesInfoFree ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }
CWE-000 int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { atomic_inc ( & key -> user -> nikeys ) ; key -> reject_error = - error ; smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; <S2SV_StartBug> if ( keyring ) <S2SV_EndBug> __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret == 0 ? link_ret : ret ; }
CWE-119 static PyObject * _pyfribidi_log2vis ( PyObject * self , PyObject * args , PyObject * kw ) { <S2SV_StartBug> PyObject * logical = NULL ; <S2SV_EndBug> <S2SV_StartBug> FriBidiParType base = FRIBIDI_TYPE_RTL ; <S2SV_EndBug> const char * encoding = "utf-8" ; int clean = 0 ; int reordernsm = 1 ; static char * kwargs [ ] = <S2SV_StartBug> { "logical" , "base_direction" , "encoding" , "clean" , "reordernsm" , NULL } ; <S2SV_EndBug> <S2SV_StartBug> if ( ! PyArg_ParseTupleAndKeywords ( args , kw , "O|isii" , kwargs , <S2SV_EndBug> <S2SV_StartBug> & logical , & base , & encoding , & clean , & reordernsm ) ) <S2SV_EndBug> <S2SV_StartBug> return NULL ; <S2SV_EndBug> if ( ! ( base == FRIBIDI_TYPE_RTL || <S2SV_StartBug> base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON ) ) <S2SV_EndBug> return PyErr_Format ( PyExc_ValueError , "invalid<S2SV_blank>value<S2SV_blank>%d:<S2SV_blank>use<S2SV_blank>either<S2SV_blank>RTL,<S2SV_blank>LTR<S2SV_blank>or<S2SV_blank>ON" , base ) ; <S2SV_StartBug> if ( PyUnicode_Check ( logical ) ) <S2SV_EndBug> return log2vis_unicode ( logical , base , clean , reordernsm ) ; <S2SV_StartBug> else if ( PyString_Check ( logical ) ) <S2SV_EndBug> return log2vis_encoded_string ( logical , encoding , base , clean , reordernsm ) ; else return PyErr_Format ( PyExc_TypeError , "expected<S2SV_blank>unicode<S2SV_blank>or<S2SV_blank>str,<S2SV_blank>not<S2SV_blank>%s" , logical -> ob_type -> tp_name ) ; }
CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( "b/26366256" ) ; <S2SV_EndBug> return ; } pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ; # endif } }
CWE-119 static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> char line [ COSINE_LINE_LENGTH ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) return FALSE ; if ( file_gets ( line , COSINE_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> err_info ) ; }
CWE-125 static void r_bin_dwarf_dump_debug_info ( FILE * f , const RBinDwarfDebugInfo * inf ) { size_t i , j , k ; RBinDwarfDIE * dies ; RBinDwarfAttrValue * values ; if ( ! inf || ! f ) { return ; } for ( i = 0 ; i < inf -> length ; i ++ ) { fprintf ( f , "<S2SV_blank><S2SV_blank>Compilation<S2SV_blank>Unit<S2SV_blank>@<S2SV_blank>offset<S2SV_blank>0x%" PFMT64x ":\\n" , inf -> comp_units [ i ] . offset ) ; fprintf ( f , "<S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\n" , inf -> comp_units [ i ] . hdr . length ) ; fprintf ( f , "<S2SV_blank><S2SV_blank><S2SV_blank>Version:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , inf -> comp_units [ i ] . hdr . version ) ; fprintf ( f , "<S2SV_blank><S2SV_blank><S2SV_blank>Abbrev<S2SV_blank>Offset:<S2SV_blank>0x%x\\n" , inf -> comp_units [ i ] . hdr . abbrev_offset ) ; fprintf ( f , "<S2SV_blank><S2SV_blank><S2SV_blank>Pointer<S2SV_blank>Size:<S2SV_blank><S2SV_blank>%d\\n" , inf -> comp_units [ i ] . hdr . pointer_size ) ; dies = inf -> comp_units [ i ] . dies ; for ( j = 0 ; j < inf -> comp_units [ i ] . length ; j ++ ) { fprintf ( f , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Abbrev<S2SV_blank>Number:<S2SV_blank>%" PFMT64u "<S2SV_blank>" , dies [ j ] . abbrev_code ) ; if ( dies [ j ] . tag && dies [ j ] . tag <= DW_TAG_volatile_type && dwarf_tag_name_encodings [ dies [ j ] . tag ] ) { fprintf ( f , "(%s)\\n" , dwarf_tag_name_encodings [ dies [ j ] . tag ] ) ; } else { fprintf ( f , "(Unknown<S2SV_blank>abbrev<S2SV_blank>tag)\\n" ) ; } if ( ! dies [ j ] . abbrev_code ) { continue ; } values = dies [ j ] . attr_values ; for ( k = 0 ; k < dies [ j ] . length ; k ++ ) { <S2SV_StartBug> if ( ! values [ k ] . name ) <S2SV_EndBug> continue ; if ( values [ k ] . name < DW_AT_vtable_elem_location && dwarf_attr_encodings [ values [ k ] . name ] ) { fprintf ( f , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-18s<S2SV_blank>:<S2SV_blank>" , dwarf_attr_encodings [ values [ k ] . name ] ) ; } else { fprintf ( f , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TODO\\t" ) ; } r_bin_dwarf_dump_attr_value ( & values [ k ] , f ) ; fprintf ( f , "\\n" ) ; } } } }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] = ( uint16 ) ( ( ( unsigned int ) wp [ stride ] + ( unsigned int ) wp [ 0 ] ) & 0xffff ) ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 DECLAREcpFunc ( cpSeparate2ContigByRow ) { tsize_t scanlinesizein = TIFFScanlineSize ( in ) ; tsize_t scanlinesizeout = TIFFScanlineSize ( out ) ; tdata_t inbuf ; tdata_t outbuf ; register uint8 * inp , * outp ; register uint32 n ; uint32 row ; tsample_t s ; <S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> outbuf = _TIFFmalloc ( scanlinesizeout ) ; if ( ! inbuf || ! outbuf ) goto bad ; _TIFFmemset ( inbuf , 0 , scanlinesizein ) ; _TIFFmemset ( outbuf , 0 , scanlinesizeout ) ; for ( row = 0 ; row < imagelength ; row ++ ) { for ( s = 0 ; s < spp ; s ++ ) { if ( TIFFReadScanline ( in , inbuf , row , s ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>scanline<S2SV_blank>%lu" , ( unsigned long ) row ) ; goto bad ; } inp = ( uint8 * ) inbuf ; outp = ( ( uint8 * ) outbuf ) + s ; for ( n = imagewidth ; n -- > 0 ; ) { * outp = * inp ++ ; outp += spp ; } } if ( TIFFWriteScanline ( out , outbuf , row , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , "Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>scanline<S2SV_blank>%lu" , ( unsigned long ) row ) ; goto bad ; } } if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 1 ; bad : if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 0 ; }
CWE-119 static int journal_unmap_buffer ( journal_t * journal , struct buffer_head * bh ) { transaction_t * transaction ; struct journal_head * jh ; int may_free = 1 ; int ret ; BUFFER_TRACE ( bh , "entry" ) ; if ( ! buffer_jbd ( bh ) ) goto zap_buffer_unlocked ; write_lock ( & journal -> j_state_lock ) ; jbd_lock_bh_state ( bh ) ; spin_lock ( & journal -> j_list_lock ) ; jh = jbd2_journal_grab_journal_head ( bh ) ; if ( ! jh ) goto zap_buffer_no_jh ; transaction = jh -> b_transaction ; if ( transaction == NULL ) { if ( ! jh -> b_cp_transaction ) { JBUFFER_TRACE ( jh , "not<S2SV_blank>on<S2SV_blank>any<S2SV_blank>transaction:<S2SV_blank>zap" ) ; goto zap_buffer ; } if ( ! buffer_dirty ( bh ) ) { goto zap_buffer ; } if ( journal -> j_running_transaction ) { JBUFFER_TRACE ( jh , "checkpointed:<S2SV_blank>add<S2SV_blank>to<S2SV_blank>BJ_Forget" ) ; ret = __dispose_buffer ( jh , journal -> j_running_transaction ) ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return ret ; } else { if ( journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , "give<S2SV_blank>to<S2SV_blank>committing<S2SV_blank>trans" ) ; ret = __dispose_buffer ( jh , journal -> j_committing_transaction ) ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return ret ; } else { clear_buffer_jbddirty ( bh ) ; goto zap_buffer ; } } } else if ( transaction == journal -> j_committing_transaction ) { JBUFFER_TRACE ( jh , "on<S2SV_blank>committing<S2SV_blank>transaction" ) ; set_buffer_freed ( bh ) ; if ( journal -> j_running_transaction && buffer_jbddirty ( bh ) ) jh -> b_next_transaction = journal -> j_running_transaction ; jbd2_journal_put_journal_head ( jh ) ; spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; return 0 ; } else { J_ASSERT_JH ( jh , transaction == journal -> j_running_transaction ) ; JBUFFER_TRACE ( jh , "on<S2SV_blank>running<S2SV_blank>transaction" ) ; may_free = __dispose_buffer ( jh , transaction ) ; } zap_buffer : jbd2_journal_put_journal_head ( jh ) ; zap_buffer_no_jh : spin_unlock ( & journal -> j_list_lock ) ; jbd_unlock_bh_state ( bh ) ; write_unlock ( & journal -> j_state_lock ) ; zap_buffer_unlocked : clear_buffer_dirty ( bh ) ; J_ASSERT_BH ( bh , ! buffer_jbddirty ( bh ) ) ; clear_buffer_mapped ( bh ) ; clear_buffer_req ( bh ) ; clear_buffer_new ( bh ) ; <S2SV_StartBug> bh -> b_bdev = NULL ; <S2SV_EndBug> return may_free ; }
CWE-476 static int tls_construct_cke_ecdhe ( SSL * s , unsigned char * * p , int * len , int * al ) { # ifndef OPENSSL_NO_EC unsigned char * encodedPoint = NULL ; int encoded_pt_len = 0 ; EVP_PKEY * ckey = NULL , * skey = NULL ; skey = s -> s3 -> peer_tmp ; if ( skey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ; <S2SV_StartBug> if ( ssl_derive ( s , ckey , skey ) == 0 ) { <S2SV_EndBug> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EVP_LIB ) ; goto err ; } encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint ( ckey , & encodedPoint ) ; if ( encoded_pt_len == 0 ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EC_LIB ) ; goto err ; } EVP_PKEY_free ( ckey ) ; ckey = NULL ; * len = encoded_pt_len ; * * p = * len ; * p += 1 ; memcpy ( * p , encodedPoint , * len ) ; * len += 1 ; OPENSSL_free ( encodedPoint ) ; return 1 ; err : EVP_PKEY_free ( ckey ) ; return 0 ; # else SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; # endif }
CWE-125 static const char * <S2SV_StartBug> parse_field ( netdissect_options * ndo , const char * * pptr , int * len ) <S2SV_EndBug> { const char * s ; <S2SV_StartBug> if ( * len <= 0 || ! pptr || ! * pptr ) <S2SV_EndBug> return NULL ; if ( * pptr > ( const char * ) ndo -> ndo_snapend ) return NULL ; s = * pptr ; <S2SV_StartBug> while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) { <S2SV_EndBug> ( * pptr ) ++ ; ( * len ) -- ; } ( * pptr ) ++ ; ( * len ) -- ; <S2SV_StartBug> if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend ) <S2SV_EndBug> return NULL ; return s ; }
CWE-476 static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ; <S2SV_StartBug> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <S2SV_EndBug> return - EINVAL ; device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - ENODEV ; target_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) ; rc = nfc_deactivate_target ( dev , target_idx , NFC_TARGET_MODE_SLEEP ) ; nfc_put_device ( dev ) ; return rc ; }
CWE-284 static inline int accept_server_socket ( int s ) { struct sockaddr_un client_address ; socklen_t clen ; <S2SV_StartBug> int fd = accept ( s , ( struct sockaddr * ) & client_address , & clen ) ; <S2SV_EndBug> APPL_TRACE_DEBUG ( "accepted<S2SV_blank>fd:%d<S2SV_blank>for<S2SV_blank>server<S2SV_blank>fd:%d" , fd , s ) ; return fd ; }
CWE-119 int qeth_snmp_command ( struct qeth_card * card , char __user * udata ) { struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ; <S2SV_StartBug> int req_len ; <S2SV_EndBug> struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ; QETH_CARD_TEXT ( card , 3 , "snmpcmd" ) ; if ( card -> info . guestlan ) return - EOPNOTSUPP ; if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) ) { return - EOPNOTSUPP ; } if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ; if ( IS_ERR ( ureq ) ) { QETH_CARD_TEXT ( card , 2 , "snmpnome" ) ; return PTR_ERR ( ureq ) ; } qinfo . udata_len = ureq -> hdr . data_len ; qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ) ; if ( ! qinfo . udata ) { kfree ( ureq ) ; return - ENOMEM ; } qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ) ; iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) ; cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) ; memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ) ; rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) ; if ( rc ) QETH_DBF_MESSAGE ( 2 , "SNMP<S2SV_blank>command<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>(0x%x)\\n" , QETH_CARD_IFNAME ( card ) , rc ) ; else { if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) ) rc = - EFAULT ; } kfree ( ureq ) ; kfree ( qinfo . udata ) ; return rc ; }
CWE-200 int tpm_open ( struct inode * inode , struct file * file ) { int minor = iminor ( inode ) ; struct tpm_chip * chip = NULL , * pos ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( pos , & tpm_chip_list , list ) { if ( pos -> vendor . miscdev . minor == minor ) { chip = pos ; get_device ( chip -> dev ) ; break ; } } rcu_read_unlock ( ) ; if ( ! chip ) return - ENODEV ; if ( test_and_set_bit ( 0 , & chip -> is_open ) ) { dev_dbg ( chip -> dev , "Another<S2SV_blank>process<S2SV_blank>owns<S2SV_blank>this<S2SV_blank>TPM\\n" ) ; put_device ( chip -> dev ) ; return - EBUSY ; } <S2SV_StartBug> chip -> data_buffer = kmalloc ( TPM_BUFSIZE * sizeof ( u8 ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( chip -> data_buffer == NULL ) { clear_bit ( 0 , & chip -> is_open ) ; put_device ( chip -> dev ) ; return - ENOMEM ; } atomic_set ( & chip -> data_pending , 0 ) ; file -> private_data = chip ; return 0 ; }
CWE-000 int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; <S2SV_StartBug> return ! match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; <S2SV_EndBug> }
CWE-000 static OPJ_BOOL opj_pi_next_pcrl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { comp = & pi -> comps [ pi -> compno ] ; for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
CWE-200 static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { <S2SV_StartBug> sax -> sax25_family = AF_NETROM ; <S2SV_EndBug> skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ; } msg -> msg_namelen = sizeof ( * sax ) ; skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return copied ; }
CWE-000 int do_remount_sb ( struct super_block * sb , int flags , void * data , int force ) { int retval ; int remount_ro ; if ( sb -> s_writers . frozen != SB_UNFROZEN ) return - EBUSY ; # ifdef CONFIG_BLOCK if ( ! ( flags & MS_RDONLY ) && bdev_read_only ( sb -> s_bdev ) ) return - EACCES ; # endif if ( flags & MS_RDONLY ) acct_auto_close ( sb ) ; shrink_dcache_sb ( sb ) ; sync_filesystem ( sb ) ; remount_ro = ( flags & MS_RDONLY ) && ! ( sb -> s_flags & MS_RDONLY ) ; if ( remount_ro ) { if ( force ) { <S2SV_StartBug> mark_files_ro ( sb ) ; <S2SV_EndBug> } else { retval = sb_prepare_remount_readonly ( sb ) ; if ( retval ) return retval ; } } if ( sb -> s_op -> remount_fs ) { retval = sb -> s_op -> remount_fs ( sb , & flags , data ) ; if ( retval ) { if ( ! force ) goto cancel_readonly ; WARN ( 1 , "forced<S2SV_blank>remount<S2SV_blank>of<S2SV_blank>a<S2SV_blank>%s<S2SV_blank>fs<S2SV_blank>returned<S2SV_blank>%i\\n" , sb -> s_type -> name , retval ) ; } } sb -> s_flags = ( sb -> s_flags & ~ MS_RMT_MASK ) | ( flags & MS_RMT_MASK ) ; smp_wmb ( ) ; sb -> s_readonly_remount = 0 ; if ( remount_ro && sb -> s_bdev ) invalidate_bdev ( sb -> s_bdev ) ; return 0 ; cancel_readonly : sb -> s_readonly_remount = 0 ; return retval ; }
CWE-119 static int64_t http_seek_internal ( URLContext * h , int64_t off , int whence , int force_reconnect ) { HTTPContext * s = h -> priv_data ; URLContext * old_hd = s -> hd ; <S2SV_StartBug> int64_t old_off = s -> off ; <S2SV_EndBug> uint8_t old_buf [ BUFFER_SIZE ] ; int old_buf_size , ret ; AVDictionary * options = NULL ; if ( whence == AVSEEK_SIZE ) return s -> filesize ; else if ( ! force_reconnect && ( ( whence == SEEK_CUR && off == 0 ) || ( whence == SEEK_SET && off == s -> off ) ) ) return s -> off ; <S2SV_StartBug> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <S2SV_EndBug> return AVERROR ( ENOSYS ) ; if ( whence == SEEK_CUR ) off += s -> off ; else if ( whence == SEEK_END ) off += s -> filesize ; else if ( whence != SEEK_SET ) return AVERROR ( EINVAL ) ; if ( off < 0 ) return AVERROR ( EINVAL ) ; s -> off = off ; if ( s -> off && h -> is_streamed ) return AVERROR ( ENOSYS ) ; old_buf_size = s -> buf_end - s -> buf_ptr ; memcpy ( old_buf , s -> buf_ptr , old_buf_size ) ; s -> hd = NULL ; if ( ( ret = http_open_cnx ( h , & options ) ) < 0 ) { av_dict_free ( & options ) ; memcpy ( s -> buffer , old_buf , old_buf_size ) ; s -> buf_ptr = s -> buffer ; s -> buf_end = s -> buffer + old_buf_size ; s -> hd = old_hd ; s -> off = old_off ; return ret ; } av_dict_free ( & options ) ; ffurl_close ( old_hd ) ; return off ; }
CWE-416 int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
CWE-125 const char * linkaddr_string ( netdissect_options * ndo , const u_char * ep , const unsigned int type , const unsigned int len ) { register u_int i ; register char * cp ; <S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> if ( len == 0 ) return ( "<empty>" ) ; if ( type == LINKADDR_ETHER && len == ETHER_ADDR_LEN ) return ( etheraddr_string ( ndo , ep ) ) ; if ( type == LINKADDR_FRELAY ) return ( q922_string ( ndo , ep , len ) ) ; tp = lookup_bytestring ( ndo , ep , len ) ; <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> return ( tp -> e_name ) ; tp -> e_name = cp = ( char * ) malloc ( len * 3 ) ; <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , "linkaddr_string:<S2SV_blank>malloc" ) ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; for ( i = len - 1 ; i > 0 ; -- i ) { * cp ++ = ':' ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; } * cp = '\\0' ; <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> }
CWE-119 void vp9_rc_compute_frame_size_bounds ( const VP9_COMP * cpi , <S2SV_StartBug> int this_frame_target , <S2SV_EndBug> int * frame_under_shoot_limit , int * frame_over_shoot_limit ) { <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> * frame_under_shoot_limit = 0 ; * frame_over_shoot_limit = INT_MAX ; } else { <S2SV_StartBug> int recode_tolerance = <S2SV_EndBug> <S2SV_StartBug> ( cpi -> sf . recode_tolerance * this_frame_target ) / 100 ; <S2SV_EndBug> <S2SV_StartBug> * frame_over_shoot_limit = this_frame_target + recode_tolerance ; <S2SV_EndBug> * frame_under_shoot_limit = this_frame_target - recode_tolerance ; <S2SV_StartBug> * frame_over_shoot_limit += 200 ; <S2SV_EndBug> * frame_under_shoot_limit -= 200 ; if ( * frame_under_shoot_limit < 0 ) * frame_under_shoot_limit = 0 ; <S2SV_StartBug> if ( * frame_over_shoot_limit > cpi -> rc . max_frame_bandwidth ) { <S2SV_EndBug> * frame_over_shoot_limit = cpi -> rc . max_frame_bandwidth ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-476 bool CompileKeymap ( XkbFile * file , struct xkb_keymap * keymap , enum merge_mode merge ) { bool ok ; XkbFile * files [ LAST_KEYMAP_FILE_TYPE + 1 ] = { NULL } ; enum xkb_file_type type ; struct xkb_context * ctx = keymap -> ctx ; for ( file = ( XkbFile * ) file -> defs ; file ; file = ( XkbFile * ) file -> common . next ) { if ( file -> file_type < FIRST_KEYMAP_FILE_TYPE || file -> file_type > LAST_KEYMAP_FILE_TYPE ) { <S2SV_StartBug> log_err ( ctx , "Cannot<S2SV_blank>define<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>a<S2SV_blank>keymap<S2SV_blank>file\\n" , <S2SV_EndBug> <S2SV_StartBug> xkb_file_type_to_string ( file -> file_type ) ) ; <S2SV_EndBug> continue ; } if ( files [ file -> file_type ] ) { log_err ( ctx , "More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>%s<S2SV_blank>section<S2SV_blank>in<S2SV_blank>keymap<S2SV_blank>file;<S2SV_blank>" "All<S2SV_blank>sections<S2SV_blank>after<S2SV_blank>the<S2SV_blank>first<S2SV_blank>ignored\\n" , xkb_file_type_to_string ( file -> file_type ) ) ; continue ; } files [ file -> file_type ] = file ; } ok = true ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { if ( files [ type ] == NULL ) { log_err ( ctx , "Required<S2SV_blank>section<S2SV_blank>%s<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>keymap\\n" , xkb_file_type_to_string ( type ) ) ; ok = false ; } } if ( ! ok ) return false ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { log_dbg ( ctx , "Compiling<S2SV_blank>%s<S2SV_blank>\\"%s\\"\\n" , xkb_file_type_to_string ( type ) , files [ type ] -> name ) ; ok = compile_file_fns [ type ] ( files [ type ] , keymap , merge ) ; if ( ! ok ) { log_err ( ctx , "Failed<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>%s\\n" , xkb_file_type_to_string ( type ) ) ; return false ; } } return UpdateDerivedKeymapFields ( keymap ) ; }
CWE-20 void bdt_enable ( void ) { bdt_log ( "ENABLE<S2SV_blank>BT" ) ; if ( bt_enabled ) { bdt_log ( "Bluetooth<S2SV_blank>is<S2SV_blank>already<S2SV_blank>enabled" ) ; return ; } <S2SV_StartBug> status = sBtInterface -> enable ( ) ; <S2SV_EndBug> check_return_status ( status ) ; }
CWE-119 void jpc_qmfb_split_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; int hstartcol ; if ( bufsize > QMFB_SPLITBUFSIZE ) { <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> abort ( ) ; } } if ( numrows >= 2 ) { hstartcol = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartcol ; n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += numcols ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += numcols ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
CWE-20 int nfsd_dispatch ( struct svc_rqst * rqstp , __be32 * statp ) { struct svc_procedure * proc ; kxdrproc_t xdr ; __be32 nfserr ; __be32 * nfserrp ; dprintk ( "nfsd_dispatch:<S2SV_blank>vers<S2SV_blank>%d<S2SV_blank>proc<S2SV_blank>%d\\n" , rqstp -> rq_vers , rqstp -> rq_proc ) ; <S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug> rqstp -> rq_cachetype = proc -> pc_cachetype ; xdr = proc -> pc_decode ; if ( xdr && ! xdr ( rqstp , ( __be32 * ) rqstp -> rq_arg . head [ 0 ] . iov_base , rqstp -> rq_argp ) ) { dprintk ( "nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>arguments!\\n" ) ; * statp = rpc_garbage_args ; return 1 ; } switch ( nfsd_cache_lookup ( rqstp ) ) { case RC_DROPIT : return 0 ; case RC_REPLY : return 1 ; case RC_DOIT : ; } nfserrp = rqstp -> rq_res . head [ 0 ] . iov_base + rqstp -> rq_res . head [ 0 ] . iov_len ; rqstp -> rq_res . head [ 0 ] . iov_len += sizeof ( __be32 ) ; nfserr = proc -> pc_func ( rqstp , rqstp -> rq_argp , rqstp -> rq_resp ) ; nfserr = map_new_errors ( rqstp -> rq_vers , nfserr ) ; if ( nfserr == nfserr_dropit || test_bit ( RQ_DROPME , & rqstp -> rq_flags ) ) { dprintk ( "nfsd:<S2SV_blank>Dropping<S2SV_blank>request;<S2SV_blank>may<S2SV_blank>be<S2SV_blank>revisited<S2SV_blank>later\\n" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; return 0 ; } if ( rqstp -> rq_proc != 0 ) * nfserrp ++ = nfserr ; if ( ! ( nfserr && rqstp -> rq_vers == 2 ) ) { xdr = proc -> pc_encode ; if ( xdr && ! xdr ( rqstp , nfserrp , rqstp -> rq_resp ) ) { dprintk ( "nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>result!\\n" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; * statp = rpc_system_err ; return 1 ; } } nfsd_cache_update ( rqstp , rqstp -> rq_cachetype , statp + 1 ) ; return 1 ; }
CWE-119 <S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }
CWE-20 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , "<S2SV_blank>wb-prep:" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; <S2SV_StartBug> while ( -- n >= 0 && ! ND_TTEST ( * ps ) ) { <S2SV_EndBug> const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , "<S2SV_blank>%u/%s:%u" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( struct id_off * ) ( ps + 1 ) ; <S2SV_StartBug> for ( ie = io + ps -> nid ; io < ie && ! ND_TTEST ( * io ) ; ++ io ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "%c%s:%u" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , ">" ) ) ; ps = ( struct pgstate * ) io ; } return ( ( u_char * ) ps <= ep ? 0 : - 1 ) ; }
CWE-200 static void * __dma_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t flags , struct dma_attrs * attrs ) { if ( dev == NULL ) { WARN_ONCE ( 1 , "Use<S2SV_blank>an<S2SV_blank>actual<S2SV_blank>device<S2SV_blank>structure<S2SV_blank>for<S2SV_blank>DMA<S2SV_blank>allocation\\n" ) ; return NULL ; } if ( IS_ENABLED ( CONFIG_ZONE_DMA ) && dev -> coherent_dma_mask <= DMA_BIT_MASK ( 32 ) ) flags |= GFP_DMA ; if ( IS_ENABLED ( CONFIG_DMA_CMA ) && ( flags & __GFP_WAIT ) ) { struct page * page ; void * addr ; size = PAGE_ALIGN ( size ) ; page = dma_alloc_from_contiguous ( dev , size >> PAGE_SHIFT , get_order ( size ) ) ; if ( ! page ) return NULL ; * dma_handle = phys_to_dma ( dev , page_to_phys ( page ) ) ; addr = page_address ( page ) ; <S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> memset ( addr , 0 , size ) ; return addr ; } else { return swiotlb_alloc_coherent ( dev , size , dma_handle , flags ) ; } }
CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_StartBug> set_exception_intercept ( svm , AC_VECTOR ) ; <S2SV_EndBug> set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm , INTERCEPT_STGI ) ; set_intercept ( svm , INTERCEPT_CLGI ) ; set_intercept ( svm , INTERCEPT_SKINIT ) ; set_intercept ( svm , INTERCEPT_WBINVD ) ; set_intercept ( svm , INTERCEPT_MONITOR ) ; set_intercept ( svm , INTERCEPT_MWAIT ) ; set_intercept ( svm , INTERCEPT_XSETBV ) ; control -> iopm_base_pa = iopm_base ; control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; control -> int_ctl = V_INTR_MASKING_MASK ; init_seg ( & save -> es ) ; init_seg ( & save -> ss ) ; init_seg ( & save -> ds ) ; init_seg ( & save -> fs ) ; init_seg ( & save -> gs ) ; save -> cs . selector = 0xf000 ; save -> cs . base = 0xffff0000 ; save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; save -> cs . limit = 0xffff ; save -> gdtr . limit = 0xffff ; save -> idtr . limit = 0xffff ; init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; svm_set_efer ( & svm -> vcpu , 0 ) ; save -> dr6 = 0xffff0ff0 ; kvm_set_rflags ( & svm -> vcpu , 2 ) ; save -> rip = 0x0000fff0 ; svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; kvm_mmu_reset_context ( & svm -> vcpu ) ; save -> cr4 = X86_CR4_PAE ; if ( npt_enabled ) { control -> nested_ctl = 1 ; clr_intercept ( svm , INTERCEPT_INVLPG ) ; clr_exception_intercept ( svm , PF_VECTOR ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; save -> g_pat = svm -> vcpu . arch . pat ; save -> cr3 = 0 ; save -> cr4 = 0 ; } svm -> asid_generation = 0 ; svm -> nested . vmcb = 0 ; svm -> vcpu . arch . hflags = 0 ; if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { control -> pause_filter_count = 3000 ; set_intercept ( svm , INTERCEPT_PAUSE ) ; } mark_all_dirty ( svm -> vmcb ) ; enable_gif ( svm ) ; }
CWE-119 void vp8_fix_contexts ( MACROBLOCKD * x ) { if ( x -> mode_info_context -> mbmi . mode != B_PRED && x -> mode_info_context -> mbmi . mode != SPLITMV ) { <S2SV_StartBug> vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> } }
CWE-362 unsigned long insn_get_seg_base ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return - 1L ; if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ; if ( user_64bit_mode ( regs ) ) { unsigned long base ; if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ; else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ; else base = 0 ; return base ; } if ( ! sel ) return - 1L ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - 1L ; <S2SV_StartBug> return get_desc_base ( desc ) ; <S2SV_EndBug> }
CWE-264 static int svc_can_register ( const uint16_t * name , size_t name_len , pid_t spid , uid_t uid ) { const char * perm = "add" ; <S2SV_StartBug> return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ; <S2SV_EndBug> }
CWE-119 void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ; <S2SV_StartBug> show_object ( obj , NULL , name , data ) ; <S2SV_EndBug> continue ; } if ( ! path ) path = "" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object , <S2SV_StartBug> NULL , path , data ) ; <S2SV_EndBug> continue ; } die ( "unknown<S2SV_blank>pending<S2SV_blank>object<S2SV_blank>%s<S2SV_blank>(%s)" , oid_to_hex ( & obj -> oid ) , name ) ; } object_array_clear ( & revs -> pending ) ; strbuf_release ( & base ) ; }
CWE-399 static int yam_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { struct yam_port * yp = netdev_priv ( dev ) ; struct yamdrv_ioctl_cfg yi ; struct yamdrv_ioctl_mcs * ym ; int ioctl_cmd ; if ( copy_from_user ( & ioctl_cmd , ifr -> ifr_data , sizeof ( int ) ) ) return - EFAULT ; if ( yp -> magic != YAM_MAGIC ) return - EINVAL ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd != SIOCDEVPRIVATE ) return - EINVAL ; switch ( ioctl_cmd ) { case SIOCYAMRESERVED : return - EINVAL ; case SIOCYAMSMCS : if ( netif_running ( dev ) ) return - EINVAL ; if ( ( ym = kmalloc ( sizeof ( struct yamdrv_ioctl_mcs ) , GFP_KERNEL ) ) == NULL ) return - ENOBUFS ; if ( copy_from_user ( ym , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_mcs ) ) ) { kfree ( ym ) ; return - EFAULT ; } if ( ym -> bitrate > YAM_MAXBITRATE ) { kfree ( ym ) ; return - EINVAL ; } add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; kfree ( ym ) ; break ; case SIOCYAMSCFG : if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ; if ( copy_from_user ( & yi , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BITRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_BAUDRATE ) && netif_running ( dev ) ) return - EINVAL ; if ( yi . cfg . mask & YAM_IOBASE ) { yp -> iobase = yi . cfg . iobase ; dev -> base_addr = yi . cfg . iobase ; } if ( yi . cfg . mask & YAM_IRQ ) { if ( yi . cfg . irq > 15 ) return - EINVAL ; yp -> irq = yi . cfg . irq ; dev -> irq = yi . cfg . irq ; } if ( yi . cfg . mask & YAM_BITRATE ) { if ( yi . cfg . bitrate > YAM_MAXBITRATE ) return - EINVAL ; yp -> bitrate = yi . cfg . bitrate ; } if ( yi . cfg . mask & YAM_BAUDRATE ) { if ( yi . cfg . baudrate > YAM_MAXBAUDRATE ) return - EINVAL ; yp -> baudrate = yi . cfg . baudrate ; } if ( yi . cfg . mask & YAM_MODE ) { if ( yi . cfg . mode > YAM_MAXMODE ) return - EINVAL ; yp -> dupmode = yi . cfg . mode ; } if ( yi . cfg . mask & YAM_HOLDDLY ) { if ( yi . cfg . holddly > YAM_MAXHOLDDLY ) return - EINVAL ; yp -> holdd = yi . cfg . holddly ; } if ( yi . cfg . mask & YAM_TXDELAY ) { if ( yi . cfg . txdelay > YAM_MAXTXDELAY ) return - EINVAL ; yp -> txd = yi . cfg . txdelay ; } if ( yi . cfg . mask & YAM_TXTAIL ) { if ( yi . cfg . txtail > YAM_MAXTXTAIL ) return - EINVAL ; yp -> txtail = yi . cfg . txtail ; } if ( yi . cfg . mask & YAM_PERSIST ) { if ( yi . cfg . persist > YAM_MAXPERSIST ) return - EINVAL ; yp -> pers = yi . cfg . persist ; } if ( yi . cfg . mask & YAM_SLOTTIME ) { if ( yi . cfg . slottime > YAM_MAXSLOTTIME ) return - EINVAL ; yp -> slot = yi . cfg . slottime ; yp -> slotcnt = yp -> slot / 10 ; } break ; case SIOCYAMGCFG : <S2SV_StartBug> yi . cfg . mask = 0xffffffff ; <S2SV_EndBug> yi . cfg . iobase = yp -> iobase ; yi . cfg . irq = yp -> irq ; yi . cfg . bitrate = yp -> bitrate ; yi . cfg . baudrate = yp -> baudrate ; yi . cfg . mode = yp -> dupmode ; yi . cfg . txdelay = yp -> txd ; yi . cfg . holddly = yp -> holdd ; yi . cfg . txtail = yp -> txtail ; yi . cfg . persist = yp -> pers ; yi . cfg . slottime = yp -> slot ; if ( copy_to_user ( ifr -> ifr_data , & yi , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; break ; default : return - EINVAL ; } return 0 ; }
CWE-200 SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo __user * , infop , int , options , struct rusage __user * , ru ) { struct rusage r ; struct waitid_info info = { . status = 0 } ; long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; int signo = 0 ; if ( err > 0 ) { signo = SIGCHLD ; err = 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! err ) { if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; }
CWE-416 static int hci_uart_set_proto ( struct hci_uart * hu , int id ) { const struct hci_uart_proto * p ; int err ; p = hci_uart_get_proto ( id ) ; if ( ! p ) return - EPROTONOSUPPORT ; hu -> proto = p ; <S2SV_StartBug> set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> err = hci_uart_register_dev ( hu ) ; if ( err ) { <S2SV_StartBug> clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> } return 0 ; }
CWE-125 static RList * r_bin_wasm_get_global_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmGlobalEntry * ptr = NULL ; <S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug> if ( sec -> payload_data + 32 > buflen ) { return NULL ; } if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; ut32 len = sec -> payload_len ; ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; while ( i < len && len < buflen && r < count ) { if ( ! ( ptr = R_NEW0 ( RBinWasmGlobalEntry ) ) ) { return ret ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , ( ut8 * ) & ptr -> content_type , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , & ptr -> mutability , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { goto beach ; } r_list_append ( ret , ptr ) ; r ++ ; } return ret ; beach : free ( ptr ) ; return ret ; }
CWE-399 static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long nr_pages ) { struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs ) return - EBUSY ; bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) return - ENOMEM ; if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) tail = 0 ; else tail &= ( pipe -> buffers - 1 ) ; head = pipe -> nrbufs - tail ; if ( head ) memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ) ; if ( tail ) memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ) ; } <S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> kfree ( pipe -> bufs ) ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; }
CWE-190 static int growVTrans ( sqlite3 * db ) { const int ARRAY_INCR = 5 ; if ( ( db -> nVTrans % ARRAY_INCR ) == 0 ) { VTable * * aVTrans ; <S2SV_StartBug> int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ; <S2SV_EndBug> aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ; if ( ! aVTrans ) { return SQLITE_NOMEM_BKPT ; } memset ( & aVTrans [ db -> nVTrans ] , 0 , sizeof ( sqlite3_vtab * ) * ARRAY_INCR ) ; db -> aVTrans = aVTrans ; } return SQLITE_OK ; }
CWE-200 long dgnc_mgmt_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { unsigned long flags ; void __user * uarg = ( void __user * ) arg ; switch ( cmd ) { case DIGI_GETDD : { struct digi_dinfo ddi ; spin_lock_irqsave ( & dgnc_global_lock , flags ) ; <S2SV_StartBug> ddi . dinfo_nboards = dgnc_NumBoards ; <S2SV_EndBug> sprintf ( ddi . dinfo_version , "%s" , DG_PART ) ; spin_unlock_irqrestore ( & dgnc_global_lock , flags ) ; if ( copy_to_user ( uarg , & ddi , sizeof ( ddi ) ) ) return - EFAULT ; break ; } case DIGI_GETBD : { int brd ; struct digi_info di ; if ( copy_from_user ( & brd , uarg , sizeof ( int ) ) ) return - EFAULT ; if ( brd < 0 || brd >= dgnc_NumBoards ) return - ENODEV ; memset ( & di , 0 , sizeof ( di ) ) ; di . info_bdnum = brd ; spin_lock_irqsave ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; di . info_bdtype = dgnc_Board [ brd ] -> dpatype ; di . info_bdstate = dgnc_Board [ brd ] -> dpastatus ; di . info_ioport = 0 ; di . info_physaddr = ( ulong ) dgnc_Board [ brd ] -> membase ; di . info_physsize = ( ulong ) dgnc_Board [ brd ] -> membase - dgnc_Board [ brd ] -> membase_end ; if ( dgnc_Board [ brd ] -> state != BOARD_FAILED ) di . info_nports = dgnc_Board [ brd ] -> nasync ; else di . info_nports = 0 ; spin_unlock_irqrestore ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; if ( copy_to_user ( uarg , & di , sizeof ( di ) ) ) return - EFAULT ; break ; } case DIGI_GET_NI_INFO : { struct channel_t * ch ; struct ni_info ni ; unsigned char mstat = 0 ; uint board = 0 ; uint channel = 0 ; if ( copy_from_user ( & ni , uarg , sizeof ( ni ) ) ) return - EFAULT ; board = ni . board ; channel = ni . channel ; if ( board >= dgnc_NumBoards ) return - ENODEV ; if ( channel >= dgnc_Board [ board ] -> nasync ) return - ENODEV ; ch = dgnc_Board [ board ] -> channels [ channel ] ; if ( ! ch || ch -> magic != DGNC_CHANNEL_MAGIC ) return - ENODEV ; memset ( & ni , 0 , sizeof ( ni ) ) ; ni . board = board ; ni . channel = channel ; spin_lock_irqsave ( & ch -> ch_lock , flags ) ; mstat = ( ch -> ch_mostat | ch -> ch_mistat ) ; if ( mstat & UART_MCR_DTR ) { ni . mstat |= TIOCM_DTR ; ni . dtr = TIOCM_DTR ; } if ( mstat & UART_MCR_RTS ) { ni . mstat |= TIOCM_RTS ; ni . rts = TIOCM_RTS ; } if ( mstat & UART_MSR_CTS ) { ni . mstat |= TIOCM_CTS ; ni . cts = TIOCM_CTS ; } if ( mstat & UART_MSR_RI ) { ni . mstat |= TIOCM_RI ; ni . ri = TIOCM_RI ; } if ( mstat & UART_MSR_DCD ) { ni . mstat |= TIOCM_CD ; ni . dcd = TIOCM_CD ; } if ( mstat & UART_MSR_DSR ) ni . mstat |= TIOCM_DSR ; ni . iflag = ch -> ch_c_iflag ; ni . oflag = ch -> ch_c_oflag ; ni . cflag = ch -> ch_c_cflag ; ni . lflag = ch -> ch_c_lflag ; if ( ch -> ch_digi . digi_flags & CTSPACE || ch -> ch_c_cflag & CRTSCTS ) ni . hflow = 1 ; else ni . hflow = 0 ; if ( ( ch -> ch_flags & CH_STOPI ) || ( ch -> ch_flags & CH_FORCED_STOPI ) ) ni . recv_stopped = 1 ; else ni . recv_stopped = 0 ; if ( ( ch -> ch_flags & CH_STOP ) || ( ch -> ch_flags & CH_FORCED_STOP ) ) ni . xmit_stopped = 1 ; else ni . xmit_stopped = 0 ; ni . curtx = ch -> ch_txcount ; ni . currx = ch -> ch_rxcount ; ni . baud = ch -> ch_old_baud ; spin_unlock_irqrestore ( & ch -> ch_lock , flags ) ; if ( copy_to_user ( uarg , & ni , sizeof ( ni ) ) ) return - EFAULT ; break ; } } return 0 ; }
CWE-000 int vt_reset_keyboard ( int fd ) { <S2SV_StartBug> int kb ; <S2SV_EndBug> <S2SV_StartBug> kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; <S2SV_EndBug> if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ; return 0 ; }
CWE-20 int oidc_handle_redirect_uri_request ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { if ( oidc_proto_is_redirect_authorization_response ( r , c ) ) { return oidc_handle_redirect_authorization_response ( r , c , session ) ; } else if ( oidc_proto_is_post_authorization_response ( r , c ) ) { return oidc_handle_post_authorization_response ( r , c , session ) ; } else if ( oidc_is_discovery_response ( r , c ) ) { return oidc_handle_discovery_response ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , "logout" ) ) { return oidc_handle_logout ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , "jwks" ) ) { return oidc_handle_jwks ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , "session" ) ) { return oidc_handle_session_management ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , "refresh" ) ) { return oidc_handle_refresh_token_request ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , "request_uri" ) ) { return oidc_handle_request_uri ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , "remove_at_cache" ) ) { return oidc_handle_remove_at_cache ( r , c ) ; } else if ( ( r -> args == NULL ) || ( apr_strnatcmp ( r -> args , "" ) == 0 ) ) { return oidc_proto_javascript_implicit ( r , c ) ; } if ( oidc_util_request_has_parameter ( r , "error" ) ) { oidc_handle_redirect_authorization_response ( r , c , session ) ; } return oidc_util_html_send_error ( r , c -> error_template , "Invalid<S2SV_blank>Request" , apr_psprintf ( r -> pool , <S2SV_StartBug> "The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s" , <S2SV_EndBug> r -> args ) , HTTP_INTERNAL_SERVER_ERROR ) ; }
CWE-264 static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }
CWE-264 static int pppol2tp_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; struct pppol2tp_session * ps ; int val ; int err ; if ( level != SOL_PPPOL2TP ) <S2SV_StartBug> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_setsockopt ( sk , tunnel , optname , val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_setsockopt ( sk , session , optname , val ) ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }
CWE-000 static cmsPipeline * DefaultICCintents ( cmsContext ContextID , cmsUInt32Number nProfiles , cmsUInt32Number TheIntents [ ] , cmsHPROFILE hProfiles [ ] , cmsBool BPC [ ] , cmsFloat64Number AdaptationStates [ ] , cmsUInt32Number dwFlags ) { cmsPipeline * Lut = NULL ; cmsPipeline * Result ; cmsHPROFILE hProfile ; cmsMAT3 m ; cmsVEC3 off ; cmsColorSpaceSignature ColorSpaceIn , ColorSpaceOut , CurrentColorSpace ; cmsProfileClassSignature ClassSig ; cmsUInt32Number i , Intent ; if ( nProfiles == 0 ) return NULL ; Result = cmsPipelineAlloc ( ContextID , 0 , 0 ) ; if ( Result == NULL ) return NULL ; CurrentColorSpace = cmsGetColorSpace ( hProfiles [ 0 ] ) ; for ( i = 0 ; i < nProfiles ; i ++ ) { cmsBool lIsDeviceLink , lIsInput ; hProfile = hProfiles [ i ] ; ClassSig = cmsGetDeviceClass ( hProfile ) ; lIsDeviceLink = ( ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass ) ; if ( ( i == 0 ) && ! lIsDeviceLink ) { lIsInput = TRUE ; } else { lIsInput = ( CurrentColorSpace != cmsSigXYZData ) && ( CurrentColorSpace != cmsSigLabData ) ; } Intent = TheIntents [ i ] ; if ( lIsInput || lIsDeviceLink ) { ColorSpaceIn = cmsGetColorSpace ( hProfile ) ; ColorSpaceOut = cmsGetPCS ( hProfile ) ; } else { ColorSpaceIn = cmsGetPCS ( hProfile ) ; ColorSpaceOut = cmsGetColorSpace ( hProfile ) ; } if ( ! ColorSpaceIsCompatible ( ColorSpaceIn , CurrentColorSpace ) ) { cmsSignalError ( ContextID , cmsERROR_COLORSPACE_CHECK , "ColorSpace<S2SV_blank>mismatch" ) ; goto Error ; } if ( lIsDeviceLink || ( ( ClassSig == cmsSigNamedColorClass ) && ( nProfiles == 1 ) ) ) { Lut = _cmsReadDevicelinkLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; if ( ClassSig == cmsSigAbstractClass && i > 0 ) { if ( ! ComputeConversion ( i , hProfiles , Intent , BPC [ i ] , AdaptationStates [ i ] , & m , & off ) ) goto Error ; } else { _cmsMAT3identity ( & m ) ; _cmsVEC3init ( & off , 0 , 0 , 0 ) ; } if ( ! AddConversion ( Result , CurrentColorSpace , ColorSpaceIn , & m , & off ) ) goto Error ; } else { if ( lIsInput ) { Lut = _cmsReadInputLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; } else { Lut = _cmsReadOutputLUT ( hProfile , Intent ) ; if ( Lut == NULL ) goto Error ; if ( ! ComputeConversion ( i , hProfiles , Intent , BPC [ i ] , AdaptationStates [ i ] , & m , & off ) ) goto Error ; if ( ! AddConversion ( Result , CurrentColorSpace , ColorSpaceIn , & m , & off ) ) goto Error ; } } if ( ! cmsPipelineCat ( Result , Lut ) ) goto Error ; cmsPipelineFree ( Lut ) ; <S2SV_StartBug> CurrentColorSpace = ColorSpaceOut ; <S2SV_EndBug> } return Result ; Error : <S2SV_StartBug> cmsPipelineFree ( Lut ) ; <S2SV_EndBug> if ( Result != NULL ) cmsPipelineFree ( Result ) ; return NULL ; cmsUNUSED_PARAMETER ( dwFlags ) ; }
CWE-119 int DecodeTime ( char * str , int * tmask , struct tm * tm , fsec_t * fsec ) { char * cp ; * tmask = DTK_TIME_M ; tm -> tm_hour = strtol ( str , & cp , 10 ) ; if ( * cp != ':' ) return - 1 ; str = cp + 1 ; tm -> tm_min = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) { tm -> tm_sec = 0 ; * fsec = 0 ; } else if ( * cp != ':' ) return - 1 ; else { str = cp + 1 ; tm -> tm_sec = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) * fsec = 0 ; else if ( * cp == '.' ) { # ifdef HAVE_INT64_TIMESTAMP <S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> strncpy ( fstr , ( cp + 1 ) , 7 ) ; strcpy ( fstr + strlen ( fstr ) , "000000" ) ; * ( fstr + 6 ) = '\\0' ; * fsec = strtol ( fstr , & cp , 10 ) ; # else str = cp ; * fsec = strtod ( str , & cp ) ; # endif if ( * cp != '\\0' ) return - 1 ; } else return - 1 ; } # ifdef HAVE_INT64_TIMESTAMP if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= USECS_PER_SEC ) return - 1 ; # else if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= 1 ) return - 1 ; # endif return 0 ; }
CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = "tun%d" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = "tap%d" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; <S2SV_StartBug> if ( err ) <S2SV_EndBug> goto err_free_dev ; dev_net_set ( dev , net ) ; dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , "tun_set_iff\\n" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }
CWE-362 static ssize_t driver_override_show ( struct device * dev , struct device_attribute * attr , char * buf ) { struct platform_device * pdev = to_platform_device ( dev ) ; <S2SV_StartBug> return sprintf ( buf , "%s\\n" , pdev -> driver_override ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-284 static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ; <S2SV_StartBug> return true ; <S2SV_EndBug> }
CWE-000 static int tty_open ( struct inode * inode , struct file * filp ) { struct tty_struct * tty = NULL ; int noctty , retval ; struct tty_driver * driver ; int index ; dev_t device = inode -> i_rdev ; unsigned saved_flags = filp -> f_flags ; nonseekable_open ( inode , filp ) ; retry_open : noctty = filp -> f_flags & O_NOCTTY ; index = - 1 ; retval = 0 ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; if ( device == MKDEV ( TTYAUX_MAJOR , 0 ) ) { tty = get_current_tty ( ) ; if ( ! tty ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENXIO ; } driver = tty_driver_kref_get ( tty -> driver ) ; index = tty -> index ; filp -> f_flags |= O_NONBLOCK ; tty_kref_put ( tty ) ; goto got_driver ; } # ifdef CONFIG_VT if ( device == MKDEV ( TTY_MAJOR , 0 ) ) { extern struct tty_driver * console_driver ; driver = tty_driver_kref_get ( console_driver ) ; index = fg_console ; noctty = 1 ; goto got_driver ; } # endif if ( device == MKDEV ( TTYAUX_MAJOR , 1 ) ) { struct tty_driver * console_driver = console_device ( & index ) ; if ( console_driver ) { driver = tty_driver_kref_get ( console_driver ) ; if ( driver ) { filp -> f_flags |= O_NONBLOCK ; noctty = 1 ; goto got_driver ; } } tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } driver = get_tty_driver ( device , & index ) ; if ( ! driver ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } got_driver : if ( ! tty ) { tty = tty_driver_lookup_tty ( driver , inode , index ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; <S2SV_StartBug> return PTR_ERR ( tty ) ; <S2SV_EndBug> } } if ( tty ) { retval = tty_reopen ( tty ) ; if ( retval ) tty = ERR_PTR ( retval ) ; } else tty = tty_init_dev ( driver , index , 0 ) ; mutex_unlock ( & tty_mutex ) ; tty_driver_kref_put ( driver ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; return PTR_ERR ( tty ) ; } retval = tty_add_file ( tty , filp ) ; if ( retval ) { tty_unlock ( ) ; tty_release ( inode , filp ) ; return retval ; } check_tty_count ( tty , "tty_open" ) ; if ( tty -> driver -> type == TTY_DRIVER_TYPE_PTY && tty -> driver -> subtype == PTY_TYPE_MASTER ) noctty = 1 ; # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG "opening<S2SV_blank>%s..." , tty -> name ) ; # endif if ( tty -> ops -> open ) retval = tty -> ops -> open ( tty , filp ) ; else retval = - ENODEV ; filp -> f_flags = saved_flags ; if ( ! retval && test_bit ( TTY_EXCLUSIVE , & tty -> flags ) && ! capable ( CAP_SYS_ADMIN ) ) retval = - EBUSY ; if ( retval ) { # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG "error<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>opening<S2SV_blank>%s..." , retval , tty -> name ) ; # endif tty_unlock ( ) ; tty_release ( inode , filp ) ; if ( retval != - ERESTARTSYS ) return retval ; if ( signal_pending ( current ) ) return retval ; schedule ( ) ; tty_lock ( ) ; if ( filp -> f_op == & hung_up_tty_fops ) filp -> f_op = & tty_fops ; tty_unlock ( ) ; goto retry_open ; } tty_unlock ( ) ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! noctty && current -> signal -> leader && ! current -> signal -> tty && tty -> session == NULL ) __proc_set_tty ( current , tty ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return 0 ; }
CWE-189 unsigned int oom_badness ( struct task_struct * p , struct mem_cgroup * mem , const nodemask_t * nodemask , unsigned long totalpages ) { <S2SV_StartBug> int points ; <S2SV_EndBug> if ( oom_unkillable_task ( p , mem , nodemask ) ) return 0 ; p = find_lock_task_mm ( p ) ; if ( ! p ) return 0 ; if ( atomic_read ( & p -> mm -> oom_disable_count ) ) { task_unlock ( p ) ; return 0 ; } if ( ! totalpages ) totalpages = 1 ; points = get_mm_rss ( p -> mm ) + p -> mm -> nr_ptes ; points += get_mm_counter ( p -> mm , MM_SWAPENTS ) ; points *= 1000 ; points /= totalpages ; task_unlock ( p ) ; if ( has_capability_noaudit ( p , CAP_SYS_ADMIN ) ) points -= 30 ; points += p -> signal -> oom_score_adj ; if ( points <= 0 ) return 1 ; return ( points < 1000 ) ? points : 1000 ; }
CWE-000 static int copy_cred ( struct svc_cred * target , struct svc_cred * source ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> <S2SV_StartBug> ret = strdup_if_nonnull ( & target -> cr_principal , source -> cr_principal ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret ) <S2SV_EndBug> return ret ; ret = strdup_if_nonnull ( & target -> cr_raw_principal , source -> cr_raw_principal ) ; if ( ret ) return ret ; target -> cr_flavor = source -> cr_flavor ; target -> cr_uid = source -> cr_uid ; target -> cr_gid = source -> cr_gid ; target -> cr_group_info = source -> cr_group_info ; get_group_info ( target -> cr_group_info ) ; target -> cr_gss_mech = source -> cr_gss_mech ; if ( source -> cr_gss_mech ) gss_mech_get ( source -> cr_gss_mech ) ; return 0 ; }
CWE-189 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; pfn = kvm_pin_pages ( slot , gfn , page_size ) ; if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR "kvm_iommu_map_address:" "iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n" , pfn ) ; <S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> return r ; }
CWE-119 WORD32 ih264d_parse_islice_data_cabac ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; if ( ps_bitstrm -> u4_ofst & 0x07 ) { ps_bitstrm -> u4_ofst += 8 ; ps_bitstrm -> u4_ofst &= 0xFFFFFFF8 ; } ret = ih264d_init_cabac_dec_envirnoment ( & ( ps_dec -> s_cab_dec_env ) , ps_bitstrm ) ; if ( ret != OK ) return ret ; ih264d_init_cabac_contexts ( I_SLICE , ps_dec ) ; ps_dec -> i1_prev_mb_qp_delta = 0 ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD16 u2_mbx ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } { UWORD8 u1_mb_type ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; u2_mbx = ps_dec -> u2_mbx ; ps_cur_mb_info -> u1_tran_form8x8 = 0 ; ps_cur_mb_info -> ps_curmb -> u1_tran_form8x8 = 0 ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; u1_mb_type = ih264d_parse_mb_type_intra_cabac ( 0 , ps_dec ) ; if ( u1_mb_type > 25 ) return ERROR_MB_TYPE ; ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( "u1_mb_type" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cabac ( ps_dec , ps_cur_mb_info , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; if ( ps_cur_mb_info -> u1_topmb && u1_mbaff ) uc_more_data_flag = 1 ; else { uc_more_data_flag = ih264d_decode_terminate ( & ps_dec -> s_cab_dec_env , ps_bitstrm ) ; uc_more_data_flag = ! uc_more_data_flag ; COPYTHECONTEXT ( "Decode<S2SV_blank>Sliceterm" , ! uc_more_data_flag ) ; } { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs << 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag << 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs >> u1_mbaff ) ) ; } <S2SV_StartBug> u1_num_mbs ++ ; <S2SV_EndBug> ps_dec -> u2_total_mbs_coded ++ ; } u1_num_mbs_next = i2_pic_wdin_mbs - u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }
CWE-20 int tls1_setup_key_block ( SSL * s ) { unsigned char * p ; const EVP_CIPHER * c ; const EVP_MD * hash ; int num ; SSL_COMP * comp ; int mac_type = NID_undef , mac_secret_size = 0 ; int ret = 0 ; if ( s -> s3 -> tmp . key_block_length != 0 ) return ( 1 ) ; if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , & comp , <S2SV_StartBug> SSL_USE_ETM ( s ) ) ) { <S2SV_EndBug> SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ; return ( 0 ) ; } s -> s3 -> tmp . new_sym_enc = c ; s -> s3 -> tmp . new_hash = hash ; s -> s3 -> tmp . new_mac_pkey_type = mac_type ; s -> s3 -> tmp . new_mac_secret_size = mac_secret_size ; num = EVP_CIPHER_key_length ( c ) + mac_secret_size + EVP_CIPHER_iv_length ( c ) ; num *= 2 ; ssl3_cleanup_key_block ( s ) ; if ( ( p = OPENSSL_malloc ( num ) ) == NULL ) { SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , ERR_R_MALLOC_FAILURE ) ; goto err ; } s -> s3 -> tmp . key_block_length = num ; s -> s3 -> tmp . key_block = p ; # ifdef SSL_DEBUG printf ( "client<S2SV_blank>random\\n" ) ; { int z ; for ( z = 0 ; z < SSL3_RANDOM_SIZE ; z ++ ) printf ( "%02X%c" , s -> s3 -> client_random [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } printf ( "server<S2SV_blank>random\\n" ) ; { int z ; for ( z = 0 ; z < SSL3_RANDOM_SIZE ; z ++ ) printf ( "%02X%c" , s -> s3 -> server_random [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } printf ( "master<S2SV_blank>key\\n" ) ; { int z ; for ( z = 0 ; z < s -> session -> master_key_length ; z ++ ) printf ( "%02X%c" , s -> session -> master_key [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } # endif if ( ! tls1_generate_key_block ( s , p , num ) ) goto err ; # ifdef SSL_DEBUG printf ( "\\nkey<S2SV_blank>block\\n" ) ; { int z ; for ( z = 0 ; z < num ; z ++ ) printf ( "%02X%c" , p [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } # endif if ( ! ( s -> options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS ) && s -> method -> version <= TLS1_VERSION ) { s -> s3 -> need_empty_fragments = 1 ; if ( s -> session -> cipher != NULL ) { if ( s -> session -> cipher -> algorithm_enc == SSL_eNULL ) s -> s3 -> need_empty_fragments = 0 ; # ifndef OPENSSL_NO_RC4 if ( s -> session -> cipher -> algorithm_enc == SSL_RC4 ) s -> s3 -> need_empty_fragments = 0 ; # endif } } ret = 1 ; err : return ( ret ) ; }
CWE-125 static void print_trans ( netdissect_options * ndo , const u_char * words , const u_char * data1 , const u_char * buf , const u_char * maxbuf ) { u_int bcc ; const char * f1 , * f2 , * f3 , * f4 ; const u_char * data , * param ; const u_char * w = words + 1 ; int datalen , paramlen ; if ( request ) { ND_TCHECK2 ( w [ 12 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 9 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 10 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 11 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 12 * 2 ) ; f1 = "TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nMaxParmCnt=[d]<S2SV_blank>\\nMaxDataCnt=[d]\\nMaxSCnt=[d]<S2SV_blank>\\nTransFlags=[w]<S2SV_blank>\\nRes1=[w]<S2SV_blank>\\nRes2=[w]<S2SV_blank>\\nRes3=[w]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nSUCnt=[d]\\n" ; f2 = "|Name=[S]\\n" ; f3 = "|Param<S2SV_blank>" ; f4 = "|Data<S2SV_blank>" ; } else { ND_TCHECK2 ( w [ 7 * 2 ] , 2 ) ; paramlen = EXTRACT_LE_16BITS ( w + 3 * 2 ) ; param = buf + EXTRACT_LE_16BITS ( w + 4 * 2 ) ; datalen = EXTRACT_LE_16BITS ( w + 6 * 2 ) ; data = buf + EXTRACT_LE_16BITS ( w + 7 * 2 ) ; f1 = "TotParamCnt=[d]<S2SV_blank>\\nTotDataCnt=[d]<S2SV_blank>\\nRes1=[d]\\nParamCnt=[d]<S2SV_blank>\\nParamOff=[d]<S2SV_blank>\\nRes2=[d]<S2SV_blank>\\nDataCnt=[d]<S2SV_blank>\\nDataOff=[d]<S2SV_blank>\\nRes3=[d]\\nLsetup=[d]\\n" ; f2 = "|Unknown<S2SV_blank>" ; f3 = "|Param<S2SV_blank>" ; f4 = "|Data<S2SV_blank>" ; } smb_fdata ( ndo , words + 1 , f1 , min ( words + 1 + 2 * words [ 0 ] , maxbuf ) , unicodestr ) ; ND_TCHECK2 ( * data1 , 2 ) ; bcc = EXTRACT_LE_16BITS ( data1 ) ; ND_PRINT ( ( ndo , "smb_bcc=%u\\n" , bcc ) ) ; if ( bcc > 0 ) { smb_fdata ( ndo , data1 + 2 , f2 , maxbuf - ( paramlen + datalen ) , unicodestr ) ; <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , "\\\\MAILSLOT\\\\BROWSE" ) == 0 ) { <S2SV_EndBug> print_browse ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( strcmp ( ( const char * ) ( data1 + 2 ) , "\\\\PIPE\\\\LANMAN" ) == 0 ) { <S2SV_EndBug> print_ipc ( ndo , param , paramlen , data , datalen ) ; return ; } <S2SV_StartBug> if ( paramlen ) <S2SV_EndBug> smb_fdata ( ndo , param , f3 , min ( param + paramlen , maxbuf ) , unicodestr ) ; if ( datalen ) smb_fdata ( ndo , data , f4 , min ( data + datalen , maxbuf ) , unicodestr ) ; } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-125 static int mp_capable_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; <S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ; if ( MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>Unknown<S2SV_blank>Version<S2SV_blank>(%d)" , MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) ) ) ; return 1 ; } if ( mpc -> flags & MP_CAPABLE_C ) ND_PRINT ( ( ndo , "<S2SV_blank>csum" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>{0x%" PRIx64 , EXTRACT_64BITS ( mpc -> sender_key ) ) ) ; if ( opt_len == 20 ) ND_PRINT ( ( ndo , ",0x%" PRIx64 , EXTRACT_64BITS ( mpc -> receiver_key ) ) ) ; ND_PRINT ( ( ndo , "}" ) ) ; return 1 ; }
CWE-119 PHP_FUNCTION ( msgfmt_format_message ) { zval * args ; UChar * spattern = NULL ; int spattern_len = 0 ; char * pattern = NULL ; int pattern_len = 0 ; const char * slocale = NULL ; int slocale_len = 0 ; MessageFormatter_object mf = { 0 } ; MessageFormatter_object * mfo = & mf ; if ( zend_parse_method_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , getThis ( ) , "ssa" , & slocale , & slocale_len , & pattern , & pattern_len , & args ) == FAILURE ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "msgfmt_format_message:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>input<S2SV_blank>params" , 0 TSRMLS_CC ) ; RETURN_FALSE ; <S2SV_StartBug> } <S2SV_EndBug> msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ; if ( pattern && pattern_len ) { intl_convert_utf8_to_utf16 ( & spattern , & spattern_len , pattern , pattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( U_FAILURE ( INTL_DATA_ERROR_CODE ( ( mfo ) ) ) ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>UTF-16" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } } else { spattern_len = 0 ; spattern = NULL ; } if ( slocale_len == 0 ) { slocale = intl_locale_get_default ( TSRMLS_C ) ; } # ifdef MSG_FORMAT_QUOTE_APOS if ( msgformat_fix_quotes ( & spattern , & spattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) != SUCCESS ) { intl_error_set ( NULL , U_INVALID_FORMAT_ERROR , "msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>quote-friendly<S2SV_blank>format" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } # endif MSG_FORMAT_OBJECT ( mfo ) = umsg_open ( spattern , spattern_len , slocale , NULL , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( spattern && spattern_len ) { efree ( spattern ) ; } INTL_METHOD_CHECK_STATUS ( mfo , "Creating<S2SV_blank>message<S2SV_blank>formatter<S2SV_blank>failed" ) ; msgfmt_do_format ( mfo , args , return_value TSRMLS_CC ) ; msgformat_data_free ( & mfo -> mf_data TSRMLS_CC ) ; }
CWE-787 <S2SV_StartBug> static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , <S2SV_EndBug> unsigned int keylen ) { return - ENOSYS ; }
CWE-125 int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , "unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor\\n" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , "unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor<S2SV_blank>set\\n" ) ; if ( ret >= 0 ) ret = - ENOMSG ; goto err ; } total_len -= length ; for ( i = 0 ; i < num ; i ++ ) { buffer += length ; cap = ( struct usb_dev_cap_header * ) buffer ; <S2SV_StartBug> length = cap -> bLength ; <S2SV_EndBug> if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , "descriptor<S2SV_blank>type<S2SV_blank>invalid,<S2SV_blank>skip\\n" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = ( struct usb_ss_cap_descriptor * ) buffer ; break ; case USB_SSP_CAP_TYPE : dev -> bos -> ssp_cap = ( struct usb_ssp_cap_descriptor * ) buffer ; break ; case CONTAINER_ID_TYPE : dev -> bos -> ss_id = ( struct usb_ss_container_id_descriptor * ) buffer ; break ; case USB_PTM_CAP_TYPE : dev -> bos -> ptm_cap = ( struct usb_ptm_cap_descriptor * ) buffer ; default : break ; } } return 0 ; err : usb_release_bos_descriptor ( dev ) ; return ret ; }
CWE-399 static void enable_nmi_window ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; if ( ( svm -> vcpu . arch . hflags & ( HF_NMI_MASK | HF_IRET_MASK ) ) == HF_NMI_MASK ) return ; svm -> nmi_singlestep = true ; svm -> vmcb -> save . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_StartBug> update_db_bp_intercept ( vcpu ) ; <S2SV_EndBug> }
CWE-362 int __fsnotify_parent ( const struct path * path , struct dentry * dentry , __u32 mask ) { struct dentry * parent ; struct inode * p_inode ; int ret = 0 ; if ( ! dentry ) dentry = path -> dentry ; if ( ! ( dentry -> d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED ) ) return 0 ; parent = dget_parent ( dentry ) ; p_inode = parent -> d_inode ; if ( unlikely ( ! fsnotify_inode_watches_children ( p_inode ) ) ) __fsnotify_update_child_dentry_flags ( p_inode ) ; else if ( p_inode -> i_fsnotify_mask & mask ) { <S2SV_StartBug> mask |= FS_EVENT_ON_CHILD ; <S2SV_EndBug> <S2SV_StartBug> if ( path ) <S2SV_EndBug> ret = fsnotify ( p_inode , mask , path , FSNOTIFY_EVENT_PATH , <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> else ret = fsnotify ( p_inode , mask , dentry -> d_inode , FSNOTIFY_EVENT_INODE , <S2SV_StartBug> dentry -> d_name . name , 0 ) ; <S2SV_EndBug> } dput ( parent ) ; return ret ; }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_StartBug> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <S2SV_EndBug> if ( ! tmp ) <S2SV_StartBug> return ; <S2SV_EndBug> _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : { <S2SV_StartBug> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\tOptions<S2SV_blank>[%s]" , bittok2str ( ospf6_option_values , "none" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Hello<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Dead<S2SV_blank>Timer<S2SV_blank>%us,<S2SV_blank>Interface-ID<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , ",<S2SV_blank>Backup<S2SV_blank>Designated<S2SV_blank>Router<S2SV_blank>%s" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Neighbor<S2SV_blank>List:" ) ) ; ap = hellop -> hello_neighbor ; while ( ( const u_char * ) ap < dataend ) { ND_TCHECK ( * ap ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , ipaddr_string ( ndo , ap ) ) ) ; ++ ap ; } } break ; } case OSPF_TYPE_DD : { register const struct dd6 * ddp = ( const struct dd6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( ddp -> db_options ) ; ND_PRINT ( ( ndo , "\\n\\tOptions<S2SV_blank>[%s]" , bittok2str ( ospf6_option_values , "none" , EXTRACT_32BITS ( & ddp -> db_options ) ) ) ) ; ND_TCHECK ( ddp -> db_flags ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>DD<S2SV_blank>Flags<S2SV_blank>[%s]" , bittok2str ( ospf6_dd_flag_values , "none" , ddp -> db_flags ) ) ) ; ND_TCHECK ( ddp -> db_seq ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>DD-Sequence<S2SV_blank>0x%08x" , EXTRACT_16BITS ( & ddp -> db_mtu ) , EXTRACT_32BITS ( & ddp -> db_seq ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { lshp = ddp -> db_lshdr ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; } case OSPF_TYPE_LS_REQ : if ( ndo -> ndo_vflag > 1 ) { lsrp = ( const struct lsr6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lsrp < dataend ) { ND_TCHECK ( * lsrp ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Advertising<S2SV_blank>Router<S2SV_blank>%s" , ipaddr_string ( ndo , & lsrp -> ls_router ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lsrp -> ls_type ) , & lsrp -> ls_stateid ) ; ++ lsrp ; } } break ; case OSPF_TYPE_LS_UPDATE : if ( ndo -> ndo_vflag > 1 ) { register const struct lsu6 * lsup = ( const struct lsu6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK ( lsup -> lsu_count ) ; i = EXTRACT_32BITS ( & lsup -> lsu_count ) ; lsap = lsup -> lsu_lsa ; while ( ( const u_char * ) lsap < dataend && i -- ) { if ( ospf6_print_lsa ( ndo , lsap , dataend ) ) goto trunc ; lsap = ( const struct lsa6 * ) ( ( const u_char * ) lsap + EXTRACT_16BITS ( & lsap -> ls_hdr . ls_length ) ) ; } } break ; case OSPF_TYPE_LS_ACK : if ( ndo -> ndo_vflag > 1 ) { lshp = ( const struct lsa6_hdr * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; while ( ( const u_char * ) lshp < dataend ) { if ( ospf6_print_lshdr ( ndo , lshp ++ , dataend ) ) goto trunc ; } } break ; default : break ; } return ( 0 ) ; trunc : return ( 1 ) ; }
CWE-119 static void sum_intra_stats ( VP8_COMP * cpi , MACROBLOCK * x ) { const MACROBLOCKD * xd = & x -> e_mbd ; const MB_PREDICTION_MODE m = xd -> mode_info_context -> mbmi . mode ; const MB_PREDICTION_MODE uvm = xd -> mode_info_context -> mbmi . uv_mode ; # ifdef MODE_STATS const int is_key = cpi -> common . frame_type == KEY_FRAME ; ++ ( is_key ? uv_modes : inter_uv_modes ) [ uvm ] ; if ( m == B_PRED ) { unsigned int * const bct = is_key ? b_modes : inter_b_modes ; int b = 0 ; do { ++ bct [ xd -> block [ b ] . bmi . mode ] ; } while ( ++ b < 16 ) ; } <S2SV_StartBug> # endif <S2SV_EndBug> ++ x -> ymode_count [ m ] ; ++ x -> uv_mode_count [ uvm ] ; }
CWE-000 IMPEG2D_ERROR_CODES_T impeg2d_dec_slice ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_slice_vertical_position ; UWORD32 u4_slice_vertical_position_extension ; IMPEG2D_ERROR_CODES_T e_error ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_PREFIX_LEN ) ; u4_slice_vertical_position = impeg2d_bit_stream_get ( ps_stream , 8 ) ; if ( u4_slice_vertical_position > 2800 ) { u4_slice_vertical_position_extension = impeg2d_bit_stream_get ( ps_stream , 3 ) ; u4_slice_vertical_position += ( u4_slice_vertical_position_extension << 7 ) ; } if ( ( u4_slice_vertical_position > ps_dec -> u2_num_vert_mb ) || ( u4_slice_vertical_position == 0 ) ) { return IMPEG2D_INVALID_VERT_SIZE ; } u4_slice_vertical_position -- ; if ( ps_dec -> u2_mb_y != u4_slice_vertical_position ) { ps_dec -> u2_mb_y = u4_slice_vertical_position ; ps_dec -> u2_mb_x = 0 ; } ps_dec -> u2_first_mb = 1 ; { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = impeg2d_bit_stream_get ( ps_stream , 5 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; } if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 9 ) ; <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , 9 ) ; } } impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; e_error = ps_dec -> pf_decode_slice ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { return e_error ; } if ( ps_dec -> u2_mb_y < ps_dec -> u2_num_vert_mb ) impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-399 void free_pipe_info ( struct pipe_inode_info * pipe ) { <S2SV_StartBug> int i ; <S2SV_EndBug> for ( i = 0 ; i < pipe -> buffers ; i ++ ) { struct pipe_buffer * buf = pipe -> bufs + i ; if ( buf -> ops ) buf -> ops -> release ( pipe , buf ) ; } if ( pipe -> tmp_page ) __free_page ( pipe -> tmp_page ) ; kfree ( pipe -> bufs ) ; kfree ( pipe ) ; }
CWE-125 static char * isis_print_id ( const uint8_t * cp , int id_len ) { int i ; static char id [ sizeof ( "xxxx.xxxx.xxxx.yy-zz" ) ] ; char * pos = id ; <S2SV_StartBug> for ( i = 1 ; i <= SYSTEM_ID_LEN ; i ++ ) { <S2SV_EndBug> snprintf ( pos , sizeof ( id ) - ( pos - id ) , "%02x" , * cp ++ ) ; pos += strlen ( pos ) ; if ( i == 2 || i == 4 ) * pos ++ = '.' ; } if ( id_len >= NODE_ID_LEN ) { snprintf ( pos , sizeof ( id ) - ( pos - id ) , ".%02x" , * cp ++ ) ; pos += strlen ( pos ) ; } if ( id_len == LSP_ID_LEN ) snprintf ( pos , sizeof ( id ) - ( pos - id ) , "-%02x" , * cp ) ; return ( id ) ; }
CWE-119 static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> int ret ; if ( strstr ( name , "tpgt_" ) != name ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }
CWE-415 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc ) <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
CWE-264 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! ip_checkentry ( & e -> ip ) ) return - EINVAL ; <S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , "(pad1)" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , "(padn:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(padn)" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , "(refresh:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , "(refresh:<S2SV_blank>%u)" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , "(altcoa:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(alt-CoA:<S2SV_blank>%s)" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , "(ni:<S2SV_blank>trunc)" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , "(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)" , <S2SV_EndBug> EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , "(auth:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(auth)" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , "(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(type-0x%02x:<S2SV_blank>len=%u)" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
CWE-000 static int pcrypt_create_aead ( struct crypto_template * tmpl , struct rtattr * * tb , u32 type , u32 mask ) { struct pcrypt_instance_ctx * ctx ; struct crypto_attr_type * algt ; struct aead_instance * inst ; struct aead_alg * alg ; const char * name ; int err ; algt = crypto_get_attr_type ( tb ) ; if ( IS_ERR ( algt ) ) return PTR_ERR ( algt ) ; name = crypto_attr_alg_name ( tb [ 1 ] ) ; if ( IS_ERR ( name ) ) return PTR_ERR ( name ) ; inst = kzalloc ( sizeof ( * inst ) + sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! inst ) return - ENOMEM ; ctx = aead_instance_ctx ( inst ) ; crypto_set_aead_spawn ( & ctx -> spawn , aead_crypto_instance ( inst ) ) ; err = crypto_grab_aead ( & ctx -> spawn , name , 0 , 0 ) ; if ( err ) goto out_free_inst ; alg = crypto_spawn_aead_alg ( & ctx -> spawn ) ; err = pcrypt_init_instance ( aead_crypto_instance ( inst ) , & alg -> base ) ; if ( err ) goto out_drop_aead ; inst -> alg . base . cra_flags = CRYPTO_ALG_ASYNC ; inst -> alg . ivsize = crypto_aead_alg_ivsize ( alg ) ; inst -> alg . maxauthsize = crypto_aead_alg_maxauthsize ( alg ) ; inst -> alg . base . cra_ctxsize = sizeof ( struct pcrypt_aead_ctx ) ; inst -> alg . init = pcrypt_aead_init_tfm ; inst -> alg . exit = pcrypt_aead_exit_tfm ; inst -> alg . setkey = pcrypt_aead_setkey ; inst -> alg . setauthsize = pcrypt_aead_setauthsize ; inst -> alg . encrypt = pcrypt_aead_encrypt ; inst -> alg . decrypt = pcrypt_aead_decrypt ; <S2SV_StartBug> err = aead_register_instance ( tmpl , inst ) ; <S2SV_EndBug> if ( err ) goto out_drop_aead ; out : return err ; out_drop_aead : crypto_drop_aead ( & ctx -> spawn ) ; out_free_inst : kfree ( inst ) ; goto out ; }
CWE-416 static void put_ucounts ( struct ucounts * ucounts ) { unsigned long flags ; <S2SV_StartBug> if ( atomic_dec_and_test ( & ucounts -> count ) ) { <S2SV_EndBug> spin_lock_irqsave ( & ucounts_lock , flags ) ; <S2SV_StartBug> hlist_del_init ( & ucounts -> node ) ; <S2SV_EndBug> spin_unlock_irqrestore ( & ucounts_lock , flags ) ; kfree ( ucounts ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static int find_best_16x16_intra ( VP9_COMP * cpi , <S2SV_StartBug> MB_PREDICTION_MODE * pbest_mode ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> MB_PREDICTION_MODE best_mode = - 1 , mode ; <S2SV_EndBug> unsigned int best_err = INT_MAX ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { unsigned int err ; xd -> mi [ 0 ] -> mbmi . mode = mode ; <S2SV_StartBug> vp9_predict_intra_block ( xd , 0 , 2 , TX_16X16 , mode , <S2SV_EndBug> x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , 0 , 0 , 0 ) ; <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , best_err ) ; if ( err < best_err ) { best_err = err ; best_mode = mode ; } } if ( pbest_mode ) * pbest_mode = best_mode ; return best_err ; }
CWE-125 void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_info ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-200 static int copy_to_user_auth ( struct xfrm_algo_auth * auth , struct sk_buff * skb ) { struct xfrm_algo * algo ; struct nlattr * nla ; nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ) ; if ( ! nla ) return - EMSGSIZE ; algo = nla_data ( nla ) ; <S2SV_StartBug> strcpy ( algo -> alg_name , auth -> alg_name ) ; <S2SV_EndBug> memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ) ; algo -> alg_key_len = auth -> alg_key_len ; return 0 ; }
CWE-119 <S2SV_StartBug> void vp9_model_to_full_probs ( const vp9_prob * model , vp9_prob * full ) { <S2SV_EndBug> if ( full != model ) <S2SV_StartBug> vpx_memcpy ( full , model , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> extend_to_full_distribution ( & full [ UNCONSTRAINED_NODES ] , model [ PIVOT_NODE ] ) ; }
CWE-119 static FILE * open_outfile ( const char * name ) { if ( strcmp ( "-" , name ) == 0 ) { set_binary_mode ( stdout ) ; return stdout ; } else { FILE * file = fopen ( name , "wb" ) ; if ( ! file ) <S2SV_StartBug> fatal ( "Failed<S2SV_blank>to<S2SV_blank>output<S2SV_blank>file<S2SV_blank>%s" , name ) ; <S2SV_EndBug> return file ; } }
CWE-399 <S2SV_StartBug> void unix_inflight ( struct file * fp ) <S2SV_EndBug> { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; } <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_EndBug> spin_unlock ( & unix_gc_lock ) ; }
CWE-125 int sock_queue_err_skb ( struct sock * sk , struct sk_buff * skb ) { if ( atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize >= ( unsigned int ) sk -> sk_rcvbuf ) return - ENOMEM ; skb_orphan ( skb ) ; skb -> sk = sk ; skb -> destructor = sock_rmem_free ; atomic_add ( skb -> truesize , & sk -> sk_rmem_alloc ) ; <S2SV_StartBug> skb_dst_force ( skb ) ; <S2SV_EndBug> skb_queue_tail ( & sk -> sk_error_queue , skb ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk ) ; return 0 ; }
CWE-284 static __be32 nfsd3_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd3_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ; <S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> error = - EOPNOTSUPP ; goto out_errno ; <S2SV_StartBug> } <S2SV_EndBug> error = fh_want_write ( fh ) ; if ( error ) <S2SV_StartBug> goto out_errno ; <S2SV_EndBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; if ( error ) goto out_drop_write ; <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; out_drop_write : fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; RETURN_STATUS ( nfserr ) ; }
CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }
CWE-362 int ext4_punch_hole ( struct inode * inode , loff_t offset , loff_t length ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t first_block , stop_block ; struct address_space * mapping = inode -> i_mapping ; loff_t first_block_offset , last_block_offset ; handle_t * handle ; unsigned int credits ; int ret = 0 ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_punch_hole ( inode , offset , length , 0 ) ; if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + length - 1 ) ; if ( ret ) return ret ; } mutex_lock ( & inode -> i_mutex ) ; if ( offset >= inode -> i_size ) goto out_mutex ; if ( offset + length > inode -> i_size ) { length = inode -> i_size + PAGE_CACHE_SIZE - ( inode -> i_size & ( PAGE_CACHE_SIZE - 1 ) ) - offset ; } if ( offset & ( sb -> s_blocksize - 1 ) || ( offset + length ) & ( sb -> s_blocksize - 1 ) ) { ret = ext4_inode_attach_jinode ( inode ) ; if ( ret < 0 ) goto out_mutex ; } <S2SV_StartBug> first_block_offset = round_up ( offset , sb -> s_blocksize ) ; <S2SV_EndBug> last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ; if ( last_block_offset > first_block_offset ) truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) credits = ext4_writepage_trans_blocks ( inode ) ; else credits = ext4_blocks_for_truncate ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( sb , ret ) ; goto out_dio ; } ret = ext4_zero_partial_blocks ( handle , inode , offset , length ) ; if ( ret ) goto out_stop ; first_block = ( offset + sb -> s_blocksize - 1 ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( first_block >= stop_block ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; ret = ext4_es_remove_extent ( inode , first_block , stop_block - first_block ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ret = ext4_ext_remove_space ( inode , first_block , stop_block - 1 ) ; else ret = ext4_ind_remove_space ( handle , inode , first_block , stop_block ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; <S2SV_StartBug> if ( last_block_offset > first_block_offset ) <S2SV_EndBug> truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; out_stop : ext4_journal_stop ( handle ) ; out_dio : <S2SV_StartBug> ext4_inode_resume_unlocked_dio ( inode ) ; <S2SV_EndBug> out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
CWE-119 static void close_output_file ( struct stream_state * stream , unsigned int fourcc ) { const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { <S2SV_StartBug> write_webm_file_footer ( & stream -> ebml , stream -> hash ) ; <S2SV_EndBug> free ( stream -> ebml . cue_list ) ; stream -> ebml . cue_list = NULL ; } # endif if ( ! stream -> config . write_webm ) { if ( ! fseek ( stream -> file , 0 , SEEK_SET ) ) ivf_write_file_header ( stream -> file , & stream -> config . cfg , fourcc , stream -> frames_out ) ; } fclose ( stream -> file ) ; }
CWE-119 void vp8_denoiser_free ( VP8_DENOISER * denoiser ) { int i ; assert ( denoiser ) ; for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_running_avg [ i ] ) ; } vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_mc_running_avg ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 void js_RegExp_prototype_exec ( js_State * J , js_Regexp * re , const char * text ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int opts ; Resub m ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushnull ( J ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> js_newarray ( J ) ; js_pushstring ( J , text ) ; js_setproperty ( J , - 2 , "input" ) ; js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; js_setproperty ( J , - 2 , "index" ) ; for ( i = 0 ; i < m . nsub ; ++ i ) { js_pushlstring ( J , m . sub [ i ] . sp , m . sub [ i ] . ep - m . sub [ i ] . sp ) ; js_setindex ( J , - 2 , i ) ; } if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushnull ( J ) ; }
CWE-20 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( "size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n" , size , msg_flags , timeo ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( "recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( "copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; msg -> msg_namelen = sizeof ( * sin ) ; } break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
CWE-264 int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; if ( fd < 0 ) return - errno ; <S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug> r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }
CWE-20 static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( "Wrong<S2SV_blank>len<S2SV_blank>argument\\n" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( "Entries_size<S2SV_blank>never<S2SV_blank>zero\\n" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( "Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }
CWE-000 OM_uint32 kg_unseal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int * conf_state , gss_qop_t * qop_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; OM_uint32 code ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_STREAM ) != NULL ) { code = kg_unseal_stream_iov ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } else { code = kg_unseal_iov_token ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } return code ; }
CWE-000 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_start_code ; IMPEG2D_ERROR_CODES_T e_error ; e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && <S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> { if ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_dec_user_data ( ps_dec ) ; } else { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; switch ( u4_start_code ) { case SEQ_DISPLAY_EXT_ID : impeg2d_dec_seq_disp_ext ( ps_dec ) ; break ; case SEQ_SCALABLE_EXT_ID : e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED ; break ; default : impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; impeg2d_peek_next_start_code ( ps_dec ) ; break ; } } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } return e_error ; }
CWE-119 static grub_err_t read_foo ( struct grub_disk * disk , grub_disk_addr_t sector , grub_size_t size , char * buf ) { <S2SV_StartBug> if ( disk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> const int blocksize = 512 ; <S2SV_EndBug> int ret ; RIOBind * iob = disk -> data ; <S2SV_StartBug> if ( bio ) iob = bio ; <S2SV_EndBug> <S2SV_StartBug> ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , <S2SV_EndBug> <S2SV_StartBug> ( ut8 * ) buf , size * blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == - 1 ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> } else eprintf ( "oops.<S2SV_blank>no<S2SV_blank>disk\\n" ) ; <S2SV_EndBug> return 0 ; }
CWE-399 static int swp_handler ( struct pt_regs * regs , unsigned int instr ) { unsigned int address , destreg , data , type ; unsigned int res = 0 ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> if ( current -> pid != previous_pid ) { pr_debug ( "\\"%s\\"<S2SV_blank>(%ld)<S2SV_blank>uses<S2SV_blank>deprecated<S2SV_blank>SWP{B}<S2SV_blank>instruction\\n" , current -> comm , ( unsigned long ) current -> pid ) ; previous_pid = current -> pid ; } address = regs -> uregs [ EXTRACT_REG_NUM ( instr , RN_OFFSET ) ] ; data = regs -> uregs [ EXTRACT_REG_NUM ( instr , RT2_OFFSET ) ] ; destreg = EXTRACT_REG_NUM ( instr , RT_OFFSET ) ; type = instr & TYPE_SWPB ; pr_debug ( "addr<S2SV_blank>in<S2SV_blank>r%d->0x%08x,<S2SV_blank>dest<S2SV_blank>is<S2SV_blank>r%d,<S2SV_blank>source<S2SV_blank>in<S2SV_blank>r%d->0x%08x)\\n" , EXTRACT_REG_NUM ( instr , RN_OFFSET ) , address , destreg , EXTRACT_REG_NUM ( instr , RT2_OFFSET ) , data ) ; if ( ! access_ok ( VERIFY_WRITE , ( address & ~ 3 ) , 4 ) ) { pr_debug ( "SWP{B}<S2SV_blank>emulation:<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>not<S2SV_blank>allowed!\\n" , ( void * ) address ) ; res = - EFAULT ; } else { res = emulate_swpX ( address , & data , type ) ; } if ( res == 0 ) { regs -> ARM_pc += 4 ; regs -> uregs [ destreg ] = data ; } else if ( res == - EFAULT ) { set_segfault ( regs , address ) ; } return 0 ; }
CWE-000 void open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ; <S2SV_StartBug> log_file = fopen ( file_name , "a" ) ; <S2SV_EndBug> if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }
CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-119 <S2SV_StartBug> static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> int i ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) for ( i = 0 ; i < COMP_INTER_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_inter_prob [ i ] ) ; if ( cm -> reference_mode != COMPOUND_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) { vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 0 ] ) ; vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 1 ] ) ; } if ( cm -> reference_mode != SINGLE_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_ref_prob [ i ] ) ; }
CWE-119 void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } if ( ps_op -> s_ivd_video_decode_op_t . u4_error_code == 0 ) ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; <S2SV_StartBug> impeg2d_next_code ( ps_dec , SEQUENCE_HEADER_CODE ) ; <S2SV_EndBug> return ; } } ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_vertical_size ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_horizontal_size ; ps_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; } ps_op -> s_ivd_video_decode_op_t . u4_frame_decoded_flag = 0 ; ps_dec -> u2_header_done = 1 ; } }
CWE-000 static ssize_t aio_setup_vectored_rw ( int type , struct kiocb * kiocb , bool compat ) { ssize_t ret ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( type , ( struct compat_iovec __user * ) kiocb -> ki_buf , kiocb -> ki_nbytes , 1 , & kiocb -> ki_inline_vec , & kiocb -> ki_iovec , 1 ) ; else # endif ret = rw_copy_check_uvector ( type , ( struct iovec __user * ) kiocb -> ki_buf , kiocb -> ki_nbytes , 1 , & kiocb -> ki_inline_vec , & kiocb -> ki_iovec , 1 ) ; if ( ret < 0 ) goto out ; <S2SV_StartBug> kiocb -> ki_nr_segs = kiocb -> ki_nbytes ; <S2SV_EndBug> kiocb -> ki_cur_seg = 0 ; kiocb -> ki_nbytes = ret ; kiocb -> ki_left = ret ; ret = 0 ; out : return ret ; }
CWE-399 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>" "0x%llx\\n" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , "%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { <S2SV_StartBug> kvmclock_reset ( vcpu ) ; <S2SV_EndBug> vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vcpu -> arch . time_offset & <S2SV_EndBug> ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_page = <S2SV_EndBug> <S2SV_StartBug> gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; <S2SV_EndBug> if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , "disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , "ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , "unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , "ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; break ; } } return 0 ; }
CWE-787 static int decode_zbuf ( AVBPrint * bp , const uint8_t * data , const uint8_t * data_end ) { z_stream zstream ; unsigned char * buf ; unsigned buf_size ; int ret ; zstream . zalloc = ff_png_zalloc ; zstream . zfree = ff_png_zfree ; zstream . opaque = NULL ; if ( inflateInit ( & zstream ) != Z_OK ) return AVERROR_EXTERNAL ; zstream . next_in = ( unsigned char * ) data ; zstream . avail_in = data_end - data ; av_bprint_init ( bp , 0 , - 1 ) ; while ( zstream . avail_in > 0 ) { <S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> if ( ! buf_size ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } zstream . next_out = buf ; <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ; if ( ret != Z_OK && ret != Z_STREAM_END ) { ret = AVERROR_EXTERNAL ; goto fail ; } bp -> len += zstream . next_out - buf ; if ( ret == Z_STREAM_END ) break ; } inflateEnd ( & zstream ) ; bp -> str [ bp -> len ] = 0 ; return 0 ; fail : inflateEnd ( & zstream ) ; av_bprint_finalize ( bp , NULL ) ; return ret ; }
CWE-125 static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank>[max<S2SV_blank>resp<S2SV_blank>delay=%d]" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[gaddr<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , "<S2SV_blank>sflag" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , "<S2SV_blank>robustness=%d" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>qqi=%d" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] , 2 ) ; nsrcs = EXTRACT_16BITS ( & bp [ 26 ] ) ; if ( nsrcs > 0 ) { if ( len < 28 + nsrcs * sizeof ( struct in6_addr ) ) ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources]" ) ) ; else if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>{" ) ) ; for ( i = 0 ; i < nsrcs ; i ++ ) { ND_TCHECK2 ( bp [ 28 + i * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ 28 + i * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>}" ) ) ; } else ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>source(s)" , nsrcs ) ) ; } ND_PRINT ( ( ndo , "]" ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> return ; }
CWE-20 void exit_io_context ( void ) { struct io_context * ioc ; task_lock ( current ) ; ioc = current -> io_context ; current -> io_context = NULL ; task_unlock ( current ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; <S2SV_StartBug> put_io_context ( ioc ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug> __reg_bound_offset ( dst_reg ) ; return 0 ; }
CWE-000 static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , "enter" ) ; const char * java_script = "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\"text/javascript\\">\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n" "\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" <S2SV_StartBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n" <S2SV_EndBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n" "\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n" "\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = "openidc-op" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , "no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , "poll" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = "3000" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , "setTimer" , NULL , DONE ) ; }
CWE-119 void vp9_disable_segmentation ( struct segmentation * seg ) { seg -> enabled = 0 ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> int i ; fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank><options><S2SV_blank>filename\\n\\n" "Options:\\n" , exec_name ) ; arg_show_usage ( stderr , all_args ) ; # if CONFIG_VP8_DECODER fprintf ( stderr , "\\nVP8<S2SV_blank>Postprocessing<S2SV_blank>Options:\\n" ) ; arg_show_usage ( stderr , vp8_pp_args ) ; # endif fprintf ( stderr , "\\nOutput<S2SV_blank>File<S2SV_blank>Patterns:\\n\\n" "<S2SV_blank><S2SV_blank>The<S2SV_blank>-o<S2SV_blank>argument<S2SV_blank>specifies<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>" "write<S2SV_blank>to.<S2SV_blank>If<S2SV_blank>the\\n<S2SV_blank><S2SV_blank>argument<S2SV_blank>does<S2SV_blank>not<S2SV_blank>include<S2SV_blank>any<S2SV_blank>escape<S2SV_blank>" "characters,<S2SV_blank>the<S2SV_blank>output<S2SV_blank>will<S2SV_blank>be\\n<S2SV_blank><S2SV_blank>written<S2SV_blank>to<S2SV_blank>a<S2SV_blank>single<S2SV_blank>file.<S2SV_blank>" "Otherwise,<S2SV_blank>the<S2SV_blank>filename<S2SV_blank>will<S2SV_blank>be<S2SV_blank>calculated<S2SV_blank>by\\n<S2SV_blank><S2SV_blank>expanding<S2SV_blank>" "the<S2SV_blank>following<S2SV_blank>escape<S2SV_blank>characters:\\n" ) ; fprintf ( stderr , "\\n\\t%%w<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>Frame<S2SV_blank>width" "\\n\\t%%h<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>Frame<S2SV_blank>height" "\\n\\t%%<n><S2SV_blank>-<S2SV_blank>Frame<S2SV_blank>number,<S2SV_blank>zero<S2SV_blank>padded<S2SV_blank>to<S2SV_blank><n><S2SV_blank>places<S2SV_blank>(1..9)" "\\n\\n<S2SV_blank><S2SV_blank>Pattern<S2SV_blank>arguments<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>conjunction<S2SV_blank>" "with<S2SV_blank>the<S2SV_blank>--yv12<S2SV_blank>and\\n<S2SV_blank><S2SV_blank>--i420<S2SV_blank>options.<S2SV_blank>If<S2SV_blank>the<S2SV_blank>-o<S2SV_blank>option<S2SV_blank>is<S2SV_blank>" "not<S2SV_blank>specified,<S2SV_blank>the<S2SV_blank>output<S2SV_blank>will<S2SV_blank>be\\n<S2SV_blank><S2SV_blank>directed<S2SV_blank>to<S2SV_blank>stdout.\\n" ) ; fprintf ( stderr , "\\nIncluded<S2SV_blank>decoders:\\n\\n" ) ; for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\n" , <S2SV_StartBug> decoder -> name , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> } exit ( EXIT_FAILURE ) ; }
CWE-189 TSQuery parse_tsquery ( char * buf , PushFunction pushval , Datum opaque , bool isplain ) { struct TSQueryParserStateData state ; int i ; TSQuery query ; int commonlen ; QueryItem * ptr ; ListCell * cell ; state . buffer = buf ; state . buf = buf ; state . state = ( isplain ) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND ; state . count = 0 ; state . polstr = NIL ; state . valstate = init_tsvector_parser ( state . buffer , true , true ) ; state . sumlen = 0 ; state . lenop = 64 ; state . curop = state . op = ( char * ) palloc ( state . lenop ) ; * ( state . curop ) = '\\0' ; makepol ( & state , pushval , opaque ) ; close_tsvector_parser ( state . valstate ) ; if ( list_length ( state . polstr ) == 0 ) { ereport ( NOTICE , ( errmsg ( "text-search<S2SV_blank>query<S2SV_blank>doesn\'t<S2SV_blank>contain<S2SV_blank>lexemes:<S2SV_blank>\\"%s\\"" , state . buffer ) ) ) ; query = ( TSQuery ) palloc ( HDRSIZETQ ) ; SET_VARSIZE ( query , HDRSIZETQ ) ; query -> size = 0 ; return query ; <S2SV_StartBug> } <S2SV_EndBug> commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ; query = ( TSQuery ) palloc0 ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = list_length ( state . polstr ) ; ptr = GETQUERY ( query ) ; i = 0 ; foreach ( cell , state . polstr ) { QueryItem * item = ( QueryItem * ) lfirst ( cell ) ; switch ( item -> type ) { case QI_VAL : memcpy ( & ptr [ i ] , item , sizeof ( QueryOperand ) ) ; break ; case QI_VALSTOP : ptr [ i ] . type = QI_VALSTOP ; break ; case QI_OPR : memcpy ( & ptr [ i ] , item , sizeof ( QueryOperator ) ) ; break ; default : elog ( ERROR , "unrecognized<S2SV_blank>QueryItem<S2SV_blank>type:<S2SV_blank>%d" , item -> type ) ; } i ++ ; } memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; pfree ( state . op ) ; findoprnd ( ptr , query -> size ) ; return query ; }
CWE-000 static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; <S2SV_StartBug> krb5_key_data * key_data ; <S2SV_EndBug> if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; <S2SV_StartBug> if ( key_data_in == NULL ) <S2SV_EndBug> goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; if ( ret [ j ] == NULL ) goto cleanup ; err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ; if ( err ) goto cleanup ; ret [ j ] -> bv_len = code -> length ; ret [ j ] -> bv_val = code -> data ; free ( code ) ; j ++ ; last = i + 1 ; if ( i < n_key_data - 1 ) currkvno = key_data [ i + 1 ] . key_data_kvno ; } } ret [ num_versions ] = NULL ; cleanup : free ( key_data ) ; if ( err != 0 ) { if ( ret != NULL ) { <S2SV_StartBug> for ( i = 0 ; i <= num_versions ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( ret [ i ] != NULL ) <S2SV_EndBug> free ( ret [ i ] ) ; free ( ret ) ; ret = NULL ; } } return ret ; }
CWE-119 void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , "EOF" , len ) ; return ; case LEX_ID : strncpy ( str , "ID" , len ) ; return ; case LEX_INT : strncpy ( str , "INT" , len ) ; return ; case LEX_FLOAT : strncpy ( str , "FLOAT" , len ) ; return ; case LEX_STR : strncpy ( str , "STRING" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , "UNFINISHED<S2SV_blank>STRING" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , "TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; case LEX_REGEX : strncpy ( str , "REGEX" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , "UNFINISHED<S2SV_blank>REGEX" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , "UNFINISHED<S2SV_blank>COMMENT" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = "==\\0" "===\\0" "!=\\0" "!==\\0" "<=\\0" "<<\\0" "<<=\\0" ">=\\0" ">>\\0" ">>>\\0" ">>=\\0" ">>>=\\0" "+=\\0" "-=\\0" "++\\0" "--\\0" "*=\\0" "/=\\0" "%=\\0" "&=\\0" "&&\\0" "|=\\0" "||\\0" "^=\\0" "=>\\0" "if\\0" "else\\0" "do\\0" "while\\0" "for\\0" "return\\0" "continue\\0" "function\\0" "return\\0" "var\\0" "let\\0" "const\\0" "this\\0" "throw\\0" "try\\0" "catch\\0" "finally\\0" "true\\0" "false\\0" "null\\0" "undefined\\0" "new\\0" "in\\0" "instanceof\\0" "switch\\0" "case\\0" "default\\0" "delete\\0" "typeof\\0" "void\\0" "debugger\\0" "class\\0" "extends\\0" "super\\0" "static\\0" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; <S2SV_StartBug> strncpy ( str , "?[" , len ) ; <S2SV_EndBug> itostr ( token , & str [ 2 ] , 10 ) ; strncat ( str , "]" , len ) ; }
CWE-399 static netdev_tx_t veth_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct net_device * rcv = NULL ; struct veth_priv * priv , * rcv_priv ; struct veth_net_stats * stats , * rcv_stats ; int length ; priv = netdev_priv ( dev ) ; rcv = priv -> peer ; rcv_priv = netdev_priv ( rcv ) ; stats = this_cpu_ptr ( priv -> stats ) ; rcv_stats = this_cpu_ptr ( rcv_priv -> stats ) ; if ( ! ( rcv -> flags & IFF_UP ) ) goto tx_drop ; if ( dev -> features & NETIF_F_NO_CSUM ) skb -> ip_summed = rcv_priv -> ip_summed ; length = skb -> len + ETH_HLEN ; if ( dev_forward_skb ( rcv , skb ) != NET_RX_SUCCESS ) goto rx_drop ; stats -> tx_bytes += length ; stats -> tx_packets ++ ; rcv_stats -> rx_bytes += length ; rcv_stats -> rx_packets ++ ; return NETDEV_TX_OK ; tx_drop : kfree_skb ( skb ) ; stats -> tx_dropped ++ ; return NETDEV_TX_OK ; rx_drop : <S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> rcv_stats -> rx_dropped ++ ; return NETDEV_TX_OK ; }
CWE-190 SQLITE_PRIVATE void sqlite3VtabBeginParse ( Parse * pParse , Token * pName1 , Token * pName2 , Token * pModuleName , int ifNotExists ) { Table * pTable ; sqlite3 * db ; sqlite3StartTable ( pParse , pName1 , pName2 , 0 , 0 , 1 , ifNotExists ) ; pTable = pParse -> pNewTable ; if ( pTable == 0 ) return ; assert ( 0 == pTable -> pIndex ) ; db = pParse -> db ; assert ( pTable -> nModuleArg == 0 ) ; <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ; <S2SV_EndBug> assert ( ( pParse -> sNameToken . z == pName2 -> z && pName2 -> z != 0 ) || ( pParse -> sNameToken . z == pName1 -> z && pName2 -> z == 0 ) ) ; pParse -> sNameToken . n = ( int ) ( & pModuleName -> z [ pModuleName -> n ] - pParse -> sNameToken . z ) ; # ifndef SQLITE_OMIT_AUTHORIZATION if ( pTable -> azModuleArg ) { int iDb = sqlite3SchemaToIndex ( db , pTable -> pSchema ) ; assert ( iDb >= 0 ) ; sqlite3AuthCheck ( pParse , SQLITE_CREATE_VTABLE , pTable -> zName , pTable -> azModuleArg [ 0 ] , pParse -> db -> aDb [ iDb ] . zDbSName ) ; } # endif }
CWE-000 static int asn1_find_indefinite_length ( const unsigned char * data , size_t datalen , size_t * _dp , size_t * _len , const char * * _errmsg ) { unsigned char tag , tmp ; size_t dp = * _dp , len , n ; int indef_level = 1 ; next_tag : if ( unlikely ( datalen - dp < 2 ) ) { if ( datalen == dp ) goto missing_eoc ; goto data_overrun_error ; } tag = data [ dp ++ ] ; <S2SV_StartBug> if ( tag == 0 ) { <S2SV_EndBug> if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; if ( -- indef_level <= 0 ) { * _len = dp - * _dp ; * _dp = dp ; return 0 ; } goto next_tag ; } if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) { do { if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; tmp = data [ dp ++ ] ; } while ( tmp & 0x80 ) ; } len = data [ dp ++ ] ; <S2SV_StartBug> if ( len <= 0x7f ) { <S2SV_EndBug> dp += len ; goto next_tag ; } if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ( tag & ASN1_CONS_BIT ) == ASN1_PRIM << 5 ) ) goto indefinite_len_primitive ; indef_level ++ ; goto next_tag ; } n = len - 0x80 ; <S2SV_StartBug> if ( unlikely ( n > sizeof ( size_t ) - 1 ) ) <S2SV_EndBug> goto length_too_long ; if ( unlikely ( n > datalen - dp ) ) goto data_overrun_error ; <S2SV_StartBug> for ( len = 0 ; n > 0 ; n -- ) { <S2SV_EndBug> len <<= 8 ; len |= data [ dp ++ ] ; } <S2SV_StartBug> dp += len ; <S2SV_EndBug> goto next_tag ; length_too_long : * _errmsg = "Unsupported<S2SV_blank>length" ; goto error ; indefinite_len_primitive : * _errmsg = "Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted" ; goto error ; invalid_eoc : * _errmsg = "Invalid<S2SV_blank>length<S2SV_blank>EOC" ; goto error ; data_overrun_error : * _errmsg = "Data<S2SV_blank>overrun<S2SV_blank>error" ; goto error ; missing_eoc : * _errmsg = "Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons" ; error : * _dp = dp ; return - 1 ; }
CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , "(pad1)" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , "(padn:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(padn)" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , "(refresh:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , "(refresh:<S2SV_blank>%u)" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , "(altcoa:<S2SV_blank>trunc)" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , "(alt-CoA:<S2SV_blank>%s)" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; <S2SV_EndBug> break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , "(ni:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ; ND_PRINT ( ( ndo , "(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , "(auth:<S2SV_blank>trunc)" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(auth)" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , "(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "(type-0x%02x:<S2SV_blank>len=%u)" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
CWE-000 int __sys_recvmmsg ( int fd , struct mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct timespec * timeout ) { int fput_needed , err , datagrams ; struct socket * sock ; struct mmsghdr __user * entry ; struct compat_mmsghdr __user * compat_entry ; struct msghdr msg_sys ; struct timespec end_time ; if ( timeout && poll_select_set_timeout ( & end_time , timeout -> tv_sec , timeout -> tv_nsec ) ) return - EINVAL ; datagrams = 0 ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) return err ; err = sock_error ( sock -> sk ) ; if ( err ) goto out_put ; entry = mmsg ; compat_entry = ( struct compat_mmsghdr __user * ) mmsg ; while ( datagrams < vlen ) { if ( MSG_CMSG_COMPAT & flags ) { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) compat_entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = __put_user ( err , & compat_entry -> msg_len ) ; ++ compat_entry ; } else { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = put_user ( err , & entry -> msg_len ) ; ++ entry ; } if ( err ) break ; ++ datagrams ; if ( flags & MSG_WAITFORONE ) flags |= MSG_DONTWAIT ; if ( timeout ) { ktime_get_ts ( timeout ) ; * timeout = timespec_sub ( end_time , * timeout ) ; if ( timeout -> tv_sec < 0 ) { timeout -> tv_sec = timeout -> tv_nsec = 0 ; break ; } if ( timeout -> tv_nsec == 0 && timeout -> tv_sec == 0 ) break ; } if ( msg_sys . msg_flags & MSG_OOB ) break ; cond_resched ( ) ; } <S2SV_StartBug> out_put : <S2SV_EndBug> fput_light ( sock -> file , fput_needed ) ; if ( err == 0 ) <S2SV_StartBug> return datagrams ; <S2SV_EndBug> if ( datagrams != 0 ) { if ( err != - EAGAIN ) { sock -> sk -> sk_err = - err ; } <S2SV_StartBug> return datagrams ; <S2SV_EndBug> } <S2SV_StartBug> return err ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> int min_log2_tile_cols , max_log2_tile_cols , ones ; vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ; ones = cm -> log2_tile_cols - min_log2_tile_cols ; while ( ones -- ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> if ( cm -> log2_tile_cols < max_log2_tile_cols ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> if ( cm -> log2_tile_rows != 0 ) <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * codec , <S2SV_EndBug> vpx_image_t * img , int frame_index , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( codec , img , frame_index , 1 , 0 , VPX_DL_GOOD_QUALITY ) ; if ( res != VPX_CODEC_OK ) die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame" ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) { die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame" ) ; } printf ( keyframe ? "K" : "." ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-399 static void xsltCompileLocationPathPattern ( xsltParserContextPtr ctxt , int novar ) { SKIP_BLANKS ; if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { NEXT ; NEXT ; ctxt -> comp -> priority = 0.5 ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { NEXT ; SKIP_BLANKS ; PUSH ( XSLT_OP_ROOT , NULL , NULL , novar ) ; if ( ( CUR != 0 ) && ( CUR != '|' ) ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } } else if ( CUR == '*' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '@' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else { xmlChar * name ; name = xsltScanNCName ( ctxt ) ; if ( name == NULL ) { xsltTransformError ( NULL , NULL , NULL , "xsltCompileLocationPathPattern<S2SV_blank>:<S2SV_blank>Name<S2SV_blank>expected\\n" ) ; ctxt -> error = 1 ; return ; } SKIP_BLANKS ; if ( ( CUR == '(' ) && ! xmlXPathIsNodeType ( name ) ) { xsltCompileIdKeyPattern ( ctxt , name , 1 , novar , 0 ) ; <S2SV_StartBug> if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { <S2SV_EndBug> PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ; NEXT ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } return ; } xsltCompileRelativePathPattern ( ctxt , name , novar ) ; } error : return ; }
CWE-20 static int dispatch_discard_io ( struct xen_blkif * blkif , struct blkif_request * req ) { int err = 0 ; int status = BLKIF_RSP_OKAY ; struct block_device * bdev = blkif -> vbd . bdev ; unsigned long secure ; <S2SV_StartBug> blkif -> st_ds_req ++ ; <S2SV_EndBug> xen_blkif_get ( blkif ) ; secure = ( blkif -> vbd . discard_secure && ( req -> u . discard . flag & BLKIF_DISCARD_SECURE ) ) ? BLKDEV_DISCARD_SECURE : 0 ; err = blkdev_issue_discard ( bdev , req -> u . discard . sector_number , req -> u . discard . nr_sectors , GFP_KERNEL , secure ) ; <S2SV_StartBug> if ( err == - EOPNOTSUPP ) { <S2SV_EndBug> pr_debug ( DRV_PFX "discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\n" ) ; status = BLKIF_RSP_EOPNOTSUPP ; } else if ( err ) status = BLKIF_RSP_ERROR ; make_response ( blkif , req -> u . discard . id , req -> operation , status ) ; xen_blkif_put ( blkif ) ; return err ; }
CWE-264 static int try_to_unmap_cluster ( unsigned long cursor , unsigned int * mapcount , struct vm_area_struct * vma , struct page * check_page ) { struct mm_struct * mm = vma -> vm_mm ; pmd_t * pmd ; pte_t * pte ; pte_t pteval ; spinlock_t * ptl ; struct page * page ; unsigned long address ; unsigned long mmun_start ; unsigned long mmun_end ; unsigned long end ; int ret = SWAP_AGAIN ; int locked_vma = 0 ; address = ( vma -> vm_start + cursor ) & CLUSTER_MASK ; end = address + CLUSTER_SIZE ; if ( address < vma -> vm_start ) address = vma -> vm_start ; if ( end > vma -> vm_end ) end = vma -> vm_end ; pmd = mm_find_pmd ( mm , address ) ; if ( ! pmd ) return ret ; mmun_start = address ; mmun_end = end ; mmu_notifier_invalidate_range_start ( mm , mmun_start , mmun_end ) ; if ( down_read_trylock ( & vma -> vm_mm -> mmap_sem ) ) { locked_vma = ( vma -> vm_flags & VM_LOCKED ) ; if ( ! locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; } pte = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; update_hiwater_rss ( mm ) ; for ( ; address < end ; pte ++ , address += PAGE_SIZE ) { if ( ! pte_present ( * pte ) ) continue ; page = vm_normal_page ( vma , address , * pte ) ; BUG_ON ( ! page || PageAnon ( page ) ) ; if ( locked_vma ) { <S2SV_StartBug> mlock_vma_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> if ( page == check_page ) <S2SV_EndBug> <S2SV_StartBug> ret = SWAP_MLOCK ; <S2SV_EndBug> continue ; } if ( ptep_clear_flush_young_notify ( vma , address , pte ) ) continue ; flush_cache_page ( vma , address , pte_pfn ( * pte ) ) ; pteval = ptep_clear_flush ( vma , address , pte ) ; if ( page -> index != linear_page_index ( vma , address ) ) { pte_t ptfile = pgoff_to_pte ( page -> index ) ; if ( pte_soft_dirty ( pteval ) ) pte_file_mksoft_dirty ( ptfile ) ; set_pte_at ( mm , address , pte , ptfile ) ; } if ( pte_dirty ( pteval ) ) set_page_dirty ( page ) ; page_remove_rmap ( page ) ; page_cache_release ( page ) ; dec_mm_counter ( mm , MM_FILEPAGES ) ; ( * mapcount ) -- ; } pte_unmap_unlock ( pte - 1 , ptl ) ; mmu_notifier_invalidate_range_end ( mm , mmun_start , mmun_end ) ; if ( locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; return ret ; }
CWE-119 static int logi_dj_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct dj_receiver_dev * djrcv_dev = hid_get_drvdata ( hdev ) ; struct dj_report * dj_report = ( struct dj_report * ) data ; unsigned long flags ; bool report_processed = false ; <S2SV_StartBug> dbg_hid ( "%s,<S2SV_blank>size:%d\\n" , __func__ , size ) ; <S2SV_EndBug> spin_lock_irqsave ( & djrcv_dev -> lock , flags ) ; if ( dj_report -> report_id == REPORT_ID_DJ_SHORT ) { switch ( dj_report -> report_type ) { case REPORT_TYPE_NOTIF_DEVICE_PAIRED : case REPORT_TYPE_NOTIF_DEVICE_UNPAIRED : logi_dj_recv_queue_notification ( djrcv_dev , dj_report ) ; break ; case REPORT_TYPE_NOTIF_CONNECTION_STATUS : if ( dj_report -> report_params [ CONNECTION_STATUS_PARAM_STATUS ] == STATUS_LINKLOSS ) { logi_dj_recv_forward_null_report ( djrcv_dev , dj_report ) ; } break ; default : logi_dj_recv_forward_report ( djrcv_dev , dj_report ) ; } report_processed = true ; } spin_unlock_irqrestore ( & djrcv_dev -> lock , flags ) ; return report_processed ; }
CWE-125 static inline long object_common1 ( UNSERIALIZE_PARAMETER , zend_class_entry * ce ) { <S2SV_StartBug> long elements ; <S2SV_EndBug> elements = parse_iv2 ( ( * p ) + 2 , p ) ; ( * p ) += 2 ; if ( ce -> serialize == NULL ) { object_init_ex ( * rval , ce ) ; } else { zend_error ( E_WARNING , "Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\'%s\'" , ce -> name ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } return elements ; }
CWE-119 bool_t xdr_nullstring ( XDR * xdrs , char * * objp ) { u_int size ; if ( xdrs -> x_op == XDR_ENCODE ) { if ( * objp == NULL ) size = 0 ; else size = strlen ( * objp ) + 1 ; } if ( ! xdr_u_int ( xdrs , & size ) ) { return FALSE ; } switch ( xdrs -> x_op ) { case XDR_DECODE : if ( size == 0 ) { * objp = NULL ; return TRUE ; } else if ( * objp == NULL ) { * objp = ( char * ) mem_alloc ( size ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } } <S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ; return TRUE ; case XDR_FREE : if ( * objp != NULL ) mem_free ( * objp , size ) ; * objp = NULL ; return TRUE ; } return FALSE ; }
CWE-264 static int command_write ( struct pci_dev * dev , int offset , u16 value , void * data ) { struct xen_pcibk_dev_data * dev_data ; int err ; <S2SV_StartBug> dev_data = pci_get_drvdata ( dev ) ; <S2SV_EndBug> if ( ! pci_is_enabled ( dev ) && is_enable_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME ":<S2SV_blank>%s:<S2SV_blank>enable\\n" , pci_name ( dev ) ) ; err = pci_enable_device ( dev ) ; if ( err ) return err ; if ( dev_data ) dev_data -> enable_intx = 1 ; } else if ( pci_is_enabled ( dev ) && ! is_enable_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME ":<S2SV_blank>%s:<S2SV_blank>disable\\n" , pci_name ( dev ) ) ; pci_disable_device ( dev ) ; if ( dev_data ) dev_data -> enable_intx = 0 ; } if ( ! dev -> is_busmaster && is_master_cmd ( value ) ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME ":<S2SV_blank>%s:<S2SV_blank>set<S2SV_blank>bus<S2SV_blank>master\\n" , pci_name ( dev ) ) ; pci_set_master ( dev ) ; } if ( value & PCI_COMMAND_INVALIDATE ) { if ( unlikely ( verbose_request ) ) printk ( KERN_DEBUG DRV_NAME ":<S2SV_blank>%s:<S2SV_blank>enable<S2SV_blank>memory-write-invalidate\\n" , pci_name ( dev ) ) ; err = pci_set_mwi ( dev ) ; if ( err ) { pr_warn ( "%s:<S2SV_blank>cannot<S2SV_blank>enable<S2SV_blank>memory-write-invalidate<S2SV_blank>(%d)\\n" , pci_name ( dev ) , err ) ; value &= ~ PCI_COMMAND_INVALIDATE ; } } <S2SV_StartBug> return pci_write_config_word ( dev , offset , value ) ; <S2SV_EndBug> }
CWE-119 void vpx_yv12_copy_y_c ( const YV12_BUFFER_CONFIG * src_ybc , YV12_BUFFER_CONFIG * dst_ybc ) { int row ; const uint8_t * src = src_ybc -> y_buffer ; uint8_t * dst = dst_ybc -> y_buffer ; <S2SV_StartBug> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <S2SV_EndBug> src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } }
CWE-119 static __u8 * lg_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { struct lg_drv_data * drv_data = hid_get_drvdata ( hdev ) ; struct usb_device_descriptor * udesc ; __u16 bcdDevice , rev_maj , rev_min ; <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>keyboard<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc [ 84 ] = rdesc [ 89 ] = 0x4d ; rdesc [ 85 ] = rdesc [ 90 ] = 0x10 ; } <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>rel/abs<S2SV_blank>in<S2SV_blank>Logitech<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc [ 33 ] = rdesc [ 50 ] = 0x02 ; } switch ( hdev -> product ) { case USB_DEVICE_ID_LOGITECH_WHEEL : udesc = & ( hid_to_usb_dev ( hdev ) -> descriptor ) ; if ( ! udesc ) { hid_err ( hdev , "NULL<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>descriptor\\n" ) ; break ; } bcdDevice = le16_to_cpu ( udesc -> bcdDevice ) ; rev_maj = bcdDevice >> 8 ; rev_min = bcdDevice & 0xff ; if ( rev_maj == 1 && rev_min == 2 && * rsize == DF_RDESC_ORIG_SIZE ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc = df_rdesc_fixed ; * rsize = sizeof ( df_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL : if ( * rsize == MOMO_RDESC_ORIG_SIZE ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Force<S2SV_blank>(Red)<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc = momo_rdesc_fixed ; * rsize = sizeof ( momo_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2 : if ( * rsize == MOMO2_RDESC_ORIG_SIZE ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Racing<S2SV_blank>Force<S2SV_blank>(Black)<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc = momo2_rdesc_fixed ; * rsize = sizeof ( momo2_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL : if ( * rsize == FV_RDESC_ORIG_SIZE ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Formula<S2SV_blank>Vibration<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc = fv_rdesc_fixed ; * rsize = sizeof ( fv_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_DFP_WHEEL : if ( * rsize == DFP_RDESC_ORIG_SIZE ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>Pro<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc = dfp_rdesc_fixed ; * rsize = sizeof ( dfp_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_WII_WHEEL : if ( * rsize >= 101 && rdesc [ 41 ] == 0x95 && rdesc [ 42 ] == 0x0B && rdesc [ 47 ] == 0x05 && rdesc [ 48 ] == 0x09 ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Speed<S2SV_blank>Force<S2SV_blank>Wireless<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc [ 41 ] = 0x05 ; rdesc [ 42 ] = 0x09 ; rdesc [ 47 ] = 0x95 ; rdesc [ 48 ] = 0x0B ; } break ; } return rdesc ; }
CWE-362 struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; <S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; # endif memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , "Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }
CWE-264 SYSCALL_DEFINE4 ( osf_wait4 , pid_t , pid , int __user * , ustatus , int , options , struct rusage32 __user * , ur ) { struct rusage r ; long ret , err ; <S2SV_StartBug> mm_segment_t old_fs ; <S2SV_EndBug> if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ; old_fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; <S2SV_StartBug> ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ; <S2SV_EndBug> set_fs ( old_fs ) ; if ( ! access_ok ( VERIFY_WRITE , ur , sizeof ( * ur ) ) ) return - EFAULT ; err = 0 ; <S2SV_StartBug> err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ; <S2SV_EndBug> err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ; err |= __put_user ( r . ru_stime . tv_sec , & ur -> ru_stime . tv_sec ) ; err |= __put_user ( r . ru_stime . tv_usec , & ur -> ru_stime . tv_usec ) ; err |= __put_user ( r . ru_maxrss , & ur -> ru_maxrss ) ; err |= __put_user ( r . ru_ixrss , & ur -> ru_ixrss ) ; err |= __put_user ( r . ru_idrss , & ur -> ru_idrss ) ; err |= __put_user ( r . ru_isrss , & ur -> ru_isrss ) ; err |= __put_user ( r . ru_minflt , & ur -> ru_minflt ) ; err |= __put_user ( r . ru_majflt , & ur -> ru_majflt ) ; err |= __put_user ( r . ru_nswap , & ur -> ru_nswap ) ; err |= __put_user ( r . ru_inblock , & ur -> ru_inblock ) ; err |= __put_user ( r . ru_oublock , & ur -> ru_oublock ) ; err |= __put_user ( r . ru_msgsnd , & ur -> ru_msgsnd ) ; err |= __put_user ( r . ru_msgrcv , & ur -> ru_msgrcv ) ; err |= __put_user ( r . ru_nsignals , & ur -> ru_nsignals ) ; err |= __put_user ( r . ru_nvcsw , & ur -> ru_nvcsw ) ; err |= __put_user ( r . ru_nivcsw , & ur -> ru_nivcsw ) ; return err ? err : ret ; }
CWE-119 int vp9_rc_clamp_iframe_target_size ( const VP9_COMP * const cpi , int target ) { const RATE_CONTROL * rc = & cpi -> rc ; <S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> if ( oxcf -> rc_max_intra_bitrate_pct ) { <S2SV_StartBug> const int max_rate = rc -> av_per_frame_bandwidth * <S2SV_EndBug> oxcf -> rc_max_intra_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; } if ( target > rc -> max_frame_bandwidth ) target = rc -> max_frame_bandwidth ; return target ; }
CWE-264 <S2SV_StartBug> static bool do_write_pids ( pid_t tpid , const char * contrl , const char * cg , const char * file , const char * buf ) <S2SV_EndBug> { int sock [ 2 ] = { - 1 , - 1 } ; pid_t qpid , cpid = - 1 ; FILE * pids_file = NULL ; bool answer = false , fail = false ; pids_file = open_pids_file ( contrl , cg ) ; if ( ! pids_file ) return false ; if ( socketpair ( AF_UNIX , SOCK_DGRAM , 0 , sock ) < 0 ) { perror ( "socketpair" ) ; goto out ; } cpid = fork ( ) ; if ( cpid == - 1 ) goto out ; if ( ! cpid ) { fclose ( pids_file ) ; pid_from_ns_wrapper ( sock [ 1 ] , tpid ) ; } const char * ptr = buf ; while ( sscanf ( ptr , "%d" , & qpid ) == 1 ) { struct ucred cred ; char v ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) { fprintf ( stderr , "%s:<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>pid<S2SV_blank>to<S2SV_blank>child:<S2SV_blank>%s\\n" , __func__ , strerror ( errno ) ) ; goto out ; } if ( recv_creds ( sock [ 0 ] , & cred , & v ) ) { if ( v == '0' ) { <S2SV_StartBug> if ( fprintf ( pids_file , "%d" , ( int ) cred . pid ) < 0 ) <S2SV_EndBug> fail = true ; } } ptr = strchr ( ptr , '\\n' ) ; if ( ! ptr ) break ; ptr ++ ; } qpid = - 1 ; if ( write ( sock [ 0 ] , & qpid , sizeof ( qpid ) ) != sizeof ( qpid ) ) fprintf ( stderr , "Warning:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ask<S2SV_blank>child<S2SV_blank>to<S2SV_blank>exit\\n" ) ; if ( ! fail ) answer = true ; out : if ( cpid != - 1 ) wait_for_pid ( cpid ) ; if ( sock [ 0 ] != - 1 ) { close ( sock [ 0 ] ) ; close ( sock [ 1 ] ) ; } if ( pids_file ) { if ( fclose ( pids_file ) != 0 ) answer = false ; } return answer ; }
CWE-000 static int iwgif_read_image ( struct iwgifrcontext * rctx ) { int retval = 0 ; struct lzwdeccontext d ; size_t subblocksize ; int has_local_ct ; int local_ct_size ; unsigned int root_codesize ; if ( ! iwgif_read ( rctx , rctx -> rbuf , 9 ) ) goto done ; rctx -> image_left = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 0 ] ) ; rctx -> image_top = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 2 ] ) ; rctx -> image_width = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 4 ] ) ; <S2SV_StartBug> rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; <S2SV_EndBug> rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ; has_local_ct = ( int ) ( ( rctx -> rbuf [ 8 ] >> 7 ) & 0x01 ) ; if ( has_local_ct ) { local_ct_size = ( int ) ( rctx -> rbuf [ 8 ] & 0x07 ) ; rctx -> colortable . num_entries = 1 << ( 1 + local_ct_size ) ; } if ( has_local_ct ) { if ( ! iwgif_read_color_table ( rctx , & rctx -> colortable ) ) goto done ; } if ( rctx -> has_transparency ) { rctx -> colortable . entry [ rctx -> trans_color_index ] . a = 0 ; } if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; root_codesize = ( unsigned int ) rctx -> rbuf [ 0 ] ; if ( root_codesize < 2 || root_codesize > 11 ) { iw_set_error ( rctx -> ctx , "Invalid<S2SV_blank>LZW<S2SV_blank>minimum<S2SV_blank>code<S2SV_blank>size" ) ; goto done ; } if ( ! iwgif_init_screen ( rctx ) ) goto done ; rctx -> total_npixels = ( size_t ) rctx -> image_width * ( size_t ) rctx -> image_height ; if ( ! iwgif_make_row_pointers ( rctx ) ) goto done ; lzw_init ( & d , root_codesize ) ; lzw_clear ( & d ) ; while ( 1 ) { if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; subblocksize = ( size_t ) rctx -> rbuf [ 0 ] ; if ( subblocksize == 0 ) break ; if ( ! iwgif_read ( rctx , rctx -> rbuf , subblocksize ) ) goto done ; if ( ! lzw_process_bytes ( rctx , & d , rctx -> rbuf , subblocksize ) ) goto done ; if ( d . eoi_flag ) break ; if ( rctx -> pixels_set >= rctx -> total_npixels ) break ; } retval = 1 ; done : return retval ; }
CWE-362 static long snd_timer_user_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { <S2SV_StartBug> struct snd_timer_user * tu ; <S2SV_EndBug> void __user * argp = ( void __user * ) arg ; int __user * p = argp ; tu = file -> private_data ; <S2SV_StartBug> switch ( cmd ) { <S2SV_EndBug> case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ; case SNDRV_TIMER_IOCTL_NEXT_DEVICE : return snd_timer_user_next_device ( argp ) ; case SNDRV_TIMER_IOCTL_TREAD : { int xarg ; <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> if ( tu -> timeri ) { mutex_unlock ( & tu -> tread_sem ) ; return - EBUSY ; } if ( get_user ( xarg , p ) ) { mutex_unlock ( & tu -> tread_sem ) ; return - EFAULT ; } tu -> tread = xarg ? 1 : 0 ; <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> } case SNDRV_TIMER_IOCTL_GINFO : return snd_timer_user_ginfo ( file , argp ) ; case SNDRV_TIMER_IOCTL_GPARAMS : return snd_timer_user_gparams ( file , argp ) ; case SNDRV_TIMER_IOCTL_GSTATUS : return snd_timer_user_gstatus ( file , argp ) ; case SNDRV_TIMER_IOCTL_SELECT : return snd_timer_user_tselect ( file , argp ) ; case SNDRV_TIMER_IOCTL_INFO : return snd_timer_user_info ( file , argp ) ; case SNDRV_TIMER_IOCTL_PARAMS : return snd_timer_user_params ( file , argp ) ; case SNDRV_TIMER_IOCTL_STATUS : return snd_timer_user_status ( file , argp ) ; case SNDRV_TIMER_IOCTL_START : case SNDRV_TIMER_IOCTL_START_OLD : return snd_timer_user_start ( file ) ; case SNDRV_TIMER_IOCTL_STOP : case SNDRV_TIMER_IOCTL_STOP_OLD : return snd_timer_user_stop ( file ) ; case SNDRV_TIMER_IOCTL_CONTINUE : case SNDRV_TIMER_IOCTL_CONTINUE_OLD : return snd_timer_user_continue ( file ) ; case SNDRV_TIMER_IOCTL_PAUSE : case SNDRV_TIMER_IOCTL_PAUSE_OLD : return snd_timer_user_pause ( file ) ; } return - ENOTTY ; }
CWE-119 static bool parse_reconnect ( struct pool * pool , json_t * val ) { <S2SV_StartBug> char * sockaddr_url , * stratum_port , * tmp ; <S2SV_EndBug> char * url , * port , address [ 256 ] ; <S2SV_StartBug> if ( opt_disable_client_reconnect ) { <S2SV_EndBug> applog ( LOG_WARNING , "Stratum<S2SV_blank>client.reconnect<S2SV_blank>forbidden,<S2SV_blank>aborting." ) ; return false ; } memset ( address , 0 , 255 ) ; <S2SV_StartBug> url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; <S2SV_EndBug> if ( ! url ) url = pool -> sockaddr_url ; port = ( char * ) json_string_value ( json_array_get ( val , 1 ) ) ; if ( ! port ) port = pool -> stratum_port ; <S2SV_StartBug> sprintf ( address , "%s:%s" , url , port ) ; <S2SV_EndBug> if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ; applog ( LOG_NOTICE , "Reconnect<S2SV_blank>requested<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s" , get_pool_name ( pool ) , address ) ; clear_pool_work ( pool ) ; mutex_lock ( & pool -> stratum_lock ) ; __suspend_stratum ( pool ) ; tmp = pool -> sockaddr_url ; pool -> sockaddr_url = sockaddr_url ; pool -> stratum_url = pool -> sockaddr_url ; free ( tmp ) ; tmp = pool -> stratum_port ; pool -> stratum_port = stratum_port ; free ( tmp ) ; mutex_unlock ( & pool -> stratum_lock ) ; if ( ! restart_stratum ( pool ) ) { pool_failed ( pool ) ; return false ; } return true ; }
CWE-119 void test_base64_lengths ( void ) { const char * in = "FuseMuse" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , 0 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , enclen ) ; } out1 [ 0 ] = '\\0' ; <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , - 1 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , exp ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , enclen ) ; } <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , i ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%s" , in ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s" , out2 ) ; } } }
CWE-416 void comps_objmrtree_unite ( COMPS_ObjMRTree * rt1 , COMPS_ObjMRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; COMPS_ObjListIt * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_objmrtree_set ( rt1 , pair -> key , it2 -> comps_obj ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { <S2SV_StartBug> size_t off = 0 , len = 0 ; <S2SV_EndBug> # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) ; if ( cmd & 0x04 ) ADD_DELTA ( off , 16UL ) ; if ( cmd & 0x08 ) ADD_DELTA ( off , 24UL ) ; if ( cmd & 0x10 ) ADD_DELTA ( len , 0UL ) ; if ( cmd & 0x20 ) ADD_DELTA ( len , 8UL ) ; if ( cmd & 0x40 ) ADD_DELTA ( len , 16UL ) ; if ( ! len ) len = 0x10000 ; # undef ADD_DELTA <S2SV_StartBug> if ( base_len < off + len || res_sz < len ) <S2SV_EndBug> goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta" ) ; return - 1 ; }
CWE-416 void ip4_datagram_release_cb ( struct sock * sk ) { const struct inet_sock * inet = inet_sk ( sk ) ; const struct ip_options_rcu * inet_opt ; __be32 daddr = inet -> inet_daddr ; <S2SV_StartBug> struct flowi4 fl4 ; <S2SV_EndBug> struct rtable * rt ; <S2SV_StartBug> if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) ) <S2SV_EndBug> return ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; <S2SV_StartBug> if ( ! IS_ERR ( rt ) ) <S2SV_EndBug> <S2SV_StartBug> __sk_dst_set ( sk , & rt -> dst ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }
CWE-000 void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) { char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> FREE ( & buf ) ; }
CWE-20 struct sk_buff * sock_alloc_send_pskb ( struct sock * sk , unsigned long header_len , unsigned long data_len , int noblock , int * errcode ) { struct sk_buff * skb ; gfp_t gfp_mask ; long timeo ; int err ; <S2SV_StartBug> gfp_mask = sk -> sk_allocation ; <S2SV_EndBug> if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ; timeo = sock_sndtimeo ( sk , noblock ) ; while ( 1 ) { err = sock_error ( sk ) ; if ( err != 0 ) goto failure ; err = - EPIPE ; if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto failure ; if ( atomic_read ( & sk -> sk_wmem_alloc ) < sk -> sk_sndbuf ) { skb = alloc_skb ( header_len , gfp_mask ) ; if ( skb ) { <S2SV_StartBug> int npages ; <S2SV_EndBug> int i ; if ( ! data_len ) <S2SV_StartBug> break ; <S2SV_EndBug> npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; skb -> truesize += data_len ; skb_shinfo ( skb ) -> nr_frags = npages ; for ( i = 0 ; i < npages ; i ++ ) { struct page * page ; page = alloc_pages ( sk -> sk_allocation , 0 ) ; if ( ! page ) { err = - ENOBUFS ; skb_shinfo ( skb ) -> nr_frags = i ; kfree_skb ( skb ) ; goto failure ; } __skb_fill_page_desc ( skb , i , page , 0 , ( data_len >= PAGE_SIZE ? PAGE_SIZE : data_len ) ) ; data_len -= PAGE_SIZE ; } break ; } err = - ENOBUFS ; goto failure ; } set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; set_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ; err = - EAGAIN ; if ( ! timeo ) goto failure ; if ( signal_pending ( current ) ) goto interrupted ; timeo = sock_wait_for_wmem ( sk , timeo ) ; } skb_set_owner_w ( skb , sk ) ; return skb ; interrupted : err = sock_intr_errno ( timeo ) ; failure : * errcode = err ; return NULL ; }
CWE-264 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCKED ; atomic_inc ( & sb -> s_active ) ; mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; lock_mount_hash ( ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; unlock_mount_hash ( ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : mnt_free_id ( mnt ) ; free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }
CWE-189 static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ; # if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else # endif <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }
CWE-125 static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) { EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ; switch ( type ) { case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( actx == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ; return 0 ; } actx -> len . aad = 0 ; actx -> len . text = 0 ; actx -> aad = 0 ; actx -> mac_inited = 0 ; actx -> tag_len = 0 ; actx -> nonce_len = 12 ; actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ; return 1 ; case EVP_CTRL_COPY : if ( actx ) { EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ; dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( dst -> cipher_data == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ; return 0 ; } } return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ; actx -> nonce_len = arg ; return 1 ; case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ; actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ; actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ; actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ; if ( ptr != NULL ) { memcpy ( actx -> tag , ptr , arg ) ; actx -> tag_len = arg ; } return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ; memcpy ( ptr , actx -> tag , arg ) ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; { unsigned int len ; unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ; len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ; if ( ! ctx -> encrypt ) { <S2SV_StartBug> len -= POLY1305_BLOCK_SIZE ; <S2SV_EndBug> memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ; aad = temp ; temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ; temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ; } actx -> tls_payload_length = len ; actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ; actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ; actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ; actx -> mac_inited = 0 ; chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ; return POLY1305_BLOCK_SIZE ; } case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ; default : return - 1 ; } }
CWE-189 Datum hstore_from_array ( PG_FUNCTION_ARGS ) { ArrayType * in_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; int ndims = ARR_NDIM ( in_array ) ; int count ; int32 buflen ; HStore * out ; Pairs * pairs ; Datum * in_datums ; bool * in_nulls ; int in_count ; int i ; Assert ( ARR_ELEMTYPE ( in_array ) == TEXTOID ) ; switch ( ndims ) { case 0 : out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; case 1 : if ( ( ARR_DIMS ( in_array ) [ 0 ] ) % 2 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>even<S2SV_blank>number<S2SV_blank>of<S2SV_blank>elements" ) ) ) ; break ; case 2 : if ( ( ARR_DIMS ( in_array ) [ 1 ] ) != 2 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>two<S2SV_blank>columns" ) ) ) ; break ; default : ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts" ) ) ) ; } deconstruct_array ( in_array , TEXTOID , - 1 , false , 'i' , & in_datums , & in_nulls , & in_count ) ; count = in_count / 2 ; <S2SV_StartBug> pairs = palloc ( count * sizeof ( Pairs ) ) ; <S2SV_EndBug> for ( i = 0 ; i < count ; ++ i ) { if ( in_nulls [ i * 2 ] ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( "null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key" ) ) ) ; if ( in_nulls [ i * 2 + 1 ] ) { pairs [ i ] . key = VARDATA_ANY ( in_datums [ i * 2 ] ) ; pairs [ i ] . val = NULL ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 ] ) ) ; pairs [ i ] . vallen = 4 ; pairs [ i ] . isnull = true ; pairs [ i ] . needfree = false ; } else { pairs [ i ] . key = VARDATA_ANY ( in_datums [ i * 2 ] ) ; pairs [ i ] . val = VARDATA_ANY ( in_datums [ i * 2 + 1 ] ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 ] ) ) ; pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 + 1 ] ) ) ; pairs [ i ] . isnull = false ; pairs [ i ] . needfree = false ; } } count = hstoreUniquePairs ( pairs , count , & buflen ) ; out = hstorePairs ( pairs , count , buflen ) ; PG_RETURN_POINTER ( out ) ; }
CWE-000 static unsigned int do_decrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> # else return do_decrypt_fn ( ctx , bx , ax ) ; # endif }
CWE-000 WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; * pu4_bitstrm_ofst = u4_bitstream_offset ; u4_temp = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; if ( u4_temp > 25 ) return ERROR_MB_TYPE ; u1_mb_type = u4_temp ; } ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( "u1_mb_type" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cavlc ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; <S2SV_StartBug> } <S2SV_EndBug> i2_cur_mb_addr ++ ; uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs << 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag << 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs >> u1_mbaff ) ) ; } u1_num_mbs ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }
CWE-000 static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , <S2SV_StartBug> struct mb_cache_entry * * pce ) <S2SV_EndBug> { __u32 hash = le32_to_cpu ( header -> h_hash ) ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; if ( ! header -> h_hash ) return NULL ; ea_idebug ( inode , "looking<S2SV_blank>for<S2SV_blank>cached<S2SV_blank>blocks<S2SV_blank>[%x]" , ( int ) hash ) ; <S2SV_StartBug> again : <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> hash ) ; while ( ce ) { struct buffer_head * bh ; <S2SV_StartBug> if ( IS_ERR ( ce ) ) { <S2SV_EndBug> if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ; break ; } bh = sb_bread ( inode -> i_sb , ce -> e_block ) ; if ( ! bh ) { EXT4_ERROR_INODE ( inode , "block<S2SV_blank>%lu<S2SV_blank>read<S2SV_blank>error" , ( unsigned long ) ce -> e_block ) ; } else if ( le32_to_cpu ( BHDR ( bh ) -> h_refcount ) >= EXT4_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , "block<S2SV_blank>%lu<S2SV_blank>refcount<S2SV_blank>%d>=%d" , ( unsigned long ) ce -> e_block , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) , EXT4_XATTR_REFCOUNT_MAX ) ; } else if ( ext4_xattr_cmp ( header , BHDR ( bh ) ) == 0 ) { * pce = ce ; return bh ; } brelse ( bh ) ; <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> } return NULL ; }
CWE-125 int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , "Seems<S2SV_blank>not<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>TNEF<S2SV_blank>file\\n" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( "TNEF<S2SV_blank>Key:<S2SV_blank>%hx\\n" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i ] ; <S2SV_StartBug> if ( a -> name == MAPI_BODY_HTML ) <S2SV_EndBug> { body . html_bodies = get_html_data ( a ) ; html_size = a -> num_values ; } <S2SV_StartBug> else if ( a -> name == MAPI_RTF_COMPRESSED ) <S2SV_EndBug> { body . rtf_bodies = get_rtf_data ( a ) ; rtf_size = a -> num_values ; } } mapi_attr_free_list ( mapi_attrs ) ; XFREE ( mapi_attrs ) ; } } break ; case LVL_ATTACHMENT : file_add_attr ( file , attr ) ; break ; default : fprintf ( stderr , "Invalid<S2SV_blank>lvl<S2SV_blank>type<S2SV_blank>on<S2SV_blank>attribute:<S2SV_blank>%d\\n" , attr -> lvl_type ) ; return 1 ; break ; } attr_free ( attr ) ; XFREE ( attr ) ; } if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; XFREE ( file ) ; } if ( flags & SAVEBODY ) { int i = 0 ; int all_flag = 0 ; if ( strcmp ( body_pref , "all" ) == 0 ) { all_flag = 1 ; body_pref = "rht" ; } for ( ; i < 3 ; i ++ ) { File * * files = get_body_files ( body_filename , body_pref [ i ] , & body ) ; if ( files ) { int j = 0 ; for ( ; files [ j ] ; j ++ ) { file_write ( files [ j ] , directory ) ; file_free ( files [ j ] ) ; XFREE ( files [ j ] ) ; } XFREE ( files ) ; if ( ! all_flag ) break ; } } } if ( body . text_body ) { free_bodies ( body . text_body , 1 ) ; XFREE ( body . text_body ) ; } if ( rtf_size > 0 ) { free_bodies ( body . rtf_bodies , rtf_size ) ; XFREE ( body . rtf_bodies ) ; } if ( html_size > 0 ) { free_bodies ( body . html_bodies , html_size ) ; XFREE ( body . html_bodies ) ; } return 0 ; }
CWE-125 uint32 TIFFNumberOfStrips ( TIFF * tif ) { TIFFDirectory * td = & tif -> tif_dir ; <S2SV_StartBug> uint32 nstrips ; <S2SV_EndBug> if ( td -> td_nstrips ) return td -> td_nstrips ; nstrips = ( td -> td_rowsperstrip == ( uint32 ) - 1 ? 1 : TIFFhowmany_32 ( td -> td_imagelength , td -> td_rowsperstrip ) ) ; if ( td -> td_planarconfig == PLANARCONFIG_SEPARATE ) nstrips = _TIFFMultiply32 ( tif , nstrips , ( uint32 ) td -> td_samplesperpixel , "TIFFNumberOfStrips" ) ; return ( nstrips ) ; }
CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ; <S2SV_StartBug> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <S2SV_EndBug> if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ; <S2SV_StartBug> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , n ) ; } else { <S2SV_StartBug> pdf -> name = malloc ( strlen ( "Unknown" ) + 1 ) ; <S2SV_EndBug> strcpy ( pdf -> name , "Unknown" ) ; } return pdf ; }
CWE-119 void ih264d_rest_of_residual_cav_chroma_dc_block ( UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD16 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 4 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( u4_lev_prefix , 15 ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) ; } } if ( u4_total_coeff < 4 ) { UWORD32 u4_max_ldz = ( 4 - u4_total_coeff ) ; FIND_ONE_IN_STREAM_LEN ( u4_total_zeroes , u4_bitstream_offset , pu4_bitstrm_buf , u4_max_ldz ) ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; UWORD32 u4_scan_pos = ( u4_total_coeff + u4_total_zeroes - 1 ) ; UWORD32 u4_zeroes_left = u4_total_zeroes ; i = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( u4_zeroes_left && i ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } while ( i >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ i -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; }
CWE-119 static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; <S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> in_uint16_le ( s , flags ) ; <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , "process_secondary_order(),<S2SV_blank>unhandled<S2SV_blank>secondary<S2SV_blank>order<S2SV_blank>%d" , type ) ; } s -> p = next_order ; }
CWE-125 static int isis_print_extd_ip_reach ( netdissect_options * ndo , const uint8_t * tptr , const char * ident , uint16_t afi ) { char ident_buffer [ 20 ] ; uint8_t prefix [ sizeof ( struct in6_addr ) ] ; u_int metric , status_byte , bit_length , byte_length , sublen , processed , subtlvtype , subtlvlen ; if ( ! ND_TTEST2 ( * tptr , 4 ) ) return ( 0 ) ; metric = EXTRACT_32BITS ( tptr ) ; processed = 4 ; tptr += 4 ; if ( afi == AF_INET ) { if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = status_byte & 0x3f ; if ( bit_length > 32 ) { ND_PRINT ( ( ndo , "%sIPv4<S2SV_blank>prefix:<S2SV_blank>bad<S2SV_blank>bit<S2SV_blank>length<S2SV_blank>%u" , ident , bit_length ) ) ; return ( 0 ) ; } processed ++ ; } else if ( afi == AF_INET6 ) { <S2SV_StartBug> if ( ! ND_TTEST2 ( * tptr , 1 ) ) <S2SV_EndBug> return ( 0 ) ; status_byte = * ( tptr ++ ) ; bit_length = * ( tptr ++ ) ; if ( bit_length > 128 ) { ND_PRINT ( ( ndo , "%sIPv6<S2SV_blank>prefix:<S2SV_blank>bad<S2SV_blank>bit<S2SV_blank>length<S2SV_blank>%u" , ident , bit_length ) ) ; return ( 0 ) ; } processed += 2 ; } else return ( 0 ) ; byte_length = ( bit_length + 7 ) / 8 ; if ( ! ND_TTEST2 ( * tptr , byte_length ) ) return ( 0 ) ; memset ( prefix , 0 , sizeof prefix ) ; memcpy ( prefix , tptr , byte_length ) ; tptr += byte_length ; processed += byte_length ; if ( afi == AF_INET ) ND_PRINT ( ( ndo , "%sIPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u" , ident , ipaddr_string ( ndo , prefix ) , bit_length ) ) ; else if ( afi == AF_INET6 ) ND_PRINT ( ( ndo , "%sIPv6<S2SV_blank>prefix:<S2SV_blank>%s/%u" , ident , ip6addr_string ( ndo , prefix ) , bit_length ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>Distribution:<S2SV_blank>%s,<S2SV_blank>Metric:<S2SV_blank>%u" , ISIS_MASK_TLV_EXTD_IP_UPDOWN ( status_byte ) ? "down" : "up" , metric ) ) ; if ( afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV ( status_byte ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>sub-TLVs<S2SV_blank>present" ) ) ; else if ( afi == AF_INET6 ) ND_PRINT ( ( ndo , ",<S2SV_blank>%s%s" , ISIS_MASK_TLV_EXTD_IP6_IE ( status_byte ) ? "External" : "Internal" , ISIS_MASK_TLV_EXTD_IP6_SUBTLV ( status_byte ) ? ",<S2SV_blank>sub-TLVs<S2SV_blank>present" : "" ) ) ; if ( ( afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV ( status_byte ) ) || ( afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV ( status_byte ) ) ) { if ( ! ND_TTEST2 ( * tptr , 1 ) ) return ( 0 ) ; sublen = * ( tptr ++ ) ; processed += sublen + 1 ; ND_PRINT ( ( ndo , "<S2SV_blank>(%u)" , sublen ) ) ; while ( sublen > 0 ) { if ( ! ND_TTEST2 ( * tptr , 2 ) ) return ( 0 ) ; subtlvtype = * ( tptr ++ ) ; subtlvlen = * ( tptr ++ ) ; snprintf ( ident_buffer , sizeof ( ident_buffer ) , "%s<S2SV_blank><S2SV_blank>" , ident ) ; if ( ! isis_print_ip_reach_subtlv ( ndo , tptr , subtlvtype , subtlvlen , ident_buffer ) ) return ( 0 ) ; tptr += subtlvlen ; sublen -= ( subtlvlen + 2 ) ; } } return ( processed ) ; }
CWE-119 static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = "PredictorEncodeTile" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , "Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>allocating<S2SV_blank>" TIFF_SSIZE_FORMAT "<S2SV_blank>byte<S2SV_blank>temp<S2SV_blank>buffer." , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; <S2SV_StartBug> assert ( ( cc0 % rowsize ) == 0 ) ; <S2SV_EndBug> while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }
CWE-119 static int hns_xgmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }
CWE-119 static void de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , "//" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , "./" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , "/./" ) ) != ( char * ) 0 ) <S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> for ( ; ; ) { while ( strncmp ( file , "../" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , "/../" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , "/.." ) == 0 ) { for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; if ( cp2 < file ) break ; * cp2 = '\\0' ; } }
CWE-284 void fslib_copy_libs ( const char * full_path ) { assert ( full_path ) ; if ( arg_debug || arg_debug_private_lib ) printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>fslib_copy_libs<S2SV_blank>%s\\n" , full_path ) ; if ( access ( full_path , R_OK ) ) { if ( arg_debug || arg_debug_private_lib ) printf ( "cannot<S2SV_blank>find<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>private-lib,<S2SV_blank>skipping...\\n" , full_path ) ; return ; } unlink ( RUN_LIB_FILE ) ; create_empty_file_as_root ( RUN_LIB_FILE , 0644 ) ; if ( chown ( RUN_LIB_FILE , getuid ( ) , getgid ( ) ) ) errExit ( "chown" ) ; if ( arg_debug || arg_debug_private_lib ) printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>running<S2SV_blank>fldd<S2SV_blank>%s\\n" , full_path ) ; sbox_run ( SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE , 3 , PATH_FLDD , full_path , RUN_LIB_FILE ) ; FILE * fp = fopen ( RUN_LIB_FILE , "r" ) ; if ( ! fp ) errExit ( "fopen" ) ; char buf [ MAXBUF ] ; while ( fgets ( buf , MAXBUF , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; fslib_duplicate ( buf ) ; } fclose ( fp ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 php_http_url_t * php_http_url_parse ( const char * str , size_t len , unsigned flags TSRMLS_DC ) { <S2SV_StartBug> size_t maxlen = 3 * len ; <S2SV_EndBug> struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ; state -> end = str + len ; state -> ptr = str ; state -> flags = flags ; state -> maxlen = maxlen ; TSRMLS_SET_CTX ( state -> ts ) ; if ( ! parse_scheme ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>URL<S2SV_blank>scheme:<S2SV_blank>\'%s\'" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_hier ( state ) ) { efree ( state ) ; return NULL ; } if ( ! parse_query ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>URL<S2SV_blank>query:<S2SV_blank>\'%s\'" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_fragment ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>URL<S2SV_blank>fragment:<S2SV_blank>\'%s\'" , state -> ptr ) ; efree ( state ) ; return NULL ; } return ( php_http_url_t * ) state ; }
CWE-119 int cipso_v4_validate ( const struct sk_buff * skb , unsigned char * * option ) { unsigned char * opt = * option ; unsigned char * tag ; unsigned char opt_iter ; unsigned char err_offset = 0 ; u8 opt_len ; u8 tag_len ; struct cipso_v4_doi * doi_def = NULL ; u32 tag_iter ; opt_len = opt [ 1 ] ; if ( opt_len < 8 ) { err_offset = 1 ; goto validate_return ; } rcu_read_lock ( ) ; doi_def = cipso_v4_doi_search ( get_unaligned_be32 ( & opt [ 2 ] ) ) ; if ( doi_def == NULL ) { err_offset = 2 ; goto validate_return_locked ; } opt_iter = CIPSO_V4_HDR_LEN ; tag = opt + opt_iter ; while ( opt_iter < opt_len ) { for ( tag_iter = 0 ; doi_def -> tags [ tag_iter ] != tag [ 0 ] ; ) if ( doi_def -> tags [ tag_iter ] == CIPSO_V4_TAG_INVALID || ++ tag_iter == CIPSO_V4_TAG_MAXCNT ) { err_offset = opt_iter ; goto validate_return_locked ; } tag_len = tag [ 1 ] ; if ( tag_len > ( opt_len - opt_iter ) ) { err_offset = opt_iter + 1 ; goto validate_return_locked ; } switch ( tag [ 0 ] ) { case CIPSO_V4_TAG_RBITMAP : if ( tag_len < CIPSO_V4_TAG_RBM_BLEN ) { err_offset = opt_iter + 1 ; goto validate_return_locked ; } if ( cipso_v4_rbm_strictvalid ) { if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 ) { err_offset = opt_iter + 3 ; goto validate_return_locked ; } if ( tag_len > CIPSO_V4_TAG_RBM_BLEN && cipso_v4_map_cat_rbm_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 ) { err_offset = opt_iter + 4 ; goto validate_return_locked ; } } break ; case CIPSO_V4_TAG_ENUM : if ( tag_len < CIPSO_V4_TAG_ENUM_BLEN ) { err_offset = opt_iter + 1 ; goto validate_return_locked ; } if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 ) { err_offset = opt_iter + 3 ; goto validate_return_locked ; } if ( tag_len > CIPSO_V4_TAG_ENUM_BLEN && cipso_v4_map_cat_enum_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 ) { err_offset = opt_iter + 4 ; goto validate_return_locked ; } break ; case CIPSO_V4_TAG_RANGE : if ( tag_len < CIPSO_V4_TAG_RNG_BLEN ) { err_offset = opt_iter + 1 ; goto validate_return_locked ; } if ( cipso_v4_map_lvl_valid ( doi_def , tag [ 3 ] ) < 0 ) { err_offset = opt_iter + 3 ; goto validate_return_locked ; } if ( tag_len > CIPSO_V4_TAG_RNG_BLEN && cipso_v4_map_cat_rng_valid ( doi_def , & tag [ 4 ] , tag_len - 4 ) < 0 ) { err_offset = opt_iter + 4 ; goto validate_return_locked ; } break ; case CIPSO_V4_TAG_LOCAL : <S2SV_StartBug> if ( ! ( skb -> dev -> flags & IFF_LOOPBACK ) ) { <S2SV_EndBug> err_offset = opt_iter ; goto validate_return_locked ; } if ( tag_len != CIPSO_V4_TAG_LOC_BLEN ) { err_offset = opt_iter + 1 ; goto validate_return_locked ; } break ; default : err_offset = opt_iter ; goto validate_return_locked ; } tag += tag_len ; opt_iter += tag_len ; } validate_return_locked : rcu_read_unlock ( ) ; validate_return : * option = opt + err_offset ; return err_offset ; }
CWE-264 static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; err = security_sb_remount ( sb , data ) ; if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; <S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }
CWE-190 SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * pParse , ExprList * pList , Expr * pExpr ) { struct ExprList_item * pItem ; sqlite3 * db = pParse -> db ; assert ( db != 0 ) ; if ( pList == 0 ) { pList = sqlite3DbMallocRawNN ( db , sizeof ( ExprList ) ) ; if ( pList == 0 ) { goto no_mem ; } pList -> nExpr = 0 ; } else if ( ( pList -> nExpr & ( pList -> nExpr - 1 ) ) == 0 ) { ExprList * pNew ; pNew = sqlite3DbRealloc ( db , pList , <S2SV_StartBug> sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; <S2SV_EndBug> if ( pNew == 0 ) { goto no_mem ; } pList = pNew ; } pItem = & pList -> a [ pList -> nExpr ++ ] ; assert ( offsetof ( struct ExprList_item , zName ) == sizeof ( pItem -> pExpr ) ) ; assert ( offsetof ( struct ExprList_item , pExpr ) == 0 ) ; memset ( & pItem -> zName , 0 , sizeof ( * pItem ) - offsetof ( struct ExprList_item , zName ) ) ; pItem -> pExpr = pExpr ; return pList ; no_mem : sqlite3ExprDelete ( db , pExpr ) ; sqlite3ExprListDelete ( db , pList ) ; return 0 ; }
CWE-399 sctp_disposition_t sctp_sf_do_asconf_ack ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * asconf_ack = arg ; struct sctp_chunk * last_asconf = asoc -> addip_last_asconf ; struct sctp_chunk * abort ; struct sctp_paramhdr * err_param = NULL ; sctp_addiphdr_t * addip_hdr ; __u32 sent_serial , rcvd_serial ; if ( ! sctp_vtag_verify ( asconf_ack , asoc ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_REPORT_BAD_TAG , SCTP_NULL ( ) ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } if ( ! net -> sctp . addip_noauth && ! asconf_ack -> auth ) return sctp_sf_discard_chunk ( net , ep , asoc , type , arg , commands ) ; if ( ! sctp_chunk_length_valid ( asconf_ack , sizeof ( sctp_addip_chunk_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; addip_hdr = ( sctp_addiphdr_t * ) asconf_ack -> skb -> data ; rcvd_serial = ntohl ( addip_hdr -> serial ) ; if ( ! sctp_verify_asconf ( asoc , <S2SV_StartBug> ( sctp_paramhdr_t * ) addip_hdr -> params , <S2SV_EndBug> ( void * ) asconf_ack -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ; if ( last_asconf ) { addip_hdr = ( sctp_addiphdr_t * ) last_asconf -> subh . addip_hdr ; sent_serial = ntohl ( addip_hdr -> serial ) ; } else { sent_serial = asoc -> addip_serial - 1 ; } if ( ADDIP_SERIAL_gte ( rcvd_serial , sent_serial + 1 ) && ! ( asoc -> addip_last_asconf ) ) { abort = sctp_make_abort ( asoc , asconf_ack , sizeof ( sctp_errhdr_t ) ) ; if ( abort ) { sctp_init_cause ( abort , SCTP_ERROR_ASCONF_ACK , 0 ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; return SCTP_DISPOSITION_ABORT ; } if ( ( rcvd_serial == sent_serial ) && asoc -> addip_last_asconf ) { sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; if ( ! sctp_process_asconf_ack ( ( struct sctp_association * ) asoc , asconf_ack ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_SEND_NEXT_ASCONF , SCTP_NULL ( ) ) ; return SCTP_DISPOSITION_CONSUME ; } abort = sctp_make_abort ( asoc , asconf_ack , sizeof ( sctp_errhdr_t ) ) ; if ( abort ) { sctp_init_cause ( abort , SCTP_ERROR_RSRC_LOW , 0 ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; return SCTP_DISPOSITION_ABORT ; } return SCTP_DISPOSITION_DISCARD ; }
CWE-189 static EAS_RESULT Parse_wave ( SDLS_SYNTHESIZER_DATA * pDLSData , EAS_I32 pos , EAS_U16 waveIndex ) { EAS_RESULT result ; EAS_U32 temp ; EAS_I32 size ; EAS_I32 endChunk ; EAS_I32 chunkPos ; EAS_I32 wsmpPos = 0 ; EAS_I32 fmtPos = 0 ; EAS_I32 dataPos = 0 ; EAS_I32 dataSize = 0 ; S_WSMP_DATA * p ; void * pSample ; S_WSMP_DATA wsmp ; chunkPos = pos + 12 ; if ( ( result = EAS_HWFileSeek ( pDLSData -> hwInstData , pDLSData -> fileHandle , pos ) ) != EAS_SUCCESS ) return result ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; if ( temp != CHUNK_WAVE ) { { } return EAS_ERROR_FILE_FORMAT ; } pos = chunkPos ; endChunk = pos + size ; while ( pos < endChunk ) { chunkPos = pos ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; switch ( temp ) { case CHUNK_WSMP : wsmpPos = chunkPos + 8 ; break ; case CHUNK_FMT : fmtPos = chunkPos + 8 ; break ; case CHUNK_DATA : dataPos = chunkPos + 8 ; dataSize = size ; break ; default : break ; } } <S2SV_StartBug> if ( dataSize > MAX_DLS_WAVE_SIZE ) <S2SV_EndBug> { return EAS_ERROR_SOUND_LIBRARY ; } if ( pDLSData -> pDLS == NULL ) p = & wsmp ; else p = & pDLSData -> wsmpData [ waveIndex ] ; p -> fineTune = 0 ; p -> unityNote = 60 ; p -> gain = 0 ; p -> loopStart = 0 ; p -> loopLength = 0 ; if ( ! fmtPos ) { { } return EAS_ERROR_UNRECOGNIZED_FORMAT ; } if ( ! dataPos ) { { } return EAS_ERROR_UNRECOGNIZED_FORMAT ; } if ( wsmpPos ) { if ( ( result = Parse_wsmp ( pDLSData , wsmpPos , p ) ) != EAS_SUCCESS ) return result ; } if ( ( result = Parse_fmt ( pDLSData , fmtPos , p ) ) != EAS_SUCCESS ) return result ; if ( bitDepth == 8 ) { if ( p -> bitsPerSample == 8 ) size = dataSize ; else size = dataSize >> 1 ; if ( p -> loopLength ) size ++ ; } else { if ( p -> bitsPerSample == 16 ) size = dataSize ; else size = dataSize << 1 ; if ( p -> loopLength ) size += 2 ; } if ( pDLSData -> pDLS == NULL ) { pDLSData -> wavePoolSize += ( EAS_U32 ) size ; return EAS_SUCCESS ; } pSample = pDLSData -> pDLS -> pDLSSamples + pDLSData -> wavePoolOffset ; pDLSData -> pDLS -> pDLSSampleOffsets [ waveIndex ] = pDLSData -> wavePoolOffset ; pDLSData -> pDLS -> pDLSSampleLen [ waveIndex ] = ( EAS_U32 ) size ; pDLSData -> wavePoolOffset += ( EAS_U32 ) size ; if ( pDLSData -> wavePoolOffset > pDLSData -> wavePoolSize ) { { } return EAS_ERROR_SOUND_LIBRARY ; } if ( ( result = Parse_data ( pDLSData , dataPos , dataSize , p , pSample ) ) != EAS_SUCCESS ) return result ; return EAS_SUCCESS ; }
CWE-000 static void sas_scsi_clear_queue_lu ( struct list_head * error_q , struct scsi_cmnd * my_cmd ) { struct scsi_cmnd * cmd , * n ; list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> } }
CWE-000 static int udf_symlink_filler ( struct file * file , struct page * page ) { struct inode * inode = page -> mapping -> host ; struct buffer_head * bh = NULL ; unsigned char * symlink ; int err ; unsigned char * p = kmap ( page ) ; struct udf_inode_info * iinfo ; uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } iinfo = UDF_I ( inode ) ; pos = udf_block_map ( inode , 0 ) ; down_read ( & iinfo -> i_data_sem ) ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { symlink = iinfo -> i_ext . i_data + iinfo -> i_lenEAttr ; } else { bh = sb_bread ( inode -> i_sb , pos ) ; if ( ! bh ) { err = - EIO ; goto out_unlock_inode ; } symlink = bh -> b_data ; } <S2SV_StartBug> udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; <S2SV_EndBug> <S2SV_StartBug> brelse ( bh ) ; <S2SV_EndBug> up_read ( & iinfo -> i_data_sem ) ; SetPageUptodate ( page ) ; kunmap ( page ) ; unlock_page ( page ) ; return 0 ; out_unlock_inode : up_read ( & iinfo -> i_data_sem ) ; SetPageError ( page ) ; out_unmap : kunmap ( page ) ; unlock_page ( page ) ; return err ; }
CWE-119 char * suhosin_encrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key TSRMLS_DC ) { <S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> char buffer2 [ 4096 ] ; char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; int l ; <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> buf = estrndup ( name , name_len ) ; <S2SV_StartBug> } else { <S2SV_EndBug> memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { encrypt_return_plain : <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } return estrndup ( value , value_len ) ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto encrypt_return_plain ; } } <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_encrypt_string ( buf2 , value_len , buf , name_len , key TSRMLS_CC ) ; d_url = php_url_encode ( d , strlen ( d ) , & l ) ; efree ( d ) ; <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return d_url ; }
CWE-119 static void numtostr ( js_State * J , const char * fmt , int w , double n ) { <S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> sprintf ( buf , fmt , w , n ) ; e = strchr ( buf , 'e' ) ; if ( e ) { int exp = atoi ( e + 1 ) ; sprintf ( e , "e%+d" , exp ) ; } js_pushstring ( J , buf ) ; }
CWE-119 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>" "0x%llx\\n" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , "%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { kvmclock_reset ( vcpu ) ; vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , "disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , "ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , "unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , "ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; break ; } } return 0 ; }
CWE-416 void usb_serial_console_disconnect ( struct usb_serial * serial ) { <S2SV_StartBug> if ( serial -> port [ 0 ] == usbcons_info . port ) { <S2SV_EndBug> usb_serial_console_exit ( ) ; usb_serial_put ( serial ) ; } }
CWE-200 static int pvc_getname ( struct socket * sock , struct sockaddr * sockaddr , int * sockaddr_len , int peer ) { struct sockaddr_atmpvc * addr ; struct atm_vcc * vcc = ATM_SD ( sock ) ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ; * sockaddr_len = sizeof ( struct sockaddr_atmpvc ) ; addr = ( struct sockaddr_atmpvc * ) sockaddr ; <S2SV_StartBug> addr -> sap_family = AF_ATMPVC ; <S2SV_EndBug> addr -> sap_addr . itf = vcc -> dev -> number ; addr -> sap_addr . vpi = vcc -> vpi ; addr -> sap_addr . vci = vcc -> vci ; return 0 ; }
CWE-415 static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) { Gif_Stream * gfs ; Gif_Image * gfi ; Gif_Context gfc ; int unknown_block_type = 0 ; if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; gfs = Gif_NewStream ( ) ; gfi = Gif_NewImage ( ) ; gfc . stream = gfs ; gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ; gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ; gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ; gfc . handler = handler ; gfc . gfi = gfi ; gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ; if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ; gfs -> landmark = landmark ; GIF_DEBUG ( ( "\\nGIF<S2SV_blank>" ) ) ; if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ; GIF_DEBUG ( ( "logscrdesc<S2SV_blank>" ) ) ; while ( ! gifeof ( grr ) ) { uint8_t block = gifgetbyte ( grr ) ; switch ( block ) { case ',' : GIF_DEBUG ( ( "imageread<S2SV_blank>%d<S2SV_blank>" , gfs -> nimages ) ) ; gfi -> identifier = last_name ; last_name = 0 ; if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ; else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) { Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ; gfi = 0 ; goto done ; } gfc . gfi = gfi = Gif_NewImage ( ) ; if ( ! gfi ) goto done ; break ; case ';' : GIF_DEBUG ( ( "term\\n" ) ) ; goto done ; case '!' : block = gifgetbyte ( grr ) ; GIF_DEBUG ( ( "ext(0x%02X)<S2SV_blank>" , block ) ) ; switch ( block ) { case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ; break ; case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ; break ; case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ; break ; case 0xFF : read_application_extension ( & gfc , grr ) ; break ; default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ; break ; } break ; default : if ( ! unknown_block_type ) { char buf [ 256 ] ; sprintf ( buf , "unknown<S2SV_blank>block<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>file<S2SV_blank>offset<S2SV_blank>%u" , block , grr -> pos - 1 ) ; gif_read_error ( & gfc , 1 , buf ) ; unknown_block_type = 1 ; } break ; } } done : if ( gfs && gfi ) { Gif_Extension * gfex ; gfs -> end_comment = gfi -> comment ; gfi -> comment = 0 ; gfs -> end_extension_list = gfi -> extension_list ; gfi -> extension_list = 0 ; for ( gfex = gfs -> end_extension_list ; gfex ; gfex = gfex -> next ) gfex -> image = NULL ; } Gif_DeleteImage ( gfi ) ; Gif_DeleteArray ( last_name ) ; Gif_DeleteArray ( gfc . prefix ) ; Gif_DeleteArray ( gfc . suffix ) ; Gif_DeleteArray ( gfc . length ) ; gfc . gfi = 0 ; <S2SV_StartBug> if ( gfs ) <S2SV_EndBug> gfs -> errors = gfc . errors [ 1 ] ; if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , "trailing<S2SV_blank>garbage<S2SV_blank>after<S2SV_blank>GIF<S2SV_blank>ignored" ) ; gif_read_error ( & gfc , - 1 , 0 ) ; return gfs ; }
CWE-284 int btsock_thread_exit ( int h ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( "invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( "cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created" ) ; return FALSE ; } sock_cmd_t cmd = { CMD_EXIT , 0 , 0 , 0 , 0 } ; <S2SV_StartBug> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <S2SV_EndBug> { pthread_join ( ts [ h ] . thread_id , 0 ) ; pthread_mutex_lock ( & thread_slot_lock ) ; free_thread_slot ( h ) ; pthread_mutex_unlock ( & thread_slot_lock ) ; return TRUE ; } return FALSE ; }
CWE-000 int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize == 0 ) return 0 ; sbsize = sf -> hdr . count * sizeof ( * sbuf ) ; sbp = sbuf = kmem_alloc ( sbsize , KM_SLEEP | KM_NOFS ) ; nsbuf = 0 ; for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { if ( unlikely ( ( ( char * ) sfe < ( char * ) sf ) || ( ( char * ) sfe >= ( ( char * ) sf + dp -> i_afp -> if_bytes ) ) ) ) { XFS_CORRUPTION_ERROR ( "xfs_attr_shortform_list" , XFS_ERRLEVEL_LOW , context -> dp -> i_mount , sfe ) ; kmem_free ( sbuf ) ; return - EFSCORRUPTED ; } sbp -> entno = i ; sbp -> hash = xfs_da_hashname ( sfe -> nameval , sfe -> namelen ) ; sbp -> name = sfe -> nameval ; sbp -> namelen = sfe -> namelen ; sbp -> valuelen = sfe -> valuelen ; sbp -> flags = sfe -> flags ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; sbp ++ ; nsbuf ++ ; } xfs_sort ( sbuf , nsbuf , sizeof ( * sbuf ) , xfs_attr_shortform_compare ) ; count = 0 ; cursor -> initted = 1 ; cursor -> blkno = 0 ; for ( sbp = sbuf , i = 0 ; i < nsbuf ; i ++ , sbp ++ ) { if ( sbp -> hash == cursor -> hashval ) { if ( cursor -> offset == count ) { break ; } count ++ ; } else if ( sbp -> hash > cursor -> hashval ) { break ; } } if ( i == nsbuf ) { kmem_free ( sbuf ) ; return 0 ; } for ( ; i < nsbuf ; i ++ , sbp ++ ) { if ( cursor -> hashval != sbp -> hash ) { cursor -> hashval = sbp -> hash ; cursor -> offset = 0 ; } error = context -> put_listent ( context , sbp -> flags , sbp -> name , sbp -> namelen , sbp -> valuelen , & sbp -> name [ sbp -> namelen ] ) ; <S2SV_StartBug> if ( error ) <S2SV_EndBug> return error ; <S2SV_StartBug> if ( context -> seen_enough ) <S2SV_EndBug> break ; cursor -> offset ++ ; } kmem_free ( sbuf ) ; return 0 ; }
CWE-119 static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; <S2SV_StartBug> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <S2SV_EndBug> return r ; }
CWE-264 int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_CHOWN ) ) <S2SV_EndBug> return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && <S2SV_StartBug> ! inode_capable ( inode , CAP_FSETID ) ) <S2SV_EndBug> attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }
CWE-264 static int svc_can_register ( const uint16_t * name , size_t name_len , pid_t spid , uid_t uid ) { const char * perm = "add" ; <S2SV_StartBug> if ( uid >= AID_APP ) { <S2SV_EndBug> return 0 ; } return check_mac_perms_from_lookup ( spid , uid , perm , str8 ( name , name_len ) ) ? 1 : 0 ; }
CWE-20 long kernel_wait4 ( pid_t upid , int __user * stat_addr , int options , struct rusage * ru ) { struct wait_opts wo ; struct pid * pid = NULL ; enum pid_type type ; long ret ; if ( options & ~ ( WNOHANG | WUNTRACED | WCONTINUED | __WNOTHREAD | __WCLONE | __WALL ) ) return - EINVAL ; <S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug> type = PIDTYPE_MAX ; else if ( upid < 0 ) { type = PIDTYPE_PGID ; pid = find_get_pid ( - upid ) ; } else if ( upid == 0 ) { type = PIDTYPE_PGID ; pid = get_task_pid ( current , PIDTYPE_PGID ) ; } else { type = PIDTYPE_PID ; pid = find_get_pid ( upid ) ; } wo . wo_type = type ; wo . wo_pid = pid ; wo . wo_flags = options | WEXITED ; wo . wo_info = NULL ; wo . wo_stat = 0 ; wo . wo_rusage = ru ; ret = do_wait ( & wo ) ; put_pid ( pid ) ; if ( ret > 0 && stat_addr && put_user ( wo . wo_stat , stat_addr ) ) ret = - EFAULT ; return ret ; }
CWE-125 static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) { EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ; switch ( type ) { case EVP_CTRL_INIT : cctx -> key_set = 0 ; cctx -> iv_set = 0 ; cctx -> L = 8 ; cctx -> M = 12 ; cctx -> tag_set = 0 ; cctx -> len_set = 0 ; cctx -> tls_aad_len = - 1 ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; cctx -> tls_aad_len = arg ; { uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; <S2SV_StartBug> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= cctx -> M ; <S2SV_EndBug> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return cctx -> M ; case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ; return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ; case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ; cctx -> L = arg ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ; if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ; if ( ptr ) { cctx -> tag_set = 1 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; } cctx -> M = arg ; return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ; if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ; cctx -> tag_set = 0 ; cctx -> iv_set = 0 ; cctx -> len_set = 0 ; return 1 ; case EVP_CTRL_COPY : { EVP_CIPHER_CTX * out = ptr ; EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ; if ( cctx -> ccm . key ) { if ( cctx -> ccm . key != & cctx -> ks ) return 0 ; cctx_out -> ccm . key = & cctx_out -> ks ; } return 1 ; } default : return - 1 ; } }
CWE-119 static int put_chars ( u32 vtermno , const char * buf , int count ) { struct port * port ; <S2SV_StartBug> struct scatterlist sg [ 1 ] ; <S2SV_EndBug> if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ; port = find_port_by_vtermno ( vtermno ) ; if ( ! port ) return - EPIPE ; <S2SV_StartBug> sg_init_one ( sg , buf , count ) ; <S2SV_EndBug> <S2SV_StartBug> return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-416 static void * __ns_get_path ( struct path * path , struct ns_common * ns ) { struct vfsmount * mnt = nsfs_mnt ; struct qstr qname = { . name = "" , } ; struct dentry * dentry ; struct inode * inode ; unsigned long d ; rcu_read_lock ( ) ; d = atomic_long_read ( & ns -> stashed ) ; if ( ! d ) goto slow ; dentry = ( struct dentry * ) d ; if ( ! lockref_get_not_dead ( & dentry -> d_lockref ) ) goto slow ; rcu_read_unlock ( ) ; ns -> ops -> put ( ns ) ; got_it : path -> mnt = mntget ( mnt ) ; path -> dentry = dentry ; return NULL ; slow : rcu_read_unlock ( ) ; inode = new_inode_pseudo ( mnt -> mnt_sb ) ; if ( ! inode ) { ns -> ops -> put ( ns ) ; return ERR_PTR ( - ENOMEM ) ; } inode -> i_ino = ns -> inum ; inode -> i_mtime = inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; inode -> i_flags |= S_IMMUTABLE ; inode -> i_mode = S_IFREG | S_IRUGO ; inode -> i_fop = & ns_file_operations ; inode -> i_private = ns ; dentry = d_alloc_pseudo ( mnt -> mnt_sb , & qname ) ; if ( ! dentry ) { iput ( inode ) ; return ERR_PTR ( - ENOMEM ) ; } d_instantiate ( dentry , inode ) ; <S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ; if ( d ) { d_delete ( dentry ) ; dput ( dentry ) ; cpu_relax ( ) ; return ERR_PTR ( - EAGAIN ) ; } goto got_it ; }
CWE-20 int tls1_mac ( SSL * ssl , SSL3_RECORD * rec , unsigned char * md , int send ) { unsigned char * seq ; EVP_MD_CTX * hash ; size_t md_size ; int i ; EVP_MD_CTX * hmac = NULL , * mac_ctx ; unsigned char header [ 13 ] ; int stream_mac = ( send ? ( ssl -> mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM ) : ( ssl -> mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM ) ) ; int t ; if ( send ) { seq = RECORD_LAYER_get_write_sequence ( & ssl -> rlayer ) ; hash = ssl -> write_hash ; } else { seq = RECORD_LAYER_get_read_sequence ( & ssl -> rlayer ) ; hash = ssl -> read_hash ; } t = EVP_MD_CTX_size ( hash ) ; OPENSSL_assert ( t >= 0 ) ; md_size = t ; if ( stream_mac ) { mac_ctx = hash ; } else { hmac = EVP_MD_CTX_new ( ) ; if ( hmac == NULL || ! EVP_MD_CTX_copy ( hmac , hash ) ) return - 1 ; mac_ctx = hmac ; } if ( SSL_IS_DTLS ( ssl ) ) { unsigned char dtlsseq [ 8 ] , * p = dtlsseq ; s2n ( send ? DTLS_RECORD_LAYER_get_w_epoch ( & ssl -> rlayer ) : DTLS_RECORD_LAYER_get_r_epoch ( & ssl -> rlayer ) , p ) ; memcpy ( p , & seq [ 2 ] , 6 ) ; memcpy ( header , dtlsseq , 8 ) ; } else memcpy ( header , seq , 8 ) ; header [ 8 ] = rec -> type ; header [ 9 ] = ( unsigned char ) ( ssl -> version >> 8 ) ; header [ 10 ] = ( unsigned char ) ( ssl -> version ) ; header [ 11 ] = ( rec -> length ) >> 8 ; header [ 12 ] = ( rec -> length ) & 0xff ; <S2SV_StartBug> if ( ! send && ! SSL_USE_ETM ( ssl ) && <S2SV_EndBug> EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && ssl3_cbc_record_digest_supported ( mac_ctx ) ) { if ( ssl3_cbc_digest_record ( mac_ctx , md , & md_size , header , rec -> input , rec -> length + md_size , rec -> orig_len , ssl -> s3 -> read_mac_secret , ssl -> s3 -> read_mac_secret_size , 0 ) <= 0 ) { EVP_MD_CTX_free ( hmac ) ; return - 1 ; } } else { if ( EVP_DigestSignUpdate ( mac_ctx , header , sizeof ( header ) ) <= 0 || EVP_DigestSignUpdate ( mac_ctx , rec -> input , rec -> length ) <= 0 || EVP_DigestSignFinal ( mac_ctx , md , & md_size ) <= 0 ) { EVP_MD_CTX_free ( hmac ) ; return - 1 ; } <S2SV_StartBug> if ( ! send && ! SSL_USE_ETM ( ssl ) && FIPS_mode ( ) ) <S2SV_EndBug> if ( ! tls_fips_digest_extra ( ssl -> enc_read_ctx , mac_ctx , rec -> input , rec -> length , rec -> orig_len ) ) { EVP_MD_CTX_free ( hmac ) ; return - 1 ; } } EVP_MD_CTX_free ( hmac ) ; # ifdef SSL_DEBUG fprintf ( stderr , "seq=" ) ; { int z ; for ( z = 0 ; z < 8 ; z ++ ) fprintf ( stderr , "%02X<S2SV_blank>" , seq [ z ] ) ; fprintf ( stderr , "\\n" ) ; } fprintf ( stderr , "rec=" ) ; { unsigned int z ; for ( z = 0 ; z < rec -> length ; z ++ ) fprintf ( stderr , "%02X<S2SV_blank>" , rec -> data [ z ] ) ; fprintf ( stderr , "\\n" ) ; } # endif if ( ! SSL_IS_DTLS ( ssl ) ) { for ( i = 7 ; i >= 0 ; i -- ) { ++ seq [ i ] ; if ( seq [ i ] != 0 ) break ; } } # ifdef SSL_DEBUG { unsigned int z ; for ( z = 0 ; z < md_size ; z ++ ) fprintf ( stderr , "%02X<S2SV_blank>" , md [ z ] ) ; fprintf ( stderr , "\\n" ) ; } # endif return ( md_size ) ; }
CWE-20 static int pppoe_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t total_len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int error = 0 ; if ( sk -> sk_state & PPPOX_BOUND ) { error = - EIO ; goto end ; } skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & error ) ; if ( error < 0 ) goto end ; <S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> if ( skb ) { total_len = min_t ( size_t , total_len , skb -> len ) ; error = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , total_len ) ; if ( error == 0 ) { consume_skb ( skb ) ; return total_len ; } } kfree_skb ( skb ) ; end : return error ; }
CWE-119 <S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> bloc = * offset ; <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> * offset = bloc ; }
CWE-476 static ssize_t o2nm_node_ipv4_address_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> int ret , i ; struct rb_node * * p , * parent ; unsigned int octets [ 4 ] ; __be32 ipv4_addr = 0 ; ret = sscanf ( page , "%3u.%3u.%3u.%3u" , & octets [ 3 ] , & octets [ 2 ] , & octets [ 1 ] , & octets [ 0 ] ) ; if ( ret != 4 ) return - EINVAL ; for ( i = 0 ; i < ARRAY_SIZE ( octets ) ; i ++ ) { if ( octets [ i ] > 255 ) return - ERANGE ; be32_add_cpu ( & ipv4_addr , octets [ i ] << ( i * 8 ) ) ; } <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> write_lock ( & cluster -> cl_nodes_lock ) ; if ( o2nm_node_ip_tree_lookup ( cluster , ipv4_addr , & p , & parent ) ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { rb_link_node ( & node -> nd_ip_node , parent , p ) ; rb_insert_color ( & node -> nd_ip_node , & cluster -> cl_node_ip_tree ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> return ret ; memcpy ( & node -> nd_ipv4_address , & ipv4_addr , sizeof ( ipv4_addr ) ) ; return count ; }
CWE-000 static int lxc_mount_auto_mounts ( struct lxc_conf * conf , int flags , struct lxc_handler * handler ) { int r ; size_t i ; static struct { int match_mask ; int match_flag ; const char * source ; const char * destination ; const char * fstype ; unsigned long flags ; const char * options ; } default_mounts [ ] = { { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , "proc" , "%r/proc" , "proc" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , "%r/proc/sys/net" , "%r/proc/net" , NULL , MS_BIND , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , "%r/proc/sys" , "%r/proc/sys" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , "%r/proc/sys" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , "%r/proc/net" , "%r/proc/sys/net" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , "%r/proc/sysrq-trigger" , "%r/proc/sysrq-trigger" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , "%r/proc/sysrq-trigger" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_RW , "proc" , "%r/proc" , "proc" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RW , "sysfs" , "%r/sys" , "sysfs" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RO , "sysfs" , "%r/sys" , "sysfs" , MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , "sysfs" , "%r/sys" , "sysfs" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , "%r/sys" , "%r/sys" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , "%r/sys" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , "sysfs" , "%r/sys/devices/virtual/net" , "sysfs" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , "%r/sys/devices/virtual/net/devices/virtual/net" , "%r/sys/devices/virtual/net" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , "%r/sys/devices/virtual/net" , NULL , MS_REMOUNT | MS_BIND | MS_NOSUID | MS_NODEV | MS_NOEXEC , NULL } , { 0 , 0 , NULL , NULL , NULL , 0 , NULL } } ; for ( i = 0 ; default_mounts [ i ] . match_mask ; i ++ ) { if ( ( flags & default_mounts [ i ] . match_mask ) == default_mounts [ i ] . match_flag ) { char * source = NULL ; char * destination = NULL ; int saved_errno ; unsigned long mflags ; if ( default_mounts [ i ] . source ) { source = lxc_string_replace ( "%r" , conf -> rootfs . path ? conf -> rootfs . mount : "" , default_mounts [ i ] . source ) ; if ( ! source ) { SYSERROR ( "memory<S2SV_blank>allocation<S2SV_blank>error" ) ; return - 1 ; } } if ( default_mounts [ i ] . destination ) { destination = lxc_string_replace ( "%r" , conf -> rootfs . path ? conf -> rootfs . mount : "" , default_mounts [ i ] . destination ) ; if ( ! destination ) { saved_errno = errno ; SYSERROR ( "memory<S2SV_blank>allocation<S2SV_blank>error" ) ; free ( source ) ; errno = saved_errno ; return - 1 ; } } mflags = add_required_remount_flags ( source , destination , default_mounts [ i ] . flags ) ; <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> saved_errno = errno ; if ( r < 0 && errno == ENOENT ) { INFO ( "Mount<S2SV_blank>source<S2SV_blank>or<S2SV_blank>target<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>doesn\'t<S2SV_blank>exist.<S2SV_blank>Skipping." , source , destination ) ; r = 0 ; } else if ( r < 0 ) SYSERROR ( "error<S2SV_blank>mounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>flags<S2SV_blank>%lu" , source , destination , mflags ) ; free ( source ) ; free ( destination ) ; if ( r < 0 ) { errno = saved_errno ; return - 1 ; } } } if ( flags & LXC_AUTO_CGROUP_MASK ) { int cg_flags ; cg_flags = flags & LXC_AUTO_CGROUP_MASK ; if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC ) { int has_sys_admin = 0 ; if ( ! lxc_list_empty ( & conf -> keepcaps ) ) { has_sys_admin = in_caplist ( CAP_SYS_ADMIN , & conf -> keepcaps ) ; } else { has_sys_admin = ! in_caplist ( CAP_SYS_ADMIN , & conf -> caps ) ; } if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC ) { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED ; } else { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED ; } } if ( ! cgroup_mount ( conf -> rootfs . path ? conf -> rootfs . mount : "" , handler , cg_flags ) ) { SYSERROR ( "error<S2SV_blank>mounting<S2SV_blank>/sys/fs/cgroup" ) ; return - 1 ; } } return 0 ; }
CWE-000 kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) { int ret , ret2 , i ; kadm5_policy_ent_rec pol ; krb5_boolean have_pol = FALSE ; krb5_db_entry * kdb ; krb5_tl_data * tl_data_orig ; osa_princ_ent_rec adb ; kadm5_server_handle_t handle = server_handle ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; <S2SV_StartBug> if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || <S2SV_EndBug> ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ; <S2SV_StartBug> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <S2SV_EndBug> return KADM5_BAD_MASK ; <S2SV_StartBug> if ( entry == ( kadm5_principal_ent_t ) NULL ) <S2SV_EndBug> return EINVAL ; if ( mask & KADM5_TL_DATA ) { tl_data_orig = entry -> tl_data ; while ( tl_data_orig ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; } } ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; if ( ret ) return ( ret ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ; if ( ret ) goto done ; adb . aux_attributes |= KADM5_POLICY ; if ( adb . policy ) free ( adb . policy ) ; adb . policy = strdup ( entry -> policy ) ; } if ( have_pol ) { if ( pol . pw_max_life ) { ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & ( kdb -> pw_expiration ) ) ; if ( ret ) goto done ; kdb -> pw_expiration += pol . pw_max_life ; } else { kdb -> pw_expiration = 0 ; } } if ( ( mask & KADM5_POLICY_CLR ) && ( adb . aux_attributes & KADM5_POLICY ) ) { free ( adb . policy ) ; adb . policy = NULL ; adb . aux_attributes &= ~ KADM5_POLICY ; kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; if ( mask & KADM5_PW_EXPIRATION ) kdb -> pw_expiration = entry -> pw_expiration ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; if ( ( mask & KADM5_KVNO ) ) { for ( i = 0 ; i < kdb -> n_key_data ; i ++ ) kdb -> key_data [ i ] . key_data_kvno = entry -> kvno ; } if ( mask & KADM5_TL_DATA ) { krb5_tl_data * tl ; for ( tl = entry -> tl_data ; tl ; tl = tl -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl ) ; if ( ret ) { goto done ; } } } if ( mask & KADM5_FAIL_AUTH_COUNT ) { if ( entry -> fail_auth_count != 0 ) { ret = KADM5_BAD_SERVER_PARAMS ; goto done ; } kdb -> fail_auth_count = 0 ; } kdb -> mask = mask ; ret = k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask ) ; if ( ret ) goto done ; ret = kdb_put_entry ( handle , kdb , & adb ) ; if ( ret ) goto done ; ( void ) k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask ) ; ret = KADM5_OK ; done : if ( have_pol ) { ret2 = kadm5_free_policy_ent ( handle -> lhandle , & pol ) ; ret = ret ? ret : ret2 ; } kdb_free_entry ( handle , kdb , & adb ) ; return ret ; }
CWE-119 bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) { <S2SV_StartBug> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <S2SV_EndBug> struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ; <S2SV_StartBug> if ( ! i_ext || ! i_ext -> len ) <S2SV_EndBug> return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ; <S2SV_StartBug> return false ; <S2SV_EndBug> }
CWE-189 static void tcp_cwnd_reduction ( struct sock * sk , const int prior_unsacked , int fast_rexmit , int flag ) { struct tcp_sock * tp = tcp_sk ( sk ) ; int sndcnt = 0 ; int delta = tp -> snd_ssthresh - tcp_packets_in_flight ( tp ) ; int newly_acked_sacked = prior_unsacked - ( tp -> packets_out - tp -> sacked_out ) ; <S2SV_StartBug> tp -> prr_delivered += newly_acked_sacked ; <S2SV_EndBug> if ( delta < 0 ) { u64 dividend = ( u64 ) tp -> snd_ssthresh * tp -> prr_delivered + tp -> prior_cwnd - 1 ; sndcnt = div_u64 ( dividend , tp -> prior_cwnd ) - tp -> prr_out ; } else if ( ( flag & FLAG_RETRANS_DATA_ACKED ) && ! ( flag & FLAG_LOST_RETRANS ) ) { sndcnt = min_t ( int , delta , max_t ( int , tp -> prr_delivered - tp -> prr_out , newly_acked_sacked ) + 1 ) ; } else { sndcnt = min ( delta , newly_acked_sacked ) ; } sndcnt = max ( sndcnt , ( fast_rexmit ? 1 : 0 ) ) ; tp -> snd_cwnd = tcp_packets_in_flight ( tp ) + sndcnt ; }
CWE-000 static void usage ( void ) { fprintf ( stderr , "usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\n" <S2SV_StartBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n" <S2SV_EndBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>-k\\n" ) ; exit ( 1 ) ; }
CWE-362 fm_mgr_config_errno_t fm_mgr_config_init ( OUT p_fm_config_conx_hdlt * p_hdl , IN int instance , OPTIONAL IN char * rem_address , OPTIONAL IN char * community ) { fm_config_conx_hdl * hdl ; fm_mgr_config_errno_t res = FM_CONF_OK ; if ( ( hdl = calloc ( 1 , sizeof ( fm_config_conx_hdl ) ) ) == NULL ) { res = FM_CONF_NO_MEM ; goto cleanup ; } hdl -> instance = instance ; * p_hdl = hdl ; if ( ! rem_address || ( strcmp ( rem_address , "localhost" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } } <S2SV_StartBug> return res ; <S2SV_EndBug> cleanup : if ( hdl ) { free ( hdl ) ; hdl = NULL ; } return res ; }
CWE-000 void impeg2d_peek_next_start_code ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> { impeg2d_bit_stream_get ( ps_stream , 8 ) ; } return ; }
CWE-264 int cap_bprm_set_creds ( struct linux_binprm * bprm ) { const struct cred * old = current_cred ( ) ; struct cred * new = bprm -> cred ; bool effective , has_cap = false ; int ret ; effective = false ; ret = get_file_caps ( bprm , & effective , & has_cap ) ; if ( ret < 0 ) return ret ; if ( ! issecure ( SECURE_NOROOT ) ) { if ( has_cap && new -> uid != 0 && new -> euid == 0 ) { warn_setuid_and_fcaps_mixed ( bprm -> filename ) ; goto skip ; } if ( new -> euid == 0 || new -> uid == 0 ) { new -> cap_permitted = cap_combine ( old -> cap_bset , old -> cap_inheritable ) ; } if ( new -> euid == 0 ) effective = true ; } skip : <S2SV_StartBug> if ( ( new -> euid != old -> uid || <S2SV_EndBug> new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) { if ( ! capable ( CAP_SETUID ) ) { new -> euid = new -> uid ; new -> egid = new -> gid ; } new -> cap_permitted = cap_intersect ( new -> cap_permitted , old -> cap_permitted ) ; } new -> suid = new -> fsuid = new -> euid ; new -> sgid = new -> fsgid = new -> egid ; if ( effective ) new -> cap_effective = new -> cap_permitted ; else cap_clear ( new -> cap_effective ) ; bprm -> cap_effective = effective ; if ( ! cap_isclear ( new -> cap_effective ) ) { if ( ! cap_issubset ( CAP_FULL_SET , new -> cap_effective ) || new -> euid != 0 || new -> uid != 0 || issecure ( SECURE_NOROOT ) ) { ret = audit_log_bprm_fcaps ( bprm , new , old ) ; if ( ret < 0 ) return ret ; } } new -> securebits &= ~ issecure_mask ( SECURE_KEEP_CAPS ) ; return 0 ; }
CWE-000 static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , <S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> { # ifdef HAVE_STATVFS struct statvfs sb ; # endif <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( "remounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>respect<S2SV_blank>bind<S2SV_blank>or<S2SV_blank>remount<S2SV_blank>options" , fsname ? fsname : "(none)" , target ? target : "(none)" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ; # ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( "(at<S2SV_blank>remount)<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>required<S2SV_blank>extra<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>%lu" , fsname , sb . f_flag , required_flags ) ; if ( ! ( mountflags & MS_REMOUNT ) ) { if ( ! ( required_flags & ~ mountflags ) && rqd_flags == 0 ) { DEBUG ( "mountflags<S2SV_blank>already<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>skipping<S2SV_blank>remount" , mountflags ) ; goto skipremount ; } } mountflags |= required_flags ; } # endif if ( mount ( fsname , target , fstype , <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , fsname , target ) ; return - 1 ; } } } # ifdef HAVE_STATVFS skipremount : # endif DEBUG ( "mounted<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\',<S2SV_blank>type<S2SV_blank>\'%s\'" , fsname , target , fstype ) ; return 0 ; }
CWE-362 static int userfaultfd_release ( struct inode * inode , struct file * file ) { struct userfaultfd_ctx * ctx = file -> private_data ; struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev ; struct userfaultfd_wake_range range = { . len = 0 , } ; unsigned long new_flags ; WRITE_ONCE ( ctx -> released , true ) ; if ( ! mmget_not_zero ( mm ) ) goto wakeup ; down_write ( & mm -> mmap_sem ) ; <S2SV_StartBug> prev = NULL ; <S2SV_EndBug> for ( vma = mm -> mmap ; vma ; vma = vma -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! vma -> vm_userfaultfd_ctx . ctx ^ ! ! ( vma -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx != ctx ) { prev = vma ; continue ; } new_flags = vma -> vm_flags & ~ ( VM_UFFD_MISSING | VM_UFFD_WP ) ; prev = vma_merge ( mm , prev , vma -> vm_start , vma -> vm_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , NULL_VM_UFFD_CTX ) ; if ( prev ) vma = prev ; else prev = vma ; vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx = NULL_VM_UFFD_CTX ; } <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; wakeup : spin_lock ( & ctx -> fault_pending_wqh . lock ) ; __wake_up_locked_key ( & ctx -> fault_pending_wqh , TASK_NORMAL , & range ) ; __wake_up ( & ctx -> fault_wqh , TASK_NORMAL , 1 , & range ) ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; wake_up_all ( & ctx -> event_wqh ) ; wake_up_poll ( & ctx -> fd_wqh , EPOLLHUP ) ; userfaultfd_ctx_put ( ctx ) ; return 0 ; }
CWE-415 static int netlink_dump ( struct sock * sk ) { struct netlink_sock * nlk = nlk_sk ( sk ) ; struct netlink_callback * cb ; struct sk_buff * skb = NULL ; struct nlmsghdr * nlh ; <S2SV_StartBug> int len , err = - ENOBUFS ; <S2SV_EndBug> int alloc_min_size ; int alloc_size ; mutex_lock ( nlk -> cb_mutex ) ; if ( ! nlk -> cb_running ) { err = - EINVAL ; goto errout_skb ; } if ( atomic_read ( & sk -> sk_rmem_alloc ) >= sk -> sk_rcvbuf ) goto errout_skb ; cb = & nlk -> cb ; alloc_min_size = max_t ( int , cb -> min_dump_alloc , NLMSG_GOODSIZE ) ; if ( alloc_min_size < nlk -> max_recvmsg_len ) { alloc_size = nlk -> max_recvmsg_len ; skb = alloc_skb ( alloc_size , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; } if ( ! skb ) { alloc_size = alloc_min_size ; skb = alloc_skb ( alloc_size , GFP_KERNEL ) ; } if ( ! skb ) goto errout_skb ; skb_reserve ( skb , skb_tailroom ( skb ) - alloc_size ) ; netlink_skb_set_owner_r ( skb , sk ) ; len = cb -> dump ( skb , cb ) ; if ( len > 0 ) { mutex_unlock ( nlk -> cb_mutex ) ; if ( sk_filter ( sk , skb ) ) kfree_skb ( skb ) ; else __netlink_sendskb ( sk , skb ) ; return 0 ; } nlh = nlmsg_put_answer ( skb , cb , NLMSG_DONE , sizeof ( len ) , NLM_F_MULTI ) ; if ( ! nlh ) goto errout_skb ; nl_dump_check_consistent ( cb , nlh ) ; memcpy ( nlmsg_data ( nlh ) , & len , sizeof ( len ) ) ; if ( sk_filter ( sk , skb ) ) kfree_skb ( skb ) ; else __netlink_sendskb ( sk , skb ) ; if ( cb -> done ) cb -> done ( cb ) ; nlk -> cb_running = false ; <S2SV_StartBug> mutex_unlock ( nlk -> cb_mutex ) ; <S2SV_EndBug> <S2SV_StartBug> module_put ( cb -> module ) ; <S2SV_EndBug> <S2SV_StartBug> consume_skb ( cb -> skb ) ; <S2SV_EndBug> return 0 ; errout_skb : mutex_unlock ( nlk -> cb_mutex ) ; kfree_skb ( skb ) ; return err ; }
CWE-20 int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr_storage * address , int mode ) { int size , ct , err ; if ( m -> msg_namelen ) { if ( mode == VERIFY_READ ) { void __user * namep ; namep = ( void __user __force * ) m -> msg_name ; err = move_addr_to_kernel ( namep , m -> msg_namelen , address ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> m -> msg_name = address ; <S2SV_EndBug> } else { m -> msg_name = NULL ; } size = m -> msg_iovlen * sizeof ( struct iovec ) ; if ( copy_from_user ( iov , ( void __user __force * ) m -> msg_iov , size ) ) return - EFAULT ; m -> msg_iov = iov ; err = 0 ; for ( ct = 0 ; ct < m -> msg_iovlen ; ct ++ ) { size_t len = iov [ ct ] . iov_len ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return err ; }
CWE-119 static int picolcd_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * raw_data , int size ) { struct picolcd_data * data = hid_get_drvdata ( hdev ) ; unsigned long flags ; int ret = 0 ; if ( ! data ) return 1 ; <S2SV_StartBug> if ( report -> id == REPORT_KEY_STATE ) { <S2SV_EndBug> if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ; } else if ( report -> id == REPORT_IR_DATA ) { ret = picolcd_raw_cir ( data , report , raw_data + 1 , size - 1 ) ; } else { spin_lock_irqsave ( & data -> lock , flags ) ; if ( data -> pending ) { memcpy ( data -> pending -> raw_data , raw_data + 1 , size - 1 ) ; data -> pending -> raw_size = size - 1 ; data -> pending -> in_report = report ; complete ( & data -> pending -> ready ) ; } spin_unlock_irqrestore ( & data -> lock , flags ) ; } picolcd_debug_raw_event ( data , hdev , report , raw_data , size ) ; return 1 ; }
CWE-189 static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }
CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , "Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>read<S2SV_blank>=<S2SV_blank>%d\\n" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ; <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , "bad<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>count<S2SV_blank>%d\\n" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }
CWE-399 long video_ioctl2 ( struct file * file , unsigned int cmd , unsigned long arg ) { <S2SV_StartBug> char sbuf [ 128 ] ; <S2SV_EndBug> void * mbuf = NULL ; void * parg = ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } <S2SV_StartBug> err = __video_do_ioctl ( file , cmd , parg ) ; <S2SV_EndBug> if ( err == - ENOIOCTLCMD ) err = - EINVAL ; if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : switch ( _IOC_DIR ( cmd ) ) { case _IOC_READ : case ( _IOC_WRITE | _IOC_READ ) : if ( copy_to_user ( ( void __user * ) arg , parg , _IOC_SIZE ( cmd ) ) ) err = - EFAULT ; break ; } out : kfree ( mbuf ) ; return err ; }
CWE-125 static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }
CWE-119 int module_load ( YR_SCAN_CONTEXT * context , YR_OBJECT * module_object , void * module_data , size_t module_data_size ) { set_integer ( 1 , module_object , "constants.one" ) ; set_integer ( 2 , module_object , "constants.two" ) ; set_string ( "foo" , module_object , "constants.foo" ) ; set_string ( "" , module_object , "constants.empty" ) ; set_integer ( 1 , module_object , "struct_array[1].i" ) ; set_integer ( 0 , module_object , "integer_array[%i]" , 0 ) ; set_integer ( 1 , module_object , "integer_array[%i]" , 1 ) ; set_integer ( 2 , module_object , "integer_array[%i]" , 2 ) ; <S2SV_StartBug> set_string ( "foo" , module_object , "string_array[%i]" , 0 ) ; <S2SV_EndBug> set_string ( "bar" , module_object , "string_array[%i]" , 1 ) ; set_string ( "baz" , module_object , "string_array[%i]" , 2 ) ; set_sized_string ( "foo\\0bar" , 7 , module_object , "string_array[%i]" , 3 ) ; set_string ( "foo" , module_object , "string_dict[%s]" , "foo" ) ; set_string ( "bar" , module_object , "string_dict[\\"bar\\"]" ) ; set_string ( "foo" , module_object , "struct_dict[%s].s" , "foo" ) ; set_integer ( 1 , module_object , "struct_dict[%s].i" , "foo" ) ; return ERROR_SUCCESS ; }
CWE-20 static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; type = dh -> dccph_type ; if ( type == DCCP_PKT_RESET && ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_ACCEPT ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case CT_DCCP_REQUEST : if ( old_state == CT_DCCP_TIMEWAIT && role == CT_DCCP_ROLE_SERVER ) { ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; } break ; case CT_DCCP_RESPOND : if ( old_state == CT_DCCP_REQUEST ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case CT_DCCP_PARTOPEN : if ( old_state == CT_DCCP_RESPOND && type == DCCP_PKT_ACK && dccp_ack_seq ( dh ) == ct -> proto . dccp . handshake_seq ) set_bit ( IPS_ASSURED_BIT , & ct -> status ) ; break ; case CT_DCCP_IGNORE : if ( ct -> proto . dccp . last_dir == ! dir && ct -> proto . dccp . last_pkt == DCCP_PKT_REQUEST && type == DCCP_PKT_RESPONSE ) { ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; new_state = CT_DCCP_RESPOND ; break ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , "nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>ignored<S2SV_blank>" ) ; return NF_ACCEPT ; case CT_DCCP_INVALID : spin_unlock_bh ( & ct -> lock ) ; if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , "nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>" ) ; return - NF_ACCEPT ; } ct -> proto . dccp . last_dir = dir ; ct -> proto . dccp . last_pkt = type ; ct -> proto . dccp . state = new_state ; spin_unlock_bh ( & ct -> lock ) ; if ( new_state != old_state ) nf_conntrack_event_cache ( IPCT_PROTOINFO , ct ) ; nf_ct_refresh_acct ( ct , ctinfo , skb , timeouts [ new_state ] ) ; return NF_ACCEPT ; }
CWE-20 static int netbk_count_requests ( struct xenvif * vif , struct xen_netif_tx_request * first , struct xen_netif_tx_request * txp , int work_to_do ) { RING_IDX cons = vif -> tx . req_cons ; int frags = 0 ; if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ; do { if ( frags >= work_to_do ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , "Need<S2SV_blank>more<S2SV_blank>frags\\n" ) ; <S2SV_EndBug> return - frags ; } if ( unlikely ( frags >= MAX_SKB_FRAGS ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , "Too<S2SV_blank>many<S2SV_blank>frags\\n" ) ; <S2SV_EndBug> return - frags ; } memcpy ( txp , RING_GET_REQUEST ( & vif -> tx , cons + frags ) , sizeof ( * txp ) ) ; if ( txp -> size > first -> size ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , "Frags<S2SV_blank>galore\\n" ) ; <S2SV_EndBug> return - frags ; } first -> size -= txp -> size ; frags ++ ; if ( unlikely ( ( txp -> offset + txp -> size ) > PAGE_SIZE ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , "txp->offset:<S2SV_blank>%x,<S2SV_blank>size:<S2SV_blank>%u\\n" , <S2SV_EndBug> <S2SV_StartBug> txp -> offset , txp -> size ) ; <S2SV_EndBug> return - frags ; } } while ( ( txp ++ ) -> flags & XEN_NETTXF_more_data ) ; return frags ; }
CWE-20 static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; <S2SV_StartBug> if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; switch ( mode ) { case PSR_AA32_MODE_USR : case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }
CWE-362 hsm_com_errno_t hcom_client_init ( OUT p_hsm_com_client_hdl_t * p_hdl , IN char * server_path , IN char * client_path , IN int max_data_len ) { hsm_com_client_hdl_t * hdl = NULL ; hsm_com_errno_t res = HSM_COM_OK ; if ( ( strlen ( server_path ) > ( HSM_COM_SVR_MAX_PATH - 1 ) ) || ( strlen ( server_path ) == 0 ) ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } if ( ( strlen ( client_path ) > ( HSM_COM_SVR_MAX_PATH - 1 ) ) || ( strlen ( client_path ) == 0 ) ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } if ( ( hdl = calloc ( 1 , sizeof ( hsm_com_client_hdl_t ) ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> scr . scratch = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> recv_buf = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> send_buf = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } hdl -> scr . scratch_fill = 0 ; hdl -> scr . scratch_len = max_data_len ; hdl -> buf_len = max_data_len ; hdl -> trans_id = 1 ; strcpy ( hdl -> s_path , server_path ) ; strcpy ( hdl -> c_path , client_path ) ; <S2SV_StartBug> hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_EndBug> * p_hdl = hdl ; return res ; cleanup : if ( hdl ) { if ( hdl -> scr . scratch ) { free ( hdl -> scr . scratch ) ; } if ( hdl -> recv_buf ) { free ( hdl -> recv_buf ) ; } free ( hdl ) ; } return res ; }
CWE-119 static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } if ( pqueue_insert ( queue -> q , item ) == NULL ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } return ( 1 ) ; }
CWE-20 int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 ) <S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }
CWE-264 static int ima_lsm_rule_init ( struct ima_measure_rule_entry * entry , char * args , int lsm_rule , int audit_type ) { int result ; if ( entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; entry -> lsm [ lsm_rule ] . type = audit_type ; result = security_filter_rule_init ( entry -> lsm [ lsm_rule ] . type , Audit_equal , args , & entry -> lsm [ lsm_rule ] . rule ) ; <S2SV_StartBug> return result ; <S2SV_EndBug> }
CWE-399 static int db_interception ( struct vcpu_svm * svm ) { struct kvm_run * kvm_run = svm -> vcpu . run ; if ( ! ( svm -> vcpu . guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) && ! svm -> nmi_singlestep ) { kvm_queue_exception ( & svm -> vcpu , DB_VECTOR ) ; return 1 ; } if ( svm -> nmi_singlestep ) { svm -> nmi_singlestep = false ; if ( ! ( svm -> vcpu . guest_debug & KVM_GUESTDBG_SINGLESTEP ) ) svm -> vmcb -> save . rflags &= ~ ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_StartBug> update_db_bp_intercept ( & svm -> vcpu ) ; <S2SV_EndBug> } if ( svm -> vcpu . guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) { kvm_run -> exit_reason = KVM_EXIT_DEBUG ; kvm_run -> debug . arch . pc = svm -> vmcb -> save . cs . base + svm -> vmcb -> save . rip ; kvm_run -> debug . arch . exception = DB_VECTOR ; return 0 ; } return 1 ; }
CWE-119 <S2SV_StartBug> void vp9_encode_mv ( VP9_COMP * cpi , vp9_writer * w , <S2SV_EndBug> const MV * mv , const MV * ref , const nmv_context * mvctx , int usehp ) { const MV diff = { mv -> row - ref -> row , mv -> col - ref -> col } ; const MV_JOINT_TYPE j = vp9_get_mv_joint ( & diff ) ; usehp = usehp && vp9_use_mv_hp ( ref ) ; vp9_write_token ( w , vp9_mv_joint_tree , mvctx -> joints , & mv_joint_encodings [ j ] ) ; if ( mv_joint_vertical ( j ) ) encode_mv_component ( w , diff . row , & mvctx -> comps [ 0 ] , usehp ) ; if ( mv_joint_horizontal ( j ) ) encode_mv_component ( w , diff . col , & mvctx -> comps [ 1 ] , usehp ) ; <S2SV_StartBug> if ( ! cpi -> dummy_packing && cpi -> sf . auto_mv_step_size ) { <S2SV_EndBug> unsigned int maxv = MAX ( abs ( mv -> row ) , abs ( mv -> col ) ) >> 3 ; cpi -> max_mv_magnitude = MAX ( maxv , cpi -> max_mv_magnitude ) ; } }
CWE-399 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; if ( pmc_overflow ( val ) ) write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
CWE-20 static inline void VectorClamp ( DDSVector4 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> }
CWE-284 static void a2dp_open_ctrl_path ( struct a2dp_stream_common * common ) { int i ; for ( i = 0 ; i < CTRL_CHAN_RETRY_COUNT ; i ++ ) { if ( ( common -> ctrl_fd = skt_connect ( A2DP_CTRL_PATH , common -> buffer_sz ) ) > 0 ) { if ( check_a2dp_ready ( common ) == 0 ) break ; ERROR ( "error<S2SV_blank>:<S2SV_blank>a2dp<S2SV_blank>not<S2SV_blank>ready,<S2SV_blank>wait<S2SV_blank>250<S2SV_blank>ms<S2SV_blank>and<S2SV_blank>retry" ) ; <S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; } <S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> } }
CWE-362 static int smb_send_rqst ( struct TCP_Server_Info * server , struct smb_rqst * rqst ) { int rc ; struct kvec * iov = rqst -> rq_iov ; int n_vec = rqst -> rq_nvec ; unsigned int smb_buf_length = get_rfc1002_length ( iov [ 0 ] . iov_base ) ; unsigned int i ; size_t total_len = 0 , sent ; struct socket * ssocket = server -> ssocket ; <S2SV_StartBug> int val = 1 ; <S2SV_EndBug> cFYI ( 1 , "Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u" , smb_buf_length ) ; dump_smb ( iov [ 0 ] . iov_base , iov [ 0 ] . iov_len ) ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; rc = smb_send_kvec ( server , iov , n_vec , & sent ) ; if ( rc < 0 ) goto uncork ; total_len += sent ; for ( i = 0 ; i < rqst -> rq_npages ; i ++ ) { struct kvec p_iov ; cifs_rqst_page_to_kvec ( rqst , i , & p_iov ) ; rc = smb_send_kvec ( server , & p_iov , 1 , & sent ) ; kunmap ( rqst -> rq_pages [ i ] ) ; if ( rc < 0 ) break ; total_len += sent ; } uncork : val = 0 ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; if ( ( total_len > 0 ) && ( total_len != smb_buf_length + 4 ) ) { cFYI ( 1 , "partial<S2SV_blank>send<S2SV_blank>(wanted=%u<S2SV_blank>sent=%zu):<S2SV_blank>terminating<S2SV_blank>" "session" , smb_buf_length + 4 , total_len ) ; server -> tcpStatus = CifsNeedReconnect ; } if ( rc < 0 && rc != - EINTR ) cERROR ( 1 , "Error<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>data<S2SV_blank>on<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>server" , rc ) ; else rc = 0 ; return rc ; }
CWE-476 jp2_box_t * jp2_box_create ( int type ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; <S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> return 0 ; } <S2SV_StartBug> memset ( box , 0 , sizeof ( jp2_box_t ) ) ; <S2SV_EndBug> box -> type = type ; box -> len = 0 ; if ( ! ( boxinfo = jp2_boxinfolookup ( type ) ) ) { return 0 ; } box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; return box ; }
CWE-000 void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( "usage:<S2SV_blank>condump<S2SV_blank><filename>\\n" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; <S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , ".txt" ) ; <S2SV_EndBug> f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( "ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n" , filename ) ; return ; } Com_Printf ( "Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) break ; if ( x != con . linewidth ) break ; } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) buffer [ x ] = 0 ; else break ; } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , "\\r\\n" ) ; # else Q_strcat ( buffer , bufferlen , "\\n" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }
CWE-476 av_cold void ff_idctdsp_init ( IDCTDSPContext * c , AVCodecContext * avctx ) { const unsigned high_bit_depth = avctx -> bits_per_raw_sample > 8 ; if ( avctx -> lowres == 1 ) { c -> idct_put = ff_jref_idct4_put ; c -> idct_add = ff_jref_idct4_add ; c -> idct = ff_j_rev_dct4 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 2 ) { c -> idct_put = ff_jref_idct2_put ; c -> idct_add = ff_jref_idct2_add ; c -> idct = ff_j_rev_dct2 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 3 ) { c -> idct_put = ff_jref_idct1_put ; c -> idct_add = ff_jref_idct1_add ; c -> idct = ff_j_rev_dct1 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) { <S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> c -> idct_put = ff_simple_idct_put_int32_10bit ; else { c -> idct_put = ff_simple_idct_put_int16_10bit ; c -> idct_add = ff_simple_idct_add_int16_10bit ; c -> idct = ff_simple_idct_int16_10bit ; } c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> bits_per_raw_sample == 12 ) { c -> idct_put = ff_simple_idct_put_int16_12bit ; c -> idct_add = ff_simple_idct_add_int16_12bit ; c -> idct = ff_simple_idct_int16_12bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> idct_algo == FF_IDCT_INT ) { c -> idct_put = ff_jref_idct_put ; c -> idct_add = ff_jref_idct_add ; c -> idct = ff_j_rev_dct ; c -> perm_type = FF_IDCT_PERM_LIBMPEG2 ; # if CONFIG_FAANIDCT } else if ( avctx -> idct_algo == FF_IDCT_FAAN ) { c -> idct_put = ff_faanidct_put ; c -> idct_add = ff_faanidct_add ; c -> idct = ff_faanidct ; c -> perm_type = FF_IDCT_PERM_NONE ; # endif } else { c -> idct_put = ff_simple_idct_put_int16_8bit ; c -> idct_add = ff_simple_idct_add_int16_8bit ; c -> idct = ff_simple_idct_int16_8bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } } } c -> put_pixels_clamped = ff_put_pixels_clamped_c ; c -> put_signed_pixels_clamped = put_signed_pixels_clamped_c ; c -> add_pixels_clamped = ff_add_pixels_clamped_c ; if ( CONFIG_MPEG4_DECODER && avctx -> idct_algo == FF_IDCT_XVID ) ff_xvid_idct_init ( c , avctx ) ; if ( ARCH_AARCH64 ) ff_idctdsp_init_aarch64 ( c , avctx , high_bit_depth ) ; if ( ARCH_ALPHA ) ff_idctdsp_init_alpha ( c , avctx , high_bit_depth ) ; if ( ARCH_ARM ) ff_idctdsp_init_arm ( c , avctx , high_bit_depth ) ; if ( ARCH_PPC ) ff_idctdsp_init_ppc ( c , avctx , high_bit_depth ) ; if ( ARCH_X86 ) ff_idctdsp_init_x86 ( c , avctx , high_bit_depth ) ; if ( ARCH_MIPS ) ff_idctdsp_init_mips ( c , avctx , high_bit_depth ) ; ff_init_scantable_permutation ( c -> idct_permutation , c -> perm_type ) ; }
CWE-000 void inode_init_owner ( struct inode * inode , const struct inode * dir , umode_t mode ) { inode -> i_uid = current_fsuid ( ) ; if ( dir && dir -> i_mode & S_ISGID ) { inode -> i_gid = dir -> i_gid ; if ( S_ISDIR ( mode ) ) mode |= S_ISGID ; <S2SV_StartBug> } else <S2SV_EndBug> inode -> i_gid = current_fsgid ( ) ; inode -> i_mode = mode ; }
CWE-362 void ieee80211_sta_ps_deliver_wakeup ( struct sta_info * sta ) { struct ieee80211_sub_if_data * sdata = sta -> sdata ; struct ieee80211_local * local = sdata -> local ; struct sk_buff_head pending ; int filtered = 0 , buffered = 0 , ac ; unsigned long flags ; clear_sta_flag ( sta , WLAN_STA_SP ) ; BUILD_BUG_ON ( BITS_TO_LONGS ( IEEE80211_NUM_TIDS ) > 1 ) ; sta -> driver_buffered_tids = 0 ; if ( ! ( local -> hw . flags & IEEE80211_HW_AP_LINK_PS ) ) drv_sta_notify ( local , sdata , STA_NOTIFY_AWAKE , & sta -> sta ) ; skb_queue_head_init ( & pending ) ; <S2SV_StartBug> for ( ac = 0 ; ac < IEEE80211_NUM_ACS ; ac ++ ) { <S2SV_EndBug> int count = skb_queue_len ( & pending ) , tmp ; spin_lock_irqsave ( & sta -> tx_filtered [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> tx_filtered [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> tx_filtered [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; filtered += tmp - count ; count = tmp ; spin_lock_irqsave ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; skb_queue_splice_tail_init ( & sta -> ps_tx_buf [ ac ] , & pending ) ; spin_unlock_irqrestore ( & sta -> ps_tx_buf [ ac ] . lock , flags ) ; tmp = skb_queue_len ( & pending ) ; buffered += tmp - count ; } <S2SV_StartBug> ieee80211_add_pending_skbs_fn ( local , & pending , clear_sta_ps_flags , sta ) ; <S2SV_EndBug> if ( ! ieee80211_smps_is_restrictive ( sta -> known_smps_mode , sdata -> smps_mode ) && sta -> known_smps_mode != sdata -> bss -> req_smps && sta_info_tx_streams ( sta ) != 1 ) { ht_dbg ( sdata , "%pM<S2SV_blank>just<S2SV_blank>woke<S2SV_blank>up<S2SV_blank>and<S2SV_blank>MIMO<S2SV_blank>capable<S2SV_blank>-<S2SV_blank>update<S2SV_blank>SMPS\\n" , sta -> sta . addr ) ; ieee80211_send_smps_action ( sdata , sdata -> bss -> req_smps , sta -> sta . addr , sdata -> vif . bss_conf . bssid ) ; } local -> total_ps_buffered -= buffered ; sta_info_recalc_tim ( sta ) ; ps_dbg ( sdata , "STA<S2SV_blank>%pM<S2SV_blank>aid<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>%d<S2SV_blank>filtered/%d<S2SV_blank>PS<S2SV_blank>frames<S2SV_blank>since<S2SV_blank>STA<S2SV_blank>not<S2SV_blank>sleeping<S2SV_blank>anymore\\n" , sta -> sta . addr , sta -> sta . aid , filtered , buffered ) ; }
CWE-000 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }
CWE-000 static int jpc_qcd_dumpparms ( jpc_ms_t * ms , FILE * out ) { jpc_qcd_t * qcd = & ms -> parms . qcd ; int i ; fprintf ( out , "qntsty<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numguard<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numstepsizes<S2SV_blank>=<S2SV_blank>%d\\n" , ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; for ( i = 0 ; i < qcd -> compparms . numstepsizes ; ++ i ) { fprintf ( out , "expn[%d]<S2SV_blank>=<S2SV_blank>0x%04x;<S2SV_blank>mant[%d]<S2SV_blank>=<S2SV_blank>0x%04x;\\n" , <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <S2SV_EndBug> <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <S2SV_EndBug> } return 0 ; }
CWE-000 static void http_splitheader ( struct http * hp , int req ) { char * p , * q , * * hh ; int n ; char buf [ 20 ] ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; if ( req ) { memset ( hp -> req , 0 , sizeof hp -> req ) ; hh = hp -> req ; } else { memset ( hp -> resp , 0 , sizeof hp -> resp ) ; hh = hp -> resp ; } n = 0 ; p = hp -> rxbuf ; while ( vct_islws ( * p ) ) p ++ ; hh [ n ++ ] = p ; while ( ! vct_islws ( * p ) ) p ++ ; <S2SV_StartBug> assert ( ! vct_iscrlf ( * p ) ) ; <S2SV_EndBug> * p ++ = '\\0' ; while ( vct_issp ( * p ) ) p ++ ; <S2SV_StartBug> assert ( ! vct_iscrlf ( * p ) ) ; <S2SV_EndBug> hh [ n ++ ] = p ; while ( ! vct_islws ( * p ) ) p ++ ; <S2SV_StartBug> if ( vct_iscrlf ( * p ) ) { <S2SV_EndBug> hh [ n ++ ] = NULL ; q = p ; p += vct_skipcrlf ( p ) ; * q = '\\0' ; } else { * p ++ = '\\0' ; while ( vct_issp ( * p ) ) p ++ ; hh [ n ++ ] = p ; <S2SV_StartBug> while ( ! vct_iscrlf ( * p ) ) <S2SV_EndBug> p ++ ; q = p ; p += vct_skipcrlf ( p ) ; * q = '\\0' ; } assert ( n == 3 ) ; while ( * p != '\\0' ) { assert ( n < MAX_HDR ) ; <S2SV_StartBug> if ( vct_iscrlf ( * p ) ) <S2SV_EndBug> break ; hh [ n ++ ] = p ++ ; <S2SV_StartBug> while ( * p != '\\0' && ! vct_iscrlf ( * p ) ) <S2SV_EndBug> p ++ ; q = p ; p += vct_skipcrlf ( p ) ; * q = '\\0' ; } p += vct_skipcrlf ( p ) ; assert ( * p == '\\0' ) ; for ( n = 0 ; n < 3 || hh [ n ] != NULL ; n ++ ) { sprintf ( buf , "http[%2d]<S2SV_blank>" , n ) ; vtc_dump ( hp -> vl , 4 , buf , hh [ n ] , - 1 ) ; } }
CWE-125 static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { <S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%d" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , "<S2SV_blank>ipv4:" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , "<S2SV_blank>fqdn:" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , "<S2SV_blank>rfc822:" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , "<S2SV_blank>ipv6:" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , "<S2SV_blank>dn:" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , "<S2SV_blank>gn:" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , "<S2SV_blank>keyid:" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , "%c" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , "." ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( tpay ) ) ) ; return NULL ; }
CWE-399 int genl_register_family ( struct genl_family * family ) { int err , i ; int start = GENL_START_ALLOC , end = GENL_MAX_ID ; err = genl_validate_ops ( family ) ; if ( err ) return err ; genl_lock_all ( ) ; if ( genl_family_find_byname ( family -> name ) ) { err = - EEXIST ; goto errout_locked ; } if ( family == & genl_ctrl ) { start = end = GENL_ID_CTRL ; } else if ( strcmp ( family -> name , "pmcraid" ) == 0 ) { start = end = GENL_ID_PMCRAID ; } else if ( strcmp ( family -> name , "VFS_DQUOT" ) == 0 ) { start = end = GENL_ID_VFS_DQUOT ; } if ( family -> maxattr && ! family -> parallel_ops ) { family -> attrbuf = kmalloc_array ( family -> maxattr + 1 , sizeof ( struct nlattr * ) , GFP_KERNEL ) ; if ( family -> attrbuf == NULL ) { err = - ENOMEM ; goto errout_locked ; } } else family -> attrbuf = NULL ; family -> id = idr_alloc ( & genl_fam_idr , family , start , end + 1 , GFP_KERNEL ) ; if ( family -> id < 0 ) { err = family -> id ; <S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> } err = genl_validate_assign_mc_groups ( family ) ; if ( err ) goto errout_remove ; genl_unlock_all ( ) ; genl_ctrl_event ( CTRL_CMD_NEWFAMILY , family , NULL , 0 ) ; for ( i = 0 ; i < family -> n_mcgrps ; i ++ ) genl_ctrl_event ( CTRL_CMD_NEWMCAST_GRP , family , & family -> mcgrps [ i ] , family -> mcgrp_offset + i ) ; return 0 ; errout_remove : idr_remove ( & genl_fam_idr , family -> id ) ; <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> errout_locked : genl_unlock_all ( ) ; return err ; }
CWE-399 static int kvm_guest_time_update ( struct kvm_vcpu * v ) { unsigned long flags , this_tsc_khz ; struct kvm_vcpu_arch * vcpu = & v -> arch ; struct kvm_arch * ka = & v -> kvm -> arch ; <S2SV_StartBug> void * shared_kaddr ; <S2SV_EndBug> s64 kernel_ns , max_kernel_ns ; u64 tsc_timestamp , host_tsc ; <S2SV_StartBug> struct pvclock_vcpu_time_info * guest_hv_clock ; <S2SV_EndBug> u8 pvclock_flags ; bool use_master_clock ; kernel_ns = 0 ; host_tsc = 0 ; spin_lock ( & ka -> pvclock_gtod_sync_lock ) ; use_master_clock = ka -> use_master_clock ; if ( use_master_clock ) { host_tsc = ka -> master_cycle_now ; kernel_ns = ka -> master_kernel_ns ; } spin_unlock ( & ka -> pvclock_gtod_sync_lock ) ; local_irq_save ( flags ) ; this_tsc_khz = __get_cpu_var ( cpu_tsc_khz ) ; if ( unlikely ( this_tsc_khz == 0 ) ) { local_irq_restore ( flags ) ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , v ) ; return 1 ; } if ( ! use_master_clock ) { host_tsc = native_read_tsc ( ) ; kernel_ns = get_kernel_ns ( ) ; } tsc_timestamp = kvm_x86_ops -> read_l1_tsc ( v , host_tsc ) ; if ( vcpu -> tsc_catchup ) { u64 tsc = compute_guest_tsc ( v , kernel_ns ) ; if ( tsc > tsc_timestamp ) { adjust_tsc_offset_guest ( v , tsc - tsc_timestamp ) ; tsc_timestamp = tsc ; } } local_irq_restore ( flags ) ; <S2SV_StartBug> if ( ! vcpu -> time_page ) <S2SV_EndBug> return 0 ; max_kernel_ns = 0 ; if ( vcpu -> hv_clock . tsc_timestamp ) { max_kernel_ns = vcpu -> last_guest_tsc - vcpu -> hv_clock . tsc_timestamp ; max_kernel_ns = pvclock_scale_delta ( max_kernel_ns , vcpu -> hv_clock . tsc_to_system_mul , vcpu -> hv_clock . tsc_shift ) ; max_kernel_ns += vcpu -> last_kernel_ns ; } if ( unlikely ( vcpu -> hw_tsc_khz != this_tsc_khz ) ) { kvm_get_time_scale ( NSEC_PER_SEC / 1000 , this_tsc_khz , & vcpu -> hv_clock . tsc_shift , & vcpu -> hv_clock . tsc_to_system_mul ) ; vcpu -> hw_tsc_khz = this_tsc_khz ; } if ( ! use_master_clock ) { if ( max_kernel_ns > kernel_ns ) kernel_ns = max_kernel_ns ; } vcpu -> hv_clock . tsc_timestamp = tsc_timestamp ; vcpu -> hv_clock . system_time = kernel_ns + v -> kvm -> arch . kvmclock_offset ; vcpu -> last_kernel_ns = kernel_ns ; vcpu -> last_guest_tsc = tsc_timestamp ; vcpu -> hv_clock . version += 2 ; <S2SV_StartBug> shared_kaddr = kmap_atomic ( vcpu -> time_page ) ; <S2SV_EndBug> guest_hv_clock = shared_kaddr + vcpu -> time_offset ; <S2SV_StartBug> pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ; <S2SV_EndBug> if ( vcpu -> pvclock_set_guest_stopped_request ) { pvclock_flags |= PVCLOCK_GUEST_STOPPED ; vcpu -> pvclock_set_guest_stopped_request = false ; } if ( use_master_clock ) pvclock_flags |= PVCLOCK_TSC_STABLE_BIT ; vcpu -> hv_clock . flags = pvclock_flags ; <S2SV_StartBug> memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock , <S2SV_EndBug> sizeof ( vcpu -> hv_clock ) ) ; <S2SV_StartBug> kunmap_atomic ( shared_kaddr ) ; <S2SV_EndBug> mark_page_dirty ( v -> kvm , vcpu -> time >> PAGE_SHIFT ) ; return 0 ; }
CWE-000 static int powermate_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( intf ) ; struct usb_host_interface * interface ; struct usb_endpoint_descriptor * endpoint ; struct powermate_device * pm ; struct input_dev * input_dev ; int pipe , maxp ; int error = - ENOMEM ; <S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug> endpoint = & interface -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_int_in ( endpoint ) ) return - EIO ; usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0a , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , interface -> desc . bInterfaceNumber , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; pm = kzalloc ( sizeof ( struct powermate_device ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! pm || ! input_dev ) goto fail1 ; if ( powermate_alloc_buffers ( udev , pm ) ) goto fail2 ; pm -> irq = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> irq ) goto fail2 ; pm -> config = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> config ) goto fail3 ; pm -> udev = udev ; pm -> intf = intf ; pm -> input = input_dev ; usb_make_path ( udev , pm -> phys , sizeof ( pm -> phys ) ) ; strlcat ( pm -> phys , "/input0" , sizeof ( pm -> phys ) ) ; spin_lock_init ( & pm -> lock ) ; switch ( le16_to_cpu ( udev -> descriptor . idProduct ) ) { case POWERMATE_PRODUCT_NEW : input_dev -> name = pm_name_powermate ; break ; case POWERMATE_PRODUCT_OLD : input_dev -> name = pm_name_soundknob ; break ; default : input_dev -> name = pm_name_soundknob ; printk ( KERN_WARNING "powermate:<S2SV_blank>unknown<S2SV_blank>product<S2SV_blank>id<S2SV_blank>%04x\\n" , le16_to_cpu ( udev -> descriptor . idProduct ) ) ; } input_dev -> phys = pm -> phys ; usb_to_input_id ( udev , & input_dev -> id ) ; input_dev -> dev . parent = & intf -> dev ; input_set_drvdata ( input_dev , pm ) ; input_dev -> event = powermate_input_event ; input_dev -> evbit [ 0 ] = BIT_MASK ( EV_KEY ) | BIT_MASK ( EV_REL ) | BIT_MASK ( EV_MSC ) ; input_dev -> keybit [ BIT_WORD ( BTN_0 ) ] = BIT_MASK ( BTN_0 ) ; input_dev -> relbit [ BIT_WORD ( REL_DIAL ) ] = BIT_MASK ( REL_DIAL ) ; input_dev -> mscbit [ BIT_WORD ( MSC_PULSELED ) ] = BIT_MASK ( MSC_PULSELED ) ; pipe = usb_rcvintpipe ( udev , endpoint -> bEndpointAddress ) ; maxp = usb_maxpacket ( udev , pipe , usb_pipeout ( pipe ) ) ; if ( maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX ) { printk ( KERN_WARNING "powermate:<S2SV_blank>Expected<S2SV_blank>payload<S2SV_blank>of<S2SV_blank>%d--%d<S2SV_blank>bytes,<S2SV_blank>found<S2SV_blank>%d<S2SV_blank>bytes!\\n" , POWERMATE_PAYLOAD_SIZE_MIN , POWERMATE_PAYLOAD_SIZE_MAX , maxp ) ; maxp = POWERMATE_PAYLOAD_SIZE_MAX ; } usb_fill_int_urb ( pm -> irq , udev , pipe , pm -> data , maxp , powermate_irq , pm , endpoint -> bInterval ) ; pm -> irq -> transfer_dma = pm -> data_dma ; pm -> irq -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; if ( usb_submit_urb ( pm -> irq , GFP_KERNEL ) ) { error = - EIO ; goto fail4 ; } error = input_register_device ( pm -> input ) ; if ( error ) goto fail5 ; pm -> requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS ; powermate_pulse_led ( pm , 0x80 , 255 , 0 , 1 , 0 ) ; usb_set_intfdata ( intf , pm ) ; return 0 ; fail5 : usb_kill_urb ( pm -> irq ) ; fail4 : usb_free_urb ( pm -> config ) ; fail3 : usb_free_urb ( pm -> irq ) ; fail2 : powermate_free_buffers ( udev , pm ) ; fail1 : input_free_device ( input_dev ) ; kfree ( pm ) ; return error ; }
CWE-119 <S2SV_StartBug> static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) { <S2SV_EndBug> int i , j ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) for ( i = 0 ; i < SWITCHABLE_FILTERS - 1 ; ++ i ) vp9_diff_update_prob ( r , & fc -> switchable_interp_prob [ j ] [ i ] ) ; }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; <S2SV_StartBug> assert ( ( cc % stride ) == 0 ) ; <S2SV_EndBug> if ( cc > stride ) { cc -= stride ; if ( stride == 3 ) { unsigned int r1 , g1 , b1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ] ; do { r1 = cp [ 3 ] ; cp [ 3 ] = ( unsigned char ) ( ( r1 - r2 ) & 0xff ) ; r2 = r1 ; g1 = cp [ 4 ] ; cp [ 4 ] = ( unsigned char ) ( ( g1 - g2 ) & 0xff ) ; g2 = g1 ; b1 = cp [ 5 ] ; cp [ 5 ] = ( unsigned char ) ( ( b1 - b2 ) & 0xff ) ; b2 = b1 ; cp += 3 ; } while ( ( cc -= 3 ) > 0 ) ; } else if ( stride == 4 ) { unsigned int r1 , g1 , b1 , a1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ] ; unsigned int a2 = cp [ 3 ] ; do { r1 = cp [ 4 ] ; cp [ 4 ] = ( unsigned char ) ( ( r1 - r2 ) & 0xff ) ; r2 = r1 ; g1 = cp [ 5 ] ; cp [ 5 ] = ( unsigned char ) ( ( g1 - g2 ) & 0xff ) ; g2 = g1 ; b1 = cp [ 6 ] ; cp [ 6 ] = ( unsigned char ) ( ( b1 - b2 ) & 0xff ) ; b2 = b1 ; a1 = cp [ 7 ] ; cp [ 7 ] = ( unsigned char ) ( ( a1 - a2 ) & 0xff ) ; a2 = a1 ; cp += 4 ; } while ( ( cc -= 4 ) > 0 ) ; } else { cp += cc - 1 ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) } while ( ( cc -= stride ) > 0 ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-189 static struct vm_area_struct * vma_to_resize ( unsigned long addr , unsigned long old_len , unsigned long new_len , unsigned long * p ) { struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = find_vma ( mm , addr ) ; if ( ! vma || vma -> vm_start > addr ) goto Efault ; if ( is_vm_hugetlb_page ( vma ) ) goto Einval ; if ( old_len > vma -> vm_end - addr ) goto Efault ; <S2SV_StartBug> if ( vma -> vm_flags & ( VM_DONTEXPAND | VM_PFNMAP ) ) { <S2SV_EndBug> if ( new_len > old_len ) goto Efault ; } if ( vma -> vm_flags & VM_LOCKED ) { unsigned long locked , lock_limit ; locked = mm -> locked_vm << PAGE_SHIFT ; lock_limit = rlimit ( RLIMIT_MEMLOCK ) ; locked += new_len - old_len ; if ( locked > lock_limit && ! capable ( CAP_IPC_LOCK ) ) goto Eagain ; } if ( ! may_expand_vm ( mm , ( new_len - old_len ) >> PAGE_SHIFT ) ) goto Enomem ; if ( vma -> vm_flags & VM_ACCOUNT ) { unsigned long charged = ( new_len - old_len ) >> PAGE_SHIFT ; if ( security_vm_enough_memory ( charged ) ) goto Efault ; * p = charged ; } return vma ; Efault : return ERR_PTR ( - EFAULT ) ; Einval : return ERR_PTR ( - EINVAL ) ; Enomem : return ERR_PTR ( - ENOMEM ) ; Eagain : return ERR_PTR ( - EAGAIN ) ; }
CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; <S2SV_StartBug> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <S2SV_EndBug> if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if ( ! al ) { error = - ENOMEM ; goto out_unlock ; } error = gfs2_quota_lock_check ( ip ) ; if ( error ) goto out_alloc_put ; retry : gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; al -> al_requested = data_blocks + ind_blocks ; error = gfs2_inplace_reserve ( ip ) ; if ( error ) { if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) { bytes >>= 1 ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; goto retry ; } goto out_qunlock ; } max_bytes = bytes ; <S2SV_StartBug> calc_max_reserv ( ip , len , & max_bytes , & data_blocks , & ind_blocks ) ; <S2SV_EndBug> al -> al_requested = data_blocks + ind_blocks ; rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( ip ) ; if ( gfs2_is_jdata ( ip ) ) rblocks += data_blocks ? data_blocks : 1 ; error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) ; if ( error ) goto out_trans_fail ; error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; gfs2_trans_end ( sdp ) ; if ( error ) goto out_trans_fail ; len -= max_bytes ; offset += max_bytes ; gfs2_inplace_release ( ip ) ; gfs2_quota_unlock ( ip ) ; gfs2_alloc_put ( ip ) ; } goto out_unlock ; out_trans_fail : gfs2_inplace_release ( ip ) ; out_qunlock : gfs2_quota_unlock ( ip ) ; out_alloc_put : gfs2_alloc_put ( ip ) ; out_unlock : gfs2_glock_dq ( & ip -> i_gh ) ; out_uninit : gfs2_holder_uninit ( & ip -> i_gh ) ; return error ; }
CWE-189 static void nfs4_xdr_enc_getacl ( struct rpc_rqst * req , struct xdr_stream * xdr , struct nfs_getaclargs * args ) { struct compound_hdr hdr = { . minorversion = nfs4_xdr_minorversion ( & args -> seq_args ) , } ; uint32_t replen ; encode_compound_hdr ( xdr , req , & hdr ) ; encode_sequence ( xdr , & args -> seq_args , & hdr ) ; encode_putfh ( xdr , args -> fh , & hdr ) ; <S2SV_StartBug> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <S2SV_EndBug> encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ; xdr_inline_pages ( & req -> rq_rcv_buf , replen << 2 , args -> acl_pages , args -> acl_pgbase , args -> acl_len ) ; <S2SV_StartBug> encode_nops ( & hdr ) ; <S2SV_EndBug> }
CWE-119 static vpx_codec_err_t encoder_destroy ( vpx_codec_alg_priv_t * ctx ) { free ( ctx -> cx_data ) ; vp9_remove_compressor ( ctx -> cpi ) ; <S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> return VPX_CODEC_OK ; }
CWE-264 int ovl_setattr ( struct dentry * dentry , struct iattr * attr ) { int err ; struct dentry * upperdentry ; err = ovl_want_write ( dentry ) ; if ( err ) goto out ; <S2SV_StartBug> upperdentry = ovl_dentry_upper ( dentry ) ; <S2SV_EndBug> <S2SV_StartBug> if ( upperdentry ) { <S2SV_EndBug> mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ; err = notify_change ( upperdentry , attr , NULL ) ; mutex_unlock ( & upperdentry -> d_inode -> i_mutex ) ; <S2SV_StartBug> } else { <S2SV_EndBug> err = ovl_copy_up_last ( dentry , attr , false ) ; } ovl_drop_write ( dentry ) ; out : return err ; }
CWE-264 <S2SV_StartBug> int setpwnam ( struct passwd * pwd ) <S2SV_EndBug> { FILE * fp = NULL , * pwf = NULL ; int save_errno ; int found ; int namelen ; int buflen = 256 ; int contlen , rc ; char * linebuf = NULL ; char * tmpname = NULL ; <S2SV_StartBug> char * atomic_dir = "/etc" ; <S2SV_EndBug> pw_init ( ) ; <S2SV_StartBug> if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) <S2SV_EndBug> return - 1 ; if ( fchown ( fileno ( fp ) , ( uid_t ) 0 , ( gid_t ) 0 ) < 0 ) goto fail ; if ( lckpwdf ( ) < 0 ) goto fail ; pwf = fopen ( PASSWD_FILE , "r" ) ; if ( ! pwf ) goto fail ; namelen = strlen ( pwd -> pw_name ) ; linebuf = malloc ( buflen ) ; if ( ! linebuf ) goto fail ; found = false ; while ( fgets ( linebuf , buflen , pwf ) != NULL ) { contlen = strlen ( linebuf ) ; while ( linebuf [ contlen - 1 ] != '\\n' && ! feof ( pwf ) ) { char * tmp ; buflen *= 2 ; tmp = realloc ( linebuf , buflen ) ; if ( tmp == NULL ) goto fail ; linebuf = tmp ; if ( fgets ( & linebuf [ contlen ] , buflen / 2 , pwf ) == NULL ) break ; contlen = strlen ( linebuf ) ; } if ( ! found && linebuf [ namelen ] == ':' && ! strncmp ( linebuf , pwd -> pw_name , namelen ) ) { if ( putpwent ( pwd , fp ) < 0 ) goto fail ; found = true ; continue ; } fputs ( linebuf , fp ) ; } if ( fchmod ( fileno ( fp ) , 0644 ) < 0 ) goto fail ; rc = close_stream ( fp ) ; fp = NULL ; if ( rc != 0 ) goto fail ; fclose ( pwf ) ; pwf = NULL ; if ( ! found ) { errno = ENOENT ; goto fail ; } unlink ( PASSWD_FILE ".OLD" ) ; ignore_result ( link ( PASSWD_FILE , PASSWD_FILE ".OLD" ) ) ; if ( rename ( tmpname , PASSWD_FILE ) < 0 ) goto fail ; ulckpwdf ( ) ; return 0 ; fail : save_errno = errno ; ulckpwdf ( ) ; if ( fp != NULL ) fclose ( fp ) ; if ( tmpname != NULL ) unlink ( tmpname ) ; free ( tmpname ) ; if ( pwf != NULL ) fclose ( pwf ) ; free ( linebuf ) ; errno = save_errno ; return - 1 ; }
CWE-119 void vp8_end_second_pass ( VP8_COMP * cpi ) { <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } <S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }
CWE-119 int read_yuv_frame ( struct VpxInputContext * input_ctx , vpx_image_t * yuv_frame ) { FILE * f = input_ctx -> file ; struct FileTypeDetectionBuffer * detect = & input_ctx -> detect ; int plane = 0 ; int shortread = 0 ; <S2SV_StartBug> for ( plane = 0 ; plane < 3 ; ++ plane ) { <S2SV_EndBug> uint8_t * ptr ; <S2SV_StartBug> const int w = ( plane ? ( 1 + yuv_frame -> d_w ) / 2 : yuv_frame -> d_w ) ; <S2SV_EndBug> <S2SV_StartBug> const int h = ( plane ? ( 1 + yuv_frame -> d_h ) / 2 : yuv_frame -> d_h ) ; <S2SV_EndBug> int r ; switch ( plane ) { case 1 : ptr = yuv_frame -> planes [ yuv_frame -> fmt == VPX_IMG_FMT_YV12 ? VPX_PLANE_V : VPX_PLANE_U ] ; break ; case 2 : ptr = yuv_frame -> planes [ yuv_frame -> fmt == VPX_IMG_FMT_YV12 ? VPX_PLANE_U : VPX_PLANE_V ] ; break ; default : ptr = yuv_frame -> planes [ plane ] ; } for ( r = 0 ; r < h ; ++ r ) { <S2SV_StartBug> size_t needed = w ; <S2SV_EndBug> size_t buf_position = 0 ; const size_t left = detect -> buf_read - detect -> position ; if ( left > 0 ) { const size_t more = ( left < needed ) ? left : needed ; memcpy ( ptr , detect -> buf + detect -> position , more ) ; buf_position = more ; needed -= more ; detect -> position += more ; } if ( needed > 0 ) { shortread |= ( fread ( ptr + buf_position , 1 , needed , f ) < needed ) ; } ptr += yuv_frame -> stride [ plane ] ; } } return shortread ; }
CWE-119 <S2SV_StartBug> static INLINE void write_buffer_16x16 ( int16_t * output , __m128i * in0 , <S2SV_EndBug> __m128i * in1 , int stride ) { write_buffer_8x8 ( output , in0 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in0 + 8 , stride ) ; output += 8 ; write_buffer_8x8 ( output , in1 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in1 + 8 , stride ) ; }
CWE-000 static inline int mount_entry_on_generic ( struct mntent * mntent , <S2SV_StartBug> const char * path ) <S2SV_EndBug> { unsigned long mntflags ; char * mntdata ; int ret ; bool optional = hasmntopt ( mntent , "optional" ) != NULL ; ret = mount_entry_create_dir_file ( mntent , path ) ; if ( ret < 0 ) return optional ? 0 : - 1 ; cull_mntent_opt ( mntent ) ; if ( parse_mntopts ( mntent -> mnt_opts , & mntflags , & mntdata ) < 0 ) { free ( mntdata ) ; return - 1 ; } ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , <S2SV_StartBug> mntflags , mntdata , optional ) ; <S2SV_EndBug> free ( mntdata ) ; return ret ; }
CWE-000 int X509_verify ( X509 * a , EVP_PKEY * r ) <S2SV_StartBug> { <S2SV_EndBug> return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }
CWE-000 static char * lxclock_name ( const char * p , const char * n ) { int ret ; int len ; char * dest ; char * rundir ; <S2SV_StartBug> len = strlen ( "/lock/lxc/" ) + strlen ( n ) + strlen ( p ) + 3 ; <S2SV_EndBug> rundir = get_rundir ( ) ; if ( ! rundir ) return NULL ; len += strlen ( rundir ) ; if ( ( dest = malloc ( len ) ) == NULL ) { free ( rundir ) ; return NULL ; } <S2SV_StartBug> ret = snprintf ( dest , len , "%s/lock/lxc/%s" , rundir , p ) ; <S2SV_EndBug> if ( ret < 0 || ret >= len ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = mkdir_p ( dest , 0755 ) ; if ( ret < 0 ) { <S2SV_StartBug> int l2 = 22 + strlen ( n ) + strlen ( p ) ; <S2SV_EndBug> if ( l2 > len ) { char * d ; d = realloc ( dest , l2 ) ; if ( ! d ) { free ( dest ) ; free ( rundir ) ; return NULL ; } len = l2 ; dest = d ; } ret = snprintf ( dest , len , "/tmp/%d/lxc%s" , geteuid ( ) , p ) ; if ( ret < 0 || ret >= len ) { free ( dest ) ; <S2SV_StartBug> free ( rundir ) ; <S2SV_EndBug> return NULL ; } ret = mkdir_p ( dest , 0755 ) ; if ( ret < 0 ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , "/tmp/%d/lxc%s/.%s" , geteuid ( ) , p , n ) ; } else ret = snprintf ( dest , len , "%s/lock/lxc/%s/.%s" , rundir , p , n ) ; free ( rundir ) ; if ( ret < 0 || ret >= len ) { free ( dest ) ; return NULL ; } return dest ; }
CWE-189 <S2SV_StartBug> void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <S2SV_EndBug> <S2SV_StartBug> int length , int offset , int total_size ) <S2SV_EndBug> { struct oz_port * port = hport ; struct urb * urb ; int err = 0 ; oz_dbg ( ON , "oz_hcd_get_desc_cnf<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>offs<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>tot_size<S2SV_blank>=<S2SV_blank>%d\\n" , length , offset , total_size ) ; urb = oz_find_urb_by_id ( port , 0 , req_id ) ; if ( ! urb ) return ; if ( status == 0 ) { <S2SV_StartBug> int copy_len ; <S2SV_EndBug> <S2SV_StartBug> int required_size = urb -> transfer_buffer_length ; <S2SV_EndBug> if ( required_size > total_size ) required_size = total_size ; copy_len = required_size - offset ; if ( length <= copy_len ) copy_len = length ; memcpy ( urb -> transfer_buffer + offset , desc , copy_len ) ; offset += copy_len ; if ( offset < required_size ) { struct usb_ctrlrequest * setup = ( struct usb_ctrlrequest * ) urb -> setup_packet ; unsigned wvalue = le16_to_cpu ( setup -> wValue ) ; if ( oz_enqueue_ep_urb ( port , 0 , 0 , urb , req_id ) ) err = - ENOMEM ; else if ( oz_usb_get_desc_req ( port -> hpd , req_id , setup -> bRequestType , ( u8 ) ( wvalue >> 8 ) , ( u8 ) wvalue , setup -> wIndex , offset , required_size - offset ) ) { oz_dequeue_ep_urb ( port , 0 , 0 , urb ) ; err = - ENOMEM ; } if ( err == 0 ) return ; } } urb -> actual_length = total_size ; oz_complete_urb ( port -> ozhcd -> hcd , urb , 0 ) ; }
CWE-119 struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , unsigned int height , unsigned int subsampling_x , unsigned int subsampling_y , <S2SV_StartBug> unsigned int depth ) { <S2SV_EndBug> struct lookahead_ctx * ctx = NULL ; depth = clamp ( depth , 1 , MAX_LAG_BUFFERS ) ; depth += MAX_PRE_FRAMES ; ctx = calloc ( 1 , sizeof ( * ctx ) ) ; if ( ctx ) { <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> ctx -> max_sz = depth ; ctx -> buf = calloc ( depth , sizeof ( * ctx -> buf ) ) ; if ( ! ctx -> buf ) goto bail ; for ( i = 0 ; i < depth ; i ++ ) <S2SV_StartBug> if ( vp9_alloc_frame_buffer ( & ctx -> buf [ i ] . img , <S2SV_EndBug> width , height , subsampling_x , subsampling_y , <S2SV_StartBug> VP9_ENC_BORDER_IN_PIXELS ) ) <S2SV_EndBug> goto bail ; } return ctx ; bail : vp9_lookahead_destroy ( ctx ) ; return NULL ; }
CWE-264 static unsigned long randomize_stack_top ( unsigned long stack_top ) { <S2SV_StartBug> unsigned int random_variable = 0 ; <S2SV_EndBug> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <S2SV_StartBug> random_variable = get_random_int ( ) & STACK_RND_MASK ; <S2SV_EndBug> random_variable <<= PAGE_SHIFT ; } # ifdef CONFIG_STACK_GROWSUP return PAGE_ALIGN ( stack_top ) + random_variable ; # else return PAGE_ALIGN ( stack_top ) - random_variable ; # endif }
CWE-476 file_transfer_t * imcb_file_send_start ( struct im_connection * ic , char * handle , char * file_name , size_t file_size ) { bee_t * bee = ic -> bee ; bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ; <S2SV_StartBug> if ( bee -> ui -> ft_in_start ) { <S2SV_EndBug> return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ; } else { return NULL ; } }
CWE-000 static void ext4_xattr_release_block ( handle_t * handle , struct inode * inode , struct buffer_head * bh ) { <S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> <S2SV_StartBug> int error = 0 ; <S2SV_EndBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; ce = mb_cache_entry_get ( ext4_mb_cache , bh -> b_bdev , bh -> b_blocknr ) ; BUFFER_TRACE ( bh , "get_write_access" ) ; error = ext4_journal_get_write_access ( handle , bh ) ; if ( error ) goto out ; lock_buffer ( bh ) ; if ( BHDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> ea_bdebug ( bh , "refcount<S2SV_blank>now=0;<S2SV_blank>freeing" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; get_bh ( bh ) ; unlock_buffer ( bh ) ; ext4_free_blocks ( handle , inode , bh , 0 , 1 , EXT4_FREE_BLOCKS_METADATA | EXT4_FREE_BLOCKS_FORGET ) ; } else { le32_add_cpu ( & BHDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_release ( ce ) ; if ( ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; unlock_buffer ( bh ) ; if ( ! ext4_handle_valid ( handle ) ) error = ext4_handle_dirty_xattr_block ( handle , inode , bh ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( inode -> i_sb ) , 1 ) ) ; ea_bdebug ( bh , "refcount<S2SV_blank>now=%d;<S2SV_blank>releasing" , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; } out : ext4_std_error ( inode -> i_sb , error ) ; return ; }
CWE-119 LIBXSMM_API_INTERN void libxsmm_sparse_csc_reader ( libxsmm_generated_code * io_generated_code , const char * i_csc_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csc_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_column_idx_id = NULL ; unsigned int l_i = 0 ; l_csc_file_handle = fopen ( i_csc_file_in , "r" ) ; if ( l_csc_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csc_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( ( size_t ) ( * o_column_count ) + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_column_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_column_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_column_idx_id == NULL ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_ALLOC_DATA ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( ( size_t ) ( * o_column_count ) + 1 ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_column_idx_id , 0 , sizeof ( unsigned int ) * ( * o_column_count ) ) ; for ( l_i = 0 ; l_i <= * o_column_count ; ++ l_i ) { ( * o_column_idx ) [ l_i ] = * o_element_count ; } ( * o_column_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_DESC ) ; fclose ( l_csc_file_handle ) ; return ; } } else { unsigned int l_row = 0 , l_column = 0 ; double l_value = 0 ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_ELEMS ) ; return ; } <S2SV_StartBug> l_row -- ; <S2SV_EndBug> l_column -- ; ( * o_row_idx ) [ l_i ] = l_row ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_column_idx_id [ l_column ] = 1 ; ( * o_column_idx ) [ l_column + 1 ] = l_i ; } } } fclose ( l_csc_file_handle ) ; if ( l_i != ( * o_element_count ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_LEN ) ; return ; } if ( l_column_idx_id != NULL ) { for ( l_i = 0 ; l_i < ( * o_column_count ) ; l_i ++ ) { if ( l_column_idx_id [ l_i ] == 0 ) { ( * o_column_idx ) [ l_i + 1 ] = ( * o_column_idx ) [ l_i ] ; } } free ( l_column_idx_id ) ; } }
CWE-000 static int klsi_105_get_line_state ( struct usb_serial_port * port , unsigned long * line_state_p ) { int rc ; u8 * status_buf ; __u16 status ; dev_info ( & port -> serial -> dev -> dev , "sending<S2SV_blank>SIO<S2SV_blank>Poll<S2SV_blank>request\\n" ) ; status_buf = kmalloc ( KLSI_STATUSBUF_LEN , GFP_KERNEL ) ; if ( ! status_buf ) return - ENOMEM ; status_buf [ 0 ] = 0xff ; status_buf [ 1 ] = 0xff ; rc = usb_control_msg ( port -> serial -> dev , usb_rcvctrlpipe ( port -> serial -> dev , 0 ) , KL5KUSB105A_SIO_POLL , USB_TYPE_VENDOR | USB_DIR_IN , 0 , 0 , status_buf , KLSI_STATUSBUF_LEN , 10000 ) ; <S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , "Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n" , <S2SV_EndBug> rc ) ; else { status = get_unaligned_le16 ( status_buf ) ; dev_info ( & port -> serial -> dev -> dev , "read<S2SV_blank>status<S2SV_blank>%x<S2SV_blank>%x\\n" , status_buf [ 0 ] , status_buf [ 1 ] ) ; * line_state_p = klsi_105_status2linestate ( status ) ; } kfree ( status_buf ) ; return rc ; }
CWE-20 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; <S2SV_StartBug> list_del ( & key -> graveyard_link ) ; <S2SV_EndBug> kdebug ( "-<S2SV_blank>%u" , key -> serial ) ; key_check ( key ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <S2SV_EndBug> ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; memzero_explicit ( key , sizeof ( * key ) ) ; kmem_cache_free ( key_jar , key ) ; } }
CWE-190 static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) { <S2SV_StartBug> int n ; <S2SV_EndBug> assert ( cnt >= 0 ) ; assert ( buf ) ; JAS_DBGLOG ( 100 , ( "mem_read(%p,<S2SV_blank>%p,<S2SV_blank>%d)\\n" , obj , buf , cnt ) ) ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; n = m -> len_ - m -> pos_ ; cnt = JAS_MIN ( n , cnt ) ; memcpy ( buf , & m -> buf_ [ m -> pos_ ] , cnt ) ; m -> pos_ += cnt ; return cnt ; }
CWE-119 static void parse_content_range ( URLContext * h , const char * p ) { HTTPContext * s = h -> priv_data ; const char * slash ; if ( ! strncmp ( p , "bytes<S2SV_blank>" , 6 ) ) { p += 6 ; <S2SV_StartBug> s -> off = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> if ( ( slash = strchr ( p , '/' ) ) && strlen ( slash ) > 0 ) <S2SV_StartBug> s -> filesize = strtoll ( slash + 1 , NULL , 10 ) ; <S2SV_EndBug> } if ( s -> seekable == - 1 && ( ! s -> is_akamai || s -> filesize != 2147483647 ) ) h -> is_streamed = 0 ; }
CWE-119 <S2SV_StartBug> static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) { <S2SV_EndBug> char buf [ 512 ] ; int retval = 0 ; va_list ap ; <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( level > svc_ctx -> log_level ) { return retval ; } va_start ( ap , fmt ) ; retval = vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ; va_end ( ap ) ; if ( svc_ctx -> log_print ) { printf ( "%s" , buf ) ; } else { strncat ( si -> message_buffer , buf , sizeof ( si -> message_buffer ) - strlen ( si -> message_buffer ) - 1 ) ; } if ( level == SVC_LOG_ERROR ) { si -> codec_ctx -> err_detail = si -> message_buffer ; } return retval ; }
CWE-264 int kvm_set_msr ( struct kvm_vcpu * vcpu , struct msr_data * msr ) { <S2SV_StartBug> return kvm_x86_ops -> set_msr ( vcpu , msr ) ; <S2SV_EndBug> }
CWE-000 int ECDSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int sig_len , EC_KEY * eckey ) { ECDSA_SIG * s ; <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> s = ECDSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; <S2SV_StartBug> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <S2SV_EndBug> ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ; err : <S2SV_StartBug> ECDSA_SIG_free ( s ) ; <S2SV_EndBug> return ( ret ) ; }
CWE-362 static int sockfs_setattr ( struct dentry * dentry , struct iattr * iattr ) { int err = simple_setattr ( dentry , iattr ) ; if ( ! err && ( iattr -> ia_valid & ATTR_UID ) ) { struct socket * sock = SOCKET_I ( d_inode ( dentry ) ) ; <S2SV_StartBug> sock -> sk -> sk_uid = iattr -> ia_uid ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return err ; }
CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }
CWE-200 int xstateregs_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct fpu * fpu = & target -> thread . fpu ; struct xregs_state * xsave ; int ret ; if ( ! boot_cpu_has ( X86_FEATURE_XSAVE ) ) return - ENODEV ; if ( ( pos != 0 ) || ( count < fpu_user_xstate_size ) ) return - EFAULT ; xsave = & fpu -> state . xsave ; fpu__activate_fpstate_write ( fpu ) ; if ( boot_cpu_has ( X86_FEATURE_XSAVES ) ) { if ( kbuf ) ret = copy_kernel_to_xstate ( xsave , kbuf ) ; else ret = copy_user_to_xstate ( xsave , ubuf ) ; } else { ret = user_regset_copyin ( & pos , & count , & kbuf , & ubuf , xsave , 0 , - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ret ) fpstate_init ( & fpu -> state ) ; xsave -> i387 . mxcsr &= mxcsr_feature_mask ; xsave -> header . xfeatures &= xfeatures_mask ; memset ( & xsave -> header . reserved , 0 , 48 ) ; return ret ; }
CWE-264 static inline int check_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , const nodemask_t * nodes , unsigned long flags , void * private ) { pmd_t * pmd ; unsigned long next ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> continue ; if ( check_pte_range ( vma , pmd , addr , next , nodes , flags , private ) ) return - EIO ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }
CWE-000 int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , ";%08x" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , "" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { <S2SV_StartBug> rc = fsmVerify ( fpath , fi ) ; <S2SV_EndBug> } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; rc = expandRegular ( fi , fn , psm , 0 , nodigest , 0 ) ; firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }
CWE-000 int simple_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; if ( type == ACL_TYPE_ACCESS ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> return 0 ; if ( error == 0 ) acl = NULL ; } inode -> i_ctime = current_time ( inode ) ; set_cached_acl ( inode , type , acl ) ; return 0 ; }
CWE-476 <S2SV_StartBug> static int dev_get_valid_name ( struct net * net , <S2SV_EndBug> struct net_device * dev , const char * name ) { BUG_ON ( ! net ) ; if ( ! dev_valid_name ( name ) ) return - EINVAL ; if ( strchr ( name , '%' ) ) return dev_alloc_name_ns ( net , dev , name ) ; else if ( __dev_get_by_name ( net , name ) ) return - EEXIST ; else if ( dev -> name != name ) strlcpy ( dev -> name , name , IFNAMSIZ ) ; return 0 ; }
CWE-284 static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) { size_t Data_Buf_Size = 1024 ; char Buf [ 1024 ] ; int Timeout = - 1 ; FILE * Fp ; parse_status_t status = PARSE_OK ; int ok_on_close = FALSE ; size_t entity_offset = 0 ; int num_read = 0 ; int ret_code = HTTP_OK ; if ( Instr && Instr -> IsVirtualFile ) { Fp = ( virtualDirCallback . open ) ( filename , UPNP_WRITE ) ; if ( Fp == NULL ) return HTTP_INTERNAL_SERVER_ERROR ; } else { <S2SV_StartBug> Fp = fopen ( filename , "wb" ) ; <S2SV_EndBug> if ( Fp == NULL ) <S2SV_StartBug> return HTTP_UNAUTHORIZED ; <S2SV_EndBug> } parser -> position = POS_ENTITY ; do { if ( parser -> position != POS_COMPLETE ) status = parser_parse_entity ( parser ) ; if ( status == PARSE_INCOMPLETE_ENTITY ) { ok_on_close = TRUE ; } else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) { ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) { num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ; if ( num_read > 0 ) { if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) { parser -> http_error_code = HTTP_INTERNAL_SERVER_ERROR ; ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } status = parser_parse_entity ( parser ) ; if ( status == PARSE_INCOMPLETE_ENTITY ) { ok_on_close = TRUE ; } else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) { ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } } else if ( num_read == 0 ) { if ( ok_on_close ) { UpnpPrintf ( UPNP_INFO , HTTP , __FILE__ , __LINE__ , "<<<<S2SV_blank>(RECVD)<S2SV_blank><<<\\n%s\\n-----------------\\n" , parser -> msg . msg . buf ) ; print_http_headers ( & parser -> msg ) ; parser -> position = POS_COMPLETE ; } else { parser -> http_error_code = HTTP_BAD_REQUEST ; ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } } else { ret_code = HTTP_SERVICE_UNAVAILABLE ; goto ExitFunction ; } } if ( ( entity_offset + Data_Buf_Size ) > parser -> msg . entity . length ) { Data_Buf_Size = parser -> msg . entity . length - entity_offset ; } memcpy ( Buf , & parser -> msg . msg . buf [ parser -> entity_start_position + entity_offset ] , Data_Buf_Size ) ; entity_offset += Data_Buf_Size ; if ( Instr && Instr -> IsVirtualFile ) { int n = virtualDirCallback . write ( Fp , Buf , Data_Buf_Size ) ; if ( n < 0 ) { ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } } else { size_t n = fwrite ( Buf , 1 , Data_Buf_Size , Fp ) ; if ( n != Data_Buf_Size ) { ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } } } while ( parser -> position != POS_COMPLETE || entity_offset != parser -> msg . entity . length ) ; ExitFunction : if ( Instr && Instr -> IsVirtualFile ) { virtualDirCallback . close ( Fp ) ; } else { fclose ( Fp ) ; } return ret_code ; }
CWE-000 static int inet_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; struct inet_protosw * answer ; struct inet_sock * inet ; struct proto * answer_prot ; unsigned char answer_flags ; int try_loading_module = 0 ; <S2SV_StartBug> int err ; <S2SV_EndBug> sock -> state = SS_UNCONNECTED ; lookup_protocol : err = - ESOCKTNOSUPPORT ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( answer , & inetsw [ sock -> type ] , list ) { err = 0 ; if ( protocol == answer -> protocol ) { if ( protocol != IPPROTO_IP ) break ; } else { if ( IPPROTO_IP == protocol ) { protocol = answer -> protocol ; break ; } if ( IPPROTO_IP == answer -> protocol ) break ; } err = - EPROTONOSUPPORT ; } if ( unlikely ( err ) ) { if ( try_loading_module < 2 ) { rcu_read_unlock ( ) ; if ( ++ try_loading_module == 1 ) request_module ( "net-pf-%d-proto-%d-type-%d" , PF_INET , protocol , sock -> type ) ; else request_module ( "net-pf-%d-proto-%d" , PF_INET , protocol ) ; goto lookup_protocol ; } else goto out_rcu_unlock ; } err = - EPERM ; if ( sock -> type == SOCK_RAW && ! kern && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) goto out_rcu_unlock ; sock -> ops = answer -> ops ; answer_prot = answer -> prot ; answer_flags = answer -> flags ; rcu_read_unlock ( ) ; WARN_ON ( ! answer_prot -> slab ) ; err = - ENOBUFS ; sk = sk_alloc ( net , PF_INET , GFP_KERNEL , answer_prot , kern ) ; if ( ! sk ) goto out ; err = 0 ; if ( INET_PROTOSW_REUSE & answer_flags ) sk -> sk_reuse = SK_CAN_REUSE ; inet = inet_sk ( sk ) ; inet -> is_icsk = ( INET_PROTOSW_ICSK & answer_flags ) != 0 ; inet -> nodefrag = 0 ; if ( SOCK_RAW == sock -> type ) { inet -> inet_num = protocol ; if ( IPPROTO_RAW == protocol ) inet -> hdrincl = 1 ; } if ( net -> ipv4 . sysctl_ip_no_pmtu_disc ) inet -> pmtudisc = IP_PMTUDISC_DONT ; else inet -> pmtudisc = IP_PMTUDISC_WANT ; inet -> inet_id = 0 ; sock_init_data ( sock , sk ) ; sk -> sk_destruct = inet_sock_destruct ; sk -> sk_protocol = protocol ; sk -> sk_backlog_rcv = sk -> sk_prot -> backlog_rcv ; inet -> uc_ttl = - 1 ; inet -> mc_loop = 1 ; inet -> mc_ttl = 1 ; inet -> mc_all = 1 ; inet -> mc_index = 0 ; inet -> mc_list = NULL ; inet -> rcv_tos = 0 ; sk_refcnt_debug_inc ( sk ) ; if ( inet -> inet_num ) { inet -> inet_sport = htons ( inet -> inet_num ) ; sk -> sk_prot -> hash ( sk ) ; } if ( sk -> sk_prot -> init ) { err = sk -> sk_prot -> init ( sk ) ; if ( err ) sk_common_release ( sk ) ; } out : return err ; out_rcu_unlock : rcu_read_unlock ( ) ; goto out ; }
CWE-416 static int xfrm_dump_policy ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net * net = sock_net ( skb -> sk ) ; <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> struct xfrm_dump_info info ; <S2SV_EndBug> BUILD_BUG_ON ( sizeof ( struct xfrm_policy_walk ) > sizeof ( cb -> args ) - sizeof ( cb -> args [ 0 ] ) ) ; info . in_skb = cb -> skb ; info . out_skb = skb ; info . nlmsg_seq = cb -> nlh -> nlmsg_seq ; info . nlmsg_flags = NLM_F_MULTI ; <S2SV_StartBug> if ( ! cb -> args [ 0 ] ) { <S2SV_EndBug> cb -> args [ 0 ] = 1 ; xfrm_policy_walk_init ( walk , XFRM_POLICY_TYPE_ANY ) ; } ( void ) xfrm_policy_walk ( net , walk , dump_one_policy , & info ) ; return skb -> len ; }
CWE-000 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; if ( g -> sect <= 0 || <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = "user<S2SV_blank>format" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
CWE-119 int main ( int argc , char * * argv ) { char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; const char * spacestr = "<S2SV_blank>" ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_uint8 * allheaders ; l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; size_t nbytes ; L_BYTEA * ba , * ba2 ; SARRAY * sa , * safirst ; static char mainName [ ] = "xtractprotos" ; if ( argc == 1 ) { fprintf ( stderr , "xtractprotos<S2SV_blank>[-prestring=<string>]<S2SV_blank>[-protos=<where>]<S2SV_blank>" "[list<S2SV_blank>of<S2SV_blank>C<S2SV_blank>files]\\n" "where<S2SV_blank>the<S2SV_blank>prestring<S2SV_blank>is<S2SV_blank>prepended<S2SV_blank>to<S2SV_blank>each<S2SV_blank>prototype,<S2SV_blank>and<S2SV_blank>\\n" "protos<S2SV_blank>can<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'inline\'<S2SV_blank>or<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>an<S2SV_blank>output<S2SV_blank>" "prototype<S2SV_blank>file\\n" ) ; return 1 ; } prestring = outprotos = NULL ; in_line = FALSE ; nflags = 0 ; maxindex = L_MIN ( 3 , argc ) ; for ( i = 1 ; i < maxindex ; i ++ ) { if ( argv [ i ] [ 0 ] == '-' ) { if ( ! strncmp ( argv [ i ] , "-prestring" , 10 ) ) { nflags ++ ; <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , "prestring=%s" , buf ) ; <S2SV_EndBug> if ( ret != 1 ) { fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>prestring\\n" ) ; return 1 ; } <S2SV_StartBug> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) { <S2SV_EndBug> L_WARNING ( "prestring<S2SV_blank>too<S2SV_blank>large;<S2SV_blank>omitting!\\n" , mainName ) ; } else { buf [ len ] = '<S2SV_blank>' ; buf [ len + 1 ] = '\\0' ; prestring = stringNew ( buf ) ; } } else if ( ! strncmp ( argv [ i ] , "-protos" , 7 ) ) { nflags ++ ; <S2SV_StartBug> ret = sscanf ( argv [ i ] + 1 , "protos=%s" , buf ) ; <S2SV_EndBug> if ( ret != 1 ) { fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>protos\\n" ) ; return 1 ; } outprotos = stringNew ( buf ) ; if ( ! strncmp ( outprotos , "inline" , 7 ) ) in_line = TRUE ; } } } if ( argc - nflags < 2 ) { fprintf ( stderr , "no<S2SV_blank>files<S2SV_blank>specified!\\n" ) ; return 1 ; } ba = l_byteaCreate ( 500 ) ; sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) "/*" , L_COPY ) ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , <S2SV_EndBug> "<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s" , version ) ; sarrayAddString ( sa , buf , L_COPY ) ; sarrayAddString ( sa , ( char * ) "<S2SV_blank>*/" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "#ifdef<S2SV_blank>__cplusplus" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "extern<S2SV_blank>\\"C\\"<S2SV_blank>{" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/\\n" , L_COPY ) ; str = sarrayToString ( sa , 1 ) ; l_byteaAppendString ( ba , str ) ; lept_free ( str ) ; sarrayDestroy ( & sa ) ; firstfile = 1 + nflags ; protos_added = FALSE ; if ( ( tempfile = l_makeTempFilename ( ) ) == NULL ) { fprintf ( stderr , "failure<S2SV_blank>to<S2SV_blank>make<S2SV_blank>a<S2SV_blank>writeable<S2SV_blank>temp<S2SV_blank>file\\n" ) ; return 1 ; } for ( i = firstfile ; i < argc ; i ++ ) { filein = argv [ i ] ; len = strlen ( filein ) ; if ( filein [ len - 1 ] == 'h' ) continue ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s" , <S2SV_EndBug> filein , tempfile ) ; ret = system ( buf ) ; if ( ret ) { fprintf ( stderr , "cpp<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n" , filein ) ; continue ; } if ( ( str = parseForProtos ( tempfile , prestring ) ) == NULL ) { fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n" , filein ) ; continue ; } if ( strlen ( str ) > 1 ) { l_byteaAppendString ( ba , str ) ; protos_added = TRUE ; } lept_free ( str ) ; } lept_rmfile ( tempfile ) ; lept_free ( tempfile ) ; sa = sarrayCreate ( 0 ) ; sarrayAddString ( sa , ( char * ) "\\n#ifdef<S2SV_blank>__cplusplus" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "}" , L_COPY ) ; sarrayAddString ( sa , ( char * ) "#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/" , L_COPY ) ; str = sarrayToString ( sa , 1 ) ; l_byteaAppendString ( ba , str ) ; lept_free ( str ) ; sarrayDestroy ( & sa ) ; protostr = ( char * ) l_byteaCopyData ( ba , & nbytes ) ; l_byteaDestroy ( & ba ) ; if ( ! outprotos ) { fprintf ( stderr , "%s\\n" , protostr ) ; lept_free ( protostr ) ; return 0 ; } if ( ! protos_added ) { fprintf ( stderr , "No<S2SV_blank>protos<S2SV_blank>found\\n" ) ; lept_free ( protostr ) ; return 1 ; } ba = l_byteaInitFromFile ( "allheaders_top.txt" ) ; if ( ! in_line ) { snprintf ( buf , sizeof ( buf ) , "#include<S2SV_blank>\\"%s\\"\\n" , outprotos ) ; l_byteaAppendString ( ba , buf ) ; l_binaryWrite ( outprotos , "w" , protostr , nbytes ) ; } else { l_byteaAppendString ( ba , protostr ) ; } ba2 = l_byteaInitFromFile ( "allheaders_bot.txt" ) ; l_byteaJoin ( ba , & ba2 ) ; l_byteaWrite ( "allheaders.h" , ba , 0 , 0 ) ; l_byteaDestroy ( & ba ) ; lept_free ( protostr ) ; return 0 ; }
CWE-119 static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , "\\x3F\\x00" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , "APDU<S2SV_blank>transmit<S2SV_blank>failed" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\n" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\n" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }
CWE-190 static void Process_ipfix_template_withdraw ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { ipfix_template_record_t * ipfix_template_record ; while ( size_left ) { <S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; id = ntohs ( ipfix_template_record -> TemplateID ) ; if ( id == IPFIX_TEMPLATE_FLOWSET_ID ) { remove_all_translation_tables ( exporter ) ; ReInitExtensionMapList ( fs ) ; } else { remove_translation_table ( fs , exporter , id ) ; } DataPtr = DataPtr + 4 ; if ( size_left < 4 ) { dbg_printf ( "Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n" , size_left ) ; size_left = 0 ; } } }
CWE-399 int kvm_arch_vcpu_init ( struct kvm_vcpu * vcpu ) { struct page * page ; struct kvm * kvm ; int r ; BUG_ON ( vcpu -> kvm == NULL ) ; kvm = vcpu -> kvm ; vcpu -> arch . emulate_ctxt . ops = & emulate_ops ; if ( ! irqchip_in_kernel ( kvm ) || kvm_vcpu_is_bsp ( vcpu ) ) vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; else vcpu -> arch . mp_state = KVM_MP_STATE_UNINITIALIZED ; page = alloc_page ( GFP_KERNEL | __GFP_ZERO ) ; if ( ! page ) { r = - ENOMEM ; goto fail ; } vcpu -> arch . pio_data = page_address ( page ) ; kvm_set_tsc_khz ( vcpu , max_tsc_khz ) ; r = kvm_mmu_create ( vcpu ) ; if ( r < 0 ) goto fail_free_pio_data ; if ( irqchip_in_kernel ( kvm ) ) { r = kvm_create_lapic ( vcpu ) ; if ( r < 0 ) goto fail_mmu_destroy ; } else static_key_slow_inc ( & kvm_no_apic_vcpu ) ; vcpu -> arch . mce_banks = kzalloc ( KVM_MAX_MCE_BANKS * sizeof ( u64 ) * 4 , GFP_KERNEL ) ; if ( ! vcpu -> arch . mce_banks ) { r = - ENOMEM ; goto fail_free_lapic ; } vcpu -> arch . mcg_cap = KVM_MAX_MCE_BANKS ; if ( ! zalloc_cpumask_var ( & vcpu -> arch . wbinvd_dirty_mask , GFP_KERNEL ) ) goto fail_free_mce_banks ; r = fx_init ( vcpu ) ; if ( r ) goto fail_free_wbinvd_dirty_mask ; vcpu -> arch . ia32_tsc_adjust_msr = 0x0 ; <S2SV_StartBug> kvm_async_pf_hash_reset ( vcpu ) ; <S2SV_EndBug> kvm_pmu_init ( vcpu ) ; return 0 ; fail_free_wbinvd_dirty_mask : free_cpumask_var ( vcpu -> arch . wbinvd_dirty_mask ) ; fail_free_mce_banks : kfree ( vcpu -> arch . mce_banks ) ; fail_free_lapic : kvm_free_lapic ( vcpu ) ; fail_mmu_destroy : kvm_mmu_destroy ( vcpu ) ; fail_free_pio_data : free_page ( ( unsigned long ) vcpu -> arch . pio_data ) ; fail : return r ; }
CWE-476 void build_ntlmssp_negotiate_blob ( unsigned char * pbuffer , struct cifs_ses * ses ) { NEGOTIATE_MESSAGE * sec_blob = ( NEGOTIATE_MESSAGE * ) pbuffer ; __u32 flags ; memset ( pbuffer , 0 , sizeof ( NEGOTIATE_MESSAGE ) ) ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmNegotiate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <S2SV_StartBug> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <S2SV_EndBug> <S2SV_StartBug> if ( ses -> server -> sign ) { <S2SV_EndBug> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_StartBug> } <S2SV_EndBug> sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> WorkstationName . BufferOffset = 0 ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; sec_blob -> DomainName . BufferOffset = 0 ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; }
CWE-200 static int recv_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; int sz_to_copy , target , needed ; int sz_copied = 0 ; u32 err ; int res = 0 ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( ( sock -> state == SS_UNCONNECTED ) || ( sock -> state == SS_CONNECTING ) ) ) { res = - ENOTCONN ; goto exit ; <S2SV_StartBug> } <S2SV_EndBug> target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ; timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } if ( sz_copied == 0 ) { set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; } if ( ! err ) { u32 offset = ( u32 ) ( unsigned long ) ( TIPC_SKB_CB ( buf ) -> handle ) ; sz -= offset ; needed = ( buf_len - sz_copied ) ; sz_to_copy = ( sz <= needed ) ? sz : needed ; res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) + offset , m -> msg_iov , sz_to_copy ) ; if ( res ) goto exit ; sz_copied += sz_to_copy ; if ( sz_to_copy < sz ) { if ( ! ( flags & MSG_PEEK ) ) TIPC_SKB_CB ( buf ) -> handle = ( void * ) ( unsigned long ) ( offset + sz_to_copy ) ; goto exit ; } } else { if ( sz_copied != 0 ) goto exit ; if ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( unlikely ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } if ( ( sz_copied < buf_len ) && ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || ( sz_copied < target ) ) && ( ! ( flags & MSG_PEEK ) ) && ( ! err ) ) goto restart ; exit : release_sock ( sk ) ; return sz_copied ? sz_copied : res ; }
CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + ( tim . length - 3 ) , <S2SV_EndBug> <S2SV_StartBug> ( tim . length - 3 ) ) ; <S2SV_EndBug> offset += tim . length - 3 ; <S2SV_StartBug> length -= tim . length - 3 ; <S2SV_EndBug> if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , "(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
CWE-200 static int atl2_probe ( struct pci_dev * pdev , const struct pci_device_id * ent ) { struct net_device * netdev ; struct atl2_adapter * adapter ; static int cards_found ; unsigned long mmio_start ; int mmio_len ; int err ; cards_found = 0 ; err = pci_enable_device ( pdev ) ; if ( err ) return err ; if ( pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) && pci_set_consistent_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) ) { printk ( KERN_ERR "atl2:<S2SV_blank>No<S2SV_blank>usable<S2SV_blank>DMA<S2SV_blank>configuration,<S2SV_blank>aborting\\n" ) ; goto err_dma ; } err = pci_request_regions ( pdev , atl2_driver_name ) ; if ( err ) goto err_pci_reg ; pci_set_master ( pdev ) ; err = - ENOMEM ; netdev = alloc_etherdev ( sizeof ( struct atl2_adapter ) ) ; if ( ! netdev ) goto err_alloc_etherdev ; SET_NETDEV_DEV ( netdev , & pdev -> dev ) ; pci_set_drvdata ( pdev , netdev ) ; adapter = netdev_priv ( netdev ) ; adapter -> netdev = netdev ; adapter -> pdev = pdev ; adapter -> hw . back = adapter ; mmio_start = pci_resource_start ( pdev , 0x0 ) ; mmio_len = pci_resource_len ( pdev , 0x0 ) ; adapter -> hw . mem_rang = ( u32 ) mmio_len ; adapter -> hw . hw_addr = ioremap ( mmio_start , mmio_len ) ; if ( ! adapter -> hw . hw_addr ) { err = - EIO ; goto err_ioremap ; } atl2_setup_pcicmd ( pdev ) ; netdev -> netdev_ops = & atl2_netdev_ops ; netdev -> ethtool_ops = & atl2_ethtool_ops ; netdev -> watchdog_timeo = 5 * HZ ; strncpy ( netdev -> name , pci_name ( pdev ) , sizeof ( netdev -> name ) - 1 ) ; netdev -> mem_start = mmio_start ; netdev -> mem_end = mmio_start + mmio_len ; adapter -> bd_number = cards_found ; adapter -> pci_using_64 = false ; err = atl2_sw_init ( adapter ) ; if ( err ) goto err_sw_init ; err = - EIO ; <S2SV_StartBug> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <S2SV_EndBug> netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ; atl2_phy_init ( & adapter -> hw ) ; if ( atl2_reset_hw ( & adapter -> hw ) ) { err = - EIO ; goto err_reset ; } atl2_read_mac_addr ( & adapter -> hw ) ; memcpy ( netdev -> dev_addr , adapter -> hw . mac_addr , netdev -> addr_len ) ; if ( ! is_valid_ether_addr ( netdev -> dev_addr ) ) { err = - EIO ; goto err_eeprom ; } atl2_check_options ( adapter ) ; setup_timer ( & adapter -> watchdog_timer , atl2_watchdog , ( unsigned long ) adapter ) ; setup_timer ( & adapter -> phy_config_timer , atl2_phy_config , ( unsigned long ) adapter ) ; INIT_WORK ( & adapter -> reset_task , atl2_reset_task ) ; INIT_WORK ( & adapter -> link_chg_task , atl2_link_chg_task ) ; strcpy ( netdev -> name , "eth%d" ) ; err = register_netdev ( netdev ) ; if ( err ) goto err_register ; netif_carrier_off ( netdev ) ; netif_stop_queue ( netdev ) ; cards_found ++ ; return 0 ; err_reset : err_register : err_sw_init : err_eeprom : iounmap ( adapter -> hw . hw_addr ) ; err_ioremap : free_netdev ( netdev ) ; err_alloc_etherdev : pci_release_regions ( pdev ) ; err_pci_reg : err_dma : pci_disable_device ( pdev ) ; return err ; }
CWE-399 int sfgets ( void ) { struct pollfd pfd ; int pollret ; ssize_t readnb ; signed char seen_r = 0 ; <S2SV_StartBug> static size_t scanned ; <S2SV_EndBug> static size_t readnbd ; if ( scanned > ( size_t ) 0U ) { readnbd -= scanned ; memmove ( cmd , cmd + scanned , readnbd ) ; scanned = ( size_t ) 0U ; } pfd . fd = clientfd ; # ifdef __APPLE_CC__ pfd . events = POLLIN | POLLERR | POLLHUP ; # else pfd . events = POLLIN | POLLPRI | POLLERR | POLLHUP ; # endif while ( scanned < cmdsize ) { if ( scanned >= readnbd ) { pfd . revents = 0 ; while ( ( pollret = poll ( & pfd , 1U , idletime * 1000UL ) ) < 0 && errno == EINTR ) ; if ( pollret == 0 ) { return - 1 ; } if ( pollret <= 0 || ( pfd . revents & ( POLLERR | POLLHUP | POLLNVAL ) ) != 0 ) { return - 2 ; } if ( ( pfd . revents & ( POLLIN | POLLPRI ) ) == 0 ) { continue ; } if ( readnbd >= cmdsize ) { break ; } # ifdef WITH_TLS if ( tls_cnx != NULL ) { while ( ( readnb = SSL_read ( tls_cnx , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } else # endif { while ( ( readnb = read ( clientfd , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } if ( readnb <= ( ssize_t ) 0 ) { return - 2 ; } readnbd += readnb ; if ( readnbd > cmdsize ) { return - 2 ; } } # ifdef RFC_CONFORMANT_LINES if ( seen_r != 0 ) { # endif if ( cmd [ scanned ] == '\\n' ) { # ifndef RFC_CONFORMANT_LINES if ( seen_r != 0 ) { # endif cmd [ scanned - 1U ] = 0 ; # ifndef RFC_CONFORMANT_LINES } else { cmd [ scanned ] = 0 ; } # endif if ( ++ scanned >= readnbd ) { scanned = readnbd = ( size_t ) 0U ; } return 0 ; } seen_r = 0 ; # ifdef RFC_CONFORMANT_LINES } # endif if ( ISCTRLCODE ( cmd [ scanned ] ) ) { if ( cmd [ scanned ] == '\\r' ) { seen_r = 1 ; } # ifdef RFC_CONFORMANT_PARSER else if ( cmd [ scanned ] == 0 ) { cmd [ scanned ] = '\\n' ; } # else cmd [ scanned ] = '_' ; # endif } scanned ++ ; } die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; return 0 ; }
CWE-119 void receive_tcppacket ( connection_t * c , const char * buffer , int len ) { <S2SV_StartBug> vpn_packet_t outpkt ; <S2SV_EndBug> outpkt . len = len ; if ( c -> options & OPTION_TCPONLY ) outpkt . priority = 0 ; else outpkt . priority = - 1 ; memcpy ( outpkt . data , buffer , len ) ; receive_packet ( c -> node , & outpkt ) ; }
CWE-000 static void prefetch_enc ( void ) { <S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> }
CWE-119 static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , "Pixel<S2SV_blank>format<S2SV_blank>0x%0x" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; <S2SV_StartBug> } else if ( encoding == 1 && ( c -> bpp == 6 || c -> bpp == 8 ) ) { <S2SV_EndBug> if ( c -> palette_size != ( 1 << ( c -> bpp - 1 ) ) ) return AVERROR_INVALIDDATA ; avctx -> pix_fmt = AV_PIX_FMT_BGR24 ; } else if ( ! encoding && c -> bpp == 24 && c -> format == CHUNKY && ! c -> palette_size ) { avctx -> pix_fmt = AV_PIX_FMT_RGB24 ; } else { avpriv_request_sample ( avctx , "Encoding<S2SV_blank>%d,<S2SV_blank>bpp<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>format<S2SV_blank>0x%x" , encoding , c -> bpp , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( encoding ) { av_fast_padded_malloc ( & c -> new_video , & c -> new_video_size , h * w + AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! c -> new_video ) return AVERROR ( ENOMEM ) ; if ( c -> bpp == 8 ) cdxl_decode_ham8 ( c , p ) ; else cdxl_decode_ham6 ( c , p ) ; } else if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { cdxl_decode_rgb ( c , p ) ; } else { cdxl_decode_raw ( c , p ) ; } * got_frame = 1 ; return buf_size ; }
CWE-20 int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { <S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; <S2SV_StartBug> data ++ ; <S2SV_EndBug> for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : <S2SV_StartBug> snprintf ( dst , dst_size , "%g" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , "%s" , * data ? "true" : "false" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
CWE-362 static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) { struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; struct request * first_rq = list_first_entry ( pending , struct request , flush . list ) ; struct request * flush_rq = fq -> flush_rq ; if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) return false ; if ( ! list_empty ( & fq -> flush_data_in_flight ) && time_before ( jiffies , fq -> flush_pending_since + FLUSH_PENDING_TIMEOUT ) ) return false ; fq -> flush_pending_idx ^= 1 ; blk_rq_init ( q , flush_rq ) ; if ( q -> mq_ops ) { <S2SV_StartBug> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <S2SV_EndBug> <S2SV_StartBug> flush_rq -> tag = first_rq -> tag ; <S2SV_EndBug> } flush_rq -> cmd_type = REQ_TYPE_FS ; flush_rq -> cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ ; flush_rq -> rq_disk = first_rq -> rq_disk ; flush_rq -> end_io = flush_end_io ; return blk_flush_queue_rq ( flush_rq , false ) ; }
CWE-119 static int translate_hex_string ( char * s , char * saved_orphan ) { int c1 = * saved_orphan ; char * start = s ; char * t = s ; for ( ; * s ; s ++ ) { <S2SV_StartBug> if ( isspace ( * s ) ) <S2SV_EndBug> continue ; if ( c1 ) { * t ++ = ( hexval ( c1 ) << 4 ) + hexval ( * s ) ; c1 = 0 ; } else c1 = * s ; } * saved_orphan = c1 ; return t - start ; }
CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
CWE-119 void * vpx_memalign ( size_t align , size_t size ) { void * addr , * x = NULL ; <S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> int number_aau ; if ( vpx_mm_create_heap_memory ( ) < 0 ) { _P ( printf ( "[vpx][mm]<S2SV_blank>ERROR<S2SV_blank>vpx_memalign()<S2SV_blank>Couldn\'t<S2SV_blank>create<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Heap.\\n" ) ; ) } number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ; addr = hmm_alloc ( & hmm_d , number_aau ) ; # else addr = VPX_MALLOC_L ( size + align - 1 + ADDRESS_STORAGE_SIZE ) ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( addr ) { x = align_addr ( ( unsigned char * ) addr + ADDRESS_STORAGE_SIZE , ( int ) align ) ; ( ( size_t * ) x ) [ - 1 ] = ( size_t ) addr ; } return x ; }
CWE-264 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( ETH_P_IPV6 ) ; <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }
CWE-119 SEL * selReadStream ( FILE * fp ) { char * selname ; <S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( "selReadStream" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( "stream<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( fscanf ( fp , "<S2SV_blank><S2SV_blank>Sel<S2SV_blank>Version<S2SV_blank>%d\\n" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>sel<S2SV_blank>file" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( "invalid<S2SV_blank>sel<S2SV_blank>version" , procName , NULL ) ; <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> return ( SEL * ) ERROR_PTR ( "error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <S2SV_StartBug> sscanf ( linebuf , "<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------" , selname ) ; <S2SV_EndBug> if ( fscanf ( fp , "<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\n" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( "dimensions<S2SV_blank>not<S2SV_blank>read" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( "sel<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; } selSetOrigin ( sel , cy , cx ) ; for ( i = 0 ; i < sy ; i ++ ) { ignore = fscanf ( fp , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ; for ( j = 0 ; j < sx ; j ++ ) ignore = fscanf ( fp , "%1d" , & sel -> data [ i ] [ j ] ) ; ignore = fscanf ( fp , "\\n" ) ; } ignore = fscanf ( fp , "\\n" ) ; LEPT_FREE ( selname ) ; return sel ; }
CWE-000 static void bgp_update_print ( netdissect_options * ndo , const u_char * dat , int length ) { struct bgp bgp ; const u_char * p ; int withdrawn_routes_len ; int len ; int i ; ND_TCHECK2 ( dat [ 0 ] , BGP_SIZE ) ; if ( length < BGP_SIZE ) goto trunc ; memcpy ( & bgp , dat , BGP_SIZE ) ; p = dat + BGP_SIZE ; length -= BGP_SIZE ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; withdrawn_routes_len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len ) { ND_TCHECK2 ( p [ 0 ] , withdrawn_routes_len ) ; if ( length < withdrawn_routes_len ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Withdrawn<S2SV_blank>routes:<S2SV_blank>%d<S2SV_blank>bytes" , withdrawn_routes_len ) ) ; p += withdrawn_routes_len ; length -= withdrawn_routes_len ; } ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len == 0 && len == 0 && length == 0 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; return ; } if ( len ) { while ( len ) { int aflags , atype , alenlen , alen ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; if ( length < 2 ) goto trunc ; aflags = * p ; atype = * ( p + 1 ) ; p += 2 ; len -= 2 ; length -= 2 ; alenlen = bgp_attr_lenlen ( aflags , p ) ; ND_TCHECK2 ( p [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; if ( length < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , p ) ; p += alenlen ; len -= alenlen ; length -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } if ( len < alen ) goto trunc ; if ( length < alen ) goto trunc ; <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <S2SV_EndBug> goto trunc ; p += alen ; len -= alen ; length -= alen ; } } if ( length ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Updated<S2SV_blank>routes:" ) ) ; while ( length ) { char buf [ MAXHOSTNAMELEN + 100 ] ; i = decode_prefix4 ( ndo , p , length , buf , sizeof ( buf ) ) ; if ( i == - 1 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; break ; } else if ( i == - 2 ) goto trunc ; else if ( i == - 3 ) goto trunc ; else { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; p += i ; length -= i ; } } } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-189 int sequencer_write ( int dev , struct file * file , const char __user * buf , int count ) { unsigned char event_rec [ EV_SZ ] , ev_code ; int p = 0 , c , ev_size ; int mode = translate_mode ( file ) ; dev = dev >> 4 ; DEB ( printk ( "sequencer_write(dev=%d,<S2SV_blank>count=%d)\\n" , dev , count ) ) ; if ( mode == OPEN_READ ) return - EIO ; c = count ; while ( c >= 4 ) { if ( copy_from_user ( ( char * ) event_rec , & ( buf ) [ p ] , 4 ) ) goto out ; ev_code = event_rec [ 0 ] ; if ( ev_code == SEQ_FULLSIZE ) { int err , fmt ; dev = * ( unsigned short * ) & event_rec [ 2 ] ; if ( dev < 0 || dev >= max_synthdev || synth_devs [ dev ] == NULL ) return - ENXIO ; if ( ! ( synth_open_mask & ( 1 << dev ) ) ) return - ENXIO ; fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ; <S2SV_StartBug> err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; <S2SV_EndBug> if ( err < 0 ) return err ; return err ; } if ( ev_code >= 128 ) { if ( seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED ) { printk ( KERN_WARNING "Sequencer:<S2SV_blank>Invalid<S2SV_blank>level<S2SV_blank>2<S2SV_blank>event<S2SV_blank>%x\\n" , ev_code ) ; return - EINVAL ; } ev_size = 8 ; if ( c < ev_size ) { if ( ! seq_playing ) seq_startplay ( ) ; return count - c ; } if ( copy_from_user ( ( char * ) & event_rec [ 4 ] , & ( buf ) [ p + 4 ] , 4 ) ) goto out ; } else { if ( seq_mode == SEQ_2 ) { printk ( KERN_WARNING "Sequencer:<S2SV_blank>4<S2SV_blank>byte<S2SV_blank>event<S2SV_blank>in<S2SV_blank>level<S2SV_blank>2<S2SV_blank>mode\\n" ) ; return - EINVAL ; } ev_size = 4 ; if ( event_rec [ 0 ] != SEQ_MIDIPUTC ) obsolete_api_used = 1 ; } if ( event_rec [ 0 ] == SEQ_MIDIPUTC ) { if ( ! midi_opened [ event_rec [ 2 ] ] ) { int err , mode ; int dev = event_rec [ 2 ] ; if ( dev >= max_mididev || midi_devs [ dev ] == NULL ) { return - ENXIO ; } mode = translate_mode ( file ) ; if ( ( err = midi_devs [ dev ] -> open ( dev , mode , sequencer_midi_input , sequencer_midi_output ) ) < 0 ) { seq_reset ( ) ; printk ( KERN_WARNING "Sequencer<S2SV_blank>Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Midi<S2SV_blank>#%d\\n" , dev ) ; return err ; } midi_opened [ dev ] = 1 ; } } if ( ! seq_queue ( event_rec , ( file -> f_flags & ( O_NONBLOCK ) ? 1 : 0 ) ) ) { int processed = count - c ; if ( ! seq_playing ) seq_startplay ( ) ; if ( ! processed && ( file -> f_flags & O_NONBLOCK ) ) return - EAGAIN ; else return processed ; } p += ev_size ; c -= ev_size ; } if ( ! seq_playing ) seq_startplay ( ) ; out : return count ; }
CWE-416 static void lo_release ( struct gendisk * disk , fmode_t mode ) { <S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> }
CWE-000 int nfssvc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readdirargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; args -> cookie = ntohl ( * p ++ ) ; args -> count = ntohl ( * p ++ ) ; args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
CWE-119 static vpx_codec_err_t ctrl_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> const int update = va_arg ( args , int ) ; vp9_update_entropy ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
CWE-362 static int sock_close ( struct inode * inode , struct file * filp ) { <S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> return 0 ; }
CWE-119 int vp8_refining_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; for ( i = 0 ; i < search_range ; i ++ ) { int best_site = - 1 ; for ( j = 0 ; j < 4 ; j ++ ) { this_row_offset = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_col_offset = ref_mv -> as_mv . col + neighbors [ j ] . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = j ; } } } } if ( best_site == - 1 ) break ; else { ref_mv -> as_mv . row += neighbors [ best_site ] . row ; ref_mv -> as_mv . col += neighbors [ best_site ] . col ; best_address += ( neighbors [ best_site ] . row ) * in_what_stride + neighbors [ best_site ] . col ; } } this_mv . as_mv . row = ref_mv -> as_mv . row << 3 ; this_mv . as_mv . col = ref_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
CWE-119 WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; WORD32 j ; UWORD8 u1_buf_mode ; struct MMCParams * ps_mmc_params ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst ; ps_slice -> u1_mmco_equalto5 = 0 ; { if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_slice -> u1_no_output_of_prior_pics_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>no_output_of_prior_pics_flag" , ps_slice -> u1_no_output_of_prior_pics_flag ) ; ps_slice -> u1_long_term_reference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>long_term_reference_flag" , ps_slice -> u1_long_term_reference_flag ) ; ps_dpb_cmds -> u1_idr_pic = 1 ; ps_dpb_cmds -> u1_no_output_of_prior_pics_flag = ps_slice -> u1_no_output_of_prior_pics_flag ; ps_dpb_cmds -> u1_long_term_reference_flag = ps_slice -> u1_long_term_reference_flag ; } else { u1_buf_mode = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>adaptive_ref_pic_buffering_flag" , u1_buf_mode ) ; ps_dpb_cmds -> u1_buf_mode = u1_buf_mode ; j = 0 ; if ( u1_buf_mode == 1 ) { UWORD32 u4_mmco ; UWORD32 u4_diff_pic_num ; UWORD32 u4_lt_idx , u4_max_lt_idx ; u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; while ( u4_mmco != END_OF_MMCO ) <S2SV_StartBug> { <S2SV_EndBug> ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ; ps_mmc_params -> u4_mmco = u4_mmco ; switch ( u4_mmco ) { case MARK_ST_PICNUM_AS_NONREF : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; break ; case MARK_LT_INDEX_AS_NONREF : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case MARK_ST_PICNUM_AS_LT_INDEX : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case SET_MAX_LT_INDEX : { u4_max_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_max_lt_idx_plus1 = u4_max_lt_idx ; break ; } case RESET_REF_PICTURES : { ps_slice -> u1_mmco_equalto5 = 1 ; break ; } case SET_LT_INDEX : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; default : break ; } u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; j ++ ; } ps_dpb_cmds -> u1_num_of_commands = j ; } } ps_dpb_cmds -> u1_dpb_commands_read = 1 ; ps_dpb_cmds -> u1_dpb_commands_read_slc = 1 ; } u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst - u4_bit_ofst ; return u4_bit_ofst ; }
CWE-119 static const interp_kernel * choose_interp_filter ( int inlength , int outlength ) { int outlength16 = outlength * 16 ; if ( outlength16 >= inlength * 16 ) <S2SV_StartBug> return vp9_filteredinterp_filters1000 ; <S2SV_EndBug> else if ( outlength16 >= inlength * 13 ) <S2SV_StartBug> return vp9_filteredinterp_filters875 ; <S2SV_EndBug> else if ( outlength16 >= inlength * 11 ) <S2SV_StartBug> return vp9_filteredinterp_filters750 ; <S2SV_EndBug> else if ( outlength16 >= inlength * 9 ) <S2SV_StartBug> return vp9_filteredinterp_filters625 ; <S2SV_EndBug> else <S2SV_StartBug> return vp9_filteredinterp_filters500 ; <S2SV_EndBug> }
CWE-119 char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) { int length ; length = strlen ( filename ) ; <S2SV_StartBug> if ( length > 0 ) <S2SV_EndBug> { if ( ( filename [ 0 ] == \'\\"\' ) && ( filename [ length - 1 ] == \'\\"\' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ; } return strdup ( filename ) ; }
CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , "BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , "BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , "BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , "BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , "R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\n" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; <S2SV_StartBug> regs [ insn -> dst_reg ] . var_off = tnum_cast ( <S2SV_EndBug> regs [ insn -> dst_reg ] . var_off , 4 ) ; <S2SV_StartBug> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; <S2SV_EndBug> } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } } } else if ( opcode > BPF_END ) { verbose ( env , "invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\n" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , "BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , "BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , "div<S2SV_blank>by<S2SV_blank>zero\\n" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , "invalid<S2SV_blank>shift<S2SV_blank>%d\\n" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }
CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && <S2SV_StartBug> * p == SSL3_MT_CLIENT_HELLO ) && <S2SV_EndBug> ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } return ( 1 ) ; }
CWE-000 static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( "BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( "BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( "invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( "unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( "fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n" , insn -> imm ) ; <S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } env -> used_maps [ env -> used_map_cnt ++ ] = map ; bpf_map_inc ( map , false ) ; fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }
CWE-000 static int prepend_path ( const struct path * path , const struct path * root , char * * buffer , int * buflen ) { struct dentry * dentry ; struct vfsmount * vfsmnt ; struct mount * mnt ; int error = 0 ; unsigned seq , m_seq = 0 ; char * bptr ; int blen ; rcu_read_lock ( ) ; restart_mnt : read_seqbegin_or_lock ( & mount_lock , & m_seq ) ; seq = 0 ; rcu_read_lock ( ) ; restart : bptr = * buffer ; blen = * buflen ; error = 0 ; dentry = path -> dentry ; vfsmnt = path -> mnt ; mnt = real_mount ( vfsmnt ) ; read_seqbegin_or_lock ( & rename_lock , & seq ) ; while ( dentry != root -> dentry || vfsmnt != root -> mnt ) { struct dentry * parent ; if ( dentry == vfsmnt -> mnt_root || IS_ROOT ( dentry ) ) { <S2SV_StartBug> struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ; <S2SV_EndBug> if ( mnt != parent ) { dentry = ACCESS_ONCE ( mnt -> mnt_mountpoint ) ; mnt = parent ; vfsmnt = & mnt -> mnt ; continue ; } if ( ! error ) error = is_mounted ( vfsmnt ) ? 1 : 2 ; break ; } parent = dentry -> d_parent ; prefetch ( parent ) ; error = prepend_name ( & bptr , & blen , & dentry -> d_name ) ; if ( error ) break ; dentry = parent ; } if ( ! ( seq & 1 ) ) rcu_read_unlock ( ) ; if ( need_seqretry ( & rename_lock , seq ) ) { seq = 1 ; goto restart ; } done_seqretry ( & rename_lock , seq ) ; if ( ! ( m_seq & 1 ) ) rcu_read_unlock ( ) ; if ( need_seqretry ( & mount_lock , m_seq ) ) { m_seq = 1 ; goto restart_mnt ; } done_seqretry ( & mount_lock , m_seq ) ; if ( error >= 0 && bptr == * buffer ) { if ( -- blen < 0 ) error = - ENAMETOOLONG ; else * -- bptr = '/' ; } * buffer = bptr ; * buflen = blen ; return error ; }
CWE-787 <S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 left ; UINT32 runlength = 1 ; UINT32 planeSize = 0 ; left = originalSize ; while ( left > 4 && planeSize < originalSize - 4 ) { if ( left > 5 && * in == * ( in + 1 ) ) { runlength ++ ; } else if ( runlength == 1 ) { * out ++ = * in ; planeSize ++ ; } else if ( runlength < 256 ) { * out ++ = * in ; * out ++ = * in ; * out ++ = runlength - 2 ; runlength = 1 ; planeSize += 3 ; } else { * out ++ = * in ; * out ++ = * in ; * out ++ = 0xFF ; * out ++ = ( runlength & 0x000000FF ) ; * out ++ = ( runlength & 0x0000FF00 ) >> 8 ; * out ++ = ( runlength & 0x00FF0000 ) >> 16 ; * out ++ = ( runlength & 0xFF000000 ) >> 24 ; runlength = 1 ; planeSize += 7 ; } in ++ ; left -- ; } if ( planeSize < originalSize - 4 ) CopyMemory ( out , in , 4 ) ; planeSize += 4 ; return planeSize ; }
CWE-284 static void btu_exec_tap_fd_read ( void * p_param ) { struct pollfd ufd ; int fd = ( int ) p_param ; if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) return ; for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; if ( ! buffer ) { BTIF_TRACE_WARNING ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>packet." , __func__ ) ; break ; } buffer -> offset = PAN_MINIMUM_OFFSET ; buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; if ( ! btpan_cb . congest_packet_size ) { <S2SV_StartBug> ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ; <S2SV_EndBug> switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>driver:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; case 0 : BTIF_TRACE_WARNING ( "%s<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>reached." , __func__ ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; default : btpan_cb . congest_packet_size = ret ; break ; } } memcpy ( packet , btpan_cb . congest_packet , MIN ( btpan_cb . congest_packet_size , buffer -> len ) ) ; buffer -> len = MIN ( btpan_cb . congest_packet_size , buffer -> len ) ; if ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) { tETH_HDR hdr ; memcpy ( & hdr , packet , sizeof ( tETH_HDR ) ) ; buffer -> len -= sizeof ( tETH_HDR ) ; buffer -> offset += sizeof ( tETH_HDR ) ; if ( forward_bnep ( & hdr , buffer ) != FORWARD_CONGEST ) btpan_cb . congest_packet_size = 0 ; } else { BTIF_TRACE_WARNING ( "%s<S2SV_blank>dropping<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d" , __func__ , buffer -> len ) ; btpan_cb . congest_packet_size = 0 ; GKI_freebuf ( buffer ) ; } ufd . fd = fd ; ufd . events = POLLIN ; ufd . revents = 0 ; <S2SV_StartBug> if ( poll ( & ufd , 1 , 0 ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) <S2SV_EndBug> break ; } btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; }
CWE-119 <S2SV_StartBug> void vp9_write_nmv_probs ( VP9_COMMON * cm , int usehp , vp9_writer * w ) { <S2SV_EndBug> int i , j ; <S2SV_StartBug> nmv_context * const mvc = & cm -> fc . nmvc ; <S2SV_EndBug> nmv_context_counts * const counts = & cm -> counts . mv ; write_mv_update ( vp9_mv_joint_tree , mvc -> joints , counts -> joints , MV_JOINTS , w ) ; for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * comp = & mvc -> comps [ i ] ; nmv_component_counts * comp_counts = & counts -> comps [ i ] ; update_mv ( w , comp_counts -> sign , & comp -> sign , MV_UPDATE_PROB ) ; write_mv_update ( vp9_mv_class_tree , comp -> classes , comp_counts -> classes , MV_CLASSES , w ) ; write_mv_update ( vp9_mv_class0_tree , comp -> class0 , comp_counts -> class0 , CLASS0_SIZE , w ) ; for ( j = 0 ; j < MV_OFFSET_BITS ; ++ j ) update_mv ( w , comp_counts -> bits [ j ] , & comp -> bits [ j ] , MV_UPDATE_PROB ) ; } for ( i = 0 ; i < 2 ; ++ i ) { for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) write_mv_update ( vp9_mv_fp_tree , mvc -> comps [ i ] . class0_fp [ j ] , counts -> comps [ i ] . class0_fp [ j ] , MV_FP_SIZE , w ) ; write_mv_update ( vp9_mv_fp_tree , mvc -> comps [ i ] . fp , counts -> comps [ i ] . fp , MV_FP_SIZE , w ) ; } if ( usehp ) { for ( i = 0 ; i < 2 ; ++ i ) { update_mv ( w , counts -> comps [ i ] . class0_hp , & mvc -> comps [ i ] . class0_hp , MV_UPDATE_PROB ) ; update_mv ( w , counts -> comps [ i ] . hp , & mvc -> comps [ i ] . hp , MV_UPDATE_PROB ) ; } } }
CWE-119 void vp8cx_pick_filter_level ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filter_step ; int filt_high = 0 ; <S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> int filt_low = 0 ; int filt_best ; int filt_direction = 0 ; int Bias = 0 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug> cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; filt_mid = cm -> filter_level ; if ( filt_mid < min_filter_level ) filt_mid = min_filter_level ; else if ( filt_mid > max_filter_level ) filt_mid = max_filter_level ; filter_step = ( filt_mid < 16 ) ? 4 : filt_mid / 4 ; vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_mid ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_mid ) ; best_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_mid ] = best_err ; filt_best = filt_mid ; while ( filter_step > 0 ) { Bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) Bias = Bias * cpi -> twopass . section_intra_rating / 20 ; filt_high = ( ( filt_mid + filter_step ) > max_filter_level ) ? max_filter_level : ( filt_mid + filter_step ) ; filt_low = ( ( filt_mid - filter_step ) < min_filter_level ) ? min_filter_level : ( filt_mid - filter_step ) ; if ( ( filt_direction <= 0 ) && ( filt_low != filt_mid ) ) { if ( ss_err [ filt_low ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_low ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_low ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_low ] = filt_err ; } else filt_err = ss_err [ filt_low ] ; if ( ( filt_err - Bias ) < best_err ) { if ( filt_err < best_err ) best_err = filt_err ; filt_best = filt_low ; } } if ( ( filt_direction >= 0 ) && ( filt_high != filt_mid ) ) { if ( ss_err [ filt_high ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_high ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_high ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_high ] = filt_err ; } else filt_err = ss_err [ filt_high ] ; if ( filt_err < ( best_err - Bias ) ) { best_err = filt_err ; filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step = filter_step / 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } cm -> filter_level = filt_best ; cm -> frame_to_show = saved_frame ; }
CWE-200 char * url_decode_r ( char * to , char * url , size_t size ) { char * s = url , * d = to , * e = & to [ size - 1 ] ; while ( * s && d < e ) { if ( unlikely ( * s == '%' ) ) { if ( likely ( s [ 1 ] && s [ 2 ] ) ) { <S2SV_StartBug> * d ++ = from_hex ( s [ 1 ] ) << 4 | from_hex ( s [ 2 ] ) ; <S2SV_EndBug> s += 2 ; } } else if ( unlikely ( * s == '+' ) ) * d ++ = '<S2SV_blank>' ; else * d ++ = * s ; s ++ ; } * d = '\\0' ; return to ; }
CWE-000 int nfssvc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
CWE-200 static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( "Downmix_Command<S2SV_blank>command<S2SV_blank>%" PRIu32 "<S2SV_blank>cmdSize<S2SV_blank>%" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%" PRIu32 ",<S2SV_blank>pReplyData:<S2SV_blank>%p" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || pReplyData == NULL || replySize == NULL || * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * rep = ( effect_param_t * ) pReplyData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ; ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>param<S2SV_blank>%" PRId32 ",<S2SV_blank>replySize<S2SV_blank>%" PRIu32 , * ( int32_t * ) rep -> data , rep -> vsize ) ; rep -> status = Downmix_getParameter ( pDownmixer , * ( int32_t * ) rep -> data , & rep -> vsize , rep -> data + sizeof ( int32_t ) ) ; * replySize = sizeof ( effect_param_t ) + sizeof ( int32_t ) + rep -> vsize ; break ; case EFFECT_CMD_SET_PARAM : ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%" PRIu32 ",<S2SV_blank>pReplyData<S2SV_blank>%p" , cmdSize , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) || pReplyData == NULL || replySize == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * cmd = ( effect_param_t * ) pCmdData ; <S2SV_StartBug> * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , <S2SV_EndBug> cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ; break ; case EFFECT_CMD_SET_PARAM_DEFERRED : ALOGW ( "Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_DEFERRED<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME" ) ; break ; case EFFECT_CMD_SET_PARAM_COMMIT : ALOGW ( "Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_COMMIT<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME" ) ; break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_ACTIVE ; ALOGV ( "EFFECT_CMD_ENABLE()<S2SV_blank>OK" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_INITIALIZED ; ALOGV ( "EFFECT_CMD_DISABLE()<S2SV_blank>OK" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_DEVICE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_SET_DEVICE:<S2SV_blank>0x%08" PRIx32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_VOLUME : { if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) * 2 ) { return - EINVAL ; } ALOGW ( "Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_VOLUME<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME" ) ; float left = ( float ) ( * ( uint32_t * ) pCmdData ) / ( 1 << 24 ) ; float right = ( float ) ( * ( ( uint32_t * ) pCmdData + 1 ) ) / ( 1 << 24 ) ; ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_SET_VOLUME:<S2SV_blank>left<S2SV_blank>%f,<S2SV_blank>right<S2SV_blank>%f<S2SV_blank>" , left , right ) ; break ; } case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_SET_AUDIO_MODE:<S2SV_blank>%" PRIu32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_CONFIG_REVERSE : case EFFECT_CMD_SET_INPUT_DEVICE : break ; default : ALOGW ( "Downmix_Command<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%" PRIu32 , cmdCode ) ; return - EINVAL ; } return 0 ; }
CWE-200 static int l2tp_ip6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) msg -> msg_name ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sk_buff * skb ; if ( flags & MSG_OOB ) goto out ; if ( addr_len ) * addr_len = sizeof ( * lsa ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( lsa ) { lsa -> l2tp_family = AF_INET6 ; lsa -> l2tp_unused = 0 ; lsa -> l2tp_addr = ipv6_hdr ( skb ) -> saddr ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ; <S2SV_StartBug> if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) <S2SV_EndBug> lsa -> l2tp_scope_id = IP6CB ( skb ) -> iif ; } if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }
CWE-189 native_handle_t * native_handle_create ( int numFds , int numInts ) { <S2SV_StartBug> native_handle_t * h = malloc ( <S2SV_EndBug> <S2SV_StartBug> sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ; <S2SV_EndBug> if ( h ) { h -> version = sizeof ( native_handle_t ) ; h -> numFds = numFds ; h -> numInts = numInts ; } return h ; }
CWE-119 static void update_golden_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( cm -> refresh_golden_frame ) { if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && ( cpi -> frames_till_gf_update_due > 0 ) ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; if ( ( cm -> frame_type != KEY_FRAME ) && ! cpi -> source_alt_ref_active ) { cpi -> gf_overspend_bits += ( cpi -> projected_frame_size - cpi -> inter_frame_target ) ; } cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cm -> refresh_golden_frame = 0 ; cpi -> frames_since_golden = 0 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; if ( cpi -> oxcf . fixed_q >= 0 && cpi -> oxcf . play_alternate && ! cpi -> common . refresh_alt_ref_frame ) { cpi -> source_alt_ref_pending = 1 ; cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; } if ( ! cpi -> source_alt_ref_pending ) cpi -> source_alt_ref_active = 0 ; if ( cpi -> frames_till_gf_update_due > 0 ) cpi -> frames_till_gf_update_due -- ; } else if ( ! cpi -> common . refresh_alt_ref_frame ) { if ( cpi -> frames_till_gf_update_due > 0 ) cpi -> frames_till_gf_update_due -- ; if ( cpi -> frames_till_alt_ref_frame ) cpi -> frames_till_alt_ref_frame -- ; cpi -> frames_since_golden ++ ; if ( cpi -> frames_since_golden > 1 ) { cpi -> recent_ref_frame_usage [ INTRA_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ INTRA_FRAME ] ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ LAST_FRAME ] ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ GOLDEN_FRAME ] ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] += cpi -> mb . count_mb_ref_frame_usage [ ALTREF_FRAME ] ; } } }
CWE-787 static int reverseSamplesBytes ( uint16 spp , uint16 bps , uint32 width , uint8 * src , uint8 * dst ) { int i ; uint32 col , bytes_per_pixel , col_offset ; uint8 bytebuff1 ; unsigned char swapbuff [ 32 ] ; if ( ( src == NULL ) || ( dst == NULL ) ) { TIFFError ( "reverseSamplesBytes" , "Invalid<S2SV_blank>input<S2SV_blank>or<S2SV_blank>output<S2SV_blank>buffer" ) ; return ( 1 ) ; } bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; <S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> { case 8 : case 4 : case 3 : case 2 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { col_offset = col * bytes_per_pixel ; _TIFFmemcpy ( swapbuff , src + col_offset , bytes_per_pixel ) ; _TIFFmemcpy ( src + col_offset , dst - col_offset - bytes_per_pixel , bytes_per_pixel ) ; _TIFFmemcpy ( dst - col_offset - bytes_per_pixel , swapbuff , bytes_per_pixel ) ; } break ; case 1 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { for ( i = 0 ; i < spp ; i ++ ) { bytebuff1 = * src ; * src ++ = * ( dst - spp + i ) ; * ( dst - spp + i ) = bytebuff1 ; } dst -= spp ; } break ; default : TIFFError ( "reverseSamplesBytes" , "Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d" , bps ) ; return ( 1 ) ; } return ( 0 ) ; }
CWE-399 static int hugetlbfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) { struct hugetlbfs_sb_info * sbinfo = HUGETLBFS_SB ( dentry -> d_sb ) ; struct hstate * h = hstate_inode ( dentry -> d_inode ) ; buf -> f_type = HUGETLBFS_MAGIC ; buf -> f_bsize = huge_page_size ( h ) ; if ( sbinfo ) { spin_lock ( & sbinfo -> stat_lock ) ; <S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> buf -> f_files = sbinfo -> max_inodes ; buf -> f_ffree = sbinfo -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; return 0 ; }
CWE-200 void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( IS_ERR_OR_NULL ( mp ) ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } <S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }
CWE-125 u_int chdlc_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , register const u_char * p ) { <S2SV_StartBug> register u_int length = h -> len ; <S2SV_EndBug> register u_int caplen = h -> caplen ; if ( caplen < CHDLC_HDRLEN ) { ND_PRINT ( ( ndo , "[|chdlc]" ) ) ; return ( caplen ) ; } <S2SV_StartBug> return ( chdlc_print ( ndo , p , length ) ) ; <S2SV_EndBug> }
CWE-362 void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-189 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( "%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\n" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ; if ( buf ) { ret = - ERANGE ; if ( acl_len > buflen ) goto out_free ; _copy_from_pages ( buf , pages , res . acl_data_offset , <S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug> } ret = acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }
CWE-399 static struct page * alloc_huge_page ( struct vm_area_struct * vma , unsigned long addr , int avoid_reserve ) { <S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> struct address_space * mapping = vma -> vm_file -> f_mapping ; struct inode * inode = mapping -> host ; long chg ; chg = vma_needs_reservation ( h , vma , addr ) ; if ( chg < 0 ) return ERR_PTR ( - VM_FAULT_OOM ) ; if ( chg ) <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; spin_lock ( & hugetlb_lock ) ; page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_unlock ( & hugetlb_lock ) ; if ( ! page ) { page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ; if ( ! page ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; } } <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> vma_commit_reservation ( h , vma , addr ) ; return page ; }
CWE-119 static noinline int hiddev_ioctl_usage ( struct hiddev * hiddev , unsigned int cmd , void __user * user_arg ) { struct hid_device * hid = hiddev -> hid ; struct hiddev_report_info rinfo ; struct hiddev_usage_ref_multi * uref_multi = NULL ; struct hiddev_usage_ref * uref ; struct hid_report * report ; struct hid_field * field ; int i ; uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , GFP_KERNEL ) ; if ( ! uref_multi ) return - ENOMEM ; uref = & uref_multi -> uref ; if ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) { if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) ) goto fault ; } else { if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) ) goto fault ; } switch ( cmd ) { case HIDIOCGUCODE : rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( uref -> usage_index >= field -> maxusage ) goto inval ; uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ; if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) { field = hiddev_lookup_usage ( hid , uref ) ; if ( field == NULL ) goto inval ; } else { rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( cmd == HIDIOCGCOLLECTIONINDEX ) { if ( uref -> usage_index >= field -> maxusage ) goto inval ; } else if ( uref -> usage_index >= field -> report_count ) goto inval ; <S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ; <S2SV_StartBug> } <S2SV_EndBug> switch ( cmd ) { case HIDIOCGUSAGE : uref -> value = field -> value [ uref -> usage_index ] ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGE : field -> value [ uref -> usage_index ] = uref -> value ; goto goodreturn ; case HIDIOCGCOLLECTIONINDEX : i = field -> usage [ uref -> usage_index ] . collection_index ; kfree ( uref_multi ) ; return i ; case HIDIOCGUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ] ; if ( copy_to_user ( user_arg , uref_multi , sizeof ( * uref_multi ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) field -> value [ uref -> usage_index + i ] = uref_multi -> values [ i ] ; goto goodreturn ; } goodreturn : kfree ( uref_multi ) ; return 0 ; fault : kfree ( uref_multi ) ; return - EFAULT ; inval : kfree ( uref_multi ) ; return - EINVAL ; } }
CWE-000 static TPM_RC StartAuthSession ( TSS2_SYS_CONTEXT * sapi_context , SESSION * session ) { TPM_RC rval ; TPM2B_ENCRYPTED_SECRET key ; char label [ ] = "ATH" ; UINT16 bytes ; int i ; key . t . size = 0 ; if ( session -> nonceOlder . t . size == 0 ) { session -> nonceOlder . t . size = GetDigestSize ( TPM_ALG_SHA1 ) ; for ( i = 0 ; i < session -> nonceOlder . t . size ; i ++ ) session -> nonceOlder . t . buffer [ i ] = 0 ; } session -> nonceNewer . t . size = session -> nonceOlder . t . size ; rval = Tss2_Sys_StartAuthSession ( sapi_context , session -> tpmKey , session -> bind , 0 , & ( session -> nonceOlder ) , & ( session -> encryptedSalt ) , session -> sessionType , & ( session -> symmetric ) , session -> authHash , & ( session -> sessionHandle ) , & ( session -> nonceNewer ) , 0 ) ; if ( rval == TPM_RC_SUCCESS ) { if ( session -> tpmKey == TPM_RH_NULL ) session -> salt . t . size = 0 ; if ( session -> bind == TPM_RH_NULL ) session -> authValueBind . t . size = 0 ; if ( session -> tpmKey == TPM_RH_NULL && session -> bind == TPM_RH_NULL ) { session -> sessionKey . b . size = 0 ; } else { bool result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> authValueBind . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> salt . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } bytes = GetDigestSize ( session -> authHash ) ; if ( key . t . size == 0 ) { session -> sessionKey . t . size = 0 ; } else { <S2SV_StartBug> rval = tpm_kdfa ( sapi_context , session -> authHash , & ( key . b ) , label , & ( session -> nonceNewer . b ) , <S2SV_EndBug> & ( session -> nonceOlder . b ) , bytes * 8 , ( TPM2B_MAX_BUFFER * ) & ( session -> sessionKey ) ) ; } if ( rval != TPM_RC_SUCCESS ) { return ( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED ) ; } } session -> nonceTpmDecrypt . b . size = 0 ; session -> nonceTpmEncrypt . b . size = 0 ; session -> nvNameChanged = 0 ; } return rval ; }
CWE-190 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; <S2SV_StartBug> int iskew = imagew - tilew ; <S2SV_EndBug> uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; for ( col = 0 ; col < imagewidth && colb < imagew ; col += tw ) { if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%lu<S2SV_blank>%lu" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } <S2SV_StartBug> if ( colb + tilew > imagew ) { <S2SV_EndBug> uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }
CWE-190 int ring_buffer_resize ( struct ring_buffer * buffer , unsigned long size , int cpu_id ) { struct ring_buffer_per_cpu * cpu_buffer ; unsigned long nr_pages ; int cpu , err = 0 ; if ( ! buffer ) return size ; if ( cpu_id != RING_BUFFER_ALL_CPUS && ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) return size ; <S2SV_StartBug> size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; <S2SV_EndBug> size *= BUF_PAGE_SIZE ; if ( size < BUF_PAGE_SIZE * 2 ) size = BUF_PAGE_SIZE * 2 ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( atomic_read ( & buffer -> resize_disabled ) ) return - EBUSY ; mutex_lock ( & buffer -> mutex ) ; if ( cpu_id == RING_BUFFER_ALL_CPUS ) { for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; cpu_buffer -> nr_pages_to_update = nr_pages - cpu_buffer -> nr_pages ; if ( cpu_buffer -> nr_pages_to_update <= 0 ) continue ; INIT_LIST_HEAD ( & cpu_buffer -> new_pages ) ; if ( __rb_allocate_pages ( cpu_buffer -> nr_pages_to_update , & cpu_buffer -> new_pages , cpu ) ) { err = - ENOMEM ; goto out_err ; } } get_online_cpus ( ) ; for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; if ( ! cpu_buffer -> nr_pages_to_update ) continue ; if ( ! cpu_online ( cpu ) ) { rb_update_pages ( cpu_buffer ) ; cpu_buffer -> nr_pages_to_update = 0 ; } else { schedule_work_on ( cpu , & cpu_buffer -> update_pages_work ) ; } } for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; if ( ! cpu_buffer -> nr_pages_to_update ) continue ; if ( cpu_online ( cpu ) ) wait_for_completion ( & cpu_buffer -> update_done ) ; cpu_buffer -> nr_pages_to_update = 0 ; } put_online_cpus ( ) ; } else { if ( ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) goto out ; cpu_buffer = buffer -> buffers [ cpu_id ] ; if ( nr_pages == cpu_buffer -> nr_pages ) goto out ; cpu_buffer -> nr_pages_to_update = nr_pages - cpu_buffer -> nr_pages ; INIT_LIST_HEAD ( & cpu_buffer -> new_pages ) ; if ( cpu_buffer -> nr_pages_to_update > 0 && __rb_allocate_pages ( cpu_buffer -> nr_pages_to_update , & cpu_buffer -> new_pages , cpu_id ) ) { err = - ENOMEM ; goto out_err ; } get_online_cpus ( ) ; if ( ! cpu_online ( cpu_id ) ) rb_update_pages ( cpu_buffer ) ; else { schedule_work_on ( cpu_id , & cpu_buffer -> update_pages_work ) ; wait_for_completion ( & cpu_buffer -> update_done ) ; } cpu_buffer -> nr_pages_to_update = 0 ; put_online_cpus ( ) ; } out : if ( atomic_read ( & buffer -> record_disabled ) ) { atomic_inc ( & buffer -> record_disabled ) ; synchronize_sched ( ) ; for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; rb_check_pages ( cpu_buffer ) ; } atomic_dec ( & buffer -> record_disabled ) ; } mutex_unlock ( & buffer -> mutex ) ; return size ; out_err : for_each_buffer_cpu ( buffer , cpu ) { struct buffer_page * bpage , * tmp ; cpu_buffer = buffer -> buffers [ cpu ] ; cpu_buffer -> nr_pages_to_update = 0 ; if ( list_empty ( & cpu_buffer -> new_pages ) ) continue ; list_for_each_entry_safe ( bpage , tmp , & cpu_buffer -> new_pages , list ) { list_del_init ( & bpage -> list ) ; free_buffer_page ( bpage ) ; } } mutex_unlock ( & buffer -> mutex ) ; return err ; }
CWE-415 SPL_METHOD ( SplDoublyLinkedList , offsetSet ) { zval * zindex , * value ; spl_dllist_object * intern ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "zz" , & zindex , & value ) == FAILURE ) { return ; } intern = Z_SPLDLLIST_P ( getThis ( ) ) ; if ( Z_TYPE_P ( zindex ) == IS_NULL ) { spl_ptr_llist_push ( intern -> llist , value ) ; } else { zend_long index ; spl_ptr_llist_element * element ; index = spl_offset_convert_to_long ( zindex ) ; if ( index < 0 || index >= intern -> llist -> count ) { <S2SV_StartBug> zval_ptr_dtor ( value ) ; <S2SV_EndBug> zend_throw_exception ( spl_ce_OutOfRangeException , "Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" , 0 ) ; return ; } element = spl_ptr_llist_offset ( intern -> llist , index , intern -> flags & SPL_DLLIST_IT_LIFO ) ; if ( element != NULL ) { if ( intern -> llist -> dtor ) { intern -> llist -> dtor ( element ) ; } zval_ptr_dtor ( & element -> data ) ; ZVAL_COPY_VALUE ( & element -> data , value ) ; if ( intern -> llist -> ctor ) { intern -> llist -> ctor ( element ) ; } } else { zval_ptr_dtor ( value ) ; zend_throw_exception ( spl_ce_OutOfRangeException , "Offset<S2SV_blank>invalid" , 0 ) ; return ; } } }
CWE-190 static int _gd2GetHeader ( gdIOCtxPtr in , int * sx , int * sy , int * cs , int * vers , int * fmt , int * ncx , int * ncy , t_chunk_info * * chunkIdx ) { int i ; int ch ; char id [ 5 ] ; t_chunk_info * cidx ; int sidx ; int nc ; GD2_DBG ( php_gd_error ( "Reading<S2SV_blank>gd2<S2SV_blank>header<S2SV_blank>info" ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { ch = gdGetC ( in ) ; if ( ch == EOF ) { goto fail1 ; } id [ i ] = ch ; } id [ 4 ] = 0 ; GD2_DBG ( php_gd_error ( "Got<S2SV_blank>file<S2SV_blank>code:<S2SV_blank>%s" , id ) ) ; if ( strcmp ( id , GD2_ID ) != 0 ) { GD2_DBG ( php_gd_error ( "Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>gd2<S2SV_blank>file" ) ) ; goto fail1 ; } if ( gdGetWord ( vers , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( "Version:<S2SV_blank>%d" , * vers ) ) ; if ( ( * vers != 1 ) && ( * vers != 2 ) ) { GD2_DBG ( php_gd_error ( "Bad<S2SV_blank>version:<S2SV_blank>%d" , * vers ) ) ; goto fail1 ; } if ( ! gdGetWord ( sx , in ) ) { GD2_DBG ( php_gd_error ( "Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>x-size" ) ) ; goto fail1 ; } if ( ! gdGetWord ( sy , in ) ) { GD2_DBG ( php_gd_error ( "Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>y-size" ) ) ; goto fail1 ; } GD2_DBG ( php_gd_error ( "Image<S2SV_blank>is<S2SV_blank>%dx%d" , * sx , * sy ) ) ; if ( gdGetWord ( cs , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( "ChunkSize:<S2SV_blank>%d" , * cs ) ) ; if ( ( * cs < GD2_CHUNKSIZE_MIN ) || ( * cs > GD2_CHUNKSIZE_MAX ) ) { GD2_DBG ( php_gd_error ( "Bad<S2SV_blank>chunk<S2SV_blank>size:<S2SV_blank>%d" , * cs ) ) ; goto fail1 ; } if ( gdGetWord ( fmt , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( "Format:<S2SV_blank>%d" , * fmt ) ) ; if ( ( * fmt != GD2_FMT_RAW ) && ( * fmt != GD2_FMT_COMPRESSED ) && ( * fmt != GD2_FMT_TRUECOLOR_RAW ) && ( * fmt != GD2_FMT_TRUECOLOR_COMPRESSED ) ) { GD2_DBG ( php_gd_error ( "Bad<S2SV_blank>data<S2SV_blank>format:<S2SV_blank>%d" , * fmt ) ) ; goto fail1 ; } if ( gdGetWord ( ncx , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( "%d<S2SV_blank>Chunks<S2SV_blank>Wide" , * ncx ) ) ; if ( gdGetWord ( ncy , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( "%d<S2SV_blank>Chunks<S2SV_blank>vertically" , * ncy ) ) ; if ( gd2_compressed ( * fmt ) ) { nc = ( * ncx ) * ( * ncy ) ; GD2_DBG ( php_gd_error ( "Reading<S2SV_blank>%d<S2SV_blank>chunk<S2SV_blank>index<S2SV_blank>entries" , nc ) ) ; <S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> if ( sidx <= 0 ) { goto fail1 ; } <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < nc ; i ++ ) { if ( gdGetInt ( & cidx [ i ] . offset , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( gdGetInt ( & cidx [ i ] . size , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( cidx [ i ] . offset < 0 || cidx [ i ] . size < 0 ) { gdFree ( cidx ) ; goto fail1 ; } } * chunkIdx = cidx ; } GD2_DBG ( php_gd_error ( "gd2<S2SV_blank>header<S2SV_blank>complete" ) ) ; return 1 ; fail1 : return 0 ; }
CWE-000 void gsm_xsmp_client_connect ( GsmXSMPClient * client , SmsConn conn , unsigned long * mask_ret , SmsCallbacks * callbacks_ret ) { client -> priv -> conn = conn ; <S2SV_StartBug> if ( client -> priv -> protocol_timeout ) { <S2SV_EndBug> g_source_remove ( client -> priv -> protocol_timeout ) ; client -> priv -> protocol_timeout = 0 ; } g_debug ( "GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s" , client -> priv -> description ) ; * mask_ret = 0 ; * mask_ret |= SmsRegisterClientProcMask ; callbacks_ret -> register_client . callback = register_client_callback ; callbacks_ret -> register_client . manager_data = client ; * mask_ret |= SmsInteractRequestProcMask ; callbacks_ret -> interact_request . callback = interact_request_callback ; callbacks_ret -> interact_request . manager_data = client ; * mask_ret |= SmsInteractDoneProcMask ; callbacks_ret -> interact_done . callback = interact_done_callback ; callbacks_ret -> interact_done . manager_data = client ; * mask_ret |= SmsSaveYourselfRequestProcMask ; callbacks_ret -> save_yourself_request . callback = save_yourself_request_callback ; callbacks_ret -> save_yourself_request . manager_data = client ; * mask_ret |= SmsSaveYourselfP2RequestProcMask ; callbacks_ret -> save_yourself_phase2_request . callback = save_yourself_phase2_request_callback ; callbacks_ret -> save_yourself_phase2_request . manager_data = client ; * mask_ret |= SmsSaveYourselfDoneProcMask ; callbacks_ret -> save_yourself_done . callback = save_yourself_done_callback ; callbacks_ret -> save_yourself_done . manager_data = client ; * mask_ret |= SmsCloseConnectionProcMask ; callbacks_ret -> close_connection . callback = close_connection_callback ; callbacks_ret -> close_connection . manager_data = client ; * mask_ret |= SmsSetPropertiesProcMask ; callbacks_ret -> set_properties . callback = set_properties_callback ; callbacks_ret -> set_properties . manager_data = client ; * mask_ret |= SmsDeletePropertiesProcMask ; callbacks_ret -> delete_properties . callback = delete_properties_callback ; callbacks_ret -> delete_properties . manager_data = client ; * mask_ret |= SmsGetPropertiesProcMask ; callbacks_ret -> get_properties . callback = get_properties_callback ; callbacks_ret -> get_properties . manager_data = client ; }
CWE-119 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; <S2SV_StartBug> dtls1_process_buffered_records ( s ) ; <S2SV_EndBug> if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; <S2SV_EndBug> } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } <S2SV_StartBug> return ( 1 ) ; <S2SV_EndBug> }
CWE-190 static int mem_write ( jas_stream_obj_t * obj , char * buf , int cnt ) { <S2SV_StartBug> int n ; <S2SV_EndBug> int ret ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <S2SV_StartBug> long newbufsize ; <S2SV_EndBug> long newpos ; assert ( buf ) ; assert ( cnt >= 0 ) ; JAS_DBGLOG ( 100 , ( "mem_write(%p,<S2SV_blank>%p,<S2SV_blank>%d)\\n" , obj , buf , cnt ) ) ; newpos = m -> pos_ + cnt ; if ( newpos > m -> bufsize_ && m -> growable_ ) { newbufsize = m -> bufsize_ ; while ( newbufsize < newpos ) { <S2SV_StartBug> newbufsize <<= 1 ; <S2SV_EndBug> assert ( newbufsize >= 0 ) ; } <S2SV_StartBug> JAS_DBGLOG ( 100 , ( "mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%z\\n" , m -> bufsize_ , <S2SV_EndBug> newbufsize ) ) ; JAS_DBGLOG ( 100 , ( "mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%ul\\n" , m -> bufsize_ , JAS_CAST ( unsigned long , newbufsize ) ) ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } } <S2SV_StartBug> if ( m -> pos_ > m -> len_ ) { <S2SV_EndBug> n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ; if ( n > 0 ) { memset ( & m -> buf_ [ m -> len_ ] , 0 , n ) ; m -> len_ += n ; } if ( m -> pos_ != m -> len_ ) { return 0 ; } } n = m -> bufsize_ - m -> pos_ ; ret = JAS_MIN ( n , cnt ) ; if ( ret > 0 ) { memcpy ( & m -> buf_ [ m -> pos_ ] , buf , ret ) ; m -> pos_ += ret ; } if ( m -> pos_ > m -> len_ ) { m -> len_ = m -> pos_ ; } assert ( ret == cnt ) ; return ret ; }
CWE-119 int vp8dx_receive_compressed_data ( VP8D_COMP * pbi , size_t size , const uint8_t * source , int64_t time_stamp ) { <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> int64_t dx_store_reg [ 8 ] ; # endif VP8_COMMON * cm = & pbi -> common ; int retcode = - 1 ; <S2SV_StartBug> pbi -> common . error . error_code = VPX_CODEC_OK ; <S2SV_EndBug> retcode = check_fragments_for_errors ( pbi ) ; if ( retcode <= 0 ) return retcode ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( dx_store_reg ) ; } # endif cm -> new_fb_idx = get_free_fb ( cm ) ; pbi -> dec_fb_ref [ INTRA_FRAME ] = & cm -> yv12_fb [ cm -> new_fb_idx ] ; pbi -> dec_fb_ref [ LAST_FRAME ] = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; pbi -> dec_fb_ref [ GOLDEN_FRAME ] = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; pbi -> dec_fb_ref [ ALTREF_FRAME ] = & cm -> yv12_fb [ cm -> alt_fb_idx ] ; if ( setjmp ( pbi -> common . error . jmp ) ) { cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; goto decode_exit ; } pbi -> common . error . setjmp = 1 ; retcode = vp8_decode_frame ( pbi ) ; if ( retcode < 0 ) { if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; pbi -> common . error . error_code = VPX_CODEC_ERROR ; goto decode_exit ; } if ( swap_frame_buffers ( cm ) ) { pbi -> common . error . error_code = VPX_CODEC_ERROR ; goto decode_exit ; } vp8_clear_system_state ( ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; cm -> show_frame_mi = cm -> mi ; } # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_enabled && pbi -> common . prev_mi ) { MODE_INFO * tmp = pbi -> common . prev_mi ; int row , col ; pbi -> common . prev_mi = pbi -> common . mi ; pbi -> common . mi = tmp ; for ( row = 0 ; row < pbi -> common . mb_rows ; ++ row ) { for ( col = 0 ; col < pbi -> common . mb_cols ; ++ col ) { const int i = row * pbi -> common . mode_info_stride + col ; pbi -> common . mi [ i ] . mbmi . segment_id = pbi -> common . prev_mi [ i ] . mbmi . segment_id ; } } } # endif pbi -> ready_for_new_data = 0 ; pbi -> last_time_stamp = time_stamp ; decode_exit : <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( dx_store_reg ) ; } # endif pbi -> common . error . setjmp = 0 ; <S2SV_StartBug> return retcode ; <S2SV_EndBug> }
CWE-125 static void ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; <S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ; <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> return ; nstrips32 = ( uint32 ) nstrips64 ; <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> "for<S2SV_blank>chopped<S2SV_blank>\\"StripByteCounts\\"<S2SV_blank>array" ) ; <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> "for<S2SV_blank>chopped<S2SV_blank>\\"StripOffsets\\"<S2SV_blank>array" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; } <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ; <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> offset += stripbytes ; bytecount -= stripbytes ; } <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }
CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , ".fini_array" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , ".init_array" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , ".preinit_array" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 4 ) { <S2SV_EndBug> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { <S2SV_StartBug> for ( i = 0 ; i < sec -> size ; i += 8 ) { <S2SV_EndBug> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }
CWE-200 static int rfcomm_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rfcomm_dlc * d = rfcomm_pi ( sk ) -> dlc ; int len ; if ( test_and_clear_bit ( RFCOMM_DEFER_SETUP , & d -> flags ) ) { <S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> return 0 ; } len = bt_sock_stream_recvmsg ( iocb , sock , msg , size , flags ) ; lock_sock ( sk ) ; if ( ! ( flags & MSG_PEEK ) && len > 0 ) atomic_sub ( len , & sk -> sk_rmem_alloc ) ; if ( atomic_read ( & sk -> sk_rmem_alloc ) <= ( sk -> sk_rcvbuf >> 2 ) ) rfcomm_dlc_unthrottle ( rfcomm_pi ( sk ) -> dlc ) ; release_sock ( sk ) ; return len ; }
CWE-000 <S2SV_StartBug> static void prefetch_table ( const volatile byte * tab , size_t len ) <S2SV_EndBug> { size_t i ; <S2SV_StartBug> for ( i = 0 ; i < len ; i += 8 * 32 ) <S2SV_EndBug> { ( void ) tab [ i + 0 * 32 ] ; ( void ) tab [ i + 1 * 32 ] ; ( void ) tab [ i + 2 * 32 ] ; ( void ) tab [ i + 3 * 32 ] ; ( void ) tab [ i + 4 * 32 ] ; ( void ) tab [ i + 5 * 32 ] ; ( void ) tab [ i + 6 * 32 ] ; ( void ) tab [ i + 7 * 32 ] ; } <S2SV_StartBug> ( void ) tab [ len - 1 ] ; <S2SV_EndBug> }
CWE-399 sctp_disposition_t sctp_sf_do_asconf ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sctp_chunk * asconf_ack = NULL ; struct sctp_paramhdr * err_param = NULL ; sctp_addiphdr_t * hdr ; <S2SV_StartBug> union sctp_addr_param * addr_param ; <S2SV_EndBug> __u32 serial ; int length ; if ( ! sctp_vtag_verify ( chunk , asoc ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_REPORT_BAD_TAG , SCTP_NULL ( ) ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } if ( ! net -> sctp . addip_noauth && ! chunk -> auth ) return sctp_sf_discard_chunk ( net , ep , asoc , type , arg , commands ) ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_addip_chunk_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; hdr = ( sctp_addiphdr_t * ) chunk -> skb -> data ; serial = ntohl ( hdr -> serial ) ; <S2SV_StartBug> addr_param = ( union sctp_addr_param * ) hdr -> params ; <S2SV_EndBug> length = ntohs ( addr_param -> p . length ) ; if ( length < sizeof ( sctp_paramhdr_t ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) addr_param , commands ) ; if ( ! sctp_verify_asconf ( asoc , <S2SV_StartBug> ( sctp_paramhdr_t * ) ( ( void * ) addr_param + length ) , <S2SV_EndBug> ( void * ) chunk -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ; if ( serial == asoc -> peer . addip_serial + 1 ) { if ( ! chunk -> has_asconf ) sctp_assoc_clean_asconf_ack_cache ( asoc ) ; asconf_ack = sctp_process_asconf ( ( struct sctp_association * ) asoc , chunk ) ; if ( ! asconf_ack ) return SCTP_DISPOSITION_NOMEM ; } else if ( serial < asoc -> peer . addip_serial + 1 ) { asconf_ack = sctp_assoc_lookup_asconf_ack ( asoc , hdr -> serial ) ; if ( ! asconf_ack ) return SCTP_DISPOSITION_DISCARD ; asconf_ack -> transport = NULL ; } else { return SCTP_DISPOSITION_DISCARD ; } asconf_ack -> dest = chunk -> source ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( asconf_ack ) ) ; if ( asoc -> new_transport ) { sctp_sf_heartbeat ( ep , asoc , type , asoc -> new_transport , commands ) ; ( ( struct sctp_association * ) asoc ) -> new_transport = NULL ; } return SCTP_DISPOSITION_CONSUME ; }
CWE-476 int jpc_tsfb_synthesize ( jpc_tsfb_t * tsfb , jas_seq2d_t * a ) { <S2SV_StartBug> return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , <S2SV_EndBug> jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ; }
CWE-20 static int netlink_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct scm_cookie scm ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied ; struct sk_buff * skb , * data_skb ; int err , ret ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; copied = 0 ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( skb == NULL ) goto out ; data_skb = skb ; # ifdef CONFIG_COMPAT_NETLINK_MESSAGES if ( unlikely ( skb_shinfo ( skb ) -> frag_list ) ) { if ( flags & MSG_CMSG_COMPAT ) data_skb = skb_shinfo ( skb ) -> frag_list ; } # endif <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = data_skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( data_skb ) ; err = skb_copy_datagram_iovec ( data_skb , 0 , msg -> msg_iov , copied ) ; if ( msg -> msg_name ) { struct sockaddr_nl * addr = ( struct sockaddr_nl * ) msg -> msg_name ; addr -> nl_family = AF_NETLINK ; addr -> nl_pad = 0 ; addr -> nl_pid = NETLINK_CB ( skb ) . portid ; addr -> nl_groups = netlink_group_mask ( NETLINK_CB ( skb ) . dst_group ) ; msg -> msg_namelen = sizeof ( * addr ) ; } if ( nlk -> flags & NETLINK_RECV_PKTINFO ) netlink_cmsg_recv_pktinfo ( msg , skb ) ; if ( NULL == siocb -> scm ) { memset ( & scm , 0 , sizeof ( scm ) ) ; siocb -> scm = & scm ; } siocb -> scm -> creds = * NETLINK_CREDS ( skb ) ; if ( flags & MSG_TRUNC ) copied = data_skb -> len ; skb_free_datagram ( sk , skb ) ; if ( nlk -> cb_running && atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf / 2 ) { ret = netlink_dump ( sk ) ; if ( ret ) { sk -> sk_err = ret ; sk -> sk_error_report ( sk ) ; } } scm_recv ( sock , msg , siocb -> scm , flags ) ; out : netlink_rcv_wake ( sk ) ; return err ? : copied ; }
CWE-119 void vp8cx_pick_filter_level_fast ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filt_val ; <S2SV_StartBug> int best_filt_val = cm -> filter_level ; <S2SV_EndBug> YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; if ( cm -> sharpness_level != cm -> last_sharpness_level ) { vp8_loop_filter_update_sharpness ( & cm -> lf_info , cm -> sharpness_level ) ; cm -> last_sharpness_level = cm -> sharpness_level ; } if ( cm -> filter_level < min_filter_level ) cm -> filter_level = min_filter_level ; else if ( cm -> filter_level > max_filter_level ) cm -> filter_level = max_filter_level ; filt_val = cm -> filter_level ; best_filt_val = filt_val ; <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; best_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; filt_val -= 1 + ( filt_val > 10 ) ; while ( filt_val >= min_filter_level ) { <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; filt_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; if ( filt_err < best_err ) { best_err = filt_err ; best_filt_val = filt_val ; } else break ; filt_val -= 1 + ( filt_val > 10 ) ; } filt_val = cm -> filter_level + 1 + ( filt_val > 10 ) ; if ( best_filt_val == cm -> filter_level ) { best_err -= ( best_err >> 10 ) ; while ( filt_val < max_filter_level ) { <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; filt_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; if ( filt_err < best_err ) { best_err = filt_err - ( filt_err >> 10 ) ; best_filt_val = filt_val ; } else break ; filt_val += 1 + ( filt_val > 10 ) ; } } cm -> filter_level = best_filt_val ; if ( cm -> filter_level < min_filter_level ) cm -> filter_level = min_filter_level ; if ( cm -> filter_level > max_filter_level ) cm -> filter_level = max_filter_level ; cm -> frame_to_show = saved_frame ; }
CWE-000 static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( "BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( "BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( "invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( "unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( "fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n" , insn -> imm ) ; return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } <S2SV_StartBug> env -> used_maps [ env -> used_map_cnt ++ ] = map ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( map , false ) ; <S2SV_EndBug> fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }
CWE-787 static unsigned int ipv6_defrag ( void * priv , struct sk_buff * skb , const struct nf_hook_state * state ) { int err ; # if IS_ENABLED ( CONFIG_NF_CONNTRACK ) if ( skb -> nfct && ! nf_ct_is_template ( ( struct nf_conn * ) skb -> nfct ) ) return NF_ACCEPT ; # endif err = nf_ct_frag6_gather ( state -> net , skb , nf_ct6_defrag_user ( state -> hook , skb ) ) ; if ( err == - EINPROGRESS ) return NF_STOLEN ; <S2SV_StartBug> return NF_ACCEPT ; <S2SV_EndBug> }
CWE-119 static int test_candidate_kf ( VP8_COMP * cpi , FIRSTPASS_STATS * last_frame , FIRSTPASS_STATS * this_frame , FIRSTPASS_STATS * next_frame ) { int is_viable_kf = 0 ; if ( ( this_frame -> pcnt_second_ref < 0.10 ) && ( next_frame -> pcnt_second_ref < 0.10 ) && ( ( this_frame -> pcnt_inter < 0.05 ) || ( ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < .25 ) && ( ( this_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) && ( ( fabs ( last_frame -> coded_error - this_frame -> coded_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > .40 ) || ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > .40 ) || ( ( next_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) { int i ; FIRSTPASS_STATS * start_pos ; FIRSTPASS_STATS local_next_frame ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double decay_accumulator = 1.0 ; double next_iiratio ; <S2SV_StartBug> vpx_memcpy ( & local_next_frame , next_frame , sizeof ( * next_frame ) ) ; <S2SV_EndBug> start_pos = cpi -> twopass . stats_in ; for ( i = 0 ; i < 16 ; i ++ ) { next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( local_next_frame . coded_error ) ) ; if ( next_iiratio > RMAX ) next_iiratio = RMAX ; if ( local_next_frame . pcnt_inter > 0.85 ) decay_accumulator = decay_accumulator * local_next_frame . pcnt_inter ; else decay_accumulator = decay_accumulator * ( ( 0.85 + local_next_frame . pcnt_inter ) / 2.0 ) ; boost_score += ( decay_accumulator * next_iiratio ) ; if ( ( local_next_frame . pcnt_inter < 0.05 ) || ( next_iiratio < 1.5 ) || ( ( ( local_next_frame . pcnt_inter - local_next_frame . pcnt_neutral ) < 0.20 ) && ( next_iiratio < 3.0 ) ) || ( ( boost_score - old_boost_score ) < 0.5 ) || ( local_next_frame . intra_error < 200 ) ) { break ; } old_boost_score = boost_score ; if ( EOF == input_stats ( cpi , & local_next_frame ) ) break ; } if ( boost_score > 5.0 && ( i > 3 ) ) is_viable_kf = 1 ; else { reset_fpf_position ( cpi , start_pos ) ; is_viable_kf = 0 ; } } return is_viable_kf ; }
CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { GradFunContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int p , direct ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { direct = 0 ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } <S2SV_StartBug> for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) { <S2SV_EndBug> int w = inlink -> w ; int h = inlink -> h ; int r = s -> radius ; if ( p ) { w = s -> chroma_w ; h = s -> chroma_h ; r = s -> chroma_r ; } if ( FFMIN ( w , h ) > 2 * r ) filter ( s , out -> data [ p ] , in -> data [ p ] , w , h , out -> linesize [ p ] , in -> linesize [ p ] , r ) ; else if ( out -> data [ p ] != in -> data [ p ] ) av_image_copy_plane ( out -> data [ p ] , out -> linesize [ p ] , in -> data [ p ] , in -> linesize [ p ] , w , h ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
CWE-000 static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; <S2SV_StartBug> if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <S2SV_EndBug> return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }
CWE-190 gdImagePtr gdImageCreate ( int sx , int sy ) { int i ; gdImagePtr im ; if ( overflow2 ( sx , sy ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sy ) ) { return NULL ; } <S2SV_StartBug> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <S2SV_EndBug> im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> AA_opacity = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> polyInts = 0 ; im -> polyAllocated = 0 ; im -> brush = 0 ; im -> tile = 0 ; im -> style = 0 ; for ( i = 0 ; i < sy ; i ++ ) { im -> pixels [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; im -> AA_opacity [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; } im -> sx = sx ; im -> sy = sy ; im -> colorsTotal = 0 ; im -> transparent = ( - 1 ) ; im -> interlace = 0 ; im -> thick = 1 ; im -> AA = 0 ; im -> AA_polygon = 0 ; for ( i = 0 ; i < gdMaxColors ; i ++ ) { im -> open [ i ] = 1 ; im -> red [ i ] = 0 ; im -> green [ i ] = 0 ; im -> blue [ i ] = 0 ; } im -> trueColor = 0 ; im -> tpixels = 0 ; im -> cx1 = 0 ; im -> cy1 = 0 ; im -> cx2 = im -> sx - 1 ; im -> cy2 = im -> sy - 1 ; im -> interpolation = NULL ; im -> interpolation_id = GD_BILINEAR_FIXED ; return im ; }
CWE-000 static void balloon_process ( struct work_struct * work ) { enum bp_state state = BP_DONE ; long credit ; do { mutex_lock ( & balloon_mutex ) ; credit = current_credit ( ) ; if ( credit > 0 ) { if ( balloon_is_inflated ( ) ) state = increase_reservation ( credit ) ; else state = reserve_additional_memory ( ) ; } <S2SV_StartBug> if ( credit < 0 ) <S2SV_EndBug> <S2SV_StartBug> state = decrease_reservation ( - credit , GFP_BALLOON ) ; <S2SV_EndBug> state = update_schedule ( state ) ; mutex_unlock ( & balloon_mutex ) ; cond_resched ( ) ; } while ( credit && state == BP_DONE ) ; if ( state == BP_EAGAIN ) schedule_delayed_work ( & balloon_worker , balloon_stats . schedule_delay * HZ ) ; }
CWE-415 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( "%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\n" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <S2SV_StartBug> if ( sk != asoc -> base . sk ) <S2SV_EndBug> goto do_error ; lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }
CWE-125 GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ; <S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }
CWE-119 static void zero_stats ( FIRSTPASS_STATS * section ) { <S2SV_StartBug> section -> frame = 0.0 ; <S2SV_EndBug> section -> intra_error = 0.0 ; section -> coded_error = 0.0 ; <S2SV_StartBug> section -> sr_coded_error = 0.0 ; <S2SV_EndBug> section -> ssim_weighted_pred_err = 0.0 ; section -> pcnt_inter = 0.0 ; section -> pcnt_motion = 0.0 ; section -> pcnt_second_ref = 0.0 ; <S2SV_StartBug> section -> pcnt_neutral = 0.0 ; <S2SV_EndBug> section -> MVr = 0.0 ; section -> mvr_abs = 0.0 ; section -> MVc = 0.0 ; section -> mvc_abs = 0.0 ; section -> MVrv = 0.0 ; section -> MVcv = 0.0 ; section -> mv_in_out_count = 0.0 ; section -> new_mv_count = 0.0 ; section -> count = 0.0 ; section -> duration = 1.0 ; section -> spatial_layer_id = 0 ; }
CWE-416 struct dst_entry * inet6_csk_route_req ( const struct sock * sk , struct flowi6 * fl6 , const struct request_sock * req , u8 proto ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = proto ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> fl6 -> flowi6_oif = ireq -> ir_iif ; fl6 -> flowi6_mark = ireq -> ir_mark ; fl6 -> fl6_dport = ireq -> ir_rmt_port ; fl6 -> fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( IS_ERR ( dst ) ) return NULL ; return dst ; }
CWE-125 static int dhcpv4_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint8_t type , optlen ; i = 0 ; while ( i < length ) { <S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> type = ( uint8_t ) tlv [ 0 ] ; optlen = ( uint8_t ) tlv [ 1 ] ; value = tlv + 2 ; ND_PRINT ( ( ndo , "\\n" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , "\\t" ) ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( dh4opt_str , "Unknown" , type ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>(%u)" , optlen + 2 ) ) ; <S2SV_EndBug> switch ( type ) { case DH4OPT_DNS_SERVERS : case DH4OPT_NTP_SERVERS : { if ( optlen < 4 || optlen % 4 != 0 ) { return - 1 ; } for ( t = 0 ; t < optlen ; t += 4 ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ipaddr_string ( ndo , value + t ) ) ) ; } break ; case DH4OPT_DOMAIN_SEARCH : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return - 1 ; } } break ; } i += 2 + optlen ; } return 0 ; }
CWE-189 static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; <S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , "not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>flex<S2SV_blank>groups" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ) ; } return 1 ; failed : return 0 ; }
CWE-787 WORD32 ixheaacd_qmf_hbe_data_reinit ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD16 * p_freq_band_tab [ 2 ] , WORD16 * p_num_sfb , WORD32 upsamp_4_flag ) { WORD32 synth_size , sfb , patch , stop_patch ; if ( ptr_hbe_txposer != NULL ) { ptr_hbe_txposer -> start_band = p_freq_band_tab [ LOW ] [ 0 ] ; ptr_hbe_txposer -> end_band = p_freq_band_tab [ LOW ] [ p_num_sfb [ LOW ] ] ; ptr_hbe_txposer -> synth_size = 4 * ( ( ptr_hbe_txposer -> start_band + 4 ) / 8 + 1 ) ; ptr_hbe_txposer -> k_start = ixheaacd_start_subband2kL_tbl [ ptr_hbe_txposer -> start_band ] ; ptr_hbe_txposer -> upsamp_4_flag = upsamp_4_flag ; if ( upsamp_4_flag ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 16 ) ptr_hbe_txposer -> k_start = 16 - ptr_hbe_txposer -> synth_size ; } else if ( ptr_hbe_txposer -> core_frame_length == 768 ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 24 ) ptr_hbe_txposer -> k_start = 24 - ptr_hbe_txposer -> synth_size ; } memset ( ptr_hbe_txposer -> synth_buf , 0 , 1280 * sizeof ( FLOAT32 ) ) ; synth_size = ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> synth_buf_offset = 18 * synth_size ; switch ( synth_size ) { case 4 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 8 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_8 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_16 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 12 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_12 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_24 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p3 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p3 ; <S2SV_EndBug> break ; case 16 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_16 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_32 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> break ; case 20 : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_20 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_40 ; break ; default : ptr_hbe_txposer -> synth_cos_tab = ( FLOAT32 * ) ixheaacd_synth_cos_table_kl_4 ; ptr_hbe_txposer -> analy_cos_sin_tab = ( FLOAT32 * ) ixheaacd_analy_cos_sin_table_kl_8 ; <S2SV_StartBug> ixheaacd_real_synth_fft = & ixheaacd_real_synth_fft_p2 ; <S2SV_EndBug> <S2SV_StartBug> ixheaacd_cmplx_anal_fft = & ixheaacd_cmplx_anal_fft_p2 ; <S2SV_EndBug> } ptr_hbe_txposer -> synth_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> analy_buf , 0 , 640 * sizeof ( FLOAT32 ) ) ; synth_size = 2 * ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> analy_wind_coeff = ixheaacd_map_prot_filter ( synth_size ) ; memset ( ptr_hbe_txposer -> x_over_qmf , 0 , MAX_NUM_PATCHES * sizeof ( WORD32 ) ) ; sfb = 0 ; if ( upsamp_4_flag ) { stop_patch = MAX_NUM_PATCHES ; ptr_hbe_txposer -> max_stretch = MAX_STRETCH ; } else { stop_patch = MAX_STRETCH ; } for ( patch = 1 ; patch <= stop_patch ; patch ++ ) { while ( sfb <= p_num_sfb [ LOW ] && p_freq_band_tab [ LOW ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; if ( sfb <= p_num_sfb [ LOW ] ) { if ( ( patch * ptr_hbe_txposer -> start_band - p_freq_band_tab [ LOW ] [ sfb - 1 ] ) <= 3 ) { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ LOW ] [ sfb - 1 ] ; } else { WORD32 sfb = 0 ; while ( sfb <= p_num_sfb [ HIGH ] && p_freq_band_tab [ HIGH ] [ sfb ] <= patch * ptr_hbe_txposer -> start_band ) sfb ++ ; ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = p_freq_band_tab [ HIGH ] [ sfb - 1 ] ; } } else { ptr_hbe_txposer -> x_over_qmf [ patch - 1 ] = ptr_hbe_txposer -> end_band ; ptr_hbe_txposer -> max_stretch = min ( patch , MAX_STRETCH ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } } if ( ptr_hbe_txposer -> k_start < 0 ) { return - 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-190 SQLITE_PRIVATE With * sqlite3WithAdd ( Parse * pParse , With * pWith , Token * pName , ExprList * pArglist , Select * pQuery ) { sqlite3 * db = pParse -> db ; With * pNew ; char * zName ; zName = sqlite3NameFromToken ( pParse -> db , pName ) ; if ( zName && pWith ) { int i ; for ( i = 0 ; i < pWith -> nCte ; i ++ ) { if ( sqlite3StrICmp ( zName , pWith -> a [ i ] . zName ) == 0 ) { sqlite3ErrorMsg ( pParse , "duplicate<S2SV_blank>WITH<S2SV_blank>table<S2SV_blank>name:<S2SV_blank>%s" , zName ) ; } } } if ( pWith ) { <S2SV_StartBug> int nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ; <S2SV_EndBug> pNew = sqlite3DbRealloc ( db , pWith , nByte ) ; } else { pNew = sqlite3DbMallocZero ( db , sizeof ( * pWith ) ) ; } assert ( ( pNew != 0 && zName != 0 ) || db -> mallocFailed ) ; if ( db -> mallocFailed ) { sqlite3ExprListDelete ( db , pArglist ) ; sqlite3SelectDelete ( db , pQuery ) ; sqlite3DbFree ( db , zName ) ; pNew = pWith ; } else { pNew -> a [ pNew -> nCte ] . pSelect = pQuery ; pNew -> a [ pNew -> nCte ] . pCols = pArglist ; pNew -> a [ pNew -> nCte ] . zName = zName ; pNew -> a [ pNew -> nCte ] . zCteErr = 0 ; pNew -> nCte ++ ; } return pNew ; }
CWE-119 static int iscsi_add_notunderstood_response ( char * key , char * value , struct iscsi_param_list * param_list ) { struct iscsi_extra_response * extra_response ; if ( strlen ( value ) > VALUE_MAXLEN ) { pr_err ( "Value<S2SV_blank>for<S2SV_blank>notunderstood<S2SV_blank>key<S2SV_blank>\\"%s\\"<S2SV_blank>exceeds<S2SV_blank>%d," "<S2SV_blank>protocol<S2SV_blank>error.\\n" , key , VALUE_MAXLEN ) ; return - 1 ; } extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ) ; if ( ! extra_response ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for" "<S2SV_blank>struct<S2SV_blank>iscsi_extra_response.\\n" ) ; return - 1 ; } INIT_LIST_HEAD ( & extra_response -> er_list ) ; <S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> strncpy ( extra_response -> value , NOTUNDERSTOOD , <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ; return 0 ; }
CWE-416 static struct ucma_multicast * ucma_alloc_multicast ( struct ucma_context * ctx ) { struct ucma_multicast * mc ; mc = kzalloc ( sizeof ( * mc ) , GFP_KERNEL ) ; if ( ! mc ) return NULL ; mutex_lock ( & mut ) ; <S2SV_StartBug> mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <S2SV_EndBug> mutex_unlock ( & mut ) ; if ( mc -> id < 0 ) goto error ; mc -> ctx = ctx ; list_add_tail ( & mc -> list , & ctx -> mc_list ) ; return mc ; error : kfree ( mc ) ; return NULL ; }
CWE-000 int fpm_stdio_init_child ( struct fpm_worker_pool_s * wp ) { # ifdef HAVE_SYSLOG_H if ( fpm_globals . error_log_fd == ZLOG_SYSLOG ) { closelog ( ) ; } else # endif if ( fpm_globals . error_log_fd > 0 ) { close ( fpm_globals . error_log_fd ) ; } fpm_globals . error_log_fd = - 1 ; zlog_set_fd ( - 1 ) ; <S2SV_StartBug> if ( wp -> listening_socket != STDIN_FILENO ) { <S2SV_EndBug> if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) { zlog ( ZLOG_SYSERROR , "failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>child<S2SV_blank>stdio:<S2SV_blank>dup2()" ) ; return - 1 ; } } return 0 ; }
CWE-119 static void show_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; <S2SV_StartBug> finish_object ( obj , path , component , cb_data ) ; <S2SV_EndBug> if ( info -> flags & REV_LIST_QUIET ) return ; <S2SV_StartBug> show_object_with_name ( stdout , obj , path , component ) ; <S2SV_EndBug> }
CWE-20 static void * etm_setup_aux ( int event_cpu , void * * pages , int nr_pages , bool overwrite ) { int cpu ; cpumask_t * mask ; struct coresight_device * sink ; struct etm_event_data * event_data = NULL ; event_data = alloc_event_data ( event_cpu ) ; if ( ! event_data ) return NULL ; sink = coresight_get_enabled_sink ( true ) ; if ( ! sink ) goto err ; INIT_WORK ( & event_data -> work , free_event_data ) ; mask = & event_data -> mask ; for_each_cpu ( cpu , mask ) { struct coresight_device * csdev ; csdev = per_cpu ( csdev_src , cpu ) ; if ( ! csdev ) goto err ; event_data -> path [ cpu ] = coresight_build_path ( csdev , sink ) ; if ( IS_ERR ( event_data -> path [ cpu ] ) ) goto err ; } if ( ! sink_ops ( sink ) -> alloc_buffer ) goto err ; <S2SV_StartBug> event_data -> snk_config = <S2SV_EndBug> sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ; if ( ! event_data -> snk_config ) goto err ; out : return event_data ; err : etm_free_aux ( event_data ) ; event_data = NULL ; goto out ; }
CWE-119 static void read_ref_frames ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_StartBug> vp9_reader * r , <S2SV_EndBug> int segment_id , MV_REFERENCE_FRAME ref_frame [ 2 ] ) { <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> FRAME_COUNTS * const counts = & cm -> counts ; if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_StartBug> ref_frame [ 0 ] = ( MV_REFERENCE_FRAME ) vp9_get_segdata ( & cm -> seg , segment_id , <S2SV_EndBug> SEG_LVL_REF_FRAME ) ; ref_frame [ 1 ] = NONE ; } else { const REFERENCE_MODE mode = read_block_reference_mode ( cm , xd , r ) ; if ( mode == COMPOUND_REFERENCE ) { const int idx = cm -> ref_frame_sign_bias [ cm -> comp_fixed_ref ] ; const int ctx = vp9_get_pred_context_comp_ref_p ( cm , xd ) ; <S2SV_StartBug> const int bit = vp9_read ( r , fc -> comp_ref_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ counts -> comp_ref [ ctx ] [ bit ] ; ref_frame [ idx ] = cm -> comp_fixed_ref ; ref_frame [ ! idx ] = cm -> comp_var_ref [ bit ] ; } else if ( mode == SINGLE_REFERENCE ) { const int ctx0 = vp9_get_pred_context_single_ref_p1 ( xd ) ; <S2SV_StartBug> const int bit0 = vp9_read ( r , fc -> single_ref_prob [ ctx0 ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ counts -> single_ref [ ctx0 ] [ 0 ] [ bit0 ] ; if ( bit0 ) { const int ctx1 = vp9_get_pred_context_single_ref_p2 ( xd ) ; <S2SV_StartBug> const int bit1 = vp9_read ( r , fc -> single_ref_prob [ ctx1 ] [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ counts -> single_ref [ ctx1 ] [ 1 ] [ bit1 ] ; ref_frame [ 0 ] = bit1 ? ALTREF_FRAME : GOLDEN_FRAME ; } else { ref_frame [ 0 ] = LAST_FRAME ; } ref_frame [ 1 ] = NONE ; } else { assert ( 0 && "Invalid<S2SV_blank>prediction<S2SV_blank>mode." ) ; } } }
CWE-189 struct timespec ns_to_timespec ( const s64 nsec ) { <S2SV_StartBug> struct timespec ts ; <S2SV_EndBug> if ( ! nsec ) return ( struct timespec ) { 0 , 0 } ; <S2SV_StartBug> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( nsec < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <S2SV_EndBug> return ts ; }
CWE-119 static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ; <S2SV_StartBug> if ( ! stream ) <S2SV_EndBug> <S2SV_StartBug> fatal ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream." ) ; <S2SV_EndBug> if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ; <S2SV_StartBug> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ; <S2SV_StartBug> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; <S2SV_EndBug> <S2SV_StartBug> stream -> config . write_webm = 1 ; <S2SV_EndBug> # if CONFIG_WEBM_IO <S2SV_StartBug> stream -> ebml . last_pts_ms = - 1 ; <S2SV_EndBug> # endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }
CWE-284 void btif_hl_select_monitor_callback ( fd_set * p_cur_set , fd_set * p_org_set ) { UNUSED ( p_org_set ) ; BTIF_TRACE_DEBUG ( "entering<S2SV_blank>%s" , __FUNCTION__ ) ; for ( const list_node_t * node = list_begin ( soc_queue ) ; node != list_end ( soc_queue ) ; node = list_next ( node ) ) { btif_hl_soc_cb_t * p_scb = list_node ( node ) ; if ( btif_hl_get_socket_state ( p_scb ) == BTIF_HL_SOC_STATE_W4_READ ) { if ( FD_ISSET ( p_scb -> socket_id [ 1 ] , p_cur_set ) ) { BTIF_TRACE_DEBUG ( "read<S2SV_blank>data<S2SV_blank>state=<S2SV_blank>BTIF_HL_SOC_STATE_W4_READ" ) ; btif_hl_mdl_cb_t * p_dcb = BTIF_HL_GET_MDL_CB_PTR ( p_scb -> app_idx , p_scb -> mcl_idx , p_scb -> mdl_idx ) ; assert ( p_dcb != NULL ) ; if ( p_dcb -> p_tx_pkt ) { BTIF_TRACE_ERROR ( "Rcv<S2SV_blank>new<S2SV_blank>pkt<S2SV_blank>but<S2SV_blank>the<S2SV_blank>last<S2SV_blank>pkt<S2SV_blank>is<S2SV_blank>still<S2SV_blank>not<S2SV_blank>been" "<S2SV_blank><S2SV_blank>sent<S2SV_blank>tx_size=%d" , p_dcb -> tx_size ) ; btif_hl_free_buf ( ( void * * ) & p_dcb -> p_tx_pkt ) ; } p_dcb -> p_tx_pkt = btif_hl_get_buf ( p_dcb -> mtu ) ; if ( p_dcb ) { <S2SV_StartBug> int r = ( int ) recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , <S2SV_EndBug> <S2SV_StartBug> p_dcb -> mtu , MSG_DONTWAIT ) ; <S2SV_EndBug> if ( r > 0 ) { BTIF_TRACE_DEBUG ( "btif_hl_select_monitor_callback<S2SV_blank>send<S2SV_blank>data<S2SV_blank>r<S2SV_blank>=%d" , r ) ; p_dcb -> tx_size = r ; BTIF_TRACE_DEBUG ( "btif_hl_select_monitor_callback<S2SV_blank>send<S2SV_blank>data<S2SV_blank>tx_size=%d" , p_dcb -> tx_size ) ; BTA_HlSendData ( p_dcb -> mdl_handle , p_dcb -> tx_size ) ; } else { BTIF_TRACE_DEBUG ( "btif_hl_select_monitor_callback<S2SV_blank>receive<S2SV_blank>failed<S2SV_blank>r=%d" , r ) ; BTA_HlDchClose ( p_dcb -> mdl_handle ) ; } } } } } if ( list_is_empty ( soc_queue ) ) BTIF_TRACE_DEBUG ( "btif_hl_select_monitor_queue<S2SV_blank>is<S2SV_blank>empty" ) ; BTIF_TRACE_DEBUG ( "leaving<S2SV_blank>%s" , __FUNCTION__ ) ; }
CWE-119 TEE_Result syscall_asymm_operate ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * src_data , size_t src_len , void * dst_data , uint64_t * dst_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; uint64_t dlen64 ; size_t dlen ; struct tee_obj * o ; void * label = NULL ; size_t label_len = 0 ; size_t n ; int salt_len ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) src_data , src_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_svc_copy_from_user ( & dlen64 , dst_len , sizeof ( dlen64 ) ) ; if ( res != TEE_SUCCESS ) return res ; dlen = dlen64 ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) dst_data , dlen ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_GENERIC ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_RSA_NOPAD : if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsanopad_encrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsanopad_decrypt ( o -> attr , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_GENERIC ; } break ; case TEE_ALG_RSAES_PKCS1_V1_5 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384 : case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512 : for ( n = 0 ; n < num_params ; n ++ ) { if ( params [ n ] . attributeID == TEE_ATTR_RSA_OAEP_LABEL ) { label = params [ n ] . content . ref . buffer ; label_len = params [ n ] . content . ref . length ; break ; } } if ( cs -> mode == TEE_MODE_ENCRYPT ) { res = crypto_acipher_rsaes_encrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else if ( cs -> mode == TEE_MODE_DECRYPT ) { res = crypto_acipher_rsaes_decrypt ( cs -> algo , o -> attr , label , label_len , src_data , src_len , dst_data , & dlen ) ; } else { res = TEE_ERROR_BAD_PARAMETERS ; } break ; # if defined ( CFG_CRYPTO_RSASSA_NA1 ) case TEE_ALG_RSASSA_PKCS1_V1_5 : # endif case TEE_ALG_RSASSA_PKCS1_V1_5_MD5 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 : case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 : case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 : if ( cs -> mode != TEE_MODE_SIGN ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , src_len ) ; res = crypto_acipher_rsassa_sign ( cs -> algo , o -> attr , salt_len , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_DSA_SHA1 : case TEE_ALG_DSA_SHA224 : case TEE_ALG_DSA_SHA256 : res = crypto_acipher_dsa_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; case TEE_ALG_ECDSA_P192 : case TEE_ALG_ECDSA_P224 : case TEE_ALG_ECDSA_P256 : case TEE_ALG_ECDSA_P384 : case TEE_ALG_ECDSA_P521 : res = crypto_acipher_ecc_sign ( cs -> algo , o -> attr , src_data , src_len , dst_data , & dlen ) ; break ; default : res = TEE_ERROR_BAD_PARAMETERS ; break ; } out : free ( params ) ; if ( res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER ) { TEE_Result res2 ; dlen64 = dlen ; res2 = tee_svc_copy_to_user ( dst_len , & dlen64 , sizeof ( * dst_len ) ) ; if ( res2 != TEE_SUCCESS ) return res2 ; } return res ; }
CWE-20 static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , "unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>" "out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; <S2SV_StartBug> return headcount ; <S2SV_EndBug> err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }
CWE-125 static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { <S2SV_StartBug> OPCODE_DESC * opcode_desc ; <S2SV_EndBug> ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , "" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op -> jump = UT64_MAX ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> nopcode = 1 ; op -> cycles = 1 ; op -> size = 2 ; r_strbuf_set ( & op -> esil , "1,$" ) ; return NULL ; }
CWE-119 void vp8_plane_add_noise_c ( unsigned char * Start , char * noise , char blackclamp [ 16 ] , char whiteclamp [ 16 ] , char bothclamp [ 16 ] , unsigned int Width , unsigned int Height , int Pitch ) { <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> for ( i = 0 ; i < Height ; i ++ ) { unsigned char * Pos = Start + i * Pitch ; char * Ref = ( char * ) ( noise + ( rand ( ) & 0xff ) ) ; for ( j = 0 ; j < Width ; j ++ ) { if ( Pos [ j ] < blackclamp [ 0 ] ) Pos [ j ] = blackclamp [ 0 ] ; if ( Pos [ j ] > 255 + whiteclamp [ 0 ] ) Pos [ j ] = 255 + whiteclamp [ 0 ] ; Pos [ j ] += Ref [ j ] ; } } }
CWE-264 static int do_new_mount ( struct path * path , const char * fstype , int flags , int mnt_flags , const char * name , void * data ) { struct file_system_type * type ; struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct vfsmount * mnt ; int err ; if ( ! fstype ) return - EINVAL ; type = get_fs_type ( fstype ) ; if ( ! type ) return - ENODEV ; if ( user_ns != & init_user_ns ) { if ( ! ( type -> fs_flags & FS_USERNS_MOUNT ) ) { put_filesystem ( type ) ; return - EPERM ; } if ( ! ( type -> fs_flags & FS_USERNS_DEV_MOUNT ) ) { flags |= MS_NODEV ; <S2SV_StartBug> mnt_flags |= MNT_NODEV ; <S2SV_EndBug> } } mnt = vfs_kern_mount ( type , flags , name , data ) ; if ( ! IS_ERR ( mnt ) && ( type -> fs_flags & FS_HAS_SUBTYPE ) && ! mnt -> mnt_sb -> s_subtype ) mnt = fs_set_subtype ( mnt , fstype ) ; put_filesystem ( type ) ; if ( IS_ERR ( mnt ) ) return PTR_ERR ( mnt ) ; err = do_add_mount ( real_mount ( mnt ) , path , mnt_flags ) ; if ( err ) mntput ( mnt ) ; return err ; }
CWE-119 <S2SV_StartBug> static void send ( node_t * node , node_t * child , byte * fout ) { <S2SV_EndBug> if ( node -> parent ) { <S2SV_StartBug> send ( node -> parent , node , fout ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( child ) { <S2SV_EndBug> if ( node -> right == child ) { add_bit ( 1 , fout ) ; } else { add_bit ( 0 , fout ) ; } } }
CWE-264 static int rd_build_device_space ( struct rd_dev * rd_dev ) { <S2SV_StartBug> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; <S2SV_EndBug> u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / sizeof ( struct scatterlist ) ) ; <S2SV_StartBug> struct rd_dev_sg_table * sg_table ; <S2SV_EndBug> struct page * pg ; struct scatterlist * sg ; if ( rd_dev -> rd_page_count <= 0 ) { pr_err ( "Illegal<S2SV_blank>page<S2SV_blank>count:<S2SV_blank>%u<S2SV_blank>for<S2SV_blank>Ramdisk<S2SV_blank>device\\n" , rd_dev -> rd_page_count ) ; return - EINVAL ; } if ( rd_dev -> rd_flags & RDF_NULLIO ) return 0 ; total_sg_needed = rd_dev -> rd_page_count ; sg_tables = ( total_sg_needed / max_sg_per_table ) + 1 ; sg_table = kzalloc ( sg_tables * sizeof ( struct rd_dev_sg_table ) , GFP_KERNEL ) ; if ( ! sg_table ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Ramdisk" "<S2SV_blank>scatterlist<S2SV_blank>tables\\n" ) ; return - ENOMEM ; } rd_dev -> sg_table_array = sg_table ; rd_dev -> sg_table_count = sg_tables ; <S2SV_StartBug> while ( total_sg_needed ) { <S2SV_EndBug> sg_per_table = ( total_sg_needed > max_sg_per_table ) ? max_sg_per_table : total_sg_needed ; sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , GFP_KERNEL ) ; if ( ! sg ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist<S2SV_blank>array" "<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev\\n" ) ; return - ENOMEM ; } sg_init_table ( sg , sg_per_table ) ; sg_table [ i ] . sg_table = sg ; sg_table [ i ] . rd_sg_count = sg_per_table ; sg_table [ i ] . page_start_offset = page_offset ; sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) - 1 ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = alloc_pages ( GFP_KERNEL , 0 ) ; if ( ! pg ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist" "<S2SV_blank>pages<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev_sg_table\\n" ) ; return - ENOMEM ; } sg_assign_page ( & sg [ j ] , pg ) ; sg [ j ] . length = PAGE_SIZE ; } page_offset += sg_per_table ; total_sg_needed -= sg_per_table ; } pr_debug ( "CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Built<S2SV_blank>Ramdisk<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>space<S2SV_blank>of" "<S2SV_blank>%u<S2SV_blank>pages<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>tables\\n" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , rd_dev -> rd_page_count , rd_dev -> sg_table_count ) ; return 0 ; }
CWE-119 <S2SV_StartBug> void vp9_iht16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> int tx_type ) { int i , j ; <S2SV_StartBug> int16_t out [ 16 * 16 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = out ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 16 ] , temp_out [ 16 ] ; <S2SV_EndBug> const transform_2d ht = IHT_16 [ tx_type ] ; for ( i = 0 ; i < 16 ; ++ i ) { ht . rows ( input , outptr ) ; input += 16 ; outptr += 16 ; } for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = out [ j * 16 + i ] ; ht . cols ( temp_in , temp_out ) ; <S2SV_StartBug> for ( j = 0 ; j < 16 ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) <S2SV_EndBug> <S2SV_StartBug> + dest [ j * stride + i ] ) ; <S2SV_EndBug> } }
CWE-000 int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; <S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , "w" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , "failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , "%u" , val ) ; fclose ( fp ) ; return 0 ; }
CWE-264 static struct dentry * aio_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { static const struct dentry_operations ops = { . d_dname = simple_dname , } ; <S2SV_StartBug> return mount_pseudo ( fs_type , "aio:" , NULL , & ops , AIO_RING_MAGIC ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static void vmx_complete_atomic_exit ( struct vcpu_vmx * vmx ) { u32 exit_intr_info ; if ( ! ( vmx -> exit_reason == EXIT_REASON_MCE_DURING_VMENTRY || vmx -> exit_reason == EXIT_REASON_EXCEPTION_NMI ) ) return ; vmx -> exit_intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; exit_intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( exit_intr_info ) ) kvm_machine_check ( ) ; <S2SV_StartBug> if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR && <S2SV_EndBug> ( exit_intr_info & INTR_INFO_VALID_MASK ) ) { kvm_before_handle_nmi ( & vmx -> vcpu ) ; asm ( "int<S2SV_blank>$2" ) ; kvm_after_handle_nmi ( & vmx -> vcpu ) ; } }
CWE-119 int ParseDateTime ( char * timestr , char * lowstr , char * * field , int * ftype , int * numfields , char * * endstr ) { int nf = 0 ; char * lp = lowstr ; * endstr = timestr ; while ( * ( * endstr ) != '\\0' ) { <S2SV_StartBug> field [ nf ] = lp ; <S2SV_EndBug> if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; if ( * ( * endstr ) == ':' ) { ftype [ nf ] = DTK_TIME ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == ':' ) || ( * ( * endstr ) == '.' ) ) * lp ++ = * ( * endstr ) ++ ; } else if ( * ( * endstr ) == '-' || * ( * endstr ) == '/' || * ( * endstr ) == '.' ) { char * dp = ( * endstr ) ; * lp ++ = * ( * endstr ) ++ ; if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = ( * dp == '.' ) ? DTK_NUMBER : DTK_DATE ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; if ( * ( * endstr ) == * dp ) { ftype [ nf ] = DTK_DATE ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == * dp ) ) * lp ++ = * ( * endstr ) ++ ; } } else { ftype [ nf ] = DTK_DATE ; while ( isalnum ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == * dp ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; } } else ftype [ nf ] = DTK_NUMBER ; } else if ( * ( * endstr ) == '.' ) { * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; ftype [ nf ] = DTK_NUMBER ; } else if ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_STRING ; * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; while ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; if ( * ( * endstr ) == '-' || * ( * endstr ) == '/' || * ( * endstr ) == '.' ) { char * dp = ( * endstr ) ; ftype [ nf ] = DTK_DATE ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || * ( * endstr ) == * dp ) * lp ++ = * ( * endstr ) ++ ; } } else if ( isspace ( ( unsigned char ) * ( * endstr ) ) ) { ( * endstr ) ++ ; continue ; } else if ( * ( * endstr ) == '+' || * ( * endstr ) == '-' ) { * lp ++ = * ( * endstr ) ++ ; while ( isspace ( ( unsigned char ) * ( * endstr ) ) ) ( * endstr ) ++ ; if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_TZ ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == ':' ) || ( * ( * endstr ) == '.' ) ) * lp ++ = * ( * endstr ) ++ ; } else if ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = DTK_SPECIAL ; * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; while ( isalpha ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = pg_tolower ( ( unsigned char ) * ( * endstr ) ++ ) ; } else return - 1 ; } else if ( ispunct ( ( unsigned char ) * ( * endstr ) ) ) { ( * endstr ) ++ ; continue ; } else return - 1 ; * lp ++ = '\\0' ; nf ++ ; <S2SV_StartBug> if ( nf > MAXDATEFIELDS ) <S2SV_EndBug> return - 1 ; } * numfields = nf ; return 0 ; }
CWE-125 static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , "Missing<S2SV_blank>descriptor<S2SV_blank>data\\n" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , "Zero<S2SV_blank>length<S2SV_blank>descriptor\\n" ) ; return NULL ; } <S2SV_StartBug> while ( buflen > 0 ) { <S2SV_EndBug> union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , "Found<S2SV_blank>union<S2SV_blank>header\\n" ) ; <S2SV_StartBug> return union_desc ; <S2SV_EndBug> } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , "Missing<S2SV_blank>CDC<S2SV_blank>union<S2SV_blank>descriptor\\n" ) ; return NULL ; }
CWE-000 static krb5_error_code process_db_args ( krb5_context context , char * * db_args , xargs_t * xargs , OPERATION optype ) { int i = 0 ; krb5_error_code st = 0 ; char * arg = NULL , * arg_val = NULL ; char * * dptr = NULL ; unsigned int arg_val_len = 0 ; if ( db_args ) { for ( i = 0 ; db_args [ i ] ; ++ i ) { arg = strtok_r ( db_args [ i ] , "=" , & arg_val ) ; <S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug> dptr = & xargs -> tktpolicydn ; } else { if ( strcmp ( arg , USERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported" ) , arg ) ; goto cleanup ; } dptr = & xargs -> dn ; } else if ( strcmp ( arg , CONTAINERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported" ) , arg ) ; goto cleanup ; } dptr = & xargs -> containerdn ; } else if ( strcmp ( arg , LINKDN_ARG ) == 0 ) { if ( xargs -> dn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported" ) , arg ) ; goto cleanup ; } dptr = & xargs -> linkdn ; } else { st = EINVAL ; k5_setmsg ( context , st , _ ( "unknown<S2SV_blank>option:<S2SV_blank>%s" ) , arg ) ; goto cleanup ; } xargs -> dn_from_kbd = TRUE ; if ( arg_val == NULL || strlen ( arg_val ) == 0 ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing" ) , arg ) ; goto cleanup ; } } if ( arg_val == NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing" ) , arg ) ; goto cleanup ; } arg_val_len = strlen ( arg_val ) + 1 ; if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { if ( ( st = krb5_ldap_name_to_policydn ( context , arg_val , dptr ) ) != 0 ) goto cleanup ; } else { * dptr = k5memdup ( arg_val , arg_val_len , & st ) ; if ( * dptr == NULL ) goto cleanup ; } } } cleanup : return st ; }
CWE-362 int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ; <S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out : <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> return ret ; }
CWE-284 static __be32 nfsacld_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; dprintk ( "nfsd:<S2SV_blank>SETACL(2acl)<S2SV_blank><S2SV_blank><S2SV_blank>%s\\n" , SVCFH_fmt ( & argp -> fh ) ) ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ; <S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> error = - EOPNOTSUPP ; goto out_errno ; <S2SV_StartBug> } <S2SV_EndBug> error = fh_want_write ( fh ) ; if ( error ) goto out_errno ; <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> if ( error ) goto out_drop_write ; <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; if ( error ) goto out_drop_write ; fh_drop_write ( fh ) ; nfserr = fh_getattr ( fh , & resp -> stat ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; return nfserr ; <S2SV_StartBug> out_drop_write : <S2SV_EndBug> fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; goto out ; }
CWE-119 static int rd_inter4x4_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel ) <S2SV_StartBug> { <S2SV_EndBug> vp8_build_inter4x4_predictors_mbuv ( & x -> e_mbd ) ; vp8_subtract_mbuv ( x -> src_diff , x -> src . u_buffer , x -> src . v_buffer , x -> src . uv_stride , & x -> e_mbd . predictor [ 256 ] , & x -> e_mbd . predictor [ 320 ] , 8 ) ; vp8_transform_mbuv ( x ) ; vp8_quantize_mbuv ( x ) ; * rate = rd_cost_mbuv ( x ) ; * distortion = vp8_mbuverror ( x ) / 4 ; return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ; }
CWE-284 int btsock_thread_wakeup ( int h ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( "invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( "thread<S2SV_blank>handle:%d,<S2SV_blank>cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created" , h ) ; return FALSE ; } sock_cmd_t cmd = { CMD_WAKEUP , 0 , 0 , 0 , 0 } ; <S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> }
CWE-119 static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; <S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n" , s -> cdx [ i ] , s -> cdy [ i ] ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>" "components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>" "cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } s -> avctx -> bits_per_raw_sample = s -> precision ; return 0 ; }
CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; <S2SV_StartBug> set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_EndBug> set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm , INTERCEPT_STGI ) ; set_intercept ( svm , INTERCEPT_CLGI ) ; set_intercept ( svm , INTERCEPT_SKINIT ) ; set_intercept ( svm , INTERCEPT_WBINVD ) ; set_intercept ( svm , INTERCEPT_MONITOR ) ; set_intercept ( svm , INTERCEPT_MWAIT ) ; set_intercept ( svm , INTERCEPT_XSETBV ) ; control -> iopm_base_pa = iopm_base ; control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; control -> int_ctl = V_INTR_MASKING_MASK ; init_seg ( & save -> es ) ; init_seg ( & save -> ss ) ; init_seg ( & save -> ds ) ; init_seg ( & save -> fs ) ; init_seg ( & save -> gs ) ; save -> cs . selector = 0xf000 ; save -> cs . base = 0xffff0000 ; save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; save -> cs . limit = 0xffff ; save -> gdtr . limit = 0xffff ; save -> idtr . limit = 0xffff ; init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; svm_set_efer ( & svm -> vcpu , 0 ) ; save -> dr6 = 0xffff0ff0 ; kvm_set_rflags ( & svm -> vcpu , 2 ) ; save -> rip = 0x0000fff0 ; svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; kvm_mmu_reset_context ( & svm -> vcpu ) ; save -> cr4 = X86_CR4_PAE ; if ( npt_enabled ) { control -> nested_ctl = 1 ; clr_intercept ( svm , INTERCEPT_INVLPG ) ; clr_exception_intercept ( svm , PF_VECTOR ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; save -> g_pat = svm -> vcpu . arch . pat ; save -> cr3 = 0 ; save -> cr4 = 0 ; } svm -> asid_generation = 0 ; svm -> nested . vmcb = 0 ; svm -> vcpu . arch . hflags = 0 ; if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { control -> pause_filter_count = 3000 ; set_intercept ( svm , INTERCEPT_PAUSE ) ; } mark_all_dirty ( svm -> vmcb ) ; enable_gif ( svm ) ; }
CWE-284 static int http_connect ( http_subtransport * t ) { int error ; char * proxy_url ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , "git_stream" ) ; if ( git_stream_supports_proxy ( t -> io ) && ! git_remote__get_http_proxy ( t -> owner -> owner , ! ! t -> connection_data . use_ssl , & proxy_url ) ) { error = git_stream_set_proxy ( t -> io , proxy_url ) ; git__free ( proxy_url ) ; if ( error < 0 ) return error ; } error = git_stream_connect ( t -> io ) ; # if defined ( GIT_OPENSSL ) || defined ( GIT_SECURE_TRANSPORT ) || defined ( GIT_CURL ) if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; <S2SV_StartBug> int is_valid ; <S2SV_EndBug> if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert , is_valid , t -> connection_data . host , t -> owner -> message_cb_payload ) ; if ( error < 0 ) { if ( ! giterr_last ( ) ) giterr_set ( GITERR_NET , "user<S2SV_blank>cancelled<S2SV_blank>certificate<S2SV_blank>check" ) ; return error ; } } # endif if ( error < 0 ) return error ; t -> connected = 1 ; return 0 ; }
CWE-119 <S2SV_StartBug> static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index > 0 ) return ; } <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , <S2SV_EndBug> output_enabled ) ; <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> if ( output_enabled ) { <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug> ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; } }
CWE-119 static int zerocopy_sg_from_iovec ( struct sk_buff * skb , const struct iovec * from , int offset , size_t count ) { int len = iov_length ( from , count ) - offset ; int copy = skb_headlen ( skb ) ; int size , offset1 = 0 ; int i = 0 ; while ( count && ( offset >= from -> iov_len ) ) { offset -= from -> iov_len ; ++ from ; -- count ; } while ( count && ( copy > 0 ) ) { size = min_t ( unsigned int , copy , from -> iov_len - offset ) ; if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ; if ( copy > size ) { ++ from ; -- count ; offset = 0 ; } else offset += size ; copy -= size ; offset1 += size ; } if ( len == offset1 ) return 0 ; while ( count -- ) { struct page * page [ MAX_SKB_FRAGS ] ; int num_pages ; unsigned long base ; unsigned long truesize ; len = from -> iov_len - offset ; if ( ! len ) { offset = 0 ; ++ from ; continue ; } base = ( unsigned long ) from -> iov_base + offset ; size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ; <S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug> ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) { for ( i = 0 ; i < num_pages ; i ++ ) put_page ( page [ i ] ) ; return - EFAULT ; } truesize = size * PAGE_SIZE ; skb -> data_len += len ; skb -> len += len ; skb -> truesize += truesize ; atomic_add ( truesize , & skb -> sk -> sk_wmem_alloc ) ; while ( len ) { int off = base & ~ PAGE_MASK ; int size = min_t ( int , len , PAGE_SIZE - off ) ; __skb_fill_page_desc ( skb , i , page [ i ] , off , size ) ; skb_shinfo ( skb ) -> nr_frags ++ ; base += size ; len -= size ; i ++ ; } offset = 0 ; ++ from ; } return 0 ; }
CWE-264 static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; int res , ret ; if ( uaddr == uaddr2 ) return - EINVAL ; if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; RB_CLEAR_NODE ( & rt_waiter . pi_tree_entry ) ; RB_CLEAR_NODE ( & rt_waiter . tree_entry ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; <S2SV_StartBug> futex_wait_queue_me ( hb , & q , to ) ; <S2SV_EndBug> spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }
CWE-119 static void scsi_write_data ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; uint32_t n ; assert ( r -> req . aiocb == NULL ) ; if ( r -> req . cmd . mode != SCSI_XFER_TO_DEV ) { DPRINTF ( "Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\n" ) ; scsi_write_complete ( r , - EINVAL ) ; return ; } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> if ( n ) { if ( s -> tray_open ) { scsi_write_complete ( r , - ENOMEDIUM ) ; } <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ; r -> req . aiocb = bdrv_aio_writev ( s -> bs , r -> sector , & r -> qiov , n , scsi_write_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_write_complete ( r , - ENOMEM ) ; } } else { scsi_write_complete ( r , 0 ) ; } }
CWE-787 <S2SV_StartBug> static void nsc_decode ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> BYTE shift = context -> ColorLossLevel - 1 ; <S2SV_EndBug> <S2SV_StartBug> BYTE * bmpdata = context -> BitmapData ; <S2SV_EndBug> for ( y = 0 ; y < context -> height ; y ++ ) { const BYTE * yplane ; const BYTE * coplane ; const BYTE * cgplane ; const BYTE * aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; if ( context -> ChromaSubsamplingLevel ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + ( y >> 1 ) * ( rw >> 1 ) ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + ( y >> 1 ) * ( rw >> 1 ) ; } else { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * context -> width ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; } for ( x = 0 ; x < context -> width ; x ++ ) { INT16 y_val = ( INT16 ) * yplane ; INT16 co_val = ( INT16 ) ( INT8 ) ( * coplane << shift ) ; INT16 cg_val = ( INT16 ) ( INT8 ) ( * cgplane << shift ) ; INT16 r_val = y_val + co_val - cg_val ; INT16 g_val = y_val + cg_val ; INT16 b_val = y_val - co_val - cg_val ; <S2SV_StartBug> * bmpdata ++ = MINMAX ( b_val , 0 , 0xFF ) ; <S2SV_EndBug> * bmpdata ++ = MINMAX ( g_val , 0 , 0xFF ) ; * bmpdata ++ = MINMAX ( r_val , 0 , 0xFF ) ; * bmpdata ++ = * aplane ; yplane ++ ; coplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; cgplane += ( context -> ChromaSubsamplingLevel ? x % 2 : 1 ) ; aplane ++ ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 static int lldp_private_8023_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Subtype<S2SV_blank>(%u)" , tok2str ( lldp_8023_subtype_values , "unknown" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8023_SUBTYPE_MACPHY : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>autonegotiation<S2SV_blank>[%s]<S2SV_blank>(0x%02x)" , bittok2str ( lldp_8023_autonegotiation_values , "none" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>PMD<S2SV_blank>autoneg<S2SV_blank>capability<S2SV_blank>[%s]<S2SV_blank>(0x%04x)" , bittok2str ( lldp_pmd_capability_values , "unknown" , EXTRACT_16BITS ( tptr + 5 ) ) , EXTRACT_16BITS ( tptr + 5 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MAU<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>(0x%04x)" , tok2str ( lldp_mau_types_values , "unknown" , EXTRACT_16BITS ( tptr + 7 ) ) , EXTRACT_16BITS ( tptr + 7 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MDI<S2SV_blank>power<S2SV_blank>support<S2SV_blank>[%s],<S2SV_blank>power<S2SV_blank>pair<S2SV_blank>%s,<S2SV_blank>power<S2SV_blank>class<S2SV_blank>%s" , bittok2str ( lldp_mdi_values , "none" , * ( tptr + 4 ) ) , tok2str ( lldp_mdi_power_pairs_values , "unknown" , * ( tptr + 5 ) ) , tok2str ( lldp_mdi_power_class_values , "unknown" , * ( tptr + 6 ) ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>aggregation<S2SV_blank>status<S2SV_blank>[%s],<S2SV_blank>aggregation<S2SV_blank>port<S2SV_blank>ID<S2SV_blank>%u" , bittok2str ( lldp_aggregation_values , "none" , * ( tptr + 4 ) ) , EXTRACT_32BITS ( tptr + 5 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MTU : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MTU<S2SV_blank>size<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; <S2SV_EndBug> break ; default : hexdump = TRUE ; break ; } return hexdump ; }
CWE-119 static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_ref_frame_t * const data = va_arg ( args , vpx_ref_frame_t * ) ; <S2SV_EndBug> if ( data ) { vpx_ref_frame_t * const frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; <S2SV_StartBug> image2yuvconfig ( & frame -> img , & sd ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_set_reference_dec ( & ctx -> pbi -> common , <S2SV_EndBug> ( VP9_REFFRAME ) frame -> frame_type , & sd ) ; } else { return VPX_CODEC_INVALID_PARAM ; } }
CWE-787 static char * decode_text_string ( const char * str , size_t str_len ) { int idx , is_hex , is_utf16be , ascii_idx ; char * ascii , hex_buf [ 5 ] = { 0 } ; is_hex = is_utf16be = idx = ascii_idx = 0 ; if ( str [ 0 ] == '(' ) { <S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> strncpy ( ascii , str , strlen ( str ) + 1 ) ; return ascii ; } else if ( str [ 0 ] == '<' ) { is_hex = 1 ; ++ idx ; } if ( is_hex && ( str_len > 5 ) && ( str [ idx ] == 'F' ) && ( str [ idx + 1 ] == 'E' ) && ( str [ idx + 2 ] == 'F' ) && ( str [ idx + 3 ] == 'F' ) ) { is_utf16be = 1 ; idx += 4 ; } else return NULL ; <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> for ( ; idx < str_len ; ++ idx ) { hex_buf [ 0 ] = str [ idx ++ ] ; hex_buf [ 1 ] = str [ idx ++ ] ; hex_buf [ 2 ] = str [ idx ++ ] ; hex_buf [ 3 ] = str [ idx ] ; ascii [ ascii_idx ++ ] = strtol ( hex_buf , NULL , 16 ) ; } return ascii ; }
CWE-000 void vrrp_print_stats ( void ) { <S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , "w" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)" , stats_file , errno , strerror ( errno ) ) ; return ; } list l = vrrp_data -> vrrp ; element e ; vrrp_t * vrrp ; <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> vrrp = ELEMENT_DATA ( e ) ; fprintf ( file , "VRRP<S2SV_blank>Instance:<S2SV_blank>%s\\n" , vrrp -> iname ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Advertisements:\\n" ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> advert_rcvd ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%d\\n" , vrrp -> stats -> advert_sent ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Became<S2SV_blank>master:<S2SV_blank>%d\\n" , vrrp -> stats -> become_master ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Released<S2SV_blank>master:<S2SV_blank>%d\\n" , vrrp -> stats -> release_master ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Packet<S2SV_blank>Errors:\\n" ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> packet_len_err ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TTL:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> ip_ttl_err ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> invalid_type_rcvd ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Advertisement<S2SV_blank>Interval:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> advert_interval_err ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>List:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> addr_list_err ) ; fprintf ( file , "<S2SV_blank><S2SV_blank>Authentication<S2SV_blank>Errors:\\n" ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%d\\n" , vrrp -> stats -> invalid_authtype ) ; # ifdef _WITH_VRRP_AUTH_ fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Mismatch:<S2SV_blank>%d\\n" , vrrp -> stats -> authtype_mismatch ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Failure:<S2SV_blank>%d\\n" , vrrp -> stats -> auth_failure ) ; # endif fprintf ( file , "<S2SV_blank><S2SV_blank>Priority<S2SV_blank>Zero:\\n" ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> pri_zero_rcvd ) ; fprintf ( file , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%" PRIu64 "\\n" , vrrp -> stats -> pri_zero_sent ) ; } fclose ( file ) ; }
CWE-125 u_int mfr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int tlen , idx , hdr_len = 0 ; uint16_t sequence_num ; uint8_t ie_type , ie_len ; const uint8_t * tptr ; ND_TCHECK2 ( * p , 4 ) ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_CTRL_FRAME && p [ 1 ] == 0 ) { ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Control,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) , tok2str ( mfr_ctrl_msg_values , "Unknown<S2SV_blank>Message<S2SV_blank>(0x%02x)" , p [ 2 ] ) , length ) ) ; tptr = p + 3 ; tlen = length - 3 ; hdr_len = 3 ; if ( ! ndo -> ndo_vflag ) return hdr_len ; while ( tlen > sizeof ( struct ie_tlv_header_t ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct ie_tlv_header_t ) ) ; ie_type = tptr [ 0 ] ; ie_len = tptr [ 1 ] ; ND_PRINT ( ( ndo , "\\n\\tIE<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>" , tok2str ( mfr_ctrl_ie_values , "Unknown" , ie_type ) , ie_type , ie_len ) ) ; if ( ie_type == 0 || ie_len <= sizeof ( struct ie_tlv_header_t ) ) return hdr_len ; ND_TCHECK2 ( * tptr , ie_len ) ; tptr += sizeof ( struct ie_tlv_header_t ) ; ie_len -= sizeof ( struct ie_tlv_header_t ) ; tlen -= sizeof ( struct ie_tlv_header_t ) ; switch ( ie_type ) { <S2SV_StartBug> case MFR_CTRL_IE_MAGIC_NUM : <S2SV_EndBug> ND_PRINT ( ( ndo , "0x%08x" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case MFR_CTRL_IE_BUNDLE_ID : case MFR_CTRL_IE_LINK_ID : for ( idx = 0 ; idx < ie_len && idx < MFR_ID_STRING_MAXLEN ; idx ++ ) { if ( * ( tptr + idx ) != 0 ) safeputchar ( ndo , * ( tptr + idx ) ) ; else break ; } break ; case MFR_CTRL_IE_TIMESTAMP : if ( ie_len == sizeof ( struct timeval ) ) { ts_print ( ndo , ( const struct timeval * ) tptr ) ; break ; } case MFR_CTRL_IE_VENDOR_EXT : case MFR_CTRL_IE_CAUSE : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , ie_len ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , ie_len ) ; tlen -= ie_len ; tptr += ie_len ; } return hdr_len ; } sequence_num = ( p [ 0 ] & 0x1e ) << 7 | p [ 1 ] ; if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_FRAG_FRAME || ( p [ 0 ] & MFR_BEC_MASK ) == MFR_B_BIT ) { ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>" , sequence_num , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; hdr_len = 2 ; fr_print ( ndo , p + hdr_len , length - hdr_len ) ; return hdr_len ; } ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]" , sequence_num , bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; print_unknown_data ( ndo , p , "\\n\\t" , length ) ; return hdr_len ; trunc : ND_PRINT ( ( ndo , "[|mfr]" ) ) ; return length ; }
CWE-000 static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; <S2SV_StartBug> if ( ! net_eq ( net , & init_net ) ) <S2SV_EndBug> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_DGRAM : if ( protocol == 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol = protocol ; ax25 -> sk = sk ; return 0 ; }
CWE-000 int hfsplus_set_posix_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int err ; char * xattr_name ; size_t size = 0 ; char * value = NULL ; hfs_dbg ( ACL_MOD , "[%s]:<S2SV_blank>ino<S2SV_blank>%lu\\n" , __func__ , inode -> i_ino ) ; switch ( type ) { case ACL_TYPE_ACCESS : xattr_name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( err < 0 ) return err ; } err = 0 ; break ; case ACL_TYPE_DEFAULT : xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; if ( unlikely ( size > HFSPLUS_MAX_INLINE_DATA_SIZE ) ) return - ENOMEM ; value = ( char * ) hfsplus_alloc_attr_entry ( ) ; if ( unlikely ( ! value ) ) return - ENOMEM ; err = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( unlikely ( err < 0 ) ) goto end_set_acl ; } err = __hfsplus_setxattr ( inode , xattr_name , value , size , 0 ) ; end_set_acl : hfsplus_destroy_attr_entry ( ( hfsplus_attr_entry * ) value ) ; if ( ! err ) set_cached_acl ( inode , type , acl ) ; return err ; }
CWE-119 SQLRETURN SQLSetDescField ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>SQL_INVALID_HANDLE" ) ; return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , "\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>HY010" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>HY010" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; } else if ( CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { SQLWCHAR * s1 = NULL ; if ( isStrField ) { s1 = ansi_to_unicode_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; if ( SQL_NTS != buffer_length ) { buffer_length *= sizeof ( SQLWCHAR ) ; } } else { s1 = value ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , s1 , buffer_length ) ; if ( isStrField ) { if ( s1 ) free ( s1 ) ; } } else { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>IM001" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( log_info . log_flag ) { sprintf ( descriptor -> msg , "\\n\\t\\tExit:[%s]" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }
CWE-119 static int cxusb_ctrl_msg ( struct dvb_usb_device * d , u8 cmd , u8 * wbuf , int wlen , u8 * rbuf , int rlen ) { struct cxusb_state * st = d -> priv ; <S2SV_StartBug> int ret , wo ; <S2SV_EndBug> if ( 1 + wlen > MAX_XFER_SIZE ) { warn ( "i2c<S2SV_blank>wr:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n" , wlen ) ; return - EOPNOTSUPP ; } <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> mutex_lock ( & d -> data_mutex ) ; st -> data [ 0 ] = cmd ; memcpy ( & st -> data [ 1 ] , wbuf , wlen ) ; <S2SV_StartBug> if ( wo ) <S2SV_EndBug> ret = dvb_usb_generic_write ( d , st -> data , 1 + wlen ) ; else ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen , <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> mutex_unlock ( & d -> data_mutex ) ; return ret ; }
CWE-125 void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , "VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u" , * tptr , tok2str ( vtp_message_type_values , "Unknown<S2SV_blank>message<S2SV_blank>type" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , "\\n\\tDomain<S2SV_blank>name:<S2SV_blank>" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%s:<S2SV_blank>%u" , tok2str ( vtp_header_values , "Unknown" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : <S2SV_StartBug> ND_PRINT ( ( ndo , ",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x" , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> tptr += 4 ; <S2SV_StartBug> while ( tptr < ( pptr + length ) ) { <S2SV_EndBug> len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; ND_TCHECK ( * vtp_vlan ) ; ND_PRINT ( ( ndo , "\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>" , tok2str ( vtp_vlan_status , "Unknown" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , "Unknown" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; while ( len > 0 ) { type = * tptr ; tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , "\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV" , tok2str ( vtp_vlan_tlv_values , "Unknown" , type ) , type ) ) ; if ( type == 0 || tlv_len == 0 ) { return ; } ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , ",<S2SV_blank>%u" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u)" , tlv_value == 1 ? "Enabled" : "Disabled" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( vtp_stp_type_values , "Unknown" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u)" , tlv_value == 1 ? "SRB" : "SRT" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u)" , tlv_value == 1 ? "Backup" : "Not<S2SV_blank>backup" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , "\\n\\t\\t<S2SV_blank><S2SV_blank>" , 2 + tlv_len * 2 ) ; break ; } len -= 2 + tlv_len * 2 ; tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , "\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , "[|vtp]" ) ) ; }
CWE-189 int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; unsigned int count ; int err = - EINVAL ; if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; <S2SV_StartBug> down_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , "control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; count = kcontrol -> count ; up_write ( & card -> controls_rwsem ) ; for ( idx = 0 ; idx < count ; idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }
CWE-000 static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds_sent = true ; err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; if ( err ) { kfree_skb ( skb ) ; goto out_err ; } unix_state_lock ( other ) ; if ( sock_flag ( other , SOCK_DEAD ) || ( other -> sk_shutdown & RCV_SHUTDOWN ) ) goto pipe_err_free ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , size ) ; sent += size ; } scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ; pipe_err_free : unix_state_unlock ( other ) ; kfree_skb ( skb ) ; pipe_err : if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) send_sig ( SIGPIPE , current , 0 ) ; err = - EPIPE ; out_err : scm_destroy ( siocb -> scm ) ; siocb -> scm = NULL ; return sent ? : err ; }
CWE-190 static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
CWE-000 int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( "%s\\n" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) { <S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug> printf ( "Extracting<S2SV_blank>%s\\n" , outname ) ; ensure_filepath ( outname ) ; if ( chmd -> extract ( chmd , f [ i ] , outname ) ) { printf ( "%s:<S2SV_blank>extract<S2SV_blank>error<S2SV_blank>on<S2SV_blank>\\"%s\\":<S2SV_blank>%s\\n" , * argv , f [ i ] -> filename , ERROR ( chmd ) ) ; } free ( outname ) ; } free ( f ) ; } chmd -> close ( chmd , chm ) ; } else { printf ( "%s:<S2SV_blank>can\'t<S2SV_blank>open<S2SV_blank>--<S2SV_blank>%s\\n" , * argv , ERROR ( chmd ) ) ; } } mspack_destroy_chm_decompressor ( chmd ) ; } return 0 ; }
CWE-119 static plist_t parse_string_node ( const char * * bnode , uint64_t size ) { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_STRING ; data -> strval = ( char * ) malloc ( sizeof ( char ) * ( size + 1 ) ) ; <S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> data -> strval [ size ] = '\\0' ; data -> length = strlen ( data -> strval ) ; return node_create ( NULL , data ) ; }
CWE-264 int generic_permission ( struct inode * inode , int mask ) { int ret ; ret = acl_permission_check ( inode , mask ) ; if ( ret != - EACCES ) return ret ; if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; if ( ! ( mask & MAY_WRITE ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; } if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; mask &= MAY_READ | MAY_WRITE | MAY_EXEC ; if ( mask == MAY_READ ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; }
CWE-399 struct pipe_inode_info * alloc_pipe_info ( void ) { struct pipe_inode_info * pipe ; pipe = kzalloc ( sizeof ( struct pipe_inode_info ) , GFP_KERNEL ) ; if ( pipe ) { <S2SV_StartBug> pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * PIPE_DEF_BUFFERS , GFP_KERNEL ) ; <S2SV_EndBug> if ( pipe -> bufs ) { init_waitqueue_head ( & pipe -> wait ) ; pipe -> r_counter = pipe -> w_counter = 1 ; <S2SV_StartBug> pipe -> buffers = PIPE_DEF_BUFFERS ; <S2SV_EndBug> mutex_init ( & pipe -> mutex ) ; return pipe ; } <S2SV_StartBug> kfree ( pipe ) ; <S2SV_EndBug> } return NULL ; }
CWE-119 static INLINE void load_pred_mv ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { <S2SV_StartBug> vpx_memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_update_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_reference ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
CWE-125 static void ImportCbYCrYQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) { QuantumAny range ; register ssize_t x ; unsigned int pixel ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; switch ( quantum_info -> depth ) { case 10 : { Quantum cbcr [ 4 ] ; pixel = 0 ; if ( quantum_info -> pack == MagickFalse ) { register ssize_t i ; size_t quantum ; ssize_t n ; n = 0 ; quantum = 0 ; <S2SV_StartBug> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 ) <S2SV_EndBug> { for ( i = 0 ; i < 4 ; i ++ ) { switch ( n % 3 ) { case 0 : { p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 22 ) & 0x3ff ) << 6 ) ) ) ; break ; } case 1 : { quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 12 ) & 0x3ff ) << 6 ) ) ) ; break ; } case 2 : { quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) ( ( ( pixel >> 2 ) & 0x3ff ) << 6 ) ) ) ; break ; } } cbcr [ i ] = ( Quantum ) ( quantum ) ; n ++ ; } p += quantum_info -> pad ; SetPixelRed ( image , cbcr [ 1 ] , q ) ; SetPixelGreen ( image , cbcr [ 0 ] , q ) ; SetPixelBlue ( image , cbcr [ 2 ] , q ) ; q += GetPixelChannels ( image ) ; SetPixelRed ( image , cbcr [ 3 ] , q ) ; SetPixelGreen ( image , cbcr [ 0 ] , q ) ; SetPixelBlue ( image , cbcr [ 2 ] , q ) ; q += GetPixelChannels ( image ) ; } break ; } } default : { range = GetQuantumRange ( quantum_info -> depth ) ; for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) { p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelRed ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; p = PushQuantumPixel ( quantum_info , p , & pixel ) ; SetPixelGreen ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } } }
CWE-399 SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { <S2SV_StartBug> struct fsnotify_group * group ; <S2SV_EndBug> struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; <S2SV_StartBug> user = get_current_user ( ) ; <S2SV_EndBug> if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } <S2SV_StartBug> group = inotify_new_group ( user , inotify_max_queued_events ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( group ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = PTR_ERR ( group ) ; <S2SV_EndBug> goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( "inotify" , & inotify_fops , group , O_RDONLY | flags ) ; <S2SV_StartBug> if ( ret >= 0 ) <S2SV_EndBug> return ret ; <S2SV_StartBug> fsnotify_put_group ( group ) ; <S2SV_EndBug> atomic_dec ( & user -> inotify_devs ) ; out_free_uid : free_uid ( user ) ; return ret ; }
CWE-000 int propagate_mnt ( struct mount * dest_mnt , struct mountpoint * dest_mp , struct mount * source_mnt , struct hlist_head * tree_list ) { struct mount * m , * n ; int ret = 0 ; user_ns = current -> nsproxy -> mnt_ns -> user_ns ; last_dest = dest_mnt ; <S2SV_StartBug> last_source = source_mnt ; <S2SV_EndBug> mp = dest_mp ; list = tree_list ; dest_master = dest_mnt -> mnt_master ; for ( n = next_peer ( dest_mnt ) ; n != dest_mnt ; n = next_peer ( n ) ) { ret = propagate_one ( n ) ; if ( ret ) goto out ; } for ( m = next_group ( dest_mnt , dest_mnt ) ; m ; m = next_group ( m , dest_mnt ) ) { n = m ; do { ret = propagate_one ( n ) ; if ( ret ) goto out ; n = next_peer ( n ) ; } while ( n != m ) ; } out : read_seqlock_excl ( & mount_lock ) ; hlist_for_each_entry ( n , tree_list , mnt_hash ) { m = n -> mnt_parent ; if ( m -> mnt_master != dest_mnt -> mnt_master ) CLEAR_MNT_MARK ( m -> mnt_master ) ; } read_sequnlock_excl ( & mount_lock ) ; return ret ; }
CWE-119 void jshGetPinString ( char * result , Pin pin ) { result [ 0 ] = 0 ; # ifdef PIN_NAMES_DIRECT if ( jshIsPinValid ( pin ) ) { result [ 0 ] = ( char ) ( 'A' + ( pinInfo [ pin ] . port & JSH_PORT_MASK ) - JSH_PORTA ) ; itostr ( pinInfo [ pin ] . pin - JSH_PIN0 , & result [ 1 ] , 10 ) ; # else if ( false ) { # if JSH_PORTA_OFFSET != - 1 } else if ( # if JSH_PORTA_OFFSET != 0 pin >= JSH_PORTA_OFFSET && # endif pin < JSH_PORTA_OFFSET + JSH_PORTA_COUNT ) { result [ 0 ] = 'A' ; itostr ( pin - JSH_PORTA_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTB_OFFSET != - 1 } else if ( pin >= JSH_PORTB_OFFSET && pin < JSH_PORTB_OFFSET + JSH_PORTB_COUNT ) { result [ 0 ] = 'B' ; itostr ( pin - JSH_PORTB_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTC_OFFSET != - 1 } else if ( pin >= JSH_PORTC_OFFSET && pin < JSH_PORTC_OFFSET + JSH_PORTC_COUNT ) { result [ 0 ] = 'C' ; itostr ( pin - JSH_PORTC_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTD_OFFSET != - 1 } else if ( # if JSH_PORTD_OFFSET != 0 pin >= JSH_PORTD_OFFSET && # endif pin < JSH_PORTD_OFFSET + JSH_PORTD_COUNT ) { result [ 0 ] = 'D' ; itostr ( pin - JSH_PORTD_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTE_OFFSET != - 1 } else if ( pin >= JSH_PORTE_OFFSET && pin < JSH_PORTE_OFFSET + JSH_PORTE_COUNT ) { result [ 0 ] = 'E' ; itostr ( pin - JSH_PORTE_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTF_OFFSET != - 1 } else if ( pin >= JSH_PORTF_OFFSET && pin < JSH_PORTF_OFFSET + JSH_PORTF_COUNT ) { result [ 0 ] = 'F' ; itostr ( pin - JSH_PORTF_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTG_OFFSET != - 1 } else if ( pin >= JSH_PORTG_OFFSET && pin < JSH_PORTG_OFFSET + JSH_PORTG_COUNT ) { result [ 0 ] = 'G' ; itostr ( pin - JSH_PORTG_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTH_OFFSET != - 1 } else if ( pin >= JSH_PORTH_OFFSET && pin < JSH_PORTH_OFFSET + JSH_PORTH_COUNT ) { result [ 0 ] = 'H' ; itostr ( pin - JSH_PORTH_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTI_OFFSET != - 1 } else if ( pin >= JSH_PORTI_OFFSET && pin < JSH_PORTI_OFFSET + JSH_PORTI_COUNT ) { result [ 0 ] = 'I' ; itostr ( pin - JSH_PORTI_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTV_OFFSET != - 1 } else if ( pin >= JSH_PORTV_OFFSET && pin < JSH_PORTV_OFFSET + JSH_PORTV_COUNT ) { result [ 0 ] = 'V' ; itostr ( pin - JSH_PORTV_OFFSET , & result [ 1 ] , 10 ) ; # endif # endif } else { <S2SV_StartBug> strncpy ( result , "undefined" , 10 ) ; <S2SV_EndBug> } }
CWE-000 int install_thread_keyring_to_cred ( struct cred * new ) { <S2SV_StartBug> struct key * keyring ; <S2SV_EndBug> keyring = keyring_alloc ( "_tid" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> thread_keyring = keyring ; return 0 ; }
CWE-20 static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; <S2SV_StartBug> uint16 nif = 0 ; <S2SV_EndBug> if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , "No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed" "<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device." , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; } <S2SV_StartBug> for ( d = alldevs ; d != NULL ; d = d -> next ) <S2SV_EndBug> { nif ++ ; if ( d -> description ) <S2SV_StartBug> plen += strlen ( d -> description ) ; <S2SV_EndBug> if ( d -> name ) <S2SV_StartBug> plen += strlen ( d -> name ) ; <S2SV_EndBug> <S2SV_StartBug> plen += sizeof ( struct rpcap_findalldevs_if ) ; <S2SV_EndBug> for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif <S2SV_StartBug> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; <S2SV_EndBug> break ; default : break ; } } } if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , <S2SV_StartBug> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; <S2SV_EndBug> for ( d = alldevs ; d != NULL ; d = d -> next ) { uint16 lname , ldescr ; findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; else ldescr = 0 ; if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; else lname = 0 ; findalldevs_if -> desclen = htons ( ldescr ) ; findalldevs_if -> namelen = htons ( lname ) ; findalldevs_if -> flags = htonl ( d -> flags ) ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif findalldevs_if -> naddr ++ ; break ; default : break ; } } findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; for ( address = d -> addresses ; address != NULL ; address = address -> next ) { struct rpcap_sockaddr * sockaddr ; switch ( address -> addr -> sa_family ) { case AF_INET : # ifdef AF_INET6 case AF_INET6 : # endif sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; break ; default : break ; } } } pcap_freealldevs ( alldevs ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; error : if ( alldevs ) pcap_freealldevs ( alldevs ) ; if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; }
CWE-119 vpx_codec_err_t vp9_set_reference_dec ( VP9_COMMON * cm , VP9_REFFRAME ref_frame_flag , YV12_BUFFER_CONFIG * sd ) { <S2SV_StartBug> RefBuffer * ref_buf = NULL ; <S2SV_EndBug> if ( ref_frame_flag == VP9_LAST_FLAG ) { ref_buf = & cm -> frame_refs [ 0 ] ; } else if ( ref_frame_flag == VP9_GOLD_FLAG ) { ref_buf = & cm -> frame_refs [ 1 ] ; } else if ( ref_frame_flag == VP9_ALT_FLAG ) { ref_buf = & cm -> frame_refs [ 2 ] ; } else { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , "Invalid<S2SV_blank>reference<S2SV_blank>frame" ) ; return cm -> error . error_code ; } if ( ! equal_dimensions ( ref_buf -> buf , sd ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , "Incorrect<S2SV_blank>buffer<S2SV_blank>dimensions" ) ; } else { int * ref_fb_ptr = & ref_buf -> idx ; const int free_fb = get_free_fb ( cm ) ; <S2SV_StartBug> cm -> frame_bufs [ free_fb ] . ref_count -- ; <S2SV_EndBug> <S2SV_StartBug> ref_cnt_fb ( cm -> frame_bufs , ref_fb_ptr , free_fb ) ; <S2SV_EndBug> <S2SV_StartBug> ref_buf -> buf = & cm -> frame_bufs [ * ref_fb_ptr ] . buf ; <S2SV_EndBug> vp8_yv12_copy_frame ( sd , ref_buf -> buf ) ; } return cm -> error . error_code ; }
CWE-119 void vp9_tile_init ( TileInfo * tile , const VP9_COMMON * cm , int row , int col ) { <S2SV_StartBug> tile -> mi_row_start = get_tile_offset ( row , cm -> mi_rows , cm -> log2_tile_rows ) ; <S2SV_EndBug> tile -> mi_row_end = get_tile_offset ( row + 1 , cm -> mi_rows , cm -> log2_tile_rows ) ; tile -> mi_col_start = get_tile_offset ( col , cm -> mi_cols , cm -> log2_tile_cols ) ; tile -> mi_col_end = get_tile_offset ( col + 1 , cm -> mi_cols , cm -> log2_tile_cols ) ; }
CWE-119 static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>load<S2SV_blank>config<S2SV_blank>file;<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file." , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file,<S2SV_blank>starting<S2SV_blank>unconfigured." , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( LOG_TAG , "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>config<S2SV_blank>object." , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } <S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> if ( ! alarm_timer ) { LOG_ERROR ( LOG_TAG , "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alarm." , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }
CWE-119 static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( "Save" ) , NULL , "*.{txt,py}" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , "w" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file" ) , _ ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static void show_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * last , <S2SV_EndBug> void * data ) { <S2SV_StartBug> char * name = path_name ( path , last ) ; <S2SV_EndBug> add_preferred_base_object ( name ) ; add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ; obj -> flags |= OBJECT_ADDED ; <S2SV_StartBug> free ( ( char * ) name ) ; <S2SV_EndBug> }
CWE-119 int main ( int argc , char * argv [ ] ) { <S2SV_StartBug> char * p , * q , * r ; <S2SV_EndBug> Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case BLOCK_LEN_OPT : blocklen = clp -> val . i ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( "output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified" ) ; if ( strcmp ( clp -> vstr , "-" ) == 0 ) ofp = stdout ; else if ( ! ( ofp = fopen ( clp -> vstr , "w" ) ) ) fatal_error ( "%s:<S2SV_blank>%s" , clp -> vstr , strerror ( errno ) ) ; break ; case PFB_OPT : pfb = 1 ; break ; case PFA_OPT : pfb = 0 ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( "t1asm<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\n" , VERSION ) ; <S2SV_StartBug> printf ( "Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n" ) ; <S2SV_EndBug> exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( "too<S2SV_blank>many<S2SV_blank>arguments" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , "-" ) == 0 ) ifp = stdin ; else if ( ! ( ifp = fopen ( clp -> vstr , "r" ) ) ) fatal_error ( "%s:<S2SV_blank>%s" , clp -> vstr , strerror ( errno ) ) ; break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! pfb ) { if ( blocklen == - 1 ) blocklen = 64 ; else if ( blocklen < 8 ) { blocklen = 8 ; error ( "warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>raised<S2SV_blank>to<S2SV_blank>%d" , blocklen ) ; } else if ( blocklen > 1024 ) { blocklen = 1024 ; error ( "warning:<S2SV_blank>line<S2SV_blank>length<S2SV_blank>lowered<S2SV_blank>to<S2SV_blank>%d" , blocklen ) ; } } if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; if ( pfb ) init_pfb_writer ( & w , blocklen , ofp ) ; # if defined ( _MSDOS ) || defined ( _WIN32 ) if ( pfb ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; if ( ! ever_active ) { <S2SV_StartBug> if ( strncmp ( line , "currentfile<S2SV_blank>eexec" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( p = line + 18 ; isspace ( * p ) ; p ++ ) <S2SV_EndBug> ; eexec_start ( p ) ; continue ; } else if ( strncmp ( line , "/lenIV" , 6 ) == 0 ) { <S2SV_StartBug> lenIV = atoi ( line + 6 ) ; <S2SV_EndBug> } else if ( ( p = strstr ( line , "string<S2SV_blank>currentfile" ) ) <S2SV_StartBug> && strstr ( line , "readstring" ) ) { <S2SV_EndBug> * p = '\\0' ; q = strrchr ( line , '/' ) ; if ( q ) { r = cs_start ; ++ q ; while ( ! isspace ( * q ) && * q != '{' ) * r ++ = * q ++ ; * r = '\\0' ; } * p = 's' ; } } if ( ! active ) { <S2SV_StartBug> if ( ( p = strstr ( line , "/Subrs" ) ) && isdigit ( p [ 7 ] ) ) <S2SV_EndBug> ever_active = active = 1 ; <S2SV_StartBug> else if ( ( p = strstr ( line , "/CharStrings" ) ) && isdigit ( p [ 13 ] ) ) <S2SV_EndBug> ever_active = active = 1 ; } if ( ( p = strstr ( line , "currentfile<S2SV_blank>closefile" ) ) ) { p += sizeof ( "currentfile<S2SV_blank>closefile" ) - 1 ; <S2SV_StartBug> for ( q = p ; isspace ( * q ) && * q != '\\n' ; q ++ ) <S2SV_EndBug> ; if ( q == p && ! * q ) error ( "warning:<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>line<S2SV_blank>too<S2SV_blank>long" ) ; else if ( q != p ) { if ( * q != '\\n' ) error ( "text<S2SV_blank>after<S2SV_blank>`currentfile<S2SV_blank>closefile\'<S2SV_blank>ignored" ) ; * p ++ = '\\n' ; * p ++ = '\\0' ; } eexec_string ( line ) ; break ; } eexec_string ( line ) ; if ( start_charstring ) { if ( ! cs_start [ 0 ] ) fatal_error ( "couldn\'t<S2SV_blank>find<S2SV_blank>charstring<S2SV_blank>start<S2SV_blank>command" ) ; parse_charstring ( ) ; } } if ( in_eexec ) eexec_end ( ) ; while ( ! feof ( ifp ) && ! ferror ( ifp ) ) { t1utils_getline ( ) ; eexec_string ( line ) ; } if ( pfb ) pfb_writer_end ( & w ) ; if ( ! ever_active ) error ( "warning:<S2SV_blank>no<S2SV_blank>charstrings<S2SV_blank>found<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file" ) ; fclose ( ifp ) ; fclose ( ofp ) ; return 0 ; }
CWE-476 static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL ; found : udev = testdev_to_usbdev ( dev ) ; dev -> info -> alt = alt -> desc . bAlternateSetting ; if ( alt -> desc . bAlternateSetting != 0 ) { tmp = usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ; if ( tmp < 0 ) return tmp ; } <S2SV_StartBug> if ( in ) { <S2SV_EndBug> dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( iso_in ) { dev -> iso_in = & iso_in -> desc ; dev -> in_iso_pipe = usb_rcvisocpipe ( udev , iso_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( iso_out ) { dev -> iso_out = & iso_out -> desc ; dev -> out_iso_pipe = usb_sndisocpipe ( udev , iso_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_in ) { dev -> int_in = & int_in -> desc ; dev -> in_int_pipe = usb_rcvintpipe ( udev , int_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_out ) { dev -> int_out = & int_out -> desc ; dev -> out_int_pipe = usb_sndintpipe ( udev , int_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } return 0 ; }
CWE-264 static int cg_open ( const char * path , struct fuse_file_info * fi ) { const char * cgroup ; char * fpath = NULL , * path1 , * path2 , * cgdir = NULL , * controller ; struct cgfs_files * k = NULL ; struct file_info * file_info ; struct fuse_context * fc = fuse_get_context ( ) ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = "/" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } k = cgfs_get_key ( controller , path1 , path2 ) ; if ( ! k ) { ret = - EINVAL ; goto out ; } free_key ( k ) ; <S2SV_StartBug> if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) { <S2SV_EndBug> ret = - EACCES ; goto out ; } file_info = malloc ( sizeof ( * file_info ) ) ; if ( ! file_info ) { ret = - ENOMEM ; goto out ; } file_info -> controller = must_copy_string ( controller ) ; file_info -> cgroup = must_copy_string ( path1 ) ; file_info -> file = must_copy_string ( path2 ) ; file_info -> type = LXC_TYPE_CGFILE ; file_info -> buf = NULL ; file_info -> buflen = 0 ; fi -> fh = ( unsigned long ) file_info ; ret = 0 ; out : free ( cgdir ) ; return ret ; }
CWE-119 int main ( int argc , char * * argv ) { u8 * byteStrmStart ; u8 * byteStrm ; u32 strmLen ; u32 picSize ; H264SwDecInst decInst ; H264SwDecRet ret ; H264SwDecInput decInput ; H264SwDecOutput decOutput ; H264SwDecPicture decPicture ; H264SwDecInfo decInfo ; u32 picNumber ; FILE * finput ; FILE * foutput ; if ( argc < 2 ) { printf ( "Usage:<S2SV_blank>%s<S2SV_blank>file.h264\\n" , argv [ 0 ] ) ; return - 1 ; } foutput = fopen ( "out.yuv" , "wb" ) ; if ( foutput == NULL ) { printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>OUTPUT<S2SV_blank>FILE\\n" ) ; return - 1 ; } finput = fopen ( argv [ argc - 1 ] , "rb" ) ; if ( finput == NULL ) { printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>INPUT<S2SV_blank>FILE\\n" ) ; return - 1 ; } fseek ( finput , 0L , SEEK_END ) ; strmLen = ( u32 ) ftell ( finput ) ; rewind ( finput ) ; <S2SV_StartBug> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <S2SV_EndBug> if ( byteStrm == NULL ) { printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>ALLOCATE<S2SV_blank>MEMORY\\n" ) ; return - 1 ; } fread ( byteStrm , sizeof ( u8 ) , strmLen , finput ) ; fclose ( finput ) ; ret = H264SwDecInit ( & decInst , 0 ) ; if ( ret != H264SWDEC_OK ) { printf ( "DECODER<S2SV_blank>INITIALIZATION<S2SV_blank>FAILED\\n" ) ; return - 1 ; } decInput . pStream = byteStrmStart ; decInput . dataLen = strmLen ; decInput . intraConcealmentMethod = 0 ; picNumber = 0 ; do { ret = H264SwDecDecode ( decInst , & decInput , & decOutput ) ; switch ( ret ) { case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY : ret = H264SwDecGetInfo ( decInst , & decInfo ) ; if ( ret != H264SWDEC_OK ) return - 1 ; picSize = decInfo . picWidth * decInfo . picHeight ; picSize = ( 3 * picSize ) / 2 ; printf ( "Width<S2SV_blank>%d<S2SV_blank>Height<S2SV_blank>%d\\n" , decInfo . picWidth , decInfo . picHeight ) ; decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; break ; case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY : case H264SWDEC_PIC_RDY : decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; while ( H264SwDecNextPicture ( decInst , & decPicture , 0 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( "PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n" , picNumber , decPicture . isIdrPicture ? "IDR" : "NON-IDR" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } break ; case H264SWDEC_EVALUATION_LIMIT_EXCEEDED : printf ( "EVALUATION<S2SV_blank>LIMIT<S2SV_blank>REACHED\\n" ) ; goto end ; default : printf ( "UNRECOVERABLE<S2SV_blank>ERROR\\n" ) ; return - 1 ; } } while ( decInput . dataLen > 0 ) ; end : while ( H264SwDecNextPicture ( decInst , & decPicture , 1 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( "PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n" , picNumber , decPicture . isIdrPicture ? "IDR" : "NON-IDR" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } H264SwDecRelease ( decInst ) ; fclose ( foutput ) ; free ( byteStrmStart ) ; return 0 ; }
CWE-119 static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code ) <S2SV_StartBug> ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ; <S2SV_EndBug> return error -> error_code ; }
CWE-416 static int xc2028_set_config ( struct dvb_frontend * fe , void * priv_cfg ) { struct xc2028_data * priv = fe -> tuner_priv ; struct xc2028_ctrl * p = priv_cfg ; int rc = 0 ; tuner_dbg ( "%s<S2SV_blank>called\\n" , __func__ ) ; mutex_lock ( & priv -> lock ) ; kfree ( priv -> ctrl . fname ) ; <S2SV_StartBug> memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ; <S2SV_EndBug> if ( p -> fname ) { priv -> ctrl . fname = kstrdup ( p -> fname , GFP_KERNEL ) ; if ( priv -> ctrl . fname == NULL ) <S2SV_StartBug> rc = - ENOMEM ; <S2SV_EndBug> } if ( ! firmware_name [ 0 ] && p -> fname && priv -> fname && strcmp ( p -> fname , priv -> fname ) ) free_firmware ( priv ) ; if ( priv -> ctrl . max_len < 9 ) priv -> ctrl . max_len = 13 ; if ( priv -> state == XC2028_NO_FIRMWARE ) { if ( ! firmware_name [ 0 ] ) priv -> fname = priv -> ctrl . fname ; else priv -> fname = firmware_name ; rc = request_firmware_nowait ( THIS_MODULE , 1 , priv -> fname , priv -> i2c_props . adap -> dev . parent , GFP_KERNEL , fe , load_firmware_cb ) ; if ( rc < 0 ) { tuner_err ( "Failed<S2SV_blank>to<S2SV_blank>request<S2SV_blank>firmware<S2SV_blank>%s\\n" , priv -> fname ) ; priv -> state = XC2028_NODEV ; } else priv -> state = XC2028_WAITING_FIRMWARE ; } mutex_unlock ( & priv -> lock ) ; return rc ; }
CWE-000 static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) { <S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }
CWE-000 krb5_error_code kdc_process_s4u2proxy_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , const krb5_enc_tkt_part * t2enc , const krb5_db_entry * server , krb5_const_principal server_princ , krb5_const_principal proxy_princ , const char * * status ) { krb5_error_code errcode ; if ( request -> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) { <S2SV_StartBug> return KRB5KDC_ERR_BADOPTION ; <S2SV_EndBug> } if ( ! krb5_principal_compare ( kdc_context , server -> princ , <S2SV_StartBug> server_princ ) ) { <S2SV_EndBug> return KRB5KDC_ERR_SERVER_NOMATCH ; } if ( ! isflagset ( t2enc -> flags , TKT_FLG_FORWARDABLE ) ) { * status = "EVIDENCE_TKT_NOT_FORWARDABLE" ; return KRB5_TKT_NOT_FORWARDABLE ; } errcode = check_allowed_to_delegate_to ( kdc_context , t2enc -> client , server , proxy_princ ) ; if ( errcode ) { * status = "NOT_ALLOWED_TO_DELEGATE" ; return errcode ; } return 0 ; }
CWE-190 <S2SV_StartBug> static int jas_iccputsint ( jas_stream_t * out , int n , longlong val ) <S2SV_EndBug> { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> tmp = ( val < 0 ) ? ( abort ( ) , 0 ) : val ; return jas_iccputuint ( out , n , tmp ) ; }
CWE-190 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; <S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>" "in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( "Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }
CWE-000 static int ext4_xattr_block_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) { struct buffer_head * bh = NULL ; struct ext4_xattr_entry * entry ; size_t size ; int error ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ea_idebug ( inode , "name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld" , name_index , name , buffer , ( long ) buffer_size ) ; error = - ENODATA ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , "reading<S2SV_blank>block<S2SV_blank>%llu" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , "b_count=%d,<S2SV_blank>refcount=%d" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { bad_block : EXT4_ERROR_INODE ( inode , "bad<S2SV_blank>block<S2SV_blank>%llu" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; entry = BFIRST ( bh ) ; error = ext4_xattr_find_entry ( & entry , name_index , name , bh -> b_size , 1 ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; size = le32_to_cpu ( entry -> e_value_size ) ; if ( buffer ) { error = - ERANGE ; if ( size > buffer_size ) goto cleanup ; memcpy ( buffer , bh -> b_data + le16_to_cpu ( entry -> e_value_offs ) , size ) ; } error = size ; cleanup : brelse ( bh ) ; return error ; }
CWE-125 u_int atm_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int length = h -> len ; uint32_t llchdr ; u_int hdrlen = 0 ; if ( caplen < 1 || length < 1 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ( caplen ) ; } if ( * p == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "CNLPID<S2SV_blank>" ) ) ; <S2SV_StartBug> isoclns_print ( ndo , p + 1 , length - 1 , caplen - 1 ) ; <S2SV_EndBug> return hdrlen ; } if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ( caplen ) ; } llchdr = EXTRACT_24BITS ( p ) ; if ( llchdr != LLC_UI_HDR ( LLCSAP_SNAP ) && llchdr != LLC_UI_HDR ( LLCSAP_ISONS ) && llchdr != LLC_UI_HDR ( LLCSAP_IP ) ) { if ( caplen < 20 || length < 20 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ( caplen ) ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "%08x%08x<S2SV_blank>%08x%08x<S2SV_blank>" , EXTRACT_32BITS ( p ) , EXTRACT_32BITS ( p + 4 ) , EXTRACT_32BITS ( p + 8 ) , EXTRACT_32BITS ( p + 12 ) ) ) ; p += 20 ; length -= 20 ; caplen -= 20 ; hdrlen += 20 ; } hdrlen += atm_llc_print ( ndo , p , length , caplen ) ; return ( hdrlen ) ; }
CWE-264 SYSCALL_DEFINE6 ( sendto , int , fd , void __user * , buff , size_t , len , unsigned int , flags , struct sockaddr __user * , addr , int , addr_len ) { struct socket * sock ; struct sockaddr_storage address ; int err ; struct msghdr msg ; struct iovec iov ; int fput_needed ; if ( len > INT_MAX ) <S2SV_StartBug> len = INT_MAX ; <S2SV_EndBug> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; iov . iov_base = buff ; iov . iov_len = len ; msg . msg_name = NULL ; iov_iter_init ( & msg . msg_iter , WRITE , & iov , 1 , len ) ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_namelen = 0 ; if ( addr ) { err = move_addr_to_kernel ( addr , addr_len , & address ) ; if ( err < 0 ) goto out_put ; msg . msg_name = ( struct sockaddr * ) & address ; msg . msg_namelen = addr_len ; } if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; msg . msg_flags = flags ; err = sock_sendmsg ( sock , & msg , len ) ; out_put : fput_light ( sock -> file , fput_needed ) ; out : return err ; }
CWE-119 int add_control_packet ( struct mt_packet * packet , enum mt_cptype cptype , void * cpdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; <S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( "add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n" ) , MT_PACKET_LEN ) ; return - 1 ; } if ( cptype == MT_CPTYPE_PLAINDATA ) { memcpy ( data , cpdata , data_len ) ; packet -> size += data_len ; return data_len ; } memcpy ( data , mt_mactelnet_cpmagic , sizeof ( mt_mactelnet_cpmagic ) ) ; data [ 4 ] = cptype ; # if BYTE_ORDER == LITTLE_ENDIAN { unsigned int templen ; templen = htonl ( data_len ) ; memcpy ( data + 5 , & templen , sizeof ( templen ) ) ; } # else memcpy ( data + 5 , & data_len , sizeof ( data_len ) ) ; # endif if ( data_len > 0 ) { memcpy ( data + MT_CPHEADER_LEN , cpdata , data_len ) ; } packet -> size += act_size ; return act_size ; }
CWE-000 static int __f2fs_set_acl ( struct inode * inode , int type , struct posix_acl * acl , struct page * ipage ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = f2fs_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) { clear_inode_flag ( inode , FI_ACL_MODE ) ; return ( int ) PTR_ERR ( value ) ; } } error = f2fs_setxattr ( inode , name_index , "" , value , size , ipage , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; clear_inode_flag ( inode , FI_ACL_MODE ) ; return error ; }
CWE-119 static int PredictorDecodeTile ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decodetile != NULL ) ; if ( ( * sp -> decodetile ) ( tif , op0 , occ0 , s ) ) { tmsize_t rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; <S2SV_StartBug> assert ( ( occ0 % rowsize ) == 0 ) ; <S2SV_EndBug> assert ( sp -> decodepfunc != NULL ) ; while ( occ0 > 0 ) { <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ; <S2SV_EndBug> occ0 -= rowsize ; op0 += rowsize ; } return 1 ; } else return 0 ; }
CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; VpxVideoReader * reader = NULL ; const VpxInterface * decoder = NULL ; const VpxVideoInfo * info = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments." ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading." , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , "wb" ) ) ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing." , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( "Unknown<S2SV_blank>input<S2SV_blank>codec." ) ; <S2SV_StartBug> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder." ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame." ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { vpx_img_write ( img , outfile ) ; ++ frame_cnt ; } } printf ( "Processed<S2SV_blank>%d<S2SV_blank>frames.\\n" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec" ) ; printf ( "Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }
CWE-125 static void rpl_dio_printopt ( netdissect_options * ndo , const struct rpl_dio_genoption * opt , u_int length ) { if ( length < RPL_DIO_GENOPTION_LEN ) return ; length -= RPL_DIO_GENOPTION_LEN ; ND_TCHECK ( opt -> rpl_dio_len ) ; while ( ( opt -> rpl_dio_type == RPL_OPT_PAD0 && ( const u_char * ) opt < ndo -> ndo_snapend ) || ND_TTEST2 ( * opt , ( opt -> rpl_dio_len + 2 ) ) ) { unsigned int optlen = opt -> rpl_dio_len + 2 ; if ( opt -> rpl_dio_type == RPL_OPT_PAD0 ) { optlen = 1 ; ND_PRINT ( ( ndo , "<S2SV_blank>opt:pad0" ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>opt:%s<S2SV_blank>len:%u<S2SV_blank>" , tok2str ( rpl_subopt_values , "subopt:%u" , opt -> rpl_dio_type ) , optlen ) ) ; if ( ndo -> ndo_vflag > 2 ) { unsigned int paylen = opt -> rpl_dio_len ; if ( paylen > length ) paylen = length ; hex_print ( ndo , "<S2SV_blank>" , ( ( const uint8_t * ) opt ) + RPL_DIO_GENOPTION_LEN , paylen ) ; } } opt = ( const struct rpl_dio_genoption * ) ( ( ( const char * ) opt ) + optlen ) ; length -= optlen ; <S2SV_StartBug> } <S2SV_EndBug> return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; }
CWE-119 <S2SV_StartBug> static vp9_variance_fn_t get_block_variance_fn ( BLOCK_SIZE bsize ) { <S2SV_EndBug> switch ( bsize ) { case BLOCK_8X8 : <S2SV_StartBug> return vp9_mse8x8 ; <S2SV_EndBug> case BLOCK_16X8 : <S2SV_StartBug> return vp9_mse16x8 ; <S2SV_EndBug> case BLOCK_8X16 : <S2SV_StartBug> return vp9_mse8x16 ; <S2SV_EndBug> default : <S2SV_StartBug> return vp9_mse16x16 ; <S2SV_EndBug> } }
CWE-399 <S2SV_StartBug> void unix_notinflight ( struct file * fp ) <S2SV_EndBug> { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; } <S2SV_StartBug> fp -> f_cred -> user -> unix_inflight -- ; <S2SV_EndBug> spin_unlock ( & unix_gc_lock ) ; }
CWE-284 void bta_hh_co_open ( UINT8 dev_handle , UINT8 sub_class , tBTA_HH_ATTR_MASK attr_mask , UINT8 app_id ) { UINT32 i ; btif_hh_device_t * p_dev = NULL ; if ( dev_handle == BTA_HH_INVALID_HANDLE ) { APPL_TRACE_WARNING ( "%s:<S2SV_blank>Oops,<S2SV_blank>dev_handle<S2SV_blank>(%d)<S2SV_blank>is<S2SV_blank>invalid..." , __FUNCTION__ , dev_handle ) ; return ; } for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { p_dev = & btif_hh_cb . devices [ i ] ; if ( p_dev -> dev_status != BTHH_CONN_STATE_UNKNOWN && p_dev -> dev_handle == dev_handle ) { APPL_TRACE_WARNING ( "%s:<S2SV_blank>Found<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>device<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>handle<S2SV_blank>" "dev_status<S2SV_blank>=<S2SV_blank>%d" , __FUNCTION__ , p_dev -> dev_status ) ; APPL_TRACE_WARNING ( "%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>bd_addr<S2SV_blank>=<S2SV_blank>[%02X:%02X:%02X:%02X:%02X:]" , __FUNCTION__ , p_dev -> bd_addr . address [ 0 ] , p_dev -> bd_addr . address [ 1 ] , p_dev -> bd_addr . address [ 2 ] , p_dev -> bd_addr . address [ 3 ] , p_dev -> bd_addr . address [ 4 ] ) ; APPL_TRACE_WARNING ( "%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>attr_mask<S2SV_blank>=<S2SV_blank>0x%04x,<S2SV_blank>sub_class<S2SV_blank>=<S2SV_blank>0x%02x,<S2SV_blank>app_id<S2SV_blank>=<S2SV_blank>%d" , __FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; if ( p_dev -> fd < 0 ) { <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else APPL_TRACE_DEBUG ( "%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d" , __FUNCTION__ , p_dev -> fd ) ; } p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; break ; } p_dev = NULL ; } if ( p_dev == NULL ) { for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { if ( btif_hh_cb . devices [ i ] . dev_status == BTHH_CONN_STATE_UNKNOWN ) { p_dev = & btif_hh_cb . devices [ i ] ; p_dev -> dev_handle = dev_handle ; p_dev -> attr_mask = attr_mask ; p_dev -> sub_class = sub_class ; p_dev -> app_id = app_id ; p_dev -> local_vup = FALSE ; btif_hh_cb . device_num ++ ; <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else { APPL_TRACE_DEBUG ( "%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d" , __FUNCTION__ , p_dev -> fd ) ; p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; } break ; } } } if ( p_dev == NULL ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Error:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>HID<S2SV_blank>devices<S2SV_blank>are<S2SV_blank>connected" , __FUNCTION__ ) ; return ; } p_dev -> dev_status = BTHH_CONN_STATE_CONNECTED ; APPL_TRACE_DEBUG ( "%s:<S2SV_blank>Return<S2SV_blank>device<S2SV_blank>status<S2SV_blank>%d" , __FUNCTION__ , p_dev -> dev_status ) ; }
CWE-200 static int rawv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; struct sk_buff * skb ; size_t copied ; int err ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } if ( skb_csum_unnecessary ( skb ) ) { err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else if ( msg -> msg_flags & MSG_TRUNC ) { if ( __skb_checksum_complete ( skb ) ) goto csum_copy_err ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else { err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( err ) goto out_free ; if ( sin6 ) { sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_flowinfo = 0 ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , <S2SV_StartBug> IP6CB ( skb ) -> iif ) ; <S2SV_EndBug> } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; err = copied ; if ( flags & MSG_TRUNC ) err = skb -> len ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; csum_copy_err : skb_kill_datagram ( sk , skb , flags ) ; err = ( flags & MSG_DONTWAIT ) ? - EAGAIN : - EHOSTUNREACH ; goto out ; }
CWE-000 static int handle_vmon ( struct kvm_vcpu * vcpu ) { int ret ; gpa_t vmptr ; struct page * page ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; const u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED | FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX ; <S2SV_StartBug> if ( ! kvm_read_cr4_bits ( vcpu , X86_CR4_VMXE ) ) { <S2SV_EndBug> kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx -> nested . vmxon ) { nested_vmx_failValid ( vcpu , VMXERR_VMXON_IN_VMX_ROOT_OPERATION ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } if ( ( vmx -> msr_ia32_feature_control & VMXON_NEEDED_FEATURES ) != VMXON_NEEDED_FEATURES ) { kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } if ( nested_vmx_get_vmptr ( vcpu , & vmptr ) ) return 1 ; if ( ! PAGE_ALIGNED ( vmptr ) || ( vmptr >> cpuid_maxphyaddr ( vcpu ) ) ) { nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } page = kvm_vcpu_gpa_to_page ( vcpu , vmptr ) ; if ( is_error_page ( page ) ) { nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } if ( * ( u32 * ) kmap ( page ) != VMCS12_REVISION ) { kunmap ( page ) ; kvm_release_page_clean ( page ) ; nested_vmx_failInvalid ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; } kunmap ( page ) ; kvm_release_page_clean ( page ) ; vmx -> nested . vmxon_ptr = vmptr ; ret = enter_vmx_operation ( vcpu ) ; if ( ret ) return ret ; nested_vmx_succeed ( vcpu ) ; return kvm_skip_emulated_instruction ( vcpu ) ; }
CWE-119 static void build_y_mask ( const loop_filter_info_n * const lfi_n , const MODE_INFO * mi , const int shift_y , LOOP_FILTER_MASK * lfm ) { const MB_MODE_INFO * mbmi = & mi -> mbmi ; const BLOCK_SIZE block_size = mbmi -> sb_type ; const TX_SIZE tx_size_y = mbmi -> tx_size ; const int filter_level = get_filter_level ( lfi_n , mbmi ) ; uint64_t * const left_y = & lfm -> left_y [ tx_size_y ] ; uint64_t * const above_y = & lfm -> above_y [ tx_size_y ] ; uint64_t * const int_4x4_y = & lfm -> int_4x4_y ; int i ; if ( ! filter_level ) { return ; } else { const int w = num_8x8_blocks_wide_lookup [ block_size ] ; const int h = num_8x8_blocks_high_lookup [ block_size ] ; int index = shift_y ; for ( i = 0 ; i < h ; i ++ ) { <S2SV_StartBug> vpx_memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; <S2SV_EndBug> index += 8 ; } } * above_y |= above_prediction_mask [ block_size ] << shift_y ; * left_y |= left_prediction_mask [ block_size ] << shift_y ; if ( mbmi -> skip && is_inter_block ( mbmi ) ) return ; * above_y |= ( size_mask [ block_size ] & above_64x64_txform_mask [ tx_size_y ] ) << shift_y ; * left_y |= ( size_mask [ block_size ] & left_64x64_txform_mask [ tx_size_y ] ) << shift_y ; if ( tx_size_y == TX_4X4 ) <S2SV_StartBug> * int_4x4_y |= ( size_mask [ block_size ] & 0xffffffffffffffff ) << shift_y ; <S2SV_EndBug> }
CWE-264 static int __poke_user ( struct task_struct * child , addr_t addr , addr_t data ) { struct user * dummy = NULL ; addr_t offset ; if ( addr < ( addr_t ) & dummy -> regs . acrs ) { if ( addr == ( addr_t ) & dummy -> regs . psw . mask ) { unsigned long mask = PSW_MASK_USER ; mask |= is_ri_task ( child ) ? PSW_MASK_RI : 0 ; <S2SV_StartBug> if ( ( data & ~ mask ) != PSW_USER_BITS ) <S2SV_EndBug> return - EINVAL ; if ( ( data & PSW_MASK_EA ) && ! ( data & PSW_MASK_BA ) ) return - EINVAL ; } * ( addr_t * ) ( ( addr_t ) & task_pt_regs ( child ) -> psw + addr ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . orig_gpr2 ) ) { offset = addr - ( addr_t ) & dummy -> regs . acrs ; # ifdef CONFIG_64BIT if ( addr == ( addr_t ) & dummy -> regs . acrs [ 15 ] ) child -> thread . acrs [ 15 ] = ( unsigned int ) ( data >> 32 ) ; else # endif * ( addr_t * ) ( ( addr_t ) & child -> thread . acrs + offset ) = data ; } else if ( addr == ( addr_t ) & dummy -> regs . orig_gpr2 ) { task_pt_regs ( child ) -> orig_gpr2 = data ; } else if ( addr < ( addr_t ) & dummy -> regs . fp_regs ) { return 0 ; } else if ( addr < ( addr_t ) ( & dummy -> regs . fp_regs + 1 ) ) { if ( addr == ( addr_t ) & dummy -> regs . fp_regs . fpc ) if ( ( unsigned int ) data != 0 || test_fp_ctl ( data >> ( BITS_PER_LONG - 32 ) ) ) return - EINVAL ; offset = addr - ( addr_t ) & dummy -> regs . fp_regs ; * ( addr_t * ) ( ( addr_t ) & child -> thread . fp_regs + offset ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . per_info + 1 ) ) { addr -= ( addr_t ) & dummy -> regs . per_info ; __poke_user_per ( child , addr , data ) ; } return 0 ; }
CWE-119 <S2SV_StartBug> int release_vp9_frame_buffer ( void * cb_priv , <S2SV_EndBug> vpx_codec_frame_buffer_t * fb ) { struct ExternalFrameBuffer * const ext_fb = ( struct ExternalFrameBuffer * ) fb -> priv ; ( void ) cb_priv ; ext_fb -> in_use = 0 ; return 0 ; }
CWE-000 static int mountpoint_last ( struct nameidata * nd , struct path * path ) { int error = 0 ; struct dentry * dentry ; struct dentry * dir = nd -> path . dentry ; if ( nd -> flags & LOOKUP_RCU ) { if ( unlazy_walk ( nd , NULL ) ) { error = - ECHILD ; goto out ; } } nd -> flags &= ~ LOOKUP_PARENT ; if ( unlikely ( nd -> last_type != LAST_NORM ) ) { error = handle_dots ( nd , nd -> last_type ) ; if ( error ) goto out ; dentry = dget ( nd -> path . dentry ) ; goto done ; } mutex_lock ( & dir -> d_inode -> i_mutex ) ; dentry = d_lookup ( dir , & nd -> last ) ; if ( ! dentry ) { dentry = d_alloc ( dir , & nd -> last ) ; if ( ! dentry ) { error = - ENOMEM ; mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } dentry = lookup_real ( dir -> d_inode , dentry , nd -> flags ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) { mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } } mutex_unlock ( & dir -> d_inode -> i_mutex ) ; done : if ( ! dentry -> d_inode || d_is_negative ( dentry ) ) { error = - ENOENT ; dput ( dentry ) ; goto out ; } path -> dentry = dentry ; <S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ; <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug> error = 0 ; out : terminate_walk ( nd ) ; return error ; }
CWE-20 static enum try_read_result try_read_network ( conn * c ) { enum try_read_result gotdata = READ_NO_DATA_RECEIVED ; int res ; <S2SV_StartBug> assert ( c != NULL ) ; <S2SV_EndBug> if ( c -> rcurr != c -> rbuf ) { if ( c -> rbytes != 0 ) memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; } while ( 1 ) { <S2SV_StartBug> if ( c -> rbytes >= c -> rsize ) { <S2SV_EndBug> char * new_rbuf = realloc ( c -> rbuf , c -> rsize * 2 ) ; if ( ! new_rbuf ) { if ( settings . verbose > 0 ) fprintf ( stderr , "Couldn\'t<S2SV_blank>realloc<S2SV_blank>input<S2SV_blank>buffer\\n" ) ; c -> rbytes = 0 ; out_string ( c , "SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>reading<S2SV_blank>request" ) ; c -> write_and_go = conn_closing ; return READ_MEMORY_ERROR ; } c -> rcurr = c -> rbuf = new_rbuf ; c -> rsize *= 2 ; } int avail = c -> rsize - c -> rbytes ; res = read ( c -> sfd , c -> rbuf + c -> rbytes , avail ) ; if ( res > 0 ) { pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; c -> thread -> stats . bytes_read += res ; pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; gotdata = READ_DATA_RECEIVED ; c -> rbytes += res ; if ( res == avail ) { continue ; } else { break ; } } if ( res == 0 ) { return READ_ERROR ; } if ( res == - 1 ) { if ( errno == EAGAIN || errno == EWOULDBLOCK ) { break ; } return READ_ERROR ; } } return gotdata ; }
CWE-119 int vp8_receive_raw_frame ( VP8_COMP * cpi , unsigned int frame_flags , YV12_BUFFER_CONFIG * sd , int64_t time_stamp , int64_t end_time ) { <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> int64_t store_reg [ 8 ] ; # if CONFIG_RUNTIME_CPU_DETECT VP8_COMMON * cm = & cpi -> common ; # endif # endif struct vpx_usec_timer timer ; int res = 0 ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & timer ) ; if ( sd -> y_width != cpi -> oxcf . Width || sd -> y_height != cpi -> oxcf . Height ) { assert ( cpi -> oxcf . lag_in_frames < 2 ) ; dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; } if ( vp8_lookahead_push ( cpi -> lookahead , sd , time_stamp , end_time , frame_flags , cpi -> active_map_enabled ? cpi -> active_map : NULL ) ) res = - 1 ; vpx_usec_timer_mark ( & timer ) ; cpi -> time_receive_data += vpx_usec_timer_elapsed ( & timer ) ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return res ; }
CWE-119 <S2SV_StartBug> int file_is_y4m ( const char detect [ 4 ] ) { <S2SV_EndBug> if ( memcmp ( detect , "YUV4" , 4 ) == 0 ) { return 1 ; } return 0 ; }
CWE-119 <S2SV_StartBug> void vp9_idct8x8_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> if ( eob == 1 ) <S2SV_StartBug> vp9_idct8x8_1_add ( input , dest , stride ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( eob <= 10 ) <S2SV_EndBug> vp9_idct8x8_10_add ( input , dest , stride ) ; else <S2SV_StartBug> vp9_idct8x8_64_add ( input , dest , stride ) ; <S2SV_EndBug> }
CWE-787 static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , <S2SV_StartBug> OPJ_UINT32 * p_data_written , <S2SV_EndBug> const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOT , <S2SV_EndBug> 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; # ifdef USE_JPWL assert ( 0 && "TODO" ) ; # endif * p_data_written = 12 ; return OPJ_TRUE ; }
CWE-20 static int __br_mdb_del ( struct net_bridge * br , struct br_mdb_entry * entry ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; struct br_ip ip ; int err = - EINVAL ; if ( ! netif_running ( br -> dev ) || br -> multicast_disabled ) return - EINVAL ; if ( timer_pending ( & br -> multicast_querier_timer ) ) return - EBUSY ; ip . proto = entry -> addr . proto ; if ( ip . proto == htons ( ETH_P_IP ) ) ip . u . ip4 = entry -> addr . u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) else ip . u . ip6 = entry -> addr . u . ip6 ; # endif spin_lock_bh ( & br -> multicast_lock ) ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & ip ) ; if ( ! mp ) goto unlock ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( ! p -> port || p -> port -> dev -> ifindex != entry -> ifindex ) continue ; if ( p -> port -> state == BR_STATE_DISABLED ) goto unlock ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ; call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; err = 0 ; <S2SV_StartBug> if ( ! mp -> ports && ! mp -> mglist && <S2SV_EndBug> netif_running ( br -> dev ) ) mod_timer ( & mp -> timer , jiffies ) ; break ; } unlock : spin_unlock_bh ( & br -> multicast_lock ) ; return err ; }
CWE-000 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; struct rds_transport * otrans = trans ; if ( ! is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) goto new_conn ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; new_conn : conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; } } <S2SV_StartBug> conn -> c_trans = trans ; <S2SV_EndBug> ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; conn -> c_send_gen = 0 ; conn -> c_reconnect_jiffies = 0 ; INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( "allocated<S2SV_blank>conn<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>%pI4<S2SV_blank>-><S2SV_blank>%pI4<S2SV_blank>over<S2SV_blank>%s<S2SV_blank>%s\\n" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : "[unknown]" , is_outgoing ? "(outgoing)" : "" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; if ( ! is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) found = NULL ; else found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { if ( ( is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) || ( otrans -> t_type != RDS_TRANS_TCP ) ) { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; } rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }
CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( "arptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( "mark_source_chains:<S2SV_blank>bad<S2SV_blank>" "negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ) ; oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct arpt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct arpt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct arpt_entry ) ) { duprintf ( "mark_source_chains:<S2SV_blank>" "bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , newpos ) ; return 0 ; } duprintf ( "Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct arpt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( "Finished<S2SV_blank>chain<S2SV_blank>%u\\n" , hook ) ; } return 1 ; }
CWE-399 gboolean cib_notify_client ( gpointer key , gpointer value , gpointer user_data ) { const char * type = NULL ; gboolean do_send = FALSE ; cib_client_t * client = value ; xmlNode * update_msg = user_data ; CRM_CHECK ( client != NULL , return TRUE ) ; CRM_CHECK ( update_msg != NULL , return TRUE ) ; <S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> crm_warn ( "Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel" ) ; return FALSE ; } type = crm_element_value ( update_msg , F_SUBTYPE ) ; CRM_LOG_ASSERT ( type != NULL ) ; if ( client -> diffs && safe_str_eq ( type , T_CIB_DIFF_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> replace && safe_str_eq ( type , T_CIB_REPLACE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> confirmations && safe_str_eq ( type , T_CIB_UPDATE_CONFIRM ) ) { do_send = TRUE ; } else if ( client -> pre_notify && safe_str_eq ( type , T_CIB_PRE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> post_notify && safe_str_eq ( type , T_CIB_POST_NOTIFY ) ) { do_send = TRUE ; } if ( do_send ) { if ( client -> ipc ) { if ( crm_ipcs_send ( client -> ipc , 0 , update_msg , TRUE ) == FALSE ) { crm_warn ( "Notification<S2SV_blank>of<S2SV_blank>client<S2SV_blank>%s/%s<S2SV_blank>failed" , client -> name , client -> id ) ; } # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client -> session ) { crm_debug ( "Sent<S2SV_blank>%s<S2SV_blank>notification<S2SV_blank>to<S2SV_blank>client<S2SV_blank>%s/%s" , type , client -> name , client -> id ) ; crm_send_remote_msg ( client -> session , update_msg , client -> encrypted ) ; # endif } else { crm_err ( "Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s" , client -> name ) ; } } return FALSE ; }
CWE-119 int vp8_full_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; for ( c = col_min ; c < col_max ; c ++ ) { <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } check_here ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
CWE-476 static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ; <S2SV_StartBug> px -> ft -> data = px ; <S2SV_EndBug> px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }
CWE-119 u32 h264bsdActivateParamSets ( storage_t * pStorage , u32 ppsId , u32 isIdr ) { u32 tmp ; u32 flag ; ASSERT ( pStorage ) ; ASSERT ( ppsId < MAX_NUM_PIC_PARAM_SETS ) ; if ( ( pStorage -> pps [ ppsId ] == NULL ) || ( pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] == NULL ) ) { return ( HANTRO_NOK ) ; } tmp = CheckPps ( pStorage -> pps [ ppsId ] , pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; if ( pStorage -> activePpsId == MAX_NUM_PIC_PARAM_SETS ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; <S2SV_StartBug> pStorage -> picSizeInMbs = <S2SV_EndBug> pStorage -> activeSps -> picWidthInMbs * <S2SV_StartBug> pStorage -> activeSps -> picHeightInMbs ; <S2SV_EndBug> pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else if ( pStorage -> pendingActivation ) { pStorage -> pendingActivation = HANTRO_FALSE ; FREE ( pStorage -> mb ) ; FREE ( pStorage -> sliceGroupMap ) ; ALLOCATE ( pStorage -> mb , pStorage -> picSizeInMbs , mbStorage_t ) ; ALLOCATE ( pStorage -> sliceGroupMap , pStorage -> picSizeInMbs , u32 ) ; if ( pStorage -> mb == NULL || pStorage -> sliceGroupMap == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( pStorage -> mb , 0 , pStorage -> picSizeInMbs * sizeof ( mbStorage_t ) ) ; h264bsdInitMbNeighbours ( pStorage -> mb , pStorage -> activeSps -> picWidthInMbs , pStorage -> picSizeInMbs ) ; if ( pStorage -> noReordering || pStorage -> activeSps -> picOrderCntType == 2 || ( pStorage -> activeSps -> vuiParametersPresentFlag && pStorage -> activeSps -> vuiParameters -> bitstreamRestrictionFlag && ! pStorage -> activeSps -> vuiParameters -> numReorderFrames ) ) flag = HANTRO_TRUE ; else flag = HANTRO_FALSE ; tmp = h264bsdResetDpb ( pStorage -> dpb , pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs , pStorage -> activeSps -> maxDpbSize , pStorage -> activeSps -> numRefFrames , pStorage -> activeSps -> maxFrameNum , flag ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; } else if ( ppsId != pStorage -> activePpsId ) { if ( pStorage -> pps [ ppsId ] -> seqParameterSetId != pStorage -> activeSpsId ) { DEBUG ( ( "SEQ<S2SV_blank>PARAM<S2SV_blank>SET<S2SV_blank>CHANGING...\\n" ) ) ; if ( isIdr ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; pStorage -> picSizeInMbs = pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ; pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else { DEBUG ( ( "TRYING<S2SV_blank>TO<S2SV_blank>CHANGE<S2SV_blank>SPS<S2SV_blank>IN<S2SV_blank>NON-IDR<S2SV_blank>SLICE\\n" ) ) ; return ( HANTRO_NOK ) ; } } else { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; } } return ( HANTRO_OK ) ; }
CWE-119 <S2SV_StartBug> static void fix_interp_filter ( VP9_COMMON * cm ) { <S2SV_EndBug> if ( cm -> interp_filter == SWITCHABLE ) { int count [ SWITCHABLE_FILTERS ] ; int i , j , c = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { count [ i ] = 0 ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) <S2SV_StartBug> count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ; <S2SV_EndBug> c += ( count [ i ] > 0 ) ; } if ( c == 1 ) { for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { if ( count [ i ] ) { cm -> interp_filter = i ; break ; } } } } }
CWE-20 int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( "sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p<S2SV_blank>len<S2SV_blank>%zu" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { <S2SV_StartBug> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { <S2SV_EndBug> msg -> msg_namelen = 0 ; return 0 ; } return err ; } copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) { sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( bt_sk ( sk ) -> skb_msg_name ) bt_sk ( sk ) -> skb_msg_name ( skb , msg -> msg_name , & msg -> msg_namelen ) ; <S2SV_StartBug> else <S2SV_EndBug> msg -> msg_namelen = 0 ; } skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
CWE-787 <S2SV_StartBug> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { nsc_encode_argb_to_aycocg_sse2 ( context , data , scanline ) ; if ( context -> ChromaSubsamplingLevel > 0 ) { nsc_encode_subsampling_sse2 ( context ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; <S2SV_StartBug> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }
CWE-119 void read_sequence_header ( decoder_info_t * decoder_info , stream_t * stream ) { decoder_info -> width = get_flc ( 16 , stream ) ; decoder_info -> height = get_flc ( 16 , stream ) ; <S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> decoder_info -> pb_split = get_flc ( 1 , stream ) ; decoder_info -> tb_split_enable = get_flc ( 1 , stream ) ; decoder_info -> max_num_ref = get_flc ( 2 , stream ) + 1 ; decoder_info -> interp_ref = get_flc ( 2 , stream ) ; decoder_info -> max_delta_qp = get_flc ( 1 , stream ) ; decoder_info -> deblocking = get_flc ( 1 , stream ) ; decoder_info -> clpf = get_flc ( 1 , stream ) ; decoder_info -> use_block_contexts = get_flc ( 1 , stream ) ; decoder_info -> bipred = get_flc ( 2 , stream ) ; decoder_info -> qmtx = get_flc ( 1 , stream ) ; if ( decoder_info -> qmtx ) { decoder_info -> qmtx_offset = get_flc ( 6 , stream ) - 32 ; } decoder_info -> subsample = get_flc ( 2 , stream ) ; decoder_info -> subsample = ( decoder_info -> subsample & 1 ) * 20 + ( decoder_info -> subsample & 2 ) * 22 + ( ( decoder_info -> subsample & 3 ) == 3 ) * 2 + 400 ; decoder_info -> num_reorder_pics = get_flc ( 4 , stream ) ; if ( decoder_info -> subsample != 400 ) { decoder_info -> cfl_intra = get_flc ( 1 , stream ) ; decoder_info -> cfl_inter = get_flc ( 1 , stream ) ; } decoder_info -> bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> bitdepth == 10 ) decoder_info -> bitdepth += 2 * get_flc ( 1 , stream ) ; decoder_info -> input_bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> input_bitdepth == 10 ) decoder_info -> input_bitdepth += 2 * get_flc ( 1 , stream ) ; }
CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , "blacklisted<S2SV_blank>by<S2SV_blank>%s\\n" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , "usb%d" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , "eth%d" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , "wlan%d" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , "wwan%d" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , "register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }
CWE-476 static int tls_construct_cke_dhe ( SSL * s , unsigned char * * p , int * len , int * al ) { # ifndef OPENSSL_NO_DH DH * dh_clnt = NULL ; const BIGNUM * pub_key ; EVP_PKEY * ckey = NULL , * skey = NULL ; skey = s -> s3 -> peer_tmp ; if ( skey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; } ckey = ssl_generate_pkey ( skey ) ; <S2SV_StartBug> dh_clnt = EVP_PKEY_get0_DH ( ckey ) ; <S2SV_EndBug> if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; EVP_PKEY_free ( ckey ) ; return 0 ; } DH_get0_key ( dh_clnt , & pub_key , NULL ) ; * len = BN_num_bytes ( pub_key ) ; s2n ( * len , * p ) ; BN_bn2bin ( pub_key , * p ) ; * len += 2 ; EVP_PKEY_free ( ckey ) ; return 1 ; # else SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; # endif }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data && ! ctx -> yv12_frame_buffers . use_frame_threads ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; return vp8dx_get_reference ( ctx -> yv12_frame_buffers . pbi [ 0 ] , frame -> frame_type , & sd ) ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-119 static EAS_RESULT PushcdlStack ( EAS_U32 * pStack , EAS_INT * pStackPtr , EAS_U32 value ) { <S2SV_StartBug> if ( * pStackPtr >= CDL_STACK_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return EAS_ERROR_FILE_FORMAT ; <S2SV_EndBug> * pStackPtr = * pStackPtr + 1 ; pStack [ * pStackPtr ] = value ; return EAS_SUCCESS ; }
CWE-399 static int ceph_x_decrypt ( struct ceph_crypto_key * secret , <S2SV_StartBug> void * * p , void * end , void * obuf , size_t olen ) <S2SV_EndBug> { struct ceph_x_encrypt_header head ; size_t head_len = sizeof ( head ) ; int len , ret ; len = ceph_decode_32 ( p ) ; if ( * p + len > end ) return - EINVAL ; dout ( "ceph_x_decrypt<S2SV_blank>len<S2SV_blank>%d\\n" , len ) ; <S2SV_StartBug> ret = ceph_decrypt2 ( secret , & head , & head_len , obuf , & olen , <S2SV_EndBug> * p , len ) ; if ( ret ) return ret ; if ( head . struct_v != 1 || le64_to_cpu ( head . magic ) != CEPHX_ENC_MAGIC ) return - EPERM ; * p += len ; return olen ; }
CWE-190 static void cpStripToTile ( uint8 * out , uint8 * in , <S2SV_StartBug> uint32 rows , uint32 cols , int outskew , int inskew ) <S2SV_EndBug> { while ( rows -- > 0 ) { uint32 j = cols ; while ( j -- > 0 ) * out ++ = * in ++ ; out += outskew ; in += inskew ; } }
CWE-119 static void update_layer_buffer_level ( SVC * svc , int encoded_frame_size ) { <S2SV_StartBug> int temporal_layer = 0 ; <S2SV_EndBug> int current_temporal_layer = svc -> temporal_layer_id ; <S2SV_StartBug> for ( temporal_layer = current_temporal_layer + 1 ; <S2SV_EndBug> <S2SV_StartBug> temporal_layer < svc -> number_temporal_layers ; ++ temporal_layer ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * lc = & svc -> layer_context [ temporal_layer ] ; <S2SV_EndBug> RATE_CONTROL * lrc = & lc -> rc ; int bits_off_for_this_layer = ( int ) ( lc -> target_bandwidth / lc -> framerate - encoded_frame_size ) ; lrc -> bits_off_target += bits_off_for_this_layer ; <S2SV_StartBug> lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lc -> maximum_buffer_size ) ; <S2SV_EndBug> lrc -> buffer_level = lrc -> bits_off_target ; } }
CWE-190 static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ; <S2SV_StartBug> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] >> shift ; entries [ i ] . green = cmap -> green [ i ] >> shift ; entries [ i ] . blue = cmap -> blue [ i ] >> shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ; }
CWE-284 int sock_send_fd ( int sock_fd , const uint8_t * buf , int len , int send_fd ) { ssize_t ret ; struct msghdr msg ; unsigned char * buffer = ( unsigned char * ) buf ; memset ( & msg , 0 , sizeof ( msg ) ) ; struct cmsghdr * cmsg ; char msgbuf [ CMSG_SPACE ( 1 ) ] ; asrt ( send_fd != - 1 ) ; if ( sock_fd == - 1 || send_fd == - 1 ) return - 1 ; msg . msg_control = msgbuf ; msg . msg_controllen = sizeof msgbuf ; cmsg = CMSG_FIRSTHDR ( & msg ) ; cmsg -> cmsg_level = SOL_SOCKET ; cmsg -> cmsg_type = SCM_RIGHTS ; cmsg -> cmsg_len = CMSG_LEN ( sizeof send_fd ) ; memcpy ( CMSG_DATA ( cmsg ) , & send_fd , sizeof send_fd ) ; int ret_len = len ; while ( len > 0 ) { struct iovec iv ; memset ( & iv , 0 , sizeof ( iv ) ) ; iv . iov_base = buffer ; iv . iov_len = len ; msg . msg_iov = & iv ; msg . msg_iovlen = 1 ; do { <S2SV_StartBug> ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ; <S2SV_EndBug> } while ( ret < 0 && errno == EINTR ) ; if ( ret < 0 ) { BTIF_TRACE_ERROR ( "fd:%d,<S2SV_blank>send_fd:%d,<S2SV_blank>sendmsg<S2SV_blank>ret:%d,<S2SV_blank>errno:%d,<S2SV_blank>%s" , sock_fd , send_fd , ( int ) ret , errno , strerror ( errno ) ) ; ret_len = - 1 ; break ; } buffer += ret ; len -= ret ; memset ( & msg , 0 , sizeof ( msg ) ) ; } BTIF_TRACE_DEBUG ( "close<S2SV_blank>fd:%d<S2SV_blank>after<S2SV_blank>sent" , send_fd ) ; close ( send_fd ) ; return ret_len ; }
CWE-000 int xfs_attr_rmtval_get ( struct xfs_da_args * args ) { struct xfs_bmbt_irec map [ ATTR_RMTVALUE_MAPSIZE ] ; struct xfs_mount * mp = args -> dp -> i_mount ; struct xfs_buf * bp ; xfs_dablk_t lblkno = args -> rmtblkno ; __uint8_t * dst = args -> value ; <S2SV_StartBug> int valuelen = args -> valuelen ; <S2SV_EndBug> int nmap ; int error ; int blkcnt = args -> rmtblkcnt ; int i ; int offset = 0 ; trace_xfs_attr_rmtval_get ( args ) ; <S2SV_StartBug> ASSERT ( ! ( args -> flags & ATTR_KERNOVAL ) ) ; <S2SV_EndBug> while ( valuelen > 0 ) { nmap = ATTR_RMTVALUE_MAPSIZE ; error = xfs_bmapi_read ( args -> dp , ( xfs_fileoff_t ) lblkno , blkcnt , map , & nmap , XFS_BMAPI_ATTRFORK ) ; if ( error ) return error ; ASSERT ( nmap >= 1 ) ; for ( i = 0 ; ( i < nmap ) && ( valuelen > 0 ) ; i ++ ) { xfs_daddr_t dblkno ; int dblkcnt ; ASSERT ( ( map [ i ] . br_startblock != DELAYSTARTBLOCK ) && ( map [ i ] . br_startblock != HOLESTARTBLOCK ) ) ; dblkno = XFS_FSB_TO_DADDR ( mp , map [ i ] . br_startblock ) ; dblkcnt = XFS_FSB_TO_BB ( mp , map [ i ] . br_blockcount ) ; error = xfs_trans_read_buf ( mp , NULL , mp -> m_ddev_targp , dblkno , dblkcnt , 0 , & bp , & xfs_attr3_rmt_buf_ops ) ; if ( error ) return error ; error = xfs_attr_rmtval_copyout ( mp , bp , args -> dp -> i_ino , & offset , & valuelen , & dst ) ; xfs_buf_relse ( bp ) ; if ( error ) return error ; lblkno += map [ i ] . br_blockcount ; blkcnt -= map [ i ] . br_blockcount ; } } ASSERT ( valuelen == 0 ) ; return 0 ; }
CWE-189 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; <S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug> write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
CWE-000 static int fsmMkfile ( rpmfi fi , const char * dest , rpmfiles files , rpmpsm psm , int nodigest , int * setmeta , int * firsthardlink ) { int rc = 0 ; int numHardlinks = rpmfiFNlink ( fi ) ; if ( numHardlinks > 1 ) { if ( * firsthardlink < 0 ) { * firsthardlink = rpmfiFX ( fi ) ; <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> } else { char * fn = rpmfilesFN ( files , * firsthardlink ) ; rc = link ( fn , dest ) ; if ( rc < 0 ) { rc = RPMERR_LINK_FAILED ; } free ( fn ) ; } } if ( numHardlinks <= 1 ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> } else if ( rpmfiArchiveHasContent ( fi ) ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> * firsthardlink = - 1 ; } else { * setmeta = 0 ; } return rc ; }
CWE-119 void vp9_update_spatial_layer_framerate ( VP9_COMP * const cpi , double framerate ) { <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> RATE_CONTROL * const lrc = & lc -> rc ; lc -> framerate = framerate ; <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> <S2SV_StartBug> lrc -> min_frame_bandwidth = ( int ) ( lrc -> av_per_frame_bandwidth * <S2SV_EndBug> oxcf -> two_pass_vbrmin_section / 100 ) ; <S2SV_StartBug> lrc -> max_frame_bandwidth = ( int ) ( ( ( int64_t ) lrc -> av_per_frame_bandwidth * <S2SV_EndBug> oxcf -> two_pass_vbrmax_section ) / 100 ) ; <S2SV_StartBug> lrc -> max_gf_interval = 16 ; <S2SV_EndBug> lrc -> static_scene_max_gf_interval = cpi -> key_frame_frequency >> 1 ; if ( oxcf -> play_alternate && oxcf -> lag_in_frames ) { if ( lrc -> max_gf_interval > oxcf -> lag_in_frames - 1 ) lrc -> max_gf_interval = oxcf -> lag_in_frames - 1 ; if ( lrc -> static_scene_max_gf_interval > oxcf -> lag_in_frames - 1 ) lrc -> static_scene_max_gf_interval = oxcf -> lag_in_frames - 1 ; } if ( lrc -> max_gf_interval > lrc -> static_scene_max_gf_interval ) lrc -> max_gf_interval = lrc -> static_scene_max_gf_interval ; }
CWE-125 static int telnet_parse ( netdissect_options * ndo , const u_char * sp , u_int length , int print ) { int i , x ; u_int c ; const u_char * osp , * p ; # define FETCH ( c , sp , length ) do { if ( length < 1 ) goto pktend ; ND_TCHECK ( * sp ) ; c = * sp ++ ; length -- ; } while ( 0 ) osp = sp ; FETCH ( c , sp , length ) ; if ( c != IAC ) goto pktend ; FETCH ( c , sp , length ) ; if ( c == IAC ) { if ( print ) ND_PRINT ( ( ndo , "IAC<S2SV_blank>IAC" ) ) ; goto done ; } i = c - TELCMD_FIRST ; if ( i < 0 || i > IAC - TELCMD_FIRST ) goto pktend ; switch ( c ) { case DONT : case DO : case WONT : case WILL : case SB : FETCH ( x , sp , length ) ; if ( x >= 0 && x < NTELOPTS ) { if ( print ) ND_PRINT ( ( ndo , "%s<S2SV_blank>%s" , telcmds [ i ] , telopts [ x ] ) ) ; } else { if ( print ) ND_PRINT ( ( ndo , "%s<S2SV_blank>%#x" , telcmds [ i ] , x ) ) ; } if ( c != SB ) break ; p = sp ; while ( length > ( u_int ) ( p + 1 - sp ) ) { ND_TCHECK2 ( * p , 2 ) ; if ( p [ 0 ] == IAC && p [ 1 ] == SE ) break ; p ++ ; } <S2SV_StartBug> if ( * p != IAC ) <S2SV_EndBug> goto pktend ; switch ( x ) { case TELOPT_AUTHENTICATION : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , STR_OR_ID ( c , authcmd ) ) ) ; if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , STR_OR_ID ( c , authtype ) ) ) ; break ; case TELOPT_ENCRYPT : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , STR_OR_ID ( c , enccmd ) ) ) ; if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , STR_OR_ID ( c , enctype ) ) ) ; break ; default : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , STR_OR_ID ( c , cmds ) ) ) ; break ; } while ( p > sp ) { FETCH ( x , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , "<S2SV_blank>%#x" , x ) ) ; } if ( print ) ND_PRINT ( ( ndo , "<S2SV_blank>SE" ) ) ; sp += 2 ; break ; default : if ( print ) ND_PRINT ( ( ndo , "%s" , telcmds [ i ] ) ) ; goto done ; } done : return sp - osp ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; pktend : return - 1 ; # undef FETCH }
CWE-20 static void snd_timer_check_master ( struct snd_timer_instance * master ) { struct snd_timer_instance * slave , * tmp ; list_for_each_entry_safe ( slave , tmp , & snd_timer_slave_list , open_list ) { if ( slave -> slave_class == master -> slave_class && slave -> slave_id == master -> slave_id ) { list_move_tail ( & slave -> open_list , & master -> slave_list_head ) ; spin_lock_irq ( & slave_active_lock ) ; <S2SV_StartBug> slave -> master = master ; <S2SV_EndBug> slave -> timer = master -> timer ; if ( slave -> flags & SNDRV_TIMER_IFLG_RUNNING ) list_add_tail ( & slave -> active_list , & master -> slave_active_head ) ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> } } }
CWE-415 void * gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageWBMPCtx ( im , fg , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-284 void GKI_delay ( UINT32 timeout_ms ) { struct timespec delay ; delay . tv_sec = timeout_ms / 1000 ; delay . tv_nsec = 1000 * 1000 * ( timeout_ms % 1000 ) ; int err ; do { <S2SV_StartBug> err = nanosleep ( & delay , & delay ) ; <S2SV_EndBug> } while ( err == - 1 && errno == EINTR ) ; }
CWE-119 void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col , const struct scale_factors * sf ) { if ( src != NULL ) { int i ; <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col , sf , pd -> subsampling_x , pd -> subsampling_y ) ; } } }
CWE-000 static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; int flags = 0 ; newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> num = inet_sk ( oldsk ) -> num ; if ( PF_INET6 == assoc -> base . sk -> sk_family ) flags = SCTP_ADDR6_ALLOWED ; if ( assoc -> peer . ipv4_address ) flags |= SCTP_ADDR4_PEERSUPP ; if ( assoc -> peer . ipv6_address ) flags |= SCTP_ADDR6_PEERSUPP ; sctp_bind_addr_copy ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , SCTP_SCOPE_GLOBAL , GFP_KERNEL , flags ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> } } skb_queue_head_init ( & newsp -> pd_lobby ) ; sctp_sk ( newsk ) -> pd_mode = assoc -> ulpq . pd_mode ; if ( sctp_sk ( oldsk ) -> pd_mode ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> } } if ( assoc -> ulpq . pd_mode ) <S2SV_StartBug> sctp_clear_pd ( oldsk ) ; <S2SV_EndBug> } newsp -> type = type ; sctp_lock_sock ( newsk ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; sctp_release_sock ( newsk ) ; }
CWE-125 static MagickBooleanType load_tile ( Image * image , Image * tile_image , XCFDocInfo * inDocInfo , XCFLayerInfo * inLayerInfo , size_t data_length , ExceptionInfo * exception ) { ssize_t y ; register ssize_t x ; register Quantum * q ; ssize_t count ; unsigned char * graydata ; XCFPixelInfo * xcfdata , * xcfodata ; <S2SV_StartBug> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <S2SV_EndBug> if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , image -> filename ) ; xcfodata = xcfdata ; graydata = ( unsigned char * ) xcfdata ; count = ReadBlob ( image , data_length , ( unsigned char * ) xcfdata ) ; if ( count != ( ssize_t ) data_length ) ThrowBinaryException ( CorruptImageError , "NotEnoughPixelData" , image -> filename ) ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { q = GetAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( inDocInfo -> image_type == GIMP_GRAY ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelGray ( tile_image , ScaleCharToQuantum ( * graydata ) , q ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; graydata ++ ; q += GetPixelChannels ( tile_image ) ; } } else if ( inDocInfo -> image_type == GIMP_RGB ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelRed ( tile_image , ScaleCharToQuantum ( xcfdata -> red ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( xcfdata -> green ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( xcfdata -> blue ) , q ) ; SetPixelAlpha ( tile_image , xcfdata -> alpha == 255U ? TransparentAlpha : ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; xcfdata ++ ; q += GetPixelChannels ( tile_image ) ; } } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; } xcfodata = ( XCFPixelInfo * ) RelinquishMagickMemory ( xcfodata ) ; return MagickTrue ; }
CWE-476 smb_sdrc_t smb_com_flush ( smb_request_t * sr ) { smb_ofile_t * file ; smb_llist_t * flist ; int rc ; if ( smb_flush_required == 0 ) { rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; } if ( sr -> smb_fid != 0xffff ) { smbsr_lookup_file ( sr ) ; if ( sr -> fid_ofile == NULL ) { smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ; return ( SDRC_ERROR ) ; } <S2SV_StartBug> smb_flush_file ( sr , sr -> fid_ofile ) ; <S2SV_EndBug> } else { flist = & sr -> tid_tree -> t_ofile_list ; smb_llist_enter ( flist , RW_READER ) ; file = smb_llist_head ( flist ) ; while ( file ) { mutex_enter ( & file -> f_mutex ) ; <S2SV_StartBug> smb_flush_file ( sr , file ) ; <S2SV_EndBug> mutex_exit ( & file -> f_mutex ) ; file = smb_llist_next ( flist , file ) ; } smb_llist_exit ( flist ) ; } rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; }
CWE-189 Datum bqarr_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; WORKSTATE state ; int32 i ; QUERYTYPE * query ; int32 commonlen ; ITEM * ptr ; NODE * tmp ; int32 pos = 0 ; # ifdef BS_DEBUG StringInfoData pbuf ; # endif state . buf = buf ; state . state = WAITOPERAND ; state . count = 0 ; state . num = 0 ; state . str = NULL ; makepol ( & state ) ; if ( ! state . num ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_PARAMETER_VALUE ) , errmsg ( "empty<S2SV_blank>query" ) ) ) ; <S2SV_StartBug> commonlen = COMPUTESIZE ( state . num ) ; <S2SV_EndBug> query = ( QUERYTYPE * ) palloc ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = state . num ; ptr = GETQUERY ( query ) ; for ( i = state . num - 1 ; i >= 0 ; i -- ) { ptr [ i ] . type = state . str -> type ; ptr [ i ] . val = state . str -> val ; tmp = state . str -> next ; pfree ( state . str ) ; state . str = tmp ; } pos = query -> size - 1 ; findoprnd ( ptr , & pos ) ; # ifdef BS_DEBUG initStringInfo ( & pbuf ) ; for ( i = 0 ; i < query -> size ; i ++ ) { if ( ptr [ i ] . type == OPR ) appendStringInfo ( & pbuf , "%c(%d)<S2SV_blank>" , ptr [ i ] . val , ptr [ i ] . left ) ; else appendStringInfo ( & pbuf , "%d<S2SV_blank>" , ptr [ i ] . val ) ; } elog ( DEBUG3 , "POR:<S2SV_blank>%s" , pbuf . data ) ; pfree ( pbuf . data ) ; # endif PG_RETURN_POINTER ( query ) ; }
CWE-000 static void start_auth_request ( PgSocket * client , const char * username ) { int res ; PktBuf * buf ; <S2SV_StartBug> client -> auth_user = client -> db -> auth_user ; <S2SV_EndBug> client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ; if ( ! find_server ( client ) ) { client -> wait_for_user_conn = true ; return ; } slog_noise ( client , "Doing<S2SV_blank>auth_conn<S2SV_blank>query" ) ; client -> wait_for_user_conn = false ; client -> wait_for_user = true ; if ( ! sbuf_pause ( & client -> sbuf ) ) { release_server ( client -> link ) ; disconnect_client ( client , true , "pause<S2SV_blank>failed" ) ; return ; } client -> link -> ready = 0 ; res = 0 ; buf = pktbuf_dynamic ( 512 ) ; if ( buf ) { pktbuf_write_ExtQuery ( buf , cf_auth_query , 1 , username ) ; res = pktbuf_send_immediate ( buf , client -> link ) ; pktbuf_free ( buf ) ; } if ( ! res ) disconnect_server ( client -> link , false , "unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>login<S2SV_blank>query" ) ; }
CWE-125 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
CWE-264 int append_camera_metadata ( camera_metadata_t * dst , const camera_metadata_t * src ) { <S2SV_StartBug> if ( dst == NULL || src == NULL ) return ERROR ; <S2SV_EndBug> if ( dst -> entry_capacity < src -> entry_count + dst -> entry_count ) return ERROR ; if ( dst -> data_capacity < src -> data_count + dst -> data_count ) return ERROR ; memcpy ( get_entries ( dst ) + dst -> entry_count , get_entries ( src ) , sizeof ( camera_metadata_buffer_entry_t [ src -> entry_count ] ) ) ; memcpy ( get_data ( dst ) + dst -> data_count , get_data ( src ) , sizeof ( uint8_t [ src -> data_count ] ) ) ; if ( dst -> data_count != 0 ) { camera_metadata_buffer_entry_t * entry = get_entries ( dst ) + dst -> entry_count ; for ( size_t i = 0 ; i < src -> entry_count ; i ++ , entry ++ ) { if ( calculate_camera_metadata_entry_data_size ( entry -> type , entry -> count ) > 0 ) { entry -> data . offset += dst -> data_count ; } } } if ( dst -> entry_count == 0 ) { dst -> flags |= src -> flags & FLAG_SORTED ; } else if ( src -> entry_count != 0 ) { dst -> flags &= ~ FLAG_SORTED ; } else { } dst -> entry_count += src -> entry_count ; dst -> data_count += src -> data_count ; assert ( validate_camera_metadata_structure ( dst , NULL ) == OK ) ; return OK ; }
CWE-119 void update_rate_histogram ( struct rate_hist * hist , const vpx_codec_enc_cfg_t * cfg , const vpx_codec_cx_pkt_t * pkt ) { int i ; int64_t then = 0 ; int64_t avg_bitrate = 0 ; int64_t sum_sz = 0 ; const int64_t now = pkt -> data . frame . pts * 1000 * ( uint64_t ) cfg -> g_timebase . num / ( uint64_t ) cfg -> g_timebase . den ; int idx = hist -> frames ++ % hist -> samples ; hist -> pts [ idx ] = now ; hist -> sz [ idx ] = ( int ) pkt -> data . frame . sz ; if ( now < cfg -> rc_buf_initial_sz ) return ; <S2SV_StartBug> then = now ; <S2SV_EndBug> for ( i = hist -> frames ; i > 0 && hist -> frames - i < hist -> samples ; i -- ) { const int i_idx = ( i - 1 ) % hist -> samples ; then = hist -> pts [ i_idx ] ; if ( now - then > cfg -> rc_buf_sz ) break ; sum_sz += hist -> sz [ i_idx ] ; } if ( now == then ) return ; avg_bitrate = sum_sz * 8 * 1000 / ( now - then ) ; idx = ( int ) ( avg_bitrate * ( RATE_BINS / 2 ) / ( cfg -> rc_target_bitrate * 1000 ) ) ; if ( idx < 0 ) idx = 0 ; if ( idx > RATE_BINS - 1 ) idx = RATE_BINS - 1 ; if ( hist -> bucket [ idx ] . low > avg_bitrate ) hist -> bucket [ idx ] . low = ( int ) avg_bitrate ; if ( hist -> bucket [ idx ] . high < avg_bitrate ) hist -> bucket [ idx ] . high = ( int ) avg_bitrate ; hist -> bucket [ idx ] . count ++ ; hist -> total ++ ; }
CWE-200 static bool_t svcauth_gss_accept_sec_context ( struct svc_req * rqst , struct rpc_gss_init_res * gr ) { struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; gss_buffer_desc recv_tok , seqbuf ; gss_OID mech ; OM_uint32 maj_stat = 0 , min_stat = 0 , ret_flags , seq ; log_debug ( "in<S2SV_blank>svcauth_gss_accept_context()" ) ; gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gr , 0 , sizeof ( * gr ) ) ; memset ( & recv_tok , 0 , sizeof ( recv_tok ) ) ; if ( ! svc_getargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ) return ( FALSE ) ; gr -> gr_major = gss_accept_sec_context ( & gr -> gr_minor , & gd -> ctx , svcauth_gss_creds , & recv_tok , GSS_C_NO_CHANNEL_BINDINGS , & gd -> client_name , & mech , & gr -> gr_token , & ret_flags , NULL , NULL ) ; svc_freeargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ; log_status ( "accept_sec_context" , gr -> gr_major , gr -> gr_minor ) ; if ( gr -> gr_major != GSS_S_COMPLETE && gr -> gr_major != GSS_S_CONTINUE_NEEDED ) { badauth ( gr -> gr_major , gr -> gr_minor , rqst -> rq_xprt ) ; gd -> ctx = GSS_C_NO_CONTEXT ; goto errout ; } <S2SV_StartBug> if ( ( gr -> gr_ctx . value = mem_alloc ( sizeof ( gss_union_ctx_id_desc ) ) ) == NULL ) { <S2SV_EndBug> fprintf ( stderr , "svcauth_gss_accept_context:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n" ) ; goto errout ; } <S2SV_StartBug> memcpy ( gr -> gr_ctx . value , gd -> ctx , sizeof ( gss_union_ctx_id_desc ) ) ; <S2SV_EndBug> gr -> gr_ctx . length = sizeof ( gss_union_ctx_id_desc ) ; gr -> gr_win = sizeof ( gd -> seqmask ) * 8 ; gd -> sec . mech = mech ; gd -> sec . qop = GSS_C_QOP_DEFAULT ; gd -> sec . svc = gc -> gc_svc ; gd -> seq = gc -> gc_seq ; gd -> win = gr -> gr_win ; if ( gr -> gr_major == GSS_S_COMPLETE ) { # ifdef SPKM if ( ! g_OID_equal ( gss_mech_spkm3 , mech ) ) { # endif maj_stat = gss_display_name ( & min_stat , gd -> client_name , & gd -> cname , & gd -> sec . mech ) ; # ifdef SPKM } # endif if ( maj_stat != GSS_S_COMPLETE ) { log_status ( "display_name" , maj_stat , min_stat ) ; goto errout ; } # ifdef DEBUG # ifdef HAVE_HEIMDAL log_debug ( "accepted<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%.*s<S2SV_blank>with<S2SV_blank>" "<mech<S2SV_blank>{},<S2SV_blank>qop<S2SV_blank>%d,<S2SV_blank>svc<S2SV_blank>%d>" , gd -> cname . length , ( char * ) gd -> cname . value , gd -> sec . qop , gd -> sec . svc ) ; # else { gss_buffer_desc mechname ; gss_oid_to_str ( & min_stat , mech , & mechname ) ; log_debug ( "accepted<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%.*s<S2SV_blank>with<S2SV_blank>" "<mech<S2SV_blank>%.*s,<S2SV_blank>qop<S2SV_blank>%d,<S2SV_blank>svc<S2SV_blank>%d>" , gd -> cname . length , ( char * ) gd -> cname . value , mechname . length , ( char * ) mechname . value , gd -> sec . qop , gd -> sec . svc ) ; gss_release_buffer ( & min_stat , & mechname ) ; } # endif # endif seq = htonl ( gr -> gr_win ) ; seqbuf . value = & seq ; seqbuf . length = sizeof ( seq ) ; gss_release_buffer ( & min_stat , & gd -> checksum ) ; maj_stat = gss_sign ( & min_stat , gd -> ctx , GSS_C_QOP_DEFAULT , & seqbuf , & gd -> checksum ) ; if ( maj_stat != GSS_S_COMPLETE ) { goto errout ; } rqst -> rq_xprt -> xp_verf . oa_flavor = RPCSEC_GSS ; rqst -> rq_xprt -> xp_verf . oa_base = gd -> checksum . value ; rqst -> rq_xprt -> xp_verf . oa_length = gd -> checksum . length ; } return ( TRUE ) ; errout : gss_release_buffer ( & min_stat , & gr -> gr_token ) ; return ( FALSE ) ; }
CWE-000 static uint16_t http_dissect_hdrs ( struct worker * w , struct http * hp , int fd , char * p , const struct http_conn * htc ) { char * q , * r ; txt t = htc -> rxbuf ; if ( * p == '\\r' ) p ++ ; hp -> nhd = HTTP_HDR_FIRST ; hp -> conds = 0 ; r = NULL ; for ( ; p < t . e ; p = r ) { q = r = p ; while ( r < t . e ) { <S2SV_StartBug> if ( ! vct_iscrlf ( * r ) ) { <S2SV_EndBug> r ++ ; continue ; } q = r ; assert ( r < t . e ) ; r += vct_skipcrlf ( r ) ; if ( r >= t . e ) break ; if ( ! vct_issp ( * r ) ) break ; while ( vct_islws ( * q ) ) * q ++ = '<S2SV_blank>' ; } if ( q - p > htc -> maxhdr ) { VSC_C_main -> losthdr ++ ; WSL ( w , SLT_LostHeader , fd , "%.*s" , q - p > 20 ? 20 : q - p , p ) ; return ( 413 ) ; } if ( p == q ) break ; if ( ( p [ 0 ] == 'i' || p [ 0 ] == 'I' ) && ( p [ 1 ] == 'f' || p [ 1 ] == 'F' ) && p [ 2 ] == '-' ) hp -> conds = 1 ; while ( q > p && vct_issp ( q [ - 1 ] ) ) q -- ; * q = '\\0' ; if ( hp -> nhd < hp -> shd ) { hp -> hdf [ hp -> nhd ] = 0 ; hp -> hd [ hp -> nhd ] . b = p ; hp -> hd [ hp -> nhd ] . e = q ; WSLH ( w , fd , hp , hp -> nhd ) ; hp -> nhd ++ ; } else { VSC_C_main -> losthdr ++ ; WSL ( w , SLT_LostHeader , fd , "%.*s" , q - p > 20 ? 20 : q - p , p ) ; return ( 413 ) ; } } return ( 0 ) ; }
CWE-399 void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = NULL ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ; # define LOCAL_OK 1 # define BRD_OK 2 # define BRD0_OK 4 # define BRD1_OK 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & IFA_F_SECONDARY ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( "%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\n" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( "%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\n" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & IFA_F_NOPREFIXROUTE ) ) fib_magic ( RTM_DELROUTE , dev -> flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; } <S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= LOCAL_OK ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= BRD_OK ; if ( brd == ifa1 -> ifa_broadcast ) ok |= BRD1_OK ; if ( any == ifa1 -> ifa_broadcast ) ok |= BRD0_OK ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= BRD_OK ; if ( brd == brd1 || brd == any1 ) ok |= BRD1_OK ; if ( any == brd1 || any == any1 ) ok |= BRD0_OK ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & BRD1_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , brd , 32 , prim ) ; if ( ! ( ok & BRD0_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , any , 32 , prim ) ; } if ( ! ( ok & LOCAL_OK ) ) { unsigned int addr_type ; fib_magic ( RTM_DELROUTE , RTN_LOCAL , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != RTN_LOCAL ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } } # undef LOCAL_OK # undef BRD_OK # undef BRD0_OK # undef BRD1_OK }
CWE-119 <S2SV_StartBug> static int detect_flash ( const struct twopass_rc * twopass , int offset ) { <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS next_frame ; <S2SV_EndBug> int flash_detected = 0 ; <S2SV_StartBug> if ( read_frame_stats ( twopass , & next_frame , offset ) != EOF ) { <S2SV_EndBug> <S2SV_StartBug> if ( next_frame . pcnt_second_ref > next_frame . pcnt_inter && <S2SV_EndBug> <S2SV_StartBug> next_frame . pcnt_second_ref >= 0.5 ) <S2SV_EndBug> flash_detected = 1 ; } return flash_detected ; }
CWE-000 void * gstd_accept ( int fd , char * * display_creds , char * * export_name , char * * mech ) { gss_name_t client ; gss_OID mech_oid ; struct gstd_tok * tok ; gss_ctx_id_t ctx = GSS_C_NO_CONTEXT ; gss_buffer_desc in , out ; OM_uint32 maj , min ; int ret ; * display_creds = NULL ; * export_name = NULL ; out . length = 0 ; in . length = 0 ; read_packet ( fd , & in , 60000 , 1 ) ; again : while ( ( ret = read_packet ( fd , & in , 60000 , 0 ) ) == - 2 ) ; if ( ret < 1 ) return NULL ; maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL , <S2SV_StartBug> NULL , NULL ) ; <S2SV_EndBug> if ( out . length && write_packet ( fd , & out ) ) { gss_release_buffer ( & min , & out ) ; return NULL ; } <S2SV_StartBug> GSTD_GSS_ERROR ( maj , min , NULL , "gss_accept_sec_context" ) ; <S2SV_EndBug> if ( maj & GSS_S_CONTINUE_NEEDED ) goto again ; * display_creds = gstd_get_display_name ( client ) ; * export_name = gstd_get_export_name ( client ) ; * mech = gstd_get_mech ( mech_oid ) ; gss_release_name ( & min , & client ) ; SETUP_GSTD_TOK ( tok , ctx , fd , "gstd_accept" ) ; return tok ; }
CWE-000 static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps ) <S2SV_StartBug> { <S2SV_EndBug> mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; memcpy ( & kvm -> arch . vpit -> pit_state , ps , sizeof ( struct kvm_pit_state ) ) ; <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ; <S2SV_EndBug> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }
CWE-476 int megasas_alloc_cmds ( struct megasas_instance * instance ) { int i ; int j ; u16 max_cmd ; struct megasas_cmd * cmd ; max_cmd = instance -> max_mfi_cmds ; instance -> cmd_list = kcalloc ( max_cmd , sizeof ( struct megasas_cmd * ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , "out<S2SV_blank>of<S2SV_blank>memory\\n" ) ; return - ENOMEM ; } memset ( instance -> cmd_list , 0 , sizeof ( struct megasas_cmd * ) * max_cmd ) ; for ( i = 0 ; i < max_cmd ; i ++ ) { instance -> cmd_list [ i ] = kmalloc ( sizeof ( struct megasas_cmd ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list [ i ] ) { for ( j = 0 ; j < i ; j ++ ) kfree ( instance -> cmd_list [ j ] ) ; kfree ( instance -> cmd_list ) ; instance -> cmd_list = NULL ; return - ENOMEM ; } } for ( i = 0 ; i < max_cmd ; i ++ ) { cmd = instance -> cmd_list [ i ] ; memset ( cmd , 0 , sizeof ( struct megasas_cmd ) ) ; cmd -> index = i ; cmd -> scmd = NULL ; cmd -> instance = instance ; list_add_tail ( & cmd -> list , & instance -> cmd_pool ) ; } if ( megasas_create_frame_pool ( instance ) ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , "Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n" ) ; megasas_free_cmds ( instance ) ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
CWE-399 static struct kioctx * ioctx_alloc ( unsigned nr_events ) { struct mm_struct * mm = current -> mm ; struct kioctx * ctx ; int err = - ENOMEM ; nr_events = max ( nr_events , num_possible_cpus ( ) * 4 ) ; nr_events *= 2 ; if ( ( nr_events > ( 0x10000000U / sizeof ( struct io_event ) ) ) || ( nr_events > ( 0x10000000U / sizeof ( struct kiocb ) ) ) ) { pr_debug ( "ENOMEM:<S2SV_blank>nr_events<S2SV_blank>too<S2SV_blank>high\\n" ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! nr_events || ( unsigned long ) nr_events > ( aio_max_nr * 2UL ) ) return ERR_PTR ( - EAGAIN ) ; ctx = kmem_cache_zalloc ( kioctx_cachep , GFP_KERNEL ) ; if ( ! ctx ) return ERR_PTR ( - ENOMEM ) ; ctx -> max_reqs = nr_events ; if ( percpu_ref_init ( & ctx -> users , free_ioctx_users ) ) goto err ; if ( percpu_ref_init ( & ctx -> reqs , free_ioctx_reqs ) ) goto err ; spin_lock_init ( & ctx -> ctx_lock ) ; spin_lock_init ( & ctx -> completion_lock ) ; mutex_init ( & ctx -> ring_lock ) ; init_waitqueue_head ( & ctx -> wait ) ; INIT_LIST_HEAD ( & ctx -> active_reqs ) ; ctx -> cpu = alloc_percpu ( struct kioctx_cpu ) ; if ( ! ctx -> cpu ) goto err ; if ( aio_setup_ring ( ctx ) < 0 ) goto err ; atomic_set ( & ctx -> reqs_available , ctx -> nr_events - 1 ) ; ctx -> req_batch = ( ctx -> nr_events - 1 ) / ( num_possible_cpus ( ) * 4 ) ; if ( ctx -> req_batch < 1 ) ctx -> req_batch = 1 ; spin_lock ( & aio_nr_lock ) ; if ( aio_nr + nr_events > ( aio_max_nr * 2UL ) || aio_nr + nr_events < aio_nr ) { spin_unlock ( & aio_nr_lock ) ; err = - EAGAIN ; goto err ; } aio_nr += ctx -> max_reqs ; spin_unlock ( & aio_nr_lock ) ; percpu_ref_get ( & ctx -> users ) ; err = ioctx_add_table ( ctx , mm ) ; if ( err ) goto err_cleanup ; pr_debug ( "allocated<S2SV_blank>ioctx<S2SV_blank>%p[%ld]:<S2SV_blank>mm=%p<S2SV_blank>mask=0x%x\\n" , ctx , ctx -> user_id , mm , ctx -> nr_events ) ; return ctx ; err_cleanup : aio_nr_sub ( ctx -> max_reqs ) ; err : <S2SV_StartBug> aio_free_ring ( ctx ) ; <S2SV_EndBug> free_percpu ( ctx -> cpu ) ; free_percpu ( ctx -> reqs . pcpu_count ) ; free_percpu ( ctx -> users . pcpu_count ) ; kmem_cache_free ( kioctx_cachep , ctx ) ; pr_debug ( "error<S2SV_blank>allocating<S2SV_blank>ioctx<S2SV_blank>%d\\n" , err ) ; return ERR_PTR ( err ) ; }
CWE-119 void vp9_set_contexts ( const MACROBLOCKD * xd , struct macroblockd_plane * pd , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , int has_eob , int aoff , int loff ) { ENTROPY_CONTEXT * const a = pd -> above_context + aoff ; ENTROPY_CONTEXT * const l = pd -> left_context + loff ; const int tx_size_in_blocks = 1 << tx_size ; if ( has_eob && xd -> mb_to_right_edge < 0 ) { int i ; const int blocks_wide = num_4x4_blocks_wide_lookup [ plane_bsize ] + ( xd -> mb_to_right_edge >> ( 5 + pd -> subsampling_x ) ) ; int above_contexts = tx_size_in_blocks ; if ( above_contexts + aoff > blocks_wide ) above_contexts = blocks_wide - aoff ; for ( i = 0 ; i < above_contexts ; ++ i ) a [ i ] = has_eob ; for ( i = above_contexts ; i < tx_size_in_blocks ; ++ i ) a [ i ] = 0 ; } else { <S2SV_StartBug> vpx_memset ( a , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <S2SV_EndBug> } if ( has_eob && xd -> mb_to_bottom_edge < 0 ) { int i ; const int blocks_high = num_4x4_blocks_high_lookup [ plane_bsize ] + ( xd -> mb_to_bottom_edge >> ( 5 + pd -> subsampling_y ) ) ; int left_contexts = tx_size_in_blocks ; if ( left_contexts + loff > blocks_high ) left_contexts = blocks_high - loff ; for ( i = 0 ; i < left_contexts ; ++ i ) l [ i ] = has_eob ; for ( i = left_contexts ; i < tx_size_in_blocks ; ++ i ) l [ i ] = 0 ; } else { <S2SV_StartBug> vpx_memset ( l , has_eob , sizeof ( ENTROPY_CONTEXT ) * tx_size_in_blocks ) ; <S2SV_EndBug> } }
CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments." ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading." , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , "wb" ) ) ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing." , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( "Couldn\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\n" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( "Unknown<S2SV_blank>input<S2SV_blank>codec." ) ; <S2SV_StartBug> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder." ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame." ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( "Processed<S2SV_blank>%d<S2SV_blank>frames.\\n" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec." ) ; printf ( "Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }
CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( "ping_unhash(isk=%p,isk->num=%u)\\n" , isk , isk -> inet_num ) ; <S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> hlist_nulls_del ( & sk -> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ; sock_put ( sk ) ; isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static void update_buffer_level ( VP9_COMP * cpi , int encoded_frame_size ) { <S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; RATE_CONTROL * const rc = & cpi -> rc ; if ( ! cm -> show_frame ) { rc -> bits_off_target -= encoded_frame_size ; } else { <S2SV_StartBug> rc -> bits_off_target += rc -> av_per_frame_bandwidth - encoded_frame_size ; <S2SV_EndBug> } <S2SV_StartBug> rc -> bits_off_target = MIN ( rc -> bits_off_target , oxcf -> maximum_buffer_size ) ; <S2SV_EndBug> rc -> buffer_level = rc -> bits_off_target ; <S2SV_StartBug> if ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> update_layer_buffer_level ( & cpi -> svc , encoded_frame_size ) ; } }
CWE-284 static int tcp_v6_do_rcv ( struct sock * sk , struct sk_buff * skb ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp ; struct sk_buff * opt_skb = NULL ; if ( skb -> protocol == htons ( ETH_P_IP ) ) return tcp_v4_do_rcv ( sk , skb ) ; <S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> goto discard ; if ( np -> rxopt . all ) opt_skb = skb_clone ( skb , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; if ( sk -> sk_state == TCP_ESTABLISHED ) { struct dst_entry * dst = sk -> sk_rx_dst ; sock_rps_save_rxhash ( sk , skb ) ; sk_mark_napi_id ( sk , skb ) ; if ( dst ) { if ( inet_sk ( sk ) -> rx_dst_ifindex != skb -> skb_iif || dst -> ops -> check ( dst , np -> rx_dst_cookie ) == NULL ) { dst_release ( dst ) ; sk -> sk_rx_dst = NULL ; } } tcp_rcv_established ( sk , skb , tcp_hdr ( skb ) , skb -> len ) ; if ( opt_skb ) goto ipv6_pktoptions ; return 0 ; } if ( tcp_checksum_complete ( skb ) ) goto csum_err ; if ( sk -> sk_state == TCP_LISTEN ) { struct sock * nsk = tcp_v6_cookie_check ( sk , skb ) ; if ( ! nsk ) goto discard ; if ( nsk != sk ) { sock_rps_save_rxhash ( nsk , skb ) ; sk_mark_napi_id ( nsk , skb ) ; if ( tcp_child_process ( sk , nsk , skb ) ) goto reset ; if ( opt_skb ) __kfree_skb ( opt_skb ) ; return 0 ; } } else sock_rps_save_rxhash ( sk , skb ) ; if ( tcp_rcv_state_process ( sk , skb ) ) goto reset ; if ( opt_skb ) goto ipv6_pktoptions ; return 0 ; reset : tcp_v6_send_reset ( sk , skb ) ; discard : if ( opt_skb ) __kfree_skb ( opt_skb ) ; kfree_skb ( skb ) ; return 0 ; csum_err : TCP_INC_STATS ( sock_net ( sk ) , TCP_MIB_CSUMERRORS ) ; TCP_INC_STATS ( sock_net ( sk ) , TCP_MIB_INERRS ) ; goto discard ; ipv6_pktoptions : tp = tcp_sk ( sk ) ; if ( TCP_SKB_CB ( opt_skb ) -> end_seq == tp -> rcv_nxt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) ) { if ( np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo ) np -> mcast_oif = tcp_v6_iif ( opt_skb ) ; if ( np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) np -> mcast_hops = ipv6_hdr ( opt_skb ) -> hop_limit ; if ( np -> rxopt . bits . rxflow || np -> rxopt . bits . rxtclass ) np -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( opt_skb ) ) ; if ( np -> repflow ) np -> flow_label = ip6_flowlabel ( ipv6_hdr ( opt_skb ) ) ; if ( ipv6_opt_accepted ( sk , opt_skb , & TCP_SKB_CB ( opt_skb ) -> header . h6 ) ) { skb_set_owner_r ( opt_skb , sk ) ; tcp_v6_restore_cb ( opt_skb ) ; opt_skb = xchg ( & np -> pktoptions , opt_skb ) ; } else { __kfree_skb ( opt_skb ) ; opt_skb = xchg ( & np -> pktoptions , NULL ) ; } } kfree_skb ( opt_skb ) ; return 0 ; }
CWE-000 static int lockd ( void * vrqstp ) { int err = 0 ; <S2SV_StartBug> struct svc_rqst * rqstp = vrqstp ; <S2SV_EndBug> set_freezable ( ) ; allow_signal ( SIGKILL ) ; dprintk ( "NFS<S2SV_blank>locking<S2SV_blank>service<S2SV_blank>started<S2SV_blank>(ver<S2SV_blank>" LOCKD_VERSION ").\\n" ) ; while ( ! kthread_should_stop ( ) ) { long timeout = MAX_SCHEDULE_TIMEOUT ; RPC_IFDEBUG ( char buf [ RPC_MAX_ADDRBUFLEN ] ) ; rqstp -> rq_server -> sv_maxconn = nlm_max_connections ; if ( signalled ( ) ) { flush_signals ( current ) ; restart_grace ( ) ; continue ; } timeout = nlmsvc_retry_blocked ( ) ; err = svc_recv ( rqstp , timeout ) ; if ( err == - EAGAIN || err == - EINTR ) continue ; dprintk ( "lockd:<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s\\n" , svc_print_addr ( rqstp , buf , sizeof ( buf ) ) ) ; svc_process ( rqstp ) ; } flush_signals ( current ) ; if ( nlmsvc_ops ) nlmsvc_invalidate_all ( ) ; nlm_shutdown_hosts ( ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-200 void __ip_select_ident ( struct iphdr * iph , int segs ) { static u32 ip_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
CWE-200 static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ; unsigned int copylen ; struct net * net = sock_net ( sk ) ; struct netns_ipvs * ipvs = net_ipvs ( net ) ; BUG_ON ( ! net ) ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL ; if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( "get_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u\\n" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; if ( copy_from_user ( arg , user , copylen ) != 0 ) return - EFAULT ; if ( cmd == IP_VS_SO_GET_DAEMON ) { struct ip_vs_daemon_user d [ 2 ] ; memset ( & d , 0 , sizeof ( d ) ) ; if ( mutex_lock_interruptible ( & ipvs -> sync_mutex ) ) return - ERESTARTSYS ; if ( ipvs -> sync_state & IP_VS_STATE_MASTER ) { d [ 0 ] . state = IP_VS_STATE_MASTER ; strlcpy ( d [ 0 ] . mcast_ifn , ipvs -> master_mcast_ifn , sizeof ( d [ 0 ] . mcast_ifn ) ) ; d [ 0 ] . syncid = ipvs -> master_syncid ; } if ( ipvs -> sync_state & IP_VS_STATE_BACKUP ) { d [ 1 ] . state = IP_VS_STATE_BACKUP ; strlcpy ( d [ 1 ] . mcast_ifn , ipvs -> backup_mcast_ifn , sizeof ( d [ 1 ] . mcast_ifn ) ) ; d [ 1 ] . syncid = ipvs -> backup_syncid ; } if ( copy_to_user ( user , & d , sizeof ( d ) ) != 0 ) ret = - EFAULT ; mutex_unlock ( & ipvs -> sync_mutex ) ; return ret ; } if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) return - ERESTARTSYS ; switch ( cmd ) { case IP_VS_SO_GET_VERSION : { char buf [ 64 ] ; sprintf ( buf , "IP<S2SV_blank>Virtual<S2SV_blank>Server<S2SV_blank>version<S2SV_blank>%d.%d.%d<S2SV_blank>(size=%d)" , NVERSION ( IP_VS_VERSION_CODE ) , ip_vs_conn_tab_size ) ; if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { ret = - EFAULT ; goto out ; } * len = strlen ( buf ) + 1 ; } break ; case IP_VS_SO_GET_INFO : { struct ip_vs_getinfo info ; info . version = IP_VS_VERSION_CODE ; info . size = ip_vs_conn_tab_size ; info . num_services = ipvs -> num_services ; if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_get_services * get ; int size ; get = ( struct ip_vs_get_services * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_service_entry ) * get -> num_services ; if ( * len != size ) { pr_err ( "length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_service_entries ( net , get , user ) ; } break ; case IP_VS_SO_GET_SERVICE : { struct ip_vs_service_entry * entry ; struct ip_vs_service * svc ; union nf_inet_addr addr ; entry = ( struct ip_vs_service_entry * ) arg ; addr . ip = entry -> addr ; if ( entry -> fwmark ) svc = __ip_vs_svc_fwm_find ( net , AF_INET , entry -> fwmark ) ; else svc = __ip_vs_service_find ( net , AF_INET , entry -> protocol , & addr , entry -> port ) ; if ( svc ) { ip_vs_copy_service ( entry , svc ) ; if ( copy_to_user ( user , entry , sizeof ( * entry ) ) != 0 ) ret = - EFAULT ; } else ret = - ESRCH ; } break ; case IP_VS_SO_GET_DESTS : { struct ip_vs_get_dests * get ; int size ; get = ( struct ip_vs_get_dests * ) arg ; size = sizeof ( * get ) + sizeof ( struct ip_vs_dest_entry ) * get -> num_dests ; if ( * len != size ) { pr_err ( "length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , * len , size ) ; ret = - EINVAL ; goto out ; } ret = __ip_vs_get_dest_entries ( net , get , user ) ; } break ; case IP_VS_SO_GET_TIMEOUT : { struct ip_vs_timeout_user t ; <S2SV_StartBug> __ip_vs_get_timeouts ( net , & t ) ; <S2SV_EndBug> if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) ret = - EFAULT ; } break ; default : ret = - EINVAL ; } out : mutex_unlock ( & __ip_vs_mutex ) ; return ret ; }
CWE-200 static void ParseCommon ( map_string_t * settings , const char * conf_filename ) { const char * value ; value = get_map_string_item_or_NULL ( settings , "WatchCrashdumpArchiveDir" ) ; if ( value ) { g_settings_sWatchCrashdumpArchiveDir = xstrdup ( value ) ; remove_map_string_item ( settings , "WatchCrashdumpArchiveDir" ) ; } value = get_map_string_item_or_NULL ( settings , "MaxCrashReportsSize" ) ; if ( value ) { char * end ; errno = 0 ; unsigned long ul = strtoul ( value , & end , 10 ) ; if ( errno || end == value || * end != '\\0' || ul > INT_MAX ) error_msg ( "Error<S2SV_blank>parsing<S2SV_blank>%s<S2SV_blank>setting:<S2SV_blank>\'%s\'" , "MaxCrashReportsSize" , value ) ; else g_settings_nMaxCrashReportsSize = ul ; remove_map_string_item ( settings , "MaxCrashReportsSize" ) ; } value = get_map_string_item_or_NULL ( settings , "DumpLocation" ) ; if ( value ) { g_settings_dump_location = xstrdup ( value ) ; remove_map_string_item ( settings , "DumpLocation" ) ; } else g_settings_dump_location = xstrdup ( DEFAULT_DUMP_LOCATION ) ; value = get_map_string_item_or_NULL ( settings , "DeleteUploaded" ) ; if ( value ) { g_settings_delete_uploaded = string_to_bool ( value ) ; remove_map_string_item ( settings , "DeleteUploaded" ) ; } value = get_map_string_item_or_NULL ( settings , "AutoreportingEnabled" ) ; if ( value ) { g_settings_autoreporting = string_to_bool ( value ) ; remove_map_string_item ( settings , "AutoreportingEnabled" ) ; } value = get_map_string_item_or_NULL ( settings , "AutoreportingEvent" ) ; if ( value ) { g_settings_autoreporting_event = xstrdup ( value ) ; remove_map_string_item ( settings , "AutoreportingEvent" ) ; } else g_settings_autoreporting_event = xstrdup ( "report_uReport" ) ; value = get_map_string_item_or_NULL ( settings , "ShortenedReporting" ) ; if ( value ) { g_settings_shortenedreporting = string_to_bool ( value ) ; remove_map_string_item ( settings , "ShortenedReporting" ) ; } else g_settings_shortenedreporting = 0 ; <S2SV_StartBug> GHashTableIter iter ; <S2SV_EndBug> const char * name ; init_map_string_iter ( & iter , settings ) ; while ( next_map_string_iter ( & iter , & name , & value ) ) { error_msg ( "Unrecognized<S2SV_blank>variable<S2SV_blank>\'%s\'<S2SV_blank>in<S2SV_blank>\'%s\'" , name , conf_filename ) ; } }
CWE-200 static int load_misc_binary ( struct linux_binprm * bprm ) { Node * fmt ; struct file * interp_file = NULL ; char iname [ BINPRM_BUF_SIZE ] ; const char * iname_addr = iname ; int retval ; int fd_binary = - 1 ; retval = - ENOEXEC ; if ( ! enabled ) goto _ret ; read_lock ( & entries_lock ) ; fmt = check_file ( bprm ) ; if ( fmt ) strlcpy ( iname , fmt -> interpreter , BINPRM_BUF_SIZE ) ; read_unlock ( & entries_lock ) ; if ( ! fmt ) goto _ret ; if ( ! ( fmt -> flags & MISC_FMT_PRESERVE_ARGV0 ) ) { retval = remove_arg_zero ( bprm ) ; if ( retval ) goto _ret ; } if ( fmt -> flags & MISC_FMT_OPEN_BINARY ) { fd_binary = get_unused_fd ( ) ; if ( fd_binary < 0 ) { retval = fd_binary ; goto _ret ; } fd_install ( fd_binary , bprm -> file ) ; would_dump ( bprm , bprm -> file ) ; allow_write_access ( bprm -> file ) ; bprm -> file = NULL ; bprm -> interp_flags |= BINPRM_FLAGS_EXECFD ; bprm -> interp_data = fd_binary ; } else { allow_write_access ( bprm -> file ) ; fput ( bprm -> file ) ; bprm -> file = NULL ; } retval = copy_strings_kernel ( 1 , & bprm -> interp , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; <S2SV_StartBug> bprm -> interp = iname ; <S2SV_EndBug> interp_file = open_exec ( iname ) ; retval = PTR_ERR ( interp_file ) ; if ( IS_ERR ( interp_file ) ) goto _error ; bprm -> file = interp_file ; if ( fmt -> flags & MISC_FMT_CREDENTIALS ) { memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; retval = kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; } else retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) goto _error ; retval = search_binary_handler ( bprm ) ; if ( retval < 0 ) goto _error ; _ret : return retval ; _error : if ( fd_binary > 0 ) sys_close ( fd_binary ) ; bprm -> interp_flags = 0 ; bprm -> interp_data = 0 ; goto _ret ; }
CWE-476 BOOL transport_connect_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> layer == TRANSPORT_LAYER_TSG ) return TRUE ; if ( ! transport_connect_tls ( transport ) ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { if ( ! connectErrorCode ) connectErrorCode = AUTHENTICATIONERROR ; fprintf ( stderr , "Authentication<S2SV_blank>failure,<S2SV_blank>check<S2SV_blank>credentials.\\n" "If<S2SV_blank>credentials<S2SV_blank>are<S2SV_blank>valid,<S2SV_blank>the<S2SV_blank>NTLMSSP<S2SV_blank>implementation<S2SV_blank>may<S2SV_blank>be<S2SV_blank>to<S2SV_blank>blame.\\n" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } credssp_free ( transport -> credssp ) ; return TRUE ; }
CWE-000 static struct svc_serv * nfs_callback_create_svc ( int minorversion ) { struct nfs_callback_data * cb_info = & nfs_callback_info [ minorversion ] ; struct svc_serv * serv ; struct svc_serv_ops * sv_ops ; if ( cb_info -> serv ) { svc_get ( cb_info -> serv ) ; return cb_info -> serv ; } switch ( minorversion ) { case 0 : sv_ops = nfs4_cb_sv_ops [ 0 ] ; break ; default : sv_ops = nfs4_cb_sv_ops [ 1 ] ; } if ( sv_ops == NULL ) return ERR_PTR ( - ENOTSUPP ) ; if ( cb_info -> users ) printk ( KERN_WARNING "nfs_callback_create_svc:<S2SV_blank>no<S2SV_blank>kthread,<S2SV_blank>%d<S2SV_blank>users??\\n" , cb_info -> users ) ; <S2SV_StartBug> serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <S2SV_EndBug> if ( ! serv ) { printk ( KERN_ERR "nfs_callback_create_svc:<S2SV_blank>create<S2SV_blank>service<S2SV_blank>failed\\n" ) ; return ERR_PTR ( - ENOMEM ) ; } cb_info -> serv = serv ; serv -> sv_maxconn = 1024 ; dprintk ( "nfs_callback_create_svc:<S2SV_blank>service<S2SV_blank>created\\n" ) ; return serv ; }
CWE-000 static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , struct buffer_head * bh ) { struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) ( bh -> b_data + F2FS_SUPER_OFFSET ) ; struct super_block * sb = sbi -> sb ; unsigned int blocksize ; if ( F2FS_SUPER_MAGIC != le32_to_cpu ( raw_super -> magic ) ) { f2fs_msg ( sb , KERN_INFO , "Magic<S2SV_blank>Mismatch,<S2SV_blank>valid(0x%x)<S2SV_blank>-<S2SV_blank>read(0x%x)" , F2FS_SUPER_MAGIC , le32_to_cpu ( raw_super -> magic ) ) ; return 1 ; } if ( F2FS_BLKSIZE != PAGE_SIZE ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>page_cache_size<S2SV_blank>(%lu),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n" , PAGE_SIZE ) ; return 1 ; } blocksize = 1 << le32_to_cpu ( raw_super -> log_blocksize ) ; if ( blocksize != F2FS_BLKSIZE ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>blocksize<S2SV_blank>(%u),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n" , blocksize ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_blocks_per_seg ) != 9 ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>log<S2SV_blank>blocks<S2SV_blank>per<S2SV_blank>segment<S2SV_blank>(%u)\\n" , le32_to_cpu ( raw_super -> log_blocks_per_seg ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectorsize ) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu ( raw_super -> log_sectorsize ) < F2FS_MIN_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>log<S2SV_blank>sectorsize<S2SV_blank>(%u)" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectors_per_block ) + le32_to_cpu ( raw_super -> log_sectorsize ) != F2FS_MAX_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>log<S2SV_blank>sectors<S2SV_blank>per<S2SV_blank>block(%u)<S2SV_blank>log<S2SV_blank>sectorsize(%u)" , le32_to_cpu ( raw_super -> log_sectors_per_block ) , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> node_ino ) != 1 || le32_to_cpu ( raw_super -> meta_ino ) != 2 || le32_to_cpu ( raw_super -> root_ino ) != 3 ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>Fs<S2SV_blank>Meta<S2SV_blank>Ino:<S2SV_blank>node(%u)<S2SV_blank>meta(%u)<S2SV_blank>root(%u)" , le32_to_cpu ( raw_super -> node_ino ) , le32_to_cpu ( raw_super -> meta_ino ) , le32_to_cpu ( raw_super -> root_ino ) ) ; return 1 ; } <S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug> return 1 ; return 0 ; }
CWE-119 static void encode_loopfilter ( struct loopfilter * lf , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> int i ; <S2SV_StartBug> vp9_wb_write_literal ( wb , lf -> filter_level , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ; <S2SV_EndBug> if ( lf -> mode_ref_delta_enabled ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ; <S2SV_EndBug> if ( lf -> mode_ref_delta_update ) { for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) { const int delta = lf -> ref_deltas [ i ] ; const int changed = delta != lf -> last_ref_deltas [ i ] ; <S2SV_StartBug> vp9_wb_write_bit ( wb , changed ) ; <S2SV_EndBug> if ( changed ) { lf -> last_ref_deltas [ i ] = delta ; <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta < 0 ) ; <S2SV_EndBug> } } for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) { const int delta = lf -> mode_deltas [ i ] ; const int changed = delta != lf -> last_mode_deltas [ i ] ; <S2SV_StartBug> vp9_wb_write_bit ( wb , changed ) ; <S2SV_EndBug> if ( changed ) { lf -> last_mode_deltas [ i ] = delta ; <S2SV_StartBug> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , delta < 0 ) ; <S2SV_EndBug> } } } } }
CWE-119 void vp8_dequant_idct_add_uv_block_mmx ( short * q , short * dq , unsigned char * dstu , unsigned char * dstv , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstu , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dstu + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstu + 4 , stride , dstu + 4 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 32 ; dstu += 4 * stride ; eobs += 2 ; } for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstv , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dstv + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstv + 4 , stride , dstv + 4 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 32 ; dstv += 4 * stride ; eobs += 2 ; } }
CWE-190 static long mem_seek ( jas_stream_obj_t * obj , long offset , int origin ) { jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <S2SV_StartBug> long newpos ; <S2SV_EndBug> JAS_DBGLOG ( 100 , ( "mem_seek(%p,<S2SV_blank>%ld,<S2SV_blank>%d)\\n" , obj , offset , origin ) ) ; switch ( origin ) { case SEEK_SET : newpos = offset ; break ; case SEEK_END : newpos = m -> len_ - offset ; break ; case SEEK_CUR : newpos = m -> pos_ + offset ; break ; default : abort ( ) ; break ; } if ( newpos < 0 ) { return - 1 ; } m -> pos_ = newpos ; return m -> pos_ ; }
CWE-119 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , "nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , "cblk<S2SV_blank>size<S2SV_blank>invalid\\n" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; <S2SV_EndBug> if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , "extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }
CWE-000 static int setup_dev_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console ) { char path [ MAXPATHLEN ] ; struct stat s ; int ret ; ret = snprintf ( path , sizeof ( path ) , "%s/dev/console" , rootfs -> mount ) ; if ( ret >= sizeof ( path ) ) { ERROR ( "console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long" ) ; return - 1 ; } if ( access ( path , F_OK ) ) { WARN ( "rootfs<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>no<S2SV_blank>console<S2SV_blank>found<S2SV_blank>at<S2SV_blank>\'%s\'" , path ) ; return 0 ; } if ( console -> master < 0 ) { INFO ( "no<S2SV_blank>console" ) ; return 0 ; } if ( stat ( path , & s ) ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>stat<S2SV_blank>\'%s\'" , path ) ; return - 1 ; } if ( chmod ( console -> name , s . st_mode ) ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>mode<S2SV_blank>\'0%o\'<S2SV_blank>to<S2SV_blank>\'%s\'" , s . st_mode , console -> name ) ; return - 1 ; } <S2SV_StartBug> if ( mount ( console -> name , path , "none" , MS_BIND , 0 ) ) { <S2SV_EndBug> ERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , console -> name , path ) ; return - 1 ; } INFO ( "console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup" ) ; return 0 ; }
CWE-000 int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; <S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> return AVERROR ( ENOMEM ) ; return 0 ; }
CWE-264 int _mkp_stage_30 ( struct plugin * p , struct client_session * cs , struct session_request * sr ) { mk_ptr_t referer ; ( void ) p ; ( void ) cs ; PLUGIN_TRACE ( "[FD<S2SV_blank>%i]<S2SV_blank>Mandril<S2SV_blank>validating<S2SV_blank>URL" , cs -> socket ) ; <S2SV_StartBug> if ( mk_security_check_url ( sr -> uri ) < 0 ) { <S2SV_EndBug> PLUGIN_TRACE ( "[FD<S2SV_blank>%i]<S2SV_blank>Close<S2SV_blank>connection,<S2SV_blank>blocked<S2SV_blank>URL" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } PLUGIN_TRACE ( "[FD<S2SV_blank>%d]<S2SV_blank>Mandril<S2SV_blank>validating<S2SV_blank>hotlinking" , cs -> socket ) ; referer = mk_api -> header_get ( & sr -> headers_toc , "Referer" , strlen ( "Referer" ) ) ; if ( mk_security_check_hotlink ( sr -> uri_processed , sr -> host , referer ) < 0 ) { PLUGIN_TRACE ( "[FD<S2SV_blank>%i]<S2SV_blank>Close<S2SV_blank>connection,<S2SV_blank>deny<S2SV_blank>hotlinking." , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } return MK_PLUGIN_RET_NOT_ME ; }
CWE-189 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; <S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR "kvm_iommu_map_address:" "iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n" , pfn ) ; <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> goto unmap_pages ; } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ; return r ; }
CWE-200 bool __net_get_random_once ( void * buf , int nbytes , bool * done , <S2SV_StartBug> struct static_key * done_key ) <S2SV_EndBug> { static DEFINE_SPINLOCK ( lock ) ; unsigned long flags ; spin_lock_irqsave ( & lock , flags ) ; if ( * done ) { spin_unlock_irqrestore ( & lock , flags ) ; return false ; } get_random_bytes ( buf , nbytes ) ; * done = true ; spin_unlock_irqrestore ( & lock , flags ) ; <S2SV_StartBug> __net_random_once_disable_jump ( done_key ) ; <S2SV_EndBug> return true ; }
CWE-000 int main ( int argc , char * argv [ ] ) { int i , fails_count = 0 ; CU_pSuite cryptoUtilsTestSuite , parserTestSuite ; CU_pSuite * suites [ ] = { & cryptoUtilsTestSuite , & parserTestSuite , NULL } ; if ( argc > 1 ) { if ( argv [ 1 ] [ 0 ] == '-' ) { if ( strcmp ( argv [ 1 ] , "-verbose" ) == 0 ) { verbose = 1 ; } else { printf ( "Usage:\\n<S2SV_blank>%s<S2SV_blank>[-verbose]<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>extensive<S2SV_blank>logging\\n" , argv [ 0 ] ) ; return 1 ; } } else { printf ( "Usage:\\n<S2SV_blank>%s<S2SV_blank>[-verbose]<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>extensive<S2SV_blank>logging\\n" , argv [ 0 ] ) ; return 1 ; } } # ifdef HAVE_LIBXML2 xmlInitParser ( ) ; # endif if ( CUE_SUCCESS != CU_initialize_registry ( ) ) { return CU_get_error ( ) ; } cryptoUtilsTestSuite = CU_add_suite ( "Bzrtp<S2SV_blank>Crypto<S2SV_blank>Utils" , NULL , NULL ) ; CU_add_test ( cryptoUtilsTestSuite , "zrtpKDF" , test_zrtpKDF ) ; CU_add_test ( cryptoUtilsTestSuite , "CRC32" , test_CRC32 ) ; CU_add_test ( cryptoUtilsTestSuite , "algo<S2SV_blank>agreement" , test_algoAgreement ) ; CU_add_test ( cryptoUtilsTestSuite , "context<S2SV_blank>algo<S2SV_blank>setter<S2SV_blank>and<S2SV_blank>getter" , test_algoSetterGetter ) ; CU_add_test ( cryptoUtilsTestSuite , "adding<S2SV_blank>mandatory<S2SV_blank>crypto<S2SV_blank>algorithms<S2SV_blank>if<S2SV_blank>needed" , test_addMandatoryCryptoTypesIfNeeded ) ; parserTestSuite = CU_add_suite ( "Bzrtp<S2SV_blank>ZRTP<S2SV_blank>Packet<S2SV_blank>Parser" , NULL , NULL ) ; CU_add_test ( parserTestSuite , "Parse" , test_parser ) ; <S2SV_StartBug> CU_add_test ( parserTestSuite , "Parse<S2SV_blank>Exchange" , test_parserComplete ) ; <S2SV_EndBug> CU_add_test ( parserTestSuite , "State<S2SV_blank>machine" , test_stateMachine ) ; for ( i = 0 ; suites [ i ] ; i ++ ) { CU_basic_run_suite ( * suites [ i ] ) ; fails_count += CU_get_number_of_tests_failed ( ) ; } CU_cleanup_registry ( ) ; # ifdef HAVE_LIBXML2 xmlCleanupParser ( ) ; # endif return ( fails_count == 0 ? 0 : 1 ) ; }
CWE-119 static inline void schedule_debug ( struct task_struct * prev ) { # ifdef CONFIG_SCHED_STACK_END_CHECK <S2SV_StartBug> BUG_ON ( task_stack_end_corrupted ( prev ) ) ; <S2SV_EndBug> # endif if ( unlikely ( in_atomic_preempt_off ( ) ) ) { __schedule_bug ( prev ) ; preempt_count_set ( PREEMPT_DISABLED ) ; } rcu_sleep_check ( ) ; profile_hit ( SCHED_PROFILING , __builtin_return_address ( 0 ) ) ; schedstat_inc ( this_rq ( ) , sched_count ) ; }
CWE-119 void IGDstartelt ( void * d , const char * name , int l ) { <S2SV_StartBug> struct IGDdatas * datas = ( struct IGDdatas * ) d ; <S2SV_EndBug> memcpy ( datas -> cureltname , name , l ) ; datas -> cureltname [ l ] = '\\0' ; datas -> level ++ ; if ( ( l == 7 ) && ! memcmp ( name , "service" , l ) ) { datas -> tmp . controlurl [ 0 ] = '\\0' ; datas -> tmp . eventsuburl [ 0 ] = '\\0' ; datas -> tmp . scpdurl [ 0 ] = '\\0' ; datas -> tmp . servicetype [ 0 ] = '\\0' ; } }
CWE-119 void vp8_setup_intra_recon_top_line ( YV12_BUFFER_CONFIG * ybf ) { <S2SV_StartBug> vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> }
CWE-416 static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
CWE-20 static vpx_codec_err_t vp8_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; unsigned int resolution_change = 0 ; unsigned int w , h ; if ( ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( update_fragments ( ctx , data , data_sz , & res ) <= 0 ) return res ; w = ctx -> si . w ; h = ctx -> si . h ; res = vp8_peek_si_internal ( ctx -> fragments . ptrs [ 0 ] , ctx -> fragments . sizes [ 0 ] , & ctx -> si , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( ( res == VPX_CODEC_UNSUP_BITSTREAM ) && ! ctx -> si . is_kf ) { res = VPX_CODEC_OK ; } if ( ! ctx -> decoder_init && ! ctx -> si . is_kf ) res = VPX_CODEC_UNSUP_BITSTREAM ; if ( ( ctx -> si . h != h ) || ( ctx -> si . w != w ) ) resolution_change = 1 ; if ( ! res && ! ctx -> decoder_init ) { VP8D_CONFIG oxcf ; oxcf . Width = ctx -> si . w ; oxcf . Height = ctx -> si . h ; oxcf . Version = 9 ; oxcf . postprocess = 0 ; oxcf . max_threads = ctx -> cfg . threads ; oxcf . error_concealment = ( ctx -> base . init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) ; if ( ! ctx -> postproc_cfg_set && ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) ) { ctx -> postproc_cfg . post_proc_flag = VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE ; ctx -> postproc_cfg . deblocking_level = 4 ; ctx -> postproc_cfg . noise_level = 0 ; } res = vp8_create_decoder_instances ( & ctx -> yv12_frame_buffers , & oxcf ) ; ctx -> decoder_init = 1 ; } if ( ctx -> decoder_init ) { ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_cb = ctx -> decrypt_cb ; ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_state = ctx -> decrypt_state ; } if ( ! res ) { VP8D_COMP * pbi = ctx -> yv12_frame_buffers . pbi [ 0 ] ; if ( resolution_change ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; # if CONFIG_MULTITHREAD int i ; # endif pc -> Width = ctx -> si . w ; pc -> Height = ctx -> si . h ; { int prev_mb_rows = pc -> mb_rows ; if ( setjmp ( pbi -> common . error . jmp ) ) { pbi -> common . error . setjmp = 0 ; <S2SV_StartBug> vp8_clear_system_state ( ) ; <S2SV_EndBug> return - 1 ; } pbi -> common . error . setjmp = 1 ; if ( pc -> Width <= 0 ) { pc -> Width = w ; vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , "Invalid<S2SV_blank>frame<S2SV_blank>width" ) ; } if ( pc -> Height <= 0 ) { pc -> Height = h ; vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , "Invalid<S2SV_blank>frame<S2SV_blank>height" ) ; } if ( vp8_alloc_frame_buffers ( pc , pc -> Width , pc -> Height ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame<S2SV_blank>buffers" ) ; xd -> pre = pc -> yv12_fb [ pc -> lst_fb_idx ] ; xd -> dst = pc -> yv12_fb [ pc -> new_fb_idx ] ; # if CONFIG_MULTITHREAD for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) { pbi -> mb_row_di [ i ] . mbd . dst = pc -> yv12_fb [ pc -> new_fb_idx ] ; vp8_build_block_doffsets ( & pbi -> mb_row_di [ i ] . mbd ) ; } # endif vp8_build_block_doffsets ( & pbi -> mb ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_enabled ) { pc -> prev_mip = vpx_calloc ( ( pc -> mb_cols + 1 ) * ( pc -> mb_rows + 1 ) , sizeof ( MODE_INFO ) ) ; if ( ! pc -> prev_mip ) { vp8_de_alloc_frame_buffers ( pc ) ; vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate" "last<S2SV_blank>frame<S2SV_blank>MODE_INFO<S2SV_blank>array" ) ; } pc -> prev_mi = pc -> prev_mip + pc -> mode_info_stride + 1 ; if ( vp8_alloc_overlap_lists ( pbi ) ) vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>overlap<S2SV_blank>lists<S2SV_blank>" "for<S2SV_blank>error<S2SV_blank>concealment" ) ; } # endif # if CONFIG_MULTITHREAD if ( pbi -> b_multithreaded_rd ) vp8mt_alloc_temp_buffers ( pbi , pc -> Width , prev_mb_rows ) ; # else ( void ) prev_mb_rows ; # endif } pbi -> common . error . setjmp = 0 ; pbi -> common . fb_idx_ref_cnt [ 0 ] = 0 ; } pbi -> fragments = ctx -> fragments ; ctx -> user_priv = user_priv ; if ( vp8dx_receive_compressed_data ( pbi , data_sz , data , deadline ) ) { res = update_error_state ( ctx , & pbi -> common . error ) ; } ctx -> fragments . count = 0 ; } return res ; }
CWE-190 static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; <S2SV_StartBug> case 'c' : return getnum ( L , fmt , 1 ) ; <S2SV_EndBug> case 'i' : case 'I' : { <S2SV_StartBug> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <S2SV_EndBug> if ( sz > MAXINTSIZE ) luaL_error ( L , "integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }
CWE-000 static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ; <S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ; <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> kfree_skb ( skb ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } return skb ; }
CWE-000 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , <S2SV_StartBug> int transhdrlen , int mtu , unsigned int flags ) <S2SV_EndBug> { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return - ENOMEM ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = CHECKSUM_PARTIAL ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; <S2SV_StartBug> ipv6_select_ident ( & fhdr ) ; <S2SV_EndBug> skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }
CWE-000 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , "%s/.asoundrc" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , "Error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link\\n" , dest ) ; exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> if ( rv ) fprintf ( stderr , "Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n" ) ; else { fs_logger2 ( "clone" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 ) <S2SV_EndBug> errExit ( "chown" ) ; <S2SV_StartBug> if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 ) <S2SV_EndBug> errExit ( "chmod" ) ; unlink ( src ) ; }
CWE-200 static long __tun_chr_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , int ifreq_len ) { struct tun_file * tfile = file -> private_data ; struct tun_struct * tun ; void __user * argp = ( void __user * ) arg ; struct sock_fprog fprog ; struct ifreq ifr ; int sndbuf ; int vnet_hdr_sz ; int ret ; <S2SV_StartBug> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) <S2SV_EndBug> if ( copy_from_user ( & ifr , argp , ifreq_len ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> if ( cmd == TUNGETFEATURES ) { return put_user ( IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE | IFF_VNET_HDR , ( unsigned int __user * ) argp ) ; } rtnl_lock ( ) ; tun = __tun_get ( tfile ) ; if ( cmd == TUNSETIFF && ! tun ) { ifr . ifr_name [ IFNAMSIZ - 1 ] = '\\0' ; ret = tun_set_iff ( tfile -> net , file , & ifr ) ; if ( ret ) goto unlock ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; goto unlock ; } ret = - EBADFD ; if ( ! tun ) goto unlock ; tun_debug ( KERN_INFO , tun , "tun_chr_ioctl<S2SV_blank>cmd<S2SV_blank>%d\\n" , cmd ) ; ret = 0 ; switch ( cmd ) { case TUNGETIFF : ret = tun_get_iff ( current -> nsproxy -> net_ns , tun , & ifr ) ; if ( ret ) break ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; break ; case TUNSETNOCSUM : tun_debug ( KERN_INFO , tun , "ignored:<S2SV_blank>set<S2SV_blank>checksum<S2SV_blank>%s\\n" , arg ? "disabled" : "enabled" ) ; break ; case TUNSETPERSIST : if ( arg ) tun -> flags |= TUN_PERSIST ; else tun -> flags &= ~ TUN_PERSIST ; tun_debug ( KERN_INFO , tun , "persist<S2SV_blank>%s\\n" , arg ? "enabled" : "disabled" ) ; break ; case TUNSETOWNER : tun -> owner = ( uid_t ) arg ; tun_debug ( KERN_INFO , tun , "owner<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n" , tun -> owner ) ; break ; case TUNSETGROUP : tun -> group = ( gid_t ) arg ; tun_debug ( KERN_INFO , tun , "group<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n" , tun -> group ) ; break ; case TUNSETLINK : if ( tun -> dev -> flags & IFF_UP ) { tun_debug ( KERN_INFO , tun , "Linktype<S2SV_blank>set<S2SV_blank>failed<S2SV_blank>because<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>up\\n" ) ; ret = - EBUSY ; } else { tun -> dev -> type = ( int ) arg ; tun_debug ( KERN_INFO , tun , "linktype<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n" , tun -> dev -> type ) ; ret = 0 ; } break ; # ifdef TUN_DEBUG case TUNSETDEBUG : tun -> debug = arg ; break ; # endif case TUNSETOFFLOAD : ret = set_offload ( tun , arg ) ; break ; case TUNSETTXFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = update_filter ( & tun -> txflt , ( void __user * ) arg ) ; break ; case SIOCGIFHWADDR : memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ) ; ifr . ifr_hwaddr . sa_family = tun -> dev -> type ; if ( copy_to_user ( argp , & ifr , ifreq_len ) ) ret = - EFAULT ; break ; case SIOCSIFHWADDR : tun_debug ( KERN_DEBUG , tun , "set<S2SV_blank>hw<S2SV_blank>address:<S2SV_blank>%pM\\n" , ifr . ifr_hwaddr . sa_data ) ; ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ) ; break ; case TUNGETSNDBUF : sndbuf = tun -> socket . sk -> sk_sndbuf ; if ( copy_to_user ( argp , & sndbuf , sizeof ( sndbuf ) ) ) ret = - EFAULT ; break ; case TUNSETSNDBUF : if ( copy_from_user ( & sndbuf , argp , sizeof ( sndbuf ) ) ) { ret = - EFAULT ; break ; } tun -> socket . sk -> sk_sndbuf = sndbuf ; break ; case TUNGETVNETHDRSZ : vnet_hdr_sz = tun -> vnet_hdr_sz ; if ( copy_to_user ( argp , & vnet_hdr_sz , sizeof ( vnet_hdr_sz ) ) ) ret = - EFAULT ; break ; case TUNSETVNETHDRSZ : if ( copy_from_user ( & vnet_hdr_sz , argp , sizeof ( vnet_hdr_sz ) ) ) { ret = - EFAULT ; break ; } if ( vnet_hdr_sz < ( int ) sizeof ( struct virtio_net_hdr ) ) { ret = - EINVAL ; break ; } tun -> vnet_hdr_sz = vnet_hdr_sz ; break ; case TUNATTACHFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = - EFAULT ; if ( copy_from_user ( & fprog , argp , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , tun -> socket . sk ) ; break ; case TUNDETACHFILTER : ret = - EINVAL ; if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) break ; ret = sk_detach_filter ( tun -> socket . sk ) ; break ; default : ret = - EINVAL ; break ; } unlock : rtnl_unlock ( ) ; if ( tun ) tun_put ( tun ) ; return ret ; }
CWE-119 static int ttusbdecfe_dvbs_diseqc_send_master_cmd ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * cmd ) { struct ttusbdecfe_state * state = ( struct ttusbdecfe_state * ) fe -> demodulator_priv ; u8 b [ ] = { 0x00 , 0xff , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; <S2SV_StartBug> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <S2SV_EndBug> state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ; return 0 ; }
CWE-20 static int snd_timer_start_slave ( struct snd_timer_instance * timeri ) { unsigned long flags ; spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags |= SNDRV_TIMER_IFLG_RUNNING ; <S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ; <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> return 1 ; }
CWE-787 grub_ssize_t grub_fshelp_read_file ( grub_disk_t disk , grub_fshelp_node_t node , void ( * read_hook ) ( grub_disk_addr_t sector , unsigned offset , unsigned length , void * closure ) , void * closure , int flags , grub_off_t pos , grub_size_t len , char * buf , grub_disk_addr_t ( * get_block ) ( grub_fshelp_node_t node , grub_disk_addr_t block ) , grub_off_t filesize , int log2blocksize ) { grub_disk_addr_t i , blockcnt ; int blocksize = 1 << ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; if ( pos + len > filesize ) len = filesize - pos ; <S2SV_StartBug> blockcnt = ( ( len + pos ) + blocksize - 1 ) >> <S2SV_EndBug> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; for ( i = pos >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ; i < blockcnt ; i ++ ) { grub_disk_addr_t blknr ; int blockoff = pos & ( blocksize - 1 ) ; int blockend = blocksize ; int skipfirst = 0 ; blknr = get_block ( node , i ) ; if ( grub_errno ) return - 1 ; blknr = blknr << log2blocksize ; if ( i == blockcnt - 1 ) { blockend = ( len + pos ) & ( blocksize - 1 ) ; if ( ! blockend ) blockend = blocksize ; } if ( i == ( pos >> ( log2blocksize + GRUB_DISK_SECTOR_BITS ) ) ) { skipfirst = blockoff ; blockend -= skipfirst ; } if ( blknr ) { disk -> read_hook = read_hook ; disk -> closure = closure ; grub_hack_lastoff = blknr * 512 ; grub_disk_read_ex ( disk , blknr , skipfirst , blockend , buf , flags ) ; disk -> read_hook = 0 ; if ( grub_errno ) return - 1 ; } else if ( buf ) grub_memset ( buf , 0 , blockend ) ; if ( buf ) buf += blocksize - skipfirst ; } return len ; }
CWE-000 int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; <S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> return ERROR_SUCCESS ; }
CWE-119 <S2SV_StartBug> int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff , <S2SV_EndBug> intptr_t block_size , int64_t * ssz ) { int i ; int64_t error = 0 , sqcoeff = 0 ; for ( i = 0 ; i < block_size ; i ++ ) { const int diff = coeff [ i ] - dqcoeff [ i ] ; error += diff * diff ; sqcoeff += coeff [ i ] * coeff [ i ] ; } * ssz = sqcoeff ; return error ; }
CWE-189 static bool snd_ctl_remove_numid_conflict ( struct snd_card * card , unsigned int count ) { <S2SV_StartBug> struct snd_kcontrol * kctl ; <S2SV_EndBug> list_for_each_entry ( kctl , & card -> controls , list ) { if ( kctl -> id . numid < card -> last_numid + 1 + count && kctl -> id . numid + kctl -> count > card -> last_numid + 1 ) { card -> last_numid = kctl -> id . numid + kctl -> count - 1 ; return true ; } } return false ; }
CWE-284 int btpan_tap_open ( ) { struct ifreq ifr ; int fd , err ; const char * clonedev = "/dev/tun" ; <S2SV_StartBug> if ( ( fd = open ( clonedev , O_RDWR ) ) < 0 ) <S2SV_EndBug> { BTIF_TRACE_DEBUG ( "could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%s,<S2SV_blank>err:%d" , clonedev , errno ) ; return fd ; } memset ( & ifr , 0 , sizeof ( ifr ) ) ; ifr . ifr_flags = IFF_TAP | IFF_NO_PI ; strncpy ( ifr . ifr_name , TAP_IF_NAME , IFNAMSIZ ) ; <S2SV_StartBug> if ( ( err = ioctl ( fd , TUNSETIFF , ( void * ) & ifr ) ) < 0 ) <S2SV_EndBug> { BTIF_TRACE_DEBUG ( "ioctl<S2SV_blank>error:%d,<S2SV_blank>errno:%s" , err , strerror ( errno ) ) ; close ( fd ) ; return err ; } if ( tap_if_up ( TAP_IF_NAME , controller_get_interface ( ) -> get_address ( ) ) == 0 ) { <S2SV_StartBug> int flags = fcntl ( fd , F_GETFL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> fcntl ( fd , F_SETFL , flags | O_NONBLOCK ) ; <S2SV_EndBug> return fd ; } BTIF_TRACE_ERROR ( "can<S2SV_blank>not<S2SV_blank>bring<S2SV_blank>up<S2SV_blank>tap<S2SV_blank>interface:%s" , TAP_IF_NAME ) ; close ( fd ) ; return INVALID_FD ; }
CWE-000 struct sk_buff * * udp_gro_receive ( struct sk_buff * * head , struct sk_buff * skb , struct udphdr * uh ) { struct udp_offload_priv * uo_priv ; struct sk_buff * p , * * pp = NULL ; struct udphdr * uh2 ; unsigned int off = skb_gro_offset ( skb ) ; int flush = 1 ; <S2SV_StartBug> if ( NAPI_GRO_CB ( skb ) -> udp_mark || <S2SV_EndBug> ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> csum_cnt == 0 && ! NAPI_GRO_CB ( skb ) -> csum_valid ) ) goto out ; <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 1 ; <S2SV_EndBug> rcu_read_lock ( ) ; uo_priv = rcu_dereference ( udp_offload_base ) ; for ( ; uo_priv != NULL ; uo_priv = rcu_dereference ( uo_priv -> next ) ) { if ( net_eq ( read_pnet ( & uo_priv -> net ) , dev_net ( skb -> dev ) ) && uo_priv -> offload -> port == uh -> dest && uo_priv -> offload -> callbacks . gro_receive ) goto unflush ; } goto out_unlock ; unflush : flush = 0 ; for ( p = * head ; p ; p = p -> next ) { if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; uh2 = ( struct udphdr * ) ( p -> data + off ) ; if ( ( * ( u32 * ) & uh -> source != * ( u32 * ) & uh2 -> source ) || ( ! uh -> check ^ ! uh2 -> check ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } skb_gro_pull ( skb , sizeof ( struct udphdr ) ) ; skb_gro_postpull_rcsum ( skb , uh , sizeof ( struct udphdr ) ) ; NAPI_GRO_CB ( skb ) -> proto = uo_priv -> offload -> ipproto ; pp = uo_priv -> offload -> callbacks . gro_receive ( head , skb , uo_priv -> offload ) ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }
CWE-119 <S2SV_StartBug> static void reset_fpf_position ( struct twopass_rc * p , <S2SV_EndBug> const FIRSTPASS_STATS * position ) { p -> stats_in = position ; }
CWE-000 static int do_dentry_open ( struct file * f , int ( * open ) ( struct inode * , struct file * ) , const struct cred * cred ) { static const struct file_operations empty_fops = { } ; struct inode * inode ; int error ; f -> f_mode = OPEN_FMODE ( f -> f_flags ) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE ; if ( unlikely ( f -> f_flags & O_PATH ) ) f -> f_mode = FMODE_PATH ; path_get ( & f -> f_path ) ; inode = f -> f_inode = f -> f_path . dentry -> d_inode ; if ( f -> f_mode & FMODE_WRITE ) { error = __get_file_write_access ( inode , f -> f_path . mnt ) ; if ( error ) goto cleanup_file ; if ( ! special_file ( inode -> i_mode ) ) file_take_write ( f ) ; } f -> f_mapping = inode -> i_mapping ; <S2SV_StartBug> file_sb_list_add ( f , inode -> i_sb ) ; <S2SV_EndBug> if ( unlikely ( f -> f_mode & FMODE_PATH ) ) { f -> f_op = & empty_fops ; return 0 ; } f -> f_op = fops_get ( inode -> i_fop ) ; if ( unlikely ( WARN_ON ( ! f -> f_op ) ) ) { error = - ENODEV ; goto cleanup_all ; } error = security_file_open ( f , cred ) ; if ( error ) goto cleanup_all ; error = break_lease ( inode , f -> f_flags ) ; if ( error ) goto cleanup_all ; if ( ! open ) open = f -> f_op -> open ; if ( open ) { error = open ( inode , f ) ; if ( error ) goto cleanup_all ; } if ( ( f -> f_mode & ( FMODE_READ | FMODE_WRITE ) ) == FMODE_READ ) i_readcount_inc ( inode ) ; f -> f_flags &= ~ ( O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC ) ; file_ra_state_init ( & f -> f_ra , f -> f_mapping -> host -> i_mapping ) ; return 0 ; cleanup_all : fops_put ( f -> f_op ) ; <S2SV_StartBug> file_sb_list_del ( f ) ; <S2SV_EndBug> if ( f -> f_mode & FMODE_WRITE ) { put_write_access ( inode ) ; if ( ! special_file ( inode -> i_mode ) ) { file_reset_write ( f ) ; __mnt_drop_write ( f -> f_path . mnt ) ; } } cleanup_file : path_put ( & f -> f_path ) ; f -> f_path . mnt = NULL ; f -> f_path . dentry = NULL ; f -> f_inode = NULL ; return error ; }
CWE-119 int stats_open_file ( stats_io_t * stats , const char * fpf , int pass ) { int res ; stats -> pass = pass ; if ( pass == 0 ) { stats -> file = fopen ( fpf , "wb" ) ; stats -> buf . sz = 0 ; stats -> buf . buf = NULL ; res = ( stats -> file != NULL ) ; } else { # if USE_POSIX_MMAP struct stat stat_buf ; int fd ; fd = open ( fpf , O_RDONLY ) ; stats -> file = fdopen ( fd , "rb" ) ; fstat ( fd , & stat_buf ) ; stats -> buf . sz = stat_buf . st_size ; stats -> buf . buf = mmap ( NULL , stats -> buf . sz , PROT_READ , MAP_PRIVATE , fd , 0 ) ; res = ( stats -> buf . buf != NULL ) ; # else size_t nbytes ; stats -> file = fopen ( fpf , "rb" ) ; <S2SV_StartBug> if ( fseek ( stats -> file , 0 , SEEK_END ) ) <S2SV_EndBug> fatal ( "First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!" ) ; stats -> buf . sz = stats -> buf_alloc_sz = ftell ( stats -> file ) ; rewind ( stats -> file ) ; stats -> buf . buf = malloc ( stats -> buf_alloc_sz ) ; if ( ! stats -> buf . buf ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>first-pass<S2SV_blank>stats<S2SV_blank>buffer<S2SV_blank>(%lu<S2SV_blank>bytes)" , ( unsigned int ) stats -> buf_alloc_sz ) ; nbytes = fread ( stats -> buf . buf , 1 , stats -> buf . sz , stats -> file ) ; res = ( nbytes == stats -> buf . sz ) ; # endif } return res ; }
CWE-119 static void Scale2D ( unsigned char * source , int source_pitch , unsigned int source_width , unsigned int source_height , unsigned char * dest , int dest_pitch , unsigned int dest_width , unsigned int dest_height , unsigned char * temp_area , unsigned char temp_area_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i , j , k ; int bands ; int dest_band_height ; int source_band_height ; typedef void ( * Scale1D ) ( const unsigned char * source , int source_step , unsigned int source_scale , unsigned int source_length , unsigned char * dest , int dest_step , unsigned int dest_scale , unsigned int dest_length ) ; Scale1D Scale1Dv = scale1d_c ; Scale1D Scale1Dh = scale1d_c ; void ( * horiz_line_scale ) ( const unsigned char * , unsigned int , unsigned char * , unsigned int ) = NULL ; void ( * vert_band_scale ) ( unsigned char * , unsigned int , unsigned char * , unsigned int , unsigned int ) = NULL ; int ratio_scalable = 1 ; int interpolation = 0 ; unsigned char * source_base ; unsigned char * line_src ; source_base = ( unsigned char * ) source ; if ( source_pitch < 0 ) { int offset ; offset = ( source_height - 1 ) ; offset *= source_pitch ; source_base += offset ; } switch ( hratio * 10 / hscale ) { case 8 : horiz_line_scale = vp8_horizontal_line_5_4_scale ; break ; case 6 : horiz_line_scale = vp8_horizontal_line_5_3_scale ; break ; case 5 : horiz_line_scale = vp8_horizontal_line_2_1_scale ; break ; default : ratio_scalable = 0 ; break ; } switch ( vratio * 10 / vscale ) { case 8 : vert_band_scale = vp8_vertical_band_5_4_scale ; source_band_height = 5 ; dest_band_height = 4 ; break ; case 6 : vert_band_scale = vp8_vertical_band_5_3_scale ; source_band_height = 5 ; dest_band_height = 3 ; break ; case 5 : if ( interlaced ) { vert_band_scale = vp8_vertical_band_2_1_scale ; } else { interpolation = 1 ; vert_band_scale = vp8_vertical_band_2_1_scale_i ; } source_band_height = 2 ; dest_band_height = 1 ; break ; default : ratio_scalable = 0 ; break ; } if ( ratio_scalable ) { if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { horiz_line_scale ( source , source_width , dest , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( interpolation ) { if ( source < source_base ) source = source_base ; horiz_line_scale ( source , source_width , temp_area , dest_width ) ; } for ( k = 0 ; k < ( int ) ( dest_height + dest_band_height - 1 ) / dest_band_height ; k ++ ) { for ( i = 0 ; i < source_band_height ; i ++ ) { line_src = ( unsigned char * ) source + i * source_pitch ; if ( line_src < source_base ) line_src = source_base ; horiz_line_scale ( line_src , source_width , temp_area + ( i + 1 ) * dest_pitch , dest_width ) ; } vert_band_scale ( temp_area + dest_pitch , dest_pitch , dest , dest_pitch , dest_width ) ; if ( interpolation ) <S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_width ) ; <S2SV_EndBug> source += ( unsigned long ) source_band_height * source_pitch ; dest += ( unsigned long ) dest_band_height * dest_pitch ; } return ; } if ( hscale == 2 && hratio == 1 ) Scale1Dh = scale1d_2t1_ps ; if ( vscale == 2 && vratio == 1 ) { if ( interlaced ) Scale1Dv = scale1d_2t1_ps ; else Scale1Dv = scale1d_2t1_i ; } if ( source_height == dest_height ) { for ( k = 0 ; k < ( int ) dest_height ; k ++ ) { Scale1Dh ( source , 1 , hscale , source_width + 1 , dest , 1 , hratio , dest_width ) ; source += source_pitch ; dest += dest_pitch ; } return ; } if ( dest_height > source_height ) { dest_band_height = temp_area_height - 1 ; source_band_height = dest_band_height * source_height / dest_height ; } else { source_band_height = temp_area_height - 1 ; dest_band_height = source_band_height * vratio / vscale ; } Scale1Dh ( source , 1 , hscale , source_width + 1 , temp_area , 1 , hratio , dest_width ) ; bands = ( dest_height + dest_band_height - 1 ) / dest_band_height ; for ( k = 0 ; k < bands ; k ++ ) { for ( i = 1 ; i < source_band_height + 1 ; i ++ ) { if ( k * source_band_height + i < ( int ) source_height ) { Scale1Dh ( source + i * source_pitch , 1 , hscale , source_width + 1 , temp_area + i * dest_pitch , 1 , hratio , dest_width ) ; } else { <S2SV_StartBug> vpx_memcpy ( temp_area + i * dest_pitch , temp_area + ( i - 1 ) * dest_pitch , dest_pitch ) ; <S2SV_EndBug> } } for ( j = 0 ; j < ( int ) dest_width ; j ++ ) { Scale1Dv ( & temp_area [ j ] , dest_pitch , vscale , source_band_height + 1 , & dest [ j ] , dest_pitch , vratio , dest_band_height ) ; } <S2SV_StartBug> vpx_memcpy ( temp_area , temp_area + source_band_height * dest_pitch , dest_pitch ) ; <S2SV_EndBug> source += source_band_height * source_pitch ; dest += dest_band_height * dest_pitch ; } }
CWE-476 static bool ResolveStateAndPredicate ( ExprDef * expr , enum xkb_match_operation * pred_rtrn , xkb_mod_mask_t * mods_rtrn , CompatInfo * info ) { if ( expr == NULL ) { * pred_rtrn = MATCH_ANY_OR_NONE ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } * pred_rtrn = MATCH_EXACTLY ; if ( expr -> expr . op == EXPR_ACTION_DECL ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> action . name ) ; <S2SV_StartBug> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { <S2SV_EndBug> log_err ( info -> ctx , "Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\"%s\\";<S2SV_blank>Ignored\\n" , pred_txt ) ; return false ; } expr = expr -> action . args ; } else if ( expr -> expr . op == EXPR_IDENT ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> ident . ident ) ; if ( pred_txt && istreq ( pred_txt , "any" ) ) { * pred_rtrn = MATCH_ANY ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } } return ExprResolveModMask ( info -> ctx , expr , MOD_REAL , & info -> mods , mods_rtrn ) ; }
CWE-119 <S2SV_StartBug> static void update_skip_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> int k ; for ( k = 0 ; k < SKIP_CONTEXTS ; ++ k ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . skip_probs [ k ] , cm -> counts . skip [ k ] ) ; <S2SV_EndBug> }
CWE-787 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOD , <S2SV_EndBug> 2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && "TODO" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , "Cannot<S2SV_blank>encode<S2SV_blank>tile\\n" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }
CWE-399 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = ( val - prev ) & 0xfffffffful ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , 0 ) ; data . period = event -> hw . last_period ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> fsl_emb_pmu_stop ( event , 0 ) ; } }
CWE-119 <S2SV_StartBug> static int conditional_skipintra ( MB_PREDICTION_MODE mode , <S2SV_EndBug> MB_PREDICTION_MODE best_intra_mode ) { if ( mode == D117_PRED && best_intra_mode != V_PRED && best_intra_mode != D135_PRED ) return 1 ; if ( mode == D63_PRED && best_intra_mode != V_PRED && best_intra_mode != D45_PRED ) return 1 ; if ( mode == D207_PRED && best_intra_mode != H_PRED && best_intra_mode != D45_PRED ) return 1 ; if ( mode == D153_PRED && best_intra_mode != H_PRED && best_intra_mode != D135_PRED ) return 1 ; return 0 ; }
CWE-200 static __net_init int setup_net ( struct net * net , struct user_namespace * user_ns ) { const struct pernet_operations * ops , * saved_ops ; int error = 0 ; LIST_HEAD ( net_exit_list ) ; refcount_set ( & net -> count , 1 ) ; refcount_set ( & net -> passive , 1 ) ; <S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> net -> user_ns = user_ns ; idr_init ( & net -> netns_ids ) ; spin_lock_init ( & net -> nsid_lock ) ; mutex_init ( & net -> ipv4 . ra_mutex ) ; list_for_each_entry ( ops , & pernet_list , list ) { error = ops_init ( ops , net ) ; if ( error < 0 ) goto out_undo ; } down_write ( & net_rwsem ) ; list_add_tail_rcu ( & net -> list , & net_namespace_list ) ; up_write ( & net_rwsem ) ; out : return error ; out_undo : list_add ( & net -> exit_list , & net_exit_list ) ; saved_ops = ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_exit_list ( ops , & net_exit_list ) ; ops = saved_ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_free_list ( ops , & net_exit_list ) ; rcu_barrier ( ) ; goto out ; }
CWE-119 static void scsi_read_data ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; uint32_t n ; if ( r -> sector_count == ( uint32_t ) - 1 ) { DPRINTF ( "Read<S2SV_blank>buf_len=%zd\\n" , r -> iov . iov_len ) ; r -> sector_count = 0 ; scsi_req_data ( & r -> req , r -> iov . iov_len ) ; return ; } DPRINTF ( "Read<S2SV_blank>sector_count=%d\\n" , r -> sector_count ) ; if ( r -> sector_count == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; return ; } assert ( r -> req . aiocb == NULL ) ; if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) { DPRINTF ( "Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\n" ) ; scsi_read_complete ( r , - EINVAL ) ; return ; } <S2SV_StartBug> n = r -> sector_count ; <S2SV_EndBug> if ( n > SCSI_DMA_BUF_SIZE / 512 ) n = SCSI_DMA_BUF_SIZE / 512 ; if ( s -> tray_open ) { scsi_read_complete ( r , - ENOMEDIUM ) ; } <S2SV_StartBug> r -> iov . iov_len = n * 512 ; <S2SV_EndBug> <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; <S2SV_StartBug> r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , & r -> qiov , n , <S2SV_EndBug> scsi_read_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_read_complete ( r , - EIO ) ; } }
CWE-119 static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , "nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , "nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , "nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , "nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\n" ) ; break ; default : dev_err ( & desc -> intf -> dev , "Unexpected<S2SV_blank>error<S2SV_blank>%d\\n" , status ) ; break ; } } desc -> rerr = status ; <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }
CWE-000 static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> CRn == 9 && r -> CRm == 13 ) { if ( r -> Op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , PMSELR_EL0 ) & ARMV8_PMU_COUNTER_MASK ; } else if ( r -> Op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } } else if ( r -> CRn == 14 && ( r -> CRm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }
CWE-000 static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) { EVP_CIPHER_CTX * ctx ; int key_len ; StringValue ( key ) ; GetCipher ( self , ctx ) ; key_len = EVP_CIPHER_CTX_key_length ( ctx ) ; if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , "key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes" , key_len ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; <S2SV_StartBug> return key ; <S2SV_EndBug> }
CWE-119 static int smacker_decode_tree ( BitstreamContext * bc , HuffContext * hc , uint32_t prefix , int length ) { <S2SV_StartBug> if ( ! bitstream_read_bit ( bc ) ) { <S2SV_EndBug> if ( hc -> current >= 256 ) { av_log ( NULL , AV_LOG_ERROR , "Tree<S2SV_blank>size<S2SV_blank>exceeded!\\n" ) ; return AVERROR_INVALIDDATA ; } if ( length ) { hc -> bits [ hc -> current ] = prefix ; hc -> lengths [ hc -> current ] = length ; } else { hc -> bits [ hc -> current ] = 0 ; hc -> lengths [ hc -> current ] = 0 ; } hc -> values [ hc -> current ] = bitstream_read ( bc , 8 ) ; hc -> current ++ ; if ( hc -> maxlength < length ) hc -> maxlength = length ; return 0 ; } else { int r ; length ++ ; r = smacker_decode_tree ( bc , hc , prefix , length ) ; if ( r ) return r ; return smacker_decode_tree ( bc , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ; } }
CWE-190 void * <S2SV_StartBug> xmalloc ( size_t size ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> void * ptr = malloc ( size ) ; <S2SV_EndBug> if ( ! ptr && ( size != 0 ) ) { perror ( "xmalloc:<S2SV_blank>Memory<S2SV_blank>allocation<S2SV_blank>failure" ) ; abort ( ) ; } return ptr ; }
CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
CWE-264 <S2SV_StartBug> static bool new_idmap_permitted ( struct user_namespace * ns , int cap_setid , <S2SV_EndBug> struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; if ( uid_eq ( uid , current_fsuid ( ) ) ) return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; if ( gid_eq ( gid , current_fsgid ( ) ) ) return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ; <S2SV_StartBug> if ( ns_capable ( ns -> parent , cap_setid ) ) <S2SV_EndBug> return true ; return false ; }
CWE-189 Datum path_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; PATH * path ; int isopen ; char * s ; int npts ; <S2SV_StartBug> int size ; <S2SV_EndBug> int depth = 0 ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\"%s\\"" , str ) ) ) ; s = str ; while ( isspace ( ( unsigned char ) * s ) ) s ++ ; if ( ( * s == LDELIM ) && ( strrchr ( s , LDELIM ) == s ) ) { s ++ ; depth ++ ; } <S2SV_StartBug> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <S2SV_EndBug> path = ( PATH * ) palloc ( size ) ; SET_VARSIZE ( path , size ) ; path -> npts = npts ; if ( ( ! path_decode ( TRUE , npts , s , & isopen , & s , & ( path -> p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == '\\0' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\"%s\\"" , str ) ) ) ; path -> closed = ( ! isopen ) ; path -> dummy = 0 ; PG_RETURN_PATH_P ( path ) ; }
CWE-125 static void print_attr_string ( netdissect_options * ndo , register const u_char * data , u_int length , u_short attr_code ) { register u_int i ; ND_TCHECK2 ( data [ 0 ] , length ) ; switch ( attr_code ) { case TUNNEL_PASS : if ( length < 3 ) <S2SV_StartBug> { <S2SV_EndBug> ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; } if ( * data && ( * data <= 0x1F ) ) ND_PRINT ( ( ndo , "Tag[%u]<S2SV_blank>" , * data ) ) ; else ND_PRINT ( ( ndo , "Tag[Unused]<S2SV_blank>" ) ) ; data ++ ; length -- ; ND_PRINT ( ( ndo , "Salt<S2SV_blank>%u<S2SV_blank>" , EXTRACT_16BITS ( data ) ) ) ; data += 2 ; length -= 2 ; break ; case TUNNEL_CLIENT_END : case TUNNEL_SERVER_END : case TUNNEL_PRIV_GROUP : case TUNNEL_ASSIGN_ID : case TUNNEL_CLIENT_AUTH : case TUNNEL_SERVER_AUTH : if ( * data <= 0x1F ) { if ( length < 1 ) <S2SV_StartBug> { <S2SV_EndBug> ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; } if ( * data ) ND_PRINT ( ( ndo , "Tag[%u]<S2SV_blank>" , * data ) ) ; else ND_PRINT ( ( ndo , "Tag[Unused]<S2SV_blank>" ) ) ; data ++ ; length -- ; } break ; <S2SV_StartBug> case EGRESS_VLAN_NAME : <S2SV_EndBug> ND_PRINT ( ( ndo , "%s<S2SV_blank>(0x%02x)<S2SV_blank>" , tok2str ( rfc4675_tagged , "Unknown<S2SV_blank>tag" , * data ) , * data ) ) ; data ++ ; length -- ; break ; } <S2SV_StartBug> for ( i = 0 ; * data && i < length ; i ++ , data ++ ) <S2SV_EndBug> ND_PRINT ( ( ndo , "%c" , ( * data < 32 || * data > 126 ) ? '.' : * data ) ) ; return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-000 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; <S2SV_StartBug> if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && <S2SV_EndBug> end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && <S2SV_StartBug> vma -> vm_userfaultfd_ctx . ctx != ctx ) ; <S2SV_EndBug> if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
CWE-000 static int __ext4_set_acl ( handle_t * handle , struct inode * inode , int type , struct posix_acl * acl ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext4_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext4_xattr_set_handle ( handle , inode , name_index , "" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
CWE-000 int nfs3svc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ~ 0 ; args -> count = ntohl ( * p ++ ) ; <S2SV_StartBug> args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_EndBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
CWE-125 static inline signed short ReadPropertyMSBShort ( const unsigned char * * p , size_t * length ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 2 ] ; unsigned short value ; if ( * length < 2 ) return ( ( unsigned short ) ~ 0 ) ; for ( i = 0 ; i < 2 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
CWE-119 void faad_resetbits ( bitfile * ld , int bits ) { uint32_t tmp ; int words = bits >> 5 ; int remainder = bits & 0x1F ; <S2SV_StartBug> ld -> bytes_left = ld -> buffer_size - words * 4 ; <S2SV_EndBug> if ( ld -> bytes_left >= 4 ) { tmp = getdword ( & ld -> start [ words ] ) ; ld -> bytes_left -= 4 ; } else { tmp = getdword_n ( & ld -> start [ words ] , ld -> bytes_left ) ; ld -> bytes_left = 0 ; } ld -> bufa = tmp ; if ( ld -> bytes_left >= 4 ) { tmp = getdword ( & ld -> start [ words + 1 ] ) ; ld -> bytes_left -= 4 ; } else { tmp = getdword_n ( & ld -> start [ words + 1 ] , ld -> bytes_left ) ; ld -> bytes_left = 0 ; } ld -> bufb = tmp ; ld -> bits_left = 32 - remainder ; ld -> tail = & ld -> start [ words + 2 ] ; ld -> error = 0 ; }
CWE-119 static vpx_codec_err_t ctrl_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> # if CONFIG_VP9_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } # else <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> # endif }
CWE-000 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'"\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { <S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'"\' ; * pt = '\\0' ; }
CWE-20 SPL_METHOD ( Array , unserialize ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; char * buf ; int buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval * pmembers , * pflags = NULL ; HashTable * aht ; long flags ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } aht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; if ( aht -> nApplyCount > 0 ) { zend_error ( E_WARNING , "Modification<S2SV_blank>of<S2SV_blank>ArrayObject<S2SV_blank>during<S2SV_blank>sorting<S2SV_blank>is<S2SV_blank>prohibited" ) ; return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pflags ) ; if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pflags ) != IS_LONG ) { goto outexcept ; } var_push_dtor ( & var_hash , & pflags ) ; -- p ; flags = Z_LVAL_P ( pflags ) ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' ) { if ( * p != 'a' && * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } intern -> ar_flags &= ~ SPL_ARRAY_CLONE_MASK ; intern -> ar_flags |= flags & SPL_ARRAY_CLONE_MASK ; zval_ptr_dtor ( & intern -> array ) ; ALLOC_INIT_ZVAL ( intern -> array ) ; <S2SV_StartBug> if ( ! php_var_unserialize ( & intern -> array , & p , s + buf_len , & var_hash TSRMLS_CC ) ) { <S2SV_EndBug> goto outexcept ; } var_push_dtor ( & var_hash , & intern -> array ) ; } if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pmembers ) ; if ( ! php_var_unserialize ( & pmembers , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pmembers ) != IS_ARRAY ) { zval_ptr_dtor ( & pmembers ) ; goto outexcept ; } var_push_dtor ( & var_hash , & pmembers ) ; if ( ! intern -> std . properties ) { rebuild_object_properties ( & intern -> std ) ; } zend_hash_copy ( intern -> std . properties , Z_ARRVAL_P ( pmembers ) , ( copy_ctor_func_t ) zval_add_ref , ( void * ) NULL , sizeof ( zval * ) ) ; zval_ptr_dtor ( & pmembers ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( pflags ) { zval_ptr_dtor ( & pflags ) ; } return ; outexcept : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( pflags ) { zval_ptr_dtor ( & pflags ) ; } zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 TSRMLS_CC , "Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%ld<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , ( long ) ( ( char * ) p - buf ) , buf_len ) ; return ; }
CWE-119 static void y4m_convert_null ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> } <S2SV_EndBug>
CWE-787 int TIFFFlushData1 ( TIFF * tif ) { if ( tif -> tif_rawcc > 0 && tif -> tif_flags & TIFF_BUF4WRITE ) { if ( ! isFillOrder ( tif , tif -> tif_dir . td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( ( uint8 * ) tif -> tif_rawdata , tif -> tif_rawcc ) ; if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; } return ( 1 ) ; }
CWE-000 void xmlParsePI ( xmlParserCtxtPtr ctxt ) { xmlChar * buf = NULL ; int len = 0 ; int size = XML_PARSER_BUFFER_SIZE ; int cur , l ; const xmlChar * target ; xmlParserInputState state ; int count = 0 ; if ( ( RAW == '<' ) && ( NXT ( 1 ) == '?' ) ) { xmlParserInputPtr input = ctxt -> input ; state = ctxt -> instate ; ctxt -> instate = XML_PARSER_PI ; SKIP ( 2 ) ; SHRINK ; target = xmlParsePITarget ( ctxt ) ; if ( target != NULL ) { if ( ( RAW == '?' ) && ( NXT ( 1 ) == '>' ) ) { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_ENTITY_BOUNDARY , "PI<S2SV_blank>declaration<S2SV_blank>doesn\'t<S2SV_blank>start<S2SV_blank>and<S2SV_blank>stop<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>entity\\n" ) ; } SKIP ( 2 ) ; if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , <S2SV_StartBug> target , NULL ) ; <S2SV_EndBug> ctxt -> instate = state ; return ; } buf = ( xmlChar * ) xmlMallocAtomic ( size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) { xmlErrMemory ( ctxt , NULL ) ; ctxt -> instate = state ; return ; } cur = CUR ; if ( ! IS_BLANK ( cur ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_SPACE_REQUIRED , "ParsePI:<S2SV_blank>PI<S2SV_blank>%s<S2SV_blank>space<S2SV_blank>expected\\n" , target ) ; } SKIP_BLANKS ; cur = CUR_CHAR ( l ) ; while ( IS_CHAR ( cur ) && ( ( cur != '?' ) || ( NXT ( 1 ) != '>' ) ) ) { if ( len + 5 >= size ) { xmlChar * tmp ; size *= 2 ; tmp = ( xmlChar * ) xmlRealloc ( buf , size * sizeof ( xmlChar ) ) ; if ( tmp == NULL ) { xmlErrMemory ( ctxt , NULL ) ; xmlFree ( buf ) ; ctxt -> instate = state ; return ; } buf = tmp ; } count ++ ; if ( count > 50 ) { GROW ; count = 0 ; } COPY_BUF ( l , buf , len , cur ) ; NEXTL ( l ) ; cur = CUR_CHAR ( l ) ; if ( cur == 0 ) { SHRINK ; GROW ; cur = CUR_CHAR ( l ) ; } } buf [ len ] = 0 ; if ( cur != '?' ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_PI_NOT_FINISHED , "ParsePI:<S2SV_blank>PI<S2SV_blank>%s<S2SV_blank>never<S2SV_blank>end<S2SV_blank>...\\n" , target ) ; } else { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , "PI<S2SV_blank>declaration<S2SV_blank>doesn\'t<S2SV_blank>start<S2SV_blank>and<S2SV_blank>stop<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>entity\\n" ) ; } SKIP ( 2 ) ; # ifdef LIBXML_CATALOG_ENABLED if ( ( ( state == XML_PARSER_MISC ) || ( state == XML_PARSER_START ) ) && ( xmlStrEqual ( target , XML_CATALOG_PI ) ) ) { xmlCatalogAllow allow = xmlCatalogGetDefaults ( ) ; if ( ( allow == XML_CATA_ALLOW_DOCUMENT ) || ( allow == XML_CATA_ALLOW_ALL ) ) xmlParseCatalogPI ( ctxt , buf ) ; } # endif if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , target , buf ) ; } xmlFree ( buf ) ; } else { xmlFatalErr ( ctxt , XML_ERR_PI_NOT_STARTED , NULL ) ; } <S2SV_StartBug> ctxt -> instate = state ; <S2SV_EndBug> } }
CWE-119 <S2SV_StartBug> void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) <S2SV_EndBug> { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( ps_dec -> u2_first_mb ) { ps_dec -> u2_mb_x = u2_mb_addr_incr - 1 ; ps_dec -> u2_mb_x = MIN ( ps_dec -> u2_mb_x , ( ps_dec -> u2_num_horiz_mb - 1 ) ) ; u2_mb_addr_incr = 1 ; ps_dec -> u2_first_mb = 0 ; } else { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << u2_len ) ; } { WORD32 i4_motion_type = ps_dec -> u2_motion_type ; if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; } if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ( ( i4_motion_type == 0 ) || ( i4_motion_type == 3 ) || ( i4_motion_type == 4 ) || ( i4_motion_type >= 7 ) ) ) { i4_motion_type = 1 ; } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_BIDRECT ) { UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = BIDIRECT ; ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> } else if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 u2_refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) u2_refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ u2_index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue >> 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> STREAM s ; <S2SV_EndBug> RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , "%s()" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; <S2SV_StartBug> ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , "mcs_recv_connect_response(),<S2SV_blank>result=%d" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; <S2SV_StartBug> mcs_parse_domain_params ( s ) ; <S2SV_EndBug> ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
CWE-416 static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ; <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> & tx_ring_data ( priv , skb -> queue_mapping ) ) ; <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }
CWE-399 static void inotify_free_group_priv ( struct fsnotify_group * group ) { idr_for_each ( & group -> inotify_data . idr , idr_callback , group ) ; idr_remove_all ( & group -> inotify_data . idr ) ; idr_destroy ( & group -> inotify_data . idr ) ; <S2SV_StartBug> free_uid ( group -> inotify_data . user ) ; <S2SV_EndBug> }
CWE-476 static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , "early<S2SV_blank>EOF" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , "report-status:<S2SV_blank>Error<S2SV_blank>reported:<S2SV_blank>%s" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p -> data , p -> len , transport -> message_cb_payload ) ; } break ; default : error = add_push_report_pkt ( push , pkt ) ; break ; } git_pkt_free ( pkt ) ; if ( error == GIT_ITEROVER ) { error = 0 ; if ( data_pkt_buf . size > 0 ) { giterr_set ( GITERR_NET , "Incomplete<S2SV_blank>pack<S2SV_blank>data<S2SV_blank>pkt-line" ) ; error = GIT_ERROR ; } goto done ; } if ( error < 0 ) { goto done ; } } done : git_buf_free ( & data_pkt_buf ) ; return error ; }
CWE-787 static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> OPJ_UNUSED ( p_manager ) ; <S2SV_EndBug> if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; } opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; # ifdef USE_JPWL assert ( 0 && "TODO" ) ; # endif * p_data_written = 12 ; return OPJ_TRUE ; }
CWE-200 static int snd_timer_user_params ( struct file * file , struct snd_timer_params __user * _params ) { struct snd_timer_user * tu ; struct snd_timer_params params ; struct snd_timer * t ; struct snd_timer_read * tr ; struct snd_timer_tread * ttr ; int err ; tu = file -> private_data ; if ( ! tu -> timeri ) return - EBADFD ; t = tu -> timeri -> timer ; if ( ! t ) return - EBADFD ; if ( copy_from_user ( & params , _params , sizeof ( params ) ) ) return - EFAULT ; if ( ! ( t -> hw . flags & SNDRV_TIMER_HW_SLAVE ) && params . ticks < 1 ) { err = - EINVAL ; goto _end ; } if ( params . queue_size > 0 && ( params . queue_size < 32 || params . queue_size > 1024 ) ) { err = - EINVAL ; goto _end ; } if ( params . filter & ~ ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) | ( 1 << SNDRV_TIMER_EVENT_START ) | ( 1 << SNDRV_TIMER_EVENT_STOP ) | ( 1 << SNDRV_TIMER_EVENT_CONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_PAUSE ) | ( 1 << SNDRV_TIMER_EVENT_SUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_RESUME ) | ( 1 << SNDRV_TIMER_EVENT_MSTART ) | ( 1 << SNDRV_TIMER_EVENT_MSTOP ) | ( 1 << SNDRV_TIMER_EVENT_MCONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_MPAUSE ) | ( 1 << SNDRV_TIMER_EVENT_MSUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_MRESUME ) ) ) { err = - EINVAL ; goto _end ; } snd_timer_stop ( tu -> timeri ) ; spin_lock_irq ( & t -> lock ) ; tu -> timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_AUTO | SNDRV_TIMER_IFLG_EXCLUSIVE | SNDRV_TIMER_IFLG_EARLY_EVENT ) ; if ( params . flags & SNDRV_TIMER_PSFLG_AUTO ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_AUTO ; if ( params . flags & SNDRV_TIMER_PSFLG_EXCLUSIVE ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EXCLUSIVE ; if ( params . flags & SNDRV_TIMER_PSFLG_EARLY_EVENT ) tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EARLY_EVENT ; spin_unlock_irq ( & t -> lock ) ; if ( params . queue_size > 0 && ( unsigned int ) tu -> queue_size != params . queue_size ) { if ( tu -> tread ) { ttr = kmalloc ( params . queue_size * sizeof ( * ttr ) , GFP_KERNEL ) ; if ( ttr ) { kfree ( tu -> tqueue ) ; tu -> queue_size = params . queue_size ; tu -> tqueue = ttr ; } } else { tr = kmalloc ( params . queue_size * sizeof ( * tr ) , GFP_KERNEL ) ; if ( tr ) { kfree ( tu -> queue ) ; tu -> queue_size = params . queue_size ; tu -> queue = tr ; } } } tu -> qhead = tu -> qtail = tu -> qused = 0 ; if ( tu -> timeri -> flags & SNDRV_TIMER_IFLG_EARLY_EVENT ) { if ( tu -> tread ) { struct snd_timer_tread tread ; <S2SV_StartBug> tread . event = SNDRV_TIMER_EVENT_EARLY ; <S2SV_EndBug> tread . tstamp . tv_sec = 0 ; tread . tstamp . tv_nsec = 0 ; tread . val = 0 ; snd_timer_user_append_to_tqueue ( tu , & tread ) ; } else { struct snd_timer_read * r = & tu -> queue [ 0 ] ; r -> resolution = 0 ; r -> ticks = 0 ; tu -> qused ++ ; tu -> qtail ++ ; } } tu -> filter = params . filter ; tu -> ticks = params . ticks ; err = 0 ; _end : if ( copy_to_user ( _params , & params , sizeof ( params ) ) ) return - EFAULT ; return err ; }
CWE-119 static int check_ptr_alignment ( struct bpf_verifier_env * env , const struct bpf_reg_state * reg , int off , int size ) { bool strict = env -> strict_alignment ; const char * pointer_desc = "" ; switch ( reg -> type ) { case PTR_TO_PACKET : case PTR_TO_PACKET_META : return check_pkt_ptr_alignment ( env , reg , off , size , strict ) ; case PTR_TO_MAP_VALUE : pointer_desc = "value<S2SV_blank>" ; break ; case PTR_TO_CTX : pointer_desc = "context<S2SV_blank>" ; break ; case PTR_TO_STACK : pointer_desc = "stack<S2SV_blank>" ; <S2SV_StartBug> break ; <S2SV_EndBug> default : break ; } return check_generic_ptr_alignment ( env , reg , pointer_desc , off , size , strict ) ; }
CWE-20 int key_update ( key_ref_t key_ref , const void * payload , size_t plen ) { struct key_preparsed_payload prep ; struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; key_check ( key ) ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) return ret ; if ( ! key -> type -> update ) return - EOPNOTSUPP ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = key -> type -> def_datalen ; prep . expiry = TIME_T_MAX ; if ( key -> type -> preparse ) { ret = key -> type -> preparse ( & prep ) ; if ( ret < 0 ) goto error ; } down_write ( & key -> sem ) ; ret = key -> type -> update ( key , & prep ) ; if ( ret == 0 ) <S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> up_write ( & key -> sem ) ; error : if ( key -> type -> preparse ) key -> type -> free_preparse ( & prep ) ; return ret ; }
CWE-362 int install_user_keyrings ( void ) { struct user_struct * user ; const struct cred * cred ; struct key * uid_keyring , * session_keyring ; key_perm_t user_keyring_perm ; char buf [ 20 ] ; int ret ; uid_t uid ; user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( "%p{%u}" , user , uid ) ; <S2SV_StartBug> if ( user -> uid_keyring ) { <S2SV_EndBug> kleave ( "<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]" ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , "_uid.%u" , uid ) ; uid_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( uid_keyring ) ) { uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( uid_keyring ) ) { ret = PTR_ERR ( uid_keyring ) ; goto error ; } } sprintf ( buf , "_uid_ses.%u" , uid ) ; session_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( session_keyring ) ) { session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( session_keyring ) ) { ret = PTR_ERR ( session_keyring ) ; goto error_release ; } ret = key_link ( session_keyring , uid_keyring ) ; if ( ret < 0 ) goto error_release_both ; } user -> uid_keyring = uid_keyring ; user -> session_keyring = session_keyring ; } mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( "<S2SV_blank>=<S2SV_blank>0" ) ; return 0 ; error_release_both : key_put ( session_keyring ) ; error_release : key_put ( uid_keyring ) ; error : mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( "<S2SV_blank>=<S2SV_blank>%d" , ret ) ; return ret ; }
CWE-119 static void resize_multistep ( const uint8_t * const input , int length , uint8_t * output , int olength , uint8_t * buf ) { int steps ; if ( length == olength ) { <S2SV_StartBug> memcpy ( output , input , sizeof ( uint8_t ) * length ) ; <S2SV_EndBug> return ; } steps = get_down2_steps ( length , olength ) ; if ( steps > 0 ) { int s ; uint8_t * out = NULL ; uint8_t * tmpbuf = NULL ; uint8_t * otmp , * otmp2 ; int filteredlength = length ; if ( ! tmpbuf ) { tmpbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * length ) ; otmp = tmpbuf ; } else { otmp = buf ; } otmp2 = otmp + get_down2_length ( length , 1 ) ; for ( s = 0 ; s < steps ; ++ s ) { const int proj_filteredlength = get_down2_length ( filteredlength , 1 ) ; const uint8_t * const in = ( s == 0 ? input : out ) ; if ( s == steps - 1 && proj_filteredlength == olength ) out = output ; else out = ( s & 1 ? otmp2 : otmp ) ; if ( filteredlength & 1 ) down2_symodd ( in , filteredlength , out ) ; else down2_symeven ( in , filteredlength , out ) ; filteredlength = proj_filteredlength ; } if ( filteredlength != olength ) { interpolate ( out , filteredlength , output , olength ) ; } if ( tmpbuf ) free ( tmpbuf ) ; } else { interpolate ( input , length , output , olength ) ; } }
CWE-119 static vpx_codec_err_t decoder_peek_si ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si ) { <S2SV_StartBug> if ( data_sz <= 8 ) <S2SV_EndBug> return VPX_CODEC_UNSUP_BITSTREAM ; if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ; si -> is_kf = 0 ; si -> w = si -> h = 0 ; { <S2SV_StartBug> struct vp9_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; <S2SV_EndBug> const int frame_marker = vp9_rb_read_literal ( & rb , 2 ) ; const int version = vp9_rb_read_bit ( & rb ) ; ( void ) vp9_rb_read_bit ( & rb ) ; if ( frame_marker != VP9_FRAME_MARKER ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( version > 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( vp9_rb_read_bit ( & rb ) ) { return VPX_CODEC_OK ; } si -> is_kf = ! vp9_rb_read_bit ( & rb ) ; if ( si -> is_kf ) { const int sRGB = 7 ; int colorspace ; rb . bit_offset += 1 ; rb . bit_offset += 1 ; if ( vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_0 || vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_1 || vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_2 ) { return VPX_CODEC_UNSUP_BITSTREAM ; } colorspace = vp9_rb_read_literal ( & rb , 3 ) ; if ( colorspace != sRGB ) { rb . bit_offset += 1 ; if ( version == 1 ) { rb . bit_offset += 2 ; rb . bit_offset += 1 ; } } else { if ( version == 1 ) { rb . bit_offset += 1 ; } else { return VPX_CODEC_UNSUP_BITSTREAM ; } } si -> w = vp9_rb_read_literal ( & rb , 16 ) + 1 ; si -> h = vp9_rb_read_literal ( & rb , 16 ) + 1 ; } } return VPX_CODEC_OK ; }
CWE-399 xmlAttrPtr xsltAttrListTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attrs ) { xmlAttrPtr attr , copy , last ; xmlNodePtr oldInsert , text ; xmlNsPtr origNs = NULL , copyNs = NULL ; const xmlChar * value ; xmlChar * valueAVT ; if ( ( ctxt == NULL ) || ( target == NULL ) || ( attrs == NULL ) ) return ( NULL ) ; oldInsert = ctxt -> insert ; ctxt -> insert = target ; if ( target -> properties ) { last = target -> properties ; while ( last -> next != NULL ) last = last -> next ; } else { last = NULL ; } attr = attrs ; do { # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) { goto next_attribute ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { goto next_attribute ; } # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>The<S2SV_blank>children<S2SV_blank>of<S2SV_blank>an<S2SV_blank>attribute<S2SV_blank>node<S2SV_blank>of<S2SV_blank>a<S2SV_blank>" "literal<S2SV_blank>result<S2SV_blank>element<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>expected<S2SV_blank>form.\\n" ) ; goto error ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST "" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST "" , 0 ) ; copy = xmlNewDocProp ( target -> doc , attr -> name , NULL ) ; if ( copy == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n" , attr -> name ) ; } goto error ; } copy -> parent = target ; if ( last == NULL ) { target -> properties = copy ; last = copy ; } else { last -> next = copy ; copy -> prev = last ; last = copy ; } if ( attr -> ns != origNs ) { origNs = attr -> ns ; if ( attr -> ns != NULL ) { # ifdef XSLT_REFACTORED copyNs = xsltGetSpecialNamespace ( ctxt , attr -> parent , attr -> ns -> href , attr -> ns -> prefix , target ) ; # else copyNs = xsltGetNamespace ( ctxt , attr -> parent , attr -> ns , target ) ; # endif if ( copyNs == NULL ) goto error ; } else copyNs = NULL ; } copy -> ns = copyNs ; text = xmlNewText ( NULL ) ; if ( text != NULL ) { copy -> last = copy -> children = text ; text -> parent = ( xmlNodePtr ) copy ; text -> doc = copy -> doc ; if ( attr -> psvi != NULL ) { valueAVT = xsltEvalAVT ( ctxt , attr -> psvi , attr -> parent ) ; if ( valueAVT == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>" "of<S2SV_blank>attribute<S2SV_blank>\'{%s}%s\'.\\n" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , "Internal<S2SV_blank>error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>evaluate<S2SV_blank>the<S2SV_blank>AVT<S2SV_blank>" "of<S2SV_blank>attribute<S2SV_blank>\'%s\'.\\n" , attr -> name ) ; } text -> content = xmlStrdup ( BAD_CAST "" ) ; goto error ; } else { text -> content = valueAVT ; } } else if ( ( ctxt -> internalized ) && ( target -> doc != NULL ) && <S2SV_StartBug> ( target -> doc -> dict == ctxt -> dict ) ) <S2SV_EndBug> { text -> content = ( xmlChar * ) value ; } else { text -> content = xmlStrdup ( value ) ; } if ( ( copy != NULL ) && ( text != NULL ) && ( xmlIsID ( copy -> doc , copy -> parent , copy ) ) ) xmlAddID ( NULL , copy -> doc , text -> content , copy ) ; } next_attribute : attr = attr -> next ; } while ( attr != NULL ) ; attr = attrs ; do { # ifdef XSLT_REFACTORED if ( ( attr -> psvi == xsltXSLTAttrMarker ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) "use-attribute-sets" ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> name , ( const xmlChar * ) "use-attribute-sets" ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { xsltApplyAttributeSet ( ctxt , ctxt -> node , ( xmlNodePtr ) attr , NULL ) ; } # endif attr = attr -> next ; } while ( attr != NULL ) ; ctxt -> insert = oldInsert ; return ( target -> properties ) ; error : ctxt -> insert = oldInsert ; return ( NULL ) ; }
CWE-264 static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = "Getting<S2SV_blank>sb<S2SV_blank>failed" ; struct inode * inode ; struct path path ; uid_t check_ruid ; int rc ; sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ; if ( rc ) { err = "Error<S2SV_blank>parsing<S2SV_blank>options" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , flags , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } rc = bdi_setup_and_register ( & sbi -> bdi , "ecryptfs" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = "Reading<S2SV_blank>sb<S2SV_blank>failed" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , "kern_path()<S2SV_blank>failed\\n" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR "Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>" "eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>" "known<S2SV_blank>incompatibilities\\n" ) ; goto out_free ; } if ( check_ruid && ! uid_eq ( path . dentry -> d_inode -> i_uid , current_uid ( ) ) ) { rc = - EPERM ; printk ( KERN_ERR "Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>" "requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n" , i_uid_read ( path . dentry -> d_inode ) , from_kuid ( & init_user_ns , current_uid ( ) ) ) ; goto out_free ; } ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; s -> s_flags = flags & ~ MS_POSIXACL ; s -> s_flags |= path . dentry -> d_sb -> s_flags & ( MS_RDONLY | MS_POSIXACL ) ; s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; <S2SV_StartBug> inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; <S2SV_EndBug> rc = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto out_free ; s -> s_root = d_make_root ( inode ) ; if ( ! s -> s_root ) { rc = - ENOMEM ; goto out_free ; } rc = - ENOMEM ; root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; if ( ! root_info ) goto out_free ; ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; root_info -> lower_path = path ; s -> s_flags |= MS_ACTIVE ; return dget ( s -> s_root ) ; out_free : path_put ( & path ) ; out1 : deactivate_locked_super ( s ) ; out : if ( sbi ) { ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; } printk ( KERN_ERR "%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , err , rc ) ; return ERR_PTR ( rc ) ; }
CWE-264 static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ; <S2SV_StartBug> char * dir = "/etc" ; <S2SV_EndBug> <S2SV_StartBug> if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { <S2SV_EndBug> ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( "can\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }
CWE-264 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kfree ( buf ) ; return ret ; }
CWE-119 static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; <S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }
CWE-000 int ext2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext2_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext2_xattr_set ( inode , name_index , "" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
CWE-189 Datum hstore_from_arrays ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; Datum * key_datums ; bool * key_nulls ; int key_count ; Datum * value_datums ; bool * value_nulls ; int value_count ; ArrayType * key_array ; ArrayType * value_array ; int i ; if ( PG_ARGISNULL ( 0 ) ) PG_RETURN_NULL ( ) ; key_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; Assert ( ARR_ELEMTYPE ( key_array ) == TEXTOID ) ; if ( ARR_NDIM ( key_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts" ) ) ) ; deconstruct_array ( key_array , TEXTOID , - 1 , false , 'i' , <S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> if ( PG_ARGISNULL ( 1 ) ) { value_array = NULL ; value_count = key_count ; value_datums = NULL ; value_nulls = NULL ; } else { value_array = PG_GETARG_ARRAYTYPE_P ( 1 ) ; Assert ( ARR_ELEMTYPE ( value_array ) == TEXTOID ) ; if ( ARR_NDIM ( value_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts" ) ) ) ; if ( ( ARR_NDIM ( key_array ) > 0 || ARR_NDIM ( value_array ) > 0 ) && ( ARR_NDIM ( key_array ) != ARR_NDIM ( value_array ) || ARR_DIMS ( key_array ) [ 0 ] != ARR_DIMS ( value_array ) [ 0 ] || ARR_LBOUND ( key_array ) [ 0 ] != ARR_LBOUND ( value_array ) [ 0 ] ) ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>same<S2SV_blank>bounds" ) ) ) ; deconstruct_array ( value_array , TEXTOID , - 1 , false , 'i' , & value_datums , & value_nulls , & value_count ) ; Assert ( key_count == value_count ) ; } pairs = palloc ( key_count * sizeof ( Pairs ) ) ; for ( i = 0 ; i < key_count ; ++ i ) { if ( key_nulls [ i ] ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( "null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key" ) ) ) ; if ( ! value_nulls || value_nulls [ i ] ) { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = NULL ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = 4 ; pairs [ i ] . isnull = true ; pairs [ i ] . needfree = false ; } else { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = VARDATA_ANY ( value_datums [ i ] ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( value_datums [ i ] ) ) ; pairs [ i ] . isnull = false ; pairs [ i ] . needfree = false ; } } key_count = hstoreUniquePairs ( pairs , key_count , & buflen ) ; out = hstorePairs ( pairs , key_count , buflen ) ; PG_RETURN_POINTER ( out ) ; }
CWE-200 static int load_script ( struct linux_binprm * bprm ) { const char * i_arg , * i_name ; char * cp ; struct file * file ; char interp [ BINPRM_BUF_SIZE ] ; int retval ; if ( ( bprm -> buf [ 0 ] != '#' ) || ( bprm -> buf [ 1 ] != '!' ) ) return - ENOEXEC ; allow_write_access ( bprm -> file ) ; fput ( bprm -> file ) ; bprm -> file = NULL ; bprm -> buf [ BINPRM_BUF_SIZE - 1 ] = '\\0' ; if ( ( cp = strchr ( bprm -> buf , '\\n' ) ) == NULL ) cp = bprm -> buf + BINPRM_BUF_SIZE - 1 ; * cp = '\\0' ; while ( cp > bprm -> buf ) { cp -- ; if ( ( * cp == '<S2SV_blank>' ) || ( * cp == '\\t' ) ) * cp = '\\0' ; else break ; } for ( cp = bprm -> buf + 2 ; ( * cp == '<S2SV_blank>' ) || ( * cp == '\\t' ) ; cp ++ ) ; if ( * cp == '\\0' ) return - ENOEXEC ; i_name = cp ; i_arg = NULL ; for ( ; * cp && ( * cp != '<S2SV_blank>' ) && ( * cp != '\\t' ) ; cp ++ ) ; while ( ( * cp == '<S2SV_blank>' ) || ( * cp == '\\t' ) ) * cp ++ = '\\0' ; if ( * cp ) i_arg = cp ; strcpy ( interp , i_name ) ; retval = remove_arg_zero ( bprm ) ; if ( retval ) return retval ; retval = copy_strings_kernel ( 1 , & bprm -> interp , bprm ) ; if ( retval < 0 ) return retval ; bprm -> argc ++ ; if ( i_arg ) { retval = copy_strings_kernel ( 1 , & i_arg , bprm ) ; if ( retval < 0 ) return retval ; bprm -> argc ++ ; } retval = copy_strings_kernel ( 1 , & i_name , bprm ) ; if ( retval ) return retval ; bprm -> argc ++ ; <S2SV_StartBug> bprm -> interp = interp ; <S2SV_EndBug> file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ; <S2SV_StartBug> return search_binary_handler ( bprm ) ; <S2SV_EndBug> }
CWE-20 void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; <S2SV_StartBug> * dptr ++ = 0xAA ; <S2SV_EndBug> memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR "ROSE:<S2SV_blank>rose_write_internal<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>frametype<S2SV_blank>%02X\\n" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
CWE-119 <S2SV_StartBug> static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . lossless ) { <S2SV_EndBug> return ONLY_4X4 ; <S2SV_StartBug> } else if ( cpi -> common . current_video_frame == 0 ) { <S2SV_EndBug> return TX_MODE_SELECT ; } else { <S2SV_StartBug> if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) { <S2SV_EndBug> return ALLOW_32X32 ; <S2SV_StartBug> } else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) { <S2SV_EndBug> const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ; return cpi -> rd_tx_select_threshes [ frame_type ] [ ALLOW_32X32 ] > cpi -> rd_tx_select_threshes [ frame_type ] [ TX_MODE_SELECT ] ? ALLOW_32X32 : TX_MODE_SELECT ; } else { unsigned int total = 0 ; int i ; for ( i = 0 ; i < TX_SIZES ; ++ i ) total += cpi -> tx_stepdown_count [ i ] ; if ( total ) { const double fraction = ( double ) cpi -> tx_stepdown_count [ 0 ] / total ; return fraction > 0.90 ? ALLOW_32X32 : TX_MODE_SELECT ; } else { return cpi -> common . tx_mode ; } <S2SV_StartBug> } <S2SV_EndBug> } }
CWE-189 TSQuery QTN2QT ( QTNode * in ) { TSQuery out ; int len ; int sumlen = 0 , nnode = 0 ; QTN2QTState state ; <S2SV_StartBug> cntsize ( in , & sumlen , & nnode ) ; <S2SV_EndBug> len = COMPUTESIZE ( nnode , sumlen ) ; out = ( TSQuery ) palloc0 ( len ) ; SET_VARSIZE ( out , len ) ; out -> size = nnode ; state . curitem = GETQUERY ( out ) ; state . operand = state . curoperand = GETOPERAND ( out ) ; fillQT ( & state , in ) ; return out ; }
CWE-119 static int airspy_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct airspy * s ; int ret ; u8 u8tmp , buf [ BUF_SIZE ] ; s = kzalloc ( sizeof ( struct airspy ) , GFP_KERNEL ) ; if ( s == NULL ) { dev_err ( & intf -> dev , "Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>state\\n" ) ; return - ENOMEM ; } mutex_init ( & s -> v4l2_lock ) ; mutex_init ( & s -> vb_queue_lock ) ; spin_lock_init ( & s -> queued_bufs_lock ) ; INIT_LIST_HEAD ( & s -> queued_bufs ) ; s -> dev = & intf -> dev ; s -> udev = interface_to_usbdev ( intf ) ; s -> f_adc = bands [ 0 ] . rangelow ; s -> f_rf = bands_rf [ 0 ] . rangelow ; s -> pixelformat = formats [ 0 ] . pixelformat ; s -> buffersize = formats [ 0 ] . buffersize ; ret = airspy_ctrl_msg ( s , CMD_BOARD_ID_READ , 0 , 0 , & u8tmp , 1 ) ; if ( ret == 0 ) ret = airspy_ctrl_msg ( s , CMD_VERSION_STRING_READ , 0 , 0 , buf , BUF_SIZE ) ; if ( ret ) { dev_err ( s -> dev , "Could<S2SV_blank>not<S2SV_blank>detect<S2SV_blank>board\\n" ) ; goto err_free_mem ; } buf [ BUF_SIZE - 1 ] = '\\0' ; dev_info ( s -> dev , "Board<S2SV_blank>ID:<S2SV_blank>%02x\\n" , u8tmp ) ; dev_info ( s -> dev , "Firmware<S2SV_blank>version:<S2SV_blank>%s\\n" , buf ) ; s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ; s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ; s -> vb_queue . drv_priv = s ; s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ; s -> vb_queue . ops = & airspy_vb2_ops ; s -> vb_queue . mem_ops = & vb2_vmalloc_memops ; s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ; ret = vb2_queue_init ( & s -> vb_queue ) ; if ( ret ) { dev_err ( s -> dev , "Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\n" ) ; goto err_free_mem ; } s -> vdev = airspy_template ; s -> vdev . queue = & s -> vb_queue ; s -> vdev . queue -> lock = & s -> vb_queue_lock ; video_set_drvdata ( & s -> vdev , s ) ; s -> v4l2_dev . release = airspy_video_release ; ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ; if ( ret ) { dev_err ( s -> dev , "Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\n" , ret ) ; goto err_free_mem ; } v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ; s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ; v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ; s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ; v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ; s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ; if ( s -> hdl . error ) { ret = s -> hdl . error ; dev_err ( s -> dev , "Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\n" ) ; goto err_free_controls ; } v4l2_ctrl_handler_setup ( & s -> hdl ) ; s -> v4l2_dev . ctrl_handler = & s -> hdl ; s -> vdev . v4l2_dev = & s -> v4l2_dev ; s -> vdev . lock = & s -> v4l2_lock ; ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ; if ( ret ) { dev_err ( s -> dev , "Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\n" , ret ) ; <S2SV_StartBug> goto err_unregister_v4l2_dev ; <S2SV_EndBug> } dev_info ( s -> dev , "Registered<S2SV_blank>as<S2SV_blank>%s\\n" , video_device_node_name ( & s -> vdev ) ) ; dev_notice ( s -> dev , "SDR<S2SV_blank>API<S2SV_blank>is<S2SV_blank>still<S2SV_blank>slightly<S2SV_blank>experimental<S2SV_blank>and<S2SV_blank>functionality<S2SV_blank>changes<S2SV_blank>may<S2SV_blank>follow\\n" ) ; return 0 ; err_free_controls : v4l2_ctrl_handler_free ( & s -> hdl ) ; <S2SV_StartBug> err_unregister_v4l2_dev : <S2SV_EndBug> v4l2_device_unregister ( & s -> v4l2_dev ) ; err_free_mem : kfree ( s ) ; return ret ; }
CWE-119 void vp9_reset_segment_features ( struct segmentation * seg ) { seg -> enabled = 0 ; seg -> update_map = 0 ; seg -> update_data = 0 ; <S2SV_StartBug> vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <S2SV_EndBug> vp9_clearall_segfeatures ( seg ) ; }
CWE-000 tdata_t _TIFFmalloc ( tsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }
CWE-119 WORD32 ih264d_parse_islice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_dec -> ps_bitstrm -> u4_ofst ; UWORD32 u4_temp ; WORD32 i_temp ; WORD32 ret ; if ( ps_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( <S2SV_EndBug> ps_dec ) ; else ps_dec -> ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) return ERROR_INV_RANGE_QP_T ; ps_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_qp_delta" , ps_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>disable_deblocking_filter_idc" , u4_temp ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_alpha_c0_offset_div2" , ps_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_beta_offset_div2" , ps_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } } else { ps_slice -> u1_disable_dblk_filter_idc = 0 ; ps_slice -> i1_slice_alpha_c0_offset = 0 ; ps_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; ret = ih264d_parse_islice_data_cabac ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; SWITCHONTRACE ; SWITCHOFFTRACECABAC ; } else { if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; ret = ih264d_parse_islice_data_cavlc ( ps_dec , ps_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; } return OK ; }
CWE-20 static int netbk_set_skb_gso ( struct xenvif * vif , struct sk_buff * skb , struct xen_netif_extra_info * gso ) { if ( ! gso -> u . gso . size ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , "GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n" ) ; <S2SV_EndBug> return - EINVAL ; } if ( gso -> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , "Bad<S2SV_blank>GSO<S2SV_blank>type<S2SV_blank>%d.\\n" , gso -> u . gso . type ) ; <S2SV_EndBug> return - EINVAL ; } skb_shinfo ( skb ) -> gso_size = gso -> u . gso . size ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_TCPV4 ; skb_shinfo ( skb ) -> gso_type |= SKB_GSO_DODGY ; skb_shinfo ( skb ) -> gso_segs = 0 ; return 0 ; }
CWE-399 static int misaligned_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } switch ( width_shift ) { case 1 : * ( __u16 * ) & buffer = ( __u16 ) regs -> regs [ srcreg ] ; break ; case 2 : * ( __u32 * ) & buffer = ( __u32 ) regs -> regs [ srcreg ] ; break ; case 3 : buffer = regs -> regs [ srcreg ] ; break ; default : printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_store,<S2SV_blank>PC=%08lx\\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } } else { __u64 val = regs -> regs [ srcreg ] ; switch ( width_shift ) { case 1 : misaligned_kernel_word_store ( address , val ) ; break ; case 2 : asm ( "stlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0" : : "r" ( val ) , "r" ( address ) ) ; asm ( "sthi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0" : : "r" ( val ) , "r" ( address ) ) ; break ; case 3 : asm ( "stlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0" : : "r" ( val ) , "r" ( address ) ) ; asm ( "sthi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0" : : "r" ( val ) , "r" ( address ) ) ; break ; default : printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_store,<S2SV_blank>PC=%08lx\\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }
CWE-125 static int dhcpv6_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint16_t type , optlen ; i = 0 ; while ( i < length ) { <S2SV_StartBug> tlv = cp + i ; <S2SV_EndBug> type = EXTRACT_16BITS ( tlv ) ; optlen = EXTRACT_16BITS ( tlv + 2 ) ; value = tlv + 4 ; ND_PRINT ( ( ndo , "\\n" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , "\\t" ) ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( dh6opt_str , "Unknown" , type ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>(%u)" , optlen + 4 ) ) ; <S2SV_EndBug> switch ( type ) { case DH6OPT_DNS_SERVERS : case DH6OPT_SNTP_SERVERS : { if ( optlen % 16 != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>%s" , istr ) ) ; return - 1 ; } for ( t = 0 ; t < optlen ; t += 16 ) ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , value + t ) ) ) ; } break ; case DH6OPT_DOMAIN_LIST : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return - 1 ; } } break ; } i += 4 + optlen ; } return 0 ; }
CWE-000 static krb5_error_code krb5_ldap_get_password_policy_from_dn ( krb5_context context , char * pol_name , char * pol_dn , osa_policy_ent_t * policy ) { krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; krb5_clear_error_message ( context ) ; if ( pol_dn == NULL ) return EINVAL ; * policy = NULL ; SETUP_CONTEXT ( ) ; GET_HANDLE ( ) ; * ( policy ) = ( osa_policy_ent_t ) malloc ( sizeof ( osa_policy_ent_rec ) ) ; if ( * policy == NULL ) { st = ENOMEM ; goto cleanup ; } memset ( * policy , 0 , sizeof ( osa_policy_ent_rec ) ) ; LDAP_SEARCH ( pol_dn , LDAP_SCOPE_BASE , "(objectclass=krbPwdPolicy)" , password_policy_attributes ) ; ent = ldap_first_entry ( ld , result ) ; <S2SV_StartBug> if ( ent != NULL ) { <S2SV_EndBug> if ( ( st = populate_policy ( context , ld , ent , pol_name , * policy ) ) != 0 ) goto cleanup ; } <S2SV_StartBug> cleanup : <S2SV_EndBug> ldap_msgfree ( result ) ; if ( st != 0 ) { if ( * policy != NULL ) { krb5_ldap_free_password_policy ( context , * policy ) ; * policy = NULL ; } } krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return st ; }
CWE-119 GPLOT * gplotRead ( const char * filename ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * rootname , * title , * xlabel , * ylabel , * ignores ; l_int32 outformat , ret , version , ignore ; FILE * fp ; GPLOT * gplot ; PROCNAME ( "gplotRead" ) ; if ( ! filename ) return ( GPLOT * ) ERROR_PTR ( "filename<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( ( fp = fopenReadStream ( filename ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( "stream<S2SV_blank>not<S2SV_blank>opened" , procName , NULL ) ; ret = fscanf ( fp , "Gplot<S2SV_blank>Version<S2SV_blank>%d\\n" , & version ) ; if ( ret != 1 ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>gplot<S2SV_blank>file" , procName , NULL ) ; } if ( version != GPLOT_VERSION_NUMBER ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "invalid<S2SV_blank>gplot<S2SV_blank>version" , procName , NULL ) ; } <S2SV_StartBug> ignore = fscanf ( fp , "Rootname:<S2SV_blank>%s\\n" , buf ) ; <S2SV_EndBug> rootname = stringNew ( buf ) ; ignore = fscanf ( fp , "Output<S2SV_blank>format:<S2SV_blank>%d\\n" , & outformat ) ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> title = stringNew ( buf + 7 ) ; title [ strlen ( title ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> xlabel = stringNew ( buf + 14 ) ; xlabel [ strlen ( xlabel ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> ylabel = stringNew ( buf + 14 ) ; ylabel [ strlen ( ylabel ) - 1 ] = '\\0' ; gplot = gplotCreate ( rootname , outformat , title , xlabel , ylabel ) ; LEPT_FREE ( rootname ) ; LEPT_FREE ( title ) ; LEPT_FREE ( xlabel ) ; LEPT_FREE ( ylabel ) ; if ( ! gplot ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( "gplot<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; } sarrayDestroy ( & gplot -> cmddata ) ; sarrayDestroy ( & gplot -> datanames ) ; sarrayDestroy ( & gplot -> plotdata ) ; sarrayDestroy ( & gplot -> plottitles ) ; numaDestroy ( & gplot -> plotstyles ) ; <S2SV_StartBug> ignore = fscanf ( fp , "Commandfile<S2SV_blank>name:<S2SV_blank>%s\\n" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> cmdname , buf ) ; ignore = fscanf ( fp , "\\nCommandfile<S2SV_blank>data:" ) ; gplot -> cmddata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\\nDatafile<S2SV_blank>names:" ) ; gplot -> datanames = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\\nPlot<S2SV_blank>data:" ) ; gplot -> plotdata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\\nPlot<S2SV_blank>titles:" ) ; gplot -> plottitles = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , "\\nPlot<S2SV_blank>styles:" ) ; gplot -> plotstyles = numaReadStream ( fp ) ; ignore = fscanf ( fp , "Number<S2SV_blank>of<S2SV_blank>plots:<S2SV_blank>%d\\n" , & gplot -> nplots ) ; <S2SV_StartBug> ignore = fscanf ( fp , "Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\n" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> outname , buf ) ; ignore = fscanf ( fp , "Axis<S2SV_blank>scaling:<S2SV_blank>%d\\n" , & gplot -> scaling ) ; fclose ( fp ) ; return gplot ; }
CWE-000 int nfsd_mountpoint ( struct dentry * dentry , struct svc_export * exp ) { <S2SV_StartBug> if ( d_mountpoint ( dentry ) ) <S2SV_EndBug> return 1 ; if ( nfsd4_is_junction ( dentry ) ) return 1 ; <S2SV_StartBug> if ( ! ( exp -> ex_flags & NFSEXP_V4ROOT ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> return d_inode ( dentry ) != NULL ; <S2SV_EndBug> }
CWE-000 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { int vm_shared = dst_vma -> vm_flags & VM_SHARED ; struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; if ( vm_shared ) { struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; spin_lock ( ptl ) ; ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; <S2SV_StartBug> out_release_nounlock : <S2SV_EndBug> if ( vm_shared ) unlock_page ( page ) ; put_page ( page ) ; goto out ; }
CWE-000 static void sctp_v6_get_dst ( struct sctp_transport * t , union sctp_addr * saddr , struct flowi * fl , struct sock * sk ) { struct sctp_association * asoc = t -> asoc ; struct dst_entry * dst = NULL ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sctp_bind_addr * bp ; <S2SV_StartBug> struct sctp_sockaddr_entry * laddr ; <S2SV_EndBug> union sctp_addr * baddr = NULL ; union sctp_addr * daddr = & t -> ipaddr ; union sctp_addr dst_saddr ; <S2SV_StartBug> __u8 matchlen = 0 ; <S2SV_EndBug> __u8 bmatchlen ; sctp_scope_t scope ; memset ( fl6 , 0 , sizeof ( struct flowi6 ) ) ; fl6 -> daddr = daddr -> v6 . sin6_addr ; fl6 -> fl6_dport = daddr -> v6 . sin6_port ; fl6 -> flowi6_proto = IPPROTO_SCTP ; if ( ipv6_addr_type ( & daddr -> v6 . sin6_addr ) & IPV6_ADDR_LINKLOCAL ) fl6 -> flowi6_oif = daddr -> v6 . sin6_scope_id ; pr_debug ( "%s:<S2SV_blank>dst=%pI6<S2SV_blank>" , __func__ , & fl6 -> daddr ) ; if ( asoc ) fl6 -> fl6_sport = htons ( asoc -> base . bind_addr . port ) ; if ( saddr ) { fl6 -> saddr = saddr -> v6 . sin6_addr ; fl6 -> fl6_sport = saddr -> v6 . sin6_port ; pr_debug ( "src=%pI6<S2SV_blank>-<S2SV_blank>" , & fl6 -> saddr ) ; } <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> if ( ! asoc || saddr ) goto out ; bp = & asoc -> base . bind_addr ; scope = sctp_scope ( daddr ) ; if ( ! IS_ERR ( dst ) ) { sctp_v6_to_addr ( & dst_saddr , & fl6 -> saddr , htons ( bp -> port ) ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { if ( ! laddr -> valid || ( laddr -> state != SCTP_ADDR_SRC ) ) continue ; if ( ( laddr -> a . sa . sa_family == AF_INET6 ) && ( sctp_v6_cmp_addr ( & dst_saddr , & laddr -> a ) ) ) { rcu_read_unlock ( ) ; goto out ; } } rcu_read_unlock ( ) ; dst_release ( dst ) ; dst = NULL ; } rcu_read_lock ( ) ; list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { if ( ! laddr -> valid ) continue ; if ( ( laddr -> state == SCTP_ADDR_SRC ) && ( laddr -> a . sa . sa_family == AF_INET6 ) && ( scope <= sctp_scope ( & laddr -> a ) ) ) { bmatchlen = sctp_v6_addr_match_len ( daddr , & laddr -> a ) ; if ( ! baddr || ( matchlen < bmatchlen ) ) { baddr = & laddr -> a ; matchlen = bmatchlen ; } } } rcu_read_unlock ( ) ; if ( baddr ) { fl6 -> saddr = baddr -> v6 . sin6_addr ; fl6 -> fl6_sport = baddr -> v6 . sin6_port ; <S2SV_StartBug> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <S2SV_EndBug> } out : if ( ! IS_ERR_OR_NULL ( dst ) ) { struct rt6_info * rt ; rt = ( struct rt6_info * ) dst ; t -> dst = dst ; t -> dst_cookie = rt -> rt6i_node ? rt -> rt6i_node -> fn_sernum : 0 ; pr_debug ( "rt6_dst:%pI6<S2SV_blank>rt6_src:%pI6\\n" , & rt -> rt6i_dst . addr , & fl6 -> saddr ) ; } else { t -> dst = NULL ; pr_debug ( "no<S2SV_blank>route\\n" ) ; } }
CWE-20 int f2fs_trim_fs ( struct f2fs_sb_info * sbi , struct fstrim_range * range ) { __u64 start = F2FS_BYTES_TO_BLK ( range -> start ) ; __u64 end = start + F2FS_BYTES_TO_BLK ( range -> len ) - 1 ; unsigned int start_segno , end_segno ; struct cp_control cpc ; int err = 0 ; if ( start >= MAX_BLKADDR ( sbi ) || range -> len < sbi -> blocksize ) return - EINVAL ; cpc . trimmed = 0 ; if ( end <= MAIN_BLKADDR ( sbi ) ) goto out ; if ( is_sbi_flag_set ( sbi , SBI_NEED_FSCK ) ) { f2fs_msg ( sbi -> sb , KERN_WARNING , "Found<S2SV_blank>FS<S2SV_blank>corruption,<S2SV_blank>run<S2SV_blank>fsck<S2SV_blank>to<S2SV_blank>fix." ) ; goto out ; } start_segno = ( start <= MAIN_BLKADDR ( sbi ) ) ? 0 : GET_SEGNO ( sbi , start ) ; end_segno = ( end >= MAX_BLKADDR ( sbi ) ) ? MAIN_SEGS ( sbi ) - 1 : GET_SEGNO ( sbi , end ) ; cpc . reason = CP_DISCARD ; cpc . trim_minlen = max_t ( __u64 , 1 , F2FS_BYTES_TO_BLK ( range -> minlen ) ) ; for ( ; start_segno <= end_segno ; start_segno = cpc . trim_end + 1 ) { cpc . trim_start = start_segno ; if ( sbi -> discard_blks == 0 ) break ; else if ( sbi -> discard_blks < BATCHED_TRIM_BLOCKS ( sbi ) ) cpc . trim_end = end_segno ; else cpc . trim_end = min_t ( unsigned int , rounddown ( start_segno + BATCHED_TRIM_SEGMENTS ( sbi ) , sbi -> segs_per_sec ) - 1 , end_segno ) ; mutex_lock ( & sbi -> gc_mutex ) ; err = write_checkpoint ( sbi , & cpc ) ; mutex_unlock ( & sbi -> gc_mutex ) ; if ( err ) break ; schedule ( ) ; } mark_discard_range_all ( sbi ) ; <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; return err ; }
CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> int size_group ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . y_mode_prob [ size_group ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ; return y_mode ; }
CWE-284 static uint16_t transmit_data_on ( int fd , uint8_t * data , uint16_t length ) { assert ( data != NULL ) ; assert ( length > 0 ) ; uint16_t transmitted_length = 0 ; while ( length > 0 ) { <S2SV_StartBug> ssize_t ret = write ( fd , data + transmitted_length , length ) ; <S2SV_EndBug> switch ( ret ) { case - 1 : LOG_ERROR ( "In<S2SV_blank>%s,<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>the<S2SV_blank>serial<S2SV_blank>port<S2SV_blank>with<S2SV_blank>fd<S2SV_blank>%d:<S2SV_blank>%s" , __func__ , fd , strerror ( errno ) ) ; return transmitted_length ; case 0 : return transmitted_length ; default : transmitted_length += ret ; length -= ret ; break ; } } return transmitted_length ; }
CWE-476 jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; if ( optstr ) { jas_eprintf ( "warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n" ) ; } jas_eprintf ( "THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n" "THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n" "IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n" "TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>header\\n" ) ; return 0 ; } <S2SV_StartBug> if ( ! ( info = bmp_getinfo ( in ) ) ) { <S2SV_EndBug> jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>info\\n" ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( "error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n" ) ; bmp_info_destroy ( info ) ; return 0 ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( "error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n" ) ; return 0 ; } if ( n > 0 ) { jas_eprintf ( "skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n" ) ; if ( bmp_gobble ( in , n ) ) { bmp_info_destroy ( info ) ; return 0 ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { bmp_info_destroy ( info ) ; return 0 ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { bmp_info_destroy ( info ) ; jas_image_destroy ( image ) ; return 0 ; } bmp_info_destroy ( info ) ; return image ; }
CWE-119 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }
CWE-200 static int open_url ( AVFormatContext * s , AVIOContext * * pb , const char * url , AVDictionary * opts , AVDictionary * opts2 , int * is_http ) { HLSContext * c = s -> priv_data ; AVDictionary * tmp = NULL ; const char * proto_name = NULL ; int ret ; av_dict_copy ( & tmp , opts , 0 ) ; av_dict_copy ( & tmp , opts2 , 0 ) ; if ( av_strstart ( url , "crypto" , NULL ) ) { if ( url [ 6 ] == '+' || url [ 6 ] == ':' ) proto_name = avio_find_protocol_name ( url + 7 ) ; } if ( ! proto_name ) proto_name = avio_find_protocol_name ( url ) ; if ( ! proto_name ) return AVERROR_INVALIDDATA ; <S2SV_StartBug> if ( ! av_strstart ( proto_name , "http" , NULL ) && ! av_strstart ( proto_name , "file" , NULL ) ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; if ( ! strncmp ( proto_name , url , strlen ( proto_name ) ) && url [ strlen ( proto_name ) ] == ':' ) ; else if ( av_strstart ( url , "crypto" , NULL ) && ! strncmp ( proto_name , url + 7 , strlen ( proto_name ) ) && url [ 7 + strlen ( proto_name ) ] == ':' ) ; else if ( strcmp ( proto_name , "file" ) || ! strncmp ( url , "file," , 5 ) ) return AVERROR_INVALIDDATA ; ret = s -> io_open ( s , pb , url , AVIO_FLAG_READ , & tmp ) ; if ( ret >= 0 ) { char * new_cookies = NULL ; if ( ! ( s -> flags & AVFMT_FLAG_CUSTOM_IO ) ) av_opt_get ( * pb , "cookies" , AV_OPT_SEARCH_CHILDREN , ( uint8_t * * ) & new_cookies ) ; if ( new_cookies ) { av_free ( c -> cookies ) ; c -> cookies = new_cookies ; } av_dict_set ( & opts , "cookies" , c -> cookies , 0 ) ; } av_dict_free ( & tmp ) ; if ( is_http ) * is_http = av_strstart ( proto_name , "http" , NULL ) ; return ret ; }
CWE-20 static int xen_netbk_get_extras ( struct xenvif * vif , struct xen_netif_extra_info * extras , int work_to_do ) { struct xen_netif_extra_info extra ; RING_IDX cons = vif -> tx . req_cons ; do { if ( unlikely ( work_to_do -- <= 0 ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , "Missing<S2SV_blank>extra<S2SV_blank>info\\n" ) ; <S2SV_EndBug> return - EBADR ; } memcpy ( & extra , RING_GET_REQUEST ( & vif -> tx , cons ) , sizeof ( extra ) ) ; if ( unlikely ( ! extra . type || extra . type >= XEN_NETIF_EXTRA_TYPE_MAX ) ) { vif -> tx . req_cons = ++ cons ; <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> "Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n" , extra . type ) ; <S2SV_EndBug> return - EINVAL ; } memcpy ( & extras [ extra . type - 1 ] , & extra , sizeof ( extra ) ) ; vif -> tx . req_cons = ++ cons ; } while ( extra . flags & XEN_NETIF_EXTRA_FLAG_MORE ) ; return work_to_do ; }
CWE-000 void sas_deform_port ( struct asd_sas_phy * phy , int gone ) { struct sas_ha_struct * sas_ha = phy -> ha ; struct asd_sas_port * port = phy -> port ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; struct domain_device * dev ; unsigned long flags ; if ( ! port ) return ; dev = port -> port_dev ; if ( dev ) dev -> pathways -- ; if ( port -> num_phys == 1 ) { sas_unregister_domain_devices ( port , gone ) ; <S2SV_StartBug> sas_port_delete ( port -> port ) ; <S2SV_EndBug> port -> port = NULL ; } else { sas_port_delete_phy ( port -> port , phy -> phy ) ; sas_device_set_phy ( dev , port -> port ) ; } if ( si -> dft -> lldd_port_deformed ) si -> dft -> lldd_port_deformed ( phy ) ; spin_lock_irqsave ( & sas_ha -> phy_port_lock , flags ) ; spin_lock ( & port -> phy_list_lock ) ; list_del_init ( & phy -> port_phy_el ) ; sas_phy_set_target ( phy , NULL ) ; phy -> port = NULL ; port -> num_phys -- ; port -> phy_mask &= ~ ( 1U << phy -> id ) ; if ( port -> num_phys == 0 ) { INIT_LIST_HEAD ( & port -> phy_list ) ; memset ( port -> sas_addr , 0 , SAS_ADDR_SIZE ) ; memset ( port -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; port -> class = 0 ; port -> iproto = 0 ; port -> tproto = 0 ; port -> oob_mode = 0 ; port -> phy_mask = 0 ; } spin_unlock ( & port -> phy_list_lock ) ; spin_unlock_irqrestore ( & sas_ha -> phy_port_lock , flags ) ; return ; }
CWE-284 ssize_t socket_bytes_available ( const socket_t * socket ) { assert ( socket != NULL ) ; int size = 0 ; <S2SV_StartBug> if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 ) <S2SV_EndBug> return - 1 ; return size ; }
CWE-787 int main ( int argc , char * * argv ) { int i , n_valid , do_write , do_scrub ; char * c , * dname , * name ; DIR * dir ; FILE * fp ; pdf_t * pdf ; pdf_flag_t flags ; if ( argc < 2 ) usage ( ) ; do_write = do_scrub = flags = 0 ; name = NULL ; for ( i = 1 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , "-w" , 2 ) == 0 ) do_write = 1 ; else if ( strncmp ( argv [ i ] , "-i" , 2 ) == 0 ) flags |= PDF_FLAG_DISP_CREATOR ; else if ( strncmp ( argv [ i ] , "-q" , 2 ) == 0 ) flags |= PDF_FLAG_QUIET ; else if ( strncmp ( argv [ i ] , "-s" , 2 ) == 0 ) do_scrub = 1 ; else if ( argv [ i ] [ 0 ] != '-' ) name = argv [ i ] ; else if ( argv [ i ] [ 0 ] == '-' ) usage ( ) ; } if ( ! name ) usage ( ) ; if ( ! ( fp = fopen ( name , "r" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , argv [ 1 ] ) ; return - 1 ; } else if ( ! pdf_is_pdf ( fp ) ) { ERR ( "\'%s\'<S2SV_blank>specified<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>PDF\\n" , name ) ; fclose ( fp ) ; return - 1 ; } if ( ! ( pdf = init_pdf ( fp , name ) ) ) { fclose ( fp ) ; return - 1 ; } for ( i = 0 , n_valid = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) ++ n_valid ; if ( n_valid < 2 ) { if ( ! ( flags & ( PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR ) ) ) printf ( "%s:<S2SV_blank>There<S2SV_blank>is<S2SV_blank>only<S2SV_blank>one<S2SV_blank>version<S2SV_blank>of<S2SV_blank>this<S2SV_blank>PDF\\n" , pdf -> name ) ; if ( do_write ) { fclose ( fp ) ; pdf_delete ( pdf ) ; return 0 ; } } dname = NULL ; if ( do_write ) { if ( ( c = strrchr ( name , '/' ) ) ) name = c + 1 ; if ( ( c = strrchr ( name , '.' ) ) ) * c = '\\0' ; <S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> sprintf ( dname , "%s-versions" , name ) ; if ( ! ( dir = opendir ( dname ) ) ) mkdir ( dname , S_IRWXU ) ; else { ERR ( "This<S2SV_blank>directory<S2SV_blank>already<S2SV_blank>exists,<S2SV_blank>PDF<S2SV_blank>version<S2SV_blank>extraction<S2SV_blank>will<S2SV_blank>" "not<S2SV_blank>occur.\\n" ) ; fclose ( fp ) ; closedir ( dir ) ; free ( dname ) ; pdf_delete ( pdf ) ; return - 1 ; } for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) write_version ( fp , name , dname , & pdf -> xrefs [ i ] ) ; } pdf_summarize ( fp , pdf , dname , flags ) ; if ( do_scrub ) scrub_document ( fp , pdf ) ; if ( flags & PDF_FLAG_DISP_CREATOR ) display_creator ( fp , pdf ) ; fclose ( fp ) ; free ( dname ) ; pdf_delete ( pdf ) ; return 0 ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_last_ref_updates ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctrl_id , va_list args ) { int * update_info = va_arg ( args , int * ) ; if ( update_info && ! ctx -> yv12_frame_buffers . use_frame_threads ) { VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; * update_info = pbi -> common . refresh_alt_ref_frame * ( int ) VP8_ALTR_FRAME + pbi -> common . refresh_golden_frame * ( int ) VP8_GOLD_FRAME + pbi -> common . refresh_last_frame * ( int ) VP8_LAST_FRAME ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-119 static void update_sharpness ( loop_filter_info_n * lfi , int sharpness_lvl ) { int lvl ; for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) { int block_inside_limit = lvl >> ( ( sharpness_lvl > 0 ) + ( sharpness_lvl > 4 ) ) ; if ( sharpness_lvl > 0 ) { if ( block_inside_limit > ( 9 - sharpness_lvl ) ) block_inside_limit = ( 9 - sharpness_lvl ) ; } if ( block_inside_limit < 1 ) block_inside_limit = 1 ; <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , <S2SV_EndBug> SIMD_WIDTH ) ; } }
CWE-000 static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }
CWE-119 vpx_codec_err_t vpx_codec_control_ ( vpx_codec_ctx_t * ctx , int ctrl_id , ... ) { vpx_codec_err_t res ; if ( ! ctx || ! ctrl_id ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv || ! ctx -> iface -> ctrl_maps ) res = VPX_CODEC_ERROR ; else { vpx_codec_ctrl_fn_map_t * entry ; res = VPX_CODEC_ERROR ; for ( entry = ctx -> iface -> ctrl_maps ; entry && entry -> fn ; entry ++ ) { if ( ! entry -> ctrl_id || entry -> ctrl_id == ctrl_id ) { va_list ap ; va_start ( ap , ctrl_id ) ; <S2SV_StartBug> res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ; <S2SV_EndBug> va_end ( ap ) ; break ; } } } return SAVE_STATUS ( ctx , res ) ; }
CWE-772 static Image * ReadSCREENSHOTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = ( Image * ) NULL ; # if defined ( MAGICKCORE_WINGDI32_DELEGATE ) { BITMAPINFO bmi ; DISPLAY_DEVICE device ; HBITMAP bitmap , bitmapOld ; HDC bitmapDC , hDC ; Image * screen ; int i ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; RGBTRIPLE * p ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; i = 0 ; device . cb = sizeof ( device ) ; image = ( Image * ) NULL ; while ( EnumDisplayDevices ( NULL , i , & device , 0 ) && ++ i ) { if ( ( device . StateFlags & DISPLAY_DEVICE_ACTIVE ) != DISPLAY_DEVICE_ACTIVE ) continue ; hDC = CreateDC ( device . DeviceName , device . DeviceName , NULL , NULL ) ; if ( hDC == ( HDC ) NULL ) ThrowReaderException ( CoderError , "UnableToCreateDC" ) ; screen = AcquireImage ( image_info ) ; screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; screen -> storage_class = DirectClass ; <S2SV_StartBug> status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; <S2SV_EndBug> if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } <S2SV_StartBug> if ( image == ( Image * ) NULL ) <S2SV_EndBug> image = screen ; else AppendImageToList ( & image , screen ) ; bitmapDC = CreateCompatibleDC ( hDC ) ; if ( bitmapDC == ( HDC ) NULL ) { DeleteDC ( hDC ) ; ThrowReaderException ( CoderError , "UnableToCreateDC" ) ; } ( void ) ResetMagickMemory ( & bmi , 0 , sizeof ( BITMAPINFO ) ) ; bmi . bmiHeader . biSize = sizeof ( BITMAPINFOHEADER ) ; bmi . bmiHeader . biWidth = ( LONG ) screen -> columns ; bmi . bmiHeader . biHeight = ( - 1 ) * ( LONG ) screen -> rows ; bmi . bmiHeader . biPlanes = 1 ; bmi . bmiHeader . biBitCount = 24 ; bmi . bmiHeader . biCompression = BI_RGB ; bitmap = CreateDIBSection ( hDC , & bmi , DIB_RGB_COLORS , ( void * * ) & p , NULL , 0 ) ; if ( bitmap == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; ThrowReaderException ( CoderError , "UnableToCreateBitmap" ) ; } bitmapOld = ( HBITMAP ) SelectObject ( bitmapDC , bitmap ) ; if ( bitmapOld == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; ThrowReaderException ( CoderError , "UnableToCreateBitmap" ) ; } BitBlt ( bitmapDC , 0 , 0 , ( int ) screen -> columns , ( int ) screen -> rows , hDC , 0 , 0 , SRCCOPY ) ; ( void ) SelectObject ( bitmapDC , bitmapOld ) ; for ( y = 0 ; y < ( ssize_t ) screen -> rows ; y ++ ) { q = QueueAuthenticPixels ( screen , 0 , y , screen -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) screen -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( p -> rgbtRed ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( p -> rgbtGreen ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( p -> rgbtBlue ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( screen , exception ) == MagickFalse ) break ; } DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; } } # elif defined ( MAGICKCORE_X11_DELEGATE ) { const char * option ; XImportInfo ximage_info ; ( void ) exception ; XGetImportInfo ( & ximage_info ) ; option = GetImageOption ( image_info , "x:screen" ) ; if ( option != ( const char * ) NULL ) ximage_info . screen = IsMagickTrue ( option ) ; option = GetImageOption ( image_info , "x:silent" ) ; if ( option != ( const char * ) NULL ) ximage_info . silent = IsMagickTrue ( option ) ; image = XImportImage ( image_info , & ximage_info ) ; } # endif return ( image ) ; }
CWE-000 static int snd_compr_allocate_buffer ( struct snd_compr_stream * stream , struct snd_compr_params * params ) { unsigned int buffer_size ; <S2SV_StartBug> void * buffer ; <S2SV_EndBug> buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ; if ( stream -> ops -> copy ) { buffer = NULL ; } else { buffer = kmalloc ( buffer_size , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM ; } stream -> runtime -> fragment_size = params -> buffer . fragment_size ; stream -> runtime -> fragments = params -> buffer . fragments ; stream -> runtime -> buffer = buffer ; stream -> runtime -> buffer_size = buffer_size ; return 0 ; }
CWE-476 jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; <S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> len = len ; JAS_DBGLOG ( 10 , ( <S2SV_StartBug> "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n" , <S2SV_EndBug> \'"\' , boxinfo -> name , \'"\' , box -> type , box -> len ) ) ; <S2SV_StartBug> if ( box -> len == 1 ) { <S2SV_EndBug> if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( "warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ; goto error ; } jas_stream_rewind ( tmpstream ) ; box -> ops = & boxinfo -> ops ; if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( "cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }
CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = "" ; const char * link_section_name = "" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( ( int ) shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , "section_name" , section_name , 0 ) ; sdb_num_set ( sdb , "entries" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; <S2SV_StartBug> char key [ 32 ] = { 0 } ; <S2SV_EndBug> Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 || vstart + vdaux < vstart ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> vstart += vdaux ; <S2SV_EndBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , "idx" , i , 0 ) ; sdb_num_set ( sdb_verdef , "vd_version" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , "vd_ndx" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , "vd_cnt" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , "flags" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , "idx" , isum , 0 ) ; sdb_num_set ( sdb_parent , "parent" , j , 0 ) ; sdb_set ( sdb_parent , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , "parent%d" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , "verdef%d" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
CWE-190 static int on_http_message_complete ( http_parser * parser ) { struct clt_info * info = parser -> data ; ws_svr * svr = ws_svr_from_ses ( info -> ses ) ; info -> request -> version_major = parser -> http_major ; info -> request -> version_minor = parser -> http_minor ; info -> request -> method = parser -> method ; dict_entry * entry ; dict_iterator * iter = dict_get_iterator ( info -> request -> headers ) ; while ( ( entry = dict_next ( iter ) ) != NULL ) { log_trace ( "Header:<S2SV_blank>%s:<S2SV_blank>%s" , ( char * ) entry -> key , ( char * ) entry -> val ) ; } dict_release_iterator ( iter ) ; if ( info -> request -> method != HTTP_GET ) goto error ; if ( http_request_get_header ( info -> request , "Host" ) == NULL ) goto error ; double version = info -> request -> version_major + info -> request -> version_minor * 0.1 ; if ( version < 1.1 ) goto error ; const char * upgrade = http_request_get_header ( info -> request , "Upgrade" ) ; if ( upgrade == NULL || strcasecmp ( upgrade , "websocket" ) != 0 ) goto error ; const char * connection = http_request_get_header ( info -> request , "Connection" ) ; <S2SV_StartBug> if ( connection == NULL ) <S2SV_EndBug> goto error ; else { bool found_upgrade = false ; int count ; sds * tokens = sdssplitlen ( connection , strlen ( connection ) , "," , 1 , & count ) ; if ( tokens == NULL ) goto error ; for ( int i = 0 ; i < count ; i ++ ) { sds token = tokens [ i ] ; sdstrim ( token , "<S2SV_blank>" ) ; if ( strcasecmp ( token , "Upgrade" ) == 0 ) { found_upgrade = true ; break ; } } sdsfreesplitres ( tokens , count ) ; if ( ! found_upgrade ) goto error ; } const char * ws_version = http_request_get_header ( info -> request , "Sec-WebSocket-Version" ) ; if ( ws_version == NULL || strcmp ( ws_version , "13" ) != 0 ) goto error ; const char * ws_key = http_request_get_header ( info -> request , "Sec-WebSocket-Key" ) ; if ( ws_key == NULL ) goto error ; const char * protocol_list = http_request_get_header ( info -> request , "Sec-WebSocket-Protocol" ) ; if ( protocol_list && ! is_good_protocol ( protocol_list , svr -> protocol ) ) goto error ; if ( strlen ( svr -> origin ) > 0 ) { const char * origin = http_request_get_header ( info -> request , "Origin" ) ; if ( origin == NULL || ! is_good_origin ( origin , svr -> origin ) ) goto error ; } if ( svr -> type . on_privdata_alloc ) { info -> privdata = svr -> type . on_privdata_alloc ( svr ) ; if ( info -> privdata == NULL ) goto error ; } info -> upgrade = true ; info -> remote = sdsnew ( http_get_remote_ip ( info -> ses , info -> request ) ) ; info -> url = sdsnew ( info -> request -> url ) ; if ( svr -> type . on_upgrade ) { svr -> type . on_upgrade ( info -> ses , info -> remote ) ; } if ( protocol_list ) { send_hand_shake_reply ( info -> ses , svr -> protocol , ws_key ) ; } else { send_hand_shake_reply ( info -> ses , NULL , ws_key ) ; } return 0 ; error : ws_svr_close_clt ( ws_svr_from_ses ( info -> ses ) , info -> ses ) ; return - 1 ; }
CWE-264 static void * arm_coherent_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , true , __builtin_return_address ( 0 ) ) ; }
CWE-264 int copy_thread ( unsigned long clone_flags , unsigned long stack_start , unsigned long stk_sz , struct task_struct * p ) { struct thread_info * thread = task_thread_info ( p ) ; struct pt_regs * childregs = task_pt_regs ( p ) ; memset ( & thread -> cpu_context , 0 , sizeof ( struct cpu_context_save ) ) ; if ( likely ( ! ( p -> flags & PF_KTHREAD ) ) ) { * childregs = * current_pt_regs ( ) ; childregs -> ARM_r0 = 0 ; if ( stack_start ) childregs -> ARM_sp = stack_start ; } else { memset ( childregs , 0 , sizeof ( struct pt_regs ) ) ; thread -> cpu_context . r4 = stk_sz ; thread -> cpu_context . r5 = stack_start ; childregs -> ARM_cpsr = SVC_MODE ; } thread -> cpu_context . pc = ( unsigned long ) ret_from_fork ; thread -> cpu_context . sp = ( unsigned long ) childregs ; clear_ptrace_hw_breakpoint ( p ) ; if ( clone_flags & CLONE_SETTLS ) <S2SV_StartBug> thread -> tp_value = childregs -> ARM_r3 ; <S2SV_EndBug> thread_notify ( THREAD_NOTIFY_COPY , thread ) ; return 0 ; }
CWE-200 static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }
CWE-264 static int em_call ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> long rel = ctxt -> src . val ; ctxt -> src . val = ( unsigned long ) ctxt -> _eip ; <S2SV_StartBug> jmp_rel ( ctxt , rel ) ; <S2SV_EndBug> return em_push ( ctxt ) ; }
CWE-399 static struct sk_buff * batadv_frag_merge_packets ( struct hlist_head * chain , struct sk_buff * skb ) { struct batadv_frag_packet * packet ; struct batadv_frag_list_entry * entry ; struct sk_buff * skb_out = NULL ; int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; packet = ( struct batadv_frag_packet * ) skb -> data ; size = ntohs ( packet -> total_size ) ; if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry -> list ) ; skb_out = entry -> skb ; kfree ( entry ) ; <S2SV_StartBug> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <S2SV_EndBug> kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ; skb_reset_transport_header ( skb_out ) ; hlist_for_each_entry ( entry , chain , list ) { size = entry -> skb -> len - hdr_size ; memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ) ; } free : batadv_frag_clear_chain ( chain ) ; return skb_out ; }
CWE-119 static vpx_codec_err_t vp8_destroy ( vpx_codec_alg_priv_t * ctx ) { <S2SV_StartBug> int i ; <S2SV_EndBug> vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ; <S2SV_StartBug> for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ; i >= 0 ; i -- ) <S2SV_EndBug> { if ( ctx -> mmaps [ i ] . dtor ) ctx -> mmaps [ i ] . dtor ( & ctx -> mmaps [ i ] ) ; } return VPX_CODEC_OK ; }
CWE-000 void lxc_execute_bind_init ( struct lxc_conf * conf ) { int ret ; char path [ PATH_MAX ] , destpath [ PATH_MAX ] , * p ; p = choose_init ( conf -> rootfs . mount ) ; if ( p ) { free ( p ) ; return ; } ret = snprintf ( path , PATH_MAX , SBINDIR "/init.lxc.static" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( "Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>lxc.init.static" ) ; return ; } if ( ! file_exists ( path ) ) { INFO ( "%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>on<S2SV_blank>host" , path ) ; return ; } ret = snprintf ( destpath , PATH_MAX , "%s%s" , conf -> rootfs . mount , "/init.lxc.static" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( "Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>container\'s<S2SV_blank>lxc.init.static" ) ; return ; } if ( ! file_exists ( destpath ) ) { FILE * pathfile = fopen ( destpath , "wb" ) ; if ( ! pathfile ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\'%s\'" , destpath ) ; return ; } fclose ( pathfile ) ; } <S2SV_StartBug> ret = mount ( path , destpath , "none" , MS_BIND , NULL ) ; <S2SV_EndBug> if ( ret < 0 ) SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container" ) ; INFO ( "lxc.init.static<S2SV_blank>bound<S2SV_blank>into<S2SV_blank>container<S2SV_blank>at<S2SV_blank>%s" , path ) ; }
CWE-119 static void yv12_extend_frame_top_c ( YV12_BUFFER_CONFIG * ybf ) { int i ; unsigned char * src_ptr1 ; unsigned char * dest_ptr1 ; unsigned int Border ; int plane_stride ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; src_ptr1 = ybf -> y_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) Border ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> dest_ptr1 += plane_stride ; } plane_stride = ybf -> uv_stride ; Border /= 2 ; src_ptr1 = ybf -> u_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> dest_ptr1 += plane_stride ; } src_ptr1 = ybf -> v_buffer - Border ; dest_ptr1 = src_ptr1 - ( Border * plane_stride ) ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr1 , src_ptr1 , plane_stride ) ; <S2SV_EndBug> dest_ptr1 += plane_stride ; } }
CWE-20 static void activate_desktop_file ( ActivateParameters * parameters , NautilusFile * file ) { ActivateParametersDesktop * parameters_desktop ; char * primary , * secondary , * display_name ; GtkWidget * dialog ; GdkScreen * screen ; char * uri ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; if ( ! nautilus_file_is_trusted_link ( file ) ) { parameters_desktop = g_new0 ( ActivateParametersDesktop , 1 ) ; if ( parameters -> parent_window ) { parameters_desktop -> parent_window = parameters -> parent_window ; g_object_add_weak_pointer ( G_OBJECT ( parameters_desktop -> parent_window ) , ( gpointer * ) & parameters_desktop -> parent_window ) ; } parameters_desktop -> file = nautilus_file_ref ( file ) ; primary = _ ( "Untrusted<S2SV_blank>application<S2SV_blank>launcher" ) ; display_name = nautilus_file_get_display_name ( file ) ; secondary = g_strdup_printf ( _ ( "The<S2SV_blank>application<S2SV_blank>launcher<S2SV_blank>“%s”<S2SV_blank>has<S2SV_blank>not<S2SV_blank>been<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>trusted.<S2SV_blank>" "If<S2SV_blank>you<S2SV_blank>do<S2SV_blank>not<S2SV_blank>know<S2SV_blank>the<S2SV_blank>source<S2SV_blank>of<S2SV_blank>this<S2SV_blank>file,<S2SV_blank>launching<S2SV_blank>it<S2SV_blank>may<S2SV_blank>be<S2SV_blank>unsafe." ) , display_name ) ; dialog = gtk_message_dialog_new ( parameters -> parent_window , 0 , GTK_MESSAGE_WARNING , GTK_BUTTONS_NONE , NULL ) ; g_object_set ( dialog , "text" , primary , "secondary-text" , secondary , NULL ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_StartBug> _ ( "_Launch<S2SV_blank>Anyway" ) , RESPONSE_RUN ) ; <S2SV_EndBug> if ( nautilus_file_can_set_permissions ( file ) ) { gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_StartBug> _ ( "Mark<S2SV_blank>as<S2SV_blank>_Trusted" ) , RESPONSE_MARK_TRUSTED ) ; <S2SV_EndBug> } <S2SV_StartBug> gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , <S2SV_EndBug> _ ( "_Cancel" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ; g_signal_connect ( dialog , "response" , G_CALLBACK ( untrusted_launcher_response_callback ) , parameters_desktop ) ; gtk_widget_show ( dialog ) ; g_free ( display_name ) ; g_free ( secondary ) ; return ; } uri = nautilus_file_get_uri ( file ) ; DEBUG ( "Launching<S2SV_blank>trusted<S2SV_blank>launcher<S2SV_blank>%s" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; }
CWE-000 <S2SV_StartBug> int udf_get_filename ( struct super_block * sb , uint8_t * sname , uint8_t * dname , <S2SV_EndBug> <S2SV_StartBug> int flen ) <S2SV_EndBug> { struct ustr * filename , * unifilename ; int len = 0 ; filename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! filename ) return 0 ; unifilename = kmalloc ( sizeof ( struct ustr ) , GFP_NOFS ) ; if ( ! unifilename ) goto out1 ; <S2SV_StartBug> if ( udf_build_ustr_exact ( unifilename , sname , flen ) ) <S2SV_EndBug> goto out2 ; if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_UTF8 ) ) { if ( ! udf_CS0toUTF8 ( filename , unifilename ) ) { udf_debug ( "Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\n" , sname ) ; goto out2 ; } } else if ( UDF_QUERY_FLAG ( sb , UDF_FLAG_NLS_MAP ) ) { if ( ! udf_CS0toNLS ( UDF_SB ( sb ) -> s_nls_map , filename , unifilename ) ) { udf_debug ( "Failed<S2SV_blank>in<S2SV_blank>udf_get_filename:<S2SV_blank>sname<S2SV_blank>=<S2SV_blank>%s\\n" , sname ) ; goto out2 ; } } else goto out2 ; <S2SV_StartBug> len = udf_translate_to_linux ( dname , filename -> u_name , filename -> u_len , <S2SV_EndBug> unifilename -> u_name , unifilename -> u_len ) ; out2 : kfree ( unifilename ) ; out1 : kfree ( filename ) ; return len ; }
CWE-20 int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; <S2SV_StartBug> int n , len ; <S2SV_EndBug> skb -> sk = NULL ; <S2SV_StartBug> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <S2SV_EndBug> len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; <S2SV_StartBug> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <S2SV_EndBug> rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis ; n ++ ) make_rose -> dest_digis [ n ] = facilities . dest_digis [ n ] ; make_rose -> source_addr = facilities . source_addr ; make_rose -> source_call = facilities . source_call ; make_rose -> source_ndigis = facilities . source_ndigis ; for ( n = 0 ; n < facilities . source_ndigis ; n ++ ) make_rose -> source_digis [ n ] = facilities . source_digis [ n ] ; make_rose -> neighbour = neigh ; make_rose -> device = dev ; make_rose -> facilities = facilities ; make_rose -> neighbour -> use ++ ; if ( rose_sk ( sk ) -> defer ) { make_rose -> state = ROSE_STATE_5 ; } else { rose_write_internal ( make , ROSE_CALL_ACCEPTED ) ; make_rose -> state = ROSE_STATE_3 ; rose_start_idletimer ( make ) ; } make_rose -> condition = 0x00 ; make_rose -> vs = 0 ; make_rose -> va = 0 ; make_rose -> vr = 0 ; make_rose -> vl = 0 ; sk -> sk_ack_backlog ++ ; rose_insert_socket ( make ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; rose_start_heartbeat ( make ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk , skb -> len ) ; return 1 ; }
CWE-416 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }
CWE-20 static MagickBooleanType ReadDXT5 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; ssize_t j , y ; MagickSizeType alpha_bits ; PixelPacket * q ; register ssize_t i , x ; unsigned char a0 , a1 ; size_t alpha , bits , code , alpha_code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; a0 = ( unsigned char ) ReadBlobByte ( image ) ; a1 = ( unsigned char ) ReadBlobByte ( image ) ; alpha_bits = ( MagickSizeType ) ReadBlobLSBLong ( image ) ; alpha_bits = alpha_bits | ( ( MagickSizeType ) ReadBlobLSBShort ( image ) << 32 ) ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickTrue ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( bits >> ( ( 4 * j + i ) * 2 ) ) & 0x3 ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; alpha_code = ( size_t ) ( alpha_bits >> ( 3 * ( 4 * j + i ) ) ) & 0x7 ; if ( alpha_code == 0 ) alpha = a0 ; else if ( alpha_code == 1 ) alpha = a1 ; else if ( a0 > a1 ) alpha = ( ( 8 - alpha_code ) * a0 + ( alpha_code - 1 ) * a1 ) / 7 ; else if ( alpha_code == 6 ) alpha = 0 ; else if ( alpha_code == 7 ) alpha = 255 ; else alpha = ( ( ( 6 - alpha_code ) * a0 + ( alpha_code - 1 ) * a1 ) / 5 ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) alpha ) ) ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug> return MagickTrue ; }
CWE-200 long vorbis_book_decodev_add ( codebook * book , ogg_int32_t * a , oggpack_buffer * b , int n , int point ) { if ( book -> used_entries > 0 ) { ogg_int32_t * v = book -> dec_buf ; int i , j ; if ( ! v ) return - 1 ; for ( i = 0 ; i < n ; ) { if ( decode_map ( book , b , v , point ) ) return - 1 ; <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> a [ i ++ ] += v [ j ] ; } } return 0 ; }
CWE-000 void acpi_ns_terminate ( void ) { acpi_status status ; <S2SV_StartBug> ACPI_FUNCTION_TRACE ( ns_terminate ) ; <S2SV_EndBug> # ifdef ACPI_EXEC_APP { union acpi_operand_object * prev ; <S2SV_StartBug> union acpi_operand_object * next ; <S2SV_EndBug> next = acpi_gbl_module_code_list ; while ( next ) { prev = next ; next = next -> method . mutex ; prev -> method . mutex = NULL ; acpi_ut_remove_reference ( prev ) ; } <S2SV_StartBug> } <S2SV_EndBug> # endif acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ; status = acpi_ut_acquire_mutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( status ) ) { return_VOID ; } acpi_ns_delete_node ( acpi_gbl_root_node ) ; ( void ) acpi_ut_release_mutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , "Namespace<S2SV_blank>freed\\n" ) ) ; return_VOID ; }
CWE-119 LIBXSMM_API_INTERN void libxsmm_sparse_csr_reader ( libxsmm_generated_code * io_generated_code , const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , "r" ) ; if ( l_csr_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_ALLOC_DATA ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i <= * o_row_count ; ++ l_i ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_DESC ) ; fclose ( l_csr_file_handle ) ; return ; } } else { unsigned int l_row = 0 , l_column = 0 ; double l_value = 0 ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_ELEMS ) ; return ; } <S2SV_StartBug> l_row -- ; <S2SV_EndBug> l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_LEN ) ; return ; } if ( l_row_idx_id != NULL ) { for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } free ( l_row_idx_id ) ; } }
CWE-119 static void write_display_size ( const VP9_COMMON * cm , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> const int scaling_active = cm -> width != cm -> display_width || cm -> height != cm -> display_height ; <S2SV_StartBug> vp9_wb_write_bit ( wb , scaling_active ) ; <S2SV_EndBug> if ( scaling_active ) { <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> display_width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> display_height - 1 , 16 ) ; <S2SV_EndBug> } }
CWE-264 static int raw_cmd_copyin ( int cmd , void __user * param , struct floppy_raw_cmd * * rcmd ) { struct floppy_raw_cmd * ptr ; int ret ; int i ; * rcmd = NULL ; loop : ptr = kmalloc ( sizeof ( struct floppy_raw_cmd ) , GFP_USER ) ; if ( ! ptr ) return - ENOMEM ; * rcmd = ptr ; ret = copy_from_user ( ptr , param , sizeof ( * ptr ) ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ptr -> next = NULL ; ptr -> buffer_length = 0 ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ptr -> cmd_count > 33 ) return - EINVAL ; for ( i = 0 ; i < 16 ; i ++ ) ptr -> reply [ i ] = 0 ; ptr -> resultcode = 0 ; <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug> if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) { if ( ptr -> length <= 0 ) return - EINVAL ; ptr -> kernel_data = ( char * ) fd_dma_mem_alloc ( ptr -> length ) ; fallback_on_nodma_alloc ( & ptr -> kernel_data , ptr -> length ) ; if ( ! ptr -> kernel_data ) return - ENOMEM ; ptr -> buffer_length = ptr -> length ; } if ( ptr -> flags & FD_RAW_WRITE ) { ret = fd_copyin ( ptr -> data , ptr -> kernel_data , ptr -> length ) ; if ( ret ) return ret ; } if ( ptr -> flags & FD_RAW_MORE ) { rcmd = & ( ptr -> next ) ; ptr -> rate &= 0x43 ; goto loop ; } return 0 ; }
CWE-20 static void ikev2_parent_inI2outR2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( "ikev2<S2SV_blank>parent<S2SV_blank>inI2outR2:<S2SV_blank>calculating<S2SV_blank>g^{xy},<S2SV_blank>sending<S2SV_blank>R2" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , "%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI2outR2_tail ( pcrc , r ) ; if ( e > STF_FAIL ) { int v2_notify_num = e - STF_FAIL ; DBG_log ( "ikev2_parent_inI2outR2_tail<S2SV_blank>returned<S2SV_blank>STF_FAIL<S2SV_blank>with<S2SV_blank>%s" , enum_name ( & ikev2_notify_names , v2_notify_num ) ) ; } else if ( e != STF_OK ) { DBG_log ( "ikev2_parent_inI2outR2_tail<S2SV_blank>returned<S2SV_blank>%s" , enum_name ( & stfstatus_name , e ) ) ; } if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
CWE-264 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( "%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> return 1 ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : return 0 ; case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }
CWE-200 static void llc_cmsg_rcv ( struct msghdr * msg , struct sk_buff * skb ) { struct llc_sock * llc = llc_sk ( skb -> sk ) ; if ( llc -> cmsg_flags & LLC_CMSG_PKTINFO ) { <S2SV_StartBug> struct llc_pktinfo info ; <S2SV_EndBug> info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ; llc_pdu_decode_dsap ( skb , & info . lpi_sap ) ; llc_pdu_decode_da ( skb , info . lpi_mac ) ; put_cmsg ( msg , SOL_LLC , LLC_OPT_PKTINFO , sizeof ( info ) , & info ) ; } }
CWE-119 const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) { <S2SV_StartBug> int number_of_frames , number_of_keyframes , encode_frame_count ; <S2SV_EndBug> int i , j ; uint32_t bytes_total = 0 ; double scale [ COMPONENTS ] ; double psnr [ COMPONENTS ] ; double mse [ COMPONENTS ] ; double y_scale ; <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || si == NULL ) return NULL ; svc_log_reset ( svc_ctx ) ; <S2SV_StartBug> encode_frame_count = si -> encode_frame_count ; <S2SV_EndBug> <S2SV_StartBug> if ( si -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; <S2SV_EndBug> svc_log ( svc_ctx , SVC_LOG_INFO , "\\n" ) ; <S2SV_StartBug> number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < si -> layers ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> number_of_frames = encode_frame_count ; <S2SV_EndBug> if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) { number_of_frames -= number_of_keyframes ; } svc_log ( svc_ctx , SVC_LOG_INFO , "Layer<S2SV_blank>%d<S2SV_blank>Average<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f],<S2SV_blank>Bytes=[%u]\\n" , i , ( double ) si -> psnr_sum [ i ] [ 0 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 1 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 2 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 3 ] / number_of_frames , si -> bytes_sum [ i ] ) ; y_scale = si -> width * si -> height * 255.0 * 255.0 * number_of_frames ; scale [ 1 ] = y_scale ; scale [ 2 ] = scale [ 3 ] = y_scale / 4 ; scale [ 0 ] = y_scale * 1.5 ; for ( j = 0 ; j < COMPONENTS ; j ++ ) { psnr [ j ] = calc_psnr ( si -> sse_sum [ i ] [ j ] / scale [ j ] ) ; mse [ j ] = si -> sse_sum [ i ] [ j ] * 255.0 * 255.0 / scale [ j ] ; } svc_log ( svc_ctx , SVC_LOG_INFO , "Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>PSNR=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n" , i , psnr [ 0 ] , psnr [ 1 ] , psnr [ 2 ] , psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_INFO , "Layer<S2SV_blank>%d<S2SV_blank>Overall<S2SV_blank>MSE=[%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f,<S2SV_blank>%2.3f]\\n" , i , mse [ 0 ] , mse [ 1 ] , mse [ 2 ] , mse [ 3 ] ) ; bytes_total += si -> bytes_sum [ i ] ; si -> bytes_sum [ i ] = 0 ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] = 0 ; si -> sse_sum [ i ] [ j ] = 0 ; } } <S2SV_StartBug> si -> encode_frame_count = 0 ; <S2SV_EndBug> svc_log ( svc_ctx , SVC_LOG_INFO , "Total<S2SV_blank>Bytes=[%u]\\n" , bytes_total ) ; return vpx_svc_get_message ( svc_ctx ) ; }
CWE-000 static int cdc_ncm_bind ( struct usbnet * dev , struct usb_interface * intf ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ; <S2SV_StartBug> ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> usbnet_link_change ( dev , 0 , 0 ) ; <S2SV_EndBug> return ret ; }
CWE-20 static int read_bytes ( FILE * fp , void * buf , size_t bytes_to_read , int fail_on_eof , char * errbuf ) { size_t amt_read ; amt_read = fread ( buf , 1 , bytes_to_read , fp ) ; if ( amt_read != bytes_to_read ) { if ( ferror ( fp ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; } else { if ( amt_read == 0 && ! fail_on_eof ) return ( 0 ) ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , <S2SV_StartBug> "truncated<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%" PRIsize "<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%" PRIsize , <S2SV_EndBug> bytes_to_read , amt_read ) ; } return ( - 1 ) ; } return ( 1 ) ; }
CWE-000 static int add_ballooned_pages ( int nr_pages ) { enum bp_state st ; if ( xen_hotplug_unpopulated ) { st = reserve_additional_memory ( ) ; if ( st != BP_ECANCELED ) { mutex_unlock ( & balloon_mutex ) ; wait_event ( balloon_wq , ! list_empty ( & ballooned_pages ) ) ; mutex_lock ( & balloon_mutex ) ; return 0 ; } } <S2SV_StartBug> st = decrease_reservation ( nr_pages , GFP_USER ) ; <S2SV_EndBug> if ( st != BP_DONE ) return - ENOMEM ; return 0 ; }
CWE-416 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; }
CWE-000 static Curves16Data * CurvesAlloc ( cmsContext ContextID , int nCurves , int nElements , cmsToneCurve * * G ) { int i , j ; Curves16Data * c16 ; c16 = _cmsMallocZero ( ContextID , sizeof ( Curves16Data ) ) ; if ( c16 == NULL ) return NULL ; c16 -> nCurves = nCurves ; c16 -> nElements = nElements ; c16 -> Curves = _cmsCalloc ( ContextID , nCurves , sizeof ( cmsUInt16Number * ) ) ; if ( c16 -> Curves == NULL ) return NULL ; for ( i = 0 ; i < nCurves ; i ++ ) { <S2SV_StartBug> c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; <S2SV_EndBug> if ( nElements == 256 ) { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , FROM_8_TO_16 ( j ) ) ; } } else { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , ( cmsUInt16Number ) j ) ; } } } return c16 ; }
CWE-20 static int cmd_handle_untagged ( struct ImapData * idata ) { unsigned int count = 0 ; char * s = imap_next_word ( idata -> buf ) ; char * pn = imap_next_word ( s ) ; if ( ( idata -> state >= IMAP_SELECTED ) && isdigit ( ( unsigned char ) * s ) ) { pn = s ; s = imap_next_word ( s ) ; if ( mutt_str_strncasecmp ( "EXISTS" , s , 6 ) == 0 ) { mutt_debug ( 2 , "Handling<S2SV_blank>EXISTS\\n" ) ; if ( mutt_str_atoui ( pn , & count ) < 0 ) { mutt_debug ( 1 , "Malformed<S2SV_blank>EXISTS:<S2SV_blank>\'%s\'\\n" , pn ) ; } if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) && count < idata -> max_msn ) { mutt_debug ( 1 , "Message<S2SV_blank>count<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>sync\\n" ) ; return 0 ; } else if ( count == idata -> max_msn ) mutt_debug ( 3 , "superfluous<S2SV_blank>EXISTS<S2SV_blank>message.\\n" ) ; else { if ( ! ( idata -> reopen & IMAP_EXPUNGE_PENDING ) ) { mutt_debug ( 2 , "New<S2SV_blank>mail<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>total.\\n" , idata -> mailbox , count ) ; idata -> reopen |= IMAP_NEWMAIL_PENDING ; } idata -> new_mail_count = count ; } } else if ( mutt_str_strncasecmp ( "EXPUNGE" , s , 7 ) == 0 ) cmd_parse_expunge ( idata , pn ) ; else if ( mutt_str_strncasecmp ( "FETCH" , s , 5 ) == 0 ) cmd_parse_fetch ( idata , pn ) ; } else if ( mutt_str_strncasecmp ( "CAPABILITY" , s , 10 ) == 0 ) cmd_parse_capability ( idata , s ) ; else if ( mutt_str_strncasecmp ( "OK<S2SV_blank>[CAPABILITY" , s , 14 ) == 0 ) cmd_parse_capability ( idata , pn ) ; else if ( mutt_str_strncasecmp ( "OK<S2SV_blank>[CAPABILITY" , pn , 14 ) == 0 ) cmd_parse_capability ( idata , imap_next_word ( pn ) ) ; else if ( mutt_str_strncasecmp ( "LIST" , s , 4 ) == 0 ) cmd_parse_list ( idata , s ) ; else if ( mutt_str_strncasecmp ( "LSUB" , s , 4 ) == 0 ) cmd_parse_lsub ( idata , s ) ; else if ( mutt_str_strncasecmp ( "MYRIGHTS" , s , 8 ) == 0 ) cmd_parse_myrights ( idata , s ) ; else if ( mutt_str_strncasecmp ( "SEARCH" , s , 6 ) == 0 ) cmd_parse_search ( idata , s ) ; else if ( mutt_str_strncasecmp ( "STATUS" , s , 6 ) == 0 ) cmd_parse_status ( idata , s ) ; else if ( mutt_str_strncasecmp ( "ENABLED" , s , 7 ) == 0 ) cmd_parse_enabled ( idata , s ) ; else if ( mutt_str_strncasecmp ( "BYE" , s , 3 ) == 0 ) { mutt_debug ( 2 , "Handling<S2SV_blank>BYE\\n" ) ; if ( idata -> status == IMAP_BYE ) return 0 ; s += 3 ; SKIPWS ( s ) ; mutt_error ( "%s" , s ) ; cmd_handle_fatal ( idata ) ; return - 1 ; } else if ( ImapServernoise && ( mutt_str_strncasecmp ( "NO" , s , 2 ) == 0 ) ) { mutt_debug ( 2 , "Handling<S2SV_blank>untagged<S2SV_blank>NO\\n" ) ; <S2SV_StartBug> mutt_error ( "%s" , s + 3 ) ; <S2SV_EndBug> } return 0 ; }
CWE-787 static void opj_j2k_set_cinema_parameters ( opj_cparameters_t * parameters , opj_image_t * image , opj_event_mgr_t * p_manager ) { int i ; parameters -> tile_size_on = OPJ_FALSE ; parameters -> cp_tdx = 1 ; parameters -> cp_tdy = 1 ; parameters -> tp_flag = 'C' ; parameters -> tp_on = 1 ; parameters -> cp_tx0 = 0 ; parameters -> cp_ty0 = 0 ; parameters -> image_offset_x0 = 0 ; parameters -> image_offset_y0 = 0 ; parameters -> cblockw_init = 32 ; parameters -> cblockh_init = 32 ; parameters -> mode = 0 ; parameters -> roi_compno = - 1 ; parameters -> subsampling_dx = 1 ; parameters -> subsampling_dy = 1 ; parameters -> irreversible = 1 ; if ( parameters -> tcp_numlayers > 1 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "1<S2SV_blank>single<S2SV_blank>quality<S2SV_blank>layer" "-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>layers<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n" "-><S2SV_blank>Rate<S2SV_blank>of<S2SV_blank>the<S2SV_blank>last<S2SV_blank>layer<S2SV_blank>(%3.1f)<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used" , parameters -> tcp_numlayers , parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ) ; parameters -> tcp_rates [ 0 ] = parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ; parameters -> tcp_numlayers = 1 ; } switch ( parameters -> rsiz ) { case OPJ_PROFILE_CINEMA_2K : if ( parameters -> numresolution > 6 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>(2k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank><=<S2SV_blank>5\\n" "-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>5<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 6 ; } break ; case OPJ_PROFILE_CINEMA_4K : if ( parameters -> numresolution < 2 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n" "-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 1 ; } else if ( parameters -> numresolution > 7 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n" "-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>6<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 7 ; } break ; default : break ; } parameters -> csty |= 0x01 ; <S2SV_StartBug> parameters -> res_spec = parameters -> numresolution - 1 ; <S2SV_EndBug> for ( i = 0 ; i < parameters -> res_spec ; i ++ ) { parameters -> prcw_init [ i ] = 256 ; <S2SV_StartBug> parameters -> prch_init [ i ] = 256 ; <S2SV_EndBug> } parameters -> prog_order = OPJ_CPRL ; if ( parameters -> rsiz == OPJ_PROFILE_CINEMA_4K ) { parameters -> numpocs = ( OPJ_UINT32 ) opj_j2k_initialise_4K_poc ( parameters -> POC , parameters -> numresolution ) ; } else { parameters -> numpocs = 0 ; } parameters -> cp_disto_alloc = 1 ; if ( parameters -> max_cs_size <= 0 ) { parameters -> max_cs_size = OPJ_CINEMA_24_CS ; opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n" "As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n" ) ; } else if ( parameters -> max_cs_size > OPJ_CINEMA_24_CS ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n" "-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1302083<S2SV_blank>bytes.\\n" ) ; parameters -> max_cs_size = OPJ_CINEMA_24_CS ; } if ( parameters -> max_comp_size <= 0 ) { parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n" "As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n" ) ; } else if ( parameters -> max_comp_size > OPJ_CINEMA_24_COMP ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n" "-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1041666<S2SV_blank>bytes.\\n" ) ; parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; } parameters -> tcp_rates [ 0 ] = ( OPJ_FLOAT32 ) ( image -> numcomps * image -> comps [ 0 ] . w * image -> comps [ 0 ] . h * image -> comps [ 0 ] . prec ) / ( OPJ_FLOAT32 ) ( ( ( OPJ_UINT32 ) parameters -> max_cs_size ) * 8 * image -> comps [ 0 ] . dx * image -> comps [ 0 ] . dy ) ; }
CWE-119 <S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> { static const struct arpt_arp uncond ; <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> }
CWE-000 int main ( int argc , char * argv [ ] ) { int ret ; struct lxc_lock * lock ; lock = lxc_newlock ( NULL , NULL ) ; if ( ! lock ) { fprintf ( stderr , "%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>unnamed<S2SV_blank>lock\\n" , __LINE__ ) ; exit ( 1 ) ; } ret = lxclock ( lock , 0 ) ; if ( ret ) { fprintf ( stderr , "%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>take<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n" , __LINE__ , ret ) ; exit ( 1 ) ; } ret = lxcunlock ( lock ) ; if ( ret ) { fprintf ( stderr , "%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n" , __LINE__ , ret ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; lock = lxc_newlock ( "/var/lib/lxc" , mycontainername ) ; if ( ! lock ) { fprintf ( stderr , "%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>lock\\n" , __LINE__ ) ; exit ( 1 ) ; } struct stat sb ; <S2SV_StartBug> char * pathname = RUNTIME_PATH "/lock/lxc/var/lib/lxc/" ; <S2SV_EndBug> ret = stat ( pathname , & sb ) ; if ( ret != 0 ) { fprintf ( stderr , "%d:<S2SV_blank>filename<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>created\\n" , __LINE__ , pathname ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; test_two_locks ( ) ; fprintf ( stderr , "all<S2SV_blank>tests<S2SV_blank>passed\\n" ) ; exit ( ret ) ; }
CWE-20 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
CWE-119 <S2SV_StartBug> static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth * <S2SV_EndBug> ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ; if ( max_bits < 0 ) max_bits = 0 ; else if ( max_bits > rc -> max_frame_bandwidth ) max_bits = rc -> max_frame_bandwidth ; return ( int ) max_bits ; }
CWE-362 <S2SV_StartBug> static struct desc_struct * get_desc ( unsigned short sel ) <S2SV_EndBug> { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) { <S2SV_StartBug> struct desc_struct * desc = NULL ; <S2SV_EndBug> struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ; <S2SV_StartBug> if ( ldt && sel < ldt -> nr_entries ) <S2SV_EndBug> <S2SV_StartBug> desc = & ldt -> entries [ sel ] ; <S2SV_EndBug> mutex_unlock ( & current -> active_mm -> context . lock ) ; <S2SV_StartBug> return desc ; <S2SV_EndBug> } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 <S2SV_StartBug> static void get_sb_partition_size_range ( VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> BLOCK_SIZE * min_block_size , <S2SV_StartBug> BLOCK_SIZE * max_block_size ) { <S2SV_EndBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int sb_width_in_blocks = MI_BLOCK_SIZE ; int sb_height_in_blocks = MI_BLOCK_SIZE ; int i , j ; int index = 0 ; for ( i = 0 ; i < sb_height_in_blocks ; ++ i ) { for ( j = 0 ; j < sb_width_in_blocks ; ++ j ) { MODE_INFO * mi = mi_8x8 [ index + j ] ; BLOCK_SIZE sb_type = mi ? mi -> mbmi . sb_type : 0 ; <S2SV_StartBug> * min_block_size = MIN ( * min_block_size , sb_type ) ; <S2SV_EndBug> * max_block_size = MAX ( * max_block_size , sb_type ) ; } index += xd -> mi_stride ; } }
CWE-264 static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes ) [ 2 ] , int error_fd ) { int close_fd ; int use_fd ; int fd ; if ( options -> flags & UV_PROCESS_DETACHED ) setsid ( ) ; for ( fd = 0 ; fd < stdio_count ; fd ++ ) { close_fd = pipes [ fd ] [ 0 ] ; use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd < 0 ) { if ( fd >= 3 ) continue ; else { use_fd = open ( "/dev/null" , fd == 0 ? O_RDONLY : O_RDWR ) ; close_fd = use_fd ; if ( use_fd == - 1 ) { uv__write_int ( error_fd , - errno ) ; perror ( "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stdio" ) ; _exit ( 127 ) ; } } } if ( fd == use_fd ) uv__cloexec ( use_fd , 0 ) ; else dup2 ( use_fd , fd ) ; if ( fd <= 2 ) uv__nonblock ( fd , 0 ) ; if ( close_fd != - 1 ) uv__close ( close_fd ) ; } for ( fd = 0 ; fd < stdio_count ; fd ++ ) { use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd >= 0 && fd != use_fd ) close ( use_fd ) ; } if ( options -> cwd != NULL && chdir ( options -> cwd ) ) { uv__write_int ( error_fd , - errno ) ; perror ( "chdir()" ) ; _exit ( 127 ) ; } <S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> uv__write_int ( error_fd , - errno ) ; perror ( "setgid()" ) ; _exit ( 127 ) ; } if ( ( options -> flags & UV_PROCESS_SETUID ) && setuid ( options -> uid ) ) { uv__write_int ( error_fd , - errno ) ; perror ( "setuid()" ) ; _exit ( 127 ) ; } if ( options -> env != NULL ) { environ = options -> env ; } execvp ( options -> file , options -> args ) ; uv__write_int ( error_fd , - errno ) ; perror ( "execvp()" ) ; _exit ( 127 ) ; }
CWE-000 <S2SV_StartBug> static void sas_probe_devices ( struct work_struct * work ) <S2SV_EndBug> { <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_PROBE , & port -> disc . pending ) ; list_for_each_entry ( dev , & port -> disco_list , disco_list_node ) { spin_lock_irq ( & port -> dev_list_lock ) ; list_add_tail ( & dev -> dev_list_node , & port -> dev_list ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; } sas_probe_sata ( port ) ; list_for_each_entry_safe ( dev , n , & port -> disco_list , disco_list_node ) { int err ; err = sas_rphy_add ( dev -> rphy ) ; if ( err ) sas_fail_probe ( dev , __func__ , err ) ; else list_del_init ( & dev -> disco_list_node ) ; } }
CWE-476 static int SMB2_sess_establish_session ( struct SMB2_sess_data * sess_data ) { int rc = 0 ; struct cifs_ses * ses = sess_data -> ses ; mutex_lock ( & ses -> server -> srv_mutex ) ; <S2SV_StartBug> if ( ses -> server -> sign && ses -> server -> ops -> generate_signingkey ) { <S2SV_EndBug> <S2SV_StartBug> rc = ses -> server -> ops -> generate_signingkey ( ses ) ; <S2SV_EndBug> kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; if ( rc ) { cifs_dbg ( FYI , "SMB3<S2SV_blank>session<S2SV_blank>key<S2SV_blank>generation<S2SV_blank>failed\\n" ) ; mutex_unlock ( & ses -> server -> srv_mutex ) ; <S2SV_StartBug> goto keygen_exit ; <S2SV_EndBug> } } if ( ! ses -> server -> session_estab ) { ses -> server -> sequence_number = 0x2 ; ses -> server -> session_estab = true ; } mutex_unlock ( & ses -> server -> srv_mutex ) ; cifs_dbg ( FYI , "SMB2/3<S2SV_blank>session<S2SV_blank>established<S2SV_blank>successfully\\n" ) ; spin_lock ( & GlobalMid_Lock ) ; ses -> status = CifsGood ; ses -> need_reconnect = false ; spin_unlock ( & GlobalMid_Lock ) ; <S2SV_StartBug> keygen_exit : <S2SV_EndBug> if ( ! ses -> server -> sign ) { kfree ( ses -> auth_key . response ) ; ses -> auth_key . response = NULL ; } return rc ; }
CWE-119 DECLAREcpFunc ( cpContig2SeparateByRow ) { tsize_t scanlinesizein = TIFFScanlineSize ( in ) ; tsize_t scanlinesizeout = TIFFScanlineSize ( out ) ; tdata_t inbuf ; tdata_t outbuf ; register uint8 * inp , * outp ; register uint32 n ; uint32 row ; tsample_t s ; <S2SV_StartBug> inbuf = _TIFFmalloc ( scanlinesizein ) ; <S2SV_EndBug> outbuf = _TIFFmalloc ( scanlinesizeout ) ; if ( ! inbuf || ! outbuf ) goto bad ; _TIFFmemset ( inbuf , 0 , scanlinesizein ) ; _TIFFmemset ( outbuf , 0 , scanlinesizeout ) ; for ( s = 0 ; s < spp ; s ++ ) { for ( row = 0 ; row < imagelength ; row ++ ) { if ( TIFFReadScanline ( in , inbuf , row , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>scanline<S2SV_blank>%lu" , ( unsigned long ) row ) ; goto bad ; } inp = ( ( uint8 * ) inbuf ) + s ; outp = ( uint8 * ) outbuf ; for ( n = imagewidth ; n -- > 0 ; ) { * outp ++ = * inp ; inp += spp ; } if ( TIFFWriteScanline ( out , outbuf , row , s ) < 0 ) { TIFFError ( TIFFFileName ( out ) , "Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>scanline<S2SV_blank>%lu" , ( unsigned long ) row ) ; goto bad ; } } } if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 1 ; bad : if ( inbuf ) _TIFFfree ( inbuf ) ; if ( outbuf ) _TIFFfree ( outbuf ) ; return 0 ; }
CWE-264 static int kvm_vm_ioctl_assign_device ( struct kvm * kvm , struct kvm_assigned_pci_dev * assigned_dev ) { int r = 0 , idx ; struct kvm_assigned_dev_kernel * match ; struct pci_dev * dev ; <S2SV_StartBug> if ( ! ( assigned_dev -> flags & KVM_DEV_ASSIGN_ENABLE_IOMMU ) ) <S2SV_EndBug> return - EINVAL ; mutex_lock ( & kvm -> lock ) ; idx = srcu_read_lock ( & kvm -> srcu ) ; match = kvm_find_assigned_dev ( & kvm -> arch . assigned_dev_head , assigned_dev -> assigned_dev_id ) ; if ( match ) { r = - EEXIST ; goto out ; } match = kzalloc ( sizeof ( struct kvm_assigned_dev_kernel ) , GFP_KERNEL ) ; if ( match == NULL ) { printk ( KERN_INFO "%s:<S2SV_blank>Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory\\n" , __func__ ) ; r = - ENOMEM ; goto out ; } dev = pci_get_domain_bus_and_slot ( assigned_dev -> segnr , assigned_dev -> busnr , assigned_dev -> devfn ) ; if ( ! dev ) { printk ( KERN_INFO "%s:<S2SV_blank>host<S2SV_blank>device<S2SV_blank>not<S2SV_blank>found\\n" , __func__ ) ; r = - EINVAL ; goto out_free ; } <S2SV_StartBug> if ( pci_enable_device ( dev ) ) { <S2SV_EndBug> printk ( KERN_INFO "%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>enable<S2SV_blank>PCI<S2SV_blank>device\\n" , __func__ ) ; r = - EBUSY ; goto out_put ; } r = pci_request_regions ( dev , "kvm_assigned_device" ) ; if ( r ) { printk ( KERN_INFO "%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>access<S2SV_blank>to<S2SV_blank>device<S2SV_blank>regions\\n" , __func__ ) ; goto out_disable ; } pci_reset_function ( dev ) ; pci_save_state ( dev ) ; match -> pci_saved_state = pci_store_saved_state ( dev ) ; if ( ! match -> pci_saved_state ) printk ( KERN_DEBUG "%s:<S2SV_blank>Couldn\'t<S2SV_blank>store<S2SV_blank>%s<S2SV_blank>saved<S2SV_blank>state\\n" , __func__ , dev_name ( & dev -> dev ) ) ; match -> assigned_dev_id = assigned_dev -> assigned_dev_id ; match -> host_segnr = assigned_dev -> segnr ; match -> host_busnr = assigned_dev -> busnr ; match -> host_devfn = assigned_dev -> devfn ; match -> flags = assigned_dev -> flags ; match -> dev = dev ; spin_lock_init ( & match -> intx_lock ) ; match -> irq_source_id = - 1 ; match -> kvm = kvm ; match -> ack_notifier . irq_acked = kvm_assigned_dev_ack_irq ; list_add ( & match -> list , & kvm -> arch . assigned_dev_head ) ; if ( ! kvm -> arch . iommu_domain ) { r = kvm_iommu_map_guest ( kvm ) ; if ( r ) goto out_list_del ; } r = kvm_assign_device ( kvm , match ) ; if ( r ) goto out_list_del ; out : srcu_read_unlock ( & kvm -> srcu , idx ) ; mutex_unlock ( & kvm -> lock ) ; return r ; out_list_del : if ( pci_load_and_free_saved_state ( dev , & match -> pci_saved_state ) ) printk ( KERN_INFO "%s:<S2SV_blank>Couldn\'t<S2SV_blank>reload<S2SV_blank>%s<S2SV_blank>saved<S2SV_blank>state\\n" , __func__ , dev_name ( & dev -> dev ) ) ; list_del ( & match -> list ) ; pci_release_regions ( dev ) ; out_disable : pci_disable_device ( dev ) ; out_put : pci_dev_put ( dev ) ; out_free : kfree ( match ) ; srcu_read_unlock ( & kvm -> srcu , idx ) ; mutex_unlock ( & kvm -> lock ) ; return r ; }
CWE-476 static int jp2_pclr_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_pclr_t * pclr = & box -> data . pclr ; int lutsize ; unsigned int i ; unsigned int j ; int_fast32_t x ; pclr -> lutdata = 0 ; <S2SV_StartBug> if ( jp2_getuint16 ( in , & pclr -> numlutents ) || <S2SV_EndBug> jp2_getuint8 ( in , & pclr -> numchans ) ) { return - 1 ; } lutsize = pclr -> numlutents * pclr -> numchans ; if ( ! ( pclr -> lutdata = jas_alloc2 ( lutsize , sizeof ( int_fast32_t ) ) ) ) { return - 1 ; } if ( ! ( pclr -> bpc = jas_alloc2 ( pclr -> numchans , sizeof ( uint_fast8_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < pclr -> numchans ; ++ i ) { if ( jp2_getuint8 ( in , & pclr -> bpc [ i ] ) ) { return - 1 ; } } for ( i = 0 ; i < pclr -> numlutents ; ++ i ) { for ( j = 0 ; j < pclr -> numchans ; ++ j ) { if ( jp2_getint ( in , ( pclr -> bpc [ j ] & 0x80 ) != 0 , ( pclr -> bpc [ j ] & 0x7f ) + 1 , & x ) ) { return - 1 ; } pclr -> lutdata [ i * pclr -> numchans + j ] = x ; } } return 0 ; }
CWE-000 int orangefs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { struct orangefs_inode_s * orangefs_inode = ORANGEFS_I ( inode ) ; int error = 0 ; void * value = NULL ; size_t size = 0 ; const char * name = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) { <S2SV_StartBug> gossip_err ( "%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\n" , <S2SV_EndBug> __func__ , error ) ; return error ; } if ( inode -> i_mode != mode ) SetModeFlag ( orangefs_inode ) ; inode -> i_mode = mode ; mark_inode_dirty_sync ( inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : gossip_err ( "%s:<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>%d!\\n" , __func__ , type ) ; return - EINVAL ; } gossip_debug ( GOSSIP_ACL_DEBUG , "%s:<S2SV_blank>inode<S2SV_blank>%pU,<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>type<S2SV_blank>%d\\n" , __func__ , get_khandle_from_ino ( inode ) , name , type ) ; if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( error < 0 ) goto out ; } gossip_debug ( GOSSIP_ACL_DEBUG , "%s:<S2SV_blank>name<S2SV_blank>%s,<S2SV_blank>value<S2SV_blank>%p,<S2SV_blank>size<S2SV_blank>%zd,<S2SV_blank>acl<S2SV_blank>%p\\n" , __func__ , name , value , size , acl ) ; error = orangefs_inode_setxattr ( inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
CWE-119 <S2SV_StartBug> static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) { <S2SV_EndBug> int i ; const double minqtarget = MIN ( ( ( x3 * maxq + x2 ) * maxq + x1 ) * maxq , maxq ) ; if ( minqtarget <= 2.0 ) return 0 ; <S2SV_StartBug> for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( minqtarget <= vp9_convert_qindex_to_q ( i ) ) <S2SV_EndBug> <S2SV_StartBug> return i ; <S2SV_EndBug> return QINDEX_RANGE - 1 ; }
CWE-264 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; if ( requeue_pi ) { <S2SV_StartBug> if ( refill_pi_state_cache ( ) ) <S2SV_EndBug> return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : if ( pi_state != NULL ) { free_pi_state ( pi_state ) ; pi_state = NULL ; } ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) <S2SV_StartBug> goto out_put_key1 ; <S2SV_EndBug> hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( ret , hb2 , & key2 , & pi_state , NULL ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { wake_futex ( this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { atomic_inc ( & pi_state -> refcount ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task , 1 ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; free_pi_state ( pi_state ) ; goto out_unlock ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } out_unlock : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : if ( pi_state != NULL ) free_pi_state ( pi_state ) ; return ret ? ret : task_count ; }
CWE-000 static int iwch_l2t_send ( struct t3cdev * tdev , struct sk_buff * skb , struct l2t_entry * l2e ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = l2t_send ( tdev , skb , l2e ) ; if ( error < 0 ) kfree_skb ( skb ) ; <S2SV_StartBug> return error ; <S2SV_EndBug> }
CWE-125 void qedi_dbg_err ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_err ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_err ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> va_end ( va ) ; }
CWE-119 static void fill_variance_tree ( void * data , BLOCK_SIZE bsize ) { <S2SV_StartBug> variance_node node ; <S2SV_EndBug> tree_to_node ( data , bsize , & node ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 1 ] , & node . part_variances -> horz [ 0 ] ) ; sum_2_variances ( node . split [ 2 ] , node . split [ 3 ] , & node . part_variances -> horz [ 1 ] ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 2 ] , & node . part_variances -> vert [ 0 ] ) ; sum_2_variances ( node . split [ 1 ] , node . split [ 3 ] , & node . part_variances -> vert [ 1 ] ) ; sum_2_variances ( & node . part_variances -> vert [ 0 ] , & node . part_variances -> vert [ 1 ] , & node . part_variances -> none ) ; }
CWE-362 static ssize_t n_tty_write ( struct tty_struct * tty , struct file * file , const unsigned char * buf , size_t nr ) { const unsigned char * b = buf ; DECLARE_WAITQUEUE ( wait , current ) ; int c ; ssize_t retval = 0 ; if ( L_TOSTOP ( tty ) && file -> f_op -> write != redirected_tty_write ) { retval = tty_check_change ( tty ) ; if ( retval ) return retval ; } down_read ( & tty -> termios_rwsem ) ; process_echoes ( tty ) ; add_wait_queue ( & tty -> write_wait , & wait ) ; while ( 1 ) { set_current_state ( TASK_INTERRUPTIBLE ) ; if ( signal_pending ( current ) ) { retval = - ERESTARTSYS ; break ; } if ( tty_hung_up_p ( file ) || ( tty -> link && ! tty -> link -> count ) ) { retval = - EIO ; break ; } if ( O_OPOST ( tty ) ) { while ( nr > 0 ) { ssize_t num = process_output_block ( tty , b , nr ) ; if ( num < 0 ) { if ( num == - EAGAIN ) break ; retval = num ; goto break_out ; } b += num ; nr -= num ; if ( nr == 0 ) break ; c = * b ; if ( process_output ( c , tty ) < 0 ) break ; b ++ ; nr -- ; } if ( tty -> ops -> flush_chars ) tty -> ops -> flush_chars ( tty ) ; } else { <S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> if ( c < 0 ) { retval = c ; goto break_out ; } if ( ! c ) break ; b += c ; nr -= c ; } } if ( ! nr ) break ; if ( file -> f_flags & O_NONBLOCK ) { retval = - EAGAIN ; break ; } up_read ( & tty -> termios_rwsem ) ; schedule ( ) ; down_read ( & tty -> termios_rwsem ) ; } break_out : __set_current_state ( TASK_RUNNING ) ; remove_wait_queue ( & tty -> write_wait , & wait ) ; if ( b - buf != nr && tty -> fasync ) set_bit ( TTY_DO_WRITE_WAKEUP , & tty -> flags ) ; up_read ( & tty -> termios_rwsem ) ; return ( b - buf ) ? b - buf : retval ; }
CWE-000 static long aio_read_events_ring ( struct kioctx * ctx , struct io_event __user * event , long nr ) { struct aio_ring * ring ; unsigned head , tail , pos ; long ret = 0 ; int copy_ret ; mutex_lock ( & ctx -> ring_lock ) ; ring = kmap_atomic ( ctx -> ring_pages [ 0 ] ) ; head = ring -> head ; tail = ring -> tail ; kunmap_atomic ( ring ) ; pr_debug ( "h%u<S2SV_blank>t%u<S2SV_blank>m%u\\n" , head , tail , ctx -> nr_events ) ; if ( head == tail ) goto out ; <S2SV_StartBug> while ( ret < nr ) { <S2SV_EndBug> long avail ; struct io_event * ev ; struct page * page ; avail = ( head <= tail ? tail : ctx -> nr_events ) - head ; if ( head == tail ) break ; avail = min ( avail , nr - ret ) ; avail = min_t ( long , avail , AIO_EVENTS_PER_PAGE - ( ( head + AIO_EVENTS_OFFSET ) % AIO_EVENTS_PER_PAGE ) ) ; pos = head + AIO_EVENTS_OFFSET ; page = ctx -> ring_pages [ pos / AIO_EVENTS_PER_PAGE ] ; pos %= AIO_EVENTS_PER_PAGE ; ev = kmap ( page ) ; copy_ret = copy_to_user ( event + ret , ev + pos , sizeof ( * ev ) * avail ) ; kunmap ( page ) ; if ( unlikely ( copy_ret ) ) { ret = - EFAULT ; goto out ; } ret += avail ; head += avail ; head %= ctx -> nr_events ; } ring = kmap_atomic ( ctx -> ring_pages [ 0 ] ) ; ring -> head = head ; kunmap_atomic ( ring ) ; flush_dcache_page ( ctx -> ring_pages [ 0 ] ) ; pr_debug ( "%li<S2SV_blank><S2SV_blank>h%u<S2SV_blank>t%u\\n" , ret , head , tail ) ; out : mutex_unlock ( & ctx -> ring_lock ) ; return ret ; }
CWE-119 static void vhost_scsi_send_evt ( struct vhost_scsi * vs , struct vhost_scsi_tpg * tpg , struct se_lun * lun , u32 event , u32 reason ) { struct vhost_scsi_evt * evt ; evt = vhost_scsi_allocate_evt ( vs , event , reason ) ; if ( ! evt ) return ; if ( tpg && lun ) { evt -> event . lun [ 0 ] = 0x01 ; <S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ; } llist_add ( & evt -> list , & vs -> vs_event_list ) ; vhost_work_queue ( & vs -> dev , & vs -> vs_event_work ) ; }
CWE-200 int vmw_gb_surface_define_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct vmw_private * dev_priv = vmw_priv ( dev ) ; struct vmw_user_surface * user_srf ; struct vmw_surface * srf ; struct vmw_resource * res ; struct vmw_resource * tmp ; union drm_vmw_gb_surface_create_arg * arg = ( union drm_vmw_gb_surface_create_arg * ) data ; struct drm_vmw_gb_surface_create_req * req = & arg -> req ; struct drm_vmw_gb_surface_create_rep * rep = & arg -> rep ; struct ttm_object_file * tfile = vmw_fpriv ( file_priv ) -> tfile ; int ret ; uint32_t size ; <S2SV_StartBug> uint32_t backup_handle ; <S2SV_EndBug> if ( req -> multisample_count != 0 ) return - EINVAL ; if ( req -> mip_levels > DRM_VMW_MAX_MIP_LEVELS ) return - EINVAL ; if ( unlikely ( vmw_user_surface_size == 0 ) ) vmw_user_surface_size = ttm_round_pot ( sizeof ( * user_srf ) ) + 128 ; size = vmw_user_surface_size + 128 ; ret = vmw_surface_gb_priv_define ( dev , size , req -> svga3d_flags , req -> format , req -> drm_surface_flags & drm_vmw_surface_flag_scanout , req -> mip_levels , req -> multisample_count , req -> array_size , req -> base_size , & srf ) ; if ( unlikely ( ret != 0 ) ) return ret ; user_srf = container_of ( srf , struct vmw_user_surface , srf ) ; if ( drm_is_primary_client ( file_priv ) ) user_srf -> master = drm_master_get ( file_priv -> master ) ; ret = ttm_read_lock ( & dev_priv -> reservation_sem , true ) ; if ( unlikely ( ret != 0 ) ) return ret ; res = & user_srf -> srf . res ; if ( req -> buffer_handle != SVGA3D_INVALID_ID ) { ret = vmw_user_dmabuf_lookup ( tfile , req -> buffer_handle , & res -> backup , & user_srf -> backup_base ) ; <S2SV_StartBug> if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE < <S2SV_EndBug> res -> backup_size ) { DRM_ERROR ( "Surface<S2SV_blank>backup<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small.\\n" ) ; vmw_dmabuf_unreference ( & res -> backup ) ; ret = - EINVAL ; <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> } } else if ( req -> drm_surface_flags & drm_vmw_surface_flag_create_buffer ) ret = vmw_user_dmabuf_alloc ( dev_priv , tfile , res -> backup_size , req -> drm_surface_flags & drm_vmw_surface_flag_shareable , & backup_handle , & res -> backup , & user_srf -> backup_base ) ; if ( unlikely ( ret != 0 ) ) { vmw_resource_unreference ( & res ) ; goto out_unlock ; } tmp = vmw_resource_reference ( res ) ; ret = ttm_prime_object_init ( tfile , res -> backup_size , & user_srf -> prime , req -> drm_surface_flags & drm_vmw_surface_flag_shareable , VMW_RES_SURFACE , & vmw_user_surface_base_release , NULL ) ; if ( unlikely ( ret != 0 ) ) { vmw_resource_unreference ( & tmp ) ; vmw_resource_unreference ( & res ) ; goto out_unlock ; } rep -> handle = user_srf -> prime . base . hash . key ; rep -> backup_size = res -> backup_size ; if ( res -> backup ) { rep -> buffer_map_handle = drm_vma_node_offset_addr ( & res -> backup -> base . vma_node ) ; rep -> buffer_size = res -> backup -> base . num_pages * PAGE_SIZE ; rep -> buffer_handle = backup_handle ; } else { rep -> buffer_map_handle = 0 ; rep -> buffer_size = 0 ; rep -> buffer_handle = SVGA3D_INVALID_ID ; } vmw_resource_unreference ( & res ) ; out_unlock : ttm_read_unlock ( & dev_priv -> reservation_sem ) ; return ret ; }
CWE-20 static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }
CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; const VpxInterface * decoder = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments." ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading." , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , "wb" ) ) ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing." , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( "Unknown<S2SV_blank>input<S2SV_blank>codec." ) ; <S2SV_StartBug> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { unsigned char digest [ 16 ] ; get_image_md5 ( img , digest ) ; print_md5 ( outfile , digest ) ; fprintf ( outfile , "<S2SV_blank><S2SV_blank>img-%dx%d-%04d.i420\\n" , img -> d_w , img -> d_h , ++ frame_cnt ) ; } } printf ( "Processed<S2SV_blank>%d<S2SV_blank>frames.\\n" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec." ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }
CWE-119 int vp8_calc_ss_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) { int i , j ; int Total = 0 ; unsigned char * src = source -> y_buffer ; unsigned char * dst = dest -> y_buffer ; for ( i = 0 ; i < source -> y_height ; i += 16 ) { for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ; <S2SV_StartBug> Total += vp8_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ; <S2SV_EndBug> } src += 16 * source -> y_stride ; dst += 16 * dest -> y_stride ; } return Total ; }
CWE-264 SYSCALL_DEFINE3 ( osf_sysinfo , int , command , char __user * , buf , long , count ) { const char * sysinfo_table [ ] = { utsname ( ) -> sysname , utsname ( ) -> nodename , utsname ( ) -> release , utsname ( ) -> version , utsname ( ) -> machine , "alpha" , "dummy" , "dummy" , "dummy" , } ; unsigned long offset ; const char * res ; long len , err = - EINVAL ; offset = command - 1 ; if ( offset >= ARRAY_SIZE ( sysinfo_table ) ) { printk ( "sysinfo(%d)" , command ) ; goto out ; } down_read ( & uts_sem ) ; res = sysinfo_table [ offset ] ; len = strlen ( res ) + 1 ; <S2SV_StartBug> if ( len > count ) <S2SV_EndBug> len = count ; if ( copy_to_user ( buf , res , len ) ) err = - EFAULT ; else err = 0 ; up_read ( & uts_sem ) ; out : return err ; }
CWE-000 void fput ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { <S2SV_StartBug> struct task_struct * task = current ; <S2SV_EndBug> file_sb_list_del ( file ) ; if ( likely ( ! in_interrupt ( ) && ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & file -> f_u . fu_rcuhead , ____fput ) ; if ( ! task_work_add ( task , & file -> f_u . fu_rcuhead , true ) ) return ; } if ( llist_add ( & file -> f_u . fu_llist , & delayed_fput_list ) ) schedule_work ( & delayed_fput_work ) ; } }
CWE-000 static int devzvol_readdir ( struct vnode * dvp , struct uio * uiop , struct cred * cred , int * eofp , caller_context_t * ct_unused , int flags_unused ) { struct sdev_node * sdvp = VTOSDEV ( dvp ) ; char * ptr ; sdcmn_err13 ( ( "zv<S2SV_blank>readdir<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>%s\'" , sdvp -> sdev_path , sdvp -> sdev_name ) ) ; if ( strcmp ( sdvp -> sdev_path , ZVOL_DIR ) == 0 ) { struct vnode * vp ; rw_exit ( & sdvp -> sdev_contents ) ; ( void ) devname_lookup_func ( sdvp , "dsk" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; ( void ) devname_lookup_func ( sdvp , "rdsk" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } if ( uiop -> uio_offset == 0 ) devzvol_prunedir ( sdvp ) ; ptr = sdvp -> sdev_path + strlen ( ZVOL_DIR ) ; if ( ( strcmp ( ptr , "/dsk" ) == 0 ) || ( strcmp ( ptr , "/rdsk" ) == 0 ) ) { rw_exit ( & sdvp -> sdev_contents ) ; devzvol_create_pool_dirs ( dvp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } <S2SV_StartBug> ptr = strchr ( ptr + 1 , '/' ) + 1 ; <S2SV_EndBug> rw_exit ( & sdvp -> sdev_contents ) ; sdev_iter_datasets ( dvp , ZFS_IOC_DATASET_LIST_NEXT , ptr ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; }
CWE-399 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb -> csum_start - skb_headroom ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; <S2SV_StartBug> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && <S2SV_EndBug> pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; ipv6_select_ident ( fptr ) ; segs = skb_segment ( skb , features ) ; out : return segs ; }
CWE-125 static RList * r_bin_wasm_get_element_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmElementEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_StartBug> ut32 len = sec -> payload_len ; <S2SV_EndBug> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; <S2SV_StartBug> while ( i < len && r < count ) { <S2SV_EndBug> if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> num_elem , & i ) ) ) { <S2SV_StartBug> free ( ptr ) ; <S2SV_EndBug> return ret ; } ut32 j = 0 ; while ( i < len && j < ptr -> num_elem ) { ut32 e ; if ( ! ( consume_u32 ( buf + i , buf + len , & e , & i ) ) ) { free ( ptr ) ; return ret ; } } r_list_append ( ret , ptr ) ; r += 1 ; } return ret ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * buf = avpkt -> data ; APEContext * s = avctx -> priv_data ; uint8_t * sample8 ; int16_t * sample16 ; int32_t * sample24 ; int i , ch , ret ; <S2SV_StartBug> int blockstodecode ; <S2SV_EndBug> av_assert0 ( s -> samples >= 0 ) ; if ( ! s -> samples ) { uint32_t nblocks , offset ; int buf_size ; if ( ! avpkt -> size ) { * got_frame_ptr = 0 ; return 0 ; } if ( avpkt -> size < 8 ) { av_log ( avctx , AV_LOG_ERROR , "Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n" ) ; return AVERROR_INVALIDDATA ; } buf_size = avpkt -> size & ~ 3 ; if ( buf_size != avpkt -> size ) { av_log ( avctx , AV_LOG_WARNING , "packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>" "extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n" ) ; } if ( s -> fileversion < 3950 ) buf_size += 2 ; av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; if ( ! s -> data ) return AVERROR ( ENOMEM ) ; s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; s -> ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = bytestream_get_be32 ( & s -> ptr ) ; offset = bytestream_get_be32 ( & s -> ptr ) ; if ( s -> fileversion >= 3900 ) { if ( offset > 3 ) { av_log ( avctx , AV_LOG_ERROR , "Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } if ( s -> data_end - s -> ptr < offset ) { av_log ( avctx , AV_LOG_ERROR , "Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n" ) ; return AVERROR_INVALIDDATA ; } s -> ptr += offset ; } else { if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) return ret ; if ( s -> fileversion > 3800 ) skip_bits_long ( & s -> gb , offset * 8 ) ; else skip_bits_long ( & s -> gb , offset ) ; } <S2SV_StartBug> if ( ! nblocks || nblocks > INT_MAX ) { <S2SV_EndBug> av_log ( avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%" PRIu32 ".\\n" , nblocks ) ; return AVERROR_INVALIDDATA ; } if ( init_frame_decoder ( s ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n" ) ; return AVERROR_INVALIDDATA ; } s -> samples = nblocks ; } if ( ! s -> data ) { * got_frame_ptr = 0 ; return avpkt -> size ; } blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; if ( s -> fileversion < 3930 ) blockstodecode = s -> samples ; <S2SV_StartBug> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , <S2SV_EndBug> <S2SV_StartBug> 2 * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ) ; <S2SV_EndBug> if ( ! s -> decoded_buffer ) return AVERROR ( ENOMEM ) ; memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; s -> decoded [ 0 ] = s -> decoded_buffer ; s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; frame -> nb_samples = blockstodecode ; if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) return ret ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) ape_unpack_mono ( s , blockstodecode ) ; else ape_unpack_stereo ( s , blockstodecode ) ; emms_c ( ) ; if ( s -> error ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , "Error<S2SV_blank>decoding<S2SV_blank>frame\\n" ) ; return AVERROR_INVALIDDATA ; } switch ( s -> bps ) { case 8 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample8 = ( uint8_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; } break ; case 16 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample16 = ( int16_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample16 ++ = s -> decoded [ ch ] [ i ] ; } break ; case 24 : for ( ch = 0 ; ch < s -> channels ; ch ++ ) { sample24 = ( int32_t * ) frame -> data [ ch ] ; for ( i = 0 ; i < blockstodecode ; i ++ ) * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; } break ; } s -> samples -= blockstodecode ; * got_frame_ptr = 1 ; return ! s -> samples ? avpkt -> size : 0 ; }
CWE-119 <S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , "ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>" "addr<S2SV_blank>%pM\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; if ( priv -> stations [ sta_id ] . used & IWL_STA_UCODE_ACTIVE ) { IWL_DEBUG_ASSOC ( priv , "STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>already<S2SV_blank>present<S2SV_blank>in<S2SV_blank>uCode<S2SV_blank>" "(according<S2SV_blank>to<S2SV_blank>driver)\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } else { priv -> stations [ sta_id ] . used |= IWL_STA_UCODE_ACTIVE ; IWL_DEBUG_ASSOC ( priv , "Added<S2SV_blank>STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>to<S2SV_blank>uCode\\n" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> if ( frame != NULL ) { <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug> yuvconfig2image ( & frame -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
CWE-119 void vp9_encode_intra_block_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { const MACROBLOCKD * const xd = & x -> e_mbd ; struct encode_b_args arg = { x , NULL , & xd -> mi [ 0 ] -> mbmi . skip } ; <S2SV_StartBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , <S2SV_EndBug> & arg ) ; }
CWE-20 static MagickBooleanType ReadUncompressedRGB ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { PixelPacket * q ; ssize_t x , y ; unsigned short color ; if ( dds_info -> pixelformat . rgb_bitcount == 8 ) ( void ) SetImageType ( image , GrayscaleType ) ; else if ( dds_info -> pixelformat . rgb_bitcount == 16 && ! IsBitMask ( dds_info -> pixelformat , 0xf800 , 0x07e0 , 0x001f , 0x0000 ) ) ThrowBinaryException ( CorruptImageError , "ImageTypeNotSupported" , image -> filename ) ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , dds_info -> width , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x ++ ) { if ( dds_info -> pixelformat . rgb_bitcount == 8 ) SetPixelGray ( q , ScaleCharToQuantum ( ReadBlobByte ( image ) ) ) ; else if ( dds_info -> pixelformat . rgb_bitcount == 16 ) { color = ReadBlobShort ( image ) ; SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( color >> 11 ) / 31.0 ) * 255 ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color << 5 ) >> 10 ) / 63.0 ) * 255 ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color << 11 ) >> 11 ) / 31.0 ) * 255 ) ) ) ; } else { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; if ( dds_info -> pixelformat . rgb_bitcount == 32 ) ( void ) ReadBlobByte ( image ) ; } SetPixelAlpha ( q , QuantumRange ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } <S2SV_StartBug> SkipRGBMipmaps ( image , dds_info , 3 ) ; <S2SV_EndBug> return MagickTrue ; }
CWE-119 <S2SV_StartBug> static void tree2tok ( struct vp9_token * tokens , const vp9_tree_index * tree , <S2SV_EndBug> int i , int v , int l ) { v += v ; ++ l ; do { <S2SV_StartBug> const vp9_tree_index j = tree [ i ++ ] ; <S2SV_EndBug> if ( j <= 0 ) { tokens [ - j ] . value = v ; tokens [ - j ] . len = l ; } else { tree2tok ( tokens , tree , j , v , l ) ; } } while ( ++ v & 1 ) ; }
CWE-119 enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) { char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ; unsigned char hmac_response [ MD5_DIGEST_LEN ] ; int len ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ; mutt_message ( _ ( "Authenticating<S2SV_blank>(CRAM-MD5)..." ) ) ; if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; imap_cmd_start ( idata , "AUTHENTICATE<S2SV_blank>CRAM-MD5" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , "Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n" , ibuf ) ; goto bail ; } <S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> if ( len == - 1 ) { mutt_debug ( 1 , "Error<S2SV_blank>decoding<S2SV_blank>base64<S2SV_blank>response.\\n" ) ; goto bail ; } obuf [ len ] = '\\0' ; mutt_debug ( 2 , "CRAM<S2SV_blank>challenge:<S2SV_blank>%s\\n" , obuf ) ; hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ; int off = snprintf ( obuf , sizeof ( obuf ) , "%s<S2SV_blank>" , idata -> conn -> account . user ) ; mutt_md5_toascii ( hmac_response , obuf + off ) ; mutt_debug ( 2 , "CRAM<S2SV_blank>response:<S2SV_blank>%s\\n" , obuf ) ; mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ; mutt_str_strcat ( ibuf , sizeof ( ibuf ) , "\\r\\n" ) ; mutt_socket_send ( idata -> conn , ibuf ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_OK ) { mutt_debug ( 1 , "Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n" ) ; goto bail ; } if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ; bail : mutt_error ( _ ( "CRAM-MD5<S2SV_blank>authentication<S2SV_blank>failed." ) ) ; return IMAP_AUTH_FAILURE ; }
CWE-000 void mwifiex_set_wmm_params ( struct mwifiex_private * priv , struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { const u8 * vendor_ie ; const u8 * wmm_ie ; u8 wmm_oui [ ] = { 0x00 , 0x50 , 0xf2 , 0x02 } ; vendor_ie = cfg80211_find_vendor_ie ( WLAN_OUI_MICROSOFT , WLAN_OUI_TYPE_MICROSOFT_WMM , params -> beacon . tail , params -> beacon . tail_len ) ; if ( vendor_ie ) { wmm_ie = vendor_ie ; <S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug> priv -> wmm_enabled = 1 ; } else { memset ( & bss_cfg -> wmm_info , 0 , sizeof ( bss_cfg -> wmm_info ) ) ; memcpy ( & bss_cfg -> wmm_info . oui , wmm_oui , sizeof ( wmm_oui ) ) ; bss_cfg -> wmm_info . subtype = MWIFIEX_WMM_SUBTYPE ; bss_cfg -> wmm_info . version = MWIFIEX_WMM_VERSION ; priv -> wmm_enabled = 0 ; } bss_cfg -> qos_info = 0x00 ; return ; }
CWE-20 EXPORTED const char * dlist_reserve_path ( const char * part , int isarchive , const struct message_guid * guid ) { static char buf [ MAX_MAILBOX_PATH ] ; <S2SV_StartBug> const char * base ; <S2SV_EndBug> if ( strchr ( part , '/' ) ) { base = part ; } else { base = isarchive ? config_archivepartitiondir ( part ) : config_partitiondir ( part ) ; <S2SV_StartBug> } <S2SV_EndBug> assert ( base != NULL ) ; snprintf ( buf , MAX_MAILBOX_PATH , "%s/sync./%lu/%s" , base , ( unsigned long ) getpid ( ) , message_guid_encode ( guid ) ) ; if ( cyrus_mkdir ( buf , 0755 ) ) { syslog ( LOG_ERR , "IOERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%s/sync./%lu/<S2SV_blank>for<S2SV_blank>reserve:<S2SV_blank>%m" , base , ( unsigned long ) getpid ( ) ) ; } return buf ; }
CWE-264 static int perf_trace_event_perm ( struct ftrace_event_call * tp_event , struct perf_event * p_event ) { if ( ftrace_event_is_function ( tp_event ) && <S2SV_StartBug> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <S2SV_EndBug> return - EPERM ; if ( ! ( p_event -> attr . sample_type & PERF_SAMPLE_RAW ) ) return 0 ; if ( p_event -> attach_state == PERF_ATTACH_TASK ) { if ( tp_event -> flags & TRACE_EVENT_FL_CAP_ANY ) return 0 ; } if ( perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; return 0 ; }
CWE-119 static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high , <S2SV_StartBug> int q ) { <S2SV_EndBug> const double error_term = err_per_mb / err_divisor ; <S2SV_StartBug> const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low , <S2SV_EndBug> pt_high ) ; if ( power_term < 1.0 ) assert ( error_term >= 0.0 ) ; return fclamp ( pow ( error_term , power_term ) , 0.05 , 5.0 ) ; }
CWE-399 long pipe_fcntl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct pipe_inode_info * pipe ; long ret ; pipe = get_pipe_info ( file ) ; if ( ! pipe ) return - EBADF ; __pipe_lock ( pipe ) ; switch ( cmd ) { case F_SETPIPE_SZ : { unsigned int size , nr_pages ; size = round_pipe_size ( arg ) ; nr_pages = size >> PAGE_SHIFT ; ret = - EINVAL ; if ( ! nr_pages ) goto out ; if ( ! capable ( CAP_SYS_RESOURCE ) && size > pipe_max_size ) { ret = - EPERM ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> ret = pipe_set_size ( pipe , nr_pages ) ; break ; } case F_GETPIPE_SZ : ret = pipe -> buffers * PAGE_SIZE ; break ; default : ret = - EINVAL ; break ; } out : __pipe_unlock ( pipe ) ; return ret ; }
CWE-119 void vp9_tokens_from_tree ( struct vp9_token * tokens , <S2SV_StartBug> const vp9_tree_index * tree ) { <S2SV_EndBug> tree2tok ( tokens , tree , 0 , 0 , 0 ) ; }
CWE-125 <S2SV_StartBug> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <S2SV_EndBug> { WLog_DBG ( TAG , "%s<S2SV_blank>(Len:<S2SV_blank>%" PRIu16 "<S2SV_blank>MaxLen:<S2SV_blank>%" PRIu16 "<S2SV_blank>BufferOffset:<S2SV_blank>%" PRIu32 ")" , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ; if ( fields -> Len > 0 ) winpr_HexDump ( TAG , WLOG_DEBUG , fields -> Buffer , fields -> Len ) ; }
CWE-119 static int nl80211_start_sched_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_sched_scan_request * request ; struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; u32 interval ; enum ieee80211_band band ; size_t ie_len ; if ( ! ( rdev -> wiphy . flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN ) || ! rdev -> ops -> sched_scan_start ) return - EOPNOTSUPP ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; if ( rdev -> sched_scan_req ) return - EINPROGRESS ; if ( ! info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) return - EINVAL ; interval = nla_get_u32 ( info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) ; if ( interval == 0 ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; request -> interval = interval ; err = rdev -> ops -> sched_scan_start ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { rdev -> sched_scan_req = request ; nl80211_send_sched_scan ( rdev , dev , NL80211_CMD_START_SCHED_SCAN ) ; goto out ; } out_free : kfree ( request ) ; out : return err ; }
CWE-119 <S2SV_StartBug> static void prob_diff_update ( const vp9_tree_index * tree , <S2SV_EndBug> <S2SV_StartBug> vp9_prob probs [ ] , <S2SV_EndBug> const unsigned int counts [ ] , <S2SV_StartBug> int n , vp9_writer * w ) { <S2SV_EndBug> int i ; unsigned int branch_ct [ 32 ] [ 2 ] ; assert ( n <= 32 ) ; vp9_tree_probs_from_distribution ( tree , branch_ct , counts ) ; for ( i = 0 ; i < n - 1 ; ++ i ) vp9_cond_prob_diff_update ( w , & probs [ i ] , branch_ct [ i ] ) ; }
CWE-119 enum nss_status _nss_mymachines_getgrnam_r ( const char * name , struct group * gr , char * buffer , size_t buflen , int * errnop ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; _cleanup_bus_message_unref_ sd_bus_message * reply = NULL ; _cleanup_bus_flush_close_unref_ sd_bus * bus = NULL ; const char * p , * e , * machine ; uint32_t mapped ; uid_t gid ; size_t l ; int r ; assert ( name ) ; assert ( gr ) ; p = startswith ( name , "vg-" ) ; if ( ! p ) goto not_found ; e = strrchr ( p , '-' ) ; if ( ! e || e == p ) goto not_found ; <S2SV_StartBug> r = parse_gid ( e + 1 , & gid ) ; <S2SV_EndBug> if ( r < 0 ) goto not_found ; machine = strndupa ( p , e - p ) ; if ( ! machine_name_is_valid ( machine ) ) goto not_found ; r = sd_bus_open_system ( & bus ) ; if ( r < 0 ) goto fail ; r = sd_bus_call_method ( bus , "org.freedesktop.machine1" , "/org/freedesktop/machine1" , "org.freedesktop.machine1.Manager" , "MapFromMachineGroup" , & error , & reply , "su" , machine , ( uint32_t ) gid ) ; if ( r < 0 ) { if ( sd_bus_error_has_name ( & error , BUS_ERROR_NO_SUCH_GROUP_MAPPING ) ) goto not_found ; goto fail ; } r = sd_bus_message_read ( reply , "u" , & mapped ) ; if ( r < 0 ) goto fail ; l = sizeof ( char * ) + strlen ( name ) + 1 ; if ( buflen < l ) { * errnop = ENOMEM ; return NSS_STATUS_TRYAGAIN ; } memzero ( buffer , sizeof ( char * ) ) ; strcpy ( buffer + sizeof ( char * ) , name ) ; gr -> gr_name = buffer + sizeof ( char * ) ; gr -> gr_gid = gid ; gr -> gr_passwd = ( char * ) "*" ; gr -> gr_mem = ( char * * ) buffer ; * errnop = 0 ; return NSS_STATUS_SUCCESS ; not_found : * errnop = 0 ; return NSS_STATUS_NOTFOUND ; fail : * errnop = - r ; return NSS_STATUS_UNAVAIL ; }
CWE-416 int inet6_csk_xmit ( struct sock * sk , struct sk_buff * skb , struct flowi * fl_unused ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; struct dst_entry * dst ; int res ; dst = inet6_csk_route_socket ( sk , & fl6 ) ; if ( IS_ERR ( dst ) ) { sk -> sk_err_soft = - PTR_ERR ( dst ) ; sk -> sk_route_caps = 0 ; kfree_skb ( skb ) ; return PTR_ERR ( dst ) ; } rcu_read_lock ( ) ; skb_dst_set_noref ( skb , dst ) ; fl6 . daddr = sk -> sk_v6_daddr ; <S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; return res ; }
CWE-000 struct vfsmount * collect_mounts ( struct path * path ) { struct mount * tree ; <S2SV_StartBug> namespace_lock ( ) ; <S2SV_EndBug> tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ; namespace_unlock ( ) ; if ( IS_ERR ( tree ) ) return ERR_CAST ( tree ) ; return & tree -> mnt ; }
CWE-362 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop_transport ; } <S2SV_StartBug> } <S2SV_EndBug> if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; } conn -> c_trans = trans ; ret = trans -> conn_alloc ( conn , gfp ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; conn -> c_send_gen = 0 ; conn -> c_outgoing = ( is_outgoing ? 1 : 0 ) ; conn -> c_reconnect_jiffies = 0 ; INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; mutex_init ( & conn -> c_cm_lock ) ; conn -> c_flags = 0 ; rdsdebug ( "allocated<S2SV_blank>conn<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>%pI4<S2SV_blank>-><S2SV_blank>%pI4<S2SV_blank>over<S2SV_blank>%s<S2SV_blank>%s\\n" , conn , & laddr , & faddr , trans -> t_name ? trans -> t_name : "[unknown]" , is_outgoing ? "(outgoing)" : "" ) ; spin_lock_irqsave ( & rds_conn_lock , flags ) ; if ( parent ) { if ( parent -> c_passive ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = parent -> c_passive ; } else { parent -> c_passive = conn ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } else { struct rds_connection * found ; found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( found ) { trans -> conn_free ( conn -> c_transport_data ) ; kmem_cache_free ( rds_conn_slab , conn ) ; conn = found ; } else { hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; rds_cong_add_conn ( conn ) ; rds_conn_count ++ ; } } spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; out : return conn ; }
CWE-125 int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\n" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\n" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\n" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\n" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; <S2SV_StartBug> } <S2SV_EndBug> p += chunksize ; } return 0 ; }
CWE-189 static int efx_ethtool_set_ringparam ( struct net_device * net_dev , struct ethtool_ringparam * ring ) { <S2SV_StartBug> struct efx_nic * efx = netdev_priv ( net_dev ) ; <S2SV_EndBug> if ( ring -> rx_mini_pending || ring -> rx_jumbo_pending || ring -> rx_pending > EFX_MAX_DMAQ_SIZE || ring -> tx_pending > EFX_MAX_DMAQ_SIZE ) return - EINVAL ; <S2SV_StartBug> if ( ring -> rx_pending < EFX_MIN_RING_SIZE || <S2SV_EndBug> ring -> tx_pending < EFX_MIN_RING_SIZE ) { netif_err ( efx , drv , efx -> net_dev , <S2SV_StartBug> "TX<S2SV_blank>and<S2SV_blank>RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%ld\\n" , <S2SV_EndBug> EFX_MIN_RING_SIZE ) ; return - EINVAL ; } <S2SV_StartBug> return efx_realloc_channels ( efx , ring -> rx_pending , ring -> tx_pending ) ; <S2SV_EndBug> }
CWE-000 <S2SV_StartBug> void bpf_map_inc ( struct bpf_map * map , bool uref ) <S2SV_EndBug> { <S2SV_StartBug> atomic_inc ( & map -> refcnt ) ; <S2SV_EndBug> if ( uref ) atomic_inc ( & map -> usercnt ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-200 static void usage ( const char * prog ) { fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank>[OPTION...]\\n" , prog ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-f,<S2SV_blank>--use-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>configuration<S2SV_blank>file\\n" ) ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-P,<S2SV_blank>--vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>VRRP<S2SV_blank>subsystem\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-C,<S2SV_blank>--check<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>Health-checker<S2SV_blank>subsystem\\n" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-B,<S2SV_blank>--no_bfd<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>run<S2SV_blank>BFD<S2SV_blank>subsystem\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--all<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Force<S2SV_blank>all<S2SV_blank>child<S2SV_blank>processes<S2SV_blank>to<S2SV_blank>run,<S2SV_blank>even<S2SV_blank>if<S2SV_blank>have<S2SV_blank>no<S2SV_blank>configuration\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-l,<S2SV_blank>--log-console<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>messages<S2SV_blank>to<S2SV_blank>local<S2SV_blank>console\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-D,<S2SV_blank>--log-detail<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Detailed<S2SV_blank>log<S2SV_blank>messages\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-S,<S2SV_blank>--log-facility=[0-7]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Set<S2SV_blank>syslog<S2SV_blank>facility<S2SV_blank>to<S2SV_blank>LOG_LOCAL[0-7]\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-g,<S2SV_blank>--log-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Also<S2SV_blank>log<S2SV_blank>to<S2SV_blank>FILE<S2SV_blank>(default<S2SV_blank>/tmp/keepalived.log)\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--flush-log-file<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flush<S2SV_blank>log<S2SV_blank>file<S2SV_blank>on<S2SV_blank>write\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n" ) ; <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> fprintf ( stderr , "<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-V,<S2SV_blank>--dont-release-vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>VRRP<S2SV_blank>VIPs<S2SV_blank>and<S2SV_blank>VROUTEs<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-I,<S2SV_blank>--dont-release-ipvs<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>IPVS<S2SV_blank>topology<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank>-R,<S2SV_blank>--dont-respawn<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>respawn<S2SV_blank>child<S2SV_blank>processes\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-n,<S2SV_blank>--dont-fork<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>fork<S2SV_blank>the<S2SV_blank>daemon<S2SV_blank>process\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--dump-conf<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Dump<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>data\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>process\\n" ) ; # ifdef _WITH_VRRP_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-r,<S2SV_blank>--vrrp_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>VRRP<S2SV_blank>child<S2SV_blank>process\\n" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-c,<S2SV_blank>--checkers_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>checkers<S2SV_blank>child<S2SV_blank>process\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-a,<S2SV_blank>--address-monitoring<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Report<S2SV_blank>all<S2SV_blank>address<S2SV_blank>additions/deletions<S2SV_blank>notified<S2SV_blank>via<S2SV_blank>netlink\\n" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-b,<S2SV_blank>--bfd_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>BFD<S2SV_blank>child<S2SV_blank>process\\n" ) ; # endif # ifdef _WITH_SNMP_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--snmp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>SNMP<S2SV_blank>subsystem\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-A,<S2SV_blank>--snmp-agent-socket=FILE<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>master<S2SV_blank>agent\\n" ) ; # endif # if HAVE_DECL_CLONE_NEWNET fprintf ( stderr , "<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--namespace=NAME<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Run<S2SV_blank>in<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>NAME<S2SV_blank>(overrides<S2SV_blank>config)\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank>-m,<S2SV_blank>--core-dump<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Produce<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>if<S2SV_blank>terminate<S2SV_blank>abnormally\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-M,<S2SV_blank>--core-dump-pattern=PATN<S2SV_blank>Also<S2SV_blank>set<S2SV_blank>/proc/sys/kernel/core_pattern<S2SV_blank>to<S2SV_blank>PATN<S2SV_blank>(default<S2SV_blank>\'core\')\\n" ) ; # ifdef _MEM_CHECK_LOG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank>-L,<S2SV_blank>--mem-check-log<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>malloc/frees<S2SV_blank>to<S2SV_blank>syslog\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank>-i,<S2SV_blank>--config-id<S2SV_blank>id<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Skip<S2SV_blank>any<S2SV_blank>configuration<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>\'@\'<S2SV_blank>that<S2SV_blank>don\'t<S2SV_blank>match<S2SV_blank>id\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>or<S2SV_blank>any<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>@^<S2SV_blank>that<S2SV_blank>do<S2SV_blank>match.\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>The<S2SV_blank>config-id<S2SV_blank>defaults<S2SV_blank>to<S2SV_blank>the<S2SV_blank>node<S2SV_blank>name<S2SV_blank>if<S2SV_blank>option<S2SV_blank>not<S2SV_blank>used\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--signum=SIGFUNC<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>signal<S2SV_blank>number<S2SV_blank>for<S2SV_blank>STOP,<S2SV_blank>RELOAD,<S2SV_blank>DATA,<S2SV_blank>STATS" # ifdef _WITH_JSON_ ",<S2SV_blank>JSON" # endif "\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-t,<S2SV_blank>--config-test[=LOG_FILE]<S2SV_blank>Check<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>for<S2SV_blank>obvious<S2SV_blank>errors,<S2SV_blank>output<S2SV_blank>to\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>stderr<S2SV_blank>by<S2SV_blank>default\\n" ) ; # ifdef _WITH_PERF_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--perf[=PERF_TYPE]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Collect<S2SV_blank>perf<S2SV_blank>data,<S2SV_blank>PERF_TYPE=all,<S2SV_blank>run(default)<S2SV_blank>or<S2SV_blank>end\\n" ) ; # endif # ifdef WITH_DEBUG_OPTIONS fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--debug[=...]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>debug<S2SV_blank>options.<S2SV_blank>p,<S2SV_blank>b,<S2SV_blank>c,<S2SV_blank>v<S2SV_blank>specify<S2SV_blank>parent,<S2SV_blank>bfd,<S2SV_blank>checker<S2SV_blank>and<S2SV_blank>vrrp<S2SV_blank>processes\\n" ) ; # ifdef _TIMER_CHECK_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T<S2SV_blank>-<S2SV_blank>timer<S2SV_blank>debug\\n" ) ; # endif # ifdef _SMTP_ALERT_DEBUG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>M<S2SV_blank>-<S2SV_blank>email<S2SV_blank>alert<S2SV_blank>debug\\n" ) ; # endif # ifdef _EPOLL_DEBUG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>E<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>debug\\n" ) ; # endif # ifdef _EPOLL_THREAD_DUMP_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>D<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>thread<S2SV_blank>dump<S2SV_blank>debug\\n" ) ; # endif # ifdef _VRRP_FD_DEBUG fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>F<S2SV_blank>-<S2SV_blank>vrrp<S2SV_blank>fd<S2SV_blank>dump<S2SV_blank>debug\\n" ) ; # endif # ifdef _REGEX_DEBUG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>debug\\n" ) ; # endif # ifdef _WITH_REGEX_TIMERS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>X<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>timers\\n" ) ; # endif # ifdef _TSM_DEBUG_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>S<S2SV_blank>-<S2SV_blank>TSM<S2SV_blank>debug\\n" ) ; # endif # ifdef _NETLINK_TIMERS_ fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>N<S2SV_blank>-<S2SV_blank>netlink<S2SV_blank>timer<S2SV_blank>debug\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Example<S2SV_blank>--debug=TpMEvcp\\n" ) ; # endif fprintf ( stderr , "<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>the<S2SV_blank>version<S2SV_blank>number\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-h,<S2SV_blank>--help<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>this<S2SV_blank>help<S2SV_blank>message\\n" ) ; }
CWE-119 static void record_recent_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , <S2SV_EndBug> void * data ) { sha1_array_append ( & recent_objects , obj -> oid . hash ) ; }
CWE-119 void test_base64_decode ( void ) { char buffer [ 16 ] ; <S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , sizeof ( clear ) - 1 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , len ) ; } buffer [ len ] = '\\0' ; if ( ! TEST_CHECK ( strcmp ( buffer , clear ) == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%s" , clear ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s" , buffer ) ; } }
CWE-264 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! ip6_checkentry ( & e -> ipv6 ) ) return - EINVAL ; <S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-119 static __u8 * ch_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <S2SV_EndBug> hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Cherry<S2SV_blank>Cymotion<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc [ 11 ] = rdesc [ 16 ] = 0xff ; rdesc [ 12 ] = rdesc [ 17 ] = 0x03 ; } return rdesc ; }
CWE-284 static void btsnoop_write ( const void * data , size_t length ) { if ( logfile_fd != INVALID_FD ) <S2SV_StartBug> write ( logfile_fd , data , length ) ; <S2SV_EndBug> btsnoop_net_write ( data , length ) ; }
CWE-119 static void update_mbgraph_frame_stats ( VP9_COMP * cpi , MBGRAPH_FRAME_STATS * stats , YV12_BUFFER_CONFIG * buf , YV12_BUFFER_CONFIG * golden_ref , YV12_BUFFER_CONFIG * alt_ref ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; VP9_COMMON * const cm = & cpi -> common ; int mb_col , mb_row , offset = 0 ; int mb_y_offset = 0 , arf_y_offset = 0 , gld_y_offset = 0 ; <S2SV_StartBug> int_mv arf_top_mv , gld_top_mv ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO mi_local = { { 0 } } ; <S2SV_EndBug> arf_top_mv . as_int = 0 ; gld_top_mv . as_int = 0 ; x -> mv_row_min = - BORDER_MV_PIXELS_B16 ; x -> mv_row_max = ( cm -> mb_rows - 1 ) * 8 + BORDER_MV_PIXELS_B16 ; xd -> up_available = 0 ; xd -> plane [ 0 ] . dst . stride = buf -> y_stride ; xd -> plane [ 0 ] . pre [ 0 ] . stride = buf -> y_stride ; xd -> plane [ 1 ] . dst . stride = buf -> uv_stride ; xd -> mi [ 0 ] = & mi_local ; mi_local . mbmi . sb_type = BLOCK_16X16 ; mi_local . mbmi . ref_frame [ 0 ] = LAST_FRAME ; mi_local . mbmi . ref_frame [ 1 ] = NONE ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { <S2SV_StartBug> int_mv arf_left_mv , gld_left_mv ; <S2SV_EndBug> int mb_y_in_offset = mb_y_offset ; int arf_y_in_offset = arf_y_offset ; <S2SV_StartBug> int gld_y_in_offset = gld_y_offset ; <S2SV_EndBug> arf_left_mv . as_int = arf_top_mv . as_int ; gld_left_mv . as_int = gld_top_mv . as_int ; x -> mv_col_min = - BORDER_MV_PIXELS_B16 ; x -> mv_col_max = ( cm -> mb_cols - 1 ) * 8 + BORDER_MV_PIXELS_B16 ; xd -> left_available = 0 ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { MBGRAPH_MB_STATS * mb_stats = & stats -> mb_stats [ offset + mb_col ] ; update_mbgraph_mb_stats ( cpi , mb_stats , buf , mb_y_in_offset , golden_ref , & gld_left_mv , alt_ref , mb_row , mb_col ) ; <S2SV_StartBug> arf_left_mv . as_int = mb_stats -> ref [ ALTREF_FRAME ] . m . mv . as_int ; <S2SV_EndBug> gld_left_mv . as_int = mb_stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int ; if ( mb_col == 0 ) { arf_top_mv . as_int = arf_left_mv . as_int ; gld_top_mv . as_int = gld_left_mv . as_int ; } xd -> left_available = 1 ; mb_y_in_offset += 16 ; gld_y_in_offset += 16 ; arf_y_in_offset += 16 ; x -> mv_col_min -= 16 ; x -> mv_col_max -= 16 ; } xd -> up_available = 1 ; mb_y_offset += buf -> y_stride * 16 ; gld_y_offset += golden_ref -> y_stride * 16 ; if ( alt_ref ) arf_y_offset += alt_ref -> y_stride * 16 ; x -> mv_row_min -= 16 ; x -> mv_row_max -= 16 ; offset += cm -> mb_cols ; } }
CWE-362 static void sctp_close ( struct sock * sk , long timeout ) { struct net * net = sock_net ( sk ) ; struct sctp_endpoint * ep ; struct sctp_association * asoc ; struct list_head * pos , * temp ; unsigned int data_was_unread ; pr_debug ( "%s:<S2SV_blank>sk:%p,<S2SV_blank>timeout:%ld\\n" , __func__ , sk , timeout ) ; lock_sock ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; sk -> sk_state = SCTP_SS_CLOSING ; ep = sctp_sk ( sk ) -> ep ; data_was_unread = sctp_queue_purge_ulpevents ( & sk -> sk_receive_queue ) ; data_was_unread += sctp_queue_purge_ulpevents ( & sctp_sk ( sk ) -> pd_lobby ) ; list_for_each_safe ( pos , temp , & ep -> asocs ) { asoc = list_entry ( pos , struct sctp_association , asocs ) ; if ( sctp_style ( sk , TCP ) ) { if ( sctp_state ( asoc , CLOSED ) ) { sctp_unhash_established ( asoc ) ; sctp_association_free ( asoc ) ; continue ; } } if ( data_was_unread || ! skb_queue_empty ( & asoc -> ulpq . lobby ) || ! skb_queue_empty ( & asoc -> ulpq . reasm ) || ( sock_flag ( sk , SOCK_LINGER ) && ! sk -> sk_lingertime ) ) { struct sctp_chunk * chunk ; chunk = sctp_make_abort_user ( asoc , NULL , 0 ) ; if ( chunk ) sctp_primitive_ABORT ( net , asoc , chunk ) ; } else sctp_primitive_SHUTDOWN ( net , asoc , NULL ) ; } if ( sctp_style ( sk , TCP ) && timeout ) sctp_wait_for_close ( sk , timeout ) ; release_sock ( sk ) ; <S2SV_StartBug> local_bh_disable ( ) ; <S2SV_EndBug> bh_lock_sock ( sk ) ; sock_hold ( sk ) ; sk_common_release ( sk ) ; bh_unlock_sock ( sk ) ; <S2SV_StartBug> local_bh_enable ( ) ; <S2SV_EndBug> sock_put ( sk ) ; SCTP_DBG_OBJCNT_DEC ( sock ) ; }
CWE-399 static int choose_filters ( struct archive_read * a ) { <S2SV_StartBug> int number_bidders , i , bid , best_bid ; <S2SV_EndBug> struct archive_read_filter_bidder * bidder , * best_bidder ; struct archive_read_filter * filter ; ssize_t avail ; int r ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ; best_bid = 0 ; best_bidder = NULL ; bidder = a -> bidders ; for ( i = 0 ; i < number_bidders ; i ++ , bidder ++ ) { if ( bidder -> bid != NULL ) { bid = ( bidder -> bid ) ( bidder , a -> filter ) ; if ( bid > best_bid ) { best_bid = bid ; best_bidder = bidder ; } } } if ( best_bidder == NULL ) { __archive_read_filter_ahead ( a -> filter , 1 , & avail ) ; if ( avail < 0 ) { __archive_read_close_filters ( a ) ; __archive_read_free_filters ( a ) ; return ( ARCHIVE_FATAL ) ; } a -> archive . compression_name = a -> filter -> name ; a -> archive . compression_code = a -> filter -> code ; return ( ARCHIVE_OK ) ; } filter = ( struct archive_read_filter * ) calloc ( 1 , sizeof ( * filter ) ) ; if ( filter == NULL ) return ( ARCHIVE_FATAL ) ; filter -> bidder = best_bidder ; filter -> archive = a ; filter -> upstream = a -> filter ; a -> filter = filter ; r = ( best_bidder -> init ) ( a -> filter ) ; if ( r != ARCHIVE_OK ) { __archive_read_close_filters ( a ) ; __archive_read_free_filters ( a ) ; return ( ARCHIVE_FATAL ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 <S2SV_StartBug> void fdct16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> fdct16_8col ( in0 ) ; fdct16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }
CWE-476 static int mpeg4video_probe ( AVProbeData * probe_packet ) { uint32_t temp_buffer = - 1 ; int VO = 0 , VOL = 0 , VOP = 0 , VISO = 0 , res = 0 ; int i ; for ( i = 0 ; i < probe_packet -> buf_size ; i ++ ) { temp_buffer = ( temp_buffer << 8 ) + probe_packet -> buf [ i ] ; <S2SV_StartBug> if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) <S2SV_EndBug> continue ; if ( temp_buffer == VOP_START_CODE ) VOP ++ ; else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ; <S2SV_StartBug> else if ( temp_buffer < 0x120 ) <S2SV_EndBug> VO ++ ; <S2SV_StartBug> else if ( temp_buffer < 0x130 ) <S2SV_EndBug> VOL ++ ; else if ( ! ( 0x1AF < temp_buffer && temp_buffer < 0x1B7 ) && ! ( 0x1B9 < temp_buffer && temp_buffer < 0x1C4 ) ) res ++ ; } if ( VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0 ) return AVPROBE_SCORE_EXTENSION ; return 0 ; }
CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ; # endif } }
CWE-20 int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
CWE-20 static MagickBooleanType ReadDXT3 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; ssize_t j , y ; PixelPacket * q ; register ssize_t i , x ; unsigned char alpha ; size_t a0 , a1 , bits , code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; a0 = ReadBlobLSBLong ( image ) ; a1 = ReadBlobLSBLong ( image ) ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickTrue ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( bits >> ( ( 4 * j + i ) * 2 ) ) & 0x3 ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; if ( j < 2 ) alpha = 17U * ( unsigned char ) ( ( a0 >> ( 4 * ( 4 * j + i ) ) ) & 0xf ) ; else alpha = 17U * ( unsigned char ) ( ( a1 >> ( 4 * ( 4 * ( j - 2 ) + i ) ) ) & 0xf ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) alpha ) ) ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug> return MagickTrue ; }
CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) { <S2SV_EndBug> <S2SV_StartBug> return ( MB_PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ; <S2SV_EndBug> }
CWE-119 void vp8_copy_mem8x8_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 8 ; r ++ ) { <S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; # else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; # endif src += src_stride ; dst += dst_stride ; } }
CWE-119 static vpx_codec_err_t ctrl_set_roi_map ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> return VPX_CODEC_INVALID_PARAM ; }
CWE-000 static void bgp_packet_mpattr_tea ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , uint8_t attrtype ) { unsigned int attrlenfield = 0 ; unsigned int attrhdrlen = 0 ; struct bgp_attr_encap_subtlv * subtlvs ; struct bgp_attr_encap_subtlv * st ; const char * attrname ; if ( ! attr || ( attrtype == BGP_ATTR_ENCAP && ( ! attr -> encap_tunneltype || attr -> encap_tunneltype == BGP_ENCAP_TYPE_MPLS ) ) ) return ; switch ( attrtype ) { case BGP_ATTR_ENCAP : attrname = "Tunnel<S2SV_blank>Encap" ; subtlvs = attr -> encap_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 2 + 2 ; attrhdrlen = 1 + 1 ; break ; <S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> case BGP_ATTR_VNC : attrname = "VNC" ; subtlvs = attr -> vnc_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 0 ; attrhdrlen = 2 + 2 ; break ; # endif default : assert ( 0 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { attrlenfield += ( attrhdrlen + st -> length ) ; } if ( attrlenfield > 0xffff ) { zlog_info ( "%s<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(length=%d),<S2SV_blank>can\'t<S2SV_blank>send<S2SV_blank>it" , attrname , attrlenfield ) ; return ; } if ( attrlenfield > 0xff ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , attrtype ) ; stream_putw ( s , attrlenfield & 0xffff ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , attrtype ) ; stream_putc ( s , attrlenfield & 0xff ) ; } if ( attrtype == BGP_ATTR_ENCAP ) { stream_putw ( s , attr -> encap_tunneltype ) ; stream_putw ( s , attrlenfield - 4 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { if ( attrtype == BGP_ATTR_ENCAP ) { stream_putc ( s , st -> type ) ; stream_putc ( s , st -> length ) ; # if ENABLE_BGP_VNC } else { stream_putw ( s , st -> type ) ; stream_putw ( s , st -> length ) ; # endif } stream_put ( s , st -> value , st -> length ) ; } }
CWE-119 static int rtmp_packet_read_one_chunk ( URLContext * h , RTMPPacket * p , int chunk_size , RTMPPacket * * prev_pkt_ptr , int * nb_prev_pkt , uint8_t hdr ) { uint8_t buf [ 16 ] ; int channel_id , timestamp , size ; uint32_t ts_field ; uint32_t extra = 0 ; enum RTMPPacketType type ; int written = 0 ; int ret , toread ; RTMPPacket * prev_pkt ; written ++ ; channel_id = hdr & 0x3F ; if ( channel_id < 2 ) { buf [ 1 ] = 0 ; if ( ffurl_read_complete ( h , buf , channel_id + 1 ) != channel_id + 1 ) return AVERROR ( EIO ) ; written += channel_id + 1 ; channel_id = AV_RL16 ( buf ) + 64 ; } if ( ( ret = ff_rtmp_check_alloc_array ( prev_pkt_ptr , nb_prev_pkt , channel_id ) ) < 0 ) return ret ; prev_pkt = * prev_pkt_ptr ; size = prev_pkt [ channel_id ] . size ; type = prev_pkt [ channel_id ] . type ; extra = prev_pkt [ channel_id ] . extra ; hdr >>= 6 ; if ( hdr == RTMP_PS_ONEBYTE ) { ts_field = prev_pkt [ channel_id ] . ts_field ; } else { if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) return AVERROR ( EIO ) ; written += 3 ; ts_field = AV_RB24 ( buf ) ; if ( hdr != RTMP_PS_FOURBYTES ) { if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) return AVERROR ( EIO ) ; written += 3 ; size = AV_RB24 ( buf ) ; if ( ffurl_read_complete ( h , buf , 1 ) != 1 ) return AVERROR ( EIO ) ; written ++ ; type = buf [ 0 ] ; if ( hdr == RTMP_PS_TWELVEBYTES ) { if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) return AVERROR ( EIO ) ; written += 4 ; extra = AV_RL32 ( buf ) ; } } } if ( ts_field == 0xFFFFFF ) { if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) return AVERROR ( EIO ) ; timestamp = AV_RB32 ( buf ) ; } else { timestamp = ts_field ; } if ( hdr != RTMP_PS_TWELVEBYTES ) timestamp += prev_pkt [ channel_id ] . timestamp ; <S2SV_StartBug> if ( ! prev_pkt [ channel_id ] . read ) { <S2SV_EndBug> if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , size ) ) < 0 ) return ret ; p -> read = written ; p -> offset = 0 ; prev_pkt [ channel_id ] . ts_field = ts_field ; prev_pkt [ channel_id ] . timestamp = timestamp ; } else { RTMPPacket * prev = & prev_pkt [ channel_id ] ; p -> data = prev -> data ; p -> size = prev -> size ; p -> channel_id = prev -> channel_id ; p -> type = prev -> type ; p -> ts_field = prev -> ts_field ; p -> extra = prev -> extra ; p -> offset = prev -> offset ; p -> read = prev -> read + written ; p -> timestamp = prev -> timestamp ; prev -> data = NULL ; } p -> extra = extra ; prev_pkt [ channel_id ] . channel_id = channel_id ; prev_pkt [ channel_id ] . type = type ; prev_pkt [ channel_id ] . size = size ; prev_pkt [ channel_id ] . extra = extra ; size = size - p -> offset ; toread = FFMIN ( size , chunk_size ) ; if ( ffurl_read_complete ( h , p -> data + p -> offset , toread ) != toread ) { ff_rtmp_packet_destroy ( p ) ; return AVERROR ( EIO ) ; } size -= toread ; p -> read += toread ; p -> offset += toread ; if ( size > 0 ) { RTMPPacket * prev = & prev_pkt [ channel_id ] ; prev -> data = p -> data ; prev -> read = p -> read ; prev -> offset = p -> offset ; p -> data = NULL ; return AVERROR ( EAGAIN ) ; } prev_pkt [ channel_id ] . read = 0 ; return p -> read ; }
CWE-399 static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } if ( fault & VM_FAULT_RETRY ) { flags &= ~ FAULT_FLAG_ALLOW_RETRY ; goto retry ; } } clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }
CWE-190 <S2SV_StartBug> static int getnum ( lua_State * L , const char * * fmt , int df ) { <S2SV_EndBug> if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; do { <S2SV_StartBug> if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) <S2SV_EndBug> luaL_error ( L , "integral<S2SV_blank>size<S2SV_blank>overflow" ) ; a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }
CWE-399 int hugepage_madvise ( struct vm_area_struct * vma , unsigned long * vm_flags , int advice ) { switch ( advice ) { case MADV_HUGEPAGE : if ( * vm_flags & ( VM_HUGEPAGE | <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ; * vm_flags &= ~ VM_NOHUGEPAGE ; * vm_flags |= VM_HUGEPAGE ; if ( unlikely ( khugepaged_enter_vma_merge ( vma ) ) ) return - ENOMEM ; break ; case MADV_NOHUGEPAGE : if ( * vm_flags & ( VM_NOHUGEPAGE | <S2SV_StartBug> VM_SHARED | VM_MAYSHARE | <S2SV_EndBug> VM_PFNMAP | VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | VM_MIXEDMAP | VM_SAO ) ) return - EINVAL ; * vm_flags &= ~ VM_HUGEPAGE ; * vm_flags |= VM_NOHUGEPAGE ; break ; } return 0 ; }
CWE-119 static void fill_variance ( int64_t s2 , int64_t s , int c , var * v ) { v -> sum_square_error = s2 ; v -> sum_error = s ; <S2SV_StartBug> v -> count = c ; <S2SV_EndBug> <S2SV_StartBug> if ( c > 0 ) <S2SV_EndBug> v -> variance = ( int ) ( 256 * ( v -> sum_square_error - v -> sum_error * v -> sum_error / v -> count ) / v -> count ) ; else v -> variance = 0 ; }
CWE-200 static void on_page_prepare ( GtkNotebook * assistant , GtkWidget * page , gpointer user_data ) { if ( ! is_processing_finished ( ) ) { show_next_step_button ( ) ; clear_warnings ( ) ; } gtk_widget_hide ( g_btn_detail ) ; gtk_widget_hide ( g_btn_onfail ) ; if ( ! g_expert_mode ) gtk_widget_hide ( g_btn_repeat ) ; save_items_from_notepad ( ) ; <S2SV_StartBug> save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; <S2SV_EndBug> if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) { if ( ! g_expert_mode ) { int n = select_next_page_no ( pages [ PAGENO_SUMMARY ] . page_no , NULL ) ; log_info ( "switching<S2SV_blank>to<S2SV_blank>page_no:%d" , n ) ; gtk_notebook_set_current_page ( assistant , n ) ; return ; } } if ( pages [ PAGENO_EDIT_ELEMENTS ] . page_widget == page ) { if ( highlight_forbidden ( ) ) { add_sensitive_data_warning ( ) ; show_warnings ( ) ; gtk_expander_set_expanded ( g_exp_search , TRUE ) ; } else gtk_toggle_button_set_active ( GTK_TOGGLE_BUTTON ( g_rb_custom_search ) , TRUE ) ; show_warnings ( ) ; } if ( pages [ PAGENO_REVIEW_DATA ] . page_widget == page ) { update_ls_details_checkboxes ( g_event_selected ) ; gtk_widget_set_sensitive ( g_btn_next , gtk_toggle_button_get_active ( g_tb_approve_bt ) ) ; } if ( pages [ PAGENO_EDIT_COMMENT ] . page_widget == page ) { gtk_widget_show ( g_btn_detail ) ; gtk_widget_set_sensitive ( g_btn_next , false ) ; on_comment_changed ( gtk_text_view_get_buffer ( g_tv_comment ) , NULL ) ; } if ( pages [ PAGENO_EVENT_PROGRESS ] . page_widget == page ) { log_info ( "g_event_selected:\'%s\'" , g_event_selected ) ; if ( g_event_selected && g_event_selected [ 0 ] ) { clear_warnings ( ) ; start_event_run ( g_event_selected ) ; } } if ( pages [ PAGENO_EVENT_SELECTOR ] . page_widget == page ) { if ( ! g_expert_mode && ! g_auto_event_list ) hide_next_step_button ( ) ; } }
CWE-200 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( "size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n" , size , msg_flags , timeo ) ; <S2SV_EndBug> if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( "recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( "copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
CWE-416 static void fanout_release ( struct sock * sk ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f ; <S2SV_StartBug> f = po -> fanout ; <S2SV_EndBug> <S2SV_StartBug> if ( ! f ) <S2SV_EndBug> return ; mutex_lock ( & fanout_mutex ) ; po -> fanout = NULL ; if ( atomic_dec_and_test ( & f -> sk_ref ) ) { list_del ( & f -> list ) ; dev_remove_pack ( & f -> prot_hook ) ; fanout_release_data ( f ) ; kfree ( f ) ; } <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static struct sock * unix_create1 ( struct net * net , struct socket * sock , int kern ) { struct sock * sk = NULL ; struct unix_sock * u ; atomic_long_inc ( & unix_nr_socks ) ; if ( atomic_long_read ( & unix_nr_socks ) > 2 * get_max_files ( ) ) goto out ; sk = sk_alloc ( net , PF_UNIX , GFP_KERNEL , & unix_proto , kern ) ; if ( ! sk ) goto out ; sock_init_data ( sock , sk ) ; lockdep_set_class ( & sk -> sk_receive_queue . lock , & af_unix_sk_receive_queue_lock_key ) ; sk -> sk_write_space = unix_write_space ; sk -> sk_max_ack_backlog = net -> unx . sysctl_max_dgram_qlen ; sk -> sk_destruct = unix_sock_destructor ; u = unix_sk ( sk ) ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; spin_lock_init ( & u -> lock ) ; atomic_long_set ( & u -> inflight , 0 ) ; INIT_LIST_HEAD ( & u -> link ) ; mutex_init ( & u -> readlock ) ; init_waitqueue_head ( & u -> peer_wait ) ; <S2SV_StartBug> unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ; <S2SV_EndBug> out : if ( sk == NULL ) atomic_long_dec ( & unix_nr_socks ) ; else { local_bh_disable ( ) ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , 1 ) ; local_bh_enable ( ) ; } return sk ; }
CWE-119 void vp9_rc_get_one_pass_vbr_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; int target ; if ( ! cpi -> refresh_alt_ref_frame && ( cm -> current_video_frame == 0 || <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> rc -> frames_to_key == 0 || <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> cm -> frame_type = KEY_FRAME ; rc -> this_key_frame_forced = cm -> current_video_frame != 0 && rc -> frames_to_key == 0 ; <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> rc -> kf_boost = DEFAULT_KF_BOOST ; rc -> source_alt_ref_active = 0 ; } else { cm -> frame_type = INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { <S2SV_StartBug> rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; <S2SV_EndBug> rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) <S2SV_StartBug> rc -> frames_till_gf_update_due = rc -> frames_to_key ; <S2SV_EndBug> cpi -> refresh_golden_frame = 1 ; rc -> source_alt_ref_pending = USE_ALTREF_FOR_ONE_PASS ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_vbr ( cpi ) ; else target = calc_pframe_target_size_one_pass_vbr ( cpi ) ; vp9_rc_set_frame_target ( cpi , target ) ; }
CWE-200 int check_user_token ( const char * authfile , const char * username , const char * otp_id , int verbose , FILE * debug_file ) { char buf [ 1024 ] ; char * s_user , * s_token ; int retval = AUTH_ERROR ; int fd ; struct stat st ; FILE * opwfile ; fd = open ( authfile , O_RDONLY , 0 ) ; if ( fd < 0 ) { if ( verbose ) D ( debug_file , "Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; return retval ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , "Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; close ( fd ) ; return retval ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file" , authfile ) ; close ( fd ) ; return retval ; } opwfile = fdopen ( fd , "r" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , "fdopen:<S2SV_blank>%s" , strerror ( errno ) ) ; close ( fd ) ; return retval ; } retval = AUTH_NO_TOKENS ; while ( fgets ( buf , 1024 , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( buf [ 0 ] == '#' ) { if ( verbose ) D ( debug_file , "Skipping<S2SV_blank>comment<S2SV_blank>line:<S2SV_blank>%s" , buf ) ; continue ; } if ( verbose ) D ( debug_file , "Authorization<S2SV_blank>line:<S2SV_blank>%s" , buf ) ; s_user = strtok_r ( buf , ":" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , "Matched<S2SV_blank>user:<S2SV_blank>%s" , s_user ) ; retval = AUTH_NOT_FOUND ; do { s_token = strtok_r ( NULL , ":" , & saveptr ) ; if ( verbose ) D ( debug_file , "Authorization<S2SV_blank>token:<S2SV_blank>%s" , s_token ) ; if ( s_token && otp_id && strcmp ( otp_id , s_token ) == 0 ) { if ( verbose ) D ( debug_file , "Match<S2SV_blank>user/token<S2SV_blank>as<S2SV_blank>%s/%s" , username , otp_id ) ; <S2SV_StartBug> return AUTH_FOUND ; <S2SV_EndBug> } } while ( s_token != NULL ) ; } } fclose ( opwfile ) ; return retval ; }
CWE-000 int ASN1_verify ( i2d_of_void * i2d , X509_ALGOR * a , ASN1_BIT_STRING * signature , char * data , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; const EVP_MD * type ; unsigned char * p , * buf_in = NULL ; int ret = - 1 , i , inl ; EVP_MD_CTX_init ( & ctx ) ; i = OBJ_obj2nid ( a -> algorithm ) ; type = EVP_get_digestbyname ( OBJ_nid2sn ( i ) ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } <S2SV_StartBug> inl = i2d ( data , NULL ) ; <S2SV_EndBug> buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } p = buf_in ; i2d ( data , & p ) ; ret = EVP_VerifyInit_ex ( & ctx , type , NULL ) && EVP_VerifyUpdate ( & ctx , ( unsigned char * ) buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_VerifyFinal ( & ctx , ( unsigned char * ) signature -> data , ( unsigned int ) signature -> length , pkey ) <= 0 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }
CWE-119 void vp9_remove_common ( VP9_COMMON * cm ) { <S2SV_StartBug> vp9_free_frame_buffers ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_free_internal_frame_buffers ( & cm -> int_frame_buffers ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static void encode_term_subexp ( vp9_writer * w , int word ) { <S2SV_EndBug> if ( ! write_bit_gte ( w , word , 16 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word , 4 ) ; <S2SV_EndBug> } else if ( ! write_bit_gte ( w , word , 32 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word - 16 , 4 ) ; <S2SV_EndBug> } else if ( ! write_bit_gte ( w , word , 64 ) ) { <S2SV_StartBug> vp9_write_literal ( w , word - 32 , 5 ) ; <S2SV_EndBug> } else { encode_uniform ( w , word - 64 ) ; } }
CWE-264 asmlinkage long sys_oabi_fcntl64 ( unsigned int fd , unsigned int cmd , unsigned long arg ) { <S2SV_StartBug> struct oabi_flock64 user ; <S2SV_EndBug> struct flock64 kernel ; mm_segment_t fs = USER_DS ; unsigned long local_arg = arg ; int ret ; switch ( cmd ) { case F_OFD_GETLK : case F_OFD_SETLK : case F_OFD_SETLKW : case F_GETLK64 : case F_SETLK64 : case F_SETLKW64 : <S2SV_StartBug> if ( copy_from_user ( & user , ( struct oabi_flock64 __user * ) arg , <S2SV_EndBug> sizeof ( user ) ) ) return - EFAULT ; kernel . l_type = user . l_type ; kernel . l_whence = user . l_whence ; kernel . l_start = user . l_start ; kernel . l_len = user . l_len ; kernel . l_pid = user . l_pid ; local_arg = ( unsigned long ) & kernel ; fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; } <S2SV_StartBug> ret = sys_fcntl64 ( fd , cmd , local_arg ) ; <S2SV_EndBug> switch ( cmd ) { case F_GETLK64 : if ( ! ret ) { user . l_type = kernel . l_type ; user . l_whence = kernel . l_whence ; user . l_start = kernel . l_start ; user . l_len = kernel . l_len ; user . l_pid = kernel . l_pid ; if ( copy_to_user ( ( struct oabi_flock64 __user * ) arg , & user , sizeof ( user ) ) ) ret = - EFAULT ; } case F_SETLK64 : case F_SETLKW64 : set_fs ( fs ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-119 static INLINE int get_tx_eob ( const struct segmentation * seg , int segment_id , TX_SIZE tx_size ) { const int eob_max = 16 << ( tx_size << 1 ) ; <S2SV_StartBug> return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ; <S2SV_EndBug> }
CWE-362 void sctp_generate_proto_unreach_event ( unsigned long data ) { struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( "%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n" , __func__ ) ; if ( ! mod_timer ( & transport -> proto_unreach_timer , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; sctp_do_sm ( net , SCTP_EVENT_T_OTHER , SCTP_ST_OTHER ( SCTP_EVENT_ICMP_PROTO_UNREACH ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_association_put ( asoc ) ; }
CWE-476 key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) { struct keyring_index_key index_key = { . description = description , } ; struct key_preparsed_payload prep ; struct assoc_array_edit * edit ; const struct cred * cred = current_cred ( ) ; struct key * keyring , * key = NULL ; key_ref_t key_ref ; int ret ; index_key . type = key_type_lookup ( type ) ; if ( IS_ERR ( index_key . type ) ) { key_ref = ERR_PTR ( - ENODEV ) ; goto error ; } key_ref = ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <S2SV_EndBug> ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ; keyring = key_ref_to_ptr ( keyring_ref ) ; key_check ( keyring ) ; key_ref = ERR_PTR ( - ENOTDIR ) ; if ( keyring -> type != & key_type_keyring ) goto error_put_type ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = index_key . type -> def_datalen ; prep . trusted = flags & KEY_ALLOC_TRUSTED ; prep . expiry = TIME_T_MAX ; if ( index_key . type -> preparse ) { ret = index_key . type -> preparse ( & prep ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } if ( ! index_key . description ) index_key . description = prep . description ; key_ref = ERR_PTR ( - EINVAL ) ; if ( ! index_key . description ) goto error_free_prep ; } index_key . desc_len = strlen ( index_key . description ) ; key_ref = ERR_PTR ( - EPERM ) ; if ( ! prep . trusted && test_bit ( KEY_FLAG_TRUSTED_ONLY , & keyring -> flags ) ) goto error_free_prep ; flags |= prep . trusted ? KEY_ALLOC_TRUSTED : 0 ; ret = __key_link_begin ( keyring , & index_key , & edit ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } ret = key_permission ( keyring_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } if ( index_key . type -> update ) { key_ref = find_key_to_update ( keyring_ref , & index_key ) ; if ( key_ref ) goto found_matching_key ; } if ( perm == KEY_PERM_UNDEF ) { perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR ; perm |= KEY_USR_VIEW ; if ( index_key . type -> read ) perm |= KEY_POS_READ ; if ( index_key . type == & key_type_keyring || index_key . type -> update ) perm |= KEY_POS_WRITE ; } key = key_alloc ( index_key . type , index_key . description , cred -> fsuid , cred -> fsgid , cred , perm , flags ) ; if ( IS_ERR ( key ) ) { key_ref = ERR_CAST ( key ) ; goto error_link_end ; } ret = __key_instantiate_and_link ( key , & prep , keyring , NULL , & edit ) ; if ( ret < 0 ) { key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } key_ref = make_key_ref ( key , is_key_possessed ( keyring_ref ) ) ; error_link_end : __key_link_end ( keyring , & index_key , edit ) ; error_free_prep : if ( index_key . type -> preparse ) index_key . type -> free_preparse ( & prep ) ; error_put_type : key_type_put ( index_key . type ) ; error : return key_ref ; found_matching_key : __key_link_end ( keyring , & index_key , edit ) ; key_ref = __key_update ( key_ref , & prep ) ; goto error_free_prep ; }
CWE-119 static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , <S2SV_EndBug> va_list args ) { <S2SV_StartBug> vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ; <S2SV_EndBug> if ( init ) { ctx -> decrypt_cb = init -> decrypt_cb ; ctx -> decrypt_state = init -> decrypt_state ; } else { ctx -> decrypt_cb = NULL ; ctx -> decrypt_state = NULL ; } return VPX_CODEC_OK ; }
CWE-000 char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ; <S2SV_StartBug> int strindex = 0 ; <S2SV_EndBug> size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , "%%%02X" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }
CWE-000 static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }
CWE-284 static int adev_open_output_stream ( struct audio_hw_device * dev , audio_io_handle_t handle , audio_devices_t devices , audio_output_flags_t flags , struct audio_config * config , struct audio_stream_out * * stream_out , const char * address ) { struct a2dp_audio_device * a2dp_dev = ( struct a2dp_audio_device * ) dev ; struct a2dp_stream_out * out ; int ret = 0 ; int i ; UNUSED ( address ) ; UNUSED ( handle ) ; UNUSED ( devices ) ; UNUSED ( flags ) ; INFO ( "opening<S2SV_blank>output" ) ; out = ( struct a2dp_stream_out * ) calloc ( 1 , sizeof ( struct a2dp_stream_out ) ) ; if ( ! out ) return - ENOMEM ; out -> stream . common . get_sample_rate = out_get_sample_rate ; out -> stream . common . set_sample_rate = out_set_sample_rate ; out -> stream . common . get_buffer_size = out_get_buffer_size ; out -> stream . common . get_channels = out_get_channels ; out -> stream . common . get_format = out_get_format ; out -> stream . common . set_format = out_set_format ; out -> stream . common . standby = out_standby ; out -> stream . common . dump = out_dump ; out -> stream . common . set_parameters = out_set_parameters ; out -> stream . common . get_parameters = out_get_parameters ; out -> stream . common . add_audio_effect = out_add_audio_effect ; out -> stream . common . remove_audio_effect = out_remove_audio_effect ; out -> stream . get_latency = out_get_latency ; out -> stream . set_volume = out_set_volume ; out -> stream . write = out_write ; out -> stream . get_render_position = out_get_render_position ; out -> stream . get_presentation_position = out_get_presentation_position ; a2dp_stream_common_init ( & out -> common ) ; out -> common . cfg . channel_flags = AUDIO_STREAM_DEFAULT_CHANNEL_FLAG ; out -> common . cfg . format = AUDIO_STREAM_DEFAULT_FORMAT ; out -> common . cfg . rate = AUDIO_STREAM_DEFAULT_RATE ; if ( config ) { config -> format = out_get_format ( ( const struct audio_stream * ) & out -> stream ) ; config -> sample_rate = out_get_sample_rate ( ( const struct audio_stream * ) & out -> stream ) ; config -> channel_mask = out_get_channels ( ( const struct audio_stream * ) & out -> stream ) ; } * stream_out = & out -> stream ; a2dp_dev -> output = out ; a2dp_open_ctrl_path ( & out -> common ) ; if ( out -> common . ctrl_fd == AUDIO_SKT_DISCONNECTED ) { ERROR ( "ctrl<S2SV_blank>socket<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>(%s)" , strerror ( errno ) ) ; ret = - 1 ; goto err_open ; } DEBUG ( "success" ) ; <S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> return 0 ; err_open : free ( out ) ; * stream_out = NULL ; a2dp_dev -> output = NULL ; ERROR ( "failed" ) ; return ret ; }
CWE-119 static int gemsafe_get_cert_len ( sc_card_t * card ) { int r ; u8 ibuf [ GEMSAFE_MAX_OBJLEN ] ; u8 * iptr ; struct sc_path path ; struct sc_file * file ; size_t objlen , certlen ; unsigned int ind , i = 0 ; sc_format_path ( GEMSAFE_PATH , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r != SC_SUCCESS || ! file ) return SC_ERROR_INTERNAL ; r = sc_read_binary ( card , 0 , ibuf , GEMSAFE_READ_QUANTUM , 0 ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; objlen = ( ( ( size_t ) ibuf [ 0 ] ) << 8 ) | ibuf [ 1 ] ; sc_log ( card -> ctx , "Stored<S2SV_blank>object<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , objlen ) ; if ( objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN ) { sc_log ( card -> ctx , "Invalid<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , objlen ) ; return SC_ERROR_INTERNAL ; } ind = 2 ; <S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> if ( ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log ( card -> ctx , "Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>allocated<S2SV_blank>and<S2SV_blank>uses<S2SV_blank>key_ref<S2SV_blank>%d" , i + 1 , gemsafe_prkeys [ i ] . ref ) ; ind += 9 ; } else { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; sc_log ( card -> ctx , "Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unallocated" , i + 1 ) ; ind += 8 ; } i ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } iptr = ibuf + GEMSAFE_READ_QUANTUM ; while ( ( size_t ) ( iptr - ibuf ) < objlen ) { r = sc_read_binary ( card , iptr - ibuf , iptr , MIN ( GEMSAFE_READ_QUANTUM , objlen - ( iptr - ibuf ) ) , 0 ) ; if ( r < 0 ) { sc_log ( card -> ctx , "Could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>cert<S2SV_blank>object" ) ; return SC_ERROR_INTERNAL ; } iptr += GEMSAFE_READ_QUANTUM ; } i = 0 ; while ( ind < objlen - 1 ) { if ( ibuf [ ind ] == 0x30 && ibuf [ ind + 1 ] == 0x82 ) { while ( i < gemsafe_cert_max && gemsafe_cert [ i ] . label == NULL ) i ++ ; if ( i == gemsafe_cert_max ) { sc_log ( card -> ctx , "Warning:<S2SV_blank>Found<S2SV_blank>orphaned<S2SV_blank>certificate<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d" , ind ) ; return SC_SUCCESS ; } if ( ind + 3 >= sizeof ibuf ) return SC_ERROR_INVALID_DATA ; certlen = ( ( ( ( size_t ) ibuf [ ind + 2 ] ) << 8 ) | ibuf [ ind + 3 ] ) + 4 ; sc_log ( card -> ctx , "Found<S2SV_blank>certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , i + 1 , ind , certlen ) ; gemsafe_cert [ i ] . index = ind ; gemsafe_cert [ i ] . count = certlen ; ind += certlen ; i ++ ; } else ind ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { if ( gemsafe_cert [ i ] . label ) { sc_log ( card -> ctx , "Warning:<S2SV_blank>Certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>missing" , i + 1 ) ; gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } } return SC_SUCCESS ; }
CWE-189 static int sysMapFD ( int fd , MemMapping * pMap ) { off_t start ; size_t length ; void * memPtr ; assert ( pMap != NULL ) ; if ( getFileStartAndLength ( fd , & start , & length ) < 0 ) return - 1 ; memPtr = mmap ( NULL , length , PROT_READ , MAP_PRIVATE , fd , start ) ; if ( memPtr == MAP_FAILED ) { LOGW ( "mmap(%d,<S2SV_blank>R,<S2SV_blank>PRIVATE,<S2SV_blank>%d,<S2SV_blank>%d)<S2SV_blank>failed:<S2SV_blank>%s\\n" , ( int ) length , fd , ( int ) start , strerror ( errno ) ) ; return - 1 ; } pMap -> addr = memPtr ; pMap -> length = length ; pMap -> range_count = 1 ; <S2SV_StartBug> pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ; <S2SV_EndBug> pMap -> ranges [ 0 ] . addr = memPtr ; pMap -> ranges [ 0 ] . length = length ; return 0 ; }
CWE-000 int nfs3svc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readargs * args ) { unsigned int len ; int v ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; <S2SV_StartBug> args -> count = ntohl ( * p ++ ) ; <S2SV_EndBug> len = min ( args -> count , max_blocksize ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , PAGE_SIZE ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ; <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
CWE-000 static krb5_error_code kdc_process_for_user ( kdc_realm_t * kdc_active_realm , krb5_pa_data * pa_data , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_pa_for_user * for_user ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_for_user ( & req_data , & for_user ) ; if ( code ) <S2SV_StartBug> return code ; <S2SV_EndBug> code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ; if ( code ) { * status = "INVALID_S4U2SELF_CHECKSUM" ; krb5_free_pa_for_user ( kdc_context , for_user ) ; return code ; } * s4u_x509_user = calloc ( 1 , sizeof ( krb5_pa_s4u_x509_user ) ) ; if ( * s4u_x509_user == NULL ) { krb5_free_pa_for_user ( kdc_context , for_user ) ; return ENOMEM ; } ( * s4u_x509_user ) -> user_id . user = for_user -> user ; for_user -> user = NULL ; krb5_free_pa_for_user ( kdc_context , for_user ) ; return 0 ; }
CWE-399 static void __inet_del_ifa ( struct in_device * in_dev , struct in_ifaddr * * ifap , int destroy , struct nlmsghdr * nlh , u32 portid ) { struct in_ifaddr * promote = NULL ; struct in_ifaddr * ifa , * ifa1 = * ifap ; struct in_ifaddr * last_prim = in_dev -> ifa_list ; struct in_ifaddr * prev_prom = NULL ; int do_promote = IN_DEV_PROMOTE_SECONDARIES ( in_dev ) ; ASSERT_RTNL ( ) ; <S2SV_StartBug> if ( ! ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) ) { <S2SV_EndBug> struct in_ifaddr * * ifap1 = & ifa1 -> ifa_next ; while ( ( ifa = * ifap1 ) != NULL ) { if ( ! ( ifa -> ifa_flags & IFA_F_SECONDARY ) && ifa1 -> ifa_scope <= ifa -> ifa_scope ) last_prim = ifa ; if ( ! ( ifa -> ifa_flags & IFA_F_SECONDARY ) || ifa1 -> ifa_mask != ifa -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , ifa ) ) { ifap1 = & ifa -> ifa_next ; prev_prom = ifa ; continue ; } if ( ! do_promote ) { inet_hash_remove ( ifa ) ; * ifap1 = ifa -> ifa_next ; rtmsg_ifa ( RTM_DELADDR , ifa , nlh , portid ) ; blocking_notifier_call_chain ( & inetaddr_chain , NETDEV_DOWN , ifa ) ; inet_free_ifa ( ifa ) ; } else { promote = ifa ; break ; } } } for ( ifa = promote ; ifa ; ifa = ifa -> ifa_next ) { if ( ifa1 -> ifa_mask == ifa -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , ifa ) ) fib_del_ifaddr ( ifa , ifa1 ) ; <S2SV_StartBug> } <S2SV_EndBug> * ifap = ifa1 -> ifa_next ; inet_hash_remove ( ifa1 ) ; rtmsg_ifa ( RTM_DELADDR , ifa1 , nlh , portid ) ; blocking_notifier_call_chain ( & inetaddr_chain , NETDEV_DOWN , ifa1 ) ; if ( promote ) { struct in_ifaddr * next_sec = promote -> ifa_next ; if ( prev_prom ) { prev_prom -> ifa_next = promote -> ifa_next ; promote -> ifa_next = last_prim -> ifa_next ; last_prim -> ifa_next = promote ; } promote -> ifa_flags &= ~ IFA_F_SECONDARY ; rtmsg_ifa ( RTM_NEWADDR , promote , nlh , portid ) ; blocking_notifier_call_chain ( & inetaddr_chain , NETDEV_UP , promote ) ; for ( ifa = next_sec ; ifa ; ifa = ifa -> ifa_next ) { if ( ifa1 -> ifa_mask != ifa -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , ifa ) ) continue ; fib_add_ifaddr ( ifa ) ; } } if ( destroy ) inet_free_ifa ( ifa1 ) ; }
CWE-200 static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , "application<S2SV_blank>%i" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; <S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug> tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; tu -> timeri -> disconnect = snd_timer_user_disconnect ; } __err : return err ; }
CWE-000 static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , "w" ) ; if ( fp ) { fprintf ( fp , "\\n" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , "%s/.Xauthority" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { fprintf ( stderr , "Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n" ) ; return 0 ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , 0600 ) ; <S2SV_StartBug> if ( rv ) <S2SV_EndBug> fprintf ( stderr , "Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n" ) ; else { <S2SV_StartBug> fs_logger2 ( "clone" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; return 1 ; } return 0 ; }
CWE-119 <S2SV_StartBug> int get_down2_steps ( int in_length , int out_length ) { <S2SV_EndBug> int steps = 0 ; int proj_in_length ; while ( ( proj_in_length = get_down2_length ( in_length , 1 ) ) >= out_length ) { ++ steps ; in_length = proj_in_length ; } return steps ; }
CWE-190 static void php_html_entities ( INTERNAL_FUNCTION_PARAMETERS , int all ) { char * str , * hint_charset = NULL ; int str_len , hint_charset_len = 0 ; size_t new_len ; long flags = ENT_COMPAT ; char * replaced ; zend_bool double_encode = 1 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s|ls!b" , & str , & str_len , & flags , & hint_charset , & hint_charset_len , & double_encode ) == FAILURE ) { return ; } replaced = php_escape_html_entities_ex ( str , str_len , & new_len , all , ( int ) flags , hint_charset , double_encode TSRMLS_CC ) ; <S2SV_StartBug> RETVAL_STRINGL ( replaced , ( int ) new_len , 0 ) ; <S2SV_EndBug> }
CWE-200 static int l2cap_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_l2 * la = ( struct sockaddr_l2 * ) addr ; struct sock * sk = sock -> sk ; struct l2cap_chan * chan = l2cap_pi ( sk ) -> chan ; <S2SV_StartBug> BT_DBG ( "sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; <S2SV_EndBug> addr -> sa_family = AF_BLUETOOTH ; * len = sizeof ( struct sockaddr_l2 ) ; if ( peer ) { la -> l2_psm = chan -> psm ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> dst ) ; la -> l2_cid = cpu_to_le16 ( chan -> dcid ) ; } else { la -> l2_psm = chan -> sport ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> src ) ; la -> l2_cid = cpu_to_le16 ( chan -> scid ) ; } return 0 ; }
CWE-284 int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , "WSAStartup<S2SV_blank>failed!\\n" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( "socket()" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( "setsockopt()" ) ; socket_close ( sfd ) ; return - 1 ; } memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( "bind()" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( "listen()" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
CWE-119 static int msg_parse_fetch ( struct ImapHeader * h , char * s ) { char tmp [ SHORT_STRING ] ; char * ptmp = NULL ; if ( ! s ) return - 1 ; while ( * s ) { SKIPWS ( s ) ; if ( mutt_str_strncasecmp ( "FLAGS" , s , 5 ) == 0 ) { s = msg_parse_flags ( h , s ) ; if ( ! s ) return - 1 ; } else if ( mutt_str_strncasecmp ( "UID" , s , 3 ) == 0 ) { s += 3 ; SKIPWS ( s ) ; if ( mutt_str_atoui ( s , & h -> data -> uid ) < 0 ) return - 1 ; s = imap_next_word ( s ) ; } else if ( mutt_str_strncasecmp ( "INTERNALDATE" , s , 12 ) == 0 ) { s += 12 ; SKIPWS ( s ) ; if ( * s != \'\\"\' ) { mutt_debug ( 1 , "bogus<S2SV_blank>INTERNALDATE<S2SV_blank>entry:<S2SV_blank>%s\\n" , s ) ; return - 1 ; } s ++ ; ptmp = tmp ; <S2SV_StartBug> while ( * s && * s != \'\\"\' ) <S2SV_EndBug> * ptmp ++ = * s ++ ; if ( * s != \'\\"\' ) return - 1 ; s ++ ; * ptmp = '\\0' ; h -> received = mutt_date_parse_imap ( tmp ) ; } else if ( mutt_str_strncasecmp ( "RFC822.SIZE" , s , 11 ) == 0 ) { s += 11 ; SKIPWS ( s ) ; ptmp = tmp ; <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> * ptmp ++ = * s ++ ; * ptmp = '\\0' ; if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 ) return - 1 ; } else if ( ( mutt_str_strncasecmp ( "BODY" , s , 4 ) == 0 ) || ( mutt_str_strncasecmp ( "RFC822.HEADER" , s , 13 ) == 0 ) ) { return - 2 ; } else if ( * s == ')' ) s ++ ; else if ( * s ) { imap_error ( "msg_parse_fetch" , s ) ; return - 1 ; } } return 0 ; }
CWE-190 static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
CWE-119 static void scsi_free_request ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 <S2SV_StartBug> static void read_mv_probs ( nmv_context * ctx , int allow_hp , vp9_reader * r ) { <S2SV_EndBug> int i , j ; update_mv_probs ( ctx -> joints , MV_JOINTS - 1 , r ) ; for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; update_mv_probs ( & comp_ctx -> sign , 1 , r ) ; update_mv_probs ( comp_ctx -> classes , MV_CLASSES - 1 , r ) ; update_mv_probs ( comp_ctx -> class0 , CLASS0_SIZE - 1 , r ) ; update_mv_probs ( comp_ctx -> bits , MV_OFFSET_BITS , r ) ; } for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) update_mv_probs ( comp_ctx -> class0_fp [ j ] , MV_FP_SIZE - 1 , r ) ; update_mv_probs ( comp_ctx -> fp , 3 , r ) ; } if ( allow_hp ) { for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * const comp_ctx = & ctx -> comps [ i ] ; update_mv_probs ( & comp_ctx -> class0_hp , 1 , r ) ; update_mv_probs ( & comp_ctx -> hp , 1 , r ) ; } } }
CWE-20 static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( "" ) ; <S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> if ( ! user ) return ERR_PTR ( - ENOMEM ) ; construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( "cons<S2SV_blank>failed" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else { goto couldnt_alloc_key ; } key_put ( dest_keyring ) ; kleave ( "<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ; couldnt_alloc_key : key_put ( dest_keyring ) ; kleave ( "<S2SV_blank>=<S2SV_blank>%d" , ret ) ; return ERR_PTR ( ret ) ; }
CWE-264 static void rd_release_device_space ( struct rd_dev * rd_dev ) { <S2SV_StartBug> u32 i , j , page_count = 0 , sg_per_table ; <S2SV_EndBug> struct rd_dev_sg_table * sg_table ; struct page * pg ; struct scatterlist * sg ; if ( ! rd_dev -> sg_table_array || ! rd_dev -> sg_table_count ) return ; <S2SV_StartBug> sg_table = rd_dev -> sg_table_array ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { <S2SV_EndBug> sg = sg_table [ i ] . sg_table ; sg_per_table = sg_table [ i ] . rd_sg_count ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = sg_page ( & sg [ j ] ) ; if ( pg ) { __free_page ( pg ) ; page_count ++ ; } } kfree ( sg ) ; } pr_debug ( "CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk" "<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u,<S2SV_blank>pages<S2SV_blank>%u<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>tables<S2SV_blank>total<S2SV_blank>bytes<S2SV_blank>%lu\\n" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , page_count , rd_dev -> sg_table_count , ( unsigned long ) page_count * PAGE_SIZE ) ; <S2SV_StartBug> kfree ( sg_table ) ; <S2SV_EndBug> rd_dev -> sg_table_array = NULL ; rd_dev -> sg_table_count = 0 ; }
CWE-20 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ; <S2SV_StartBug> u32 offset ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } offset = IUCV_SKB_CB ( skb ) -> offset ; rlen = skb -> len - offset ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , offset , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , sizeof ( IUCV_SKB_CB ( skb ) -> class ) , ( void * ) & IUCV_SKB_CB ( skb ) -> class ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { if ( copied < rlen ) { IUCV_SKB_CB ( skb ) -> offset = offset + copied ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { IUCV_SKB_CB ( rskb ) -> offset = 0 ; if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
CWE-416 static ssize_t sg_write ( struct file * filp , const char __user * buf , size_t count , loff_t * ppos ) { int mxsize , cmd_size , k ; int input_size , blocking ; unsigned char opcode ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; struct sg_header old_hdr ; sg_io_hdr_t * hp ; unsigned char cmnd [ SG_MAX_CDB_SIZE ] ; <S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , "sg_write:<S2SV_blank>count=%d\\n" , ( int ) count ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! ( ( filp -> f_flags & O_NONBLOCK ) || scsi_block_when_processing_errors ( sdp -> device ) ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_READ , buf , count ) ) return - EFAULT ; if ( count < SZ_SG_HEADER ) return - EIO ; if ( __copy_from_user ( & old_hdr , buf , SZ_SG_HEADER ) ) return - EFAULT ; blocking = ! ( filp -> f_flags & O_NONBLOCK ) ; if ( old_hdr . reply_len < 0 ) return sg_new_write ( sfp , filp , buf , count , blocking , 0 , 0 , NULL ) ; if ( count < ( SZ_SG_HEADER + 6 ) ) return - EIO ; if ( ! ( srp = sg_add_request ( sfp ) ) ) { SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sdp , "sg_write:<S2SV_blank>queue<S2SV_blank>full\\n" ) ) ; return - EDOM ; } buf += SZ_SG_HEADER ; __get_user ( opcode , buf ) ; if ( sfp -> next_cmd_len > 0 ) { cmd_size = sfp -> next_cmd_len ; sfp -> next_cmd_len = 0 ; } else { cmd_size = COMMAND_SIZE ( opcode ) ; if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte ) cmd_size = 12 ; } SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sdp , "sg_write:<S2SV_blank><S2SV_blank><S2SV_blank>scsi<S2SV_blank>opcode=0x%02x,<S2SV_blank>cmd_size=%d\\n" , ( int ) opcode , cmd_size ) ) ; input_size = count - cmd_size ; mxsize = ( input_size > old_hdr . reply_len ) ? input_size : old_hdr . reply_len ; mxsize -= SZ_SG_HEADER ; input_size -= SZ_SG_HEADER ; if ( input_size < 0 ) { sg_remove_request ( sfp , srp ) ; return - EIO ; } hp = & srp -> header ; hp -> interface_id = '\\0' ; hp -> cmd_len = ( unsigned char ) cmd_size ; hp -> iovec_count = 0 ; hp -> mx_sb_len = 0 ; if ( input_size > 0 ) hp -> dxfer_direction = ( old_hdr . reply_len > SZ_SG_HEADER ) ? SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV ; else hp -> dxfer_direction = ( mxsize > 0 ) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE ; hp -> dxfer_len = mxsize ; if ( ( hp -> dxfer_direction == SG_DXFER_TO_DEV ) || ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) ) hp -> dxferp = ( char __user * ) buf + cmd_size ; else hp -> dxferp = NULL ; hp -> sbp = NULL ; hp -> timeout = old_hdr . reply_len ; hp -> flags = input_size ; hp -> pack_id = old_hdr . pack_id ; hp -> usr_ptr = NULL ; if ( __copy_from_user ( cmnd , buf , cmd_size ) ) return - EFAULT ; if ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) { static char cmd [ TASK_COMM_LEN ] ; if ( strcmp ( current -> comm , cmd ) ) { printk_ratelimited ( KERN_WARNING "sg_write:<S2SV_blank>data<S2SV_blank>in/out<S2SV_blank>%d/%d<S2SV_blank>bytes<S2SV_blank>" "for<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>0x%x--<S2SV_blank>guessing<S2SV_blank>" "data<S2SV_blank>in;\\n<S2SV_blank><S2SV_blank><S2SV_blank>program<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>setting<S2SV_blank>" "count<S2SV_blank>and/or<S2SV_blank>reply_len<S2SV_blank>properly\\n" , old_hdr . reply_len - ( int ) SZ_SG_HEADER , input_size , ( unsigned int ) cmnd [ 0 ] , current -> comm ) ; strcpy ( cmd , current -> comm ) ; } } k = sg_common_write ( sfp , srp , cmnd , sfp -> timeout , blocking ) ; return ( k < 0 ) ? k : count ; }
CWE-119 static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) { AVCodecParameters * par = stream -> codecpar ; if ( ! strcmp ( attr , "packetization-mode" ) ) { av_log ( s , AV_LOG_DEBUG , "RTP<S2SV_blank>Packetization<S2SV_blank>Mode:<S2SV_blank>%d\\n" , atoi ( value ) ) ; h264_data -> packetization_mode = atoi ( value ) ; if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , "Interleaved<S2SV_blank>RTP<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>yet.\\n" ) ; } else if ( ! strcmp ( attr , "profile-level-id" ) ) { if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ; } else if ( ! strcmp ( attr , "sprop-parameter-sets" ) ) { int ret ; <S2SV_StartBug> if ( value [ strlen ( value ) - 1 ] == ',' ) { <S2SV_EndBug> av_log ( s , AV_LOG_WARNING , "Missing<S2SV_blank>PPS<S2SV_blank>in<S2SV_blank>sprop-parameter-sets,<S2SV_blank>ignoring\\n" ) ; return 0 ; } par -> extradata_size = 0 ; av_freep ( & par -> extradata ) ; ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ; av_log ( s , AV_LOG_DEBUG , "Extradata<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>(size:<S2SV_blank>%d)\\n" , par -> extradata , par -> extradata_size ) ; return ret ; } return 0 ; }
CWE-119 void vpx_svc_release ( SvcContext * svc_ctx ) { <S2SV_StartBug> SvcInternal * si ; <S2SV_EndBug> if ( svc_ctx == NULL ) return ; <S2SV_StartBug> si = ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> if ( si != NULL ) { <S2SV_StartBug> free ( si -> buffer ) ; <S2SV_EndBug> if ( si -> rc_stats_buf ) { free ( si -> rc_stats_buf ) ; } free ( si ) ; svc_ctx -> internal = NULL ; } }
CWE-119 <S2SV_StartBug> void vp9_idct32x32_add ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> int eob ) { if ( eob == 1 ) <S2SV_StartBug> vp9_idct32x32_1_add ( input , dest , stride ) ; <S2SV_EndBug> else if ( eob <= 34 ) <S2SV_StartBug> vp9_idct32x32_34_add ( input , dest , stride ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_idct32x32_1024_add ( input , dest , stride ) ; <S2SV_EndBug> }
CWE-119 int vp9_block_energy ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bs ) { double energy ; <S2SV_StartBug> unsigned int var = block_variance ( cpi , x , bs ) ; <S2SV_EndBug> vp9_clear_system_state ( ) ; energy = 0.9 * ( log ( var + 1.0 ) - 10.0 ) ; return clamp ( ( int ) round ( energy ) , ENERGY_MIN , ENERGY_MAX ) ; }
CWE-772 struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; <S2SV_StartBug> struct iovec iov ; <S2SV_EndBug> iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int local_nr_pages = end - start ; const int page_limit = cur_page + local_nr_pages ; ret = get_user_pages_fast ( uaddr , local_nr_pages , ( iter -> type & WRITE ) != WRITE , & pages [ cur_page ] ) ; <S2SV_StartBug> if ( ret < local_nr_pages ) { <S2SV_EndBug> ret = - EFAULT ; goto out_unmap ; } offset = offset_in_page ( uaddr ) ; for ( j = cur_page ; j < page_limit ; j ++ ) { unsigned int bytes = PAGE_SIZE - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; if ( len <= 0 ) break ; if ( bytes > len ) bytes = len ; if ( bio_add_pc_page ( q , bio , pages [ j ] , bytes , offset ) < bytes ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ; len -= bytes ; offset = 0 ; } cur_page = j ; while ( j < page_limit ) put_page ( pages [ j ++ ] ) ; } kfree ( pages ) ; bio_set_flag ( bio , BIO_USER_MAPPED ) ; bio_get ( bio ) ; return bio ; out_unmap : <S2SV_StartBug> for ( j = 0 ; j < nr_pages ; j ++ ) { <S2SV_EndBug> if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } out : kfree ( pages ) ; bio_put ( bio ) ; return ERR_PTR ( ret ) ; }
CWE-787 static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) { <S2SV_StartBug> int v , i ; <S2SV_EndBug> if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || <S2SV_StartBug> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }
CWE-119 <S2SV_StartBug> static int decode_uniform ( vp9_reader * r ) { <S2SV_EndBug> const int l = 8 ; const int m = ( 1 << l ) - 191 ; <S2SV_StartBug> const int v = vp9_read_literal ( r , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ; <S2SV_EndBug> }
CWE-000 static uint16_t http_splitline ( struct worker * w , int fd , struct http * hp , const struct http_conn * htc , int h1 , int h2 , int h3 ) { char * p , * q ; CHECK_OBJ_NOTNULL ( htc , HTTP_CONN_MAGIC ) ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; Tcheck ( htc -> rxbuf ) ; for ( p = htc -> rxbuf . b ; vct_islws ( * p ) ; p ++ ) continue ; q = p ; for ( ; ! vct_issp ( * p ) ; p ++ ) { if ( vct_isctl ( * p ) ) return ( 400 ) ; } hp -> hd [ h1 ] . b = q ; hp -> hd [ h1 ] . e = p ; for ( ; vct_issp ( * p ) ; p ++ ) { if ( vct_isctl ( * p ) ) return ( 400 ) ; } q = p ; for ( ; ! vct_islws ( * p ) ; p ++ ) { if ( vct_isctl ( * p ) ) return ( 400 ) ; } hp -> hd [ h2 ] . b = q ; hp -> hd [ h2 ] . e = p ; if ( ! Tlen ( hp -> hd [ h2 ] ) ) return ( 400 ) ; for ( ; vct_issp ( * p ) ; p ++ ) { if ( vct_isctl ( * p ) ) return ( 400 ) ; } q = p ; <S2SV_StartBug> if ( ! vct_iscrlf ( * p ) ) { <S2SV_EndBug> <S2SV_StartBug> for ( ; ! vct_iscrlf ( * p ) ; p ++ ) <S2SV_EndBug> if ( ! vct_issep ( * p ) && vct_isctl ( * p ) ) return ( 400 ) ; } hp -> hd [ h3 ] . b = q ; hp -> hd [ h3 ] . e = p ; p += vct_skipcrlf ( p ) ; * hp -> hd [ h1 ] . e = '\\0' ; WSLH ( w , fd , hp , h1 ) ; * hp -> hd [ h2 ] . e = '\\0' ; WSLH ( w , fd , hp , h2 ) ; if ( hp -> hd [ h3 ] . e != NULL ) { * hp -> hd [ h3 ] . e = '\\0' ; WSLH ( w , fd , hp , h3 ) ; } return ( http_dissect_hdrs ( w , hp , fd , p , htc ) ) ; }
CWE-119 static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ; <S2SV_StartBug> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <S2SV_EndBug> } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; }
CWE-189 int do_adjtimex ( struct timex * txc ) { <S2SV_StartBug> long mtemp , save_adjust , rem ; <S2SV_EndBug> s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ; <S2SV_StartBug> time_offset = div_long_long_rem_signed ( time_offset , <S2SV_EndBug> <S2SV_StartBug> NTP_INTERVAL_FREQ , <S2SV_EndBug> & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }
CWE-787 BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }
CWE-415 static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) { <S2SV_StartBug> unsigned char * buf ; <S2SV_EndBug> assert ( m -> buf_ ) ; assert ( bufsize >= 0 ) ; <S2SV_StartBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) { <S2SV_EndBug> return - 1 ; } m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }
CWE-284 static ssize_t out_write ( struct audio_stream_out * stream , const void * buffer , size_t bytes ) { struct a2dp_stream_out * out = ( struct a2dp_stream_out * ) stream ; int sent ; DEBUG ( "write<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>(fd<S2SV_blank>%d)" , bytes , out -> common . audio_fd ) ; pthread_mutex_lock ( & out -> common . lock ) ; if ( out -> common . state == AUDIO_A2DP_STATE_SUSPENDED ) { DEBUG ( "stream<S2SV_blank>suspended" ) ; pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } if ( ( out -> common . state == AUDIO_A2DP_STATE_STOPPED ) || ( out -> common . state == AUDIO_A2DP_STATE_STANDBY ) ) { if ( start_audio_datapath ( & out -> common ) < 0 ) { int us_delay = calc_audiotime ( out -> common . cfg , bytes ) ; DEBUG ( "emulate<S2SV_blank>a2dp<S2SV_blank>write<S2SV_blank>delay<S2SV_blank>(%d<S2SV_blank>us)" , us_delay ) ; <S2SV_StartBug> usleep ( us_delay ) ; <S2SV_EndBug> pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } } else if ( out -> common . state != AUDIO_A2DP_STATE_STARTED ) { ERROR ( "stream<S2SV_blank>not<S2SV_blank>in<S2SV_blank>stopped<S2SV_blank>or<S2SV_blank>standby" ) ; pthread_mutex_unlock ( & out -> common . lock ) ; return - 1 ; } pthread_mutex_unlock ( & out -> common . lock ) ; sent = skt_write ( out -> common . audio_fd , buffer , bytes ) ; if ( sent == - 1 ) { skt_disconnect ( out -> common . audio_fd ) ; out -> common . audio_fd = AUDIO_SKT_DISCONNECTED ; if ( out -> common . state != AUDIO_A2DP_STATE_SUSPENDED ) out -> common . state = AUDIO_A2DP_STATE_STOPPED ; else ERROR ( "write<S2SV_blank>failed<S2SV_blank>:<S2SV_blank>stream<S2SV_blank>suspended,<S2SV_blank>avoid<S2SV_blank>resetting<S2SV_blank>state" ) ; } else { const size_t frames = bytes / audio_stream_out_frame_size ( stream ) ; out -> frames_rendered += frames ; out -> frames_presented += frames ; } DEBUG ( "wrote<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>%zu<S2SV_blank>bytes" , sent , bytes ) ; return sent ; }
CWE-119 static BT_HDR * create_pbuf ( UINT16 len , UINT8 * data ) { <S2SV_StartBug> BT_HDR * p_buf = GKI_getbuf ( ( UINT16 ) ( len + BTA_HH_MIN_OFFSET + sizeof ( BT_HDR ) ) ) ; <S2SV_EndBug> if ( p_buf ) { UINT8 * pbuf_data ; p_buf -> len = len ; p_buf -> offset = BTA_HH_MIN_OFFSET ; pbuf_data = ( UINT8 * ) ( p_buf + 1 ) + p_buf -> offset ; memcpy ( pbuf_data , data , len ) ; } return p_buf ; }
CWE-119 static int ExecuteSQL ( SQLHDBC hDbc , char * szSQL , char cDelimiter , int bColumnNames , int bHTMLTable ) { SQLHSTMT hStmt ; SQLTCHAR szSepLine [ 32001 ] ; SQLTCHAR szUcSQL [ 32001 ] ; SQLSMALLINT cols ; SQLINTEGER ret ; SQLLEN nRows = 0 ; szSepLine [ 0 ] = 0 ; ansi_to_unicode ( szSQL , szUcSQL ) ; if ( SQLAllocStmt ( hDbc , & hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , 0 ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLAllocStmt\\n" ) ; return 0 ; } if ( buseED ) { ret = SQLExecDirect ( hStmt , szUcSQL , SQL_NTS ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , "[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecDirect\\n" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; <S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug> return 0 ; } } else { if ( SQLPrepare ( hStmt , szUcSQL , SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLPrepare\\n" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } ret = SQLExecute ( hStmt ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , "[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecute\\n" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } } do { if ( SQLNumResultCols ( hStmt , & cols ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , "[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLNumResultCols\\n" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } if ( cols > 0 ) { if ( bHTMLTable ) WriteHeaderHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteHeaderNormal ( hStmt , szSepLine ) ; else if ( cDelimiter && bColumnNames ) WriteHeaderDelimited ( hStmt , cDelimiter ) ; if ( bHTMLTable ) WriteBodyHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) nRows = WriteBodyNormal ( hStmt ) ; else WriteBodyDelimited ( hStmt , cDelimiter ) ; } if ( bHTMLTable ) WriteFooterHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteFooterNormal ( hStmt , szSepLine , nRows ) ; } while ( SQL_SUCCEEDED ( SQLMoreResults ( hStmt ) ) ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 1 ; }
CWE-119 PTA * ptaReadStream ( FILE * fp ) { char typestr [ 128 ] ; l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ; PROCNAME ( "ptaReadStream" ) ; if ( ! fp ) return ( PTA * ) ERROR_PTR ( "stream<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( fscanf ( fp , "\\n<S2SV_blank>Pta<S2SV_blank>Version<S2SV_blank>%d\\n" , & version ) != 1 ) return ( PTA * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file" , procName , NULL ) ; if ( version != PTA_VERSION_NUMBER ) return ( PTA * ) ERROR_PTR ( "invalid<S2SV_blank>pta<S2SV_blank>version" , procName , NULL ) ; <S2SV_StartBug> if ( fscanf ( fp , "<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%s\\n" , & n , typestr ) != 2 ) <S2SV_EndBug> return ( PTA * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>pta<S2SV_blank>file" , procName , NULL ) ; if ( ! strcmp ( typestr , "float" ) ) type = 0 ; else type = 1 ; if ( ( pta = ptaCreate ( n ) ) == NULL ) return ( PTA * ) ERROR_PTR ( "pta<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; for ( i = 0 ; i < n ; i ++ ) { if ( type == 0 ) { if ( fscanf ( fp , "<S2SV_blank><S2SV_blank><S2SV_blank>(%f,<S2SV_blank>%f)\\n" , & x , & y ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( "error<S2SV_blank>reading<S2SV_blank>floats" , procName , NULL ) ; } ptaAddPt ( pta , x , y ) ; } else { if ( fscanf ( fp , "<S2SV_blank><S2SV_blank><S2SV_blank>(%d,<S2SV_blank>%d)\\n" , & ix , & iy ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( "error<S2SV_blank>reading<S2SV_blank>ints" , procName , NULL ) ; } ptaAddPt ( pta , ix , iy ) ; } } return pta ; }
CWE-119 static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , "1028" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; <S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , "<S2SV_blank>bc<S2SV_blank>" , vpdlen - len - 1 ) ; <S2SV_EndBug> } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , "BCM5717" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , "BCM5718" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , "BCM57780" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , "BCM57760" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , "BCM57790" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , "BCM57788" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , "BCM57761" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , "BCM57765" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , "BCM57781" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , "BCM57785" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , "BCM57791" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , "BCM57795" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , "BCM57762" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , "BCM57766" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , "BCM57782" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , "BCM57786" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , "BCM95906" ) ; } else { nomatch : strcpy ( tp -> board_part_number , "none" ) ; } }
CWE-125 int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; <S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
CWE-119 <S2SV_StartBug> void validate_positive_rational ( const char * msg , <S2SV_EndBug> struct vpx_rational * rat ) { if ( rat -> den < 0 ) { rat -> num *= - 1 ; rat -> den *= - 1 ; } if ( rat -> num < 0 ) die ( "Error:<S2SV_blank>%s<S2SV_blank>must<S2SV_blank>be<S2SV_blank>positive\\n" , msg ) ; if ( ! rat -> den ) die ( "Error:<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>zero<S2SV_blank>denominator\\n" , msg ) ; }
CWE-200 void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { <S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 hash , id ; <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
CWE-119 static struct VP8D_COMP * create_decompressor ( VP8D_CONFIG * oxcf ) { VP8D_COMP * pbi = vpx_memalign ( 32 , sizeof ( VP8D_COMP ) ) ; if ( ! pbi ) return NULL ; <S2SV_StartBug> vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; <S2SV_EndBug> if ( setjmp ( pbi -> common . error . jmp ) ) { pbi -> common . error . setjmp = 0 ; remove_decompressor ( pbi ) ; return 0 ; } pbi -> common . error . setjmp = 1 ; vp8_create_common ( & pbi -> common ) ; pbi -> common . current_video_frame = 0 ; pbi -> ready_for_new_data = 1 ; vp8cx_init_de_quantizer ( pbi ) ; vp8_loop_filter_init ( & pbi -> common ) ; pbi -> common . error . setjmp = 0 ; # if CONFIG_ERROR_CONCEALMENT pbi -> ec_enabled = oxcf -> error_concealment ; pbi -> overlaps = NULL ; # else <S2SV_StartBug> pbi -> ec_enabled = 0 ; <S2SV_EndBug> # endif pbi -> ec_active = 0 ; pbi -> decoded_key_frame = 0 ; pbi -> independent_partitions = 0 ; vp8_setup_block_dptrs ( & pbi -> mb ) ; return pbi ; }
CWE-399 struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = NULL ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ; <S2SV_StartBug> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <S2SV_EndBug> sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return NULL ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } skb_pull ( chunk -> skb , sizeof ( sctp_chunkhdr_t ) ) ; chunk -> subh . v = NULL ; <S2SV_StartBug> if ( chunk -> chunk_end < skb_tail_pointer ( chunk -> skb ) ) { <S2SV_EndBug> chunk -> singleton = 0 ; } else if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) { <S2SV_StartBug> sctp_chunk_free ( chunk ) ; <S2SV_EndBug> chunk = queue -> in_progress = NULL ; return NULL ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( "+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return chunk ; }
CWE-362 void sock_release ( struct socket * sock ) { <S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = NULL ; module_put ( owner ) ; } <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug> pr_err ( "%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\n" , __func__ ) ; if ( ! sock -> file ) { iput ( SOCK_INODE ( sock ) ) ; return ; } sock -> file = NULL ; }
CWE-119 bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { applog ( LOG_INFO , "setup_stratum_socket()<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>failed" , get_pool_name ( pool ) ) ; sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[]}" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[\\"" PACKAGE "/" VERSION "\\",<S2SV_blank>\\"%s\\"]}" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[\\"" PACKAGE "/" VERSION "\\"]}" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , "Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , "JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , "result" ) ; err_val = json_object_get ( val , "error" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( "(unknown<S2SV_blank>reason)" ) ; applog ( LOG_INFO , "JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = ( unsigned char * ) calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , "Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , "%s<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , get_pool_name ( pool ) , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , "%s<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d" , get_pool_name ( pool ) , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , "Initiating<S2SV_blank>stratum<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s" , get_pool_name ( pool ) ) ; if ( sockd ) { applog ( LOG_DEBUG , "Suspending<S2SV_blank>stratum<S2SV_blank>on<S2SV_blank>%s" , get_pool_name ( pool ) ) ; suspend_stratum ( pool ) ; } } json_decref ( val ) ; return ret ; }
CWE-20 static gboolean is_link_trusted ( NautilusFile * file , gboolean is_launcher ) { GFile * location ; gboolean res ; <S2SV_StartBug> if ( ! is_launcher ) <S2SV_EndBug> { return TRUE ; } <S2SV_StartBug> if ( nautilus_file_can_execute ( file ) ) <S2SV_EndBug> { return TRUE ; } res = FALSE ; if ( nautilus_file_is_local ( file ) ) { location = nautilus_file_get_location ( file ) ; res = nautilus_is_in_system_dir ( location ) ; g_object_unref ( location ) ; } return res ; }
CWE-20 static gboolean parse_netscreen_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { <S2SV_StartBug> int sec ; <S2SV_EndBug> int dsec ; char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; char direction [ 2 ] ; <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> char cap_src [ 13 ] ; char cap_dst [ 13 ] ; guint8 * pd ; gchar * p ; int n , i = 0 ; <S2SV_StartBug> guint offset = 0 ; <S2SV_EndBug> gchar dststr [ 13 ] ; phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; <S2SV_StartBug> if ( sscanf ( line , "%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9u:%12s->%12s/" , <S2SV_EndBug> & sec , & dsec , cap_int , direction , & pkt_len , cap_src , cap_dst ) < 5 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen:<S2SV_blank>Can\'t<S2SV_blank>parse<S2SV_blank>packet-header" ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "netscreen:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> ts . secs = sec ; phdr -> ts . nsecs = dsec * 100000000 ; phdr -> len = pkt_len ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; while ( 1 ) { if ( file_gets ( line , NETSCREEN_LINE_LENGTH , fh ) == NULL ) { break ; } for ( p = & line [ 0 ] ; g_ascii_isspace ( * p ) ; p ++ ) ; if ( * p == '\\0' ) { break ; } n = parse_single_hex_dump_line ( p , pd , offset ) ; if ( offset == 0 && n < 6 ) { if ( info_line ( line ) ) { if ( ++ i <= NETSCREEN_MAX_INFOLINES ) { continue ; } } else { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen:<S2SV_blank>cannot<S2SV_blank>parse<S2SV_blank>hex-data" ) ; return FALSE ; } } if ( n == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen:<S2SV_blank>cannot<S2SV_blank>parse<S2SV_blank>hex-data" ) ; return FALSE ; } offset += n ; if ( offset > pkt_len ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen:<S2SV_blank>too<S2SV_blank>much<S2SV_blank>hex-data" ) ; return FALSE ; } } if ( strncmp ( cap_int , "adsl" , 4 ) == 0 ) { g_snprintf ( dststr , 13 , "%02x%02x%02x%02x%02x%02x" , pd [ 0 ] , pd [ 1 ] , pd [ 2 ] , pd [ 3 ] , pd [ 4 ] , pd [ 5 ] ) ; if ( strncmp ( dststr , cap_dst , 12 ) == 0 ) phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; else phdr -> pkt_encap = WTAP_ENCAP_PPP ; } else if ( strncmp ( cap_int , "seri" , 4 ) == 0 ) phdr -> pkt_encap = WTAP_ENCAP_PPP ; else phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; phdr -> caplen = offset ; return TRUE ; }
CWE-476 void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }
CWE-190 int jas_stream_write ( jas_stream_t * stream , const void * buf , int cnt ) { int n ; <S2SV_StartBug> const char * bufptr ; <S2SV_EndBug> bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( jas_stream_putc ( stream , * bufptr ) == EOF ) { return n ; } ++ bufptr ; ++ n ; } return n ; }
CWE-119 <S2SV_StartBug> int fourcc_is_ivf ( const char detect [ 4 ] ) { <S2SV_EndBug> if ( memcmp ( detect , "DKIF" , 4 ) == 0 ) { return 1 ; } return 0 ; }
CWE-119 void vp8_bilinear_predict8x4_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) { uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 ; uint8x8_t d7u8 , d9u8 , d11u8 , d22u8 , d23u8 , d24u8 , d25u8 , d26u8 ; uint8x16_t q1u8 , q2u8 , q3u8 , q4u8 , q5u8 ; uint16x8_t q1u16 , q2u16 , q3u16 , q4u16 ; uint16x8_t q6u16 , q7u16 , q8u16 , q9u16 , q10u16 ; if ( xoffset == 0 ) { d22u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d23u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d24u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d25u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d26u8 = vld1_u8 ( src_ptr ) ; } else { q1u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; q2u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; q3u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; q4u8 = vld1q_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; q5u8 = vld1q_u8 ( src_ptr ) ; <S2SV_StartBug> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <S2SV_EndBug> q6u16 = vmull_u8 ( vget_low_u8 ( q1u8 ) , d0u8 ) ; q7u16 = vmull_u8 ( vget_low_u8 ( q2u8 ) , d0u8 ) ; q8u16 = vmull_u8 ( vget_low_u8 ( q3u8 ) , d0u8 ) ; q9u16 = vmull_u8 ( vget_low_u8 ( q4u8 ) , d0u8 ) ; q10u16 = vmull_u8 ( vget_low_u8 ( q5u8 ) , d0u8 ) ; d3u8 = vext_u8 ( vget_low_u8 ( q1u8 ) , vget_high_u8 ( q1u8 ) , 1 ) ; d5u8 = vext_u8 ( vget_low_u8 ( q2u8 ) , vget_high_u8 ( q2u8 ) , 1 ) ; d7u8 = vext_u8 ( vget_low_u8 ( q3u8 ) , vget_high_u8 ( q3u8 ) , 1 ) ; d9u8 = vext_u8 ( vget_low_u8 ( q4u8 ) , vget_high_u8 ( q4u8 ) , 1 ) ; d11u8 = vext_u8 ( vget_low_u8 ( q5u8 ) , vget_high_u8 ( q5u8 ) , 1 ) ; q6u16 = vmlal_u8 ( q6u16 , d3u8 , d1u8 ) ; q7u16 = vmlal_u8 ( q7u16 , d5u8 , d1u8 ) ; q8u16 = vmlal_u8 ( q8u16 , d7u8 , d1u8 ) ; q9u16 = vmlal_u8 ( q9u16 , d9u8 , d1u8 ) ; q10u16 = vmlal_u8 ( q10u16 , d11u8 , d1u8 ) ; d22u8 = vqrshrn_n_u16 ( q6u16 , 7 ) ; d23u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ; d24u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ; d25u8 = vqrshrn_n_u16 ( q9u16 , 7 ) ; d26u8 = vqrshrn_n_u16 ( q10u16 , 7 ) ; } if ( yoffset == 0 ) { vst1_u8 ( ( uint8_t * ) dst_ptr , d22u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d23u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d24u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d25u8 ) ; } else { d0u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 0 ] ) ; d1u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 1 ] ) ; q1u16 = vmull_u8 ( d22u8 , d0u8 ) ; q2u16 = vmull_u8 ( d23u8 , d0u8 ) ; q3u16 = vmull_u8 ( d24u8 , d0u8 ) ; q4u16 = vmull_u8 ( d25u8 , d0u8 ) ; q1u16 = vmlal_u8 ( q1u16 , d23u8 , d1u8 ) ; q2u16 = vmlal_u8 ( q2u16 , d24u8 , d1u8 ) ; q3u16 = vmlal_u8 ( q3u16 , d25u8 , d1u8 ) ; q4u16 = vmlal_u8 ( q4u16 , d26u8 , d1u8 ) ; d2u8 = vqrshrn_n_u16 ( q1u16 , 7 ) ; d3u8 = vqrshrn_n_u16 ( q2u16 , 7 ) ; d4u8 = vqrshrn_n_u16 ( q3u16 , 7 ) ; d5u8 = vqrshrn_n_u16 ( q4u16 , 7 ) ; vst1_u8 ( ( uint8_t * ) dst_ptr , d2u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d3u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d4u8 ) ; dst_ptr += dst_pitch ; vst1_u8 ( ( uint8_t * ) dst_ptr , d5u8 ) ; } return ; }
CWE-000 static int n_tty_ioctl ( struct tty_struct * tty , struct file * file , unsigned int cmd , unsigned long arg ) { struct n_tty_data * ldata = tty -> disc_data ; int retval ; switch ( cmd ) { case TIOCOUTQ : return put_user ( tty_chars_in_buffer ( tty ) , ( int __user * ) arg ) ; case TIOCINQ : down_write ( & tty -> termios_rwsem ) ; <S2SV_StartBug> if ( L_ICANON ( tty ) ) <S2SV_EndBug> retval = inq_canon ( ldata ) ; else retval = read_cnt ( ldata ) ; up_write ( & tty -> termios_rwsem ) ; return put_user ( retval , ( unsigned int __user * ) arg ) ; default : return n_tty_ioctl_helper ( tty , file , cmd , arg ) ; } }
CWE-20 static zval * * spl_array_get_dimension_ptr_ptr ( int check_inherited , zval * object , zval * offset , int type TSRMLS_DC ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ; zval * * retval ; char * key ; uint len ; long index ; HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <S2SV_StartBug> if ( ! offset ) { <S2SV_EndBug> return & EG ( uninitialized_zval_ptr ) ; } if ( ( type == BP_VAR_W || type == BP_VAR_RW ) && ( ht -> nApplyCount > 0 ) ) { zend_error ( E_WARNING , "Modification<S2SV_blank>of<S2SV_blank>ArrayObject<S2SV_blank>during<S2SV_blank>sorting<S2SV_blank>is<S2SV_blank>prohibited" ) ; return & EG ( error_zval_ptr ) ; ; } switch ( Z_TYPE_P ( offset ) ) { case IS_STRING : key = Z_STRVAL_P ( offset ) ; len = Z_STRLEN_P ( offset ) + 1 ; string_offest : if ( zend_symtable_find ( ht , key , len , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , "Undefined<S2SV_blank>index:<S2SV_blank>%s" , key ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , "Undefined<S2SV_blank>index:<S2SV_blank>%s" , key ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_symtable_update ( ht , key , len , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; case IS_NULL : key = "" ; len = 1 ; goto string_offest ; case IS_RESOURCE : zend_error ( E_STRICT , "Resource<S2SV_blank>ID#%ld<S2SV_blank>used<S2SV_blank>as<S2SV_blank>offset,<S2SV_blank>casting<S2SV_blank>to<S2SV_blank>integer<S2SV_blank>(%ld)" , Z_LVAL_P ( offset ) , Z_LVAL_P ( offset ) ) ; case IS_DOUBLE : case IS_BOOL : case IS_LONG : if ( offset -> type == IS_DOUBLE ) { index = ( long ) Z_DVAL_P ( offset ) ; } else { index = Z_LVAL_P ( offset ) ; } if ( zend_hash_index_find ( ht , index , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , "Undefined<S2SV_blank>offset:<S2SV_blank>%ld" , index ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , "Undefined<S2SV_blank>offset:<S2SV_blank>%ld" , index ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_hash_index_update ( ht , index , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; default : zend_error ( E_WARNING , "Illegal<S2SV_blank>offset<S2SV_blank>type" ) ; return ( type == BP_VAR_W || type == BP_VAR_RW ) ? & EG ( error_zval_ptr ) : & EG ( uninitialized_zval_ptr ) ; } }
CWE-000 void impeg2d_next_code ( dec_state_t * ps_dec , UWORD32 u4_start_code_val ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush_to_byte_boundary ( ps_stream ) ; <S2SV_StartBug> while ( ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != u4_start_code_val ) <S2SV_EndBug> <S2SV_StartBug> && ( ps_dec -> s_bit_stream . u4_offset <= ps_dec -> s_bit_stream . u4_max_offset ) ) <S2SV_EndBug> { if ( impeg2d_bit_stream_get ( ps_stream , 8 ) != 0 ) { } } return ; }
CWE-264 <S2SV_StartBug> static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) <S2SV_EndBug> { <S2SV_StartBug> switch ( ctxt -> op_bytes ) { <S2SV_EndBug> case 2 : ctxt -> _eip = ( u16 ) dst ; break ; case 4 : ctxt -> _eip = ( u32 ) dst ; break ; case 8 : ctxt -> _eip = dst ; break ; default : WARN ( 1 , "unsupported<S2SV_blank>eip<S2SV_blank>assignment<S2SV_blank>size\\n" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-362 static int snd_timer_user_release ( struct inode * inode , struct file * file ) { struct snd_timer_user * tu ; if ( file -> private_data ) { tu = file -> private_data ; file -> private_data = NULL ; <S2SV_StartBug> if ( tu -> timeri ) <S2SV_EndBug> <S2SV_StartBug> snd_timer_close ( tu -> timeri ) ; <S2SV_EndBug> kfree ( tu -> queue ) ; kfree ( tu -> tqueue ) ; kfree ( tu ) ; } return 0 ; }
CWE-189 Datum ltree_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; char * ptr ; nodeitem * list , * lptr ; int num = 0 , totallen = 0 ; int state = LTPRS_WAITNAME ; ltree * result ; ltree_level * curlevel ; int charlen ; int pos = 0 ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( charlen == 1 && t_iseq ( ptr , '.' ) ) num ++ ; ptr += charlen ; } <S2SV_StartBug> list = lptr = ( nodeitem * ) palloc ( sizeof ( nodeitem ) * ( num + 1 ) ) ; <S2SV_EndBug> ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( state == LTPRS_WAITNAME ) { if ( ISALNUM ( ptr ) ) { lptr -> start = ptr ; lptr -> wlen = 0 ; state = LTPRS_WAITDELIM ; } else UNCHAR ; } else if ( state == LTPRS_WAITDELIM ) { if ( charlen == 1 && t_iseq ( ptr , '.' ) ) { lptr -> len = ptr - lptr -> start ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( "name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) , errdetail ( "Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>" "be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d." , lptr -> wlen , pos ) ) ) ; totallen += MAXALIGN ( lptr -> len + LEVEL_HDRSIZE ) ; lptr ++ ; state = LTPRS_WAITNAME ; } else if ( ! ISALNUM ( ptr ) ) UNCHAR ; } else elog ( ERROR , "internal<S2SV_blank>error<S2SV_blank>in<S2SV_blank>parser" ) ; ptr += charlen ; lptr -> wlen ++ ; pos ++ ; } if ( state == LTPRS_WAITDELIM ) { lptr -> len = ptr - lptr -> start ; if ( lptr -> wlen > 255 ) ereport ( ERROR , ( errcode ( ERRCODE_NAME_TOO_LONG ) , errmsg ( "name<S2SV_blank>of<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) , errdetail ( "Name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>" "be<S2SV_blank><<S2SV_blank>256,<S2SV_blank>in<S2SV_blank>position<S2SV_blank>%d." , lptr -> wlen , pos ) ) ) ; totallen += MAXALIGN ( lptr -> len + LEVEL_HDRSIZE ) ; lptr ++ ; } else if ( ! ( state == LTPRS_WAITNAME && lptr == list ) ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( "syntax<S2SV_blank>error" ) , errdetail ( "Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>line." ) ) ) ; result = ( ltree * ) palloc0 ( LTREE_HDRSIZE + totallen ) ; SET_VARSIZE ( result , LTREE_HDRSIZE + totallen ) ; result -> numlevel = lptr - list ; curlevel = LTREE_FIRST ( result ) ; lptr = list ; while ( lptr - list < result -> numlevel ) { curlevel -> len = ( uint16 ) lptr -> len ; memcpy ( curlevel -> name , lptr -> start , lptr -> len ) ; curlevel = LEVEL_NEXT ( curlevel ) ; lptr ++ ; } pfree ( list ) ; PG_RETURN_POINTER ( result ) ; }
CWE-119 static int fwnet_incoming_packet ( struct fwnet_device * dev , __be32 * buf , int len , int source_node_id , int generation , bool is_broadcast ) { struct sk_buff * skb ; struct net_device * net = dev -> netdev ; struct rfc2734_header hdr ; unsigned lf ; unsigned long flags ; struct fwnet_peer * peer ; struct fwnet_partial_datagram * pd ; int fg_off ; int dg_size ; u16 datagram_label ; int retval ; u16 ether_type ; <S2SV_StartBug> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; <S2SV_EndBug> lf = fwnet_get_hdr_lf ( & hdr ) ; if ( lf == RFC2374_HDR_UNFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; buf ++ ; len -= RFC2374_UNFRAG_HDR_SIZE ; skb = dev_alloc_skb ( len + LL_RESERVED_SPACE ( net ) ) ; if ( unlikely ( ! skb ) ) { net -> stats . rx_dropped ++ ; return - ENOMEM ; } skb_reserve ( skb , LL_RESERVED_SPACE ( net ) ) ; memcpy ( skb_put ( skb , len ) , buf , len ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , is_broadcast , ether_type ) ; } <S2SV_StartBug> hdr . w1 = ntohl ( buf [ 1 ] ) ; <S2SV_EndBug> buf += 2 ; len -= RFC2374_FRAG_HDR_SIZE ; if ( lf == RFC2374_HDR_FIRSTFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; fg_off = 0 ; } else { ether_type = 0 ; fg_off = fwnet_get_hdr_fg_off ( & hdr ) ; } datagram_label = fwnet_get_hdr_dgl ( & hdr ) ; dg_size = fwnet_get_hdr_dg_size ( & hdr ) ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ; if ( ! peer ) { retval = - ENOENT ; goto fail ; } pd = fwnet_pd_find ( peer , datagram_label ) ; if ( pd == NULL ) { while ( peer -> pdg_size >= FWNET_MAX_FRAGMENTS ) { fwnet_pd_delete ( list_first_entry ( & peer -> pd_list , struct fwnet_partial_datagram , pd_link ) ) ; peer -> pdg_size -- ; } pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { retval = - ENOMEM ; goto fail ; } peer -> pdg_size ++ ; } else { if ( fwnet_frag_overlap ( pd , fg_off , len ) || pd -> datagram_size != dg_size ) { fwnet_pd_delete ( pd ) ; pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } else { if ( ! fwnet_pd_update ( peer , pd , buf , fg_off , len ) ) { fwnet_pd_delete ( pd ) ; peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } } if ( lf == RFC2374_HDR_FIRSTFRAG ) pd -> ether_type = ether_type ; if ( fwnet_pd_is_complete ( pd ) ) { ether_type = pd -> ether_type ; peer -> pdg_size -- ; skb = skb_get ( pd -> skb ) ; fwnet_pd_delete ( pd ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , false , ether_type ) ; } retval = 0 ; fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ; return retval ; }
CWE-119 void vp8_update_gf_useage_maps ( VP8_COMP * cpi , VP8_COMMON * cm , MACROBLOCK * x ) { int mb_row , mb_col ; MODE_INFO * this_mb_mode_info = cm -> mi ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; if ( ( cm -> frame_type == KEY_FRAME ) || ( cm -> refresh_golden_frame ) ) { <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; } else { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( ( this_mb_mode_info -> mbmi . ref_frame == GOLDEN_FRAME ) || ( this_mb_mode_info -> mbmi . ref_frame == ALTREF_FRAME ) ) { if ( * ( x -> gf_active_ptr ) == 0 ) { * ( x -> gf_active_ptr ) = 1 ; cpi -> gf_active_count ++ ; } } else if ( ( this_mb_mode_info -> mbmi . mode != ZEROMV ) && * ( x -> gf_active_ptr ) ) { * ( x -> gf_active_ptr ) = 0 ; cpi -> gf_active_count -- ; } x -> gf_active_ptr ++ ; this_mb_mode_info ++ ; } this_mb_mode_info ++ ; } } }
CWE-119 grub_err_t grub_disk_read ( grub_disk_t disk , grub_disk_addr_t sector , grub_off_t offset , grub_size_t size , void * buf ) { char * tmp_buf ; unsigned real_offset ; if ( grub_disk_adjust_range ( disk , & sector , & offset , size ) != GRUB_ERR_NONE ) { grub_error_push ( ) ; grub_dprintf ( "disk" , "Read<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>sector<S2SV_blank>0x%llx<S2SV_blank>(%s).\\n" , ( unsigned long long ) sector , grub_errmsg ) ; grub_error_pop ( ) ; return grub_errno ; } real_offset = offset ; tmp_buf = grub_malloc ( GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS ) ; if ( ! tmp_buf ) return grub_errno ; while ( size ) { char * data ; grub_disk_addr_t start_sector ; grub_size_t len ; grub_size_t pos ; start_sector = sector & ~ ( GRUB_DISK_CACHE_SIZE - 1 ) ; pos = ( sector - start_sector ) << GRUB_DISK_SECTOR_BITS ; len = ( ( GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS ) - pos - real_offset ) ; if ( len > size ) len = size ; data = grub_disk_cache_fetch ( disk -> dev -> id , disk -> id , start_sector ) ; if ( data ) { <S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> grub_memcpy ( buf , data + pos + real_offset , len ) ; <S2SV_EndBug> grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ; } else { if ( start_sector + GRUB_DISK_CACHE_SIZE > disk -> total_sectors || ( disk -> dev -> read ) ( disk , start_sector , GRUB_DISK_CACHE_SIZE , tmp_buf ) != GRUB_ERR_NONE ) { unsigned num ; char * p ; grub_errno = GRUB_ERR_NONE ; num = ( ( size + real_offset + GRUB_DISK_SECTOR_SIZE - 1 ) >> GRUB_DISK_SECTOR_BITS ) ; p = grub_realloc ( tmp_buf , num << GRUB_DISK_SECTOR_BITS ) ; if ( ! p ) goto finish ; tmp_buf = p ; if ( ( disk -> dev -> read ) ( disk , sector , num , tmp_buf ) ) { grub_error_push ( ) ; grub_dprintf ( "disk" , "%s<S2SV_blank>read<S2SV_blank>failed\\n" , disk -> name ) ; grub_error_pop ( ) ; goto finish ; } if ( buf ) grub_memcpy ( buf , tmp_buf + real_offset , size ) ; if ( disk -> read_hook ) while ( size ) { grub_size_t to_read ; to_read = size ; if ( real_offset + to_read > GRUB_DISK_SECTOR_SIZE ) to_read = GRUB_DISK_SECTOR_SIZE - real_offset ; ( disk -> read_hook ) ( sector , real_offset , to_read , disk -> closure ) ; if ( grub_errno != GRUB_ERR_NONE ) goto finish ; sector ++ ; size -= to_read ; real_offset = 0 ; } goto finish ; } if ( buf ) grub_memcpy ( buf , tmp_buf + pos + real_offset , len ) ; grub_disk_cache_store ( disk -> dev -> id , disk -> id , start_sector , tmp_buf ) ; } if ( disk -> read_hook ) { grub_disk_addr_t s = sector ; grub_size_t l = len ; while ( l ) { ( disk -> read_hook ) ( s , real_offset , ( ( l > GRUB_DISK_SECTOR_SIZE ) ? GRUB_DISK_SECTOR_SIZE : l ) , disk -> closure ) ; if ( l < GRUB_DISK_SECTOR_SIZE - real_offset ) break ; s ++ ; l -= GRUB_DISK_SECTOR_SIZE - real_offset ; real_offset = 0 ; } } sector = start_sector + GRUB_DISK_CACHE_SIZE ; if ( buf ) buf = ( char * ) buf + len ; size -= len ; real_offset = 0 ; } finish : grub_free ( tmp_buf ) ; return grub_errno ; }
CWE-399 static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) { gint len , remaining ; char * text ; if ( offset % 2 ) offset += 2 - ( offset % 2 ) ; <S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> if ( remaining <= 0 ) { if ( data ) * data = g_strdup ( "" ) ; return offset ; } text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ; len = ( int ) strlen ( text ) ; proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ; if ( data ) * data = text ; else g_free ( text ) ; return offset + ( len + 1 ) * 2 ; }
CWE-000 int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> goto csum_copy_err ; } <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv_offset ( msg , skb , sizeof ( struct udphdr ) ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; cond_resched ( ) ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
CWE-000 asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) <S2SV_StartBug> { <S2SV_EndBug> console_verbose ( ) ; pr_crit ( "Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n" , handler [ reason ] , esr ) ; <S2SV_StartBug> die ( "Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode" , regs , 0 ) ; <S2SV_EndBug> local_irq_disable ( ) ; panic ( "bad<S2SV_blank>mode" ) ; }
CWE-119 void unix_inflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 int main ( int argc , char * argv [ ] ) { FILE * iplist = NULL ; plist_t root_node = NULL ; char * plist_out = NULL ; uint32_t size = 0 ; int read_size = 0 ; char * plist_entire = NULL ; struct stat filestats ; options_t * options = parse_arguments ( argc , argv ) ; if ( ! options ) { print_usage ( argc , argv ) ; return 0 ; } iplist = fopen ( options -> in_file , "rb" ) ; if ( ! iplist ) { free ( options ) ; return 1 ; } <S2SV_StartBug> stat ( options -> in_file , & filestats ) ; <S2SV_EndBug> plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ; read_size = fread ( plist_entire , sizeof ( char ) , filestats . st_size , iplist ) ; fclose ( iplist ) ; if ( memcmp ( plist_entire , "bplist00" , 8 ) == 0 ) { plist_from_bin ( plist_entire , read_size , & root_node ) ; plist_to_xml ( root_node , & plist_out , & size ) ; } else { plist_from_xml ( plist_entire , read_size , & root_node ) ; plist_to_bin ( root_node , & plist_out , & size ) ; } plist_free ( root_node ) ; free ( plist_entire ) ; if ( plist_out ) { if ( options -> out_file != NULL ) { FILE * oplist = fopen ( options -> out_file , "wb" ) ; if ( ! oplist ) { free ( options ) ; return 1 ; } fwrite ( plist_out , size , sizeof ( char ) , oplist ) ; fclose ( oplist ) ; } else fwrite ( plist_out , size , sizeof ( char ) , stdout ) ; free ( plist_out ) ; } else printf ( "ERROR:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>input<S2SV_blank>file.\\n" ) ; free ( options ) ; return 0 ; }
CWE-200 WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( "\\nForbidden<S2SV_blank>bit<S2SV_blank>set<S2SV_blank>in<S2SV_blank>Nal<S2SV_blank>Unit,<S2SV_blank>Let\'s<S2SV_blank>try\\n" ) ; } u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ps_dec -> u1_pic_decode_done != 1 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; } ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_first_byte ) ) ; switch ( u1_nal_unit_type ) { case SLICE_DATA_PARTITION_A_NAL : case SLICE_DATA_PARTITION_B_NAL : case SLICE_DATA_PARTITION_C_NAL : if ( ! ps_dec -> i4_decode_header ) ih264d_parse_slice_partition ( ps_dec , ps_bitstrm ) ; break ; case IDR_SLICE_NAL : case SLICE_NAL : DEBUG_THREADS_PRINTF ( "Decoding<S2SV_blank><S2SV_blank>a<S2SV_blank>slice<S2SV_blank>NAL\\n" ) ; if ( ! ps_dec -> i4_decode_header ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u4_slice_start_code_found = 1 ; ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_decode_slice ( ( UWORD8 ) ( u1_nal_unit_type == IDR_SLICE_NAL ) , u1_nal_ref_idc , ps_dec ) ; <S2SV_StartBug> if ( ( ps_dec -> u4_first_slice_in_pic != 0 ) && <S2SV_EndBug> ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) ) { ps_dec -> u4_first_slice_in_pic = 1 ; } if ( i_status != OK ) { return i_status ; } } else { H264_DEC_DEBUG_PRINT ( "\\nSlice<S2SV_blank>NAL<S2SV_blank>Supplied<S2SV_blank>but<S2SV_blank>no<S2SV_blank>header<S2SV_blank>has<S2SV_blank>been<S2SV_blank>supplied\\n" ) ; } } break ; case SEI_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sei_message ( ps_dec , ps_bitstrm ) ; if ( i_status != OK ) return i_status ; ih264d_parse_sei ( ps_dec , ps_bitstrm ) ; } break ; case SEQ_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_sps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x1 ; break ; case PIC_PARAM_NAL : ih264d_rbsp_to_sodb ( ps_dec -> ps_bitstrm ) ; i_status = ih264d_parse_pps ( ps_dec , ps_bitstrm ) ; if ( i_status == ERROR_INV_SPS_PPS_T ) return i_status ; if ( ! i_status ) ps_dec -> i4_header_decoded |= 0x2 ; break ; case ACCESS_UNIT_DELIMITER_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_access_unit_delimiter_rbsp ( ps_dec ) ; } break ; case END_OF_STREAM_RBSP : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_end_of_stream ( ps_dec ) ; } break ; case FILLER_DATA_NAL : if ( ! ps_dec -> i4_decode_header ) { ih264d_parse_filler_data ( ps_dec , ps_bitstrm ) ; } break ; default : H264_DEC_DEBUG_PRINT ( "\\nUnknown<S2SV_blank>NAL<S2SV_blank>type<S2SV_blank>%d\\n" , u1_nal_unit_type ) ; break ; } } } return i_status ; }
CWE-264 static struct mnt_namespace * dup_mnt_ns ( struct mnt_namespace * mnt_ns , struct user_namespace * user_ns , struct fs_struct * fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old = mnt_ns -> root ; struct mount * new ; int copy_flags ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; down_write ( & namespace_sem ) ; copy_flags = CL_COPY_ALL | CL_EXPIRE ; if ( user_ns != mnt_ns -> user_ns ) <S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { up_write ( & namespace_sem ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; br_write_unlock ( & vfsmount_lock ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; if ( fs ) { if ( & p -> mnt == fs -> root . mnt ) { fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == fs -> pwd . mnt ) { fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; } up_write ( & namespace_sem ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }
CWE-000 void sas_unregister_dev ( struct asd_sas_port * port , struct domain_device * dev ) { if ( ! test_bit ( SAS_DEV_DESTROY , & dev -> state ) && ! list_empty ( & dev -> disco_list_node ) ) { list_del_init ( & dev -> disco_list_node ) ; sas_rphy_free ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; return ; } if ( ! test_and_set_bit ( SAS_DEV_DESTROY , & dev -> state ) ) { sas_rphy_unlink ( dev -> rphy ) ; list_move_tail ( & dev -> disco_list_node , & port -> destroy_list ) ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_DESTRUCT ) ; <S2SV_EndBug> } }
CWE-200 static int vivid_fb_ioctl ( struct fb_info * info , unsigned cmd , unsigned long arg ) { struct vivid_dev * dev = ( struct vivid_dev * ) info -> par ; switch ( cmd ) { case FBIOGET_VBLANK : { <S2SV_StartBug> struct fb_vblank vblank ; <S2SV_EndBug> vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ; vblank . count = 0 ; vblank . vcount = 0 ; vblank . hcount = 0 ; if ( copy_to_user ( ( void __user * ) arg , & vblank , sizeof ( vblank ) ) ) return - EFAULT ; return 0 ; } default : dprintk ( dev , 1 , "Unknown<S2SV_blank>ioctl<S2SV_blank>%08x\\n" , cmd ) ; return - EINVAL ; } return 0 ; }
CWE-787 static void load_xref_from_plaintext ( FILE * fp , xref_t * xref ) { int i , buf_idx , obj_id , added_entries ; char c , buf [ 32 ] = { 0 } ; long start , pos ; start = ftell ( fp ) ; pos = xref -> end ; fseek ( fp , pos , SEEK_SET ) ; while ( ftell ( fp ) != 0 ) if ( SAFE_F ( fp , ( fgetc ( fp ) == '/' && fgetc ( fp ) == 'S' ) ) ) break ; else SAFE_E ( fseek ( fp , -- pos , SEEK_SET ) , 0 , "Failed<S2SV_blank>seek<S2SV_blank>to<S2SV_blank>xref<S2SV_blank>/Size.\\n" ) ; SAFE_E ( fread ( buf , 1 , 21 , fp ) , 21 , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>entry<S2SV_blank>Size<S2SV_blank>string.\\n" ) ; xref -> n_entries = atoi ( buf + strlen ( "ize<S2SV_blank>" ) ) ; <S2SV_StartBug> xref -> entries = calloc ( 1 , xref -> n_entries * sizeof ( struct _xref_entry ) ) ; <S2SV_EndBug> obj_id = 0 ; fseek ( fp , xref -> start + strlen ( "xref" ) , SEEK_SET ) ; added_entries = 0 ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) { c = fgetc ( fp ) ; while ( c == '\\n' || c == '\\r' ) c = fgetc ( fp ) ; buf_idx = 0 ; while ( c != '\\n' && c != '\\r' && ! feof ( fp ) && ! ferror ( fp ) && buf_idx < sizeof ( buf ) ) { buf [ buf_idx ++ ] = c ; c = fgetc ( fp ) ; } if ( buf_idx >= sizeof ( buf ) ) { ERR ( "Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>newline<S2SV_blank>character.<S2SV_blank>" "This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n" ) ; exit ( EXIT_FAILURE ) ; } buf [ buf_idx ] = '\\0' ; if ( strchr ( buf , 't' ) ) break ; if ( strlen ( buf ) > 17 ) { xref -> entries [ i ] . obj_id = obj_id ++ ; xref -> entries [ i ] . offset = atol ( strtok ( buf , "<S2SV_blank>" ) ) ; xref -> entries [ i ] . gen_num = atoi ( strtok ( NULL , "<S2SV_blank>" ) ) ; xref -> entries [ i ] . f_or_n = buf [ 17 ] ; ++ added_entries ; } else { obj_id = atoi ( buf ) ; -- i ; } } xref -> n_entries = added_entries ; fseek ( fp , start , SEEK_SET ) ; }
CWE-119 static int vp8_rdcost_mby ( MACROBLOCK * mb ) { int cost = 0 ; int b ; MACROBLOCKD * x = & mb -> e_mbd ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; <S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; for ( b = 0 ; b < 16 ; b ++ ) cost += cost_coeffs ( mb , x -> block + b , PLANE_TYPE_Y_NO_DC , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; cost += cost_coeffs ( mb , x -> block + 24 , PLANE_TYPE_Y2 , ta + vp8_block2above [ 24 ] , tl + vp8_block2left [ 24 ] ) ; return cost ; }
CWE-119 static void ctrycatchfinally ( JF , js_Ast * trystm , js_Ast * catchvar , js_Ast * catchstm , js_Ast * finallystm ) { int L1 , L2 , L3 ; L1 = emitjump ( J , F , OP_TRY ) ; { L2 = emitjump ( J , F , OP_TRY ) ; { cstm ( J , F , finallystm ) ; emit ( J , F , OP_THROW ) ; } label ( J , F , L2 ) ; if ( F -> strict ) { checkfutureword ( J , F , catchvar ) ; if ( ! strcmp ( catchvar -> string , "arguments" ) ) jsC_error ( J , catchvar , "redefining<S2SV_blank>\'arguments\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>strict<S2SV_blank>mode" ) ; if ( ! strcmp ( catchvar -> string , "eval" ) ) jsC_error ( J , catchvar , "redefining<S2SV_blank>\'eval\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>strict<S2SV_blank>mode" ) ; } emitline ( J , F , catchvar ) ; emitstring ( J , F , OP_CATCH , catchvar -> string ) ; cstm ( J , F , catchstm ) ; emit ( J , F , OP_ENDCATCH ) ; <S2SV_StartBug> L3 = emitjump ( J , F , OP_JUMP ) ; <S2SV_EndBug> } label ( J , F , L1 ) ; cstm ( J , F , trystm ) ; emit ( J , F , OP_ENDTRY ) ; label ( J , F , L3 ) ; cstm ( J , F , finallystm ) ; }
CWE-119 static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { <S2SV_StartBug> skb = sock_alloc_send_skb ( sk , <S2SV_EndBug> hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_StartBug> skb -> csum = 0 ; <S2SV_EndBug> } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } kfree_skb ( skb ) ; return err ; }
CWE-000 static void lockd_down_net ( struct svc_serv * serv , struct net * net ) { struct lockd_net * ln = net_generic ( net , lockd_net_id ) ; if ( ln -> nlmsvc_users ) { if ( -- ln -> nlmsvc_users == 0 ) { nlm_shutdown_hosts_net ( net ) ; <S2SV_StartBug> cancel_delayed_work_sync ( & ln -> grace_period_end ) ; <S2SV_EndBug> locks_end_grace ( & ln -> lockd_manager ) ; svc_shutdown_net ( serv , net ) ; dprintk ( "lockd_down_net:<S2SV_blank>per-net<S2SV_blank>data<S2SV_blank>destroyed;<S2SV_blank>net=%p\\n" , net ) ; } } else { printk ( KERN_ERR "lockd_down_net:<S2SV_blank>no<S2SV_blank>users!<S2SV_blank>task=%p,<S2SV_blank>net=%p\\n" , nlmsvc_task , net ) ; BUG ( ) ; } }
CWE-119 int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , "PACK" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; <S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug> if ( len == PKT_LEN_SIZE ) { * head = NULL ; * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ACK" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "NAK" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , "ERR<S2SV_blank>" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ok" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ng" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "unpack" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }
CWE-476 int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( "Sending<S2SV_blank>CONNECT\\n" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ; <S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> pr_debug ( "SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\n" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CONNECT , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , service_name_tlv , service_name_tlv_length ) ; llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( "error<S2SV_blank>%d\\n" , err ) ; kfree ( service_name_tlv ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
CWE-264 static int read_exceptions ( struct pstore * ps , int ( * callback ) ( void * callback_context , chunk_t old , chunk_t new ) , void * callback_context ) { int r , full = 1 ; for ( ps -> current_area = 0 ; full ; ps -> current_area ++ ) { r = area_io ( ps , READ ) ; if ( r ) return r ; r = insert_exceptions ( ps , callback , callback_context , & full ) ; if ( r ) return r ; } ps -> current_area -- ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-284 int btsock_thread_post_cmd ( int h , int type , const unsigned char * data , int size , uint32_t user_id ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( "invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( "cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created.<S2SV_blank>socket<S2SV_blank>thread<S2SV_blank>may<S2SV_blank>not<S2SV_blank>initialized" ) ; return FALSE ; } sock_cmd_t cmd = { CMD_USER_PRIVATE , 0 , type , size , user_id } ; APPL_TRACE_DEBUG ( "post<S2SV_blank>cmd<S2SV_blank>type:%d,<S2SV_blank>size:%d,<S2SV_blank>h:%d,<S2SV_blank>" , type , size , h ) ; sock_cmd_t * cmd_send = & cmd ; int size_send = sizeof ( cmd ) ; if ( data && size ) { size_send = sizeof ( cmd ) + size ; cmd_send = ( sock_cmd_t * ) alloca ( size_send ) ; if ( cmd_send ) { * cmd_send = cmd ; memcpy ( cmd_send + 1 , data , size ) ; } else { APPL_TRACE_ERROR ( "alloca<S2SV_blank>failed<S2SV_blank>at<S2SV_blank>h:%d,<S2SV_blank>cmd<S2SV_blank>type:%d,<S2SV_blank>size:%d" , h , type , size_send ) ; return FALSE ; } } <S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , cmd_send , size_send , 0 ) == size_send ; <S2SV_EndBug> }
CWE-000 krb5_error_code kdc_process_s4u2self_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , krb5_const_principal client_princ , krb5_const_principal header_srv_princ , krb5_boolean issuing_referral , const krb5_db_entry * server , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_timestamp kdc_time , krb5_pa_s4u_x509_user * * s4u_x509_user , krb5_db_entry * * princ_ptr , const char * * status ) { krb5_error_code code ; krb5_boolean is_local_tgt ; krb5_pa_data * pa_data ; int flags ; krb5_db_entry * princ ; * princ_ptr = NULL ; pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_S4U_X509_USER ) ; if ( pa_data != NULL ) { code = kdc_process_s4u_x509_user ( kdc_context , request , pa_data , tgs_subkey , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else { pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_FOR_USER ) ; if ( pa_data != NULL ) { code = kdc_process_for_user ( kdc_active_realm , pa_data , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else return 0 ; } flags = 0 ; switch ( krb5_princ_type ( kdc_context , request -> server ) ) { case KRB5_NT_SRV_HST : if ( krb5_princ_size ( kdc_context , request -> server ) == 2 ) flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM ; break ; case KRB5_NT_ENTERPRISE_PRINCIPAL : flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE ; break ; default : break ; } if ( ! krb5_principal_compare_flags ( kdc_context , request -> server , client_princ , flags ) ) { * status = "INVALID_S4U2SELF_REQUEST" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = "INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS" ; return KRB5KDC_ERR_BADOPTION ; } is_local_tgt = ! is_cross_tgs_principal ( header_srv_princ ) ; if ( is_local_tgt && issuing_referral ) { * status = "LOOKING_UP_SERVER" ; return KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; } if ( is_local_principal ( kdc_active_realm , ( * s4u_x509_user ) -> user_id . user ) ) { krb5_db_entry no_server ; krb5_pa_data * * e_data = NULL ; if ( ! is_local_tgt && ! issuing_referral ) { * status = "NOT_CROSS_REALM_REQUEST" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } code = krb5_db_get_principal ( kdc_context , ( * s4u_x509_user ) -> user_id . user , KRB5_KDB_FLAG_INCLUDE_PAC , & princ ) ; if ( code == KRB5_KDB_NOENTRY ) { * status = "UNKNOWN_S4U2SELF_PRINCIPAL" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } else if ( code ) { * status = "LOOKING_UP_S4U2SELF_PRINCIPAL" ; return code ; } memset ( & no_server , 0 , sizeof ( no_server ) ) ; <S2SV_StartBug> code = validate_as_request ( kdc_active_realm , request , * princ , <S2SV_EndBug> no_server , kdc_time , status , & e_data ) ; if ( code ) { krb5_db_free_principal ( kdc_context , princ ) ; krb5_free_pa_data ( kdc_context , e_data ) ; return code ; } * princ_ptr = princ ; } else if ( is_local_tgt ) { * status = "S4U2SELF_CLIENT_NOT_OURS" ; return KRB5KDC_ERR_POLICY ; } return 0 ; }
CWE-000 static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) <S2SV_StartBug> { <S2SV_EndBug> if ( ! to_vmx ( vcpu ) -> nested . vmxon ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; } return 1 ; }
CWE-119 void vp8_init_mbmode_probs ( VP8_COMMON * x ) { <S2SV_StartBug> vpx_memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ; <S2SV_EndBug> }
CWE-000 int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { <S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> return - ENOTSUPP ; return 1 ; }
CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
CWE-119 static void down2_symodd ( const uint8_t * const input , int length , uint8_t * output ) { <S2SV_StartBug> static const int16_t * filter = vp9_down2_symodd_half_filter ; <S2SV_EndBug> const int filter_len_half = sizeof ( vp9_down2_symodd_half_filter ) / 2 ; int i , j ; uint8_t * optr = output ; int l1 = filter_len_half - 1 ; int l2 = ( length - filter_len_half + 1 ) ; l1 += ( l1 & 1 ) ; l2 += ( l2 & 1 ) ; if ( l1 > l2 ) { for ( i = 0 ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ ( i + j >= length ? length - 1 : i + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } else { for ( i = 0 ; i < l1 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ i + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < l2 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ i + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) + input [ i ] * filter [ 0 ] ; for ( j = 1 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ ( i + j >= length ? length - 1 : i + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } }
CWE-476 static int skcipher_setkey ( void * private , const u8 * key , unsigned int keylen ) { <S2SV_StartBug> return crypto_skcipher_setkey ( private , key , keylen ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static int fill_autodev ( const struct lxc_rootfs * rootfs ) { int ret ; char path [ MAXPATHLEN ] ; int i ; mode_t cmask ; INFO ( "Creating<S2SV_blank>initial<S2SV_blank>consoles<S2SV_blank>under<S2SV_blank>container<S2SV_blank>/dev" ) ; ret = snprintf ( path , MAXPATHLEN , "%s/dev" , rootfs -> path ? rootfs -> mount : "" ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { ERROR ( "Error<S2SV_blank>calculating<S2SV_blank>container<S2SV_blank>/dev<S2SV_blank>location" ) ; return - 1 ; } if ( ! dir_exists ( path ) ) return 0 ; INFO ( "Populating<S2SV_blank>container<S2SV_blank>/dev" ) ; cmask = umask ( S_IXUSR | S_IXGRP | S_IXOTH ) ; for ( i = 0 ; i < sizeof ( lxc_devs ) / sizeof ( lxc_devs [ 0 ] ) ; i ++ ) { const struct lxc_devs * d = & lxc_devs [ i ] ; ret = snprintf ( path , MAXPATHLEN , "%s/dev/%s" , rootfs -> path ? rootfs -> mount : "" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; ret = mknod ( path , d -> mode , makedev ( d -> maj , d -> min ) ) ; if ( ret && errno != EEXIST ) { char hostpath [ MAXPATHLEN ] ; FILE * pathfile ; ret = snprintf ( hostpath , MAXPATHLEN , "/dev/%s" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; pathfile = fopen ( path , "wb" ) ; if ( ! pathfile ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>device<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\'%s\'" , path ) ; return - 1 ; } fclose ( pathfile ) ; <S2SV_StartBug> if ( mount ( hostpath , path , 0 , MS_BIND , NULL ) != 0 ) { <S2SV_EndBug> SYSERROR ( "Failed<S2SV_blank>bind<S2SV_blank>mounting<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>host<S2SV_blank>into<S2SV_blank>container" , d -> name ) ; return - 1 ; } } } umask ( cmask ) ; INFO ( "Populated<S2SV_blank>container<S2SV_blank>/dev" ) ; return 0 ; }
CWE-119 int vp8_refining_search_sadx4 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; for ( i = 0 ; i < search_range ; i ++ ) { int best_site = - 1 ; int all_in = 1 ; all_in &= ( ( ref_mv -> as_mv . row - 1 ) > x -> mv_row_min ) ; all_in &= ( ( ref_mv -> as_mv . row + 1 ) < x -> mv_row_max ) ; all_in &= ( ( ref_mv -> as_mv . col - 1 ) > x -> mv_col_min ) ; all_in &= ( ( ref_mv -> as_mv . col + 1 ) < x -> mv_col_max ) ; if ( all_in ) { unsigned int sad_array [ 4 ] ; const unsigned char * block_offset [ 4 ] ; block_offset [ 0 ] = best_address - in_what_stride ; block_offset [ 1 ] = best_address - 1 ; block_offset [ 2 ] = best_address + 1 ; block_offset [ 3 ] = best_address + in_what_stride ; fn_ptr -> sdx4df ( what , what_stride , block_offset , in_what_stride , sad_array ) ; for ( j = 0 ; j < 4 ; j ++ ) { if ( sad_array [ j ] < bestsad ) { this_mv . as_mv . row = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_mv . as_mv . col = ref_mv -> as_mv . col + neighbors [ j ] . col ; sad_array [ j ] += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( sad_array [ j ] < bestsad ) { bestsad = sad_array [ j ] ; best_site = j ; } } } } else { for ( j = 0 ; j < 4 ; j ++ ) { this_row_offset = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_col_offset = ref_mv -> as_mv . col + neighbors [ j ] . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = j ; } } } } } if ( best_site == - 1 ) break ; else { ref_mv -> as_mv . row += neighbors [ best_site ] . row ; ref_mv -> as_mv . col += neighbors [ best_site ] . col ; best_address += ( neighbors [ best_site ] . row ) * in_what_stride + neighbors [ best_site ] . col ; } } this_mv . as_mv . row = ref_mv -> as_mv . row * 8 ; this_mv . as_mv . col = ref_mv -> as_mv . col * 8 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
CWE-119 static void mt_decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ; <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above ; unsigned char * yleft ; int left_stride ; unsigned char top_left ; if ( i < 4 && pbi -> common . filter_level ) Above = xd -> recon_above [ 0 ] + b -> offset ; else Above = dst - dst_stride ; if ( i % 4 == 0 && pbi -> common . filter_level ) { yleft = xd -> recon_left [ 0 ] + i ; left_stride = 1 ; } else { yleft = dst - 1 ; left_stride = dst_stride ; } if ( ( i == 4 || i == 8 || i == 12 ) && pbi -> common . filter_level ) top_left = * ( xd -> recon_left [ 0 ] + i - 1 ) ; else top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }
CWE-119 <S2SV_StartBug> void vp9_setup_dst_planes ( MACROBLOCKD * xd , <S2SV_EndBug> const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <S2SV_StartBug> struct macroblockd_plane * const pd = & xd -> plane [ i ] ; <S2SV_EndBug> setup_pred_plane ( & pd -> dst , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , pd -> subsampling_x , pd -> subsampling_y ) ; } }
CWE-125 static int lha_read_file_header_1 ( struct archive_read * a , struct lha * lha ) { const unsigned char * p ; size_t extdsize ; int i , err , err2 ; int namelen , padding ; unsigned char headersum , sum_calculated ; err = ARCHIVE_OK ; if ( ( p = __archive_read_ahead ( a , H1_FIXED_SIZE , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; lha -> header_size = p [ H1_HEADER_SIZE_OFFSET ] + 2 ; headersum = p [ H1_HEADER_SUM_OFFSET ] ; lha -> compsize = archive_le32dec ( p + H1_COMP_SIZE_OFFSET ) ; lha -> origsize = archive_le32dec ( p + H1_ORIG_SIZE_OFFSET ) ; lha -> mtime = lha_dos_time ( p + H1_DOS_TIME_OFFSET ) ; namelen = p [ H1_NAME_LEN_OFFSET ] ; padding = ( ( int ) lha -> header_size ) - H1_FIXED_SIZE - namelen ; if ( namelen > 230 || padding < 0 ) goto invalid ; if ( ( p = __archive_read_ahead ( a , lha -> header_size , NULL ) ) == NULL ) return ( truncated_error ( a ) ) ; for ( i = 0 ; i < namelen ; i ++ ) { if ( p [ i + H1_FILE_NAME_OFFSET ] == 0xff ) goto invalid ; } archive_strncpy ( & lha -> filename , p + H1_FILE_NAME_OFFSET , namelen ) ; lha -> crc = archive_le16dec ( p + H1_FILE_NAME_OFFSET + namelen ) ; lha -> setflag |= CRC_IS_SET ; sum_calculated = lha_calcsum ( 0 , p , 2 , lha -> header_size - 2 ) ; __archive_read_consume ( a , lha -> header_size - 2 ) ; err2 = lha_read_file_extended_header ( a , lha , NULL , 2 , ( size_t ) ( lha -> compsize + 2 ) , & extdsize ) ; if ( err2 < ARCHIVE_WARN ) return ( err2 ) ; if ( err2 < err ) err = err2 ; lha -> compsize -= extdsize - 2 ; <S2SV_StartBug> if ( sum_calculated != headersum ) { <S2SV_EndBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error" ) ; return ( ARCHIVE_FATAL ) ; } return ( err ) ; invalid : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>LHa<S2SV_blank>header" ) ; return ( ARCHIVE_FATAL ) ; }
CWE-119 void vp8_dequant_idct_add_uv_block_c ( short * q , short * dq , unsigned char * dstu , unsigned char * dstv , int stride , char * eobs ) { int i , j ; for ( i = 0 ; i < 2 ; i ++ ) { for ( j = 0 ; j < 2 ; j ++ ) { if ( * eobs ++ > 1 ) vp8_dequant_idct_add_c ( q , dq , dstu , stride ) ; else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 16 ; dstu += 4 ; } dstu += 4 * stride - 8 ; } for ( i = 0 ; i < 2 ; i ++ ) { for ( j = 0 ; j < 2 ; j ++ ) { if ( * eobs ++ > 1 ) vp8_dequant_idct_add_c ( q , dq , dstv , stride ) ; else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 16 ; dstv += 4 ; } dstv += 4 * stride - 8 ; } }
CWE-000 <S2SV_StartBug> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <S2SV_EndBug> { int c ; unsigned int value ; do { c = ReadBlobByte ( image ) ; if ( c == EOF ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } while ( ( c == '<S2SV_blank>' ) || ( c == '\\t' ) || ( c == '\\n' ) || ( c == '\\r' ) ) ; value = 0 ; while ( hex_digits [ c ] >= 0 ) { if ( value > ( unsigned int ) ( INT_MAX / 10 ) ) break ; value *= 16 ; c &= 0xff ; if ( value > ( unsigned int ) ( INT_MAX - hex_digits [ c ] ) ) break ; value += hex_digits [ c ] ; c = ReadBlobByte ( image ) ; if ( c == EOF ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } <S2SV_StartBug> return ( value ) ; <S2SV_EndBug> }
CWE-119 static void init_encode_frame_mb_context ( VP9_COMP * cpi ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; <S2SV_StartBug> x -> act_zbin_adj = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; <S2SV_EndBug> vp9_setup_pre_planes ( xd , 0 , get_ref_frame_buffer ( cpi , LAST_FRAME ) , 0 , 0 , NULL ) ; vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , 0 , 0 ) ; vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; <S2SV_EndBug> xd -> mi [ 0 ] -> mbmi . uv_mode = DC_PRED ; vpx_memset ( xd -> above_context [ 0 ] , 0 , sizeof ( * xd -> above_context [ 0 ] ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ; <S2SV_StartBug> vpx_memset ( xd -> above_seg_context , 0 , <S2SV_EndBug> sizeof ( * xd -> above_seg_context ) * aligned_mi_cols ) ; }
CWE-264 static void otp_verify ( krb5_context context , krb5_data * req_pkt , krb5_kdc_req * request , krb5_enc_tkt_part * enc_tkt_reply , krb5_pa_data * pa , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_verify_respond_fn respond , void * arg ) { krb5_keyblock * armor_key = NULL ; krb5_pa_otp_req * req = NULL ; struct request_state * rs ; krb5_error_code retval ; krb5_data d , plaintext ; char * config ; <S2SV_StartBug> enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; <S2SV_EndBug> armor_key = cb -> fast_armor ( context , rock ) ; if ( armor_key == NULL ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; com_err ( "otp" , retval , "No<S2SV_blank>armor<S2SV_blank>key<S2SV_blank>found<S2SV_blank>when<S2SV_blank>verifying<S2SV_blank>padata" ) ; goto error ; } d = make_data ( pa -> contents , pa -> length ) ; retval = decode_krb5_pa_otp_req ( & d , & req ) ; if ( retval != 0 ) { com_err ( "otp" , retval , "Unable<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>OTP<S2SV_blank>request" ) ; goto error ; } retval = decrypt_encdata ( context , armor_key , req , & plaintext ) ; if ( retval != 0 ) { com_err ( "otp" , retval , "Unable<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>nonce" ) ; goto error ; } retval = nonce_verify ( context , armor_key , & plaintext ) ; if ( retval != 0 ) retval = timestamp_verify ( context , & plaintext ) ; krb5_free_data_contents ( context , & plaintext ) ; if ( retval != 0 ) { com_err ( "otp" , retval , "Unable<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>nonce<S2SV_blank>or<S2SV_blank>timestamp" ) ; goto error ; } rs = k5alloc ( sizeof ( struct request_state ) , & retval ) ; if ( rs == NULL ) goto error ; rs -> arg = arg ; <S2SV_StartBug> rs -> respond = respond ; <S2SV_EndBug> retval = cb -> get_string ( context , rock , "otp" , & config ) ; if ( retval == 0 && config == NULL ) retval = KRB5_PREAUTH_FAILED ; if ( retval != 0 ) { free ( rs ) ; goto error ; } otp_state_verify ( ( otp_state * ) moddata , cb -> event_context ( context , rock ) , request -> client , config , req , on_response , rs ) ; cb -> free_string ( context , rock , config ) ; k5_free_pa_otp_req ( context , req ) ; return ; error : k5_free_pa_otp_req ( context , req ) ; ( * respond ) ( arg , retval , NULL , NULL , NULL ) ; }
CWE-119 int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { <S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }
CWE-000 static void inf_gtk_certificate_manager_certificate_func ( InfXmppConnection * connection , gnutls_session_t session , InfCertificateChain * chain , gpointer user_data ) { InfGtkCertificateManager * manager ; InfGtkCertificateManagerPrivate * priv ; InfGtkCertificateDialogFlags flags ; gnutls_x509_crt_t presented_cert ; gnutls_x509_crt_t known_cert ; gchar * hostname ; gboolean match_hostname ; gboolean issuer_known ; gnutls_x509_crt_t root_cert ; int ret ; unsigned int verify ; GHashTable * table ; gboolean cert_equal ; time_t expiration_time ; InfGtkCertificateManagerQuery * query ; gchar * text ; GtkWidget * vbox ; GtkWidget * label ; GError * error ; manager = INF_GTK_CERTIFICATE_MANAGER ( user_data ) ; priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE ( manager ) ; g_object_get ( G_OBJECT ( connection ) , "remote-hostname" , & hostname , NULL ) ; presented_cert = inf_certificate_chain_get_own_certificate ( chain ) ; match_hostname = gnutls_x509_crt_check_hostname ( presented_cert , hostname ) ; ret = gnutls_certificate_verify_peers2 ( session , & verify ) ; error = NULL ; if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ; if ( error == NULL ) { issuer_known = TRUE ; if ( verify & GNUTLS_CERT_SIGNER_NOT_FOUND ) { issuer_known = FALSE ; root_cert = inf_certificate_chain_get_root_certificate ( chain ) ; ret = gnutls_x509_crt_list_verify ( inf_certificate_chain_get_raw ( chain ) , inf_certificate_chain_get_n_certificates ( chain ) , & root_cert , 1 , NULL , 0 , GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT , & verify ) ; if ( ret != GNUTLS_E_SUCCESS ) inf_gnutls_set_error ( & error , ret ) ; <S2SV_StartBug> else if ( verify & GNUTLS_CERT_INVALID ) <S2SV_EndBug> inf_gnutls_certificate_verification_set_error ( & error , verify ) ; <S2SV_StartBug> } <S2SV_EndBug> } table = NULL ; if ( error == NULL ) { known_cert = NULL ; if ( ! match_hostname || ! issuer_known ) { table = inf_gtk_certificate_manager_ref_known_hosts ( manager , & error ) ; if ( table != NULL ) known_cert = g_hash_table_lookup ( table , hostname ) ; } } flags = 0 ; if ( error == NULL ) { if ( known_cert != NULL ) { cert_equal = inf_gtk_certificate_manager_compare_fingerprint ( known_cert , presented_cert , & error ) ; if ( error == NULL && cert_equal == FALSE ) { if ( ! match_hostname ) flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH ; if ( ! issuer_known ) flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN ; flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED ; expiration_time = gnutls_x509_crt_get_expiration_time ( known_cert ) ; if ( expiration_time != ( time_t ) ( - 1 ) ) { expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE ; if ( time ( NULL ) > expiration_time ) { flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED ; } } } } else { if ( ! match_hostname ) flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH ; if ( ! issuer_known ) flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN ; } } if ( error == NULL ) { if ( flags == 0 ) { if ( match_hostname && issuer_known ) { if ( table != NULL && g_hash_table_remove ( table , hostname ) == TRUE ) { inf_gtk_certificate_manager_write_known_hosts_with_warning ( manager , table ) ; } } inf_xmpp_connection_certificate_verify_continue ( connection ) ; } else { query = g_slice_new ( InfGtkCertificateManagerQuery ) ; query -> manager = manager ; query -> known_hosts = table ; query -> connection = connection ; query -> dialog = inf_gtk_certificate_dialog_new ( priv -> parent_window , 0 , flags , hostname , chain ) ; query -> certificate_chain = chain ; table = NULL ; g_object_ref ( query -> connection ) ; inf_certificate_chain_ref ( chain ) ; g_signal_connect ( G_OBJECT ( connection ) , "notify::status" , G_CALLBACK ( inf_gtk_certificate_manager_notify_status_cb ) , query ) ; g_signal_connect ( G_OBJECT ( query -> dialog ) , "response" , G_CALLBACK ( inf_gtk_certificate_manager_response_cb ) , query ) ; gtk_dialog_add_button ( GTK_DIALOG ( query -> dialog ) , _ ( "_Cancel<S2SV_blank>connection" ) , GTK_RESPONSE_REJECT ) ; gtk_dialog_add_button ( GTK_DIALOG ( query -> dialog ) , _ ( "C_ontinue<S2SV_blank>connection" ) , GTK_RESPONSE_ACCEPT ) ; text = g_strdup_printf ( _ ( "Do<S2SV_blank>you<S2SV_blank>want<S2SV_blank>to<S2SV_blank>continue<S2SV_blank>the<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>host<S2SV_blank>\\"%s\\"?<S2SV_blank>If<S2SV_blank>you<S2SV_blank>" "choose<S2SV_blank>to<S2SV_blank>continue,<S2SV_blank>this<S2SV_blank>certificate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>trusted<S2SV_blank>in<S2SV_blank>the<S2SV_blank>" "future<S2SV_blank>when<S2SV_blank>connecting<S2SV_blank>to<S2SV_blank>this<S2SV_blank>host." ) , hostname ) ; label = gtk_label_new ( text ) ; gtk_label_set_line_wrap ( GTK_LABEL ( label ) , TRUE ) ; gtk_label_set_line_wrap_mode ( GTK_LABEL ( label ) , PANGO_WRAP_WORD_CHAR ) ; gtk_label_set_max_width_chars ( GTK_LABEL ( label ) , 60 ) ; gtk_misc_set_alignment ( GTK_MISC ( label ) , 0.0 , 0.0 ) ; gtk_widget_show ( label ) ; g_free ( text ) ; vbox = gtk_dialog_get_content_area ( GTK_DIALOG ( query -> dialog ) ) ; gtk_box_pack_start ( GTK_BOX ( vbox ) , label , FALSE , FALSE , 0 ) ; priv -> queries = g_slist_prepend ( priv -> queries , query ) ; gtk_window_present ( GTK_WINDOW ( query -> dialog ) ) ; } } else { inf_xmpp_connection_certificate_verify_cancel ( connection , error ) ; g_error_free ( error ) ; } if ( table != NULL ) g_hash_table_unref ( table ) ; g_free ( hostname ) ; }
CWE-000 static CURLcode pop3_parse_url_path ( struct connectdata * conn ) { struct pop3_conn * pop3c = & conn -> proto . pop3c ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! pop3c -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
CWE-189 static __inline__ void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }
CWE-284 void _moddeinit ( module_unload_intent_t intent ) { service_named_unbind_command ( "chanserv" , & cs_flags ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-200 static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , "entering<S2SV_blank>CDROM_DRIVE_STATUS\\n" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }
CWE-000 int am_check_url ( request_rec * r , const char * url ) { const char * i ; for ( i = url ; * i ; i ++ ) { if ( * i >= 0 && * i < '<S2SV_blank>' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , "Control<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; } <S2SV_StartBug> } <S2SV_EndBug> return OK ; }
CWE-119 static bool ldm_frag_add ( const u8 * data , int size , struct list_head * frags ) { struct frag * f ; struct list_head * item ; int rec , num , group ; BUG_ON ( ! data || ! frags ) ; if ( size < 2 * VBLK_SIZE_HEAD ) { ldm_error ( "Value<S2SV_blank>of<S2SV_blank>size<S2SV_blank>is<S2SV_blank>to<S2SV_blank>small." ) ; return false ; } group = get_unaligned_be32 ( data + 0x08 ) ; rec = get_unaligned_be16 ( data + 0x0C ) ; num = get_unaligned_be16 ( data + 0x0E ) ; if ( ( num < 1 ) || ( num > 4 ) ) { ldm_error ( "A<S2SV_blank>VBLK<S2SV_blank>claims<S2SV_blank>to<S2SV_blank>have<S2SV_blank>%d<S2SV_blank>parts." , num ) ; return false ; } if ( rec >= num ) { ldm_error ( "REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)" , rec , num ) ; return false ; } list_for_each ( item , frags ) { f = list_entry ( item , struct frag , list ) ; if ( f -> group == group ) goto found ; } f = kmalloc ( sizeof ( * f ) + size * num , GFP_KERNEL ) ; if ( ! f ) { ldm_crit ( "Out<S2SV_blank>of<S2SV_blank>memory." ) ; return false ; } f -> group = group ; f -> num = num ; f -> rec = rec ; f -> map = 0xFF << num ; list_add_tail ( & f -> list , frags ) ; found : <S2SV_StartBug> if ( f -> map & ( 1 << rec ) ) { <S2SV_EndBug> ldm_error ( "Duplicate<S2SV_blank>VBLK,<S2SV_blank>part<S2SV_blank>%d." , rec ) ; f -> map &= 0x7F ; return false ; } f -> map |= ( 1 << rec ) ; data += VBLK_SIZE_HEAD ; size -= VBLK_SIZE_HEAD ; memcpy ( f -> data + rec * ( size - VBLK_SIZE_HEAD ) + VBLK_SIZE_HEAD , data , size ) ; return true ; }
CWE-20 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> ret = - ENOKEY ; goto error2 ; } ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
CWE-264 static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; <S2SV_StartBug> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }
CWE-362 void snd_timer_interrupt ( struct snd_timer * timer , unsigned long ticks_left ) { struct snd_timer_instance * ti , * ts , * tmp ; unsigned long resolution , ticks ; struct list_head * p , * ack_list_head ; unsigned long flags ; int use_tasklet = 0 ; if ( timer == NULL ) return ; spin_lock_irqsave ( & timer -> lock , flags ) ; if ( timer -> hw . c_resolution ) resolution = timer -> hw . c_resolution ( timer ) ; else resolution = timer -> hw . resolution ; list_for_each_entry_safe ( ti , tmp , & timer -> active_list_head , active_list ) { if ( ! ( ti -> flags & SNDRV_TIMER_IFLG_RUNNING ) ) continue ; ti -> pticks += ticks_left ; ti -> resolution = resolution ; if ( ti -> cticks < ticks_left ) ti -> cticks = 0 ; else ti -> cticks -= ticks_left ; if ( ti -> cticks ) continue ; if ( ti -> flags & SNDRV_TIMER_IFLG_AUTO ) { ti -> cticks = ti -> ticks ; } else { ti -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; if ( -- timer -> running ) <S2SV_StartBug> list_del ( & ti -> active_list ) ; <S2SV_EndBug> } if ( ( timer -> hw . flags & SNDRV_TIMER_HW_TASKLET ) || ( ti -> flags & SNDRV_TIMER_IFLG_FAST ) ) ack_list_head = & timer -> ack_list_head ; else ack_list_head = & timer -> sack_list_head ; if ( list_empty ( & ti -> ack_list ) ) list_add_tail ( & ti -> ack_list , ack_list_head ) ; list_for_each_entry ( ts , & ti -> slave_active_head , active_list ) { ts -> pticks = ti -> pticks ; ts -> resolution = resolution ; if ( list_empty ( & ts -> ack_list ) ) list_add_tail ( & ts -> ack_list , ack_list_head ) ; } } if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) snd_timer_reschedule ( timer , timer -> sticks ) ; if ( timer -> running ) { if ( timer -> hw . flags & SNDRV_TIMER_HW_STOP ) { timer -> hw . stop ( timer ) ; timer -> flags |= SNDRV_TIMER_FLG_CHANGE ; } if ( ! ( timer -> hw . flags & SNDRV_TIMER_HW_AUTO ) || ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) ) { timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; timer -> hw . start ( timer ) ; } } else { timer -> hw . stop ( timer ) ; } while ( ! list_empty ( & timer -> ack_list_head ) ) { p = timer -> ack_list_head . next ; ti = list_entry ( p , struct snd_timer_instance , ack_list ) ; list_del_init ( p ) ; ticks = ti -> pticks ; ti -> pticks = 0 ; ti -> flags |= SNDRV_TIMER_IFLG_CALLBACK ; spin_unlock ( & timer -> lock ) ; if ( ti -> callback ) ti -> callback ( ti , resolution , ticks ) ; spin_lock ( & timer -> lock ) ; ti -> flags &= ~ SNDRV_TIMER_IFLG_CALLBACK ; } use_tasklet = ! list_empty ( & timer -> sack_list_head ) ; spin_unlock_irqrestore ( & timer -> lock , flags ) ; if ( use_tasklet ) tasklet_schedule ( & timer -> task_queue ) ; }
CWE-119 xmlChar * xmlStringLenDecodeEntities ( xmlParserCtxtPtr ctxt , const xmlChar * str , int len , int what , xmlChar end , xmlChar end2 , xmlChar end3 ) { xmlChar * buffer = NULL ; int buffer_size = 0 ; xmlChar * current = NULL ; xmlChar * rep = NULL ; const xmlChar * last ; xmlEntityPtr ent ; int c , l ; int nbchars = 0 ; if ( ( ctxt == NULL ) || ( str == NULL ) || ( len < 0 ) ) return ( NULL ) ; last = str + len ; if ( ( ( ctxt -> depth > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> depth > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; return ( NULL ) ; } buffer_size = XML_PARSER_BIG_BUFFER_SIZE ; buffer = ( xmlChar * ) xmlMallocAtomic ( buffer_size * sizeof ( xmlChar ) ) ; if ( buffer == NULL ) goto mem_error ; if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; while ( ( c != 0 ) && ( c != end ) && ( c != end2 ) && ( c != end3 ) ) { if ( c == 0 ) break ; if ( ( c == '&' ) && ( str [ 1 ] == '#' ) ) { int val = xmlParseStringCharRef ( ctxt , & str ) ; if ( val != 0 ) { COPY_BUF ( 0 , buffer , nbchars , val ) ; } if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else if ( ( c == '&' ) && ( what & XML_SUBSTITUTE_REF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , "String<S2SV_blank>decoding<S2SV_blank>Entity<S2SV_blank>Reference:<S2SV_blank>%.30s\\n" , str ) ; ent = xmlParseStringEntityRef ( ctxt , & str ) ; if ( ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) || ( ctxt -> lastError . code == XML_ERR_INTERNAL_ERROR ) ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( ent -> content != NULL ) { COPY_BUF ( 0 , buffer , nbchars , ent -> content [ 0 ] ) ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else { xmlFatalErrMsg ( ctxt , XML_ERR_INTERNAL_ERROR , "predefined<S2SV_blank>entity<S2SV_blank>has<S2SV_blank>no<S2SV_blank>content\\n" ) ; } } else if ( ( ent != NULL ) && ( ent -> content != NULL ) ) { ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; buffer [ nbchars ++ ] = '&' ; if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) { <S2SV_StartBug> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <S2SV_EndBug> } for ( ; i > 0 ; i -- ) buffer [ nbchars ++ ] = * cur ++ ; buffer [ nbchars ++ ] = ';' ; } } else if ( c == '%' && ( what & XML_SUBSTITUTE_PEREF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , "String<S2SV_blank>decoding<S2SV_blank>PE<S2SV_blank>Reference:<S2SV_blank>%.30s\\n" , str ) ; ent = xmlParseStringPEReference ( ctxt , & str ) ; if ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ent != NULL ) { if ( ent -> content == NULL ) { xmlLoadEntityContent ( ctxt , ent ) ; } ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } } else { COPY_BUF ( l , buffer , nbchars , c ) ; str += l ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; } buffer [ nbchars ] = 0 ; return ( buffer ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; int_error : if ( rep != NULL ) xmlFree ( rep ) ; if ( buffer != NULL ) xmlFree ( buffer ) ; return ( NULL ) ; }
CWE-119 static void logi_dj_recv_add_djhid_device ( struct dj_receiver_dev * djrcv_dev , struct dj_report * dj_report ) { struct hid_device * djrcv_hdev = djrcv_dev -> hdev ; struct usb_interface * intf = to_usb_interface ( djrcv_hdev -> dev . parent ) ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct hid_device * dj_hiddev ; struct dj_device * dj_dev ; unsigned char tmpstr [ 3 ] ; if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY ) { dbg_hid ( "%s:<S2SV_blank>device<S2SV_blank>list<S2SV_blank>is<S2SV_blank>empty\\n" , __func__ ) ; djrcv_dev -> querying_devices = false ; return ; } <S2SV_StartBug> if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || <S2SV_EndBug> ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & djrcv_hdev -> dev , "%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n" , __func__ , dj_report -> device_index ) ; return ; } if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] ) { dbg_hid ( "%s:<S2SV_blank>device<S2SV_blank>is<S2SV_blank>already<S2SV_blank>known\\n" , __func__ ) ; return ; } dj_hiddev = hid_allocate_device ( ) ; if ( IS_ERR ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , "%s:<S2SV_blank>hid_allocate_device<S2SV_blank>failed\\n" , __func__ ) ; return ; } dj_hiddev -> ll_driver = & logi_dj_ll_driver ; dj_hiddev -> dev . parent = & djrcv_hdev -> dev ; dj_hiddev -> bus = BUS_USB ; dj_hiddev -> vendor = le16_to_cpu ( usbdev -> descriptor . idVendor ) ; dj_hiddev -> product = le16_to_cpu ( usbdev -> descriptor . idProduct ) ; snprintf ( dj_hiddev -> name , sizeof ( dj_hiddev -> name ) , "Logitech<S2SV_blank>Unifying<S2SV_blank>Device.<S2SV_blank>Wireless<S2SV_blank>PID:%02x%02x" , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_MSB ] , dj_report -> report_params [ DEVICE_PAIRED_PARAM_EQUAD_ID_LSB ] ) ; usb_make_path ( usbdev , dj_hiddev -> phys , sizeof ( dj_hiddev -> phys ) ) ; snprintf ( tmpstr , sizeof ( tmpstr ) , ":%d" , dj_report -> device_index ) ; strlcat ( dj_hiddev -> phys , tmpstr , sizeof ( dj_hiddev -> phys ) ) ; dj_dev = kzalloc ( sizeof ( struct dj_device ) , GFP_KERNEL ) ; if ( ! dj_dev ) { dev_err ( & djrcv_hdev -> dev , "%s:<S2SV_blank>failed<S2SV_blank>allocating<S2SV_blank>dj_device\\n" , __func__ ) ; goto dj_device_allocate_fail ; } dj_dev -> reports_supported = get_unaligned_le32 ( dj_report -> report_params + DEVICE_PAIRED_RF_REPORT_TYPE ) ; dj_dev -> hdev = dj_hiddev ; dj_dev -> dj_receiver_dev = djrcv_dev ; dj_dev -> device_index = dj_report -> device_index ; dj_hiddev -> driver_data = dj_dev ; djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = dj_dev ; if ( hid_add_device ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , "%s:<S2SV_blank>failed<S2SV_blank>adding<S2SV_blank>dj_device\\n" , __func__ ) ; goto hid_add_device_fail ; } return ; hid_add_device_fail : djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] = NULL ; kfree ( dj_dev ) ; dj_device_allocate_fail : hid_destroy_device ( dj_hiddev ) ; }
CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_inter_mode ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> int ctx ) { <S2SV_StartBug> const int mode = vp9_read_tree ( r , vp9_inter_mode_tree , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . inter_mode_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . inter_mode [ ctx ] [ mode ] ; return NEARESTMV + mode ; }
CWE-000 int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , "AUTHENTICATE" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , "*" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , "*" ) ) return send_reply ( cptr , ERR_SASLFAIL , ":<S2SV_blank>service<S2SV_blank>unavailable" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , "[%s]" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) { <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> sendcmdto_one ( & me , CMD_SASL , acptr , "%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_one ( & me , CMD_SASL , acptr , "%C<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_one ( & me , CMD_SASL , acptr , "%C<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_one ( & me , CMD_SASL , acptr , "%C<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s" , acptr , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } else { if ( first ) { <S2SV_StartBug> if ( ! EmptyString ( cli_sslclifp ( cptr ) ) ) <S2SV_EndBug> sendcmdto_serv_butone ( & me , CMD_SASL , cptr , "*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>:%s" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] , cli_sslclifp ( cptr ) ) ; else sendcmdto_serv_butone ( & me , CMD_SASL , cptr , "*<S2SV_blank>%C!%u.%u<S2SV_blank>S<S2SV_blank>:%s" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; if ( feature_bool ( FEAT_SASL_SENDHOST ) ) sendcmdto_serv_butone ( & me , CMD_SASL , cptr , "*<S2SV_blank>%C!%u.%u<S2SV_blank>H<S2SV_blank>:%s@%s:%s" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , cli_username ( cptr ) , realhost , cli_sock_ip ( cptr ) ) ; } else { sendcmdto_serv_butone ( & me , CMD_SASL , cptr , "*<S2SV_blank>%C!%u.%u<S2SV_blank>C<S2SV_blank>:%s" , & me , cli_fd ( cptr ) , cli_saslcookie ( cptr ) , parv [ 1 ] ) ; } } if ( ! t_active ( & cli_sasltimeout ( cptr ) ) ) timer_add ( timer_init ( & cli_sasltimeout ( cptr ) ) , sasl_timeout_callback , ( void * ) cptr , TT_RELATIVE , feature_int ( FEAT_SASL_TIMEOUT ) ) ; return 0 ; }
CWE-399 int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , const struct tcphdr * th , unsigned int len ) { struct tcp_sock * tp = tcp_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; int queued = 0 ; int res ; tp -> rx_opt . saw_tstamp = 0 ; switch ( sk -> sk_state ) { case TCP_CLOSE : goto discard ; case TCP_LISTEN : if ( th -> ack ) return 1 ; if ( th -> rst ) goto discard ; if ( th -> syn ) { <S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> return 1 ; kfree_skb ( skb ) ; return 0 ; } goto discard ; case TCP_SYN_SENT : queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; if ( queued >= 0 ) return queued ; tcp_urg ( sk , skb , th ) ; __kfree_skb ( skb ) ; tcp_data_snd_check ( sk ) ; return 0 ; } res = tcp_validate_incoming ( sk , skb , th , 0 ) ; if ( res <= 0 ) return - res ; if ( th -> ack ) { int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; switch ( sk -> sk_state ) { case TCP_SYN_RECV : if ( acceptable ) { tp -> copied_seq = tp -> rcv_nxt ; smp_mb ( ) ; tcp_set_state ( sk , TCP_ESTABLISHED ) ; sk -> sk_state_change ( sk ) ; if ( sk -> sk_socket ) sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; tp -> snd_wnd = ntohs ( th -> window ) << tp -> rx_opt . snd_wscale ; tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; if ( tp -> rx_opt . tstamp_ok ) tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; icsk -> icsk_af_ops -> rebuild_header ( sk ) ; tcp_init_metrics ( sk ) ; tcp_init_congestion_control ( sk ) ; tp -> lsndtime = tcp_time_stamp ; tcp_mtup_init ( sk ) ; tcp_initialize_rcv_mss ( sk ) ; tcp_init_buffer_space ( sk ) ; tcp_fast_path_on ( tp ) ; } else { return 1 ; } break ; case TCP_FIN_WAIT1 : if ( tp -> snd_una == tp -> write_seq ) { tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; sk -> sk_shutdown |= SEND_SHUTDOWN ; dst_confirm ( __sk_dst_get ( sk ) ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_state_change ( sk ) ; else { int tmo ; if ( tp -> linger2 < 0 || ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { tcp_done ( sk ) ; NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; return 1 ; } tmo = tcp_fin_time ( sk ) ; if ( tmo > TCP_TIMEWAIT_LEN ) { inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; } else if ( th -> fin || sock_owned_by_user ( sk ) ) { inet_csk_reset_keepalive_timer ( sk , tmo ) ; } else { tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; goto discard ; } } } break ; case TCP_CLOSING : if ( tp -> snd_una == tp -> write_seq ) { tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; goto discard ; } break ; case TCP_LAST_ACK : if ( tp -> snd_una == tp -> write_seq ) { tcp_update_metrics ( sk ) ; tcp_done ( sk ) ; goto discard ; } break ; } } else goto discard ; tcp_urg ( sk , skb , th ) ; switch ( sk -> sk_state ) { case TCP_CLOSE_WAIT : case TCP_CLOSING : case TCP_LAST_ACK : if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) break ; case TCP_FIN_WAIT1 : case TCP_FIN_WAIT2 : if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; tcp_reset ( sk ) ; return 1 ; } } case TCP_ESTABLISHED : tcp_data_queue ( sk , skb ) ; queued = 1 ; break ; } if ( sk -> sk_state != TCP_CLOSE ) { tcp_data_snd_check ( sk ) ; tcp_ack_snd_check ( sk ) ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }
CWE-119 static int au1200fb_fb_mmap ( struct fb_info * info , struct vm_area_struct * vma ) { <S2SV_StartBug> unsigned int len ; <S2SV_EndBug> unsigned long start = 0 , off ; <S2SV_StartBug> struct au1200fb_device * fbdev = info -> par ; <S2SV_EndBug> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= _CACHE_MASK ; <S2SV_StartBug> return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }
CWE-119 <S2SV_StartBug> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> ( void ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <S2SV_EndBug> lf_data -> start , lf_data -> stop , lf_data -> y_only ) ; return 1 ; }
CWE-264 void mm_release ( struct task_struct * tsk , struct mm_struct * mm ) { <S2SV_StartBug> struct completion * vfork_done = tsk -> vfork_done ; <S2SV_EndBug> deactivate_mm ( tsk , mm ) ; if ( vfork_done ) { tsk -> vfork_done = NULL ; complete ( vfork_done ) ; } if ( tsk -> clear_child_tid && ! ( tsk -> flags & PF_SIGNALED ) && atomic_read ( & mm -> mm_users ) > 1 ) { u32 __user * tidptr = tsk -> clear_child_tid ; tsk -> clear_child_tid = NULL ; put_user ( 0 , tidptr ) ; sys_futex ( tidptr , FUTEX_WAKE , 1 , NULL , NULL , 0 ) ; } }
CWE-000 STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; <S2SV_StartBug> } <S2SV_EndBug> retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; error = xfs_attr_node_addname ( args ) ; return ( error ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) return ( error ) ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_StartBug> if ( args -> rmtblkno ) { <S2SV_EndBug> error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; xfs_attr3_leaf_remove ( bp , args ) ; if ( ( forkoff = xfs_attr_shortform_allfit ( bp , dp ) ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_shortform ( bp , args , forkoff ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; } return error ; }
CWE-119 static int PredictorDecodeRow ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decoderow != NULL ) ; assert ( sp -> decodepfunc != NULL ) ; if ( ( * sp -> decoderow ) ( tif , op0 , occ0 , s ) ) { <S2SV_StartBug> ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ; <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> } else return 0 ; }
CWE-264 static void vmx_refresh_apicv_exec_ctrl ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; vmcs_write32 ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 <S2SV_StartBug> static void write_segment_id ( vp9_writer * w , const struct segmentation * seg , <S2SV_EndBug> int segment_id ) { if ( seg -> enabled && seg -> update_map ) vp9_write_tree ( w , vp9_segment_tree , seg -> tree_probs , segment_id , 3 , 0 ) ; }
CWE-119 static void is_skippable ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * argv ) { struct is_skippable_args * args = argv ; <S2SV_StartBug> args -> skippable [ 0 ] &= ( ! args -> x -> plane [ plane ] . eobs [ block ] ) ; <S2SV_EndBug> }
CWE-772 static int hwsim_new_radio_nl ( struct sk_buff * msg , struct genl_info * info ) { struct hwsim_new_radio_params param = { 0 } ; const char * hwname = NULL ; int ret ; param . reg_strict = info -> attrs [ HWSIM_ATTR_REG_STRICT_REG ] ; param . p2p_device = info -> attrs [ HWSIM_ATTR_SUPPORT_P2P_DEVICE ] ; param . channels = channels ; param . destroy_on_close = info -> attrs [ HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE ] ; if ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) param . channels = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) ; if ( info -> attrs [ HWSIM_ATTR_NO_VIF ] ) param . no_vif = true ; if ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) { hwname = kasprintf ( GFP_KERNEL , "%.*s" , nla_len ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) , ( char * ) nla_data ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) ) ; if ( ! hwname ) return - ENOMEM ; param . hwname = hwname ; } if ( info -> attrs [ HWSIM_ATTR_USE_CHANCTX ] ) param . use_chanctx = true ; else param . use_chanctx = ( param . channels > 1 ) ; if ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) param . reg_alpha2 = nla_data ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) ; if ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) { u32 idx = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) ; <S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> } ret = mac80211_hwsim_new_radio ( info , & param ) ; kfree ( hwname ) ; return ret ; }
CWE-125 static int sh_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { ut8 op_MSB , op_LSB ; int ret ; <S2SV_StartBug> if ( ! data ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> jump = op -> fail = - 1 ; op -> ptr = op -> val = - 1 ; op -> size = 2 ; op_MSB = anal -> big_endian ? data [ 0 ] : data [ 1 ] ; op_LSB = anal -> big_endian ? data [ 1 ] : data [ 0 ] ; ret = first_nibble_decode [ ( op_MSB >> 4 ) & 0x0F ] ( anal , op , ( ut16 ) ( op_MSB << 8 | op_LSB ) ) ; return ret ; }
CWE-399 static int simulate_sync ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == SPEC0 && ( opcode & FUNC ) == SYNC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return 0 ; } return - 1 ; }
CWE-362 static int sctp_setsockopt_auto_asconf ( struct sock * sk , char __user * optval , unsigned int optlen ) { int val ; struct sctp_sock * sp = sctp_sk ( sk ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; if ( ! sctp_is_ep_boundall ( sk ) && val ) return - EINVAL ; if ( ( val && sp -> do_auto_asconf ) || ( ! val && ! sp -> do_auto_asconf ) ) return 0 ; <S2SV_StartBug> if ( val == 0 && sp -> do_auto_asconf ) { <S2SV_EndBug> list_del ( & sp -> auto_asconf_list ) ; sp -> do_auto_asconf = 0 ; } else if ( val && ! sp -> do_auto_asconf ) { list_add_tail ( & sp -> auto_asconf_list , & sock_net ( sk ) -> sctp . auto_asconf_splist ) ; sp -> do_auto_asconf = 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-399 static int archive_read_format_zip_cleanup ( struct archive_read * a ) { struct zip * zip ; struct zip_entry * zip_entry , * next_zip_entry ; zip = ( struct zip * ) ( a -> format -> data ) ; # ifdef HAVE_ZLIB_H if ( zip -> stream_valid ) inflateEnd ( & zip -> stream ) ; # endif <S2SV_StartBug> # if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndBug> if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; } # endif # ifdef HAVE_BZLIB_H if ( zip -> bzstream_valid ) { BZ2_bzDecompressEnd ( & zip -> bzstream ) ; } # endif free ( zip -> uncompressed_buffer ) ; if ( zip -> ppmd8_valid ) __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; if ( zip -> zip_entries ) { zip_entry = zip -> zip_entries ; while ( zip_entry != NULL ) { next_zip_entry = zip_entry -> next ; archive_string_free ( & zip_entry -> rsrcname ) ; free ( zip_entry ) ; zip_entry = next_zip_entry ; } } free ( zip -> decrypted_buffer ) ; if ( zip -> cctx_valid ) archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; if ( zip -> hctx_valid ) archive_hmac_sha1_cleanup ( & zip -> hctx ) ; free ( zip -> iv ) ; free ( zip -> erd ) ; free ( zip -> v_data ) ; archive_string_free ( & zip -> format_name ) ; free ( zip ) ; ( a -> format -> data ) = NULL ; return ( ARCHIVE_OK ) ; }
CWE-399 int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x0500 : goto simple ; case 0x0B00 : break ; case 0x0F00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) != 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; case 0x0900 : break ; case 0x0D00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) == 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; } break ; case 0xA000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; break ; case 0xB000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; } break ; } return ret ; simple : ret = handle_unaligned_ins ( instruction , regs , ma ) ; if ( ret == 0 ) regs -> pc += instruction_size ( instruction ) ; return ret ; }
CWE-119 <S2SV_StartBug> static int read_segment_id ( vp9_reader * r , const struct segmentation * seg ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; <S2SV_EndBug> }
CWE-416 static struct ucounts * get_ucounts ( struct user_namespace * ns , kuid_t uid ) { struct hlist_head * hashent = ucounts_hashentry ( ns , uid ) ; struct ucounts * ucounts , * new ; spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ! ucounts ) { spin_unlock_irq ( & ucounts_lock ) ; new = kzalloc ( sizeof ( * new ) , GFP_KERNEL ) ; if ( ! new ) return NULL ; new -> ns = ns ; new -> uid = uid ; <S2SV_StartBug> atomic_set ( & new -> count , 0 ) ; <S2SV_EndBug> spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ucounts ) { kfree ( new ) ; } else { hlist_add_head ( & new -> node , hashent ) ; ucounts = new ; } } <S2SV_StartBug> if ( ! atomic_add_unless ( & ucounts -> count , 1 , INT_MAX ) ) <S2SV_EndBug> ucounts = NULL ; spin_unlock_irq ( & ucounts_lock ) ; return ucounts ; }
CWE-200 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ALIGN16 ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; return SET_IVD_FATAL_ERROR ( e_error ) ; } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_StartBug> ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; <S2SV_EndBug> impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-264 void bnep_net_setup ( struct net_device * dev ) { memset ( dev -> broadcast , 0xff , ETH_ALEN ) ; dev -> addr_len = ETH_ALEN ; ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> dev -> watchdog_timeo = HZ * 2 ; }
CWE-119 static void unqueue_me_pi ( struct futex_q * q ) { WARN_ON ( plist_node_empty ( & q -> list ) ) ; plist_del ( & q -> list , & q -> list . plist ) ; BUG_ON ( ! q -> pi_state ) ; free_pi_state ( q -> pi_state ) ; q -> pi_state = NULL ; spin_unlock ( q -> lock_ptr ) ; <S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> }
CWE-125 static void nfs_printfh ( netdissect_options * ndo , register const uint32_t * dp , const u_int len ) { my_fsid fsid ; uint32_t ino ; const char * sfsname = NULL ; char * spacep ; if ( ndo -> ndo_uflag ) { u_int i ; char const * sep = "" ; ND_PRINT ( ( ndo , "<S2SV_blank>fh[" ) ) ; for ( i = 0 ; i < len ; i ++ ) { ND_PRINT ( ( ndo , "%s%x" , sep , dp [ i ] ) ) ; sep = ":" ; } ND_PRINT ( ( ndo , "]" ) ) ; return ; } Parse_fh ( ( const u_char * ) dp , len , & fsid , & ino , NULL , & sfsname , 0 ) ; if ( sfsname ) { <S2SV_StartBug> static char temp [ NFSX_V3FHMAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; <S2SV_EndBug> <S2SV_StartBug> temp [ sizeof ( temp ) - 1 ] = '\\0' ; <S2SV_EndBug> spacep = strchr ( temp , '<S2SV_blank>' ) ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo , "<S2SV_blank>fh<S2SV_blank>%s/" , temp ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>fh<S2SV_blank>%d,%d/" , fsid . Fsid_dev . Major , fsid . Fsid_dev . Minor ) ) ; } if ( fsid . Fsid_dev . Minor == 257 ) ND_PRINT ( ( ndo , "%s" , fsid . Opaque_Handle ) ) ; else ND_PRINT ( ( ndo , "%ld" , ( long ) ino ) ) ; }
CWE-119 static ssize_t k90_show_macro_mode ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; const char * macro_mode ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>mode<S2SV_blank>(error<S2SV_blank>%d).\\n" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> switch ( data [ 0 ] ) { case K90_MACRO_MODE_HW : macro_mode = "HW" ; break ; case K90_MACRO_MODE_SW : macro_mode = "SW" ; break ; default : dev_warn ( dev , "K90<S2SV_blank>in<S2SV_blank>unknown<S2SV_blank>mode:<S2SV_blank>%02hhx.\\n" , data [ 0 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , "%s\\n" , macro_mode ) ; }
CWE-416 mrb_value mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , "o" , & orig ) ; <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; <S2SV_EndBug> if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; } <S2SV_StartBug> fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; <S2SV_EndBug> fptr_orig = io_get_open_fptr ( mrb , orig ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , "@buf" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , "@buf" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig -> sync ; fptr_copy -> is_socket = fptr_orig -> is_socket ; return copy ; }
CWE-476 static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { <S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static void accumulate_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame += frame -> frame ; <S2SV_StartBug> section -> spatial_layer_id = frame -> spatial_layer_id ; <S2SV_EndBug> section -> intra_error += frame -> intra_error ; section -> coded_error += frame -> coded_error ; section -> sr_coded_error += frame -> sr_coded_error ; <S2SV_StartBug> section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ; <S2SV_EndBug> section -> pcnt_inter += frame -> pcnt_inter ; section -> pcnt_motion += frame -> pcnt_motion ; section -> pcnt_second_ref += frame -> pcnt_second_ref ; <S2SV_StartBug> section -> pcnt_neutral += frame -> pcnt_neutral ; <S2SV_EndBug> section -> MVr += frame -> MVr ; section -> mvr_abs += frame -> mvr_abs ; section -> MVc += frame -> MVc ; section -> mvc_abs += frame -> mvc_abs ; section -> MVrv += frame -> MVrv ; section -> MVcv += frame -> MVcv ; section -> mv_in_out_count += frame -> mv_in_out_count ; section -> new_mv_count += frame -> new_mv_count ; section -> count += frame -> count ; section -> duration += frame -> duration ; }
CWE-476 static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( "Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( "MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , "<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n" , port_no , irq , dfl & SERIO_PARITY ? ",<S2SV_blank>bad<S2SV_blank>parity" : "" , dfl & SERIO_TIMEOUT ? ",<S2SV_blank>timeout" : "" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; <S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }
CWE-125 <S2SV_StartBug> int ntlm_read_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { if ( Stream_GetRemainingLength ( s ) < 12 ) return - 1 ; Stream_Read ( s , header -> Signature , 8 ) ; Stream_Read_UINT32 ( s , header -> MessageType ) ; if ( strncmp ( ( char * ) header -> Signature , NTLM_SIGNATURE , 8 ) != 0 ) return - 1 ; return 1 ; }
CWE-119 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'"\' ; <S2SV_StartBug> dlen -= 2 ; <S2SV_EndBug> for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { if ( dlen < 2 ) break ; dlen -= 2 ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'"\' ; * pt = '\\0' ; }
CWE-189 void jiffies_to_timespec ( const unsigned long jiffies , struct timespec * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <S2SV_EndBug> }
CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ; <S2SV_StartBug> proto = EXTRACT_16BITS ( & p [ 2 ] ) ; <S2SV_EndBug> if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , "%s,<S2SV_blank>ethertype<S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>" , tok2str ( chdlc_cast_values , "0x%02x" , p [ 0 ] ) , tok2str ( ethertype_values , "Unknown" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO : <S2SV_StartBug> if ( * ( p + 1 ) == 0x81 || <S2SV_EndBug> * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; else isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "unknown<S2SV_blank>CHDLC<S2SV_blank>protocol<S2SV_blank>(0x%04x)" , proto ) ) ; break ; } return ( CHDLC_HDRLEN ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-190 void * xcalloc ( size_t num , size_t size ) { <S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> if ( ptr ) { <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> } return ptr ; }
CWE-20 static int bnep_sock_ioctl ( struct socket * sock , unsigned int cmd , unsigned long arg ) { struct bnep_connlist_req cl ; struct bnep_connadd_req ca ; struct bnep_conndel_req cd ; struct bnep_conninfo ci ; struct socket * nsock ; void __user * argp = ( void __user * ) arg ; int err ; BT_DBG ( "cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%lx" , cmd , arg ) ; switch ( cmd ) { case BNEPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EACCES ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; nsock = sockfd_lookup ( ca . sock , & err ) ; if ( ! nsock ) return err ; if ( nsock -> sk -> sk_state != BT_CONNECTED ) { sockfd_put ( nsock ) ; return - EBADFD ; } <S2SV_StartBug> err = bnep_add_connection ( & ca , nsock ) ; <S2SV_EndBug> if ( ! err ) { if ( copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; } else sockfd_put ( nsock ) ; return err ; case BNEPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EACCES ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return bnep_del_connection ( & cd ) ; case BNEPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = bnep_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case BNEPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = bnep_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; default : return - EINVAL ; } return 0 ; }
CWE-119 static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; <S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> break ; <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }
CWE-787 int rds_rdma_extra_size ( struct rds_rdma_args * args ) { struct rds_iovec vec ; struct rds_iovec __user * local_vec ; int tot_pages = 0 ; unsigned int nr_pages ; unsigned int i ; <S2SV_StartBug> local_vec = ( struct rds_iovec __user * ) ( unsigned long ) args -> local_vec_addr ; <S2SV_EndBug> for ( i = 0 ; i < args -> nr_local ; i ++ ) { if ( copy_from_user ( & vec , & local_vec [ i ] , sizeof ( struct rds_iovec ) ) ) return - EFAULT ; nr_pages = rds_pages_in_vec ( & vec ) ; if ( nr_pages == 0 ) return - EINVAL ; tot_pages += nr_pages ; if ( tot_pages < 0 ) return - EINVAL ; } return tot_pages * sizeof ( struct scatterlist ) ; }
CWE-000 void w3m_exit ( int i ) { # ifdef USE_MIGEMO init_migemo ( ) ; # endif stopDownload ( ) ; deleteFiles ( ) ; # ifdef USE_SSL free_ssl_ctx ( ) ; # endif disconnectFTP ( ) ; # ifdef USE_NNTP disconnectNews ( ) ; # endif # ifdef __MINGW32_VERSION WSACleanup ( ) ; # endif <S2SV_StartBug> exit ( i ) ; <S2SV_EndBug> }
CWE-415 static OM_uint32 init_ctx_reselect ( OM_uint32 * minor_status , spnego_gss_ctx_id_t sc , OM_uint32 acc_negState , gss_OID supportedMech , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * tokflag ) { OM_uint32 tmpmin ; <S2SV_StartBug> size_t i ; <S2SV_EndBug> generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ; gss_delete_sec_context ( & tmpmin , & sc -> ctx_handle , GSS_C_NO_BUFFER ) ; for ( i = 0 ; i < sc -> mech_set -> count ; i ++ ) { if ( g_OID_equal ( supportedMech , & sc -> mech_set -> elements [ i ] ) ) break ; } if ( i == sc -> mech_set -> count ) return GSS_S_DEFECTIVE_TOKEN ; sc -> internal_mech = & sc -> mech_set -> elements [ i ] ; if ( acc_negState != REQUEST_MIC ) return GSS_S_DEFECTIVE_TOKEN ; sc -> mech_complete = 0 ; sc -> mic_reqd = 1 ; * negState = REQUEST_MIC ; * tokflag = CONT_TOKEN_SEND ; return GSS_S_CONTINUE_NEEDED ; }
CWE-362 static int ext4_split_extent_at ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , ext4_lblk_t split , int split_flag , int flags ) { ext4_fsblk_t newblock ; ext4_lblk_t ee_block ; struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex2 = NULL ; unsigned int ee_len , depth ; <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ext_debug ( "ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical" "block<S2SV_blank>%llu\\n" , inode -> i_ino , ( unsigned long long ) split ) ; ext4_ext_show_leaf ( inode , path ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; newblock = split - ee_block + ext4_ext_pblock ( ex ) ; BUG_ON ( split < ee_block || split >= ( ee_block + ee_len ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( split == ee_block ) { if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex ) ; else ext4_ext_mark_initialized ( ex ) ; if ( ! ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } memcpy ( & orig_ex , ex , sizeof ( orig_ex ) ) ; ex -> ee_len = cpu_to_le16 ( split - ee_block ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT1 ) ext4_ext_mark_uninitialized ( ex ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto fix_extent_len ; ex2 = & newex ; ex2 -> ee_block = cpu_to_le32 ( split ) ; ex2 -> ee_len = cpu_to_le16 ( ee_len - ( split - ee_block ) ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex2 ) ; err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - ENOSPC && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> if ( err ) goto fix_extent_len ; ex -> ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; fix_extent_len : ex -> ee_len = orig_ex . ee_len ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }
CWE-264 static Channel * server_request_direct_streamlocal ( void ) { Channel * c = NULL ; char * target , * originator ; u_short originator_port ; target = packet_get_string ( NULL ) ; originator = packet_get_string ( NULL ) ; originator_port = packet_get_int ( ) ; packet_check_eom ( ) ; debug ( "server_request_direct_streamlocal:<S2SV_blank>originator<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>target<S2SV_blank>%s" , originator , originator_port , target ) ; if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 && <S2SV_StartBug> ! no_port_forwarding_flag && ! options . disable_forwarding ) { <S2SV_EndBug> c = channel_connect_to_path ( target , "direct-streamlocal@openssh.com" , "direct-streamlocal" ) ; } else { logit ( "refused<S2SV_blank>streamlocal<S2SV_blank>port<S2SV_blank>forward:<S2SV_blank>" "originator<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>target<S2SV_blank>%s" , originator , originator_port , target ) ; } free ( originator ) ; free ( target ) ; return c ; }
CWE-119 int cdc_parse_cdc_header ( struct usb_cdc_parsed_header * hdr , struct usb_interface * intf , u8 * buffer , int buflen ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_header_desc * header = NULL ; struct usb_cdc_ether_desc * ether = NULL ; struct usb_cdc_mdlm_detail_desc * detail = NULL ; struct usb_cdc_mdlm_desc * desc = NULL ; unsigned int elength ; int cnt = 0 ; memset ( hdr , 0x00 , sizeof ( struct usb_cdc_parsed_header ) ) ; hdr -> phonet_magic_present = false ; while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , "skipping<S2SV_blank>garbage<S2SV_blank>byte\\n" ) ; elength = 1 ; <S2SV_StartBug> goto next_desc ; <S2SV_EndBug> } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , "skipping<S2SV_blank>garbage\\n" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , "More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; hdr -> usb_cdc_country_functional_desc = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : if ( elength != sizeof ( struct usb_cdc_header_desc ) ) goto next_desc ; if ( header ) return - EINVAL ; header = ( struct usb_cdc_header_desc * ) buffer ; break ; case USB_CDC_ACM_TYPE : if ( elength < sizeof ( struct usb_cdc_acm_descriptor ) ) goto next_desc ; hdr -> usb_cdc_acm_descriptor = ( struct usb_cdc_acm_descriptor * ) buffer ; break ; case USB_CDC_ETHERNET_TYPE : if ( elength != sizeof ( struct usb_cdc_ether_desc ) ) goto next_desc ; if ( ether ) return - EINVAL ; ether = ( struct usb_cdc_ether_desc * ) buffer ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < sizeof ( struct usb_cdc_call_mgmt_descriptor ) ) goto next_desc ; hdr -> usb_cdc_call_mgmt_descriptor = ( struct usb_cdc_call_mgmt_descriptor * ) buffer ; break ; case USB_CDC_DMM_TYPE : if ( elength < sizeof ( struct usb_cdc_dmm_desc ) ) goto next_desc ; hdr -> usb_cdc_dmm_desc = ( struct usb_cdc_dmm_desc * ) buffer ; break ; case USB_CDC_MDLM_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_desc * ) ) goto next_desc ; if ( desc ) return - EINVAL ; desc = ( struct usb_cdc_mdlm_desc * ) buffer ; break ; case USB_CDC_MDLM_DETAIL_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_detail_desc * ) ) goto next_desc ; if ( detail ) return - EINVAL ; detail = ( struct usb_cdc_mdlm_detail_desc * ) buffer ; break ; case USB_CDC_NCM_TYPE : if ( elength < sizeof ( struct usb_cdc_ncm_desc ) ) goto next_desc ; hdr -> usb_cdc_ncm_desc = ( struct usb_cdc_ncm_desc * ) buffer ; break ; case USB_CDC_MBIM_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_desc ) ) goto next_desc ; hdr -> usb_cdc_mbim_desc = ( struct usb_cdc_mbim_desc * ) buffer ; break ; case USB_CDC_MBIM_EXTENDED_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_extended_desc ) ) break ; hdr -> usb_cdc_mbim_extended_desc = ( struct usb_cdc_mbim_extended_desc * ) buffer ; break ; case CDC_PHONET_MAGIC_NUMBER : hdr -> phonet_magic_present = true ; break ; default : dev_dbg ( & intf -> dev , "Ignoring<S2SV_blank>descriptor:<S2SV_blank>type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n" , buffer [ 2 ] , elength ) ; goto next_desc ; } cnt ++ ; next_desc : buflen -= elength ; buffer += elength ; } hdr -> usb_cdc_union_desc = union_header ; hdr -> usb_cdc_header_desc = header ; hdr -> usb_cdc_mdlm_detail_desc = detail ; hdr -> usb_cdc_mdlm_desc = desc ; hdr -> usb_cdc_ether_desc = ether ; return cnt ; }
CWE-264 <S2SV_StartBug> static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) <S2SV_EndBug> { <S2SV_StartBug> assign_eip_near ( ctxt , ctxt -> _eip + rel ) ; <S2SV_EndBug> }
CWE-264 static void chase_port ( struct edgeport_port * port , unsigned long timeout , int flush ) { int baud_rate ; struct tty_struct * tty = tty_port_tty_get ( & port -> port -> port ) ; struct usb_serial * serial = port -> port -> serial ; wait_queue_t wait ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> if ( ! timeout ) timeout = ( HZ * EDGE_CLOSING_WAIT ) / 100 ; spin_lock_irqsave ( & port -> ep_lock , flags ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tty -> write_wait , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; if ( kfifo_len ( & port -> write_fifo ) == 0 || timeout == 0 || signal_pending ( current ) || serial -> disconnected ) break ; spin_unlock_irqrestore ( & port -> ep_lock , flags ) ; timeout = schedule_timeout ( timeout ) ; spin_lock_irqsave ( & port -> ep_lock , flags ) ; } set_current_state ( TASK_RUNNING ) ; remove_wait_queue ( & tty -> write_wait , & wait ) ; if ( flush ) kfifo_reset_out ( & port -> write_fifo ) ; spin_unlock_irqrestore ( & port -> ep_lock , flags ) ; tty_kref_put ( tty ) ; timeout += jiffies ; while ( ( long ) ( jiffies - timeout ) < 0 && ! signal_pending ( current ) && ! serial -> disconnected ) { if ( ! tx_active ( port ) ) break ; msleep ( 10 ) ; } if ( serial -> disconnected ) return ; baud_rate = port -> baud_rate ; if ( baud_rate == 0 ) baud_rate = 50 ; msleep ( max ( 1 , DIV_ROUND_UP ( 10000 , baud_rate ) ) ) ; }
CWE-119 <S2SV_StartBug> static int prob_diff_update_cost ( vp9_prob newp , vp9_prob oldp ) { <S2SV_EndBug> int delp = remap_prob ( newp , oldp ) ; return update_bits [ delp ] * 256 ; }
CWE-125 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
CWE-000 long join_session_keyring ( const char * name ) { const struct cred * old ; struct cred * new ; struct key * keyring ; long ret , serial ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; old = current_cred ( ) ; if ( ! name ) { ret = install_session_keyring_to_cred ( new , NULL ) ; if ( ret < 0 ) goto error ; serial = new -> session_keyring -> serial ; ret = commit_creds ( new ) ; if ( ret == 0 ) ret = serial ; goto okay ; } mutex_lock ( & key_session_mutex ) ; keyring = find_keyring_by_name ( name , false ) ; if ( PTR_ERR ( keyring ) == - ENOKEY ) { keyring = keyring_alloc ( name , old -> uid , old -> gid , old , KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( keyring ) ) { ret = PTR_ERR ( keyring ) ; goto error2 ; } } else if ( IS_ERR ( keyring ) ) { ret = PTR_ERR ( keyring ) ; goto error2 ; } else if ( keyring == new -> session_keyring ) { <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> goto error2 ; } ret = install_session_keyring_to_cred ( new , keyring ) ; if ( ret < 0 ) goto error2 ; commit_creds ( new ) ; mutex_unlock ( & key_session_mutex ) ; ret = keyring -> serial ; key_put ( keyring ) ; okay : return ret ; error2 : mutex_unlock ( & key_session_mutex ) ; error : abort_creds ( new ) ; return ret ; }
CWE-787 WORD32 ixheaacd_real_synth_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD32 num_columns , FLOAT32 qmf_buf_real [ ] [ 64 ] , FLOAT32 qmf_buf_imag [ ] [ 64 ] ) { WORD32 i , j , k , l , idx ; FLOAT32 g [ 640 ] ; FLOAT32 w [ 640 ] ; FLOAT32 synth_out [ 128 ] ; FLOAT32 accu_r ; WORD32 synth_size = ptr_hbe_txposer -> synth_size ; FLOAT32 * ptr_cos_tab_trans_qmf = ( FLOAT32 * ) & ixheaacd_cos_table_trans_qmf [ 0 ] [ 0 ] + ptr_hbe_txposer -> k_start * 32 ; FLOAT32 * buffer = ptr_hbe_txposer -> synth_buf ; for ( idx = 0 ; idx < num_columns ; idx ++ ) { FLOAT32 loc_qmf_buf [ 64 ] ; FLOAT32 * synth_buf_r = loc_qmf_buf ; FLOAT32 * out_buf = ptr_hbe_txposer -> ptr_input_buf + ( idx + 1 ) * ptr_hbe_txposer -> synth_size ; FLOAT32 * synth_cos_tab = ptr_hbe_txposer -> synth_cos_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> synth_wind_coeff ; if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ; for ( k = 0 ; k < synth_size ; k ++ ) { WORD32 ki = ptr_hbe_txposer -> k_start + k ; synth_buf_r [ k ] = ( FLOAT32 ) ( ptr_cos_tab_trans_qmf [ ( k << 1 ) + 0 ] * qmf_buf_real [ idx ] [ ki ] + ptr_cos_tab_trans_qmf [ ( k << 1 ) + 1 ] * qmf_buf_imag [ idx ] [ ki ] ) ; synth_buf_r [ k + ptr_hbe_txposer -> synth_size ] = 0 ; } for ( l = ( 20 * synth_size - 1 ) ; l >= 2 * synth_size ; l -- ) { buffer [ l ] = buffer [ l - 2 * synth_size ] ; } if ( synth_size == 20 ) { FLOAT32 * psynth_cos_tab = synth_cos_tab ; for ( l = 0 ; l < ( synth_size + 1 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ synth_size - l ] = accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } for ( l = ( synth_size + 1 ) ; l < ( 2 * synth_size - synth_size / 2 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ 3 * synth_size - l ] = - accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 3 * synth_size >> 1 ] = accu_r ; } else { FLOAT32 tmp ; FLOAT32 * ptr_u = synth_out ; WORD32 kmax = ( synth_size >> 1 ) ; FLOAT32 * syn_buf = & buffer [ kmax ] ; kmax += synth_size ; <S2SV_StartBug> if ( ixheaacd_real_synth_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } syn_buf = & buffer [ 0 ] ; kmax -= synth_size ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } } for ( i = 0 ; i < 5 ; i ++ ) { memcpy ( & g [ ( 2 * i + 0 ) * synth_size ] , & buffer [ ( 4 * i + 0 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; memcpy ( & g [ ( 2 * i + 1 ) * synth_size ] , & buffer [ ( 4 * i + 3 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; } for ( k = 0 ; k < 10 * synth_size ; k ++ ) { w [ k ] = g [ k ] * interp_window_coeff [ k ] ; } for ( i = 0 ; i < synth_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 10 ; j ++ ) { accu_r = accu_r + w [ synth_size * j + i ] ; } out_buf [ i ] = ( FLOAT32 ) accu_r ; } } return 0 ; }
CWE-000 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , "%s/.asoundrc" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , "Error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link\\n" , dest ) ; exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <S2SV_StartBug> if ( rv ) <S2SV_EndBug> fprintf ( stderr , "Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n" ) ; else { <S2SV_StartBug> fs_logger2 ( "clone" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }
CWE-000 static int treo_attach ( struct usb_serial * serial ) { struct usb_serial_port * swap_port ; if ( ! ( ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == HANDSPRING_VENDOR_ID ) || ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == KYOCERA_VENDOR_ID ) ) || ( serial -> num_interrupt_in == 0 ) ) return 0 ; <S2SV_StartBug> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <S2SV_EndBug> swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ; if ( ! swap_port ) return - ENOMEM ; COPY_PORT ( swap_port , serial -> port [ 0 ] ) ; COPY_PORT ( serial -> port [ 0 ] , serial -> port [ 1 ] ) ; COPY_PORT ( serial -> port [ 1 ] , swap_port ) ; kfree ( swap_port ) ; return 0 ; }
CWE-200 static mode_t set_umask ( const char * optarg ) { long umask_long ; mode_t umask_val ; char * endptr ; umask_long = strtoll ( optarg , & endptr , 0 ) ; if ( * endptr || umask_long < 0 || umask_long & ~ 0777L ) { fprintf ( stderr , "Invalid<S2SV_blank>--umask<S2SV_blank>option<S2SV_blank>%s" , optarg ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } umask_val = umask_long & 0777 ; umask ( umask_val ) ; umask_cmdline = true ; return umask_val ; }
CWE-399 <S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> { struct xenvif * vif ; struct pending_tx_info * pending_tx_info ; pending_ring_idx_t index ; if ( netbk -> mmap_pages [ pending_idx ] == NULL ) return ; pending_tx_info = & netbk -> pending_tx_info [ pending_idx ] ; vif = pending_tx_info -> vif ; <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> index = pending_index ( netbk -> pending_prod ++ ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; netbk -> mmap_pages [ pending_idx ] -> mapping = 0 ; put_page ( netbk -> mmap_pages [ pending_idx ] ) ; netbk -> mmap_pages [ pending_idx ] = NULL ; }
CWE-125 static int decode_multicast_vpn ( netdissect_options * ndo , const u_char * pptr , char * buf , u_int buflen ) { uint8_t route_type , route_length , addr_length , sg_length ; u_int offset ; ND_TCHECK2 ( pptr [ 0 ] , 2 ) ; route_type = * pptr ++ ; route_length = * pptr ++ ; snprintf ( buf , buflen , "Route-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_multicast_vpn_route_type_values , "Unknown" , route_type ) , route_type , route_length ) ; switch ( route_type ) { case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , ",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Originator<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , pptr ) , bgp_vpn_ip_print ( ndo , pptr + BGP_VPN_RD_LEN , ( route_length - BGP_VPN_RD_LEN ) << 3 ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN + 4 ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , ",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Source-AS<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , pptr ) , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + BGP_VPN_RD_LEN ) ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , ",<S2SV_blank>RD:<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , pptr ) ) ; pptr += BGP_VPN_RD_LEN ; sg_length = bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; addr_length = route_length - sg_length ; ND_TCHECK2 ( pptr [ 0 ] , addr_length ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , ",<S2SV_blank>Originator<S2SV_blank>%s" , bgp_vpn_ip_print ( ndo , pptr , addr_length << 3 ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , ",<S2SV_blank>RD:<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , pptr ) ) ; pptr += BGP_VPN_RD_LEN ; bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN : <S2SV_StartBug> ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; <S2SV_EndBug> offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , ",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Source-AS<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , pptr ) , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> pptr += BGP_VPN_RD_LEN ; <S2SV_EndBug> bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF : default : break ; } return route_length + 2 ; trunc : return - 2 ; }
CWE-20 static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; <S2SV_StartBug> if ( chunk_num > chm -> num_chunks ) return NULL ; <S2SV_EndBug> if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
CWE-125 sctp_disposition_t sctp_sf_ootb ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sk_buff * skb = chunk -> skb ; sctp_chunkhdr_t * ch ; sctp_errhdr_t * err ; __u8 * ch_end ; int ootb_shut_ack = 0 ; int ootb_cookie_ack = 0 ; SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; ch = ( sctp_chunkhdr_t * ) chunk -> chunk_hdr ; do { if ( ntohs ( ch -> length ) < sizeof ( sctp_chunkhdr_t ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; <S2SV_StartBug> if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) <S2SV_EndBug> ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } } ch_end = ( ( __u8 * ) ch ) + SCTP_PAD4 ( ntohs ( ch -> length ) ) ; if ( ch_end > skb_tail_pointer ( skb ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; <S2SV_StartBug> ch = ( sctp_chunkhdr_t * ) ch_end ; <S2SV_EndBug> } while ( ch_end < skb_tail_pointer ( skb ) ) ; if ( ootb_shut_ack ) return sctp_sf_shut_8_4_5 ( net , ep , asoc , type , arg , commands ) ; else if ( ootb_cookie_ack ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; else return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; }
CWE-119 static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <S2SV_StartBug> DPRINTF ( "Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] , <S2SV_EndBug> nmv_context_counts * counts ) { int i ; for ( i = 0 ; i < 1 + has_second_ref ( mbmi ) ; ++ i ) { <S2SV_StartBug> const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ; <S2SV_EndBug> const MV diff = { mvs [ i ] . as_mv . row - ref -> row , mvs [ i ] . as_mv . col - ref -> col } ; vp9_inc_mv ( & diff , counts ) ; } }
CWE-119 static ssize_t exitcode_proc_write ( struct file * file , const char __user * buffer , size_t count , loff_t * pos ) { char * end , buf [ sizeof ( "nnnnn\\0" ) ] ; <S2SV_StartBug> int tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( buf , buffer , count ) ) <S2SV_EndBug> return - EFAULT ; tmp = simple_strtol ( buf , & end , 0 ) ; if ( ( * end != '\\0' ) && ! isspace ( * end ) ) return - EINVAL ; uml_exitcode = tmp ; return count ; }
CWE-119 void monitor_apply_keystate ( struct monitor * pmonitor ) { struct ssh * ssh = active_state ; struct kex * kex ; int r ; debug3 ( "%s:<S2SV_blank>packet_set_state" , __func__ ) ; if ( ( r = ssh_packet_set_state ( ssh , child_state ) ) != 0 ) fatal ( "%s:<S2SV_blank>packet_set_state:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; sshbuf_free ( child_state ) ; child_state = NULL ; if ( ( kex = ssh -> kex ) != NULL ) { # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; # endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; } <S2SV_StartBug> if ( options . compression ) { <S2SV_EndBug> ssh_packet_set_compress_hooks ( ssh , pmonitor -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } }
CWE-119 <S2SV_StartBug> static void mark_object ( struct object * obj , struct strbuf * path , <S2SV_EndBug> const char * name , void * data ) { update_progress ( data ) ; }
CWE-200 <S2SV_StartBug> static void print_bpf_insn ( struct bpf_insn * insn ) <S2SV_EndBug> { u8 class = BPF_CLASS ( insn -> code ) ; if ( class == BPF_ALU || class == BPF_ALU64 ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) verbose ( "(%02x)<S2SV_blank>%sr%d<S2SV_blank>%s<S2SV_blank>%sr%d\\n" , insn -> code , class == BPF_ALU ? "(u32)<S2SV_blank>" : "" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? "(u32)<S2SV_blank>" : "" , insn -> src_reg ) ; else verbose ( "(%02x)<S2SV_blank>%sr%d<S2SV_blank>%s<S2SV_blank>%s%d\\n" , insn -> code , class == BPF_ALU ? "(u32)<S2SV_blank>" : "" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? "(u32)<S2SV_blank>" : "" , insn -> imm ) ; } else if ( class == BPF_STX ) { if ( BPF_MODE ( insn -> code ) == BPF_MEM ) verbose ( "(%02x)<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>=<S2SV_blank>r%d\\n" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else if ( BPF_MODE ( insn -> code ) == BPF_XADD ) verbose ( "(%02x)<S2SV_blank>lock<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>+=<S2SV_blank>r%d\\n" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else verbose ( "BUG_%02x\\n" , insn -> code ) ; } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { verbose ( "BUG_st_%02x\\n" , insn -> code ) ; return ; } verbose ( "(%02x)<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>=<S2SV_blank>%d\\n" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> imm ) ; } else if ( class == BPF_LDX ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { verbose ( "BUG_ldx_%02x\\n" , insn -> code ) ; return ; } verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)\\n" , insn -> code , insn -> dst_reg , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> src_reg , insn -> off ) ; } else if ( class == BPF_LD ) { if ( BPF_MODE ( insn -> code ) == BPF_ABS ) { verbose ( "(%02x)<S2SV_blank>r0<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)skb[%d]\\n" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> imm ) ; } else if ( BPF_MODE ( insn -> code ) == BPF_IND ) { verbose ( "(%02x)<S2SV_blank>r0<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)skb[r%d<S2SV_blank>+<S2SV_blank>%d]\\n" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> src_reg , insn -> imm ) ; <S2SV_StartBug> } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) { <S2SV_EndBug> verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%x\\n" , <S2SV_StartBug> insn -> code , insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> } else { verbose ( "BUG_ld_%02x\\n" , insn -> code ) ; return ; } } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { verbose ( "(%02x)<S2SV_blank>call<S2SV_blank>%s#%d\\n" , insn -> code , func_id_name ( insn -> imm ) , insn -> imm ) ; } else if ( insn -> code == ( BPF_JMP | BPF_JA ) ) { verbose ( "(%02x)<S2SV_blank>goto<S2SV_blank>pc%+d\\n" , insn -> code , insn -> off ) ; } else if ( insn -> code == ( BPF_JMP | BPF_EXIT ) ) { verbose ( "(%02x)<S2SV_blank>exit\\n" , insn -> code ) ; } else if ( BPF_SRC ( insn -> code ) == BPF_X ) { verbose ( "(%02x)<S2SV_blank>if<S2SV_blank>r%d<S2SV_blank>%s<S2SV_blank>r%d<S2SV_blank>goto<S2SV_blank>pc%+d\\n" , insn -> code , insn -> dst_reg , bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , insn -> src_reg , insn -> off ) ; } else { verbose ( "(%02x)<S2SV_blank>if<S2SV_blank>r%d<S2SV_blank>%s<S2SV_blank>0x%x<S2SV_blank>goto<S2SV_blank>pc%+d\\n" , insn -> code , insn -> dst_reg , bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , insn -> imm , insn -> off ) ; } } else { verbose ( "(%02x)<S2SV_blank>%s\\n" , insn -> code , bpf_class_string [ class ] ) ; } }
CWE-000 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
CWE-119 <S2SV_StartBug> static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> vp9_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ; if ( cm -> tx_mode >= ALLOW_32X32 ) <S2SV_StartBug> vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ; <S2SV_EndBug> if ( cm -> tx_mode == TX_MODE_SELECT ) { int i , j ; unsigned int ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 3 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ; <S2SV_EndBug> } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 2 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] , <S2SV_EndBug> ct_16x16p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <S2SV_StartBug> tx_counts_to_branch_counts_32x32 ( cm -> counts . tx . p32x32 [ i ] , ct_32x32p ) ; <S2SV_EndBug> for ( j = 0 ; j < TX_SIZES - 1 ; j ++ ) <S2SV_StartBug> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p32x32 [ i ] [ j ] , <S2SV_EndBug> ct_32x32p [ j ] ) ; } } }
CWE-415 int dccp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , struct dccp_hdr * dh , unsigned int len ) { struct dccp_sock * dp = dccp_sk ( sk ) ; struct dccp_skb_cb * dcb = DCCP_SKB_CB ( skb ) ; const int old_state = sk -> sk_state ; int queued = 0 ; if ( sk -> sk_state == DCCP_LISTEN ) { if ( dh -> dccph_type == DCCP_PKT_REQUEST ) { if ( inet_csk ( sk ) -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) return 1 ; <S2SV_StartBug> goto discard ; <S2SV_EndBug> } if ( dh -> dccph_type == DCCP_PKT_RESET ) goto discard ; dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } else if ( sk -> sk_state == DCCP_CLOSED ) { dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } if ( sk -> sk_state != DCCP_REQUESTING && dccp_check_seqno ( sk , skb ) ) goto discard ; if ( ( dp -> dccps_role != DCCP_ROLE_CLIENT && dh -> dccph_type == DCCP_PKT_RESPONSE ) || ( dp -> dccps_role == DCCP_ROLE_CLIENT && dh -> dccph_type == DCCP_PKT_REQUEST ) || ( sk -> sk_state == DCCP_RESPOND && dh -> dccph_type == DCCP_PKT_DATA ) ) { dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNC ) ; goto discard ; } if ( dccp_parse_options ( sk , NULL , skb ) ) return 1 ; if ( dh -> dccph_type == DCCP_PKT_RESET ) { dccp_rcv_reset ( sk , skb ) ; return 0 ; } else if ( dh -> dccph_type == DCCP_PKT_CLOSEREQ ) { if ( dccp_rcv_closereq ( sk , skb ) ) return 0 ; goto discard ; } else if ( dh -> dccph_type == DCCP_PKT_CLOSE ) { if ( dccp_rcv_close ( sk , skb ) ) return 0 ; goto discard ; } switch ( sk -> sk_state ) { case DCCP_REQUESTING : queued = dccp_rcv_request_sent_state_process ( sk , skb , dh , len ) ; if ( queued >= 0 ) return queued ; __kfree_skb ( skb ) ; return 0 ; case DCCP_PARTOPEN : dccp_handle_ackvec_processing ( sk , skb ) ; dccp_deliver_input_to_ccids ( sk , skb ) ; case DCCP_RESPOND : queued = dccp_rcv_respond_partopen_state_process ( sk , skb , dh , len ) ; break ; } if ( dh -> dccph_type == DCCP_PKT_ACK || dh -> dccph_type == DCCP_PKT_DATAACK ) { switch ( old_state ) { case DCCP_PARTOPEN : sk -> sk_state_change ( sk ) ; sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; break ; } } else if ( unlikely ( dh -> dccph_type == DCCP_PKT_SYNC ) ) { dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNCACK ) ; goto discard ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }
CWE-284 static void update_logging ( ) { bool should_log = module_started && ( logging_enabled_via_api || stack_config -> get_btsnoop_turned_on ( ) ) ; if ( should_log == is_logging ) return ; is_logging = should_log ; if ( should_log ) { btsnoop_net_open ( ) ; const char * log_path = stack_config -> get_btsnoop_log_path ( ) ; if ( stack_config -> get_btsnoop_should_save_last ( ) ) { char last_log_path [ PATH_MAX ] ; snprintf ( last_log_path , PATH_MAX , "%s.%llu" , log_path , btsnoop_timestamp ( ) ) ; if ( ! rename ( log_path , last_log_path ) && errno != ENOENT ) LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>rename<S2SV_blank>\'%s\'<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , log_path , last_log_path , strerror ( errno ) ) ; } <S2SV_StartBug> logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ; <S2SV_EndBug> if ( logfile_fd == INVALID_FD ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , log_path , strerror ( errno ) ) ; is_logging = false ; return ; } <S2SV_StartBug> write ( logfile_fd , "btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea" , 16 ) ; <S2SV_EndBug> } else { if ( logfile_fd != INVALID_FD ) close ( logfile_fd ) ; logfile_fd = INVALID_FD ; btsnoop_net_close ( ) ; } }
CWE-200 static int udf_encode_fh ( struct inode * inode , __u32 * fh , int * lenp , struct inode * parent ) { int len = * lenp ; struct kernel_lb_addr location = UDF_I ( inode ) -> i_location ; struct fid * fid = ( struct fid * ) fh ; int type = FILEID_UDF_WITHOUT_PARENT ; if ( parent && ( len < 5 ) ) { * lenp = 5 ; return 255 ; } else if ( len < 3 ) { * lenp = 3 ; return 255 ; } * lenp = 3 ; fid -> udf . block = location . logicalBlockNum ; fid -> udf . partref = location . partitionReferenceNum ; <S2SV_StartBug> fid -> udf . generation = inode -> i_generation ; <S2SV_EndBug> if ( parent ) { location = UDF_I ( parent ) -> i_location ; fid -> udf . parent_block = location . logicalBlockNum ; fid -> udf . parent_partref = location . partitionReferenceNum ; fid -> udf . parent_generation = inode -> i_generation ; * lenp = 5 ; type = FILEID_UDF_WITH_PARENT ; } return type ; }
CWE-284 static int http_connect ( http_subtransport * t ) { int error ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , "git_stream" ) ; apply_proxy_config ( t ) ; error = git_stream_connect ( t -> io ) ; if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; <S2SV_StartBug> int is_valid ; <S2SV_EndBug> if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert , is_valid , t -> connection_data . host , t -> owner -> message_cb_payload ) ; if ( error < 0 ) { if ( ! giterr_last ( ) ) giterr_set ( GITERR_NET , "user<S2SV_blank>cancelled<S2SV_blank>certificate<S2SV_blank>check" ) ; return error ; } } if ( error < 0 ) return error ; t -> connected = 1 ; return 0 ; }
CWE-125 void color_sycc_to_rgb ( opj_image_t * img ) { if ( img -> numcomps < 3 ) { img -> color_space = OPJ_CLRSPC_GRAY ; return ; } if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) { sycc420_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc422_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc444_to_rgb ( img ) ; } else { fprintf ( stderr , "%s:%d:color_sycc_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n" , __FILE__ , __LINE__ ) ; return ; } <S2SV_StartBug> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> horDiff32 ( tif , cp0 , cc ) ; <S2SV_EndBug> TIFFSwabArrayOfLong ( wp , wc ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-20 static int pppol2tp_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int err ; struct sk_buff * skb ; struct sock * sk = sock -> sk ; err = - EIO ; if ( sk -> sk_state & PPPOX_BOUND ) <S2SV_StartBug> goto end ; <S2SV_EndBug> msg -> msg_namelen = 0 ; err = 0 ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) goto end ; if ( len > skb -> len ) len = skb -> len ; else if ( len < skb -> len ) msg -> msg_flags |= MSG_TRUNC ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , len ) ; if ( likely ( err == 0 ) ) err = len ; kfree_skb ( skb ) ; end : return err ; }
CWE-189 static int sanitize_ptr_alu ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , struct bpf_reg_state * dst_reg , bool off_is_neg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_insn_aux_data * aux = cur_aux ( env ) ; bool ptr_is_dst_reg = ptr_reg == dst_reg ; u8 opcode = BPF_OP ( insn -> code ) ; u32 alu_state , alu_limit ; struct bpf_reg_state tmp ; bool ret ; <S2SV_StartBug> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) <S2SV_EndBug> return 0 ; if ( vstate -> speculative ) goto do_sim ; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) return 0 ; <S2SV_StartBug> if ( aux -> alu_state && <S2SV_EndBug> ( aux -> alu_state != alu_state || aux -> alu_limit != alu_limit ) ) <S2SV_StartBug> return - EACCES ; <S2SV_EndBug> aux -> alu_state = alu_state ; aux -> alu_limit = alu_limit ; do_sim : if ( ! ptr_is_dst_reg ) { tmp = * dst_reg ; * dst_reg = * ptr_reg ; } ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; if ( ! ptr_is_dst_reg ) * dst_reg = tmp ; return ! ret ? - EFAULT : 0 ; }
CWE-119 static INLINE void store_pred_mv ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { <S2SV_StartBug> vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> }
CWE-125 static void icmp6_rrenum_print ( netdissect_options * ndo , const u_char * bp , const u_char * ep ) { const struct icmp6_router_renum * rr6 ; const char * cp ; const struct rr_pco_match * match ; const struct rr_pco_use * use ; char hbuf [ NI_MAXHOST ] ; int n ; if ( ep < bp ) return ; rr6 = ( const struct icmp6_router_renum * ) bp ; cp = ( const char * ) ( rr6 + 1 ) ; ND_TCHECK ( rr6 -> rr_reserved ) ; switch ( rr6 -> rr_code ) { case ICMP6_ROUTER_RENUMBERING_COMMAND : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>command" ) ) ; break ; case ICMP6_ROUTER_RENUMBERING_RESULT : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>result" ) ) ; break ; case ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>sequence<S2SV_blank>number<S2SV_blank>reset" ) ) ; break ; default : ND_PRINT ( ( ndo , "router<S2SV_blank>renum:<S2SV_blank>code-#%d" , rr6 -> rr_code ) ) ; break ; } ND_PRINT ( ( ndo , ",<S2SV_blank>seq=%u" , EXTRACT_32BITS ( & rr6 -> rr_seqnum ) ) ) ; if ( ndo -> ndo_vflag ) { # define F ( x , y ) ( ( rr6 -> rr_flags ) & ( x ) ? ( y ) : "" ) ND_PRINT ( ( ndo , "[" ) ) ; if ( rr6 -> rr_flags ) { ND_PRINT ( ( ndo , "%s%s%s%s%s," , F ( ICMP6_RR_FLAGS_TEST , "T" ) , F ( ICMP6_RR_FLAGS_REQRESULT , "R" ) , F ( ICMP6_RR_FLAGS_FORCEAPPLY , "A" ) , F ( ICMP6_RR_FLAGS_SPECSITE , "S" ) , F ( ICMP6_RR_FLAGS_PREVDONE , "P" ) ) ) ; } ND_PRINT ( ( ndo , "seg=%u," , rr6 -> rr_segnum ) ) ; ND_PRINT ( ( ndo , "maxdelay=%u" , EXTRACT_16BITS ( & rr6 -> rr_maxdelay ) ) ) ; if ( rr6 -> rr_reserved ) ND_PRINT ( ( ndo , "rsvd=0x%x" , EXTRACT_32BITS ( & rr6 -> rr_reserved ) ) ) ; ND_PRINT ( ( ndo , "]" ) ) ; # undef F } if ( rr6 -> rr_code == ICMP6_ROUTER_RENUMBERING_COMMAND ) { match = ( const struct rr_pco_match * ) cp ; cp = ( const char * ) ( match + 1 ) ; ND_TCHECK ( match -> rpm_prefix ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "\\n\\t" ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "match(" ) ) ; switch ( match -> rpm_code ) { case RPM_PCO_ADD : ND_PRINT ( ( ndo , "add" ) ) ; break ; case RPM_PCO_CHANGE : ND_PRINT ( ( ndo , "change" ) ) ; break ; case RPM_PCO_SETGLOBAL : ND_PRINT ( ( ndo , "setglobal" ) ) ; break ; default : ND_PRINT ( ( ndo , "#%u" , match -> rpm_code ) ) ; break ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ",ord=%u" , match -> rpm_ordinal ) ) ; ND_PRINT ( ( ndo , ",min=%u" , match -> rpm_minlen ) ) ; ND_PRINT ( ( ndo , ",max=%u" , match -> rpm_maxlen ) ) ; } if ( addrtostr6 ( & match -> rpm_prefix , hbuf , sizeof ( hbuf ) ) ) ND_PRINT ( ( ndo , ",%s/%u" , hbuf , match -> rpm_matchlen ) ) ; else ND_PRINT ( ( ndo , ",?/%u" , match -> rpm_matchlen ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; n = match -> rpm_len - 3 ; if ( n % 4 ) goto trunc ; n /= 4 ; while ( n -- > 0 ) { use = ( const struct rr_pco_use * ) cp ; cp = ( const char * ) ( use + 1 ) ; ND_TCHECK ( use -> rpu_prefix ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "\\n\\t" ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "use(" ) ) ; if ( use -> rpu_flags ) { # define F ( x , y ) ( ( use -> rpu_flags ) & ( x ) ? ( y ) : "" ) ND_PRINT ( ( ndo , "%s%s," , F ( ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME , "V" ) , F ( ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME , "P" ) ) ) ; # undef F } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "mask=0x%x," , use -> rpu_ramask ) ) ; ND_PRINT ( ( ndo , "raflags=0x%x," , use -> rpu_raflags ) ) ; if ( ~ use -> rpu_vltime == 0 ) ND_PRINT ( ( ndo , "vltime=infty," ) ) ; else ND_PRINT ( ( ndo , "vltime=%u," , EXTRACT_32BITS ( & use -> rpu_vltime ) ) ) ; if ( ~ use -> rpu_pltime == 0 ) ND_PRINT ( ( ndo , "pltime=infty," ) ) ; else ND_PRINT ( ( ndo , "pltime=%u," , EXTRACT_32BITS ( & use -> rpu_pltime ) ) ) ; } if ( addrtostr6 ( & use -> rpu_prefix , hbuf , sizeof ( hbuf ) ) ) ND_PRINT ( ( ndo , "%s/%u/%u" , hbuf , use -> rpu_uselen , use -> rpu_keeplen ) ) ; else ND_PRINT ( ( ndo , "?/%u/%u" , use -> rpu_uselen , use -> rpu_keeplen ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; } } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> }
CWE-264 static int timer_start ( Unit * u ) { Timer * t = TIMER ( u ) ; TimerValue * v ; assert ( t ) ; assert ( t -> state == TIMER_DEAD || t -> state == TIMER_FAILED ) ; if ( UNIT_TRIGGER ( u ) -> load_state != UNIT_LOADED ) return - ENOENT ; t -> last_trigger = DUAL_TIMESTAMP_NULL ; LIST_FOREACH ( value , v , t -> values ) if ( v -> base == TIMER_ACTIVE ) v -> disabled = false ; if ( t -> stamp_path ) { struct stat st ; if ( stat ( t -> stamp_path , & st ) >= 0 ) t -> last_trigger . realtime = timespec_load ( & st . st_atim ) ; else if ( errno == ENOENT ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> } t -> result = TIMER_SUCCESS ; timer_enter_waiting ( t , true ) ; return 1 ; }
CWE-200 static int get_linux_shareopts ( const char * shareopts , char * * plinux_opts ) { int rc ; assert ( plinux_opts != NULL ) ; * plinux_opts = NULL ; ( void ) add_linux_shareopt ( plinux_opts , "no_subtree_check" , NULL ) ; ( void ) add_linux_shareopt ( plinux_opts , "no_root_squash" , NULL ) ; ( void ) add_linux_shareopt ( plinux_opts , "mountpoint" , NULL ) ; <S2SV_StartBug> rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb , <S2SV_EndBug> plinux_opts ) ; if ( rc != SA_OK ) { free ( * plinux_opts ) ; * plinux_opts = NULL ; } return ( rc ) ; }
CWE-119 CURLcode Curl_urldecode ( struct SessionHandle * data , const char * string , size_t length , char * * ostring , size_t * olen , bool reject_ctrl ) { size_t alloc = ( length ? length : strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; unsigned char in ; size_t strindex = 0 ; unsigned long hex ; CURLcode res ; if ( ! ns ) return CURLE_OUT_OF_MEMORY ; while ( -- alloc > 0 ) { in = * string ; <S2SV_StartBug> if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <S2SV_EndBug> char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; res = Curl_convert_from_network ( data , & in , 1 ) ; if ( res ) { free ( ns ) ; return res ; } string += 2 ; alloc -= 2 ; } if ( reject_ctrl && ( in < 0x20 ) ) { free ( ns ) ; return CURLE_URL_MALFORMAT ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) * olen = strindex ; if ( ostring ) * ostring = ns ; return CURLE_OK ; }
CWE-119 static void get_cx_data ( struct stream_state * stream , struct VpxEncoderConfig * global , int * got_data ) { const vpx_codec_cx_pkt_t * pkt ; const struct vpx_codec_enc_cfg * cfg = & stream -> config . cfg ; vpx_codec_iter_t iter = NULL ; * got_data = 0 ; while ( ( pkt = vpx_codec_get_cx_data ( & stream -> encoder , & iter ) ) ) { static size_t fsize = 0 ; <S2SV_StartBug> static off_t ivf_header_pos = 0 ; <S2SV_EndBug> switch ( pkt -> kind ) { case VPX_CODEC_CX_FRAME_PKT : if ( ! ( pkt -> data . frame . flags & VPX_FRAME_IS_FRAGMENT ) ) { stream -> frames_out ++ ; } if ( ! global -> quiet ) fprintf ( stderr , "<S2SV_blank>%6luF" , ( unsigned long ) pkt -> data . frame . sz ) ; update_rate_histogram ( stream -> rate_hist , cfg , pkt ) ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { <S2SV_StartBug> if ( ! stream -> ebml . debug ) <S2SV_EndBug> stream -> hash = murmur ( pkt -> data . frame . buf , ( int ) pkt -> data . frame . sz , stream -> hash ) ; write_webm_block ( & stream -> ebml , cfg , pkt ) ; } # endif if ( ! stream -> config . write_webm ) { if ( pkt -> data . frame . partition_id <= 0 ) { ivf_header_pos = ftello ( stream -> file ) ; fsize = pkt -> data . frame . sz ; ivf_write_frame_header ( stream -> file , pkt -> data . frame . pts , fsize ) ; } else { fsize += pkt -> data . frame . sz ; if ( ! ( pkt -> data . frame . flags & VPX_FRAME_IS_FRAGMENT ) ) { <S2SV_StartBug> off_t currpos = ftello ( stream -> file ) ; <S2SV_EndBug> fseeko ( stream -> file , ivf_header_pos , SEEK_SET ) ; ivf_write_frame_size ( stream -> file , fsize ) ; fseeko ( stream -> file , currpos , SEEK_SET ) ; } } ( void ) fwrite ( pkt -> data . frame . buf , 1 , pkt -> data . frame . sz , stream -> file ) ; } stream -> nbytes += pkt -> data . raw . sz ; * got_data = 1 ; # if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF && ! stream -> mismatch_seen ) { vpx_codec_decode ( & stream -> decoder , pkt -> data . frame . buf , ( unsigned int ) pkt -> data . frame . sz , NULL , 0 ) ; if ( stream -> decoder . err ) { warn_or_exit_on_error ( & stream -> decoder , global -> test_decode == TEST_DECODE_FATAL , "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>stream<S2SV_blank>%d" , stream -> frames_out + 1 , stream -> index ) ; stream -> mismatch_seen = stream -> frames_out + 1 ; } } # endif break ; case VPX_CODEC_STATS_PKT : stream -> frames_out ++ ; stats_write ( & stream -> stats , pkt -> data . twopass_stats . buf , pkt -> data . twopass_stats . sz ) ; stream -> nbytes += pkt -> data . raw . sz ; break ; <S2SV_StartBug> case VPX_CODEC_PSNR_PKT : <S2SV_EndBug> if ( global -> show_psnr ) { int i ; stream -> psnr_sse_total += pkt -> data . psnr . sse [ 0 ] ; stream -> psnr_samples_total += pkt -> data . psnr . samples [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { if ( ! global -> quiet ) fprintf ( stderr , "%.3f<S2SV_blank>" , pkt -> data . psnr . psnr [ i ] ) ; stream -> psnr_totals [ i ] += pkt -> data . psnr . psnr [ i ] ; } stream -> psnr_count ++ ; } break ; default : break ; } } }
CWE-20 static int on_header_cb ( nghttp2_session * ngh2 , const nghttp2_frame * frame , const uint8_t * name , size_t namelen , const uint8_t * value , size_t valuelen , uint8_t flags , void * userp ) { h2_session * session = ( h2_session * ) userp ; h2_stream * stream ; apr_status_t status ; ( void ) flags ; stream = get_stream ( session , frame -> hd . stream_id ) ; if ( ! stream ) { <S2SV_StartBug> ap_log_cerror ( APLOG_MARK , APLOG_ERR , 0 , session -> c , <S2SV_EndBug> APLOGNO ( 02920 ) "h2_session:<S2SV_blank><S2SV_blank>stream(%ld-%d):<S2SV_blank>on_header<S2SV_blank>unknown<S2SV_blank>stream" , session -> id , ( int ) frame -> hd . stream_id ) ; return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ; } status = h2_stream_add_header ( stream , ( const char * ) name , namelen , ( const char * ) value , valuelen ) ; <S2SV_StartBug> if ( status != APR_SUCCESS && ! h2_stream_is_ready ( stream ) ) { <S2SV_EndBug> return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ; } return 0 ; }
CWE-264 static __init int hardware_setup ( void ) { int r = - ENOMEM , i , msr ; rdmsrl_safe ( MSR_EFER , & host_efer ) ; for ( i = 0 ; i < ARRAY_SIZE ( vmx_msr_index ) ; ++ i ) kvm_define_shared_msr ( i , vmx_msr_index [ i ] ) ; vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_a ) return r ; vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_b ) goto out ; vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy ) goto out1 ; vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy_x2apic ) goto out2 ; vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode ) goto out3 ; vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode_x2apic ) goto out4 ; if ( nested ) { vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_nested ) goto out5 ; } vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmread_bitmap ) goto out6 ; vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmwrite_bitmap ) goto out7 ; memset ( vmx_vmread_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_vmwrite_bitmap , 0xff , PAGE_SIZE ) ; memset ( vmx_io_bitmap_a , 0xff , PAGE_SIZE ) ; clear_bit ( 0x80 , vmx_io_bitmap_a ) ; memset ( vmx_io_bitmap_b , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_legacy , 0xff , PAGE_SIZE ) ; memset ( vmx_msr_bitmap_longmode , 0xff , PAGE_SIZE ) ; if ( nested ) memset ( vmx_msr_bitmap_nested , 0xff , PAGE_SIZE ) ; if ( setup_vmcs_config ( & vmcs_config ) < 0 ) { r = - EIO ; goto out8 ; } if ( boot_cpu_has ( X86_FEATURE_NX ) ) kvm_enable_efer_bits ( EFER_NX ) ; if ( ! cpu_has_vmx_vpid ( ) ) enable_vpid = 0 ; if ( ! cpu_has_vmx_shadow_vmcs ( ) ) enable_shadow_vmcs = 0 ; if ( enable_shadow_vmcs ) init_vmcs_shadow_fields ( ) ; if ( ! cpu_has_vmx_ept ( ) || ! cpu_has_vmx_ept_4levels ( ) ) { enable_ept = 0 ; enable_unrestricted_guest = 0 ; enable_ept_ad_bits = 0 ; } if ( ! cpu_has_vmx_ept_ad_bits ( ) ) enable_ept_ad_bits = 0 ; if ( ! cpu_has_vmx_unrestricted_guest ( ) ) enable_unrestricted_guest = 0 ; if ( ! cpu_has_vmx_flexpriority ( ) ) flexpriority_enabled = 0 ; if ( ! flexpriority_enabled ) kvm_x86_ops -> set_apic_access_page_addr = NULL ; if ( ! cpu_has_vmx_tpr_shadow ( ) ) kvm_x86_ops -> update_cr8_intercept = NULL ; if ( enable_ept && ! cpu_has_vmx_ept_2m_page ( ) ) kvm_disable_largepages ( ) ; if ( ! cpu_has_vmx_ple ( ) ) ple_gap = 0 ; if ( ! cpu_has_vmx_apicv ( ) ) enable_apicv = 0 ; if ( cpu_has_vmx_tsc_scaling ( ) ) { kvm_has_tsc_control = true ; kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX ; kvm_tsc_scaling_ratio_frac_bits = 48 ; } vmx_disable_intercept_for_msr ( MSR_FS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_GS_BASE , false ) ; vmx_disable_intercept_for_msr ( MSR_KERNEL_GS_BASE , true ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_CS , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_ESP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false ) ; vmx_disable_intercept_for_msr ( MSR_IA32_BNDCFGS , true ) ; memcpy ( vmx_msr_bitmap_legacy_x2apic , vmx_msr_bitmap_legacy , PAGE_SIZE ) ; memcpy ( vmx_msr_bitmap_longmode_x2apic , vmx_msr_bitmap_longmode , PAGE_SIZE ) ; set_bit ( 0 , vmx_vpid_bitmap ) ; <S2SV_StartBug> if ( enable_apicv ) { <S2SV_EndBug> for ( msr = 0x800 ; msr <= 0x8ff ; msr ++ ) vmx_disable_intercept_msr_read_x2apic ( msr ) ; vmx_enable_intercept_msr_read_x2apic ( 0x802 ) ; vmx_enable_intercept_msr_read_x2apic ( 0x839 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x808 ) ; vmx_disable_intercept_msr_write_x2apic ( 0x80b ) ; vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( enable_ept ) { kvm_mmu_set_mask_ptes ( 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_ACCESS_BIT : 0ull , ( enable_ept_ad_bits ) ? VMX_EPT_DIRTY_BIT : 0ull , 0ull , VMX_EPT_EXECUTABLE_MASK ) ; ept_set_mmio_spte_mask ( ) ; kvm_enable_tdp ( ) ; } else kvm_disable_tdp ( ) ; update_ple_window_actual_max ( ) ; if ( ! enable_ept || ! enable_ept_ad_bits || ! cpu_has_vmx_pml ( ) ) enable_pml = 0 ; if ( ! enable_pml ) { kvm_x86_ops -> slot_enable_log_dirty = NULL ; kvm_x86_ops -> slot_disable_log_dirty = NULL ; kvm_x86_ops -> flush_log_dirty = NULL ; kvm_x86_ops -> enable_log_dirty_pt_masked = NULL ; } kvm_set_posted_intr_wakeup_handler ( wakeup_handler ) ; return alloc_kvm_area ( ) ; out8 : free_page ( ( unsigned long ) vmx_vmwrite_bitmap ) ; out7 : free_page ( ( unsigned long ) vmx_vmread_bitmap ) ; out6 : if ( nested ) free_page ( ( unsigned long ) vmx_msr_bitmap_nested ) ; out5 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode_x2apic ) ; out4 : free_page ( ( unsigned long ) vmx_msr_bitmap_longmode ) ; out3 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy_x2apic ) ; out2 : free_page ( ( unsigned long ) vmx_msr_bitmap_legacy ) ; out1 : free_page ( ( unsigned long ) vmx_io_bitmap_b ) ; out : free_page ( ( unsigned long ) vmx_io_bitmap_a ) ; return r ; }
CWE-200 static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) { struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ; struct tipc_link_info link_info ; int err ; if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ; err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ; if ( err ) return err ; link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ; link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ; <S2SV_StartBug> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <S2SV_EndBug> return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ; }
CWE-787 DECLAREwriteFunc ( writeBufferToContigTiles ) { uint32 imagew = TIFFScanlineSize ( out ) ; uint32 tilew = TIFFTileRowSize ( out ) ; int iskew = imagew - tilew ; tsize_t tilesize = TIFFTileSize ( out ) ; tdata_t obuf ; uint8 * bufp = ( uint8 * ) buf ; uint32 tl , tw ; uint32 row ; ( void ) spp ; obuf = _TIFFmalloc ( TIFFTileSize ( out ) ) ; if ( obuf == NULL ) return 0 ; _TIFFmemset ( obuf , 0 , tilesize ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILELENGTH , & tl ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILEWIDTH , & tw ) ; for ( row = 0 ; row < imagelength ; row += tilelength ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <S2SV_StartBug> for ( col = 0 ; col < imagewidth ; col += tw ) { <S2SV_EndBug> if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; int oskew = tilew - width ; cpStripToTile ( obuf , bufp + colb , nrow , width , oskew , oskew + iskew ) ; } else cpStripToTile ( obuf , bufp + colb , nrow , tilew , 0 , iskew ) ; if ( TIFFWriteTile ( out , obuf , col , row , 0 , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , "Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%lu<S2SV_blank>%lu" , ( unsigned long ) col , ( unsigned long ) row ) ; _TIFFfree ( obuf ) ; return 0 ; } colb += tilew ; } bufp += nrow * imagew ; } _TIFFfree ( obuf ) ; return 1 ; }
CWE-119 static int check_mem_access ( struct bpf_verifier_env * env , int insn_idx , u32 regno , int off , int bpf_size , enum bpf_access_type t , int value_regno ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = cur_regs ( env ) ; struct bpf_reg_state * reg = regs + regno ; int size , err = 0 ; size = bpf_size_to_bytes ( bpf_size ) ; if ( size < 0 ) return size ; err = check_ptr_alignment ( env , reg , off , size ) ; if ( err ) return err ; off += reg -> off ; if ( reg -> type == PTR_TO_MAP_VALUE ) { if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>map\\n" , value_regno ) ; return - EACCES ; } err = check_map_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else if ( reg -> type == PTR_TO_CTX ) { enum bpf_reg_type reg_type = SCALAR_VALUE ; if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>ctx\\n" , value_regno ) ; return - EACCES ; } if ( reg -> off ) { verbose ( env , "dereference<S2SV_blank>of<S2SV_blank>modified<S2SV_blank>ctx<S2SV_blank>ptr<S2SV_blank>R%d<S2SV_blank>off=%d+%d,<S2SV_blank>ctx+const<S2SV_blank>is<S2SV_blank>allowed,<S2SV_blank>ctx+const+const<S2SV_blank>is<S2SV_blank>not\\n" , regno , reg -> off , off - reg -> off ) ; return - EACCES ; } if ( ! tnum_is_const ( reg -> var_off ) || reg -> var_off . value ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , "variable<S2SV_blank>ctx<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d" , tn_buf , off , size ) ; return - EACCES ; } err = check_ctx_access ( env , insn_idx , off , size , t , & reg_type ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) { if ( reg_type == SCALAR_VALUE ) mark_reg_unknown ( env , regs , value_regno ) ; else mark_reg_known_zero ( env , regs , value_regno ) ; regs [ value_regno ] . id = 0 ; regs [ value_regno ] . off = 0 ; regs [ value_regno ] . range = 0 ; regs [ value_regno ] . type = reg_type ; } } else if ( reg -> type == PTR_TO_STACK ) { if ( ! tnum_is_const ( reg -> var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , "variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d" , tn_buf , off , size ) ; return - EACCES ; } off += reg -> var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK ) { verbose ( env , "invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\n" , off , size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( t == BPF_WRITE ) err = check_stack_write ( env , state , off , size , value_regno ) ; else err = check_stack_read ( env , state , off , size , value_regno ) ; } else if ( reg_is_pkt_pointer ( reg ) ) { if ( t == BPF_WRITE && ! may_access_direct_pkt_data ( env , NULL , t ) ) { verbose ( env , "cannot<S2SV_blank>write<S2SV_blank>into<S2SV_blank>packet\\n" ) ; return - EACCES ; } if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>packet\\n" , value_regno ) ; return - EACCES ; } err = check_packet_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else { verbose ( env , "R%d<S2SV_blank>invalid<S2SV_blank>mem<S2SV_blank>access<S2SV_blank>\'%s\'\\n" , regno , reg_type_str [ reg -> type ] ) ; return - EACCES ; } if ( ! err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ && regs [ value_regno ] . type == SCALAR_VALUE ) { <S2SV_StartBug> regs [ value_regno ] . var_off = <S2SV_EndBug> tnum_cast ( regs [ value_regno ] . var_off , size ) ; __update_reg_bounds ( & regs [ value_regno ] ) ; } return err ; }
CWE-000 static void Sp_match ( js_State * J ) { js_Regexp * re ; const char * text ; int len ; const char * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , "" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! ( re -> flags & JS_REGEXP_G ) ) { js_RegExp_prototype_exec ( J , re , text ) ; return ; } re -> last = 0 ; js_newarray ( J ) ; len = 0 ; a = text ; e = text + strlen ( text ) ; while ( a <= e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; js_pushlstring ( J , b , c - b ) ; js_setindex ( J , - 2 , len ++ ) ; a = c ; if ( c - b == 0 ) ++ a ; } if ( len == 0 ) { js_pop ( J , 1 ) ; js_pushnull ( J ) ; } }
CWE-20 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] ; FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } pwp_image = image ; memset ( magick , 0 , sizeof ( magick ) ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , "SFW95" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "sfw:%s" , filename ) ; for ( ; ; ) { ( void ) memset ( magick , 0 , sizeof ( magick ) ) ; for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) == 0 ) break ; } if ( c == EOF ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowFileException ( exception , FileOpenError , "UnableToWriteFile" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( "SFW94A" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } ( void ) fclose ( file ) ; if ( c == EOF ) { ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MagickPathExtent , "slide_%02ld.sfw" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( image != ( Image * ) NULL ) { if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "UnexpectedEndOfFile" , "`%s\':<S2SV_blank>%s" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; } return ( GetFirstImageInList ( image ) ) ; }
CWE-190 int rpc_pack ( rpc_pkg * pkg , void * * data , uint32_t * size ) { static void * send_buf ; static size_t send_buf_size ; <S2SV_StartBug> uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ; <S2SV_EndBug> if ( send_buf_size < pkg_size ) { if ( send_buf ) free ( send_buf ) ; send_buf_size = pkg_size * 2 ; send_buf = malloc ( send_buf_size ) ; <S2SV_StartBug> assert ( send_buf != NULL ) ; <S2SV_EndBug> } memcpy ( send_buf , pkg , RPC_PKG_HEAD_SIZE ) ; if ( pkg -> ext_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE , pkg -> ext , pkg -> ext_size ) ; if ( pkg -> body_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE + pkg -> ext_size , pkg -> body , pkg -> body_size ) ; pkg = send_buf ; pkg -> magic = htole32 ( RPC_PKG_MAGIC ) ; pkg -> command = htole32 ( pkg -> command ) ; pkg -> pkg_type = htole16 ( pkg -> pkg_type ) ; pkg -> result = htole32 ( pkg -> result ) ; pkg -> sequence = htole32 ( pkg -> sequence ) ; pkg -> req_id = htole64 ( pkg -> req_id ) ; pkg -> body_size = htole32 ( pkg -> body_size ) ; pkg -> ext_size = htole16 ( pkg -> ext_size ) ; pkg -> crc32 = 0 ; pkg -> crc32 = htole32 ( generate_crc32c ( send_buf , pkg_size ) ) ; * data = send_buf ; * size = pkg_size ; return 0 ; }
CWE-119 void vp9_resize_plane ( const uint8_t * const input , int height , int width , int in_stride , uint8_t * output , int height2 , int width2 , int out_stride ) { int i ; uint8_t * intbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * width2 * height ) ; uint8_t * tmpbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * ( width < height ? height : width ) ) ; uint8_t * arrbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * ( height + height2 ) ) ; <S2SV_StartBug> for ( i = 0 ; i < height ; ++ i ) <S2SV_EndBug> resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ; for ( i = 0 ; i < width2 ; ++ i ) { fill_col_to_arr ( intbuf + i , width2 , height , arrbuf ) ; resize_multistep ( arrbuf , height , arrbuf + height , height2 , tmpbuf ) ; fill_arr_to_col ( output + i , out_stride , height2 , arrbuf + height ) ; } free ( intbuf ) ; free ( tmpbuf ) ; free ( arrbuf ) ; }
CWE-000 static void change_port_settings ( struct tty_struct * tty , struct edgeport_port * edge_port , struct ktermios * old_termios ) { struct device * dev = & edge_port -> port -> dev ; struct ump_uart_config * config ; int baud ; unsigned cflag ; int status ; int port_number = edge_port -> port -> port_number ; config = kmalloc ( sizeof ( * config ) , GFP_KERNEL ) ; if ( ! config ) { tty -> termios = * old_termios ; return ; } cflag = tty -> termios . c_cflag ; config -> wFlags = 0 ; config -> wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT ; config -> wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR ; config -> bUartMode = ( __u8 ) ( edge_port -> bUartMode ) ; switch ( cflag & CSIZE ) { case CS5 : config -> bDataBits = UMP_UART_CHAR5BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>5\\n" , __func__ ) ; break ; case CS6 : config -> bDataBits = UMP_UART_CHAR6BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>6\\n" , __func__ ) ; break ; case CS7 : config -> bDataBits = UMP_UART_CHAR7BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>7\\n" , __func__ ) ; break ; default : case CS8 : config -> bDataBits = UMP_UART_CHAR8BITS ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>8\\n" , __func__ ) ; break ; } if ( cflag & PARENB ) { if ( cflag & PARODD ) { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_ODDPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>odd\\n" , __func__ ) ; } else { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_EVENPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>even\\n" , __func__ ) ; } } else { config -> bParity = UMP_UART_NOPARITY ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>none\\n" , __func__ ) ; } if ( cflag & CSTOPB ) { config -> bStopBits = UMP_UART_STOPBIT2 ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>2\\n" , __func__ ) ; } else { config -> bStopBits = UMP_UART_STOPBIT1 ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>1\\n" , __func__ ) ; } if ( cflag & CRTSCTS ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW ; config -> wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>enabled\\n" , __func__ ) ; } else { dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; restart_read ( edge_port ) ; } config -> cXon = START_CHAR ( tty ) ; config -> cXoff = STOP_CHAR ( tty ) ; if ( I_IXOFF ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_IN_X ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; if ( I_IXON ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n" , __func__ ) ; tty -> termios . c_cflag &= ~ CMSPAR ; baud = tty_get_baud_rate ( tty ) ; if ( ! baud ) { baud = 9600 ; <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> tty_encode_baud_rate ( tty , baud , baud ) ; <S2SV_EndBug> edge_port -> baud_rate = baud ; config -> wBaudRate = ( __u16 ) ( ( 461550L + baud / 2 ) / baud ) ; dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>baud<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>wBaudRate<S2SV_blank>=<S2SV_blank>%d\\n" , __func__ , baud , config -> wBaudRate ) ; dev_dbg ( dev , "wBaudRate:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , ( int ) ( 461550L / config -> wBaudRate ) ) ; dev_dbg ( dev , "wFlags:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\n" , config -> wFlags ) ; dev_dbg ( dev , "bDataBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bDataBits ) ; dev_dbg ( dev , "bParity:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bParity ) ; dev_dbg ( dev , "bStopBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bStopBits ) ; dev_dbg ( dev , "cXon:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> cXon ) ; dev_dbg ( dev , "cXoff:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> cXoff ) ; dev_dbg ( dev , "bUartMode:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , config -> bUartMode ) ; cpu_to_be16s ( & config -> wFlags ) ; cpu_to_be16s ( & config -> wBaudRate ) ; status = send_cmd ( edge_port -> port -> serial -> dev , UMPC_SET_CONFIG , ( __u8 ) ( UMPM_UART1_PORT + port_number ) , 0 , ( __u8 * ) config , sizeof ( * config ) ) ; if ( status ) dev_dbg ( dev , "%s<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>config<S2SV_blank>to<S2SV_blank>device\\n" , __func__ , status ) ; kfree ( config ) ; }
CWE-125 static const u_char * ikev2_ke_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_ke ke ; const struct ikev2_ke * k ; k = ( const struct ikev2_ke * ) ext ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & ke , ext , sizeof ( ke ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , ke . h . critical ) ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%u<S2SV_blank>group=%s" , ntohs ( ke . h . len ) - 8 , STR_OR_ID ( ntohs ( ke . ke_group ) , dh_p_map ) ) ) ; if ( 2 < ndo -> ndo_vflag && 8 < ntohs ( ke . h . len ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( k + 1 ) , ntohs ( ke . h . len ) - 8 ) ) goto trunc ; } return ( const u_char * ) ext + ntohs ( ke . h . len ) ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( tpay ) ) ) ; return NULL ; }
CWE-000 static unsigned int do_encrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , <S2SV_StartBug> encT ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) <S2SV_StartBug> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <S2SV_EndBug> # else return do_encrypt_fn ( ctx , bx , ax ) ; # endif }
CWE-399 static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; <S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> return 0 ; return 1 ; }
CWE-264 struct tcp_sock_t * tcp_open ( uint16_t port ) { struct tcp_sock_t * this = calloc ( 1 , sizeof * this ) ; if ( this == NULL ) { <S2SV_StartBug> ERR ( "callocing<S2SV_blank>this<S2SV_blank>failed" ) ; <S2SV_EndBug> goto error ; } this -> sd = - 1 ; <S2SV_StartBug> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; <S2SV_EndBug> if ( this -> sd < 0 ) { <S2SV_StartBug> ERR ( "sockect<S2SV_blank>open<S2SV_blank>failed" ) ; <S2SV_EndBug> goto error ; } struct sockaddr_in6 addr ; memset ( & addr , 0 , sizeof addr ) ; <S2SV_StartBug> addr . sin6_family = AF_INET6 ; <S2SV_EndBug> addr . sin6_port = htons ( port ) ; <S2SV_StartBug> addr . sin6_addr = in6addr_any ; <S2SV_EndBug> if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) { if ( g_options . only_desired_port == 1 ) <S2SV_StartBug> ERR ( "Bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>" <S2SV_EndBug> "Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions." ) ; goto error ; } if ( listen ( this -> sd , HTTP_MAX_PENDING_CONNS ) < 0 ) { <S2SV_StartBug> ERR ( "listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket" ) ; <S2SV_EndBug> goto error ; } return this ; error : if ( this != NULL ) { if ( this -> sd != - 1 ) { close ( this -> sd ) ; } free ( this ) ; } return NULL ; }
CWE-362 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : <S2SV_StartBug> ret = key_validate ( key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 ) { <S2SV_EndBug> ret = - EOPNOTSUPP ; <S2SV_StartBug> if ( key -> type -> read ) { <S2SV_EndBug> down_read ( & key -> sem ) ; <S2SV_StartBug> ret = key -> type -> read ( key , buffer , buflen ) ; <S2SV_EndBug> up_read ( & key -> sem ) ; } } error2 : key_put ( key ) ; error : return ret ; }
CWE-20 static int dccp_error ( struct net * net , struct nf_conn * tmpl , struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info * ctinfo , u_int8_t pf , unsigned int hooknum ) { struct dccp_hdr _dh , * dh ; unsigned int dccp_len = skb -> len - dataoff ; unsigned int cscov ; const char * msg ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> if ( dh == NULL ) { msg = "nf_ct_dccp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>" ; goto out_invalid ; } if ( dh -> dccph_doff * 4 < sizeof ( struct dccp_hdr ) || dh -> dccph_doff * 4 > dccp_len ) { msg = "nf_ct_dccp:<S2SV_blank>truncated/malformed<S2SV_blank>packet<S2SV_blank>" ; goto out_invalid ; } cscov = dccp_len ; if ( dh -> dccph_cscov ) { cscov = ( dh -> dccph_cscov - 1 ) * 4 ; if ( cscov > dccp_len ) { msg = "nf_ct_dccp:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>coverage<S2SV_blank>" ; goto out_invalid ; } } if ( net -> ct . sysctl_checksum && hooknum == NF_INET_PRE_ROUTING && nf_checksum_partial ( skb , hooknum , dataoff , cscov , IPPROTO_DCCP , pf ) ) { msg = "nf_ct_dccp:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>" ; goto out_invalid ; } if ( dh -> dccph_type >= DCCP_PKT_INVALID ) { msg = "nf_ct_dccp:<S2SV_blank>reserved<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>" ; goto out_invalid ; } return NF_ACCEPT ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , "%s" , msg ) ; return - NF_ACCEPT ; }
CWE-119 static void subtract_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame -= frame -> frame ; <S2SV_StartBug> section -> intra_error -= frame -> intra_error ; <S2SV_EndBug> section -> coded_error -= frame -> coded_error ; section -> sr_coded_error -= frame -> sr_coded_error ; <S2SV_StartBug> section -> ssim_weighted_pred_err -= frame -> ssim_weighted_pred_err ; <S2SV_EndBug> section -> pcnt_inter -= frame -> pcnt_inter ; section -> pcnt_motion -= frame -> pcnt_motion ; section -> pcnt_second_ref -= frame -> pcnt_second_ref ; <S2SV_StartBug> section -> pcnt_neutral -= frame -> pcnt_neutral ; <S2SV_EndBug> section -> MVr -= frame -> MVr ; section -> mvr_abs -= frame -> mvr_abs ; section -> MVc -= frame -> MVc ; section -> mvc_abs -= frame -> mvc_abs ; section -> MVrv -= frame -> MVrv ; section -> MVcv -= frame -> MVcv ; section -> mv_in_out_count -= frame -> mv_in_out_count ; section -> new_mv_count -= frame -> new_mv_count ; section -> count -= frame -> count ; section -> duration -= frame -> duration ; }
CWE-119 static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp8_extracfg * vp8_cfg , int finalize ) { RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; <S2SV_StartBug> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; <S2SV_EndBug> RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # else RANGE_CHECK_HI ( cfg , g_lag_in_frames , 25 ) ; # endif RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; # if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , rc_resize_allowed , 0 ) ; # else RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; # endif RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # else RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; # endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( "kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>" "or<S2SV_blank>kf_max_dist<S2SV_blank>instead." ) ; RANGE_CHECK_BOOL ( vp8_cfg , enable_auto_alt_ref ) ; RANGE_CHECK ( vp8_cfg , cpu_used , - 16 , 16 ) ; # if CONFIG_REALTIME_ONLY && ! CONFIG_TEMPORAL_DENOISING RANGE_CHECK ( vp8_cfg , noise_sensitivity , 0 , 0 ) ; # else RANGE_CHECK_HI ( vp8_cfg , noise_sensitivity , 6 ) ; # endif RANGE_CHECK ( vp8_cfg , token_partitions , VP8_ONE_TOKENPARTITION , VP8_EIGHT_TOKENPARTITION ) ; RANGE_CHECK_HI ( vp8_cfg , Sharpness , 7 ) ; RANGE_CHECK ( vp8_cfg , arnr_max_frames , 0 , 15 ) ; RANGE_CHECK_HI ( vp8_cfg , arnr_strength , 6 ) ; RANGE_CHECK ( vp8_cfg , arnr_type , 1 , 3 ) ; <S2SV_StartBug> RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; FIRSTPASS_STATS * stats ; if ( ! cfg -> rc_twopass_stats_in . buf ) ERROR ( "rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set." ) ; if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( "rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet." ) ; if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( "rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets." ) ; stats = ( void * ) ( ( char * ) cfg -> rc_twopass_stats_in . buf + ( n_packets - 1 ) * packet_sz ) ; if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( "rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet" ) ; } # endif RANGE_CHECK ( cfg , ts_number_layers , 1 , 5 ) ; if ( cfg -> ts_number_layers > 1 ) { unsigned int i ; RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ ) <S2SV_StartBug> if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] ) <S2SV_EndBug> ERROR ( "ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing" ) ; RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; i -- ) if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) ERROR ( "ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2" ) ; RANGE_CHECK_HI ( cfg , ts_layer_id [ i ] , cfg -> ts_number_layers - 1 ) ; } # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cfg -> g_threads > ( 1 << vp8_cfg -> token_partitions ) ) ERROR ( "g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions" ) ; # endif return VPX_CODEC_OK ; }
CWE-119 vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <S2SV_StartBug> vpx_codec_dec_cfg_t * cfg , <S2SV_EndBug> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_DECODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_POSTPROC ) && ! ( iface -> caps & VPX_CODEC_CAP_POSTPROC ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) && ! ( iface -> caps & VPX_CODEC_CAP_ERROR_CONCEALMENT ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) && ! ( iface -> caps & VPX_CODEC_CAP_INPUT_FRAGMENTS ) ) res = VPX_CODEC_INCAPABLE ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_DECODER ) ) res = VPX_CODEC_INCAPABLE ; else { memset ( ctx , 0 , sizeof ( * ctx ) ) ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . dec = cfg ; <S2SV_StartBug> res = VPX_CODEC_OK ; <S2SV_EndBug> if ( ! ( flags & VPX_CODEC_USE_XMA ) ) { res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; } } return SAVE_STATUS ( ctx , res ) ; }
CWE-125 static int <S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( tl1 > l2 ) return 0 ; return ( strncmp ( tstr1 , str2 , tl1 ) == 0 ? 1 : 0 ) ; }
CWE-20 static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : <S2SV_StartBug> p += 2 ; <S2SV_EndBug> n += 2 ; len -= 2 ; break ; case 0x40 : <S2SV_StartBug> p += 3 ; <S2SV_EndBug> n += 3 ; len -= 3 ; break ; case 0x80 : <S2SV_StartBug> p += 4 ; <S2SV_EndBug> n += 4 ; len -= 4 ; break ; case 0xC0 : <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> if ( l < 10 || l > 20 ) return - 1 ; if ( * p == FAC_CCITT_DEST_NSAP ) { memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }
CWE-416 int ipmi_si_port_setup ( struct si_sm_io * io ) { unsigned int addr = io -> addr_data ; int idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = port_inb ; io -> outputb = port_outb ; break ; case 2 : io -> inputb = port_inw ; io -> outputb = port_outw ; break ; case 4 : io -> inputb = port_inl ; io -> outputb = port_outl ; break ; default : dev_warn ( io -> dev , "Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { while ( idx -- ) release_region ( addr + idx * io -> regspacing , io -> regsize ) ; return - EIO ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-200 static void copy_to_user_state ( struct xfrm_state * x , struct xfrm_usersa_info * p ) { <S2SV_StartBug> memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ; <S2SV_EndBug> memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ; memcpy ( & p -> lft , & x -> lft , sizeof ( p -> lft ) ) ; memcpy ( & p -> curlft , & x -> curlft , sizeof ( p -> curlft ) ) ; memcpy ( & p -> stats , & x -> stats , sizeof ( p -> stats ) ) ; memcpy ( & p -> saddr , & x -> props . saddr , sizeof ( p -> saddr ) ) ; p -> mode = x -> props . mode ; p -> replay_window = x -> props . replay_window ; p -> reqid = x -> props . reqid ; p -> family = x -> props . family ; p -> flags = x -> props . flags ; p -> seq = x -> km . seq ; }
CWE-119 static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu -> dies [ cu -> length ] . length == cu -> dies [ cu -> length ] . capacity ) { r_bin_dwarf_expand_die ( & cu -> dies [ cu -> length ] ) ; } if ( i >= cu -> dies [ cu -> length ] . capacity || i >= da -> decls [ abbr_code - 1 ] . capacity ) { eprintf ( "Warning:<S2SV_blank>malformed<S2SV_blank>dwarf<S2SV_blank>attribute<S2SV_blank>capacity<S2SV_blank>doesn\'t<S2SV_blank>match<S2SV_blank>length\\n" ) ; break ; } memset ( & cu -> dies [ cu -> length ] . attr_values [ i ] , 0 , sizeof ( cu -> dies [ cu -> length ] . attr_values [ i ] ) ) ; buf = r_bin_dwarf_parse_attr_value ( buf , buf_end - buf , & da -> decls [ abbr_code - 1 ] . specs [ i ] , & cu -> dies [ cu -> length ] . attr_values [ i ] , & cu -> hdr , debug_str , debug_str_len ) ; if ( cu -> dies [ cu -> length ] . attr_values [ i ] . name == DW_AT_comp_dir ) { const char * name = cu -> dies [ cu -> length ] . attr_values [ i ] . encoding . str_struct . string ; <S2SV_StartBug> sdb_set ( s , "DW_AT_comp_dir" , name , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> cu -> dies [ cu -> length ] . length ++ ; } cu -> length ++ ; } return buf ; }
CWE-200 static int cdrom_ioctl_select_disc ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , "entering<S2SV_blank>CDROM_SELECT_DISC\\n" ) ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) ) return - ENOSYS ; if ( arg != CDSL_CURRENT && arg != CDSL_NONE ) { <S2SV_StartBug> if ( ( int ) arg >= cdi -> capacity ) <S2SV_EndBug> return - EINVAL ; } if ( cdi -> ops -> select_disc ) return cdi -> ops -> select_disc ( cdi , arg ) ; cd_dbg ( CD_CHANGER , "Using<S2SV_blank>generic<S2SV_blank>cdrom_select_disc()\\n" ) ; return cdrom_select_disc ( cdi , arg ) ; }
CWE-125 static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( "\\n" , config -> errors ) ; ptr += cut + 1 ; <S2SV_StartBug> len -= cut ; <S2SV_EndBug> } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }
CWE-119 int vp8_encode_intra ( VP8_COMP * cpi , MACROBLOCK * x , int use_dc_pred ) { int i ; int intra_pred_var = 0 ; ( void ) cpi ; if ( use_dc_pred ) { x -> e_mbd . mode_info_context -> mbmi . mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; vp8_encode_intra16x16mby ( x ) ; vp8_inverse_transform_mby ( & x -> e_mbd ) ; } else { for ( i = 0 ; i < 16 ; i ++ ) { x -> e_mbd . block [ i ] . bmi . as_mode = B_DC_PRED ; vp8_encode_intra4x4block ( x , i ) ; } } <S2SV_StartBug> intra_pred_var = vp8_get_mb_ss ( x -> src_diff ) ; <S2SV_EndBug> return intra_pred_var ; }
CWE-190 static void bump_cpu_timer ( struct k_itimer * timer , u64 now ) { int i ; u64 delta , incr ; if ( timer -> it . cpu . incr == 0 ) return ; if ( now < timer -> it . cpu . expires ) return ; incr = timer -> it . cpu . incr ; delta = now + incr - timer -> it . cpu . expires ; for ( i = 0 ; incr < delta - incr ; i ++ ) incr = incr << 1 ; for ( ; i >= 0 ; incr >>= 1 , i -- ) { if ( delta < incr ) continue ; timer -> it . cpu . expires += incr ; <S2SV_StartBug> timer -> it_overrun += 1 << i ; <S2SV_EndBug> delta -= incr ; } }
CWE-264 static int userns_install ( struct nsproxy * nsproxy , void * ns ) { struct user_namespace * user_ns = ns ; struct cred * cred ; if ( user_ns == current_user_ns ( ) ) return - EINVAL ; <S2SV_StartBug> if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) <S2SV_EndBug> return - EINVAL ; if ( ! ns_capable ( user_ns , CAP_SYS_ADMIN ) ) return - EPERM ; cred = prepare_creds ( ) ; if ( ! cred ) return - ENOMEM ; put_user_ns ( cred -> user_ns ) ; set_cred_user_ns ( cred , get_user_ns ( user_ns ) ) ; return commit_creds ( cred ) ; }
CWE-119 static vpx_codec_err_t ctrl_set_active_map ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_active_map_t * const map = va_arg ( args , vpx_active_map_t * ) ; if ( map ) { <S2SV_StartBug> if ( ! vp9_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) <S2SV_EndBug> return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else { return VPX_CODEC_INVALID_PARAM ; } }
CWE-284 int sock_recv_all ( int sock_fd , uint8_t * buf , int len ) { int r = len ; int ret = - 1 ; while ( r ) { <S2SV_StartBug> do ret = recv ( sock_fd , buf , r , MSG_WAITALL ) ; <S2SV_EndBug> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( "sock<S2SV_blank>fd:%d<S2SV_blank>recv<S2SV_blank>errno:%d,<S2SV_blank>ret:%d" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; r -= ret ; } return len ; }
CWE-416 static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; <S2SV_StartBug> if ( len < tcp_hdrlen ) <S2SV_EndBug> return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( "unknown<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>path-MTU<S2SV_blank>(%u)\\n" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; if ( oldmss <= newmss ) return 0 ; opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ i + 3 ] = newmss & 0x00ff ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( oldmss ) , htons ( newmss ) , false ) ; return 0 ; } } if ( len > tcp_hdrlen ) return 0 ; <S2SV_StartBug> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { <S2SV_EndBug> if ( pskb_expand_head ( skb , 0 , TCPOLEN_MSS - skb_tailroom ( skb ) , GFP_ATOMIC ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; } skb_put ( skb , TCPOLEN_MSS ) ; if ( xt_family ( par ) == NFPROTO_IPV4 ) newmss = min ( newmss , ( u16 ) 536 ) ; else newmss = min ( newmss , ( u16 ) 1220 ) ; opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; memmove ( opt + TCPOLEN_MSS , opt , len - sizeof ( struct tcphdr ) ) ; inet_proto_csum_replace2 ( & tcph -> check , skb , htons ( len ) , htons ( len + TCPOLEN_MSS ) , true ) ; opt [ 0 ] = TCPOPT_MSS ; opt [ 1 ] = TCPOLEN_MSS ; opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; opt [ 3 ] = newmss & 0x00ff ; inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; oldval = ( ( __be16 * ) tcph ) [ 6 ] ; tcph -> doff += TCPOLEN_MSS / 4 ; inet_proto_csum_replace2 ( & tcph -> check , skb , oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; return TCPOLEN_MSS ; }
CWE-200 static void copy_to_user_policy ( struct xfrm_policy * xp , struct xfrm_userpolicy_info * p , int dir ) <S2SV_StartBug> { <S2SV_EndBug> memcpy ( & p -> sel , & xp -> selector , sizeof ( p -> sel ) ) ; memcpy ( & p -> lft , & xp -> lft , sizeof ( p -> lft ) ) ; memcpy ( & p -> curlft , & xp -> curlft , sizeof ( p -> curlft ) ) ; p -> priority = xp -> priority ; p -> index = xp -> index ; p -> sel . family = xp -> family ; p -> dir = dir ; p -> action = xp -> action ; p -> flags = xp -> flags ; p -> share = XFRM_SHARE_ANY ; }
CWE-119 void vp9_restore_layer_context ( VP9_COMP * const cpi ) { <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> const int old_frame_since_key = cpi -> rc . frames_since_key ; const int old_frame_to_key = cpi -> rc . frames_to_key ; cpi -> rc = lc -> rc ; cpi -> twopass = lc -> twopass ; cpi -> oxcf . target_bandwidth = lc -> target_bandwidth ; <S2SV_StartBug> cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ; <S2SV_EndBug> cpi -> oxcf . optimal_buffer_level = lc -> optimal_buffer_level ; cpi -> oxcf . maximum_buffer_size = lc -> maximum_buffer_size ; cpi -> output_framerate = lc -> framerate ; if ( cpi -> svc . number_temporal_layers > 1 ) { cpi -> rc . frames_since_key = old_frame_since_key ; cpi -> rc . frames_to_key = old_frame_to_key ; } }
CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = "tun%d" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = "tap%d" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; <S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , "tun_set_iff\\n" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }
CWE-200 static void ipv6_select_ident ( struct frag_hdr * fhdr , struct rt6_info * rt ) { static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_src . addr , hash ) ; <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> fhdr -> identification = htonl ( id ) ; }
CWE-119 void mp_decode_to_lua_array ( lua_State * L , mp_cur * c , size_t len ) { assert ( len <= UINT_MAX ) ; int index = 1 ; <S2SV_StartBug> lua_newtable ( L ) ; <S2SV_EndBug> while ( len -- ) { lua_pushnumber ( L , index ++ ) ; mp_decode_to_lua_type ( L , c ) ; if ( c -> err ) return ; lua_settable ( L , - 3 ) ; } }
CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; <S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> int n = 0 ; defaultoptions ( & h ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; <S2SV_EndBug> luaL_checkstack ( L , 2 , "too<S2SV_blank>many<S2SV_blank>results" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; n ++ ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; n ++ ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; n ++ ; break ; } case 'c' : { if ( size == 0 ) { if ( n == 0 || ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , "format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; n -- ; luaL_argcheck ( L , size <= ld && pos <= ld - size , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; } lua_pushlstring ( L , data + pos , size ) ; n ++ ; break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , "unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data" ) ; size = ( e - ( data + pos ) ) + 1 ; lua_pushlstring ( L , data + pos , size - 1 ) ; n ++ ; break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; return n + 1 ; }
CWE-284 static int uhid_event ( btif_hh_device_t * p_dev ) { struct uhid_event ev ; ssize_t ret ; memset ( & ev , 0 , sizeof ( ev ) ) ; if ( ! p_dev ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Device<S2SV_blank>not<S2SV_blank>found" , __FUNCTION__ ) return - 1 ; } <S2SV_StartBug> ret = read ( p_dev -> fd , & ev , sizeof ( ev ) ) ; <S2SV_EndBug> if ( ret == 0 ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Read<S2SV_blank>HUP<S2SV_blank>on<S2SV_blank>uhid-cdev<S2SV_blank>%s" , __FUNCTION__ , strerror ( errno ) ) ; return - EFAULT ; } else if ( ret < 0 ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Cannot<S2SV_blank>read<S2SV_blank>uhid-cdev:<S2SV_blank>%s" , __FUNCTION__ , strerror ( errno ) ) ; return - errno ; } else if ( ( ev . type == UHID_OUTPUT ) || ( ev . type == UHID_OUTPUT_EV ) ) { if ( ret < ( ssize_t ) sizeof ( ev ) ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Invalid<S2SV_blank>size<S2SV_blank>read<S2SV_blank>from<S2SV_blank>uhid-dev:<S2SV_blank>%ld<S2SV_blank>!=<S2SV_blank>%lu" , __FUNCTION__ , ret , sizeof ( ev . type ) ) ; return - EFAULT ; } } switch ( ev . type ) { case UHID_START : APPL_TRACE_DEBUG ( "UHID_START<S2SV_blank>from<S2SV_blank>uhid-dev\\n" ) ; p_dev -> ready_for_data = TRUE ; break ; case UHID_STOP : APPL_TRACE_DEBUG ( "UHID_STOP<S2SV_blank>from<S2SV_blank>uhid-dev\\n" ) ; p_dev -> ready_for_data = FALSE ; break ; case UHID_OPEN : APPL_TRACE_DEBUG ( "UHID_OPEN<S2SV_blank>from<S2SV_blank>uhid-dev\\n" ) ; break ; case UHID_CLOSE : APPL_TRACE_DEBUG ( "UHID_CLOSE<S2SV_blank>from<S2SV_blank>uhid-dev\\n" ) ; p_dev -> ready_for_data = FALSE ; break ; case UHID_OUTPUT : if ( ret < ( ssize_t ) ( sizeof ( ev . type ) + sizeof ( ev . u . output ) ) ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Invalid<S2SV_blank>size<S2SV_blank>read<S2SV_blank>from<S2SV_blank>uhid-dev:<S2SV_blank>%zd<S2SV_blank><<S2SV_blank>%zu" , __FUNCTION__ , ret , sizeof ( ev . type ) + sizeof ( ev . u . output ) ) ; return - EFAULT ; } APPL_TRACE_DEBUG ( "UHID_OUTPUT:<S2SV_blank>Report<S2SV_blank>type<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>report_size<S2SV_blank>=<S2SV_blank>%d" , ev . u . output . rtype , ev . u . output . size ) ; if ( ev . u . output . rtype == UHID_FEATURE_REPORT ) btif_hh_setreport ( p_dev , BTHH_FEATURE_REPORT , ev . u . output . size , ev . u . output . data ) ; else if ( ev . u . output . rtype == UHID_OUTPUT_REPORT ) btif_hh_setreport ( p_dev , BTHH_OUTPUT_REPORT , ev . u . output . size , ev . u . output . data ) ; else btif_hh_setreport ( p_dev , BTHH_INPUT_REPORT , ev . u . output . size , ev . u . output . data ) ; break ; case UHID_OUTPUT_EV : APPL_TRACE_DEBUG ( "UHID_OUTPUT_EV<S2SV_blank>from<S2SV_blank>uhid-dev\\n" ) ; break ; case UHID_FEATURE : APPL_TRACE_DEBUG ( "UHID_FEATURE<S2SV_blank>from<S2SV_blank>uhid-dev\\n" ) ; break ; case UHID_FEATURE_ANSWER : APPL_TRACE_DEBUG ( "UHID_FEATURE_ANSWER<S2SV_blank>from<S2SV_blank>uhid-dev\\n" ) ; break ; default : APPL_TRACE_DEBUG ( "Invalid<S2SV_blank>event<S2SV_blank>from<S2SV_blank>uhid-dev:<S2SV_blank>%u\\n" , ev . type ) ; } return 0 ; }
CWE-190 static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }
CWE-119 static int check_stack_boundary ( struct bpf_verifier_env * env , int regno , int access_size , bool zero_size_allowed , struct bpf_call_arg_meta * meta ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = state -> regs ; int off , i , slot , spi ; if ( regs [ regno ] . type != PTR_TO_STACK ) { if ( zero_size_allowed && access_size == 0 && register_is_null ( regs [ regno ] ) ) return 0 ; verbose ( env , "R%d<S2SV_blank>type=%s<S2SV_blank>expected=%s\\n" , regno , reg_type_str [ regs [ regno ] . type ] , reg_type_str [ PTR_TO_STACK ] ) ; return - EACCES ; } if ( ! tnum_is_const ( regs [ regno ] . var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , regs [ regno ] . var_off ) ; verbose ( env , "invalid<S2SV_blank>variable<S2SV_blank>stack<S2SV_blank>read<S2SV_blank>R%d<S2SV_blank>var_off=%s\\n" , regno , tn_buf ) ; <S2SV_StartBug> } <S2SV_EndBug> off = regs [ regno ] . off + regs [ regno ] . var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK || off + access_size > 0 || access_size < 0 || ( access_size == 0 && ! zero_size_allowed ) ) { verbose ( env , "invalid<S2SV_blank>stack<S2SV_blank>type<S2SV_blank>R%d<S2SV_blank>off=%d<S2SV_blank>access_size=%d\\n" , regno , off , access_size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( meta && meta -> raw_mode ) { meta -> access_size = access_size ; meta -> regno = regno ; return 0 ; } for ( i = 0 ; i < access_size ; i ++ ) { slot = - ( off + i ) - 1 ; spi = slot / BPF_REG_SIZE ; if ( state -> allocated_stack <= slot || state -> stack [ spi ] . slot_type [ slot % BPF_REG_SIZE ] != STACK_MISC ) { verbose ( env , "invalid<S2SV_blank>indirect<S2SV_blank>read<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>off<S2SV_blank>%d+%d<S2SV_blank>size<S2SV_blank>%d\\n" , off , i , access_size ) ; return - EACCES ; } } return 0 ; }
CWE-20 static int tomoyo_mount_acl ( struct tomoyo_request_info * r , char * dev_name , struct path * dir , char * type , unsigned long flags ) { struct path path ; struct file_system_type * fstype = NULL ; const char * requested_type = NULL ; const char * requested_dir_name = NULL ; const char * requested_dev_name = NULL ; struct tomoyo_path_info rtype ; struct tomoyo_path_info rdev ; struct tomoyo_path_info rdir ; int need_dev = 0 ; int error = - ENOMEM ; requested_type = tomoyo_encode ( type ) ; if ( ! requested_type ) goto out ; rtype . name = requested_type ; tomoyo_fill_path_info ( & rtype ) ; requested_dir_name = tomoyo_realpath_from_path ( dir ) ; if ( ! requested_dir_name ) { error = - ENOMEM ; goto out ; } rdir . name = requested_dir_name ; tomoyo_fill_path_info ( & rdir ) ; if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_BIND_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MOVE_KEYWORD ) ) { need_dev = - 1 ; } else { fstype = get_fs_type ( type ) ; if ( ! fstype ) { error = - ENODEV ; goto out ; } if ( fstype -> fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if ( need_dev ) { <S2SV_StartBug> if ( kern_path ( dev_name , LOOKUP_FOLLOW , & path ) ) { <S2SV_EndBug> error = - ENOENT ; goto out ; } requested_dev_name = tomoyo_realpath_from_path ( & path ) ; path_put ( & path ) ; if ( ! requested_dev_name ) { error = - ENOENT ; goto out ; } } else { if ( ! dev_name ) dev_name = "<NULL>" ; requested_dev_name = tomoyo_encode ( dev_name ) ; if ( ! requested_dev_name ) { error = - ENOMEM ; goto out ; } } rdev . name = requested_dev_name ; tomoyo_fill_path_info ( & rdev ) ; r -> param_type = TOMOYO_TYPE_MOUNT_ACL ; r -> param . mount . need_dev = need_dev ; r -> param . mount . dev = & rdev ; r -> param . mount . dir = & rdir ; r -> param . mount . type = & rtype ; r -> param . mount . flags = flags ; do { tomoyo_check_acl ( r , tomoyo_check_mount_acl ) ; error = tomoyo_audit_mount_log ( r ) ; } while ( error == TOMOYO_RETRY_REQUEST ) ; out : kfree ( requested_dev_name ) ; kfree ( requested_dir_name ) ; if ( fstype ) put_filesystem ( fstype ) ; kfree ( requested_type ) ; return error ; }
CWE-119 void vp8_mbpost_proc_across_ip_c ( unsigned char * src , int pitch , int rows , int cols , int flimit ) { int r , c , i ; unsigned char * s = src ; unsigned char d [ 16 ] ; for ( r = 0 ; r < rows ; r ++ ) { int sumsq = 0 ; int sum = 0 ; for ( i = - 8 ; i < 0 ; i ++ ) s [ i ] = s [ 0 ] ; <S2SV_StartBug> for ( i = cols ; i < cols + 17 ; i ++ ) <S2SV_EndBug> s [ i ] = s [ cols - 1 ] ; for ( i = - 8 ; i <= 6 ; i ++ ) { sumsq += s [ i ] * s [ i ] ; sum += s [ i ] ; d [ i + 8 ] = 0 ; } for ( c = 0 ; c < cols + 8 ; c ++ ) { int x = s [ c + 7 ] - s [ c - 8 ] ; int y = s [ c + 7 ] + s [ c - 8 ] ; sum += x ; sumsq += x * y ; d [ c & 15 ] = s [ c ] ; if ( sumsq * 15 - sum * sum < flimit ) { d [ c & 15 ] = ( 8 + sum + s [ c ] ) >> 4 ; } s [ c - 8 ] = d [ ( c - 8 ) & 15 ] ; } s += pitch ; } }
CWE-119 static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>command_info<S2SV_blank>is<S2SV_blank>NULL,<S2SV_blank>exiting.\\n" , __func__ ) ; return ; } <S2SV_StartBug> if ( status ) { <S2SV_EndBug> dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\n" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\n" , __func__ ) ; <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> memcpy ( command_info -> result_buffer , & data [ 1 ] , <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>reply<S2SV_blank>from<S2SV_blank>firmware\\n" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>resubmitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n" , __func__ , result ) ; }
CWE-362 static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; struct sctp_bind_hashbucket * head ; <S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug> memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ; inet_sk_copy_descendant ( newsk , oldsk ) ; memcpy ( & newsp -> auto_asconf_list , & tmplist , sizeof ( tmplist ) ) ; } else inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; head = & sctp_port_hashtable [ sctp_phashfn ( sock_net ( oldsk ) , inet_sk ( oldsk ) -> inet_num ) ] ; local_bh_disable ( ) ; spin_lock ( & head -> lock ) ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> inet_num = inet_sk ( oldsk ) -> inet_num ; spin_unlock ( & head -> lock ) ; local_bh_enable ( ) ; sctp_bind_addr_dup ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , GFP_KERNEL ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } skb_queue_head_init ( & newsp -> pd_lobby ) ; atomic_set ( & sctp_sk ( newsk ) -> pd_mode , assoc -> ulpq . pd_mode ) ; if ( atomic_read ( & sctp_sk ( oldsk ) -> pd_mode ) ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } if ( assoc -> ulpq . pd_mode ) sctp_clear_pd ( oldsk , NULL ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; newsp -> type = type ; lock_sock_nested ( newsk , SINGLE_DEPTH_NESTING ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; release_sock ( newsk ) ; }
CWE-119 static SCSIRequest * scsi_new_request ( SCSIDevice * d , uint32_t tag , uint32_t lun , void * hba_private ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; SCSIRequest * req ; <S2SV_StartBug> SCSIDiskReq * r ; <S2SV_EndBug> req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ; <S2SV_StartBug> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_EndBug> r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ; return req ; }
CWE-000 void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { <S2SV_StartBug> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; <S2SV_EndBug> return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , ".cfg" ) ; Com_Printf ( "Writing<S2SV_blank>%s.\\n" , filename ) ; Com_WriteConfigToFile ( filename ) ; }
CWE-125 u_int null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int length = h -> len ; u_int caplen = h -> caplen ; u_int family ; if ( caplen < NULL_HDRLEN ) { ND_PRINT ( ( ndo , "[|null]" ) ) ; return ( NULL_HDRLEN ) ; } memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; if ( ( family & 0xFFFF0000 ) != 0 ) family = SWAPLONG ( family ) ; if ( ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length ) ; length -= NULL_HDRLEN ; caplen -= NULL_HDRLEN ; p += NULL_HDRLEN ; switch ( family ) { case BSD_AFNUM_INET : ip_print ( ndo , p , length ) ; break ; case BSD_AFNUM_INET6_BSD : case BSD_AFNUM_INET6_FREEBSD : case BSD_AFNUM_INET6_DARWIN : ip6_print ( ndo , p , length ) ; break ; case BSD_AFNUM_ISO : <S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> break ; case BSD_AFNUM_APPLETALK : atalk_print ( ndo , p , length ) ; break ; case BSD_AFNUM_IPX : ipx_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; } return ( NULL_HDRLEN ) ; }
CWE-000 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , "%s" , "larval" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-125 static void atmarp_print ( netdissect_options * ndo , const u_char * bp , u_int length , u_int caplen ) { const struct atmarp_pkthdr * ap ; u_short pro , hrd , op ; ap = ( const struct atmarp_pkthdr * ) bp ; ND_TCHECK ( * ap ) ; hrd = ATMHRD ( ap ) ; pro = ATMPRO ( ap ) ; op = ATMOP ( ap ) ; if ( ! ND_TTEST2 ( * aar_tpa ( ap ) , ATMTPROTO_LEN ( ap ) ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; return ; } if ( ! ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , "ARP,<S2SV_blank>" ) ) ; } if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || ATMSPROTO_LEN ( ap ) != 4 || ATMTPROTO_LEN ( ap ) != 4 || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)" , tok2str ( arphrd_values , "Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)" , hrd ) , tok2str ( ethertype_values , "Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)" , pro ) , ATMSPROTO_LEN ( ap ) , ATMTPROTO_LEN ( ap ) ) ) ; if ( ! ndo -> ndo_vflag ) { goto out ; } } ND_PRINT ( ( ndo , "%s%s<S2SV_blank>" , ndo -> ndo_vflag ? ",<S2SV_blank>" : "" , tok2str ( arpop_values , "Unknown<S2SV_blank>(%u)" , op ) ) ) ; switch ( op ) { case ARPOP_REQUEST : <S2SV_StartBug> ND_PRINT ( ( ndo , "who-has<S2SV_blank>%s" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; <S2SV_EndBug> if ( ATMTHRD_LEN ( ap ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , ")" ) ) ; } <S2SV_StartBug> ND_PRINT ( ( ndo , "tell<S2SV_blank>%s" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; case ARPOP_REPLY : <S2SV_StartBug> ND_PRINT ( ( ndo , "%s<S2SV_blank>is-at<S2SV_blank>" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREQUEST : ND_PRINT ( ( ndo , "who-is<S2SV_blank>" ) ) ; atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; break ; case ARPOP_INVREPLY : atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , ATMSSLN ( ap ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "at<S2SV_blank>%s" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; case ARPOP_NAK : <S2SV_StartBug> ND_PRINT ( ( ndo , "for<S2SV_blank>%s" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; <S2SV_EndBug> break ; default : ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; return ; } out : ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
CWE-000 static int dn_create ( struct net * net , struct socket * sock , int protocol , int kern ) { <S2SV_StartBug> struct sock * sk ; <S2SV_EndBug> if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_SEQPACKET : if ( protocol != DNPROTO_NSP ) return - EPROTONOSUPPORT ; break ; case SOCK_STREAM : break ; default : return - ESOCKTNOSUPPORT ; } if ( ( sk = dn_alloc_sock ( net , sock , GFP_KERNEL , kern ) ) == NULL ) return - ENOBUFS ; sk -> sk_protocol = protocol ; return 0 ; }
CWE-119 char * path_name ( const struct name_path * path , const char * name ) { const struct name_path * p ; char * n , * m ; int nlen = strlen ( name ) ; int len = nlen + 1 ; for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) len += p -> elem_len + 1 ; } n = xmalloc ( len ) ; m = n + len - ( nlen + 1 ) ; <S2SV_StartBug> strcpy ( m , name ) ; <S2SV_EndBug> for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) { m -= p -> elem_len + 1 ; memcpy ( m , p -> elem , p -> elem_len ) ; m [ p -> elem_len ] = '/' ; } } return n ; }
CWE-125 static int string_scan_range ( RList * list , RBinFile * bf , int min , const ut64 from , const ut64 to , int type ) { ut8 tmp [ R_STRING_SCAN_BUFFER_SIZE ] ; ut64 str_start , needle = from ; int count = 0 , i , rc , runes ; int str_type = R_STRING_TYPE_DETECT ; if ( type == - 1 ) { type = R_STRING_TYPE_DETECT ; } if ( from >= to ) { eprintf ( "Invalid<S2SV_blank>range<S2SV_blank>to<S2SV_blank>find<S2SV_blank>strings<S2SV_blank>0x%llx<S2SV_blank>..<S2SV_blank>0x%llx\\n" , from , to ) ; return - 1 ; } <S2SV_StartBug> ut8 * buf = calloc ( to - from , 1 ) ; <S2SV_EndBug> if ( ! buf || ! min ) { return - 1 ; } <S2SV_StartBug> r_buf_read_at ( bf -> buf , from , buf , to - from ) ; <S2SV_EndBug> while ( needle < to ) { rc = r_utf8_decode ( buf + needle - from , to - needle , NULL ) ; if ( ! rc ) { needle ++ ; continue ; } if ( type == R_STRING_TYPE_DETECT ) { char * w = ( char * ) buf + needle + rc - from ; <S2SV_StartBug> if ( ( to - needle ) > 5 ) { <S2SV_EndBug> <S2SV_StartBug> bool is_wide32 = needle + rc + 2 < to && ! w [ 0 ] && ! w [ 1 ] && ! w [ 2 ] && w [ 3 ] && ! w [ 4 ] ; <S2SV_EndBug> if ( is_wide32 ) { str_type = R_STRING_TYPE_WIDE32 ; } else { bool is_wide = needle + rc + 2 < to && ! w [ 0 ] && w [ 1 ] && ! w [ 2 ] ; str_type = is_wide ? R_STRING_TYPE_WIDE : R_STRING_TYPE_ASCII ; } } else { str_type = R_STRING_TYPE_ASCII ; } } else { str_type = type ; } runes = 0 ; str_start = needle ; for ( rc = i = 0 ; i < sizeof ( tmp ) - 3 && needle < to ; i += rc ) { RRune r = { 0 } ; if ( str_type == R_STRING_TYPE_WIDE32 ) { rc = r_utf32le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc ) { rc = 4 ; } } else if ( str_type == R_STRING_TYPE_WIDE ) { rc = r_utf16le_decode ( buf + needle - from , to - needle , & r ) ; if ( rc == 1 ) { rc = 2 ; } } else { rc = r_utf8_decode ( buf + needle - from , to - needle , & r ) ; if ( rc > 1 ) { str_type = R_STRING_TYPE_UTF8 ; } } if ( ! rc ) { needle ++ ; break ; } needle += rc ; if ( r_isprint ( r ) && r != '\\\\' ) { if ( str_type == R_STRING_TYPE_WIDE32 ) { if ( r == 0xff ) { r = 0 ; } } rc = r_utf8_encode ( & tmp [ i ] , r ) ; runes ++ ; } else if ( r && r < 0x100 && strchr ( "\\b\\v\\f\\n\\r\\t\\a\\033\\\\" , ( char ) r ) ) { if ( ( i + 32 ) < sizeof ( tmp ) && r < 93 ) { tmp [ i + 0 ] = '\\\\' ; tmp [ i + 1 ] = "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>abtnvfr<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>e<S2SV_blank><S2SV_blank>" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" "<S2SV_blank><S2SV_blank>\\\\" [ r ] ; } else { break ; } rc = 2 ; runes ++ ; } else { break ; } } tmp [ i ++ ] = '\\0' ; if ( runes >= min ) { if ( str_type == R_STRING_TYPE_ASCII ) { int j ; for ( j = 0 ; j < i ; j ++ ) { char ch = tmp [ j ] ; if ( ch != '\\n' && ch != '\\r' && ch != '\\t' ) { if ( ! IS_PRINTABLE ( tmp [ j ] ) ) { continue ; } } } } RBinString * bs = R_NEW0 ( RBinString ) ; if ( ! bs ) { break ; } bs -> type = str_type ; bs -> length = runes ; bs -> size = needle - str_start ; bs -> ordinal = count ++ ; switch ( str_type ) { case R_STRING_TYPE_WIDE : if ( str_start - from > 1 ) { const ut8 * p = buf + str_start - 2 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 2 ; } } break ; case R_STRING_TYPE_WIDE32 : if ( str_start - from > 3 ) { const ut8 * p = buf + str_start - 4 - from ; if ( p [ 0 ] == 0xff && p [ 1 ] == 0xfe ) { str_start -= 4 ; } } break ; } bs -> paddr = bs -> vaddr = str_start ; bs -> string = r_str_ndup ( ( const char * ) tmp , i ) ; if ( list ) { r_list_append ( list , bs ) ; } else { print_string ( bs , bf ) ; r_bin_string_free ( bs ) ; } } } free ( buf ) ; return count ; }
CWE-119 int vp8_full_search_sadx8 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; unsigned char * in_what ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned short , sad_array8 , 8 ) ; <S2SV_EndBug> unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , <S2SV_StartBug> bestaddress , in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; c = col_min ; while ( ( c + 7 ) < col_max ) { int i ; fn_ptr -> sdx8f ( what , what_stride , check_here , in_what_stride , sad_array8 ) ; for ( i = 0 ; i < 8 ; i ++ ) { thissad = sad_array8 [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( ( c + 2 ) < col_max ) { int i ; fn_ptr -> sdx3f ( what , what_stride , check_here , in_what_stride , sad_array ) ; for ( i = 0 ; i < 3 ; i ++ ) { thissad = sad_array [ i ] ; if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } while ( c < col_max ) { <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } } check_here ++ ; c ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row * 8 ; this_mv . as_mv . col = best_mv -> as_mv . col * 8 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
CWE-264 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ MNT_WRITE_HOLD ; <S2SV_StartBug> atomic_inc ( & sb -> s_active ) ; <S2SV_EndBug> mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; br_write_unlock ( & vfsmount_lock ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }
CWE-399 asmlinkage void do_ade ( struct pt_regs * regs ) { unsigned int __user * pc ; mm_segment_t seg ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , <S2SV_StartBug> 1 , 0 , regs , regs -> cp0_badvaddr ) ; <S2SV_EndBug> if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ; pc = ( unsigned int __user * ) exception_epc ( regs ) ; if ( user_mode ( regs ) && ! test_thread_flag ( TIF_FIXADE ) ) goto sigbus ; if ( unaligned_action == UNALIGNED_ACTION_SIGNAL ) goto sigbus ; else if ( unaligned_action == UNALIGNED_ACTION_SHOW ) show_registers ( regs ) ; seg = get_fs ( ) ; if ( ! user_mode ( regs ) ) set_fs ( KERNEL_DS ) ; emulate_load_store_insn ( regs , ( void __user * ) regs -> cp0_badvaddr , pc ) ; set_fs ( seg ) ; return ; sigbus : die_if_kernel ( "Kernel<S2SV_blank>unaligned<S2SV_blank>instruction<S2SV_blank>access" , regs ) ; force_sig ( SIGBUS , current ) ; }
CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ipt_entry * e = ( struct ipt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ipt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( "iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( "mark_source_chains:<S2SV_blank>bad<S2SV_blank>" "negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( "Back<S2SV_blank>unset<S2SV_blank>" "on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>" "rule<S2SV_blank>%u\\n" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ipt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ipt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ipt_entry ) ) { duprintf ( "mark_source_chains:<S2SV_blank>" "bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , newpos ) ; return 0 ; } duprintf ( "Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ipt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( "Finished<S2SV_blank>chain<S2SV_blank>%u\\n" , hook ) ; } return 1 ; }
CWE-264 int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy ) <S2SV_StartBug> { <S2SV_EndBug> if ( policy -> version != 0 ) return - EINVAL ; if ( ! inode_has_encryption_context ( inode ) ) { if ( ! inode -> i_sb -> s_cop -> empty_dir ) return - EOPNOTSUPP ; if ( ! inode -> i_sb -> s_cop -> empty_dir ( inode ) ) return - ENOTEMPTY ; return create_encryption_context_from_policy ( inode , policy ) ; } if ( is_encryption_context_consistent_with_policy ( inode , policy ) ) return 0 ; printk ( KERN_WARNING "%s:<S2SV_blank>Policy<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>encryption<S2SV_blank>context\\n" , __func__ ) ; return - EINVAL ; }
CWE-125 static int ng_pkt ( git_pkt * * out , const char * line , size_t len ) { git_pkt_ng * pkt ; const char * ptr ; size_t alloclen ; pkt = git__malloc ( sizeof ( * pkt ) ) ; GITERR_CHECK_ALLOC ( pkt ) ; pkt -> ref = NULL ; pkt -> type = GIT_PKT_NG ; <S2SV_StartBug> line += 3 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '<S2SV_blank>' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref , line , len ) ; pkt -> ref [ len ] = '\\0' ; <S2SV_StartBug> line = ptr + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( ptr = strchr ( line , '\\n' ) ) ) <S2SV_EndBug> goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg , line , len ) ; pkt -> msg [ len ] = '\\0' ; * out = ( git_pkt * ) pkt ; return 0 ; out_err : giterr_set ( GITERR_NET , "invalid<S2SV_blank>packet<S2SV_blank>line" ) ; git__free ( pkt -> ref ) ; git__free ( pkt ) ; return - 1 ; }
CWE-000 static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> strlcpy ( rcipher . type , "cipher" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-125 static void * Type_MLU_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) { cmsMLU * mlu ; cmsUInt32Number Count , RecLen , NumOfWchar ; cmsUInt32Number SizeOfHeader ; cmsUInt32Number Len , Offset ; cmsUInt32Number i ; wchar_t * Block ; cmsUInt32Number BeginOfThisString , EndOfThisString , LargestPosition ; * nItems = 0 ; if ( ! _cmsReadUInt32Number ( io , & Count ) ) return NULL ; if ( ! _cmsReadUInt32Number ( io , & RecLen ) ) return NULL ; if ( RecLen != 12 ) { cmsSignalError ( self -> ContextID , cmsERROR_UNKNOWN_EXTENSION , "multiLocalizedUnicodeType<S2SV_blank>of<S2SV_blank>len<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported." ) ; return NULL ; } mlu = cmsMLUalloc ( self -> ContextID , Count ) ; if ( mlu == NULL ) return NULL ; mlu -> UsedEntries = Count ; SizeOfHeader = 12 * Count + sizeof ( _cmsTagBase ) ; LargestPosition = 0 ; for ( i = 0 ; i < Count ; i ++ ) { if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Language ) ) goto Error ; if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Country ) ) goto Error ; if ( ! _cmsReadUInt32Number ( io , & Len ) ) goto Error ; if ( ! _cmsReadUInt32Number ( io , & Offset ) ) goto Error ; <S2SV_StartBug> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; <S2SV_EndBug> BeginOfThisString = Offset - SizeOfHeader - 8 ; mlu -> Entries [ i ] . Len = ( Len * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; mlu -> Entries [ i ] . StrW = ( BeginOfThisString * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; EndOfThisString = BeginOfThisString + Len ; if ( EndOfThisString > LargestPosition ) LargestPosition = EndOfThisString ; } SizeOfTag = ( LargestPosition * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; if ( SizeOfTag == 0 ) { Block = NULL ; NumOfWchar = 0 ; } else { Block = ( wchar_t * ) _cmsMalloc ( self -> ContextID , SizeOfTag ) ; if ( Block == NULL ) goto Error ; NumOfWchar = SizeOfTag / sizeof ( wchar_t ) ; if ( ! _cmsReadWCharArray ( io , NumOfWchar , Block ) ) goto Error ; } mlu -> MemPool = Block ; mlu -> PoolSize = SizeOfTag ; mlu -> PoolUsed = SizeOfTag ; * nItems = 1 ; return ( void * ) mlu ; Error : if ( mlu ) cmsMLUfree ( mlu ) ; return NULL ; }
CWE-787 static int bmpr_read_rle ( struct iwbmprcontext * rctx ) { int retval = 0 ; if ( ! ( rctx -> compression == IWBMP_BI_RLE8 && rctx -> bitcount == 8 ) && ! ( rctx -> compression == IWBMP_BI_RLE4 && rctx -> bitcount == 4 ) ) { iw_set_error ( rctx -> ctx , "Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( rctx -> topdown ) { <S2SV_StartBug> iw_set_error ( rctx -> ctx , "Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images" ) ; <S2SV_EndBug> } rctx -> img -> imgtype = IW_IMGTYPE_RGBA ; rctx -> img -> bit_depth = 8 ; rctx -> img -> bpr = iw_calc_bytesperrow ( rctx -> width , 32 ) ; rctx -> img -> pixels = ( iw_byte * ) iw_malloc_large ( rctx -> ctx , rctx -> img -> bpr , rctx -> img -> height ) ; if ( ! rctx -> img -> pixels ) goto done ; if ( ! bmpr_read_rle_internal ( rctx ) ) goto done ; if ( ! bmpr_has_transparency ( rctx -> img ) ) { bmpr_strip_alpha ( rctx -> img ) ; } retval = 1 ; done : return retval ; }
CWE-119 void vp9_foreach_transformed_block ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , foreach_transformed_block_visitor visit , void * arg ) { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <S2SV_EndBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; }
CWE-000 static int iowarrior_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct iowarrior * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; int i ; int retval = - ENOMEM ; dev = kzalloc ( sizeof ( struct iowarrior ) , GFP_KERNEL ) ; if ( dev == NULL ) { dev_err ( & interface -> dev , "Out<S2SV_blank>of<S2SV_blank>memory\\n" ) ; return retval ; } mutex_init ( & dev -> mutex ) ; atomic_set ( & dev -> intr_idx , 0 ) ; atomic_set ( & dev -> read_idx , 0 ) ; spin_lock_init ( & dev -> intr_idx_lock ) ; atomic_set ( & dev -> overflow_flag , 0 ) ; init_waitqueue_head ( & dev -> read_wait ) ; atomic_set ( & dev -> write_busy , 0 ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> udev = udev ; dev -> interface = interface ; iface_desc = interface -> cur_altsetting ; <S2SV_StartBug> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; <S2SV_EndBug> for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( endpoint ) ) dev -> int_in_endpoint = endpoint ; if ( usb_endpoint_is_int_out ( endpoint ) ) dev -> int_out_endpoint = endpoint ; } dev -> report_size = usb_endpoint_maxp ( dev -> int_in_endpoint ) ; if ( ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) && ( dev -> product_id == USB_DEVICE_ID_CODEMERCS_IOW56 ) ) dev -> report_size = 7 ; dev -> int_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> int_in_urb ) { dev_err ( & interface -> dev , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>interrupt_in_urb\\n" ) ; goto error ; } dev -> int_in_buffer = kmalloc ( dev -> report_size , GFP_KERNEL ) ; if ( ! dev -> int_in_buffer ) { dev_err ( & interface -> dev , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>int_in_buffer\\n" ) ; goto error ; } usb_fill_int_urb ( dev -> int_in_urb , dev -> udev , usb_rcvintpipe ( dev -> udev , dev -> int_in_endpoint -> bEndpointAddress ) , dev -> int_in_buffer , dev -> report_size , iowarrior_callback , dev , dev -> int_in_endpoint -> bInterval ) ; dev -> read_queue = kmalloc ( ( ( dev -> report_size + 1 ) * MAX_INTERRUPT_BUFFER ) , GFP_KERNEL ) ; if ( ! dev -> read_queue ) { dev_err ( & interface -> dev , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>read_queue\\n" ) ; goto error ; } memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; usb_string ( udev , udev -> descriptor . iSerialNumber , dev -> chip_serial , sizeof ( dev -> chip_serial ) ) ; if ( strlen ( dev -> chip_serial ) != 8 ) memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; if ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) { usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0A , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; } dev -> present = 1 ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & iowarrior_class ) ; if ( retval ) { dev_err ( & interface -> dev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , "IOWarrior<S2SV_blank>product=0x%x,<S2SV_blank>serial=%s<S2SV_blank>interface=%d<S2SV_blank>" "now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>iowarrior%d\\n" , dev -> product_id , dev -> chip_serial , iface_desc -> desc . bInterfaceNumber , dev -> minor - IOWARRIOR_MINOR_BASE ) ; return retval ; error : iowarrior_delete ( dev ) ; return retval ; }
CWE-362 static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags , unsigned int allocated , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_inode_aio ( inode ) ; ext_debug ( "ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical<S2SV_blank>" "block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%x,<S2SV_blank>allocated<S2SV_blank>%u\\n" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; trace_ext4_ext_handle_uninitialized_extents ( inode , map , allocated , newblock ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ; if ( ret <= 0 ) goto out ; if ( io ) ext4_set_io_unwritten_flag ( inode , io ) ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) map -> m_flags |= EXT4_MAP_UNINIT ; goto out ; } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) { <S2SV_StartBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <S2SV_EndBug> path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; } else err = ret ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { map -> m_flags |= EXT4_MAP_UNWRITTEN ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , map , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; map -> m_flags |= EXT4_MAP_NEW ; if ( allocated > map -> m_len ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + map -> m_len , allocated - map -> m_len ) ; allocated = map -> m_len ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) { unsigned int reserved_clusters ; reserved_clusters = get_reserved_cluster_alloc ( inode , map -> m_lblk , map -> m_len ) ; if ( reserved_clusters ) ext4_da_update_reserve_space ( inode , reserved_clusters , 0 ) ; } map_out : map -> m_flags |= EXT4_MAP_MAPPED ; if ( ( flags & EXT4_GET_BLOCKS_KEEP_SIZE ) == 0 ) { err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; if ( err < 0 ) goto out2 ; } out1 : if ( allocated > map -> m_len ) allocated = map -> m_len ; ext4_ext_show_leaf ( inode , path ) ; map -> m_pblk = newblock ; map -> m_len = allocated ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }
CWE-119 static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct strbuf * base , const char * name , void * cb_data ) { struct object * obj = & tree -> object ; struct tree_desc desc ; struct name_entry entry ; enum interesting match = revs -> diffopt . pathspec . nr == 0 ? all_entries_interesting : entry_not_interesting ; int baselen = base -> len ; if ( ! revs -> tree_objects ) return ; if ( ! obj ) die ( "bad<S2SV_blank>tree<S2SV_blank>object" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) { if ( revs -> ignore_missing_links ) return ; die ( "bad<S2SV_blank>tree<S2SV_blank>object<S2SV_blank>%s" , oid_to_hex ( & obj -> oid ) ) ; } obj -> flags |= SEEN ; <S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> strbuf_addstr ( base , name ) ; if ( base -> len ) strbuf_addch ( base , '/' ) ; init_tree_desc ( & desc , tree -> buffer , tree -> size ) ; while ( tree_entry ( & desc , & entry ) ) { if ( match != all_entries_interesting ) { match = tree_entry_interesting ( & entry , base , 0 , & revs -> diffopt . pathspec ) ; if ( match == all_entries_not_interesting ) break ; if ( match == entry_not_interesting ) continue ; } if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , base , entry . path , cb_data ) ; else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , base , entry . path , cb_data ) ; else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , base , entry . path , cb_data ) ; } strbuf_setlen ( base , baselen ) ; free_tree_buffer ( tree ) ; }
CWE-119 <S2SV_StartBug> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }
CWE-20 int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr_storage * kern_address , int mode ) { int tot_len ; if ( kern_msg -> msg_namelen ) { if ( mode == VERIFY_READ ) { int err = move_addr_to_kernel ( kern_msg -> msg_name , kern_msg -> msg_namelen , kern_address ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> kern_msg -> msg_name = kern_address ; <S2SV_EndBug> } else kern_msg -> msg_name = NULL ; tot_len = iov_from_user_compat_to_kern ( kern_iov , ( struct compat_iovec __user * ) kern_msg -> msg_iov , kern_msg -> msg_iovlen ) ; if ( tot_len >= 0 ) kern_msg -> msg_iov = kern_iov ; return tot_len ; }
CWE-119 <S2SV_StartBug> void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) { <S2SV_EndBug> fprintf ( stderr , "%d<S2SV_blank>decoded<S2SV_blank>frames/%d<S2SV_blank>showed<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>%" PRId64 "<S2SV_blank>us<S2SV_blank>(%.2f<S2SV_blank>fps)\\r" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ; }
CWE-000 int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; <S2SV_StartBug> args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; <S2SV_EndBug> args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; if ( retval ) return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }
CWE-125 static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? "grounded," : "" , tok2str ( rpl_mop_values , "mop%u" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; }
CWE-000 int snd_usbmidi_create ( struct snd_card * card , struct usb_interface * iface , struct list_head * midi_list , const struct snd_usb_audio_quirk * quirk ) { struct snd_usb_midi * umidi ; struct snd_usb_midi_endpoint_info endpoints [ MIDI_MAX_ENDPOINTS ] ; int out_ports , in_ports ; int i , err ; umidi = kzalloc ( sizeof ( * umidi ) , GFP_KERNEL ) ; if ( ! umidi ) return - ENOMEM ; umidi -> dev = interface_to_usbdev ( iface ) ; umidi -> card = card ; umidi -> iface = iface ; umidi -> quirk = quirk ; umidi -> usb_protocol_ops = & snd_usbmidi_standard_ops ; spin_lock_init ( & umidi -> disc_lock ) ; init_rwsem ( & umidi -> disc_rwsem ) ; mutex_init ( & umidi -> mutex ) ; umidi -> usb_id = USB_ID ( le16_to_cpu ( umidi -> dev -> descriptor . idVendor ) , le16_to_cpu ( umidi -> dev -> descriptor . idProduct ) ) ; setup_timer ( & umidi -> error_timer , snd_usbmidi_error_timer , ( unsigned long ) umidi ) ; memset ( endpoints , 0 , sizeof ( endpoints ) ) ; switch ( quirk ? quirk -> type : QUIRK_MIDI_STANDARD_INTERFACE ) { case QUIRK_MIDI_STANDARD_INTERFACE : err = snd_usbmidi_get_ms_info ( umidi , endpoints ) ; if ( umidi -> usb_id == USB_ID ( 0x0763 , 0x0150 ) ) umidi -> usb_protocol_ops = & snd_usbmidi_maudio_broken_running_status_ops ; break ; case QUIRK_MIDI_US122L : umidi -> usb_protocol_ops = & snd_usbmidi_122l_ops ; case QUIRK_MIDI_FIXED_ENDPOINT : memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case QUIRK_MIDI_YAMAHA : err = snd_usbmidi_detect_yamaha ( umidi , & endpoints [ 0 ] ) ; break ; case QUIRK_MIDI_ROLAND : err = snd_usbmidi_detect_roland ( umidi , & endpoints [ 0 ] ) ; break ; case QUIRK_MIDI_MIDIMAN : umidi -> usb_protocol_ops = & snd_usbmidi_midiman_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = 0 ; break ; case QUIRK_MIDI_NOVATION : umidi -> usb_protocol_ops = & snd_usbmidi_novation_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_RAW_BYTES : umidi -> usb_protocol_ops = & snd_usbmidi_raw_ops ; if ( umidi -> usb_id == USB_ID ( 0x07fd , 0x0001 ) ) usb_set_interface ( umidi -> dev , 0 , 0 ) ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_EMAGIC : umidi -> usb_protocol_ops = & snd_usbmidi_emagic_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case QUIRK_MIDI_CME : umidi -> usb_protocol_ops = & snd_usbmidi_cme_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_AKAI : umidi -> usb_protocol_ops = & snd_usbmidi_akai_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; endpoints [ 1 ] . out_cables = 0 ; break ; case QUIRK_MIDI_FTDI : umidi -> usb_protocol_ops = & snd_usbmidi_ftdi_ops ; err = usb_control_msg ( umidi -> dev , usb_sndctrlpipe ( umidi -> dev , 0 ) , 3 , 0x40 , 0x60 , 0 , NULL , 0 , 1000 ) ; if ( err < 0 ) break ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_CH345 : umidi -> usb_protocol_ops = & snd_usbmidi_ch345_broken_sysex_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; default : dev_err ( & umidi -> dev -> dev , "invalid<S2SV_blank>quirk<S2SV_blank>type<S2SV_blank>%d\\n" , quirk -> type ) ; err = - ENXIO ; break ; } if ( err < 0 ) { kfree ( umidi ) ; return err ; } out_ports = 0 ; in_ports = 0 ; for ( i = 0 ; i < MIDI_MAX_ENDPOINTS ; ++ i ) { out_ports += hweight16 ( endpoints [ i ] . out_cables ) ; in_ports += hweight16 ( endpoints [ i ] . in_cables ) ; } err = snd_usbmidi_create_rawmidi ( umidi , out_ports , in_ports ) ; if ( err < 0 ) { kfree ( umidi ) ; return err ; } if ( quirk && quirk -> type == QUIRK_MIDI_MIDIMAN ) err = snd_usbmidi_create_endpoints_midiman ( umidi , & endpoints [ 0 ] ) ; else err = snd_usbmidi_create_endpoints ( umidi , endpoints ) ; if ( err < 0 ) { <S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug> return err ; } usb_autopm_get_interface_no_resume ( umidi -> iface ) ; list_add_tail ( & umidi -> list , midi_list ) ; return 0 ; }
CWE-416 void fe_netjoin_init ( void ) { settings_add_bool ( "misc" , "hide_netsplit_quits" , TRUE ) ; settings_add_int ( "misc" , "netjoin_max_nicks" , 10 ) ; join_tag = - 1 ; printing_joins = FALSE ; read_settings ( ) ; signal_add ( "setup<S2SV_blank>changed" , ( SIGNAL_FUNC ) read_settings ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 void vp9_rc_set_frame_target ( VP9_COMP * cpi , int target ) { const VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; rc -> this_frame_target = target ; <S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ( cm -> width * cm -> height ) ; }
CWE-000 static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( "" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ; <S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> if ( ! user ) <S2SV_StartBug> return ERR_PTR ( - ENOMEM ) ; <S2SV_EndBug> construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( "cons<S2SV_blank>failed" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else { <S2SV_StartBug> goto couldnt_alloc_key ; <S2SV_EndBug> } key_put ( dest_keyring ) ; kleave ( "<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ; <S2SV_StartBug> couldnt_alloc_key : <S2SV_EndBug> <S2SV_StartBug> key_put ( dest_keyring ) ; <S2SV_EndBug> kleave ( "<S2SV_blank>=<S2SV_blank>%d" , ret ) ; return ERR_PTR ( ret ) ; }
CWE-787 void avcodec_align_dimensions2 ( AVCodecContext * s , int * width , int * height , int linesize_align [ AV_NUM_DATA_POINTERS ] ) { int i ; int w_align = 1 ; int h_align = 1 ; AVPixFmtDescriptor const * desc = av_pix_fmt_desc_get ( s -> pix_fmt ) ; if ( desc ) { w_align = 1 << desc -> log2_chroma_w ; h_align = 1 << desc -> log2_chroma_h ; } switch ( s -> pix_fmt ) { case AV_PIX_FMT_YUV420P : case AV_PIX_FMT_YUYV422 : case AV_PIX_FMT_YVYU422 : case AV_PIX_FMT_UYVY422 : case AV_PIX_FMT_YUV422P : case AV_PIX_FMT_YUV440P : case AV_PIX_FMT_YUV444P : case AV_PIX_FMT_GBRP : case AV_PIX_FMT_GBRAP : case AV_PIX_FMT_GRAY8 : case AV_PIX_FMT_GRAY16BE : case AV_PIX_FMT_GRAY16LE : case AV_PIX_FMT_YUVJ420P : case AV_PIX_FMT_YUVJ422P : case AV_PIX_FMT_YUVJ440P : case AV_PIX_FMT_YUVJ444P : case AV_PIX_FMT_YUVA420P : case AV_PIX_FMT_YUVA422P : case AV_PIX_FMT_YUVA444P : case AV_PIX_FMT_YUV420P9LE : case AV_PIX_FMT_YUV420P9BE : case AV_PIX_FMT_YUV420P10LE : case AV_PIX_FMT_YUV420P10BE : case AV_PIX_FMT_YUV420P12LE : case AV_PIX_FMT_YUV420P12BE : case AV_PIX_FMT_YUV420P14LE : case AV_PIX_FMT_YUV420P14BE : case AV_PIX_FMT_YUV420P16LE : case AV_PIX_FMT_YUV420P16BE : case AV_PIX_FMT_YUVA420P9LE : case AV_PIX_FMT_YUVA420P9BE : case AV_PIX_FMT_YUVA420P10LE : case AV_PIX_FMT_YUVA420P10BE : case AV_PIX_FMT_YUVA420P16LE : case AV_PIX_FMT_YUVA420P16BE : case AV_PIX_FMT_YUV422P9LE : case AV_PIX_FMT_YUV422P9BE : case AV_PIX_FMT_YUV422P10LE : case AV_PIX_FMT_YUV422P10BE : case AV_PIX_FMT_YUV422P12LE : case AV_PIX_FMT_YUV422P12BE : case AV_PIX_FMT_YUV422P14LE : case AV_PIX_FMT_YUV422P14BE : case AV_PIX_FMT_YUV422P16LE : case AV_PIX_FMT_YUV422P16BE : case AV_PIX_FMT_YUVA422P9LE : case AV_PIX_FMT_YUVA422P9BE : case AV_PIX_FMT_YUVA422P10LE : case AV_PIX_FMT_YUVA422P10BE : case AV_PIX_FMT_YUVA422P16LE : case AV_PIX_FMT_YUVA422P16BE : case AV_PIX_FMT_YUV440P10LE : case AV_PIX_FMT_YUV440P10BE : case AV_PIX_FMT_YUV440P12LE : case AV_PIX_FMT_YUV440P12BE : case AV_PIX_FMT_YUV444P9LE : case AV_PIX_FMT_YUV444P9BE : case AV_PIX_FMT_YUV444P10LE : case AV_PIX_FMT_YUV444P10BE : case AV_PIX_FMT_YUV444P12LE : case AV_PIX_FMT_YUV444P12BE : case AV_PIX_FMT_YUV444P14LE : case AV_PIX_FMT_YUV444P14BE : case AV_PIX_FMT_YUV444P16LE : case AV_PIX_FMT_YUV444P16BE : case AV_PIX_FMT_YUVA444P9LE : case AV_PIX_FMT_YUVA444P9BE : case AV_PIX_FMT_YUVA444P10LE : case AV_PIX_FMT_YUVA444P10BE : case AV_PIX_FMT_YUVA444P16LE : case AV_PIX_FMT_YUVA444P16BE : case AV_PIX_FMT_GBRP9LE : case AV_PIX_FMT_GBRP9BE : case AV_PIX_FMT_GBRP10LE : case AV_PIX_FMT_GBRP10BE : case AV_PIX_FMT_GBRP12LE : case AV_PIX_FMT_GBRP12BE : case AV_PIX_FMT_GBRP14LE : case AV_PIX_FMT_GBRP14BE : case AV_PIX_FMT_GBRP16LE : case AV_PIX_FMT_GBRP16BE : case AV_PIX_FMT_GBRAP12LE : case AV_PIX_FMT_GBRAP12BE : case AV_PIX_FMT_GBRAP16LE : case AV_PIX_FMT_GBRAP16BE : w_align = 16 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV411P : case AV_PIX_FMT_YUVJ411P : case AV_PIX_FMT_UYYVYY411 : w_align = 32 ; h_align = 16 * 2 ; break ; case AV_PIX_FMT_YUV410P : if ( s -> codec_id == AV_CODEC_ID_SVQ1 ) { w_align = 64 ; h_align = 64 ; } break ; case AV_PIX_FMT_RGB555 : if ( s -> codec_id == AV_CODEC_ID_RPZA ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case AV_PIX_FMT_PAL8 : case AV_PIX_FMT_BGR8 : case AV_PIX_FMT_RGB8 : if ( s -> codec_id == AV_CODEC_ID_SMC || s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } <S2SV_StartBug> if ( s -> codec_id == AV_CODEC_ID_JV ) { <S2SV_EndBug> w_align = 8 ; h_align = 8 ; } break ; case AV_PIX_FMT_BGR24 : if ( ( s -> codec_id == AV_CODEC_ID_MSZH ) || ( s -> codec_id == AV_CODEC_ID_ZLIB ) ) { w_align = 4 ; h_align = 4 ; } break ; case AV_PIX_FMT_RGB24 : if ( s -> codec_id == AV_CODEC_ID_CINEPAK ) { w_align = 4 ; h_align = 4 ; } break ; default : break ; } if ( s -> codec_id == AV_CODEC_ID_IFF_ILBM ) { w_align = FFMAX ( w_align , 8 ) ; } * width = FFALIGN ( * width , w_align ) ; * height = FFALIGN ( * height , h_align ) ; if ( s -> codec_id == AV_CODEC_ID_H264 || s -> lowres ) { * height += 2 ; * width = FFMAX ( * width , 32 ) ; } for ( i = 0 ; i < 4 ; i ++ ) linesize_align [ i ] = STRIDE_ALIGN ; }
CWE-20 static int get_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; u32 off ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; <S2SV_StartBug> if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) <S2SV_EndBug> return - EFAULT ; return 0 ; }
CWE-119 void Huff_Compress ( msg_t * mbuf , int offset ) { int i , ch , size ; byte seq [ 65536 ] ; byte * buffer ; huff_t huff ; size = mbuf -> cursize - offset ; buffer = mbuf -> data + + offset ; if ( size <= 0 ) { return ; } Com_Memset ( & huff , 0 , sizeof ( huff_t ) ) ; huff . tree = huff . lhead = huff . loc [ NYT ] = & ( huff . nodeList [ huff . blocNode ++ ] ) ; huff . tree -> symbol = NYT ; huff . tree -> weight = 0 ; huff . lhead -> next = huff . lhead -> prev = NULL ; huff . tree -> parent = huff . tree -> left = huff . tree -> right = NULL ; seq [ 0 ] = ( size >> 8 ) ; seq [ 1 ] = size & 0xff ; bloc = 16 ; for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ; <S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> Huff_addRef ( & huff , ( byte ) ch ) ; } bloc += 8 ; mbuf -> cursize = ( bloc >> 3 ) + offset ; Com_Memcpy ( mbuf -> data + offset , seq , ( bloc >> 3 ) ) ; }
CWE-119 static vpx_codec_err_t ctrl_set_previewpp ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> # if CONFIG_VP9_POSTPROC <S2SV_StartBug> vp8_postproc_cfg_t * config = va_arg ( args , vp8_postproc_cfg_t * ) ; <S2SV_EndBug> ( void ) ctr_id ; if ( config != NULL ) { ctx -> preview_ppcfg = * config ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } # else ( void ) ctx ; <S2SV_StartBug> ( void ) ctr_id ; <S2SV_EndBug> ( void ) args ; return VPX_CODEC_INCAPABLE ; # endif }
CWE-119 int usbip_recv_xbuff ( struct usbip_device * ud , struct urb * urb ) { int ret ; int size ; if ( ud -> side == USBIP_STUB ) { if ( usb_pipein ( urb -> pipe ) ) return 0 ; size = urb -> transfer_buffer_length ; } else { if ( usb_pipeout ( urb -> pipe ) ) return 0 ; size = urb -> actual_length ; } if ( ! ( size > 0 ) ) return 0 ; <S2SV_StartBug> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <S2SV_EndBug> if ( ret != size ) { dev_err ( & urb -> dev -> dev , "recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; <S2SV_StartBug> } else { <S2SV_EndBug> usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-119 static int fx_command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { struct effect_s * effect = ( struct effect_s * ) self ; if ( effect == NULL ) return - EINVAL ; switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) return - EINVAL ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_CONFIG : { if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( "fx_command()<S2SV_blank>EFFECT_CMD_SET_CONFIG<S2SV_blank>invalid<S2SV_blank>args" ) ; return - EINVAL ; } * ( int * ) pReplyData = session_set_config ( effect -> session , ( effect_config_t * ) pCmdData ) ; if ( * ( int * ) pReplyData != 0 ) break ; if ( effect -> state != EFFECT_STATE_ACTIVE ) * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_CONFIG ) ; } break ; case EFFECT_CMD_GET_CONFIG : if ( pReplyData == NULL || * replySize != sizeof ( effect_config_t ) ) { ALOGV ( "fx_command()<S2SV_blank>EFFECT_CMD_GET_CONFIG<S2SV_blank>invalid<S2SV_blank>args" ) ; return - EINVAL ; } session_get_config ( effect -> session , ( effect_config_t * ) pReplyData ) ; break ; case EFFECT_CMD_RESET : break ; case EFFECT_CMD_GET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL || <S2SV_StartBug> * replySize < ( int ) sizeof ( effect_param_t ) ) { <S2SV_EndBug> ALOGV ( "fx_command()<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>args" ) ; return - EINVAL ; } effect_param_t * p = ( effect_param_t * ) pCmdData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + p -> psize ) ; p = ( effect_param_t * ) pReplyData ; p -> status = - ENOSYS ; } break ; case EFFECT_CMD_SET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { ALOGV ( "fx_command()<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>args" ) ; return - EINVAL ; } effect_param_t * p = ( effect_param_t * ) pCmdData ; if ( p -> psize != sizeof ( int32_t ) ) { ALOGV ( "fx_command()<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>param<S2SV_blank>format" ) ; return - EINVAL ; } * ( int * ) pReplyData = - ENOSYS ; } break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( "fx_command()<S2SV_blank>EFFECT_CMD_ENABLE<S2SV_blank>invalid<S2SV_blank>args" ) ; return - EINVAL ; } * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_ACTIVE ) ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( "fx_command()<S2SV_blank>EFFECT_CMD_DISABLE<S2SV_blank>invalid<S2SV_blank>args" ) ; return - EINVAL ; } * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_CONFIG ) ; break ; case EFFECT_CMD_SET_DEVICE : case EFFECT_CMD_SET_INPUT_DEVICE : case EFFECT_CMD_SET_VOLUME : case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != sizeof ( uint32_t ) ) { ALOGV ( "fx_command()<S2SV_blank>%s<S2SV_blank>invalid<S2SV_blank>args" , cmdCode == EFFECT_CMD_SET_DEVICE ? "EFFECT_CMD_SET_DEVICE" : cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? "EFFECT_CMD_SET_INPUT_DEVICE" : cmdCode == EFFECT_CMD_SET_VOLUME ? "EFFECT_CMD_SET_VOLUME" : cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? "EFFECT_CMD_SET_AUDIO_MODE" : "" ) ; return - EINVAL ; } ALOGV ( "fx_command()<S2SV_blank>%s<S2SV_blank>value<S2SV_blank>%08x" , cmdCode == EFFECT_CMD_SET_DEVICE ? "EFFECT_CMD_SET_DEVICE" : cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? "EFFECT_CMD_SET_INPUT_DEVICE" : cmdCode == EFFECT_CMD_SET_VOLUME ? "EFFECT_CMD_SET_VOLUME" : cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? "EFFECT_CMD_SET_AUDIO_MODE" : "" , * ( int * ) pCmdData ) ; break ; default : return - EINVAL ; } return 0 ; }
CWE-000 static VALUE ossl_cipher_initialize ( VALUE self , VALUE str ) { EVP_CIPHER_CTX * ctx ; const EVP_CIPHER * cipher ; <S2SV_StartBug> char * name ; <S2SV_EndBug> unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = { 0 } ; name = StringValueCStr ( str ) ; GetCipherInit ( self , ctx ) ; if ( ctx ) { ossl_raise ( rb_eRuntimeError , "Cipher<S2SV_blank>already<S2SV_blank>inititalized!" ) ; } AllocCipher ( self , ctx ) ; if ( ! ( cipher = EVP_get_cipherbyname ( name ) ) ) { ossl_raise ( rb_eRuntimeError , "unsupported<S2SV_blank>cipher<S2SV_blank>algorithm<S2SV_blank>(%" PRIsVALUE ")" , str ) ; } <S2SV_StartBug> if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) <S2SV_EndBug> ossl_raise ( eCipherError , NULL ) ; return self ; }
CWE-119 static void initialize_encoder ( struct stream_state * stream , struct VpxEncoderConfig * global ) { int i ; int flags = 0 ; flags |= global -> show_psnr ? VPX_CODEC_USE_PSNR : 0 ; flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ; <S2SV_StartBug> vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , flags ) ; ctx_exit_on_error ( & stream -> encoder , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder" ) ; for ( i = 0 ; i < stream -> config . arg_ctrl_cnt ; i ++ ) { int ctrl = stream -> config . arg_ctrls [ i ] [ 0 ] ; int value = stream -> config . arg_ctrls [ i ] [ 1 ] ; if ( vpx_codec_control_ ( & stream -> encoder , ctrl , value ) ) fprintf ( stderr , "Error:<S2SV_blank>Tried<S2SV_blank>to<S2SV_blank>set<S2SV_blank>control<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>%d\\n" , ctrl , value ) ; ctx_exit_on_error ( & stream -> encoder , "Failed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>codec" ) ; } # if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF ) { const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ; <S2SV_StartBug> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <S2SV_EndBug> } # endif }
CWE-119 static int cdrom_ioctl_media_changed ( struct cdrom_device_info * cdi , unsigned long arg ) { struct cdrom_changer_info * info ; int ret ; cd_dbg ( CD_DO_IOCTL , "entering<S2SV_blank>CDROM_MEDIA_CHANGED\\n" ) ; if ( ! CDROM_CAN ( CDC_MEDIA_CHANGED ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ; <S2SV_StartBug> if ( ( unsigned int ) arg >= cdi -> capacity ) <S2SV_EndBug> return - EINVAL ; info = kmalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( ! info ) return - ENOMEM ; ret = cdrom_read_mech_status ( cdi , info ) ; if ( ! ret ) ret = info -> slots [ arg ] . change ; kfree ( info ) ; return ret ; }
CWE-119 void vp9_pack_bitstream ( VP9_COMP * cpi , uint8_t * dest , size_t * size ) { uint8_t * data = dest ; size_t first_part_size , uncompressed_hdr_size ; <S2SV_StartBug> struct vp9_write_bit_buffer wb = { data , 0 } ; <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer saved_wb ; <S2SV_EndBug> write_uncompressed_header ( cpi , & wb ) ; saved_wb = wb ; <S2SV_StartBug> vp9_wb_write_literal ( & wb , 0 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> uncompressed_hdr_size = vp9_rb_bytes_written ( & wb ) ; <S2SV_EndBug> data += uncompressed_hdr_size ; <S2SV_StartBug> vp9_compute_update_table ( ) ; <S2SV_EndBug> vp9_clear_system_state ( ) ; first_part_size = write_compressed_header ( cpi , data ) ; data += first_part_size ; <S2SV_StartBug> vp9_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ; <S2SV_EndBug> data += encode_tiles ( cpi , data ) ; * size = data - dest ; }
CWE-399 static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; vcpu = kvm_arch_vcpu_create ( kvm , id ) ; if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ; <S2SV_StartBug> if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { <S2SV_EndBug> r = - EINVAL ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - EEXIST ; goto unlock_vcpu_destroy ; } BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }
CWE-119 void WT_Interpolate ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; const EAS_SAMPLE * loopEnd ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pOutputBuffer = pWTIntFrame -> pAudioBuffer ; loopEnd = ( const EAS_SAMPLE * ) pWTVoice -> loopEnd + 1 ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = pWTVoice -> phaseFrac ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; acc0 = ( EAS_I32 ) ( pSamples - loopEnd ) ; if ( acc0 >= 0 ) pSamples = ( const EAS_SAMPLE * ) pWTVoice -> loopStart + acc0 ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
CWE-119 static vpx_codec_err_t vp8e_set_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ; <S2SV_StartBug> if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) ) <S2SV_EndBug> <S2SV_StartBug> && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ) <S2SV_EndBug> <S2SV_StartBug> ERROR ( "Cannot<S2SV_blank>change<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>after<S2SV_blank>initialization" ) ; <S2SV_EndBug> if ( ( cfg -> g_lag_in_frames > ctx -> cfg . g_lag_in_frames ) ) ERROR ( "Cannot<S2SV_blank>increase<S2SV_blank>lag_in_frames" ) ; res = validate_config ( ctx , cfg , & ctx -> vp8_cfg , 0 ) ; if ( ! res ) { ctx -> cfg = * cfg ; set_vp8e_config ( & ctx -> oxcf , ctx -> cfg , ctx -> vp8_cfg , NULL ) ; vp8_change_config ( ctx -> cpi , & ctx -> oxcf ) ; } return res ; }
CWE-119 static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; int retsize ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( "Downmix_Command<S2SV_blank>command<S2SV_blank>%" PRIu32 "<S2SV_blank>cmdSize<S2SV_blank>%" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT : <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) <S2SV_StartBug> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%" PRIu32 ",<S2SV_blank>pReplyData:<S2SV_blank>%p" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || <S2SV_StartBug> pReplyData == NULL || <S2SV_EndBug> * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * rep = ( effect_param_t * ) pReplyData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ; ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>param<S2SV_blank>%" PRId32 ",<S2SV_blank>replySize<S2SV_blank>%" PRIu32 , * ( int32_t * ) rep -> data , rep -> vsize ) ; rep -> status = Downmix_getParameter ( pDownmixer , * ( int32_t * ) rep -> data , & rep -> vsize , rep -> data + sizeof ( int32_t ) ) ; * replySize = sizeof ( effect_param_t ) + sizeof ( int32_t ) + rep -> vsize ; break ; case EFFECT_CMD_SET_PARAM : ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%" PRIu32 ",<S2SV_blank>pReplyData<S2SV_blank>%p" , cmdSize , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) <S2SV_StartBug> || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { <S2SV_EndBug> return - EINVAL ; } effect_param_t * cmd = ( effect_param_t * ) pCmdData ; * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ; break ; case EFFECT_CMD_SET_PARAM_DEFERRED : ALOGW ( "Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_DEFERRED<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME" ) ; break ; case EFFECT_CMD_SET_PARAM_COMMIT : ALOGW ( "Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_COMMIT<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME" ) ; break ; case EFFECT_CMD_ENABLE : <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_ACTIVE ; ALOGV ( "EFFECT_CMD_ENABLE()<S2SV_blank>OK" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_INITIALIZED ; ALOGV ( "EFFECT_CMD_DISABLE()<S2SV_blank>OK" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_DEVICE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_SET_DEVICE:<S2SV_blank>0x%08" PRIx32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_VOLUME : { if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) * 2 ) { return - EINVAL ; } ALOGW ( "Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_VOLUME<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME" ) ; float left = ( float ) ( * ( uint32_t * ) pCmdData ) / ( 1 << 24 ) ; float right = ( float ) ( * ( ( uint32_t * ) pCmdData + 1 ) ) / ( 1 << 24 ) ; ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_SET_VOLUME:<S2SV_blank>left<S2SV_blank>%f,<S2SV_blank>right<S2SV_blank>%f<S2SV_blank>" , left , right ) ; break ; } case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( "Downmix_Command<S2SV_blank>EFFECT_CMD_SET_AUDIO_MODE:<S2SV_blank>%" PRIu32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_CONFIG_REVERSE : case EFFECT_CMD_SET_INPUT_DEVICE : break ; default : ALOGW ( "Downmix_Command<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%" PRIu32 , cmdCode ) ; return - EINVAL ; } return 0 ; }
CWE-264 const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ; <S2SV_StartBug> # undef _ <S2SV_EndBug> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ; # undef _ default : str = "<unknown<S2SV_blank>variable>" ; break ; } break ; } return str ; }
CWE-20 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
CWE-000 static int verify_source_vc ( char * * ret_path , const char * src_vc ) { _cleanup_close_ int fd = - 1 ; char * path ; int r ; fd = open_terminal ( src_vc , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) return log_error_errno ( fd , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%m" , src_vc ) ; r = verify_vc_device ( fd ) ; if ( r < 0 ) return log_error_errno ( r , "Device<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>virtual<S2SV_blank>console:<S2SV_blank>%m" , src_vc ) ; r = verify_vc_allocation_byfd ( fd ) ; if ( r < 0 ) return log_error_errno ( r , "Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allocated:<S2SV_blank>%m" , src_vc ) ; <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) return log_error_errno ( r , "Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m" , src_vc ) ; path = strdup ( src_vc ) ; if ( ! path ) return log_oom ( ) ; * ret_path = path ; return TAKE_FD ( fd ) ; }
CWE-119 static void unset_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { <S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = NULL ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map" ) ; }
CWE-119 <S2SV_StartBug> int check_fragments_for_errors ( VP8D_COMP * pbi ) <S2SV_EndBug> { if ( ! pbi -> ec_active && pbi -> fragments . count <= 1 && pbi -> fragments . sizes [ 0 ] == 0 ) { VP8_COMMON * cm = & pbi -> common ; if ( cm -> fb_idx_ref_cnt [ cm -> lst_fb_idx ] > 1 ) { const int prev_idx = cm -> lst_fb_idx ; cm -> fb_idx_ref_cnt [ prev_idx ] -- ; cm -> lst_fb_idx = get_free_fb ( cm ) ; vp8_yv12_copy_frame ( & cm -> yv12_fb [ prev_idx ] , & cm -> yv12_fb [ cm -> lst_fb_idx ] ) ; } cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; cm -> show_frame = 0 ; return 0 ; } return 1 ; }
CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; <S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; unsigned int table_len ; int ret = 0 ; bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; lvd = ( struct logicalVolDesc * ) bh -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , "error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>" "Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; i < sbi -> s_partitions && offset < table_len ; i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> struct sparingTable * st ; <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( "Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( "Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( "Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( "Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( "Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( "Flags:<S2SV_blank>%d<S2SV_blank>%d\\n" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( "Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( "Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( "FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
CWE-362 static int sctp_init_sock ( struct sock * sk ) { struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; pr_debug ( "%s:<S2SV_blank>sk:%p\\n" , __func__ , sk ) ; sp = sctp_sk ( sk ) ; switch ( sk -> sk_type ) { case SOCK_SEQPACKET : sp -> type = SCTP_SOCKET_UDP ; break ; case SOCK_STREAM : sp -> type = SCTP_SOCKET_TCP ; break ; default : return - ESOCKTNOSUPPORT ; } sp -> default_stream = 0 ; sp -> default_ppid = 0 ; sp -> default_flags = 0 ; sp -> default_context = 0 ; sp -> default_timetolive = 0 ; sp -> default_rcv_context = 0 ; sp -> max_burst = net -> sctp . max_burst ; sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; sp -> rtoinfo . srto_max = net -> sctp . rto_max ; sp -> rtoinfo . srto_min = net -> sctp . rto_min ; sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; sp -> assocparams . sasoc_number_peer_destinations = 0 ; sp -> assocparams . sasoc_peer_rwnd = 0 ; sp -> assocparams . sasoc_local_rwnd = 0 ; sp -> assocparams . sasoc_cookie_life = net -> sctp . valid_cookie_life ; memset ( & sp -> subscribe , 0 , sizeof ( struct sctp_event_subscribe ) ) ; sp -> hbinterval = net -> sctp . hb_interval ; sp -> pathmaxrxt = net -> sctp . max_retrans_path ; sp -> pathmtu = 0 ; sp -> sackdelay = net -> sctp . sack_timeout ; sp -> sackfreq = 2 ; sp -> param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE ; sp -> disable_fragments = 0 ; sp -> nodelay = 0 ; sp -> recvrcvinfo = 0 ; sp -> recvnxtinfo = 0 ; sp -> v4mapped = 1 ; sp -> autoclose = 0 ; sp -> user_frag = 0 ; sp -> adaptation_ind = 0 ; sp -> pf = sctp_get_pf_specific ( sk -> sk_family ) ; atomic_set ( & sp -> pd_mode , 0 ) ; skb_queue_head_init ( & sp -> pd_lobby ) ; sp -> frag_interleave = 0 ; sp -> ep = sctp_endpoint_new ( sk , GFP_KERNEL ) ; if ( ! sp -> ep ) return - ENOMEM ; sp -> hmac = NULL ; sk -> sk_destruct = sctp_destruct_sock ; SCTP_DBG_OBJCNT_INC ( sock ) ; local_bh_disable ( ) ; percpu_counter_inc ( & sctp_sockets_allocated ) ; sock_prot_inuse_add ( net , sk -> sk_prot , 1 ) ; if ( net -> sctp . default_auto_asconf ) { <S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> & net -> sctp . auto_asconf_splist ) ; <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> local_bh_enable ( ) ; return 0 ; }
CWE-476 unsigned int arpt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = NF_DROP ; const struct arphdr * arp ; struct arpt_entry * e , * * jumpstack ; const char * indev , * outdev ; const void * table_base ; unsigned int cpu , stackidx = 0 ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; if ( ! pskb_may_pull ( skb , arp_hdr_len ( skb -> dev ) ) ) return NF_DROP ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct arpt_entry * * ) private -> jumpstack [ cpu ] ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; acpar . state = state ; acpar . hotdrop = false ; arp = arp_hdr ( skb ) ; do { const struct xt_entry_target * t ; struct xt_counters * counter ; if ( ! arp_packet_match ( arp , skb -> dev , indev , outdev , & e -> arp ) ) { e = arpt_next_entry ( e ) ; continue ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , arp_hdr_len ( skb -> dev ) , 1 ) ; t = arpt_get_target_c ( e ) ; if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = arpt_next_entry ( e ) ; } continue ; } if ( table_base + v != arpt_next_entry ( e ) ) { <S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { arp = arp_hdr ( skb ) ; e = arpt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }
CWE-000 EAPI_MAIN int elm_main ( int argc , char * argv [ ] ) { int args = 1 ; unsigned char quitOption = 0 ; <S2SV_StartBug> Browser_Window * window ; <S2SV_EndBug> Ecore_Getopt_Value values [ ] = { ECORE_GETOPT_VALUE_STR ( evas_engine_name ) , <S2SV_StartBug> ECORE_GETOPT_VALUE_BOOL ( quitOption ) , <S2SV_EndBug> ECORE_GETOPT_VALUE_BOOL ( frame_flattening_enabled ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_NONE } ; if ( ! ewk_init ( ) ) return EXIT_FAILURE ; ewk_view_smart_class_set ( miniBrowserViewSmartClass ( ) ) ; ecore_app_args_set ( argc , ( const char * * ) argv ) ; args = ecore_getopt_parse ( & options , values , argc , argv ) ; if ( args < 0 ) return quit ( EINA_FALSE , "ERROR:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>options.\\n" ) ; if ( quitOption ) return quit ( EINA_TRUE , NULL ) ; if ( evas_engine_name ) elm_config_preferred_engine_set ( evas_engine_name ) ; # if defined ( WTF_USE_ACCELERATED_COMPOSITING ) && defined ( HAVE_ECORE_X ) else { evas_engine_name = "opengl_x11" ; elm_config_preferred_engine_set ( evas_engine_name ) ; } # endif Ewk_Context * context = ewk_context_default_get ( ) ; ewk_context_favicon_database_directory_set ( context , NULL ) ; <S2SV_StartBug> if ( args < argc ) { <S2SV_EndBug> char * url = url_from_user_input ( argv [ args ] ) ; window = window_create ( url ) ; free ( url ) ; } else window = window_create ( DEFAULT_URL ) ; if ( ! window ) return quit ( EINA_FALSE , "ERROR:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>browser<S2SV_blank>window.\\n" ) ; windows = eina_list_append ( windows , window ) ; elm_run ( ) ; return quit ( EINA_TRUE , NULL ) ; }
CWE-362 fm_mgr_config_errno_t fm_mgr_config_mgr_connect ( fm_config_conx_hdl * hdl , fm_mgr_type_t mgr ) { char s_path [ 256 ] ; char c_path [ 256 ] ; char * mgr_prefix ; p_hsm_com_client_hdl_t * mgr_hdl ; <S2SV_StartBug> pid_t pid ; <S2SV_EndBug> memset ( s_path , 0 , sizeof ( s_path ) ) ; <S2SV_StartBug> memset ( c_path , 0 , sizeof ( c_path ) ) ; <S2SV_EndBug> pid = getpid ( ) ; switch ( mgr ) { case FM_MGR_SM : mgr_prefix = HSM_FM_SCK_SM ; mgr_hdl = & hdl -> sm_hdl ; break ; case FM_MGR_PM : mgr_prefix = HSM_FM_SCK_PM ; mgr_hdl = & hdl -> pm_hdl ; break ; case FM_MGR_FE : mgr_prefix = HSM_FM_SCK_FE ; mgr_hdl = & hdl -> fe_hdl ; break ; default : return FM_CONF_INIT_ERR ; } sprintf ( s_path , "%s%s%d" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ; <S2SV_StartBug> sprintf ( c_path , "%s%s%d_C_%lu" , HSM_FM_SCK_PREFIX , mgr_prefix , <S2SV_EndBug> <S2SV_StartBug> hdl -> instance , ( long unsigned ) pid ) ; <S2SV_EndBug> if ( * mgr_hdl == NULL ) { if ( hcom_client_init ( mgr_hdl , s_path , c_path , 32768 ) != HSM_COM_OK ) { return FM_CONF_INIT_ERR ; } } if ( hcom_client_connect ( * mgr_hdl ) == HSM_COM_OK ) { hdl -> conx_mask |= mgr ; return FM_CONF_OK ; } return FM_CONF_CONX_ERR ; }
CWE-119 int tcp_read_sock ( struct sock * sk , read_descriptor_t * desc , sk_read_actor_t recv_actor ) { struct sk_buff * skb ; struct tcp_sock * tp = tcp_sk ( sk ) ; u32 seq = tp -> copied_seq ; u32 offset ; int copied = 0 ; if ( sk -> sk_state == TCP_LISTEN ) return - ENOTCONN ; while ( ( skb = tcp_recv_skb ( sk , seq , & offset ) ) != NULL ) { if ( offset < skb -> len ) { int used ; size_t len ; len = skb -> len - offset ; if ( tp -> urg_data ) { u32 urg_offset = tp -> urg_seq - seq ; if ( urg_offset < len ) len = urg_offset ; if ( ! len ) break ; } used = recv_actor ( desc , skb , offset , len ) ; if ( used < 0 ) { if ( ! copied ) copied = used ; break ; } else if ( used <= len ) { seq += used ; copied += used ; offset += used ; } skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ; if ( ! skb || ( offset + 1 != skb -> len ) ) break ; } if ( tcp_hdr ( skb ) -> fin ) { sk_eat_skb ( sk , skb , 0 ) ; ++ seq ; break ; } sk_eat_skb ( sk , skb , 0 ) ; if ( ! desc -> count ) break ; <S2SV_StartBug> } <S2SV_EndBug> tp -> copied_seq = seq ; <S2SV_StartBug> tcp_rcv_space_adjust ( sk ) ; <S2SV_EndBug> if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ; return copied ; }
CWE-20 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , "submodule" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , "disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s" , name ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
CWE-125 static void handle_mlppp ( netdissect_options * ndo , const u_char * p , int length ) { if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "MLPPP,<S2SV_blank>" ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "seq<S2SV_blank>0x%03x,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u" , <S2SV_EndBug> ( EXTRACT_16BITS ( p ) ) & 0x0fff , bittok2str ( ppp_ml_flag_values , "none" , * p & 0xc0 ) , length ) ) ; }
CWE-000 static int sctp_v6_xmit ( struct sk_buff * skb , struct sctp_transport * transport ) { struct sock * sk = skb -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_StartBug> struct flowi6 fl6 ; <S2SV_EndBug> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ; fl6 . saddr = transport -> saddr . v6 . sin6_addr ; fl6 . flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ; if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ; else fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( np -> opt && np -> opt -> srcrt ) { struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ; fl6 . daddr = * rt0 -> addr ; } pr_debug ( "%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n" , __func__ , skb , <S2SV_StartBug> skb -> len , & fl6 . saddr , & fl6 . daddr ) ; <S2SV_EndBug> <S2SV_StartBug> SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_EndBug> if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ; <S2SV_StartBug> return ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct4x4_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <S2SV_EndBug> const transform_2d ht = FHT_4 [ tx_type ] ; for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ; if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) <S2SV_StartBug> outptr [ j * 4 + i ] = temp_out [ j ] ; <S2SV_EndBug> } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j + i * 4 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ; } } }
CWE-476 static int daemon_AuthUserPwd ( char * username , char * password , char * errbuf ) { # ifdef _WIN32 HANDLE Token ; if ( LogonUser ( username , "." , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "LogonUser()<S2SV_blank>failed" ) ; return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_fmt_errmsg_for_win32_err ( errbuf , PCAP_ERRBUF_SIZE , GetLastError ( ) , "ImpersonateLoggedOnUser()<S2SV_blank>failed" ) ; CloseHandle ( Token ) ; return - 1 ; } CloseHandle ( Token ) ; return 0 ; # else struct passwd * user ; char * user_password ; # ifdef HAVE_GETSPNAM struct spwd * usersp ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( ( user = getpwnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } # ifdef HAVE_GETSPNAM if ( ( usersp = getspnam ( username ) ) == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } user_password = usersp -> sp_pwdp ; # else user_password = user -> pw_passwd ; # endif <S2SV_StartBug> if ( strcmp ( user_password , ( char * ) crypt ( password , user_password ) ) != 0 ) <S2SV_EndBug> { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed:<S2SV_blank>user<S2SV_blank>name<S2SV_blank>or<S2SV_blank>password<S2SV_blank>incorrect" ) ; return - 1 ; } if ( setuid ( user -> pw_uid ) ) { pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , errno , "setuid" ) ; return - 1 ; } return 0 ; # endif }
CWE-119 static int dtls1_process_buffered_records ( SSL * s ) { pitem * item ; item = pqueue_peek ( s -> d1 -> unprocessed_rcds . q ) ; if ( item ) { if ( s -> d1 -> unprocessed_rcds . epoch != s -> d1 -> r_epoch ) return ( 1 ) ; while ( pqueue_peek ( s -> d1 -> unprocessed_rcds . q ) ) { dtls1_get_unprocessed_record ( s ) ; if ( ! dtls1_process_record ( s ) ) return ( 0 ) ; <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> processed_rcds ) , <S2SV_EndBug> <S2SV_StartBug> s -> s3 -> rrec . seq_num ) ; <S2SV_EndBug> } } s -> d1 -> processed_rcds . epoch = s -> d1 -> r_epoch ; s -> d1 -> unprocessed_rcds . epoch = s -> d1 -> r_epoch + 1 ; return ( 1 ) ; }
CWE-119 static char * rfc2047_decode_word ( const char * s , size_t len , enum ContentEncoding enc ) { const char * it = s ; const char * end = s + len ; if ( enc == ENCQUOTEDPRINTABLE ) { struct Buffer buf = { 0 } ; for ( ; it < end ; ++ it ) { if ( * it == '_' ) { mutt_buffer_addch ( & buf , '<S2SV_blank>' ) ; } else if ( ( * it == '=' ) && ( ! ( it [ 1 ] & ~ 127 ) && hexval ( it [ 1 ] ) != - 1 ) && ( ! ( it [ 2 ] & ~ 127 ) && hexval ( it [ 2 ] ) != - 1 ) ) { mutt_buffer_addch ( & buf , ( hexval ( it [ 1 ] ) << 4 ) | hexval ( it [ 2 ] ) ) ; it += 2 ; } else { mutt_buffer_addch ( & buf , * it ) ; } } mutt_buffer_addch ( & buf , '\\0' ) ; return buf . data ; } else if ( enc == ENCBASE64 ) { <S2SV_StartBug> char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> int dlen = mutt_b64_decode ( out , it ) ; <S2SV_EndBug> if ( dlen == - 1 ) { FREE ( & out ) ; return NULL ; } out [ dlen ] = '\\0' ; return out ; } assert ( 0 ) ; return NULL ; }
CWE-476 void pdo_stmt_init ( TSRMLS_D ) { zend_class_entry ce ; INIT_CLASS_ENTRY ( ce , "PDOStatement" , pdo_dbstmt_functions ) ; pdo_dbstmt_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_dbstmt_ce -> get_iterator = pdo_stmt_iter_get ; pdo_dbstmt_ce -> create_object = pdo_dbstmt_new ; zend_class_implements ( pdo_dbstmt_ce TSRMLS_CC , 1 , zend_ce_traversable ) ; zend_declare_property_null ( pdo_dbstmt_ce , "queryString" , sizeof ( "queryString" ) - 1 , ZEND_ACC_PUBLIC TSRMLS_CC ) ; memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ; pdo_dbstmt_object_handlers . write_property = dbstmt_prop_write ; pdo_dbstmt_object_handlers . unset_property = dbstmt_prop_delete ; pdo_dbstmt_object_handlers . get_method = dbstmt_method_get ; pdo_dbstmt_object_handlers . compare_objects = dbstmt_compare ; pdo_dbstmt_object_handlers . clone_obj = dbstmt_clone_obj ; INIT_CLASS_ENTRY ( ce , "PDORow" , pdo_row_functions ) ; pdo_row_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_row_ce -> ce_flags |= ZEND_ACC_FINAL_CLASS ; pdo_row_ce -> create_object = pdo_row_new ; pdo_row_ce -> serialize = pdo_row_serialize ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-20 static int security_context_to_sid_core ( const char * scontext , u32 scontext_len , u32 * sid , u32 def_sid , gfp_t gfp_flags , int force ) { char * scontext2 , * str = NULL ; struct context context ; <S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> if ( ! ss_initialized ) { int i ; for ( i = 1 ; i < SECINITSID_NUM ; i ++ ) { if ( ! strcmp ( initial_sid_to_string [ i ] , scontext ) ) { * sid = i ; return 0 ; } } * sid = SECINITSID_KERNEL ; return 0 ; } * sid = SECSID_NULL ; scontext2 = kmalloc ( scontext_len + 1 , gfp_flags ) ; if ( ! scontext2 ) return - ENOMEM ; memcpy ( scontext2 , scontext , scontext_len ) ; scontext2 [ scontext_len ] = 0 ; if ( force ) { rc = - ENOMEM ; str = kstrdup ( scontext2 , gfp_flags ) ; if ( ! str ) goto out ; } read_lock ( & policy_rwlock ) ; rc = string_to_context_struct ( & policydb , & sidtab , scontext2 , scontext_len , & context , def_sid ) ; if ( rc == - EINVAL && force ) { context . str = str ; context . len = scontext_len ; str = NULL ; } else if ( rc ) goto out_unlock ; rc = sidtab_context_to_sid ( & sidtab , & context , sid ) ; context_destroy ( & context ) ; out_unlock : read_unlock ( & policy_rwlock ) ; out : kfree ( scontext2 ) ; kfree ( str ) ; return rc ; }
CWE-476 static bool LookupModMask ( struct xkb_context * ctx , const void * priv , xkb_atom_t field , enum expr_value_type type , xkb_mod_mask_t * val_rtrn ) { const char * str ; xkb_mod_index_t ndx ; const LookupModMaskPriv * arg = priv ; const struct xkb_mod_set * mods = arg -> mods ; enum mod_type mod_type = arg -> mod_type ; if ( type != EXPR_TYPE_INT ) return false ; str = xkb_atom_text ( ctx , field ) ; <S2SV_StartBug> if ( istreq ( str , "all" ) ) { <S2SV_EndBug> * val_rtrn = MOD_REAL_MASK_ALL ; return true ; } if ( istreq ( str , "none" ) ) { * val_rtrn = 0 ; return true ; } ndx = XkbModNameToIndex ( mods , field , mod_type ) ; if ( ndx == XKB_MOD_INVALID ) return false ; * val_rtrn = ( 1u << ndx ) ; return true ; }
CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <S2SV_StartBug> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <S2SV_EndBug> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
CWE-200 static void set_orig_addr ( struct msghdr * m , struct tipc_msg * msg ) { struct sockaddr_tipc * addr = ( struct sockaddr_tipc * ) m -> msg_name ; if ( addr ) { addr -> family = AF_TIPC ; <S2SV_StartBug> addr -> addrtype = TIPC_ADDR_ID ; <S2SV_EndBug> addr -> addr . id . ref = msg_origport ( msg ) ; addr -> addr . id . node = msg_orignode ( msg ) ; addr -> addr . name . domain = 0 ; addr -> scope = 0 ; m -> msg_namelen = sizeof ( struct sockaddr_tipc ) ; } }
CWE-200 static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct sk_buff * skb = NULL ; struct sockaddr_pn sa ; int rval = - EOPNOTSUPP ; int copylen ; if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) <S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( sa ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; if ( skb == NULL ) goto out_nofree ; pn_skb_get_src_sockaddr ( skb , & sa ) ; copylen = skb -> len ; if ( len < copylen ) { msg -> msg_flags |= MSG_TRUNC ; copylen = len ; } rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; if ( rval ) { rval = - EFAULT ; goto out ; } rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> out : skb_free_datagram ( sk , skb ) ; out_nofree : return rval ; }
CWE-000 static int fetch_uidl ( char * line , void * data ) { int i , index ; struct Context * ctx = ( struct Context * ) data ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; char * endp = NULL ; errno = 0 ; index = strtol ( line , & endp , 10 ) ; if ( errno ) return - 1 ; while ( * endp == '<S2SV_blank>' ) endp ++ ; memmove ( line , endp , strlen ( endp ) + 1 ) ; <S2SV_StartBug> for ( i = 0 ; i < ctx -> msgcount ; i ++ ) <S2SV_EndBug> if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ; if ( i == ctx -> msgcount ) { mutt_debug ( 1 , "new<S2SV_blank>header<S2SV_blank>%d<S2SV_blank>%s\\n" , index , line ) ; if ( i >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; ctx -> msgcount ++ ; ctx -> hdrs [ i ] = mutt_header_new ( ) ; ctx -> hdrs [ i ] -> data = mutt_str_strdup ( line ) ; } else if ( ctx -> hdrs [ i ] -> index != index - 1 ) pop_data -> clear_cache = true ; ctx -> hdrs [ i ] -> refno = index ; ctx -> hdrs [ i ] -> index = index - 1 ; return 0 ; }
CWE-399 struct scm_fp_list * scm_fp_dup ( struct scm_fp_list * fpl ) { struct scm_fp_list * new_fpl ; int i ; if ( ! fpl ) return NULL ; new_fpl = kmemdup ( fpl , offsetof ( struct scm_fp_list , fp [ fpl -> count ] ) , GFP_KERNEL ) ; if ( new_fpl ) { for ( i = 0 ; i < fpl -> count ; i ++ ) get_file ( fpl -> fp [ i ] ) ; new_fpl -> max = new_fpl -> count ; <S2SV_StartBug> } <S2SV_EndBug> return new_fpl ; }
CWE-20 static void ikev2_parent_inI1outR1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( "ikev2<S2SV_blank>parent<S2SV_blank>inI1outR1:<S2SV_blank>calculated<S2SV_blank>ke+nonce,<S2SV_blank>sending<S2SV_blank>R1" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , "%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI1outR1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
CWE-000 void xmlParseElement ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; const xmlChar * prefix = NULL ; const xmlChar * URI = NULL ; xmlParserNodeInfo node_info ; int line , tlen ; xmlNodePtr ret ; int nsNr = ctxt -> nsNr ; if ( ( ( unsigned int ) ctxt -> nameNr > xmlParserMaxDepth ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { xmlFatalErrMsgInt ( ctxt , XML_ERR_INTERNAL_ERROR , "Excessive<S2SV_blank>depth<S2SV_blank>in<S2SV_blank>document:<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>XML_PARSE_HUGE<S2SV_blank>option\\n" , xmlParserMaxDepth ) ; ctxt -> instate = XML_PARSER_EOF ; return ; } if ( ctxt -> record_info ) { node_info . begin_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . begin_line = ctxt -> input -> line ; } if ( ctxt -> spaceNr == 0 ) spacePush ( ctxt , - 1 ) ; else if ( * ctxt -> space == - 2 ) spacePush ( ctxt , - 1 ) ; else spacePush ( ctxt , * ctxt -> space ) ; line = ctxt -> input -> line ; # ifdef LIBXML_SAX1_ENABLED if ( ctxt -> sax2 ) # endif name = xmlParseStartTag2 ( ctxt , & prefix , & URI , & tlen ) ; # ifdef LIBXML_SAX1_ENABLED else name = xmlParseStartTag ( ctxt ) ; # endif <S2SV_StartBug> if ( name == NULL ) { <S2SV_EndBug> spacePop ( ctxt ) ; return ; } namePush ( ctxt , name ) ; ret = ctxt -> node ; # ifdef LIBXML_VALID_ENABLED if ( ctxt -> validate && ctxt -> wellFormed && ctxt -> myDoc && ctxt -> node && ( ctxt -> node == ctxt -> myDoc -> children ) ) ctxt -> valid &= xmlValidateRoot ( & ctxt -> vctxt , ctxt -> myDoc ) ; # endif if ( ( RAW == '/' ) && ( NXT ( 1 ) == '>' ) ) { SKIP ( 2 ) ; if ( ctxt -> sax2 ) { if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> endElementNs != NULL ) && ( ! ctxt -> disableSAX ) ) ctxt -> sax -> endElementNs ( ctxt -> userData , name , prefix , URI ) ; # ifdef LIBXML_SAX1_ENABLED } else { if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> endElement != NULL ) && ( ! ctxt -> disableSAX ) ) ctxt -> sax -> endElement ( ctxt -> userData , name ) ; # endif } namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } return ; } if ( RAW == '>' ) { NEXT1 ; } else { xmlFatalErrMsgStrIntStr ( ctxt , XML_ERR_GT_REQUIRED , "Couldn\'t<S2SV_blank>find<S2SV_blank>end<S2SV_blank>of<S2SV_blank>Start<S2SV_blank>Tag<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d\\n" , name , line , NULL ) ; nodePop ( ctxt ) ; namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } return ; } xmlParseContent ( ctxt ) ; if ( ! IS_BYTE_CHAR ( RAW ) ) { xmlFatalErrMsgStrIntStr ( ctxt , XML_ERR_TAG_NOT_FINISHED , "Premature<S2SV_blank>end<S2SV_blank>of<S2SV_blank>data<S2SV_blank>in<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d\\n" , name , line , NULL ) ; nodePop ( ctxt ) ; namePop ( ctxt ) ; spacePop ( ctxt ) ; if ( nsNr != ctxt -> nsNr ) nsPop ( ctxt , ctxt -> nsNr - nsNr ) ; return ; } if ( ctxt -> sax2 ) { xmlParseEndTag2 ( ctxt , prefix , URI , line , ctxt -> nsNr - nsNr , tlen ) ; namePop ( ctxt ) ; } # ifdef LIBXML_SAX1_ENABLED else xmlParseEndTag1 ( ctxt , line ) ; # endif if ( ret != NULL && ctxt -> record_info ) { node_info . end_pos = ctxt -> input -> consumed + ( CUR_PTR - ctxt -> input -> base ) ; node_info . end_line = ctxt -> input -> line ; node_info . node = ret ; xmlParserAddNodeInfo ( ctxt , & node_info ) ; } }
CWE-000 static int crypto_report_acomp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_acomp racomp ; <S2SV_StartBug> strlcpy ( racomp . type , "acomp" , sizeof ( racomp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-189 static u64 __skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb_is_nonlinear ( skb ) ) return 0 ; <S2SV_StartBug> if ( A > skb -> len - sizeof ( struct nlattr ) ) <S2SV_EndBug> return 0 ; nla = ( struct nlattr * ) & skb -> data [ A ] ; <S2SV_StartBug> if ( nla -> nla_len > A - skb -> len ) <S2SV_EndBug> return 0 ; nla = nla_find_nested ( nla , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
CWE-000 static const u_char * ikev2_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { const struct ikev2_n * p ; struct ikev2_n n ; const u_char * cp ; <S2SV_StartBug> u_char showspi , showdata , showsomedata ; <S2SV_EndBug> const char * notify_name ; uint32_t type ; p = ( const struct ikev2_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_N ) , n . h . critical ) ; showspi = 1 ; <S2SV_StartBug> showdata = 0 ; <S2SV_EndBug> showsomedata = 0 ; notify_name = NULL ; ND_PRINT ( ( ndo , "<S2SV_blank>prot_id=%s" , PROTOIDSTR ( n . prot_id ) ) ) ; type = ntohs ( n . type ) ; switch ( type ) { case IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD : notify_name = "unsupported_critical_payload" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_IKE_SPI : notify_name = "invalid_ike_spi" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_MAJOR_VERSION : notify_name = "invalid_major_version" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_SYNTAX : notify_name = "invalid_syntax" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_MESSAGE_ID : notify_name = "invalid_message_id" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_SPI : notify_name = "invalid_spi" ; showspi = 1 ; break ; case IV2_NOTIFY_NO_PROPOSAL_CHOSEN : notify_name = "no_protocol_chosen" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_KE_PAYLOAD : notify_name = "invalid_ke_payload" ; showspi = 1 ; break ; case IV2_NOTIFY_AUTHENTICATION_FAILED : notify_name = "authentication_failed" ; showspi = 1 ; break ; case IV2_NOTIFY_SINGLE_PAIR_REQUIRED : notify_name = "single_pair_required" ; showspi = 1 ; break ; case IV2_NOTIFY_NO_ADDITIONAL_SAS : notify_name = "no_additional_sas" ; showspi = 0 ; break ; case IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE : notify_name = "internal_address_failure" ; showspi = 0 ; break ; case IV2_NOTIFY_FAILED_CP_REQUIRED : notify_name = "failed:cp_required" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_SELECTORS : notify_name = "invalid_selectors" ; showspi = 0 ; break ; case IV2_NOTIFY_INITIAL_CONTACT : notify_name = "initial_contact" ; showspi = 0 ; break ; case IV2_NOTIFY_SET_WINDOW_SIZE : notify_name = "set_window_size" ; showspi = 0 ; break ; case IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE : notify_name = "additional_ts_possible" ; showspi = 0 ; break ; case IV2_NOTIFY_IPCOMP_SUPPORTED : notify_name = "ipcomp_supported" ; showspi = 0 ; break ; case IV2_NOTIFY_NAT_DETECTION_SOURCE_IP : notify_name = "nat_detection_source_ip" ; showspi = 1 ; break ; case IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP : notify_name = "nat_detection_destination_ip" ; showspi = 1 ; break ; case IV2_NOTIFY_COOKIE : notify_name = "cookie" ; showspi = 1 ; <S2SV_StartBug> showsomedata = 1 ; <S2SV_EndBug> showdata = 0 ; break ; case IV2_NOTIFY_USE_TRANSPORT_MODE : notify_name = "use_transport_mode" ; showspi = 0 ; break ; case IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED : notify_name = "http_cert_lookup_supported" ; showspi = 0 ; break ; case IV2_NOTIFY_REKEY_SA : notify_name = "rekey_sa" ; showspi = 1 ; break ; case IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED : notify_name = "tfc_padding_not_supported" ; showspi = 0 ; break ; case IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO : notify_name = "non_first_fragment_also" ; showspi = 0 ; break ; default : if ( type < 8192 ) { notify_name = "error" ; } else if ( type < 16384 ) { notify_name = "private-error" ; } else if ( type < 40960 ) { notify_name = "status" ; } else { notify_name = "private-status" ; } } if ( notify_name ) { ND_PRINT ( ( ndo , "<S2SV_blank>type=%u(%s)" , type , notify_name ) ) ; } if ( showspi && n . spi_size ) { ND_PRINT ( ( ndo , "<S2SV_blank>spi=" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; <S2SV_StartBug> if ( 3 < ndo -> ndo_vflag ) { <S2SV_EndBug> showdata = 1 ; } <S2SV_StartBug> if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>data=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_StartBug> } else if ( showsomedata && cp < ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; <S2SV_EndBug> } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }
CWE-119 static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> int mi_row , int mi_col ) { <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> MODE_INFO * m ; xd -> mi = cm -> mi_grid_visible + ( mi_row * cm -> mi_stride + mi_col ) ; m = xd -> mi [ 0 ] ; <S2SV_StartBug> set_mi_row_col ( xd , tile , <S2SV_EndBug> mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ; if ( frame_is_intra_only ( cm ) ) { <S2SV_StartBug> write_mb_modes_kf ( cpi , xd -> mi , w ) ; <S2SV_EndBug> } else { pack_inter_mode_mvs ( cpi , m , w ) ; } assert ( * tok < tok_end ) ; <S2SV_StartBug> pack_mb_tokens ( w , tok , tok_end ) ; <S2SV_EndBug> }
CWE-119 static int kill_something_info ( int sig , struct siginfo * info , pid_t pid ) { int ret ; if ( pid > 0 ) { rcu_read_lock ( ) ; ret = kill_pid_info ( sig , info , find_vpid ( pid ) ) ; rcu_read_unlock ( ) ; return ret ; <S2SV_StartBug> } <S2SV_EndBug> read_lock ( & tasklist_lock ) ; if ( pid != - 1 ) { ret = __kill_pgrp_info ( sig , info , pid ? find_vpid ( - pid ) : task_pgrp ( current ) ) ; } else { int retval = 0 , count = 0 ; struct task_struct * p ; for_each_process ( p ) { if ( task_pid_vnr ( p ) > 1 && ! same_thread_group ( p , current ) ) { int err = group_send_sig_info ( sig , info , p ) ; ++ count ; if ( err != - EPERM ) retval = err ; } } ret = count ? retval : - ESRCH ; } read_unlock ( & tasklist_lock ) ; return ret ; }
CWE-189 int i915_gem_execbuffer2 ( struct drm_device * dev , void * data , struct drm_file * file ) { struct drm_i915_gem_execbuffer2 * args = data ; struct drm_i915_gem_exec_object2 * exec2_list = NULL ; int ret ; <S2SV_StartBug> if ( args -> buffer_count < 1 ) { <S2SV_EndBug> DRM_DEBUG ( "execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\n" , args -> buffer_count ) ; return - EINVAL ; } exec2_list = kmalloc ( sizeof ( * exec2_list ) * args -> buffer_count , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( exec2_list == NULL ) exec2_list = drm_malloc_ab ( sizeof ( * exec2_list ) , args -> buffer_count ) ; if ( exec2_list == NULL ) { DRM_DEBUG ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>exec<S2SV_blank>list<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>buffers\\n" , args -> buffer_count ) ; return - ENOMEM ; } ret = copy_from_user ( exec2_list , ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret != 0 ) { DRM_DEBUG ( "copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>failed<S2SV_blank>%d\\n" , args -> buffer_count , ret ) ; drm_free_large ( exec2_list ) ; return - EFAULT ; } ret = i915_gem_do_execbuffer ( dev , data , file , args , exec2_list ) ; if ( ! ret ) { ret = copy_to_user ( ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , exec2_list , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret ) { ret = - EFAULT ; DRM_DEBUG ( "failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>" "back<S2SV_blank>to<S2SV_blank>user<S2SV_blank>(%d)\\n" , args -> buffer_count , ret ) ; } } drm_free_large ( exec2_list ) ; return ret ; }
CWE-000 static void gsm_xsmp_client_disconnect ( GsmXSMPClient * client ) { if ( client -> priv -> watch_id > 0 ) { g_source_remove ( client -> priv -> watch_id ) ; } if ( client -> priv -> conn != NULL ) { SmsCleanUp ( client -> priv -> conn ) ; } if ( client -> priv -> ice_connection != NULL ) { IceSetShutdownNegotiation ( client -> priv -> ice_connection , FALSE ) ; IceCloseConnection ( client -> priv -> ice_connection ) ; } <S2SV_StartBug> if ( client -> priv -> protocol_timeout > 0 ) { <S2SV_EndBug> g_source_remove ( client -> priv -> protocol_timeout ) ; } }
CWE-264 int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; <S2SV_StartBug> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <S2SV_EndBug> if ( fd < 0 ) return - errno ; if ( mode != MODE_INVALID ) { r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }
CWE-200 static int sco_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) { struct sockaddr_sco * sa = ( struct sockaddr_sco * ) addr ; struct sock * sk = sock -> sk ; int err = 0 ; BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>%pMR" , sk , & sa -> sco_bdaddr ) ; <S2SV_StartBug> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) <S2SV_EndBug> return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_state != BT_OPEN ) { err = - EBADFD ; goto done ; } if ( sk -> sk_type != SOCK_SEQPACKET ) { err = - EINVAL ; goto done ; } bacpy ( & sco_pi ( sk ) -> src , & sa -> sco_bdaddr ) ; sk -> sk_state = BT_BOUND ; done : release_sock ( sk ) ; return err ; }
CWE-476 struct key * request_key_and_link ( struct key_type * type , const char * description , const void * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct keyring_search_context ctx = { . index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , <S2SV_StartBug> . match_data . cmp = type -> match , <S2SV_EndBug> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * key ; key_ref_t key_ref ; int ret ; kenter ( "%s,%s,%p,%zu,%p,%p,%lx" , ctx . index_key . type -> name , ctx . index_key . description , callout_info , callout_len , aux , dest_keyring , flags ) ; if ( type -> match_preparse ) { ret = type -> match_preparse ( & ctx . match_data ) ; if ( ret < 0 ) { key = ERR_PTR ( ret ) ; goto error ; } } key_ref = search_process_keyrings ( & ctx ) ; if ( ! IS_ERR ( key_ref ) ) { key = key_ref_to_ptr ( key_ref ) ; if ( dest_keyring ) { construct_get_dest_keyring ( & dest_keyring ) ; ret = key_link ( dest_keyring , key ) ; key_put ( dest_keyring ) ; if ( ret < 0 ) { key_put ( key ) ; key = ERR_PTR ( ret ) ; goto error_free ; } } } else if ( PTR_ERR ( key_ref ) != - EAGAIN ) { key = ERR_CAST ( key_ref ) ; } else { key = ERR_PTR ( - ENOKEY ) ; if ( ! callout_info ) goto error_free ; key = construct_key_and_link ( & ctx , callout_info , callout_len , aux , dest_keyring , flags ) ; } error_free : if ( type -> match_free ) type -> match_free ( & ctx . match_data ) ; error : kleave ( "<S2SV_blank>=<S2SV_blank>%p" , key ) ; return key ; }
CWE-190 static int jas_iccgetsint32 ( jas_stream_t * in , jas_iccsint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; <S2SV_StartBug> * val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) & <S2SV_EndBug> <S2SV_StartBug> 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ; <S2SV_EndBug> return 0 ; }
CWE-000 int oidc_oauth_check_userid ( request_rec * r , oidc_cfg * c ) { if ( ! ap_is_initial_req ( r ) ) { if ( r -> main != NULL ) r -> user = r -> main -> user ; else if ( r -> prev != NULL ) r -> user = r -> prev -> user ; if ( r -> user != NULL ) { oidc_debug ( r , "recycling<S2SV_blank>user<S2SV_blank>\'%s\'<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>request<S2SV_blank>for<S2SV_blank>sub-request" , r -> user ) ; return OK ; } } else if ( ( c -> redirect_uri != NULL ) && ( oidc_util_request_matches_url ( r , c -> redirect_uri ) ) ) { if ( oidc_util_request_has_parameter ( r , "jwks" ) ) { return oidc_handle_jwks ( r , c ) ; } } const char * access_token = NULL ; if ( oidc_oauth_get_bearer_token ( r , & access_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , "invalid_request" , "No<S2SV_blank>bearer<S2SV_blank>token<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>request" ) ; json_t * token = NULL ; char * s_token = NULL ; if ( c -> oauth . introspection_endpoint_url != NULL ) { if ( oidc_oauth_resolve_access_token ( r , c , access_token , & token , & s_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , "invalid_token" , "Reference<S2SV_blank>token<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>introspected" ) ; } else { if ( oidc_oauth_validate_jwt_access_token ( r , c , access_token , & token , & s_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , "invalid_token" , "JWT<S2SV_blank>token<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>validated" ) ; } if ( token == NULL ) { oidc_error ( r , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>claims<S2SV_blank>(token<S2SV_blank>==<S2SV_blank>NULL)" ) ; return oidc_oauth_return_www_authenticate ( r , "invalid_token" , "No<S2SV_blank>claims<S2SV_blank>could<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>from<S2SV_blank>the<S2SV_blank>token" ) ; } oidc_request_state_set ( r , OIDC_CLAIMS_SESSION_KEY , ( const char * ) s_token ) ; if ( oidc_oauth_set_remote_user ( r , c , token ) == FALSE ) { oidc_error ( r , "remote<S2SV_blank>user<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set,<S2SV_blank>aborting<S2SV_blank>with<S2SV_blank>HTTP_UNAUTHORIZED" ) ; return oidc_oauth_return_www_authenticate ( r , "invalid_token" , "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>remote<S2SV_blank>user" ) ; } <S2SV_StartBug> char * authn_header = oidc_cfg_dir_authn_header ( r ) ; <S2SV_EndBug> int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ; int pass_envvars = oidc_cfg_dir_pass_info_in_envvars ( r ) ; if ( ( r -> user != NULL ) && ( authn_header != NULL ) ) { oidc_debug ( r , "setting<S2SV_blank>authn<S2SV_blank>header<S2SV_blank>(%s)<S2SV_blank>to:<S2SV_blank>%s" , authn_header , r -> user ) ; apr_table_set ( r -> headers_in , authn_header , r -> user ) ; } oidc_util_set_app_infos ( r , token , c -> claim_prefix , c -> claim_delimiter , pass_headers , pass_envvars ) ; if ( access_token != NULL ) { oidc_util_set_app_info ( r , "access_token" , access_token , OIDC_DEFAULT_HEADER_PREFIX , pass_headers , pass_envvars ) ; } json_decref ( token ) ; return OK ; }
CWE-190 static int __get_data_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh , int create , int flag , pgoff_t * next_pgofs ) { struct f2fs_map_blocks map ; int err ; map . m_lblk = iblock ; map . m_len = bh -> b_size >> inode -> i_blkbits ; map . m_next_pgofs = next_pgofs ; err = f2fs_map_blocks ( inode , & map , create , flag ) ; if ( ! err ) { map_bh ( bh , inode -> i_sb , map . m_pblk ) ; bh -> b_state = ( bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <S2SV_StartBug> bh -> b_size = map . m_len << inode -> i_blkbits ; <S2SV_EndBug> } return err ; }
CWE-264 static int save_new_data ( struct chfn_control * ctl ) { char * gecos ; int len ; len = xasprintf ( & gecos , "%s,%s,%s,%s,%s" , ctl -> newf . full_name , ctl -> newf . office , ctl -> newf . office_phone , ctl -> newf . home_phone , ctl -> newf . other ) ; if ( ! ctl -> newf . other ) { while ( len > 0 && gecos [ len - 1 ] == ',' ) len -- ; gecos [ len ] = 0 ; } # ifdef HAVE_LIBUSER if ( set_value_libuser ( "chfn" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) { # else ctl -> pw -> pw_gecos = gecos ; <S2SV_StartBug> if ( setpwnam ( ctl -> pw ) < 0 ) { <S2SV_EndBug> warn ( "setpwnam<S2SV_blank>failed" ) ; # endif printf ( _ ( "Finger<S2SV_blank>information<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later.\\n" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( "Finger<S2SV_blank>information<S2SV_blank>changed.\\n" ) ) ; return 0 ; }
CWE-000 static int ghash_final ( struct shash_desc * desc , u8 * dst ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * buf = dctx -> buffer ; <S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug> memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ; return 0 ; }
CWE-119 long fuse_do_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , unsigned int flags ) { struct fuse_file * ff = file -> private_data ; struct fuse_conn * fc = ff -> fc ; struct fuse_ioctl_in inarg = { . fh = ff -> fh , . cmd = cmd , . arg = arg , . flags = flags } ; struct fuse_ioctl_out outarg ; struct fuse_req * req = NULL ; struct page * * pages = NULL ; struct page * iov_page = NULL ; struct iovec * in_iov = NULL , * out_iov = NULL ; unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ; size_t in_size , out_size , transferred ; int err ; BUILD_BUG_ON ( sizeof ( struct iovec ) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE ) ; err = - ENOMEM ; pages = kzalloc ( sizeof ( pages [ 0 ] ) * FUSE_MAX_PAGES_PER_REQ , GFP_KERNEL ) ; iov_page = alloc_page ( GFP_KERNEL ) ; if ( ! pages || ! iov_page ) goto out ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) { struct iovec * iov = page_address ( iov_page ) ; iov -> iov_base = ( void __user * ) arg ; iov -> iov_len = _IOC_SIZE ( cmd ) ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { in_iov = iov ; in_iovs = 1 ; } if ( _IOC_DIR ( cmd ) & _IOC_READ ) { out_iov = iov ; out_iovs = 1 ; } } retry : inarg . in_size = in_size = iov_length ( in_iov , in_iovs ) ; inarg . out_size = out_size = iov_length ( out_iov , out_iovs ) ; out_size = max_t ( size_t , out_size , PAGE_SIZE ) ; max_pages = DIV_ROUND_UP ( max ( in_size , out_size ) , PAGE_SIZE ) ; err = - ENOMEM ; if ( max_pages > FUSE_MAX_PAGES_PER_REQ ) goto out ; while ( num_pages < max_pages ) { pages [ num_pages ] = alloc_page ( GFP_KERNEL | __GFP_HIGHMEM ) ; if ( ! pages [ num_pages ] ) goto out ; num_pages ++ ; } req = fuse_get_req ( fc ) ; if ( IS_ERR ( req ) ) { err = PTR_ERR ( req ) ; req = NULL ; goto out ; } memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages ) ; req -> num_pages = num_pages ; req -> in . h . opcode = FUSE_IOCTL ; req -> in . h . nodeid = ff -> nodeid ; req -> in . numargs = 1 ; req -> in . args [ 0 ] . size = sizeof ( inarg ) ; req -> in . args [ 0 ] . value = & inarg ; if ( in_size ) { req -> in . numargs ++ ; req -> in . args [ 1 ] . size = in_size ; req -> in . argpages = 1 ; err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , false ) ; if ( err ) goto out ; } req -> out . numargs = 2 ; req -> out . args [ 0 ] . size = sizeof ( outarg ) ; req -> out . args [ 0 ] . value = & outarg ; req -> out . args [ 1 ] . size = out_size ; req -> out . argpages = 1 ; req -> out . argvar = 1 ; fuse_request_send ( fc , req ) ; err = req -> out . h . error ; transferred = req -> out . args [ 1 ] . size ; fuse_put_request ( fc , req ) ; req = NULL ; if ( err ) goto out ; if ( outarg . flags & FUSE_IOCTL_RETRY ) { char * vaddr ; err = - EIO ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) goto out ; in_iovs = outarg . in_iovs ; out_iovs = outarg . out_iovs ; err = - ENOMEM ; if ( in_iovs > FUSE_IOCTL_MAX_IOV || out_iovs > FUSE_IOCTL_MAX_IOV || in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV ) goto out ; vaddr = kmap_atomic ( pages [ 0 ] , KM_USER0 ) ; err = fuse_copy_ioctl_iovec ( page_address ( iov_page ) , vaddr , transferred , in_iovs + out_iovs , ( flags & FUSE_IOCTL_COMPAT ) != 0 ) ; kunmap_atomic ( vaddr , KM_USER0 ) ; if ( err ) goto out ; in_iov = page_address ( iov_page ) ; out_iov = in_iov + in_iovs ; <S2SV_StartBug> goto retry ; <S2SV_EndBug> } err = - EIO ; if ( transferred > inarg . out_size ) goto out ; err = fuse_ioctl_copy_user ( pages , out_iov , out_iovs , transferred , true ) ; out : if ( req ) fuse_put_request ( fc , req ) ; if ( iov_page ) __free_page ( iov_page ) ; while ( num_pages ) __free_page ( pages [ -- num_pages ] ) ; kfree ( pages ) ; return err ? err : outarg . result ; }
CWE-125 JsVar * jswrap_graphics_createArrayBuffer ( int width , int height , int bpp , JsVar * options ) { if ( width <= 0 || height <= 0 || width > 32767 || height > 32767 ) { jsExceptionHere ( JSET_ERROR , "Invalid<S2SV_blank>Size" ) ; return 0 ; } if ( ! isValidBPP ( bpp ) ) { jsExceptionHere ( JSET_ERROR , "Invalid<S2SV_blank>BPP" ) ; return 0 ; } JsVar * parent = jspNewObject ( 0 , "Graphics" ) ; if ( ! parent ) return 0 ; JsGraphics gfx ; graphicsStructInit ( & gfx ) ; gfx . data . type = JSGRAPHICSTYPE_ARRAYBUFFER ; gfx . data . flags = JSGRAPHICSFLAGS_NONE ; gfx . graphicsVar = parent ; gfx . data . width = ( unsigned short ) width ; gfx . data . height = ( unsigned short ) height ; gfx . data . bpp = ( unsigned char ) bpp ; if ( jsvIsObject ( options ) ) { if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "zigzag" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_ZIGZAG ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "msb" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "vertical_byte" , 0 ) ) ) { if ( gfx . data . bpp == 1 ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ; else <S2SV_StartBug> jsWarn ( "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; <S2SV_EndBug> } JsVar * colorv = jsvObjectGetChild ( options , "color_order" , 0 ) ; if ( colorv ) { if ( jsvIsStringEqual ( colorv , "rgb" ) ) ; else if ( ! jsvIsStringEqual ( colorv , "brg" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BRG ) ; else if ( ! jsvIsStringEqual ( colorv , "bgr" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BGR ) ; else if ( ! jsvIsStringEqual ( colorv , "gbr" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GBR ) ; else if ( ! jsvIsStringEqual ( colorv , "grb" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GRB ) ; else if ( ! jsvIsStringEqual ( colorv , "rbg" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_RBG ) ; else jsWarn ( "color_order<S2SV_blank>must<S2SV_blank>be<S2SV_blank>3<S2SV_blank>characters" ) ; jsvUnLock ( colorv ) ; } } lcdInit_ArrayBuffer ( & gfx ) ; graphicsSetVar ( & gfx ) ; return parent ; }
CWE-000 static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) { EVP_CIPHER_CTX * ctx ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , * p_key = NULL ; unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ; VALUE pass , init_v ; if ( rb_scan_args ( argc , argv , "02" , & pass , & init_v ) > 0 ) { VALUE cname = rb_class_path ( rb_obj_class ( self ) ) ; rb_warn ( "arguments<S2SV_blank>for<S2SV_blank>%" PRIsVALUE "#encrypt<S2SV_blank>and<S2SV_blank>%" PRIsVALUE "#decrypt<S2SV_blank>were<S2SV_blank>deprecated;<S2SV_blank>" "use<S2SV_blank>%" PRIsVALUE "#pkcs5_keyivgen<S2SV_blank>to<S2SV_blank>derive<S2SV_blank>key<S2SV_blank>and<S2SV_blank>IV" , cname , cname , cname ) ; StringValue ( pass ) ; GetCipher ( self , ctx ) ; if ( NIL_P ( init_v ) ) memcpy ( iv , "OpenSSL<S2SV_blank>for<S2SV_blank>Ruby<S2SV_blank>rulez!" , sizeof ( iv ) ) ; else { StringValue ( init_v ) ; if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) { memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ; memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ; } else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ; } EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ; p_key = key ; p_iv = iv ; } else { GetCipher ( self , ctx ) ; } if ( EVP_CipherInit_ex ( ctx , NULL , NULL , p_key , p_iv , mode ) != 1 ) { ossl_raise ( eCipherError , NULL ) ; } <S2SV_StartBug> return self ; <S2SV_EndBug> }
CWE-415 static int sg_common_write ( Sg_fd * sfp , Sg_request * srp , unsigned char * cmnd , int timeout , int blocking ) { int k , at_head ; Sg_device * sdp = sfp -> parentdp ; sg_io_hdr_t * hp = & srp -> header ; srp -> data . cmd_opcode = cmnd [ 0 ] ; hp -> status = 0 ; hp -> masked_status = 0 ; hp -> msg_status = 0 ; hp -> info = 0 ; hp -> host_status = 0 ; hp -> driver_status = 0 ; hp -> resid = 0 ; SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sfp -> parentdp , "sg_common_write:<S2SV_blank><S2SV_blank>scsi<S2SV_blank>opcode=0x%02x,<S2SV_blank>cmd_size=%d\\n" , ( int ) cmnd [ 0 ] , ( int ) hp -> cmd_len ) ) ; k = sg_start_req ( srp , cmnd ) ; if ( k ) { SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sfp -> parentdp , "sg_common_write:<S2SV_blank>start_req<S2SV_blank>err=%d\\n" , k ) ) ; sg_finish_rem_req ( srp ) ; return k ; } if ( atomic_read ( & sdp -> detaching ) ) { <S2SV_StartBug> if ( srp -> bio ) <S2SV_EndBug> <S2SV_StartBug> blk_end_request_all ( srp -> rq , - EIO ) ; <S2SV_EndBug> sg_finish_rem_req ( srp ) ; return - ENODEV ; } hp -> duration = jiffies_to_msecs ( jiffies ) ; if ( hp -> interface_id != '\\0' && ( SG_FLAG_Q_AT_TAIL & hp -> flags ) ) at_head = 0 ; else at_head = 1 ; srp -> rq -> timeout = timeout ; kref_get ( & sfp -> f_ref ) ; blk_execute_rq_nowait ( sdp -> device -> request_queue , sdp -> disk , srp -> rq , at_head , sg_rq_end_io ) ; return 0 ; }
CWE-000 static OPJ_BOOL bmp_read_rle8_data ( FILE * IN , OPJ_UINT8 * pData , OPJ_UINT32 stride , OPJ_UINT32 width , OPJ_UINT32 height ) { <S2SV_StartBug> OPJ_UINT32 x , y ; <S2SV_EndBug> OPJ_UINT8 * pix ; const OPJ_UINT8 * beyond ; beyond = pData + stride * height ; pix = pData ; <S2SV_StartBug> x = y = 0U ; <S2SV_EndBug> while ( y < height ) { int c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } if ( c ) { int j , c1_int ; OPJ_UINT8 c1 ; c1_int = getc ( IN ) ; if ( c1_int == EOF ) { return OPJ_FALSE ; } c1 = ( OPJ_UINT8 ) c1_int ; for ( j = 0 ; ( j < c ) && ( x < width ) && ( ( OPJ_SIZE_T ) pix < ( OPJ_SIZE_T ) beyond ) ; j ++ , x ++ , pix ++ ) { <S2SV_StartBug> * pix = c1 ; <S2SV_EndBug> } } else { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } if ( c == 0x00 ) { x = 0 ; ++ y ; pix = pData + y * stride + x ; } else if ( c == 0x01 ) { break ; } else if ( c == 0x02 ) { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } x += ( OPJ_UINT32 ) c ; c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } y += ( OPJ_UINT32 ) c ; pix = pData + y * stride + x ; } else { int j ; for ( j = 0 ; ( j < c ) && ( x < width ) && ( ( OPJ_SIZE_T ) pix < ( OPJ_SIZE_T ) beyond ) ; j ++ , x ++ , pix ++ ) { int c1_int ; OPJ_UINT8 c1 ; c1_int = getc ( IN ) ; if ( c1_int == EOF ) { return OPJ_FALSE ; } c1 = ( OPJ_UINT8 ) c1_int ; * pix = c1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ( OPJ_UINT32 ) c & 1U ) { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } } } } } <S2SV_StartBug> return OPJ_TRUE ; <S2SV_EndBug> }
CWE-119 char * uwsgi_expand_path ( char * dir , int dir_len , char * ptr ) { <S2SV_StartBug> char src [ PATH_MAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( src , dir , dir_len ) ; <S2SV_EndBug> src [ dir_len ] = 0 ; char * dst = ptr ; if ( ! dst ) dst = uwsgi_malloc ( PATH_MAX + 1 ) ; if ( ! realpath ( src , dst ) ) { uwsgi_error_realpath ( src ) ; if ( ! ptr ) free ( dst ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return dst ; }
CWE-399 static void handle_associated_event ( struct cpu_hw_events * cpuc , int idx , struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc = & event -> hw ; mipspmu_event_update ( event , hwc , idx ) ; data -> period = event -> hw . last_period ; if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ; <S2SV_StartBug> if ( perf_event_overflow ( event , 0 , data , regs ) ) <S2SV_EndBug> mipspmu -> disable_event ( idx ) ; }
CWE-119 static int logi_dj_ll_raw_request ( struct hid_device * hid , unsigned char reportnum , __u8 * buf , size_t count , unsigned char report_type , int reqtype ) { struct dj_device * djdev = hid -> driver_data ; struct dj_receiver_dev * djrcv_dev = djdev -> dj_receiver_dev ; u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <S2SV_StartBug> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <S2SV_EndBug> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ; return ret ; }
CWE-284 int uinput_create ( char * name ) { struct uinput_dev dev ; int fd , x = 0 ; for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) { <S2SV_StartBug> fd = open ( uinput_dev_path [ x ] , O_RDWR ) ; <S2SV_EndBug> if ( fd < 0 ) continue ; break ; } if ( x == MAX_UINPUT_PATHS ) { BTIF_TRACE_ERROR ( "%s<S2SV_blank>ERROR:<S2SV_blank>uinput<S2SV_blank>device<S2SV_blank>open<S2SV_blank>failed" , __FUNCTION__ ) ; return - 1 ; } memset ( & dev , 0 , sizeof ( dev ) ) ; if ( name ) strncpy ( dev . name , name , UINPUT_MAX_NAME_SIZE - 1 ) ; dev . id . bustype = BUS_BLUETOOTH ; dev . id . vendor = 0x0000 ; dev . id . product = 0x0000 ; dev . id . version = 0x0000 ; <S2SV_StartBug> if ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { <S2SV_EndBug> BTIF_TRACE_ERROR ( "%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>device<S2SV_blank>information" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; <S2SV_EndBug> <S2SV_StartBug> ioctl ( fd , UI_SET_EVBIT , EV_SYN ) ; <S2SV_EndBug> for ( x = 0 ; key_map [ x ] . name != NULL ; x ++ ) <S2SV_StartBug> ioctl ( fd , UI_SET_KEYBIT , key_map [ x ] . mapped_id ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ioctl ( fd , UI_DEV_CREATE , NULL ) < 0 ) { <S2SV_EndBug> BTIF_TRACE_ERROR ( "%s<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>uinput<S2SV_blank>device" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } return fd ; }
CWE-000 static void destroy_super ( struct super_block * s ) { int i ; list_lru_destroy ( & s -> s_dentry_lru ) ; list_lru_destroy ( & s -> s_inode_lru ) ; <S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> free_percpu ( s -> s_files ) ; # endif for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) percpu_counter_destroy ( & s -> s_writers . counter [ i ] ) ; security_sb_free ( s ) ; WARN_ON ( ! list_empty ( & s -> s_mounts ) ) ; kfree ( s -> s_subtype ) ; kfree ( s -> s_options ) ; kfree_rcu ( s , rcu ) ; }
CWE-399 static int simulate_llsc ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == LL ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_ll ( regs , opcode ) ; } if ( ( opcode & OPCODE ) == SC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_sc ( regs , opcode ) ; } return - 1 ; }
CWE-000 void arch_pick_mmap_layout ( struct mm_struct * mm ) { unsigned long random_factor = 0UL ; if ( current -> flags & PF_RANDOMIZE ) random_factor = arch_mmap_rnd ( ) ; <S2SV_StartBug> mm -> mmap_legacy_base = mmap_legacy_base ( random_factor ) ; <S2SV_EndBug> if ( mmap_is_legacy ( ) ) { mm -> mmap_base = mm -> mmap_legacy_base ; mm -> get_unmapped_area = arch_get_unmapped_area ; } else { mm -> mmap_base = mmap_base ( random_factor ) ; mm -> get_unmapped_area = arch_get_unmapped_area_topdown ; } }
CWE-476 int crypto_rng_reset ( struct crypto_rng * tfm , const u8 * seed , unsigned int slen ) { u8 * buf = NULL ; int err ; if ( ! seed && slen ) { buf = kmalloc ( slen , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; get_random_bytes ( buf , slen ) ; seed = buf ; } <S2SV_StartBug> err = tfm -> seed ( tfm , seed , slen ) ; <S2SV_EndBug> kfree ( buf ) ; return err ; }
CWE-119 static vpx_codec_err_t set_vp8e_config ( VP8_CONFIG * oxcf , vpx_codec_enc_cfg_t cfg , struct vp8_extracfg vp8_cfg , vpx_codec_priv_enc_mr_cfg_t * mr_cfg ) { oxcf -> multi_threaded = cfg . g_threads ; oxcf -> Version = cfg . g_profile ; oxcf -> Width = cfg . g_w ; oxcf -> Height = cfg . g_h ; oxcf -> timebase = cfg . g_timebase ; oxcf -> error_resilient_mode = cfg . g_error_resilient ; switch ( cfg . g_pass ) { case VPX_RC_ONE_PASS : oxcf -> Mode = MODE_BESTQUALITY ; break ; case VPX_RC_FIRST_PASS : oxcf -> Mode = MODE_FIRSTPASS ; break ; case VPX_RC_LAST_PASS : oxcf -> Mode = MODE_SECONDPASS_BEST ; break ; } if ( cfg . g_pass == VPX_RC_FIRST_PASS || cfg . g_pass == VPX_RC_ONE_PASS ) { oxcf -> allow_lag = 0 ; oxcf -> lag_in_frames = 0 ; } else { oxcf -> allow_lag = ( cfg . g_lag_in_frames ) > 0 ; oxcf -> lag_in_frames = cfg . g_lag_in_frames ; } oxcf -> allow_df = ( cfg . rc_dropframe_thresh > 0 ) ; oxcf -> drop_frames_water_mark = cfg . rc_dropframe_thresh ; oxcf -> allow_spatial_resampling = cfg . rc_resize_allowed ; oxcf -> resample_up_water_mark = cfg . rc_resize_up_thresh ; oxcf -> resample_down_water_mark = cfg . rc_resize_down_thresh ; if ( cfg . rc_end_usage == VPX_VBR ) { oxcf -> end_usage = USAGE_LOCAL_FILE_PLAYBACK ; } else if ( cfg . rc_end_usage == VPX_CBR ) { oxcf -> end_usage = USAGE_STREAM_FROM_SERVER ; } else if ( cfg . rc_end_usage == VPX_CQ ) { oxcf -> end_usage = USAGE_CONSTRAINED_QUALITY ; } else if ( cfg . rc_end_usage == VPX_Q ) { oxcf -> end_usage = USAGE_CONSTANT_QUALITY ; } oxcf -> target_bandwidth = cfg . rc_target_bitrate ; oxcf -> rc_max_intra_bitrate_pct = vp8_cfg . rc_max_intra_bitrate_pct ; oxcf -> best_allowed_q = cfg . rc_min_quantizer ; oxcf -> worst_allowed_q = cfg . rc_max_quantizer ; oxcf -> cq_level = vp8_cfg . cq_level ; oxcf -> fixed_q = - 1 ; oxcf -> under_shoot_pct = cfg . rc_undershoot_pct ; oxcf -> over_shoot_pct = cfg . rc_overshoot_pct ; oxcf -> maximum_buffer_size_in_ms = cfg . rc_buf_sz ; oxcf -> starting_buffer_level_in_ms = cfg . rc_buf_initial_sz ; oxcf -> optimal_buffer_level_in_ms = cfg . rc_buf_optimal_sz ; oxcf -> maximum_buffer_size = cfg . rc_buf_sz ; oxcf -> starting_buffer_level = cfg . rc_buf_initial_sz ; oxcf -> optimal_buffer_level = cfg . rc_buf_optimal_sz ; oxcf -> two_pass_vbrbias = cfg . rc_2pass_vbr_bias_pct ; oxcf -> two_pass_vbrmin_section = cfg . rc_2pass_vbr_minsection_pct ; oxcf -> two_pass_vbrmax_section = cfg . rc_2pass_vbr_maxsection_pct ; oxcf -> auto_key = cfg . kf_mode == VPX_KF_AUTO && cfg . kf_min_dist != cfg . kf_max_dist ; oxcf -> key_freq = cfg . kf_max_dist ; oxcf -> number_of_layers = cfg . ts_number_layers ; oxcf -> periodicity = cfg . ts_periodicity ; if ( oxcf -> number_of_layers > 1 ) { memcpy ( oxcf -> target_bitrate , cfg . ts_target_bitrate , sizeof ( cfg . ts_target_bitrate ) ) ; memcpy ( oxcf -> rate_decimator , cfg . ts_rate_decimator , sizeof ( cfg . ts_rate_decimator ) ) ; memcpy ( oxcf -> layer_id , cfg . ts_layer_id , sizeof ( cfg . ts_layer_id ) ) ; } # if CONFIG_MULTI_RES_ENCODING if ( mr_cfg ) { oxcf -> mr_total_resolutions = mr_cfg -> mr_total_resolutions ; oxcf -> mr_encoder_id = mr_cfg -> mr_encoder_id ; oxcf -> mr_down_sampling_factor . num = mr_cfg -> mr_down_sampling_factor . num ; oxcf -> mr_down_sampling_factor . den = mr_cfg -> mr_down_sampling_factor . den ; oxcf -> mr_low_res_mode_info = mr_cfg -> mr_low_res_mode_info ; } <S2SV_StartBug> # endif <S2SV_EndBug> oxcf -> cpu_used = vp8_cfg . cpu_used ; oxcf -> encode_breakout = vp8_cfg . static_thresh ; oxcf -> play_alternate = vp8_cfg . enable_auto_alt_ref ; oxcf -> noise_sensitivity = vp8_cfg . noise_sensitivity ; oxcf -> Sharpness = vp8_cfg . Sharpness ; oxcf -> token_partitions = vp8_cfg . token_partitions ; oxcf -> two_pass_stats_in = cfg . rc_twopass_stats_in ; oxcf -> output_pkt_list = vp8_cfg . pkt_list ; oxcf -> arnr_max_frames = vp8_cfg . arnr_max_frames ; oxcf -> arnr_strength = vp8_cfg . arnr_strength ; oxcf -> arnr_type = vp8_cfg . arnr_type ; <S2SV_StartBug> oxcf -> tuning = vp8_cfg . tuning ; <S2SV_EndBug> return VPX_CODEC_OK ; }
CWE-119 static void calc_av_activity ( VP8_COMP * cpi , int64_t activity_sum ) { # if ACT_MEDIAN { unsigned int median ; unsigned int i , j ; unsigned int * sortlist ; unsigned int tmp ; CHECK_MEM_ERROR ( sortlist , vpx_calloc ( sizeof ( unsigned int ) , cpi -> common . MBs ) ) ; <S2SV_StartBug> vpx_memcpy ( sortlist , cpi -> mb_activity_map , <S2SV_EndBug> sizeof ( unsigned int ) * cpi -> common . MBs ) ; for ( i = 1 ; i < cpi -> common . MBs ; i ++ ) { for ( j = i ; j > 0 ; j -- ) { if ( sortlist [ j ] < sortlist [ j - 1 ] ) { tmp = sortlist [ j - 1 ] ; sortlist [ j - 1 ] = sortlist [ j ] ; sortlist [ j ] = tmp ; } else break ; } } median = ( 1 + sortlist [ cpi -> common . MBs >> 1 ] + sortlist [ ( cpi -> common . MBs >> 1 ) + 1 ] ) >> 1 ; cpi -> activity_avg = median ; vpx_free ( sortlist ) ; } # else cpi -> activity_avg = ( unsigned int ) ( activity_sum / cpi -> common . MBs ) ; # endif if ( cpi -> activity_avg < VP8_ACTIVITY_AVG_MIN ) cpi -> activity_avg = VP8_ACTIVITY_AVG_MIN ; if ( ALT_ACT_MEASURE ) cpi -> activity_avg = 100000 ; }
CWE-119 void WT_InterpolateNoLoop ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( "b/26366256" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = ( EAS_I32 ) pWTVoice -> phaseFrac ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
CWE-264 SYSCALL_DEFINE2 ( osf_getdomainname , char __user * , name , int , namelen ) { unsigned len ; int i ; if ( ! access_ok ( VERIFY_WRITE , name , namelen ) ) return - EFAULT ; len = namelen ; <S2SV_StartBug> if ( namelen > 32 ) <S2SV_EndBug> len = 32 ; down_read ( & uts_sem ) ; for ( i = 0 ; i < len ; ++ i ) { __put_user ( utsname ( ) -> domainname [ i ] , name + i ) ; if ( utsname ( ) -> domainname [ i ] == '\\0' ) break ; } up_read ( & uts_sem ) ; return 0 ; }
CWE-399 static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) { <S2SV_StartBug> case DB_VECTOR : <S2SV_EndBug> dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }
CWE-000 void pin_remove ( struct fs_pin * pin ) { spin_lock ( & pin_lock ) ; <S2SV_StartBug> hlist_del ( & pin -> m_list ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_del ( & pin -> s_list ) ; <S2SV_EndBug> spin_unlock ( & pin_lock ) ; spin_lock_irq ( & pin -> wait . lock ) ; pin -> done = 1 ; wake_up_locked ( & pin -> wait ) ; spin_unlock_irq ( & pin -> wait . lock ) ; }
CWE-190 static PHP_NAMED_FUNCTION ( zif_zip_entry_read ) { zval * zip_entry ; zend_long len = 0 ; zip_read_rsrc * zr_rsrc ; zend_string * buffer ; int n = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "r|l" , & zip_entry , & len ) == FAILURE ) { return ; } if ( ( zr_rsrc = ( zip_read_rsrc * ) zend_fetch_resource ( Z_RES_P ( zip_entry ) , le_zip_entry_name , le_zip_entry ) ) == NULL ) { RETURN_FALSE ; } if ( len <= 0 ) { len = 1024 ; } if ( zr_rsrc -> zf ) { <S2SV_StartBug> buffer = zend_string_alloc ( len , 0 ) ; <S2SV_EndBug> n = zip_fread ( zr_rsrc -> zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; if ( n > 0 ) { ZSTR_VAL ( buffer ) [ n ] = '\\0' ; ZSTR_LEN ( buffer ) = n ; RETURN_NEW_STR ( buffer ) ; } else { zend_string_free ( buffer ) ; RETURN_EMPTY_STRING ( ) } } else { RETURN_FALSE ; } }
CWE-190 <S2SV_StartBug> static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) <S2SV_EndBug> { unsigned char * buf ; <S2SV_StartBug> assert ( bufsize >= 0 ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( "mem_resize(%p,<S2SV_blank>%d)\\n" , m , bufsize ) ) ; <S2SV_EndBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) { JAS_DBGLOG ( 100 , ( "mem_resize<S2SV_blank>realloc<S2SV_blank>failed\\n" ) ) ; return - 1 ; } JAS_DBGLOG ( 100 , ( "mem_resize<S2SV_blank>realloc<S2SV_blank>succeeded\\n" ) ) ; m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }
CWE-119 <S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * codec , <S2SV_EndBug> vpx_image_t * img , int frame_index , int flags , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( codec , img , frame_index , 1 , flags , VPX_DL_GOOD_QUALITY ) ; if ( res != VPX_CODEC_OK ) die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame" ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) { die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame" ) ; } printf ( keyframe ? "K" : "." ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-264 static NPError g_NPN_GetValue ( NPP instance , NPNVariable variable , void * value ) { D ( bug ( "NPN_GetValue<S2SV_blank>instance=%p,<S2SV_blank>variable=%d<S2SV_blank>[%s]\\n" , instance , variable , string_of_NPNVariable ( variable ) ) ) ; if ( ! thread_check ( ) ) { npw_printf ( "WARNING:<S2SV_blank>NPN_GetValue<S2SV_blank>not<S2SV_blank>called<S2SV_blank>from<S2SV_blank>the<S2SV_blank>main<S2SV_blank>thread\\n" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } PluginInstance * plugin = NULL ; if ( instance ) plugin = PLUGIN_INSTANCE ( instance ) ; switch ( variable ) { case NPNVxDisplay : * ( void * * ) value = x_display ; break ; case NPNVxtAppContext : * ( void * * ) value = XtDisplayToApplicationContext ( x_display ) ; break ; case NPNVToolkit : * ( NPNToolkitType * ) value = NPW_TOOLKIT ; break ; # if USE_XPCOM case NPNVserviceManager : { nsIServiceManager * sm ; int ret = NS_GetServiceManager ( & sm ) ; if ( NS_FAILED ( ret ) ) { npw_printf ( "WARNING:<S2SV_blank>NS_GetServiceManager<S2SV_blank>failed\\n" ) ; return NPERR_GENERIC_ERROR ; } * ( nsIServiceManager * * ) value = sm ; break ; } case NPNVDOMWindow : case NPNVDOMElement : npw_printf ( "WARNING:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>NPN_GetValue()\\n" , string_of_NPNVariable ( variable ) ) ; return NPERR_INVALID_PARAM ; # endif case NPNVnetscapeWindow : if ( plugin == NULL ) { npw_printf ( "ERROR:<S2SV_blank>NPNVnetscapeWindow<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>non<S2SV_blank>NULL<S2SV_blank>instance\\n" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } if ( plugin -> browser_toplevel == NULL ) { GdkNativeWindow netscape_xid = None ; NPError error = g_NPN_GetValue_real ( instance , variable , & netscape_xid ) ; if ( error != NPERR_NO_ERROR ) return error ; if ( netscape_xid == None ) return NPERR_GENERIC_ERROR ; plugin -> browser_toplevel = gdk_window_foreign_new ( netscape_xid ) ; if ( plugin -> browser_toplevel == NULL ) return NPERR_GENERIC_ERROR ; } * ( ( GdkNativeWindow * ) value ) = GDK_WINDOW_XWINDOW ( plugin -> browser_toplevel ) ; break ; # if ALLOW_WINDOWLESS_PLUGINS case NPNVSupportsWindowless : # endif case NPNVSupportsXEmbedBool : case NPNVWindowNPObject : case NPNVPluginElementNPObject : <S2SV_StartBug> return g_NPN_GetValue_real ( instance , variable , value ) ; <S2SV_EndBug> default : switch ( variable & 0xff ) { case 13 : if ( NPW_TOOLKIT == NPNVGtk2 ) { * ( NPNToolkitType * ) value = NPW_TOOLKIT ; return NPERR_NO_ERROR ; } break ; } D ( bug ( "WARNING:<S2SV_blank>unhandled<S2SV_blank>variable<S2SV_blank>%d<S2SV_blank>(%s)<S2SV_blank>in<S2SV_blank>NPN_GetValue()\\n" , variable , string_of_NPNVariable ( variable ) ) ) ; return NPERR_INVALID_PARAM ; } return NPERR_NO_ERROR ; }
CWE-119 static void dump_boot ( DOS_FS * fs , struct boot_sector * b , unsigned lss ) { unsigned short sectors ; printf ( "Boot<S2SV_blank>sector<S2SV_blank>contents:\\n" ) ; if ( ! atari_format ) { char id [ 9 ] ; strncpy ( id , ( const char * ) b -> system_id , 8 ) ; id [ 8 ] = 0 ; printf ( "System<S2SV_blank>ID<S2SV_blank>\\"%s\\"\\n" , id ) ; } else { printf ( "Serial<S2SV_blank>number<S2SV_blank>0x%x\\n" , b -> system_id [ 5 ] | ( b -> system_id [ 6 ] << 8 ) | ( b -> system_id [ 7 ] << 16 ) ) ; } printf ( "Media<S2SV_blank>byte<S2SV_blank>0x%02x<S2SV_blank>(%s)\\n" , b -> media , get_media_descr ( b -> media ) ) ; printf ( "%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>logical<S2SV_blank>sector\\n" , GET_UNALIGNED_W ( b -> sector_size ) ) ; printf ( "%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>cluster\\n" , fs -> cluster_size ) ; printf ( "%10d<S2SV_blank>reserved<S2SV_blank>sector%s\\n" , le16toh ( b -> reserved ) , le16toh ( b -> reserved ) == 1 ? "" : "s" ) ; printf ( "First<S2SV_blank>FAT<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n" , ( unsigned long long ) fs -> fat_start , ( unsigned long long ) fs -> fat_start / lss ) ; printf ( "%10d<S2SV_blank>FATs,<S2SV_blank>%d<S2SV_blank>bit<S2SV_blank>entries\\n" , b -> fats , fs -> fat_bits ) ; <S2SV_StartBug> printf ( "%10d<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%u<S2SV_blank>sectors)\\n" , fs -> fat_size , <S2SV_EndBug> <S2SV_StartBug> fs -> fat_size / lss ) ; <S2SV_EndBug> if ( ! fs -> root_cluster ) { printf ( "Root<S2SV_blank>directory<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n" , ( unsigned long long ) fs -> root_start , ( unsigned long long ) fs -> root_start / lss ) ; printf ( "%10d<S2SV_blank>root<S2SV_blank>directory<S2SV_blank>entries\\n" , fs -> root_entries ) ; } else { printf ( "Root<S2SV_blank>directory<S2SV_blank>start<S2SV_blank>at<S2SV_blank>cluster<S2SV_blank>%lu<S2SV_blank>(arbitrary<S2SV_blank>size)\\n" , ( unsigned long ) fs -> root_cluster ) ; } printf ( "Data<S2SV_blank>area<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>byte<S2SV_blank>%llu<S2SV_blank>(sector<S2SV_blank>%llu)\\n" , ( unsigned long long ) fs -> data_start , ( unsigned long long ) fs -> data_start / lss ) ; printf ( "%10lu<S2SV_blank>data<S2SV_blank>clusters<S2SV_blank>(%llu<S2SV_blank>bytes)\\n" , ( unsigned long ) fs -> data_clusters , ( unsigned long long ) fs -> data_clusters * fs -> cluster_size ) ; printf ( "%u<S2SV_blank>sectors/track,<S2SV_blank>%u<S2SV_blank>heads\\n" , le16toh ( b -> secs_track ) , le16toh ( b -> heads ) ) ; printf ( "%10u<S2SV_blank>hidden<S2SV_blank>sectors\\n" , atari_format ? ( ( ( unsigned char * ) & b -> hidden ) [ 0 ] | ( ( unsigned char * ) & b -> hidden ) [ 1 ] << 8 ) : le32toh ( b -> hidden ) ) ; sectors = GET_UNALIGNED_W ( b -> sectors ) ; printf ( "%10u<S2SV_blank>sectors<S2SV_blank>total\\n" , sectors ? sectors : le32toh ( b -> total_sect ) ) ; }
CWE-119 static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) { <S2SV_StartBug> return tmp ; <S2SV_EndBug> } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : state -> buffer [ state -> offset ++ ] = * state -> ptr ; break ; default : if ( ! ( mb = parse_mb ( state , PARSE_SCHEME , state -> ptr , state -> end , tmp , 1 ) ) ) { <S2SV_StartBug> return tmp ; <S2SV_EndBug> } state -> ptr += mb - 1 ; } } while ( ++ state -> ptr != state -> end ) ; <S2SV_StartBug> return state -> ptr = tmp ; <S2SV_EndBug> }
CWE-264 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( "trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n" , ret ) ; kfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( "trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n" , ret ) ; kfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kfree ( datablob ) ; kfree ( new_o ) ; return ret ; }
CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> ( void ) memcpy ( ( ( char * ) buf ) + offs , <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug> return len ; }
CWE-000 int xfs_attr3_leaf_lookup_int ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; xfs_dahash_t hashval ; int probe ; int span ; trace_xfs_attr_leaf_lookup ( args ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; hashval = args -> hashval ; probe = span = ichdr . count / 2 ; for ( entry = & entries [ probe ] ; span > 4 ; entry = & entries [ probe ] ) { span /= 2 ; if ( be32_to_cpu ( entry -> hashval ) < hashval ) probe += span ; else if ( be32_to_cpu ( entry -> hashval ) > hashval ) probe -= span ; else break ; } ASSERT ( probe >= 0 && ( ! ichdr . count || probe < ichdr . count ) ) ; ASSERT ( span <= 4 || be32_to_cpu ( entry -> hashval ) == hashval ) ; while ( probe > 0 && be32_to_cpu ( entry -> hashval ) >= hashval ) { entry -- ; probe -- ; } while ( probe < ichdr . count && be32_to_cpu ( entry -> hashval ) < hashval ) { entry ++ ; probe ++ ; } if ( probe == ichdr . count || be32_to_cpu ( entry -> hashval ) != hashval ) { args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; } for ( ; probe < ichdr . count && ( be32_to_cpu ( entry -> hashval ) == hashval ) ; entry ++ , probe ++ ) { if ( ( args -> flags & XFS_ATTR_INCOMPLETE ) != ( entry -> flags & XFS_ATTR_INCOMPLETE ) ) { continue ; } if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , probe ) ; if ( name_loc -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; return XFS_ERROR ( EEXIST ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , probe ) ; if ( name_rmt -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; <S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> return XFS_ERROR ( EEXIST ) ; } } args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; }
CWE-119 const vpx_codec_cx_pkt_t * vpx_codec_get_cx_data ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) { const vpx_codec_cx_pkt_t * pkt = NULL ; if ( ctx ) { if ( ! iter ) ctx -> err = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> pkt = ctx -> iface -> enc . get_cx_data ( ctx -> priv -> alg_priv , iter ) ; <S2SV_EndBug> } if ( pkt && pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { vpx_codec_priv_t * const priv = ctx -> priv ; char * const dst_buf = ( char * ) priv -> enc . cx_data_dst_buf . buf ; if ( dst_buf && pkt -> data . raw . buf != dst_buf && pkt -> data . raw . sz + priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after <= priv -> enc . cx_data_dst_buf . sz ) { vpx_codec_cx_pkt_t * modified_pkt = & priv -> enc . cx_data_pkt ; memcpy ( dst_buf + priv -> enc . cx_data_pad_before , pkt -> data . raw . buf , pkt -> data . raw . sz ) ; * modified_pkt = * pkt ; modified_pkt -> data . raw . buf = dst_buf ; modified_pkt -> data . raw . sz += priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after ; pkt = modified_pkt ; } if ( dst_buf == pkt -> data . raw . buf ) { priv -> enc . cx_data_dst_buf . buf = dst_buf + pkt -> data . raw . sz ; priv -> enc . cx_data_dst_buf . sz -= pkt -> data . raw . sz ; } } return pkt ; }
CWE-399 static void unix_detach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; scm -> fp = UNIXCB ( skb ) . fp ; UNIXCB ( skb ) . fp = NULL ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <S2SV_StartBug> unix_notinflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> }
CWE-119 int vp9_is_skippable_in_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { int result = 1 ; <S2SV_StartBug> struct is_skippable_args args = { x , & result } ; <S2SV_EndBug> vp9_foreach_transformed_block_in_plane ( & x -> e_mbd , bsize , plane , is_skippable , & args ) ; return result ; }
CWE-000 static rsRetVal createSocket ( instanceConf_t * info , void * * sock ) { int rv ; sublist * sub ; * sock = zsocket_new ( s_context , info -> type ) ; if ( ! sock ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , "zsocket_new<S2SV_blank>failed:<S2SV_blank>%s,<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%d" , zmq_strerror ( errno ) , info -> type ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( "imzmq3:<S2SV_blank>socket<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>created<S2SV_blank>successfully\\n" , info -> type ) if ( info -> identity ) zsocket_set_identity ( * sock , info -> identity ) ; if ( info -> sndBuf > - 1 ) zsocket_set_sndbuf ( * sock , info -> sndBuf ) ; if ( info -> rcvBuf > - 1 ) zsocket_set_rcvbuf ( * sock , info -> rcvBuf ) ; if ( info -> linger > - 1 ) zsocket_set_linger ( * sock , info -> linger ) ; if ( info -> backlog > - 1 ) zsocket_set_backlog ( * sock , info -> backlog ) ; if ( info -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( * sock , info -> sndTimeout ) ; if ( info -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( * sock , info -> rcvTimeout ) ; if ( info -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( * sock , info -> maxMsgSize ) ; if ( info -> rate > - 1 ) zsocket_set_rate ( * sock , info -> rate ) ; if ( info -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( * sock , info -> recoveryIVL ) ; if ( info -> multicastHops > - 1 ) zsocket_set_multicast_hops ( * sock , info -> multicastHops ) ; if ( info -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( * sock , info -> reconnectIVL ) ; if ( info -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( * sock , info -> reconnectIVLMax ) ; if ( info -> ipv4Only > - 1 ) zsocket_set_ipv4only ( * sock , info -> ipv4Only ) ; if ( info -> affinity > - 1 ) zsocket_set_affinity ( * sock , info -> affinity ) ; if ( info -> sndHWM > - 1 ) zsocket_set_sndhwm ( * sock , info -> sndHWM ) ; if ( info -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( * sock , info -> rcvHWM ) ; if ( info -> type == ZMQ_SUB ) { for ( sub = info -> subscriptions ; sub != NULL ; sub = sub -> next ) { zsocket_set_subscribe ( * sock , sub -> subscribe ) ; } } if ( info -> action == ACTION_CONNECT ) { <S2SV_StartBug> rv = zsocket_connect ( * sock , info -> description ) ; <S2SV_EndBug> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , "zmq_connect<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s" , info -> description , zmq_strerror ( errno ) ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( "imzmq3:<S2SV_blank>connect<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>successful\\n" , info -> description ) ; } else { <S2SV_StartBug> rv = zsocket_bind ( * sock , info -> description ) ; <S2SV_EndBug> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , "zmq_bind<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s" , info -> description , zmq_strerror ( errno ) ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( "imzmq3:<S2SV_blank>bind<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>successful\\n" , info -> description ) ; } return RS_RET_OK ; }
CWE-119 int vp8dx_get_raw_frame ( VP8D_COMP * pbi , YV12_BUFFER_CONFIG * sd , int64_t * time_stamp , int64_t * time_end_stamp , vp8_ppflags_t * flags ) { int ret = - 1 ; if ( pbi -> ready_for_new_data == 1 ) return ret ; if ( pbi -> common . show_frame == 0 ) return ret ; pbi -> ready_for_new_data = 1 ; * time_stamp = pbi -> last_time_stamp ; * time_end_stamp = 0 ; # if CONFIG_POSTPROC ret = vp8_post_proc_frame ( & pbi -> common , sd , flags ) ; # else <S2SV_StartBug> if ( pbi -> common . frame_to_show ) <S2SV_EndBug> { * sd = * pbi -> common . frame_to_show ; sd -> y_width = pbi -> common . Width ; sd -> y_height = pbi -> common . Height ; sd -> uv_height = pbi -> common . Height / 2 ; ret = 0 ; } else { ret = - 1 ; } # endif vp8_clear_system_state ( ) ; return ret ; }
CWE-000 static int nfs4_callback_svc ( void * vrqstp ) { int err ; struct svc_rqst * rqstp = vrqstp ; set_freezable ( ) ; <S2SV_StartBug> while ( ! kthread_should_stop ( ) ) { <S2SV_EndBug> err = svc_recv ( rqstp , MAX_SCHEDULE_TIMEOUT ) ; if ( err == - EAGAIN || err == - EINTR ) continue ; svc_process ( rqstp ) ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> void vp9_rc_init_minq_luts ( ) { <S2SV_EndBug> int i ; for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) { const double maxq = vp9_convert_qindex_to_q ( i ) ; kf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.000001 , - 0.0004 , 0.15 ) ; kf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.000002 , - 0.0012 , 0.50 ) ; gf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.32 ) ; gf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.50 ) ; afq_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.33 ) ; afq_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.55 ) ; inter_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.75 ) ; } }
CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <S2SV_StartBug> value [ n ] >= min && value [ n ] <= max && <S2SV_EndBug> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max <S2SV_StartBug> && field -> usage [ field -> value [ n ] - min ] . hid <S2SV_EndBug> && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; if ( value [ n ] >= min && value [ n ] <= max <S2SV_StartBug> && field -> usage [ value [ n ] - min ] . hid <S2SV_EndBug> && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; } memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; exit : kfree ( value ) ; }
CWE-125 static void ip_cmsg_recv_checksum ( struct msghdr * msg , struct sk_buff * skb , int tlen , int offset ) { __wsum csum = skb -> csum ; if ( skb -> ip_summed != CHECKSUM_COMPLETE ) return ; <S2SV_StartBug> if ( offset != 0 ) <S2SV_EndBug> csum = csum_sub ( csum , <S2SV_StartBug> csum_partial ( skb_transport_header ( skb ) + tlen , <S2SV_EndBug> <S2SV_StartBug> offset , 0 ) ) ; <S2SV_EndBug> put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ; }
CWE-476 static int compile_bag_node ( BagNode * node , regex_t * reg , ScanEnv * env ) { int r , len ; switch ( node -> type ) { case BAG_MEMORY : r = compile_bag_memory_node ( node , reg , env ) ; break ; case BAG_OPTION : r = compile_option_node ( node , reg , env ) ; break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { QuantNode * qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; r = compile_tree_n_times ( NODE_QUANT_BODY ( qn ) , qn -> lower , reg , env ) ; if ( r != 0 ) return r ; len = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( len < 0 ) return len ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; r = compile_tree ( NODE_QUANT_BODY ( qn ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_POP_OUT ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; COP ( reg ) -> jump . addr = - ( ( int ) SIZE_OP_PUSH + len + ( int ) SIZE_OP_POP_OUT ) ; } else { r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; r = compile_tree ( NODE_BAG_BODY ( node ) , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; } break ; case BAG_IF_ELSE : { <S2SV_StartBug> int cond_len , then_len , jump_len ; <S2SV_EndBug> Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; r = add_op ( reg , OP_ATOMIC_START ) ; if ( r != 0 ) return r ; cond_len = compile_length_tree ( cond , reg ) ; if ( cond_len < 0 ) return cond_len ; if ( IS_NOT_NULL ( Then ) ) { then_len = compile_length_tree ( Then , reg ) ; if ( then_len < 0 ) return then_len ; } else then_len = 0 ; <S2SV_StartBug> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END ; <S2SV_EndBug> if ( IS_NOT_NULL ( Else ) ) jump_len += SIZE_OP_JUMP ; r = add_op ( reg , OP_PUSH ) ; if ( r != 0 ) return r ; COP ( reg ) -> push . addr = SIZE_INC_OP + jump_len ; r = compile_tree ( cond , reg , env ) ; if ( r != 0 ) return r ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Then ) ) { r = compile_tree ( Then , reg , env ) ; if ( r != 0 ) return r ; } if ( IS_NOT_NULL ( Else ) ) { <S2SV_StartBug> int else_len = compile_length_tree ( Else , reg ) ; <S2SV_EndBug> r = add_op ( reg , OP_JUMP ) ; if ( r != 0 ) return r ; <S2SV_StartBug> COP ( reg ) -> jump . addr = else_len + SIZE_INC_OP ; <S2SV_EndBug> <S2SV_StartBug> r = compile_tree ( Else , reg , env ) ; <S2SV_EndBug> } } break ; } return r ; }
CWE-200 static int raptor_rdfxml_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rdfxml_parser * rdf_xml_parser ; rdf_xml_parser = ( raptor_rdfxml_parser * ) rdf_parser -> context ; if ( ! uri ) return 1 ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NORMALIZE_LANGUAGE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NORMALIZE_LANGUAGE ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; <S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> raptor_sax2_set_uri_filter ( rdf_xml_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rdf_xml_parser -> sax2 , uri ) ; if ( rdf_xml_parser -> id_set ) { raptor_free_id_set ( rdf_xml_parser -> id_set ) ; rdf_xml_parser -> id_set = NULL ; } if ( RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_CHECK_RDF_ID ) ) { rdf_xml_parser -> id_set = raptor_new_id_set ( rdf_parser -> world ) ; if ( ! rdf_xml_parser -> id_set ) return 1 ; } return 0 ; }
CWE-362 void flush_tlb_page ( struct vm_area_struct * vma , unsigned long start ) { struct mm_struct * mm = vma -> vm_mm ; preempt_disable ( ) ; if ( current -> active_mm == mm ) { <S2SV_StartBug> if ( current -> mm ) <S2SV_EndBug> __flush_tlb_one ( start ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> leave_mm ( smp_processor_id ( ) ) ; <S2SV_EndBug> } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , 0UL ) ; preempt_enable ( ) ; }
CWE-284 static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; <S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> }
CWE-119 void vp8_bilinear_predict4x4_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) { uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 , d6u8 ; uint8x8_t d26u8 , d27u8 , d28u8 , d29u8 , d30u8 ; <S2SV_StartBug> uint32x2_t d28u32 , d29u32 , d30u32 ; <S2SV_EndBug> uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 0 ) ; src_ptr += src_pixels_per_line ; d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 1 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 0 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 1 ) ; src_ptr += src_pixels_per_line ; d30u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d30u32 , 0 ) ; d28u8 = vreinterpret_u8_u32 ( d28u32 ) ; d29u8 = vreinterpret_u8_u32 ( d29u32 ) ; d30u8 = vreinterpret_u8_u32 ( d30u32 ) ; } else { d2u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d3u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d4u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d5u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d6u8 = vld1_u8 ( src_ptr ) ; q1u8 = vcombine_u8 ( d2u8 , d3u8 ) ; q2u8 = vcombine_u8 ( d4u8 , d5u8 ) ; <S2SV_StartBug> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <S2SV_EndBug> q4u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q1u8 ) , 8 ) ; q5u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q2u8 ) , 8 ) ; d12u64 = vshr_n_u64 ( vreinterpret_u64_u8 ( d6u8 ) , 8 ) ; d0u32x2 = vzip_u32 ( vreinterpret_u32_u8 ( vget_low_u8 ( q1u8 ) ) , vreinterpret_u32_u8 ( vget_high_u8 ( q1u8 ) ) ) ; d1u32x2 = vzip_u32 ( vreinterpret_u32_u8 ( vget_low_u8 ( q2u8 ) ) , vreinterpret_u32_u8 ( vget_high_u8 ( q2u8 ) ) ) ; d2u32x2 = vzip_u32 ( vreinterpret_u32_u64 ( vget_low_u64 ( q4u64 ) ) , vreinterpret_u32_u64 ( vget_high_u64 ( q4u64 ) ) ) ; d3u32x2 = vzip_u32 ( vreinterpret_u32_u64 ( vget_low_u64 ( q5u64 ) ) , vreinterpret_u32_u64 ( vget_high_u64 ( q5u64 ) ) ) ; q7u16 = vmull_u8 ( vreinterpret_u8_u32 ( d0u32x2 . val [ 0 ] ) , d0u8 ) ; q8u16 = vmull_u8 ( vreinterpret_u8_u32 ( d1u32x2 . val [ 0 ] ) , d0u8 ) ; q9u16 = vmull_u8 ( d6u8 , d0u8 ) ; q7u16 = vmlal_u8 ( q7u16 , vreinterpret_u8_u32 ( d2u32x2 . val [ 0 ] ) , d1u8 ) ; q8u16 = vmlal_u8 ( q8u16 , vreinterpret_u8_u32 ( d3u32x2 . val [ 0 ] ) , d1u8 ) ; q9u16 = vmlal_u8 ( q9u16 , vreinterpret_u8_u64 ( d12u64 ) , d1u8 ) ; d28u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ; d29u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ; d30u8 = vqrshrn_n_u16 ( q9u16 , 7 ) ; } if ( yoffset == 0 ) { vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d28u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d28u8 ) , 1 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d29u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d29u8 ) , 1 ) ; } else { d0u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 0 ] ) ; d1u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 1 ] ) ; q1u16 = vmull_u8 ( d28u8 , d0u8 ) ; q2u16 = vmull_u8 ( d29u8 , d0u8 ) ; d26u8 = vext_u8 ( d28u8 , d29u8 , 4 ) ; d27u8 = vext_u8 ( d29u8 , d30u8 , 4 ) ; q1u16 = vmlal_u8 ( q1u16 , d26u8 , d1u8 ) ; q2u16 = vmlal_u8 ( q2u16 , d27u8 , d1u8 ) ; d2u8 = vqrshrn_n_u16 ( q1u16 , 7 ) ; d3u8 = vqrshrn_n_u16 ( q2u16 , 7 ) ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d2u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d2u8 ) , 1 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d3u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d3u8 ) , 1 ) ; } return ; }
CWE-284 int btpan_tap_send ( int tap_fd , const BD_ADDR src , const BD_ADDR dst , UINT16 proto , const char * buf , UINT16 len , BOOLEAN ext , BOOLEAN forward ) { UNUSED ( ext ) ; UNUSED ( forward ) ; if ( tap_fd != INVALID_FD ) { tETH_HDR eth_hdr ; memcpy ( & eth_hdr . h_dest , dst , ETH_ADDR_LEN ) ; memcpy ( & eth_hdr . h_src , src , ETH_ADDR_LEN ) ; eth_hdr . h_proto = htons ( proto ) ; char packet [ TAP_MAX_PKT_WRITE_LEN + sizeof ( tETH_HDR ) ] ; memcpy ( packet , & eth_hdr , sizeof ( tETH_HDR ) ) ; if ( len > TAP_MAX_PKT_WRITE_LEN ) { LOG_ERROR ( "btpan_tap_send<S2SV_blank>eth<S2SV_blank>packet<S2SV_blank>size:%d<S2SV_blank>is<S2SV_blank>exceeded<S2SV_blank>limit!" , len ) ; return - 1 ; } memcpy ( packet + sizeof ( tETH_HDR ) , buf , len ) ; <S2SV_StartBug> int ret = write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ; <S2SV_EndBug> BTIF_TRACE_DEBUG ( "ret:%d" , ret ) ; return ret ; } return - 1 ; }
CWE-119 <S2SV_StartBug> void vp9_inc_frame_in_layer ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 ) <S2SV_EndBug> ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ; ++ lc -> current_video_frame_in_layer ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-416 static void regulator_ena_gpio_free ( struct regulator_dev * rdev ) { struct regulator_enable_gpio * pin , * n ; if ( ! rdev -> ena_pin ) return ; list_for_each_entry_safe ( pin , n , & regulator_ena_gpio_list , list ) { if ( pin -> gpiod == rdev -> ena_pin -> gpiod ) { if ( pin -> request_count <= 1 ) { pin -> request_count = 0 ; gpiod_put ( pin -> gpiod ) ; list_del ( & pin -> list ) ; kfree ( pin ) ; <S2SV_StartBug> } else { <S2SV_EndBug> pin -> request_count -- ; } } } }
CWE-189 int CIFSFindNext ( const int xid , struct cifs_tcon * tcon , __u16 searchHandle , struct cifs_search_info * psrch_inf ) { TRANSACTION2_FNEXT_REQ * pSMB = NULL ; TRANSACTION2_FNEXT_RSP * pSMBr = NULL ; T2_FNEXT_RSP_PARMS * parms ; char * response_data ; int rc = 0 ; <S2SV_StartBug> int bytes_returned , name_len ; <S2SV_EndBug> __u16 params , byte_count ; cFYI ( 1 , "In<S2SV_blank>FindNext" ) ; if ( psrch_inf -> endOfSearch ) return - ENOENT ; rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr ) ; if ( rc ) return rc ; params = 14 ; byte_count = 0 ; pSMB -> TotalDataCount = 0 ; pSMB -> MaxParameterCount = cpu_to_le16 ( 8 ) ; pSMB -> MaxDataCount = cpu_to_le16 ( ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) & 0xFFFFFF00 ) ; pSMB -> MaxSetupCount = 0 ; pSMB -> Reserved = 0 ; pSMB -> Flags = 0 ; pSMB -> Timeout = 0 ; pSMB -> Reserved2 = 0 ; pSMB -> ParameterOffset = cpu_to_le16 ( offsetof ( struct smb_com_transaction2_fnext_req , SearchHandle ) - 4 ) ; pSMB -> DataCount = 0 ; pSMB -> DataOffset = 0 ; pSMB -> SetupCount = 1 ; pSMB -> Reserved3 = 0 ; pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_NEXT ) ; pSMB -> SearchHandle = searchHandle ; pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) ) ; pSMB -> InformationLevel = cpu_to_le16 ( psrch_inf -> info_level ) ; pSMB -> ResumeKey = psrch_inf -> resume_key ; pSMB -> SearchFlags = cpu_to_le16 ( CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME ) ; name_len = psrch_inf -> resume_name_len ; params += name_len ; if ( name_len < PATH_MAX ) { memcpy ( pSMB -> ResumeFileName , psrch_inf -> presume_name , name_len ) ; byte_count += name_len ; pSMB -> ResumeFileName [ name_len ] = 0 ; pSMB -> ResumeFileName [ name_len + 1 ] = 0 ; } else { rc = - EINVAL ; goto FNext2_err_exit ; } byte_count = params + 1 ; pSMB -> TotalParameterCount = cpu_to_le16 ( params ) ; pSMB -> ParameterCount = pSMB -> TotalParameterCount ; inc_rfc1001_len ( pSMB , byte_count ) ; pSMB -> ByteCount = cpu_to_le16 ( byte_count ) ; rc = SendReceive ( xid , tcon -> ses , ( struct smb_hdr * ) pSMB , ( struct smb_hdr * ) pSMBr , & bytes_returned , 0 ) ; cifs_stats_inc ( & tcon -> num_fnext ) ; if ( rc ) { if ( rc == - EBADF ) { psrch_inf -> endOfSearch = true ; cifs_buf_release ( pSMB ) ; rc = 0 ; } else cFYI ( 1 , "FindNext<S2SV_blank>returned<S2SV_blank>=<S2SV_blank>%d" , rc ) ; } else { rc = validate_t2 ( ( struct smb_t2_rsp * ) pSMBr ) ; if ( rc == 0 ) { unsigned int lnoff ; if ( pSMBr -> hdr . Flags2 & SMBFLG2_UNICODE ) psrch_inf -> unicode = true ; else psrch_inf -> unicode = false ; response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . ParameterOffset ) ; parms = ( T2_FNEXT_RSP_PARMS * ) response_data ; response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . DataOffset ) ; if ( psrch_inf -> smallBuf ) cifs_small_buf_release ( psrch_inf -> ntwrk_buf_start ) ; else cifs_buf_release ( psrch_inf -> ntwrk_buf_start ) ; psrch_inf -> srch_entries_start = response_data ; psrch_inf -> ntwrk_buf_start = ( char * ) pSMB ; psrch_inf -> smallBuf = 0 ; if ( parms -> EndofSearch ) psrch_inf -> endOfSearch = true ; else psrch_inf -> endOfSearch = false ; psrch_inf -> entries_in_buffer = le16_to_cpu ( parms -> SearchCount ) ; psrch_inf -> index_of_last_entry += psrch_inf -> entries_in_buffer ; lnoff = le16_to_cpu ( parms -> LastNameOffset ) ; if ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE < lnoff ) { cERROR ( 1 , "ignoring<S2SV_blank>corrupt<S2SV_blank>resume<S2SV_blank>name" ) ; psrch_inf -> last_entry = NULL ; return rc ; } else psrch_inf -> last_entry = psrch_inf -> srch_entries_start + lnoff ; } } FNext2_err_exit : if ( rc != 0 ) cifs_buf_release ( pSMB ) ; return rc ; }
CWE-416 int __ext4_journal_stop ( const char * where , unsigned int line , handle_t * handle ) { struct super_block * sb ; int err ; int rc ; if ( ! ext4_handle_valid ( handle ) ) { ext4_put_nojournal ( handle ) ; return 0 ; } <S2SV_StartBug> if ( ! handle -> h_transaction ) { <S2SV_EndBug> <S2SV_StartBug> err = jbd2_journal_stop ( handle ) ; <S2SV_EndBug> <S2SV_StartBug> return handle -> h_err ? handle -> h_err : err ; <S2SV_EndBug> } <S2SV_StartBug> sb = handle -> h_transaction -> t_journal -> j_private ; <S2SV_EndBug> err = handle -> h_err ; rc = jbd2_journal_stop ( handle ) ; if ( ! err ) err = rc ; if ( err ) __ext4_std_error ( sb , where , line , err ) ; return err ; }
CWE-119 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <S2SV_StartBug> if ( sec_attr == NULL ) { <S2SV_EndBug> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }
CWE-190 void * checked_xcalloc ( size_t num , size_t size ) { <S2SV_StartBug> alloc_limit_assert ( "checked_xcalloc" , ( num * size ) ) ; <S2SV_EndBug> return xcalloc ( num , size ) ; }
CWE-119 void WT_NoiseGenerator ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 nInterpolatedSample ; EAS_I32 numSamples ; <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; tmp0 = ( EAS_I32 ) ( pWTVoice -> phaseAccum ) >> 18 ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; while ( numSamples -- ) { nInterpolatedSample = MULT_AUDIO_COEF ( tmp0 , ( PHASE_ONE - pWTVoice -> phaseFrac ) ) ; nInterpolatedSample += MULT_AUDIO_COEF ( tmp1 , pWTVoice -> phaseFrac ) ; * pOutputBuffer ++ = ( EAS_PCM ) nInterpolatedSample ; pWTVoice -> phaseFrac += ( EAS_U32 ) phaseInc ; if ( GET_PHASE_INT_PART ( pWTVoice -> phaseFrac ) ) { tmp0 = tmp1 ; pWTVoice -> phaseAccum = pWTVoice -> loopEnd ; pWTVoice -> loopEnd = ( 5 * pWTVoice -> loopEnd + 1 ) ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; pWTVoice -> phaseFrac = GET_PHASE_FRAC_PART ( pWTVoice -> phaseFrac ) ; } } }
CWE-119 <S2SV_StartBug> static void write_sync_code ( struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ; <S2SV_EndBug> }
CWE-476 static void process_lru_command ( conn * c , token_t * tokens , const size_t ntokens ) { uint32_t pct_hot ; uint32_t pct_warm ; double hot_factor ; int32_t ttl ; double factor ; set_noreply_maybe ( c , tokens , ntokens ) ; if ( strcmp ( tokens [ 1 ] . value , "tune" ) == 0 && ntokens >= 7 ) { if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) { out_string ( c , "ERROR" ) ; } else { if ( pct_hot + pct_warm > 80 ) { out_string ( c , "ERROR<S2SV_blank>hot<S2SV_blank>and<S2SV_blank>warm<S2SV_blank>pcts<S2SV_blank>must<S2SV_blank>not<S2SV_blank>exceed<S2SV_blank>80" ) ; } else if ( factor <= 0 || hot_factor <= 0 ) { out_string ( c , "ERROR<S2SV_blank>hot/warm<S2SV_blank>age<S2SV_blank>factors<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; } else { settings . hot_lru_pct = pct_hot ; settings . warm_lru_pct = pct_warm ; settings . hot_max_factor = hot_factor ; settings . warm_max_factor = factor ; out_string ( c , "OK" ) ; } } <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , "mode" ) == 0 && ntokens >= 3 && <S2SV_EndBug> settings . lru_maintainer_thread ) { if ( strcmp ( tokens [ 2 ] . value , "flat" ) == 0 ) { settings . lru_segmented = false ; out_string ( c , "OK" ) ; } else if ( strcmp ( tokens [ 2 ] . value , "segmented" ) == 0 ) { settings . lru_segmented = true ; out_string ( c , "OK" ) ; } else { out_string ( c , "ERROR" ) ; } <S2SV_StartBug> } else if ( strcmp ( tokens [ 1 ] . value , "temp_ttl" ) == 0 && ntokens >= 3 && <S2SV_EndBug> settings . lru_maintainer_thread ) { if ( ! safe_strtol ( tokens [ 2 ] . value , & ttl ) ) { out_string ( c , "ERROR" ) ; } else { if ( ttl < 0 ) { settings . temp_lru = false ; } else { settings . temp_lru = true ; settings . temporary_ttl = ttl ; } out_string ( c , "OK" ) ; } } else { out_string ( c , "ERROR" ) ; } }
CWE-20 void xenvif_disconnect ( struct xenvif * vif ) { <S2SV_StartBug> struct net_device * dev = vif -> dev ; <S2SV_EndBug> <S2SV_StartBug> if ( netif_carrier_ok ( dev ) ) { <S2SV_EndBug> rtnl_lock ( ) ; netif_carrier_off ( dev ) ; if ( netif_running ( dev ) ) <S2SV_StartBug> xenvif_down ( vif ) ; <S2SV_EndBug> <S2SV_StartBug> rtnl_unlock ( ) ; <S2SV_EndBug> xenvif_put ( vif ) ; } atomic_dec ( & vif -> refcnt ) ; wait_event ( vif -> waiting_to_free , atomic_read ( & vif -> refcnt ) == 0 ) ; del_timer_sync ( & vif -> credit_timeout ) ; if ( vif -> irq ) unbind_from_irqhandler ( vif -> irq , vif ) ; unregister_netdev ( vif -> dev ) ; xen_netbk_unmap_frontend_rings ( vif ) ; free_netdev ( vif -> dev ) ; }
CWE-119 void vp9_cyclic_refresh_free ( CYCLIC_REFRESH * cr ) { vpx_free ( cr -> map ) ; <S2SV_StartBug> vpx_free ( cr ) ; <S2SV_EndBug> }
CWE-200 static void save_text_if_changed ( const char * name , const char * new_value ) { if ( ! g_hash_table_lookup ( g_loaded_texts , name ) ) return ; const char * old_value = g_cd ? problem_data_get_content_or_NULL ( g_cd , name ) : "" ; if ( ! old_value ) old_value = "" ; if ( strcmp ( new_value , old_value ) != 0 ) { struct dump_dir * dd = wizard_open_directory_for_writing ( g_dump_dir_name ) ; if ( dd ) dd_save_text ( dd , name , new_value ) ; dd_close ( dd ) ; <S2SV_StartBug> problem_data_reload_from_dump_dir ( ) ; <S2SV_EndBug> update_gui_state_from_problem_data ( 0 ) ; } }
CWE-000 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 ; ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = refcount_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> strlcpy ( rl . type , "larval" , sizeof ( rl . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_ACOMPRESS : if ( crypto_report_acomp ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_AKCIPHER : if ( crypto_report_akcipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_KPP : if ( crypto_report_kpp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-200 static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rose_sock * rose = rose_sk ( sk ) ; struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( srose != NULL ) { <S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }
CWE-416 static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_mco_size ; opj_tcp_t * l_tcp = 00 ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; OPJ_UINT32 i ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; <S2SV_StartBug> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <S2SV_EndBug> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>write<S2SV_blank>MCO<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } <S2SV_StartBug> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <S2SV_EndBug> l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; ++ l_current_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { opj_write_bytes ( l_current_data , l_mcc_record -> m_index , 1 ) ; ++ l_current_data ; ++ l_mcc_record ; } if ( opj_stream_write_data ( p_stream , p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size , p_manager ) != l_mco_size ) { return OPJ_FALSE ; } return OPJ_TRUE ; }
CWE-20 static struct dst_entry * ip6_sk_dst_check ( struct sock * sk , struct dst_entry * dst , const struct flowi6 * fl6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> if ( ! dst ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) { dst_release ( dst ) ; dst = NULL ; } out : return dst ; }
CWE-000 int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; int family = sk -> sk_family ; struct sk_buff * skb ; int copied , err ; pr_debug ( "ping_recvmsg(sk=%p,sk->num=%u)\\n" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) { struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_StartBug> sin -> sin_family = AF_INET ; <S2SV_EndBug> sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_StartBug> sin6 -> sin6_family = AF_INET6 ; <S2SV_EndBug> sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ; <S2SV_StartBug> * addr_len = sizeof ( * sin6 ) ; <S2SV_EndBug> if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( "ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n" , err ) ; return err ; }
CWE-119 <S2SV_StartBug> static void save_context ( VP9_COMP * cpi , int mi_row , int mi_col , <S2SV_EndBug> ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) { <S2SV_StartBug> const MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> const MACROBLOCKD * const xd = & x -> e_mbd ; int p ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; for ( p = 0 ; p < MAX_MB_PLANE ; ++ p ) { <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> a + num_4x4_blocks_wide * p , xd -> above_context [ p ] + ( mi_col * 2 >> xd -> plane [ p ] . subsampling_x ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ; <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> l + num_4x4_blocks_high * p , xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ; } <S2SV_StartBug> vpx_memcpy ( sa , xd -> above_seg_context + mi_col , <S2SV_EndBug> sizeof ( * xd -> above_seg_context ) * mi_width ) ; <S2SV_StartBug> vpx_memcpy ( sl , xd -> left_seg_context + ( mi_row & MI_MASK ) , <S2SV_EndBug> sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ; }
CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; j ++ ; szLine [ i ] &= 0xbf ; } else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } szLineConv [ j ] = szLine [ i ] ; j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; <S2SV_StartBug> szLineConv [ i ] = 0 ; <S2SV_EndBug> strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }
CWE-119 protected int file_check_mem ( struct magic_set * ms , unsigned int level ) { size_t len ; if ( level >= ms -> c . len ) { <S2SV_StartBug> len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ; <S2SV_EndBug> ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ; if ( ms -> c . li == NULL ) { file_oomem ( ms , len ) ; return - 1 ; } } ms -> c . li [ level ] . got_match = 0 ; # ifdef ENABLE_CONDITIONALS ms -> c . li [ level ] . last_match = 0 ; ms -> c . li [ level ] . last_cond = COND_NONE ; # endif return 0 ; }
CWE-119 <S2SV_StartBug> static void write_selected_tx_size ( const VP9_COMP * cpi , <S2SV_EndBug> TX_SIZE tx_size , BLOCK_SIZE bsize , <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ; <S2SV_StartBug> const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> const vp9_prob * const tx_probs = get_tx_probs2 ( max_tx_size , xd , <S2SV_StartBug> & cpi -> common . fc . tx_probs ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write ( w , tx_size != TX_4X4 , tx_probs [ 0 ] ) ; <S2SV_EndBug> if ( tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) { <S2SV_StartBug> vp9_write ( w , tx_size != TX_8X8 , tx_probs [ 1 ] ) ; <S2SV_EndBug> if ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 ) <S2SV_StartBug> vp9_write ( w , tx_size != TX_16X16 , tx_probs [ 2 ] ) ; <S2SV_EndBug> } }
CWE-119 static int read_compressed_header ( VP9Decoder * pbi , const uint8_t * data , size_t partition_size ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> vp9_reader r ; int k ; <S2SV_StartBug> if ( vp9_reader_init ( & r , data , partition_size ) ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0" ) ; cm -> tx_mode = xd -> lossless ? ONLY_4X4 : read_tx_mode ( & r ) ; if ( cm -> tx_mode == TX_MODE_SELECT ) read_tx_mode_probs ( & fc -> tx_probs , & r ) ; read_coef_probs ( fc , cm -> tx_mode , & r ) ; for ( k = 0 ; k < SKIP_CONTEXTS ; ++ k ) vp9_diff_update_prob ( & r , & fc -> skip_probs [ k ] ) ; if ( ! frame_is_intra_only ( cm ) ) { nmv_context * const nmvc = & fc -> nmvc ; int i , j ; read_inter_mode_probs ( fc , & r ) ; if ( cm -> interp_filter == SWITCHABLE ) read_switchable_interp_probs ( fc , & r ) ; for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) vp9_diff_update_prob ( & r , & fc -> intra_inter_prob [ i ] ) ; cm -> reference_mode = read_frame_reference_mode ( cm , & r ) ; if ( cm -> reference_mode != SINGLE_REFERENCE ) setup_compound_reference_mode ( cm ) ; read_frame_reference_mode_probs ( cm , & r ) ; for ( j = 0 ; j < BLOCK_SIZE_GROUPS ; j ++ ) for ( i = 0 ; i < INTRA_MODES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> y_mode_prob [ j ] [ i ] ) ; for ( j = 0 ; j < PARTITION_CONTEXTS ; ++ j ) for ( i = 0 ; i < PARTITION_TYPES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> partition_prob [ j ] [ i ] ) ; read_mv_probs ( nmvc , cm -> allow_high_precision_mv , & r ) ; } <S2SV_StartBug> return vp9_reader_has_error ( & r ) ; <S2SV_EndBug> }
CWE-125 void decnet_print ( netdissect_options * ndo , register const u_char * ap , register u_int length , register u_int caplen ) { register const union routehdr * rhp ; register int mflags ; int dst , src , hops ; u_int nsplen , pktlen ; const u_char * nspp ; if ( length < sizeof ( struct shorthdr ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; } ND_TCHECK2 ( * ap , sizeof ( short ) ) ; pktlen = EXTRACT_LE_16BITS ( ap ) ; if ( pktlen < sizeof ( struct shorthdr ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; } if ( pktlen > length ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; } length = pktlen ; rhp = ( const union routehdr * ) & ( ap [ sizeof ( short ) ] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ; mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ; if ( mflags & RMF_PAD ) { u_int padlen = mflags & RMF_PADMASK ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "[pad:%d]<S2SV_blank>" , padlen ) ) ; if ( length < padlen + 2 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; } ND_TCHECK2 ( ap [ sizeof ( short ) ] , padlen ) ; ap += padlen ; length -= padlen ; caplen -= padlen ; rhp = ( const union routehdr * ) & ( ap [ sizeof ( short ) ] ) ; <S2SV_StartBug> mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ; <S2SV_EndBug> } if ( mflags & RMF_FVER ) { ND_PRINT ( ( ndo , "future-version-decnet" ) ) ; ND_DEFAULTPRINT ( ap , min ( length , caplen ) ) ; return ; } if ( mflags & RMF_CTLMSG ) { if ( ! print_decnet_ctlmsg ( ndo , rhp , length , caplen ) ) goto trunc ; return ; } switch ( mflags & RMF_MASK ) { case RMF_LONG : if ( length < sizeof ( struct longhdr ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; } ND_TCHECK ( rhp -> rh_long ) ; dst = EXTRACT_LE_16BITS ( rhp -> rh_long . lg_dst . dne_remote . dne_nodeaddr ) ; src = EXTRACT_LE_16BITS ( rhp -> rh_long . lg_src . dne_remote . dne_nodeaddr ) ; hops = EXTRACT_LE_8BITS ( rhp -> rh_long . lg_visits ) ; nspp = & ( ap [ sizeof ( short ) + sizeof ( struct longhdr ) ] ) ; nsplen = length - sizeof ( struct longhdr ) ; break ; case RMF_SHORT : ND_TCHECK ( rhp -> rh_short ) ; dst = EXTRACT_LE_16BITS ( rhp -> rh_short . sh_dst ) ; src = EXTRACT_LE_16BITS ( rhp -> rh_short . sh_src ) ; hops = ( EXTRACT_LE_8BITS ( rhp -> rh_short . sh_visits ) & VIS_MASK ) + 1 ; nspp = & ( ap [ sizeof ( short ) + sizeof ( struct shorthdr ) ] ) ; nsplen = length - sizeof ( struct shorthdr ) ; break ; default : ND_PRINT ( ( ndo , "unknown<S2SV_blank>message<S2SV_blank>flags<S2SV_blank>under<S2SV_blank>mask" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , min ( length , caplen ) ) ; return ; } ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>" , dnaddr_string ( ndo , src ) , dnaddr_string ( ndo , dst ) , pktlen ) ) ; if ( ndo -> ndo_vflag ) { if ( mflags & RMF_RQR ) ND_PRINT ( ( ndo , "RQR<S2SV_blank>" ) ) ; if ( mflags & RMF_RTS ) ND_PRINT ( ( ndo , "RTS<S2SV_blank>" ) ) ; if ( mflags & RMF_IE ) ND_PRINT ( ( ndo , "IE<S2SV_blank>" ) ) ; ND_PRINT ( ( ndo , "%d<S2SV_blank>hops<S2SV_blank>" , hops ) ) ; } if ( ! print_nsp ( ndo , nspp , nsplen ) ) goto trunc ; return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return ; }
CWE-119 <S2SV_StartBug> static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int hbs , int mi_row , int mi_col , <S2SV_StartBug> PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) { <S2SV_EndBug> const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; <S2SV_EndBug> const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ; const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ; if ( has_rows && has_cols ) { vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ; } else if ( ! has_rows && has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ; <S2SV_EndBug> } else if ( has_rows && ! has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ; <S2SV_EndBug> } else { assert ( p == PARTITION_SPLIT ) ; } }
CWE-000 int xfs_attr3_leaf_getvalue ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; int valuelen ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; ASSERT ( args -> index < ichdr . count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; ASSERT ( name_loc -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) == 0 ) ; valuelen = be16_to_cpu ( name_loc -> valuelen ) ; if ( args -> flags & ATTR_KERNOVAL ) { args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } args -> valuelen = valuelen ; memcpy ( args -> value , & name_loc -> nameval [ args -> namelen ] , valuelen ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; ASSERT ( name_rmt -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) == 0 ) ; <S2SV_StartBug> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , <S2SV_StartBug> valuelen ) ; <S2SV_EndBug> if ( args -> flags & ATTR_KERNOVAL ) { <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( args -> valuelen < valuelen ) { <S2SV_EndBug> args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } <S2SV_StartBug> args -> valuelen = valuelen ; <S2SV_EndBug> } return 0 ; }
CWE-000 <S2SV_StartBug> static int udf_translate_to_linux ( uint8_t * newName , uint8_t * udfName , <S2SV_EndBug> <S2SV_StartBug> int udfLen , uint8_t * fidName , <S2SV_EndBug> int fidNameLen ) { int index , newIndex = 0 , needsCRC = 0 ; int extIndex = 0 , newExtIndex = 0 , hasExt = 0 ; unsigned short valueCRC ; uint8_t curr ; if ( udfName [ 0 ] == '.' && ( udfLen == 1 || ( udfLen == 2 && udfName [ 1 ] == '.' ) ) ) { needsCRC = 1 ; newIndex = udfLen ; memcpy ( newName , udfName , udfLen ) ; } else { for ( index = 0 ; index < udfLen ; index ++ ) { curr = udfName [ index ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( index + 1 < udfLen && ( udfName [ index + 1 ] == '/' || udfName [ index + 1 ] == 0 ) ) index ++ ; } if ( curr == EXT_MARK && ( udfLen - index - 1 ) <= EXT_SIZE ) { if ( udfLen == index + 1 ) hasExt = 0 ; else { hasExt = 1 ; extIndex = index ; newExtIndex = newIndex ; } } <S2SV_StartBug> if ( newIndex < 256 ) <S2SV_EndBug> newName [ newIndex ++ ] = curr ; else needsCRC = 1 ; } } if ( needsCRC ) { uint8_t ext [ EXT_SIZE ] ; int localExtIndex = 0 ; if ( hasExt ) { int maxFilenameLen ; for ( index = 0 ; index < EXT_SIZE && extIndex + index + 1 < udfLen ; index ++ ) { curr = udfName [ extIndex + index + 1 ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( extIndex + index + 2 < udfLen && ( index + 1 < EXT_SIZE && ( udfName [ extIndex + index + 2 ] == '/' || udfName [ extIndex + index + 2 ] == 0 ) ) ) index ++ ; } ext [ localExtIndex ++ ] = curr ; } <S2SV_StartBug> maxFilenameLen = 250 - localExtIndex ; <S2SV_EndBug> if ( newIndex > maxFilenameLen ) newIndex = maxFilenameLen ; else newIndex = newExtIndex ; <S2SV_StartBug> } else if ( newIndex > 250 ) <S2SV_EndBug> newIndex = 250 ; newName [ newIndex ++ ] = CRC_MARK ; valueCRC = crc_itu_t ( 0 , fidName , fidNameLen ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC >> 8 ) ; newName [ newIndex ++ ] = hex_asc_upper_hi ( valueCRC ) ; newName [ newIndex ++ ] = hex_asc_upper_lo ( valueCRC ) ; if ( hasExt ) { newName [ newIndex ++ ] = EXT_MARK ; for ( index = 0 ; index < localExtIndex ; index ++ ) newName [ newIndex ++ ] = ext [ index ] ; } } return newIndex ; }
CWE-125 int _yr_scan_verify_re_match ( YR_SCAN_CONTEXT * context , YR_AC_MATCH * ac_match , uint8_t * data , size_t data_size , size_t data_base , size_t offset ) { CALLBACK_ARGS callback_args ; RE_EXEC_FUNC exec ; int forward_matches = - 1 ; int backward_matches = - 1 ; int flags = 0 ; if ( STRING_IS_GREEDY_REGEXP ( ac_match -> string ) ) flags |= RE_FLAGS_GREEDY ; if ( STRING_IS_NO_CASE ( ac_match -> string ) ) flags |= RE_FLAGS_NO_CASE ; if ( STRING_IS_DOT_ALL ( ac_match -> string ) ) flags |= RE_FLAGS_DOT_ALL ; if ( STRING_IS_FAST_REGEXP ( ac_match -> string ) ) exec = yr_re_fast_exec ; else exec = yr_re_exec ; if ( STRING_IS_ASCII ( ac_match -> string ) ) { forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> NULL , NULL ) ; } if ( STRING_IS_WIDE ( ac_match -> string ) && forward_matches == - 1 ) { flags |= RE_FLAGS_WIDE ; forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> NULL , NULL ) ; } switch ( forward_matches ) { case - 1 : return ERROR_SUCCESS ; case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } if ( forward_matches == 0 && ac_match -> backward_code == NULL ) return ERROR_SUCCESS ; callback_args . string = ac_match -> string ; callback_args . context = context ; callback_args . data = data ; callback_args . data_size = data_size ; callback_args . data_base = data_base ; callback_args . forward_matches = forward_matches ; callback_args . full_word = STRING_IS_FULL_WORD ( ac_match -> string ) ; if ( ac_match -> backward_code != NULL ) { backward_matches = exec ( ac_match -> backward_code , <S2SV_StartBug> data + offset , <S2SV_EndBug> offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ; switch ( backward_matches ) { case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } } else { FAIL_ON_ERROR ( _yr_scan_match_callback ( data + offset , 0 , flags , & callback_args ) ) ; } return ERROR_SUCCESS ; }
CWE-190 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; } return - EINVAL ; }
CWE-119 int mndp_add_attribute ( struct mt_packet * packet , enum mt_mndp_attrtype attrtype , void * attrdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned short type = attrtype ; unsigned short len = data_len ; <S2SV_StartBug> if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( "mndp_add_attribute:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n" ) , MT_PACKET_LEN ) ; return - 1 ; } type = htons ( type ) ; memcpy ( data , & type , sizeof ( type ) ) ; len = htons ( len ) ; memcpy ( data + 2 , & len , sizeof ( len ) ) ; memcpy ( data + 4 , attrdata , data_len ) ; packet -> size += 4 + data_len ; return 4 + data_len ; }
CWE-200 long vorbis_book_decodev_set ( codebook * book , ogg_int32_t * a , oggpack_buffer * b , int n , int point ) { if ( book -> used_entries > 0 ) { ogg_int32_t * v = book -> dec_buf ; int i , j ; if ( ! v ) return - 1 ; for ( i = 0 ; i < n ; ) { if ( decode_map ( book , b , v , point ) ) return - 1 ; <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> a [ i ++ ] = v [ j ] ; } } else { int i , j ; for ( i = 0 ; i < n ; ) { <S2SV_StartBug> for ( j = 0 ; j < book -> dim ; j ++ ) <S2SV_EndBug> a [ i ++ ] = 0 ; } } return 0 ; }
CWE-119 static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , "reg" , & cs ) ) { dev_err ( dev , "Couldn\'t<S2SV_blank>determine<S2SV_blank>chip<S2SV_blank>select.\\n" ) ; goto err ; } <S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> dev_err ( dev , "Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\n" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , "%s.%d" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }
CWE-416 int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = NULL ; struct iov_iter i ; int ret ; <S2SV_StartBug> if ( map_data ) <S2SV_EndBug> copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , BIO_USER_MAPPED ) ) rq -> cmd_flags |= REQ_COPY_USER ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ; <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug> return - EINVAL ; }
CWE-119 int au1100fb_fb_mmap ( struct fb_info * fbi , struct vm_area_struct * vma ) { struct au1100fb_device * fbdev ; <S2SV_StartBug> unsigned int len ; <S2SV_EndBug> unsigned long start = 0 , off ; <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= ( 6 << 9 ) ; <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) { return - EAGAIN ; } return 0 ; }
CWE-119 <S2SV_StartBug> static void show_psnr ( struct stream_state * stream ) { <S2SV_EndBug> int i ; double ovpsnr ; if ( ! stream -> psnr_count ) return ; fprintf ( stderr , "Stream<S2SV_blank>%d<S2SV_blank>PSNR<S2SV_blank>(Overall/Avg/Y/U/V)" , stream -> index ) ; <S2SV_StartBug> ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 , <S2SV_EndBug> ( double ) stream -> psnr_sse_total ) ; fprintf ( stderr , "<S2SV_blank>%.3f" , ovpsnr ) ; for ( i = 0 ; i < 4 ; i ++ ) { fprintf ( stderr , "<S2SV_blank>%.3f" , stream -> psnr_totals [ i ] / stream -> psnr_count ) ; } fprintf ( stderr , "\\n" ) ; }
CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '<S2SV_blank>' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { <S2SV_StartBug> int a = getnum ( L , fmt , MAXALIGN ) ; <S2SV_EndBug> if ( ! isp2 ( a ) ) luaL_error ( L , "alignment<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>2" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , "invalid<S2SV_blank>format<S2SV_blank>option<S2SV_blank>\'%c\'" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }
CWE-119 static uint64_t calc_plane_error ( unsigned char * orig , int orig_stride , unsigned char * recon , int recon_stride , unsigned int cols , unsigned int rows ) { unsigned int row , col ; uint64_t total_sse = 0 ; int diff ; for ( row = 0 ; row + 16 <= rows ; row += 16 ) { for ( col = 0 ; col + 16 <= cols ; col += 16 ) { unsigned int sse ; <S2SV_StartBug> vp8_mse16x16 ( orig + col , orig_stride , <S2SV_EndBug> recon + col , recon_stride , & sse ) ; total_sse += sse ; } if ( col < cols ) { unsigned int border_row , border_col ; unsigned char * border_orig = orig ; unsigned char * border_recon = recon ; for ( border_row = 0 ; border_row < 16 ; border_row ++ ) { for ( border_col = col ; border_col < cols ; border_col ++ ) { diff = border_orig [ border_col ] - border_recon [ border_col ] ; total_sse += diff * diff ; } border_orig += orig_stride ; border_recon += recon_stride ; } } orig += orig_stride * 16 ; recon += recon_stride * 16 ; } for ( ; row < rows ; row ++ ) { for ( col = 0 ; col < cols ; col ++ ) { diff = orig [ col ] - recon [ col ] ; total_sse += diff * diff ; } orig += orig_stride ; recon += recon_stride ; } vp8_clear_system_state ( ) ; return total_sse ; }
CWE-20 static void llc_sap_rcv ( struct llc_sap * sap , struct sk_buff * skb , struct sock * sk ) { struct llc_sap_state_ev * ev = llc_sap_ev ( skb ) ; ev -> type = LLC_SAP_EV_TYPE_PDU ; ev -> reason = 0 ; <S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug> llc_sap_state_process ( sap , skb ) ; }
CWE-362 static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { <S2SV_StartBug> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <S2SV_EndBug> flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }
CWE-125 int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , <S2SV_StartBug> size_t input_size , <S2SV_EndBug> int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; <S2SV_StartBug> int max_bytes_matched = input_size ; <S2SV_EndBug> input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { int cb_result = callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } break ; } else { return bytes_matched ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { next_input = input + i * input_incr ; if ( bytes_matched + i >= max_bytes_matched ) break ; if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; ip = next_opcode ; break ; default : assert ( FALSE ) ; } } } return - 1 ; }
CWE-264 static int raw_cmd_copyout ( int cmd , void __user * param , struct floppy_raw_cmd * ptr ) { int ret ; while ( ptr ) { <S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> if ( ret ) return - EFAULT ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ( ptr -> flags & FD_RAW_READ ) && ptr -> buffer_length ) { if ( ptr -> length >= 0 && ptr -> length <= ptr -> buffer_length ) { long length = ptr -> buffer_length - ptr -> length ; ret = fd_copyout ( ptr -> data , ptr -> kernel_data , length ) ; if ( ret ) return ret ; } } ptr = ptr -> next ; } return 0 ; }
CWE-119 <S2SV_StartBug> static SvcInternal * get_svc_internal ( SvcContext * svc_ctx ) { <S2SV_EndBug> if ( svc_ctx == NULL ) return NULL ; if ( svc_ctx -> internal == NULL ) { <S2SV_StartBug> SvcInternal * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ; <S2SV_EndBug> if ( si != NULL ) { memset ( si , 0 , sizeof ( * si ) ) ; } svc_ctx -> internal = si ; } <S2SV_StartBug> return ( SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> }
CWE-125 static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u" , tok2str ( lmp_data_link_subobj , "Unknown" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_switch_cap_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_encoding_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-399 static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; sixel_buffer [ length ] = '\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) { <S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , "NotEnoughPixelData" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-200 static void * __alloc_from_pool ( size_t size , struct page * * ret_page , gfp_t flags ) { unsigned long val ; void * ptr = NULL ; if ( ! atomic_pool ) { WARN ( 1 , "coherent<S2SV_blank>pool<S2SV_blank>not<S2SV_blank>initialised!\\n" ) ; return NULL ; } val = gen_pool_alloc ( atomic_pool , size ) ; if ( val ) { phys_addr_t phys = gen_pool_virt_to_phys ( atomic_pool , val ) ; * ret_page = phys_to_page ( phys ) ; ptr = ( void * ) val ; <S2SV_StartBug> if ( flags & __GFP_ZERO ) <S2SV_EndBug> memset ( ptr , 0 , size ) ; } return ptr ; }
CWE-362 void sctp_generate_heartbeat_event ( unsigned long data ) { int error = 0 ; struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( "%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n" , __func__ ) ; if ( ! mod_timer ( & transport -> hb_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_HEARTBEAT ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }
CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , "Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n" , expr -> expr . op ) ; return false ; }
CWE-20 static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { <S2SV_StartBug> u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; <S2SV_EndBug> switch ( mode ) { case PSR_AA32_MODE_USR : <S2SV_StartBug> case PSR_AA32_MODE_FIQ : <S2SV_EndBug> case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : <S2SV_StartBug> case PSR_MODE_EL0t : <S2SV_EndBug> case PSR_MODE_EL1t : <S2SV_StartBug> case PSR_MODE_EL1h : <S2SV_EndBug> break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }
CWE-787 static int next_state_class ( CClassNode * cc , OnigCodePoint * vs , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; if ( * state == CCS_RANGE ) return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE ; if ( * state == CCS_VALUE && * type != CCV_CLASS ) { if ( * type == CCV_SB ) BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } } <S2SV_StartBug> * state = CCS_VALUE ; <S2SV_EndBug> * type = CCV_CLASS ; return 0 ; }
CWE-119 static vpx_codec_err_t ctrl_set_dbg_options ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER && CONFIG_POSTPROC <S2SV_EndBug> int data = va_arg ( args , int ) ; # define MAP ( id , var ) case id : var = data ; break ; switch ( ctrl_id ) { MAP ( VP8_SET_DBG_COLOR_REF_FRAME , ctx -> dbg_color_ref_frame_flag ) ; MAP ( VP8_SET_DBG_COLOR_MB_MODES , ctx -> dbg_color_mb_modes_flag ) ; MAP ( VP8_SET_DBG_COLOR_B_MODES , ctx -> dbg_color_b_modes_flag ) ; MAP ( VP8_SET_DBG_DISPLAY_MV , ctx -> dbg_display_mv_flag ) ; } return VPX_CODEC_OK ; # else return VPX_CODEC_INCAPABLE ; <S2SV_StartBug> # endif <S2SV_EndBug> }
CWE-362 int inet_sk_rebuild_header ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; struct rtable * rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ; __be32 daddr ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( rt ) return 0 ; <S2SV_StartBug> daddr = inet -> inet_daddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> daddr = inet -> opt -> faddr ; rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! IS_ERR ( rt ) ) { err = 0 ; sk_setup_caps ( sk , & rt -> dst ) ; } else { err = PTR_ERR ( rt ) ; sk -> sk_route_caps = 0 ; if ( ! sysctl_ip_dynaddr || sk -> sk_state != TCP_SYN_SENT || ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) || ( err = inet_sk_reselect_saddr ( sk ) ) != 0 ) sk -> sk_err_soft = - err ; } return err ; }
CWE-000 static int ims_pcu_parse_cdc_data ( struct usb_interface * intf , struct ims_pcu * pcu ) { const struct usb_cdc_union_desc * union_desc ; struct usb_host_interface * alt ; union_desc = ims_pcu_get_cdc_union_desc ( intf ) ; if ( ! union_desc ) return - EINVAL ; pcu -> ctrl_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bMasterInterface0 ) ; <S2SV_StartBug> alt = pcu -> ctrl_intf -> cur_altsetting ; <S2SV_EndBug> pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ; pcu -> max_ctrl_size = usb_endpoint_maxp ( pcu -> ep_ctrl ) ; pcu -> data_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bSlaveInterface0 ) ; <S2SV_StartBug> alt = pcu -> data_intf -> cur_altsetting ; <S2SV_EndBug> if ( alt -> desc . bNumEndpoints != 2 ) { dev_err ( pcu -> dev , "Incorrect<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>(%d)\\n" , alt -> desc . bNumEndpoints ) ; return - EINVAL ; } pcu -> ep_out = & alt -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_bulk_out ( pcu -> ep_out ) ) { dev_err ( pcu -> dev , "First<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>OUT\\n" ) ; return - EINVAL ; } pcu -> max_out_size = usb_endpoint_maxp ( pcu -> ep_out ) ; if ( pcu -> max_out_size < 8 ) { dev_err ( pcu -> dev , "Max<S2SV_blank>OUT<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n" , pcu -> max_out_size ) ; return - EINVAL ; } pcu -> ep_in = & alt -> endpoint [ 1 ] . desc ; if ( ! usb_endpoint_is_bulk_in ( pcu -> ep_in ) ) { dev_err ( pcu -> dev , "Second<S2SV_blank>endpoint<S2SV_blank>on<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>not<S2SV_blank>BULK<S2SV_blank>IN\\n" ) ; return - EINVAL ; } pcu -> max_in_size = usb_endpoint_maxp ( pcu -> ep_in ) ; if ( pcu -> max_in_size < 8 ) { dev_err ( pcu -> dev , "Max<S2SV_blank>IN<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%zd)\\n" , pcu -> max_in_size ) ; return - EINVAL ; } return 0 ; }
CWE-399 static int br_mdb_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net_device * dev ; struct net * net = sock_net ( skb -> sk ) ; struct nlmsghdr * nlh = NULL ; int idx = 0 , s_idx ; s_idx = cb -> args [ 0 ] ; rcu_read_lock ( ) ; cb -> seq = net -> dev_base_seq + br_mdb_rehash_seq ; for_each_netdev_rcu ( net , dev ) { if ( dev -> priv_flags & IFF_EBRIDGE ) { struct br_port_msg * bpm ; if ( idx < s_idx ) goto skip ; nlh = nlmsg_put ( skb , NETLINK_CB ( cb -> skb ) . portid , cb -> nlh -> nlmsg_seq , RTM_GETMDB , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( nlh == NULL ) break ; <S2SV_StartBug> bpm = nlmsg_data ( nlh ) ; <S2SV_EndBug> bpm -> ifindex = dev -> ifindex ; if ( br_mdb_fill_info ( skb , cb , dev ) < 0 ) goto out ; if ( br_rports_fill_info ( skb , cb , dev ) < 0 ) goto out ; cb -> args [ 1 ] = 0 ; nlmsg_end ( skb , nlh ) ; skip : idx ++ ; } } out : if ( nlh ) nlmsg_end ( skb , nlh ) ; rcu_read_unlock ( ) ; cb -> args [ 0 ] = idx ; return skb -> len ; }
CWE-119 static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) { YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp9_copy_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
CWE-119 static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> const int ref_frame_flags = va_arg ( args , int ) ; vp9_update_reference ( ctx -> cpi , ref_frame_flags ) ; return VPX_CODEC_OK ; }
CWE-000 static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; <S2SV_StartBug> assert ( name ) ; <S2SV_EndBug> r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? "\\033%G" : "\\033%@" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>UTF-8<S2SV_blank>term<S2SV_blank>processing<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , "Failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>iutf8<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" , enable_disable ( utf8 ) , name ) ; log_debug ( "UTF-8<S2SV_blank>kbdmode<S2SV_blank>%sd<S2SV_blank>on<S2SV_blank>%s" , enable_disable ( utf8 ) , name ) ; return 0 ; }
CWE-000 static int mount_autodev ( const char * name , const struct lxc_rootfs * rootfs , const char * lxcpath ) { int ret ; size_t clen ; char * path ; INFO ( "Mounting<S2SV_blank>container<S2SV_blank>/dev" ) ; clen = ( rootfs -> path ? strlen ( rootfs -> mount ) : 0 ) + 9 ; path = alloca ( clen ) ; ret = snprintf ( path , clen , "%s/dev" , rootfs -> path ? rootfs -> mount : "" ) ; if ( ret < 0 || ret >= clen ) return - 1 ; if ( ! dir_exists ( path ) ) { WARN ( "No<S2SV_blank>/dev<S2SV_blank>in<S2SV_blank>container." ) ; WARN ( "Proceeding<S2SV_blank>without<S2SV_blank>autodev<S2SV_blank>setup" ) ; return 0 ; } <S2SV_StartBug> if ( mount ( "none" , path , "tmpfs" , 0 , "size=100000,mode=755" ) ) { <S2SV_EndBug> SYSERROR ( "Failed<S2SV_blank>mounting<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s\\n" , path ) ; return false ; } INFO ( "Mounted<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s" , path ) ; ret = snprintf ( path , clen , "%s/dev/pts" , rootfs -> path ? rootfs -> mount : "" ) ; if ( ret < 0 || ret >= clen ) return - 1 ; if ( ! dir_exists ( path ) ) { ret = mkdir ( path , S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH ) ; if ( ret ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>/dev/pts<S2SV_blank>in<S2SV_blank>container" ) ; return - 1 ; } } INFO ( "Mounted<S2SV_blank>container<S2SV_blank>/dev" ) ; return 0 ; }
CWE-284 static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags , <S2SV_StartBug> struct in6_addr * addr , uint32_t * ifindex ) <S2SV_EndBug> { struct sockaddr_in6 sin6 ; <S2SV_StartBug> unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ; <S2SV_EndBug> struct iovec iovec ; struct msghdr msghdr ; struct cmsghdr * cmsghdr ; ssize_t len ; iovec . iov_len = * buflen ; iovec . iov_base = buf ; memset ( & msghdr , 0 , sizeof ( msghdr ) ) ; msghdr . msg_name = & sin6 ; msghdr . msg_namelen = sizeof ( sin6 ) ; msghdr . msg_iov = & iovec ; msghdr . msg_iovlen = 1 ; msghdr . msg_control = cbuf ; msghdr . msg_controllen = sizeof ( cbuf ) ; len = recvmsg ( sockfd , & msghdr , flags ) ; if ( len == - 1 ) return - errno ; * buflen = len ; * ifindex = sin6 . sin6_scope_id ; for ( cmsghdr = CMSG_FIRSTHDR ( & msghdr ) ; cmsghdr ; cmsghdr = CMSG_NXTHDR ( & msghdr , cmsghdr ) ) { <S2SV_StartBug> if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 && <S2SV_EndBug> <S2SV_StartBug> cmsghdr -> cmsg_type == IPV6_PKTINFO && <S2SV_EndBug> cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) { struct in6_pktinfo * pktinfo ; pktinfo = ( struct in6_pktinfo * ) CMSG_DATA ( cmsghdr ) ; * ifindex = pktinfo -> ipi6_ifindex ; } <S2SV_StartBug> } <S2SV_EndBug> * addr = sin6 . sin6_addr ; return 0 ; }
CWE-189 Datum poly_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; POLYGON * poly ; int npts ; int size ; <S2SV_StartBug> int isopen ; <S2SV_EndBug> char * s ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\"%s\\"" , str ) ) ) ; <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> poly = ( POLYGON * ) palloc0 ( size ) ; SET_VARSIZE ( poly , size ) ; poly -> npts = npts ; if ( ( ! path_decode ( FALSE , npts , str , & isopen , & s , & ( poly -> p [ 0 ] ) ) ) || ( * s != '\\0' ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\"%s\\"" , str ) ) ) ; make_bound_box ( poly ) ; PG_RETURN_POLYGON_P ( poly ) ; }
CWE-119 static void write_image_file ( const vpx_image_t * img , const int planes [ 3 ] , FILE * file ) { <S2SV_StartBug> int i , y ; <S2SV_EndBug> for ( i = 0 ; i < 3 ; ++ i ) { const int plane = planes [ i ] ; const unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; const int w = vpx_img_plane_width ( img , plane ) ; const int h = vpx_img_plane_height ( img , plane ) ; for ( y = 0 ; y < h ; ++ y ) { <S2SV_StartBug> fwrite ( buf , 1 , w , file ) ; <S2SV_EndBug> buf += stride ; } } }
CWE-119 static void scsi_dma_restart_bh ( void * opaque ) { SCSIDiskState * s = opaque ; SCSIRequest * req ; SCSIDiskReq * r ; qemu_bh_delete ( s -> bh ) ; s -> bh = NULL ; QTAILQ_FOREACH ( req , & s -> qdev . requests , next ) { r = DO_UPCAST ( SCSIDiskReq , req , req ) ; if ( r -> status & SCSI_REQ_STATUS_RETRY ) { int status = r -> status ; int ret ; r -> status &= ~ ( SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK ) ; switch ( status & SCSI_REQ_STATUS_RETRY_TYPE_MASK ) { case SCSI_REQ_STATUS_RETRY_READ : scsi_read_data ( & r -> req ) ; break ; case SCSI_REQ_STATUS_RETRY_WRITE : scsi_write_data ( & r -> req ) ; break ; case SCSI_REQ_STATUS_RETRY_FLUSH : <S2SV_StartBug> ret = scsi_disk_emulate_command ( r , r -> iov . iov_base ) ; <S2SV_EndBug> if ( ret == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } } } } }
CWE-000 static int crypto_report_comp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_comp rcomp ; <S2SV_StartBug> strlcpy ( rcomp . type , "compression" , sizeof ( rcomp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-284 bool semaphore_try_wait ( semaphore_t * semaphore ) { assert ( semaphore != NULL ) ; assert ( semaphore -> fd != INVALID_FD ) ; <S2SV_StartBug> int flags = fcntl ( semaphore -> fd , F_GETFL ) ; <S2SV_EndBug> if ( flags == - 1 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; return false ; } <S2SV_StartBug> if ( fcntl ( semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) == - 1 ) { <S2SV_EndBug> LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>O_NONBLOCK<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; return false ; } eventfd_t value ; if ( eventfd_read ( semaphore -> fd , & value ) == - 1 ) return false ; <S2SV_StartBug> if ( fcntl ( semaphore -> fd , F_SETFL , flags ) == - 1 ) <S2SV_EndBug> LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>resetore<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; return true ; }
CWE-284 static void uipc_read_task ( void * arg ) { int ch_id ; int result ; UNUSED ( arg ) ; prctl ( PR_SET_NAME , ( unsigned long ) "uipc-main" , 0 , 0 , 0 ) ; raise_priority_a2dp ( TASK_UIPC_READ ) ; while ( uipc_main . running ) { uipc_main . read_set = uipc_main . active_set ; <S2SV_StartBug> result = select ( uipc_main . max_fd + 1 , & uipc_main . read_set , NULL , NULL , NULL ) ; <S2SV_EndBug> if ( result == 0 ) { BTIF_TRACE_EVENT ( "select<S2SV_blank>timeout" ) ; continue ; } else if ( result < 0 ) { BTIF_TRACE_EVENT ( "select<S2SV_blank>failed<S2SV_blank>%s" , strerror ( errno ) ) ; continue ; } UIPC_LOCK ( ) ; uipc_check_interrupt_locked ( ) ; uipc_check_task_flags_locked ( ) ; uipc_check_fd_locked ( UIPC_CH_ID_AV_AUDIO ) ; for ( ch_id = 0 ; ch_id < UIPC_CH_NUM ; ch_id ++ ) { if ( ch_id != UIPC_CH_ID_AV_AUDIO ) uipc_check_fd_locked ( ch_id ) ; } UIPC_UNLOCK ( ) ; } BTIF_TRACE_EVENT ( "UIPC<S2SV_blank>READ<S2SV_blank>THREAD<S2SV_blank>EXITING" ) ; uipc_main_cleanup ( ) ; uipc_main . tid = 0 ; BTIF_TRACE_EVENT ( "UIPC<S2SV_blank>READ<S2SV_blank>THREAD<S2SV_blank>DONE" ) ; }
CWE-000 static void check_1_6_dummy ( kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * * passptr ) { int i ; char * password = * passptr ; <S2SV_StartBug> if ( ! ( mask & KADM5_ATTRIBUTES ) || <S2SV_EndBug> ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ; for ( i = 0 ; ( unsigned char ) password [ i ] == i + 1 ; i ++ ) ; if ( password [ i ] != '\\0' || i != 255 ) return ; * passptr = NULL ; }
CWE-190 static int readSeparateStripsIntoBuffer ( TIFF * in , uint8 * obuf , uint32 length , uint32 width , uint16 spp , struct dump_opts * dump ) { <S2SV_StartBug> int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; <S2SV_EndBug> int32 bytes_read = 0 ; <S2SV_StartBug> uint16 bps , nstrips , planar , strips_per_sample ; <S2SV_EndBug> uint32 src_rowsize , dst_rowsize , rows_processed , rps ; uint32 rows_this_strip = 0 ; tsample_t s ; tstrip_t strip ; tsize_t scanlinesize = TIFFScanlineSize ( in ) ; tsize_t stripsize = TIFFStripSize ( in ) ; unsigned char * srcbuffs [ MAX_SAMPLES ] ; unsigned char * buff = NULL ; unsigned char * dst = NULL ; if ( obuf == NULL ) { TIFFError ( "readSeparateStripsIntoBuffer" , "Invalid<S2SV_blank>buffer<S2SV_blank>argument" ) ; return ( 0 ) ; } memset ( srcbuffs , '\\0' , sizeof ( srcbuffs ) ) ; TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; if ( rps > length ) rps = length ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; src_rowsize = ( ( bps * width ) + 7 ) / 8 ; dst_rowsize = ( ( bps * width * spp ) + 7 ) / 8 ; dst = obuf ; if ( ( dump -> infile != NULL ) && ( dump -> level == 3 ) ) { dump_info ( dump -> infile , dump -> format , "" , "Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Scanline<S2SV_blank>size,<S2SV_blank>%4d<S2SV_blank>bytes" , width , length , scanlinesize ) ; dump_info ( dump -> infile , dump -> format , "" , "Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d,<S2SV_blank>Shift<S2SV_blank>width<S2SV_blank>%d" , bps , spp , shift_width ) ; } nstrips = TIFFNumberOfStrips ( in ) ; strips_per_sample = nstrips / spp ; for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { srcbuffs [ s ] = NULL ; buff = _TIFFmalloc ( stripsize ) ; if ( ! buff ) { TIFFError ( "readSeparateStripsIntoBuffer" , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>strip<S2SV_blank>read<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d" , s ) ; for ( i = 0 ; i < s ; i ++ ) _TIFFfree ( srcbuffs [ i ] ) ; return 0 ; } srcbuffs [ s ] = buff ; } rows_processed = 0 ; for ( j = 0 ; ( j < strips_per_sample ) && ( result == 1 ) ; j ++ ) { for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { buff = srcbuffs [ s ] ; strip = ( s * strips_per_sample ) + j ; bytes_read = TIFFReadEncodedStrip ( in , strip , buff , stripsize ) ; rows_this_strip = bytes_read / src_rowsize ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d" , ( unsigned long ) strip , s + 1 ) ; result = 0 ; break ; } # ifdef DEVELMODE TIFFError ( "" , "Strip<S2SV_blank>%2d,<S2SV_blank>read<S2SV_blank>%5d<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>%4d<S2SV_blank>scanlines,<S2SV_blank>shift<S2SV_blank>width<S2SV_blank>%d" , strip , bytes_read , rows_this_strip , shift_width ) ; # endif } if ( rps > rows_this_strip ) rps = rows_this_strip ; dst = obuf + ( dst_rowsize * rows_processed ) ; if ( ( bps % 8 ) == 0 ) { if ( combineSeparateSamplesBytes ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } } else { switch ( shift_width ) { case 1 : if ( combineSeparateSamples8bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 2 : if ( combineSeparateSamples16bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 3 : if ( combineSeparateSamples24bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 4 : case 5 : case 6 : case 7 : case 8 : if ( combineSeparateSamples32bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; default : TIFFError ( "readSeparateStripsIntoBuffer" , "Unsupported<S2SV_blank>bit<S2SV_blank>depth:<S2SV_blank>%d" , bps ) ; result = 0 ; break ; } } if ( ( rows_processed + rps ) > length ) { rows_processed = length ; rps = length - rows_processed ; } else rows_processed += rps ; } for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { buff = srcbuffs [ s ] ; if ( buff != NULL ) _TIFFfree ( buff ) ; } return ( result ) ; }
CWE-284 static int process_cmd_sock ( int h ) { sock_cmd_t cmd = { - 1 , 0 , 0 , 0 , 0 } ; int fd = ts [ h ] . cmd_fdr ; <S2SV_StartBug> if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) ) <S2SV_EndBug> { APPL_TRACE_ERROR ( "recv<S2SV_blank>cmd<S2SV_blank>errno:%d" , errno ) ; return FALSE ; } APPL_TRACE_DEBUG ( "cmd.id:%d" , cmd . id ) ; switch ( cmd . id ) { case CMD_ADD_FD : add_poll ( h , cmd . fd , cmd . type , cmd . flags , cmd . user_id ) ; break ; case CMD_REMOVE_FD : for ( int i = 1 ; i < MAX_POLL ; ++ i ) { poll_slot_t * poll_slot = & ts [ h ] . ps [ i ] ; if ( poll_slot -> pfd . fd == cmd . fd ) { remove_poll ( h , poll_slot , poll_slot -> flags ) ; break ; } } close ( cmd . fd ) ; break ; case CMD_WAKEUP : break ; case CMD_USER_PRIVATE : asrt ( ts [ h ] . cmd_callback ) ; if ( ts [ h ] . cmd_callback ) ts [ h ] . cmd_callback ( fd , cmd . type , cmd . flags , cmd . user_id ) ; break ; case CMD_EXIT : return FALSE ; default : APPL_TRACE_DEBUG ( "unknown<S2SV_blank>cmd:<S2SV_blank>%d" , cmd . id ) ; break ; } return TRUE ; }
CWE-399 static void do_free_upto ( BIO * f , BIO * upto ) { if ( upto ) { BIO * tbio ; do { tbio = BIO_pop ( f ) ; BIO_free ( f ) ; f = tbio ; } <S2SV_StartBug> while ( f != upto ) ; <S2SV_EndBug> } else BIO_free_all ( f ) ; }
CWE-119 static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ; <S2SV_StartBug> in_uint16_le ( s , type ) ; <S2SV_EndBug> in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , "cliprdr_process(),<S2SV_blank>type=%d,<S2SV_blank>status=%d,<S2SV_blank>length=%d" , type , status , length ) ; <S2SV_StartBug> if ( status == CLIPRDR_ERROR ) <S2SV_EndBug> { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , "cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>error<S2SV_blank>(type=%d)" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , "cliprdr_process(),<S2SV_blank>unhandled<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>%d" , type ) ; } }
CWE-20 static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { sco_conn_defer_accept ( pi -> conn -> hcon , pi -> setting ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }
CWE-125 static int isis_print_is_reach_subtlv ( netdissect_options * ndo , const uint8_t * tptr , u_int subt , u_int subl , const char * ident ) { u_int te_class , priority_level , gmpls_switch_cap ; union { float f ; uint32_t i ; } bw ; ND_PRINT ( ( ndo , "%s%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u" , ident , tok2str ( isis_ext_is_reach_subtlv_values , "unknown" , subt ) , subt , subl ) ) ; ND_TCHECK2 ( * tptr , subl ) ; switch ( subt ) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP : case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID : case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID : if ( subl >= 4 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>0x%08x" , EXTRACT_32BITS ( tptr ) ) ) ; if ( subl == 8 ) ND_PRINT ( ( ndo , ",<S2SV_blank>0x%08x" , EXTRACT_32BITS ( tptr + 4 ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR : case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR : if ( subl >= sizeof ( struct in_addr ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW : if ( subl >= 4 ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW : if ( subl >= 32 ) { for ( te_class = 0 ; te_class < 8 ; te_class ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>TE-Class<S2SV_blank>%u:<S2SV_blank>%.3f<S2SV_blank>Mbps" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } } break ; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : <S2SV_StartBug> ND_PRINT ( ( ndo , "%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)" , <S2SV_EndBug> ident , tok2str ( diffserv_te_bc_values , "unknown" , * tptr ) , * tptr ) ) ; tptr ++ ; for ( te_class = 0 ; te_class < ( subl - 1 ) / 4 ; te_class ++ ) { <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Bandwidth<S2SV_blank>constraint<S2SV_blank>CT%u:<S2SV_blank>%.3f<S2SV_blank>Mbps" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC : if ( subl >= 3 ) ND_PRINT ( ( ndo , ",<S2SV_blank>%u" , EXTRACT_24BITS ( tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE : if ( subl == 2 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]<S2SV_blank>(0x%04x)" , bittok2str ( isis_subtlv_link_attribute_values , "Unknown" , EXTRACT_16BITS ( tptr ) ) , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE : if ( subl >= 2 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u" , bittok2str ( gmpls_link_prot_values , "none" , * tptr ) , * ( tptr + 1 ) ) ) ; } break ; case ISIS_SUBTLV_SPB_METRIC : if ( subl >= 6 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>LM:<S2SV_blank>%u" , EXTRACT_24BITS ( tptr ) ) ) ; tptr = tptr + 3 ; ND_PRINT ( ( ndo , ",<S2SV_blank>P:<S2SV_blank>%u" , * ( tptr ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , ",<S2SV_blank>P-ID:<S2SV_blank>%u" , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR : if ( subl >= 36 ) { gmpls_switch_cap = * tptr ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>Switching<S2SV_blank>Capability:%s" , ident , tok2str ( gmpls_switch_cap_values , "Unknown" , gmpls_switch_cap ) ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>LSP<S2SV_blank>Encoding:<S2SV_blank>%s" , tok2str ( gmpls_encoding_values , "Unknown" , * ( tptr + 1 ) ) ) ) ; tptr += 4 ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Max<S2SV_blank>LSP<S2SV_blank>Bandwidth:" , ident ) ) ; for ( priority_level = 0 ; priority_level < 8 ; priority_level ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>priority<S2SV_blank>level<S2SV_blank>%d:<S2SV_blank>%.3f<S2SV_blank>Mbps" , ident , priority_level , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } subl -= 36 ; switch ( gmpls_switch_cap ) { case GMPLS_PSC1 : case GMPLS_PSC2 : case GMPLS_PSC3 : case GMPLS_PSC4 : ND_TCHECK2 ( * tptr , 6 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>MTU:<S2SV_blank>%u" , ident , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case GMPLS_TSC : ND_TCHECK2 ( * tptr , 8 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank><S2SV_blank>Indication<S2SV_blank>%s" , ident , tok2str ( gmpls_switch_cap_tsc_indication_values , "Unknown<S2SV_blank>(%u)" , * ( tptr + 4 ) ) ) ) ; break ; default : if ( subl > 0 ) { if ( ! print_unknown_data ( ndo , tptr , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , subl ) ) return ( 0 ) ; } } } break ; default : if ( ! print_unknown_data ( ndo , tptr , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , subl ) ) return ( 0 ) ; break ; } return ( 1 ) ; trunc : return ( 0 ) ; }
CWE-200 static void tcp_send_challenge_ack ( struct sock * sk , const struct sk_buff * skb ) { static u32 challenge_timestamp ; static unsigned int challenge_count ; struct tcp_sock * tp = tcp_sk ( sk ) ; <S2SV_StartBug> u32 now ; <S2SV_EndBug> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ; now = jiffies / HZ ; if ( now != challenge_timestamp ) { <S2SV_StartBug> challenge_timestamp = now ; <S2SV_EndBug> <S2SV_StartBug> challenge_count = 0 ; <S2SV_EndBug> } if ( ++ challenge_count <= sysctl_tcp_challenge_ack_limit ) { NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK ) ; tcp_send_ack ( sk ) ; } }
CWE-189 static ltxtquery * queryin ( char * buf ) { QPRS_STATE state ; int32 i ; ltxtquery * query ; int32 commonlen ; ITEM * ptr ; NODE * tmp ; int32 pos = 0 ; # ifdef BS_DEBUG char pbuf [ 16384 ] , * cur ; # endif state . buf = buf ; state . state = WAITOPERAND ; state . count = 0 ; state . num = 0 ; state . str = NULL ; state . sumlen = 0 ; state . lenop = 64 ; state . curop = state . op = ( char * ) palloc ( state . lenop ) ; * ( state . curop ) = '\\0' ; makepol ( & state ) ; if ( ! state . num ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( "syntax<S2SV_blank>error" ) , errdetail ( "Empty<S2SV_blank>query." ) ) ) ; <S2SV_StartBug> commonlen = COMPUTESIZE ( state . num , state . sumlen ) ; <S2SV_EndBug> query = ( ltxtquery * ) palloc ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = state . num ; ptr = GETQUERY ( query ) ; for ( i = 0 ; i < state . num ; i ++ ) { ptr [ i ] . type = state . str -> type ; ptr [ i ] . val = state . str -> val ; ptr [ i ] . distance = state . str -> distance ; ptr [ i ] . length = state . str -> length ; ptr [ i ] . flag = state . str -> flag ; tmp = state . str -> next ; pfree ( state . str ) ; state . str = tmp ; } memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; pfree ( state . op ) ; pos = 0 ; findoprnd ( ptr , & pos ) ; return query ; }
CWE-20 static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : p += 2 ; n += 2 ; len -= 2 ; break ; case 0x40 : p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : p += 4 ; n += 4 ; len -= 4 ; break ; case 0xC0 : l = p [ 1 ] ; <S2SV_StartBug> if ( * p == FAC_CCITT_DEST_NSAP ) { <S2SV_EndBug> memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }
CWE-000 static enum ofperr parse_group_prop_ntr_selection_method ( struct ofpbuf * payload , enum ofp11_group_type group_type , enum ofp15_group_mod_command group_cmd , struct ofputil_group_props * gp ) { struct ntr_group_prop_selection_method * prop = payload -> data ; size_t fields_len , method_len ; enum ofperr error ; switch ( group_type ) { case OFPGT11_SELECT : break ; case OFPGT11_ALL : case OFPGT11_INDIRECT : case OFPGT11_FF : OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>is<S2SV_blank>" "only<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>select<S2SV_blank>groups" ) ; return OFPERR_OFPBPC_BAD_VALUE ; default : <S2SV_StartBug> OVS_NOT_REACHED ( ) ; <S2SV_EndBug> } switch ( group_cmd ) { case OFPGC15_ADD : case OFPGC15_MODIFY : case OFPGC15_ADD_OR_MOD : break ; case OFPGC15_DELETE : case OFPGC15_INSERT_BUCKET : case OFPGC15_REMOVE_BUCKET : OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>is<S2SV_blank>" "only<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>add<S2SV_blank>and<S2SV_blank>delete<S2SV_blank>group<S2SV_blank>modifications" ) ; return OFPERR_OFPBPC_BAD_VALUE ; default : <S2SV_StartBug> OVS_NOT_REACHED ( ) ; <S2SV_EndBug> } if ( payload -> size < sizeof * prop ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>" "length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>not<S2SV_blank>valid" , payload -> size ) ; return OFPERR_OFPBPC_BAD_LEN ; } method_len = strnlen ( prop -> selection_method , NTR_MAX_SELECTION_METHOD_LEN ) ; if ( method_len == NTR_MAX_SELECTION_METHOD_LEN ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>is<S2SV_blank>not<S2SV_blank>null<S2SV_blank>terminated" ) ; return OFPERR_OFPBPC_BAD_VALUE ; } if ( strcmp ( "hash" , prop -> selection_method ) && strcmp ( "dp_hash" , prop -> selection_method ) ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported" , prop -> selection_method ) ; return OFPERR_OFPBPC_BAD_VALUE ; } strcpy ( gp -> selection_method , prop -> selection_method ) ; gp -> selection_method_param = ntohll ( prop -> selection_method_param ) ; ofpbuf_pull ( payload , sizeof * prop ) ; fields_len = ntohs ( prop -> length ) - sizeof * prop ; if ( fields_len && strcmp ( "hash" , gp -> selection_method ) ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>%s<S2SV_blank>" "does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>fields" , gp -> selection_method ) ; return OFPERR_OFPBPC_BAD_VALUE ; } error = oxm_pull_field_array ( payload -> data , fields_len , & gp -> fields ) ; if ( error ) { OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>fields<S2SV_blank>are<S2SV_blank>invalid" ) ; return error ; } return 0 ; }
CWE-119 <S2SV_StartBug> static int read_mv_component ( vp9_reader * r , <S2SV_EndBug> const nmv_component * mvcomp , int usehp ) { int mag , d , fr , hp ; <S2SV_StartBug> const int sign = vp9_read ( r , mvcomp -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> const int mv_class = vp9_read_tree ( r , vp9_mv_class_tree , mvcomp -> classes ) ; <S2SV_EndBug> const int class0 = mv_class == MV_CLASS_0 ; if ( class0 ) { <S2SV_StartBug> d = vp9_read_tree ( r , vp9_mv_class0_tree , mvcomp -> class0 ) ; <S2SV_EndBug> } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; d = 0 ; for ( i = 0 ; i < n ; ++ i ) <S2SV_StartBug> d |= vp9_read ( r , mvcomp -> bits [ i ] ) << i ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> fr = vp9_read_tree ( r , vp9_mv_fp_tree , class0 ? mvcomp -> class0_fp [ d ] <S2SV_EndBug> : mvcomp -> fp ) ; <S2SV_StartBug> hp = usehp ? vp9_read ( r , class0 ? mvcomp -> class0_hp : mvcomp -> hp ) <S2SV_EndBug> : 1 ; <S2SV_StartBug> mag = vp9_get_mv_mag ( mv_class , ( d << 3 ) | ( fr << 1 ) | hp ) + 1 ; <S2SV_EndBug> return sign ? - mag : mag ; }
CWE-20 asmlinkage long compat_sys_recvmmsg ( int fd , struct compat_mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct compat_timespec __user * timeout ) { int datagrams ; struct timespec ktspec ; if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ; <S2SV_StartBug> if ( COMPAT_USE_64BIT_TIME ) <S2SV_EndBug> return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ; if ( timeout == NULL ) return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , NULL ) ; <S2SV_StartBug> if ( get_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> return - EFAULT ; datagrams = __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , & ktspec ) ; <S2SV_StartBug> if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) ) <S2SV_EndBug> datagrams = - EFAULT ; return datagrams ; }
CWE-119 void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh , <S2SV_StartBug> int flag ) <S2SV_EndBug> { double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065 ; int ppl = ( int ) ( level + .5 ) ; <S2SV_StartBug> int mb_rows = source -> y_width >> 4 ; <S2SV_EndBug> <S2SV_StartBug> int mb_cols = source -> y_height >> 4 ; <S2SV_EndBug> unsigned char * limits = cm -> pp_limits_buffer ; ; <S2SV_StartBug> int mbr , mbc ; <S2SV_EndBug> ( void ) post ; ( void ) low_var_thresh ; ( void ) flag ; <S2SV_StartBug> vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols ) ; <S2SV_EndBug> for ( mbr = 0 ; mbr < mb_rows ; mbr ++ ) { vp8_post_proc_down_and_across_mb_row ( source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_stride , source -> y_stride , source -> y_width , limits , 16 ) ; <S2SV_StartBug> vp8_post_proc_down_and_across_mb_row ( <S2SV_EndBug> source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride , <S2SV_StartBug> source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; <S2SV_EndBug> } }
CWE-787 static char * get_object ( FILE * fp , int obj_id , const xref_t * xref , size_t * size , int * is_stream ) { static const int blk_sz = 256 ; int i , total_sz , read_sz , n_blks , search , stream ; size_t obj_sz ; char * c , * data ; long start ; const xref_entry_t * entry ; if ( size ) * size = 0 ; if ( is_stream ) * is_stream = 0 ; start = ftell ( fp ) ; entry = NULL ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) if ( xref -> entries [ i ] . obj_id == obj_id ) { entry = & xref -> entries [ i ] ; break ; } if ( ! entry ) return NULL ; fseek ( fp , entry -> offset , SEEK_SET ) ; obj_sz = 0 ; total_sz = 0 ; n_blks = 1 ; <S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> memset ( data , 0 , blk_sz * n_blks ) ; stream = 0 ; while ( ( read_sz = fread ( data + total_sz , 1 , blk_sz - 1 , fp ) ) && ! ferror ( fp ) ) { total_sz += read_sz ; * ( data + total_sz ) = '\\0' ; if ( total_sz + blk_sz >= ( blk_sz * n_blks ) ) data = realloc ( data , blk_sz * ( ++ n_blks ) ) ; search = total_sz - read_sz ; if ( search < 0 ) search = 0 ; if ( ( c = strstr ( data + search , "endobj" ) ) ) { * ( c + strlen ( "endobj" ) + 1 ) = '\\0' ; obj_sz = ( void * ) strstr ( data + search , "endobj" ) - ( void * ) data ; obj_sz += strlen ( "endobj" ) + 1 ; break ; } else if ( strstr ( data , "stream" ) ) stream = 1 ; } clearerr ( fp ) ; fseek ( fp , start , SEEK_SET ) ; if ( size ) * size = obj_sz ; if ( is_stream ) * is_stream = stream ; return data ; }
CWE-399 static void xen_netbk_fill_frags ( struct xen_netbk * netbk , struct sk_buff * skb ) { struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i ; for ( i = 0 ; i < nr_frags ; i ++ ) { skb_frag_t * frag = shinfo -> frags + i ; struct xen_netif_tx_request * txp ; struct page * page ; u16 pending_idx ; pending_idx = frag_get_pending_idx ( frag ) ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ; __skb_fill_page_desc ( skb , i , page , txp -> offset , txp -> size ) ; skb -> len += txp -> size ; skb -> data_len += txp -> size ; skb -> truesize += txp -> size ; get_page ( netbk -> mmap_pages [ pending_idx ] ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } }
CWE-190 SQLITE_PRIVATE VList * sqlite3VListAdd ( sqlite3 * db , VList * pIn , const char * zName , int nName , int iVal ) { int nInt ; char * z ; int i ; nInt = nName / 4 + 3 ; assert ( pIn == 0 || pIn [ 0 ] >= 3 ) ; if ( pIn == 0 || pIn [ 1 ] + nInt > pIn [ 0 ] ) { <S2SV_StartBug> int nAlloc = ( pIn ? pIn [ 0 ] * 2 : 10 ) + nInt ; <S2SV_EndBug> VList * pOut = sqlite3DbRealloc ( db , pIn , nAlloc * sizeof ( int ) ) ; if ( pOut == 0 ) return pIn ; if ( pIn == 0 ) pOut [ 1 ] = 2 ; pIn = pOut ; pIn [ 0 ] = nAlloc ; } i = pIn [ 1 ] ; pIn [ i ] = iVal ; pIn [ i + 1 ] = nInt ; z = ( char * ) & pIn [ i + 2 ] ; pIn [ 1 ] = i + nInt ; assert ( pIn [ 1 ] <= pIn [ 0 ] ) ; memcpy ( z , zName , nName ) ; z [ nName ] = 0 ; return pIn ; }
CWE-119 <S2SV_StartBug> static void encode_uniform ( vp9_writer * w , int v ) { <S2SV_EndBug> const int l = 8 ; const int m = ( 1 << l ) - 191 ; if ( v < m ) { <S2SV_StartBug> vp9_write_literal ( w , v , l - 1 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp9_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , ( v - m ) & 1 , 1 ) ; <S2SV_EndBug> } }
CWE-000 int nfssvc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readargs * args ) { unsigned int len ; int v ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; args -> offset = ntohl ( * p ++ ) ; len = args -> count = ntohl ( * p ++ ) ; <S2SV_StartBug> p ++ ; <S2SV_EndBug> len = min_t ( unsigned int , len , NFSSVC_MAXBLKSIZE_V2 ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , PAGE_SIZE ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ; <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
CWE-476 xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) return __this_address ; switch ( mode & S_IFMT ) { case S_IFIFO : case S_IFCHR : case S_IFBLK : case S_IFSOCK : if ( dip -> di_format != XFS_DINODE_FMT_DEV ) return __this_address ; break ; case S_IFREG : case S_IFLNK : case S_IFDIR : <S2SV_StartBug> switch ( dip -> di_format ) { <S2SV_EndBug> case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ; if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ; if ( dip -> di_nextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { switch ( dip -> di_aformat ) { case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } } else { switch ( dip -> di_aformat ) { case 0 : case XFS_DINODE_FMT_EXTENTS : break ; default : return __this_address ; } if ( dip -> di_anextents ) return __this_address ; } fa = xfs_inode_validate_extsize ( mp , be32_to_cpu ( dip -> di_extsize ) , mode , flags ) ; if ( fa ) return fa ; if ( dip -> di_version < 3 ) return NULL ; flags2 = be64_to_cpu ( dip -> di_flags2 ) ; if ( ( flags2 & ( XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE ) ) && ! xfs_sb_version_hasreflink ( & mp -> m_sb ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( mode & S_IFMT ) != S_IFREG ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags & XFS_DIFLAG_REALTIME ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags2 & XFS_DIFLAG2_DAX ) ) return __this_address ; fa = xfs_inode_validate_cowextsize ( mp , be32_to_cpu ( dip -> di_cowextsize ) , mode , flags , flags2 ) ; if ( fa ) return fa ; return NULL ; }
CWE-416 static int updateDevice ( const struct header * headers , time_t t ) { struct device * * pp = & devlist ; struct device * p = * pp ; while ( p ) { if ( p -> headers [ HEADER_NT ] . l == headers [ HEADER_NT ] . l && ( 0 == memcmp ( p -> headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . l ) ) && p -> headers [ HEADER_USN ] . l == headers [ HEADER_USN ] . l && ( 0 == memcmp ( p -> headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . l ) ) ) { syslog ( LOG_DEBUG , "device<S2SV_blank>updated<S2SV_blank>:<S2SV_blank>%.*s" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; p -> t = t ; if ( headers [ HEADER_LOCATION ] . l > p -> headers [ HEADER_LOCATION ] . l ) { struct device * tmp ; tmp = realloc ( p , sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! tmp ) { syslog ( LOG_ERR , "updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error" ) ; <S2SV_StartBug> free ( p ) ; <S2SV_EndBug> return 0 ; } p = tmp ; * pp = p ; } memcpy ( p -> data + p -> headers [ 0 ] . l + p -> headers [ 1 ] . l , headers [ 2 ] . p , headers [ 2 ] . l ) ; return 0 ; } pp = & p -> next ; p = * pp ; } syslog ( LOG_INFO , "new<S2SV_blank>device<S2SV_blank>discovered<S2SV_blank>:<S2SV_blank>%.*s" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; { char * pc ; int i ; p = malloc ( sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! p ) { syslog ( LOG_ERR , "updateDevice():<S2SV_blank>cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; return - 1 ; } p -> next = devlist ; p -> t = t ; pc = p -> data ; for ( i = 0 ; i < 3 ; i ++ ) { p -> headers [ i ] . p = pc ; p -> headers [ i ] . l = headers [ i ] . l ; memcpy ( pc , headers [ i ] . p , headers [ i ] . l ) ; pc += headers [ i ] . l ; } devlist = p ; sendNotifications ( NOTIF_NEW , p , NULL ) ; } return 1 ; }
CWE-119 static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = "<html>" ; char framestring [ ] = "</frameset></html>" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( "pixHtmlViewer" ) ; if ( ! dirin ) return ERROR_INT ( "dirin<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( "dirout<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( "rootname<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( "thumbwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( "viewwidth<S2SV_blank>too<S2SV_blank>small;<S2SV_blank>using<S2SV_blank>min<S2SV_blank>value\\n" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , "mkdir<S2SV_blank>-p<S2SV_blank>%s" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( "output<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>made\\n" , procName , dirout ) ; return 1 ; } if ( ( safiles = getFilenamesInDirectory ( dirin ) ) == NULL ) return ERROR_INT ( "safiles<S2SV_blank>not<S2SV_blank>made" , procName , 1 ) ; <S2SV_StartBug> sprintf ( charbuf , "%s/%s.html" , dirout , rootname ) ; <S2SV_EndBug> mainname = stringNew ( charbuf ) ; <S2SV_StartBug> sprintf ( charbuf , "%s/%s-links.html" , dirout , rootname ) ; <S2SV_EndBug> linkname = stringNew ( charbuf ) ; linknameshort = stringJoin ( rootname , "-links.html" ) ; sathumbs = sarrayCreate ( 0 ) ; saviews = sarrayCreate ( 0 ) ; nfiles = sarrayGetCount ( safiles ) ; index = 0 ; for ( i = 0 ; i < nfiles ; i ++ ) { fname = sarrayGetString ( safiles , i , L_NOCOPY ) ; fullname = genPathname ( dirin , fname ) ; fprintf ( stderr , "name:<S2SV_blank>%s\\n" , fullname ) ; if ( ( pix = pixRead ( fullname ) ) == NULL ) { fprintf ( stderr , "file<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>a<S2SV_blank>readable<S2SV_blank>image\\n" , fullname ) ; lept_free ( fullname ) ; continue ; } lept_free ( fullname ) ; pixGetDimensions ( pix , & w , NULL , & d ) ; factor = ( l_float32 ) thumbwidth / ( l_float32 ) w ; pixthumb = pixScale ( pix , factor , factor ) ; <S2SV_StartBug> sprintf ( charbuf , "%s_thumb_%03d" , rootname , index ) ; <S2SV_EndBug> sarrayAddString ( sathumbs , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixthumb ) ; lept_free ( outname ) ; pixDestroy ( & pixthumb ) ; factor = ( l_float32 ) viewwidth / ( l_float32 ) w ; if ( factor >= 1.0 ) pixview = pixClone ( pix ) ; else pixview = pixScale ( pix , factor , factor ) ; snprintf ( charbuf , sizeof ( charbuf ) , "%s_view_%03d" , rootname , index ) ; sarrayAddString ( saviews , charbuf , L_COPY ) ; outname = genPathname ( dirout , charbuf ) ; WriteFormattedPix ( outname , pixview ) ; lept_free ( outname ) ; pixDestroy ( & pixview ) ; pixDestroy ( & pix ) ; index ++ ; } sahtml = sarrayCreate ( 0 ) ; sarrayAddString ( sahtml , htmlstring , L_COPY ) ; sprintf ( charbuf , "<frameset<S2SV_blank>cols=\\"%d,<S2SV_blank>*\\">" , thumbwidth + 30 ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , "<frame<S2SV_blank>name=\\"thumbs\\"<S2SV_blank>src=\\"%s\\">" , linknameshort ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sprintf ( charbuf , "<frame<S2SV_blank>name=\\"views\\"<S2SV_blank>src=\\"%s\\">" , sarrayGetString ( saviews , 0 , L_NOCOPY ) ) ; sarrayAddString ( sahtml , charbuf , L_COPY ) ; sarrayAddString ( sahtml , framestring , L_COPY ) ; shtml = sarrayToString ( sahtml , 1 ) ; l_binaryWrite ( mainname , "w" , shtml , strlen ( shtml ) ) ; fprintf ( stderr , "******************************************\\n" "Writing<S2SV_blank>html<S2SV_blank>file:<S2SV_blank>%s\\n" "******************************************\\n" , mainname ) ; lept_free ( shtml ) ; lept_free ( mainname ) ; nimages = sarrayGetCount ( saviews ) ; fprintf ( stderr , "num.<S2SV_blank>images<S2SV_blank>=<S2SV_blank>%d\\n" , nimages ) ; salink = sarrayCreate ( 0 ) ; for ( i = 0 ; i < nimages ; i ++ ) { viewfile = sarrayGetString ( saviews , i , L_NOCOPY ) ; thumbfile = sarrayGetString ( sathumbs , i , L_NOCOPY ) ; sprintf ( charbuf , "<a<S2SV_blank>href=\\"%s\\"<S2SV_blank>TARGET=views><img<S2SV_blank>src=\\"%s\\"></a>" , viewfile , thumbfile ) ; sarrayAddString ( salink , charbuf , L_COPY ) ; } slink = sarrayToString ( salink , 1 ) ; l_binaryWrite ( linkname , "w" , slink , strlen ( slink ) ) ; lept_free ( slink ) ; lept_free ( linkname ) ; lept_free ( linknameshort ) ; sarrayDestroy ( & safiles ) ; sarrayDestroy ( & sathumbs ) ; sarrayDestroy ( & saviews ) ; sarrayDestroy ( & sahtml ) ; sarrayDestroy ( & salink ) ; return 0 ; }
CWE-20 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; p = key -> payload . data [ 0 ] ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( "trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n" , ret ) ; kzfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( "trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n" , ret ) ; kzfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kzfree ( datablob ) ; kzfree ( new_o ) ; return ret ; }
CWE-20 static gboolean netscreen_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) { return FALSE ; } if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; <S2SV_StartBug> if ( pkt_len == - 1 ) <S2SV_EndBug> return FALSE ; if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ; return TRUE ; }
CWE-125 static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; <S2SV_StartBug> int iSrc ; <S2SV_EndBug> res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }
CWE-284 int btsock_thread_add_fd ( int h , int fd , int type , int flags , uint32_t user_id ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( "invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( "cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created.<S2SV_blank>socket<S2SV_blank>thread<S2SV_blank>may<S2SV_blank>not<S2SV_blank>initialized" ) ; return FALSE ; } if ( flags & SOCK_THREAD_ADD_FD_SYNC ) { if ( ts [ h ] . thread_id == pthread_self ( ) ) { flags &= ~ SOCK_THREAD_ADD_FD_SYNC ; add_poll ( h , fd , type , flags , user_id ) ; return TRUE ; } APPL_TRACE_DEBUG ( "THREAD_ADD_FD_SYNC<S2SV_blank>is<S2SV_blank>not<S2SV_blank>called<S2SV_blank>in<S2SV_blank>poll<S2SV_blank>thread,<S2SV_blank>fallback<S2SV_blank>to<S2SV_blank>async" ) ; } sock_cmd_t cmd = { CMD_ADD_FD , fd , type , flags , user_id } ; APPL_TRACE_DEBUG ( "adding<S2SV_blank>fd:%d,<S2SV_blank>flags:0x%x" , fd , flags ) ; <S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> }
CWE-000 long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; <S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }
CWE-000 void xgroupCommand ( client * c ) { const char * help [ ] = { "CREATE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>consumer<S2SV_blank>group." , "SETID<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>current<S2SV_blank>group<S2SV_blank>ID." , "DELGROUP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>group." , "DELCONSUMER<S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><consumer><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>conusmer." , "HELP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Prints<S2SV_blank>this<S2SV_blank>help." , NULL } ; stream * s = NULL ; sds grpname = NULL ; streamCG * cg = NULL ; char * opt = c -> argv [ 1 ] -> ptr ; if ( c -> argc >= 4 ) { robj * o = lookupKeyWriteOrReply ( c , c -> argv [ 2 ] , shared . nokeyerr ) ; <S2SV_StartBug> if ( o == NULL ) return ; <S2SV_EndBug> s = o -> ptr ; grpname = c -> argv [ 3 ] -> ptr ; if ( ( cg = streamLookupCG ( s , grpname ) ) == NULL && ( ! strcasecmp ( opt , "SETID" ) || ! strcasecmp ( opt , "DELCONSUMER" ) ) ) { addReplyErrorFormat ( c , "-NOGROUP<S2SV_blank>No<S2SV_blank>such<S2SV_blank>consumer<S2SV_blank>group<S2SV_blank>\'%s\'<S2SV_blank>" "for<S2SV_blank>key<S2SV_blank>name<S2SV_blank>\'%s\'" , ( char * ) grpname , ( char * ) c -> argv [ 2 ] -> ptr ) ; return ; } } if ( ! strcasecmp ( opt , "CREATE" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , "$" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } streamCG * cg = streamCreateCG ( s , grpname , sdslen ( grpname ) , & id ) ; if ( cg ) { addReply ( c , shared . ok ) ; server . dirty ++ ; } else { addReplySds ( c , sdsnew ( "-BUSYGROUP<S2SV_blank>Consumer<S2SV_blank>Group<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists\\r\\n" ) ) ; } } else if ( ! strcasecmp ( opt , "SETID" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , "$" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } cg -> last_id = id ; addReply ( c , shared . ok ) ; } else if ( ! strcasecmp ( opt , "DESTROY" ) && c -> argc == 4 ) { if ( cg ) { raxRemove ( s -> cgroups , ( unsigned char * ) grpname , sdslen ( grpname ) , NULL ) ; streamFreeCG ( cg ) ; addReply ( c , shared . cone ) ; } else { addReply ( c , shared . czero ) ; } } else if ( ! strcasecmp ( opt , "DELCONSUMER" ) && c -> argc == 5 ) { long long pending = streamDelConsumer ( cg , c -> argv [ 4 ] -> ptr ) ; addReplyLongLong ( c , pending ) ; server . dirty ++ ; } else if ( ! strcasecmp ( opt , "HELP" ) ) { addReplyHelp ( c , help ) ; } else { addReply ( c , shared . syntaxerr ) ; } }
CWE-20 static void mpeg4_encode_gop_header ( MpegEncContext * s ) { <S2SV_StartBug> int hours , minutes , seconds ; <S2SV_EndBug> int64_t time ; put_bits ( & s -> pb , 16 , 0 ) ; put_bits ( & s -> pb , 16 , GOP_STARTCODE ) ; time = s -> current_picture_ptr -> f -> pts ; if ( s -> reordered_input_picture [ 1 ] ) time = FFMIN ( time , s -> reordered_input_picture [ 1 ] -> f -> pts ) ; time = time * s -> avctx -> time_base . num ; s -> last_time_base = FFUDIV ( time , s -> avctx -> time_base . den ) ; seconds = FFUDIV ( time , s -> avctx -> time_base . den ) ; minutes = FFUDIV ( seconds , 60 ) ; seconds = FFUMOD ( seconds , 60 ) ; hours = FFUDIV ( minutes , 60 ) ; minutes = FFUMOD ( minutes , 60 ) ; hours = FFUMOD ( hours , 24 ) ; put_bits ( & s -> pb , 5 , hours ) ; put_bits ( & s -> pb , 6 , minutes ) ; put_bits ( & s -> pb , 1 , 1 ) ; put_bits ( & s -> pb , 6 , seconds ) ; put_bits ( & s -> pb , 1 , ! ! ( s -> avctx -> flags & AV_CODEC_FLAG_CLOSED_GOP ) ) ; put_bits ( & s -> pb , 1 , 0 ) ; ff_mpeg4_stuffing ( & s -> pb ) ; }
CWE-189 static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; krb5_key_data * key_data ; if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; if ( key_data_in == NULL ) goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; if ( ret [ j ] == NULL ) goto cleanup ; err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ; if ( err ) goto cleanup ; ret [ j ] -> bv_len = code -> length ; ret [ j ] -> bv_val = code -> data ; free ( code ) ; j ++ ; last = i + 1 ; <S2SV_StartBug> currkvno = key_data [ i ] . key_data_kvno ; <S2SV_EndBug> } } ret [ num_versions ] = NULL ; cleanup : free ( key_data ) ; if ( err != 0 ) { if ( ret != NULL ) { for ( i = 0 ; i <= num_versions ; i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ; free ( ret ) ; ret = NULL ; } } return ret ; }
CWE-119 <S2SV_StartBug> static int decode_term_subexp ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 4 ) + 16 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! vp9_read_bit ( r ) ) <S2SV_EndBug> <S2SV_StartBug> return vp9_read_literal ( r , 5 ) + 32 ; <S2SV_EndBug> return decode_uniform ( r ) + 64 ; }
CWE-399 <S2SV_StartBug> static int udp_push_pending_frames ( struct sock * sk ) <S2SV_EndBug> { struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct flowi4 * fl4 = & inet -> cork . fl . u . ip4 ; struct sk_buff * skb ; int err = 0 ; skb = ip_finish_skb ( sk , fl4 ) ; if ( ! skb ) goto out ; err = udp_send_skb ( skb , fl4 ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }
CWE-200 static int raptor_rss_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rss_parser * rss_parser = ( raptor_rss_parser * ) rdf_parser -> context ; int n ; if ( ! uri ) return 1 ; for ( n = 0 ; n < RAPTOR_RSS_NAMESPACES_SIZE ; n ++ ) rss_parser -> nspaces_seen [ n ] = 'N' ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; <S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rss_parser -> sax2 , uri ) ; return 0 ; }
CWE-362 static void init_once ( void * foo ) { struct ext4_inode_info * ei = ( struct ext4_inode_info * ) foo ; INIT_LIST_HEAD ( & ei -> i_orphan ) ; init_rwsem ( & ei -> xattr_sem ) ; init_rwsem ( & ei -> i_data_sem ) ; <S2SV_StartBug> inode_init_once ( & ei -> vfs_inode ) ; <S2SV_EndBug> }
CWE-362 static int inet_sk_reselect_saddr ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __be32 old_saddr = inet -> inet_saddr ; __be32 daddr = inet -> inet_daddr ; struct flowi4 fl4 ; struct rtable * rt ; __be32 new_saddr ; <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> daddr = inet -> opt -> faddr ; rt = ip_route_connect ( & fl4 , daddr , 0 , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , sk -> sk_protocol , inet -> inet_sport , inet -> inet_dport , sk , false ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; sk_setup_caps ( sk , & rt -> dst ) ; new_saddr = rt -> rt_src ; if ( new_saddr == old_saddr ) return 0 ; if ( sysctl_ip_dynaddr > 1 ) { printk ( KERN_INFO "%s():<S2SV_blank>shifting<S2SV_blank>inet->saddr<S2SV_blank>from<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n" , __func__ , & old_saddr , & new_saddr ) ; } inet -> inet_saddr = inet -> inet_rcv_saddr = new_saddr ; __sk_prot_rehash ( sk ) ; return 0 ; }
CWE-000 static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end != fq -> q . len ) ) goto err ; fq -> q . last_in |= INET_FRAG_LAST_IN ; fq -> q . len = end ; } else { if ( end & 0x7 ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , offsetof ( struct ipv6hdr , payload_len ) ) ; return - 1 ; } if ( end > fq -> q . len ) { if ( fq -> q . last_in & INET_FRAG_LAST_IN ) goto err ; fq -> q . len = end ; } } if ( end == offset ) goto err ; if ( ! pskb_pull ( skb , ( u8 * ) ( fhdr + 1 ) - skb -> data ) ) goto err ; if ( pskb_trim_rcsum ( skb , end - offset ) ) goto err ; prev = fq -> q . fragments_tail ; if ( ! prev || FRAG6_CB ( prev ) -> offset < offset ) { next = NULL ; goto found ; } prev = NULL ; for ( next = fq -> q . fragments ; next != NULL ; next = next -> next ) { if ( FRAG6_CB ( next ) -> offset >= offset ) break ; prev = next ; } found : <S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> offset += i ; if ( end <= offset ) goto err ; if ( ! pskb_pull ( skb , i ) ) goto err ; if ( skb -> ip_summed != CHECKSUM_UNNECESSARY ) skb -> ip_summed = CHECKSUM_NONE ; } } <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> int i = end - FRAG6_CB ( next ) -> offset ; if ( i < next -> len ) { if ( ! pskb_pull ( next , i ) ) goto err ; FRAG6_CB ( next ) -> offset += i ; fq -> q . meat -= i ; if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ; break ; } else { struct sk_buff * free_it = next ; next = next -> next ; if ( prev ) prev -> next = next ; else fq -> q . fragments = next ; fq -> q . meat -= free_it -> len ; frag_kfree_skb ( fq -> q . net , free_it ) ; } } FRAG6_CB ( skb ) -> offset = offset ; skb -> next = next ; if ( ! next ) fq -> q . fragments_tail = skb ; if ( prev ) prev -> next = skb ; else fq -> q . fragments = skb ; dev = skb -> dev ; if ( dev ) { fq -> iif = dev -> ifindex ; skb -> dev = NULL ; } fq -> q . stamp = skb -> tstamp ; fq -> q . meat += skb -> len ; atomic_add ( skb -> truesize , & fq -> q . net -> mem ) ; if ( offset == 0 ) { fq -> nhoffset = nhoff ; fq -> q . last_in |= INET_FRAG_FIRST_IN ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) return ip6_frag_reasm ( fq , prev , dev ) ; write_lock ( & ip6_frags . lock ) ; list_move_tail ( & fq -> q . lru_list , & fq -> q . net -> lru_list ) ; write_unlock ( & ip6_frags . lock ) ; return - 1 ; <S2SV_StartBug> err : <S2SV_EndBug> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ; kfree_skb ( skb ) ; return - 1 ; }
CWE-000 LONG ValidateSignature ( HWND hDlg , const char * path ) { LONG r ; WINTRUST_DATA trust_data = { 0 } ; WINTRUST_FILE_INFO trust_file = { 0 } ; GUID guid_generic_verify = { 0xaac56b , 0xcd44 , 0x11d0 , { 0x8c , 0xc2 , 0x0 , 0xc0 , 0x4f , 0xc2 , 0x95 , 0xee } } ; char * signature_name ; size_t i , len ; signature_name = GetSignatureName ( path ) ; if ( signature_name == NULL ) { uprintf ( "PKI:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>signature<S2SV_blank>name" ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; return TRUST_E_NOSIGNATURE ; } for ( i = 0 ; i < ARRAYSIZE ( cert_name ) ; i ++ ) { len = strlen ( cert_name [ i ] ) ; if ( strncmp ( signature_name , cert_name [ i ] , len ) == 0 ) { if ( ( len >= strlen ( signature_name ) ) || isspace ( signature_name [ len ] ) ) break ; } } if ( i >= ARRAYSIZE ( cert_name ) ) { uprintf ( "PKI:<S2SV_blank>Signature<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>unexpected..." , signature_name ) ; if ( MessageBoxExU ( hDlg , lmprintf ( MSG_285 , signature_name ) , lmprintf ( MSG_283 ) , MB_YESNO | MB_ICONWARNING | MB_IS_RTL , selected_langid ) != IDYES ) return TRUST_E_EXPLICIT_DISTRUST ; } trust_file . cbStruct = sizeof ( trust_file ) ; trust_file . pcwszFilePath = utf8_to_wchar ( path ) ; if ( trust_file . pcwszFilePath == NULL ) { uprintf ( "PKI:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>\'%s\'<S2SV_blank>to<S2SV_blank>UTF16" , path ) ; return ERROR_SEVERITY_ERROR | FAC ( FACILITY_CERT ) | ERROR_NOT_ENOUGH_MEMORY ; } trust_data . cbStruct = sizeof ( trust_data ) ; <S2SV_StartBug> trust_data . dwUIChoice = WTD_UI_ALL ; <S2SV_EndBug> trust_data . fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN ; trust_data . dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400 ; trust_data . dwUnionChoice = WTD_CHOICE_FILE ; trust_data . pFile = & trust_file ; r = WinVerifyTrust ( NULL , & guid_generic_verify , & trust_data ) ; safe_free ( trust_file . pcwszFilePath ) ; <S2SV_StartBug> return r ; <S2SV_EndBug> }
CWE-125 static void send_ssi_file ( struct mg_connection * conn , const char * path , struct mg_file * filep , int include_level ) { char buf [ MG_BUF_LEN ] ; int ch , offset , len , in_tag , in_ssi_tag ; if ( include_level > 10 ) { mg_cry_internal ( conn , "SSI<S2SV_blank>#include<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>deep<S2SV_blank>(%s)" , path ) ; return ; } in_tag = in_ssi_tag = len = offset = 0 ; while ( ( ch = mg_fgetc ( filep , offset ++ ) ) != EOF ) { if ( in_tag ) { if ( ch == '>' ) { buf [ len ++ ] = '>' ; if ( in_ssi_tag ) { buf [ len ] = 0 ; <S2SV_StartBug> if ( ! memcmp ( buf + 5 , "include" , 7 ) ) { <S2SV_EndBug> do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ; # if ! defined ( NO_POPEN ) <S2SV_StartBug> } else if ( ! memcmp ( buf + 5 , "exec" , 4 ) ) { <S2SV_EndBug> do_ssi_exec ( conn , buf + 9 ) ; # endif } else { mg_cry_internal ( conn , "%s:<S2SV_blank>unknown<S2SV_blank>SSI<S2SV_blank>" "command:<S2SV_blank>\\"%s\\"" , path , buf ) ; } len = 0 ; in_ssi_tag = in_tag = 0 ; } else { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; in_tag = 0 ; } } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( ( len == 5 ) && ! memcmp ( buf , "<!--#" , 5 ) ) { in_ssi_tag = 1 ; } if ( ( len + 2 ) > ( int ) sizeof ( buf ) ) { mg_cry_internal ( conn , "%s:<S2SV_blank>tag<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" , path ) ; return ; } } } else { if ( ch == '<' ) { in_tag = 1 ; if ( len > 0 ) { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; } len = 1 ; buf [ 0 ] = '<' ; } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( len == ( int ) sizeof ( buf ) ) { mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; } } } } if ( len > 0 ) { mg_write ( conn , buf , ( size_t ) len ) ; } }
CWE-200 static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { spinlock_t * ptl ; struct vm_area_struct * vma = walk -> vma ; pte_t * ptep ; unsigned char * vec = walk -> private ; int nr = ( end - addr ) >> PAGE_SHIFT ; ptl = pmd_trans_huge_lock ( pmd , vma ) ; if ( ptl ) { memset ( vec , 1 , nr ) ; spin_unlock ( ptl ) ; goto out ; } if ( pmd_trans_unstable ( pmd ) ) { <S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> goto out ; } ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { pte_t pte = * ptep ; if ( pte_none ( pte ) ) <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> vma , vec ) ; else if ( pte_present ( pte ) ) * vec = 1 ; else { swp_entry_t entry = pte_to_swp_entry ( pte ) ; <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> * vec = 1 ; } else { # ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ; # else WARN_ON ( 1 ) ; * vec = 1 ; # endif } } vec ++ ; } pte_unmap_unlock ( ptep - 1 , ptl ) ; out : walk -> private += nr ; cond_resched ( ) ; return 0 ; }
