CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
CWE-000 static ssize_t aio_setup_iocb ( struct kiocb * kiocb , bool compat ) { struct file * file = kiocb -> ki_filp ; ssize_t ret = 0 ; switch ( kiocb -> ki_opcode ) { case IOCB_CMD_PREAD : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITE : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PREADV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( READ , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITEV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( WRITE , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_FDSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fdsync ; break ; case IOCB_CMD_FSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fsync ; break ; default : dprintk ( "EINVAL:<S2SV_blank>io_submit:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n" ) ; ret = - EINVAL ; } if ( ! kiocb -> ki_retry ) return ret ; return 0 ; }
CWE-20 int main ( int argc , char * * argv ) { const char * test_name = NULL ; bool skip_sanity_suite = false ; for ( int i = 1 ; i < argc ; ++ i ) { if ( ! strcmp ( "--help" , argv [ i ] ) ) { print_usage ( argv [ 0 ] ) ; return 0 ; } if ( ! strcmp ( "--insanity" , argv [ i ] ) ) { skip_sanity_suite = true ; continue ; } if ( ! is_valid ( argv [ i ] ) ) { printf ( "Error:<S2SV_blank>invalid<S2SV_blank>test<S2SV_blank>name.\\n" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( test_name != NULL ) { printf ( "Error:<S2SV_blank>invalid<S2SV_blank>arguments.\\n" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } test_name = argv [ i ] ; } if ( is_shell_running ( ) ) { printf ( "Run<S2SV_blank>\'adb<S2SV_blank>shell<S2SV_blank>stop\'<S2SV_blank>before<S2SV_blank>running<S2SV_blank>%s.\\n" , argv [ 0 ] ) ; return - 1 ; } config_t * config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { printf ( "Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stack<S2SV_blank>config<S2SV_blank>file.\\n" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } for ( const config_section_node_t * node = config_section_begin ( config ) ; node != config_section_end ( config ) ; node = config_section_next ( node ) ) { const char * name = config_section_name ( node ) ; if ( config_has_key ( config , name , "LinkKey" ) && string_to_bdaddr ( name , & bt_remote_bdaddr ) ) { break ; } } config_free ( config ) ; if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { printf ( "Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>paired<S2SV_blank>device<S2SV_blank>in<S2SV_blank>config<S2SV_blank>file.\\n" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { printf ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Bluetooth<S2SV_blank>HAL.\\n" ) ; return 1 ; } if ( ! btsocket_init ( ) ) { printf ( "Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>Bluetooth<S2SV_blank>sockets.\\n" ) ; return 2 ; } if ( ! pan_init ( ) ) { printf ( "Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PAN.\\n" ) ; return 3 ; } if ( ! gatt_init ( ) ) { printf ( "Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>GATT.\\n" ) ; return 4 ; } watchdog_running = true ; pthread_create ( & watchdog_thread , NULL , watchdog_fn , NULL ) ; static const char * DEFAULT = "\\x1b[0m" ; static const char * GREEN = "\\x1b[0;32m" ; static const char * RED = "\\x1b[0;31m" ; if ( ! isatty ( fileno ( stdout ) ) ) { DEFAULT = GREEN = RED = "" ; } int pass = 0 ; int fail = 0 ; int case_num = 0 ; if ( ! skip_sanity_suite ) { for ( size_t i = 0 ; i < sanity_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , sanity_suite [ i ] . function_name ) ) { callbacks_init ( ) ; if ( sanity_suite [ i ] . function ( ) ) { printf ( "[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n" , ++ case_num , sanity_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( "[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n" , ++ case_num , sanity_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } callbacks_cleanup ( ) ; ++ watchdog_id ; } } } if ( fail ) { printf ( "\\n%sSanity<S2SV_blank>suite<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>errors.%s\\n" , RED , fail , DEFAULT ) ; hal_close ( ) ; return 4 ; } for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { callbacks_init ( ) ; <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> if ( test_suite [ i ] . function ( ) ) { printf ( "[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n" , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( "[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n" , ++ case_num , test_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } CALL_AND_WAIT ( bt_interface -> disable ( ) , adapter_state_changed ) ; callbacks_cleanup ( ) ; ++ watchdog_id ; } } printf ( "\\n" ) ; if ( fail ) { printf ( "%d/%d<S2SV_blank>tests<S2SV_blank>failed.<S2SV_blank>See<S2SV_blank>above<S2SV_blank>for<S2SV_blank>failed<S2SV_blank>test<S2SV_blank>cases.\\n" , fail , sanity_suite_size + test_suite_size ) ; } else { printf ( "All<S2SV_blank>tests<S2SV_blank>passed!\\n" ) ; } watchdog_running = false ; pthread_join ( watchdog_thread , NULL ) ; hal_close ( ) ; return 0 ; }
CWE-284 static sent_status_t send_data_to_app ( int fd , BT_HDR * p_buf ) { if ( p_buf -> len == 0 ) return SENT_ALL ; <S2SV_StartBug> ssize_t sent = send ( fd , p_buf -> data + p_buf -> offset , p_buf -> len , MSG_DONTWAIT ) ; <S2SV_EndBug> if ( sent == - 1 ) { if ( errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR ) return SENT_NONE ; LOG_ERROR ( "%s<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>RFCOMM<S2SV_blank>data<S2SV_blank>back<S2SV_blank>to<S2SV_blank>app:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; return SENT_FAILED ; } if ( sent == 0 ) return SENT_FAILED ; if ( sent == p_buf -> len ) return SENT_ALL ; p_buf -> offset += sent ; p_buf -> len -= sent ; return SENT_PARTIAL ; }
CWE-119 static INLINE void fdct32x32 ( int rd_transform , <S2SV_StartBug> const int16_t * src , int16_t * dst , int src_stride ) { <S2SV_EndBug> if ( rd_transform ) <S2SV_StartBug> vp9_fdct32x32_rd ( src , dst , src_stride ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_fdct32x32 ( src , dst , src_stride ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> int Downmix_Reset ( downmix_object_t * pDownmixer , bool init ) { <S2SV_EndBug> return 0 ; }
CWE-476 void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = '<S2SV_blank>' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) { <S2SV_StartBug> if ( rows > 1 ) { <S2SV_EndBug> pos = columnPos ( l , col ) ; a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; if ( a == NULL ) break ; spos = a -> start . pos ; epos = a -> end . pos ; } if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || spos < 0 || epos < 0 || COLPOS ( l , epos ) < col ) break ; pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , rows > 1 , form -> type == FORM_INPUT_PASSWORD ) ; if ( pos != epos ) { shiftAnchorPosition ( buf -> href , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> name , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> img , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , a -> start . line , spos , pos - epos ) ; } } break ; } copyBuffer ( buf , & save ) ; arrangeLine ( buf ) ; }
CWE-200 static void save_bt_to_dump_dir ( const char * bt , const char * exe , const char * reason ) { time_t t = time ( NULL ) ; const char * iso_date = iso_date_string ( & t ) ; uid_t my_euid = ( uid_t ) - 1L ; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH ; if ( ! ( g_opts & OPT_x ) ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } <S2SV_StartBug> pid_t my_pid = getpid ( ) ; <S2SV_EndBug> char base [ sizeof ( "xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu" ) + 2 * sizeof ( long ) * 3 ] ; sprintf ( base , "xorg-%s-%lu-%u" , iso_date , ( long ) my_pid , g_bt_count ) ; char * path = concat_path_file ( debug_dumps_dir , base ) ; struct dump_dir * dd = dd_create ( path , my_euid , mode ) ; if ( dd ) { dd_create_basic_files ( dd , my_euid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; dd_save_text ( dd , FILENAME_ANALYZER , "xorg" ) ; dd_save_text ( dd , FILENAME_TYPE , "xorg" ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; dd_save_text ( dd , FILENAME_BACKTRACE , bt ) ; if ( ! exe ) { exe = "/usr/bin/X" ; if ( access ( "/usr/bin/Xorg" , X_OK ) == 0 ) exe = "/usr/bin/Xorg" ; } dd_save_text ( dd , FILENAME_EXECUTABLE , exe ) ; dd_close ( dd ) ; notify_new_path ( path ) ; } free ( path ) ; }
CWE-399 static int wanxl_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { const size_t size = sizeof ( sync_serial_settings ) ; sync_serial_settings line ; port_t * port = dev_to_port ( dev ) ; if ( cmd != SIOCWANDEV ) return hdlc_ioctl ( dev , ifr , cmd ) ; switch ( ifr -> ifr_settings . type ) { case IF_GET_IFACE : ifr -> ifr_settings . type = IF_IFACE_SYNC_SERIAL ; if ( ifr -> ifr_settings . size < size ) { ifr -> ifr_settings . size = size ; return - ENOBUFS ; <S2SV_StartBug> } <S2SV_EndBug> line . clock_type = get_status ( port ) -> clocking ; line . clock_rate = 0 ; line . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & line , size ) ) return - EFAULT ; return 0 ; case IF_IFACE_SYNC_SERIAL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( dev -> flags & IFF_UP ) return - EBUSY ; if ( copy_from_user ( & line , ifr -> ifr_settings . ifs_ifsu . sync , size ) ) return - EFAULT ; if ( line . clock_type != CLOCK_EXT && line . clock_type != CLOCK_TXFROMRX ) return - EINVAL ; if ( line . loopback != 0 ) return - EINVAL ; get_status ( port ) -> clocking = line . clock_type ; return 0 ; default : return hdlc_ioctl ( dev , ifr , cmd ) ; } }
CWE-119 static int virtnet_probe ( struct virtio_device * vdev ) { int i , err ; struct net_device * dev ; struct virtnet_info * vi ; u16 max_queue_pairs ; if ( ! vdev -> config -> get ) { dev_err ( & vdev -> dev , "%s<S2SV_blank>failure:<S2SV_blank>config<S2SV_blank>access<S2SV_blank>disabled\\n" , __func__ ) ; return - EINVAL ; } if ( ! virtnet_validate_features ( vdev ) ) return - EINVAL ; err = virtio_cread_feature ( vdev , VIRTIO_NET_F_MQ , struct virtio_net_config , max_virtqueue_pairs , & max_queue_pairs ) ; if ( err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN || max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX || ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) max_queue_pairs = 1 ; dev = alloc_etherdev_mq ( sizeof ( struct virtnet_info ) , max_queue_pairs ) ; if ( ! dev ) return - ENOMEM ; dev -> priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE ; dev -> netdev_ops = & virtnet_netdev ; dev -> features = NETIF_F_HIGHDMA ; dev -> ethtool_ops = & virtnet_ethtool_ops ; SET_NETDEV_DEV ( dev , & vdev -> dev ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CSUM ) ) { <S2SV_StartBug> dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <S2SV_EndBug> if ( csum ) <S2SV_StartBug> dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <S2SV_EndBug> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) { dev -> hw_features |= NETIF_F_TSO | NETIF_F_UFO | NETIF_F_TSO_ECN | NETIF_F_TSO6 ; } if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO4 ) ) dev -> hw_features |= NETIF_F_TSO ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO6 ) ) dev -> hw_features |= NETIF_F_TSO6 ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_ECN ) ) dev -> hw_features |= NETIF_F_TSO_ECN ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_UFO ) ) dev -> hw_features |= NETIF_F_UFO ; dev -> features |= NETIF_F_GSO_ROBUST ; if ( gso ) dev -> features |= dev -> hw_features & ( NETIF_F_ALL_TSO | NETIF_F_UFO ) ; } if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_CSUM ) ) dev -> features |= NETIF_F_RXCSUM ; dev -> vlan_features = dev -> features ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MAC ) ) virtio_cread_bytes ( vdev , offsetof ( struct virtio_net_config , mac ) , dev -> dev_addr , dev -> addr_len ) ; else eth_hw_addr_random ( dev ) ; vi = netdev_priv ( dev ) ; vi -> dev = dev ; vi -> vdev = vdev ; vdev -> priv = vi ; vi -> stats = alloc_percpu ( struct virtnet_stats ) ; err = - ENOMEM ; if ( vi -> stats == NULL ) goto free ; for_each_possible_cpu ( i ) { struct virtnet_stats * virtnet_stats ; virtnet_stats = per_cpu_ptr ( vi -> stats , i ) ; u64_stats_init ( & virtnet_stats -> tx_syncp ) ; u64_stats_init ( & virtnet_stats -> rx_syncp ) ; } INIT_WORK ( & vi -> config_work , virtnet_config_changed_work ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_TSO4 ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_TSO6 ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_ECN ) || virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_UFO ) ) vi -> big_packets = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) ) vi -> mergeable_rx_bufs = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) || virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) vi -> hdr_len = sizeof ( struct virtio_net_hdr_mrg_rxbuf ) ; else vi -> hdr_len = sizeof ( struct virtio_net_hdr ) ; if ( virtio_has_feature ( vdev , VIRTIO_F_ANY_LAYOUT ) || virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) vi -> any_header_sg = true ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) vi -> has_cvq = true ; if ( vi -> any_header_sg ) dev -> needed_headroom = vi -> hdr_len ; vi -> curr_queue_pairs = 1 ; vi -> max_queue_pairs = max_queue_pairs ; err = init_vqs ( vi ) ; if ( err ) goto free_stats ; # ifdef CONFIG_SYSFS if ( vi -> mergeable_rx_bufs ) dev -> sysfs_rx_queue_group = & virtio_net_mrg_rx_group ; # endif netif_set_real_num_tx_queues ( dev , vi -> curr_queue_pairs ) ; netif_set_real_num_rx_queues ( dev , vi -> curr_queue_pairs ) ; err = register_netdev ( dev ) ; if ( err ) { pr_debug ( "virtio_net:<S2SV_blank>registering<S2SV_blank>device<S2SV_blank>failed\\n" ) ; goto free_vqs ; } virtio_device_ready ( vdev ) ; for ( i = 0 ; i < vi -> curr_queue_pairs ; i ++ ) { try_fill_recv ( vi , & vi -> rq [ i ] , GFP_KERNEL ) ; if ( vi -> rq [ i ] . vq -> num_free == virtqueue_get_vring_size ( vi -> rq [ i ] . vq ) ) { free_unused_bufs ( vi ) ; err = - ENOMEM ; goto free_recv_bufs ; } } vi -> nb . notifier_call = & virtnet_cpu_callback ; err = register_hotcpu_notifier ( & vi -> nb ) ; if ( err ) { pr_debug ( "virtio_net:<S2SV_blank>registering<S2SV_blank>cpu<S2SV_blank>notifier<S2SV_blank>failed\\n" ) ; goto free_recv_bufs ; } if ( virtio_has_feature ( vi -> vdev , VIRTIO_NET_F_STATUS ) ) { netif_carrier_off ( dev ) ; schedule_work ( & vi -> config_work ) ; } else { vi -> status = VIRTIO_NET_S_LINK_UP ; netif_carrier_on ( dev ) ; } pr_debug ( "virtnet:<S2SV_blank>registered<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>RX<S2SV_blank>and<S2SV_blank>TX<S2SV_blank>vq\'s\\n" , dev -> name , max_queue_pairs ) ; return 0 ; free_recv_bufs : vi -> vdev -> config -> reset ( vdev ) ; free_receive_bufs ( vi ) ; unregister_netdev ( dev ) ; free_vqs : cancel_delayed_work_sync ( & vi -> refill ) ; free_receive_page_frags ( vi ) ; virtnet_del_vqs ( vi ) ; free_stats : free_percpu ( vi -> stats ) ; free : free_netdev ( dev ) ; return err ; }
CWE-119 l_int32 gplotMakeOutput ( GPLOT * gplot ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * cmdname ; l_int32 ignore ; PROCNAME ( "gplotMakeOutput" ) ; if ( ! gplot ) return ERROR_INT ( "gplot<S2SV_blank>not<S2SV_blank>defined" , procName , 1 ) ; gplotGenCommandFile ( gplot ) ; gplotGenDataFiles ( gplot ) ; cmdname = genPathname ( gplot -> cmdname , NULL ) ; # ifndef _WIN32 <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "gnuplot<S2SV_blank>%s" , cmdname ) ; <S2SV_EndBug> # else <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , "wgnuplot<S2SV_blank>%s" , cmdname ) ; <S2SV_EndBug> # endif # ifndef OS_IOS ignore = system ( buf ) ; # endif LEPT_FREE ( cmdname ) ; return 0 ; }
CWE-362 static int ext4_split_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_map_blocks * map , int split_flag , int flags ) { ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len , depth ; int err = 0 ; int uninitialized ; int split_flag1 , flags1 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; uninitialized = ext4_ext_is_uninitialized ( ex ) ; if ( map -> m_lblk + map -> m_len < ee_block + ee_len ) { <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> EXT4_EXT_MAY_ZEROOUT : 0 ; flags1 = flags | EXT4_GET_BLOCKS_PRE_IO ; if ( uninitialized ) split_flag1 |= EXT4_EXT_MARK_UNINIT1 | EXT4_EXT_MARK_UNINIT2 ; <S2SV_StartBug> err = ext4_split_extent_at ( handle , inode , path , <S2SV_EndBug> map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ; if ( err ) goto out ; } ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) return PTR_ERR ( path ) ; if ( map -> m_lblk >= ee_block ) { <S2SV_StartBug> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ? <S2SV_EndBug> EXT4_EXT_MAY_ZEROOUT : 0 ; if ( uninitialized ) split_flag1 |= EXT4_EXT_MARK_UNINIT1 ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) split_flag1 |= EXT4_EXT_MARK_UNINIT2 ; err = ext4_split_extent_at ( handle , inode , path , map -> m_lblk , split_flag1 , flags ) ; if ( err ) goto out ; } ext4_ext_show_leaf ( inode , path ) ; out : return err ? err : map -> m_len ; }
CWE-125 int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) { char obj_txt [ 128 ] ; <S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> BIO_write ( bio , "\\n" , 1 ) ; return 1 ; }
CWE-000 static char * get_next_file ( FILE * VFile , char * ptr ) { <S2SV_StartBug> char * ret ; <S2SV_EndBug> ret = fgets ( ptr , PATH_MAX , VFile ) ; if ( ! ret ) return NULL ; <S2SV_StartBug> if ( ptr [ strlen ( ptr ) - 1 ] == '\\n' ) <S2SV_EndBug> <S2SV_StartBug> ptr [ strlen ( ptr ) - 1 ] = '\\0' ; <S2SV_EndBug> return ret ; }
CWE-125 static struct sk_buff * ipv6_gso_segment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; struct ipv6hdr * ipv6h ; const struct net_offload * ops ; int proto ; struct frag_hdr * fptr ; unsigned int unfrag_ip6hlen ; unsigned int payload_len ; u8 * prevhdr ; int offset = 0 ; bool encap , udpfrag ; int nhoff ; bool gso_partial ; skb_reset_network_header ( skb ) ; nhoff = skb_network_header ( skb ) - skb_mac_header ( skb ) ; if ( unlikely ( ! pskb_may_pull ( skb , sizeof ( * ipv6h ) ) ) ) goto out ; encap = SKB_GSO_CB ( skb ) -> encap_level > 0 ; if ( encap ) features &= skb -> dev -> hw_enc_features ; SKB_GSO_CB ( skb ) -> encap_level += sizeof ( * ipv6h ) ; ipv6h = ipv6_hdr ( skb ) ; __skb_pull ( skb , sizeof ( * ipv6h ) ) ; segs = ERR_PTR ( - EPROTONOSUPPORT ) ; proto = ipv6_gso_pull_exthdrs ( skb , ipv6h -> nexthdr ) ; if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6 ) ) udpfrag = proto == IPPROTO_UDP && encap ; else udpfrag = proto == IPPROTO_UDP && ! skb -> encapsulation ; ops = rcu_dereference ( inet6_offloads [ proto ] ) ; if ( likely ( ops && ops -> callbacks . gso_segment ) ) { skb_reset_transport_header ( skb ) ; segs = ops -> callbacks . gso_segment ( skb , features ) ; } if ( IS_ERR_OR_NULL ( segs ) ) goto out ; gso_partial = ! ! ( skb_shinfo ( segs ) -> gso_type & SKB_GSO_PARTIAL ) ; for ( skb = segs ; skb ; skb = skb -> next ) { ipv6h = ( struct ipv6hdr * ) ( skb_mac_header ( skb ) + nhoff ) ; if ( gso_partial ) payload_len = skb_shinfo ( skb ) -> gso_size + SKB_GSO_CB ( skb ) -> data_offset + skb -> head - ( unsigned char * ) ( ipv6h + 1 ) ; else payload_len = skb -> len - nhoff - sizeof ( * ipv6h ) ; ipv6h -> payload_len = htons ( payload_len ) ; skb -> network_header = ( u8 * ) ipv6h - skb -> head ; if ( udpfrag ) { unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; <S2SV_EndBug> fptr -> frag_off = htons ( offset ) ; if ( skb -> next ) fptr -> frag_off |= htons ( IP6_MF ) ; offset += ( ntohs ( ipv6h -> payload_len ) - sizeof ( struct frag_hdr ) ) ; } if ( encap ) skb_reset_inner_headers ( skb ) ; } out : return segs ; }
CWE-476 BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , "client<S2SV_blank>authentication<S2SV_blank>failure\\n" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } return TRUE ; }
CWE-000 int main ( int argc , char * argv [ ] ) { OM_uint32 minor , major ; gss_ctx_id_t context ; gss_union_ctx_id_desc uctx ; krb5_gss_ctx_id_rec kgctx ; krb5_key k1 , k2 ; krb5_keyblock kb1 , kb2 ; gss_buffer_desc in , out ; unsigned char k1buf [ 32 ] , k2buf [ 32 ] , outbuf [ 44 ] ; size_t i ; context = ( gss_ctx_id_t ) & uctx ; uctx . mech_type = & mech_krb5 ; uctx . internal_ctx_id = ( gss_ctx_id_t ) & kgctx ; kgctx . k5_context = NULL ; <S2SV_StartBug> kgctx . have_acceptor_subkey = 1 ; <S2SV_EndBug> kb1 . contents = k1buf ; kb2 . contents = k2buf ; for ( i = 0 ; i < sizeof ( tests ) / sizeof ( * tests ) ; i ++ ) { kb1 . enctype = tests [ i ] . enctype ; kb1 . length = fromhex ( tests [ i ] . key1 , k1buf ) ; check_k5err ( NULL , "create_key" , krb5_k_create_key ( NULL , & kb1 , & k1 ) ) ; kgctx . subkey = k1 ; kb2 . enctype = tests [ i ] . enctype ; kb2 . length = fromhex ( tests [ i ] . key2 , k2buf ) ; check_k5err ( NULL , "create_key" , krb5_k_create_key ( NULL , & kb2 , & k2 ) ) ; kgctx . acceptor_subkey = k2 ; in . length = 0 ; in . value = NULL ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_PARTIAL , & in , 44 , & out ) ; check_gsserr ( "gss_pseudo_random" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out1 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; in . length = strlen ( inputstr ) ; in . value = ( char * ) inputstr ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 44 , & out ) ; check_gsserr ( "gss_pseudo_random" , major , minor ) ; ( void ) fromhex ( tests [ i ] . out2 , outbuf ) ; assert ( out . length == 44 && memcmp ( out . value , outbuf , 44 ) == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; major = gss_pseudo_random ( & minor , context , GSS_C_PRF_KEY_FULL , & in , 0 , & out ) ; check_gsserr ( "gss_pseudo_random" , major , minor ) ; assert ( out . length == 0 ) ; ( void ) gss_release_buffer ( & minor , & out ) ; krb5_k_free_key ( NULL , k1 ) ; krb5_k_free_key ( NULL , k2 ) ; } return 0 ; }
CWE-362 static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , unsigned long arg ) { struct vbg_session * session = filp -> private_data ; size_t returned_size , size ; struct vbg_ioctl_hdr hdr ; bool is_vmmdev_req ; int ret = 0 ; void * buf ; if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ; if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ; size = max ( hdr . size_in , hdr . size_out ) ; if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ; if ( size > SZ_16M ) return - E2BIG ; is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; else buf = kmalloc ( size , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; <S2SV_StartBug> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <S2SV_EndBug> ret = - EFAULT ; goto out ; } if ( hdr . size_in < size ) memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; ret = vbg_core_ioctl ( session , req , buf ) ; if ( ret ) goto out ; returned_size = ( ( struct vbg_ioctl_hdr * ) buf ) -> size_out ; if ( returned_size > size ) { vbg_debug ( "%s:<S2SV_blank>too<S2SV_blank>much<S2SV_blank>output<S2SV_blank>data<S2SV_blank>%zu<S2SV_blank>><S2SV_blank>%zu\\n" , __func__ , returned_size , size ) ; returned_size = size ; } if ( copy_to_user ( ( void * ) arg , buf , returned_size ) != 0 ) ret = - EFAULT ; out : if ( is_vmmdev_req ) vbg_req_free ( buf , size ) ; else kfree ( buf ) ; return ret ; }
CWE-264 static struct net_device * _init_airo_card ( unsigned short irq , int port , int is_pcmcia , struct pci_dev * pci , struct device * dmdev ) { struct net_device * dev ; struct airo_info * ai ; int i , rc ; CapabilityRid cap_rid ; dev = alloc_netdev ( sizeof ( * ai ) , "" , ether_setup ) ; if ( ! dev ) { airo_print_err ( "" , "Couldn\'t<S2SV_blank>alloc_etherdev" ) ; return NULL ; } ai = dev -> ml_priv = netdev_priv ( dev ) ; ai -> wifidev = NULL ; ai -> flags = 1 << FLAG_RADIO_DOWN ; ai -> jobs = 0 ; ai -> dev = dev ; if ( pci && ( pci -> device == 0x5000 || pci -> device == 0xa504 ) ) { airo_print_dbg ( "" , "Found<S2SV_blank>an<S2SV_blank>MPI350<S2SV_blank>card" ) ; set_bit ( FLAG_MPI , & ai -> flags ) ; } spin_lock_init ( & ai -> aux_lock ) ; sema_init ( & ai -> sem , 1 ) ; ai -> config . len = 0 ; ai -> pci = pci ; init_waitqueue_head ( & ai -> thr_wait ) ; ai -> tfm = NULL ; add_airo_dev ( ai ) ; if ( airo_networks_allocate ( ai ) ) goto err_out_free ; airo_networks_initialize ( ai ) ; skb_queue_head_init ( & ai -> txq ) ; if ( test_bit ( FLAG_MPI , & ai -> flags ) ) dev -> netdev_ops = & mpi_netdev_ops ; else dev -> netdev_ops = & airo_netdev_ops ; dev -> wireless_handlers = & airo_handler_def ; ai -> wireless_data . spy_data = & ai -> spy_data ; dev -> wireless_data = & ai -> wireless_data ; dev -> irq = irq ; dev -> base_addr = port ; <S2SV_StartBug> SET_NETDEV_DEV ( dev , dmdev ) ; <S2SV_EndBug> reset_card ( dev , 1 ) ; msleep ( 400 ) ; if ( ! is_pcmcia ) { if ( ! request_region ( dev -> base_addr , 64 , DRV_NAME ) ) { rc = - EBUSY ; airo_print_err ( dev -> name , "Couldn\'t<S2SV_blank>request<S2SV_blank>region" ) ; goto err_out_nets ; } } if ( test_bit ( FLAG_MPI , & ai -> flags ) ) { if ( mpi_map_card ( ai , pci ) ) { airo_print_err ( "" , "Could<S2SV_blank>not<S2SV_blank>map<S2SV_blank>memory" ) ; goto err_out_res ; } } if ( probe ) { if ( setup_card ( ai , dev -> dev_addr , 1 ) != SUCCESS ) { airo_print_err ( dev -> name , "MAC<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>enabled" ) ; rc = - EIO ; goto err_out_map ; } } else if ( ! test_bit ( FLAG_MPI , & ai -> flags ) ) { ai -> bap_read = fast_bap_read ; set_bit ( FLAG_FLASHING , & ai -> flags ) ; } strcpy ( dev -> name , "eth%d" ) ; rc = register_netdev ( dev ) ; if ( rc ) { airo_print_err ( dev -> name , "Couldn\'t<S2SV_blank>register_netdev" ) ; goto err_out_map ; } ai -> wifidev = init_wifidev ( ai , dev ) ; if ( ! ai -> wifidev ) goto err_out_reg ; rc = readCapabilityRid ( ai , & cap_rid , 1 ) ; if ( rc != SUCCESS ) { rc = - EIO ; goto err_out_wifi ; } ai -> wep_capable = ( cap_rid . softCap & cpu_to_le16 ( 0x02 ) ) ? 1 : 0 ; ai -> max_wep_idx = ( cap_rid . softCap & cpu_to_le16 ( 0x80 ) ) ? 3 : 0 ; airo_print_info ( dev -> name , "Firmware<S2SV_blank>version<S2SV_blank>%x.%x.%02d" , ( ( le16_to_cpu ( cap_rid . softVer ) >> 8 ) & 0xF ) , ( le16_to_cpu ( cap_rid . softVer ) & 0xFF ) , le16_to_cpu ( cap_rid . softSubVer ) ) ; if ( le16_to_cpu ( cap_rid . softVer ) > 0x530 || ( le16_to_cpu ( cap_rid . softVer ) == 0x530 && le16_to_cpu ( cap_rid . softSubVer ) >= 17 ) ) { airo_print_info ( ai -> dev -> name , "WPA<S2SV_blank>supported." ) ; set_bit ( FLAG_WPA_CAPABLE , & ai -> flags ) ; ai -> bssListFirst = RID_WPA_BSSLISTFIRST ; ai -> bssListNext = RID_WPA_BSSLISTNEXT ; ai -> bssListRidLen = sizeof ( BSSListRid ) ; } else { airo_print_info ( ai -> dev -> name , "WPA<S2SV_blank>unsupported<S2SV_blank>with<S2SV_blank>firmware<S2SV_blank>" "versions<S2SV_blank>older<S2SV_blank>than<S2SV_blank>5.30.17." ) ; ai -> bssListFirst = RID_BSSLISTFIRST ; ai -> bssListNext = RID_BSSLISTNEXT ; ai -> bssListRidLen = sizeof ( BSSListRid ) - sizeof ( BSSListRidExtra ) ; } set_bit ( FLAG_REGISTERED , & ai -> flags ) ; airo_print_info ( dev -> name , "MAC<S2SV_blank>enabled<S2SV_blank>%pM" , dev -> dev_addr ) ; if ( probe && ! test_bit ( FLAG_MPI , & ai -> flags ) ) for ( i = 0 ; i < MAX_FIDS ; i ++ ) ai -> fids [ i ] = transmit_allocate ( ai , AIRO_DEF_MTU , i >= MAX_FIDS / 2 ) ; if ( setup_proc_entry ( dev , dev -> ml_priv ) < 0 ) goto err_out_wifi ; return dev ; err_out_wifi : unregister_netdev ( ai -> wifidev ) ; free_netdev ( ai -> wifidev ) ; err_out_reg : unregister_netdev ( dev ) ; err_out_map : if ( test_bit ( FLAG_MPI , & ai -> flags ) && pci ) { pci_free_consistent ( pci , PCI_SHARED_LEN , ai -> shared , ai -> shared_dma ) ; iounmap ( ai -> pciaux ) ; iounmap ( ai -> pcimem ) ; mpi_unmap_card ( ai -> pci ) ; } err_out_res : if ( ! is_pcmcia ) release_region ( dev -> base_addr , 64 ) ; err_out_nets : airo_networks_free ( ai ) ; err_out_free : del_airo_dev ( ai ) ; free_netdev ( dev ) ; return NULL ; }
CWE-119 static vpx_codec_err_t validate_img ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img ) { switch ( img -> fmt ) { case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_I420 : <S2SV_StartBug> case VPX_IMG_FMT_I422 : <S2SV_EndBug> <S2SV_StartBug> case VPX_IMG_FMT_I444 : <S2SV_EndBug> break ; default : ERROR ( "Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>Only<S2SV_blank>YV12,<S2SV_blank>I420,<S2SV_blank>I422,<S2SV_blank>I444<S2SV_blank>images<S2SV_blank>are<S2SV_blank>" <S2SV_StartBug> "supported." ) ; <S2SV_EndBug> } if ( img -> d_w != ctx -> cfg . g_w || img -> d_h != ctx -> cfg . g_h ) ERROR ( "Image<S2SV_blank>size<S2SV_blank>must<S2SV_blank>match<S2SV_blank>encoder<S2SV_blank>init<S2SV_blank>configuration<S2SV_blank>size" ) ; return VPX_CODEC_OK ; }
CWE-119 <S2SV_StartBug> void fadst4_sse2 ( __m128i * in ) { <S2SV_EndBug> const __m128i k__sinpi_p01_p02 = pair_set_epi16 ( sinpi_1_9 , sinpi_2_9 ) ; const __m128i k__sinpi_p04_m01 = pair_set_epi16 ( sinpi_4_9 , - sinpi_1_9 ) ; const __m128i k__sinpi_p03_p04 = pair_set_epi16 ( sinpi_3_9 , sinpi_4_9 ) ; const __m128i k__sinpi_m03_p02 = pair_set_epi16 ( - sinpi_3_9 , sinpi_2_9 ) ; <S2SV_StartBug> const __m128i k__sinpi_p03_p03 = _mm_set1_epi16 ( sinpi_3_9 ) ; <S2SV_EndBug> const __m128i kZero = _mm_set1_epi16 ( 0 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u [ 8 ] , v [ 8 ] ; __m128i in7 = _mm_add_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( in [ 0 ] , in [ 1 ] ) ; u [ 1 ] = _mm_unpacklo_epi16 ( in [ 2 ] , in [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( in7 , kZero ) ; u [ 3 ] = _mm_unpacklo_epi16 ( in [ 2 ] , kZero ) ; u [ 4 ] = _mm_unpacklo_epi16 ( in [ 3 ] , kZero ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__sinpi_p01_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__sinpi_p03_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__sinpi_p03_p03 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 0 ] , k__sinpi_p04_m01 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 1 ] , k__sinpi_m03_p02 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__sinpi_p03_p03 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 4 ] , k__sinpi_p03_p03 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_sub_epi32 ( v [ 2 ] , v [ 6 ] ) ; u [ 2 ] = _mm_add_epi32 ( v [ 3 ] , v [ 4 ] ) ; u [ 3 ] = _mm_sub_epi32 ( u [ 2 ] , u [ 0 ] ) ; u [ 4 ] = _mm_slli_epi32 ( v [ 5 ] , 2 ) ; u [ 5 ] = _mm_sub_epi32 ( u [ 4 ] , v [ 5 ] ) ; u [ 6 ] = _mm_add_epi32 ( u [ 3 ] , u [ 5 ] ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 2 ] ) ; in [ 1 ] = _mm_packs_epi32 ( u [ 1 ] , u [ 3 ] ) ; transpose_4x4 ( in ) ; }
CWE-119 <S2SV_StartBug> static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) <S2SV_EndBug> { static const struct ip6t_ip6 uncond ; <S2SV_StartBug> return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> }
CWE-20 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kzfree ( buf ) ; return ret ; }
CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; if ( cmd & 0x01 ) off = * delta ++ ; if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <S2SV_StartBug> if ( cmd & 0x08 ) off |= * delta ++ << 24UL ; <S2SV_EndBug> if ( cmd & 0x10 ) len = * delta ++ ; if ( cmd & 0x20 ) len |= * delta ++ << 8UL ; if ( cmd & 0x40 ) len |= * delta ++ << 16UL ; if ( ! len ) len = 0x10000 ; if ( base_len < off + len || res_sz < len ) goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , "failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta" ) ; return - 1 ; }
CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; <S2SV_StartBug> if ( n <= 0 ) return ( n ) ; <S2SV_EndBug> if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && * p == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } return ( 1 ) ; }
CWE-119 void dvb_usbv2_disconnect ( struct usb_interface * intf ) { struct dvb_usb_device * d = usb_get_intfdata ( intf ) ; <S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> dev_dbg ( & d -> udev -> dev , "%s:<S2SV_blank>bInterfaceNumber=%d\\n" , __func__ , intf -> cur_altsetting -> desc . bInterfaceNumber ) ; if ( d -> props -> exit ) d -> props -> exit ( d ) ; dvb_usbv2_exit ( d ) ; <S2SV_StartBug> dev_info ( & dev , "%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> }
CWE-399 static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; return 0 ; }
CWE-200 static int copy_to_user_tmpl ( struct xfrm_policy * xp , struct sk_buff * skb ) { struct xfrm_user_tmpl vec [ XFRM_MAX_DEPTH ] ; int i ; if ( xp -> xfrm_nr == 0 ) return 0 ; for ( i = 0 ; i < xp -> xfrm_nr ; i ++ ) { struct xfrm_user_tmpl * up = & vec [ i ] ; struct xfrm_tmpl * kp = & xp -> xfrm_vec [ i ] ; <S2SV_StartBug> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <S2SV_EndBug> up -> family = kp -> encap_family ; memcpy ( & up -> saddr , & kp -> saddr , sizeof ( up -> saddr ) ) ; up -> reqid = kp -> reqid ; up -> mode = kp -> mode ; up -> share = kp -> share ; up -> optional = kp -> optional ; up -> aalgos = kp -> aalgos ; up -> ealgos = kp -> ealgos ; up -> calgos = kp -> calgos ; } return nla_put ( skb , XFRMA_TMPL , sizeof ( struct xfrm_user_tmpl ) * xp -> xfrm_nr , vec ) ; }
CWE-787 static OPJ_BOOL opj_j2k_write_first_tile_part ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , opj_stream_private_t * p_stream , struct opj_event_mgr * p_manager ) { OPJ_UINT32 l_nb_bytes_written = 0 ; OPJ_UINT32 l_current_nb_bytes_written ; OPJ_BYTE * l_begin_data = 00 ; opj_tcd_t * l_tcd = 00 ; opj_cp_t * l_cp = 00 ; l_tcd = p_j2k -> m_tcd ; l_cp = & ( p_j2k -> m_cp ) ; l_tcd -> cur_pino = 0 ; p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number = 0 ; l_current_nb_bytes_written = 0 ; l_begin_data = p_data ; <S2SV_StartBug> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <S2SV_EndBug> p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; if ( ! OPJ_IS_CINEMA ( l_cp -> rsiz ) ) { # if 0 for ( compno = 1 ; compno < p_j2k -> m_private_image -> numcomps ; compno ++ ) { l_current_nb_bytes_written = 0 ; opj_j2k_write_coc_in_memory ( p_j2k , compno , p_data , & l_current_nb_bytes_written , p_manager ) ; l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_current_nb_bytes_written = 0 ; opj_j2k_write_qcc_in_memory ( p_j2k , compno , p_data , & l_current_nb_bytes_written , p_manager ) ; l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; } # endif if ( l_cp -> tcps [ p_j2k -> m_current_tile_number ] . numpocs ) { l_current_nb_bytes_written = 0 ; opj_j2k_write_poc_in_memory ( p_j2k , p_data , & l_current_nb_bytes_written , p_manager ) ; l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; } } l_current_nb_bytes_written = 0 ; if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; * p_data_written = l_nb_bytes_written ; opj_write_bytes ( l_begin_data + 6 , l_nb_bytes_written , 4 ) ; if ( OPJ_IS_CINEMA ( l_cp -> rsiz ) ) { opj_j2k_update_tlm ( p_j2k , l_nb_bytes_written ) ; } return OPJ_TRUE ; }
CWE-119 <S2SV_StartBug> static int get_max_filter_level ( VP9_COMP * cpi ) { <S2SV_EndBug> return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-399 SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { struct fsnotify_group * group ; struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; user = get_current_user ( ) ; if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } group = inotify_new_group ( user , inotify_max_queued_events ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( "inotify" , & inotify_fops , group , O_RDONLY | flags ) ; if ( ret >= 0 ) return ret ; <S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> out_free_uid : free_uid ( user ) ; return ret ; }
CWE-399 static void vhost_net_ubuf_put_and_wait ( struct vhost_net_ubuf_ref * ubufs ) { kref_put ( & ubufs -> kref , vhost_net_zerocopy_done_signal ) ; wait_event ( ubufs -> wait , ! atomic_read ( & ubufs -> kref . refcount ) ) ; <S2SV_StartBug> kfree ( ubufs ) ; <S2SV_EndBug> }
CWE-362 int dccp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { const struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ; <S2SV_StartBug> int err ; <S2SV_EndBug> dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ; <S2SV_StartBug> if ( inet -> opt != NULL && inet -> opt -> srr ) { <S2SV_EndBug> if ( daddr == 0 ) return - EINVAL ; <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_DCCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; } <S2SV_StartBug> if ( inet -> opt == NULL || ! inet -> opt -> srr ) <S2SV_EndBug> daddr = rt -> rt_dst ; if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( inet -> opt != NULL ) <S2SV_EndBug> inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet_hash_connect ( & dccp_death_row , sk ) ; if ( err != 0 ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { rt = NULL ; goto failure ; } sk_setup_caps ( sk , & rt -> dst ) ; dp -> dccps_iss = secure_dccp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , inet -> inet_dport ) ; inet -> inet_id = dp -> dccps_iss ^ jiffies ; err = dccp_connect ( sk ) ; rt = NULL ; if ( err != 0 ) goto failure ; out : return err ; failure : dccp_set_state ( sk , DCCP_CLOSED ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; goto out ; }
CWE-399 static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; <S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }
CWE-119 static void zz_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , YV12_BUFFER_CONFIG * raw_buffer , int * raw_motion_err , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; unsigned char * src_ptr = ( * ( b -> base_src ) + b -> src ) ; int src_stride = b -> src_stride ; unsigned char * raw_ptr ; int raw_stride = raw_buffer -> y_stride ; unsigned char * ref_ptr ; int ref_stride = x -> e_mbd . pre . y_stride ; <S2SV_StartBug> raw_ptr = ( unsigned char * ) ( raw_buffer -> y_buffer + recon_yoffset <S2SV_EndBug> + d -> offset ) ; <S2SV_StartBug> vp8_mse16x16 ( src_ptr , src_stride , raw_ptr , raw_stride , <S2SV_EndBug> ( unsigned int * ) ( raw_motion_err ) ) ; xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; ref_ptr = ( unsigned char * ) ( xd -> pre . y_buffer + d -> offset ) ; <S2SV_StartBug> vp8_mse16x16 ( src_ptr , src_stride , ref_ptr , ref_stride , <S2SV_EndBug> ( unsigned int * ) ( best_motion_err ) ) ; }
CWE-119 static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { <S2SV_StartBug> int rc ; <S2SV_EndBug> unsigned char key2 [ 8 ] ; <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( "ecb(des)" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> if ( IS_ERR ( tfm_des ) ) { <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> cifs_dbg ( VFS , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n" ) ; <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , "could<S2SV_blank>not<S2SV_blank>encrypt<S2SV_blank>crypt<S2SV_blank>key<S2SV_blank>rc:<S2SV_blank>%d\\n" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; <S2SV_StartBug> smbhash_err : <S2SV_EndBug> return rc ; }
CWE-200 static unsigned create_oops_dump_dirs ( GList * oops_list , unsigned oops_cnt ) { unsigned countdown = MAX_DUMPED_DD_COUNT ; log_notice ( "Saving<S2SV_blank>%u<S2SV_blank>oopses<S2SV_blank>as<S2SV_blank>problem<S2SV_blank>dirs" , oops_cnt >= countdown ? countdown : oops_cnt ) ; char * cmdline_str = xmalloc_fopen_fgetline_fclose ( "/proc/cmdline" ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( "/proc/sys/crypto/fips_enabled" ) ; char * proc_modules = xmalloc_open_read_close ( "/proc/modules" , NULL ) ; char * suspend_stats = xmalloc_open_read_close ( "/sys/kernel/debug/suspend_stats" , NULL ) ; time_t t = time ( NULL ) ; const char * iso_date = iso_date_string ( & t ) ; uid_t my_euid = ( uid_t ) - 1L ; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH ; if ( ! world_readable_dump ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } <S2SV_StartBug> pid_t my_pid = getpid ( ) ; <S2SV_EndBug> unsigned idx = 0 ; unsigned errors = 0 ; while ( idx < oops_cnt ) { char base [ sizeof ( "oops-YYYY-MM-DD-hh:mm:ss-%lu-%lu" ) + 2 * sizeof ( long ) * 3 ] ; sprintf ( base , "oops-%s-%lu-%lu" , iso_date , ( long ) my_pid , ( long ) idx ) ; char * path = concat_path_file ( debug_dumps_dir , base ) ; struct dump_dir * dd = dd_create ( path , my_euid , mode ) ; if ( dd ) { dd_create_basic_files ( dd , my_euid , NULL ) ; save_oops_data_in_dump_dir ( dd , ( char * ) g_list_nth_data ( oops_list , idx ++ ) , proc_modules ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; dd_save_text ( dd , FILENAME_ANALYZER , "Kerneloops" ) ; dd_save_text ( dd , FILENAME_TYPE , "Kerneloops" ) ; if ( cmdline_str ) dd_save_text ( dd , FILENAME_CMDLINE , cmdline_str ) ; if ( proc_modules ) dd_save_text ( dd , "proc_modules" , proc_modules ) ; if ( fips_enabled && strcmp ( fips_enabled , "0" ) != 0 ) dd_save_text ( dd , "fips_enabled" , fips_enabled ) ; if ( suspend_stats ) dd_save_text ( dd , "suspend_stats" , suspend_stats ) ; dd_close ( dd ) ; notify_new_path ( path ) ; } else errors ++ ; free ( path ) ; if ( -- countdown == 0 ) break ; if ( dd && throttle_dd_creation ) sleep ( 1 ) ; } free ( cmdline_str ) ; free ( proc_modules ) ; free ( fips_enabled ) ; free ( suspend_stats ) ; return errors ; }
CWE-20 static int pfkey_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * skb ; int copied , err ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT ) ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; err = ( flags & MSG_TRUNC ) ? skb -> len : copied ; if ( pfk -> dump . dump != NULL && 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) pfkey_do_dump ( pfk ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
CWE-119 static TX_SIZE read_selected_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_StartBug> TX_SIZE max_tx_size , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> const int ctx = vp9_get_tx_size_context ( xd ) ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * tx_probs = get_tx_probs ( max_tx_size , ctx , & cm -> fc . tx_probs ) ; <S2SV_EndBug> <S2SV_StartBug> int tx_size = vp9_read ( r , tx_probs [ 0 ] ) ; <S2SV_EndBug> if ( tx_size != TX_4X4 && max_tx_size >= TX_16X16 ) { <S2SV_StartBug> tx_size += vp9_read ( r , tx_probs [ 1 ] ) ; <S2SV_EndBug> if ( tx_size != TX_8X8 && max_tx_size >= TX_32X32 ) <S2SV_StartBug> tx_size += vp9_read ( r , tx_probs [ 2 ] ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> <S2SV_StartBug> ++ get_tx_counts ( max_tx_size , ctx , & cm -> counts . tx ) [ tx_size ] ; <S2SV_EndBug> return ( TX_SIZE ) tx_size ; }
CWE-000 static int save_dev ( blkid_dev dev , FILE * file ) { struct list_head * p ; if ( ! dev || dev -> bid_name [ 0 ] != '/' ) return 0 ; DBG ( SAVE , ul_debug ( "device<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s" , dev -> bid_name , dev -> bid_type ? dev -> bid_type : "(null)" ) ) ; fprintf ( file , "<device<S2SV_blank>DEVNO=\\"0x%04lx\\"<S2SV_blank>TIME=\\"%ld.%ld\\"" , ( unsigned long ) dev -> bid_devno , ( long ) dev -> bid_time , ( long ) dev -> bid_utime ) ; if ( dev -> bid_pri ) fprintf ( file , "<S2SV_blank>PRI=\\"%d\\"" , dev -> bid_pri ) ; list_for_each ( p , & dev -> bid_tags ) { blkid_tag tag = list_entry ( p , struct blkid_struct_tag , bit_tags ) ; <S2SV_StartBug> fprintf ( file , "<S2SV_blank>%s=\\"%s\\"" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> } fprintf ( file , ">%s</device>\\n" , dev -> bid_name ) ; return 0 ; }
CWE-416 static int get_task_ioprio ( struct task_struct * p ) { int ret ; ret = security_task_getioprio ( p ) ; if ( ret ) goto out ; ret = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_NONE , IOPRIO_NORM ) ; <S2SV_StartBug> if ( p -> io_context ) <S2SV_EndBug> ret = p -> io_context -> ioprio ; <S2SV_StartBug> out : <S2SV_EndBug> return ret ; }
CWE-416 int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = mem_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , "Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-20 static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( data + data_sz <= data ) { res = VPX_CODEC_INVALID_PARAM ; } else { uint8_t clear_buffer [ 10 ] ; const uint8_t * clear = data ; if ( decrypt_cb ) { int n = MIN ( sizeof ( clear_buffer ) , data_sz ) ; decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } si -> is_kf = 0 ; if ( data_sz >= 10 && ! ( clear [ 0 ] & 0x01 ) ) { si -> is_kf = 1 ; if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) return VPX_CODEC_UNSUP_BITSTREAM ; si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ; <S2SV_StartBug> if ( ! ( si -> h | si -> w ) ) <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> } <S2SV_StartBug> else <S2SV_EndBug> { res = VPX_CODEC_UNSUP_BITSTREAM ; } } return res ; }
CWE-125 <S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug> int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; __generic_ld_st ( op , "ram" , 0 , 1 , 0 , k , 0 ) ; ESIL_A ( "r%d,=," , d ) ; }
CWE-000 static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { <S2SV_StartBug> struct mount * n , * p ; <S2SV_EndBug> for ( n = m ; ; n = p ) { p = n -> mnt_master ; <S2SV_StartBug> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <S2SV_EndBug> while ( last_dest -> mnt_master != p ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } if ( ! peers ( n , last_dest ) ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } break ; } } type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( & mount_lock ) ; } hlist_add_head ( & child -> mnt_hash , list ) ; return 0 ; }
CWE-476 static bool CopyKeyAliasesToKeymap ( struct xkb_keymap * keymap , KeyNamesInfo * info ) { AliasInfo * alias ; unsigned i , num_key_aliases ; struct xkb_key_alias * key_aliases ; num_key_aliases = 0 ; darray_foreach ( alias , info -> aliases ) { if ( ! XkbKeyByName ( keymap , alias -> real , false ) ) { log_vrb ( info -> ctx , 5 , "Attempt<S2SV_blank>to<S2SV_blank>alias<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>non-existent<S2SV_blank>key<S2SV_blank>%s;<S2SV_blank>Ignored\\n" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } if ( XkbKeyByName ( keymap , alias -> alias , false ) ) { log_vrb ( info -> ctx , 5 , "Attempt<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alias<S2SV_blank>with<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>a<S2SV_blank>real<S2SV_blank>key;<S2SV_blank>" "Alias<S2SV_blank>\\"%s<S2SV_blank>=<S2SV_blank>%s\\"<S2SV_blank>ignored\\n" , KeyNameText ( info -> ctx , alias -> alias ) , KeyNameText ( info -> ctx , alias -> real ) ) ; alias -> real = XKB_ATOM_NONE ; continue ; } num_key_aliases ++ ; } key_aliases = NULL ; if ( num_key_aliases > 0 ) { key_aliases = calloc ( num_key_aliases , sizeof ( * key_aliases ) ) ; if ( ! key_aliases ) return false ; <S2SV_StartBug> } <S2SV_EndBug> i = 0 ; darray_foreach ( alias , info -> aliases ) { if ( alias -> real != XKB_ATOM_NONE ) { key_aliases [ i ] . alias = alias -> alias ; key_aliases [ i ] . real = alias -> real ; i ++ ; } } <S2SV_StartBug> keymap -> num_key_aliases = num_key_aliases ; <S2SV_EndBug> keymap -> key_aliases = key_aliases ; return true ; }
CWE-190 static int jas_iccgetuint64 ( jas_stream_t * in , jas_iccuint64_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
CWE-119 void vp8mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd ) { VP8_COMMON * pc = & pbi -> common ; unsigned int i ; int j ; int filter_level = pc -> filter_level ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; if ( filter_level ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> for ( j = 1 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> } for ( j = 0 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> } vp8_loop_filter_frame_init ( pc , & pbi -> mb , filter_level ) ; } else vp8_setup_intra_recon_top_line ( yv12_fb_new ) ; setup_decoding_thread_data ( pbi , xd , pbi -> mb_row_di , pbi -> decoding_thread_count ) ; for ( i = 0 ; i < pbi -> decoding_thread_count ; i ++ ) sem_post ( & pbi -> h_event_start_decoding [ i ] ) ; mt_decode_mb_rows ( pbi , xd , 0 ) ; sem_wait ( & pbi -> h_event_end_decoding ) ; }
CWE-119 void vp8_second_pass ( VP8_COMP * cpi ) { int tmp_q ; int frames_left = ( int ) ( cpi -> twopass . total_stats . count - cpi -> common . current_video_frame ) ; FIRSTPASS_STATS this_frame = { 0 } ; FIRSTPASS_STATS this_frame_copy ; double this_frame_intra_error ; double this_frame_coded_error ; int overhead_bits ; if ( ! cpi -> twopass . stats_in ) { return ; } vp8_clear_system_state ( ) ; if ( EOF == input_stats ( cpi , & this_frame ) ) return ; this_frame_intra_error = this_frame . intra_error ; this_frame_coded_error = this_frame . coded_error ; if ( cpi -> twopass . frames_to_key == 0 ) { <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> find_next_key_frame ( cpi , & this_frame_copy ) ; if ( cpi -> oxcf . error_resilient_mode ) { cpi -> twopass . gf_group_bits = cpi -> twopass . kf_group_bits ; cpi -> twopass . gf_group_error_left = ( int ) cpi -> twopass . kf_group_error_left ; cpi -> baseline_gf_interval = cpi -> twopass . frames_to_key ; cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; cpi -> source_alt_ref_pending = 0 ; } } if ( cpi -> frames_till_gf_update_due == 0 ) { <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> define_gf_group ( cpi , & this_frame_copy ) ; if ( cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) { int bak = cpi -> per_frame_bandwidth ; <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> assign_std_frame_bits ( cpi , & this_frame_copy ) ; cpi -> per_frame_bandwidth = bak ; } } else { if ( cpi -> oxcf . error_resilient_mode ) { cpi -> frames_till_gf_update_due = cpi -> twopass . frames_to_key ; if ( cpi -> common . frame_type != KEY_FRAME ) { <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> assign_std_frame_bits ( cpi , & this_frame_copy ) ; } } else { <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> assign_std_frame_bits ( cpi , & this_frame_copy ) ; } } cpi -> twopass . this_iiratio = ( unsigned int ) ( this_frame_intra_error / DOUBLE_DIVIDE_CHECK ( this_frame_coded_error ) ) ; { FIRSTPASS_STATS next_frame ; if ( lookup_next_frame_stats ( cpi , & next_frame ) != EOF ) { cpi -> twopass . next_iiratio = ( unsigned int ) ( next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; } } cpi -> target_bandwidth = ( int ) ( cpi -> per_frame_bandwidth * cpi -> output_framerate ) ; if ( cpi -> target_bandwidth < 0 ) cpi -> target_bandwidth = 0 ; overhead_bits = ( int ) estimate_modemvcost ( cpi , & cpi -> twopass . total_left_stats ) ; if ( cpi -> common . current_video_frame == 0 ) { cpi -> twopass . est_max_qcorrection_factor = 1.0 ; if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) { int est_cq ; est_cq = estimate_cq ( cpi , & cpi -> twopass . total_left_stats , ( int ) ( cpi -> twopass . bits_left / frames_left ) , overhead_bits ) ; cpi -> cq_target_quality = cpi -> oxcf . cq_level ; if ( est_cq > cpi -> cq_target_quality ) cpi -> cq_target_quality = est_cq ; } cpi -> twopass . maxq_max_limit = cpi -> worst_quality ; cpi -> twopass . maxq_min_limit = cpi -> best_quality ; tmp_q = estimate_max_q ( cpi , & cpi -> twopass . total_left_stats , ( int ) ( cpi -> twopass . bits_left / frames_left ) , overhead_bits ) ; cpi -> twopass . maxq_max_limit = ( ( tmp_q + 32 ) < cpi -> worst_quality ) ? ( tmp_q + 32 ) : cpi -> worst_quality ; cpi -> twopass . maxq_min_limit = ( ( tmp_q - 32 ) > cpi -> best_quality ) ? ( tmp_q - 32 ) : cpi -> best_quality ; cpi -> active_worst_quality = tmp_q ; cpi -> ni_av_qi = tmp_q ; } else if ( ( cpi -> common . current_video_frame < ( ( ( unsigned int ) cpi -> twopass . total_stats . count * 255 ) >> 8 ) ) && ( ( cpi -> common . current_video_frame + cpi -> baseline_gf_interval ) < ( unsigned int ) cpi -> twopass . total_stats . count ) ) { if ( frames_left < 1 ) frames_left = 1 ; tmp_q = estimate_max_q ( cpi , & cpi -> twopass . total_left_stats , ( int ) ( cpi -> twopass . bits_left / frames_left ) , overhead_bits ) ; if ( tmp_q > cpi -> active_worst_quality ) cpi -> active_worst_quality ++ ; else if ( tmp_q < cpi -> active_worst_quality ) cpi -> active_worst_quality -- ; cpi -> active_worst_quality = ( ( cpi -> active_worst_quality * 3 ) + tmp_q + 2 ) / 4 ; } cpi -> twopass . frames_to_key -- ; subtract_stats ( & cpi -> twopass . total_left_stats , & this_frame ) ; }
CWE-119 struct se_portal_group * tcm_loop_make_naa_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct tcm_loop_hba * tl_hba = container_of ( wwn , struct tcm_loop_hba , tl_hba_wwn ) ; struct tcm_loop_tpg * tl_tpg ; char * tpgt_str , * end_ptr ; int ret ; unsigned short int tpgt ; tpgt_str = strstr ( name , "tpgt_" ) ; if ( ! tpgt_str ) { printk ( KERN_ERR "Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>\\"tpgt_#\\"<S2SV_blank>directory" "<S2SV_blank>group\\n" ) ; return ERR_PTR ( - EINVAL ) ; } tpgt_str += 5 ; tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> printk ( KERN_ERR "Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:" "<S2SV_blank>%u\\n" , tpgt , TL_TPGS_PER_HBA ) ; return ERR_PTR ( - EINVAL ) ; } tl_tpg = & tl_hba -> tl_hba_tpgs [ tpgt ] ; tl_tpg -> tl_hba = tl_hba ; tl_tpg -> tl_tpgt = tpgt ; ret = core_tpg_register ( & tcm_loop_fabric_configfs -> tf_ops , wwn , & tl_tpg -> tl_se_tpg , tl_tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) return ERR_PTR ( - ENOMEM ) ; printk ( KERN_INFO "TCM_Loop_ConfigFS:<S2SV_blank>Allocated<S2SV_blank>Emulated<S2SV_blank>%s" "<S2SV_blank>Target<S2SV_blank>Port<S2SV_blank>%s,t,0x%04x\\n" , tcm_loop_dump_proto_id ( tl_hba ) , config_item_name ( & wwn -> wwn_group . cg_item ) , tpgt ) ; return & tl_tpg -> tl_se_tpg ; }
CWE-119 <S2SV_StartBug> static int cost_mv_ref ( const VP9_COMP * cpi , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> int mode_context ) { <S2SV_EndBug> const MACROBLOCK * const x = & cpi -> mb ; const int segment_id = x -> e_mbd . mi [ 0 ] -> mbmi . segment_id ; if ( ! vp9_segfeature_active ( & cpi -> common . seg , segment_id , SEG_LVL_SKIP ) ) { assert ( is_inter_mode ( mode ) ) ; <S2SV_StartBug> return x -> inter_mode_cost [ mode_context ] [ INTER_OFFSET ( mode ) ] ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> return 0 ; } }
CWE-125 int WavpackVerifySingleBlock ( unsigned char * buffer , int verify_checksum ) { WavpackHeader * wphdr = ( WavpackHeader * ) buffer ; uint32_t checksum_passed = 0 , bcount , meta_bc ; unsigned char * dp , meta_id , c1 , c2 ; if ( strncmp ( wphdr -> ckID , "wvpk" , 4 ) || wphdr -> ckSize + 8 < sizeof ( WavpackHeader ) ) return FALSE ; bcount = wphdr -> ckSize - sizeof ( WavpackHeader ) + 8 ; dp = ( unsigned char * ) ( wphdr + 1 ) ; while ( bcount >= 2 ) { meta_id = * dp ++ ; c1 = * dp ++ ; meta_bc = c1 << 1 ; bcount -= 2 ; if ( meta_id & ID_LARGE ) { if ( bcount < 2 ) return FALSE ; c1 = * dp ++ ; c2 = * dp ++ ; meta_bc += ( ( uint32_t ) c1 << 9 ) + ( ( uint32_t ) c2 << 17 ) ; bcount -= 2 ; } if ( bcount < meta_bc ) return FALSE ; if ( verify_checksum && ( meta_id & ID_UNIQUE ) == ID_BLOCK_CHECKSUM ) { # ifdef BITSTREAM_SHORTS uint16_t * csptr = ( uint16_t * ) buffer ; # else unsigned char * csptr = buffer ; # endif int wcount = ( int ) ( dp - 2 - buffer ) >> 1 ; uint32_t csum = ( uint32_t ) - 1 ; if ( ( meta_id & ID_ODD_SIZE ) || meta_bc < 2 || meta_bc > 4 ) return FALSE ; # ifdef BITSTREAM_SHORTS while ( wcount -- ) csum = ( csum * 3 ) + * csptr ++ ; # else WavpackNativeToLittleEndian ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; while ( wcount -- ) { csum = ( csum * 3 ) + csptr [ 0 ] + ( csptr [ 1 ] << 8 ) ; csptr += 2 ; } WavpackLittleEndianToNative ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; # endif if ( meta_bc == 4 ) { <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> return FALSE ; } else { csum ^= csum >> 16 ; <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug> return FALSE ; } checksum_passed ++ ; } bcount -= meta_bc ; dp += meta_bc ; } return ( bcount == 0 ) && ( ! verify_checksum || ! ( wphdr -> flags & HAS_CHECKSUM ) || checksum_passed ) ; }
CWE-119 void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { <S2SV_StartBug> cpi -> zbin_mode_boost = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; <S2SV_EndBug> }
CWE-119 static unsigned int tt_activity_measure ( VP8_COMP * cpi , MACROBLOCK * x ) { unsigned int act ; unsigned int sse ; <S2SV_StartBug> act = vp8_variance16x16 ( x -> src . y_buffer , <S2SV_EndBug> x -> src . y_stride , VP8_VAR_OFFS , 0 , & sse ) ; act = act << 4 ; if ( act < 8 << 12 ) act = act < 5 << 12 ? act : 5 << 12 ; return act ; }
CWE-000 <S2SV_StartBug> static void parse_input ( h2o_http2_conn_t * conn ) <S2SV_EndBug> { size_t http2_max_concurrent_requests_per_connection = conn -> super . ctx -> globalconf -> http2 . max_concurrent_requests_per_connection ; int perform_early_exit = 0 ; if ( conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed != http2_max_concurrent_requests_per_connection ) perform_early_exit = 1 ; while ( conn -> state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn -> sock -> input -> size != 0 ) { if ( perform_early_exit == 1 && conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed == http2_max_concurrent_requests_per_connection ) goto EarlyExit ; const char * err_desc = NULL ; ssize_t ret = conn -> _read_expect ( conn , ( uint8_t * ) conn -> sock -> input -> bytes , conn -> sock -> input -> size , & err_desc ) ; if ( ret == H2O_HTTP2_ERROR_INCOMPLETE ) { break ; } else if ( ret < 0 ) { if ( ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY ) { enqueue_goaway ( conn , ( int ) ret , err_desc != NULL ? ( h2o_iovec_t ) { ( char * ) err_desc , strlen ( err_desc ) } : ( h2o_iovec_t ) { } ) ; } <S2SV_StartBug> close_connection ( conn ) ; <S2SV_EndBug> return ; } h2o_buffer_consume ( & conn -> sock -> input , ret ) ; } if ( ! h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_start ( conn -> sock , on_read ) ; <S2SV_StartBug> return ; <S2SV_EndBug> EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static void open_output_file ( struct stream_state * stream , <S2SV_StartBug> struct VpxEncoderConfig * global ) { <S2SV_EndBug> const char * fn = stream -> config . out_fn ; const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; stream -> file = strcmp ( fn , "-" ) ? fopen ( fn , "wb" ) : set_binary_mode ( stdout ) ; if ( ! stream -> file ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file" ) ; if ( stream -> config . write_webm && fseek ( stream -> file , 0 , SEEK_CUR ) ) fatal ( "WebM<S2SV_blank>output<S2SV_blank>to<S2SV_blank>pipes<S2SV_blank>not<S2SV_blank>supported." ) ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { stream -> ebml . stream = stream -> file ; write_webm_file_header ( & stream -> ebml , cfg , & global -> framerate , stream -> config . stereo_fmt , <S2SV_StartBug> global -> codec -> fourcc ) ; <S2SV_EndBug> } # endif if ( ! stream -> config . write_webm ) { ivf_write_file_header ( stream -> file , cfg , global -> codec -> fourcc , 0 ) ; } }
CWE-000 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_start_code ; IMPEG2D_ERROR_CODES_T e_error ; e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && <S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> { if ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_dec_user_data ( ps_dec ) ; } else { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; switch ( u4_start_code ) { case QUANT_MATRIX_EXT_ID : impeg2d_dec_quant_matrix_ext ( ps_dec ) ; break ; case COPYRIGHT_EXT_ID : impeg2d_dec_copyright_ext ( ps_dec ) ; break ; case PIC_DISPLAY_EXT_ID : impeg2d_dec_pic_disp_ext ( ps_dec ) ; break ; case CAMERA_PARAM_EXT_ID : impeg2d_dec_cam_param_ext ( ps_dec ) ; break ; case ITU_T_EXT_ID : impeg2d_dec_itu_t_ext ( ps_dec ) ; break ; case PIC_SPATIAL_SCALABLE_EXT_ID : case PIC_TEMPORAL_SCALABLE_EXT_ID : e_error = IMPEG2D_SCALABLITY_NOT_SUP ; break ; default : impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; impeg2d_next_start_code ( ps_dec ) ; break ; } } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } return e_error ; }
CWE-119 void btif_config_flush ( void ) { assert ( config != NULL ) ; assert ( alarm_timer != NULL ) ; alarm_cancel ( alarm_timer ) ; <S2SV_StartBug> pthread_mutex_lock ( & lock ) ; <S2SV_EndBug> config_save ( config , CONFIG_FILE_PATH ) ; pthread_mutex_unlock ( & lock ) ; }
CWE-416 static void nick_hash_remove ( CHANNEL_REC * channel , NICK_REC * nick ) { <S2SV_StartBug> NICK_REC * list ; <S2SV_EndBug> list = g_hash_table_lookup ( channel -> nicks , nick -> nick ) ; if ( list == NULL ) return ; <S2SV_StartBug> if ( list == nick || list -> next == NULL ) { <S2SV_EndBug> g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( list -> next != NULL ) { <S2SV_StartBug> g_hash_table_insert ( channel -> nicks , nick -> next -> nick , <S2SV_EndBug> nick -> next ) ; } <S2SV_StartBug> } else { <S2SV_EndBug> while ( list -> next != nick ) list = list -> next ; list -> next = nick -> next ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-416 int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , "Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\n" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }
CWE-119 int vp8_alloc_frame_buffers ( VP8_COMMON * oci , int width , int height ) { int i ; vp8_de_alloc_frame_buffers ( oci ) ; if ( ( width & 0xf ) != 0 ) width += 16 - ( width & 0xf ) ; if ( ( height & 0xf ) != 0 ) height += 16 - ( height & 0xf ) ; for ( i = 0 ; i < NUM_YV12_BUFFERS ; i ++ ) { oci -> fb_idx_ref_cnt [ i ] = 0 ; oci -> yv12_fb [ i ] . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & oci -> yv12_fb [ i ] , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; } oci -> new_fb_idx = 0 ; oci -> lst_fb_idx = 1 ; oci -> gld_fb_idx = 2 ; oci -> alt_fb_idx = 3 ; oci -> fb_idx_ref_cnt [ 0 ] = 1 ; oci -> fb_idx_ref_cnt [ 1 ] = 1 ; oci -> fb_idx_ref_cnt [ 2 ] = 1 ; oci -> fb_idx_ref_cnt [ 3 ] = 1 ; if ( vp8_yv12_alloc_frame_buffer ( & oci -> temp_scale_frame , width , 16 , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; oci -> mb_rows = height >> 4 ; oci -> mb_cols = width >> 4 ; oci -> MBs = oci -> mb_rows * oci -> mb_cols ; oci -> mode_info_stride = oci -> mb_cols + 1 ; oci -> mip = vpx_calloc ( ( oci -> mb_cols + 1 ) * ( oci -> mb_rows + 1 ) , sizeof ( MODE_INFO ) ) ; if ( ! oci -> mip ) goto allocation_fail ; oci -> mi = oci -> mip + oci -> mode_info_stride + 1 ; oci -> above_context = vpx_calloc ( sizeof ( ENTROPY_CONTEXT_PLANES ) * oci -> mb_cols , 1 ) ; if ( ! oci -> above_context ) goto allocation_fail ; # if CONFIG_POSTPROC if ( vp8_yv12_alloc_frame_buffer ( & oci -> post_proc_buffer , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; oci -> post_proc_buffer_int_used = 0 ; <S2SV_StartBug> vpx_memset ( & oci -> postproc_state , 0 , sizeof ( oci -> postproc_state ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( oci -> post_proc_buffer . buffer_alloc , 128 , <S2SV_EndBug> oci -> post_proc_buffer . frame_size ) ; oci -> pp_limits_buffer = vpx_memalign ( 16 , 24 * ( ( oci -> mb_cols + 1 ) & ~ 1 ) ) ; if ( ! oci -> pp_limits_buffer ) goto allocation_fail ; # endif return 0 ; allocation_fail : vp8_de_alloc_frame_buffers ( oci ) ; return 1 ; }
CWE-399 static void kvmclock_reset ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> kvm_release_page_dirty ( vcpu -> arch . time_page ) ; vcpu -> arch . time_page = NULL ; } }
CWE-119 <S2SV_StartBug> static void update_switchable_interp_probs ( VP9_COMMON * cm , vp9_writer * w ) { <S2SV_EndBug> int j ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) prob_diff_update ( vp9_switchable_interp_tree , <S2SV_StartBug> cm -> fc . switchable_interp_prob [ j ] , <S2SV_EndBug> <S2SV_StartBug> cm -> counts . switchable_interp [ j ] , SWITCHABLE_FILTERS , w ) ; <S2SV_EndBug> }
CWE-119 static uint8_t excluded_channels ( bitfile * ld , drc_info * drc ) { uint8_t i , n = 0 ; uint8_t num_excl_chan = 7 ; for ( i = 0 ; i < 7 ; i ++ ) { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 103 , "excluded_channels():<S2SV_blank>exclude_mask" ) ) ; } n ++ ; while ( ( drc -> additional_excluded_chns [ n - 1 ] = faad_get1bit ( ld DEBUGVAR ( 1 , 104 , "excluded_channels():<S2SV_blank>additional_excluded_chns" ) ) ) == 1 ) { <S2SV_StartBug> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <S2SV_EndBug> { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 105 , "excluded_channels():<S2SV_blank>exclude_mask" ) ) ; } n ++ ; num_excl_chan += 7 ; } return n ; }
CWE-000 static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; unsigned char * in ; long in_len , out_len ; VALUE data , str ; rb_scan_args ( argc , argv , "11" , & data , & str ) ; <S2SV_StartBug> StringValue ( data ) ; <S2SV_EndBug> in = ( unsigned char * ) RSTRING_PTR ( data ) ; if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , "data<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty" ) ; GetCipher ( self , ctx ) ; out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ; if ( out_len <= 0 ) { ossl_raise ( rb_eRangeError , "data<S2SV_blank>too<S2SV_blank>big<S2SV_blank>to<S2SV_blank>make<S2SV_blank>output<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>bytes" , in_len ) ; } if ( NIL_P ( str ) ) { str = rb_str_new ( 0 , out_len ) ; } else { StringValue ( str ) ; rb_str_resize ( str , out_len ) ; } if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ; assert ( out_len < RSTRING_LEN ( str ) ) ; rb_str_set_len ( str , out_len ) ; return str ; }
CWE-476 long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; <S2SV_StartBug> ret = key_permission ( key_ref , KEY_NEED_READ ) ; <S2SV_EndBug> if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
CWE-20 static ext3_fsblk_t get_sb_block ( void * * data , struct super_block * sb ) { ext3_fsblk_t sb_block ; char * options = ( char * ) * data ; if ( ! options || strncmp ( options , "sb=" , 3 ) != 0 ) return 1 ; options += 3 ; sb_block = simple_strtoul ( options , & options , 0 ) ; if ( * options && * options != ',' ) { <S2SV_StartBug> ext3_msg ( sb , "error:<S2SV_blank>invalid<S2SV_blank>sb<S2SV_blank>specification:<S2SV_blank>%s" , <S2SV_EndBug> ( char * ) * data ) ; return 1 ; } if ( * options == ',' ) options ++ ; * data = ( void * ) options ; return sb_block ; }
CWE-119 RD_BOOL <S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , "ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }
CWE-125 static size_t consume_init_expr ( ut8 * buf , ut8 * max , ut8 eoc , void * out , ut32 * offset ) { ut32 i = 0 ; while ( buf + i < max && buf [ i ] != eoc ) { <S2SV_StartBug> i += 1 ; <S2SV_EndBug> } if ( buf [ i ] != eoc ) { return 0 ; } if ( offset ) { * offset += i + 1 ; } return i + 1 ; }
CWE-416 struct sk_buff * skb_segment ( struct sk_buff * head_skb , netdev_features_t features ) { struct sk_buff * segs = NULL ; struct sk_buff * tail = NULL ; struct sk_buff * list_skb = skb_shinfo ( head_skb ) -> frag_list ; skb_frag_t * frag = skb_shinfo ( head_skb ) -> frags ; unsigned int mss = skb_shinfo ( head_skb ) -> gso_size ; <S2SV_StartBug> unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ; <S2SV_EndBug> unsigned int offset = doffset ; unsigned int tnl_hlen = skb_tnl_header_len ( head_skb ) ; unsigned int headroom ; unsigned int len ; __be16 proto ; bool csum ; int sg = ! ! ( features & NETIF_F_SG ) ; int nfrags = skb_shinfo ( head_skb ) -> nr_frags ; int err = - ENOMEM ; int i = 0 ; int pos ; proto = skb_network_protocol ( head_skb ) ; if ( unlikely ( ! proto ) ) return ERR_PTR ( - EINVAL ) ; csum = ! ! can_checksum_protocol ( features , proto ) ; __skb_push ( head_skb , doffset ) ; headroom = skb_headroom ( head_skb ) ; pos = skb_headlen ( head_skb ) ; do { struct sk_buff * nskb ; skb_frag_t * nskb_frag ; int hsize ; int size ; len = head_skb -> len - offset ; if ( len > mss ) len = mss ; hsize = skb_headlen ( head_skb ) - offset ; if ( hsize < 0 ) hsize = 0 ; if ( hsize > len || ! sg ) hsize = len ; if ( ! hsize && i >= nfrags && skb_headlen ( list_skb ) && ( skb_headlen ( list_skb ) == len || sg ) ) { BUG_ON ( skb_headlen ( list_skb ) > len ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ; <S2SV_StartBug> pos += skb_headlen ( list_skb ) ; <S2SV_EndBug> while ( pos < offset + len ) { BUG_ON ( i >= nfrags ) ; size = skb_frag_size ( frag ) ; if ( pos + size > offset + len ) break ; i ++ ; pos += size ; frag ++ ; } nskb = skb_clone ( list_skb , GFP_ATOMIC ) ; list_skb = list_skb -> next ; if ( unlikely ( ! nskb ) ) goto err ; if ( unlikely ( pskb_trim ( nskb , len ) ) ) { kfree_skb ( nskb ) ; goto err ; } hsize = skb_end_offset ( nskb ) ; if ( skb_cow_head ( nskb , doffset + headroom ) ) { kfree_skb ( nskb ) ; goto err ; } nskb -> truesize += skb_end_offset ( nskb ) - hsize ; skb_release_head_state ( nskb ) ; __skb_push ( nskb , doffset ) ; } else { nskb = __alloc_skb ( hsize + doffset + headroom , GFP_ATOMIC , skb_alloc_rx_flag ( head_skb ) , NUMA_NO_NODE ) ; if ( unlikely ( ! nskb ) ) goto err ; skb_reserve ( nskb , headroom ) ; __skb_put ( nskb , doffset ) ; } if ( segs ) tail -> next = nskb ; else segs = nskb ; tail = nskb ; __copy_skb_header ( nskb , head_skb ) ; nskb -> mac_len = head_skb -> mac_len ; skb_headers_offset_update ( nskb , skb_headroom ( nskb ) - headroom ) ; skb_copy_from_linear_data_offset ( head_skb , - tnl_hlen , nskb -> data - tnl_hlen , doffset + tnl_hlen ) ; if ( nskb -> len == len + doffset ) goto perform_csum_check ; if ( ! sg ) { nskb -> ip_summed = CHECKSUM_NONE ; nskb -> csum = skb_copy_and_csum_bits ( head_skb , offset , skb_put ( nskb , len ) , len , 0 ) ; continue ; } nskb_frag = skb_shinfo ( nskb ) -> frags ; skb_copy_from_linear_data_offset ( head_skb , offset , skb_put ( nskb , hsize ) , hsize ) ; skb_shinfo ( nskb ) -> tx_flags = skb_shinfo ( head_skb ) -> tx_flags & SKBTX_SHARED_FRAG ; while ( pos < offset + len ) { if ( i >= nfrags ) { BUG_ON ( skb_headlen ( list_skb ) ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ; <S2SV_StartBug> BUG_ON ( ! nfrags ) ; <S2SV_EndBug> list_skb = list_skb -> next ; } if ( unlikely ( skb_shinfo ( nskb ) -> nr_frags >= MAX_SKB_FRAGS ) ) { net_warn_ratelimited ( "skb_segment:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>frags:<S2SV_blank>%u<S2SV_blank>%u\\n" , pos , mss ) ; goto err ; } <S2SV_StartBug> * nskb_frag = * frag ; <S2SV_EndBug> __skb_frag_ref ( nskb_frag ) ; size = skb_frag_size ( nskb_frag ) ; if ( pos < offset ) { nskb_frag -> page_offset += offset - pos ; skb_frag_size_sub ( nskb_frag , offset - pos ) ; } skb_shinfo ( nskb ) -> nr_frags ++ ; if ( pos + size <= offset + len ) { i ++ ; frag ++ ; pos += size ; } else { skb_frag_size_sub ( nskb_frag , pos + size - ( offset + len ) ) ; goto skip_fraglist ; } nskb_frag ++ ; } skip_fraglist : nskb -> data_len = len - hsize ; nskb -> len += nskb -> data_len ; nskb -> truesize += nskb -> data_len ; perform_csum_check : if ( ! csum ) { nskb -> csum = skb_checksum ( nskb , doffset , nskb -> len - doffset , 0 ) ; nskb -> ip_summed = CHECKSUM_NONE ; } } while ( ( offset += len ) < head_skb -> len ) ; return segs ; err : kfree_skb_list ( segs ) ; return ERR_PTR ( err ) ; }
CWE-190 void opj_get_all_encoding_parameters ( const opj_image_t * p_image , const opj_cp_t * p_cp , OPJ_UINT32 tileno , OPJ_INT32 * p_tx0 , OPJ_INT32 * p_tx1 , OPJ_INT32 * p_ty0 , OPJ_INT32 * p_ty1 , OPJ_UINT32 * p_dx_min , OPJ_UINT32 * p_dy_min , OPJ_UINT32 * p_max_prec , OPJ_UINT32 * p_max_res , OPJ_UINT32 * * p_resolutions ) { OPJ_UINT32 compno , resno ; const opj_tcp_t * tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; const opj_image_comp_t * l_img_comp = 00 ; OPJ_UINT32 * lResolutionPtr ; OPJ_UINT32 p , q ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( tileno < p_cp -> tw * p_cp -> th ) ; tcp = & p_cp -> tcps [ tileno ] ; l_tccp = tcp -> tccps ; l_img_comp = p_image -> comps ; p = tileno % p_cp -> tw ; q = tileno / p_cp -> tw ; <S2SV_StartBug> * p_tx0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> tx0 + p * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx ) , ( OPJ_INT32 ) p_image -> x1 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y0 ) ; <S2SV_EndBug> <S2SV_StartBug> * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) * p_cp -> tdy ) , ( OPJ_INT32 ) p_image -> y1 ) ; <S2SV_EndBug> * p_max_prec = 0 ; * p_max_res = 0 ; * p_dx_min = 0x7fffffff ; * p_dy_min = 0x7fffffff ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { OPJ_UINT32 l_level_no ; OPJ_INT32 l_rx0 , l_ry0 , l_rx1 , l_ry1 ; OPJ_INT32 l_px0 , l_py0 , l_px1 , py1 ; OPJ_UINT32 l_product ; OPJ_INT32 l_tcx0 , l_tcy0 , l_tcx1 , l_tcy1 ; OPJ_UINT32 l_pdx , l_pdy , l_pw , l_ph ; lResolutionPtr = p_resolutions [ compno ] ; l_tcx0 = opj_int_ceildiv ( * p_tx0 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy0 = opj_int_ceildiv ( * p_ty0 , ( OPJ_INT32 ) l_img_comp -> dy ) ; l_tcx1 = opj_int_ceildiv ( * p_tx1 , ( OPJ_INT32 ) l_img_comp -> dx ) ; l_tcy1 = opj_int_ceildiv ( * p_ty1 , ( OPJ_INT32 ) l_img_comp -> dy ) ; if ( l_tccp -> numresolutions > * p_max_res ) { * p_max_res = l_tccp -> numresolutions ; } l_level_no = l_tccp -> numresolutions - 1 ; for ( resno = 0 ; resno < l_tccp -> numresolutions ; ++ resno ) { OPJ_UINT32 l_dx , l_dy ; l_pdx = l_tccp -> prcw [ resno ] ; l_pdy = l_tccp -> prch [ resno ] ; * lResolutionPtr ++ = l_pdx ; * lResolutionPtr ++ = l_pdy ; l_dx = l_img_comp -> dx * ( 1u << ( l_pdx + l_level_no ) ) ; l_dy = l_img_comp -> dy * ( 1u << ( l_pdy + l_level_no ) ) ; * p_dx_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dx_min , ( OPJ_INT32 ) l_dx ) ; * p_dy_min = ( OPJ_UINT32 ) opj_int_min ( ( OPJ_INT32 ) * p_dy_min , ( OPJ_INT32 ) l_dy ) ; l_rx0 = opj_int_ceildivpow2 ( l_tcx0 , ( OPJ_INT32 ) l_level_no ) ; l_ry0 = opj_int_ceildivpow2 ( l_tcy0 , ( OPJ_INT32 ) l_level_no ) ; l_rx1 = opj_int_ceildivpow2 ( l_tcx1 , ( OPJ_INT32 ) l_level_no ) ; l_ry1 = opj_int_ceildivpow2 ( l_tcy1 , ( OPJ_INT32 ) l_level_no ) ; l_px0 = opj_int_floordivpow2 ( l_rx0 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; l_py0 = opj_int_floordivpow2 ( l_ry0 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_px1 = opj_int_ceildivpow2 ( l_rx1 , ( OPJ_INT32 ) l_pdx ) << l_pdx ; py1 = opj_int_ceildivpow2 ( l_ry1 , ( OPJ_INT32 ) l_pdy ) << l_pdy ; l_pw = ( l_rx0 == l_rx1 ) ? 0 : ( OPJ_UINT32 ) ( ( l_px1 - l_px0 ) >> l_pdx ) ; l_ph = ( l_ry0 == l_ry1 ) ? 0 : ( OPJ_UINT32 ) ( ( py1 - l_py0 ) >> l_pdy ) ; * lResolutionPtr ++ = l_pw ; * lResolutionPtr ++ = l_ph ; l_product = l_pw * l_ph ; if ( l_product > * p_max_prec ) { * p_max_prec = l_product ; } -- l_level_no ; } ++ l_tccp ; ++ l_img_comp ; } }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> swabHorAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; TIFFSwabArrayOfLong ( wp , wc ) ; <S2SV_StartBug> horAcc32 ( tif , cp0 , cc ) ; <S2SV_EndBug> }
CWE-000 static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) { <S2SV_StartBug> FILE * fp = fopen ( dest_filename , "w" ) ; <S2SV_EndBug> if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , "fd/%u" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , "%u:%s\\n" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , "fdinfo/%u" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , "r" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( "Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; } fclose ( fp ) ; return true ; }
CWE-000 int imap_subscribe ( char * path , bool subscribe ) { struct ImapData * idata = NULL ; char buf [ LONG_STRING ] ; char mbox [ LONG_STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct ImapMbox mx ; <S2SV_StartBug> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <S2SV_EndBug> { mutt_error ( _ ( "Bad<S2SV_blank>mailbox<S2SV_blank>name" ) ) ; return - 1 ; } idata = imap_conn_find ( & ( mx . account ) , 0 ) ; if ( ! idata ) goto fail ; imap_fix_path ( idata , mx . mbox , buf , sizeof ( buf ) ) ; if ( ! * buf ) mutt_str_strfcpy ( buf , "INBOX" , sizeof ( buf ) ) ; if ( ImapCheckSubscribed ) { mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; <S2SV_StartBug> snprintf ( mbox , sizeof ( mbox ) , "%smailboxes<S2SV_blank>\\"%s\\"" , subscribe ? "" : "un" , path ) ; <S2SV_EndBug> if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , "Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n" , errstr ) ; FREE ( & token . data ) ; } if ( subscribe ) mutt_message ( _ ( "Subscribing<S2SV_blank>to<S2SV_blank>%s..." ) , buf ) ; else mutt_message ( _ ( "Unsubscribing<S2SV_blank>from<S2SV_blank>%s..." ) , buf ) ; imap_munge_mbox_name ( idata , mbox , sizeof ( mbox ) , buf ) ; snprintf ( buf , sizeof ( buf ) , "%sSUBSCRIBE<S2SV_blank>%s" , subscribe ? "" : "UN" , mbox ) ; if ( imap_exec ( idata , buf , 0 ) < 0 ) goto fail ; imap_unmunge_mbox_name ( idata , mx . mbox ) ; if ( subscribe ) mutt_message ( _ ( "Subscribed<S2SV_blank>to<S2SV_blank>%s" ) , mx . mbox ) ; else mutt_message ( _ ( "Unsubscribed<S2SV_blank>from<S2SV_blank>%s" ) , mx . mbox ) ; FREE ( & mx . mbox ) ; return 0 ; fail : FREE ( & mx . mbox ) ; return - 1 ; }
CWE-284 int send_event ( int fd , uint16_t type , uint16_t code , int32_t value ) { struct uinput_event event ; BTIF_TRACE_DEBUG ( "%s<S2SV_blank>type:%u<S2SV_blank>code:%u<S2SV_blank>value:%d" , __FUNCTION__ , type , code , value ) ; memset ( & event , 0 , sizeof ( event ) ) ; event . type = type ; event . code = code ; event . value = value ; <S2SV_StartBug> return write ( fd , & event , sizeof ( event ) ) ; <S2SV_EndBug> }
CWE-20 <S2SV_StartBug> static int isofs_read_inode ( struct inode * inode ) <S2SV_EndBug> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO "%s:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] & 2 ) { if ( sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; else inode -> i_mode = S_IFDIR | S_IRUGO | S_IXUGO ; set_nlink ( inode , 1 ) ; } else { if ( sbi -> s_fmode != ISOFS_INVALID_MODE ) { inode -> i_mode = S_IFREG | sbi -> s_fmode ; } else { inode -> i_mode = S_IFREG | S_IRUGO | S_IXUGO ; } set_nlink ( inode , 1 ) ; } inode -> i_uid = sbi -> s_uid ; inode -> i_gid = sbi -> s_gid ; inode -> i_blocks = 0 ; ei -> i_format_parm [ 0 ] = 0 ; ei -> i_format_parm [ 1 ] = 0 ; ei -> i_format_parm [ 2 ] = 0 ; ei -> i_section_size = isonum_733 ( de -> size ) ; if ( de -> flags [ - high_sierra ] & 0x80 ) { ret = isofs_read_level3_size ( inode ) ; if ( ret < 0 ) goto fail ; ret = - EIO ; } else { ei -> i_next_section_block = 0 ; ei -> i_next_section_offset = 0 ; inode -> i_size = isonum_733 ( de -> size ) ; } if ( sbi -> s_cruft ) inode -> i_size &= 0x00ffffff ; if ( de -> interleave [ 0 ] ) { printk ( KERN_DEBUG "ISOFS:<S2SV_blank>Interleaved<S2SV_blank>files<S2SV_blank>not<S2SV_blank>(yet)<S2SV_blank>supported.\\n" ) ; inode -> i_size = 0 ; } if ( de -> file_unit_size [ 0 ] != 0 ) { printk ( KERN_DEBUG "ISOFS:<S2SV_blank>File<S2SV_blank>unit<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>0<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>(%ld).\\n" , inode -> i_ino ) ; } # ifdef DEBUG if ( ( de -> flags [ - high_sierra ] & ~ 2 ) != 0 ) { printk ( KERN_DEBUG "ISOFS:<S2SV_blank>Unusual<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>ISO<S2SV_blank>file<S2SV_blank>" "(%ld<S2SV_blank>%x).\\n" , inode -> i_ino , de -> flags [ - high_sierra ] ) ; } # endif inode -> i_mtime . tv_sec = inode -> i_atime . tv_sec = inode -> i_ctime . tv_sec = iso_date ( de -> date , high_sierra ) ; inode -> i_mtime . tv_nsec = inode -> i_atime . tv_nsec = inode -> i_ctime . tv_nsec = 0 ; ei -> i_first_extent = ( isonum_733 ( de -> extent ) + isonum_711 ( de -> ext_attr_length ) ) ; inode -> i_blocks = ( inode -> i_size + 511 ) >> 9 ; if ( ! high_sierra ) { <S2SV_StartBug> parse_rock_ridge_inode ( de , inode ) ; <S2SV_EndBug> if ( sbi -> s_uid_set ) inode -> i_uid = sbi -> s_uid ; if ( sbi -> s_gid_set ) inode -> i_gid = sbi -> s_gid ; } if ( S_ISDIR ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_dmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFDIR | sbi -> s_dmode ; if ( S_ISREG ( inode -> i_mode ) && sbi -> s_overriderockperm && sbi -> s_fmode != ISOFS_INVALID_MODE ) inode -> i_mode = S_IFREG | sbi -> s_fmode ; if ( S_ISREG ( inode -> i_mode ) ) { inode -> i_fop = & generic_ro_fops ; switch ( ei -> i_file_format ) { # ifdef CONFIG_ZISOFS case isofs_file_compressed : inode -> i_data . a_ops = & zisofs_aops ; break ; # endif default : inode -> i_data . a_ops = & isofs_aops ; break ; } } else if ( S_ISDIR ( inode -> i_mode ) ) { inode -> i_op = & isofs_dir_inode_operations ; inode -> i_fop = & isofs_dir_operations ; } else if ( S_ISLNK ( inode -> i_mode ) ) { inode -> i_op = & page_symlink_inode_operations ; inode -> i_data . a_ops = & isofs_symlink_aops ; } else init_special_inode ( inode , inode -> i_mode , inode -> i_rdev ) ; ret = 0 ; out : kfree ( tmpde ) ; if ( bh ) brelse ( bh ) ; return ret ; out_badread : printk ( KERN_WARNING "ISOFS:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>i-node<S2SV_blank>block\\n" ) ; fail : goto out ; }
CWE-119 static void yv12_extend_frame_bottom_c ( YV12_BUFFER_CONFIG * ybf ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr2 ; unsigned int Border ; int plane_stride ; int plane_height ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; plane_height = ybf -> y_height ; src_ptr1 = ybf -> y_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) Border ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> dest_ptr2 += plane_stride ; } plane_stride = ybf -> uv_stride ; plane_height = ybf -> uv_height ; Border /= 2 ; src_ptr1 = ybf -> u_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> dest_ptr2 += plane_stride ; } src_ptr1 = ybf -> v_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <S2SV_StartBug> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <S2SV_EndBug> dest_ptr2 += plane_stride ; } }
CWE-399 static int ceph_x_verify_authorizer_reply ( struct ceph_auth_client * ac , struct ceph_authorizer * a , size_t len ) { struct ceph_x_authorizer * au = ( void * ) a ; struct ceph_x_ticket_handler * th ; int ret = 0 ; struct ceph_x_authorize_reply reply ; <S2SV_StartBug> void * p = au -> reply_buf ; <S2SV_EndBug> void * end = p + sizeof ( au -> reply_buf ) ; th = get_ticket_handler ( ac , au -> service ) ; if ( IS_ERR ( th ) ) return PTR_ERR ( th ) ; <S2SV_StartBug> ret = ceph_x_decrypt ( & th -> session_key , & p , end , & reply , sizeof ( reply ) ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret != sizeof ( reply ) ) return - EPERM ; if ( au -> nonce + 1 != le64_to_cpu ( reply . nonce_plus_one ) ) ret = - EPERM ; else ret = 0 ; dout ( "verify_authorizer_reply<S2SV_blank>nonce<S2SV_blank>%llx<S2SV_blank>got<S2SV_blank>%llx<S2SV_blank>ret<S2SV_blank>%d\\n" , au -> nonce , le64_to_cpu ( reply . nonce_plus_one ) , ret ) ; return ret ; }
CWE-200 static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; <S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; } <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> }
CWE-000 G_DEFINE_TYPE ( GsmXsmpServer , gsm_xsmp_server , G_TYPE_OBJECT ) typedef struct { GsmXsmpServer * server ; IceListenObj listener ; } GsmIceConnectionData ; <S2SV_StartBug> static gboolean <S2SV_EndBug> accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) { IceListenObj listener ; IceConn ice_conn ; IceAcceptStatus status ; GsmClient * client ; GsmXsmpServer * server ; listener = data -> listener ; server = data -> server ; g_debug ( "GsmXsmpServer:<S2SV_blank>accept_ice_connection()" ) ; ice_conn = IceAcceptConnection ( listener , & status ) ; if ( status != IceAcceptSuccess ) { g_debug ( "GsmXsmpServer:<S2SV_blank>IceAcceptConnection<S2SV_blank>returned<S2SV_blank>%d" , status ) ; return TRUE ; } client = gsm_xsmp_client_new ( ice_conn ) ; <S2SV_StartBug> ice_conn -> context = client ; <S2SV_EndBug> gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client ) ; return TRUE ; }
CWE-119 <S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> { # if defined ( CHECK_MEMORY_USAGE ) static u32 numBytes = 0 ; <S2SV_StartBug> numBytes += size ; <S2SV_EndBug> DEBUG ( ( "Allocated<S2SV_blank>%d<S2SV_blank>bytes,<S2SV_blank>total<S2SV_blank>%d\\n" , size , numBytes ) ) ; # endif <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }
CWE-119 TEE_Result syscall_asymm_verify ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * data , size_t data_len , const void * sig , size_t sig_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; struct tee_obj * o ; size_t hash_size ; int salt_len = 0 ; TEE_Attribute * params = NULL ; uint32_t hash_algo ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; if ( cs -> mode != TEE_MODE_VERIFY ) return TEE_ERROR_BAD_PARAMETERS ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) data , data_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) sig , sig_len ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) ) { case TEE_MAIN_ALGO_RSA : if ( cs -> algo != TEE_ALG_RSASSA_PKCS1_V1_5 ) { hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len != hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , hash_size ) ; } res = crypto_acipher_rsassa_verify ( cs -> algo , o -> attr , salt_len , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_DSA : hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len > hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } res = crypto_acipher_dsa_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_ECDSA : res = crypto_acipher_ecc_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; default : res = TEE_ERROR_NOT_SUPPORTED ; } out : free ( params ) ; return res ; }
CWE-119 int vp9_rc_clamp_pframe_target_size ( const VP9_COMP * const cpi , int target ) { const RATE_CONTROL * rc = & cpi -> rc ; <S2SV_StartBug> const int min_frame_target = MAX ( rc -> min_frame_bandwidth , <S2SV_EndBug> <S2SV_StartBug> rc -> av_per_frame_bandwidth >> 5 ) ; <S2SV_EndBug> if ( target < min_frame_target ) target = min_frame_target ; if ( cpi -> refresh_golden_frame && rc -> is_src_frame_alt_ref ) { target = min_frame_target ; } if ( target > rc -> max_frame_bandwidth ) target = rc -> max_frame_bandwidth ; <S2SV_StartBug> return target ; <S2SV_EndBug> }
CWE-119 static int decode_dds1 ( GetByteContext * gb , uint8_t * frame , int width , int height ) { const uint8_t * frame_start = frame ; const uint8_t * frame_end = frame + width * height ; int mask = 0x10000 , bitbuf = 0 ; int i , v , offset , count , segments ; segments = bytestream2_get_le16 ( gb ) ; while ( segments -- ) { if ( bytestream2_get_bytes_left ( gb ) < 2 ) return AVERROR_INVALIDDATA ; if ( mask == 0x10000 ) { bitbuf = bytestream2_get_le16u ( gb ) ; mask = 1 ; } if ( bitbuf & mask ) { v = bytestream2_get_le16 ( gb ) ; offset = ( v & 0x1FFF ) << 2 ; count = ( ( v >> 13 ) + 2 ) << 1 ; if ( frame - frame_start < offset || frame_end - frame < count * 2 + width ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < count ; i ++ ) { frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = frame [ - offset ] ; frame += 2 ; } } else if ( bitbuf & ( mask << 1 ) ) { v = bytestream2_get_le16 ( gb ) * 2 ; if ( frame - frame_end < v ) return AVERROR_INVALIDDATA ; frame += v ; } else { <S2SV_StartBug> if ( frame_end - frame < width + 3 ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; frame += 2 ; frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = bytestream2_get_byte ( gb ) ; frame += 2 ; } mask <<= 2 ; } return 0 ; }
CWE-119 static AVFrame * get_video_buffer ( AVFilterLink * inlink , int w , int h ) { PadContext * s = inlink -> dst -> priv ; AVFrame * frame = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , w + ( s -> w - s -> in_w ) , h + ( s -> h - s -> in_h ) ) ; int plane ; if ( ! frame ) return NULL ; frame -> width = w ; frame -> height = h ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ plane ] ; int vsub = s -> draw . vsub [ plane ] ; frame -> data [ plane ] += ( s -> x >> hsub ) * s -> draw . pixelstep [ plane ] + ( s -> y >> vsub ) * frame -> linesize [ plane ] ; } return frame ; }
CWE-000 int xfs_attr_rmtval_set ( struct xfs_da_args * args ) { struct xfs_inode * dp = args -> dp ; struct xfs_mount * mp = dp -> i_mount ; struct xfs_bmbt_irec map ; xfs_dablk_t lblkno ; xfs_fileoff_t lfileoff = 0 ; __uint8_t * src = args -> value ; int blkcnt ; int valuelen ; int nmap ; int error ; int offset = 0 ; trace_xfs_attr_rmtval_set ( args ) ; <S2SV_StartBug> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <S2SV_EndBug> error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ; if ( error ) return error ; args -> rmtblkno = lblkno = ( xfs_dablk_t ) lfileoff ; args -> rmtblkcnt = blkcnt ; while ( blkcnt > 0 ) { int committed ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_write ( args -> trans , dp , ( xfs_fileoff_t ) lblkno , blkcnt , XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA , args -> firstblock , args -> total , & map , & nmap , args -> flist ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; ASSERT ( nmap == 1 ) ; ASSERT ( ( map . br_startblock != DELAYSTARTBLOCK ) && ( map . br_startblock != HOLESTARTBLOCK ) ) ; lblkno += map . br_blockcount ; blkcnt -= map . br_blockcount ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; } lblkno = args -> rmtblkno ; blkcnt = args -> rmtblkcnt ; <S2SV_StartBug> valuelen = args -> valuelen ; <S2SV_EndBug> while ( valuelen > 0 ) { struct xfs_buf * bp ; xfs_daddr_t dblkno ; int dblkcnt ; ASSERT ( blkcnt > 0 ) ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_read ( dp , ( xfs_fileoff_t ) lblkno , blkcnt , & map , & nmap , XFS_BMAPI_ATTRFORK ) ; if ( error ) return ( error ) ; ASSERT ( nmap == 1 ) ; ASSERT ( ( map . br_startblock != DELAYSTARTBLOCK ) && ( map . br_startblock != HOLESTARTBLOCK ) ) ; dblkno = XFS_FSB_TO_DADDR ( mp , map . br_startblock ) , dblkcnt = XFS_FSB_TO_BB ( mp , map . br_blockcount ) ; bp = xfs_buf_get ( mp -> m_ddev_targp , dblkno , dblkcnt , 0 ) ; if ( ! bp ) return ENOMEM ; bp -> b_ops = & xfs_attr3_rmt_buf_ops ; xfs_attr_rmtval_copyin ( mp , bp , args -> dp -> i_ino , & offset , & valuelen , & src ) ; error = xfs_bwrite ( bp ) ; xfs_buf_relse ( bp ) ; if ( error ) return error ; lblkno += map . br_blockcount ; blkcnt -= map . br_blockcount ; } ASSERT ( valuelen == 0 ) ; return 0 ; }
CWE-119 static void write_interp_filter ( INTERP_FILTER filter , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> const int filter_to_literal [ ] = { 1 , 0 , 2 , 3 } ; <S2SV_StartBug> vp9_wb_write_bit ( wb , filter == SWITCHABLE ) ; <S2SV_EndBug> if ( filter != SWITCHABLE ) <S2SV_StartBug> vp9_wb_write_literal ( wb , filter_to_literal [ filter ] , 2 ) ; <S2SV_EndBug> }
CWE-119 int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }
CWE-119 char * _multi_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( len + 2 ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; chr [ len ++ ] = '\\0' ; return chr ; }
CWE-399 static int masq_inet_event ( struct notifier_block * this , unsigned long event , void * ptr ) { <S2SV_StartBug> struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ; <S2SV_EndBug> struct netdev_notifier_info info ; <S2SV_StartBug> netdev_notifier_info_init ( & info , dev ) ; <S2SV_EndBug> return masq_device_event ( this , event , & info ) ; }
CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <S2SV_StartBug> if ( data -> multi_easy ) <S2SV_EndBug> <S2SV_StartBug> curl_multi_cleanup ( data -> multi_easy ) ; <S2SV_EndBug> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if ( data -> share ) { Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; data -> share -> dirty -- ; Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; } Curl_wildcard_dtor ( & data -> wildcard ) ; Curl_freeset ( data ) ; free ( data ) ; return CURLE_OK ; }
CWE-399 <S2SV_StartBug> static void ip6_append_data_mtu ( int * mtu , <S2SV_EndBug> int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb , <S2SV_StartBug> struct rt6_info * rt ) <S2SV_EndBug> { if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) ) { if ( skb == NULL ) { * mtu = * mtu - rt -> dst . header_len ; } else { <S2SV_StartBug> * mtu = dst_mtu ( rt -> dst . path ) ; <S2SV_EndBug> } * maxfraglen = ( ( * mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; } }
CWE-787 static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; <S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> cmap_entry_size = tga [ 7 ] ; # if 0 <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> # endif <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , "tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , "Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , "File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported." ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
CWE-119 static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ; <S2SV_StartBug> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { <S2SV_EndBug> struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ; <S2SV_StartBug> if ( unix_sock_count ) { <S2SV_EndBug> for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_StartBug> } <S2SV_EndBug> return max_level ; }
CWE-119 <S2SV_StartBug> void vp9_cost_tokens ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> cost ( costs , tree , probs , 0 , 0 ) ; }
CWE-362 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <S2SV_EndBug> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
CWE-119 void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ; jpc_fix_t * buf = splitbuf ; register jpc_fix_t * srcptr ; register jpc_fix_t * dstptr ; register int n ; register int m ; <S2SV_StartBug> int hstartcol ; <S2SV_EndBug> if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) { <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { * dstptr = * srcptr ; ++ dstptr ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; srcptr += stride << 1 ; } <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> srcptr = buf ; n = m ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; ++ srcptr ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
CWE-119 void vp8_setup_key_frame ( VP8_COMP * cpi ) { vp8_default_coef_probs ( & cpi -> common ) ; <S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ; } <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ; if ( cpi -> auto_gold ) cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; else cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; cpi -> common . refresh_golden_frame = 1 ; cpi -> common . refresh_alt_ref_frame = 1 ; }
CWE-416 static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( "No<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>ttyUSB%i\\n" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref ) ; tty -> driver = usb_serial_tty_driver ; tty -> index = co -> index ; init_ldsem ( & tty -> ldisc_sem ) ; spin_lock_init ( & tty -> files_lock ) ; INIT_LIST_HEAD ( & tty -> tty_files ) ; kref_get ( & tty -> driver -> kref ) ; __module_get ( tty -> driver -> owner ) ; tty -> ops = & usb_console_fake_tty_ops ; tty_init_termios ( tty ) ; tty_port_tty_set ( & port -> port , tty ) ; } retval = serial -> type -> open ( NULL , port ) ; if ( retval ) { dev_err ( & port -> dev , "could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>USB<S2SV_blank>console<S2SV_blank>port\\n" ) ; goto fail ; } if ( serial -> type -> set_termios ) { tty -> termios . c_cflag = cflag ; tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; serial -> type -> set_termios ( tty , port , & dummy ) ; tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; } tty_port_set_initialized ( & port -> port , 1 ) ; } -- port -> port . count ; port -> port . console = 1 ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; fail : tty_port_tty_set ( & port -> port , NULL ) ; tty_kref_put ( tty ) ; reset_open_count : port -> port . count = 0 ; <S2SV_StartBug> usb_autopm_put_interface ( serial -> interface ) ; <S2SV_EndBug> error_get_interface : usb_serial_put ( serial ) ; mutex_unlock ( & serial -> disc_mutex ) ; return retval ; }
CWE-476 static void srpt_handle_tsk_mgmt ( struct srpt_rdma_ch * ch , struct srpt_recv_ioctx * recv_ioctx , struct srpt_send_ioctx * send_ioctx ) { struct srp_tsk_mgmt * srp_tsk ; struct se_cmd * cmd ; struct se_session * sess = ch -> sess ; uint64_t unpacked_lun ; <S2SV_StartBug> uint32_t tag = 0 ; <S2SV_EndBug> int tcm_tmr ; int rc ; BUG_ON ( ! send_ioctx ) ; srp_tsk = recv_ioctx -> ioctx . buf ; cmd = & send_ioctx -> cmd ; pr_debug ( "recv<S2SV_blank>tsk_mgmt<S2SV_blank>fn<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>task_tag<S2SV_blank>%lld<S2SV_blank>and<S2SV_blank>cmd<S2SV_blank>tag<S2SV_blank>%lld" "<S2SV_blank>cm_id<S2SV_blank>%p<S2SV_blank>sess<S2SV_blank>%p\\n" , srp_tsk -> tsk_mgmt_func , srp_tsk -> task_tag , srp_tsk -> tag , ch -> cm_id , ch -> sess ) ; srpt_set_cmd_state ( send_ioctx , SRPT_STATE_MGMT ) ; send_ioctx -> cmd . tag = srp_tsk -> tag ; tcm_tmr = srp_tmr_to_tcm ( srp_tsk -> tsk_mgmt_func ) ; <S2SV_StartBug> if ( tcm_tmr < 0 ) { <S2SV_EndBug> send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED ; goto fail ; } unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; if ( srp_tsk -> tsk_mgmt_func == SRP_TSK_ABORT_TASK ) { <S2SV_StartBug> rc = srpt_rx_mgmt_fn_tag ( send_ioctx , srp_tsk -> task_tag ) ; <S2SV_EndBug> if ( rc < 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_TASK_DOES_NOT_EXIST ; goto fail ; } tag = srp_tsk -> task_tag ; } rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL , tag , TARGET_SCF_ACK_KREF ) ; if ( rc != 0 ) { send_ioctx -> cmd . se_tmr_req -> response = TMR_FUNCTION_REJECTED ; goto fail ; } return ; fail : transport_send_check_condition_and_sense ( cmd , 0 , 0 ) ; }
CWE-000 int xfs_attr3_leaf_flipflags ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf1 ; struct xfs_attr_leafblock * leaf2 ; struct xfs_attr_leaf_entry * entry1 ; struct xfs_attr_leaf_entry * entry2 ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp1 ; struct xfs_buf * bp2 ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr1 ; struct xfs_attr3_icleaf_hdr ichdr2 ; xfs_attr_leaf_name_local_t * name_loc ; int namelen1 , namelen2 ; char * name1 , * name2 ; # endif trace_xfs_attr_leaf_flipflags ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp1 ) ; if ( error ) return error ; if ( args -> blkno2 != args -> blkno ) { error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno2 , - 1 , & bp2 ) ; if ( error ) return error ; } else { bp2 = bp1 ; } leaf1 = bp1 -> b_addr ; entry1 = & xfs_attr3_leaf_entryp ( leaf1 ) [ args -> index ] ; leaf2 = bp2 -> b_addr ; entry2 = & xfs_attr3_leaf_entryp ( leaf2 ) [ args -> index2 ] ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr1 , leaf1 ) ; ASSERT ( args -> index < ichdr1 . count ) ; ASSERT ( args -> index >= 0 ) ; xfs_attr3_leaf_hdr_from_disk ( & ichdr2 , leaf2 ) ; ASSERT ( args -> index2 < ichdr2 . count ) ; ASSERT ( args -> index2 >= 0 ) ; if ( entry1 -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf1 , args -> index ) ; namelen1 = name_loc -> namelen ; name1 = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ; namelen1 = name_rmt -> namelen ; name1 = ( char * ) name_rmt -> name ; } if ( entry2 -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf2 , args -> index2 ) ; namelen2 = name_loc -> namelen ; name2 = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf2 , args -> index2 ) ; namelen2 = name_rmt -> namelen ; name2 = ( char * ) name_rmt -> name ; } ASSERT ( be32_to_cpu ( entry1 -> hashval ) == be32_to_cpu ( entry2 -> hashval ) ) ; ASSERT ( namelen1 == namelen2 ) ; ASSERT ( memcmp ( name1 , name2 , namelen1 ) == 0 ) ; # endif ASSERT ( entry1 -> flags & XFS_ATTR_INCOMPLETE ) ; ASSERT ( ( entry2 -> flags & XFS_ATTR_INCOMPLETE ) == 0 ) ; entry1 -> flags &= ~ XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , entry1 , sizeof ( * entry1 ) ) ) ; if ( args -> rmtblkno ) { ASSERT ( ( entry1 -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf1 , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; <S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> xfs_trans_log_buf ( args -> trans , bp1 , XFS_DA_LOGRANGE ( leaf1 , name_rmt , sizeof ( * name_rmt ) ) ) ; } entry2 -> flags |= XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp2 , XFS_DA_LOGRANGE ( leaf2 , entry2 , sizeof ( * entry2 ) ) ) ; if ( ( entry2 -> flags & XFS_ATTR_LOCAL ) == 0 ) { name_rmt = xfs_attr3_leaf_name_remote ( leaf2 , args -> index2 ) ; name_rmt -> valueblk = 0 ; name_rmt -> valuelen = 0 ; xfs_trans_log_buf ( args -> trans , bp2 , XFS_DA_LOGRANGE ( leaf2 , name_rmt , sizeof ( * name_rmt ) ) ) ; } error = xfs_trans_roll ( & args -> trans , args -> dp ) ; return error ; }
CWE-20 void init_util ( void ) { filegen_register ( statsdir , "peerstats" , & peerstats ) ; filegen_register ( statsdir , "loopstats" , & loopstats ) ; filegen_register ( statsdir , "clockstats" , & clockstats ) ; filegen_register ( statsdir , "rawstats" , & rawstats ) ; filegen_register ( statsdir , "sysstats" , & sysstats ) ; filegen_register ( statsdir , "protostats" , & protostats ) ; <S2SV_StartBug> # ifdef AUTOKEY <S2SV_EndBug> filegen_register ( statsdir , "cryptostats" , & cryptostats ) ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifdef DEBUG_TIMING filegen_register ( statsdir , "timingstats" , & timingstats ) ; <S2SV_StartBug> # endif <S2SV_EndBug> step_callback = & ntpd_time_stepped ; # ifdef DEBUG atexit ( & uninit_util ) ; # endif }
CWE-000 static int http_rxchunk ( struct http * hp ) { char * q ; int l , i ; l = hp -> prxbuf ; do ( void ) http_rxchar ( hp , 1 , 0 ) ; while ( hp -> rxbuf [ hp -> prxbuf - 1 ] != '\\n' ) ; vtc_dump ( hp -> vl , 4 , "len" , hp -> rxbuf + l , - 1 ) ; i = strtoul ( hp -> rxbuf + l , & q , 16 ) ; bprintf ( hp -> chunklen , "%d" , i ) ; if ( ( q == hp -> rxbuf + l ) || ( * q != '\\0' && ! vct_islws ( * q ) ) ) { vtc_log ( hp -> vl , hp -> fatal , "chunked<S2SV_blank>fail<S2SV_blank>%02x<S2SV_blank>@<S2SV_blank>%d" , * q , q - ( hp -> rxbuf + l ) ) ; } assert ( q != hp -> rxbuf + l ) ; assert ( * q == '\\0' || vct_islws ( * q ) ) ; hp -> prxbuf = l ; if ( i > 0 ) { ( void ) http_rxchar ( hp , i , 0 ) ; vtc_dump ( hp -> vl , 4 , "chunk" , hp -> rxbuf + l , i ) ; } l = hp -> prxbuf ; ( void ) http_rxchar ( hp , 2 , 0 ) ; <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l ] ) ) <S2SV_EndBug> vtc_log ( hp -> vl , hp -> fatal , "Wrong<S2SV_blank>chunk<S2SV_blank>tail[0]<S2SV_blank>=<S2SV_blank>%02x" , hp -> rxbuf [ l ] & 0xff ) ; <S2SV_StartBug> if ( ! vct_iscrlf ( hp -> rxbuf [ l + 1 ] ) ) <S2SV_EndBug> vtc_log ( hp -> vl , hp -> fatal , "Wrong<S2SV_blank>chunk<S2SV_blank>tail[1]<S2SV_blank>=<S2SV_blank>%02x" , hp -> rxbuf [ l + 1 ] & 0xff ) ; hp -> prxbuf = l ; hp -> rxbuf [ l ] = '\\0' ; return ( i ) ; }
CWE-000 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) return - EINVAL ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-125 static char * get_icu_value_internal ( const char * loc_name , char * tag_name , int * result , int fromParseLocale ) { char * tag_value = NULL ; int32_t tag_value_len = 512 ; int singletonPos = 0 ; char * mod_loc_name = NULL ; int grOffset = 0 ; int32_t buflen = 512 ; UErrorCode status = U_ZERO_ERROR ; if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) != 0 ) { grOffset = findOffset ( LOC_GRANDFATHERED , loc_name ) ; if ( grOffset >= 0 ) { if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { return estrdup ( loc_name ) ; } else { return NULL ; } } if ( fromParseLocale == 1 ) { if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { if ( strlen ( loc_name ) > 1 && ( isIDPrefix ( loc_name ) == 1 ) ) { return estrdup ( loc_name ) ; } } singletonPos = getSingletonPos ( loc_name ) ; if ( singletonPos == 0 ) { return NULL ; } else if ( singletonPos > 0 ) { mod_loc_name = estrndup ( loc_name , singletonPos - 1 ) ; } } } if ( mod_loc_name == NULL ) { mod_loc_name = estrdup ( loc_name ) ; } do { tag_value = erealloc ( tag_value , buflen ) ; tag_value_len = buflen ; if ( strcmp ( tag_name , LOC_SCRIPT_TAG ) == 0 ) { buflen = uloc_getScript ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { buflen = uloc_getLanguage ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_REGION_TAG ) == 0 ) { buflen = uloc_getCountry ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_VARIANT_TAG ) == 0 ) { buflen = uloc_getVariant ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) == 0 ) { buflen = uloc_canonicalize ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( U_FAILURE ( status ) ) { if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; <S2SV_StartBug> continue ; <S2SV_EndBug> } * result = 0 ; if ( tag_value ) { efree ( tag_value ) ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return NULL ; } } while ( buflen > tag_value_len ) ; if ( buflen == 0 ) { * result = - 1 ; if ( tag_value ) { efree ( tag_value ) ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return NULL ; } else { * result = 1 ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return tag_value ; }
CWE-119 void vp8_multiframe_quality_enhance ( VP8_COMMON * cm ) { YV12_BUFFER_CONFIG * show = cm -> frame_to_show ; YV12_BUFFER_CONFIG * dest = & cm -> post_proc_buffer ; FRAME_TYPE frame_type = cm -> frame_type ; const MODE_INFO * mode_info_context = cm -> show_frame_mi ; int mb_row ; int mb_col ; int totmap , map [ 4 ] ; int qcurr = cm -> base_qindex ; int qprev = cm -> postproc_state . last_base_qindex ; unsigned char * y_ptr , * u_ptr , * v_ptr ; unsigned char * yd_ptr , * ud_ptr , * vd_ptr ; y_ptr = show -> y_buffer ; u_ptr = show -> u_buffer ; v_ptr = show -> v_buffer ; yd_ptr = dest -> y_buffer ; ud_ptr = dest -> u_buffer ; vd_ptr = dest -> v_buffer ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( frame_type == INTER_FRAME ) totmap = qualify_inter_mb ( mode_info_context , map ) ; else totmap = ( frame_type == KEY_FRAME ? 4 : 0 ) ; if ( totmap ) { if ( totmap < 4 ) { int i , j ; for ( i = 0 ; i < 2 ; ++ i ) for ( j = 0 ; j < 2 ; ++ j ) { if ( map [ i * 2 + j ] ) { multiframe_quality_enhance_block ( 8 , qcurr , qprev , y_ptr + 8 * ( i * show -> y_stride + j ) , u_ptr + 4 * ( i * show -> uv_stride + j ) , v_ptr + 4 * ( i * show -> uv_stride + j ) , show -> y_stride , show -> uv_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , ud_ptr + 4 * ( i * dest -> uv_stride + j ) , vd_ptr + 4 * ( i * dest -> uv_stride + j ) , dest -> y_stride , dest -> uv_stride ) ; } else { int k ; unsigned char * up = u_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * udp = ud_ptr + 4 * ( i * dest -> uv_stride + j ) ; unsigned char * vp = v_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * vdp = vd_ptr + 4 * ( i * dest -> uv_stride + j ) ; vp8_copy_mem8x8 ( y_ptr + 8 * ( i * show -> y_stride + j ) , show -> y_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , dest -> y_stride ) ; for ( k = 0 ; k < 4 ; ++ k , up += show -> uv_stride , udp += dest -> uv_stride , vp += show -> uv_stride , vdp += dest -> uv_stride ) { <S2SV_StartBug> vpx_memcpy ( udp , up , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , 4 ) ; <S2SV_EndBug> } } } } else { multiframe_quality_enhance_block ( 16 , qcurr , qprev , y_ptr , u_ptr , v_ptr , show -> y_stride , show -> uv_stride , yd_ptr , ud_ptr , vd_ptr , dest -> y_stride , dest -> uv_stride ) ; } } else { vp8_copy_mem16x16 ( y_ptr , show -> y_stride , yd_ptr , dest -> y_stride ) ; vp8_copy_mem8x8 ( u_ptr , show -> uv_stride , ud_ptr , dest -> uv_stride ) ; vp8_copy_mem8x8 ( v_ptr , show -> uv_stride , vd_ptr , dest -> uv_stride ) ; } y_ptr += 16 ; u_ptr += 8 ; v_ptr += 8 ; yd_ptr += 16 ; ud_ptr += 8 ; vd_ptr += 8 ; mode_info_context ++ ; } y_ptr += show -> y_stride * 16 - 16 * cm -> mb_cols ; u_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; v_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; yd_ptr += dest -> y_stride * 16 - 16 * cm -> mb_cols ; ud_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; vd_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; mode_info_context ++ ; } }
CWE-416 static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } } <S2SV_StartBug> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <S2SV_EndBug> sk_dst_reset ( sk ) ; return opt ; }
CWE-190 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; <S2SV_StartBug> DEFINE_WAKE_Q ( wake_q ) ; <S2SV_EndBug> if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { mark_wake_futex ( & wake_q , this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { get_pi_state ( pi_state ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; put_pi_state ( pi_state ) ; break ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } put_pi_state ( pi_state ) ; out_unlock : double_unlock_hb ( hb1 , hb2 ) ; wake_up_q ( & wake_q ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : return ret ? ret : task_count ; }
CWE-399 public int magic_getparam ( struct magic_set * ms , int param , void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : * ( size_t * ) val = ms -> indir_max ; return 0 ; case MAGIC_PARAM_NAME_MAX : * ( size_t * ) val = ms -> name_max ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : * ( size_t * ) val = ms -> elf_phnum_max ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : * ( size_t * ) val = ms -> elf_shnum_max ; return 0 ; <S2SV_StartBug> default : <S2SV_EndBug> errno = EINVAL ; return - 1 ; } }
CWE-284 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { <S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> } <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug> } }
CWE-416 <S2SV_StartBug> int hns_nic_net_xmit_hw ( struct net_device * ndev , <S2SV_EndBug> struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; struct hnae_ring * ring = ring_data -> ring ; struct device * dev = ring_to_dev ( ring ) ; struct netdev_queue * dev_queue ; struct skb_frag_struct * frag ; int buf_num ; int seg_num ; dma_addr_t dma ; int size , next_to_use ; int i ; switch ( priv -> ops . maybe_stop_tx ( & skb , & buf_num , ring ) ) { case - EBUSY : ring -> stats . tx_busy ++ ; goto out_net_tx_busy ; case - ENOMEM : ring -> stats . sw_err_cnt ++ ; netdev_err ( ndev , "no<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>xmit!\\n" ) ; goto out_err_tx_ok ; default : break ; } seg_num = skb_shinfo ( skb ) -> nr_frags + 1 ; next_to_use = ring -> next_to_use ; size = skb_headlen ( skb ) ; dma = dma_map_single ( dev , skb -> data , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , "TX<S2SV_blank>head<S2SV_blank>DMA<S2SV_blank>map<S2SV_blank>failed\\n" ) ; ring -> stats . sw_err_cnt ++ ; goto out_err_tx_ok ; } priv -> ops . fill_desc ( ring , skb , size , dma , seg_num == 1 ? 1 : 0 , buf_num , DESC_TYPE_SKB , ndev -> mtu ) ; for ( i = 1 ; i < seg_num ; i ++ ) { frag = & skb_shinfo ( skb ) -> frags [ i - 1 ] ; size = skb_frag_size ( frag ) ; dma = skb_frag_dma_map ( dev , frag , 0 , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , "TX<S2SV_blank>frag(%d)<S2SV_blank>DMA<S2SV_blank>map<S2SV_blank>failed\\n" , i ) ; ring -> stats . sw_err_cnt ++ ; goto out_map_frag_fail ; } priv -> ops . fill_desc ( ring , skb_frag_page ( frag ) , size , dma , seg_num - 1 == i ? 1 : 0 , buf_num , DESC_TYPE_PAGE , ndev -> mtu ) ; } dev_queue = netdev_get_tx_queue ( ndev , skb -> queue_mapping ) ; netdev_tx_sent_queue ( dev_queue , skb -> len ) ; <S2SV_StartBug> wmb ( ) ; <S2SV_EndBug> assert ( skb -> queue_mapping < priv -> ae_handle -> q_num ) ; hnae_queue_xmit ( priv -> ae_handle -> qs [ skb -> queue_mapping ] , buf_num ) ; ring -> stats . tx_pkts ++ ; ring -> stats . tx_bytes += skb -> len ; return NETDEV_TX_OK ; out_map_frag_fail : while ( ring -> next_to_use != next_to_use ) { unfill_desc ( ring ) ; if ( ring -> next_to_use != next_to_use ) dma_unmap_page ( dev , ring -> desc_cb [ ring -> next_to_use ] . dma , ring -> desc_cb [ ring -> next_to_use ] . length , DMA_TO_DEVICE ) ; else dma_unmap_single ( dev , ring -> desc_cb [ next_to_use ] . dma , ring -> desc_cb [ next_to_use ] . length , DMA_TO_DEVICE ) ; } out_err_tx_ok : dev_kfree_skb_any ( skb ) ; return NETDEV_TX_OK ; out_net_tx_busy : netif_stop_subqueue ( ndev , skb -> queue_mapping ) ; smp_mb ( ) ; return NETDEV_TX_BUSY ; }
CWE-787 static int next_state_val ( CClassNode * cc , OnigCodePoint * vs , OnigCodePoint v , int * vs_israw , int v_israw , enum CCVALTYPE intype , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; switch ( * state ) { case CCS_VALUE : if ( * type == CCV_SB ) { <S2SV_StartBug> BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; <S2SV_EndBug> } else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } break ; case CCS_RANGE : if ( intype == * type ) { if ( intype == CCV_SB ) { if ( * vs > 0xff || v > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) v ) ; } else { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , v ) ; if ( r < 0 ) return r ; } } else { # if 0 if ( intype == CCV_CODE_POINT && * type == CCV_SB ) { # endif if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) ( v < 0xff ? v : 0xff ) ) ; r = add_code_range ( & ( cc -> mbuf ) , env , ( OnigCodePoint ) * vs , v ) ; if ( r < 0 ) return r ; # if 0 } else return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE ; # endif } ccs_range_end : * state = CCS_COMPLETE ; break ; case CCS_COMPLETE : case CCS_START : * state = CCS_VALUE ; break ; default : break ; } * vs_israw = v_israw ; * vs = v ; * type = intype ; return 0 ; }
CWE-000 static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Invalid<S2SV_blank>empty<S2SV_blank>pathname" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) <S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Path<S2SV_blank>contains<S2SV_blank>\'..\'" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
CWE-119 <S2SV_StartBug> void <S2SV_EndBug> byteSwap ( UWORD32 * buf , unsigned words ) { md5byte * p ; int i = 1 ; if ( * ( char * ) & i == 1 ) return ; p = ( md5byte * ) buf ; do { * buf ++ = ( UWORD32 ) ( ( unsigned ) p [ 3 ] << 8 | p [ 2 ] ) << 16 | ( ( unsigned ) p [ 1 ] << 8 | p [ 0 ] ) ; p += 4 ; } while ( -- words ) ; }
CWE-190 static void common_hrtimer_rearm ( struct k_itimer * timr ) { struct hrtimer * timer = & timr -> it . real . timer ; if ( ! timr -> it_interval ) return ; <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> timer -> base -> get_time ( ) , timr -> it_interval ) ; hrtimer_restart ( timer ) ; }
CWE-119 void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) { long unsigned int i ; unsigned char c ; char buf2 [ 15 ] ; mowgli_string_t * s = mowgli_string_create ( ) ; * buf2 = '\\0' ; * outbuffer = '\\0' ; if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) { return ; } for ( i = 0 ; s1 [ i ] != '\\0' ; i ++ ) { c = s1 [ i ] ; if ( c > 127 ) { snprintf ( buf2 , sizeof buf2 , "&#%d;" , c ) ; s -> append ( s , buf2 , strlen ( buf2 ) ) ; } else if ( c == '&' ) { s -> append ( s , "&amp;" , 5 ) ; } else if ( c == '<' ) { s -> append ( s , "&lt;" , 4 ) ; } else if ( c == '>' ) { s -> append ( s , "&gt;" , 4 ) ; } else if ( c == \'"\' ) { s -> append ( s , "&quot;" , 6 ) ; } else { s -> append_char ( s , c ) ; } } <S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug> }
CWE-264 static void __xml_acl_post_process ( xmlNode * xml ) { xmlNode * cIter = __xml_first_child ( xml ) ; xml_private_t * p = xml -> _private ; if ( is_set ( p -> flags , xpf_created ) ) { xmlAttr * xIter = NULL ; <S2SV_StartBug> for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) { <S2SV_EndBug> const char * prop_name = ( const char * ) xIter -> name ; <S2SV_StartBug> if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) { <S2SV_EndBug> continue ; } else if ( __xml_acl_check ( xml , NULL , xpf_acl_write ) ) { crm_trace ( "Creation<S2SV_blank>of<S2SV_blank>%s=%s<S2SV_blank>is<S2SV_blank>allowed" , crm_element_name ( xml ) , ID ( xml ) ) ; break ; } else { <S2SV_StartBug> char * path = xml_get_path ( xml ) ; <S2SV_EndBug> crm_trace ( "Cannot<S2SV_blank>add<S2SV_blank>new<S2SV_blank>node<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s" , crm_element_name ( xml ) , path ) ; if ( xml != xmlDocGetRootElement ( xml -> doc ) ) { xmlUnlinkNode ( xml ) ; xmlFreeNode ( xml ) ; } free ( path ) ; return ; } } <S2SV_StartBug> } <S2SV_EndBug> while ( cIter != NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; __xml_acl_post_process ( child ) ; } }
CWE-119 <S2SV_StartBug> CYCLIC_REFRESH * vp9_cyclic_refresh_alloc ( int mi_rows , int mi_cols ) { <S2SV_EndBug> CYCLIC_REFRESH * const cr = vpx_calloc ( 1 , sizeof ( * cr ) ) ; if ( cr == NULL ) return NULL ; cr -> map = vpx_calloc ( mi_rows * mi_cols , sizeof ( * cr -> map ) ) ; if ( cr -> map == NULL ) { vpx_free ( cr ) ; return NULL ; } <S2SV_StartBug> return cr ; <S2SV_EndBug> }
CWE-119 static int process_plane ( uint8 * in , int width , int height , uint8 * out , int size ) { UNUSED ( size ) ; int indexw ; int indexh ; int code ; int collen ; int replen ; int color ; int x ; int revcode ; uint8 * last_line ; uint8 * this_line ; uint8 * org_in ; uint8 * org_out ; org_in = in ; org_out = out ; last_line = 0 ; indexh = 0 ; while ( indexh < height ) { out = ( org_out + width * height * 4 ) - ( ( indexh + 1 ) * width * 4 ) ; color = 0 ; this_line = out ; indexw = 0 ; if ( last_line == 0 ) { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { color = CVAL ( in ) ; * out = color ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { * out = color ; out += 4 ; indexw ++ ; replen -- ; } } } else { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { x = CVAL ( in ) ; if ( x & 1 ) { x = x >> 1 ; x = x + 1 ; color = - x ; } else { x = x >> 1 ; color = x ; } x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; replen -- ; } } } indexh ++ ; last_line = this_line ; } return ( int ) ( in - org_in ) ; }
CWE-399 static int xen_netbk_tx_check_gop ( struct xen_netbk * netbk , struct sk_buff * skb , struct gnttab_copy * * gopp ) { struct gnttab_copy * gop = * gopp ; u16 pending_idx = * ( ( u16 * ) skb -> data ) ; <S2SV_StartBug> struct pending_tx_info * pending_tx_info = netbk -> pending_tx_info ; <S2SV_EndBug> struct xenvif * vif = pending_tx_info [ pending_idx ] . vif ; struct xen_netif_tx_request * txp ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i , err , start ; err = gop -> status ; <S2SV_StartBug> if ( unlikely ( err ) ) { <S2SV_EndBug> pending_ring_idx_t index ; index = pending_index ( netbk -> pending_prod ++ ) ; txp = & pending_tx_info [ pending_idx ] . req ; make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ; <S2SV_StartBug> netbk -> pending_ring [ index ] = pending_idx ; <S2SV_EndBug> xenvif_put ( vif ) ; } start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; for ( i = start ; i < nr_frags ; i ++ ) { int j , newerr ; <S2SV_StartBug> pending_ring_idx_t index ; <S2SV_EndBug> pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ; newerr = ( ++ gop ) -> status ; if ( likely ( ! newerr ) ) { if ( unlikely ( err ) ) <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> continue ; } <S2SV_StartBug> txp = & netbk -> pending_tx_info [ pending_idx ] . req ; <S2SV_EndBug> make_tx_response ( vif , txp , XEN_NETIF_RSP_ERROR ) ; <S2SV_StartBug> index = pending_index ( netbk -> pending_prod ++ ) ; <S2SV_EndBug> netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; if ( err ) continue ; pending_idx = * ( ( u16 * ) skb -> data ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> for ( j = start ; j < i ; j ++ ) { pending_idx = frag_get_pending_idx ( & shinfo -> frags [ j ] ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } err = newerr ; } * gopp = gop + 1 ; return err ; }
CWE-000 void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }
CWE-284 ssize_t socket_write ( const socket_t * socket , const void * buf , size_t count ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; <S2SV_StartBug> return send ( socket -> fd , buf , count , MSG_DONTWAIT ) ; <S2SV_EndBug> }
CWE-119 void vp9_update_mbgraph_stats ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; int i , n_frames = vp9_lookahead_depth ( cpi -> lookahead ) ; <S2SV_StartBug> YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; <S2SV_EndBug> if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ; if ( n_frames > MAX_LAG_BUFFERS ) n_frames = MAX_LAG_BUFFERS ; cpi -> mbgraph_n_frames = n_frames ; for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; <S2SV_StartBug> vpx_memset ( frame_stats -> mb_stats , 0 , <S2SV_EndBug> cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; } for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ; assert ( q_cur != NULL ) ; update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , golden_ref , cpi -> Source ) ; } <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> separate_arf_mbs ( cpi ) ; }
CWE-264 static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , "sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>" "cmd=0x%x\\n" , disk -> disk_name , cmd ) ) ; <S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }
CWE-000 char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) { <S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> return ns ; }
CWE-000 static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( "GsmXSMPClient:<S2SV_blank>Setting<S2SV_blank>up<S2SV_blank>new<S2SV_blank>connection" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ; <S2SV_StartBug> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <S2SV_EndBug> ( GSourceFunc ) _client_protocol_timeout , client ) ; set_description ( client ) ; g_debug ( "GsmXSMPClient:<S2SV_blank>New<S2SV_blank>client<S2SV_blank>\'%s\'" , client -> priv -> description ) ; }
CWE-119 static int aiff_read_chanmap ( SF_PRIVATE * psf , unsigned dword ) { const AIFF_CAF_CHANNEL_MAP * map_info ; unsigned channel_bitmap , channel_decriptions , bytesread ; int layout_tag ; bytesread = psf_binheader_readf ( psf , "444" , & layout_tag , & channel_bitmap , & channel_decriptions ) ; if ( ( map_info = aiff_caf_of_channel_layout_tag ( layout_tag ) ) == NULL ) return 0 ; psf_log_printf ( psf , "<S2SV_blank><S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>%x\\n" , layout_tag ) ; if ( map_info ) psf_log_printf ( psf , "<S2SV_blank><S2SV_blank>Layout<S2SV_blank>:<S2SV_blank>%s\\n" , map_info -> name ) ; if ( bytesread < dword ) psf_binheader_readf ( psf , "j" , dword - bytesread ) ; if ( map_info -> channel_map != NULL ) <S2SV_StartBug> { size_t chanmap_size = psf -> sf . channels * sizeof ( psf -> channel_map [ 0 ] ) ; <S2SV_EndBug> free ( psf -> channel_map ) ; if ( ( psf -> channel_map = malloc ( chanmap_size ) ) == NULL ) return SFE_MALLOC_FAILED ; memcpy ( psf -> channel_map , map_info -> channel_map , chanmap_size ) ; } ; return 0 ; }
CWE-20 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <S2SV_StartBug> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <S2SV_EndBug> CORE_MMU_USER_PARAM_SIZE ) ; <S2SV_StartBug> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <S2SV_EndBug> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_StartBug> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <S2SV_EndBug> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }
CWE-000 int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ; <S2SV_StartBug> return error ; <S2SV_EndBug> }
CWE-119 TEE_Result syscall_cryp_obj_populate ( unsigned long obj , struct utee_attribute * usr_attrs , unsigned long attr_count ) { TEE_Result res ; struct tee_ta_session * sess ; struct tee_obj * o ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * attrs = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_IMPLEMENTED ; <S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_attrs , attr_count , attrs ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_POPULATE , type_props , attrs , attr_count ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_obj_populate_type ( o , type_props , attrs , attr_count ) ; if ( res == TEE_SUCCESS ) o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; out : free ( attrs ) ; return res ; }
CWE-000 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ; mac_start = skb_mac_header ( skb ) ; memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; <S2SV_StartBug> ipv6_select_ident ( fptr ) ; <S2SV_EndBug> segs = skb_segment ( skb , features ) ; out : return segs ; }
CWE-119 TEE_Result syscall_obj_generate_key ( unsigned long obj , unsigned long key_size , const struct utee_attribute * usr_params , unsigned long param_count ) { TEE_Result res ; struct tee_ta_session * sess ; const struct tee_cryp_obj_type_props * type_props ; struct tee_obj * o ; struct tee_cryp_obj_secret * key ; size_t byte_size ; TEE_Attribute * params = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_STATE ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_STATE ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size % type_props -> quanta != 0 ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size < type_props -> min_size ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size > type_props -> max_size ) return TEE_ERROR_NOT_SUPPORTED ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_GENERATE_KEY , type_props , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; switch ( o -> info . objectType ) { case TEE_TYPE_AES : case TEE_TYPE_DES : case TEE_TYPE_DES3 : case TEE_TYPE_HMAC_MD5 : case TEE_TYPE_HMAC_SHA1 : case TEE_TYPE_HMAC_SHA224 : case TEE_TYPE_HMAC_SHA256 : case TEE_TYPE_HMAC_SHA384 : case TEE_TYPE_HMAC_SHA512 : case TEE_TYPE_GENERIC_SECRET : byte_size = key_size / 8 ; if ( o -> info . objectType == TEE_TYPE_DES || o -> info . objectType == TEE_TYPE_DES3 ) { byte_size = ( key_size + key_size / 7 ) / 8 ; } key = ( struct tee_cryp_obj_secret * ) o -> attr ; if ( byte_size > key -> alloc_size ) { res = TEE_ERROR_EXCESS_DATA ; goto out ; } res = crypto_rng_read ( ( void * ) ( key + 1 ) , byte_size ) ; if ( res != TEE_SUCCESS ) goto out ; key -> key_size = byte_size ; o -> have_attrs = ( 1 << type_props -> num_type_attrs ) - 1 ; break ; case TEE_TYPE_RSA_KEYPAIR : res = tee_svc_obj_generate_key_rsa ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DSA_KEYPAIR : res = tee_svc_obj_generate_key_dsa ( o , type_props , key_size ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DH_KEYPAIR : res = tee_svc_obj_generate_key_dh ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_ECDSA_KEYPAIR : case TEE_TYPE_ECDH_KEYPAIR : res = tee_svc_obj_generate_key_ecc ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; default : res = TEE_ERROR_BAD_FORMAT ; } out : free ( params ) ; if ( res == TEE_SUCCESS ) { o -> info . keySize = key_size ; o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; } return res ; }
CWE-416 INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( "r%d,r%d,^,!," , r , d ) ; ESIL_A ( "?{,%" PFMT64d ",pc,=,}," , op -> jump ) ; }
CWE-189 static int efx_register_netdev ( struct efx_nic * efx ) { struct net_device * net_dev = efx -> net_dev ; struct efx_channel * channel ; int rc ; net_dev -> watchdog_timeo = 5 * HZ ; net_dev -> irq = efx -> pci_dev -> irq ; net_dev -> netdev_ops = & efx_netdev_ops ; SET_ETHTOOL_OPS ( net_dev , & efx_ethtool_ops ) ; <S2SV_StartBug> efx -> mac_op -> update_stats ( efx ) ; <S2SV_EndBug> memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ; rtnl_lock ( ) ; rc = dev_alloc_name ( net_dev , net_dev -> name ) ; if ( rc < 0 ) goto fail_locked ; efx_update_name ( efx ) ; rc = register_netdevice ( net_dev ) ; if ( rc ) goto fail_locked ; efx_for_each_channel ( channel , efx ) { struct efx_tx_queue * tx_queue ; efx_for_each_channel_tx_queue ( tx_queue , channel ) efx_init_tx_queue_core_txq ( tx_queue ) ; } netif_carrier_off ( efx -> net_dev ) ; rtnl_unlock ( ) ; rc = device_create_file ( & efx -> pci_dev -> dev , & dev_attr_phy_type ) ; if ( rc ) { netif_err ( efx , drv , efx -> net_dev , "failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>net<S2SV_blank>dev<S2SV_blank>attributes\\n" ) ; goto fail_registered ; } return 0 ; fail_locked : rtnl_unlock ( ) ; netif_err ( efx , drv , efx -> net_dev , "could<S2SV_blank>not<S2SV_blank>register<S2SV_blank>net<S2SV_blank>dev\\n" ) ; return rc ; fail_registered : unregister_netdev ( net_dev ) ; return rc ; }
CWE-20 static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { memset ( sax , 0 , sizeof ( * sax ) ) ; sax -> sax25_family = AF_NETROM ; skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ; <S2SV_StartBug> } <S2SV_EndBug> msg -> msg_namelen = sizeof ( * sax ) ; <S2SV_StartBug> skb_free_datagram ( sk , skb ) ; <S2SV_EndBug> release_sock ( sk ) ; return copied ; }
CWE-119 int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { av_dlog ( NULL , "overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , "%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> pc -> buffer = new_buffer ; if ( next > - FF_INPUT_BUFFER_PADDING_SIZE ) memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ) ; pc -> index = 0 ; * buf = pc -> buffer ; } for ( ; next < 0 ; next ++ ) { pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> overread ++ ; } if ( pc -> overread ) { av_dlog ( NULL , "overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , "%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } return 0 ; }
CWE-416 <S2SV_StartBug> static int ion_handle_put ( struct ion_handle * handle ) <S2SV_EndBug> { struct ion_client * client = handle -> client ; int ret ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> ret = kref_put ( & handle -> ref , ion_handle_destroy ) ; <S2SV_EndBug> mutex_unlock ( & client -> lock ) ; return ret ; }
CWE-200 static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; <S2SV_StartBug> err = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }
CWE-399 struct sctp_chunk * sctp_assoc_lookup_asconf_ack ( const struct sctp_association * asoc , __be32 serial ) { struct sctp_chunk * ack ; list_for_each_entry ( ack , & asoc -> asconf_ack_list , transmitted_list ) { <S2SV_StartBug> if ( ack -> subh . addip_hdr -> serial == serial ) { <S2SV_EndBug> sctp_chunk_hold ( ack ) ; return ack ; } } return NULL ; }
CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( "iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( "mark_source_chains:<S2SV_blank>bad<S2SV_blank>" "negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( "Back<S2SV_blank>unset<S2SV_blank>" "on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>" "rule<S2SV_blank>%u\\n" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ip6t_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ip6t_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ip6t_entry ) ) { duprintf ( "mark_source_chains:<S2SV_blank>" "bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , newpos ) ; return 0 ; } duprintf ( "Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ip6t_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( "Finished<S2SV_blank>chain<S2SV_blank>%u\\n" , hook ) ; } return 1 ; }
CWE-000 static void sas_discover_domain ( struct work_struct * work ) { struct domain_device * dev ; int error = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DISCOVER_DOMAIN , & port -> disc . pending ) ; if ( port -> port_dev ) return ; error = sas_get_port_device ( port ) ; if ( error ) return ; dev = port -> port_dev ; SAS_DPRINTK ( "DOING<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n" , port -> id , task_pid_nr ( current ) ) ; switch ( dev -> dev_type ) { case SAS_END_DEVICE : error = sas_discover_end_dev ( dev ) ; break ; case SAS_EDGE_EXPANDER_DEVICE : case SAS_FANOUT_EXPANDER_DEVICE : error = sas_discover_root_expander ( dev ) ; break ; case SAS_SATA_DEV : case SAS_SATA_PM : # ifdef CONFIG_SCSI_SAS_ATA error = sas_discover_sata ( dev ) ; break ; # else SAS_DPRINTK ( "ATA<S2SV_blank>device<S2SV_blank>seen<S2SV_blank>but<S2SV_blank>CONFIG_SCSI_SAS_ATA=N<S2SV_blank>so<S2SV_blank>cannot<S2SV_blank>attach\\n" ) ; # endif default : error = - ENXIO ; SAS_DPRINTK ( "unhandled<S2SV_blank>device<S2SV_blank>%d\\n" , dev -> dev_type ) ; break ; } if ( error ) { sas_rphy_free ( dev -> rphy ) ; list_del_init ( & dev -> disco_list_node ) ; spin_lock_irq ( & port -> dev_list_lock ) ; list_del_init ( & dev -> dev_list_node ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; sas_put_device ( dev ) ; port -> port_dev = NULL ; } <S2SV_StartBug> SAS_DPRINTK ( "DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\n" , port -> id , <S2SV_EndBug> task_pid_nr ( current ) , error ) ; }
CWE-000 static struct file * path_openat ( int dfd , struct filename * pathname , struct nameidata * nd , const struct open_flags * op , int flags ) { struct file * file ; struct path path ; int opened = 0 ; int error ; file = get_empty_filp ( ) ; if ( IS_ERR ( file ) ) return file ; file -> f_flags = op -> open_flag ; if ( unlikely ( file -> f_flags & __O_TMPFILE ) ) { error = do_tmpfile ( dfd , pathname , nd , flags , op , file , & opened ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } error = path_init ( dfd , pathname , flags , nd ) ; if ( unlikely ( error ) ) goto out ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; while ( unlikely ( error > 0 ) ) { struct path link = path ; void * cookie ; if ( ! ( nd -> flags & LOOKUP_FOLLOW ) ) { path_put_conditional ( & path , nd ) ; path_put ( & nd -> path ) ; error = - ELOOP ; break ; } error = may_follow_link ( & link , nd ) ; if ( unlikely ( error ) ) break ; nd -> flags |= LOOKUP_PARENT ; nd -> flags &= ~ ( LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_EXCL ) ; error = follow_link ( & link , nd , & cookie ) ; if ( unlikely ( error ) ) break ; error = do_last ( nd , & path , file , op , & opened , pathname ) ; put_link ( nd , & link , cookie ) ; } out : path_cleanup ( nd ) ; <S2SV_StartBug> if ( ! ( opened & FILE_OPENED ) ) { <S2SV_EndBug> BUG_ON ( ! error ) ; put_filp ( file ) ; } if ( unlikely ( error ) ) { if ( error == - EOPENSTALE ) { if ( flags & LOOKUP_RCU ) error = - ECHILD ; else error = - ESTALE ; } file = ERR_PTR ( error ) ; } return file ; }
CWE-119 static int rd_cost_mbuv ( MACROBLOCK * mb ) { int b ; int cost = 0 ; MACROBLOCKD * x = & mb -> e_mbd ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; <S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; for ( b = 16 ; b < 24 ; b ++ ) cost += cost_coeffs ( mb , x -> block + b , PLANE_TYPE_UV , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; return cost ; }
CWE-119 static double get_prediction_decay_rate ( VP8_COMP * cpi , FIRSTPASS_STATS * next_frame ) { double prediction_decay_rate ; double motion_decay ; <S2SV_StartBug> double motion_pct = next_frame -> pcnt_motion ; <S2SV_EndBug> prediction_decay_rate = next_frame -> pcnt_inter ; motion_decay = ( 1.0 - ( motion_pct / 20.0 ) ) ; if ( motion_decay < prediction_decay_rate ) prediction_decay_rate = motion_decay ; { double this_mv_rabs ; double this_mv_cabs ; double distance_factor ; this_mv_rabs = fabs ( next_frame -> mvr_abs * motion_pct ) ; this_mv_cabs = fabs ( next_frame -> mvc_abs * motion_pct ) ; distance_factor = sqrt ( ( this_mv_rabs * this_mv_rabs ) + ( this_mv_cabs * this_mv_cabs ) ) / 250.0 ; distance_factor = ( ( distance_factor > 1.0 ) ? 0.0 : ( 1.0 - distance_factor ) ) ; if ( distance_factor < prediction_decay_rate ) prediction_decay_rate = distance_factor ; } return prediction_decay_rate ; }
CWE-119 void set_cfg_option ( char * opt_string ) { char * sep , * sep2 , szSec [ 1024 ] , szKey [ 1024 ] , szVal [ 1024 ] ; sep = strchr ( opt_string , ':' ) ; if ( ! sep ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n" , opt_string ) ; return ; } { const size_t sepIdx = sep - opt_string ; <S2SV_StartBug> strncpy ( szSec , opt_string , sepIdx ) ; <S2SV_EndBug> szSec [ sepIdx ] = 0 ; } sep ++ ; sep2 = strchr ( sep , '=' ) ; if ( ! sep2 ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:Name=Value\\n" , opt_string ) ; return ; } { const size_t sepIdx = sep2 - sep ; <S2SV_StartBug> strncpy ( szKey , sep , sepIdx ) ; <S2SV_EndBug> szKey [ sepIdx ] = 0 ; <S2SV_StartBug> strcpy ( szVal , sep2 + 1 ) ; <S2SV_EndBug> } if ( ! stricmp ( szKey , "*" ) ) { if ( stricmp ( szVal , "null" ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>expected<S2SV_blank>Section:*=null\\n" , opt_string ) ; return ; } gf_cfg_del_section ( cfg_file , szSec ) ; return ; } if ( ! stricmp ( szVal , "null" ) ) { szVal [ 0 ] = 0 ; } gf_cfg_set_key ( cfg_file , szSec , szKey , szVal [ 0 ] ? szVal : NULL ) ; }
CWE-125 static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) { int name_end = - 1 ; int j = * idx ; int ptr_count = 0 ; # define GET32 ( x ) do { if ( j + 4 > length ) goto err ; memcpy ( & t32_ , packet + j , 4 ) ; j += 4 ; x = ntohl ( t32_ ) ; } while ( 0 ) # define GET16 ( x ) do { if ( j + 2 > length ) goto err ; memcpy ( & t_ , packet + j , 2 ) ; j += 2 ; x = ntohs ( t_ ) ; } while ( 0 ) # define GET8 ( x ) do { if ( j >= length ) goto err ; x = packet [ j ++ ] ; } while ( 0 ) char * cp = name_out ; const char * const end = name_out + name_out_len ; for ( ; ; ) { u8 label_len ; <S2SV_StartBug> if ( j >= length ) return - 1 ; <S2SV_EndBug> GET8 ( label_len ) ; if ( ! label_len ) break ; if ( label_len & 0xc0 ) { u8 ptr_low ; GET8 ( ptr_low ) ; if ( name_end < 0 ) name_end = j ; j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ; if ( j < 0 || j >= length ) return - 1 ; if ( ++ ptr_count > length ) return - 1 ; continue ; } if ( label_len > 63 ) return - 1 ; if ( cp != name_out ) { if ( cp + 1 >= end ) return - 1 ; * cp ++ = '.' ; } if ( cp + label_len >= end ) return - 1 ; <S2SV_StartBug> memcpy ( cp , packet + j , label_len ) ; <S2SV_EndBug> cp += label_len ; j += label_len ; } if ( cp >= end ) return - 1 ; * cp = '\\0' ; if ( name_end < 0 ) * idx = j ; else * idx = name_end ; return 0 ; err : return - 1 ; }
CWE-125 static u_int ieee802_11_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int orig_caplen , int pad , u_int fcslen ) { uint16_t fc ; u_int caplen , hdrlen , meshdrlen ; struct lladdr_info src , dst ; int llc_hdrlen ; caplen = orig_caplen ; if ( length < fcslen ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return caplen ; } length -= fcslen ; if ( caplen > length ) { fcslen = caplen - length ; caplen -= fcslen ; ndo -> ndo_snapend -= fcslen ; } if ( caplen < IEEE802_11_FC_LEN ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return orig_caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( ndo , fc ) ; if ( hdrlen == 0 ) { return ( 0 ) ; } if ( pad ) hdrlen = roundup2 ( hdrlen , 4 ) ; if ( ndo -> ndo_Hflag && FC_TYPE ( fc ) == T_DATA && DATA_FRAME_IS_QOS ( FC_SUBTYPE ( fc ) ) ) { <S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> hdrlen += meshdrlen ; } else meshdrlen = 0 ; if ( caplen < hdrlen ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } if ( ndo -> ndo_eflag ) ieee_802_11_hdr_print ( ndo , fc , p , hdrlen , meshdrlen ) ; length -= hdrlen ; caplen -= hdrlen ; p += hdrlen ; src . addr_string = etheraddr_string ; dst . addr_string = etheraddr_string ; switch ( FC_TYPE ( fc ) ) { case T_MGMT : get_mgmt_src_dst_mac ( p - hdrlen , & src . addr , & dst . addr ) ; if ( ! mgmt_body_print ( ndo , fc , src . addr , p , length ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } break ; case T_CTRL : if ( ! ctrl_body_print ( ndo , fc , p - hdrlen ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } break ; case T_DATA : if ( DATA_FRAME_IS_NULL ( FC_SUBTYPE ( fc ) ) ) return hdrlen ; if ( FC_PROTECTED ( fc ) ) { ND_PRINT ( ( ndo , "Data" ) ) ; if ( ! wep_print ( ndo , p ) ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; } } else { get_data_src_dst_mac ( fc , p - hdrlen , & src . addr , & dst . addr ) ; llc_hdrlen = llc_print ( ndo , p , length , caplen , & src , & dst ) ; if ( llc_hdrlen < 0 ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; llc_hdrlen = - llc_hdrlen ; } hdrlen += llc_hdrlen ; } break ; default : break ; } return hdrlen ; }
CWE-000 int vp8_remove_decoder_instances ( struct frame_buffers * fb ) { if ( ! fb -> use_frame_threads ) { VP8D_COMP * pbi = fb -> pbi [ 0 ] ; if ( ! pbi ) return VPX_CODEC_ERROR ; # if CONFIG_MULTITHREAD <S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug> vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; vp8_decoder_remove_threads ( pbi ) ; # endif remove_decompressor ( pbi ) ; } else { } return VPX_CODEC_OK ; }
CWE-399 static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } else { __u64 lo , hi ; switch ( width_shift ) { case 1 : misaligned_kernel_word_load ( address , do_sign_extend , & regs -> regs [ destreg ] ) ; break ; case 2 : asm ( "ldlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0" : "=r" ( lo ) : "r" ( address ) ) ; asm ( "ldhi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0" : "=r" ( hi ) : "r" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; case 3 : asm ( "ldlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0" : "=r" ( lo ) : "r" ( address ) ) ; asm ( "ldhi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0" : "=r" ( hi ) : "r" ( address ) ) ; regs -> regs [ destreg ] = lo | hi ; break ; default : printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } return 0 ; }
CWE-000 int install_user_keyrings ( void ) { struct user_struct * user ; const struct cred * cred ; struct key * uid_keyring , * session_keyring ; key_perm_t user_keyring_perm ; char buf [ 20 ] ; int ret ; uid_t uid ; user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( "%p{%u}" , user , uid ) ; if ( user -> uid_keyring && user -> session_keyring ) { kleave ( "<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]" ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , "_uid.%u" , uid ) ; uid_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( uid_keyring ) ) { uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> NULL , NULL ) ; if ( IS_ERR ( uid_keyring ) ) { ret = PTR_ERR ( uid_keyring ) ; goto error ; } } sprintf ( buf , "_uid_ses.%u" , uid ) ; session_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( session_keyring ) ) { session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> NULL , NULL ) ; if ( IS_ERR ( session_keyring ) ) { ret = PTR_ERR ( session_keyring ) ; goto error_release ; } ret = key_link ( session_keyring , uid_keyring ) ; if ( ret < 0 ) goto error_release_both ; } user -> uid_keyring = uid_keyring ; user -> session_keyring = session_keyring ; } mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( "<S2SV_blank>=<S2SV_blank>0" ) ; return 0 ; error_release_both : key_put ( session_keyring ) ; error_release : key_put ( uid_keyring ) ; error : mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( "<S2SV_blank>=<S2SV_blank>%d" , ret ) ; return ret ; }
CWE-362 static int packet_do_bind ( struct sock * sk , const char * name , int ifindex , __be16 proto ) { struct packet_sock * po = pkt_sk ( sk ) ; struct net_device * dev_curr ; __be16 proto_curr ; bool need_rehook ; struct net_device * dev = NULL ; int ret = 0 ; bool unlisted = false ; <S2SV_StartBug> if ( po -> fanout ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; if ( name ) { dev = dev_get_by_name_rcu ( sock_net ( sk ) , name ) ; if ( ! dev ) { ret = - ENODEV ; goto out_unlock ; } } else if ( ifindex ) { dev = dev_get_by_index_rcu ( sock_net ( sk ) , ifindex ) ; if ( ! dev ) { ret = - ENODEV ; goto out_unlock ; } } if ( dev ) dev_hold ( dev ) ; proto_curr = po -> prot_hook . type ; dev_curr = po -> prot_hook . dev ; need_rehook = proto_curr != proto || dev_curr != dev ; if ( need_rehook ) { if ( po -> running ) { rcu_read_unlock ( ) ; __unregister_prot_hook ( sk , true ) ; rcu_read_lock ( ) ; dev_curr = po -> prot_hook . dev ; if ( dev ) unlisted = ! dev_get_by_index_rcu ( sock_net ( sk ) , dev -> ifindex ) ; } po -> num = proto ; po -> prot_hook . type = proto ; if ( unlikely ( unlisted ) ) { dev_put ( dev ) ; po -> prot_hook . dev = NULL ; po -> ifindex = - 1 ; packet_cached_dev_reset ( po ) ; } else { po -> prot_hook . dev = dev ; po -> ifindex = dev ? dev -> ifindex : 0 ; packet_cached_dev_assign ( po , dev ) ; } } if ( dev_curr ) dev_put ( dev_curr ) ; if ( proto == 0 || ! need_rehook ) goto out_unlock ; if ( ! unlisted && ( ! dev || ( dev -> flags & IFF_UP ) ) ) { register_prot_hook ( sk ) ; } else { sk -> sk_err = ENETDOWN ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_error_report ( sk ) ; } out_unlock : rcu_read_unlock ( ) ; spin_unlock ( & po -> bind_lock ) ; release_sock ( sk ) ; return ret ; }
CWE-000 static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ; <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> offset += chars ; buf -> len -= chars ; if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { total_len = chars ; buf -> len = 0 ; } if ( ! buf -> len ) { buf -> ops = NULL ; ops -> release ( pipe , buf ) ; curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 ) ; pipe -> curbuf = curbuf ; pipe -> nrbufs = -- bufs ; do_wakeup = 1 ; } total_len -= chars ; if ( ! total_len ) break ; } if ( bufs ) continue ; if ( ! pipe -> writers ) break ; if ( ! pipe -> waiting_writers ) { if ( ret ) break ; if ( filp -> f_flags & O_NONBLOCK ) { ret = - EAGAIN ; break ; } } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } pipe_wait ( pipe ) ; } __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } if ( ret > 0 ) file_accessed ( filp ) ; return ret ; }
CWE-119 void vp8_cal_sad ( VP8_COMP * cpi , MACROBLOCKD * xd , MACROBLOCK * x , int recon_yoffset , int near_sadidx [ ] ) { int near_sad [ 8 ] = { 0 } ; BLOCK * b = & x -> block [ 0 ] ; unsigned char * src_y_ptr = * ( b -> base_src ) ; if ( xd -> mb_to_top_edge == 0 && xd -> mb_to_left_edge == 0 ) { near_sad [ 0 ] = near_sad [ 1 ] = near_sad [ 2 ] = INT_MAX ; } else if ( xd -> mb_to_top_edge == 0 ) { near_sad [ 0 ] = near_sad [ 2 ] = INT_MAX ; <S2SV_StartBug> near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> } else if ( xd -> mb_to_left_edge == 0 ) { near_sad [ 1 ] = near_sad [ 2 ] = INT_MAX ; <S2SV_StartBug> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> } else { <S2SV_StartBug> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 2 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 - 16 , xd -> dst . y_stride , UINT_MAX ) ; <S2SV_EndBug> } if ( cpi -> common . last_frame_type != KEY_FRAME ) { unsigned char * pre_y_buffer = cpi -> common . yv12_fb [ cpi -> common . lst_fb_idx ] . y_buffer + recon_yoffset ; int pre_y_stride = cpi -> common . yv12_fb [ cpi -> common . lst_fb_idx ] . y_stride ; if ( xd -> mb_to_top_edge == 0 ) near_sad [ 4 ] = INT_MAX ; if ( xd -> mb_to_left_edge == 0 ) near_sad [ 5 ] = INT_MAX ; if ( xd -> mb_to_right_edge == 0 ) near_sad [ 6 ] = INT_MAX ; if ( xd -> mb_to_bottom_edge == 0 ) near_sad [ 7 ] = INT_MAX ; if ( near_sad [ 4 ] != INT_MAX ) <S2SV_StartBug> near_sad [ 4 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> if ( near_sad [ 5 ] != INT_MAX ) <S2SV_StartBug> near_sad [ 5 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer - 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> <S2SV_StartBug> near_sad [ 3 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> if ( near_sad [ 6 ] != INT_MAX ) <S2SV_StartBug> near_sad [ 6 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> if ( near_sad [ 7 ] != INT_MAX ) <S2SV_StartBug> near_sad [ 7 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , pre_y_buffer + pre_y_stride * 16 , pre_y_stride , UINT_MAX ) ; <S2SV_EndBug> } if ( cpi -> common . last_frame_type != KEY_FRAME ) { insertsortsad ( near_sad , near_sadidx , 8 ) ; } else { insertsortsad ( near_sad , near_sadidx , 3 ) ; } }
CWE-119 static int evaluate_inter_mode ( unsigned int * sse , int rate2 , int * distortion2 , VP8_COMP * cpi , MACROBLOCK * x , int rd_adj ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; int_mv mv = x -> e_mbd . mode_info_context -> mbmi . mv ; <S2SV_StartBug> int this_rd ; <S2SV_EndBug> if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { * sse = 0 ; * distortion2 = 0 ; x -> skip = 1 ; return INT_MAX ; } if ( ( this_mode != NEWMV ) || ! ( cpi -> sf . half_pixel_search ) || cpi -> common . full_pixel == 1 ) * distortion2 = vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , sse , mv ) ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , * distortion2 ) ; <S2SV_StartBug> if ( this_mode == ZEROMV ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( cpi -> ref_frame_flags & VP8_LAST_FRAME & <S2SV_EndBug> cpi -> common . refresh_last_frame ) && x -> e_mbd . mode_info_context -> mbmi . ref_frame != LAST_FRAME ) rd_adj = 100 ; this_rd = ( ( int64_t ) this_rd ) * rd_adj / 100 ; } check_for_encode_breakout ( * sse , x ) ; return this_rd ; }
CWE-416 char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; <S2SV_StartBug> tm = localtime ( & t ) ; <S2SV_EndBug> str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }
CWE-200 IMPEG2D_ERROR_CODES_T impeg2d_init_video_state ( dec_state_t * ps_dec , e_video_type_t e_video_type ) { if ( e_video_type == MPEG_1_VIDEO ) { ps_dec -> u2_is_mpeg2 = 0 ; ps_dec -> u2_progressive_sequence = 1 ; ps_dec -> u2_intra_dc_precision = 0 ; ps_dec -> u2_picture_structure = FRAME_PICTURE ; ps_dec -> u2_frame_pred_frame_dct = 1 ; ps_dec -> u2_concealment_motion_vectors = 0 ; ps_dec -> u2_q_scale_type = 0 ; ps_dec -> u2_intra_vlc_format = 0 ; ps_dec -> u2_alternate_scan = 0 ; ps_dec -> u2_repeat_first_field = 0 ; ps_dec -> u2_progressive_frame = 1 ; ps_dec -> u2_frame_rate_extension_n = 0 ; ps_dec -> u2_frame_rate_extension_d = 0 ; <S2SV_StartBug> ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg1 ; <S2SV_EndBug> } else { ps_dec -> u2_is_mpeg2 = 1 ; ps_dec -> u2_full_pel_forw_vector = 0 ; ps_dec -> u2_forw_f_code = 7 ; ps_dec -> u2_full_pel_back_vector = 0 ; ps_dec -> u2_back_f_code = 7 ; ps_dec -> pf_vld_inv_quant = impeg2d_vld_inv_quant_mpeg2 ; } impeg2d_init_function_ptr ( ps_dec ) ; ps_dec -> u2_frame_height = ALIGN16 ( ps_dec -> u2_vertical_size ) ; ps_dec -> u2_frame_width = ALIGN16 ( ps_dec -> u2_horizontal_size ) ; ps_dec -> u2_num_horiz_mb = ( ps_dec -> u2_horizontal_size + 15 ) >> 4 ; if ( ps_dec -> u2_frame_height > ps_dec -> u2_create_max_height || ps_dec -> u2_frame_width > ps_dec -> u2_create_max_width ) { return IMPEG2D_PIC_SIZE_NOT_SUPPORTED ; } ps_dec -> u2_num_flds_decoded = 0 ; { UWORD32 numer ; UWORD32 denom ; numer = ( UWORD32 ) gau2_impeg2_frm_rate_code [ ps_dec -> u2_frame_rate_code ] [ 1 ] * ( UWORD32 ) ( ps_dec -> u2_frame_rate_extension_d + 1 ) ; denom = ( UWORD32 ) gau2_impeg2_frm_rate_code [ ps_dec -> u2_frame_rate_code ] [ 0 ] * ( UWORD32 ) ( ps_dec -> u2_frame_rate_extension_n + 1 ) ; ps_dec -> u2_framePeriod = ( numer * 1000 * 100 ) / denom ; } if ( VERTICAL_SCAN == ps_dec -> u2_alternate_scan ) { ps_dec -> pu1_inv_scan_matrix = ( UWORD8 * ) gau1_impeg2_inv_scan_vertical ; } else { ps_dec -> pu1_inv_scan_matrix = ( UWORD8 * ) gau1_impeg2_inv_scan_zig_zag ; } return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-000 GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { <S2SV_StartBug> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n" ) ) ; <S2SV_EndBug> <S2SV_StartBug> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <S2SV_EndBug> } return GF_OK ; }
CWE-189 asmlinkage long sys_oabi_semtimedop ( int semid , struct oabi_sembuf __user * tsops , unsigned nsops , const struct timespec __user * timeout ) { struct sembuf * sops ; struct timespec local_timeout ; long err ; int i ; <S2SV_StartBug> if ( nsops < 1 ) <S2SV_EndBug> return - EINVAL ; sops = kmalloc ( sizeof ( * sops ) * nsops , GFP_KERNEL ) ; if ( ! sops ) return - ENOMEM ; err = 0 ; for ( i = 0 ; i < nsops ; i ++ ) { __get_user_error ( sops [ i ] . sem_num , & tsops -> sem_num , err ) ; __get_user_error ( sops [ i ] . sem_op , & tsops -> sem_op , err ) ; __get_user_error ( sops [ i ] . sem_flg , & tsops -> sem_flg , err ) ; tsops ++ ; } if ( timeout ) { err |= copy_from_user ( & local_timeout , timeout , sizeof ( * timeout ) ) ; timeout = & local_timeout ; } if ( err ) { err = - EFAULT ; } else { mm_segment_t fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; err = sys_semtimedop ( semid , sops , nsops , timeout ) ; set_fs ( fs ) ; } kfree ( sops ) ; return err ; }
CWE-119 static REFERENCE_MODE read_frame_reference_mode ( const VP9_COMMON * cm , <S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> if ( is_compound_reference_allowed ( cm ) ) { <S2SV_StartBug> return vp9_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT <S2SV_EndBug> : COMPOUND_REFERENCE ) : SINGLE_REFERENCE ; } else { return SINGLE_REFERENCE ; } }
CWE-362 static void sctp_generate_timeout_event ( struct sctp_association * asoc , sctp_event_timeout_t timeout_type ) { <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( "%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\n" , __func__ , timeout_type ) ; if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( timeout_type ) , asoc -> state , asoc -> ep , asoc , ( void * ) timeout_type , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_association_put ( asoc ) ; }
CWE-362 static long madvise_remove ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { loff_t offset ; int error ; <S2SV_StartBug> * prev = NULL ; <S2SV_EndBug> if ( vma -> vm_flags & ( VM_LOCKED | VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ; <S2SV_StartBug> if ( ! vma -> vm_file || ! vma -> vm_file -> f_mapping <S2SV_EndBug> <S2SV_StartBug> || ! vma -> vm_file -> f_mapping -> host ) { <S2SV_EndBug> return - EINVAL ; } if ( ( vma -> vm_flags & ( VM_SHARED | VM_WRITE ) ) != ( VM_SHARED | VM_WRITE ) ) return - EACCES ; offset = ( loff_t ) ( start - vma -> vm_start ) + ( ( loff_t ) vma -> vm_pgoff << PAGE_SHIFT ) ; <S2SV_StartBug> up_read ( & current -> mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> error = do_fallocate ( vma -> vm_file , <S2SV_EndBug> FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , <S2SV_StartBug> offset , end - start ) ; <S2SV_EndBug> down_read ( & current -> mm -> mmap_sem ) ; return error ; }
CWE-119 <S2SV_StartBug> static int input_stats ( struct twopass_rc * p , FIRSTPASS_STATS * fps ) { <S2SV_EndBug> if ( p -> stats_in >= p -> stats_in_end ) return EOF ; * fps = * p -> stats_in ; ++ p -> stats_in ; return 1 ; }
CWE-200 void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ; <S2SV_StartBug> buf = g_malloc ( size ) ; <S2SV_EndBug> if ( object ) { g_signal_connect ( object , "postclose" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }
CWE-000 crm_client_t * crm_client_new ( qb_ipcs_connection_t * c , uid_t uid_client , gid_t gid_client ) { <S2SV_StartBug> static uid_t uid_server = 0 ; <S2SV_EndBug> static gid_t gid_cluster = 0 ; crm_client_t * client = NULL ; CRM_LOG_ASSERT ( c ) ; if ( c == NULL ) { return NULL ; } if ( gid_cluster == 0 ) { <S2SV_StartBug> uid_server = getuid ( ) ; <S2SV_EndBug> if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & gid_cluster ) < 0 ) { static bool have_error = FALSE ; if ( have_error == FALSE ) { crm_warn ( "Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>group<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , CRM_DAEMON_USER ) ; have_error = TRUE ; } } } <S2SV_StartBug> if ( gid_cluster != 0 && gid_client != 0 ) { <S2SV_EndBug> uid_t best_uid = - 1 ; if ( uid_client == 0 || uid_server == 0 ) { best_uid = QB_MAX ( uid_client , uid_server ) ; crm_trace ( "Allowing<S2SV_blank>user<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>clean<S2SV_blank>up<S2SV_blank>after<S2SV_blank>disconnect" , best_uid ) ; } crm_trace ( "Giving<S2SV_blank>access<S2SV_blank>to<S2SV_blank>group<S2SV_blank>%u" , gid_cluster ) ; qb_ipcs_connection_auth_set ( c , best_uid , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) ; } crm_client_init ( ) ; client = calloc ( 1 , sizeof ( crm_client_t ) ) ; client -> ipcs = c ; client -> kind = CRM_CLIENT_IPC ; client -> pid = crm_ipcs_client_pid ( c ) ; client -> id = crm_generate_uuid ( ) ; crm_debug ( "Connecting<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>pid=%u<S2SV_blank>id=%s" , c , uid_client , gid_client , client -> pid , client -> id ) ; # if ENABLE_ACL client -> user = uid2username ( uid_client ) ; # endif g_hash_table_insert ( client_connections , c , client ) ; return client ; }
CWE-125 static const char * parse_string ( cJSON * item , const char * str , const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \'\\"\' ) { * ep = str ; return 0 ; } <S2SV_StartBug> while ( * end_ptr != \'\\"\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\' ) end_ptr ++ ; <S2SV_EndBug> out = ( char * ) cJSON_malloc ( len + 1 ) ; if ( ! out ) return 0 ; item -> valuestring = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) { if ( * ptr != '\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\b' ; break ; case 'f' : * ptr2 ++ = '\\f' ; break ; case 'n' : * ptr2 ++ = '\\n' ; break ; case 'r' : * ptr2 ++ = '\\r' ; break ; case 't' : * ptr2 ++ = '\\t' ; break ; case 'u' : uc = parse_hex4 ( ptr + 1 ) ; ptr += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) { * ep = str ; return 0 ; } if ( uc >= 0xD800 && uc <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } if ( ptr [ 1 ] != '\\\\' || ptr [ 2 ] != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 ( ptr + 3 ) ; ptr += 6 ; if ( uc2 < 0xDC00 || uc2 > 0xDFFF ) { * ep = str ; return 0 ; } uc = 0x10000 + ( ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ) ; } len = 4 ; if ( uc < 0x80 ) len = 1 ; else if ( uc < 0x800 ) len = 2 ; else if ( uc < 0x10000 ) len = 3 ; ptr2 += len ; switch ( len ) { case 4 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 3 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 2 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; uc >>= 6 ; case 1 : * -- ptr2 = ( uc | firstByteMark [ len ] ) ; } ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } ptr ++ ; } } * ptr2 = 0 ; if ( * ptr == \'\\"\' ) ptr ++ ; return ptr ; }
CWE-189 static Image * ExtractPostscript ( Image * image , const ImageInfo * image_info , MagickOffsetType PS_Offset , ssize_t PS_Size , ExceptionInfo * exception ) { char postscript_file [ MaxTextExtent ] ; const MagicInfo * magic_info ; FILE * ps_file ; ImageInfo * clone_info ; Image * image2 ; unsigned char magick [ 2 * MaxTextExtent ] ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) return ( image ) ; clone_info -> blob = ( void * ) NULL ; clone_info -> length = 0 ; ( void ) AcquireUniqueFilename ( postscript_file ) ; ps_file = fopen_utf8 ( postscript_file , "wb" ) ; if ( ps_file == ( FILE * ) NULL ) goto FINISH ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; ( void ) ReadBlob ( image , 2 * MaxTextExtent , magick ) ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; while ( PS_Size -- > 0 ) { ( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ; } ( void ) fclose ( ps_file ) ; magic_info = GetMagicInfo ( magick , 2 * MaxTextExtent , exception ) ; if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ; if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <S2SV_StartBug> ( void ) strncpy ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> FormatLocaleString ( clone_info -> filename , MaxTextExtent , "%s" , postscript_file ) ; image2 = ReadImage ( clone_info , exception ) ; if ( ! image2 ) goto FINISH_UNL ; ( void ) CopyMagickString ( image2 -> filename , image -> filename , MaxTextExtent ) ; ( void ) CopyMagickString ( image2 -> magick_filename , image -> magick_filename , MaxTextExtent ) ; ( void ) CopyMagickString ( image2 -> magick , image -> magick , MaxTextExtent ) ; image2 -> depth = image -> depth ; DestroyBlob ( image2 ) ; image2 -> blob = ReferenceBlob ( image -> blob ) ; if ( ( image -> rows == 0 ) || ( image -> columns == 0 ) ) DeleteImageFromList ( & image ) ; AppendImageToList ( & image , image2 ) ; FINISH_UNL : ( void ) RelinquishUniqueFileResource ( postscript_file ) ; FINISH : DestroyImageInfo ( clone_info ) ; return ( image ) ; }
CWE-119 <S2SV_StartBug> static int write_skip ( const VP9_COMP * cpi , int segment_id , const MODE_INFO * mi , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> <S2SV_StartBug> const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> if ( vp9_segfeature_active ( & cpi -> common . seg , segment_id , SEG_LVL_SKIP ) ) { return 1 ; } else { const int skip = mi -> mbmi . skip ; <S2SV_StartBug> vp9_write ( w , skip , vp9_get_skip_prob ( & cpi -> common , xd ) ) ; <S2SV_EndBug> return skip ; } }
CWE-125 static int read_new_config_info ( WavpackContext * wpc , WavpackMetadata * wpmd ) { int bytecnt = wpmd -> byte_length ; unsigned char * byteptr = wpmd -> data ; wpc -> version_five = 1 ; wpc -> file_format = wpc -> config . qmode = wpc -> channel_layout = 0 ; if ( wpc -> channel_reordering ) { free ( wpc -> channel_reordering ) ; wpc -> channel_reordering = NULL ; } <S2SV_StartBug> if ( bytecnt ) { <S2SV_EndBug> wpc -> file_format = * byteptr ++ ; wpc -> config . qmode = ( wpc -> config . qmode & ~ 0xff ) | * byteptr ++ ; bytecnt -= 2 ; if ( bytecnt ) { int nchans , i ; wpc -> channel_layout = ( int32_t ) * byteptr ++ << 16 ; bytecnt -- ; if ( bytecnt ) { wpc -> channel_layout += nchans = * byteptr ++ ; bytecnt -- ; if ( bytecnt ) { if ( bytecnt > nchans ) return FALSE ; wpc -> channel_reordering = malloc ( nchans ) ; if ( wpc -> channel_reordering ) { for ( i = 0 ; i < nchans ; ++ i ) if ( bytecnt ) { wpc -> channel_reordering [ i ] = * byteptr ++ ; <S2SV_StartBug> bytecnt -- ; <S2SV_EndBug> } else wpc -> channel_reordering [ i ] = i ; } } } else wpc -> channel_layout += wpc -> config . num_channels ; } } return TRUE ; }
CWE-362 static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; <S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( ret < 0 ) { <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev ) ; return ret ; } <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> cd -> fd = ret ; return 0 ; }
CWE-000 static void copy_xauthority ( void ) { char * src = RUN_XAUTHORITY_FILE ; char * dest ; if ( asprintf ( & dest , "%s/.Xauthority" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , "Error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link\\n" , dest ) ; exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <S2SV_StartBug> if ( rv ) <S2SV_EndBug> fprintf ( stderr , "Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n" ) ; else { <S2SV_StartBug> fs_logger2 ( "clone" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }
CWE-416 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
CWE-264 void * arm_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , false , __builtin_return_address ( 0 ) ) ; }
CWE-399 static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) { AVFilterContext * ctx = inlink -> dst ; FPSContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int64_t delta ; int i , ret ; s -> frames_in ++ ; if ( s -> pts == AV_NOPTS_VALUE ) { if ( buf -> pts != AV_NOPTS_VALUE ) { ret = write_to_fifo ( s -> fifo , buf ) ; if ( ret < 0 ) return ret ; if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { double first_pts = s -> start_time * AV_TIME_BASE ; first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , inlink -> time_base ) ; av_log ( ctx , AV_LOG_VERBOSE , "Set<S2SV_blank>first<S2SV_blank>pts<S2SV_blank>to<S2SV_blank>(in:%" PRId64 "<S2SV_blank>out:%" PRId64 ")\\n" , s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , outlink -> time_base ) ) ; } else { s -> first_pts = s -> pts = buf -> pts ; } } else { av_log ( ctx , AV_LOG_WARNING , "Discarding<S2SV_blank>initial<S2SV_blank>frame(s)<S2SV_blank>with<S2SV_blank>no<S2SV_blank>" "timestamp.\\n" ) ; av_frame_free ( & buf ) ; s -> drop ++ ; } return 0 ; } <S2SV_StartBug> if ( buf -> pts == AV_NOPTS_VALUE ) { <S2SV_EndBug> return write_to_fifo ( s -> fifo , buf ) ; } delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) ; if ( delta < 1 ) { AVFrame * tmp ; int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; av_log ( ctx , AV_LOG_DEBUG , "Dropping<S2SV_blank>%d<S2SV_blank>frame(s).\\n" , drop ) ; s -> drop += drop ; av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , tmp ) ; av_frame_free ( & buf ) ; return ret ; } for ( i = 0 ; i < delta ; i ++ ) { AVFrame * buf_out ; av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { AVFrame * dup = av_frame_clone ( buf_out ) ; av_log ( ctx , AV_LOG_DEBUG , "Duplicating<S2SV_blank>frame.\\n" ) ; if ( dup ) ret = write_to_fifo ( s -> fifo , dup ) ; else ret = AVERROR ( ENOMEM ) ; if ( ret < 0 ) { av_frame_free ( & buf_out ) ; av_frame_free ( & buf ) ; return ret ; } s -> dup ++ ; } buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out ; if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { av_frame_free ( & buf ) ; return ret ; } s -> frames_out ++ ; } flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , buf ) ; s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; return ret ; }
CWE-000 void receive_carbon ( void * * state ) { prof_input ( "/carbons<S2SV_blank>on" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( "<iq<S2SV_blank>id=\'*\'<S2SV_blank>type=\'set\'><enable<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'/></iq>" ) ) ; stbbr_send ( "<presence<S2SV_blank>to=\'stabber@localhost\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>" "<priority>10</priority>" "<status>On<S2SV_blank>my<S2SV_blank>mobile</status>" "</presence>" ) ; assert_true ( prof_output_exact ( "Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\"On<S2SV_blank>my<S2SV_blank>mobile\\"" ) ) ; prof_input ( "/msg<S2SV_blank>Buddy1" ) ; assert_true ( prof_output_exact ( "unencrypted" ) ) ; stbbr_send ( <S2SV_StartBug> "<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>" <S2SV_EndBug> "<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>" "<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>" "<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>" "<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>" "</message>" "</forwarded>" "</received>" "</message>" ) ; assert_true ( prof_output_regex ( "Buddy1/mobile:<S2SV_blank>.+test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient" ) ) ; }
CWE-125 static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { <S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ; pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ; for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ; rlvlno < pi -> picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
CWE-119 int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , <S2SV_StartBug> double correction_factor ) { <S2SV_EndBug> <S2SV_StartBug> const double q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> <S2SV_StartBug> int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ; <S2SV_EndBug> enumerator += ( int ) ( enumerator * q ) >> 12 ; <S2SV_StartBug> return ( int ) ( 0.5 + ( enumerator * correction_factor / q ) ) ; <S2SV_EndBug> }
CWE-20 static inline key_ref_t __key_update ( key_ref_t key_ref , struct key_preparsed_payload * prep ) { struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) goto error ; ret = - EEXIST ; if ( ! key -> type -> update ) goto error ; down_write ( & key -> sem ) ; ret = key -> type -> update ( key , prep ) ; if ( ret == 0 ) <S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> up_write ( & key -> sem ) ; if ( ret < 0 ) goto error ; out : return key_ref ; error : key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto out ; }
CWE-000 static noinline int btrfs_mksubvol ( struct path * parent , char * name , int namelen , struct btrfs_root * snap_src , u64 * async_transid , bool readonly , struct btrfs_qgroup_inherit * * inherit ) { struct inode * dir = parent -> dentry -> d_inode ; struct dentry * dentry ; int error ; mutex_lock_nested ( & dir -> i_mutex , I_MUTEX_PARENT ) ; dentry = lookup_one_len ( name , parent -> dentry , namelen ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) goto out_unlock ; error = - EEXIST ; if ( dentry -> d_inode ) goto out_dput ; error = btrfs_may_create ( dir , dentry ) ; if ( error ) goto out_dput ; <S2SV_StartBug> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <S2SV_EndBug> if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ; if ( snap_src ) { error = create_snapshot ( snap_src , dentry , name , namelen , async_transid , readonly , inherit ) ; } else { error = create_subvol ( BTRFS_I ( dir ) -> root , dentry , name , namelen , async_transid , inherit ) ; } if ( ! error ) fsnotify_mkdir ( dir , dentry ) ; out_up_read : up_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; out_dput : dput ( dentry ) ; out_unlock : mutex_unlock ( & dir -> i_mutex ) ; return error ; }
CWE-000 int xfs_attr3_leaf_clearflag ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr ; xfs_attr_leaf_name_local_t * name_loc ; int namelen ; char * name ; # endif trace_xfs_attr_leaf_clearflag ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return ( error ) ; leaf = bp -> b_addr ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( args -> index < ichdr . count ) ; ASSERT ( args -> index >= 0 ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; namelen = name_loc -> namelen ; name = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; namelen = name_rmt -> namelen ; name = ( char * ) name_rmt -> name ; } ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ; ASSERT ( namelen == args -> namelen ) ; ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ; # endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; if ( args -> rmtblkno ) { ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; <S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; } return xfs_trans_roll ( & args -> trans , args -> dp ) ; }
CWE-416 static long do_get_mempolicy ( int * policy , nodemask_t * nmask , unsigned long addr , unsigned long flags ) { int err ; struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = NULL ; struct mempolicy * pol = current -> mempolicy ; if ( flags & ~ ( unsigned long ) ( MPOL_F_NODE | MPOL_F_ADDR | MPOL_F_MEMS_ALLOWED ) ) return - EINVAL ; if ( flags & MPOL_F_MEMS_ALLOWED ) { if ( flags & ( MPOL_F_NODE | MPOL_F_ADDR ) ) return - EINVAL ; * policy = 0 ; task_lock ( current ) ; * nmask = cpuset_current_mems_allowed ; task_unlock ( current ) ; return 0 ; } if ( flags & MPOL_F_ADDR ) { down_read ( & mm -> mmap_sem ) ; vma = find_vma_intersection ( mm , addr , addr + 1 ) ; if ( ! vma ) { up_read ( & mm -> mmap_sem ) ; return - EFAULT ; } if ( vma -> vm_ops && vma -> vm_ops -> get_policy ) pol = vma -> vm_ops -> get_policy ( vma , addr ) ; else pol = vma -> vm_policy ; } else if ( addr ) return - EINVAL ; if ( ! pol ) pol = & default_policy ; if ( flags & MPOL_F_NODE ) { if ( flags & MPOL_F_ADDR ) { err = lookup_node ( addr ) ; if ( err < 0 ) goto out ; * policy = err ; } else if ( pol == current -> mempolicy && pol -> mode == MPOL_INTERLEAVE ) { * policy = next_node_in ( current -> il_prev , pol -> v . nodes ) ; } else { err = - EINVAL ; goto out ; } } else { * policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ; * policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ; } <S2SV_StartBug> if ( vma ) { <S2SV_EndBug> up_read ( & current -> mm -> mmap_sem ) ; vma = NULL ; } err = 0 ; if ( nmask ) { if ( mpol_store_user_nodemask ( pol ) ) { * nmask = pol -> w . user_nodemask ; } else { task_lock ( current ) ; get_policy_nodemask ( pol , nmask ) ; task_unlock ( current ) ; } } out : mpol_cond_put ( pol ) ; if ( vma ) up_read ( & current -> mm -> mmap_sem ) ; return err ; }
CWE-787 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; int iskew = imagew - tilew ; uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <S2SV_StartBug> for ( col = 0 ; col < imagewidth ; col += tw ) { <S2SV_EndBug> if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%lu<S2SV_blank>%lu" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }
CWE-416 static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }
CWE-362 static int snd_ctl_elem_user_get ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { struct user_element * ue = kcontrol -> private_data ; <S2SV_StartBug> memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-415 void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
CWE-000 int xfs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error = 0 ; if ( ! acl ) goto set_acl ; error = - E2BIG ; if ( acl -> a_count > XFS_ACL_MAX_ENTRIES ( XFS_M ( inode -> i_sb ) ) ) return error ; if ( type == ACL_TYPE_ACCESS ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error <= 0 ) { <S2SV_EndBug> acl = NULL ; if ( error < 0 ) return error ; <S2SV_StartBug> } <S2SV_EndBug> error = xfs_set_mode ( inode , mode ) ; if ( error ) return error ; } set_acl : return __xfs_set_acl ( inode , type , acl ) ; }
CWE-399 int dev_forward_skb ( struct net_device * dev , struct sk_buff * skb ) { skb_orphan ( skb ) ; <S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> return NET_RX_DROP ; <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug> skb_set_dev ( skb , dev ) ; skb -> tstamp . tv64 = 0 ; skb -> pkt_type = PACKET_HOST ; skb -> protocol = eth_type_trans ( skb , dev ) ; return netif_rx ( skb ) ; }
CWE-190 SQLITE_PRIVATE void * sqlite3ArrayAllocate ( sqlite3 * db , void * pArray , int szEntry , int * pnEntry , int * pIdx ) { char * z ; <S2SV_StartBug> int n = * pnEntry ; <S2SV_EndBug> if ( ( n & ( n - 1 ) ) == 0 ) { <S2SV_StartBug> int sz = ( n == 0 ) ? 1 : 2 * n ; <S2SV_EndBug> void * pNew = sqlite3DbRealloc ( db , pArray , sz * szEntry ) ; if ( pNew == 0 ) { * pIdx = - 1 ; return pArray ; } pArray = pNew ; } z = ( char * ) pArray ; memset ( & z [ n * szEntry ] , 0 , szEntry ) ; * pIdx = n ; ++ * pnEntry ; return pArray ; }
CWE-190 int jas_stream_gobble ( jas_stream_t * stream , int n ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_getc ( stream ) == EOF ) { return n - m ; } } return n ; }
CWE-119 static int xlate_to_uni ( const unsigned char * name , int len , unsigned char * outname , int * longlen , int * outlen , int escape , int utf8 , struct nls_table * nls ) { const unsigned char * ip ; unsigned char nc ; unsigned char * op ; unsigned int ec ; int i , k , fill ; int charlen ; if ( utf8 ) { <S2SV_StartBug> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <S2SV_EndBug> if ( * outlen < 0 ) return * outlen ; else if ( * outlen > FAT_LFN_LEN ) return - ENAMETOOLONG ; op = & outname [ * outlen * sizeof ( wchar_t ) ] ; } else { if ( nls ) { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; * outlen += 1 ) { if ( escape && ( * ip == ':' ) ) { if ( i > len - 5 ) return - EINVAL ; ec = 0 ; for ( k = 1 ; k < 5 ; k ++ ) { nc = ip [ k ] ; ec <<= 4 ; if ( nc >= '0' && nc <= '9' ) { ec |= nc - '0' ; continue ; } if ( nc >= 'a' && nc <= 'f' ) { ec |= nc - ( 'a' - 10 ) ; continue ; } if ( nc >= 'A' && nc <= 'F' ) { ec |= nc - ( 'A' - 10 ) ; continue ; } return - EINVAL ; } * op ++ = ec & 0xFF ; * op ++ = ec >> 8 ; ip += 5 ; i += 5 ; } else { if ( ( charlen = nls -> char2uni ( ip , len - i , ( wchar_t * ) op ) ) < 0 ) return - EINVAL ; ip += charlen ; i += charlen ; op += 2 ; } } if ( i < len ) return - ENAMETOOLONG ; } else { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; i ++ , * outlen += 1 ) { * op ++ = * ip ++ ; * op ++ = 0 ; } if ( i < len ) return - ENAMETOOLONG ; } } * longlen = * outlen ; if ( * outlen % 13 ) { * op ++ = 0 ; * op ++ = 0 ; * outlen += 1 ; if ( * outlen % 13 ) { fill = 13 - ( * outlen % 13 ) ; for ( i = 0 ; i < fill ; i ++ ) { * op ++ = 0xff ; * op ++ = 0xff ; } * outlen += fill ; } } return 0 ; }
CWE-119 <S2SV_StartBug> static void count_segs ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) { <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int segment_id ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_StartBug> xd -> mi = mi_8x8 ; <S2SV_EndBug> segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ; set_mi_row_col ( xd , tile , mi_row , bh , mi_col , bw , cm -> mi_rows , cm -> mi_cols ) ; no_pred_segcounts [ segment_id ] ++ ; if ( cm -> frame_type != KEY_FRAME ) { <S2SV_StartBug> const BLOCK_SIZE bsize = mi_8x8 [ 0 ] -> mbmi . sb_type ; <S2SV_EndBug> <S2SV_StartBug> const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <S2SV_EndBug> bsize , mi_row , mi_col ) ; const int pred_flag = pred_segment_id == segment_id ; const int pred_context = vp9_get_pred_context_seg_id ( xd ) ; xd -> mi [ 0 ] -> mbmi . seg_id_predicted = pred_flag ; temporal_predictor_count [ pred_context ] [ pred_flag ] ++ ; if ( ! pred_flag ) t_unpred_seg_counts [ segment_id ] ++ ; } }
CWE-000 static int einj_error_inject ( u32 type , u32 flags , u64 param1 , u64 param2 , u64 param3 , u64 param4 ) { int rc ; <S2SV_StartBug> u64 base_addr , size ; <S2SV_EndBug> if ( flags && ( flags & ~ ( SETWA_FLAGS_APICID | SETWA_FLAGS_MEM | SETWA_FLAGS_PCIE_SBDF ) ) ) return - EINVAL ; if ( ! ( param_extension || acpi5 ) ) goto inject ; if ( type & ACPI5_VENDOR_BIT ) { if ( vendor_flags != SETWA_FLAGS_MEM ) goto inject ; } else if ( ! ( type & MEM_ERROR_MASK ) && ! ( flags & SETWA_FLAGS_MEM ) ) goto inject ; base_addr = param1 & param2 ; size = ~ param2 + 1 ; if ( ( ( param2 & PAGE_MASK ) != PAGE_MASK ) || ( ( region_intersects ( base_addr , size , IORESOURCE_SYSTEM_RAM , IORES_DESC_NONE ) != REGION_INTERSECTS ) && ( region_intersects ( base_addr , size , IORESOURCE_MEM , IORES_DESC_PERSISTENT_MEMORY ) != REGION_INTERSECTS ) ) ) return - EINVAL ; inject : mutex_lock ( & einj_mutex ) ; rc = __einj_error_inject ( type , flags , param1 , param2 , param3 , param4 ) ; mutex_unlock ( & einj_mutex ) ; return rc ; }
CWE-119 static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( "KVP:<S2SV_blank>Transaction<S2SV_blank>not<S2SV_blank>active\\n" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == NULL ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = HV_E_FAIL ; goto response_done ; } <S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = REG_SZ ; icmsghdrp -> status = HV_S_OK ; response_done : icmsghdrp -> icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE ; vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , VM_PKT_DATA_INBAND , 0 ) ; }
CWE-264 long arch_ptrace ( struct task_struct * child , long request , unsigned long addr , unsigned long data ) { int ret ; unsigned long __user * datap = ( unsigned long __user * ) data ; switch ( request ) { case PTRACE_PEEKUSR : ret = ptrace_read_user ( child , addr , datap ) ; break ; case PTRACE_POKEUSR : ret = ptrace_write_user ( child , addr , data ) ; break ; case PTRACE_GETREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_SETREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_GETFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; case PTRACE_SETFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; # ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS : ret = ptrace_getwmmxregs ( child , datap ) ; break ; case PTRACE_SETWMMXREGS : ret = ptrace_setwmmxregs ( child , datap ) ; break ; # endif case PTRACE_GET_THREAD_AREA : <S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> datap ) ; break ; case PTRACE_SET_SYSCALL : task_thread_info ( child ) -> syscall = data ; ret = 0 ; break ; # ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS : ret = ptrace_getcrunchregs ( child , datap ) ; break ; case PTRACE_SETCRUNCHREGS : ret = ptrace_setcrunchregs ( child , datap ) ; break ; # endif # ifdef CONFIG_VFP case PTRACE_GETVFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; case PTRACE_SETVFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; # endif # ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_gethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; case PTRACE_SETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_sethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; # endif default : ret = ptrace_request ( child , request , addr , data ) ; break ; } return ret ; }
CWE-125 int rt6_print ( netdissect_options * ndo , register const u_char * bp , const u_char * bp2 _U_ ) { register const struct ip6_rthdr * dp ; register const struct ip6_rthdr0 * dp0 ; register const u_char * ep ; int i , len ; register const struct in6_addr * addr ; dp = ( const struct ip6_rthdr * ) bp ; <S2SV_StartBug> len = dp -> ip6r_len ; <S2SV_EndBug> ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; ND_PRINT ( ( ndo , "srcrt<S2SV_blank>(len=%d" , dp -> ip6r_len ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>type=%d" , dp -> ip6r_type ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>segleft=%d" , dp -> ip6r_segleft ) ) ; switch ( dp -> ip6r_type ) { case IPV6_RTHDR_TYPE_0 : case IPV6_RTHDR_TYPE_2 : dp0 = ( const struct ip6_rthdr0 * ) dp ; ND_TCHECK ( dp0 -> ip6r0_reserved ) ; if ( dp0 -> ip6r0_reserved || ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ",<S2SV_blank>rsv=0x%0x" , EXTRACT_32BITS ( & dp0 -> ip6r0_reserved ) ) ) ; } if ( len % 2 == 1 ) goto trunc ; len >>= 1 ; addr = & dp0 -> ip6r0_addr [ 0 ] ; for ( i = 0 ; i < len ; i ++ ) { if ( ( const u_char * ) ( addr + 1 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>[%d]%s" , i , ip6addr_string ( ndo , addr ) ) ) ; addr ++ ; } ND_PRINT ( ( ndo , ")<S2SV_blank>" ) ) ; return ( ( dp0 -> ip6r0_len + 1 ) << 3 ) ; break ; default : goto trunc ; break ; } trunc : ND_PRINT ( ( ndo , "[|srcrt]" ) ) ; return - 1 ; }
CWE-000 static int mwifiex_update_vs_ie ( const u8 * ies , int ies_len , struct mwifiex_ie * * ie_ptr , u16 mask , unsigned int oui , u8 oui_type ) { struct ieee_types_header * vs_ie ; struct mwifiex_ie * ie = * ie_ptr ; const u8 * vendor_ie ; vendor_ie = cfg80211_find_vendor_ie ( oui , oui_type , ies , ies_len ) ; if ( vendor_ie ) { if ( ! * ie_ptr ) { * ie_ptr = kzalloc ( sizeof ( struct mwifiex_ie ) , GFP_KERNEL ) ; if ( ! * ie_ptr ) return - ENOMEM ; ie = * ie_ptr ; } vs_ie = ( struct ieee_types_header * ) vendor_ie ; <S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug> vs_ie , vs_ie -> len + 2 ) ; le16_unaligned_add_cpu ( & ie -> ie_length , vs_ie -> len + 2 ) ; ie -> mgmt_subtype_mask = cpu_to_le16 ( mask ) ; ie -> ie_index = cpu_to_le16 ( MWIFIEX_AUTO_IDX_MASK ) ; } * ie_ptr = ie ; return 0 ; }
CWE-416 void comps_objrtree_unite ( COMPS_ObjRTree * rt1 , COMPS_ObjRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data != NULL ) { comps_objrtree_set ( rt1 , pair -> key , ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-119 static int read_private_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; const sc_acl_entry_t * e ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( "I0012" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>select<S2SV_blank>private<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n" , sc_strerror ( r ) ) ; return 2 ; } e = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; if ( e == NULL || e -> method == SC_AC_NEVER ) return 10 ; <S2SV_StartBug> bufsize = file -> size ; <S2SV_EndBug> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>private<S2SV_blank>key<S2SV_blank>file:<S2SV_blank>%s\\n" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( "Key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found.\\n" , opt_key_num ) ; return 2 ; } return parse_private_key ( p , keysize , rsa ) ; }
CWE-399 static int ovl_copy_up_locked ( struct dentry * workdir , struct dentry * upperdir , struct dentry * dentry , struct path * lowerpath , struct kstat * stat , struct iattr * attr , const char * link ) { struct inode * wdir = workdir -> d_inode ; struct inode * udir = upperdir -> d_inode ; struct dentry * newdentry = NULL ; struct dentry * upper = NULL ; umode_t mode = stat -> mode ; int err ; newdentry = ovl_lookup_temp ( workdir , dentry ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out1 ; stat -> mode &= S_IFMT ; err = ovl_create_real ( wdir , newdentry , stat , link , NULL , true ) ; stat -> mode = mode ; if ( err ) goto out2 ; if ( S_ISREG ( stat -> mode ) ) { struct path upperpath ; ovl_path_upper ( dentry , & upperpath ) ; BUG_ON ( upperpath . dentry != NULL ) ; upperpath . dentry = newdentry ; err = ovl_copy_up_data ( lowerpath , & upperpath , stat -> size ) ; if ( err ) goto out_cleanup ; } err = ovl_copy_xattr ( lowerpath -> dentry , newdentry ) ; if ( err ) goto out_cleanup ; mutex_lock ( & newdentry -> d_inode -> i_mutex ) ; err = ovl_set_attr ( newdentry , stat ) ; if ( ! err && attr ) err = notify_change ( newdentry , attr , NULL ) ; mutex_unlock ( & newdentry -> d_inode -> i_mutex ) ; if ( err ) goto out_cleanup ; err = ovl_do_rename ( wdir , newdentry , udir , upper , 0 ) ; if ( err ) goto out_cleanup ; ovl_dentry_update ( dentry , newdentry ) ; newdentry = NULL ; if ( ! S_ISDIR ( stat -> mode ) ) ovl_dentry_set_opaque ( dentry , true ) ; out2 : dput ( upper ) ; out1 : dput ( newdentry ) ; out : return err ; out_cleanup : ovl_cleanup ( wdir , newdentry ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> }
CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = "" ; const char * link_section_name = "" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , "section_name" , section_name , 0 ) ; sdb_num_set ( sdb , "entries" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , "idx" , i , 0 ) ; sdb_num_set ( sdb_verdef , "vd_version" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , "vd_ndx" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , "vd_cnt" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , "flags" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , "idx" , isum , 0 ) ; sdb_num_set ( sdb_parent , "parent" , j , 0 ) ; sdb_set ( sdb_parent , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , "parent%d" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , "verdef%d" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
CWE-189 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; <S2SV_StartBug> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <S2SV_EndBug> <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; ue -> card = card ; ue -> info = * info ; ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }
CWE-476 static int bmp_getint32 ( jas_stream_t * in , int_fast32_t * val ) { int n ; uint_fast32_t v ; int c ; for ( n = 4 , v = 0 ; ; ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } <S2SV_StartBug> v |= ( c << 24 ) ; <S2SV_EndBug> if ( -- n <= 0 ) { break ; } v >>= 8 ; } if ( val ) { * val = v ; } return 0 ; }
CWE-476 RCMS * r_pkcs7_parse_cms ( const ut8 * buffer , ut32 length ) { RASN1Object * object ; RCMS * container ; if ( ! buffer || ! length ) { return NULL ; } container = R_NEW0 ( RCMS ) ; if ( ! container ) { return NULL ; } object = r_asn1_create_object ( buffer , length ) ; <S2SV_StartBug> if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) { <S2SV_EndBug> r_asn1_free_object ( object ) ; free ( container ) ; return NULL ; } container -> contentType = r_asn1_stringify_oid ( object -> list . objects [ 0 ] -> sector , object -> list . objects [ 0 ] -> length ) ; r_pkcs7_parse_signeddata ( & container -> signedData , object -> list . objects [ 1 ] -> list . objects [ 0 ] ) ; r_asn1_free_object ( object ) ; return container ; }
CWE-119 static void Np_toString ( js_State * J ) { <S2SV_StartBug> char buf [ 32 ] ; <S2SV_EndBug> js_Object * self = js_toobject ( J , 0 ) ; int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; if ( self -> type != JS_CNUMBER ) js_typeerror ( J , "not<S2SV_blank>a<S2SV_blank>number" ) ; if ( radix == 10 ) { js_pushstring ( J , jsV_numbertostring ( J , buf , self -> u . number ) ) ; return ; } if ( radix < 2 || radix > 36 ) js_rangeerror ( J , "invalid<S2SV_blank>radix" ) ; { static const char digits [ ] = "0123456789abcdefghijklmnopqrstuvwxyz" ; <S2SV_StartBug> char buf [ 100 ] ; <S2SV_EndBug> double number = self -> u . number ; int sign = self -> u . number < 0 ; js_Buffer * sb = NULL ; uint64_t u , limit = ( ( uint64_t ) 1 << 52 ) ; int ndigits , exp , point ; if ( number == 0 ) { js_pushstring ( J , "0" ) ; return ; } if ( isnan ( number ) ) { js_pushstring ( J , "NaN" ) ; return ; } if ( isinf ( number ) ) { js_pushstring ( J , sign ? "-Infinity" : "Infinity" ) ; return ; } if ( sign ) number = - number ; exp = 0 ; while ( number * pow ( radix , exp ) > limit ) -- exp ; while ( number * pow ( radix , exp + 1 ) < limit ) ++ exp ; u = number * pow ( radix , exp ) + 0.5 ; while ( u > 0 && ( u % radix ) == 0 ) { u /= radix ; -- exp ; } ndigits = 0 ; while ( u > 0 ) { buf [ ndigits ++ ] = digits [ u % radix ] ; u /= radix ; } point = ndigits - exp ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } if ( sign ) js_putc ( J , & sb , '-' ) ; if ( point <= 0 ) { js_putc ( J , & sb , '0' ) ; js_putc ( J , & sb , '.' ) ; while ( point ++ < 0 ) js_putc ( J , & sb , '0' ) ; while ( ndigits -- > 0 ) js_putc ( J , & sb , buf [ ndigits ] ) ; } else { while ( ndigits -- > 0 ) { js_putc ( J , & sb , buf [ ndigits ] ) ; if ( -- point == 0 && ndigits > 0 ) js_putc ( J , & sb , '.' ) ; } while ( point -- > 0 ) js_putc ( J , & sb , '0' ) ; } js_putc ( J , & sb , 0 ) ; js_pushstring ( J , sb -> s ) ; js_endtry ( J ) ; js_free ( J , sb ) ; } }
CWE-119 <S2SV_StartBug> int file_is_raw ( struct VpxInputContext * input ) { <S2SV_EndBug> uint8_t buf [ 32 ] ; int is_raw = 0 ; vpx_codec_stream_info_t si ; si . sz = sizeof ( si ) ; if ( fread ( buf , 1 , 32 , input -> file ) == 32 ) { int i ; if ( mem_get_le32 ( buf ) < 256 * 1024 * 1024 ) { for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; <S2SV_StartBug> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <S2SV_EndBug> buf + 4 , 32 - 4 , & si ) ) { is_raw = 1 ; input -> fourcc = decoder -> fourcc ; input -> width = si . w ; input -> height = si . h ; input -> framerate . numerator = 30 ; input -> framerate . denominator = 1 ; break ; } } } } rewind ( input -> file ) ; return is_raw ; }
CWE-284 static void * sock_poll_thread ( void * arg ) { struct pollfd pfds [ MAX_POLL ] ; memset ( pfds , 0 , sizeof ( pfds ) ) ; int h = ( intptr_t ) arg ; for ( ; ; ) { prepare_poll_fds ( h , pfds ) ; <S2SV_StartBug> int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; <S2SV_EndBug> if ( ret == - 1 ) { APPL_TRACE_ERROR ( "poll<S2SV_blank>ret<S2SV_blank>-1,<S2SV_blank>exit<S2SV_blank>the<S2SV_blank>thread,<S2SV_blank>errno:%d,<S2SV_blank>err:%s" , errno , strerror ( errno ) ) ; break ; } if ( ret != 0 ) { int need_process_data_fd = TRUE ; if ( pfds [ 0 ] . revents ) { asrt ( pfds [ 0 ] . fd == ts [ h ] . cmd_fdr ) ; if ( ! process_cmd_sock ( h ) ) { APPL_TRACE_DEBUG ( "h:%d,<S2SV_blank>process_cmd_sock<S2SV_blank>return<S2SV_blank>false,<S2SV_blank>exit..." , h ) ; break ; } if ( ret == 1 ) need_process_data_fd = FALSE ; else ret -- ; } if ( need_process_data_fd ) process_data_sock ( h , pfds , ret ) ; } else { APPL_TRACE_DEBUG ( "no<S2SV_blank>data,<S2SV_blank>select<S2SV_blank>ret:<S2SV_blank>%d" , ret ) } ; } ts [ h ] . thread_id = - 1 ; APPL_TRACE_DEBUG ( "socket<S2SV_blank>poll<S2SV_blank>thread<S2SV_blank>exiting,<S2SV_blank>h:%d" , h ) ; return 0 ; }
CWE-000 static void unix_release_sock ( struct sock * sk , int embrion ) { struct unix_sock * u = unix_sk ( sk ) ; struct path path ; struct sock * skpair ; struct sk_buff * skb ; int state ; unix_remove_socket ( sk ) ; unix_state_lock ( sk ) ; sock_orphan ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; path = u -> path ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; state = sk -> sk_state ; sk -> sk_state = TCP_CLOSE ; unix_state_unlock ( sk ) ; wake_up_interruptible_all ( & u -> peer_wait ) ; skpair = unix_peer ( sk ) ; if ( skpair != NULL ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_SEQPACKET ) { unix_state_lock ( skpair ) ; skpair -> sk_shutdown = SHUTDOWN_MASK ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) skpair -> sk_err = ECONNRESET ; unix_state_unlock ( skpair ) ; skpair -> sk_state_change ( skpair ) ; sk_wake_async ( skpair , SOCK_WAKE_WAITD , POLL_HUP ) ; } <S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> unix_peer ( sk ) = NULL ; } while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != NULL ) { if ( state == TCP_LISTEN ) unix_release_sock ( skb -> sk , 1 ) ; UNIXCB ( skb ) . consumed = skb -> len ; kfree_skb ( skb ) ; } if ( path . dentry ) path_put ( & path ) ; sock_put ( sk ) ; if ( unix_tot_inflight ) unix_gc ( ) ; }
CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }
CWE-416 static ssize_t userfaultfd_ctx_read ( struct userfaultfd_ctx * ctx , int no_wait , struct uffd_msg * msg ) { ssize_t ret ; DECLARE_WAITQUEUE ( wait , current ) ; struct userfaultfd_wait_queue * uwq ; LIST_HEAD ( fork_event ) ; struct userfaultfd_ctx * fork_nctx = NULL ; spin_lock ( & ctx -> fd_wqh . lock ) ; __add_wait_queue ( & ctx -> fd_wqh , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; spin_lock ( & ctx -> fault_pending_wqh . lock ) ; uwq = find_userfault ( ctx ) ; if ( uwq ) { write_seqcount_begin ( & ctx -> refile_seq ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> fault_wqh , & uwq -> wq ) ; write_seqcount_end ( & ctx -> refile_seq ) ; * msg = uwq -> msg ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; spin_lock ( & ctx -> event_wqh . lock ) ; uwq = find_userfault_evt ( ctx ) ; if ( uwq ) { * msg = uwq -> msg ; if ( uwq -> msg . event == UFFD_EVENT_FORK ) { fork_nctx = ( struct userfaultfd_ctx * ) ( unsigned long ) uwq -> msg . arg . reserved . reserved1 ; list_move ( & uwq -> wq . entry , & fork_event ) ; <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ret = 0 ; break ; } userfaultfd_event_complete ( ctx , uwq ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; if ( signal_pending ( current ) ) { ret = - ERESTARTSYS ; break ; } if ( no_wait ) { ret = - EAGAIN ; break ; } spin_unlock ( & ctx -> fd_wqh . lock ) ; schedule ( ) ; spin_lock ( & ctx -> fd_wqh . lock ) ; } __remove_wait_queue ( & ctx -> fd_wqh , & wait ) ; __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> fd_wqh . lock ) ; if ( ! ret && msg -> event == UFFD_EVENT_FORK ) { ret = resolve_userfault_fork ( ctx , fork_nctx , msg ) ; <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> spin_lock ( & ctx -> event_wqh . lock ) ; if ( ! list_empty ( & fork_event ) ) { <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> typeof ( * uwq ) , wq . entry ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> event_wqh , & uwq -> wq ) ; <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> } <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> } } return ret ; }
CWE-119 date PGTYPESdate_from_asc ( char * str , char * * endptr ) { date dDate ; fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; <S2SV_StartBug> char lowstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; bool EuroDates = FALSE ; errno = 0 ; <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> { errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , EuroDates ) != 0 ) { errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ; } switch ( dtype ) { case DTK_DATE : break ; case DTK_EPOCH : if ( GetEpochTime ( tm ) < 0 ) { errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ; } break ; default : errno = PGTYPES_DATE_BAD_DATE ; return INT_MIN ; } dDate = ( date2j ( tm -> tm_year , tm -> tm_mon , tm -> tm_mday ) - date2j ( 2000 , 1 , 1 ) ) ; return dDate ; }
CWE-119 void vp9_init_second_pass_spatial_svc ( VP9_COMP * cpi ) { SVC * const svc = & cpi -> svc ; int i ; for ( i = 0 ; i < svc -> number_spatial_layers ; ++ i ) { <S2SV_StartBug> struct twopass_rc * const twopass = & svc -> layer_context [ i ] . twopass ; <S2SV_EndBug> svc -> spatial_layer_id = i ; vp9_init_second_pass ( cpi ) ; twopass -> total_stats . spatial_layer_id = i ; twopass -> total_left_stats . spatial_layer_id = i ; } svc -> spatial_layer_id = 0 ; }
CWE-000 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { "invalid" , "rsasig" , "shared-secret" , "dsssig" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>method=%s" , len - 4 , <S2SV_EndBug> STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; <S2SV_StartBug> if ( 1 < ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>authdata=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , ")<S2SV_blank>" ) ) ; <S2SV_StartBug> } else if ( ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } <S2SV_StartBug> return ( const u_char * ) ext + len ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( tpay ) ) ) ; return NULL ; }
CWE-415 struct sock * inet_csk_clone_lock ( const struct sock * sk , const struct request_sock * req , const gfp_t priority ) { struct sock * newsk = sk_clone_lock ( sk , priority ) ; if ( newsk ) { struct inet_connection_sock * newicsk = inet_csk ( newsk ) ; newsk -> sk_state = TCP_SYN_RECV ; newicsk -> icsk_bind_hash = NULL ; inet_sk ( newsk ) -> inet_dport = inet_rsk ( req ) -> ir_rmt_port ; inet_sk ( newsk ) -> inet_num = inet_rsk ( req ) -> ir_num ; inet_sk ( newsk ) -> inet_sport = htons ( inet_rsk ( req ) -> ir_num ) ; newsk -> sk_write_space = sk_stream_write_space ; sock_reset_flag ( newsk , SOCK_RCU_FREE ) ; <S2SV_StartBug> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <S2SV_EndBug> atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ; newicsk -> icsk_retransmits = 0 ; newicsk -> icsk_backoff = 0 ; newicsk -> icsk_probes_out = 0 ; memset ( & newicsk -> icsk_accept_queue , 0 , sizeof ( newicsk -> icsk_accept_queue ) ) ; security_inet_csk_clone ( newsk , req ) ; } return newsk ; }
CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , "%i" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
CWE-000 static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; <S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }
CWE-20 int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; <S2SV_StartBug> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , <S2SV_EndBug> open_list ) { <S2SV_StartBug> spin_lock_irq ( & slave_active_lock ) ; <S2SV_EndBug> _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> mutex_unlock ( & register_mutex ) ; } out : if ( timeri -> private_free ) timeri -> private_free ( timeri ) ; kfree ( timeri -> owner ) ; kfree ( timeri ) ; if ( timer ) module_put ( timer -> module ) ; return 0 ; }
CWE-125 void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
CWE-20 static void ikev2_parent_inR1outI2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( "ikev2<S2SV_blank>parent<S2SV_blank>inR1outI2:<S2SV_blank>calculating<S2SV_blank>g^{xy},<S2SV_blank>sending<S2SV_blank>I2" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , "%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inR1outI2_tail ( pcrc , r ) ; if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
CWE-119 int nfssvc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_writeargs * args ) { unsigned int len , hdr , dlen ; struct kvec * head = rqstp -> rq_arg . head ; int v ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p ++ ; args -> offset = ntohl ( * p ++ ) ; p ++ ; len = args -> len = ntohl ( * p ++ ) ; if ( len > NFSSVC_MAXBLKSIZE_V2 ) return 0 ; <S2SV_StartBug> hdr = ( void * ) p - head -> iov_base ; <S2SV_EndBug> dlen = head -> iov_len + rqstp -> rq_arg . page_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }
CWE-119 private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , "Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document" ) == - 1 ) return - 1 ; if ( file_printf ( ms , ",<S2SV_blank>%s<S2SV_blank>Endian" , si . si_byte_order == 0xfffe ? "Little" : "Big" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , ",<S2SV_blank>Os:<S2SV_blank>Windows,<S2SV_blank>Version<S2SV_blank>%d.%d" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , ",<S2SV_blank>Os:<S2SV_blank>MacOS,<S2SV_blank>Version<S2SV_blank>%d.%d" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , ",<S2SV_blank>Os<S2SV_blank>%d,<S2SV_blank>Version:<S2SV_blank>%d.%d" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> if ( str ) if ( file_printf ( ms , ",<S2SV_blank>%s" , str ) == - 1 ) <S2SV_StartBug> return - 2 ; <S2SV_EndBug> } <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> free ( info ) ; return m == - 1 ? - 2 : m ; }
CWE-190 static uint8_t * extend_raw_data ( LHAFileHeader * * header , LHAInputStream * stream , size_t nbytes ) { LHAFileHeader * new_header ; size_t new_raw_len ; <S2SV_StartBug> uint8_t * result ; <S2SV_EndBug> new_raw_len = RAW_DATA_LEN ( header ) + nbytes ; new_header = realloc ( * header , sizeof ( LHAFileHeader ) + new_raw_len ) ; if ( new_header == NULL ) { return NULL ; } * header = new_header ; new_header -> raw_data = ( uint8_t * ) ( new_header + 1 ) ; result = new_header -> raw_data + new_header -> raw_data_len ; if ( ! lha_input_stream_read ( stream , result , nbytes ) ) { return NULL ; } new_header -> raw_data_len = new_raw_len ; return result ; }
CWE-000 <S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> { struct key * keyring ; int bucket ; if ( ! name ) return ERR_PTR ( - EINVAL ) ; bucket = keyring_hash ( name ) ; read_lock ( & keyring_name_lock ) ; if ( keyring_name_hash [ bucket ] . next ) { list_for_each_entry ( keyring , & keyring_name_hash [ bucket ] , name_link ) { if ( ! kuid_has_mapping ( current_user_ns ( ) , keyring -> user -> uid ) ) continue ; if ( test_bit ( KEY_FLAG_REVOKED , & keyring -> flags ) ) continue ; if ( strcmp ( keyring -> description , name ) != 0 ) continue ; <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> key_permission ( make_key_ref ( keyring , 0 ) , KEY_NEED_SEARCH ) < 0 ) <S2SV_StartBug> continue ; <S2SV_EndBug> if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ; keyring -> last_used_at = current_kernel_time ( ) . tv_sec ; goto out ; } } keyring = ERR_PTR ( - ENOKEY ) ; out : read_unlock ( & keyring_name_lock ) ; return keyring ; }
CWE-119 static void test_show_object ( struct object * object , <S2SV_StartBug> struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap_test_data * tdata = data ; int bitmap_pos ; bitmap_pos = bitmap_position ( object -> oid . hash ) ; if ( bitmap_pos < 0 ) die ( "Object<S2SV_blank>not<S2SV_blank>in<S2SV_blank>bitmap:<S2SV_blank>%s\\n" , oid_to_hex ( & object -> oid ) ) ; bitmap_set ( tdata -> base , bitmap_pos ) ; display_progress ( tdata -> prg , ++ tdata -> seen ) ; }
CWE-125 void mpls_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const u_char * p ; uint32_t label_entry ; uint16_t label_stack_depth = 0 ; enum mpls_packet_type pt = PT_UNKNOWN ; p = bp ; ND_PRINT ( ( ndo , "MPLS" ) ) ; do { ND_TCHECK2 ( * p , sizeof ( label_entry ) ) ; if ( length < sizeof ( label_entry ) ) { ND_PRINT ( ( ndo , "[|MPLS],<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; return ; } label_entry = EXTRACT_32BITS ( p ) ; ND_PRINT ( ( ndo , "%s(label<S2SV_blank>%u" , ( label_stack_depth && ndo -> ndo_vflag ) ? "\\n\\t" : "<S2SV_blank>" , MPLS_LABEL ( label_entry ) ) ) ; label_stack_depth ++ ; if ( ndo -> ndo_vflag && MPLS_LABEL ( label_entry ) < sizeof ( mpls_labelname ) / sizeof ( mpls_labelname [ 0 ] ) ) ND_PRINT ( ( ndo , "<S2SV_blank>(%s)" , mpls_labelname [ MPLS_LABEL ( label_entry ) ] ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>exp<S2SV_blank>%u" , MPLS_EXP ( label_entry ) ) ) ; if ( MPLS_STACK ( label_entry ) ) ND_PRINT ( ( ndo , ",<S2SV_blank>[S]" ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>ttl<S2SV_blank>%u)" , MPLS_TTL ( label_entry ) ) ) ; p += sizeof ( label_entry ) ; length -= sizeof ( label_entry ) ; } while ( ! MPLS_STACK ( label_entry ) ) ; switch ( MPLS_LABEL ( label_entry ) ) { case 0 : case 3 : pt = PT_IPV4 ; break ; case 2 : pt = PT_IPV6 ; break ; default : ND_TCHECK ( * p ) ; if ( length < 1 ) { return ; } switch ( * p ) { case 0x45 : case 0x46 : case 0x47 : case 0x48 : case 0x49 : case 0x4a : case 0x4b : case 0x4c : case 0x4d : case 0x4e : case 0x4f : pt = PT_IPV4 ; break ; case 0x60 : case 0x61 : case 0x62 : case 0x63 : case 0x64 : case 0x65 : case 0x66 : case 0x67 : case 0x68 : case 0x69 : case 0x6a : case 0x6b : case 0x6c : case 0x6d : case 0x6e : case 0x6f : pt = PT_IPV6 ; break ; case 0x81 : case 0x82 : case 0x83 : pt = PT_OSI ; break ; default : break ; } } if ( pt == PT_UNKNOWN ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , length ) ; return ; } ND_PRINT ( ( ndo , ndo -> ndo_vflag ? "\\n\\t" : "<S2SV_blank>" ) ) ; switch ( pt ) { case PT_IPV4 : ip_print ( ndo , p , length ) ; break ; case PT_IPV6 : ip6_print ( ndo , p , length ) ; break ; case PT_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , "[|MPLS]" ) ) ; }
CWE-000 struct bpf_prog * bpf_prog_get ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_prog * prog ; prog = __bpf_prog_get ( f ) ; if ( IS_ERR ( prog ) ) return prog ; <S2SV_StartBug> atomic_inc ( & prog -> aux -> refcnt ) ; <S2SV_EndBug> fdput ( f ) ; return prog ; }
CWE-415 int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , GFP_KERNEL ) ; if ( ! new_blkg ) return - ENOMEM ; preloaded = ! radix_tree_preload ( GFP_KERNEL ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ; <S2SV_StartBug> if ( IS_ERR ( blkg ) ) { <S2SV_EndBug> blkg_free ( new_blkg ) ; return PTR_ERR ( blkg ) ; <S2SV_StartBug> } <S2SV_EndBug> q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }
CWE-190 void posixtimer_rearm ( struct siginfo * info ) { struct k_itimer * timr ; unsigned long flags ; timr = lock_timer ( info -> si_tid , & flags ) ; if ( ! timr ) return ; if ( timr -> it_requeue_pending == info -> si_sys_private ) { timr -> kclock -> timer_rearm ( timr ) ; timr -> it_active = 1 ; timr -> it_overrun_last = timr -> it_overrun ; <S2SV_StartBug> timr -> it_overrun = - 1 ; <S2SV_EndBug> ++ timr -> it_requeue_pending ; <S2SV_StartBug> info -> si_overrun += timr -> it_overrun_last ; <S2SV_EndBug> } unlock_timer ( timr , flags ) ; }
CWE-119 <S2SV_StartBug> void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> if ( eob > 1 ) <S2SV_StartBug> vp9_iwht4x4_16_add ( input , dest , stride ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_iwht4x4_1_add ( input , dest , stride ) ; <S2SV_EndBug> }
CWE-125 void vqp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct vqp_common_header_t * vqp_common_header ; const struct vqp_obj_tlv_t * vqp_obj_tlv ; const u_char * tptr ; uint16_t vqp_obj_len ; uint32_t vqp_obj_type ; <S2SV_StartBug> int tlen ; <S2SV_EndBug> uint8_t nitems ; tptr = pptr ; tlen = len ; vqp_common_header = ( const struct vqp_common_header_t * ) pptr ; <S2SV_StartBug> ND_TCHECK ( * vqp_common_header ) ; <S2SV_EndBug> if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) { ND_PRINT ( ( ndo , "VQP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , "VQPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>error-code<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , "unknown<S2SV_blank>(%u)" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , "unknown<S2SV_blank>(%u)" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , len ) ) ; return ; } nitems = vqp_common_header -> nitems ; ND_PRINT ( ( ndo , "\\n\\tVQPv%u,<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>error-code<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>items<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , "unknown<S2SV_blank>(%u)" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , "unknown<S2SV_blank>(%u)" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , EXTRACT_32BITS ( & vqp_common_header -> sequence ) , nitems , len ) ) ; tptr += sizeof ( const struct vqp_common_header_t ) ; tlen -= sizeof ( const struct vqp_common_header_t ) ; while ( nitems > 0 && tlen > 0 ) { vqp_obj_tlv = ( const struct vqp_obj_tlv_t * ) tptr ; <S2SV_StartBug> vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ; <S2SV_EndBug> vqp_obj_len = EXTRACT_16BITS ( vqp_obj_tlv -> obj_length ) ; tptr += sizeof ( struct vqp_obj_tlv_t ) ; tlen -= sizeof ( struct vqp_obj_tlv_t ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(0x%08x),<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>" , tok2str ( vqp_obj_values , "Unknown" , vqp_obj_type ) , vqp_obj_type , vqp_obj_len ) ) ; if ( vqp_obj_type == 0 || vqp_obj_len == 0 ) { return ; } ND_TCHECK2 ( * tptr , vqp_obj_len ) ; <S2SV_StartBug> switch ( vqp_obj_type ) { <S2SV_EndBug> case VQP_OBJ_IP_ADDRESS : <S2SV_StartBug> ND_PRINT ( ( ndo , "%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> break ; case VQP_OBJ_PORT_NAME : case VQP_OBJ_VLAN_NAME : case VQP_OBJ_VTP_DOMAIN : case VQP_OBJ_ETHERNET_PKT : safeputs ( ndo , tptr , vqp_obj_len ) ; break ; case VQP_OBJ_MAC_ADDRESS : <S2SV_StartBug> case VQP_OBJ_MAC_NULL : <S2SV_EndBug> ND_PRINT ( ( ndo , "%s" , etheraddr_string ( ndo , tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , vqp_obj_len ) ; break ; } tptr += vqp_obj_len ; tlen -= vqp_obj_len ; nitems -- ; } return ; trunc : ND_PRINT ( ( ndo , "\\n\\t[|VQP]" ) ) ; }
CWE-264 static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int ret ; <S2SV_StartBug> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <S2SV_EndBug> if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < PCI_ROM_RESOURCE ; i ++ ) { if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) <S2SV_StartBug> * value |= PCI_COMMAND_IO ; <S2SV_EndBug> if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ; } return ret ; }
CWE-119 static void set_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; <S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = ( uint8_t * ) malloc ( map . rows * map . cols ) ; for ( i = 0 ; i < map . rows * map . cols ; ++ i ) map . active_map [ i ] = i % 2 ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map" ) ; free ( map . active_map ) ; }
CWE-119 static Image * ReadAAIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; size_t height , length , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; do { image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( * p == 254 ) * p = 255 ; SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobLSBLong ( image ) ; height = ReadBlobLSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-125 <S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> return - 1 ; fields -> Buffer = ( PBYTE ) malloc ( fields -> Len ) ; if ( ! fields -> Buffer ) return - 1 ; Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Read ( s , fields -> Buffer , fields -> Len ) ; } return 1 ; }
CWE-119 static void estimate_missing_mvs ( MB_OVERLAP * overlaps , MODE_INFO * mi , MODE_INFO * prev_mi , int mb_rows , int mb_cols , unsigned int first_corrupt ) { int mb_row , mb_col ; <S2SV_StartBug> vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; <S2SV_EndBug> for ( mb_row = 0 ; mb_row < mb_rows ; ++ mb_row ) { for ( mb_col = 0 ; mb_col < mb_cols ; ++ mb_col ) { if ( prev_mi -> mbmi . ref_frame == LAST_FRAME ) { calc_prev_mb_overlaps ( overlaps , prev_mi , mb_row , mb_col , mb_rows , mb_cols ) ; } ++ prev_mi ; } ++ prev_mi ; } mb_row = first_corrupt / mb_cols ; mb_col = first_corrupt - mb_row * mb_cols ; mi += mb_row * ( mb_cols + 1 ) + mb_col ; for ( ; mb_row < mb_rows ; ++ mb_row ) { int mb_to_top_edge = - ( ( mb_row * 16 ) ) << 3 ; int mb_to_bottom_edge = ( ( mb_rows - 1 - mb_row ) * 16 ) << 3 ; for ( ; mb_col < mb_cols ; ++ mb_col ) { int mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; int mb_to_right_edge = ( ( mb_cols - 1 - mb_col ) * 16 ) << 3 ; const B_OVERLAP * block_overlaps = overlaps [ mb_row * mb_cols + mb_col ] . overlaps ; mi -> mbmi . ref_frame = LAST_FRAME ; mi -> mbmi . mode = SPLITMV ; mi -> mbmi . uv_mode = DC_PRED ; mi -> mbmi . partitioning = 3 ; mi -> mbmi . segment_id = 0 ; estimate_mb_mvs ( block_overlaps , mi , mb_to_left_edge , mb_to_right_edge , mb_to_top_edge , mb_to_bottom_edge ) ; ++ mi ; } mb_col = 0 ; ++ mi ; } }
CWE-264 int do_set_thread_area ( struct task_struct * p , int idx , struct user_desc __user * u_info , int can_allocate ) { struct user_desc info ; if ( copy_from_user ( & info , u_info , sizeof ( info ) ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> if ( idx == - 1 ) idx = info . entry_number ; if ( idx == - 1 && can_allocate ) { idx = get_free_idx ( ) ; if ( idx < 0 ) return idx ; if ( put_user ( idx , & u_info -> entry_number ) ) return - EFAULT ; } if ( idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX ) return - EINVAL ; set_tls_desc ( p , idx , & info , 1 ) ; return 0 ; }
CWE-000 static int read_packet ( int fd , gss_buffer_t buf , int timeout , int first ) { int ret ; static uint32_t len = 0 ; static char len_buf [ 4 ] ; static int len_buf_pos = 0 ; static char * tmpbuf = 0 ; static int tmpbuf_pos = 0 ; if ( first ) { len_buf_pos = 0 ; return - 2 ; } if ( len_buf_pos < 4 ) { ret = timed_read ( fd , & len_buf [ len_buf_pos ] , 4 - len_buf_pos , timeout ) ; if ( ret == - 1 ) { if ( errno == EINTR || errno == EAGAIN ) return - 2 ; LOG ( LOG_ERR , ( "%s" , strerror ( errno ) ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ret == 0 ) { if ( len_buf_pos == 0 ) return 0 ; LOG ( LOG_INFO , ( "EOF<S2SV_blank>reading<S2SV_blank>packet<S2SV_blank>len" ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } len_buf_pos += ret ; } if ( len_buf_pos != 4 ) return - 2 ; len = ntohl ( * ( uint32_t * ) len_buf ) ; if ( len > GSTD_MAXPACKETCONTENTS + 512 ) { LOG ( LOG_ERR , ( "ridiculous<S2SV_blank>length,<S2SV_blank>%ld" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ! tmpbuf ) { if ( ( tmpbuf = malloc ( len ) ) == NULL ) { LOG ( LOG_CRIT , ( "malloc<S2SV_blank>failure,<S2SV_blank>%ld<S2SV_blank>bytes" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } } ret = timed_read ( fd , tmpbuf + tmpbuf_pos , len - tmpbuf_pos , timeout ) ; if ( ret == - 1 ) { if ( errno == EINTR || errno == EAGAIN ) return - 2 ; LOG ( LOG_ERR , ( "%s" , strerror ( errno ) ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ret == 0 ) { LOG ( LOG_ERR , ( "EOF<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>packet<S2SV_blank>(len=%d)" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } tmpbuf_pos += ret ; if ( tmpbuf_pos == len ) { buf -> length = len ; buf -> value = tmpbuf ; len = len_buf_pos = tmpbuf_pos = 0 ; tmpbuf = NULL ; LOG ( LOG_DEBUG , ( "read<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d" , buf -> length ) ) ; return 1 ; } return - 2 ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-20 int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * zap = NULL ; int ret ; ret = key_payload_reserve ( key , prep -> datalen ) ; if ( ret < 0 ) return ret ; key -> expiry = prep -> expiry ; <S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> zap = dereference_key_locked ( key ) ; rcu_assign_keypointer ( key , prep -> payload . data [ 0 ] ) ; prep -> payload . data [ 0 ] = NULL ; if ( zap ) call_rcu ( & zap -> rcu , user_free_payload_rcu ) ; return ret ; }
CWE-000 static int resp_get_length ( netdissect_options * ndo , register const u_char * bp , int len , const u_char * * endp ) { int result ; u_char c ; int saw_digit ; int neg ; int too_large ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; too_large = 0 ; neg = 0 ; if ( * bp == '-' ) { neg = 1 ; bp ++ ; len -- ; } result = 0 ; saw_digit = 0 ; for ( ; ; ) { if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; c = * bp ; if ( ! ( c >= '0' && c <= '9' ) ) { <S2SV_StartBug> if ( ! saw_digit ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> break ; } c -= '0' ; if ( result > ( INT_MAX / 10 ) ) { too_large = 1 ; } else { result *= 10 ; if ( result == INT_MAX && c > ( INT_MAX % 10 ) ) { too_large = 1 ; } else result += c ; } bp ++ ; len -- ; saw_digit = 1 ; } if ( ! saw_digit ) goto invalid ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; <S2SV_StartBug> if ( * bp != '\\r' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> bp ++ ; len -- ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; <S2SV_StartBug> if ( * bp != '\\n' ) <S2SV_EndBug> <S2SV_StartBug> goto invalid ; <S2SV_EndBug> bp ++ ; len -- ; * endp = bp ; if ( neg ) { if ( too_large || result != 1 ) return ( - 4 ) ; result = - 1 ; } return ( too_large ? - 3 : result ) ; trunc : <S2SV_StartBug> return ( - 2 ) ; <S2SV_EndBug> invalid : <S2SV_StartBug> return ( - 5 ) ; <S2SV_EndBug> }
CWE-399 static int udp_v6_push_pending_frames ( struct sock * sk ) { struct sk_buff * skb ; struct udphdr * uh ; struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; <S2SV_StartBug> struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( ( skb = skb_peek ( & sk -> sk_write_queue ) ) == NULL ) goto out ; uh = udp_hdr ( skb ) ; uh -> source = fl6 -> fl6_sport ; uh -> dest = fl6 -> fl6_dport ; uh -> len = htons ( up -> len ) ; uh -> check = 0 ; if ( is_udplite ) csum = udplite_csum_outgoing ( sk , skb ) ; else if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { udp6_hwcsum_outgoing ( sk , skb , & fl6 -> saddr , & fl6 -> daddr , up -> len ) ; goto send ; } else csum = udp_csum_outgoing ( sk , skb ) ; uh -> check = csum_ipv6_magic ( & fl6 -> saddr , & fl6 -> daddr , up -> len , fl6 -> flowi6_proto , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; send : err = ip6_push_pending_frames ( sk ) ; if ( err ) { if ( err == - ENOBUFS && ! inet6_sk ( sk ) -> recverr ) { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; err = 0 ; } } else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_OUTDATAGRAMS , is_udplite ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }
CWE-264 SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB : <S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_roi_map ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_roi_map_t * data = va_arg ( args , vpx_roi_map_t * ) ; if ( data ) { vpx_roi_map_t * roi = ( vpx_roi_map_t * ) data ; if ( ! vp8_set_roimap ( ctx -> cpi , roi -> roi_map , roi -> rows , roi -> cols , roi -> delta_q , roi -> delta_lf , roi -> static_threshold ) ) return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-399 <S2SV_StartBug> static void kiocb_batch_free ( struct kiocb_batch * batch ) <S2SV_EndBug> { <S2SV_StartBug> struct kiocb * req , * n ; <S2SV_EndBug> list_for_each_entry_safe ( req , n , & batch -> head , ki_batch ) { list_del ( & req -> ki_batch ) ; <S2SV_StartBug> kmem_cache_free ( kiocb_cachep , req ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> }
CWE-200 int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case FBIOGTYPE : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - EFAULT ; return 0 ; } case FBIOPUTCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = NULL ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - EFAULT ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case FBIOGETCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; if ( index + count > cmap -> len ) return - EINVAL ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - EFAULT ; } return 0 ; } default : return - EINVAL ; } }
CWE-20 int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , "sorbo" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( "Inet<S2SV_blank>check<S2SV_blank>by<S2SV_blank>%s<S2SV_blank>%d\\n" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; <S2SV_StartBug> last_id = ntohs ( * pid ) ; <S2SV_EndBug> if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( "Got<S2SV_blank>packet<S2SV_blank>%d<S2SV_blank>%d" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( "<S2SV_blank>(DUP)\\n" ) ; return 0 ; } printf ( "\\n" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
CWE-000 static av_cold int vqa_decode_init ( AVCodecContext * avctx ) { VqaContext * s = avctx -> priv_data ; int i , j , codebook_index , ret ; s -> avctx = avctx ; avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; if ( s -> avctx -> extradata_size != VQA_HEADER_SIZE ) { av_log ( s -> avctx , AV_LOG_ERROR , "expected<S2SV_blank>extradata<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%d\\n" , VQA_HEADER_SIZE ) ; return AVERROR ( EINVAL ) ; } s -> vqa_version = s -> avctx -> extradata [ 0 ] ; switch ( s -> vqa_version ) { case 1 : case 2 : break ; case 3 : avpriv_report_missing_feature ( avctx , "VQA<S2SV_blank>Version<S2SV_blank>%d" , s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; default : avpriv_request_sample ( avctx , "VQA<S2SV_blank>Version<S2SV_blank>%i" , s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; } s -> width = AV_RL16 ( & s -> avctx -> extradata [ 6 ] ) ; s -> height = AV_RL16 ( & s -> avctx -> extradata [ 8 ] ) ; <S2SV_StartBug> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <S2SV_EndBug> s -> width = s -> height = 0 ; return ret ; } s -> vector_width = s -> avctx -> extradata [ 10 ] ; s -> vector_height = s -> avctx -> extradata [ 11 ] ; s -> partial_count = s -> partial_countdown = s -> avctx -> extradata [ 13 ] ; if ( ( s -> vector_width != 4 ) || ( ( s -> vector_height != 2 ) && ( s -> vector_height != 4 ) ) ) { return AVERROR_INVALIDDATA ; } if ( s -> width % s -> vector_width || s -> height % s -> vector_height ) { av_log ( avctx , AV_LOG_ERROR , "Image<S2SV_blank>size<S2SV_blank>not<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>block<S2SV_blank>size\\n" ) ; return AVERROR_INVALIDDATA ; } s -> codebook_size = MAX_CODEBOOK_SIZE ; s -> codebook = av_malloc ( s -> codebook_size ) ; if ( ! s -> codebook ) goto fail ; s -> next_codebook_buffer = av_malloc ( s -> codebook_size ) ; if ( ! s -> next_codebook_buffer ) goto fail ; s -> decode_buffer_size = ( s -> width / s -> vector_width ) * ( s -> height / s -> vector_height ) * 2 ; s -> decode_buffer = av_mallocz ( s -> decode_buffer_size ) ; if ( ! s -> decode_buffer ) goto fail ; if ( s -> vector_height == 4 ) { codebook_index = 0xFF00 * 16 ; for ( i = 0 ; i < 256 ; i ++ ) for ( j = 0 ; j < 16 ; j ++ ) s -> codebook [ codebook_index ++ ] = i ; } else { codebook_index = 0xF00 * 8 ; for ( i = 0 ; i < 256 ; i ++ ) for ( j = 0 ; j < 8 ; j ++ ) s -> codebook [ codebook_index ++ ] = i ; } s -> next_codebook_buffer_index = 0 ; return 0 ; fail : av_freep ( & s -> codebook ) ; av_freep ( & s -> next_codebook_buffer ) ; av_freep ( & s -> decode_buffer ) ; return AVERROR ( ENOMEM ) ; }
CWE-119 static Image * ReadHRZImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; ssize_t count , y ; size_t length ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 256 ; image -> rows = 240 ; image -> depth = 8 ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; length = ( size_t ) ( 3 * image -> columns ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( 4 * * p ++ ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( SetImageProgress ( image , LoadImageTag , y , image -> rows ) == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-284 static int a2dp_command ( struct a2dp_stream_common * common , char cmd ) { char ack ; DEBUG ( "A2DP<S2SV_blank>COMMAND<S2SV_blank>%s" , dump_a2dp_ctrl_event ( cmd ) ) ; <S2SV_StartBug> if ( send ( common -> ctrl_fd , & cmd , 1 , MSG_NOSIGNAL ) == - 1 ) <S2SV_EndBug> { ERROR ( "cmd<S2SV_blank>failed<S2SV_blank>(%s)" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } if ( a2dp_ctrl_receive ( common , & ack , 1 ) < 0 ) return - 1 ; DEBUG ( "A2DP<S2SV_blank>COMMAND<S2SV_blank>%s<S2SV_blank>DONE<S2SV_blank>STATUS<S2SV_blank>%d" , dump_a2dp_ctrl_event ( cmd ) , ack ) ; if ( ack == A2DP_CTRL_ACK_INCALL_FAILURE ) return ack ; if ( ack != A2DP_CTRL_ACK_SUCCESS ) return - 1 ; return 0 ; }
CWE-119 static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; <S2SV_StartBug> vpx_roi_map_t roi = { 0 } ; <S2SV_EndBug> roi . rows = ( cfg -> g_h + 15 ) / 16 ; roi . cols = ( cfg -> g_w + 15 ) / 16 ; roi . delta_q [ 0 ] = 0 ; roi . delta_q [ 1 ] = - 2 ; roi . delta_q [ 2 ] = - 4 ; roi . delta_q [ 3 ] = - 6 ; roi . delta_lf [ 0 ] = 0 ; roi . delta_lf [ 1 ] = 1 ; roi . delta_lf [ 2 ] = 2 ; roi . delta_lf [ 3 ] = 3 ; roi . static_threshold [ 0 ] = 1500 ; roi . static_threshold [ 1 ] = 1000 ; roi . static_threshold [ 2 ] = 500 ; roi . static_threshold [ 3 ] = 0 ; roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ; for ( i = 0 ; i < roi . rows * roi . cols ; ++ i ) roi . roi_map [ i ] = i % 4 ; if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>ROI<S2SV_blank>map" ) ; free ( roi . roi_map ) ; }
CWE-000 int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) { struct ext4_extent_header * eh ; struct ext4_extent * ex , * fex ; struct ext4_extent * nearex ; struct ext4_ext_path * npath = NULL ; int depth , len , err ; ext4_lblk_t next ; unsigned uninitialized = 0 ; BUG_ON ( ext4_ext_get_actual_len ( newext ) == 0 ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; BUG_ON ( path [ depth ] . p_hdr == NULL ) ; <S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( "append<S2SV_blank>[%d]%d<S2SV_blank>block<S2SV_blank>to<S2SV_blank>%d:[%d]%d<S2SV_blank>(from<S2SV_blank>%llu)\\n" , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , le32_to_cpu ( ex -> ee_block ) , ext4_ext_is_uninitialized ( ex ) , ext4_ext_get_actual_len ( ex ) , ext_pblock ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; if ( ext4_ext_is_uninitialized ( ex ) ) uninitialized = 1 ; ex -> ee_len = cpu_to_le16 ( ext4_ext_get_actual_len ( ex ) + ext4_ext_get_actual_len ( newext ) ) ; if ( uninitialized ) ext4_ext_mark_uninitialized ( ex ) ; eh = path [ depth ] . p_hdr ; nearex = ex ; goto merge ; } repeat : depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) goto has_space ; fex = EXT_LAST_EXTENT ( eh ) ; next = ext4_ext_next_leaf_block ( inode , path ) ; if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( fex -> ee_block ) && next != EXT_MAX_BLOCK ) { ext_debug ( "next<S2SV_blank>leaf<S2SV_blank>block<S2SV_blank>-<S2SV_blank>%d\\n" , next ) ; BUG_ON ( npath != NULL ) ; npath = ext4_ext_find_extent ( inode , next , NULL ) ; if ( IS_ERR ( npath ) ) return PTR_ERR ( npath ) ; BUG_ON ( npath -> p_depth != path -> p_depth ) ; eh = npath [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) { ext_debug ( "next<S2SV_blank>leaf<S2SV_blank>isnt<S2SV_blank>full(%d)\\n" , le16_to_cpu ( eh -> eh_entries ) ) ; path = npath ; goto repeat ; } ext_debug ( "next<S2SV_blank>leaf<S2SV_blank>has<S2SV_blank>no<S2SV_blank>free<S2SV_blank>space(%d,%d)\\n" , le16_to_cpu ( eh -> eh_entries ) , le16_to_cpu ( eh -> eh_max ) ) ; } err = ext4_ext_create_new_leaf ( handle , inode , path , newext ) ; if ( err ) goto cleanup ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; has_space : nearex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; if ( ! nearex ) { ext_debug ( "first<S2SV_blank>extent<S2SV_blank>in<S2SV_blank>the<S2SV_blank>leaf:<S2SV_blank>%d:%llu:[%d]%d\\n" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) ) ; path [ depth ] . p_ext = EXT_FIRST_EXTENT ( eh ) ; } else if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( nearex -> ee_block ) ) { if ( nearex != EXT_LAST_EXTENT ( eh ) ) { len = EXT_MAX_EXTENT ( eh ) - nearex ; len = ( len - 1 ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( "insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>after:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>" "move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 2 , nearex + 1 , len ) ; } path [ depth ] . p_ext = nearex + 1 ; } else { BUG_ON ( newext -> ee_block == nearex -> ee_block ) ; len = ( EXT_MAX_EXTENT ( eh ) - nearex ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( "insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>before:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>" "move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 1 , nearex , len ) ; path [ depth ] . p_ext = nearex ; } le16_add_cpu ( & eh -> eh_entries , 1 ) ; nearex = path [ depth ] . p_ext ; nearex -> ee_block = newext -> ee_block ; ext4_ext_store_pblock ( nearex , ext_pblock ( newext ) ) ; nearex -> ee_len = newext -> ee_len ; merge : <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ext4_ext_try_to_merge ( inode , path , nearex ) ; err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto cleanup ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; cleanup : if ( npath ) { ext4_ext_drop_refs ( npath ) ; kfree ( npath ) ; } ext4_ext_invalidate_cache ( inode ) ; return err ; }
CWE-119 BITMAP_UPDATE * update_read_bitmap_update ( rdpUpdate * update , wStream * s ) { UINT32 i ; BITMAP_UPDATE * bitmapUpdate = calloc ( 1 , sizeof ( BITMAP_UPDATE ) ) ; if ( ! bitmapUpdate ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 2 ) goto fail ; Stream_Read_UINT16 ( s , bitmapUpdate -> number ) ; WLog_Print ( update -> log , WLOG_TRACE , "BitmapUpdate:<S2SV_blank>%" PRIu32 "" , bitmapUpdate -> number ) ; if ( bitmapUpdate -> number > bitmapUpdate -> count ) { <S2SV_StartBug> UINT16 count ; <S2SV_EndBug> BITMAP_DATA * newdata ; count = bitmapUpdate -> number * 2 ; <S2SV_StartBug> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <S2SV_EndBug> sizeof ( BITMAP_DATA ) * count ) ; if ( ! newdata ) goto fail ; bitmapUpdate -> rectangles = newdata ; ZeroMemory ( & bitmapUpdate -> rectangles [ bitmapUpdate -> count ] , sizeof ( BITMAP_DATA ) * ( count - bitmapUpdate -> count ) ) ; bitmapUpdate -> count = count ; } for ( i = 0 ; i < bitmapUpdate -> number ; i ++ ) { if ( ! update_read_bitmap_data ( update , s , & bitmapUpdate -> rectangles [ i ] ) ) goto fail ; } return bitmapUpdate ; fail : free_bitmap_update ( update -> context , bitmapUpdate ) ; return NULL ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data && ! ctx -> yv12_frame_buffers . use_frame_threads ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; return vp8dx_set_reference ( ctx -> yv12_frame_buffers . pbi [ 0 ] , frame -> frame_type , & sd ) ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-125 void isoclns_print ( netdissect_options * ndo , <S2SV_StartBug> const uint8_t * p , u_int length , u_int caplen ) <S2SV_EndBug> { <S2SV_StartBug> if ( caplen <= 1 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "|OSI" ) ) ; return ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "OSI<S2SV_blank>NLPID<S2SV_blank>%s<S2SV_blank>(0x%02x):<S2SV_blank>" , tok2str ( nlpid_values , "Unknown" , * p ) , * p ) ) ; switch ( * p ) { case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) ) <S2SV_StartBug> print_unknown_data ( ndo , p , "\\n\\t" , caplen ) ; <S2SV_EndBug> break ; case NLPID_ESIS : esis_print ( ndo , p , length ) ; return ; case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) ) <S2SV_StartBug> print_unknown_data ( ndo , p , "\\n\\t" , caplen ) ; <S2SV_EndBug> break ; case NLPID_NULLNS : ND_PRINT ( ( ndo , "%slength:<S2SV_blank>%u" , ndo -> ndo_eflag ? "" : ",<S2SV_blank>" , length ) ) ; break ; case NLPID_Q933 : q933_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_IP : ip_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_PPP : ppp_print ( ndo , p + 1 , length - 1 ) ; break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "OSI<S2SV_blank>NLPID<S2SV_blank>0x%02x<S2SV_blank>unknown" , * p ) ) ; ND_PRINT ( ( ndo , "%slength:<S2SV_blank>%u" , ndo -> ndo_eflag ? "" : ",<S2SV_blank>" , length ) ) ; <S2SV_StartBug> if ( caplen > 1 ) <S2SV_EndBug> <S2SV_StartBug> print_unknown_data ( ndo , p , "\\n\\t" , caplen ) ; <S2SV_EndBug> break ; } }
CWE-000 static int irda_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; struct irda_sock * self ; <S2SV_StartBug> if ( net != & init_net ) <S2SV_EndBug> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_STREAM : case SOCK_SEQPACKET : case SOCK_DGRAM : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_IRDA , GFP_KERNEL , & irda_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; self = irda_sk ( sk ) ; pr_debug ( "%s()<S2SV_blank>:<S2SV_blank>self<S2SV_blank>is<S2SV_blank>%p\\n" , __func__ , self ) ; init_waitqueue_head ( & self -> query_wait ) ; switch ( sock -> type ) { case SOCK_STREAM : sock -> ops = & irda_stream_ops ; self -> max_sdu_size_rx = TTP_SAR_DISABLE ; break ; case SOCK_SEQPACKET : sock -> ops = & irda_seqpacket_ops ; self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; break ; case SOCK_DGRAM : switch ( protocol ) { # ifdef CONFIG_IRDA_ULTRA case IRDAPROTO_ULTRA : sock -> ops = & irda_ultra_ops ; self -> max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER ; self -> max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER ; break ; # endif case IRDAPROTO_UNITDATA : sock -> ops = & irda_dgram_ops ; self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; break ; default : sk_free ( sk ) ; return - ESOCKTNOSUPPORT ; } break ; default : sk_free ( sk ) ; return - ESOCKTNOSUPPORT ; } sock_init_data ( sock , sk ) ; sk -> sk_family = PF_IRDA ; sk -> sk_protocol = protocol ; self -> ckey = irlmp_register_client ( 0 , NULL , NULL , NULL ) ; self -> mask . word = 0xffff ; self -> rx_flow = self -> tx_flow = FLOW_START ; self -> nslots = DISCOVERY_DEFAULT_SLOTS ; self -> daddr = DEV_ADDR_ANY ; self -> saddr = 0x0 ; return 0 ; }
CWE-119 static void show_stream_config ( struct stream_state * stream , struct VpxEncoderConfig * global , struct VpxInputContext * input ) { # define SHOW ( field ) fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-28s<S2SV_blank>=<S2SV_blank>%d\\n" , # field , stream -> config . cfg . field ) if ( stream -> index == 0 ) { fprintf ( stderr , "Codec:<S2SV_blank>%s\\n" , <S2SV_StartBug> vpx_codec_iface_name ( global -> codec -> interface ( ) ) ) ; <S2SV_EndBug> fprintf ( stderr , "Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n" , input -> filename , <S2SV_StartBug> input -> use_i420 ? "I420" : "YV12" ) ; <S2SV_EndBug> } if ( stream -> next || stream -> index ) fprintf ( stderr , "\\nStream<S2SV_blank>Index:<S2SV_blank>%d\\n" , stream -> index ) ; fprintf ( stderr , "Destination<S2SV_blank>file:<S2SV_blank>%s\\n" , stream -> config . out_fn ) ; fprintf ( stderr , "Encoder<S2SV_blank>parameters:\\n" ) ; SHOW ( g_usage ) ; SHOW ( g_threads ) ; SHOW ( g_profile ) ; SHOW ( g_w ) ; SHOW ( g_h ) ; <S2SV_StartBug> SHOW ( g_timebase . num ) ; <S2SV_EndBug> SHOW ( g_timebase . den ) ; SHOW ( g_error_resilient ) ; SHOW ( g_pass ) ; SHOW ( g_lag_in_frames ) ; SHOW ( rc_dropframe_thresh ) ; <S2SV_StartBug> SHOW ( rc_resize_allowed ) ; <S2SV_EndBug> SHOW ( rc_resize_up_thresh ) ; SHOW ( rc_resize_down_thresh ) ; SHOW ( rc_end_usage ) ; SHOW ( rc_target_bitrate ) ; SHOW ( rc_min_quantizer ) ; SHOW ( rc_max_quantizer ) ; SHOW ( rc_undershoot_pct ) ; SHOW ( rc_overshoot_pct ) ; SHOW ( rc_buf_sz ) ; SHOW ( rc_buf_initial_sz ) ; SHOW ( rc_buf_optimal_sz ) ; SHOW ( rc_2pass_vbr_bias_pct ) ; SHOW ( rc_2pass_vbr_minsection_pct ) ; SHOW ( rc_2pass_vbr_maxsection_pct ) ; SHOW ( kf_mode ) ; SHOW ( kf_min_dist ) ; SHOW ( kf_max_dist ) ; }
CWE-119 static vpx_codec_err_t vp8e_mr_alloc_mem ( const vpx_codec_enc_cfg_t * cfg , void * * mem_loc ) { vpx_codec_err_t res = 0 ; # if CONFIG_MULTI_RES_ENCODING LOWER_RES_FRAME_INFO * shared_mem_loc ; int mb_rows = ( ( cfg -> g_w + 15 ) >> 4 ) ; int mb_cols = ( ( cfg -> g_h + 15 ) >> 4 ) ; shared_mem_loc = calloc ( 1 , sizeof ( LOWER_RES_FRAME_INFO ) ) ; if ( ! shared_mem_loc ) { res = VPX_CODEC_MEM_ERROR ; } shared_mem_loc -> mb_info = calloc ( mb_rows * mb_cols , sizeof ( LOWER_RES_MB_INFO ) ) ; if ( ! ( shared_mem_loc -> mb_info ) ) { res = VPX_CODEC_MEM_ERROR ; } else { * mem_loc = ( void * ) shared_mem_loc ; res = VPX_CODEC_OK ; } <S2SV_StartBug> # endif <S2SV_EndBug> return res ; }
CWE-119 void vp9_setup_src_planes ( MACROBLOCK * x , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; x -> e_mbd . cur_buf = src ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) setup_pred_plane ( & x -> plane [ i ] . src , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , x -> e_mbd . plane [ i ] . subsampling_x , x -> e_mbd . plane [ i ] . subsampling_y ) ; }
CWE-119 <S2SV_StartBug> static void restore_context ( VP9_COMP * cpi , int mi_row , int mi_col , <S2SV_EndBug> ENTROPY_CONTEXT a [ 16 * MAX_MB_PLANE ] , ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , PARTITION_CONTEXT sa [ 8 ] , PARTITION_CONTEXT sl [ 8 ] , BLOCK_SIZE bsize ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; int p ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; for ( p = 0 ; p < MAX_MB_PLANE ; p ++ ) { <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> xd -> above_context [ p ] + ( ( mi_col * 2 ) >> xd -> plane [ p ] . subsampling_x ) , a + num_4x4_blocks_wide * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_wide ) >> xd -> plane [ p ] . subsampling_x ) ; <S2SV_StartBug> vpx_memcpy ( <S2SV_EndBug> xd -> left_context [ p ] + ( ( mi_row & MI_MASK ) * 2 >> xd -> plane [ p ] . subsampling_y ) , l + num_4x4_blocks_high * p , ( sizeof ( ENTROPY_CONTEXT ) * num_4x4_blocks_high ) >> xd -> plane [ p ] . subsampling_y ) ; } <S2SV_StartBug> vpx_memcpy ( xd -> above_seg_context + mi_col , sa , <S2SV_EndBug> sizeof ( * xd -> above_seg_context ) * mi_width ) ; <S2SV_StartBug> vpx_memcpy ( xd -> left_seg_context + ( mi_row & MI_MASK ) , sl , <S2SV_EndBug> sizeof ( xd -> left_seg_context [ 0 ] ) * mi_height ) ; }
CWE-119 int iscsi_decode_text_input ( u8 phase , u8 sender , char * textbuf , u32 length , struct iscsi_conn * conn ) { struct iscsi_param_list * param_list = conn -> param_list ; char * tmpbuf , * start = NULL , * end = NULL ; tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ) ; if ( ! tmpbuf ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>tmpbuf.\\n" ) ; return - 1 ; } memcpy ( tmpbuf , textbuf , length ) ; tmpbuf [ length ] = '\\0' ; start = tmpbuf ; end = ( start + length ) ; while ( start < end ) { char * key , * value ; struct iscsi_param * param ; if ( iscsi_extract_key_value ( start , & key , & value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } pr_debug ( "Got<S2SV_blank>key:<S2SV_blank>%s=%s\\n" , key , value ) ; if ( phase & PHASE_SECURITY ) { if ( iscsi_check_for_auth_key ( key ) > 0 ) { <S2SV_StartBug> char * tmpptr = key + strlen ( key ) ; <S2SV_EndBug> * tmpptr = '=' ; kfree ( tmpbuf ) ; return 1 ; } } param = iscsi_check_key ( key , phase , sender , param_list ) ; if ( ! param ) { if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; continue ; } if ( iscsi_check_value ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; if ( IS_PSTATE_PROPOSER ( param ) ) { if ( iscsi_check_proposer_state ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_RESPONSE_GOT ( param ) ; } else { if ( iscsi_check_acceptor_state ( param , value , conn ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_ACCEPTOR ( param ) ; } } kfree ( tmpbuf ) ; return 0 ; }
CWE-476 static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i + 47 >= dctx -> remaining ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; return END_NOT_FOUND ; }
CWE-476 static int i8042_start ( struct serio * serio ) { struct i8042_port * port = serio -> port_data ; <S2SV_StartBug> port -> exists = true ; <S2SV_EndBug> <S2SV_StartBug> mb ( ) ; <S2SV_EndBug> return 0 ; }
CWE-20 size_t cdf_count_chain ( const cdf_sat_t * sat , cdf_secid_t sid , size_t size ) { size_t i , j ; <S2SV_StartBug> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <S2SV_EndBug> DPRINTF ( ( "Chain:" ) ) ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { DPRINTF ( ( "<S2SV_blank>%d" , sid ) ) ; if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( "Counting<S2SV_blank>chain<S2SV_blank>loop<S2SV_blank>limit" ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } <S2SV_StartBug> if ( sid > maxsector ) { <S2SV_EndBug> DPRINTF ( ( "Sector<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n" , sid , maxsector ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } sid = CDF_TOLE4 ( ( uint32_t ) sat -> sat_tab [ sid ] ) ; } if ( i == 0 ) { DPRINTF ( ( "<S2SV_blank>none,<S2SV_blank>sid:<S2SV_blank>%d\\n" , sid ) ) ; return ( size_t ) - 1 ; } DPRINTF ( ( "\\n" ) ) ; return i ; }
CWE-119 static int PredictorEncodeRow ( TIFF * tif , uint8 * bp , tmsize_t cc , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encoderow != NULL ) ; <S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug> return ( * sp -> encoderow ) ( tif , bp , cc , s ) ; }
CWE-119 static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ; <S2SV_StartBug> } else if ( event -> type == et_char ) { <S2SV_EndBug> if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( "scripting.html" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }
CWE-119 <S2SV_StartBug> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <S2SV_EndBug> { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , <S2SV_StartBug> indx , data , size , 100 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , "%s<S2SV_blank>returned<S2SV_blank>%d\\n" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-119 static __u8 * nci_extract_rf_params_nfca_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfca_poll * nfca_poll , __u8 * data ) { nfca_poll -> sens_res = __le16_to_cpu ( * ( ( __u16 * ) data ) ) ; data += 2 ; <S2SV_StartBug> nfca_poll -> nfcid1_len = * data ++ ; <S2SV_EndBug> pr_debug ( "sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\n" , nfca_poll -> sens_res , nfca_poll -> nfcid1_len ) ; memcpy ( nfca_poll -> nfcid1 , data , nfca_poll -> nfcid1_len ) ; data += nfca_poll -> nfcid1_len ; nfca_poll -> sel_res_len = * data ++ ; if ( nfca_poll -> sel_res_len != 0 ) nfca_poll -> sel_res = * data ++ ; pr_debug ( "sel_res_len<S2SV_blank>%d,<S2SV_blank>sel_res<S2SV_blank>0x%x\\n" , nfca_poll -> sel_res_len , nfca_poll -> sel_res ) ; return data ; }
CWE-125 static int lldp_mgmt_addr_tlv_print ( netdissect_options * ndo , const u_char * pptr , u_int len ) { uint8_t mgmt_addr_len , intf_num_subtype , oid_len ; const u_char * tptr ; u_int tlen ; char * mgmt_addr ; tlen = len ; tptr = pptr ; if ( tlen < 1 ) { return 0 ; } mgmt_addr_len = * tptr ++ ; tlen -- ; if ( tlen < mgmt_addr_len ) { return 0 ; } mgmt_addr = lldp_network_addr_print ( ndo , tptr , mgmt_addr_len ) ; if ( mgmt_addr == NULL ) { return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>%s" , mgmt_addr_len , mgmt_addr ) ) ; tptr += mgmt_addr_len ; tlen -= mgmt_addr_len ; if ( tlen < LLDP_INTF_NUM_LEN ) { return 0 ; } intf_num_subtype = * tptr ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Interface<S2SV_blank>Numbering<S2SV_blank>(%u):<S2SV_blank>%u" , tok2str ( lldp_intf_numb_subtype_values , "Unknown" , intf_num_subtype ) , intf_num_subtype , EXTRACT_32BITS ( tptr + 1 ) ) ) ; tptr += LLDP_INTF_NUM_LEN ; tlen -= LLDP_INTF_NUM_LEN ; if ( tlen ) { oid_len = * tptr ; <S2SV_StartBug> if ( tlen < oid_len ) { <S2SV_EndBug> return 0 ; } if ( oid_len ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>OID<S2SV_blank>length<S2SV_blank>%u" , oid_len ) ) ; safeputs ( ndo , tptr + 1 , oid_len ) ; } } return 1 ; }
CWE-000 int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , ";%08x" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , "" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { rc = fsmVerify ( fpath , fi ) ; } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; <S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }
CWE-362 void flush_tlb_mm_range ( struct mm_struct * mm , unsigned long start , unsigned long end , unsigned long vmflag ) { unsigned long addr ; unsigned long base_pages_to_flush = TLB_FLUSH_ALL ; preempt_disable ( ) ; <S2SV_StartBug> if ( current -> active_mm != mm ) <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ! current -> mm ) { leave_mm ( smp_processor_id ( ) ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } if ( ( end != TLB_FLUSH_ALL ) && ! ( vmflag & VM_HUGETLB ) ) base_pages_to_flush = ( end - start ) >> PAGE_SHIFT ; if ( base_pages_to_flush > tlb_single_page_flush_ceiling ) { base_pages_to_flush = TLB_FLUSH_ALL ; count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ALL ) ; local_flush_tlb ( ) ; } else { for ( addr = start ; addr < end ; addr += PAGE_SIZE ) { count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ONE ) ; __flush_tlb_single ( addr ) ; } } trace_tlb_flush ( TLB_LOCAL_MM_SHOOTDOWN , base_pages_to_flush ) ; out : if ( base_pages_to_flush == TLB_FLUSH_ALL ) { start = 0UL ; end = TLB_FLUSH_ALL ; } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , end ) ; preempt_enable ( ) ; }
CWE-20 static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ; <S2SV_StartBug> long timeo ; <S2SV_EndBug> msg -> msg_namelen = 0 ; lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ! timeo || ( flags & MSG_PEEK ) ) break ; } else { if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { copied = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) { copied = - ENOTCONN ; break ; } break ; } if ( ! timeo ) { copied = - EAGAIN ; break ; } } if ( copied >= target ) { release_sock ( sk ) ; lock_sock ( sk ) ; } else sk_wait_data ( sk , & timeo ) ; if ( ( flags & MSG_PEEK ) && peek_seq != llc -> copied_seq ) { net_dbg_ratelimited ( "LLC(%s:%d):<S2SV_blank>Application<S2SV_blank>bug,<S2SV_blank>race<S2SV_blank>in<S2SV_blank>MSG_PEEK\\n" , current -> comm , task_pid_nr ( current ) ) ; peek_seq = llc -> copied_seq ; } continue ; found_ok_skb : used = skb -> len - offset ; if ( len < used ) used = len ; if ( ! ( flags & MSG_TRUNC ) ) { int rc = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , used ) ; if ( rc ) { if ( ! copied ) copied = - EFAULT ; break ; } } * seq += used ; copied += used ; len -= used ; if ( sk -> sk_type != SOCK_STREAM ) goto copy_uaddr ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } if ( used + offset < skb -> len ) continue ; } while ( len > 0 ) ; out : release_sock ( sk ) ; return copied ; copy_uaddr : if ( uaddr != NULL && skb != NULL ) { memcpy ( uaddr , llc_ui_skb_cb ( skb ) , sizeof ( * uaddr ) ) ; msg -> msg_namelen = sizeof ( * uaddr ) ; } if ( llc_sk ( sk ) -> cmsg_flags ) llc_cmsg_rcv ( msg , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } goto out ; }
CWE-119 <S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap * base = data ; bitmap_set ( base , find_object_pos ( object -> oid . hash ) ) ; mark_as_seen ( object ) ; }
CWE-119 <S2SV_StartBug> void vp9_fht8x8_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { __m128i in [ 8 ] ; switch ( tx_type ) { case DCT_DCT : <S2SV_StartBug> vp9_fdct8x8_sse2 ( input , output , stride ) ; <S2SV_EndBug> break ; case ADST_DCT : load_buffer_8x8 ( input , in , stride ) ; fadst8_sse2 ( in ) ; fdct8_sse2 ( in ) ; right_shift_8x8 ( in , 1 ) ; write_buffer_8x8 ( output , in , 8 ) ; break ; case DCT_ADST : load_buffer_8x8 ( input , in , stride ) ; fdct8_sse2 ( in ) ; fadst8_sse2 ( in ) ; right_shift_8x8 ( in , 1 ) ; write_buffer_8x8 ( output , in , 8 ) ; break ; case ADST_ADST : load_buffer_8x8 ( input , in , stride ) ; fadst8_sse2 ( in ) ; fadst8_sse2 ( in ) ; right_shift_8x8 ( in , 1 ) ; write_buffer_8x8 ( output , in , 8 ) ; break ; default : assert ( 0 ) ; break ; } }
CWE-000 static int mxf_read_index_entry_array ( AVIOContext * pb , MXFIndexTableSegment * segment ) { int i , length ; segment -> nb_index_entries = avio_rb32 ( pb ) ; length = avio_rb32 ( pb ) ; <S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) { av_freep ( & segment -> temporal_offset_entries ) ; av_freep ( & segment -> flag_entries ) ; return AVERROR ( ENOMEM ) ; } <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug> segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ; avio_r8 ( pb ) ; segment -> flag_entries [ i ] = avio_r8 ( pb ) ; segment -> stream_offset_entries [ i ] = avio_rb64 ( pb ) ; avio_skip ( pb , length - 11 ) ; } return 0 ; }
CWE-000 static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code ) <S2SV_StartBug> return code ; <S2SV_EndBug> code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ; if ( code ) { * status = "INVALID_S4U2SELF_CHECKSUM" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = "INVALID_S4U2SELF_REQUEST" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }
CWE-119 static int atusb_get_and_show_build ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ; <S2SV_StartBug> char build [ ATUSB_BUILD_SIZE + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ; if ( ret >= 0 ) { build [ ret ] = 0 ; dev_info ( & usb_dev -> dev , "Firmware:<S2SV_blank>build<S2SV_blank>%s\\n" , build ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
CWE-000 static int __btrfs_set_acl ( struct btrfs_trans_handle * trans , struct inode * inode , struct posix_acl * acl , int type ) { int ret , size = 0 ; const char * name ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; } ret = 0 ; break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EINVAL : 0 ; name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out ; } ret = __btrfs_setxattr ( trans , inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! ret ) set_cached_acl ( inode , type , acl ) ; return ret ; }
CWE-264 static __inline__ int scm_check_creds ( struct ucred * creds ) { const struct cred * cred = current_cred ( ) ; kuid_t uid = make_kuid ( cred -> user_ns , creds -> uid ) ; kgid_t gid = make_kgid ( cred -> user_ns , creds -> gid ) ; if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) return - EINVAL ; <S2SV_StartBug> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) { return 0 ; } return - EPERM ; }
CWE-000 void AcpiNsTerminate ( void ) { ACPI_STATUS Status ; <S2SV_StartBug> ACPI_FUNCTION_TRACE ( NsTerminate ) ; <S2SV_EndBug> # ifdef ACPI_EXEC_APP { ACPI_OPERAND_OBJECT * Prev ; <S2SV_StartBug> ACPI_OPERAND_OBJECT * Next ; <S2SV_EndBug> Next = AcpiGbl_ModuleCodeList ; while ( Next ) { Prev = Next ; Next = Next -> Method . Mutex ; Prev -> Method . Mutex = NULL ; AcpiUtRemoveReference ( Prev ) ; } <S2SV_StartBug> } <S2SV_EndBug> # endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( Status ) ) { return_VOID ; } AcpiNsDeleteNode ( AcpiGbl_RootNode ) ; ( void ) AcpiUtReleaseMutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , "Namespace<S2SV_blank>freed\\n" ) ) ; return_VOID ; }
CWE-189 static int efx_probe_all ( struct efx_nic * efx ) { int rc ; rc = efx_probe_nic ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>NIC\\n" ) ; goto fail1 ; } rc = efx_probe_port ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>port\\n" ) ; goto fail2 ; } <S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug> rc = efx_probe_channels ( efx ) ; if ( rc ) goto fail3 ; rc = efx_probe_filters ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>filter<S2SV_blank>tables\\n" ) ; goto fail4 ; } return 0 ; fail4 : efx_remove_channels ( efx ) ; fail3 : efx_remove_port ( efx ) ; fail2 : efx_remove_nic ( efx ) ; fail1 : return rc ; }
CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , "BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , "BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , "BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , "BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , "R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\n" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ; __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; <S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> } } else if ( opcode > BPF_END ) { verbose ( env , "invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\n" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , "BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , "BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , "div<S2SV_blank>by<S2SV_blank>zero\\n" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , "invalid<S2SV_blank>shift<S2SV_blank>%d\\n" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }
CWE-416 static int dccp_v6_send_response ( const struct sock * sk , struct request_sock * req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; int err = - 1 ; struct dst_entry * dst ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowlabel = 0 ; fl6 . flowi6_oif = ireq -> ir_iif ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; dst = NULL ; goto done ; } skb = dccp_make_response ( sk , dst , req ) ; if ( skb != NULL ) { struct dccp_hdr * dh = dccp_hdr ( skb ) ; dh -> dccph_checksum = dccp_v6_csum_finish ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> err = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> err = net_xmit_eval ( err ) ; } done : dst_release ( dst ) ; return err ; }
CWE-416 extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) { <S2SV_StartBug> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <S2SV_EndBug> & cpat , & cpat_end ) ; if ( r != 0 ) return r ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }
CWE-787 static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>node<S2SV_blank>type<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x:<S2SV_blank>found<S2SV_blank>0x%02x,<S2SV_blank>expected<S2SV_blank>0x%02x\\n" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>size<S2SV_blank>node<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = FALSE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_NULL : default : return NULL ; } case BPLIST_UINT : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_UINT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_uint_node ( object , size ) ; case BPLIST_REAL : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_real_node ( object , size ) ; case BPLIST_DATE : if ( 3 != size ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>size<S2SV_blank>for<S2SV_blank>BPLIST_DATE<S2SV_blank>node\\n" , __func__ ) ; return NULL ; } if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_DATE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_date_node ( object , size ) ; case BPLIST_DATA : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_data_node ( object , size ) ; case BPLIST_STRING : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_string_node ( object , size ) ; case BPLIST_UNICODE : if ( size * 2 < size ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>size.\\n" , __func__ ) ; return NULL ; } <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_unicode_node ( object , size ) ; case BPLIST_SET : case BPLIST_ARRAY : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_array_node ( bplist , object , size ) ; case BPLIST_UID : if ( * object + size + 1 > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_UID<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_uid_node ( object , size ) ; case BPLIST_DICT : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" , __func__ ) ; return NULL ; } return parse_dict_node ( bplist , object , size ) ; default : PLIST_BIN_ERR ( "%s:<S2SV_blank>unexpected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x\\n" , __func__ , type ) ; return NULL ; } return NULL ; }
CWE-119 void vp8_dequant_idct_add_c ( short * input , short * dq , unsigned char * dest , int stride ) { int i ; for ( i = 0 ; i < 16 ; i ++ ) { input [ i ] = dq [ i ] * input [ i ] ; } vp8_short_idct4x4llm_c ( input , dest , stride , dest , stride ) ; <S2SV_StartBug> vpx_memset ( input , 0 , 32 ) ; <S2SV_EndBug> }
CWE-476 static int unimac_mdio_probe ( struct platform_device * pdev ) { struct unimac_mdio_pdata * pdata = pdev -> dev . platform_data ; struct unimac_mdio_priv * priv ; struct device_node * np ; struct mii_bus * bus ; struct resource * r ; int ret ; np = pdev -> dev . of_node ; priv = devm_kzalloc ( & pdev -> dev , sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; r = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; <S2SV_EndBug> if ( ! priv -> base ) { dev_err ( & pdev -> dev , "failed<S2SV_blank>to<S2SV_blank>remap<S2SV_blank>register\\n" ) ; return - ENOMEM ; } priv -> mii_bus = mdiobus_alloc ( ) ; if ( ! priv -> mii_bus ) return - ENOMEM ; bus = priv -> mii_bus ; bus -> priv = priv ; if ( pdata ) { bus -> name = pdata -> bus_name ; priv -> wait_func = pdata -> wait_func ; priv -> wait_func_data = pdata -> wait_func_data ; bus -> phy_mask = ~ pdata -> phy_mask ; } else { bus -> name = "unimac<S2SV_blank>MII<S2SV_blank>bus" ; priv -> wait_func_data = priv ; priv -> wait_func = unimac_mdio_poll ; } bus -> parent = & pdev -> dev ; bus -> read = unimac_mdio_read ; bus -> write = unimac_mdio_write ; bus -> reset = unimac_mdio_reset ; snprintf ( bus -> id , MII_BUS_ID_SIZE , "%s-%d" , pdev -> name , pdev -> id ) ; ret = of_mdiobus_register ( bus , np ) ; if ( ret ) { dev_err ( & pdev -> dev , "MDIO<S2SV_blank>bus<S2SV_blank>registration<S2SV_blank>failed\\n" ) ; goto out_mdio_free ; } platform_set_drvdata ( pdev , priv ) ; dev_info ( & pdev -> dev , "Broadcom<S2SV_blank>UniMAC<S2SV_blank>MDIO<S2SV_blank>bus<S2SV_blank>at<S2SV_blank>0x%p\\n" , priv -> base ) ; return 0 ; out_mdio_free : mdiobus_free ( bus ) ; return ret ; }
CWE-125 INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( "%d,1,<<,r%d,&," , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? "!," : "!,!," ) ; ESIL_A ( "?{,%" PFMT64d ",pc,=,}," , op -> jump ) ; }
CWE-399 static int dcbnl_ieee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * ieee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx ; int err ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) return - EMSGSIZE ; ieee = nla_nest_start ( skb , DCB_ATTR_IEEE ) ; if ( ! ieee ) return - EMSGSIZE ; if ( ops -> ieee_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_getmaxrate ) { struct ieee_maxrate maxrate ; <S2SV_StartBug> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; <S2SV_EndBug> if ( ! err ) { err = nla_put ( skb , DCB_ATTR_IEEE_MAXRATE , sizeof ( maxrate ) , & maxrate ) ; if ( err ) return - EMSGSIZE ; } } if ( ops -> ieee_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } app = nla_nest_start ( skb , DCB_ATTR_IEEE_APP_TABLE ) ; if ( ! app ) return - EMSGSIZE ; spin_lock ( & dcb_lock ) ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { err = nla_put ( skb , DCB_ATTR_IEEE_APP , sizeof ( itr -> app ) , & itr -> app ) ; if ( err ) { spin_unlock ( & dcb_lock ) ; return - EMSGSIZE ; } } } if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; nla_nest_end ( skb , app ) ; if ( ops -> ieee_peer_getets ) { struct ieee_ets ets ; <S2SV_StartBug> err = ops -> ieee_peer_getets ( netdev , & ets ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) return - EMSGSIZE ; } if ( ops -> ieee_peer_getpfc ) { <S2SV_StartBug> struct ieee_pfc pfc ; <S2SV_EndBug> err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_IEEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) return - EMSGSIZE ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_IEEE_PEER_APP , DCB_ATTR_IEEE_APP_UNSPEC , DCB_ATTR_IEEE_APP ) ; if ( err ) return - EMSGSIZE ; } nla_nest_end ( skb , ieee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) return - EMSGSIZE ; } return 0 ; }
CWE-264 static int load_state_from_tss16 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_16 * tss ) { int ret ; u8 cpl ; ctxt -> _eip = tss -> ip ; ctxt -> eflags = tss -> flag | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> ax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> cx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> dx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> bx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> sp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> bp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> si ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> di ; set_segment_selector ( ctxt , tss -> ldt , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; cpl = tss -> cs & 3 ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }
CWE-264 static inline int unuse_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , swp_entry_t entry , struct page * page ) { pmd_t * pmd ; unsigned long next ; int ret ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; <S2SV_StartBug> if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) <S2SV_EndBug> continue ; if ( pmd_none_or_clear_bad ( pmd ) ) continue ; ret = unuse_pte_range ( vma , pmd , addr , next , entry , page ) ; if ( ret ) return ret ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }
CWE-264 static inline int check_sticky ( struct inode * dir , struct inode * inode ) { kuid_t fsuid = current_fsuid ( ) ; if ( ! ( dir -> i_mode & S_ISVTX ) ) return 0 ; if ( uid_eq ( inode -> i_uid , fsuid ) ) return 0 ; if ( uid_eq ( dir -> i_uid , fsuid ) ) return 0 ; <S2SV_StartBug> return ! inode_capable ( inode , CAP_FOWNER ) ; <S2SV_EndBug> }
CWE-119 static void update_golden_frame_stats ( VP9_COMP * cpi ) { RATE_CONTROL * const rc = & cpi -> rc ; if ( cpi -> refresh_golden_frame ) { rc -> frames_since_golden = 0 ; <S2SV_StartBug> if ( ! rc -> source_alt_ref_pending ) <S2SV_EndBug> <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ; } else if ( ! cpi -> refresh_alt_ref_frame ) { if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ; rc -> frames_since_golden ++ ; } }
CWE-200 int raptor_turtle_writer_set_option ( raptor_turtle_writer * turtle_writer , raptor_option option , int value ) { if ( value < 0 || ! raptor_option_is_valid_for_area ( option , RAPTOR_OPTION_AREA_TURTLE_WRITER ) ) return 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : if ( value ) turtle_writer -> flags |= TURTLE_WRITER_AUTO_INDENT ; else turtle_writer -> flags &= ~ TURTLE_WRITER_AUTO_INDENT ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : turtle_writer -> indent = value ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : break ; case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : <S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ; break ; } return 0 ; }
CWE-125 <S2SV_StartBug> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> MaxLen < 1 ) fields -> MaxLen = fields -> Len ; Stream_Write_UINT16 ( s , fields -> Len ) ; Stream_Write_UINT16 ( s , fields -> MaxLen ) ; Stream_Write_UINT32 ( s , fields -> BufferOffset ) ; }
CWE-119 static void set_block_size ( VP9_COMP * const cpi , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { if ( cpi -> common . mi_cols > mi_col && cpi -> common . mi_rows > mi_row ) { <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ; <S2SV_EndBug> xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; <S2SV_StartBug> duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> } }
CWE-119 static int crypto_ccm_auth ( struct aead_request * req , struct scatterlist * plain , unsigned int cryptlen ) { struct crypto_ccm_req_priv_ctx * pctx = crypto_ccm_reqctx ( req ) ; struct crypto_aead * aead = crypto_aead_reqtfm ( req ) ; struct crypto_ccm_ctx * ctx = crypto_aead_ctx ( aead ) ; AHASH_REQUEST_ON_STACK ( ahreq , ctx -> mac ) ; unsigned int assoclen = req -> assoclen ; struct scatterlist sg [ 3 ] ; <S2SV_StartBug> u8 odata [ 16 ] ; <S2SV_EndBug> u8 idata [ 16 ] ; int ilen , err ; err = format_input ( odata , req , cryptlen ) ; if ( err ) goto out ; sg_init_table ( sg , 3 ) ; sg_set_buf ( & sg [ 0 ] , odata , 16 ) ; if ( assoclen ) { ilen = format_adata ( idata , assoclen ) ; sg_set_buf ( & sg [ 1 ] , idata , ilen ) ; sg_chain ( sg , 3 , req -> src ) ; } else { ilen = 0 ; sg_chain ( sg , 2 , req -> src ) ; } ahash_request_set_tfm ( ahreq , ctx -> mac ) ; ahash_request_set_callback ( ahreq , pctx -> flags , NULL , NULL ) ; ahash_request_set_crypt ( ahreq , sg , NULL , assoclen + ilen + 16 ) ; err = crypto_ahash_init ( ahreq ) ; if ( err ) goto out ; err = crypto_ahash_update ( ahreq ) ; if ( err ) goto out ; ilen = 16 - ( assoclen + ilen ) % 16 ; if ( ilen < 16 ) { memset ( idata , 0 , ilen ) ; sg_init_table ( sg , 2 ) ; sg_set_buf ( & sg [ 0 ] , idata , ilen ) ; if ( plain ) sg_chain ( sg , 2 , plain ) ; plain = sg ; cryptlen += ilen ; } ahash_request_set_crypt ( ahreq , plain , pctx -> odata , cryptlen ) ; err = crypto_ahash_finup ( ahreq ) ; out : return err ; }
CWE-20 static int rfcomm_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rfcomm_dlc * d = rfcomm_pi ( sk ) -> dlc ; int len ; if ( test_and_clear_bit ( RFCOMM_DEFER_SETUP , & d -> flags ) ) { <S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; return 0 ; } len = bt_sock_stream_recvmsg ( iocb , sock , msg , size , flags ) ; lock_sock ( sk ) ; if ( ! ( flags & MSG_PEEK ) && len > 0 ) atomic_sub ( len , & sk -> sk_rmem_alloc ) ; if ( atomic_read ( & sk -> sk_rmem_alloc ) <= ( sk -> sk_rcvbuf >> 2 ) ) rfcomm_dlc_unthrottle ( rfcomm_pi ( sk ) -> dlc ) ; release_sock ( sk ) ; return len ; }
CWE-119 ssize_t cdf_read_sector ( const cdf_info_t * info , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) , <S2SV_EndBug> ( ( char * ) buf ) + offs , len ) ; }
CWE-000 SYSCALL_DEFINE4 ( epoll_ctl , int , epfd , int , op , int , fd , struct epoll_event __user * , event ) { int error ; int did_lock_epmutex = 0 ; struct file * file , * tfile ; struct eventpoll * ep ; struct epitem * epi ; struct epoll_event epds ; error = - EFAULT ; if ( ep_op_has_event ( op ) && copy_from_user ( & epds , event , sizeof ( struct epoll_event ) ) ) goto error_return ; error = - EBADF ; file = fget ( epfd ) ; if ( ! file ) goto error_return ; tfile = fget ( fd ) ; if ( ! tfile ) goto error_fput ; error = - EPERM ; if ( ! tfile -> f_op || ! tfile -> f_op -> poll ) goto error_tgt_fput ; error = - EINVAL ; if ( file == tfile || ! is_file_epoll ( file ) ) goto error_tgt_fput ; ep = file -> private_data ; if ( op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; } if ( op == EPOLL_CTL_ADD ) { if ( is_file_epoll ( tfile ) ) { error = - ELOOP ; <S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> } else list_add ( & tfile -> f_tfile_llink , & tfile_check_list ) ; } mutex_lock_nested ( & ep -> mtx , 0 ) ; epi = ep_find ( ep , tfile , fd ) ; error = - EINVAL ; switch ( op ) { case EPOLL_CTL_ADD : if ( ! epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_insert ( ep , & epds , tfile , fd ) ; } else error = - EEXIST ; clear_tfile_check_list ( ) ; break ; case EPOLL_CTL_DEL : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - ENOENT ; break ; case EPOLL_CTL_MOD : if ( epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_modify ( ep , epi , & epds ) ; } else error = - ENOENT ; break ; } mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : if ( did_lock_epmutex ) mutex_unlock ( & epmutex ) ; fput ( tfile ) ; error_fput : fput ( file ) ; error_return : return error ; }
CWE-119 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; <S2SV_StartBug> return SET_IVD_FATAL_ERROR ( e_error ) ; <S2SV_EndBug> } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } impeg2d_bit_stream_flush ( ps_stream , 18 ) ; GET_MARKER_BIT ( ps_dec , ps_stream ) ; impeg2d_bit_stream_flush ( ps_stream , 11 ) ; if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_intra_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_intra_quant_matrix , gau1_impeg2_intra_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } if ( impeg2d_bit_stream_get_bit ( ps_stream ) == 1 ) { UWORD16 i ; for ( i = 0 ; i < NUM_PELS_IN_BLOCK ; i ++ ) { ps_dec -> au1_inter_quant_matrix [ gau1_impeg2_inv_scan_zig_zag [ i ] ] = ( UWORD8 ) impeg2d_bit_stream_get ( ps_stream , 8 ) ; } } else { memcpy ( ps_dec -> au1_inter_quant_matrix , gau1_impeg2_inter_quant_matrix_default , NUM_PELS_IN_BLOCK ) ; } impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-119 void jslGetTokenString ( char * str , size_t len ) { if ( lex -> tk == LEX_ID ) { <S2SV_StartBug> strncpy ( str , "ID:" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> } else if ( lex -> tk == LEX_STR ) { <S2SV_StartBug> strncpy ( str , "String:\'" , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( str , jslGetTokenValueAsString ( ) , len ) ; <S2SV_EndBug> strncat ( str , "\'" , len ) ; } else jslTokenAsString ( lex -> tk , str , len ) ; }
CWE-000 bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , "Found<S2SV_blank>constant<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>where<S2SV_blank>boolean<S2SV_blank>was<S2SV_blank>expected\\n" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , "true" ) || istreq ( ident , "yes" ) || istreq ( ident , "on" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , "false" ) || istreq ( ident , "no" ) || istreq ( ident , "off" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , "Identifier<S2SV_blank>\\"%s\\"<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , "Default<S2SV_blank>\\"%s.%s\\"<S2SV_blank>of<S2SV_blank>type<S2SV_blank>boolean<S2SV_blank>is<S2SV_blank>unknown\\n" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT : <S2SV_StartBug> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <S2SV_EndBug> if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ; case EXPR_ADD : case EXPR_SUBTRACT : case EXPR_MULTIPLY : case EXPR_DIVIDE : case EXPR_ASSIGN : case EXPR_NEGATE : case EXPR_UNARY_PLUS : log_err ( ctx , "%s<S2SV_blank>of<S2SV_blank>boolean<S2SV_blank>values<S2SV_blank>not<S2SV_blank>permitted\\n" , expr_op_type_to_string ( expr -> expr . op ) ) ; break ; default : log_wsgo ( ctx , "Unknown<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveBoolean\\n" , expr -> expr . op ) ; break ; } return false ; }
CWE-20 <S2SV_StartBug> void f2fs_wait_discard_bios ( struct f2fs_sb_info * sbi ) <S2SV_EndBug> { __issue_discard_cmd ( sbi , false ) ; __drop_discard_cmd ( sbi ) ; <S2SV_StartBug> __wait_discard_cmd ( sbi , false ) ; <S2SV_EndBug> }
CWE-119 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } } } else { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; for ( n = 0 ; n < num_images ; n ++ ) { if ( n != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) <S2SV_EndBug> { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-119 void vpx_scale_frame ( YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst , unsigned char * temp_area , unsigned char temp_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i ; int dw = ( hscale - 1 + src -> y_width * hratio ) / hscale ; int dh = ( vscale - 1 + src -> y_height * vratio ) / vscale ; Scale2D ( ( unsigned char * ) src -> y_buffer , src -> y_stride , src -> y_width , src -> y_height , ( unsigned char * ) dst -> y_buffer , dst -> y_stride , dw , dh , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw < ( int ) dst -> y_width ) for ( i = 0 ; i < dh ; i ++ ) <S2SV_StartBug> vpx_memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ; <S2SV_EndBug> if ( dh < ( int ) dst -> y_height ) for ( i = dh - 1 ; i < ( int ) dst -> y_height ; i ++ ) <S2SV_StartBug> vpx_memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ; <S2SV_EndBug> Scale2D ( ( unsigned char * ) src -> u_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> u_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw / 2 < ( int ) dst -> uv_width ) for ( i = 0 ; i < dst -> uv_height ; i ++ ) <S2SV_StartBug> vpx_memset ( dst -> u_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> u_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ; <S2SV_EndBug> if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ; i < ( int ) dst -> y_height / 2 ; i ++ ) <S2SV_StartBug> vpx_memcpy ( dst -> u_buffer + i * dst -> uv_stride , dst -> u_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ; <S2SV_EndBug> Scale2D ( ( unsigned char * ) src -> v_buffer , src -> uv_stride , src -> uv_width , src -> uv_height , ( unsigned char * ) dst -> v_buffer , dst -> uv_stride , dw / 2 , dh / 2 , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw / 2 < ( int ) dst -> uv_width ) for ( i = 0 ; i < dst -> uv_height ; i ++ ) <S2SV_StartBug> vpx_memset ( dst -> v_buffer + i * dst -> uv_stride + dw / 2 - 1 , dst -> v_buffer [ i * dst -> uv_stride + dw / 2 - 2 ] , dst -> uv_width - dw / 2 + 1 ) ; <S2SV_EndBug> if ( dh / 2 < ( int ) dst -> uv_height ) for ( i = dh / 2 - 1 ; i < ( int ) dst -> y_height / 2 ; i ++ ) <S2SV_StartBug> vpx_memcpy ( dst -> v_buffer + i * dst -> uv_stride , dst -> v_buffer + ( dh / 2 - 2 ) * dst -> uv_stride , dst -> uv_width ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static void write_mb_modes_kf ( const VP9_COMP * cpi , MODE_INFO * * mi_8x8 , <S2SV_EndBug> <S2SV_StartBug> vp9_writer * w ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const struct segmentation * const seg = & cm -> seg ; const MODE_INFO * const mi = mi_8x8 [ 0 ] ; <S2SV_StartBug> const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> const MODE_INFO * const left_mi = xd -> left_available ? mi_8x8 [ - 1 ] : NULL ; <S2SV_EndBug> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; const BLOCK_SIZE bsize = mbmi -> sb_type ; if ( seg -> update_map ) write_segment_id ( w , seg , mbmi -> segment_id ) ; <S2SV_StartBug> write_skip ( cpi , mbmi -> segment_id , mi , w ) ; <S2SV_EndBug> if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT ) <S2SV_StartBug> write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ; <S2SV_EndBug> if ( bsize >= BLOCK_8X8 ) { write_intra_mode ( w , mbmi -> mode , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int block = idy * 2 + idx ; write_intra_mode ( w , mi -> bmi [ block ] . as_mode , get_y_mode_probs ( mi , above_mi , left_mi , block ) ) ; } } } write_intra_mode ( w , mbmi -> uv_mode , vp9_kf_uv_mode_prob [ mbmi -> mode ] ) ; }
CWE-125 <S2SV_StartBug> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <S2SV_EndBug> { int i , j , v ; <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> intra_matrix [ j ] = v ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> get_bits ( gb , 8 ) ; } } <S2SV_StartBug> if ( get_bits1 ( gb ) ) { <S2SV_EndBug> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <S2SV_StartBug> for ( i = 0 ; i < 64 ; i ++ ) { <S2SV_EndBug> get_bits ( gb , 8 ) ; } } next_start_code_studio ( gb ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-20 <S2SV_StartBug> void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) <S2SV_EndBug> { <S2SV_StartBug> vcpu -> arch . apic -> vapic_addr = vapic_addr ; <S2SV_EndBug> if ( vapic_addr ) __set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ; <S2SV_StartBug> else <S2SV_EndBug> __clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-200 static int l2tp_ip_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }
CWE-190 static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = BPF_OP ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( WARN_ON_ONCE ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , "verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>sbounds\\n" ) ; return - EINVAL ; } if ( WARN_ON_ONCE ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , "verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>ubounds\\n" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , "R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_MAP_VALUE_OR_NULL ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_MAP_VALUE_OR_NULL<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == CONST_PTR_TO_MAP ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>CONST_PTR_TO_MAP<S2SV_blank>prohibited\\n" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_PACKET_END ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_PACKET_END<S2SV_blank>prohibited\\n" , dst ) ; return - EACCES ; } dst_reg -> type = ptr_reg -> type ; <S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> switch ( opcode ) { case BPF_ADD : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case BPF_SUB : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , "R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : if ( ! env -> allow_ptr_leaks ) verbose ( env , "R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug> __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
CWE-119 <S2SV_StartBug> static void fadst4 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int x0 , x1 , x2 , x3 ; <S2SV_EndBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; x0 = input [ 0 ] ; x1 = input [ 1 ] ; x2 = input [ 2 ] ; x3 = input [ 3 ] ; if ( ! ( x0 | x1 | x2 | x3 ) ) { output [ 0 ] = output [ 1 ] = output [ 2 ] = output [ 3 ] = 0 ; return ; } s0 = sinpi_1_9 * x0 ; s1 = sinpi_4_9 * x0 ; s2 = sinpi_2_9 * x1 ; s3 = sinpi_1_9 * x1 ; s4 = sinpi_3_9 * x2 ; s5 = sinpi_4_9 * x3 ; s6 = sinpi_2_9 * x3 ; s7 = x0 + x1 - x3 ; x0 = s0 + s2 + s5 ; x1 = sinpi_3_9 * s7 ; x2 = s1 - s3 + s6 ; x3 = s4 ; s0 = x0 + x3 ; s1 = x1 ; s2 = x2 - x3 ; s3 = x2 - x0 + x3 ; <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( s0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( s1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = fdct_round_shift ( s2 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = fdct_round_shift ( s3 ) ; <S2SV_EndBug> }
CWE-399 static void nlmclnt_unlock_callback ( struct rpc_task * task , void * data ) { struct nlm_rqst * req = data ; u32 status = ntohl ( req -> a_res . status ) ; if ( RPC_ASSASSINATED ( task ) ) goto die ; if ( task -> tk_status < 0 ) { dprintk ( "lockd:<S2SV_blank>unlock<S2SV_blank>failed<S2SV_blank>(err<S2SV_blank>=<S2SV_blank>%d)\\n" , - task -> tk_status ) ; <S2SV_StartBug> goto retry_rebind ; <S2SV_EndBug> } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay ( task , NLMCLNT_GRACE_WAIT ) ; goto retry_unlock ; } if ( status != NLM_LCK_GRANTED ) printk ( KERN_WARNING "lockd:<S2SV_blank>unexpected<S2SV_blank>unlock<S2SV_blank>status:<S2SV_blank>%d\\n" , status ) ; die : return ; retry_rebind : nlm_rebind_host ( req -> a_host ) ; retry_unlock : rpc_restart_call ( task ) ; }
CWE-119 <S2SV_StartBug> static void set_segment_id ( VP9_COMMON * cm , BLOCK_SIZE bsize , <S2SV_EndBug> int mi_row , int mi_col , int segment_id ) { <S2SV_StartBug> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <S2SV_EndBug> const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; int x , y ; assert ( segment_id >= 0 && segment_id < MAX_SEGMENTS ) ; <S2SV_StartBug> for ( y = 0 ; y < ymis ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( x = 0 ; x < xmis ; x ++ ) <S2SV_EndBug> <S2SV_StartBug> cm -> last_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ; <S2SV_EndBug> }
CWE-000 static void ip_expire ( unsigned long arg ) { struct ipq * qp ; struct net * net ; qp = container_of ( ( struct inet_frag_queue * ) arg , struct ipq , q ) ; net = container_of ( qp -> q . net , struct net , ipv4 . frags ) ; spin_lock ( & qp -> q . lock ) ; if ( qp -> q . last_in & INET_FRAG_COMPLETE ) goto out ; ipq_kill ( qp ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMTIMEOUT ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMFAILS ) ; if ( ( qp -> q . last_in & INET_FRAG_FIRST_IN ) && qp -> q . fragments != NULL ) { struct sk_buff * head = qp -> q . fragments ; <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> head -> dev = dev_get_by_index_rcu ( net , qp -> iif ) ; <S2SV_StartBug> if ( ! head -> dev ) <S2SV_EndBug> goto out_rcu_unlock ; <S2SV_StartBug> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { <S2SV_EndBug> const struct iphdr * iph = ip_hdr ( head ) ; int err = ip_route_input ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( unlikely ( err ) ) goto out_rcu_unlock ; if ( skb_rtable ( head ) -> rt_type != RTN_LOCAL ) goto out_rcu_unlock ; <S2SV_StartBug> } <S2SV_EndBug> icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ; out_rcu_unlock : rcu_read_unlock ( ) ; } out : spin_unlock ( & qp -> q . lock ) ; ipq_put ( qp ) ; }
CWE-119 <S2SV_StartBug> void vp9_diff_update_prob ( vp9_reader * r , vp9_prob * p ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_read ( r , DIFF_UPDATE_PROB ) ) { <S2SV_EndBug> const int delp = decode_term_subexp ( r ) ; <S2SV_StartBug> * p = ( vp9_prob ) inv_remap_prob ( delp , * p ) ; <S2SV_EndBug> } }
CWE-264 static int em_ret_near_imm ( struct x86_emulate_ctxt * ctxt ) { int rc ; <S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> ctxt -> dst . addr . reg = & ctxt -> _eip ; ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_StartBug> rc = emulate_pop ( ctxt , & ctxt -> dst . val , ctxt -> op_bytes ) ; <S2SV_EndBug> if ( rc != X86EMUL_CONTINUE ) return rc ; rsp_increment ( ctxt , ctxt -> src . val ) ; return X86EMUL_CONTINUE ; }
CWE-416 static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; <S2SV_StartBug> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_EndBug> struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; <S2SV_StartBug> if ( np -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; <S2SV_EndBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( newnp -> opt != NULL ) <S2SV_EndBug> <S2SV_StartBug> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + <S2SV_EndBug> <S2SV_StartBug> newnp -> opt -> opt_flen ) ; <S2SV_EndBug> dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
CWE-119 <S2SV_StartBug> static void cost ( int * costs , vp9_tree tree , const vp9_prob * probs , <S2SV_EndBug> int i , int c ) { <S2SV_StartBug> const vp9_prob prob = probs [ i / 2 ] ; <S2SV_EndBug> int b ; for ( b = 0 ; b <= 1 ; ++ b ) { const int cc = c + vp9_cost_bit ( prob , b ) ; <S2SV_StartBug> const vp9_tree_index ii = tree [ i + b ] ; <S2SV_EndBug> if ( ii <= 0 ) costs [ - ii ] = cc ; else cost ( costs , tree , probs , ii , cc ) ; } }
