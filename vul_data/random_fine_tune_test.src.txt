CWE-476 static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , BLK_MQ_F_SHOULD_MERGE ) ; if ( IS_ERR ( disk -> queue ) ) { <S2SV_StartBug> disk -> queue = NULL ; <S2SV_EndBug> continue ; } INIT_LIST_HEAD ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; if ( ( * drives [ unit ] ) [ D_PRT ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , "%s%d" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; } }
CWE-119 static INLINE void add_token_no_extra ( TOKENEXTRA * * t , <S2SV_StartBug> const vp9_prob * context_tree , <S2SV_EndBug> uint8_t token , uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }
CWE-362 static int newseg ( struct ipc_namespace * ns , struct ipc_params * params ) { key_t key = params -> key ; int shmflg = params -> flg ; size_t size = params -> u . size ; int error ; struct shmid_kernel * shp ; size_t numpages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; struct file * file ; char name [ 13 ] ; int id ; vm_flags_t acctflag = 0 ; if ( size < SHMMIN || size > ns -> shm_ctlmax ) return - EINVAL ; if ( numpages << PAGE_SHIFT < size ) return - ENOSPC ; if ( ns -> shm_tot + numpages < ns -> shm_tot || ns -> shm_tot + numpages > ns -> shm_ctlall ) return - ENOSPC ; shp = ipc_rcu_alloc ( sizeof ( * shp ) ) ; if ( ! shp ) return - ENOMEM ; shp -> shm_perm . key = key ; shp -> shm_perm . mode = ( shmflg & S_IRWXUGO ) ; shp -> mlock_user = NULL ; shp -> shm_perm . security = NULL ; error = security_shm_alloc ( shp ) ; if ( error ) { ipc_rcu_putref ( shp , ipc_rcu_free ) ; return error ; } sprintf ( name , "SYSV%08x" , key ) ; if ( shmflg & SHM_HUGETLB ) { struct hstate * hs ; size_t hugesize ; hs = hstate_sizelog ( ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; if ( ! hs ) { error = - EINVAL ; goto no_file ; } hugesize = ALIGN ( size , huge_page_size ( hs ) ) ; if ( shmflg & SHM_NORESERVE ) acctflag = VM_NORESERVE ; file = hugetlb_file_setup ( name , hugesize , acctflag , & shp -> mlock_user , HUGETLB_SHMFS_INODE , ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; } else { if ( ( shmflg & SHM_NORESERVE ) && sysctl_overcommit_memory != OVERCOMMIT_NEVER ) acctflag = VM_NORESERVE ; file = shmem_kernel_file_setup ( name , size , acctflag ) ; } error = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) goto no_file ; <S2SV_StartBug> id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ; <S2SV_EndBug> if ( id < 0 ) { error = id ; goto no_id ; } <S2SV_StartBug> shp -> shm_cprid = task_tgid_vnr ( current ) ; <S2SV_EndBug> shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; list_add ( & shp -> shm_clist , & current -> sysvshm . shm_clist ) ; file_inode ( file ) -> i_ino = shp -> shm_perm . id ; ns -> shm_tot += numpages ; error = shp -> shm_perm . id ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; return error ; no_id : if ( is_file_hugepages ( file ) && shp -> mlock_user ) user_shm_unlock ( size , shp -> mlock_user ) ; fput ( file ) ; no_file : ipc_rcu_putref ( shp , shm_rcu_free ) ; return error ; }
CWE-264 static void _isdn_setup ( struct net_device * dev ) { isdn_net_local * lp = netdev_priv ( dev ) ; ether_setup ( dev ) ; dev -> flags = IFF_NOARP | IFF_POINTOPOINT ; <S2SV_StartBug> dev -> header_ops = NULL ; <S2SV_EndBug> dev -> netdev_ops = & isdn_netdev_ops ; dev -> tx_queue_len = 30 ; lp -> p_encap = ISDN_NET_ENCAP_RAWIP ; lp -> magic = ISDN_NET_MAGIC ; lp -> last = lp ; lp -> next = lp ; lp -> isdn_device = - 1 ; lp -> isdn_channel = - 1 ; lp -> pre_device = - 1 ; lp -> pre_channel = - 1 ; lp -> exclusive = - 1 ; lp -> ppp_slot = - 1 ; lp -> pppbind = - 1 ; skb_queue_head_init ( & lp -> super_tx_queue ) ; lp -> l2_proto = ISDN_PROTO_L2_X75I ; lp -> l3_proto = ISDN_PROTO_L3_TRANS ; lp -> triggercps = 6000 ; lp -> slavedelay = 10 * HZ ; lp -> hupflags = ISDN_INHUP ; lp -> onhtime = 10 ; lp -> dialmax = 1 ; lp -> flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL ; lp -> cbdelay = 25 ; lp -> dialtimeout = - 1 ; lp -> dialwait = 5 * HZ ; lp -> dialstarted = 0 ; lp -> dialwait_timer = 0 ; }
CWE-119 vpx_codec_err_t vpx_codec_enc_config_set ( vpx_codec_ctx_t * ctx , const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ; if ( ! ctx || ! ctx -> iface || ! ctx -> priv || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> res = ctx -> iface -> enc . cfg_set ( ctx -> priv -> alg_priv , cfg ) ; <S2SV_EndBug> return SAVE_STATUS ( ctx , res ) ; }
CWE-119 void uwbd_stop ( struct uwb_rc * rc ) <S2SV_StartBug> { <S2SV_EndBug> kthread_stop ( rc -> uwbd . task ) ; uwbd_flush ( rc ) ; }
CWE-119 const char * util_acl_to_str ( const sc_acl_entry_t * e ) { static char line [ 80 ] , buf [ 20 ] ; unsigned int acl ; if ( e == NULL ) return "N/A" ; line [ 0 ] = 0 ; while ( e != NULL ) { acl = e -> method ; switch ( acl ) { case SC_AC_UNKNOWN : return "N/A" ; case SC_AC_NEVER : return "NEVR" ; case SC_AC_NONE : return "NONE" ; case SC_AC_CHV : strcpy ( buf , "CHV" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , "%d" , e -> key_ref ) ; break ; case SC_AC_TERM : strcpy ( buf , "TERM" ) ; break ; case SC_AC_PRO : strcpy ( buf , "PROT" ) ; break ; case SC_AC_AUT : strcpy ( buf , "AUTH" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 4 , "%d" , e -> key_ref ) ; break ; case SC_AC_SEN : strcpy ( buf , "Sec.Env.<S2SV_blank>" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , "#%d" , e -> key_ref ) ; break ; case SC_AC_SCB : strcpy ( buf , "Sec.ControlByte<S2SV_blank>" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , "Ox%X" , e -> key_ref ) ; break ; case SC_AC_IDA : strcpy ( buf , "PKCS#15<S2SV_blank>AuthID<S2SV_blank>" ) ; if ( e -> key_ref != SC_AC_KEY_REF_NONE ) sprintf ( buf + 3 , "#%d" , e -> key_ref ) ; break ; default : strcpy ( buf , "????" ) ; break ; } <S2SV_StartBug> strcat ( line , buf ) ; <S2SV_EndBug> <S2SV_StartBug> strcat ( line , "<S2SV_blank>" ) ; <S2SV_EndBug> e = e -> next ; } <S2SV_StartBug> line [ strlen ( line ) - 1 ] = 0 ; <S2SV_EndBug> return line ; }
CWE-20 static struct block_device * ext3_blkdev_get ( dev_t dev , struct super_block * sb ) { struct block_device * bdev ; char b [ BDEVNAME_SIZE ] ; bdev = blkdev_get_by_dev ( dev , FMODE_READ | FMODE_WRITE | FMODE_EXCL , sb ) ; if ( IS_ERR ( bdev ) ) goto fail ; return bdev ; fail : <S2SV_StartBug> ext3_msg ( sb , "error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>journal<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%ld" , <S2SV_EndBug> __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; return NULL ; }
CWE-119 <S2SV_StartBug> void vp9_iht8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride , <S2SV_EndBug> int tx_type ) { int i , j ; <S2SV_StartBug> int16_t out [ 8 * 8 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = out ; <S2SV_EndBug> <S2SV_StartBug> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <S2SV_EndBug> const transform_2d ht = IHT_8 [ tx_type ] ; for ( i = 0 ; i < 8 ; ++ i ) { ht . rows ( input , outptr ) ; input += 8 ; outptr += 8 ; } for ( i = 0 ; i < 8 ; ++ i ) { for ( j = 0 ; j < 8 ; ++ j ) temp_in [ j ] = out [ j * 8 + i ] ; ht . cols ( temp_in , temp_out ) ; <S2SV_StartBug> for ( j = 0 ; j < 8 ; ++ j ) <S2SV_EndBug> <S2SV_StartBug> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) <S2SV_EndBug> <S2SV_StartBug> + dest [ j * stride + i ] ) ; <S2SV_EndBug> } }
CWE-119 static Image * ReadAVSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; register unsigned char * p ; size_t height , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; do { ssize_t length ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; length = ( size_t ) 4 * image -> columns ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != length ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( q -> opacity != OpaqueOpacity ) image -> matte = MagickTrue ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( ( width != 0UL ) && ( height != 0UL ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( width != 0UL ) && ( height != 0UL ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-20 static int do_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags , pte_t orig_pte ) { pgoff_t pgoff = ( ( ( address & PAGE_MASK ) - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; <S2SV_StartBug> pte_unmap ( page_table ) ; <S2SV_EndBug> if ( ! ( flags & FAULT_FLAG_WRITE ) ) return do_read_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; if ( ! ( vma -> vm_flags & VM_SHARED ) ) return do_cow_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; return do_shared_fault ( mm , vma , address , pmd , pgoff , flags , orig_pte ) ; }
CWE-264 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }
CWE-125 static int jpeg_size ( unsigned char * data , unsigned int data_size , int * width , int * height ) { int i = 0 ; if ( i + 3 < data_size && data [ i ] == 0xFF && data [ i + 1 ] == 0xD8 && data [ i + 2 ] == 0xFF && data [ i + 3 ] == 0xE0 ) { i += 4 ; if ( i + 6 < data_size && data [ i + 2 ] == 'J' && data [ i + 3 ] == 'F' && data [ i + 4 ] == 'I' && data [ i + 5 ] == 'F' && data [ i + 6 ] == 0x00 ) { unsigned short block_length = data [ i ] * 256 + data [ i + 1 ] ; while ( i < data_size ) { i += block_length ; if ( ( i + 1 ) >= data_size ) return - 1 ; if ( data [ i ] != 0xFF ) return - 1 ; if ( data [ i + 1 ] == 0xC0 ) { * height = data [ i + 5 ] * 256 + data [ i + 6 ] ; * width = data [ i + 7 ] * 256 + data [ i + 8 ] ; return 0 ; } i += 2 ; <S2SV_StartBug> block_length = data [ i ] * 256 + data [ i + 1 ] ; <S2SV_EndBug> } } } return - 1 ; }
CWE-000 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> signed long personality ; <S2SV_EndBug> if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; if ( ! fetch_seccomp ( name , lxcpath , init_ctx , options ) ) WARN ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>" "namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( "could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { pid_t to_cleanup_pid = pid ; close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process" ) ; goto cleanup_error ; } if ( options -> stdin_fd == 0 ) { signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)" ) ; goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)" ) ; goto cleanup_error ; } shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( "could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }
CWE-20 void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) { u32 data , tpr ; int max_irr , max_isr ; <S2SV_StartBug> struct kvm_lapic * apic = vcpu -> arch . apic ; <S2SV_EndBug> void * vapic ; apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; tpr = kvm_apic_get_reg ( apic , APIC_TASKPRI ) & 0xff ; max_irr = apic_find_highest_irr ( apic ) ; if ( max_irr < 0 ) max_irr = 0 ; max_isr = apic_find_highest_isr ( apic ) ; if ( max_isr < 0 ) max_isr = 0 ; data = ( tpr & 0xff ) | ( ( max_isr & 0xf0 ) << 8 ) | ( max_irr << 24 ) ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ; kunmap_atomic ( vapic ) ; }
CWE-119 <S2SV_StartBug> void vp9_fht16x16_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct16x16_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 16 ] , temp_out [ 16 ] ; <S2SV_EndBug> const transform_2d ht = FHT_16 [ tx_type ] ; for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) <S2SV_StartBug> outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; <S2SV_EndBug> } for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = out [ j + i * 16 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) output [ j + i * 16 ] = temp_out [ j ] ; } } }
CWE-362 static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct net * net = sock_net ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; struct flowi4 fl4 ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; struct ip_options_data opt_copy ; struct raw_frag_vec rfv ; <S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> if ( len > 0xFFFF ) <S2SV_StartBug> goto out ; <S2SV_EndBug> err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; err = - EINVAL ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != AF_INET ) { pr_info_once ( "%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\n" , __func__ , current -> comm ) ; err = - EAFNOSUPPORT ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - EDESTADDRREQ ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; daddr = inet -> inet_daddr ; } ipc . sockc . tsflags = sk -> sk_tsflags ; ipc . addr = inet -> inet_saddr ; ipc . opt = NULL ; ipc . tx_flags = 0 ; ipc . ttl = 0 ; ipc . tos = - 1 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sk , msg , & ipc , false ) ; if ( unlikely ( err ) ) { kfree ( ipc . opt ) ; goto out ; } if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } if ( ipc . opt ) { err = - EINVAL ; <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> goto done ; if ( ipc . opt -> opt . srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> opt . faddr ; } } tos = get_rtconn_flags ( & ipc , sk ) ; if ( msg -> msg_flags & MSG_DONTROUTE ) tos |= RTO_ONLINK ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } else if ( ! ipc . oif ) ipc . oif = inet -> uc_index ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> inet_sk_flowi_flags ( sk ) | <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> daddr , saddr , 0 , 0 , sk -> sk_uid ) ; <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> rfv . msg = msg ; rfv . hlen = 0 ; err = raw_probe_proto_opt ( & rfv , & fl4 ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto done ; } err = - EACCES ; if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto done ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ; else { sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; if ( ! ipc . addr ) ipc . addr = fl4 . daddr ; lock_sock ( sk ) ; err = ip_append_data ( sk , & fl4 , raw_getfrag , & rfv , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = ip_push_pending_frames ( sk , & fl4 ) ; if ( err == - ENOBUFS && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : if ( msg -> msg_flags & MSG_PROBE ) dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
CWE-20 static int caif_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int copied = 0 ; int target ; int err = 0 ; long timeo ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> err = - EAGAIN ; if ( sk -> sk_state == CAIF_CONNECTING ) goto out ; caif_read_lock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { int chunk ; struct sk_buff * skb ; lock_sock ( sk ) ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; caif_check_flow_release ( sk ) ; if ( skb == NULL ) { if ( copied >= target ) goto unlock ; err = sock_error ( sk ) ; if ( err ) goto unlock ; err = - ECONNRESET ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) goto unlock ; err = - EPIPE ; if ( sk -> sk_state != CAIF_CONNECTED ) goto unlock ; if ( sock_flag ( sk , SOCK_DEAD ) ) goto unlock ; release_sock ( sk ) ; err = - EAGAIN ; if ( ! timeo ) break ; caif_read_unlock ( sk ) ; timeo = caif_stream_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } caif_read_lock ( sk ) ; continue ; unlock : release_sock ( sk ) ; break ; } release_sock ( sk ) ; chunk = min_t ( unsigned int , skb -> len , size ) ; if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { skb_pull ( skb , chunk ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; caif_read_unlock ( sk ) ; out : return copied ? : err ; }
CWE-000 void nlmsvc_grant_reply ( struct nlm_cookie * cookie , __be32 status ) { struct nlm_block * block ; dprintk ( "grant_reply:<S2SV_blank>looking<S2SV_blank>for<S2SV_blank>cookie<S2SV_blank>%x,<S2SV_blank>s=%d<S2SV_blank>\\n" , * ( unsigned int * ) ( cookie -> data ) , status ) ; if ( ! ( block = nlmsvc_find_block ( cookie ) ) ) return ; <S2SV_StartBug> if ( block ) { <S2SV_EndBug> if ( status == nlm_lck_denied_grace_period ) { nlmsvc_insert_block ( block , 10 * HZ ) ; } else { nlmsvc_unlink_block ( block ) ; } <S2SV_StartBug> } <S2SV_EndBug> nlmsvc_release_block ( block ) ; }
CWE-000 krb5_error_code pkinit_check_kdc_pkid ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , pkinit_identity_crypto_context id_cryptoctx , unsigned char * pdid_buf , unsigned int pkid_len , int * valid_kdcPkId ) { krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED ; PKCS7_ISSUER_AND_SERIAL * is = NULL ; const unsigned char * p = pdid_buf ; int status = 1 ; X509 * kdc_cert = sk_X509_value ( id_cryptoctx -> my_certs , id_cryptoctx -> cert_index ) ; * valid_kdcPkId = 0 ; pkiDebug ( "found<S2SV_blank>kdcPkId<S2SV_blank>in<S2SV_blank>AS<S2SV_blank>REQ\\n" ) ; is = d2i_PKCS7_ISSUER_AND_SERIAL ( NULL , & p , ( int ) pkid_len ) ; if ( is == NULL ) <S2SV_StartBug> goto cleanup ; <S2SV_EndBug> status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ; if ( ! status ) { status = ASN1_INTEGER_cmp ( X509_get_serialNumber ( kdc_cert ) , is -> serial ) ; if ( ! status ) * valid_kdcPkId = 1 ; } retval = 0 ; <S2SV_StartBug> cleanup : <S2SV_EndBug> X509_NAME_free ( is -> issuer ) ; ASN1_INTEGER_free ( is -> serial ) ; free ( is ) ; return retval ; }
CWE-000 void init_rc ( void ) { int i ; struct stat st ; FILE * f ; if ( rc_dir != NULL ) goto open_rc ; rc_dir = expandPath ( RC_DIR ) ; i = strlen ( rc_dir ) ; if ( i > 1 && rc_dir [ i - 1 ] == '/' ) rc_dir [ i - 1 ] = '\\0' ; # ifdef USE_M17N display_charset_str = wc_get_ces_list ( ) ; document_charset_str = display_charset_str ; system_charset_str = display_charset_str ; # endif if ( stat ( rc_dir , & st ) < 0 ) { if ( errno == ENOENT ) { if ( do_mkdir ( rc_dir , 0700 ) < 0 ) { goto rc_dir_err ; } else { stat ( rc_dir , & st ) ; } } else { goto rc_dir_err ; } } if ( ! S_ISDIR ( st . st_mode ) ) { goto rc_dir_err ; } if ( ! ( st . st_mode & S_IWUSR ) ) { goto rc_dir_err ; } no_rc_dir = FALSE ; tmp_dir = rc_dir ; if ( config_file == NULL ) config_file = rcFile ( CONFIG_FILE ) ; create_option_search_table ( ) ; open_rc : if ( ( f = fopen ( etcFile ( W3MCONFIG ) , "rt" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( ( f = fopen ( confFile ( CONFIG_FILE ) , "rt" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( config_file && ( f = fopen ( config_file , "rt" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } return ; rc_dir_err : no_rc_dir = TRUE ; if ( ( ( tmp_dir = getenv ( "TMPDIR" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( "TMP" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( "TEMP" ) ) == NULL || * tmp_dir == '\\0' ) ) tmp_dir = "/tmp" ; <S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> goto open_rc ; }
CWE-362 void inet_sock_destruct ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; __skb_queue_purge ( & sk -> sk_error_queue ) ; sk_mem_reclaim ( sk ) ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state != TCP_CLOSE ) { pr_err ( "Attempt<S2SV_blank>to<S2SV_blank>release<S2SV_blank>TCP<S2SV_blank>socket<S2SV_blank>in<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%p\\n" , sk -> sk_state , sk ) ; return ; } if ( ! sock_flag ( sk , SOCK_DEAD ) ) { pr_err ( "Attempt<S2SV_blank>to<S2SV_blank>release<S2SV_blank>alive<S2SV_blank>inet<S2SV_blank>socket<S2SV_blank>%p\\n" , sk ) ; return ; } WARN_ON ( atomic_read ( & sk -> sk_rmem_alloc ) ) ; WARN_ON ( atomic_read ( & sk -> sk_wmem_alloc ) ) ; WARN_ON ( sk -> sk_wmem_queued ) ; WARN_ON ( sk -> sk_forward_alloc ) ; <S2SV_StartBug> kfree ( inet -> opt ) ; <S2SV_EndBug> dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ; sk_refcnt_debug_dec ( sk ) ; }
CWE-20 static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , "%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\n" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , "%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\n" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , "<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , "\\n<%d<S2SV_blank><S2SV_blank><S2SV_blank>" , c -> sfd ) ; } fprintf ( stderr , "<S2SV_blank>0x%02x" , req -> bytes [ ii ] ) ; } fprintf ( stderr , "\\n" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , "Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\n" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , "SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; <S2SV_StartBug> if ( ! el ) <S2SV_EndBug> return 0 ; cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
CWE-119 int arm_cpu_caps ( void ) { int flags ; int mask ; if ( ! arm_cpu_env_flags ( & flags ) ) { return flags ; } mask = arm_cpu_env_mask ( ) ; <S2SV_StartBug> # if HAVE_EDSP <S2SV_EndBug> flags |= HAS_EDSP ; # endif # if HAVE_MEDIA flags |= HAS_MEDIA ; # endif <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> flags |= HAS_NEON ; # endif return flags & mask ; }
CWE-119 <S2SV_StartBug> static double get_prediction_decay_rate ( const VP9_COMMON * cm , <S2SV_EndBug> const FIRSTPASS_STATS * next_frame ) { <S2SV_StartBug> const double mb_sr_err_diff = ( next_frame -> sr_coded_error - <S2SV_EndBug> next_frame -> coded_error ) / cm -> MBs ; <S2SV_StartBug> const double second_ref_decay = mb_sr_err_diff <= 512.0 <S2SV_EndBug> <S2SV_StartBug> ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) <S2SV_EndBug> : 0.85 ; return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ; }
CWE-000 <S2SV_StartBug> struct mb_cache * <S2SV_EndBug> <S2SV_StartBug> ext4_xattr_create_cache ( char * name ) <S2SV_EndBug> { <S2SV_StartBug> return mb_cache_create ( name , HASH_BUCKET_BITS ) ; <S2SV_EndBug> }
CWE-476 int xfs_attr_shortform_to_leaf ( struct xfs_da_args * args , struct xfs_buf * * leaf_bp ) { xfs_inode_t * dp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_da_args_t nargs ; char * tmpbuffer ; int error , i , size ; xfs_dablk_t blkno ; struct xfs_buf * bp ; xfs_ifork_t * ifp ; trace_xfs_attr_sf_to_leaf ( args ) ; dp = args -> dp ; ifp = dp -> i_afp ; sf = ( xfs_attr_shortform_t * ) ifp -> if_u1 . if_data ; size = be16_to_cpu ( sf -> hdr . totsize ) ; tmpbuffer = kmem_alloc ( size , KM_SLEEP ) ; ASSERT ( tmpbuffer != NULL ) ; memcpy ( tmpbuffer , ifp -> if_u1 . if_data , size ) ; sf = ( xfs_attr_shortform_t * ) tmpbuffer ; xfs_idata_realloc ( dp , - size , XFS_ATTR_FORK ) ; xfs_bmap_local_to_extents_empty ( dp , XFS_ATTR_FORK ) ; bp = NULL ; error = xfs_da_grow_inode ( args , & blkno ) ; if ( error ) { if ( error == - EIO ) goto out ; xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ; memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ; goto out ; } ASSERT ( blkno == 0 ) ; error = xfs_attr3_leaf_create ( args , blkno , & bp ) ; if ( error ) { <S2SV_StartBug> error = xfs_da_shrink_inode ( args , 0 , bp ) ; <S2SV_EndBug> bp = NULL ; if ( error ) goto out ; xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ; memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ; goto out ; } memset ( ( char * ) & nargs , 0 , sizeof ( nargs ) ) ; nargs . dp = dp ; nargs . geo = args -> geo ; nargs . firstblock = args -> firstblock ; nargs . dfops = args -> dfops ; nargs . total = args -> total ; nargs . whichfork = XFS_ATTR_FORK ; nargs . trans = args -> trans ; nargs . op_flags = XFS_DA_OP_OKNOENT ; sfe = & sf -> list [ 0 ] ; for ( i = 0 ; i < sf -> hdr . count ; i ++ ) { nargs . name = sfe -> nameval ; nargs . namelen = sfe -> namelen ; nargs . value = & sfe -> nameval [ nargs . namelen ] ; nargs . valuelen = sfe -> valuelen ; nargs . hashval = xfs_da_hashname ( sfe -> nameval , sfe -> namelen ) ; nargs . flags = XFS_ATTR_NSP_ONDISK_TO_ARGS ( sfe -> flags ) ; error = xfs_attr3_leaf_lookup_int ( bp , & nargs ) ; ASSERT ( error == - ENOATTR ) ; error = xfs_attr3_leaf_add ( bp , & nargs ) ; ASSERT ( error != - ENOSPC ) ; if ( error ) goto out ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } error = 0 ; * leaf_bp = bp ; out : kmem_free ( tmpbuffer ) ; return error ; }
CWE-119 <S2SV_StartBug> MB_PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug> const MODE_INFO * left_mi , int b ) { if ( b == 0 || b == 2 ) { if ( ! left_mi || is_inter_block ( & left_mi -> mbmi ) ) return DC_PRED ; return get_y_mode ( left_mi , b + 1 ) ; } else { assert ( b == 1 || b == 3 ) ; return cur_mi -> bmi [ b - 1 ] . as_mode ; } }
CWE-20 static int adjust_insn_aux_data ( struct bpf_verifier_env * env , u32 prog_len , u32 off , u32 cnt ) { <S2SV_StartBug> struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; <S2SV_EndBug> if ( cnt == 1 ) return 0 ; new_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * prog_len ) ; if ( ! new_data ) return - ENOMEM ; memcpy ( new_data , old_data , sizeof ( struct bpf_insn_aux_data ) * off ) ; memcpy ( new_data + off + cnt - 1 , old_data + off , sizeof ( struct bpf_insn_aux_data ) * ( prog_len - off - cnt + 1 ) ) ; <S2SV_StartBug> env -> insn_aux_data = new_data ; <S2SV_EndBug> vfree ( old_data ) ; return 0 ; }
CWE-190 static int read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , struct _7z_folder * f , size_t numFolders ) { const unsigned char * p ; uint64_t * usizes ; size_t unpack_streams ; int type ; unsigned i ; uint32_t numDigests ; memset ( ss , 0 , sizeof ( * ss ) ) ; for ( i = 0 ; i < numFolders ; i ++ ) f [ i ] . numUnpackStreams = 1 ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kNumUnPackStream ) { unpack_streams = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) return ( - 1 ) ; <S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } else unpack_streams = numFolders ; ss -> unpack_streams = unpack_streams ; if ( unpack_streams ) { ss -> unpackSizes = calloc ( unpack_streams , sizeof ( * ss -> unpackSizes ) ) ; ss -> digestsDefined = calloc ( unpack_streams , sizeof ( * ss -> digestsDefined ) ) ; ss -> digests = calloc ( unpack_streams , sizeof ( * ss -> digests ) ) ; if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || ss -> digests == NULL ) return ( - 1 ) ; } usizes = ss -> unpackSizes ; for ( i = 0 ; i < numFolders ; i ++ ) { unsigned pack ; uint64_t sum ; if ( f [ i ] . numUnpackStreams == 0 ) continue ; sum = 0 ; if ( type == kSize ) { for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { if ( parse_7zip_uint64 ( a , usizes ) < 0 ) return ( - 1 ) ; sum += * usizes ++ ; } } * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; } if ( type == kSize ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } for ( i = 0 ; i < unpack_streams ; i ++ ) { ss -> digestsDefined [ i ] = 0 ; ss -> digests [ i ] = 0 ; } numDigests = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; } if ( type == kCRC ) { struct _7z_digests tmpDigests ; unsigned char * digestsDefined = ss -> digestsDefined ; uint32_t * digests = ss -> digests ; int di = 0 ; memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { free_Digest ( & tmpDigests ) ; return ( - 1 ) ; } for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { * digestsDefined ++ = 1 ; * digests ++ = f [ i ] . digest ; } else { unsigned j ; for ( j = 0 ; j < f [ i ] . numUnpackStreams ; j ++ , di ++ ) { * digestsDefined ++ = tmpDigests . defineds [ di ] ; * digests ++ = tmpDigests . digests [ di ] ; } } } free_Digest ( & tmpDigests ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } if ( type != kEnd ) return ( - 1 ) ; return ( 0 ) ; }
CWE-119 void vp8_optimize_mbuv ( MACROBLOCK * x ) { int b ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; if ( ! x -> e_mbd . above_context ) return ; if ( ! x -> e_mbd . left_context ) return ; <S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; for ( b = 16 ; b < 24 ; b ++ ) { optimize_b ( x , b , PLANE_TYPE_UV , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } }
CWE-189 Pairs * hstoreArrayToPairs ( ArrayType * a , int * npairs ) { Datum * key_datums ; bool * key_nulls ; int key_count ; Pairs * key_pairs ; int bufsiz ; int i , j ; deconstruct_array ( a , TEXTOID , - 1 , false , 'i' , & key_datums , & key_nulls , & key_count ) ; if ( key_count == 0 ) { * npairs = 0 ; return NULL ; } <S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> for ( i = 0 , j = 0 ; i < key_count ; i ++ ) { if ( ! key_nulls [ i ] ) { key_pairs [ j ] . key = VARDATA ( key_datums [ i ] ) ; key_pairs [ j ] . keylen = VARSIZE ( key_datums [ i ] ) - VARHDRSZ ; key_pairs [ j ] . val = NULL ; key_pairs [ j ] . vallen = 0 ; key_pairs [ j ] . needfree = 0 ; key_pairs [ j ] . isnull = 1 ; j ++ ; } } * npairs = hstoreUniquePairs ( key_pairs , j , & bufsiz ) ; return key_pairs ; }
CWE-000 <S2SV_StartBug> struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) <S2SV_EndBug> { struct nfs_inode * nfsi = NFS_I ( inode ) ; struct nfs_open_context * pos , * ctx = NULL ; spin_lock ( & inode -> i_lock ) ; list_for_each_entry ( pos , & nfsi -> open_files , list ) { if ( cred != NULL && pos -> cred != cred ) continue ; if ( ( pos -> mode & mode ) == mode ) { ctx = get_nfs_open_context ( pos ) ; break ; } } spin_unlock ( & inode -> i_lock ) ; return ctx ; }
CWE-189 static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; <S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }
CWE-200 static int sched_read_attr ( struct sched_attr __user * uattr , struct sched_attr * attr , unsigned int usize ) { int ret ; if ( ! access_ok ( VERIFY_WRITE , uattr , usize ) ) return - EFAULT ; if ( usize < sizeof ( * attr ) ) { unsigned char * addr ; unsigned char * end ; addr = ( void * ) attr + usize ; end = ( void * ) attr + sizeof ( * attr ) ; for ( ; addr < end ; addr ++ ) { if ( * addr ) goto err_size ; } attr -> size = usize ; } <S2SV_StartBug> ret = copy_to_user ( uattr , attr , usize ) ; <S2SV_EndBug> if ( ret ) return - EFAULT ; out : return ret ; err_size : ret = - E2BIG ; goto out ; }
CWE-284 static int skt_write ( int fd , const void * p , size_t len ) { int sent ; struct pollfd pfd ; FNLOG ( ) ; pfd . fd = fd ; pfd . events = POLLOUT ; <S2SV_StartBug> if ( poll ( & pfd , 1 , 500 ) == 0 ) <S2SV_EndBug> return 0 ; ts_log ( "skt_write" , len , NULL ) ; <S2SV_StartBug> if ( ( sent = send ( fd , p , len , MSG_NOSIGNAL ) ) == - 1 ) <S2SV_EndBug> { ERROR ( "write<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>errno=%d\\n" , errno ) ; return - 1 ; } return sent ; }
CWE-416 int fscrypt_setup_filename ( struct inode * dir , const struct qstr * iname , int lookup , struct fscrypt_name * fname ) { int ret = 0 , bigname = 0 ; memset ( fname , 0 , sizeof ( struct fscrypt_name ) ) ; fname -> usr_fname = iname ; if ( ! dir -> i_sb -> s_cop -> is_encrypted ( dir ) || fscrypt_is_dot_dotdot ( iname ) ) { fname -> disk_name . name = ( unsigned char * ) iname -> name ; fname -> disk_name . len = iname -> len ; return 0 ; } <S2SV_StartBug> ret = fscrypt_get_crypt_info ( dir ) ; <S2SV_EndBug> if ( ret && ret != - EOPNOTSUPP ) return ret ; if ( dir -> i_crypt_info ) { ret = fscrypt_fname_alloc_buffer ( dir , iname -> len , & fname -> crypto_buf ) ; if ( ret ) return ret ; ret = fname_encrypt ( dir , iname , & fname -> crypto_buf ) ; if ( ret ) goto errout ; fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; return 0 ; } if ( ! lookup ) return - ENOKEY ; if ( iname -> name [ 0 ] == '_' ) bigname = 1 ; if ( ( bigname && ( iname -> len != 33 ) ) || ( ! bigname && ( iname -> len > 43 ) ) ) return - ENOENT ; fname -> crypto_buf . name = kmalloc ( 32 , GFP_KERNEL ) ; if ( fname -> crypto_buf . name == NULL ) return - ENOMEM ; ret = digest_decode ( iname -> name + bigname , iname -> len - bigname , fname -> crypto_buf . name ) ; if ( ret < 0 ) { ret = - ENOENT ; goto errout ; } fname -> crypto_buf . len = ret ; if ( bigname ) { memcpy ( & fname -> hash , fname -> crypto_buf . name , 4 ) ; memcpy ( & fname -> minor_hash , fname -> crypto_buf . name + 4 , 4 ) ; } else { fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; } return 0 ; errout : fscrypt_fname_free_buffer ( & fname -> crypto_buf ) ; return ret ; }
CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if <S2SV_EndBug> ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
CWE-119 static vpx_image_t * encoder_get_preview ( vpx_codec_alg_priv_t * ctx ) { YV12_BUFFER_CONFIG sd ; <S2SV_StartBug> vp9_ppflags_t flags = { 0 } ; <S2SV_EndBug> if ( ctx -> preview_ppcfg . post_proc_flag ) { flags . post_proc_flag = ctx -> preview_ppcfg . post_proc_flag ; flags . deblocking_level = ctx -> preview_ppcfg . deblocking_level ; flags . noise_level = ctx -> preview_ppcfg . noise_level ; } if ( vp9_get_preview_raw_frame ( ctx -> cpi , & sd , & flags ) == 0 ) { yuvconfig2image ( & ctx -> preview_img , & sd , NULL ) ; return & ctx -> preview_img ; } else { return NULL ; } }
CWE-200 int udpv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; <S2SV_StartBug> bool slow ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( struct sockaddr_in6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { struct sockaddr_in6 * sin6 ; sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ; } <S2SV_StartBug> } <S2SV_EndBug> if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; if ( noblock ) return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
CWE-000 static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , struct iovec * iovec ) { <S2SV_StartBug> if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) ) <S2SV_EndBug> return - EFAULT ; iovec -> iov_base = buf ; <S2SV_StartBug> iovec -> iov_len = kiocb -> ki_nbytes ; <S2SV_EndBug> * nr_segs = 1 ; return 0 ; }
CWE-399 int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; <S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) return chg ; <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return - ENOSPC ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }
CWE-399 void hugetlb_unreserve_pages ( struct inode * inode , long offset , long freed ) { struct hstate * h = hstate_inode ( inode ) ; long chg = region_truncate ( & inode -> i_mapping -> private_list , offset ) ; <S2SV_StartBug> spin_lock ( & inode -> i_lock ) ; <S2SV_EndBug> inode -> i_blocks -= ( blocks_per_huge_page ( h ) * freed ) ; spin_unlock ( & inode -> i_lock ) ; <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , ( chg - freed ) ) ; <S2SV_EndBug> hugetlb_acct_memory ( h , - ( chg - freed ) ) ; }
CWE-000 static int cypress_generic_port_probe ( struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct cypress_private * priv ; <S2SV_StartBug> priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! priv ) return - ENOMEM ; priv -> comm_is_ok = ! 0 ; spin_lock_init ( & priv -> lock ) ; if ( kfifo_alloc ( & priv -> write_fifo , CYPRESS_BUF_SIZE , GFP_KERNEL ) ) { kfree ( priv ) ; return - ENOMEM ; } if ( ! is_frwd ( serial -> dev ) ) usb_reset_configuration ( serial -> dev ) ; priv -> cmd_ctrl = 0 ; priv -> line_control = 0 ; priv -> termios_initialized = 0 ; priv -> rx_flags = 0 ; if ( port -> interrupt_out_size > 9 ) priv -> pkt_fmt = packet_format_1 ; else priv -> pkt_fmt = packet_format_2 ; if ( interval > 0 ) { priv -> write_urb_interval = interval ; priv -> read_urb_interval = interval ; dev_dbg ( & port -> dev , "%s<S2SV_blank>-<S2SV_blank>read<S2SV_blank>&<S2SV_blank>write<S2SV_blank>intervals<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>%d\\n" , __func__ , interval ) ; } else { priv -> write_urb_interval = port -> interrupt_out_urb -> interval ; priv -> read_urb_interval = port -> interrupt_in_urb -> interval ; dev_dbg ( & port -> dev , "%s<S2SV_blank>-<S2SV_blank>intervals:<S2SV_blank>read=%d<S2SV_blank>write=%d\\n" , __func__ , priv -> read_urb_interval , priv -> write_urb_interval ) ; } usb_set_serial_port_data ( port , priv ) ; port -> port . drain_delay = 256 ; return 0 ; }
CWE-20 int auth_password ( Authctxt * authctxt , const char * password ) { struct passwd * pw = authctxt -> pw ; int result , ok = authctxt -> valid ; # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) static int expire_checked = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ; # endif if ( * password == '\\0' && options . permit_empty_passwd == 0 ) return 0 ; # ifdef KRB5 if ( options . kerberos_authentication == 1 ) { int ret = auth_krb5_password ( authctxt , password ) ; if ( ret == 1 || ret == 0 ) return ret && ok ; } # endif # ifdef HAVE_CYGWIN { HANDLE hToken = cygwin_logon_user ( pw , password ) ; if ( hToken == INVALID_HANDLE_VALUE ) return 0 ; cygwin_set_impersonation_token ( hToken ) ; return ok ; } # endif # ifdef USE_PAM if ( options . use_pam ) return ( sshpam_auth_passwd ( authctxt , password ) && ok ) ; # endif # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) if ( ! expire_checked ) { expire_checked = 1 ; if ( auth_shadow_pwexpired ( authctxt ) ) authctxt -> force_pwchange = 1 ; } # endif result = sys_auth_passwd ( authctxt , password ) ; if ( authctxt -> force_pwchange ) disable_forwarding ( ) ; return ( result && ok ) ; }
CWE-000 ssize_t tcp_splice_read ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) { struct sock * sk = sock -> sk ; struct tcp_splice_state tss = { . pipe = pipe , . len = len , . flags = flags , } ; long timeo ; ssize_t spliced ; int ret ; sock_rps_record_flow ( sk ) ; if ( unlikely ( * ppos ) ) return - ESPIPE ; ret = spliced = 0 ; lock_sock ( sk ) ; timeo = sock_rcvtimeo ( sk , sock -> file -> f_flags & O_NONBLOCK ) ; while ( tss . len ) { ret = __tcp_splice_read ( sk , & tss ) ; if ( ret < 0 ) break ; else if ( ! ret ) { if ( spliced ) break ; if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { ret = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) ret = - ENOTCONN ; break ; } if ( ! timeo ) { ret = - EAGAIN ; break ; } <S2SV_StartBug> sk_wait_data ( sk , & timeo , NULL ) ; <S2SV_EndBug> if ( signal_pending ( current ) ) { ret = sock_intr_errno ( timeo ) ; break ; } continue ; } tss . len -= ret ; spliced += ret ; if ( ! timeo ) break ; release_sock ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || signal_pending ( current ) ) break ; } release_sock ( sk ) ; if ( spliced ) return spliced ; return ret ; }
CWE-119 static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , <S2SV_StartBug> vp8_decrypt_cb * decrypt_cb , <S2SV_EndBug> void * decrypt_state ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( data + data_sz <= data ) { res = VPX_CODEC_INVALID_PARAM ; } else { uint8_t clear_buffer [ 10 ] ; const uint8_t * clear = data ; if ( decrypt_cb ) { <S2SV_StartBug> int n = data_sz > 10 ? 10 : data_sz ; <S2SV_EndBug> decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } si -> is_kf = 0 ; if ( data_sz >= 10 && ! ( clear [ 0 ] & 0x01 ) ) { si -> is_kf = 1 ; if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ; if ( ! ( si -> h | si -> w ) ) res = VPX_CODEC_UNSUP_BITSTREAM ; } else { res = VPX_CODEC_UNSUP_BITSTREAM ; } } return res ; }
CWE-000 void processInputBuffer ( client * c ) { server . current_client = c ; while ( sdslen ( c -> querybuf ) ) { if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ; if ( c -> flags & CLIENT_BLOCKED ) break ; <S2SV_StartBug> if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ; <S2SV_EndBug> if ( ! c -> reqtype ) { if ( c -> querybuf [ 0 ] == '*' ) { c -> reqtype = PROTO_REQ_MULTIBULK ; } else { c -> reqtype = PROTO_REQ_INLINE ; } } if ( c -> reqtype == PROTO_REQ_INLINE ) { if ( processInlineBuffer ( c ) != C_OK ) break ; } else if ( c -> reqtype == PROTO_REQ_MULTIBULK ) { if ( processMultibulkBuffer ( c ) != C_OK ) break ; } else { serverPanic ( "Unknown<S2SV_blank>request<S2SV_blank>type" ) ; } if ( c -> argc == 0 ) { resetClient ( c ) ; } else { if ( processCommand ( c ) == C_OK ) resetClient ( c ) ; if ( server . current_client == NULL ) break ; } } server . current_client = NULL ; }
CWE-125 static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)" , tok2str ( bacconfopts_values , "Unknown" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( bacconfopts_values , "Unknown" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , "[|bacp]" ) ) ; return 0 ; }
CWE-399 static void update_exception_bitmap ( struct kvm_vcpu * vcpu ) { u32 eb ; eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | <S2SV_StartBug> ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) ; <S2SV_EndBug> if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ; if ( to_vmx ( vcpu ) -> rmode . vm86_active ) eb = ~ 0 ; if ( enable_ept ) eb &= ~ ( 1u << PF_VECTOR ) ; if ( vcpu -> fpu_active ) eb &= ~ ( 1u << NM_VECTOR ) ; if ( is_guest_mode ( vcpu ) ) eb |= get_vmcs12 ( vcpu ) -> exception_bitmap ; vmcs_write32 ( EXCEPTION_BITMAP , eb ) ; }
CWE-362 static ssize_t driver_override_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) { struct platform_device * pdev = to_platform_device ( dev ) ; <S2SV_StartBug> char * driver_override , * old = pdev -> driver_override , * cp ; <S2SV_EndBug> if ( count > PATH_MAX ) return - EINVAL ; driver_override = kstrndup ( buf , count , GFP_KERNEL ) ; if ( ! driver_override ) return - ENOMEM ; cp = strchr ( driver_override , '\\n' ) ; if ( cp ) * cp = '\\0' ; <S2SV_StartBug> if ( strlen ( driver_override ) ) { <S2SV_EndBug> pdev -> driver_override = driver_override ; } else { kfree ( driver_override ) ; pdev -> driver_override = NULL ; } <S2SV_StartBug> kfree ( old ) ; <S2SV_EndBug> return count ; }
CWE-362 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags ) { struct mm_struct * mm = vma -> vm_mm ; struct dev_pagemap * pgmap = NULL ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; <S2SV_StartBug> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <S2SV_EndBug> pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { pgmap = get_dev_pagemap ( pte_pfn ( pte ) , NULL ) ; if ( pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) { get_page ( page ) ; if ( pgmap ) { put_dev_pagemap ( pgmap ) ; pgmap = NULL ; } } if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }
CWE-362 static inline int ldsem_cmpxchg ( long * old , long new , struct ld_semaphore * sem ) { <S2SV_StartBug> long tmp = * old ; <S2SV_EndBug> * old = atomic_long_cmpxchg ( & sem -> count , * old , new ) ; <S2SV_StartBug> return * old == tmp ; <S2SV_EndBug> }
CWE-189 static void tcp_illinois_info ( struct sock * sk , u32 ext , struct sk_buff * skb ) { const struct illinois * ca = inet_csk_ca ( sk ) ; if ( ext & ( 1 << ( INET_DIAG_VEGASINFO - 1 ) ) ) { struct tcpvegas_info info = { . tcpv_enabled = 1 , . tcpv_rttcnt = ca -> cnt_rtt , . tcpv_minrtt = ca -> base_rtt , } ; <S2SV_StartBug> u64 t = ca -> sum_rtt ; <S2SV_EndBug> <S2SV_StartBug> do_div ( t , ca -> cnt_rtt ) ; <S2SV_EndBug> <S2SV_StartBug> info . tcpv_rtt = t ; <S2SV_EndBug> nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ; } }
CWE-119 static int nl80211_trigger_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct cfg80211_scan_request * request ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; enum ieee80211_band band ; size_t ie_len ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( ! rdev -> ops -> scan ) return - EOPNOTSUPP ; if ( rdev -> scan_req ) return - EBUSY ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; rdev -> scan_req = request ; err = rdev -> ops -> scan ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { nl80211_send_scan_start ( rdev , dev ) ; dev_hold ( dev ) ; } else { out_free : rdev -> scan_req = NULL ; kfree ( request ) ; } return err ; }
CWE-119 static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ; <S2SV_StartBug> int pixel_ptr = 0 ; <S2SV_EndBug> int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , "First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , "MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode & 0x1f ) + 1 ; if ( ( opcode & 0x80 ) == 0 ) { colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; opcode = 0 ; if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { opcode = 0x20 ; n_blocks = 1 ; } } switch ( opcode & 0xe0 ) { case 0x80 : while ( n_blocks -- ) { ADVANCE_BLOCK ( ) ; } break ; case 0xa0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; while ( n_blocks -- ) { <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> } break ; case 0xc0 : colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; case 0x20 : colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; color4 [ 0 ] = colorB ; color4 [ 1 ] = 0 ; color4 [ 2 ] = 0 ; color4 [ 3 ] = colorA ; ta = ( colorA >> 10 ) & 0x1F ; tb = ( colorB >> 10 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; ta = ( colorA >> 5 ) & 0x1F ; tb = ( colorB >> 5 ) & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; ta = colorA & 0x1F ; tb = colorB & 0x1F ; color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; if ( s -> size - stream_ptr < n_blocks * 4 ) return ; while ( n_blocks -- ) { <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { index = s -> buf [ stream_ptr ++ ] ; for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; pixels [ block_ptr ] = color4 [ idx ] ; block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> } break ; case 0x00 : if ( s -> size - stream_ptr < 16 ) return ; <S2SV_StartBug> block_ptr = row_ptr + pixel_ptr ; <S2SV_EndBug> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; stream_ptr += 2 ; } pixels [ block_ptr ] = colorA ; block_ptr ++ ; } block_ptr += row_inc ; } <S2SV_StartBug> ADVANCE_BLOCK ( ) ; <S2SV_EndBug> break ; default : av_log ( s -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk." "<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n" , opcode , chunk_size - stream_ptr ) ; return ; } } }
CWE-362 int ext4_collapse_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t punch_start , punch_stop ; handle_t * handle ; unsigned int credits ; loff_t new_size , ioffset ; int ret ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; trace_ext4_collapse_range ( inode , offset , len ) ; punch_start = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; punch_stop = ( offset + len ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( offset + len >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } <S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; ret = ext4_es_remove_extent ( inode , punch_start , EXT_MAX_BLOCKS - punch_start ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_remove_space ( inode , punch_start , punch_stop - 1 ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ext4_discard_preallocations ( inode ) ; ret = ext4_ext_shift_extents ( inode , handle , punch_stop , punch_stop - punch_start , SHIFT_LEFT ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } new_size = i_size_read ( inode ) - len ; i_size_write ( inode , new_size ) ; EXT4_I ( inode ) -> i_disksize = new_size ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; out_stop : ext4_journal_stop ( handle ) ; <S2SV_StartBug> out_dio : <S2SV_EndBug> ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
CWE-000 unsigned int get_random_int ( void ) { <S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> __u32 * hash = get_cpu_var ( get_random_int_hash ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> keyptr = get_keyptr ( ) ; hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ; <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> put_cpu_var ( get_random_int_hash ) ; return ret ; }
CWE-264 static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = "Getting<S2SV_blank>sb<S2SV_blank>failed" ; struct inode * inode ; struct path path ; <S2SV_StartBug> int rc ; <S2SV_EndBug> sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } <S2SV_StartBug> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <S2SV_EndBug> if ( rc ) { err = "Error<S2SV_blank>parsing<S2SV_blank>options" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } s -> s_flags = flags ; rc = bdi_setup_and_register ( & sbi -> bdi , "ecryptfs" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = "Reading<S2SV_blank>sb<S2SV_blank>failed" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , "kern_path()<S2SV_blank>failed\\n" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR "Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>" "eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>" "known<S2SV_blank>incompatibilities\\n" ) ; goto out_free ; } <S2SV_StartBug> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; <S2SV_EndBug> s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; rc = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto out_free ; s -> s_root = d_alloc_root ( inode ) ; if ( ! s -> s_root ) { iput ( inode ) ; rc = - ENOMEM ; goto out_free ; } rc = - ENOMEM ; root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; if ( ! root_info ) goto out_free ; ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; ecryptfs_set_dentry_lower ( s -> s_root , path . dentry ) ; ecryptfs_set_dentry_lower_mnt ( s -> s_root , path . mnt ) ; s -> s_flags |= MS_ACTIVE ; return dget ( s -> s_root ) ; out_free : path_put ( & path ) ; out1 : deactivate_locked_super ( s ) ; out : if ( sbi ) { ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; } printk ( KERN_ERR "%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , err , rc ) ; return ERR_PTR ( rc ) ; }
CWE-119 <S2SV_StartBug> void vp9_entropy_mv_init ( ) { <S2SV_EndBug> vp9_tokens_from_tree ( mv_joint_encodings , vp9_mv_joint_tree ) ; vp9_tokens_from_tree ( mv_class_encodings , vp9_mv_class_tree ) ; vp9_tokens_from_tree ( mv_class0_encodings , vp9_mv_class0_tree ) ; vp9_tokens_from_tree ( mv_fp_encodings , vp9_mv_fp_tree ) ; }
CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { uint32_t loc ; struct sparingTable * st ; struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( "Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( "Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( "Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( "Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( "Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( "Flags:<S2SV_blank>%d<S2SV_blank>%d\\n" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( "Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( "Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( "FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
CWE-20 static int snd_hrtimer_start ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ; <S2SV_StartBug> hrtimer_cancel ( & stime -> hrt ) ; <S2SV_EndBug> hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ; atomic_set ( & stime -> running , 1 ) ; return 0 ; }
CWE-399 static int nlmsg_populate_mdb_fill ( struct sk_buff * skb , struct net_device * dev , struct br_mdb_entry * entry , u32 pid , u32 seq , int type , unsigned int flags ) { struct nlmsghdr * nlh ; struct br_port_msg * bpm ; struct nlattr * nest , * nest2 ; nlh = nlmsg_put ( skb , pid , seq , type , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( ! nlh ) return - EMSGSIZE ; bpm = nlmsg_data ( nlh ) ; <S2SV_StartBug> bpm -> family = AF_BRIDGE ; <S2SV_EndBug> bpm -> ifindex = dev -> ifindex ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) goto cancel ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) goto end ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( * entry ) , entry ) ) goto end ; nla_nest_end ( skb , nest2 ) ; nla_nest_end ( skb , nest ) ; return nlmsg_end ( skb , nlh ) ; end : nla_nest_end ( skb , nest ) ; cancel : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }
CWE-264 static int <S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> struct perf_event * event ) { <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ; <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> }
CWE-284 static int ndp_sock_recv ( struct ndp * ndp ) { struct ndp_msg * msg ; enum ndp_msg_type msg_type ; size_t len ; int err ; msg = ndp_msg_alloc ( ) ; if ( ! msg ) return - ENOMEM ; len = ndp_msg_payload_maxlen ( msg ) ; err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 , <S2SV_StartBug> & msg -> addrto , & msg -> ifindex ) ; <S2SV_EndBug> if ( err ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message" ) ; goto free_msg ; } <S2SV_StartBug> dbg ( ndp , "rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u" , <S2SV_EndBug> <S2SV_StartBug> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <S2SV_EndBug> if ( len < sizeof ( * msg -> icmp6_hdr ) ) { warn ( ndp , "rcvd<S2SV_blank>icmp6<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>short<S2SV_blank>(%luB)" , len ) ; err = 0 ; goto free_msg ; } err = ndp_msg_type_by_raw_type ( & msg_type , msg -> icmp6_hdr -> icmp6_type ) ; if ( err ) { err = 0 ; goto free_msg ; } ndp_msg_init ( msg , msg_type ) ; ndp_msg_payload_len_set ( msg , len ) ; if ( ! ndp_msg_check_valid ( msg ) ) { warn ( ndp , "rcvd<S2SV_blank>invalid<S2SV_blank>ND<S2SV_blank>message" ) ; err = 0 ; goto free_msg ; } dbg ( ndp , "rcvd<S2SV_blank>%s,<S2SV_blank>len:<S2SV_blank>%zuB" , ndp_msg_type_info ( msg_type ) -> strabbr , len ) ; if ( ! ndp_msg_check_opts ( msg ) ) { err = 0 ; goto free_msg ; } err = ndp_call_handlers ( ndp , msg ) ; ; free_msg : ndp_msg_destroy ( msg ) ; return err ; }
CWE-20 static void _out_result ( conn_t out , nad_t nad ) { int attr ; jid_t from , to ; char * rkey ; int rkeylen ; attr = nad_find_attr ( nad , 0 , - 1 , "from" , NULL ) ; if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , "missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>from<S2SV_blank>on<S2SV_blank>db<S2SV_blank>result<S2SV_blank>packet" ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , "to" , NULL ) ; if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , "missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>to<S2SV_blank>on<S2SV_blank>db<S2SV_blank>result<S2SV_blank>packet" ) ; jid_free ( from ) ; nad_free ( nad ) ; return ; } rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; rkeylen = strlen ( rkey ) ; <S2SV_StartBug> if ( nad_find_attr ( nad , 0 , - 1 , "type" , "valid" ) >= 0 ) { <S2SV_EndBug> log_write ( out -> s2s -> log , LOG_NOTICE , "[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? ",<S2SV_blank>TLS<S2SV_blank>negotiated" : "" , out -> s -> compressed ? ",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled" : "" ) ; xhash_put ( out -> states , pstrdup ( xhash_pool ( out -> states ) , rkey ) , ( void * ) conn_VALID ) ; log_debug ( ZONE , "%s<S2SV_blank>valid,<S2SV_blank>flushing<S2SV_blank>queue" , rkey ) ; out_flush_route_queue ( out -> s2s , rkey , rkeylen ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } log_write ( out -> s2s -> log , LOG_NOTICE , "[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>invalid" , out -> fd -> fd , out -> ip , out -> port , rkey ) ; log_write ( out -> s2s -> log , LOG_NOTICE , "[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>closing<S2SV_blank>connection" , out -> fd -> fd , out -> ip , out -> port ) ; sx_error ( out -> s , stream_err_INVALID_ID , "dialback<S2SV_blank>negotiation<S2SV_blank>failed" ) ; sx_close ( out -> s ) ; out_bounce_route_queue ( out -> s2s , rkey , rkeylen , stanza_err_SERVICE_UNAVAILABLE ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; }
CWE-284 BOOLEAN UIPC_Send ( tUIPC_CH_ID ch_id , UINT16 msg_evt , UINT8 * p_buf , UINT16 msglen ) { UNUSED ( msg_evt ) ; BTIF_TRACE_DEBUG ( "UIPC_Send<S2SV_blank>:<S2SV_blank>ch_id:%d<S2SV_blank>%d<S2SV_blank>bytes" , ch_id , msglen ) ; UIPC_LOCK ( ) ; <S2SV_StartBug> if ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) < 0 ) <S2SV_EndBug> { BTIF_TRACE_ERROR ( "failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>(%s)" , strerror ( errno ) ) ; } UIPC_UNLOCK ( ) ; return FALSE ; }
CWE-119 static int read_skip ( VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_StartBug> int segment_id , vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) { <S2SV_EndBug> return 1 ; } else { const int ctx = vp9_get_skip_context ( xd ) ; <S2SV_StartBug> const int skip = vp9_read ( r , cm -> fc . skip_probs [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . skip [ ctx ] [ skip ] ; return skip ; } }
CWE-000 static inline int process_nested_data ( UNSERIALIZE_PARAMETER , HashTable * ht , long elements , int objprops ) { while ( elements -- > 0 ) { zval * key , * data , * * old_data ; ALLOC_INIT_ZVAL ( key ) ; if ( ! php_var_unserialize ( & key , p , max , NULL TSRMLS_CC ) ) { zval_dtor ( key ) ; FREE_ZVAL ( key ) ; return 0 ; } if ( Z_TYPE_P ( key ) != IS_LONG && Z_TYPE_P ( key ) != IS_STRING ) { zval_dtor ( key ) ; FREE_ZVAL ( key ) ; return 0 ; } ALLOC_INIT_ZVAL ( data ) ; if ( ! php_var_unserialize ( & data , p , max , var_hash TSRMLS_CC ) ) { zval_dtor ( key ) ; FREE_ZVAL ( key ) ; zval_dtor ( data ) ; FREE_ZVAL ( data ) ; return 0 ; } if ( ! objprops ) { switch ( Z_TYPE_P ( key ) ) { case IS_LONG : if ( zend_hash_index_find ( ht , Z_LVAL_P ( key ) , ( void * * ) & old_data ) == SUCCESS ) { var_push_dtor ( var_hash , old_data ) ; } zend_hash_index_update ( ht , Z_LVAL_P ( key ) , & data , sizeof ( data ) , NULL ) ; break ; case IS_STRING : if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { var_push_dtor ( var_hash , old_data ) ; } zend_symtable_update ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , & data , sizeof ( data ) , NULL ) ; break ; } } else { convert_to_string ( key ) ; <S2SV_StartBug> if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { <S2SV_EndBug> var_push_dtor ( var_hash , old_data ) ; } zend_hash_update ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , & data , sizeof data , NULL ) ; } zval_dtor ( key ) ; FREE_ZVAL ( key ) ; if ( elements && * ( * p - 1 ) != ';' && * ( * p - 1 ) != '}' ) { ( * p ) -- ; return 0 ; } } return 1 ; }
CWE-119 static void videobuf_vm_open ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; <S2SV_StartBug> dprintk ( 2 , "vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n" , map , <S2SV_EndBug> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count ++ ; }
CWE-416 static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * daddr , * final_p , final ; struct dst_entry * dst ; struct flowi6 fl6 ; struct ip6_flowlabel * flowlabel = NULL ; struct ipv6_txoptions * opt ; int addr_type ; int err ; if ( usin -> sin6_family == AF_INET ) { if ( __ipv6_only_sock ( sk ) ) return - EAFNOSUPPORT ; err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; goto ipv4_connected ; } if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type == IPV6_ADDR_ANY ) { usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; } daddr = & usin -> sin6_addr ; if ( addr_type == IPV6_ADDR_MAPPED ) { struct sockaddr_in sin ; if ( __ipv6_only_sock ( sk ) ) { err = - ENETUNREACH ; goto out ; } sin . sin_family = AF_INET ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; sin . sin_port = usin -> sin6_port ; err = __ip4_datagram_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; ipv4_connected : if ( err ) goto out ; ipv6_addr_set_v4mapped ( inet -> inet_daddr , & sk -> sk_v6_daddr ) ; if ( ipv6_addr_any ( & np -> saddr ) || ipv6_mapped_addr_any ( & np -> saddr ) ) ipv6_addr_set_v4mapped ( inet -> inet_saddr , & np -> saddr ) ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) || ipv6_mapped_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { ipv6_addr_set_v4mapped ( inet -> inet_rcv_saddr , & sk -> sk_v6_rcv_saddr ) ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } goto out ; } if ( __ipv6_addr_needs_scope_id ( addr_type ) ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) { err = - EINVAL ; goto out ; } sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if && ( addr_type & IPV6_ADDR_MULTICAST ) ) sk -> sk_bound_dev_if = np -> mcast_oif ; if ( ! sk -> sk_bound_dev_if ) { err = - EINVAL ; goto out ; } } sk -> sk_v6_daddr = * daddr ; np -> flow_label = fl6 . flowlabel ; inet -> inet_dport = usin -> sin6_port ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; if ( ! fl6 . flowi6_oif && ( addr_type & IPV6_ADDR_MULTICAST ) ) fl6 . flowi6_oif = np -> mcast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; err = 0 ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( ipv6_addr_any ( & np -> saddr ) ) np -> saddr = fl6 . saddr ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { sk -> sk_v6_rcv_saddr = fl6 . saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL , # ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr : # endif NULL ) ; sk -> sk_state = TCP_ESTABLISHED ; sk_set_txhash ( sk ) ; out : fl6_sock_release ( flowlabel ) ; return err ; }
CWE-119 void vp8_copy_mem8x4_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 4 ; r ++ ) { <S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; # else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; # endif src += src_stride ; dst += dst_stride ; } }
CWE-119 static int wdm_post_reset ( struct usb_interface * intf ) { struct wdm_device * desc = wdm_find_device ( intf ) ; <S2SV_StartBug> int rv ; <S2SV_EndBug> clear_bit ( WDM_RESETTING , & desc -> flags ) ; rv = recover_from_urb_loss ( desc ) ; mutex_unlock ( & desc -> wlock ) ; mutex_unlock ( & desc -> rlock ) ; return 0 ; }
CWE-000 static int nsv_parse_NSVf_header ( AVFormatContext * s ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; unsigned int av_unused file_size ; unsigned int size ; int64_t duration ; int strings_size ; int table_entries ; int table_entries_used ; nsv -> state = NSV_UNSYNC ; size = avio_rl32 ( pb ) ; if ( size < 28 ) return - 1 ; nsv -> NSVf_end = size ; file_size = ( uint32_t ) avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n" , size ) ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n" , file_size ) ; nsv -> duration = duration = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%" PRId64 "<S2SV_blank>ms\\n" , duration ) ; strings_size = avio_rl32 ( pb ) ; table_entries = avio_rl32 ( pb ) ; table_entries_used = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n" , strings_size , table_entries , table_entries_used ) ; if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; if ( strings_size > 0 ) { char * strings ; char * p , * endp ; char * token , * value ; char quote ; p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ; if ( ! p ) return AVERROR ( ENOMEM ) ; endp = strings + strings_size ; avio_read ( pb , strings , strings_size ) ; while ( p < endp ) { while ( * p == '<S2SV_blank>' ) p ++ ; if ( p >= endp - 2 ) break ; token = p ; p = strchr ( p , '=' ) ; if ( ! p || p >= endp - 2 ) break ; * p ++ = '\\0' ; quote = * p ++ ; value = p ; p = strchr ( p , quote ) ; if ( ! p || p >= endp ) break ; * p ++ = '\\0' ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n" , token , value ) ; av_dict_set ( & s -> metadata , token , value , 0 ) ; } av_free ( strings ) ; } if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; if ( table_entries_used > 0 ) { int i ; nsv -> index_entries = table_entries_used ; if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) return - 1 ; nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_file_offset ) return AVERROR ( ENOMEM ) ; <S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_timestamps ) return AVERROR ( ENOMEM ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; } } } av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; if ( avio_feof ( pb ) ) return - 1 ; nsv -> state = NSV_HAS_READ_NSVF ; return 0 ; }
CWE-119 static void output_stats ( const VP8_COMP * cpi , struct vpx_codec_pkt_list * pktlist , FIRSTPASS_STATS * stats ) { struct vpx_codec_cx_pkt pkt ; <S2SV_StartBug> pkt . kind = VPX_CODEC_STATS_PKT ; <S2SV_EndBug> pkt . data . twopass_stats . buf = stats ; pkt . data . twopass_stats . sz = sizeof ( FIRSTPASS_STATS ) ; vpx_codec_pkt_list_add ( pktlist , & pkt ) ; # if OUTPUT_FPF { FILE * fpfile ; fpfile = fopen ( "firstpass.stt" , "a" ) ; fprintf ( fpfile , "%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f" "<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f<S2SV_blank>%12.4f" "<S2SV_blank>%12.0f<S2SV_blank>%12.0f<S2SV_blank>%12.4f\\n" , stats -> frame , stats -> intra_error , stats -> coded_error , stats -> ssim_weighted_pred_err , stats -> pcnt_inter , stats -> pcnt_motion , stats -> pcnt_second_ref , stats -> pcnt_neutral , stats -> MVr , stats -> mvr_abs , stats -> MVc , stats -> mvc_abs , stats -> MVrv , stats -> MVcv , stats -> mv_in_out_count , stats -> new_mv_count , stats -> count , stats -> duration ) ; fclose ( fpfile ) ; } # endif }
CWE-476 static GsfInfileTar * tar_directory_for_file ( GsfInfileTar * dir , const char * name , gboolean last ) { const char * s = name ; while ( 1 ) { const char * s0 = s ; char * dirname ; while ( 1 ) { if ( * s == 0 ) { if ( last && s != s0 ) break ; else return dir ; } if ( * s == '/' ) break ; s ++ ; } dirname = g_strndup ( s0 , s - s0 ) ; while ( * s == '/' ) s ++ ; if ( strcmp ( dirname , "." ) != 0 ) { GsfInput * subdir = gsf_infile_child_by_name ( GSF_INFILE ( dir ) , dirname ) ; if ( subdir ) { <S2SV_StartBug> g_object_unref ( subdir ) ; <S2SV_EndBug> <S2SV_StartBug> dir = GSF_INFILE_TAR ( subdir ) ; <S2SV_EndBug> } else dir = tar_create_dir ( dir , dirname ) ; } g_free ( dirname ) ; } }
CWE-190 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; sig_none = timr -> it_sigev_notify == SIGEV_NONE ; iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) <S2SV_StartBug> timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ; <S2SV_EndBug> remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
CWE-000 static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) { <S2SV_StartBug> int start = 0 ; <S2SV_EndBug> u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ; <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }
CWE-119 <S2SV_StartBug> static void fdct4 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int16_t step [ 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int temp1 , temp2 ; <S2SV_EndBug> step [ 0 ] = input [ 0 ] + input [ 3 ] ; step [ 1 ] = input [ 1 ] + input [ 2 ] ; step [ 2 ] = input [ 1 ] - input [ 2 ] ; step [ 3 ] = input [ 0 ] - input [ 3 ] ; temp1 = ( step [ 0 ] + step [ 1 ] ) * cospi_16_64 ; temp2 = ( step [ 0 ] - step [ 1 ] ) * cospi_16_64 ; <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> output [ 2 ] = fdct_round_shift ( temp2 ) ; temp1 = step [ 2 ] * cospi_24_64 + step [ 3 ] * cospi_8_64 ; temp2 = - step [ 2 ] * cospi_8_64 + step [ 3 ] * cospi_24_64 ; <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( temp1 ) ; <S2SV_EndBug> output [ 3 ] = fdct_round_shift ( temp2 ) ; }
CWE-264 static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }
CWE-000 static int pop_fetch_headers ( struct Context * ctx ) { struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif time ( & pop_data -> check_time ) ; pop_data -> clear_cache = false ; for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) ctx -> hdrs [ i ] -> refno = - 1 ; const int old_count = ctx -> msgcount ; int ret = pop_fetch_data ( pop_data , "UIDL\\r\\n" , NULL , fetch_uidl , ctx ) ; const int new_count = ctx -> msgcount ; ctx -> msgcount = old_count ; if ( pop_data -> cmd_uidl == 2 ) { if ( ret == 0 ) { pop_data -> cmd_uidl = 1 ; mutt_debug ( 1 , "set<S2SV_blank>UIDL<S2SV_blank>capability\\n" ) ; } if ( ret == - 2 && pop_data -> cmd_uidl == 2 ) { pop_data -> cmd_uidl = 0 ; mutt_debug ( 1 , "unset<S2SV_blank>UIDL<S2SV_blank>capability\\n" ) ; snprintf ( pop_data -> err_msg , sizeof ( pop_data -> err_msg ) , "%s" , _ ( "Command<S2SV_blank>UIDL<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server." ) ) ; } } if ( ! ctx -> quiet ) { mutt_progress_init ( & progress , _ ( "Fetching<S2SV_blank>message<S2SV_blank>headers..." ) , MUTT_PROGRESS_MSG , ReadInc , new_count - old_count ) ; } if ( ret == 0 ) { int i , deleted ; for ( i = 0 , deleted = 0 ; i < old_count ; i ++ ) { if ( ctx -> hdrs [ i ] -> refno == - 1 ) { ctx -> hdrs [ i ] -> deleted = true ; deleted ++ ; } } if ( deleted > 0 ) { mutt_error ( ngettext ( "%d<S2SV_blank>message<S2SV_blank>has<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." , "%d<S2SV_blank>messages<S2SV_blank>have<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." , deleted ) , deleted ) ; } bool hcached = false ; for ( i = old_count ; i < new_count ; i ++ ) { if ( ! ctx -> quiet ) mutt_progress_update ( & progress , i + 1 - old_count , - 1 ) ; # ifdef USE_HCACHE void * data = mutt_hcache_fetch ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; if ( data ) { char * uidl = mutt_str_strdup ( ctx -> hdrs [ i ] -> data ) ; int refno = ctx -> hdrs [ i ] -> refno ; int index = ctx -> hdrs [ i ] -> index ; struct Header * h = mutt_hcache_restore ( ( unsigned char * ) data ) ; mutt_hcache_free ( hc , & data ) ; mutt_header_free ( & ctx -> hdrs [ i ] ) ; ctx -> hdrs [ i ] = h ; ctx -> hdrs [ i ] -> refno = refno ; ctx -> hdrs [ i ] -> index = index ; ctx -> hdrs [ i ] -> data = uidl ; ret = 0 ; hcached = true ; } else # endif if ( ( ret = pop_read_header ( pop_data , ctx -> hdrs [ i ] ) ) < 0 ) break ; # ifdef USE_HCACHE else { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif const bool bcached = <S2SV_StartBug> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; <S2SV_EndBug> ctx -> hdrs [ i ] -> old = false ; ctx -> hdrs [ i ] -> read = false ; if ( hcached ) { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; else if ( MarkOld ) ctx -> hdrs [ i ] -> old = true ; } else { if ( bcached ) ctx -> hdrs [ i ] -> read = true ; } ctx -> msgcount ++ ; } if ( i > old_count ) mx_update_context ( ctx , i - old_count ) ; } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret < 0 ) { for ( int i = ctx -> msgcount ; i < new_count ; i ++ ) mutt_header_free ( & ctx -> hdrs [ i ] ) ; return ret ; } if ( MessageCacheClean ) mutt_bcache_list ( pop_data -> bcache , msg_cache_check , ( void * ) ctx ) ; mutt_clear_error ( ) ; return ( new_count - old_count ) ; }
CWE-000 int sas_discover_sata ( struct domain_device * dev ) { int res ; if ( dev -> dev_type == SAS_SATA_PM ) return - ENODEV ; dev -> sata_dev . class = sas_get_ata_command_set ( dev ) ; sas_fill_in_rphy ( dev , dev -> rphy ) ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }
CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_capcode_values , "Unknown" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { case BGP_CAPCODE_MP : ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; <S2SV_StartBug> case BGP_CAPCODE_RESTART : <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t\\tRestart<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>Restart<S2SV_blank>Time<S2SV_blank>%us" , ( ( opt [ i + 2 ] ) & 0x80 ) ? "R" : "none" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank>AFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Forwarding<S2SV_blank>state<S2SV_blank>preserved:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , ( ( opt [ i + cap_offset + 3 ] ) & 0x80 ) ? "yes" : "no" ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; case BGP_CAPCODE_RR : case BGP_CAPCODE_RR_CISCO : break ; case BGP_CAPCODE_AS_NEW : if ( cap_len == 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>4<S2SV_blank>Byte<S2SV_blank>AS<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( opt + i + 2 ) ) ) ) ; } break ; case BGP_CAPCODE_ADD_PATH : cap_offset = 2 ; if ( tcap_len == 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(bogus)" ) ) ; break ; } while ( tcap_len > 0 ) { if ( tcap_len < 4 ) { ND_PRINT ( ( ndo , "\\n\\t\\t(invalid)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Send/Receive:<S2SV_blank>%s" , tok2str ( af_values , "Unknown" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , "Unknown" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , tok2str ( bgp_add_path_recvsend , "Bogus<S2SV_blank>(0x%02x)" , opt [ i + cap_offset + 3 ] ) ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; default : ND_PRINT ( ( ndo , "\\n\\t\\tno<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>Capability<S2SV_blank>%u" , cap_type ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; break ; } if ( ndo -> ndo_vflag > 1 && cap_len > 0 ) { print_unknown_data ( ndo , & opt [ i + 2 ] , "\\n\\t\\t" , cap_len ) ; } i += BGP_CAP_HEADER_SIZE + cap_len ; } return ; trunc : ND_PRINT ( ( ndo , "[|BGP]" ) ) ; }
CWE-119 static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <S2SV_StartBug> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <S2SV_EndBug> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }
CWE-119 void vp8_optimize_mby ( MACROBLOCK * x ) { int b ; int type ; int has_2nd_order ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; if ( ! x -> e_mbd . above_context ) return ; if ( ! x -> e_mbd . left_context ) return ; <S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ; type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ; for ( b = 0 ; b < 16 ; b ++ ) { optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } if ( has_2nd_order ) { b = 24 ; optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } }
CWE-119 <S2SV_StartBug> static int read_frame_stats ( const struct twopass_rc * p , <S2SV_EndBug> FIRSTPASS_STATS * frame_stats , int offset ) { <S2SV_StartBug> const FIRSTPASS_STATS * fps_ptr = p -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> if ( offset >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] >= p -> stats_in_end ) <S2SV_EndBug> return EOF ; <S2SV_StartBug> } else if ( offset < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] < p -> stats_in_start ) <S2SV_EndBug> return EOF ; } * frame_stats = fps_ptr [ offset ] ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
CWE-20 static void server_real_connect ( SERVER_REC * server , IPADDR * ip , const char * unix_socket ) { GIOChannel * handle ; IPADDR * own_ip = NULL ; const char * errmsg ; char * errmsg2 ; char ipaddr [ MAX_IP_LEN ] ; int port ; g_return_if_fail ( ip != NULL || unix_socket != NULL ) ; signal_emit ( "server<S2SV_blank>connecting" , 2 , server , ip ) ; if ( server -> connrec -> no_connect ) return ; if ( ip != NULL ) { own_ip = ip == NULL ? NULL : ( IPADDR_IS_V6 ( ip ) ? server -> connrec -> own_ip6 : server -> connrec -> own_ip4 ) ; port = server -> connrec -> proxy != NULL ? server -> connrec -> proxy_port : server -> connrec -> port ; handle = server -> connrec -> use_ssl ? <S2SV_StartBug> net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , <S2SV_EndBug> server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ; } else { handle = net_connect_unix ( unix_socket ) ; } if ( handle == NULL ) { errmsg = g_strerror ( errno ) ; errmsg2 = NULL ; if ( errno == EADDRNOTAVAIL ) { if ( own_ip != NULL ) { net_ip2host ( own_ip , ipaddr ) ; errmsg2 = g_strconcat ( errmsg , ":<S2SV_blank>" , ipaddr , NULL ) ; } server -> no_reconnect = TRUE ; } if ( server -> connrec -> use_ssl && errno == ENOSYS ) server -> no_reconnect = TRUE ; server -> connection_lost = TRUE ; server_connect_failed ( server , errmsg2 ? errmsg2 : errmsg ) ; g_free ( errmsg2 ) ; } else { server -> handle = net_sendbuffer_create ( handle , 0 ) ; # ifdef HAVE_OPENSSL if ( server -> connrec -> use_ssl ) server_connect_callback_init_ssl ( server , handle ) ; else # endif server -> connect_tag = g_input_add ( handle , G_INPUT_WRITE | G_INPUT_READ , ( GInputFunction ) server_connect_callback_init , server ) ; } }
CWE-125 static void mldv2_report_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int group , nsrcs , ngroups ; u_int i , j ; if ( len < 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>len<S2SV_blank>%d]" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 1 ] ) ; ngroups = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 1 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>record(s)" , ngroups ) ) ; if ( ndo -> ndo_vflag > 0 ) { group = 8 ; for ( i = 0 ; i < ngroups ; i ++ ) { if ( len < group + 20 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>groups]" ) ) ; return ; } ND_TCHECK2 ( bp [ group + 4 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>[gaddr<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ group + 4 ] ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , tok2str ( mldv2report2str , "<S2SV_blank>[v2-report-#%d]" , bp [ group ] ) ) ) ; nsrcs = ( bp [ group + 2 ] << 8 ) + bp [ group + 3 ] ; if ( len < group + 20 + ( nsrcs * sizeof ( struct in6_addr ) ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>sources<S2SV_blank>%d]" , nsrcs ) ) ; return ; } if ( ndo -> ndo_vflag == 1 ) ND_PRINT ( ( ndo , ",<S2SV_blank>%d<S2SV_blank>source(s)" , nsrcs ) ) ; else { ND_PRINT ( ( ndo , "<S2SV_blank>{" ) ) ; for ( j = 0 ; j < nsrcs ; j ++ ) { ND_TCHECK2 ( bp [ group + 20 + j * sizeof ( struct in6_addr ) ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ group + 20 + j * sizeof ( struct in6_addr ) ] ) ) ) ; } ND_PRINT ( ( ndo , "<S2SV_blank>}" ) ) ; } group += 20 + nsrcs * sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , "]" ) ) ; } } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "[|icmp6]" ) ) ; <S2SV_EndBug> return ; }
CWE-189 static bool states_equal ( struct bpf_verifier_env * env , struct bpf_verifier_state * old , struct bpf_verifier_state * cur ) { int i ; <S2SV_StartBug> if ( old -> curframe != cur -> curframe ) <S2SV_EndBug> return false ; for ( i = 0 ; i <= old -> curframe ; i ++ ) { if ( old -> frame [ i ] -> callsite != cur -> frame [ i ] -> callsite ) return false ; if ( ! func_states_equal ( old -> frame [ i ] , cur -> frame [ i ] ) ) return false ; } return true ; }
CWE-189 static struct mobj * alloc_ta_mem ( size_t size ) { # ifdef CFG_PAGED_USER_TA return mobj_paged_alloc ( size ) ; # else struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ; <S2SV_StartBug> if ( mobj ) <S2SV_EndBug> <S2SV_StartBug> memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <S2SV_EndBug> return mobj ; # endif }
CWE-119 static void sum_intra_stats ( FRAME_COUNTS * counts , const MODE_INFO * mi ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = mi -> mbmi . mode ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = mi -> mbmi . uv_mode ; <S2SV_EndBug> const BLOCK_SIZE bsize = mi -> mbmi . sb_type ; if ( bsize < BLOCK_8X8 ) { int idx , idy ; const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) ++ counts -> y_mode [ 0 ] [ mi -> bmi [ idy * 2 + idx ] . as_mode ] ; } else { ++ counts -> y_mode [ size_group_lookup [ bsize ] ] [ y_mode ] ; } ++ counts -> uv_mode [ y_mode ] [ uv_mode ] ; }
CWE-000 static inline int add_post_vars ( zval * arr , post_var_data_t * vars , zend_bool eof TSRMLS_DC ) { uint64_t max_vars = PG ( max_input_vars ) ; vars -> ptr = vars -> str . c ; vars -> end = vars -> str . c + vars -> str . len ; while ( add_post_var ( arr , vars , eof TSRMLS_CC ) ) { if ( ++ vars -> cnt > max_vars ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Input<S2SV_blank>variables<S2SV_blank>exceeded<S2SV_blank>%" PRIu64 ".<S2SV_blank>" "To<S2SV_blank>increase<S2SV_blank>the<S2SV_blank>limit<S2SV_blank>change<S2SV_blank>max_input_vars<S2SV_blank>in<S2SV_blank>php.ini." , max_vars ) ; return FAILURE ; } } <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ; } return SUCCESS ; }
CWE-000 int perf_config ( config_fn_t fn , void * data ) { <S2SV_StartBug> int ret = 0 , found = 0 ; <S2SV_EndBug> char * repo_config = NULL ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( "HOME" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( "%s/.perfconfig" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; } <S2SV_StartBug> repo_config = perf_pathdup ( "config" ) ; <S2SV_EndBug> if ( ! access ( repo_config , R_OK ) ) { ret += perf_config_from_file ( fn , repo_config , data ) ; found += 1 ; } free ( repo_config ) ; if ( found == 0 ) return - 1 ; return ret ; }
CWE-476 smb_sdrc_t smb2_flush ( smb_request_t * sr ) { <S2SV_StartBug> smb_ofile_t * of = NULL ; <S2SV_EndBug> uint16_t StructSize ; uint16_t reserved1 ; uint32_t reserved2 ; smb2fid_t smb2fid ; uint32_t status ; int rc = 0 ; rc = smb_mbc_decodef ( & sr -> smb_data , "wwlqq" , & StructSize , & reserved1 , & reserved2 , & smb2fid . persistent , & smb2fid . temporal ) ; if ( rc ) return ( SDRC_ERROR ) ; if ( StructSize != 24 ) return ( SDRC_ERROR ) ; status = smb2sr_lookup_fid ( sr , & smb2fid ) ; if ( status ) { smb2sr_put_error ( sr , status ) ; return ( SDRC_SUCCESS ) ; } <S2SV_StartBug> of = sr -> fid_ofile ; <S2SV_EndBug> if ( ( of -> f_node -> flags & NODE_FLAGS_WRITE_THROUGH ) == 0 ) ( void ) smb_fsop_commit ( sr , of -> f_cr , of -> f_node ) ; ( void ) smb_mbc_encodef ( & sr -> reply , "wwl" , 4 , 0 ) ; return ( SDRC_SUCCESS ) ; }
CWE-000 inline void update_rq_clock ( struct rq * rq ) <S2SV_StartBug> { <S2SV_EndBug> if ( ! rq -> skip_clock_update ) { int cpu = cpu_of ( rq ) ; <S2SV_StartBug> u64 irq_time ; <S2SV_EndBug> rq -> clock = sched_clock_cpu ( cpu ) ; irq_time = irq_time_cpu ( cpu ) ; if ( rq -> clock - irq_time > rq -> clock_task ) rq -> clock_task = rq -> clock - irq_time ; sched_irq_time_avg_update ( rq , irq_time ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-125 int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , "(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "mobility:<S2SV_blank>%s" , tok2str ( ip6m_str , "type-#%u" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x" , type == IP6M_HOME_TEST_INIT ? "Home" : "Care-of" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>nonce<S2SV_blank>id=0x%x" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x" , type == IP6M_HOME_TEST ? "Home" : "Care-of" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x" , type == IP6M_HOME_TEST ? "Home" : "Care-of" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>seq#=%u" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 1 ) ; if ( bp [ hlen ] & 0xf0 ) ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , "A" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , "H" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , "L" ) ) ; if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , "K" ) ) ; hlen += 1 ; hlen += 1 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime=%u" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>status=%u" , mh -> ip6m_data8 [ 0 ] ) ) ; if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , "<S2SV_blank>K" ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>seq#=%u" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime=%u" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>status=%u" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 16 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>homeaddr<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , "<S2SV_blank>len=%u" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_StartBug> return ( mhlen ) ; <S2SV_EndBug> }
CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> } if ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
CWE-119 static void dma_rx ( struct b43_dmaring * ring , int * slot ) { const struct b43_dma_ops * ops = ring -> ops ; struct b43_dmadesc_generic * desc ; struct b43_dmadesc_meta * meta ; struct b43_rxhdr_fw4 * rxhdr ; struct sk_buff * skb ; u16 len ; int err ; dma_addr_t dmaaddr ; desc = ops -> idx2desc ( ring , * slot , & meta ) ; sync_descbuffer_for_cpu ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; skb = meta -> skb ; rxhdr = ( struct b43_rxhdr_fw4 * ) skb -> data ; len = le16_to_cpu ( rxhdr -> frame_len ) ; if ( len == 0 ) { int i = 0 ; do { udelay ( 2 ) ; barrier ( ) ; len = le16_to_cpu ( rxhdr -> frame_len ) ; } while ( len == 0 && i ++ < 5 ) ; if ( unlikely ( len == 0 ) ) { dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } } if ( unlikely ( b43_rx_buffer_is_poisoned ( ring , skb ) ) ) { b43dbg ( ring -> dev -> wl , "DMA<S2SV_blank>RX:<S2SV_blank>Dropping<S2SV_blank>poisoned<S2SV_blank>buffer.\\n" ) ; dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } <S2SV_StartBug> if ( unlikely ( len > ring -> rx_buffersize ) ) { <S2SV_EndBug> int cnt = 0 ; s32 tmp = len ; while ( 1 ) { desc = ops -> idx2desc ( ring , * slot , & meta ) ; b43_poison_rx_buffer ( ring , meta -> skb ) ; sync_descbuffer_for_device ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; * slot = next_slot ( ring , * slot ) ; cnt ++ ; tmp -= ring -> rx_buffersize ; if ( tmp <= 0 ) break ; } b43err ( ring -> dev -> wl , "DMA<S2SV_blank>RX<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>" "(len:<S2SV_blank>%u,<S2SV_blank>buffer:<S2SV_blank>%u,<S2SV_blank>nr-dropped:<S2SV_blank>%d)\\n" , len , ring -> rx_buffersize , cnt ) ; goto drop ; } dmaaddr = meta -> dmaaddr ; err = setup_rx_descbuffer ( ring , desc , meta , GFP_ATOMIC ) ; if ( unlikely ( err ) ) { b43dbg ( ring -> dev -> wl , "DMA<S2SV_blank>RX:<S2SV_blank>setup_rx_descbuffer()<S2SV_blank>failed\\n" ) ; goto drop_recycle_buffer ; } unmap_descbuffer ( ring , dmaaddr , ring -> rx_buffersize , 0 ) ; skb_put ( skb , len + ring -> frameoffset ) ; skb_pull ( skb , ring -> frameoffset ) ; b43_rx ( ring -> dev , skb , rxhdr ) ; drop : return ; drop_recycle_buffer : b43_poison_rx_buffer ( ring , skb ) ; sync_descbuffer_for_device ( ring , dmaaddr , ring -> rx_buffersize ) ; }
CWE-416 <S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static int update_mv ( vp9_writer * w , const unsigned int ct [ 2 ] , vp9_prob * cur_p , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd_p ) { <S2SV_EndBug> <S2SV_StartBug> const vp9_prob new_p = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) | 1 ; <S2SV_EndBug> const int update = cost_branch256 ( ct , * cur_p ) + vp9_cost_zero ( upd_p ) > cost_branch256 ( ct , new_p ) + vp9_cost_one ( upd_p ) + 7 * 256 ; <S2SV_StartBug> vp9_write ( w , update , upd_p ) ; <S2SV_EndBug> if ( update ) { * cur_p = new_p ; <S2SV_StartBug> vp9_write_literal ( w , new_p >> 1 , 7 ) ; <S2SV_EndBug> } return update ; }
CWE-20 static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { <S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u" , tok2str ( lmp_data_link_subobj , "Unknown" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , <S2SV_EndBug> tok2str ( gmpls_switch_cap_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_encoding_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , <S2SV_EndBug> EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ; }
CWE-125 static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = "<elided>" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|dao-truncated]" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , "<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]" ) ) ; return ; }
CWE-476 int upnp_redirect ( const char * rhost , unsigned short eport , const char * iaddr , unsigned short iport , const char * protocol , const char * desc , unsigned int leaseduration ) { int proto , r ; char iaddr_old [ 32 ] ; char rhost_old [ 32 ] ; unsigned short iport_old ; struct in_addr address ; unsigned int timestamp ; proto = proto_atoi ( protocol ) ; if ( inet_aton ( iaddr , & address ) <= 0 ) { syslog ( LOG_ERR , "inet_aton(%s)<S2SV_blank>FAILED" , iaddr ) ; return - 1 ; } if ( ! check_upnp_rule_against_permissions ( upnppermlist , num_upnpperm , eport , address , iport ) ) { syslog ( LOG_INFO , "redirection<S2SV_blank>permission<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>" "%hu->%s:%hu<S2SV_blank>%s" , eport , iaddr , iport , protocol ) ; return - 3 ; } <S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ; if ( r == 0 ) { if ( strcmp ( iaddr , iaddr_old ) == 0 && ( ( rhost == NULL && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , "*" ) == 0 ) && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , rhost_old ) == 0 ) ) ) ) { syslog ( LOG_INFO , "updating<S2SV_blank>existing<S2SV_blank>port<S2SV_blank>mapping<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>=><S2SV_blank>%s:%hu" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; if ( iport != iport_old ) { r = update_portmapping ( ext_if_name , eport , proto , iport , desc , timestamp ) ; } else { r = update_portmapping_desc_timestamp ( ext_if_name , eport , proto , desc , timestamp ) ; } # ifdef ENABLE_LEASEFILE if ( r == 0 ) { lease_file_remove ( eport , proto ) ; lease_file_add ( eport , iaddr , iport , proto , desc , timestamp ) ; } # endif return r ; } else { syslog ( LOG_INFO , "port<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>already<S2SV_blank>redirected<S2SV_blank>to<S2SV_blank>%s:%hu" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; return - 2 ; } # ifdef CHECK_PORTINUSE } else if ( port_in_use ( ext_if_name , eport , proto , iaddr , iport ) > 0 ) { syslog ( LOG_INFO , "port<S2SV_blank>%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use" , eport , protocol ) ; return - 4 ; # endif } else { timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; syslog ( LOG_INFO , "redirecting<S2SV_blank>port<S2SV_blank>%hu<S2SV_blank>to<S2SV_blank>%s:%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>for:<S2SV_blank>%s" , eport , iaddr , iport , protocol , desc ) ; return upnp_redirect_internal ( rhost , eport , iaddr , iport , proto , desc , timestamp ) ; } }
CWE-000 static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct packet_offload * ptype ; __be16 type = skb -> protocol ; struct list_head * head = & offload_base ; int same_flow ; enum gro_result ret ; int grow ; if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) goto normal ; if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) goto normal ; gro_list_prepare ( napi , skb ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( ptype , head , list ) { if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) continue ; skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; skb_reset_mac_len ( skb ) ; NAPI_GRO_CB ( skb ) -> same_flow = 0 ; NAPI_GRO_CB ( skb ) -> flush = 0 ; NAPI_GRO_CB ( skb ) -> free = 0 ; <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; switch ( skb -> ip_summed ) { case CHECKSUM_COMPLETE : NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; break ; case CHECKSUM_UNNECESSARY : NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; break ; default : NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; } pp = ptype -> callbacks . gro_receive ( & napi -> gro_list , skb ) ; break ; } rcu_read_unlock ( ) ; if ( & ptype -> list == head ) goto normal ; same_flow = NAPI_GRO_CB ( skb ) -> same_flow ; ret = NAPI_GRO_CB ( skb ) -> free ? GRO_MERGED_FREE : GRO_MERGED ; if ( pp ) { struct sk_buff * nskb = * pp ; * pp = nskb -> next ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; napi -> gro_count -- ; } if ( same_flow ) goto ok ; if ( NAPI_GRO_CB ( skb ) -> flush ) goto normal ; if ( unlikely ( napi -> gro_count >= MAX_GRO_SKBS ) ) { struct sk_buff * nskb = napi -> gro_list ; while ( nskb -> next ) { pp = & nskb -> next ; nskb = * pp ; } * pp = NULL ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; } else { napi -> gro_count ++ ; } NAPI_GRO_CB ( skb ) -> count = 1 ; NAPI_GRO_CB ( skb ) -> age = jiffies ; NAPI_GRO_CB ( skb ) -> last = skb ; skb_shinfo ( skb ) -> gso_size = skb_gro_len ( skb ) ; skb -> next = napi -> gro_list ; napi -> gro_list = skb ; ret = GRO_HELD ; pull : grow = skb_gro_offset ( skb ) - skb_headlen ( skb ) ; if ( grow > 0 ) gro_pull_from_frag0 ( skb , grow ) ; ok : return ret ; normal : ret = GRO_NORMAL ; goto pull ; }
CWE-119 void WT_NoiseGenerator ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 nInterpolatedSample ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( "b/26366256" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; tmp0 = ( EAS_I32 ) ( pWTVoice -> phaseAccum ) >> 18 ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; while ( numSamples -- ) { nInterpolatedSample = MULT_AUDIO_COEF ( tmp0 , ( PHASE_ONE - pWTVoice -> phaseFrac ) ) ; nInterpolatedSample += MULT_AUDIO_COEF ( tmp1 , pWTVoice -> phaseFrac ) ; * pOutputBuffer ++ = ( EAS_PCM ) nInterpolatedSample ; pWTVoice -> phaseFrac += ( EAS_U32 ) phaseInc ; if ( GET_PHASE_INT_PART ( pWTVoice -> phaseFrac ) ) { tmp0 = tmp1 ; pWTVoice -> phaseAccum = pWTVoice -> loopEnd ; pWTVoice -> loopEnd = ( 5 * pWTVoice -> loopEnd + 1 ) ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; pWTVoice -> phaseFrac = GET_PHASE_FRAC_PART ( pWTVoice -> phaseFrac ) ; } } }
CWE-119 int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) return luaL_argerror ( L , 0 , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , "Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack." ) ; buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { <S2SV_StartBug> lua_pushvalue ( L , i ) ; <S2SV_EndBug> mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }
CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = "" ; const char * link_section_name = "" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , "section_name" , section_name , 0 ) ; sdb_num_set ( sdb , "entries" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , "idx" , i , 0 ) ; sdb_num_set ( sdb_verdef , "vd_version" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , "vd_ndx" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , "vd_cnt" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , "flags" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , "idx" , isum , 0 ) ; sdb_num_set ( sdb_parent , "parent" , j , 0 ) ; sdb_set ( sdb_parent , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , "parent%d" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , "verdef%d" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
CWE-264 static int kvm_iommu_unmap_memslots ( struct kvm * kvm ) { int idx ; struct kvm_memslots * slots ; struct kvm_memory_slot * memslot ; idx = srcu_read_lock ( & kvm -> srcu ) ; slots = kvm_memslots ( kvm ) ; kvm_for_each_memslot ( memslot , slots ) <S2SV_StartBug> kvm_iommu_put_pages ( kvm , memslot -> base_gfn , memslot -> npages ) ; <S2SV_EndBug> srcu_read_unlock ( & kvm -> srcu , idx ) ; return 0 ; }
CWE-119 static void update_alt_ref_frame_stats ( VP9_COMP * cpi ) { RATE_CONTROL * const rc = & cpi -> rc ; rc -> frames_since_golden = 0 ; <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( ! cpi -> multi_arf_enabled ) # endif rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 1 ; }
CWE-20 static int _snd_timer_stop ( struct snd_timer_instance * timeri , int keep_flag , int event ) { struct snd_timer * timer ; unsigned long flags ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { if ( ! keep_flag ) { spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> } goto __end ; } timer = timeri -> timer ; if ( ! timer ) return - EINVAL ; spin_lock_irqsave ( & timer -> lock , flags ) ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; if ( ( timeri -> flags & SNDRV_TIMER_IFLG_RUNNING ) && ! ( -- timer -> running ) ) { timer -> hw . stop ( timer ) ; if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) { timer -> flags &= ~ SNDRV_TIMER_FLG_RESCHED ; snd_timer_reschedule ( timer , 0 ) ; if ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) { timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; timer -> hw . start ( timer ) ; } } } if ( ! keep_flag ) timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START ) ; spin_unlock_irqrestore ( & timer -> lock , flags ) ; __end : if ( event != SNDRV_TIMER_EVENT_RESOLUTION ) snd_timer_notify1 ( timeri , event ) ; return 0 ; }
CWE-20 static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - EINVAL ; if ( args [ size - 1 ] != '\\0' ) { if ( size == PAGE_SIZE ) return - EINVAL ; args [ size ] = '\\0' ; } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , "<S2SV_blank>" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , "current" ) == 0 ) { if ( strcmp ( command , "changehat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permhat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , "changeprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else if ( strcmp ( command , "permipc" ) == 0 ) { error = aa_setprocattr_permipc ( args ) ; } else { struct common_audit_data sa ; COMMON_AUDIT_DATA_INIT ( & sa , NONE ) ; sa . aad . op = OP_SETPROCATTR ; sa . aad . info = name ; sa . aad . error = - EINVAL ; <S2SV_StartBug> return aa_audit ( AUDIT_APPARMOR_DENIED , NULL , GFP_KERNEL , <S2SV_EndBug> & sa , NULL ) ; } } else if ( strcmp ( name , "exec" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , AA_ONEXEC , ! AA_DO_TEST ) ; } else { return - EINVAL ; } if ( ! error ) error = size ; return error ; }
CWE-200 static void __net_random_once_deferred ( struct work_struct * w ) { struct __net_random_once_work * work = container_of ( w , struct __net_random_once_work , work ) ; <S2SV_StartBug> if ( ! static_key_enabled ( work -> key ) ) <S2SV_EndBug> static_key_slow_inc ( work -> key ) ; kfree ( work ) ; }
CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = "" ; const char * link_section_name = "" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , "section_name" , section_name , 0 ) ; sdb_num_set ( sdb , "entries" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , "idx" , i , 0 ) ; sdb_num_set ( sdb_verdef , "vd_version" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , "vd_ndx" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , "vd_cnt" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , "flags" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , "idx" , isum , 0 ) ; sdb_num_set ( sdb_parent , "parent" , j , 0 ) ; sdb_set ( sdb_parent , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , "parent%d" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , "verdef%d" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
CWE-119 static void optimize_mb ( MACROBLOCK * x ) { int b ; int type ; int has_2nd_order ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; <S2SV_StartBug> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ; type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ; for ( b = 0 ; b < 16 ; b ++ ) { optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } for ( b = 16 ; b < 24 ; b ++ ) { optimize_b ( x , b , PLANE_TYPE_UV , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } if ( has_2nd_order ) { b = 24 ; optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } }
CWE-362 static ssize_t environ_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { char * page ; unsigned long src = * ppos ; int ret = 0 ; struct mm_struct * mm = file -> private_data ; unsigned long env_start , env_end ; <S2SV_StartBug> if ( ! mm ) <S2SV_EndBug> return 0 ; page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ; if ( ! page ) return - ENOMEM ; ret = 0 ; if ( ! atomic_inc_not_zero ( & mm -> mm_users ) ) goto free ; down_read ( & mm -> mmap_sem ) ; env_start = mm -> env_start ; env_end = mm -> env_end ; up_read ( & mm -> mmap_sem ) ; while ( count > 0 ) { size_t this_len , max_len ; int retval ; if ( src >= ( env_end - env_start ) ) break ; this_len = env_end - ( env_start + src ) ; max_len = min_t ( size_t , PAGE_SIZE , count ) ; this_len = min ( max_len , this_len ) ; retval = access_remote_vm ( mm , ( env_start + src ) , page , this_len , 0 ) ; if ( retval <= 0 ) { ret = retval ; break ; } if ( copy_to_user ( buf , page , retval ) ) { ret = - EFAULT ; break ; } ret += retval ; src += retval ; buf += retval ; count -= retval ; } * ppos = src ; mmput ( mm ) ; free : free_page ( ( unsigned long ) page ) ; return ret ; }
CWE-125 <S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug> { int i ; const char * str ; WLog_INFO ( TAG , "negotiateFlags<S2SV_blank>\\"0x%08" PRIX32 "\\"" , flags ) ; for ( i = 31 ; i >= 0 ; i -- ) { if ( ( flags >> i ) & 1 ) { str = NTLM_NEGOTIATE_STRINGS [ ( 31 - i ) ] ; WLog_INFO ( TAG , "\\t%s<S2SV_blank>(%d)," , str , ( 31 - i ) ) ; } } }
CWE-125 static void rpl_print ( netdissect_options * ndo , const struct icmp6_hdr * hdr , const u_char * bp , u_int length ) { int secured = hdr -> icmp6_code & 0x80 ; int basecode = hdr -> icmp6_code & 0x7f ; if ( secured ) { ND_PRINT ( ( ndo , ",<S2SV_blank>(SEC)<S2SV_blank>[worktodo]" ) ) ; return ; } else { ND_PRINT ( ( ndo , ",<S2SV_blank>(CLR)" ) ) ; } switch ( basecode ) { case ND_RPL_DAG_IS : ND_PRINT ( ( ndo , "DODAG<S2SV_blank>Information<S2SV_blank>Solicitation" ) ) ; if ( ndo -> ndo_vflag ) { } break ; case ND_RPL_DAG_IO : ND_PRINT ( ( ndo , "DODAG<S2SV_blank>Information<S2SV_blank>Object" ) ) ; if ( ndo -> ndo_vflag ) { rpl_dio_print ( ndo , bp , length ) ; } break ; case ND_RPL_DAO : ND_PRINT ( ( ndo , "Destination<S2SV_blank>Advertisement<S2SV_blank>Object" ) ) ; if ( ndo -> ndo_vflag ) { rpl_dao_print ( ndo , bp , length ) ; } break ; case ND_RPL_DAO_ACK : ND_PRINT ( ( ndo , "Destination<S2SV_blank>Advertisement<S2SV_blank>Object<S2SV_blank>Ack" ) ) ; if ( ndo -> ndo_vflag ) { rpl_daoack_print ( ndo , bp , length ) ; } break ; default : ND_PRINT ( ( ndo , "RPL<S2SV_blank>message,<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>%u" , hdr -> icmp6_code ) ) ; break ; } return ; # if 0 trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; # endif }
CWE-476 int expand_downwards ( struct vm_area_struct * vma , unsigned long address ) { struct mm_struct * mm = vma -> vm_mm ; struct vm_area_struct * prev ; <S2SV_StartBug> int error ; <S2SV_EndBug> address &= PAGE_MASK ; <S2SV_StartBug> error = security_mmap_addr ( address ) ; <S2SV_EndBug> if ( error ) return error ; prev = vma -> vm_prev ; if ( prev && ! ( prev -> vm_flags & VM_GROWSDOWN ) && ( prev -> vm_flags & ( VM_WRITE | VM_READ | VM_EXEC ) ) ) { if ( address - prev -> vm_end < stack_guard_gap ) return - ENOMEM ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) return - ENOMEM ; anon_vma_lock_write ( vma -> anon_vma ) ; if ( address < vma -> vm_start ) { unsigned long size , grow ; size = vma -> vm_end - address ; grow = ( vma -> vm_start - address ) >> PAGE_SHIFT ; error = - ENOMEM ; if ( grow <= vma -> vm_pgoff ) { error = acct_stack_growth ( vma , size , grow ) ; if ( ! error ) { spin_lock ( & mm -> page_table_lock ) ; if ( vma -> vm_flags & VM_LOCKED ) mm -> locked_vm += grow ; vm_stat_account ( mm , vma -> vm_flags , grow ) ; anon_vma_interval_tree_pre_update_vma ( vma ) ; vma -> vm_start = address ; vma -> vm_pgoff -= grow ; anon_vma_interval_tree_post_update_vma ( vma ) ; vma_gap_update ( vma ) ; spin_unlock ( & mm -> page_table_lock ) ; perf_event_mmap ( vma ) ; } } } anon_vma_unlock_write ( vma -> anon_vma ) ; khugepaged_enter_vma_merge ( vma , vma -> vm_flags ) ; validate_mm ( mm ) ; return error ; }
CWE-200 static int xfrm_alloc_replay_state_esn ( struct xfrm_replay_state_esn * * replay_esn , struct xfrm_replay_state_esn * * preplay_esn , struct nlattr * rta ) { struct xfrm_replay_state_esn * p , * pp , * up ; <S2SV_StartBug> if ( ! rta ) <S2SV_EndBug> return 0 ; up = nla_data ( rta ) ; <S2SV_StartBug> p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! p ) return - ENOMEM ; <S2SV_StartBug> pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! pp ) { kfree ( p ) ; return - ENOMEM ; } <S2SV_StartBug> * replay_esn = p ; <S2SV_EndBug> * preplay_esn = pp ; return 0 ; }
CWE-119 static vpx_codec_err_t vp8e_destroy ( vpx_codec_alg_priv_t * ctx ) { # if CONFIG_MULTI_RES_ENCODING if ( ctx -> oxcf . mr_total_resolutions > 0 && ( ctx -> oxcf . mr_encoder_id == ctx -> oxcf . mr_total_resolutions - 1 ) ) { LOWER_RES_FRAME_INFO * shared_mem_loc = ( LOWER_RES_FRAME_INFO * ) ctx -> oxcf . mr_low_res_mode_info ; free ( shared_mem_loc -> mb_info ) ; free ( ctx -> oxcf . mr_low_res_mode_info ) ; } # endif free ( ctx -> cx_data ) ; vp8_remove_compressor ( & ctx -> cpi ) ; <S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> return VPX_CODEC_OK ; }
CWE-119 static void write_frame_size ( const VP9_COMMON * cm , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ; <S2SV_EndBug> write_display_size ( cm , wb ) ; }
CWE-119 <S2SV_StartBug> MB_PREDICTION_MODE vp9_above_block_mode ( const MODE_INFO * cur_mi , <S2SV_EndBug> const MODE_INFO * above_mi , int b ) { if ( b == 0 || b == 1 ) { if ( ! above_mi || is_inter_block ( & above_mi -> mbmi ) ) return DC_PRED ; return get_y_mode ( above_mi , b + 2 ) ; } else { assert ( b == 2 || b == 3 ) ; return cur_mi -> bmi [ b - 2 ] . as_mode ; } }
CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos ) <S2SV_StartBug> { <S2SV_EndBug> if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) { ptr [ * pos ] . left = 0 ; ( * pos ) ++ ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = 1 ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }
CWE-362 struct sock * dccp_v4_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet_request_sock * ireq ; struct inet_sock * newinet ; struct sock * newsk ; if ( sk_acceptq_is_full ( sk ) ) goto exit_overflow ; if ( dst == NULL && ( dst = inet_csk_route_req ( sk , req ) ) == NULL ) goto exit ; newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto exit_nonewsk ; sk_setup_caps ( newsk , dst ) ; newinet = inet_sk ( newsk ) ; ireq = inet_rsk ( req ) ; newinet -> inet_daddr = ireq -> rmt_addr ; newinet -> inet_rcv_saddr = ireq -> loc_addr ; newinet -> inet_saddr = ireq -> loc_addr ; <S2SV_StartBug> newinet -> opt = ireq -> opt ; <S2SV_EndBug> ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; newinet -> inet_id = jiffies ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto exit ; } __inet_hash_nolisten ( newsk , NULL ) ; return newsk ; exit_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; exit_nonewsk : dst_release ( dst ) ; exit : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
CWE-000 static void flatpak_proxy_client_finalize ( GObject * object ) { FlatpakProxyClient * client = FLATPAK_PROXY_CLIENT ( object ) ; client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ; <S2SV_StartBug> g_clear_object ( & client -> proxy ) ; <S2SV_EndBug> g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; free_side ( & client -> client_side ) ; free_side ( & client -> bus_side ) ; G_OBJECT_CLASS ( flatpak_proxy_client_parent_class ) -> finalize ( object ) ; }
CWE-20 static inline void VectorClamp3 ( DDSVector3 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> }
CWE-362 static void * vips_foreign_load_start ( VipsImage * out , void * a , void * b ) { VipsForeignLoad * load = VIPS_FOREIGN_LOAD ( b ) ; <S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> if ( ! load -> real ) { if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ; # ifdef DEBUG printf ( "vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\n" ) ; # endif load -> real -> progress_signal = load -> out ; g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ; if ( class -> load ( load ) || <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> return ( NULL ) ; if ( ! vips_foreign_load_iscompat ( load -> real , out ) ) <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ; } return ( vips_region_new ( load -> real ) ) ; }
CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank>" "<keyframe-interval><S2SV_blank>[<error-resilient>]\\nSee<S2SV_blank>comments<S2SV_blank>in<S2SV_blank>" "simple_encoder.c<S2SV_blank>for<S2SV_blank>more<S2SV_blank>information.\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_use_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int reference_flag = va_arg ( args , int ) ; vp8_use_as_reference ( ctx -> cpi , reference_flag ) ; return VPX_CODEC_OK ; }
CWE-000 static av_cold int rl2_read_header ( AVFormatContext * s ) { AVIOContext * pb = s -> pb ; AVStream * st ; unsigned int frame_count ; unsigned int audio_frame_counter = 0 ; unsigned int video_frame_counter = 0 ; unsigned int back_size ; unsigned short sound_rate ; unsigned short rate ; unsigned short channels ; unsigned short def_sound_size ; unsigned int signature ; unsigned int pts_den = 11025 ; unsigned int pts_num = 1103 ; unsigned int * chunk_offset = NULL ; int * chunk_size = NULL ; int * audio_size = NULL ; int i ; int ret = 0 ; avio_skip ( pb , 4 ) ; back_size = avio_rl32 ( pb ) ; signature = avio_rb32 ( pb ) ; avio_skip ( pb , 4 ) ; frame_count = avio_rl32 ( pb ) ; if ( back_size > INT_MAX / 2 || frame_count > INT_MAX / sizeof ( uint32_t ) ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 2 ) ; sound_rate = avio_rl16 ( pb ) ; rate = avio_rl16 ( pb ) ; channels = avio_rl16 ( pb ) ; def_sound_size = avio_rl16 ( pb ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RL2 ; st -> codecpar -> codec_tag = 0 ; st -> codecpar -> width = 320 ; st -> codecpar -> height = 200 ; st -> codecpar -> extradata_size = EXTRADATA1_SIZE ; if ( signature == RLV3_TAG && back_size > 0 ) st -> codecpar -> extradata_size += back_size ; if ( ff_get_extradata ( s , st -> codecpar , pb , st -> codecpar -> extradata_size ) < 0 ) return AVERROR ( ENOMEM ) ; if ( sound_rate ) { if ( ! channels || channels > 42 ) { av_log ( s , AV_LOG_ERROR , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>channels:<S2SV_blank>%d\\n" , channels ) ; return AVERROR_INVALIDDATA ; } pts_num = def_sound_size ; pts_den = rate ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; st -> codecpar -> codec_tag = 1 ; st -> codecpar -> channels = channels ; st -> codecpar -> bits_per_coded_sample = 8 ; st -> codecpar -> sample_rate = rate ; st -> codecpar -> bit_rate = st -> codecpar -> channels * st -> codecpar -> sample_rate * st -> codecpar -> bits_per_coded_sample ; st -> codecpar -> block_align = st -> codecpar -> channels * st -> codecpar -> bits_per_coded_sample / 8 ; avpriv_set_pts_info ( st , 32 , 1 , rate ) ; } avpriv_set_pts_info ( s -> streams [ 0 ] , 32 , pts_num , pts_den ) ; chunk_size = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; audio_size = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; chunk_offset = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; if ( ! chunk_size || ! audio_size || ! chunk_offset ) { av_free ( chunk_size ) ; av_free ( audio_size ) ; av_free ( chunk_offset ) ; return AVERROR ( ENOMEM ) ; } <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> chunk_size [ i ] = avio_rl32 ( pb ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> chunk_offset [ i ] = avio_rl32 ( pb ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) <S2SV_EndBug> audio_size [ i ] = avio_rl32 ( pb ) & 0xFFFF ; <S2SV_StartBug> for ( i = 0 ; i < frame_count ; i ++ ) { <S2SV_EndBug> if ( chunk_size [ i ] < 0 || audio_size [ i ] > chunk_size [ i ] ) { ret = AVERROR_INVALIDDATA ; break ; } if ( sound_rate && audio_size [ i ] ) { av_add_index_entry ( s -> streams [ 1 ] , chunk_offset [ i ] , audio_frame_counter , audio_size [ i ] , 0 , AVINDEX_KEYFRAME ) ; audio_frame_counter += audio_size [ i ] / channels ; } av_add_index_entry ( s -> streams [ 0 ] , chunk_offset [ i ] + audio_size [ i ] , video_frame_counter , chunk_size [ i ] - audio_size [ i ] , 0 , AVINDEX_KEYFRAME ) ; ++ video_frame_counter ; } av_free ( chunk_size ) ; av_free ( audio_size ) ; av_free ( chunk_offset ) ; return ret ; }
CWE-20 static void gimp_write_and_read_file ( Gimp * gimp , gboolean with_unusual_stuff , gboolean compat_paths , gboolean use_gimp_2_8_features ) { GimpImage * image ; GimpImage * loaded_image ; GimpPlugInProcedure * proc ; <S2SV_StartBug> gchar * filename ; <S2SV_EndBug> GFile * file ; image = gimp_create_mainimage ( gimp , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; gimp_assert_mainimage ( image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; <S2SV_StartBug> filename = g_build_filename ( g_get_tmp_dir ( ) , "gimp-test.xcf" , NULL ) ; <S2SV_EndBug> file = g_file_new_for_path ( filename ) ; g_free ( filename ) ; proc = gimp_plug_in_manager_file_procedure_find ( image -> gimp -> plug_in_manager , GIMP_FILE_PROCEDURE_GROUP_SAVE , file , NULL ) ; file_save ( gimp , image , NULL , file , proc , GIMP_RUN_NONINTERACTIVE , FALSE , FALSE , FALSE , NULL ) ; loaded_image = gimp_test_load_image ( image -> gimp , file ) ; gimp_assert_mainimage ( loaded_image , with_unusual_stuff , compat_paths , use_gimp_2_8_features ) ; g_file_delete ( file , NULL , NULL ) ; g_object_unref ( file ) ; }
CWE-200 static int ccid3_hc_tx_getsockopt ( struct sock * sk , const int optname , int len , u32 __user * optval , int __user * optlen ) { const struct ccid3_hc_tx_sock * hc = ccid3_hc_tx_sk ( sk ) ; struct tfrc_tx_info tfrc ; const void * val ; switch ( optname ) { case DCCP_SOCKOPT_CCID_TX_INFO : if ( len < sizeof ( tfrc ) ) return - EINVAL ; <S2SV_StartBug> tfrc . tfrctx_x = hc -> tx_x ; <S2SV_EndBug> tfrc . tfrctx_x_recv = hc -> tx_x_recv ; tfrc . tfrctx_x_calc = hc -> tx_x_calc ; tfrc . tfrctx_rtt = hc -> tx_rtt ; tfrc . tfrctx_p = hc -> tx_p ; tfrc . tfrctx_rto = hc -> tx_t_rto ; tfrc . tfrctx_ipi = hc -> tx_t_ipi ; len = sizeof ( tfrc ) ; val = & tfrc ; break ; default : return - ENOPROTOOPT ; } if ( put_user ( len , optlen ) || copy_to_user ( optval , val , len ) ) return - EFAULT ; return 0 ; }
CWE-119 static int key_verify ( pam_handle_t * pamh , int flags , PKCS11_KEY * authkey ) { int ok = 0 ; unsigned char challenge [ 30 ] ; <S2SV_StartBug> unsigned char signature [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> unsigned int siglen = sizeof signature ; <S2SV_EndBug> const EVP_MD * md = EVP_sha1 ( ) ; EVP_MD_CTX * md_ctx = EVP_MD_CTX_new ( ) ; EVP_PKEY * privkey = PKCS11_get_private_key ( authkey ) ; EVP_PKEY * pubkey = PKCS11_get_public_key ( authkey ) ; <S2SV_StartBug> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <S2SV_EndBug> goto err ; } if ( NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md || ! EVP_SignInit ( md_ctx , md ) || ! EVP_SignUpdate ( md_ctx , challenge , sizeof challenge ) || ! EVP_SignFinal ( md_ctx , signature , & siglen , privkey ) || ! EVP_MD_CTX_reset ( md_ctx ) || ! EVP_VerifyInit ( md_ctx , md ) || ! EVP_VerifyUpdate ( md_ctx , challenge , sizeof challenge ) || 1 != EVP_VerifyFinal ( md_ctx , signature , siglen , pubkey ) ) { pam_syslog ( pamh , LOG_DEBUG , "Error<S2SV_blank>verifying<S2SV_blank>key:<S2SV_blank>%s\\n" , ERR_reason_error_string ( ERR_get_error ( ) ) ) ; prompt ( flags , pamh , PAM_ERROR_MSG , NULL , _ ( "Error<S2SV_blank>verifying<S2SV_blank>key" ) ) ; goto err ; } ok = 1 ; <S2SV_StartBug> err : <S2SV_EndBug> if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ; if ( NULL != privkey ) EVP_PKEY_free ( privkey ) ; if ( NULL != md_ctx ) { EVP_MD_CTX_free ( md_ctx ) ; } return ok ; }
CWE-284 static uint16_t transmit_data ( serial_data_type_t type , uint8_t * data , uint16_t length ) { assert ( data != NULL ) ; assert ( length > 0 ) ; if ( type < DATA_TYPE_COMMAND || type > DATA_TYPE_SCO ) { LOG_ERROR ( "%s<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>type:<S2SV_blank>%d" , __func__ , type ) ; return 0 ; } -- data ; uint8_t previous_byte = * data ; * ( data ) = type ; ++ length ; uint16_t transmitted_length = 0 ; while ( length > 0 ) { <S2SV_StartBug> ssize_t ret = write ( uart_fd , data + transmitted_length , length ) ; <S2SV_EndBug> switch ( ret ) { case - 1 : LOG_ERROR ( "In<S2SV_blank>%s,<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>the<S2SV_blank>uart<S2SV_blank>serial<S2SV_blank>port:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; goto done ; case 0 : goto done ; default : transmitted_length += ret ; length -= ret ; break ; } } done : ; * ( data ) = previous_byte ; if ( transmitted_length > 0 ) -- transmitted_length ; return transmitted_length ; }
CWE-119 void process_pfa ( FILE * ifp , const char * ifp_filename , struct font_reader * fr ) { char buffer [ LINESIZE ] ; int c = 0 ; int blocktyp = PFA_ASCII ; char saved_orphan = 0 ; ( void ) ifp_filename ; while ( c != EOF ) { char * line = buffer , * last = buffer ; int crlf = 0 ; c = getc ( ifp ) ; while ( c != EOF && c != '\\r' && c != '\\n' && last < buffer + LINESIZE - 1 ) { * last ++ = c ; c = getc ( ifp ) ; } if ( last == buffer + LINESIZE - 1 ) ungetc ( c , ifp ) ; else if ( c == '\\r' && blocktyp != PFA_BINARY ) { c = getc ( ifp ) ; if ( c != '\\n' ) ungetc ( c , ifp ) , crlf = 1 ; else crlf = 2 ; * last ++ = '\\n' ; } else if ( c != EOF ) * last ++ = c ; * last = 0 ; if ( blocktyp == PFA_ASCII ) { <S2SV_StartBug> if ( strncmp ( line , "currentfile<S2SV_blank>eexec" , 17 ) == 0 && isspace ( line [ 17 ] ) ) { <S2SV_EndBug> char saved_p ; <S2SV_StartBug> for ( line += 18 ; isspace ( * line ) ; line ++ ) <S2SV_EndBug> ; saved_p = * line ; * line = 0 ; fr -> output_ascii ( buffer , line - buffer ) ; * line = saved_p ; blocktyp = PFA_EEXEC_TEST ; if ( ! * line ) continue ; } else { fr -> output_ascii ( line , last - line ) ; continue ; } } if ( blocktyp == PFA_EEXEC_TEST ) { <S2SV_StartBug> for ( ; line < last && isspace ( * line ) ; line ++ ) <S2SV_EndBug> ; if ( line == last ) continue ; <S2SV_StartBug> else if ( last >= line + 4 && isxdigit ( line [ 0 ] ) && isxdigit ( line [ 1 ] ) <S2SV_EndBug> <S2SV_StartBug> && isxdigit ( line [ 2 ] ) && isxdigit ( line [ 3 ] ) ) <S2SV_EndBug> blocktyp = PFA_HEX ; else blocktyp = PFA_BINARY ; memmove ( buffer , line , last - line + 1 ) ; last = buffer + ( last - line ) ; line = buffer ; if ( blocktyp == PFA_BINARY && crlf ) { last [ - 1 ] = '\\r' ; if ( crlf == 2 ) * last ++ = '\\n' ; } } if ( all_zeroes ( line ) ) { fr -> output_ascii ( line , last - line ) ; blocktyp = PFA_ASCII ; } else if ( blocktyp == PFA_HEX ) { int len = translate_hex_string ( line , & saved_orphan ) ; if ( len ) fr -> output_binary ( ( unsigned char * ) line , len ) ; } else fr -> output_binary ( ( unsigned char * ) line , last - line ) ; } fr -> output_end ( ) ; }
CWE-000 static M_fs_error_t M_fs_copy_file ( const char * path_old , const char * path_new , M_fs_file_mode_t mode , M_fs_progress_cb_t cb , M_fs_progress_flags_t progress_flags , M_fs_progress_t * progress , const M_fs_perms_t * perms ) { M_fs_file_t * fd_old ; M_fs_file_t * fd_new ; M_fs_info_t * info = NULL ; unsigned char temp [ M_FS_BUF_SIZE ] ; size_t read_len ; size_t wrote_len ; size_t wrote_total = 0 ; size_t offset ; M_fs_error_t res ; <S2SV_StartBug> if ( M_fs_perms_can_access ( path_new , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { <S2SV_EndBug> res = M_fs_delete ( path_new , M_FALSE , NULL , M_FS_PROGRESS_NOEXTRA ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } } res = M_fs_file_open ( & fd_old , path_old , M_FS_BUF_SIZE , M_FS_FILE_MODE_READ | M_FS_FILE_MODE_NOCREATE , NULL ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } if ( perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS ) { res = M_fs_info_file ( & info , fd_old , M_FS_PATH_INFO_FLAGS_NONE ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } perms = M_fs_info_get_perms ( info ) ; } res = M_fs_file_open ( & fd_new , path_new , M_FS_BUF_SIZE , M_FS_FILE_MODE_WRITE | M_FS_FILE_MODE_OVERWRITE , perms ) ; M_fs_info_destroy ( info ) ; if ( res != M_FS_ERROR_SUCCESS ) { M_fs_file_close ( fd_old ) ; return res ; } while ( ( res = M_fs_file_read ( fd_old , temp , sizeof ( temp ) , & read_len , M_FS_FILE_RW_NORMAL ) ) == M_FS_ERROR_SUCCESS && read_len != 0 ) { offset = 0 ; while ( offset < read_len ) { res = M_fs_file_write ( fd_new , temp + offset , read_len - offset , & wrote_len , M_FS_FILE_RW_NORMAL ) ; offset += wrote_len ; wrote_total += wrote_len ; if ( cb ) { M_fs_progress_set_result ( progress , res ) ; if ( progress_flags & M_FS_PROGRESS_SIZE_TOTAL ) { M_fs_progress_set_size_total_progess ( progress , M_fs_progress_get_size_total_progess ( progress ) + wrote_len ) ; } if ( progress_flags & M_FS_PROGRESS_SIZE_CUR ) { M_fs_progress_set_size_current_progress ( progress , wrote_total ) ; } if ( progress_flags & M_FS_PROGRESS_COUNT ) { M_fs_progress_set_count ( progress , M_fs_progress_get_count ( progress ) + 1 ) ; } if ( ! cb ( progress ) ) { res = M_FS_ERROR_CANCELED ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } if ( res != M_FS_ERROR_SUCCESS ) { break ; } } M_fs_file_close ( fd_old ) ; M_fs_file_close ( fd_new ) ; if ( res != M_FS_ERROR_SUCCESS ) { return res ; } return M_FS_ERROR_SUCCESS ; }
CWE-119 static char * pool_strdup ( const char * s ) { <S2SV_StartBug> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( r , s ) ; <S2SV_EndBug> return r ; }
CWE-476 int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; <S2SV_StartBug> init_thread : <S2SV_EndBug> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , "f2fs_flush-%u:%u" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }
CWE-200 static inline int verify_replay ( struct xfrm_usersa_info * p , struct nlattr * * attrs ) { struct nlattr * rt = attrs [ XFRMA_REPLAY_ESN_VAL ] ; <S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! rt ) return 0 ; if ( p -> id . proto != IPPROTO_ESP ) return - EINVAL ; if ( p -> replay_window != 0 ) return - EINVAL ; return 0 ; }
CWE-190 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; <S2SV_StartBug> dst_known = tnum_is_const ( dst_reg -> var_off ) ; <S2SV_EndBug> switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_uv ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE y_mode ) { <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE uv_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . uv_mode_prob [ y_mode ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . uv_mode [ y_mode ] [ uv_mode ] ; return uv_mode ; }
CWE-20 static void ComputePrincipleComponent ( const float * covariance , DDSVector3 * principle ) { DDSVector4 row0 , row1 , row2 , v ; register ssize_t i ; row0 . x = covariance [ 0 ] ; row0 . y = covariance [ 1 ] ; row0 . z = covariance [ 2 ] ; row0 . w = 0.0f ; row1 . x = covariance [ 1 ] ; row1 . y = covariance [ 3 ] ; row1 . z = covariance [ 4 ] ; row1 . w = 0.0f ; row2 . x = covariance [ 2 ] ; row2 . y = covariance [ 4 ] ; row2 . z = covariance [ 5 ] ; row2 . w = 0.0f ; VectorInit ( v , 1.0f ) ; for ( i = 0 ; i < 8 ; i ++ ) { DDSVector4 w ; float a ; w . x = row0 . x * v . x ; w . y = row0 . y * v . x ; w . z = row0 . z * v . x ; w . w = row0 . w * v . x ; w . x = ( row1 . x * v . y ) + w . x ; w . y = ( row1 . y * v . y ) + w . y ; w . z = ( row1 . z * v . y ) + w . z ; w . w = ( row1 . w * v . y ) + w . w ; w . x = ( row2 . x * v . z ) + w . x ; w . y = ( row2 . y * v . z ) + w . y ; w . z = ( row2 . z * v . z ) + w . z ; w . w = ( row2 . w * v . z ) + w . w ; <S2SV_StartBug> a = 1.0f / MaxF ( w . x , MaxF ( w . y , w . z ) ) ; <S2SV_EndBug> v . x = w . x * a ; v . y = w . y * a ; v . z = w . z * a ; v . w = w . w * a ; } VectorCopy43 ( v , principle ) ; }
CWE-119 CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) { CURLcode result ; char * plainauth ; size_t ulen ; size_t plen ; size_t plainlen ; * outlen = 0 ; * outptr = NULL ; ulen = strlen ( userp ) ; plen = strlen ( passwdp ) ; <S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ; plainauth = malloc ( plainlen ) ; if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ; memcpy ( plainauth , userp , ulen ) ; plainauth [ ulen ] = '\\0' ; memcpy ( plainauth + ulen + 1 , userp , ulen ) ; plainauth [ 2 * ulen + 1 ] = '\\0' ; memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ; result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ; free ( plainauth ) ; return result ; }
CWE-284 void btsnoop_net_write ( const void * data , size_t length ) { # if ( ! defined ( BT_NET_DEBUG ) || ( BT_NET_DEBUG != TRUE ) ) return ; # endif pthread_mutex_lock ( & client_socket_lock_ ) ; if ( client_socket_ != - 1 ) { <S2SV_StartBug> if ( send ( client_socket_ , data , length , 0 ) == - 1 && errno == ECONNRESET ) { <S2SV_EndBug> safe_close_ ( & client_socket_ ) ; } } pthread_mutex_unlock ( & client_socket_lock_ ) ; }
CWE-20 int ext4_orphan_add ( handle_t * handle , struct inode * inode ) { struct super_block * sb = inode -> i_sb ; struct ext4_iloc iloc ; int err = 0 , rc ; <S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; if ( ! list_empty ( & EXT4_I ( inode ) -> i_orphan ) ) goto out_unlock ; J_ASSERT ( ( S_ISREG ( inode -> i_mode ) || S_ISDIR ( inode -> i_mode ) || S_ISLNK ( inode -> i_mode ) ) || inode -> i_nlink == 0 ) ; BUFFER_TRACE ( EXT4_SB ( sb ) -> s_sbh , "get_write_access" ) ; err = ext4_journal_get_write_access ( handle , EXT4_SB ( sb ) -> s_sbh ) ; if ( err ) goto out_unlock ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_unlock ; if ( NEXT_ORPHAN ( inode ) && NEXT_ORPHAN ( inode ) <= ( le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_inodes_count ) ) ) goto mem_insert ; NEXT_ORPHAN ( inode ) = le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_last_orphan ) ; EXT4_SB ( sb ) -> s_es -> s_last_orphan = cpu_to_le32 ( inode -> i_ino ) ; err = ext4_handle_dirty_super ( handle , sb ) ; rc = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; if ( ! err ) err = rc ; mem_insert : if ( ! err ) list_add ( & EXT4_I ( inode ) -> i_orphan , & EXT4_SB ( sb ) -> s_orphan ) ; jbd_debug ( 4 , "superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%lu\\n" , inode -> i_ino ) ; jbd_debug ( 4 , "orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%d\\n" , inode -> i_ino , NEXT_ORPHAN ( inode ) ) ; out_unlock : mutex_unlock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; ext4_std_error ( inode -> i_sb , err ) ; return err ; }
CWE-264 static void bond_setup ( struct net_device * bond_dev ) { struct bonding * bond = netdev_priv ( bond_dev ) ; rwlock_init ( & bond -> lock ) ; rwlock_init ( & bond -> curr_slave_lock ) ; bond -> params = bonding_defaults ; bond -> dev = bond_dev ; INIT_LIST_HEAD ( & bond -> vlan_list ) ; ether_setup ( bond_dev ) ; bond_dev -> netdev_ops = & bond_netdev_ops ; bond_dev -> ethtool_ops = & bond_ethtool_ops ; bond_set_mode_ops ( bond , bond -> params . mode ) ; bond_dev -> destructor = bond_destructor ; bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; bond_dev -> priv_flags |= IFF_BONDING ; <S2SV_StartBug> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ; bond_dev -> features |= NETIF_F_LLTX ; bond_dev -> hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER ; bond_dev -> hw_features &= ~ ( NETIF_F_ALL_CSUM & ~ NETIF_F_NO_CSUM ) ; bond_dev -> features |= bond_dev -> hw_features ; }
CWE-119 static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) { GetByteContext * gb = & s -> gb ; RangeCoder * rc = & s -> rc ; unsigned totfr = pixel -> total_freq ; unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; int i , j , ret , c , cnt_c ; if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) return ret ; while ( x < 16 ) { cnt_x = pixel -> lookup [ x ] ; if ( value >= cumfr + cnt_x ) cumfr += cnt_x ; else break ; x ++ ; } c = x * 16 ; cnt_c = 0 ; while ( c < 256 ) { cnt_c = pixel -> freq [ c ] ; if ( value >= cumfr + cnt_c ) cumfr += cnt_c ; else break ; c ++ ; } <S2SV_StartBug> if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) <S2SV_EndBug> return ret ; pixel -> freq [ c ] = cnt_c + step ; pixel -> lookup [ x ] = cnt_x + step ; totfr += step ; if ( totfr > BOT ) { totfr = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; pixel -> freq [ i ] = nc ; totfr += nc ; } for ( i = 0 ; i < 16 ; i ++ ) { unsigned sum = 0 ; unsigned i16_17 = i << 4 ; for ( j = 0 ; j < 16 ; j ++ ) sum += pixel -> freq [ i16_17 + j ] ; pixel -> lookup [ i ] = sum ; } } pixel -> total_freq = totfr ; * rval = c & s -> cbits ; return 0 ; }
CWE-119 static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; <S2SV_StartBug> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_EndBug> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; return 0 ; }
CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
CWE-416 static PHP_MINIT_FUNCTION ( zip ) { # ifdef PHP_ZIP_USE_OO zend_class_entry ce ; memcpy ( & zip_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; zip_object_handlers . clone_obj = NULL ; zip_object_handlers . get_property_ptr_ptr = php_zip_get_property_ptr_ptr ; <S2SV_StartBug> zip_object_handlers . get_properties = php_zip_get_properties ; <S2SV_EndBug> zip_object_handlers . read_property = php_zip_read_property ; zip_object_handlers . has_property = php_zip_has_property ; INIT_CLASS_ENTRY ( ce , "ZipArchive" , zip_class_functions ) ; ce . create_object = php_zip_object_new ; zip_class_entry = zend_register_internal_class ( & ce TSRMLS_CC ) ; zend_hash_init ( & zip_prop_handlers , 0 , NULL , NULL , 1 ) ; php_zip_register_prop_handler ( & zip_prop_handlers , "status" , php_zip_status , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , "statusSys" , php_zip_status_sys , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , "numFiles" , php_zip_get_num_files , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , "filename" , NULL , NULL , php_zipobj_get_filename , IS_STRING TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , "comment" , NULL , php_zipobj_get_zip_comment , NULL , IS_STRING TSRMLS_CC ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CREATE" , ZIP_CREATE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "EXCL" , ZIP_EXCL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CHECKCONS" , ZIP_CHECKCONS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "OVERWRITE" , ZIP_OVERWRITE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "FL_NOCASE" , ZIP_FL_NOCASE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "FL_NODIR" , ZIP_FL_NODIR ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "FL_COMPRESSED" , ZIP_FL_COMPRESSED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "FL_UNCHANGED" , ZIP_FL_UNCHANGED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_DEFAULT" , ZIP_CM_DEFAULT ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_STORE" , ZIP_CM_STORE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_SHRINK" , ZIP_CM_SHRINK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_REDUCE_1" , ZIP_CM_REDUCE_1 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_REDUCE_2" , ZIP_CM_REDUCE_2 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_REDUCE_3" , ZIP_CM_REDUCE_3 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_REDUCE_4" , ZIP_CM_REDUCE_4 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_IMPLODE" , ZIP_CM_IMPLODE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_DEFLATE" , ZIP_CM_DEFLATE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_DEFLATE64" , ZIP_CM_DEFLATE64 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_PKWARE_IMPLODE" , ZIP_CM_PKWARE_IMPLODE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_BZIP2" , ZIP_CM_BZIP2 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_LZMA" , ZIP_CM_LZMA ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_TERSE" , ZIP_CM_TERSE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_LZ77" , ZIP_CM_LZ77 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_WAVPACK" , ZIP_CM_WAVPACK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "CM_PPMD" , ZIP_CM_PPMD ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_OK" , ZIP_ER_OK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_MULTIDISK" , ZIP_ER_MULTIDISK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_RENAME" , ZIP_ER_RENAME ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_CLOSE" , ZIP_ER_CLOSE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_SEEK" , ZIP_ER_SEEK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_READ" , ZIP_ER_READ ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_WRITE" , ZIP_ER_WRITE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_CRC" , ZIP_ER_CRC ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_ZIPCLOSED" , ZIP_ER_ZIPCLOSED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_NOENT" , ZIP_ER_NOENT ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_EXISTS" , ZIP_ER_EXISTS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_OPEN" , ZIP_ER_OPEN ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_TMPOPEN" , ZIP_ER_TMPOPEN ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_ZLIB" , ZIP_ER_ZLIB ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_MEMORY" , ZIP_ER_MEMORY ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_CHANGED" , ZIP_ER_CHANGED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_COMPNOTSUPP" , ZIP_ER_COMPNOTSUPP ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_EOF" , ZIP_ER_EOF ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_INVAL" , ZIP_ER_INVAL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_NOZIP" , ZIP_ER_NOZIP ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_INTERNAL" , ZIP_ER_INTERNAL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_INCONS" , ZIP_ER_INCONS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_REMOVE" , ZIP_ER_REMOVE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( "ER_DELETED" , ZIP_ER_DELETED ) ; php_register_url_stream_wrapper ( "zip" , & php_stream_zip_wrapper TSRMLS_CC ) ; # endif le_zip_dir = zend_register_list_destructors_ex ( php_zip_free_dir , NULL , le_zip_dir_name , module_number ) ; le_zip_entry = zend_register_list_destructors_ex ( php_zip_free_entry , NULL , le_zip_entry_name , module_number ) ; return SUCCESS ; }
CWE-119 void vp9_setup_block_planes ( MACROBLOCKD * xd , int ss_x , int ss_y ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { xd -> plane [ i ] . plane_type = i ? PLANE_TYPE_UV : PLANE_TYPE_Y ; xd -> plane [ i ] . subsampling_x = i ? ss_x : 0 ; xd -> plane [ i ] . subsampling_y = i ? ss_y : 0 ; } <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> xd -> plane [ 3 ] . plane_type = PLANE_TYPE_Y ; xd -> plane [ 3 ] . subsampling_x = 0 ; xd -> plane [ 3 ] . subsampling_y = 0 ; # endif }
CWE-119 static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; <S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num ++ ; if ( ctx -> tx_seq_num == 0 ) ctx -> tx_seq_num = 1 ; spin_lock ( & eb -> lock ) ; if ( oz_queue_elt_info ( eb , 0 , 0 , ei ) == 0 ) ei = NULL ; spin_unlock ( & eb -> lock ) ; } spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; out : if ( ei ) { count = 0 ; spin_lock_bh ( & eb -> lock ) ; oz_elt_info_free ( eb , ei ) ; spin_unlock_bh ( & eb -> lock ) ; } oz_pd_put ( pd ) ; return count ; }
CWE-119 static void iriap_getvaluebyclass_indication ( struct iriap_cb * self , struct sk_buff * skb ) { struct ias_object * obj ; struct ias_attrib * attrib ; int name_len ; int attr_len ; char name [ IAS_MAX_CLASSNAME + 1 ] ; char attr [ IAS_MAX_ATTRIBNAME + 1 ] ; __u8 * fp ; int n ; IRDA_DEBUG ( 4 , "%s()\\n" , __func__ ) ; IRDA_ASSERT ( self != NULL , return ; ) ; IRDA_ASSERT ( self -> magic == IAS_MAGIC , return ; ) ; IRDA_ASSERT ( skb != NULL , return ; ) ; fp = skb -> data ; n = 1 ; name_len = fp [ n ++ ] ; <S2SV_StartBug> memcpy ( name , fp + n , name_len ) ; n += name_len ; <S2SV_EndBug> name [ name_len ] = '\\0' ; <S2SV_StartBug> attr_len = fp [ n ++ ] ; <S2SV_EndBug> memcpy ( attr , fp + n , attr_len ) ; n += attr_len ; attr [ attr_len ] = '\\0' ; IRDA_DEBUG ( 4 , "LM-IAS:<S2SV_blank>Looking<S2SV_blank>up<S2SV_blank>%s:<S2SV_blank>%s\\n" , name , attr ) ; obj = irias_find_object ( name ) ; if ( obj == NULL ) { IRDA_DEBUG ( 2 , "LM-IAS:<S2SV_blank>Object<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found\\n" , name ) ; iriap_getvaluebyclass_response ( self , 0x1235 , IAS_CLASS_UNKNOWN , & irias_missing ) ; return ; } IRDA_DEBUG ( 4 , "LM-IAS:<S2SV_blank>found<S2SV_blank>%s,<S2SV_blank>id=%d\\n" , obj -> name , obj -> id ) ; attrib = irias_find_attrib ( obj , attr ) ; if ( attrib == NULL ) { IRDA_DEBUG ( 2 , "LM-IAS:<S2SV_blank>Attribute<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found\\n" , attr ) ; iriap_getvaluebyclass_response ( self , obj -> id , IAS_ATTRIB_UNKNOWN , & irias_missing ) ; return ; } iriap_getvaluebyclass_response ( self , obj -> id , IAS_SUCCESS , attrib -> value ) ; }
CWE-362 hsm_com_errno_t unix_client_connect ( hsm_com_client_hdl_t * hdl ) { int fd , len ; struct sockaddr_un unix_addr ; <S2SV_StartBug> if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) <S2SV_EndBug> { return HSM_COM_ERROR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) { <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> return HSM_COM_PATH_ERR ; } snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , "%s" , hdl -> c_path ) ; len = SUN_LEN ( & unix_addr ) ; unlink ( unix_addr . sun_path ) ; if ( bind ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) { <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> close ( fd ) ; return HSM_COM_BIND_ERR ; } if ( chmod ( unix_addr . sun_path , S_IRWXU ) < 0 ) { <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> close ( fd ) ; return HSM_COM_CHMOD_ERR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; strncpy ( unix_addr . sun_path , hdl -> s_path , sizeof ( unix_addr . sun_path ) ) ; unix_addr . sun_path [ sizeof ( unix_addr . sun_path ) - 1 ] = 0 ; len = SUN_LEN ( & unix_addr ) ; if ( connect ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) { <S2SV_StartBug> unlink ( hdl -> c_path ) ; <S2SV_EndBug> close ( fd ) ; return HSM_COM_CONX_ERR ; } hdl -> client_fd = fd ; hdl -> client_state = HSM_COM_C_STATE_CT ; if ( unix_sck_send_conn ( hdl , 2 ) != HSM_COM_OK ) { hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_StartBug> return HSM_COM_SEND_ERR ; <S2SV_EndBug> } return HSM_COM_OK ; }
CWE-119 int vpx_img_read ( vpx_image_t * img , FILE * file ) { int plane ; for ( plane = 0 ; plane < 3 ; ++ plane ) { unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; <S2SV_StartBug> const int w = vpx_img_plane_width ( img , plane ) ; <S2SV_EndBug> const int h = vpx_img_plane_height ( img , plane ) ; int y ; for ( y = 0 ; y < h ; ++ y ) { <S2SV_StartBug> if ( fread ( buf , 1 , w , file ) != w ) <S2SV_EndBug> return 0 ; buf += stride ; } } return 1 ; }
CWE-000 static int unix_dgram_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; struct sockaddr_un * sunaddr = msg -> msg_name ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie tmp_scm ; int max_level ; int data_len = 0 ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( siocb -> scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; unix_get_secdata ( siocb -> scm , skb ) ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iovec ( skb , 0 , msg -> msg_iov , 0 , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } unix_state_lock ( other ) ; err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_unlock ( other ) ; sock_put ( other ) ; err = 0 ; unix_state_lock ( sk ) ; if ( unix_peer ( sk ) == other ) { unix_peer ( sk ) = NULL ; unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { if ( ! timeo ) { err = - EAGAIN ; goto out_unlock ; } timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , len ) ; sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return len ; out_unlock : unix_state_unlock ( other ) ; out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return err ; }
CWE-119 int nntp_add_group ( char * line , void * data ) { struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> char desc [ HUGE_STRING ] = "" ; char mod ; anum_t first , last ; if ( ! nserv || ! line ) return 0 ; <S2SV_StartBug> if ( sscanf ( line , "%s<S2SV_blank>" ANUM "<S2SV_blank>" ANUM "<S2SV_blank>%c<S2SV_blank>%[^\\n]" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> nntp_data = nntp_data_find ( nserv , group ) ; nntp_data -> deleted = false ; nntp_data -> first_message = first ; nntp_data -> last_message = last ; nntp_data -> allowed = ( mod == 'y' ) || ( mod == 'm' ) ; mutt_str_replace ( & nntp_data -> desc , desc ) ; if ( nntp_data -> newsrc_ent || nntp_data -> last_cached ) nntp_group_unread_stat ( nntp_data ) ; else if ( nntp_data -> last_message && nntp_data -> first_message <= nntp_data -> last_message ) nntp_data -> unread = nntp_data -> last_message - nntp_data -> first_message + 1 ; else nntp_data -> unread = 0 ; return 0 ; }
CWE-000 bool_t auth_gssapi_unwrap_data ( OM_uint32 * major , OM_uint32 * minor , gss_ctx_id_t context , uint32_t seq_num , XDR * in_xdrs , bool_t ( * xdr_func ) ( ) , caddr_t xdr_ptr ) { gss_buffer_desc in_buf , out_buf ; XDR temp_xdrs ; uint32_t verf_seq_num ; int conf , qop ; unsigned int length ; PRINTF ( ( "gssapi_unwrap_data:<S2SV_blank>starting\\n" ) ) ; * major = GSS_S_COMPLETE ; * minor = 0 ; in_buf . value = NULL ; out_buf . value = NULL ; if ( ! xdr_bytes ( in_xdrs , ( char * * ) & in_buf . value , & length , ( unsigned int ) - 1 ) ) { PRINTF ( ( "gssapi_unwrap_data:<S2SV_blank>deserializing<S2SV_blank>encrypted<S2SV_blank>data<S2SV_blank>failed\\n" ) ) ; temp_xdrs . x_op = XDR_FREE ; ( void ) xdr_bytes ( & temp_xdrs , ( char * * ) & in_buf . value , & length , ( unsigned int ) - 1 ) ; return FALSE ; } in_buf . length = length ; * major = gss_unseal ( minor , context , & in_buf , & out_buf , & conf , & qop ) ; free ( in_buf . value ) ; if ( * major != GSS_S_COMPLETE ) return FALSE ; PRINTF ( ( "gssapi_unwrap_data:<S2SV_blank>%llu<S2SV_blank>bytes<S2SV_blank>data,<S2SV_blank>%llu<S2SV_blank>bytes<S2SV_blank>sealed\\n" , ( unsigned long long ) out_buf . length , ( unsigned long long ) in_buf . length ) ) ; xdrmem_create ( & temp_xdrs , out_buf . value , out_buf . length , XDR_DECODE ) ; if ( ! xdr_u_int32 ( & temp_xdrs , & verf_seq_num ) ) { PRINTF ( ( "gssapi_unwrap_data:<S2SV_blank>deserializing<S2SV_blank>verf_seq_num<S2SV_blank>failed\\n" ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } if ( verf_seq_num != seq_num ) { PRINTF ( ( "gssapi_unwrap_data:<S2SV_blank>seq<S2SV_blank>%d<S2SV_blank>specified,<S2SV_blank>read<S2SV_blank>%d\\n" , seq_num , verf_seq_num ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } PRINTF ( ( "gssapi_unwrap_data:<S2SV_blank>unwrap<S2SV_blank>seq_num<S2SV_blank>%d<S2SV_blank>okay\\n" , verf_seq_num ) ) ; if ( ! ( * xdr_func ) ( & temp_xdrs , xdr_ptr ) ) { PRINTF ( ( "gssapi_unwrap_data:<S2SV_blank>deserializing<S2SV_blank>arguments<S2SV_blank>failed\\n" ) ) ; gss_release_buffer ( minor , & out_buf ) ; <S2SV_StartBug> xdr_free ( xdr_func , xdr_ptr ) ; <S2SV_EndBug> XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } PRINTF ( ( "gssapi_unwrap_data:<S2SV_blank>succeeding\\n\\n" ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return TRUE ; }
CWE-416 int ppp_register_net_channel ( struct net * net , struct ppp_channel * chan ) { struct channel * pch ; struct ppp_net * pn ; pch = kzalloc ( sizeof ( struct channel ) , GFP_KERNEL ) ; if ( ! pch ) return - ENOMEM ; pn = ppp_pernet ( net ) ; pch -> ppp = NULL ; pch -> chan = chan ; <S2SV_StartBug> pch -> chan_net = net ; <S2SV_EndBug> chan -> ppp = pch ; init_ppp_file ( & pch -> file , CHANNEL ) ; pch -> file . hdrlen = chan -> hdrlen ; # ifdef CONFIG_PPP_MULTILINK pch -> lastseq = - 1 ; # endif init_rwsem ( & pch -> chan_sem ) ; spin_lock_init ( & pch -> downl ) ; rwlock_init ( & pch -> upl ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; pch -> file . index = ++ pn -> last_channel_index ; list_add ( & pch -> list , & pn -> new_channels ) ; atomic_inc ( & channel_count ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; return 0 ; }
CWE-264 static int multipath_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct multipath * m = ( struct multipath * ) ti -> private ; struct block_device * bdev = NULL ; fmode_t mode = 0 ; unsigned long flags ; int r = 0 ; spin_lock_irqsave ( & m -> lock , flags ) ; if ( ! m -> current_pgpath ) __choose_pgpath ( m , 0 ) ; if ( m -> current_pgpath ) { bdev = m -> current_pgpath -> path . dev -> bdev ; mode = m -> current_pgpath -> path . dev -> mode ; } if ( m -> queue_io ) r = - EAGAIN ; else if ( ! bdev ) r = - EIO ; spin_unlock_irqrestore ( & m -> lock , flags ) ; <S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> }
CWE-000 <S2SV_StartBug> static int expandRegular ( rpmfi fi , const char * dest , rpmpsm psm , int nodigest , int nocontent ) <S2SV_EndBug> { FD_t wfd = NULL ; int rc = 0 ; { mode_t old_umask = umask ( 0577 ) ; <S2SV_StartBug> wfd = Fopen ( dest , "w.ufdio" ) ; <S2SV_EndBug> <S2SV_StartBug> umask ( old_umask ) ; <S2SV_EndBug> } if ( Ferror ( wfd ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; } if ( ! nocontent ) rc = rpmfiArchiveReadToFilePsm ( fi , wfd , nodigest , psm ) ; exit : if ( wfd ) { int myerrno = errno ; Fclose ( wfd ) ; errno = myerrno ; } return rc ; }
CWE-000 uint16_t http_DissectRequest ( struct sess * sp ) { struct http_conn * htc ; struct http * hp ; uint16_t retval ; CHECK_OBJ_NOTNULL ( sp , SESS_MAGIC ) ; htc = sp -> htc ; CHECK_OBJ_NOTNULL ( htc , HTTP_CONN_MAGIC ) ; hp = sp -> http ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; hp -> logtag = HTTP_Rx ; retval = http_splitline ( sp -> wrk , sp -> fd , hp , htc , HTTP_HDR_REQ , HTTP_HDR_URL , HTTP_HDR_PROTO ) ; if ( retval != 0 ) { WSPR ( sp , SLT_HttpGarbage , htc -> rxbuf ) ; return ( retval ) ; } http_ProtoVer ( hp ) ; <S2SV_StartBug> retval = htc_request_check_host_hdr ( hp ) ; <S2SV_EndBug> if ( retval != 0 ) { <S2SV_StartBug> WSP ( sp , SLT_Error , "Duplicated<S2SV_blank>Host<S2SV_blank>header" ) ; <S2SV_EndBug> return ( retval ) ; } <S2SV_StartBug> return ( retval ) ; <S2SV_EndBug> }
CWE-787 opj_image_t * pgxtoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f = NULL ; int w , h , prec ; int i , numcomps , max ; OPJ_COLOR_SPACE color_space ; opj_image_cmptparm_t cmptparm ; opj_image_t * image = NULL ; int adjustS , ushift , dshift , force8 ; char endian1 , endian2 , sign ; char signtmp [ 32 ] ; char temp [ 32 ] ; int bigendian ; opj_image_comp_t * comp = NULL ; numcomps = 1 ; color_space = OPJ_CLRSPC_GRAY ; memset ( & cmptparm , 0 , sizeof ( opj_image_cmptparm_t ) ) ; max = 0 ; f = fopen ( filename , "rb" ) ; if ( ! f ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!\\n" , filename ) ; return NULL ; } fseek ( f , 0 , SEEK_SET ) ; <S2SV_StartBug> if ( fscanf ( f , "PG%[<S2SV_blank>\\t]%c%c%[<S2SV_blank>\\t+-]%d%[<S2SV_blank>\\t]%d%[<S2SV_blank>\\t]%d" , temp , & endian1 , <S2SV_EndBug> & endian2 , signtmp , & prec , temp , & w , temp , & h ) != 9 ) { fclose ( f ) ; fprintf ( stderr , "ERROR:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>right<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>from<S2SV_blank>the<S2SV_blank>fscanf()<S2SV_blank>function!\\n" ) ; return NULL ; } i = 0 ; sign = '+' ; while ( signtmp [ i ] != '\\0' ) { if ( signtmp [ i ] == '-' ) { sign = '-' ; } i ++ ; } fgetc ( f ) ; if ( endian1 == 'M' && endian2 == 'L' ) { bigendian = 1 ; } else if ( endian2 == 'M' && endian1 == 'L' ) { bigendian = 0 ; } else { fclose ( f ) ; fprintf ( stderr , "Bad<S2SV_blank>pgx<S2SV_blank>header,<S2SV_blank>please<S2SV_blank>check<S2SV_blank>input<S2SV_blank>file\\n" ) ; return NULL ; } cmptparm . x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; cmptparm . y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; cmptparm . w = ! cmptparm . x0 ? ( OPJ_UINT32 ) ( ( w - 1 ) * parameters -> subsampling_dx + 1 ) : cmptparm . x0 + ( OPJ_UINT32 ) ( w - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dx + 1 ; cmptparm . h = ! cmptparm . y0 ? ( OPJ_UINT32 ) ( ( h - 1 ) * parameters -> subsampling_dy + 1 ) : cmptparm . y0 + ( OPJ_UINT32 ) ( h - 1 ) * ( OPJ_UINT32 ) parameters -> subsampling_dy + 1 ; if ( sign == '-' ) { cmptparm . sgnd = 1 ; } else { cmptparm . sgnd = 0 ; } if ( prec < 8 ) { force8 = 1 ; ushift = 8 - prec ; dshift = prec - ushift ; if ( cmptparm . sgnd ) { adjustS = ( 1 << ( prec - 1 ) ) ; } else { adjustS = 0 ; } cmptparm . sgnd = 0 ; prec = 8 ; } else { ushift = dshift = force8 = adjustS = 0 ; } cmptparm . prec = ( OPJ_UINT32 ) prec ; cmptparm . bpp = ( OPJ_UINT32 ) prec ; cmptparm . dx = ( OPJ_UINT32 ) parameters -> subsampling_dx ; cmptparm . dy = ( OPJ_UINT32 ) parameters -> subsampling_dy ; image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = cmptparm . x0 ; image -> y0 = cmptparm . x0 ; image -> x1 = cmptparm . w ; image -> y1 = cmptparm . h ; comp = & image -> comps [ 0 ] ; for ( i = 0 ; i < w * h ; i ++ ) { int v ; if ( force8 ) { v = readuchar ( f ) + adjustS ; v = ( v << ushift ) + ( v >> dshift ) ; comp -> data [ i ] = ( unsigned char ) v ; if ( v > max ) { max = v ; } continue ; } if ( comp -> prec == 8 ) { if ( ! comp -> sgnd ) { v = readuchar ( f ) ; } else { v = ( char ) readuchar ( f ) ; } } else if ( comp -> prec <= 16 ) { if ( ! comp -> sgnd ) { v = readushort ( f , bigendian ) ; } else { v = ( short ) readushort ( f , bigendian ) ; } } else { if ( ! comp -> sgnd ) { v = ( int ) readuint ( f , bigendian ) ; } else { v = ( int ) readuint ( f , bigendian ) ; } } if ( v > max ) { max = v ; } comp -> data [ i ] = v ; } fclose ( f ) ; comp -> bpp = ( OPJ_UINT32 ) int_floorlog2 ( max ) + 1 ; return image ; }
CWE-119 int main ( int argc , char * argv [ ] ) { char * fin , * fout ; FILE * fpin , * fpout ; uint8_t * inbuf , * outbuf ; uint8_t * inbuf_u , * outbuf_u ; uint8_t * inbuf_v , * outbuf_v ; int f , frames ; <S2SV_StartBug> int width , height , target_width , target_height ; <S2SV_EndBug> if ( argc < 5 ) { printf ( "Incorrect<S2SV_blank>parameters:\\n" ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } fin = argv [ 1 ] ; fout = argv [ 4 ] ; if ( ! parse_dim ( argv [ 2 ] , & width , & height ) ) { printf ( "Incorrect<S2SV_blank>parameters:<S2SV_blank>%s\\n" , argv [ 2 ] ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } if ( ! parse_dim ( argv [ 3 ] , & target_width , & target_height ) ) { printf ( "Incorrect<S2SV_blank>parameters:<S2SV_blank>%s\\n" , argv [ 3 ] ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } fpin = fopen ( fin , "rb" ) ; if ( fpin == NULL ) { printf ( "Can\'t<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>read\\n" , fin ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } fpout = fopen ( fout , "wb" ) ; if ( fpout == NULL ) { printf ( "Can\'t<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>write\\n" , fout ) ; <S2SV_StartBug> usage ( argv [ 0 ] ) ; <S2SV_EndBug> return 1 ; } if ( argc >= 6 ) frames = atoi ( argv [ 5 ] ) ; else frames = INT_MAX ; printf ( "Input<S2SV_blank>size:<S2SV_blank><S2SV_blank>%dx%d\\n" , width , height ) ; printf ( "Target<S2SV_blank>size:<S2SV_blank>%dx%d,<S2SV_blank>Frames:<S2SV_blank>" , target_width , target_height ) ; if ( frames == INT_MAX ) printf ( "All\\n" ) ; else printf ( "%d\\n" , frames ) ; inbuf = ( uint8_t * ) malloc ( width * height * 3 / 2 ) ; outbuf = ( uint8_t * ) malloc ( target_width * target_height * 3 / 2 ) ; inbuf_u = inbuf + width * height ; inbuf_v = inbuf_u + width * height / 4 ; outbuf_u = outbuf + target_width * target_height ; outbuf_v = outbuf_u + target_width * target_height / 4 ; f = 0 ; while ( f < frames ) { if ( fread ( inbuf , width * height * 3 / 2 , 1 , fpin ) != 1 ) break ; vp9_resize_frame420 ( inbuf , width , inbuf_u , inbuf_v , width / 2 , height , width , outbuf , target_width , outbuf_u , outbuf_v , target_width / 2 , target_height , target_width ) ; fwrite ( outbuf , target_width * target_height * 3 / 2 , 1 , fpout ) ; f ++ ; } printf ( "%d<S2SV_blank>frames<S2SV_blank>processed\\n" , f ) ; fclose ( fpin ) ; fclose ( fpout ) ; free ( inbuf ) ; free ( outbuf ) ; return 0 ; }
CWE-125 void __skb_tstamp_tx ( struct sk_buff * orig_skb , struct skb_shared_hwtstamps * hwtstamps , struct sock * sk , int tstype ) { struct sk_buff * skb ; <S2SV_StartBug> bool tsonly ; <S2SV_EndBug> if ( ! sk ) return ; tsonly = sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY ; if ( ! skb_may_tx_timestamp ( sk , tsonly ) ) return ; if ( tsonly ) { # ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && <S2SV_StartBug> sk -> sk_type == SOCK_STREAM ) <S2SV_EndBug> skb = tcp_get_timestamping_opt_stats ( sk ) ; <S2SV_StartBug> else <S2SV_EndBug> # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ; } else { skb = skb_clone ( orig_skb , GFP_ATOMIC ) ; } if ( ! skb ) return ; if ( tsonly ) { skb_shinfo ( skb ) -> tx_flags = skb_shinfo ( orig_skb ) -> tx_flags ; skb_shinfo ( skb ) -> tskey = skb_shinfo ( orig_skb ) -> tskey ; } if ( hwtstamps ) * skb_hwtstamps ( skb ) = * hwtstamps ; else skb -> tstamp = ktime_get_real ( ) ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <S2SV_EndBug> }
CWE-119 void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , unsigned char abs_delta ) { seg -> abs_delta = abs_delta ; <S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug> }
CWE-200 static int create_problem_dir ( GHashTable * problem_info , unsigned pid ) { if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) exit ( 1 ) ; } gchar * dir_basename = g_hash_table_lookup ( problem_info , "basename" ) ; if ( ! dir_basename ) dir_basename = g_hash_table_lookup ( problem_info , FILENAME_TYPE ) ; char * path = xasprintf ( "%s/%s-%s-%u.new" , g_settings_dump_location , dir_basename , iso_date_string ( NULL ) , pid ) ; g_hash_table_remove ( problem_info , "basename" ) ; <S2SV_StartBug> struct dump_dir * dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> if ( ! dd ) { error_msg_and_die ( "Error<S2SV_blank>creating<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>\'%s\'" , path ) ; } dd_create_basic_files ( dd , client_uid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; gpointer gpkey = g_hash_table_lookup ( problem_info , FILENAME_CMDLINE ) ; if ( ! gpkey ) { char * cmdline = get_cmdline ( pid ) ; if ( cmdline ) { dd_save_text ( dd , FILENAME_CMDLINE , cmdline ) ; free ( cmdline ) ; } } char uid_str [ sizeof ( long ) * 3 + 2 ] ; sprintf ( uid_str , "%lu" , ( long ) client_uid ) ; dd_save_text ( dd , FILENAME_UID , uid_str ) ; GHashTableIter iter ; gpointer gpvalue ; g_hash_table_iter_init ( & iter , problem_info ) ; while ( g_hash_table_iter_next ( & iter , & gpkey , & gpvalue ) ) { dd_save_text ( dd , ( gchar * ) gpkey , ( gchar * ) gpvalue ) ; } dd_close ( dd ) ; g_hash_table_destroy ( problem_info ) ; char * newpath = xstrndup ( path , strlen ( path ) - strlen ( ".new" ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log_notice ( "Saved<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>\'%s\'" , pid , path ) ; printf ( "HTTP/1.1<S2SV_blank>201<S2SV_blank>Created\\r\\n\\r\\n" ) ; fflush ( NULL ) ; close ( STDOUT_FILENO ) ; xdup2 ( STDERR_FILENO , STDOUT_FILENO ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { trim_problem_dirs ( g_settings_dump_location , g_settings_nMaxCrashReportsSize * ( double ) ( 1024 * 1024 ) , path ) ; } run_post_create ( path ) ; exit ( 0 ) ; }
CWE-125 <S2SV_StartBug> int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ; Stream_Read_UINT16 ( s , fields -> Len ) ; Stream_Read_UINT16 ( s , fields -> MaxLen ) ; Stream_Read_UINT32 ( s , fields -> BufferOffset ) ; return 1 ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_active_map_t * data = va_arg ( args , vpx_active_map_t * ) ; if ( data ) { vpx_active_map_t * map = ( vpx_active_map_t * ) data ; if ( ! vp8_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-000 static int compile_search ( struct Context * ctx , const struct Pattern * pat , struct Buffer * buf ) { if ( do_search ( pat , 0 ) == 0 ) return 0 ; if ( pat -> not ) mutt_buffer_addstr ( buf , "NOT<S2SV_blank>" ) ; if ( pat -> child ) { int clauses ; clauses = do_search ( pat -> child , 1 ) ; if ( clauses > 0 ) { const struct Pattern * clause = pat -> child ; mutt_buffer_addch ( buf , '(' ) ; while ( clauses ) { if ( do_search ( clause , 0 ) ) { if ( pat -> op == MUTT_OR && clauses > 1 ) mutt_buffer_addstr ( buf , "OR<S2SV_blank>" ) ; clauses -- ; if ( compile_search ( ctx , clause , buf ) < 0 ) return - 1 ; if ( clauses ) mutt_buffer_addch ( buf , '<S2SV_blank>' ) ; } clause = clause -> next ; } mutt_buffer_addch ( buf , ')' ) ; } } else { char term [ STRING ] ; char * delim = NULL ; switch ( pat -> op ) { case MUTT_HEADER : mutt_buffer_addstr ( buf , "HEADER<S2SV_blank>" ) ; delim = strchr ( pat -> p . str , ':' ) ; if ( ! delim ) { mutt_error ( _ ( "Header<S2SV_blank>search<S2SV_blank>without<S2SV_blank>header<S2SV_blank>name:<S2SV_blank>%s" ) , pat -> p . str ) ; return - 1 ; } * delim = '\\0' ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; mutt_buffer_addch ( buf , '<S2SV_blank>' ) ; * delim = ':' ; delim ++ ; SKIPWS ( delim ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , delim ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_BODY : mutt_buffer_addstr ( buf , "BODY<S2SV_blank>" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_WHOLE_MSG : mutt_buffer_addstr ( buf , "TEXT<S2SV_blank>" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_SERVERSEARCH : { struct ImapData * idata = ctx -> data ; if ( ! mutt_bit_isset ( idata -> capabilities , X_GM_EXT1 ) ) { mutt_error ( _ ( "Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s" ) , pat -> p . str ) ; return - 1 ; } } mutt_buffer_addstr ( buf , "X-GM-RAW<S2SV_blank>" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; } } return 0 ; }
CWE-125 static ssize_t next_line ( struct archive_read * a , const char * * b , ssize_t * avail , ssize_t * ravail , ssize_t * nl ) { ssize_t len ; int quit ; quit = 0 ; if ( * avail == 0 ) { * nl = 0 ; len = 0 ; } else len = get_line_size ( * b , * avail , nl ) ; while ( * nl == 0 && len == * avail && ! quit ) { ssize_t diff = * ravail - * avail ; size_t nbytes_req = ( * ravail + 1023 ) & ~ 1023U ; ssize_t tested ; if ( nbytes_req < ( size_t ) * ravail + 160 ) nbytes_req <<= 1 ; * b = __archive_read_ahead ( a , nbytes_req , avail ) ; if ( * b == NULL ) { if ( * ravail >= * avail ) return ( 0 ) ; * b = __archive_read_ahead ( a , * avail , avail ) ; quit = 1 ; } * ravail = * avail ; * b += diff ; * avail -= diff ; tested = len ; <S2SV_StartBug> len = get_line_size ( * b , * avail , nl ) ; <S2SV_EndBug> if ( len >= 0 ) len += tested ; } return ( len ) ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t ctrl_set_svc_layer_id ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_svc_layer_id_t * const data = va_arg ( args , vpx_svc_layer_id_t * ) ; VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ; SVC * const svc = & cpi -> svc ; svc -> spatial_layer_id = data -> spatial_layer_id ; svc -> temporal_layer_id = data -> temporal_layer_id ; if ( svc -> temporal_layer_id < 0 || svc -> temporal_layer_id >= ( int ) ctx -> cfg . ts_number_layers ) { return VPX_CODEC_INVALID_PARAM ; } if ( svc -> spatial_layer_id < 0 || svc -> spatial_layer_id >= ( int ) ctx -> cfg . ss_number_layers ) { return VPX_CODEC_INVALID_PARAM ; } return VPX_CODEC_OK ; }
CWE-284 static void * listen_fn_ ( UNUSED_ATTR void * context ) { prctl ( PR_SET_NAME , ( unsigned long ) LISTEN_THREAD_NAME_ , 0 , 0 , 0 ) ; listen_socket_ = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( listen_socket_ == - 1 ) { LOG_ERROR ( "%s<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; goto cleanup ; } int enable = 1 ; if ( setsockopt ( listen_socket_ , SOL_SOCKET , SO_REUSEADDR , & enable , sizeof ( enable ) ) == - 1 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>SO_REUSEADDR:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; goto cleanup ; } struct sockaddr_in addr ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = htonl ( LOCALHOST_ ) ; addr . sin_port = htons ( LISTEN_PORT_ ) ; if ( bind ( listen_socket_ , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>listen<S2SV_blank>socket:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; goto cleanup ; } if ( listen ( listen_socket_ , 10 ) == - 1 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>listen:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; goto cleanup ; } for ( ; ; ) { <S2SV_StartBug> int client_socket = accept ( listen_socket_ , NULL , NULL ) ; <S2SV_EndBug> if ( client_socket == - 1 ) { if ( errno == EINVAL || errno == EBADF ) { break ; } LOG_WARN ( "%s<S2SV_blank>error<S2SV_blank>accepting<S2SV_blank>socket:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; continue ; } pthread_mutex_lock ( & client_socket_lock_ ) ; safe_close_ ( & client_socket_ ) ; client_socket_ = client_socket ; <S2SV_StartBug> send ( client_socket_ , "btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea" , 16 , 0 ) ; <S2SV_EndBug> pthread_mutex_unlock ( & client_socket_lock_ ) ; } cleanup : safe_close_ ( & listen_socket_ ) ; return NULL ; }
CWE-476 static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( "RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }
CWE-000 STATIC int xfs_attr_shortform_addname ( xfs_da_args_t * args ) { int newsize , forkoff , retval ; trace_xfs_attr_sf_addname ( args ) ; retval = xfs_attr_shortform_lookup ( args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) { return retval ; } else if ( retval == - EEXIST ) { if ( args -> flags & ATTR_CREATE ) return retval ; retval = xfs_attr_shortform_remove ( args ) ; <S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> } if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX || args -> valuelen >= XFS_ATTR_SF_ENTSIZE_MAX ) return - ENOSPC ; newsize = XFS_ATTR_SF_TOTSIZE ( args -> dp ) ; newsize += XFS_ATTR_SF_ENTSIZE_BYNAME ( args -> namelen , args -> valuelen ) ; forkoff = xfs_attr_shortform_bytesfit ( args -> dp , newsize ) ; if ( ! forkoff ) return - ENOSPC ; xfs_attr_shortform_add ( args , forkoff ) ; return 0 ; }
CWE-20 static krb5_int32 find_referral_tgs ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , krb5_principal * krbtgt_princ ) { krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; char * * realms = NULL , * hostname = NULL ; krb5_data srealm = request -> server -> realm ; if ( ! is_referral_req ( kdc_active_realm , request ) ) goto cleanup ; hostname = data2string ( krb5_princ_component ( kdc_context , request -> server , 1 ) ) ; if ( hostname == NULL ) { retval = ENOMEM ; goto cleanup ; } if ( strchr ( hostname , '.' ) == NULL ) goto cleanup ; retval = krb5_get_host_realm ( kdc_context , hostname , & realms ) ; if ( retval ) { kdc_err ( kdc_context , retval , "unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>realm<S2SV_blank>of<S2SV_blank>host" ) ; goto cleanup ; } <S2SV_StartBug> if ( realms == NULL || realms [ 0 ] == '\\0' || <S2SV_EndBug> data_eq_string ( srealm , realms [ 0 ] ) ) { retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto cleanup ; } retval = krb5_build_principal ( kdc_context , krbtgt_princ , srealm . length , srealm . data , "krbtgt" , realms [ 0 ] , ( char * ) 0 ) ; cleanup : krb5_free_host_realm ( kdc_context , realms ) ; free ( hostname ) ; return retval ; }
CWE-416 void comps_rtree_unite ( COMPS_RTree * rt1 , COMPS_RTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_RTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> data != NULL ) { comps_rtree_set ( rt1 , pair -> key , rt2 -> data_cloner ( ( ( COMPS_RTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-119 static int format8BIM ( Image * ifile , Image * ofile ) { char temp [ MagickPathExtent ] ; unsigned int foundOSType ; int ID , resCount , i , c ; ssize_t count ; unsigned char * PString , * str ; resCount = 0 ; foundOSType = 0 ; ( void ) foundOSType ; c = ReadBlobByte ( ifile ) ; while ( c != EOF ) { if ( c == '8' ) { unsigned char buffer [ 5 ] ; buffer [ 0 ] = ( unsigned char ) c ; for ( i = 1 ; i < 4 ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; buffer [ i ] = ( unsigned char ) c ; } buffer [ 4 ] = 0 ; if ( strcmp ( ( const char * ) buffer , "8BIM" ) == 0 ) foundOSType = 1 ; else continue ; } else { c = ReadBlobByte ( ifile ) ; continue ; } ID = ReadBlobMSBSignedShort ( ifile ) ; if ( ID < 0 ) return ( - 1 ) ; { unsigned char plen ; c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; plen = ( unsigned char ) c ; PString = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( plen + MagickPathExtent ) , sizeof ( * PString ) ) ; if ( PString == ( unsigned char * ) NULL ) return 0 ; for ( i = 0 ; i < plen ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } PString [ i ] = ( unsigned char ) c ; } PString [ plen ] = 0 ; if ( ( plen & 0x01 ) == 0 ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } } } count = ( ssize_t ) ReadBlobMSBSignedLong ( ifile ) ; if ( ( count < 0 ) || ( count > GetBlobSize ( ifile ) ) ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } <S2SV_StartBug> str = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) count , sizeof ( * str ) ) ; <S2SV_EndBug> if ( str == ( unsigned char * ) NULL ) { PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return 0 ; } for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) { str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; return - 1 ; } str [ i ] = ( unsigned char ) c ; } if ( ID != THUMBNAIL_ID ) { if ( strlen ( ( const char * ) PString ) > 0 ) ( void ) FormatLocaleString ( temp , MagickPathExtent , "8BIM#%d#%s=" , ID , PString ) ; else ( void ) FormatLocaleString ( temp , MagickPathExtent , "8BIM#%d=" , ID ) ; ( void ) WriteBlobString ( ofile , temp ) ; if ( ID == IPTC_ID ) { formatString ( ofile , "IPTC" , 4 ) ; formatIPTCfromBuffer ( ofile , ( char * ) str , ( ssize_t ) count ) ; } else formatString ( ofile , ( char * ) str , ( ssize_t ) count ) ; } str = ( unsigned char * ) RelinquishMagickMemory ( str ) ; PString = ( unsigned char * ) RelinquishMagickMemory ( PString ) ; resCount ++ ; c = ReadBlobByte ( ifile ) ; } return resCount ; }
CWE-000 int tcp_disconnect ( struct sock * sk , int flags ) { struct inet_sock * inet = inet_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; int err = 0 ; int old_state = sk -> sk_state ; if ( old_state != TCP_CLOSE ) tcp_set_state ( sk , TCP_CLOSE ) ; if ( old_state == TCP_LISTEN ) { inet_csk_listen_stop ( sk ) ; } else if ( unlikely ( tp -> repair ) ) { sk -> sk_err = ECONNABORTED ; } else if ( tcp_need_reset ( old_state ) || ( tp -> snd_nxt != tp -> write_seq && ( 1 << old_state ) & ( TCPF_CLOSING | TCPF_LAST_ACK ) ) ) { tcp_send_active_reset ( sk , gfp_any ( ) ) ; sk -> sk_err = ECONNRESET ; } else if ( old_state == TCP_SYN_SENT ) sk -> sk_err = ECONNRESET ; tcp_clear_xmit_timers ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; tcp_write_queue_purge ( sk ) ; tcp_fastopen_active_disable_ofo_check ( sk ) ; skb_rbtree_purge ( & tp -> out_of_order_queue ) ; inet -> inet_dport = 0 ; if ( ! ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) ) inet_reset_saddr ( sk ) ; sk -> sk_shutdown = 0 ; sock_reset_flag ( sk , SOCK_DONE ) ; tp -> srtt_us = 0 ; tp -> write_seq += tp -> max_window + 2 ; if ( tp -> write_seq == 0 ) tp -> write_seq = 1 ; icsk -> icsk_backoff = 0 ; tp -> snd_cwnd = 2 ; icsk -> icsk_probes_out = 0 ; tp -> packets_out = 0 ; tp -> snd_ssthresh = TCP_INFINITE_SSTHRESH ; tp -> snd_cwnd_cnt = 0 ; tp -> window_clamp = 0 ; tcp_set_ca_state ( sk , TCP_CA_Open ) ; tcp_clear_retrans ( tp ) ; inet_csk_delack_init ( sk ) ; <S2SV_StartBug> tcp_init_send_head ( sk ) ; <S2SV_EndBug> memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ; __sk_dst_reset ( sk ) ; tcp_saved_syn_free ( tp ) ; tcp_free_fastopen_req ( tp ) ; inet -> defer_connect = 0 ; WARN_ON ( inet -> inet_num && ! icsk -> icsk_bind_hash ) ; sk -> sk_error_report ( sk ) ; return err ; }
CWE-000 static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , "" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) <S2SV_EndBug> js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }
CWE-20 static void keyring_describe ( const struct key * keyring , struct seq_file * m ) { if ( keyring -> description ) seq_puts ( m , keyring -> description ) ; else seq_puts ( m , "[anon]" ) ; <S2SV_StartBug> if ( key_is_instantiated ( keyring ) ) { <S2SV_EndBug> if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , ":<S2SV_blank>%lu" , keyring -> keys . nr_leaves_on_tree ) ; else seq_puts ( m , ":<S2SV_blank>empty" ) ; } }
CWE-125 static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = "?" ; unsigned short port = 0 ; <S2SV_StartBug> switch ( af ) { <S2SV_EndBug> case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? "udp" : "tcp" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , "]" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? "udp6" : "tcp6" ; break ; case AF_UNIX : <S2SV_StartBug> strncpy ( addr_text , <S2SV_EndBug> <S2SV_StartBug> ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , <S2SV_EndBug> sizeof ( addr_text ) - 1 ) ; addr_text [ sizeof ( addr_text ) - 1 ] = '\\0' ; protoname = "unix" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , "<AF<S2SV_blank>%d>" , af ) ; } if ( port ) { sprintf ( addr , "%s:%s:%u" , protoname , addr_text , port ) ; } else { sprintf ( addr , "%s:%s" , protoname , addr_text ) ; } }
CWE-119 static int xmlParse3986Port ( xmlURIPtr uri , const char * * str ) { const char * cur = * str ; unsigned port = 0 ; if ( ISA_DIGIT ( cur ) ) { while ( ISA_DIGIT ( cur ) ) { port = port * 10 + ( * cur - '0' ) ; cur ++ ; } if ( uri != NULL ) <S2SV_StartBug> uri -> port = port & INT_MAX ; <S2SV_EndBug> * str = cur ; return ( 0 ) ; } return ( 1 ) ; }
CWE-000 static void fpm_child_init ( struct fpm_worker_pool_s * wp ) { <S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) { zlog ( ZLOG_ERROR , "[pool<S2SV_blank>%s]<S2SV_blank>child<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>initialize" , wp -> config -> name ) ; exit ( FPM_EXIT_SOFTWARE ) ; } }
CWE-190 SQLITE_PRIVATE int sqlite3VtabEponymousTableInit ( Parse * pParse , Module * pMod ) { const sqlite3_module * pModule = pMod -> pModule ; Table * pTab ; char * zErr = 0 ; int rc ; sqlite3 * db = pParse -> db ; if ( pMod -> pEpoTab ) return 1 ; if ( pModule -> xCreate != 0 && pModule -> xCreate != pModule -> xConnect ) return 0 ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) return 0 ; pTab -> zName = sqlite3DbStrDup ( db , pMod -> zName ) ; if ( pTab -> zName == 0 ) { sqlite3DbFree ( db , pTab ) ; return 0 ; } pMod -> pEpoTab = pTab ; pTab -> nTabRef = 1 ; pTab -> pSchema = db -> aDb [ 0 ] . pSchema ; assert ( pTab -> nModuleArg == 0 ) ; pTab -> iPKey = - 1 ; <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <S2SV_EndBug> rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ; if ( rc ) { sqlite3ErrorMsg ( pParse , "%s" , zErr ) ; sqlite3DbFree ( db , zErr ) ; sqlite3VtabEponymousTableClear ( db , pMod ) ; return 0 ; } return 1 ; }
CWE-362 struct mapped_device * dm_get_from_kobject ( struct kobject * kobj ) { struct mapped_device * md ; md = container_of ( kobj , struct mapped_device , kobj_holder . kobj ) ; <S2SV_StartBug> if ( test_bit ( DMF_FREEING , & md -> flags ) || <S2SV_EndBug> <S2SV_StartBug> dm_deleting_md ( md ) ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> dm_get ( md ) ; <S2SV_EndBug> return md ; }
CWE-000 unsigned int nf_nat_redirect_ipv4 ( struct sk_buff * skb , const struct nf_nat_ipv4_multi_range_compat * mr , unsigned int hooknum ) { struct nf_conn * ct ; enum ip_conntrack_info ctinfo ; __be32 newdst ; struct nf_nat_range newrange ; NF_CT_ASSERT ( hooknum == NF_INET_PRE_ROUTING || hooknum == NF_INET_LOCAL_OUT ) ; ct = nf_ct_get ( skb , & ctinfo ) ; NF_CT_ASSERT ( ct && ( ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ) ) ; if ( hooknum == NF_INET_LOCAL_OUT ) { newdst = htonl ( 0x7F000001 ) ; } else { struct in_device * indev ; struct in_ifaddr * ifa ; newdst = 0 ; rcu_read_lock ( ) ; indev = __in_dev_get_rcu ( skb -> dev ) ; <S2SV_StartBug> if ( indev != NULL ) { <S2SV_EndBug> ifa = indev -> ifa_list ; newdst = ifa -> ifa_local ; } rcu_read_unlock ( ) ; if ( ! newdst ) return NF_DROP ; } memset ( & newrange . min_addr , 0 , sizeof ( newrange . min_addr ) ) ; memset ( & newrange . max_addr , 0 , sizeof ( newrange . max_addr ) ) ; newrange . flags = mr -> range [ 0 ] . flags | NF_NAT_RANGE_MAP_IPS ; newrange . min_addr . ip = newdst ; newrange . max_addr . ip = newdst ; newrange . min_proto = mr -> range [ 0 ] . min ; newrange . max_proto = mr -> range [ 0 ] . max ; return nf_nat_setup_info ( ct , & newrange , NF_NAT_MANIP_DST ) ; }
CWE-189 static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , <S2SV_StartBug> int insn_idx , int prev_insn_idx ) <S2SV_EndBug> { struct bpf_verifier_state * cur = env -> cur_state ; struct bpf_verifier_stack_elem * elem ; int err ; elem = kzalloc ( sizeof ( struct bpf_verifier_stack_elem ) , GFP_KERNEL ) ; if ( ! elem ) goto err ; elem -> insn_idx = insn_idx ; elem -> prev_insn_idx = prev_insn_idx ; elem -> next = env -> head ; env -> head = elem ; env -> stack_size ++ ; err = copy_verifier_state ( & elem -> st , cur ) ; if ( err ) <S2SV_StartBug> goto err ; <S2SV_EndBug> if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) { verbose ( env , "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>complex\\n" ) ; goto err ; } return & elem -> st ; err : free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; while ( ! pop_stack ( env , NULL , NULL ) ) ; return NULL ; }
CWE-119 static int compare_img ( const vpx_image_t * const img1 , const vpx_image_t * const img2 ) { <S2SV_StartBug> const uint32_t c_w = <S2SV_EndBug> ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ; const uint32_t c_h = ( img1 -> d_h + img1 -> y_chroma_shift ) >> img1 -> y_chroma_shift ; uint32_t i ; int match = 1 ; match &= ( img1 -> fmt == img2 -> fmt ) ; match &= ( img1 -> d_w == img2 -> d_w ) ; match &= ( img1 -> d_h == img2 -> d_h ) ; <S2SV_StartBug> for ( i = 0 ; i < img1 -> d_h ; ++ i ) <S2SV_EndBug> match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , img2 -> planes [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ] , <S2SV_StartBug> img1 -> d_w ) == 0 ) ; <S2SV_EndBug> for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_U ] + i * img1 -> stride [ VPX_PLANE_U ] , img2 -> planes [ VPX_PLANE_U ] + i * img2 -> stride [ VPX_PLANE_U ] , c_w ) == 0 ) ; for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_V ] + i * img1 -> stride [ VPX_PLANE_V ] , img2 -> planes [ VPX_PLANE_V ] + i * img2 -> stride [ VPX_PLANE_V ] , c_w ) == 0 ) ; return match ; }
CWE-189 static int nfs4_xdr_dec_getacl ( struct rpc_rqst * rqstp , struct xdr_stream * xdr , struct nfs_getaclres * res ) { struct compound_hdr hdr ; int status ; status = decode_compound_hdr ( xdr , & hdr ) ; if ( status ) goto out ; status = decode_sequence ( xdr , & res -> seq_res , rqstp ) ; if ( status ) goto out ; status = decode_putfh ( xdr ) ; if ( status ) goto out ; <S2SV_StartBug> status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ; <S2SV_EndBug> out : return status ; }
CWE-000 int ocfs2_setattr ( struct dentry * dentry , struct iattr * attr ) { int status = 0 , size_change ; int inode_locked = 0 ; struct inode * inode = d_inode ( dentry ) ; struct super_block * sb = inode -> i_sb ; struct ocfs2_super * osb = OCFS2_SB ( sb ) ; struct buffer_head * bh = NULL ; handle_t * handle = NULL ; struct dquot * transfer_to [ MAXQUOTAS ] = { } ; int qtype ; int had_lock ; struct ocfs2_lock_holder oh ; trace_ocfs2_setattr ( inode , dentry , ( unsigned long long ) OCFS2_I ( inode ) -> ip_blkno , dentry -> d_name . len , dentry -> d_name . name , attr -> ia_valid , attr -> ia_mode , from_kuid ( & init_user_ns , attr -> ia_uid ) , from_kgid ( & init_user_ns , attr -> ia_gid ) ) ; if ( S_ISLNK ( inode -> i_mode ) ) attr -> ia_valid &= ~ ATTR_SIZE ; # define OCFS2_VALID_ATTRS ( ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE | ATTR_GID | ATTR_UID | ATTR_MODE ) if ( ! ( attr -> ia_valid & OCFS2_VALID_ATTRS ) ) return 0 ; status = setattr_prepare ( dentry , attr ) ; if ( status ) return status ; if ( is_quota_modification ( inode , attr ) ) { status = dquot_initialize ( inode ) ; if ( status ) return status ; } size_change = S_ISREG ( inode -> i_mode ) && attr -> ia_valid & ATTR_SIZE ; if ( size_change ) { <S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> if ( status < 0 ) { mlog_errno ( status ) ; goto bail ; } } had_lock = ocfs2_inode_lock_tracker ( inode , & bh , 1 , & oh ) ; if ( had_lock < 0 ) { status = had_lock ; goto bail_unlock_rw ; } else if ( had_lock ) { mlog ( ML_ERROR , "Another<S2SV_blank>case<S2SV_blank>of<S2SV_blank>recursive<S2SV_blank>locking:\\n" ) ; dump_stack ( ) ; } inode_locked = 1 ; if ( size_change ) { status = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( status ) <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( i_size_read ( inode ) >= attr -> ia_size ) { if ( ocfs2_should_order_data ( inode ) ) { status = ocfs2_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( status ) goto bail_unlock ; } status = ocfs2_truncate_file ( inode , bh , attr -> ia_size ) ; } else status = ocfs2_extend_file ( inode , bh , attr -> ia_size ) ; if ( status < 0 ) { if ( status != - ENOSPC ) mlog_errno ( status ) ; status = - ENOSPC ; goto bail_unlock ; } } if ( ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { if ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_USRQUOTA ) ) { transfer_to [ USRQUOTA ] = dqget ( sb , make_kqid_uid ( attr -> ia_uid ) ) ; if ( IS_ERR ( transfer_to [ USRQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ USRQUOTA ] ) ; goto bail_unlock ; } } if ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_GRPQUOTA ) ) { transfer_to [ GRPQUOTA ] = dqget ( sb , make_kqid_gid ( attr -> ia_gid ) ) ; if ( IS_ERR ( transfer_to [ GRPQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ GRPQUOTA ] ) ; goto bail_unlock ; } } handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS + 2 * ocfs2_quota_trans_credits ( sb ) ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } status = __dquot_transfer ( inode , transfer_to ) ; if ( status < 0 ) goto bail_commit ; } else { handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } } setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; status = ocfs2_mark_inode_dirty ( handle , inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; bail_commit : ocfs2_commit_trans ( osb , handle ) ; bail_unlock : if ( status && inode_locked ) { ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; inode_locked = 0 ; } bail_unlock_rw : if ( size_change ) ocfs2_rw_unlock ( inode , 1 ) ; bail : for ( qtype = 0 ; qtype < OCFS2_MAXQUOTAS ; qtype ++ ) dqput ( transfer_to [ qtype ] ) ; if ( ! status && attr -> ia_valid & ATTR_MODE ) { status = ocfs2_acl_chmod ( inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; } if ( inode_locked ) ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; brelse ( bh ) ; return status ; }
CWE-119 void WT_Interpolate ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; const EAS_SAMPLE * loopEnd ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( "b/26366256" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; loopEnd = ( const EAS_SAMPLE * ) pWTVoice -> loopEnd + 1 ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = pWTVoice -> phaseFrac ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; acc0 = ( EAS_I32 ) ( pSamples - loopEnd ) ; if ( acc0 >= 0 ) pSamples = ( const EAS_SAMPLE * ) pWTVoice -> loopStart + acc0 ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
CWE-200 static int hidp_setup_hid ( struct hidp_session * session , struct hidp_connadd_req * req ) { struct hid_device * hid ; int err ; session -> rd_data = kzalloc ( req -> rd_size , GFP_KERNEL ) ; if ( ! session -> rd_data ) return - ENOMEM ; if ( copy_from_user ( session -> rd_data , req -> rd_data , req -> rd_size ) ) { err = - EFAULT ; goto fault ; } session -> rd_size = req -> rd_size ; hid = hid_allocate_device ( ) ; if ( IS_ERR ( hid ) ) { err = PTR_ERR ( hid ) ; goto fault ; } session -> hid = hid ; hid -> driver_data = session ; hid -> bus = BUS_BLUETOOTH ; hid -> vendor = req -> vendor ; hid -> product = req -> product ; hid -> version = req -> version ; hid -> country = req -> country ; <S2SV_StartBug> strncpy ( hid -> name , req -> name , 128 ) ; <S2SV_EndBug> snprintf ( hid -> phys , sizeof ( hid -> phys ) , "%pMR" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ; snprintf ( hid -> uniq , sizeof ( hid -> uniq ) , "%pMR" , & bt_sk ( session -> ctrl_sock -> sk ) -> dst ) ; hid -> dev . parent = & session -> conn -> dev ; hid -> ll_driver = & hidp_hid_driver ; hid -> hid_get_raw_report = hidp_get_raw_report ; hid -> hid_output_raw_report = hidp_output_raw_report ; if ( hid_ignore ( hid ) ) { hid_destroy_device ( session -> hid ) ; session -> hid = NULL ; return - ENODEV ; } return 0 ; fault : kfree ( session -> rd_data ) ; session -> rd_data = NULL ; return err ; }
CWE-125 static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , "<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%s<S2SV_blank>" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>#%u<S2SV_blank>type=%s<S2SV_blank>id=%u<S2SV_blank>" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { if ( map && nmap ) { <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , "..." ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
CWE-399 int SMB2_tcon ( const unsigned int xid , struct cifs_ses * ses , const char * tree , struct cifs_tcon * tcon , const struct nls_table * cp ) { struct smb2_tree_connect_req * req ; struct smb2_tree_connect_rsp * rsp = NULL ; struct kvec iov [ 2 ] ; int rc = 0 ; int resp_buftype ; int unc_path_len ; struct TCP_Server_Info * server ; __le16 * unc_path = NULL ; cifs_dbg ( FYI , "TCON\\n" ) ; if ( ( ses -> server ) && tree ) server = ses -> server ; else return - EIO ; if ( tcon && tcon -> bad_network_name ) return - ENOENT ; unc_path = kmalloc ( MAX_SHARENAME_LENGTH * 2 , GFP_KERNEL ) ; if ( unc_path == NULL ) return - ENOMEM ; unc_path_len = cifs_strtoUTF16 ( unc_path , tree , strlen ( tree ) , cp ) + 1 ; unc_path_len *= 2 ; if ( unc_path_len < 2 ) { kfree ( unc_path ) ; return - EINVAL ; } rc = small_smb2_init ( SMB2_TREE_CONNECT , tcon , ( void * * ) & req ) ; if ( rc ) { kfree ( unc_path ) ; return rc ; } if ( tcon == NULL ) { req -> hdr . SessionId = ses -> Suid ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = get_rfc1002_length ( req ) + 4 - 1 ; req -> PathOffset = cpu_to_le16 ( sizeof ( struct smb2_tree_connect_req ) - 1 - 4 ) ; req -> PathLength = cpu_to_le16 ( unc_path_len - 2 ) ; iov [ 1 ] . iov_base = unc_path ; iov [ 1 ] . iov_len = unc_path_len ; inc_rfc1001_len ( req , unc_path_len - 1 ) ; rc = SendReceive2 ( xid , ses , iov , 2 , & resp_buftype , 0 ) ; rsp = ( struct smb2_tree_connect_rsp * ) iov [ 0 ] . iov_base ; if ( rc != 0 ) { if ( tcon ) { cifs_stats_fail_inc ( tcon , SMB2_TREE_CONNECT_HE ) ; tcon -> need_reconnect = true ; } goto tcon_error_exit ; } if ( tcon == NULL ) { ses -> ipc_tid = rsp -> hdr . TreeId ; goto tcon_exit ; } if ( rsp -> ShareType & SMB2_SHARE_TYPE_DISK ) cifs_dbg ( FYI , "connection<S2SV_blank>to<S2SV_blank>disk<S2SV_blank>share\\n" ) ; else if ( rsp -> ShareType & SMB2_SHARE_TYPE_PIPE ) { tcon -> ipc = true ; cifs_dbg ( FYI , "connection<S2SV_blank>to<S2SV_blank>pipe<S2SV_blank>share\\n" ) ; } else if ( rsp -> ShareType & SMB2_SHARE_TYPE_PRINT ) { tcon -> print = true ; cifs_dbg ( FYI , "connection<S2SV_blank>to<S2SV_blank>printer\\n" ) ; } else { cifs_dbg ( VFS , "unknown<S2SV_blank>share<S2SV_blank>type<S2SV_blank>%d\\n" , rsp -> ShareType ) ; rc = - EOPNOTSUPP ; goto tcon_error_exit ; } tcon -> share_flags = le32_to_cpu ( rsp -> ShareFlags ) ; tcon -> capabilities = rsp -> Capabilities ; tcon -> maximal_access = le32_to_cpu ( rsp -> MaximalAccess ) ; tcon -> tidStatus = CifsGood ; tcon -> need_reconnect = false ; tcon -> tid = rsp -> hdr . TreeId ; strlcpy ( tcon -> treeName , tree , sizeof ( tcon -> treeName ) ) ; if ( ( rsp -> Capabilities & SMB2_SHARE_CAP_DFS ) && ( ( tcon -> share_flags & SHI1005_FLAGS_DFS ) == 0 ) ) cifs_dbg ( VFS , "DFS<S2SV_blank>capability<S2SV_blank>contradicts<S2SV_blank>DFS<S2SV_blank>flag\\n" ) ; init_copy_chunk_defaults ( tcon ) ; if ( tcon -> ses -> server -> ops -> validate_negotiate ) rc = tcon -> ses -> server -> ops -> validate_negotiate ( xid , tcon ) ; tcon_exit : free_rsp_buf ( resp_buftype , rsp ) ; kfree ( unc_path ) ; return rc ; tcon_error_exit : if ( rsp -> hdr . Status == STATUS_BAD_NETWORK_NAME ) { cifs_dbg ( VFS , "BAD_NETWORK_NAME:<S2SV_blank>%s\\n" , tree ) ; <S2SV_StartBug> tcon -> bad_network_name = true ; <S2SV_EndBug> } goto tcon_exit ; }
CWE-000 struct file * get_empty_filp ( void ) { const struct cred * cred = current_cred ( ) ; static long old_max ; struct file * f ; int error ; if ( get_nr_files ( ) >= files_stat . max_files && ! capable ( CAP_SYS_ADMIN ) ) { if ( percpu_counter_sum_positive ( & nr_files ) >= files_stat . max_files ) goto over ; } f = kmem_cache_zalloc ( filp_cachep , GFP_KERNEL ) ; if ( unlikely ( ! f ) ) return ERR_PTR ( - ENOMEM ) ; percpu_counter_inc ( & nr_files ) ; f -> f_cred = get_cred ( cred ) ; error = security_file_alloc ( f ) ; if ( unlikely ( error ) ) { file_free ( f ) ; return ERR_PTR ( error ) ; } <S2SV_StartBug> INIT_LIST_HEAD ( & f -> f_u . fu_list ) ; <S2SV_EndBug> atomic_long_set ( & f -> f_count , 1 ) ; rwlock_init ( & f -> f_owner . lock ) ; spin_lock_init ( & f -> f_lock ) ; eventpoll_init_file ( f ) ; return f ; over : if ( get_nr_files ( ) > old_max ) { pr_info ( "VFS:<S2SV_blank>file-max<S2SV_blank>limit<S2SV_blank>%lu<S2SV_blank>reached\\n" , get_max_files ( ) ) ; old_max = get_nr_files ( ) ; } return ERR_PTR ( - ENFILE ) ; }
CWE-362 static void create_watching_parent ( void ) { pid_t child ; sigset_t ourset ; struct sigaction oldact [ 3 ] ; int status = 0 ; int retval ; retval = pam_open_session ( pamh , 0 ) ; if ( is_pam_failure ( retval ) ) { cleanup_pam ( retval ) ; errx ( EXIT_FAILURE , _ ( "cannot<S2SV_blank>open<S2SV_blank>session:<S2SV_blank>%s" ) , pam_strerror ( pamh , retval ) ) ; } else _pam_session_opened = 1 ; memset ( oldact , 0 , sizeof ( oldact ) ) ; child = fork ( ) ; if ( child == ( pid_t ) - 1 ) { cleanup_pam ( PAM_ABORT ) ; err ( EXIT_FAILURE , _ ( "cannot<S2SV_blank>create<S2SV_blank>child<S2SV_blank>process" ) ) ; } if ( child == 0 ) return ; if ( chdir ( "/" ) != 0 ) warn ( _ ( "cannot<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>%s" ) , "/" ) ; sigfillset ( & ourset ) ; if ( sigprocmask ( SIG_BLOCK , & ourset , NULL ) ) { warn ( _ ( "cannot<S2SV_blank>block<S2SV_blank>signals" ) ) ; caught_signal = true ; } if ( ! caught_signal ) { struct sigaction action ; action . sa_handler = su_catch_sig ; sigemptyset ( & action . sa_mask ) ; action . sa_flags = 0 ; sigemptyset ( & ourset ) ; if ( ! same_session ) { if ( sigaddset ( & ourset , SIGINT ) || sigaddset ( & ourset , SIGQUIT ) ) { warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; caught_signal = true ; } } if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) { warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; caught_signal = true ; } if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) { warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; caught_signal = true ; } } if ( ! caught_signal ) { pid_t pid ; for ( ; ; ) { pid = waitpid ( child , & status , WUNTRACED ) ; if ( pid != ( pid_t ) - 1 && WIFSTOPPED ( status ) ) { kill ( getpid ( ) , SIGSTOP ) ; kill ( pid , SIGCONT ) ; } else break ; } if ( pid != ( pid_t ) - 1 ) { if ( WIFSIGNALED ( status ) ) { fprintf ( stderr , "%s%s\\n" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( "<S2SV_blank>(core<S2SV_blank>dumped)" ) : "" ) ; status = WTERMSIG ( status ) + 128 ; } else status = WEXITSTATUS ( status ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( caught_signal ) status = caught_signal + 128 ; else status = 1 ; } else status = 1 ; <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> { fprintf ( stderr , _ ( "\\nSession<S2SV_blank>terminated,<S2SV_blank>killing<S2SV_blank>shell..." ) ) ; kill ( child , SIGTERM ) ; } cleanup_pam ( PAM_SUCCESS ) ; if ( caught_signal ) { <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> kill ( child , SIGKILL ) ; <S2SV_StartBug> fprintf ( stderr , _ ( "<S2SV_blank>...killed.\\n" ) ) ; <S2SV_EndBug> switch ( caught_signal ) { case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ; break ; case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ; break ; case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ; break ; default : caught_signal = SIGKILL ; break ; } kill ( getpid ( ) , caught_signal ) ; } exit ( status ) ; }
CWE-200 int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( "sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p<S2SV_blank>len<S2SV_blank>%zu" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; <S2SV_EndBug> if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) sock_recv_ts_and_drops ( msg , sk , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
CWE-119 void vp8_dequant_idct_add_y_block_mmx ( short * q , short * dq , unsigned char * dst , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 4 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dst , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dst , stride , dst , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dst + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dst + 4 , stride , dst + 4 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 2 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 32 , dq , dst + 8 , stride ) ; else if ( eobs [ 2 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 32 ] * dq [ 0 ] , dst + 8 , stride , dst + 8 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 32 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } if ( eobs [ 3 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 48 , dq , dst + 12 , stride ) ; else if ( eobs [ 3 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 48 ] * dq [ 0 ] , dst + 12 , stride , dst + 12 , stride ) ; <S2SV_StartBug> vpx_memset ( q + 48 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 64 ; dst += 4 * stride ; eobs += 4 ; } }
CWE-20 static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; <S2SV_StartBug> int pkt_len , pktnum , hr , min , sec , csec ; <S2SV_EndBug> char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , "%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\'t<S2SV_blank>valid" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\0' ; } while ( strcmp ( line , "OFFSET<S2SV_blank>0001-0203" ) != 0 ) ; <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , "LEN=%9d" , & pkt_len ) ; <S2SV_EndBug> if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item" ) ; return FALSE ; } <S2SV_StartBug> phdr -> rec_type = REC_TYPE_PACKET ; <S2SV_EndBug> phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; } <S2SV_StartBug> ws_buffer_assure_space ( buf , TOSHIBA_MAX_PACKET_LEN ) ; <S2SV_EndBug> pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid" ) ; return FALSE ; } } return TRUE ; }
CWE-119 static void update_alt_ref_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && cpi -> frames_till_gf_update_due ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; cpi -> gf_overspend_bits += cpi -> projected_frame_size ; cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cpi -> frames_since_golden = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 1 ; }
CWE-000 static int find_source_vc ( char * * ret_path , unsigned * ret_idx ) { _cleanup_free_ char * path = NULL ; int r , err = 0 ; unsigned i ; path = new ( char , sizeof ( "/dev/tty63" ) ) ; if ( ! path ) return log_oom ( ) ; for ( i = 1 ; i <= 63 ; i ++ ) { _cleanup_close_ int fd = - 1 ; r = verify_vc_allocation ( i ) ; if ( r < 0 ) { if ( ! err ) err = - r ; continue ; } sprintf ( path , "/dev/tty%u" , i ) ; fd = open_terminal ( path , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd < 0 ) { if ( ! err ) err = - fd ; continue ; } <S2SV_StartBug> r = verify_vc_kbmode ( fd ) ; <S2SV_EndBug> if ( r < 0 ) { if ( ! err ) err = - r ; continue ; } * ret_idx = i ; * ret_path = TAKE_PTR ( path ) ; return TAKE_FD ( fd ) ; } return log_error_errno ( err , "No<S2SV_blank>usable<S2SV_blank>source<S2SV_blank>console<S2SV_blank>found:<S2SV_blank>%m" ) ; }
CWE-119 static void setup_pass ( struct stream_state * stream , struct VpxEncoderConfig * global , int pass ) { if ( stream -> config . stats_fn ) { if ( ! stats_open_file ( & stream -> stats , stream -> config . stats_fn , pass ) ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>statistics<S2SV_blank>store" ) ; } else { if ( ! stats_open_mem ( & stream -> stats , pass ) ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>statistics<S2SV_blank>store" ) ; } <S2SV_StartBug> stream -> config . cfg . g_pass = global -> passes == 2 <S2SV_EndBug> ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ; <S2SV_StartBug> if ( pass ) <S2SV_EndBug> stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ; <S2SV_StartBug> stream -> cx_time = 0 ; <S2SV_EndBug> stream -> nbytes = 0 ; stream -> frames_out = 0 ; }
CWE-000 <S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> { <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> char buf [ 65 ] ; if ( current -> personality & UNAME26 ) { <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> int ndots = 0 ; <S2SV_StartBug> unsigned v ; <S2SV_EndBug> while ( * rest ) { if ( * rest == '.' && ++ ndots >= 3 ) break ; if ( ! isdigit ( * rest ) && * rest != '.' ) break ; rest ++ ; } v = ( ( LINUX_VERSION_CODE >> 8 ) & 0xff ) + 40 ; <S2SV_StartBug> snprintf ( buf , len , "2.6.%u%s" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> } return ret ; }
CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <S2SV_StartBug> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; wp += wc - 1 ; do { REPEAT4 ( stride , wp [ stride ] = ( uint16 ) ( ( ( unsigned int ) wp [ stride ] - ( unsigned int ) wp [ 0 ] ) & 0xffff ) ; wp -- ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-787 int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; <S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( "Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>" "This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }
CWE-284 ssize_t socket_read ( const socket_t * socket , void * buf , size_t count ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; <S2SV_StartBug> return recv ( socket -> fd , buf , count , MSG_DONTWAIT ) ; <S2SV_EndBug> }
CWE-119 static void extend_plane ( uint8_t * const src , int src_stride , int width , int height , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i ; const int linesize = extend_left + extend_right + width ; uint8_t * src_ptr1 = src ; uint8_t * src_ptr2 = src + width - 1 ; uint8_t * dst_ptr1 = src - extend_left ; uint8_t * dst_ptr2 = src + width ; for ( i = 0 ; i < height ; ++ i ) { <S2SV_StartBug> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; <S2SV_EndBug> src_ptr1 += src_stride ; src_ptr2 += src_stride ; dst_ptr1 += src_stride ; dst_ptr2 += src_stride ; } src_ptr1 = src - extend_left ; src_ptr2 = src + src_stride * ( height - 1 ) - extend_left ; dst_ptr1 = src + src_stride * - extend_top - extend_left ; dst_ptr2 = src + src_stride * height - extend_left ; for ( i = 0 ; i < extend_top ; ++ i ) { <S2SV_StartBug> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <S2SV_EndBug> dst_ptr1 += src_stride ; } for ( i = 0 ; i < extend_bottom ; ++ i ) { <S2SV_StartBug> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <S2SV_EndBug> dst_ptr2 += src_stride ; } }
CWE-119 static int hns_gmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_gmac_stats_string ) ; return 0 ; }
CWE-000 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_int32 now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; <S2SV_StartBug> if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || <S2SV_EndBug> ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; <S2SV_StartBug> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <S2SV_EndBug> return KADM5_BAD_MASK ; <S2SV_StartBug> if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_EndBug> <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> if ( entry == NULL ) return EINVAL ; ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = krb5_db_alloc ( handle -> context , NULL , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( kdb , 0 , sizeof ( * kdb ) ) ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = now + polent . pw_max_life ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; if ( ( ret = kadm5_copy_principal ( handle -> context , entry -> principal , & ( kdb -> princ ) ) ) ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
CWE-000 static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }
CWE-264 static int em_loop ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ; if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }
CWE-200 static int raw_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) { err = ip_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }
CWE-119 int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , "Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d." , offset , len ) ; else if ( offset > len ) return luaL_error ( L , "Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d." , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , "Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input." ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , "Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input." ) ; } } if ( ! decode_all ) { int offset = len - c . left ; <S2SV_StartBug> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; <S2SV_EndBug> lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
CWE-119 void btif_config_save ( void ) { assert ( alarm_timer != NULL ) ; assert ( config != NULL ) ; <S2SV_StartBug> alarm_set ( alarm_timer , CONFIG_SETTLE_PERIOD_MS , timer_config_save , NULL ) ; <S2SV_EndBug> }
CWE-119 static int netlbl_cipsov4_add_common ( struct genl_info * info , struct cipso_v4_doi * doi_def ) { struct nlattr * nla ; int nla_rem ; u32 iter = 0 ; doi_def -> doi = nla_get_u32 ( info -> attrs [ NLBL_CIPSOV4_A_DOI ] ) ; if ( nla_validate_nested ( info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , NLBL_CIPSOV4_A_MAX , netlbl_cipsov4_genl_policy ) != 0 ) return - EINVAL ; nla_for_each_nested ( nla , info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , nla_rem ) if ( nla -> nla_type == NLBL_CIPSOV4_A_TAG ) { <S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> return - EINVAL ; doi_def -> tags [ iter ++ ] = nla_get_u8 ( nla ) ; } <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> return 0 ; }
CWE-000 int nfs3svc_decode_readdirplusargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { int len ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ntohl ( * p ++ ) ; args -> count = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> count = min ( args -> count , max_blocksize ) ; <S2SV_EndBug> while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; if ( ! args -> buffer ) args -> buffer = page_address ( p ) ; len -= PAGE_SIZE ; } <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
CWE-416 static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; <S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> return 0 ; }
CWE-189 static int sgi_clock_set ( clockid_t clockid , struct timespec * tp ) { u64 nsec ; <S2SV_StartBug> u64 rem ; <S2SV_EndBug> nsec = rtc_time ( ) * sgi_clock_period ; <S2SV_StartBug> sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ; else { sgi_clock_offset . tv_nsec = tp -> tv_sec + NSEC_PER_SEC - rem ; sgi_clock_offset . tv_sec -- ; } return 0 ; }
CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <S2SV_StartBug> if ( likely ( walk . nbytes == nbytes ) ) <S2SV_EndBug> { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
CWE-20 void big_key_revoke ( struct key * key ) { struct path * path = ( struct path * ) & key -> payload . data [ big_key_path ] ; key_payload_reserve ( key , 0 ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) && <S2SV_EndBug> ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ; }
CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = "" , direction [ 6 ] = "" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , "%4d-%2d-%2d,%2d:%2d:%2d.%9d:" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> "%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> "%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , "TEST:" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , "PPoATM:" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , "PPoFR:" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , "ATM:" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , "FR:" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , "HDLC:" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , "PPP:" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , "ETH:" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , "l2-tx" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , "l2-rx" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }
CWE-119 static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) { krb5_error_code retval = 0 ; char * r = NULL ; krb5_data * data = NULL ; krb5_int32 count = 0 ; krb5_int32 size = 2 ; char * component = NULL ; data = malloc ( size * sizeof ( krb5_data ) ) ; if ( ! data ) { retval = ENOMEM ; } <S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> r = strdup ( realm ) ; if ( ! r ) { retval = ENOMEM ; } } while ( ! retval && ( component = va_arg ( ap , char * ) ) ) { if ( count == size ) { krb5_data * new_data = NULL ; size *= 2 ; new_data = realloc ( data , size * sizeof ( krb5_data ) ) ; if ( new_data ) { data = new_data ; } else { retval = ENOMEM ; } } if ( ! retval ) { data [ count ] . length = strlen ( component ) ; data [ count ] . data = strdup ( component ) ; if ( ! data [ count ] . data ) { retval = ENOMEM ; } count ++ ; } } if ( ! retval ) { princ -> type = KRB5_NT_UNKNOWN ; princ -> magic = KV5M_PRINCIPAL ; princ -> realm = make_data ( r , rlen ) ; princ -> data = data ; princ -> length = count ; r = NULL ; data = NULL ; } if ( data ) { while ( -- count >= 0 ) { free ( data [ count ] . data ) ; } free ( data ) ; } free ( r ) ; return retval ; }
CWE-20 static __always_inline int __do_follow_link ( struct path * path , struct nameidata * nd ) { int error ; void * cookie ; struct dentry * dentry = path -> dentry ; touch_atime ( path -> mnt , dentry ) ; nd_set_link ( nd , NULL ) ; if ( path -> mnt != nd -> path . mnt ) { path_to_nameidata ( path , nd ) ; dget ( dentry ) ; } mntget ( path -> mnt ) ; <S2SV_StartBug> cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; <S2SV_EndBug> error = PTR_ERR ( cookie ) ; if ( ! IS_ERR ( cookie ) ) { char * s = nd_get_link ( nd ) ; error = 0 ; if ( s ) error = __vfs_follow_link ( nd , s ) ; else if ( nd -> last_type == LAST_BIND ) { error = force_reval_path ( & nd -> path , nd ) ; if ( error ) path_put ( & nd -> path ) ; } if ( dentry -> d_inode -> i_op -> put_link ) dentry -> d_inode -> i_op -> put_link ( dentry , nd , cookie ) ; } return error ; }
CWE-20 static int rose_parse_national ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char * pt ; unsigned char l , lg , n = 0 ; int fac_national_digis_received = 0 ; do { switch ( * p & 0xC0 ) { case 0x00 : p += 2 ; n += 2 ; len -= 2 ; break ; case 0x40 : if ( * p == FAC_NATIONAL_RAND ) facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ; p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : p += 4 ; n += 4 ; len -= 4 ; break ; case 0xC0 : l = p [ 1 ] ; if ( * p == FAC_NATIONAL_DEST_DIGI ) { if ( ! fac_national_digis_received ) { memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; facilities -> source_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_SRC_DIGI ) { if ( ! fac_national_digis_received ) { memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; facilities -> dest_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_FAIL_CALL ) { memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; } else if ( * p == FAC_NATIONAL_FAIL_ADD ) { memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; } else if ( * p == FAC_NATIONAL_DIGIS ) { fac_national_digis_received = 1 ; facilities -> source_ndigis = 0 ; facilities -> dest_ndigis = 0 ; for ( pt = p + 2 , lg = 0 ; lg < l ; pt += AX25_ADDR_LEN , lg += AX25_ADDR_LEN ) { <S2SV_StartBug> if ( pt [ 6 ] & AX25_HBIT ) <S2SV_EndBug> memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; <S2SV_EndBug> } } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }
CWE-284 static inline void uipc_wakeup_locked ( void ) { char sig_on = 1 ; BTIF_TRACE_EVENT ( "UIPC<S2SV_blank>SEND<S2SV_blank>WAKE<S2SV_blank>UP" ) ; <S2SV_StartBug> send ( uipc_main . signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> }
CWE-362 static int em_sysenter ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ; <S2SV_StartBug> if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <S2SV_EndBug> && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) return X86EMUL_UNHANDLEABLE ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; <S2SV_StartBug> switch ( ctxt -> mode ) { <S2SV_EndBug> case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; break ; default : break ; } ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF ) ; <S2SV_StartBug> cs_sel = ( u16 ) msr_data ; <S2SV_EndBug> cs_sel &= ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; <S2SV_StartBug> ss_sel &= ~ SELECTOR_RPL_MASK ; <S2SV_EndBug> <S2SV_StartBug> if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) { <S2SV_EndBug> cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_EIP , & msr_data ) ; <S2SV_StartBug> ctxt -> _eip = msr_data ; <S2SV_EndBug> ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_ESP , & msr_data ) ; <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = msr_data ; <S2SV_EndBug> return X86EMUL_CONTINUE ; }
CWE-000 void bandwidth_pid ( pid_t pid , const char * command , const char * dev , int down , int up ) { EUID_ASSERT ( ) ; EUID_ROOT ( ) ; char * comm = pid_proc_comm ( pid ) ; EUID_USER ( ) ; if ( ! comm ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n" ) ; exit ( 1 ) ; } if ( strcmp ( comm , "firejail" ) != 0 ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n" ) ; exit ( 1 ) ; } free ( comm ) ; char * name ; if ( asprintf ( & name , "/run/firejail/network/%d-netmap" , pid ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( name , & s ) == - 1 ) { fprintf ( stderr , "Error:<S2SV_blank>the<S2SV_blank>sandbox<S2SV_blank>doesn\'t<S2SV_blank>use<S2SV_blank>a<S2SV_blank>new<S2SV_blank>network<S2SV_blank>namespace\\n" ) ; exit ( 1 ) ; } pid_t child ; if ( find_child ( pid , & child ) == - 1 ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n" ) ; exit ( 1 ) ; } EUID_ROOT ( ) ; if ( join_namespace ( child , "net" ) ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n" ) ; exit ( 1 ) ; } if ( strcmp ( command , "set" ) == 0 ) bandwidth_set ( pid , dev , down , up ) ; else if ( strcmp ( command , "clear" ) == 0 ) bandwidth_remove ( pid , dev ) ; char * devname = NULL ; if ( dev ) { char * fname ; if ( asprintf ( & fname , "%s/%d-netmap" , RUN_FIREJAIL_NETWORK_DIR , ( int ) pid ) == - 1 ) errExit ( "asprintf" ) ; FILE * fp = fopen ( fname , "r" ) ; if ( ! fp ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>network<S2SV_blank>map<S2SV_blank>file<S2SV_blank>%s\\n" , fname ) ; exit ( 1 ) ; } char buf [ 1024 ] ; int len = strlen ( dev ) ; while ( fgets ( buf , 1024 , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; if ( * buf == '\\0' ) break ; if ( strncmp ( buf , dev , len ) == 0 && buf [ len ] == ':' ) { devname = strdup ( buf + len + 1 ) ; if ( ! devname ) errExit ( "strdup" ) ; if ( if_nametoindex ( devname ) == 0 ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>network<S2SV_blank>device<S2SV_blank>%s\\n" , devname ) ; exit ( 1 ) ; } break ; } } free ( fname ) ; fclose ( fp ) ; } char * cmd = NULL ; if ( devname ) { if ( strcmp ( command , "set" ) == 0 ) { if ( asprintf ( & cmd , "%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%d" , LIBDIR , command , devname , down , up ) == - 1 ) errExit ( "asprintf" ) ; } else { if ( asprintf ( & cmd , "%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s" , LIBDIR , command , devname ) == - 1 ) errExit ( "asprintf" ) ; } } else { if ( asprintf ( & cmd , "%s/firejail/fshaper.sh<S2SV_blank>--%s" , LIBDIR , command ) == - 1 ) errExit ( "asprintf" ) ; } assert ( cmd ) ; environ = NULL ; if ( setreuid ( 0 , 0 ) ) errExit ( "setreuid" ) ; if ( setregid ( 0 , 0 ) ) errExit ( "setregid" ) ; <S2SV_StartBug> if ( ! cfg . shell ) <S2SV_EndBug> cfg . shell = guess_shell ( ) ; if ( ! cfg . shell ) { fprintf ( stderr , "Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\n" ) ; exit ( 1 ) ; } char * arg [ 4 ] ; <S2SV_StartBug> arg [ 0 ] = cfg . shell ; <S2SV_EndBug> arg [ 1 ] = "-c" ; arg [ 2 ] = cmd ; arg [ 3 ] = NULL ; clearenv ( ) ; execvp ( arg [ 0 ] , arg ) ; errExit ( "execvp" ) ; }
CWE-119 static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; ncomponents = bytestream2_get_be16u ( & s -> g ) ; if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; <S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>seperation\\n" ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>" "components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>" "cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } return 0 ; }
CWE-119 <S2SV_StartBug> void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) vp9_idct4x4_add ( input , dest , stride , eob ) ; else vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ; }
CWE-20 static int __sock_diag_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh ) { int err ; struct sock_diag_req * req = nlmsg_data ( nlh ) ; const struct sock_diag_handler * hndl ; if ( nlmsg_len ( nlh ) < sizeof ( * req ) ) return - EINVAL ; <S2SV_StartBug> hndl = sock_diag_lock_handler ( req -> sdiag_family ) ; <S2SV_EndBug> if ( hndl == NULL ) err = - ENOENT ; else err = hndl -> dump ( skb , nlh ) ; sock_diag_unlock_handler ( hndl ) ; return err ; }
CWE-000 static int usb_enumerate_device_otg ( struct usb_device * udev ) { int err = 0 ; # ifdef CONFIG_USB_OTG if ( ! udev -> bus -> is_b_host && udev -> config && udev -> parent == udev -> bus -> root_hub ) { struct usb_otg_descriptor * desc = NULL ; struct usb_bus * bus = udev -> bus ; unsigned port1 = udev -> portnum ; err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , <S2SV_StartBug> USB_DT_OTG , ( void * * ) & desc ) ; <S2SV_EndBug> if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ; dev_info ( & udev -> dev , "Dual-Role<S2SV_blank>OTG<S2SV_blank>device<S2SV_blank>on<S2SV_blank>%sHNP<S2SV_blank>port\\n" , ( port1 == bus -> otg_port ) ? "" : "non-" ) ; if ( port1 == bus -> otg_port ) { bus -> b_hnp_enable = 1 ; err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_B_HNP_ENABLE , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) { dev_err ( & udev -> dev , "can\'t<S2SV_blank>set<S2SV_blank>HNP<S2SV_blank>mode:<S2SV_blank>%d\\n" , err ) ; bus -> b_hnp_enable = 0 ; } } else if ( desc -> bLength == sizeof ( struct usb_otg_descriptor ) ) { err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_A_ALT_HNP_SUPPORT , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) dev_err ( & udev -> dev , "set<S2SV_blank>a_alt_hnp_support<S2SV_blank>failed:<S2SV_blank>%d\\n" , err ) ; } } # endif return err ; }
CWE-125 static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) { # define SIZEOF_FILE_NAME 255 int i = 0 ; const char * basename ; if ( ! dbg_data ) { return 0 ; } switch ( dbg_dir_entry -> Type ) { case IMAGE_DEBUG_TYPE_CODEVIEW : if ( ! strncmp ( ( char * ) dbg_data , "RSDS" , 4 ) ) { SCV_RSDS_HEADER rsds_hdr ; init_rsdr_hdr ( & rsds_hdr ) ; if ( ! get_rsds ( dbg_data , dbg_data_len , & rsds_hdr ) ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>read<S2SV_blank>PE<S2SV_blank>debug<S2SV_blank>info\\n" ) ; return 0 ; } snprintf ( res -> guidstr , GUIDSTR_LEN , "%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x" , rsds_hdr . guid . data1 , rsds_hdr . guid . data2 , rsds_hdr . guid . data3 , rsds_hdr . guid . data4 [ 0 ] , rsds_hdr . guid . data4 [ 1 ] , rsds_hdr . guid . data4 [ 2 ] , rsds_hdr . guid . data4 [ 3 ] , rsds_hdr . guid . data4 [ 4 ] , rsds_hdr . guid . data4 [ 5 ] , rsds_hdr . guid . data4 [ 6 ] , rsds_hdr . guid . data4 [ 7 ] , rsds_hdr . age ) ; basename = r_file_basename ( ( char * ) rsds_hdr . file_name ) ; strncpy ( res -> file_name , ( const char * ) basename , sizeof ( res -> file_name ) ) ; res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; rsds_hdr . free ( ( struct SCV_RSDS_HEADER * ) & rsds_hdr ) ; } else if ( strncmp ( ( const char * ) dbg_data , "NB10" , 4 ) == 0 ) { <S2SV_StartBug> SCV_NB10_HEADER nb10_hdr ; <S2SV_EndBug> init_cv_nb10_header ( & nb10_hdr ) ; get_nb10 ( dbg_data , & nb10_hdr ) ; snprintf ( res -> guidstr , sizeof ( res -> guidstr ) , <S2SV_StartBug> "%x%x" , nb10_hdr . timestamp , nb10_hdr . age ) ; <S2SV_EndBug> strncpy ( res -> file_name , ( const char * ) <S2SV_StartBug> nb10_hdr . file_name , sizeof ( res -> file_name ) - 1 ) ; <S2SV_EndBug> res -> file_name [ sizeof ( res -> file_name ) - 1 ] = 0 ; nb10_hdr . free ( ( struct SCV_NB10_HEADER * ) & nb10_hdr ) ; } else { bprintf ( "CodeView<S2SV_blank>section<S2SV_blank>not<S2SV_blank>NB10<S2SV_blank>or<S2SV_blank>RSDS\\n" ) ; return 0 ; } break ; default : return 0 ; } while ( i < 33 ) { res -> guidstr [ i ] = toupper ( ( int ) res -> guidstr [ i ] ) ; i ++ ; } return 1 ; }
CWE-000 static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>syncword\\n" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>streamid\\n" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , "expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ; <S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> pva_log ( s , AV_LOG_WARNING , "expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>" "trying<S2SV_blank>to<S2SV_blank>recover\\n" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , "header<S2SV_blank>too<S2SV_blank>short\\n" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , "audio<S2SV_blank>data<S2SV_blank>corruption\\n" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }
CWE-476 static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; } break ; case BAG_STOP_BACKTRACK : if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { int v ; QuantNode * qn ; qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; tlen = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; if ( tlen < 0 ) return tlen ; v = onig_positive_int_multiply ( qn -> lower , tlen ) ; if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; } else { len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; } break ; case BAG_IF_ELSE : { Node * cond = NODE_BAG_BODY ( node ) ; Node * Then = node -> te . Then ; Node * Else = node -> te . Else ; len = compile_length_tree ( cond , reg ) ; if ( len < 0 ) return len ; len += SIZE_OP_PUSH ; len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END ; if ( IS_NOT_NULL ( Then ) ) { tlen = compile_length_tree ( Then , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } <S2SV_StartBug> if ( IS_NOT_NULL ( Else ) ) { <S2SV_EndBug> <S2SV_StartBug> len += SIZE_OP_JUMP ; <S2SV_EndBug> tlen = compile_length_tree ( Else , reg ) ; if ( tlen < 0 ) return tlen ; len += tlen ; } } break ; case BAG_OPTION : len = 0 ; break ; } return len ; }
CWE-000 struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( "payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( "Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( "message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; <S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> pr_debug ( "Invalid<S2SV_blank>fragment<S2SV_blank>offset\\n" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( "Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( "Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( "Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }
CWE-000 STATIC int xfs_attr_calc_size ( struct xfs_inode * ip , int namelen , int valuelen , int * local ) { struct xfs_mount * mp = ip -> i_mount ; int size ; int nblks ; size = xfs_attr_leaf_newentsize ( namelen , valuelen , mp -> m_sb . sb_blocksize , local ) ; nblks = XFS_DAENTER_SPACE_RES ( mp , XFS_ATTR_FORK ) ; if ( * local ) { if ( size > ( mp -> m_sb . sb_blocksize >> 1 ) ) { nblks *= 2 ; } } else { <S2SV_StartBug> uint dblocks = XFS_B_TO_FSB ( mp , valuelen ) ; <S2SV_EndBug> nblks += dblocks ; nblks += XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; } return nblks ; }
CWE-476 static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; int interlaced = dctx -> interlaced ; int cur_field = dctx -> cur_field ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; interlaced = ( state & 2 ) >> 1 ; cur_field = state & 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i >= dctx -> remaining && ( ! dctx -> interlaced || dctx -> cur_field ) ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> interlaced = interlaced ; dctx -> cur_field = 0 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> interlaced = interlaced ; dctx -> cur_field = 0 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; dctx -> interlaced = interlaced ; dctx -> cur_field = cur_field ; return END_NOT_FOUND ; }
CWE-189 int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( "invalid<S2SV_blank>framebuffer<S2SV_blank>id\\n" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { <S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num_clips ) ; } else { ret = - ENOSYS ; goto out_err2 ; } out_err2 : kfree ( clips ) ; out_err1 : mutex_unlock ( & dev -> mode_config . mutex ) ; return ret ; }
CWE-000 int ip_forward ( struct sk_buff * skb ) { u32 mtu ; struct iphdr * iph ; struct rtable * rt ; struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; if ( skb -> pkt_type != PACKET_HOST ) goto drop ; if ( skb_warn_if_lro ( skb ) ) goto drop ; if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_FWD , skb ) ) goto drop ; if ( IPCB ( skb ) -> opt . router_alert && ip_call_ra_chain ( skb ) ) return NET_RX_SUCCESS ; skb_forward_csum ( skb ) ; if ( ip_hdr ( skb ) -> ttl <= 1 ) goto too_many_hops ; if ( ! xfrm4_route_forward ( skb ) ) goto drop ; rt = skb_rtable ( skb ) ; if ( opt -> is_strictroute && rt -> rt_uses_gateway ) goto sr_failed ; IPCB ( skb ) -> flags |= IPSKB_FORWARDED ; mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ; if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) { IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ; icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , htonl ( mtu ) ) ; goto drop ; } if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) goto drop ; iph = ip_hdr ( skb ) ; ip_decrease_ttl ( iph ) ; <S2SV_StartBug> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) <S2SV_EndBug> ip_rt_send_redirect ( skb ) ; skb -> priority = rt_tos2priority ( iph -> tos ) ; return NF_HOOK ( NFPROTO_IPV4 , NF_INET_FORWARD , skb , skb -> dev , rt -> dst . dev , ip_forward_finish ) ; sr_failed : icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_SR_FAILED , 0 ) ; goto drop ; too_many_hops : IP_INC_STATS_BH ( dev_net ( skb_dst ( skb ) -> dev ) , IPSTATS_MIB_INHDRERRORS ) ; icmp_send ( skb , ICMP_TIME_EXCEEDED , ICMP_EXC_TTL , 0 ) ; drop : kfree_skb ( skb ) ; return NET_RX_DROP ; }
CWE-476 static int crypto_skcipher_init_tfm ( struct crypto_tfm * tfm ) { struct crypto_skcipher * skcipher = __crypto_skcipher_cast ( tfm ) ; struct skcipher_alg * alg = crypto_skcipher_alg ( skcipher ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_blkcipher_type ) return crypto_init_skcipher_ops_blkcipher ( tfm ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_ablkcipher_type || tfm -> __crt_alg -> cra_type == & crypto_givcipher_type ) return crypto_init_skcipher_ops_ablkcipher ( tfm ) ; <S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug> skcipher -> encrypt = alg -> encrypt ; skcipher -> decrypt = alg -> decrypt ; skcipher -> ivsize = alg -> ivsize ; skcipher -> keysize = alg -> max_keysize ; if ( alg -> exit ) skcipher -> base . exit = crypto_skcipher_exit_tfm ; if ( alg -> init ) return alg -> init ( skcipher ) ; return 0 ; }
CWE-416 static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( "Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\n" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , "ipmi_si.%d" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( "ipmi_si" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\n" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; if ( ! new_smi -> si_sm ) { rv = - ENOMEM ; goto out_err ; } new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , & new_smi -> io ) ; rv = new_smi -> io . io_setup ( & new_smi -> io ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\n" ) ; goto out_err ; } if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "Interface<S2SV_blank>detection<S2SV_blank>failed\\n" ) ; rv = - ENODEV ; goto out_err ; } rv = try_get_dev_id ( new_smi ) ; if ( rv ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\n" ) ; goto out_err ; } setup_oem_data_handler ( new_smi ) ; setup_xaction_handlers ( new_smi ) ; check_for_broken_irqs ( new_smi ) ; new_smi -> waiting_msg = NULL ; new_smi -> curr_msg = NULL ; atomic_set ( & new_smi -> req_events , 0 ) ; new_smi -> run_to_completion = false ; for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) atomic_set ( & new_smi -> stats [ i ] , 0 ) ; new_smi -> interrupt_disabled = true ; atomic_set ( & new_smi -> need_watch , 0 ) ; rv = try_enable_event_buffer ( new_smi ) ; if ( rv == 0 ) new_smi -> has_event_buffer = true ; start_clear_flags ( new_smi ) ; if ( new_smi -> io . irq ) { new_smi -> interrupt_disabled = false ; atomic_set ( & new_smi -> req_events , 1 ) ; } if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { rv = platform_device_add ( new_smi -> pdev ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } new_smi -> pdev_registered = true ; } dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } new_smi -> dev_group_added = true ; rv = ipmi_register_smi ( & handlers , new_smi , new_smi -> io . dev , new_smi -> io . slave_addr ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } smi_num ++ ; dev_info ( new_smi -> io . dev , "IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\n" , si_to_str [ new_smi -> io . si_type ] ) ; WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; out_err : <S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> return rv ; }
CWE-119 <S2SV_StartBug> void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct16x16_add ( input , dest , stride , eob ) ; } else { vp9_iht16x16_256_add ( input , dest , stride , tx_type ) ; } }
CWE-787 VOID ixheaacd_shiftrountine_with_rnd_hq ( WORD32 * qmf_real , WORD32 * qmf_imag , WORD32 * filter_states , WORD32 len , WORD32 shift ) { WORD32 * filter_states_rev = filter_states + len ; WORD32 treal , timag ; WORD32 j ; for ( j = ( len - 1 ) ; j >= 0 ; j -= 2 ) { WORD32 r1 , r2 , i1 , i2 ; i2 = qmf_imag [ j ] ; r2 = qmf_real [ j ] ; r1 = * qmf_real ++ ; i1 = * qmf_imag ++ ; <S2SV_StartBug> timag = ixheaacd_add32 ( i1 , r1 ) ; <S2SV_EndBug> timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; filter_states_rev [ j ] = timag ; <S2SV_StartBug> treal = ixheaacd_sub32 ( i2 , r2 ) ; <S2SV_EndBug> treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32 ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32 ( i2 , r2 ) ; timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; * filter_states_rev ++ = timag ; } }
CWE-119 <S2SV_StartBug> static void encode_unsigned_max ( struct vp9_write_bit_buffer * wb , <S2SV_EndBug> int data , int max ) { <S2SV_StartBug> vp9_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> }
CWE-416 static int xfrm_user_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( skb -> sk ) ; struct nlattr * attrs [ XFRMA_MAX + 1 ] ; const struct xfrm_link * link ; int type , err ; # ifdef CONFIG_COMPAT if ( in_compat_syscall ( ) ) return - EOPNOTSUPP ; # endif type = nlh -> nlmsg_type ; if ( type > XFRM_MSG_MAX ) return - EINVAL ; type -= XFRM_MSG_BASE ; link = & xfrm_dispatch [ type ] ; if ( ! netlink_net_capable ( skb , CAP_NET_ADMIN ) ) return - EPERM ; if ( ( type == ( XFRM_MSG_GETSA - XFRM_MSG_BASE ) || type == ( XFRM_MSG_GETPOLICY - XFRM_MSG_BASE ) ) && ( nlh -> nlmsg_flags & NLM_F_DUMP ) ) { if ( link -> dump == NULL ) return - EINVAL ; { struct netlink_dump_control c = { <S2SV_StartBug> . dump = link -> dump , <S2SV_EndBug> . done = link -> done , } ; return netlink_dump_start ( net -> xfrm . nlsk , skb , nlh , & c ) ; } } err = nlmsg_parse ( nlh , xfrm_msg_min [ type ] , attrs , link -> nla_max ? : XFRMA_MAX , link -> nla_pol ? : xfrma_policy , extack ) ; if ( err < 0 ) return err ; if ( link -> doit == NULL ) return - EINVAL ; return link -> doit ( skb , nlh , attrs ) ; }
CWE-119 static void setup_decoding_thread_data ( VP8D_COMP * pbi , MACROBLOCKD * xd , MB_ROW_DEC * mbrd , int count ) { VP8_COMMON * const pc = & pbi -> common ; int i ; for ( i = 0 ; i < count ; i ++ ) { MACROBLOCKD * mbd = & mbrd [ i ] . mbd ; mbd -> subpixel_predict = xd -> subpixel_predict ; mbd -> subpixel_predict8x4 = xd -> subpixel_predict8x4 ; mbd -> subpixel_predict8x8 = xd -> subpixel_predict8x8 ; mbd -> subpixel_predict16x16 = xd -> subpixel_predict16x16 ; mbd -> mode_info_context = pc -> mi + pc -> mode_info_stride * ( i + 1 ) ; mbd -> mode_info_stride = pc -> mode_info_stride ; mbd -> frame_type = pc -> frame_type ; mbd -> pre = xd -> pre ; mbd -> dst = xd -> dst ; mbd -> segmentation_enabled = xd -> segmentation_enabled ; mbd -> mb_segement_abs_delta = xd -> mb_segement_abs_delta ; <S2SV_StartBug> vpx_memcpy ( mbd -> segment_feature_data , xd -> segment_feature_data , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> mbd -> mode_ref_lf_delta_enabled = xd -> mode_ref_lf_delta_enabled ; mbd -> mode_ref_lf_delta_update = xd -> mode_ref_lf_delta_update ; mbd -> current_bc = & pbi -> mbc [ 0 ] ; <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ; <S2SV_EndBug> mbd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) mbd -> fullpixel_mask = 0xfffffff8 ; } for ( i = 0 ; i < pc -> mb_rows ; i ++ ) pbi -> mt_current_mb_col [ i ] = - 1 ; }
CWE-20 <S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> { struct io_context * ioc ; <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }
CWE-284 static int tap_if_up ( const char * devname , const bt_bdaddr_t * addr ) { struct ifreq ifr ; int sk , err ; sk = socket ( AF_INET , SOCK_DGRAM , 0 ) ; if ( sk < 0 ) return - 1 ; memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IFNAMSIZ - 1 ) ; <S2SV_StartBug> err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ; <S2SV_EndBug> if ( err < 0 ) { BTIF_TRACE_ERROR ( "Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>network<S2SV_blank>hardware<S2SV_blank>for<S2SV_blank>interface:%s,<S2SV_blank>errno:%s" , devname , strerror ( errno ) ) ; close ( sk ) ; return - 1 ; } strncpy ( ifr . ifr_name , devname , IFNAMSIZ - 1 ) ; memcpy ( ifr . ifr_hwaddr . sa_data , addr -> address , 6 ) ; if ( ifr . ifr_hwaddr . sa_data [ 0 ] & 0x01 ) { BTIF_TRACE_WARNING ( "Not<S2SV_blank>a<S2SV_blank>unicast<S2SV_blank>MAC<S2SV_blank>address,<S2SV_blank>force<S2SV_blank>multicast<S2SV_blank>bit<S2SV_blank>flipping" ) ; ifr . ifr_hwaddr . sa_data [ 0 ] &= ~ 0x01 ; } <S2SV_StartBug> err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ; <S2SV_EndBug> if ( err < 0 ) { BTIF_TRACE_ERROR ( "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>bt<S2SV_blank>address<S2SV_blank>for<S2SV_blank>interface:%s,<S2SV_blank>errno:%s" , devname , strerror ( errno ) ) ; close ( sk ) ; return - 1 ; } memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IF_NAMESIZE - 1 ) ; ifr . ifr_flags |= IFF_UP ; ifr . ifr_flags |= IFF_MULTICAST ; <S2SV_StartBug> err = ioctl ( sk , SIOCSIFFLAGS , ( caddr_t ) & ifr ) ; <S2SV_EndBug> if ( err < 0 ) { BTIF_TRACE_ERROR ( "Could<S2SV_blank>not<S2SV_blank>bring<S2SV_blank>up<S2SV_blank>network<S2SV_blank>interface:%s,<S2SV_blank>errno:%d" , devname , errno ) ; close ( sk ) ; return - 1 ; } close ( sk ) ; BTIF_TRACE_DEBUG ( "network<S2SV_blank>interface:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>up" , devname ) ; return 0 ; }
CWE-000 static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case BPF_TYPE_PROG : <S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> break ; case BPF_TYPE_MAP : <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> break ; default : WARN_ON_ONCE ( 1 ) ; break ; } return raw ; }
CWE-20 static int remove_bond ( const bt_bdaddr_t * bd_addr ) <S2SV_StartBug> { <S2SV_EndBug> if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }
CWE-416 static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; <S2SV_StartBug> mmu_notifier_mm_init ( mm ) ; <S2SV_EndBug> init_tlb_flush_pending ( mm ) ; # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return mm ; fail_nocontext : mm_free_pgd ( mm ) ; fail_nopgd : free_mm ( mm ) ; return NULL ; }
CWE-264 struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { <S2SV_StartBug> request_module ( "%s" , name ) ; <S2SV_EndBug> if ( ! ( ( type ^ CRYPTO_ALG_NEED_FALLBACK ) & mask & CRYPTO_ALG_NEED_FALLBACK ) ) <S2SV_StartBug> request_module ( "%s-all" , name ) ; <S2SV_EndBug> alg = crypto_alg_lookup ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }
CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <S2SV_StartBug> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <S2SV_EndBug> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = "nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = "nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , "%s" , msg ) ; return false ; }
CWE-000 void vrrp_print_data ( void ) { <S2SV_StartBug> FILE * file = fopen ( dump_file , "w" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)" , dump_file , errno , strerror ( errno ) ) ; return ; } dump_data_vrrp ( file ) ; fclose ( file ) ; }
CWE-264 int rpc_type_of_NPNVariable ( int variable ) { int type ; switch ( variable ) { case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : <S2SV_StartBug> case NPNVSupportsWindowless : <S2SV_EndBug> type = RPC_TYPE_BOOLEAN ; break ; case NPNVToolkit : case NPNVnetscapeWindow : type = RPC_TYPE_UINT32 ; break ; case NPNVWindowNPObject : case NPNVPluginElementNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }
CWE-119 static int http_read_stream ( URLContext * h , uint8_t * buf , int size ) { HTTPContext * s = h -> priv_data ; int err , new_location , read_ret ; int64_t seek_ret ; if ( ! s -> hd ) return AVERROR_EOF ; if ( s -> end_chunked_post && ! s -> end_header ) { err = http_read_header ( h , & new_location ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> if ( s -> chunksize >= 0 ) { <S2SV_EndBug> if ( ! s -> chunksize ) { char line [ 32 ] ; do { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; } while ( ! * line ) ; <S2SV_StartBug> s -> chunksize = strtoll ( line , NULL , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( NULL , AV_LOG_TRACE , "Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%" PRId64 "\'\\n" , <S2SV_EndBug> s -> chunksize ) ; if ( ! s -> chunksize ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } size = FFMIN ( size , s -> chunksize ) ; } # if CONFIG_ZLIB if ( s -> compressed ) return http_buf_read_compressed ( h , buf , size ) ; # endif read_ret = http_buf_read ( h , buf , size ) ; if ( ( read_ret < 0 && s -> reconnect && ( ! h -> is_streamed || s -> reconnect_streamed ) && s -> filesize > 0 && s -> off < s -> filesize ) || ( read_ret == 0 && s -> reconnect_at_eof && ( ! h -> is_streamed || s -> reconnect_streamed ) ) ) { <S2SV_StartBug> int64_t target = h -> is_streamed ? 0 : s -> off ; <S2SV_EndBug> if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ; <S2SV_StartBug> av_log ( h , AV_LOG_INFO , "Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRId64 "<S2SV_blank>error=%s.\\n" , s -> off , av_err2str ( read_ret ) ) ; <S2SV_EndBug> av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ; s -> reconnect_delay = 1 + 2 * s -> reconnect_delay ; seek_ret = http_seek_internal ( h , target , SEEK_SET , 1 ) ; if ( seek_ret != target ) { <S2SV_StartBug> av_log ( h , AV_LOG_ERROR , "Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRId64 ".\\n" , target ) ; <S2SV_EndBug> return read_ret ; } read_ret = http_buf_read ( h , buf , size ) ; } else s -> reconnect_delay = 0 ; return read_ret ; }
CWE-119 static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , <S2SV_StartBug> int_mv * ref_mv , <S2SV_EndBug> int_mv * second_ref_mv , int64_t comp_pred_diff [ REFERENCE_MODES ] , <S2SV_StartBug> int64_t tx_size_diff [ TX_MODES ] , <S2SV_EndBug> <S2SV_StartBug> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) { <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; ctx -> skip = x -> skip ; <S2SV_StartBug> ctx -> best_mode_index = mode_index ; <S2SV_EndBug> ctx -> mic = * xd -> mi [ 0 ] ; <S2SV_StartBug> ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ; <S2SV_EndBug> ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ; ctx -> single_pred_diff = ( int ) comp_pred_diff [ SINGLE_REFERENCE ] ; ctx -> comp_pred_diff = ( int ) comp_pred_diff [ COMPOUND_REFERENCE ] ; ctx -> hybrid_pred_diff = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ; <S2SV_StartBug> vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ; <S2SV_EndBug> vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ; }
CWE-200 static int __fpu__restore_sig ( void __user * buf , void __user * buf_fx , int size ) { int ia32_fxstate = ( buf != buf_fx ) ; struct task_struct * tsk = current ; struct fpu * fpu = & tsk -> thread . fpu ; int state_size = fpu_kernel_xstate_size ; u64 xfeatures = 0 ; int fx_only = 0 ; ia32_fxstate &= ( IS_ENABLED ( CONFIG_X86_32 ) || IS_ENABLED ( CONFIG_IA32_EMULATION ) ) ; if ( ! buf ) { fpu__clear ( fpu ) ; return 0 ; } if ( ! access_ok ( VERIFY_READ , buf , size ) ) return - EACCES ; fpu__activate_curr ( fpu ) ; if ( ! static_cpu_has ( X86_FEATURE_FPU ) ) return fpregs_soft_set ( current , NULL , 0 , sizeof ( struct user_i387_ia32_struct ) , NULL , buf ) != 0 ; if ( use_xsave ( ) ) { struct _fpx_sw_bytes fx_sw_user ; if ( unlikely ( check_for_xstate ( buf_fx , buf_fx , & fx_sw_user ) ) ) { state_size = sizeof ( struct fxregs_state ) ; fx_only = 1 ; trace_x86_fpu_xstate_check_failed ( fpu ) ; } else { state_size = fx_sw_user . xstate_size ; xfeatures = fx_sw_user . xfeatures ; } } if ( ia32_fxstate ) { struct fpu * fpu = & tsk -> thread . fpu ; struct user_i387_ia32_struct env ; int err = 0 ; fpu__drop ( fpu ) ; <S2SV_StartBug> if ( using_compacted_format ( ) ) <S2SV_EndBug> err = copy_user_to_xstate ( & fpu -> state . xsave , buf_fx ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ; <S2SV_EndBug> if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) { fpstate_init ( & fpu -> state ) ; trace_x86_fpu_init_state ( fpu ) ; err = - 1 ; } else { sanitize_restored_xstate ( tsk , & env , xfeatures , fx_only ) ; } fpu -> fpstate_active = 1 ; preempt_disable ( ) ; fpu__restore ( fpu ) ; preempt_enable ( ) ; return err ; } else { user_fpu_begin ( ) ; if ( copy_user_to_fpregs_zeroing ( buf_fx , xfeatures , fx_only ) ) { fpu__clear ( fpu ) ; return - 1 ; } } return 0 ; }
CWE-119 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }
CWE-119 void grubfs_free ( GrubFS * gf ) { if ( gf ) { <S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug> free ( gf -> file ) ; free ( gf ) ; } }
CWE-000 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { <S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> if ( useSystemLib ) Com_Printf ( "Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\"%s\\"...\\n" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = "." ; Com_Printf ( "Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\"%s\\"<S2SV_blank>from<S2SV_blank>\\"%s\\"...\\n" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , "%s%c%s" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( "fs_basepath" ) ; if ( ! basePath || ! * basePath ) basePath = "." ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( "Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\"%s\\"<S2SV_blank>from<S2SV_blank>\\"%s\\"...\\n" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , "%s%c%s" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( "Loading<S2SV_blank>\\"%s\\"<S2SV_blank>failed\\n" , name ) ; } } return dllhandle ; }
CWE-119 <S2SV_StartBug> static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) <S2SV_EndBug> { <S2SV_StartBug> return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , <S2SV_EndBug> RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE , <S2SV_StartBug> indx , 0 , data , size , 500 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 <S2SV_StartBug> static void encode_mv_component ( vp9_writer * w , int comp , <S2SV_EndBug> const nmv_component * mvcomp , int usehp ) { int offset ; const int sign = comp < 0 ; const int mag = sign ? - comp : comp ; const int mv_class = vp9_get_mv_class ( mag - 1 , & offset ) ; const int d = offset >> 3 ; const int fr = ( offset >> 1 ) & 3 ; const int hp = offset & 1 ; assert ( comp != 0 ) ; <S2SV_StartBug> vp9_write ( w , sign , mvcomp -> sign ) ; <S2SV_EndBug> vp9_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ; if ( mv_class == MV_CLASS_0 ) { vp9_write_token ( w , vp9_mv_class0_tree , mvcomp -> class0 , & mv_class0_encodings [ d ] ) ; } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; for ( i = 0 ; i < n ; ++ i ) <S2SV_StartBug> vp9_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; <S2SV_EndBug> } vp9_write_token ( w , vp9_mv_fp_tree , mv_class == MV_CLASS_0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp , & mv_fp_encodings [ fr ] ) ; if ( usehp ) <S2SV_StartBug> vp9_write ( w , hp , <S2SV_EndBug> mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; }
CWE-119 static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; <S2SV_StartBug> nfcf_poll -> sensf_res_len = * data ++ ; <S2SV_EndBug> pr_debug ( "bit_rate<S2SV_blank>%d,<S2SV_blank>sensf_res_len<S2SV_blank>%d\\n" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }
CWE-000 static enum AVPixelFormat h263_get_format ( AVCodecContext * avctx ) <S2SV_StartBug> { <S2SV_EndBug> if ( avctx -> bits_per_raw_sample > 8 ) { <S2SV_StartBug> av_assert1 ( avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ; <S2SV_EndBug> return avctx -> pix_fmt ; } if ( avctx -> codec -> id == AV_CODEC_ID_MSS2 ) return AV_PIX_FMT_YUV420P ; if ( CONFIG_GRAY && ( avctx -> flags & AV_CODEC_FLAG_GRAY ) ) { if ( avctx -> color_range == AVCOL_RANGE_UNSPECIFIED ) avctx -> color_range = AVCOL_RANGE_MPEG ; return AV_PIX_FMT_GRAY8 ; } return avctx -> pix_fmt = ff_get_format ( avctx , avctx -> codec -> pix_fmts ) ; }
CWE-000 static void copy_xauthority ( void ) { char * src = RUN_XAUTHORITY_FILE ; char * dest ; if ( asprintf ( & dest , "%s/.Xauthority" , cfg . homedir ) == - 1 ) errExit ( "asprintf" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , "Error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link\\n" , dest ) ; exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( "fork" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; <S2SV_StartBug> int rv = copy_file ( src , dest ) ; <S2SV_EndBug> if ( rv ) fprintf ( stderr , "Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.Xauthority<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n" ) ; else { fs_logger2 ( "clone" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; <S2SV_StartBug> if ( chown ( dest , getuid ( ) , getgid ( ) ) < 0 ) <S2SV_EndBug> errExit ( "chown" ) ; <S2SV_StartBug> if ( chmod ( dest , S_IRUSR | S_IWUSR ) < 0 ) <S2SV_EndBug> errExit ( "chmod" ) ; unlink ( src ) ; }
CWE-264 static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; <S2SV_StartBug> u64 msr_data ; <S2SV_EndBug> int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ; <S2SV_StartBug> cs . dpl = 3 ; <S2SV_EndBug> ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ; <S2SV_StartBug> break ; <S2SV_EndBug> } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; <S2SV_StartBug> ctxt -> _eip = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_EndBug> <S2SV_StartBug> * reg_write ( ctxt , VCPU_REGS_RSP ) = reg_read ( ctxt , VCPU_REGS_RCX ) ; <S2SV_EndBug> return X86EMUL_CONTINUE ; }
CWE-119 void TEMPLATE ( process_block_dec ) ( decoder_info_t * decoder_info , int size , int yposY , int xposY , int sub ) { int width = decoder_info -> width ; int height = decoder_info -> height ; stream_t * stream = decoder_info -> stream ; frame_type_t frame_type = decoder_info -> frame_info . frame_type ; int split_flag = 0 ; if ( yposY >= height || xposY >= width ) return ; int decode_this_size = ( yposY + size <= height ) && ( xposY + size <= width ) ; int decode_rectangular_size = ! decode_this_size && frame_type != I_FRAME ; int bit_start = stream -> bitcnt ; int mode = MODE_SKIP ; block_context_t block_context ; TEMPLATE ( find_block_contexts ) ( yposY , xposY , height , width , size , decoder_info -> deblock_data , & block_context , decoder_info -> use_block_contexts ) ; decoder_info -> block_context = & block_context ; split_flag = decode_super_mode ( decoder_info , size , decode_this_size ) ; mode = decoder_info -> mode ; if ( size == ( 1 << decoder_info -> log2_sb_size ) && ( split_flag || mode != MODE_SKIP ) && decoder_info -> max_delta_qp > 0 ) { int delta_qp = read_delta_qp ( stream ) ; int prev_qp ; if ( yposY == 0 && xposY == 0 ) prev_qp = decoder_info -> frame_info . qp ; else prev_qp = decoder_info -> frame_info . qpb ; decoder_info -> frame_info . qpb = prev_qp + delta_qp ; } decoder_info -> bit_count . super_mode [ decoder_info -> bit_count . stat_frame_type ] += ( stream -> bitcnt - bit_start ) ; <S2SV_StartBug> if ( split_flag ) { <S2SV_EndBug> int new_size = size / 2 ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 1 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 1 * new_size , sub ) ; } else if ( decode_this_size || decode_rectangular_size ) { decode_block ( decoder_info , size , yposY , xposY , sub ) ; } }
CWE-119 static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; QuantumInfo * quantum_info ; QuantumType quantum_type ; MagickBooleanType status ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 1 ; image -> endian = MSBEndian ; ( void ) ReadBlobLSBShort ( image ) ; image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ; ( void ) ReadBlobLSBShort ( image ) ; image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> quantum_type = IndexQuantum ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = GetQuantumPixels ( quantum_info ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register PixelPacket * restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; count = ReadBlob ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , pixels ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-200 static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ; <S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; } <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( "new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }
CWE-787 char * enl_ipc_get ( const char * msg_data ) { static char * message = NULL ; <S2SV_StartBug> static unsigned short len = 0 ; <S2SV_EndBug> char buff [ 13 ] , * ret_msg = NULL ; register unsigned char i ; unsigned char blen ; if ( msg_data == IPC_TIMEOUT ) { return ( IPC_TIMEOUT ) ; } for ( i = 0 ; i < 12 ; i ++ ) { buff [ i ] = msg_data [ i ] ; } buff [ 12 ] = 0 ; blen = strlen ( buff ) ; if ( message != NULL ) { len += blen ; message = ( char * ) erealloc ( message , len + 1 ) ; strcat ( message , buff ) ; } else { len = blen ; message = ( char * ) emalloc ( len + 1 ) ; strcpy ( message , buff ) ; } if ( blen < 12 ) { ret_msg = message ; message = NULL ; D ( ( "Received<S2SV_blank>complete<S2SV_blank>reply:<S2SV_blank><S2SV_blank>\\"%s\\"\\n" , ret_msg ) ) ; } return ( ret_msg ) ; }
CWE-119 static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; <S2SV_EndBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; return r -> qiov . size / 512 ; }
CWE-000 static void sas_init_port ( struct asd_sas_port * port , struct sas_ha_struct * sas_ha , int i ) { memset ( port , 0 , sizeof ( * port ) ) ; port -> id = i ; INIT_LIST_HEAD ( & port -> dev_list ) ; INIT_LIST_HEAD ( & port -> disco_list ) ; INIT_LIST_HEAD ( & port -> destroy_list ) ; <S2SV_StartBug> spin_lock_init ( & port -> phy_list_lock ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & port -> phy_list ) ; port -> ha = sas_ha ; spin_lock_init ( & port -> dev_list_lock ) ; }
CWE-416 static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; <S2SV_StartBug> rec -> sasl_username = src -> sasl_username ; <S2SV_EndBug> <S2SV_StartBug> rec -> sasl_password = src -> sasl_password ; <S2SV_EndBug> * dest = ( SERVER_CONNECT_REC * ) rec ; }
CWE-416 static void timerfd_remove_cancel ( struct timerfd_ctx * ctx ) { <S2SV_StartBug> if ( ctx -> might_cancel ) { <S2SV_EndBug> ctx -> might_cancel = false ; <S2SV_StartBug> spin_lock ( & cancel_lock ) ; <S2SV_EndBug> <S2SV_StartBug> list_del_rcu ( & ctx -> clist ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & cancel_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
CWE-190 static int vfio_msi_enable ( struct vfio_pci_device * vdev , int nvec , bool msix ) { struct pci_dev * pdev = vdev -> pdev ; unsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI ; int ret ; if ( ! is_irq_none ( vdev ) ) return - EINVAL ; <S2SV_StartBug> vdev -> ctx = kzalloc ( nvec * sizeof ( struct vfio_pci_irq_ctx ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! vdev -> ctx ) return - ENOMEM ; ret = pci_alloc_irq_vectors ( pdev , 1 , nvec , flag ) ; if ( ret < nvec ) { if ( ret > 0 ) pci_free_irq_vectors ( pdev ) ; kfree ( vdev -> ctx ) ; return ret ; } vdev -> num_ctx = nvec ; vdev -> irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX : VFIO_PCI_MSI_IRQ_INDEX ; if ( ! msix ) { vdev -> msi_qmax = fls ( nvec * 2 - 1 ) - 1 ; } return 0 ; }
CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos ) <S2SV_StartBug> { <S2SV_EndBug> # ifdef BS_DEBUG elog ( DEBUG3 , ( ptr [ * pos ] . type == OPR ) ? "%d<S2SV_blank><S2SV_blank>%c" : "%d<S2SV_blank><S2SV_blank>%d" , * pos , ptr [ * pos ] . val ) ; # endif if ( ptr [ * pos ] . type == VAL ) { ptr [ * pos ] . left = 0 ; ( * pos ) -- ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = - 1 ; ( * pos ) -- ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) -- ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }
CWE-000 static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ; <S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , "No<S2SV_blank>longer<S2SV_blank>receiving<S2SV_blank>playlist<S2SV_blank>%d\\n" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload : <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , "Failed<S2SV_blank>to<S2SV_blank>reload<S2SV_blank>playlist<S2SV_blank>%d\\n" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , "skipping<S2SV_blank>%d<S2SV_blank>segments<S2SV_blank>ahead,<S2SV_blank>expired<S2SV_blank>from<S2SV_blank>playlists\\n" , v -> start_seq_no - v -> cur_seq_no ) ; v -> cur_seq_no = v -> start_seq_no ; } if ( v -> cur_seq_no >= v -> start_seq_no + v -> n_segments ) { if ( v -> finished ) return AVERROR_EOF ; while ( av_gettime_relative ( ) - v -> last_load_time < reload_interval ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_usleep ( 100 * 1000 ) ; } goto reload ; } seg = current_segment ( v ) ; ret = update_init_section ( v , seg ) ; if ( ret ) return ret ; ret = open_input ( c , v , seg ) ; if ( ret < 0 ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_log ( v -> parent , AV_LOG_WARNING , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>segment<S2SV_blank>of<S2SV_blank>playlist<S2SV_blank>%d\\n" , v -> index ) ; v -> cur_seq_no += 1 ; goto reload ; } just_opened = 1 ; } if ( v -> init_sec_buf_read_offset < v -> init_sec_data_len ) { int copy_size = FFMIN ( v -> init_sec_data_len - v -> init_sec_buf_read_offset , buf_size ) ; memcpy ( buf , v -> init_sec_buf , copy_size ) ; v -> init_sec_buf_read_offset += copy_size ; return copy_size ; } ret = read_from_url ( v , current_segment ( v ) , buf , buf_size , READ_NORMAL ) ; if ( ret > 0 ) { if ( just_opened && v -> is_id3_timestamped != 0 ) { intercept_id3 ( v , buf , buf_size , & ret ) ; } return ret ; } ff_format_io_close ( v -> parent , & v -> input ) ; v -> cur_seq_no ++ ; c -> cur_seq_no = v -> cur_seq_no ; goto restart ; }
CWE-20 static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; <S2SV_StartBug> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; <S2SV_EndBug> if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - EEXIST ; goto unlock_vcpu_destroy ; } BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; kvm_arch_vcpu_postcreate ( vcpu ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }
CWE-119 static INLINE void mi_buf_shift ( MACROBLOCK * x , int i ) { MB_MODE_INFO * const mbmi = & x -> e_mbd . mi [ 0 ] -> mbmi ; struct macroblock_plane * const p = & x -> plane [ 0 ] ; struct macroblockd_plane * const pd = & x -> e_mbd . plane [ 0 ] ; <S2SV_StartBug> p -> src . buf = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ; <S2SV_EndBug> assert ( ( ( intptr_t ) pd -> pre [ 0 ] . buf & 0x7 ) == 0 ) ; <S2SV_StartBug> pd -> pre [ 0 ] . buf = & pd -> pre [ 0 ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> pre [ 0 ] . stride ) ] ; if ( has_second_ref ( mbmi ) ) <S2SV_StartBug> pd -> pre [ 1 ] . buf = & pd -> pre [ 1 ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> pre [ 1 ] . stride ) ] ; }
CWE-190 static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { pirlvl = pi -> picomp -> pirlvls ; <S2SV_StartBug> pi -> xstep = pi -> picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <S2SV_EndBug> pi -> picomp -> numrlvls - 1 ) ) ; <S2SV_StartBug> pi -> ystep = pi -> picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <S2SV_EndBug> pi -> picomp -> numrlvls - 1 ) ) ; for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ; rlvlno < pi -> picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; <S2SV_StartBug> pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
CWE-000 DECLAREcpFunc ( cpDecodedStrips ) { tsize_t stripsize = TIFFStripSize ( in ) ; tdata_t buf = _TIFFmalloc ( stripsize ) ; ( void ) imagewidth ; ( void ) spp ; if ( buf ) { tstrip_t s , ns = TIFFNumberOfStrips ( in ) ; uint32 row = 0 ; _TIFFmemset ( buf , 0 , stripsize ) ; <S2SV_StartBug> for ( s = 0 ; s < ns ; s ++ ) { <S2SV_EndBug> tsize_t cc = ( row + rowsperstrip > imagelength ) ? TIFFVStripSize ( in , imagelength - row ) : stripsize ; if ( TIFFReadEncodedStrip ( in , s , buf , cc ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>strip<S2SV_blank>%lu" , ( unsigned long ) s ) ; goto bad ; } if ( TIFFWriteEncodedStrip ( out , s , buf , cc ) < 0 ) { TIFFError ( TIFFFileName ( out ) , "Error,<S2SV_blank>can\'t<S2SV_blank>write<S2SV_blank>strip<S2SV_blank>%lu" , ( unsigned long ) s ) ; goto bad ; } row += rowsperstrip ; } _TIFFfree ( buf ) ; return 1 ; } else { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%lu<S2SV_blank>" "to<S2SV_blank>read<S2SV_blank>strips" , ( unsigned long ) stripsize ) ; return 0 ; } bad : _TIFFfree ( buf ) ; return 0 ; }
CWE-119 WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ ( u4_word ) ; u4_bitstream_offset += ( u4_ldz + 1 ) ; u4_word = 0 ; if ( u4_ldz ) GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , u4_ldz ) ; * pu4_bitstrm_ofst = u4_bitstream_offset ; u4_temp = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; if ( u4_temp > 25 ) return ERROR_MB_TYPE ; u1_mb_type = u4_temp ; } ps_cur_mb_info -> u1_mb_type = u1_mb_type ; COPYTHECONTEXT ( "u1_mb_type" , u1_mb_type ) ; if ( 25 == u1_mb_type ) { ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = 0 ; } else { ret = ih264d_parse_imb_cavlc ( ps_dec , ps_cur_mb_info , u1_num_mbs , u1_mb_type ) ; if ( ret != OK ) return ret ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; } if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; { mv_pred_t * ps_mv_nmb_start = ps_dec -> ps_mv_cur + ( u1_num_mbs << 4 ) ; mv_pred_t s_mvPred = { { 0 , 0 , 0 , 0 } , { - 1 , - 1 } , 0 , 0 } ; ih264d_rep_mv_colz ( ps_dec , & s_mvPred , ps_mv_nmb_start , 0 , ( UWORD8 ) ( ps_dec -> u1_cur_mb_fld_dec_flag << 1 ) , 4 , 4 ) ; } if ( ps_dec -> u4_num_cores < 3 ) { if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ps_dec -> pf_compute_bs ( ps_dec , ps_cur_mb_info , ( UWORD16 ) ( u1_num_mbs >> u1_mbaff ) ) ; } u1_num_mbs ++ ; <S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || ( ! uc_more_data_flag ) ; ps_cur_mb_info -> u1_end_of_slice = ( ! uc_more_data_flag ) ; if ( u1_tfr_n_mb || ( ! uc_more_data_flag ) ) { if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } while ( uc_more_data_flag ) ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ( u2_first_mb_in_slice << u1_mbaff ) ; return ret ; }
CWE-284 static void _prolog_error ( batch_job_launch_msg_t * req , int rc ) { char * err_name_ptr , err_name [ 256 ] , path_name [ MAXPATHLEN ] ; char * fmt_char ; int fd ; if ( req -> std_err || req -> std_out ) { if ( req -> std_err ) strncpy ( err_name , req -> std_err , sizeof ( err_name ) ) ; else strncpy ( err_name , req -> std_out , sizeof ( err_name ) ) ; if ( ( fmt_char = strchr ( err_name , ( int ) '%' ) ) && ( fmt_char [ 1 ] == 'j' ) && ! strchr ( fmt_char + 1 , ( int ) '%' ) ) { char tmp_name [ 256 ] ; fmt_char [ 1 ] = 'u' ; snprintf ( tmp_name , sizeof ( tmp_name ) , err_name , req -> job_id ) ; strncpy ( err_name , tmp_name , sizeof ( err_name ) ) ; } } else { snprintf ( err_name , sizeof ( err_name ) , "slurm-%u.out" , req -> job_id ) ; } err_name_ptr = err_name ; if ( err_name_ptr [ 0 ] == '/' ) snprintf ( path_name , MAXPATHLEN , "%s" , err_name_ptr ) ; else if ( req -> work_dir ) snprintf ( path_name , MAXPATHLEN , "%s/%s" , req -> work_dir , err_name_ptr ) ; else snprintf ( path_name , MAXPATHLEN , "/%s" , err_name_ptr ) ; <S2SV_StartBug> if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> error ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s" , path_name , <S2SV_EndBug> slurm_strerror ( errno ) ) ; return ; } snprintf ( err_name , sizeof ( err_name ) , "Error<S2SV_blank>running<S2SV_blank>slurm<S2SV_blank>prolog:<S2SV_blank>%d\\n" , WEXITSTATUS ( rc ) ) ; safe_write ( fd , err_name , strlen ( err_name ) ) ; if ( fchown ( fd , ( uid_t ) req -> uid , ( gid_t ) req -> gid ) == - 1 ) { snprintf ( err_name , sizeof ( err_name ) , "Couldn\'t<S2SV_blank>change<S2SV_blank>fd<S2SV_blank>owner<S2SV_blank>to<S2SV_blank>%u:%u:<S2SV_blank>%m\\n" , req -> uid , req -> gid ) ; } rwfail : close ( fd ) ; }
CWE-119 PHP_FUNCTION ( radius_get_vendor_attr ) { <S2SV_StartBug> int res ; <S2SV_EndBug> <S2SV_StartBug> const void * data ; <S2SV_EndBug> int len ; <S2SV_StartBug> u_int32_t vendor ; <S2SV_EndBug> <S2SV_StartBug> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "s" , & data , & len ) == FAILURE ) { <S2SV_EndBug> return ; } <S2SV_StartBug> res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; <S2SV_EndBug> if ( res == - 1 ) { RETURN_FALSE ; } else { array_init ( return_value ) ; <S2SV_StartBug> add_assoc_long ( return_value , "attr" , res ) ; <S2SV_EndBug> add_assoc_long ( return_value , "vendor" , vendor ) ; <S2SV_StartBug> add_assoc_stringl ( return_value , "data" , ( char * ) data , len , 1 ) ; <S2SV_EndBug> return ; } }
CWE-20 static void request_key_auth_describe ( const struct key * key , struct seq_file * m ) { struct request_key_auth * rka = key -> payload . data [ 0 ] ; seq_puts ( m , "key:" ) ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , "<S2SV_blank>pid:%d<S2SV_blank>ci:%zu" , rka -> pid , rka -> callout_len ) ; }
CWE-119 static bool parse_reconnect ( struct pool * pool , json_t * val ) { char * sockaddr_url , * stratum_port , * tmp ; char * url , * port , address [ 256 ] ; memset ( address , 0 , 255 ) ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; else { char * dot_pool , * dot_reconnect ; dot_pool = strchr ( pool -> sockaddr_url , '.' ) ; if ( ! dot_pool ) { applog ( LOG_ERR , "Denied<S2SV_blank>stratum<S2SV_blank>reconnect<S2SV_blank>request<S2SV_blank>for<S2SV_blank>pool<S2SV_blank>without<S2SV_blank>domain<S2SV_blank>\'%s\'" , pool -> sockaddr_url ) ; return false ; } dot_reconnect = strchr ( url , '.' ) ; if ( ! dot_reconnect ) { applog ( LOG_ERR , "Denied<S2SV_blank>stratum<S2SV_blank>reconnect<S2SV_blank>request<S2SV_blank>to<S2SV_blank>url<S2SV_blank>without<S2SV_blank>domain<S2SV_blank>\'%s\'" , url ) ; return false ; } if ( strcmp ( dot_pool , dot_reconnect ) ) { applog ( LOG_ERR , "Denied<S2SV_blank>stratum<S2SV_blank>reconnect<S2SV_blank>request<S2SV_blank>to<S2SV_blank>non-matching<S2SV_blank>domain<S2SV_blank>url<S2SV_blank>\'%s\'" , pool -> sockaddr_url ) ; return false ; } } port = ( char * ) json_string_value ( json_array_get ( val , 1 ) ) ; if ( ! port ) port = pool -> stratum_port ; <S2SV_StartBug> sprintf ( address , "%s:%s" , url , port ) ; <S2SV_EndBug> if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ; applog ( LOG_WARNING , "Stratum<S2SV_blank>reconnect<S2SV_blank>requested<S2SV_blank>from<S2SV_blank>pool<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s" , pool -> pool_no , address ) ; clear_pool_work ( pool ) ; mutex_lock ( & pool -> stratum_lock ) ; __suspend_stratum ( pool ) ; tmp = pool -> sockaddr_url ; pool -> sockaddr_url = sockaddr_url ; pool -> stratum_url = pool -> sockaddr_url ; free ( tmp ) ; tmp = pool -> stratum_port ; pool -> stratum_port = stratum_port ; free ( tmp ) ; mutex_unlock ( & pool -> stratum_lock ) ; if ( ! restart_stratum ( pool ) ) { pool_failed ( pool ) ; return false ; } return true ; }
CWE-399 static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( "PMI:<S2SV_blank>silly<S2SV_blank>index<S2SV_blank>%ld\\n" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( "PMI:<S2SV_blank>No<S2SV_blank>event<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d!\\n" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }
CWE-119 EAS_BOOL WT_CheckSampleEnd ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame , EAS_BOOL update ) { EAS_U32 endPhaseAccum ; EAS_U32 endPhaseFrac ; EAS_I32 numSamples ; EAS_BOOL done = EAS_FALSE ; endPhaseFrac = pWTVoice -> phaseFrac + ( pWTIntFrame -> frame . phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS ) ; endPhaseAccum = pWTVoice -> phaseAccum + GET_PHASE_INT_PART ( endPhaseFrac ) ; if ( endPhaseAccum >= pWTVoice -> loopEnd ) { numSamples = ( EAS_I32 ) ( pWTVoice -> loopEnd - pWTVoice -> phaseAccum ) ; numSamples = ( EAS_I32 ) ( ( numSamples << NUM_PHASE_FRAC_BITS ) - pWTVoice -> phaseFrac ) ; if ( pWTIntFrame -> frame . phaseIncrement ) { pWTIntFrame -> numSamples = 1 + ( numSamples / pWTIntFrame -> frame . phaseIncrement ) ; } else { pWTIntFrame -> numSamples = numSamples ; } if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( "b/26366256" ) ; <S2SV_StartBug> pWTIntFrame -> numSamples = 0 ; <S2SV_EndBug> } done = EAS_TRUE ; } if ( update ) { pWTVoice -> phaseFrac = endPhaseFrac ; pWTVoice -> phaseAccum = endPhaseAccum ; } return done ; }
CWE-119 static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref , <S2SV_StartBug> int_mv * prev_golden_ref_mv , <S2SV_EndBug> YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error ; VP9_COMMON * cm = & cpi -> common ; x -> plane [ 0 ] . src . buf = buf -> y_buffer + mb_y_offset ; x -> plane [ 0 ] . src . stride = buf -> y_stride ; xd -> plane [ 0 ] . dst . buf = get_frame_new_buffer ( cm ) -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . dst . stride = get_frame_new_buffer ( cm ) -> y_stride ; intra_error = find_best_16x16_intra ( cpi , & stats -> ref [ INTRA_FRAME ] . m . mode ) ; if ( intra_error <= 0 ) intra_error = 1 ; stats -> ref [ INTRA_FRAME ] . err = intra_error ; if ( golden_ref ) { int g_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = golden_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = golden_ref -> y_stride ; g_motion_error = do_16x16_motion_search ( cpi , prev_golden_ref_mv , & stats -> ref [ GOLDEN_FRAME ] . m . mv , mb_row , mb_col ) ; stats -> ref [ GOLDEN_FRAME ] . err = g_motion_error ; } else { stats -> ref [ GOLDEN_FRAME ] . err = INT_MAX ; stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int = 0 ; } if ( alt_ref ) { int a_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = alt_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = alt_ref -> y_stride ; a_motion_error = do_16x16_zerozero_search ( cpi , & stats -> ref [ ALTREF_FRAME ] . m . mv ) ; stats -> ref [ ALTREF_FRAME ] . err = a_motion_error ; } else { stats -> ref [ ALTREF_FRAME ] . err = INT_MAX ; stats -> ref [ ALTREF_FRAME ] . m . mv . as_int = 0 ; } }
CWE-119 <S2SV_StartBug> static void read_tx_mode_probs ( struct tx_probs * tx_probs , vp9_reader * r ) { <S2SV_EndBug> int i , j ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) for ( j = 0 ; j < TX_SIZES - 3 ; ++ j ) vp9_diff_update_prob ( r , & tx_probs -> p8x8 [ i ] [ j ] ) ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) for ( j = 0 ; j < TX_SIZES - 2 ; ++ j ) vp9_diff_update_prob ( r , & tx_probs -> p16x16 [ i ] [ j ] ) ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) for ( j = 0 ; j < TX_SIZES - 1 ; ++ j ) vp9_diff_update_prob ( r , & tx_probs -> p32x32 [ i ] [ j ] ) ; }
CWE-119 static __exit void sctp_exit ( void ) { sctp_v6_del_protocol ( ) ; sctp_v4_del_protocol ( ) ; <S2SV_StartBug> unregister_pernet_subsys ( & sctp_net_ops ) ; <S2SV_EndBug> sctp_v6_protosw_exit ( ) ; <S2SV_StartBug> sctp_v4_protosw_exit ( ) ; <S2SV_EndBug> sctp_v6_pf_exit ( ) ; sctp_v4_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; kfree ( sctp_ep_hashtable ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; percpu_counter_destroy ( & sctp_sockets_allocated ) ; rcu_barrier ( ) ; kmem_cache_destroy ( sctp_chunk_cachep ) ; kmem_cache_destroy ( sctp_bucket_cachep ) ; }
CWE-000 static struct sk_buff * * gre_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct sk_buff * p ; const struct gre_base_hdr * greh ; unsigned int hlen , grehlen ; unsigned int off ; int flush = 1 ; struct packet_offload * ptype ; <S2SV_StartBug> __be16 type ; <S2SV_EndBug> off = skb_gro_offset ( skb ) ; hlen = off + sizeof ( * greh ) ; greh = skb_gro_header_fast ( skb , off ) ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out ; } if ( ( greh -> flags & ~ ( GRE_KEY | GRE_CSUM ) ) != 0 ) goto out ; type = greh -> protocol ; rcu_read_lock ( ) ; ptype = gro_find_receive_by_type ( type ) ; if ( ! ptype ) goto out_unlock ; grehlen = GRE_HEADER_SECTION ; if ( greh -> flags & GRE_KEY ) grehlen += GRE_HEADER_SECTION ; if ( greh -> flags & GRE_CSUM ) grehlen += GRE_HEADER_SECTION ; hlen = off + grehlen ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out_unlock ; } if ( ( greh -> flags & GRE_CSUM ) && ! NAPI_GRO_CB ( skb ) -> flush ) { if ( skb_gro_checksum_simple_validate ( skb ) ) goto out_unlock ; skb_gro_checksum_try_convert ( skb , IPPROTO_GRE , 0 , null_compute_pseudo ) ; } for ( p = * head ; p ; p = p -> next ) { const struct gre_base_hdr * greh2 ; if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; greh2 = ( struct gre_base_hdr * ) ( p -> data + off ) ; if ( greh2 -> flags != greh -> flags || greh2 -> protocol != greh -> protocol ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } if ( greh -> flags & GRE_KEY ) { if ( * ( __be32 * ) ( greh2 + 1 ) != * ( __be32 * ) ( greh + 1 ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } } skb_gro_pull ( skb , grehlen ) ; skb_gro_postpull_rcsum ( skb , greh , grehlen ) ; pp = ptype -> callbacks . gro_receive ( head , skb ) ; flush = 0 ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }
CWE-000 static void sas_eh_handle_sas_errors ( struct Scsi_Host * shost , struct list_head * work_q ) { struct scsi_cmnd * cmd , * n ; enum task_disposition res = TASK_IS_DONE ; int tmf_resp , need_reset ; struct sas_internal * i = to_sas_internal ( shost -> transportt ) ; unsigned long flags ; struct sas_ha_struct * ha = SHOST_TO_SAS_HA ( shost ) ; LIST_HEAD ( done ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct sas_task * task ; spin_lock_irqsave ( & dev -> done_lock , flags ) ; task = TO_SAS_TASK ( cmd ) ; spin_unlock_irqrestore ( & dev -> done_lock , flags ) ; if ( ! task ) list_move_tail ( & cmd -> eh_entry , & done ) ; } Again : list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct sas_task * task = TO_SAS_TASK ( cmd ) ; list_del_init ( & cmd -> eh_entry ) ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; need_reset = task -> task_state_flags & SAS_TASK_NEED_DEV_RESET ; spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; if ( need_reset ) { SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>requests<S2SV_blank>reset\\n" , __func__ , task ) ; goto reset ; } SAS_DPRINTK ( "trying<S2SV_blank>to<S2SV_blank>find<S2SV_blank>task<S2SV_blank>0x%p\\n" , task ) ; res = sas_scsi_find_task ( task ) ; switch ( res ) { case TASK_IS_DONE : SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\n" , __func__ , task ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> continue ; case TASK_IS_ABORTED : SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>aborted\\n" , __func__ , task ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> continue ; case TASK_IS_AT_LU : SAS_DPRINTK ( "task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>lu<S2SV_blank>recover\\n" , task ) ; reset : tmf_resp = sas_recover_lu ( task -> dev , cmd ) ; if ( tmf_resp == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( "dev<S2SV_blank>%016llx<S2SV_blank>LU<S2SV_blank>%llx<S2SV_blank>is<S2SV_blank>" "recovered\\n" , SAS_ADDR ( task -> dev ) , cmd -> device -> lun ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> sas_scsi_clear_queue_lu ( work_q , cmd ) ; goto Again ; } case TASK_IS_NOT_AT_LU : case TASK_ABORT_FAILED : SAS_DPRINTK ( "task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>not<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>I_T<S2SV_blank>recover\\n" , task ) ; tmf_resp = sas_recover_I_T ( task -> dev ) ; if ( tmf_resp == TMF_RESP_FUNC_COMPLETE || tmf_resp == - ENODEV ) { struct domain_device * dev = task -> dev ; SAS_DPRINTK ( "I_T<S2SV_blank>%016llx<S2SV_blank>recovered\\n" , SAS_ADDR ( task -> dev -> sas_addr ) ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_I_T ( work_q , dev ) ; goto Again ; } try_to_reset_cmd_device ( cmd ) ; if ( i -> dft -> lldd_clear_nexus_port ) { struct asd_sas_port * port = task -> dev -> port ; SAS_DPRINTK ( "clearing<S2SV_blank>nexus<S2SV_blank>for<S2SV_blank>port:%d\\n" , port -> id ) ; res = i -> dft -> lldd_clear_nexus_port ( port ) ; if ( res == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( "clear<S2SV_blank>nexus<S2SV_blank>port:%d<S2SV_blank>" "succeeded\\n" , port -> id ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_port ( work_q , port ) ; goto Again ; } } if ( i -> dft -> lldd_clear_nexus_ha ) { SAS_DPRINTK ( "clear<S2SV_blank>nexus<S2SV_blank>ha\\n" ) ; res = i -> dft -> lldd_clear_nexus_ha ( ha ) ; if ( res == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( "clear<S2SV_blank>nexus<S2SV_blank>ha<S2SV_blank>" "succeeded\\n" ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } SAS_DPRINTK ( "error<S2SV_blank>from<S2SV_blank><S2SV_blank>device<S2SV_blank>%llx,<S2SV_blank>LUN<S2SV_blank>%llx<S2SV_blank>" "couldn\'t<S2SV_blank>be<S2SV_blank>recovered<S2SV_blank>in<S2SV_blank>any<S2SV_blank>way\\n" , SAS_ADDR ( task -> dev -> sas_addr ) , cmd -> device -> lun ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } out : list_splice_tail ( & done , work_q ) ; list_splice_tail_init ( & ha -> eh_ata_q , work_q ) ; return ; clear_q : SAS_DPRINTK ( "---<S2SV_blank>Exit<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>clear_q\\n" , __func__ ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) sas_eh_finish_cmd ( cmd ) ; goto out ; }
CWE-000 static void sas_revalidate_domain ( struct work_struct * work ) { int res = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; struct sas_ha_struct * ha = port -> ha ; struct domain_device * ddev = port -> port_dev ; mutex_lock ( & ha -> disco_mutex ) ; if ( test_bit ( SAS_HA_ATA_EH_ACTIVE , & ha -> state ) ) { SAS_DPRINTK ( "REVALIDATION<S2SV_blank>DEFERRED<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n" , port -> id , task_pid_nr ( current ) ) ; goto out ; } clear_bit ( DISCE_REVALIDATE_DOMAIN , & port -> disc . pending ) ; SAS_DPRINTK ( "REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n" , port -> id , task_pid_nr ( current ) ) ; if ( ddev && ( ddev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE || ddev -> dev_type == SAS_EDGE_EXPANDER_DEVICE ) ) res = sas_ex_revalidate_domain ( ddev ) ; SAS_DPRINTK ( "done<S2SV_blank>REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>res<S2SV_blank>0x%x\\n" , port -> id , task_pid_nr ( current ) , res ) ; out : mutex_unlock ( & ha -> disco_mutex ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-399 static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; <S2SV_StartBug> struct resv_map * reservations = vma_resv_map ( vma ) ; <S2SV_EndBug> unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; kref_put ( & reservations -> refs , resv_map_release ) ; if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; <S2SV_StartBug> hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ; <S2SV_EndBug> } } }
CWE-125 void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , "unknown<S2SV_blank>type<S2SV_blank>(%u)" , type ) ; ND_PRINT ( ( ndo , "VRRPv%u,<S2SV_blank>%s" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , ",<S2SV_blank>(ttl<S2SV_blank>%u)" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>vrid<S2SV_blank>%u,<S2SV_blank>prio<S2SV_blank>%u" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , ",<S2SV_blank>authtype<S2SV_blank>%s" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>intvl<S2SV_blank>%us,<S2SV_blank>length<S2SV_blank>%u" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , ",<S2SV_blank>intvl<S2SV_blank>%ucs,<S2SV_blank>length<S2SV_blank>%u" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; <S2SV_StartBug> if ( in_cksum ( vec , 1 ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)" , <S2SV_StartBug> EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; <S2SV_EndBug> } if ( version == 3 && ND_TTEST2 ( bp [ 0 ] , len ) ) { uint16_t cksum = nextproto4_cksum ( ndo , ( const struct ip * ) bp2 , bp , len , len , IPPROTO_VRRP ) ; if ( cksum ) ND_PRINT ( ( ndo , ",<S2SV_blank>(bad<S2SV_blank>vrrp<S2SV_blank>cksum<S2SV_blank>%x)" , EXTRACT_16BITS ( & bp [ 6 ] ) ) ) ; } ND_PRINT ( ( ndo , ",<S2SV_blank>addrs" ) ) ; if ( naddrs > 1 ) ND_PRINT ( ( ndo , "(%d)" , naddrs ) ) ; ND_PRINT ( ( ndo , ":" ) ) ; c = '<S2SV_blank>' ; bp += 8 ; for ( i = 0 ; i < naddrs ; i ++ ) { ND_TCHECK ( bp [ 3 ] ) ; ND_PRINT ( ( ndo , "%c%s" , c , ipaddr_string ( ndo , bp ) ) ) ; c = ',' ; bp += 4 ; } if ( version == 2 && auth_type == VRRP_AUTH_SIMPLE ) { ND_TCHECK ( bp [ 7 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>auth<S2SV_blank>\\"" ) ) ; if ( fn_printn ( ndo , bp , 8 , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , "\\"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "\\"" ) ) ; } } return ; trunc : ND_PRINT ( ( ndo , "[|vrrp]" ) ) ; }
CWE-125 int frag6_print ( netdissect_options * ndo , register const u_char * bp , register const u_char * bp2 ) { register const struct ip6_frag * dp ; register const struct ip6_hdr * ip6 ; dp = ( const struct ip6_frag * ) bp ; ip6 = ( const struct ip6_hdr * ) bp2 ; <S2SV_StartBug> ND_TCHECK ( dp -> ip6f_offlg ) ; <S2SV_EndBug> if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "frag<S2SV_blank>(0x%08x:%d|%ld)" , EXTRACT_32BITS ( & dp -> ip6f_ident ) , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } else { ND_PRINT ( ( ndo , "frag<S2SV_blank>(%d|%ld)" , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } if ( ( EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK ) != 0 ) return - 1 ; else { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; return sizeof ( struct ip6_frag ) ; } trunc : ND_PRINT ( ( ndo , "[|frag]" ) ) ; return - 1 ; }
CWE-20 static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) { struct cpio * cpio ; const void * h ; struct archive_string_conv * sconv ; size_t namelength ; size_t name_pad ; int r ; cpio = ( struct cpio * ) ( a -> format -> data ) ; sconv = cpio -> opt_sconv ; if ( sconv == NULL ) { if ( ! cpio -> init_default_conversion ) { cpio -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ; cpio -> init_default_conversion = 1 ; } sconv = cpio -> sconv_default ; } r = ( cpio -> read_header ( a , cpio , entry , & namelength , & name_pad ) ) ; if ( r < ARCHIVE_WARN ) return ( r ) ; h = __archive_read_ahead ( a , namelength + name_pad , NULL ) ; if ( h == NULL ) return ( ARCHIVE_FATAL ) ; if ( archive_entry_copy_pathname_l ( entry , ( const char * ) h , namelength , sconv ) != 0 ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , "Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Pathname<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale." , archive_string_conversion_charset_name ( sconv ) ) ; r = ARCHIVE_WARN ; } cpio -> entry_offset = 0 ; __archive_read_consume ( a , namelength + name_pad ) ; if ( archive_entry_filetype ( entry ) == AE_IFLNK ) { <S2SV_StartBug> h = __archive_read_ahead ( a , <S2SV_EndBug> ( size_t ) cpio -> entry_bytes_remaining , NULL ) ; if ( h == NULL ) return ( ARCHIVE_FATAL ) ; if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , "Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Linkname" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Linkname<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>" "current<S2SV_blank>locale." , archive_string_conversion_charset_name ( sconv ) ) ; r = ARCHIVE_WARN ; } __archive_read_consume ( a , cpio -> entry_bytes_remaining ) ; cpio -> entry_bytes_remaining = 0 ; } if ( namelength == 11 && strcmp ( ( const char * ) h , "TRAILER!!!" ) == 0 ) { archive_clear_error ( & a -> archive ) ; return ( ARCHIVE_EOF ) ; } if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) { return ( ARCHIVE_FATAL ) ; } return ( r ) ; }
CWE-399 static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }
CWE-200 int compat_get_timex ( struct timex * txc , const struct compat_timex __user * utp ) { struct compat_timex tx32 ; <S2SV_StartBug> if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) <S2SV_EndBug> return - EFAULT ; txc -> modes = tx32 . modes ; txc -> offset = tx32 . offset ; txc -> freq = tx32 . freq ; txc -> maxerror = tx32 . maxerror ; txc -> esterror = tx32 . esterror ; txc -> status = tx32 . status ; txc -> constant = tx32 . constant ; txc -> precision = tx32 . precision ; txc -> tolerance = tx32 . tolerance ; txc -> time . tv_sec = tx32 . time . tv_sec ; txc -> time . tv_usec = tx32 . time . tv_usec ; txc -> tick = tx32 . tick ; txc -> ppsfreq = tx32 . ppsfreq ; txc -> jitter = tx32 . jitter ; txc -> shift = tx32 . shift ; txc -> stabil = tx32 . stabil ; txc -> jitcnt = tx32 . jitcnt ; txc -> calcnt = tx32 . calcnt ; txc -> errcnt = tx32 . errcnt ; txc -> stbcnt = tx32 . stbcnt ; return 0 ; }
CWE-189 static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i ] = src1 [ i ] + src2 [ i ] ; }
CWE-119 int evutil_parse_sockaddr_port ( const char * ip_as_string , struct sockaddr * out , int * outlen ) { int port ; char buf [ 128 ] ; const char * cp , * addr_part , * port_part ; int is_ipv6 ; cp = strchr ( ip_as_string , ':' ) ; if ( * ip_as_string == '[' ) { <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! ( cp = strchr ( ip_as_string , ']' ) ) ) { return - 1 ; } <S2SV_StartBug> len = ( int ) ( cp - ( ip_as_string + 1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( len > ( int ) sizeof ( buf ) - 1 ) { <S2SV_EndBug> return - 1 ; } memcpy ( buf , ip_as_string + 1 , len ) ; buf [ len ] = '\\0' ; addr_part = buf ; if ( cp [ 1 ] == ':' ) port_part = cp + 2 ; else port_part = NULL ; is_ipv6 = 1 ; } else if ( cp && strchr ( cp + 1 , ':' ) ) { is_ipv6 = 1 ; addr_part = ip_as_string ; port_part = NULL ; } else if ( cp ) { is_ipv6 = 0 ; if ( cp - ip_as_string > ( int ) sizeof ( buf ) - 1 ) { return - 1 ; } memcpy ( buf , ip_as_string , cp - ip_as_string ) ; buf [ cp - ip_as_string ] = '\\0' ; addr_part = buf ; port_part = cp + 1 ; } else { addr_part = ip_as_string ; port_part = NULL ; is_ipv6 = 0 ; } if ( port_part == NULL ) { port = 0 ; } else { port = atoi ( port_part ) ; if ( port <= 0 || port > 65535 ) { return - 1 ; } } if ( ! addr_part ) return - 1 ; # ifdef AF_INET6 if ( is_ipv6 ) { struct sockaddr_in6 sin6 ; memset ( & sin6 , 0 , sizeof ( sin6 ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN sin6 . sin6_len = sizeof ( sin6 ) ; # endif sin6 . sin6_family = AF_INET6 ; sin6 . sin6_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET6 , addr_part , & sin6 . sin6_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin6 ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin6 , sizeof ( sin6 ) ) ; * outlen = sizeof ( sin6 ) ; return 0 ; } else # endif { struct sockaddr_in sin ; memset ( & sin , 0 , sizeof ( sin ) ) ; # ifdef EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN sin . sin_len = sizeof ( sin ) ; # endif sin . sin_family = AF_INET ; sin . sin_port = htons ( port ) ; if ( 1 != evutil_inet_pton ( AF_INET , addr_part , & sin . sin_addr ) ) return - 1 ; if ( ( int ) sizeof ( sin ) > * outlen ) return - 1 ; memset ( out , 0 , * outlen ) ; memcpy ( out , & sin , sizeof ( sin ) ) ; * outlen = sizeof ( sin ) ; return 0 ; } }
CWE-000 static OPJ_BOOL opj_pi_next_cprl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { pi -> first = 0 ; } for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 resno ; comp = & pi -> comps [ pi -> compno ] ; pi -> dx = 0 ; pi -> dy = 0 ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
CWE-264 int touch ( const char * path ) { <S2SV_StartBug> return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> }
CWE-000 UWORD16 impeg2d_get_mb_addr_incr ( stream_t * ps_stream ) { UWORD16 u2_mb_addr_incr = 0 ; <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , MB_ESCAPE_CODE_LEN ) ; u2_mb_addr_incr += 33 ; } u2_mb_addr_incr += impeg2d_dec_vld_symbol ( ps_stream , gai2_impeg2d_mb_addr_incr , MB_ADDR_INCR_LEN ) + MB_ADDR_INCR_OFFSET ; return ( u2_mb_addr_incr ) ; }
CWE-119 <S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> const JsVarFloat stopAtError = 0.0000001 ; <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , "NaN" , len ) ; <S2SV_EndBug> else if ( ! isfinite ( val ) ) { <S2SV_StartBug> if ( val < 0 ) strncpy ( str , "-Infinity" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , "Infinity" , len ) ; <S2SV_EndBug> } else { if ( val < 0 ) { if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '-' ; val = - val ; } if ( ( ( JsVarInt ) ( val + stopAtError ) ) == ( 1 + ( JsVarInt ) val ) ) val = ( JsVarFloat ) ( 1 + ( JsVarInt ) val ) ; JsVarFloat d = 1 ; while ( d * radix <= val ) d *= radix ; while ( d >= 1 ) { int v = ( int ) ( val / d ) ; val -= v * d ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix ; } # ifndef USE_NO_FLOATS if ( ( ( fractionalDigits < 0 ) && val > 0 ) || fractionalDigits > 0 ) { bool hasPt = false ; val *= radix ; while ( ( ( fractionalDigits < 0 ) && ( fractionalDigits > - 12 ) && ( val > stopAtError ) ) || ( fractionalDigits > 0 ) ) { int v = ( int ) ( val + ( ( fractionalDigits == 1 ) ? 0.4 : 0.00000001 ) ) ; val = ( val - v ) * radix ; if ( v == radix ) v = radix - 1 ; if ( ! hasPt ) { hasPt = true ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '.' ; } if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; fractionalDigits -- ; } } # endif * ( str ++ ) = 0 ; } }
CWE-399 static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ; if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <S2SV_StartBug> unix_inflight ( scm -> fp -> fp [ i ] ) ; <S2SV_EndBug> return max_level ; }
CWE-119 int copy_creds ( struct task_struct * p , unsigned long clone_flags ) { # ifdef CONFIG_KEYS struct thread_group_cred * tgcred ; # endif struct cred * new ; int ret ; <S2SV_StartBug> if ( <S2SV_EndBug> # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) { p -> real_cred = get_cred ( p -> cred ) ; get_cred ( p -> cred ) ; alter_cred_subscribers ( p -> cred , 2 ) ; kdebug ( "share_creds(%p{%d,%d})" , p -> cred , atomic_read ( & p -> cred -> usage ) , read_cred_subscribers ( p -> cred ) ) ; atomic_inc ( & p -> cred -> user -> processes ) ; return 0 ; } new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; if ( clone_flags & CLONE_NEWUSER ) { ret = create_user_ns ( new ) ; if ( ret < 0 ) goto error_put ; } new -> user_ns = new -> user -> user_ns ; # ifdef CONFIG_KEYS if ( new -> thread_keyring ) { key_put ( new -> thread_keyring ) ; new -> thread_keyring = NULL ; if ( clone_flags & CLONE_THREAD ) install_thread_keyring_to_cred ( new ) ; } if ( ! ( clone_flags & CLONE_THREAD ) ) { tgcred = kmalloc ( sizeof ( * tgcred ) , GFP_KERNEL ) ; if ( ! tgcred ) { ret = - ENOMEM ; goto error_put ; } atomic_set ( & tgcred -> usage , 1 ) ; spin_lock_init ( & tgcred -> lock ) ; tgcred -> process_keyring = NULL ; tgcred -> session_keyring = key_get ( new -> tgcred -> session_keyring ) ; release_tgcred ( new ) ; new -> tgcred = tgcred ; } # endif atomic_inc ( & new -> user -> processes ) ; p -> cred = p -> real_cred = get_cred ( new ) ; alter_cred_subscribers ( new , 2 ) ; validate_creds ( new ) ; return 0 ; error_put : put_cred ( new ) ; return ret ; }
CWE-284 static int uhid_write ( int fd , const struct uhid_event * ev ) { <S2SV_StartBug> ssize_t ret = write ( fd , ev , sizeof ( * ev ) ) ; <S2SV_EndBug> if ( ret < 0 ) { int rtn = - errno ; APPL_TRACE_ERROR ( "%s:<S2SV_blank>Cannot<S2SV_blank>write<S2SV_blank>to<S2SV_blank>uhid:%s" , __FUNCTION__ , strerror ( errno ) ) ; return rtn ; } else if ( ret != ( ssize_t ) sizeof ( * ev ) ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Wrong<S2SV_blank>size<S2SV_blank>written<S2SV_blank>to<S2SV_blank>uhid:<S2SV_blank>%zd<S2SV_blank>!=<S2SV_blank>%zu" , __FUNCTION__ , ret , sizeof ( * ev ) ) ; return - EFAULT ; } return 0 ; }
CWE-000 static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec , <S2SV_StartBug> bool compat ) <S2SV_EndBug> { ssize_t ret ; * nr_segs = * len ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( rw , ( struct compat_iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; else # endif ret = rw_copy_check_uvector ( rw , ( struct iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; if ( ret < 0 ) return ret ; * len = ret ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-000 static void on_read ( h2o_socket_t * sock , int status ) { h2o_http2_conn_t * conn = sock -> data ; if ( status != 0 ) { h2o_socket_read_stop ( conn -> sock ) ; close_connection ( conn ) ; return ; } update_idle_timeout ( conn ) ; <S2SV_StartBug> parse_input ( conn ) ; <S2SV_EndBug> if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { h2o_timeout_unlink ( & conn -> _write . timeout_entry ) ; do_emit_writereq ( conn ) ; } }
CWE-119 static long vop_ioctl ( struct file * f , unsigned int cmd , unsigned long arg ) { struct vop_vdev * vdev = f -> private_data ; struct vop_info * vi = vdev -> vi ; void __user * argp = ( void __user * ) arg ; int ret ; switch ( cmd ) { case MIC_VIRTIO_ADD_DEVICE : { struct mic_device_desc dd , * dd_config ; if ( copy_from_user ( & dd , argp , sizeof ( dd ) ) ) return - EFAULT ; if ( mic_aligned_desc_size ( & dd ) > MIC_MAX_DESC_BLK_SIZE || dd . num_vq > MIC_MAX_VRINGS ) return - EINVAL ; dd_config = kzalloc ( mic_desc_size ( & dd ) , GFP_KERNEL ) ; if ( ! dd_config ) return - ENOMEM ; if ( copy_from_user ( dd_config , argp , mic_desc_size ( & dd ) ) ) { ret = - EFAULT ; goto free_ret ; } <S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> mutex_lock ( & vi -> vop_mutex ) ; ret = vop_virtio_add_device ( vdev , dd_config ) ; if ( ret ) goto unlock_ret ; list_add_tail ( & vdev -> list , & vi -> vdev_list ) ; unlock_ret : mutex_unlock ( & vi -> vop_mutex ) ; mutex_unlock ( & vdev -> vdev_mutex ) ; free_ret : kfree ( dd_config ) ; return ret ; } case MIC_VIRTIO_COPY_DESC : { struct mic_copy_desc copy ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto _unlock_ret ; if ( copy_from_user ( & copy , argp , sizeof ( copy ) ) ) { ret = - EFAULT ; goto _unlock_ret ; } ret = vop_virtio_copy_desc ( vdev , & copy ) ; if ( ret < 0 ) goto _unlock_ret ; if ( copy_to_user ( & ( ( struct mic_copy_desc __user * ) argp ) -> out_len , & copy . out_len , sizeof ( copy . out_len ) ) ) ret = - EFAULT ; _unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } case MIC_VIRTIO_CONFIG_CHANGE : { void * buf ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto __unlock_ret ; buf = kzalloc ( vdev -> dd -> config_len , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto __unlock_ret ; } if ( copy_from_user ( buf , argp , vdev -> dd -> config_len ) ) { ret = - EFAULT ; goto done ; } ret = vop_virtio_config_change ( vdev , buf ) ; done : kfree ( buf ) ; __unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } default : return - ENOIOCTLCMD ; } ; return 0 ; }
CWE-000 void wiki_handle_http_request ( HttpRequest * req ) { HttpResponse * res = http_response_new ( req ) ; char * page = http_request_get_path_info ( req ) ; char * command = http_request_get_query_string ( req ) ; char * wikitext = "" ; util_dehttpize ( page ) ; if ( ! strcmp ( page , "/" ) ) { if ( access ( "WikiHome" , R_OK ) != 0 ) wiki_redirect ( res , "/WikiHome?create" ) ; page = "/WikiHome" ; } if ( ! strcmp ( page , "/styles.css" ) ) { http_response_set_content_type ( res , "text/css" ) ; http_response_printf ( res , "%s" , CssData ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , "/favicon.ico" ) ) { http_response_set_content_type ( res , "image/ico" ) ; http_response_set_data ( res , FaviconData , FaviconDataLen ) ; http_response_send ( res ) ; exit ( 0 ) ; } page = page + 1 ; if ( ! strncmp ( page , "api/" , 4 ) ) { char * p ; page += 4 ; for ( p = page ; * p != '\\0' ; p ++ ) if ( * p == '?' ) { * p = '\\0' ; break ; } wiki_handle_rest_call ( req , res , page ) ; exit ( 0 ) ; } <S2SV_StartBug> if ( strchr ( page , '/' ) ) <S2SV_EndBug> { http_response_set_status ( res , 404 , "Not<S2SV_blank>Found" ) ; http_response_printf ( res , "<html><body>404<S2SV_blank>Not<S2SV_blank>Found</body></html>\\n" ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , "Changes" ) ) { wiki_show_changes_page ( res ) ; } else if ( ! strcmp ( page , "ChangesRss" ) ) { wiki_show_changes_page_rss ( res ) ; } else if ( ! strcmp ( page , "Search" ) ) { wiki_show_search_results_page ( res , http_request_param_get ( req , "expr" ) ) ; } else if ( ! strcmp ( page , "Create" ) ) { if ( ( wikitext = http_request_param_get ( req , "title" ) ) != NULL ) { wiki_redirect ( res , http_request_param_get ( req , "title" ) ) ; } else { wiki_show_create_page ( res ) ; } } else { if ( ( wikitext = http_request_param_get ( req , "wikitext" ) ) != NULL ) { file_write ( page , wikitext ) ; } if ( access ( page , R_OK ) == 0 ) { wikitext = file_read ( page ) ; if ( ! strcmp ( command , "edit" ) ) { wiki_show_edit_page ( res , wikitext , page ) ; } else { wiki_show_page ( res , wikitext , page ) ; } } else { if ( ! strcmp ( command , "create" ) ) { wiki_show_edit_page ( res , NULL , page ) ; } else { char buf [ 1024 ] ; snprintf ( buf , 1024 , "%s?create" , page ) ; wiki_redirect ( res , buf ) ; } } } }
CWE-20 static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; <S2SV_StartBug> vma_stop ( priv , vma ) ; <S2SV_EndBug> if ( priv -> task ) put_task_struct ( priv -> task ) ; }
CWE-119 void queue_push ( register Queue * qp , size_t extra_length , char const * info ) { register char * cp ; size_t memory_length ; size_t available_length ; size_t begin_length ; size_t n_begin ; size_t q_length ; if ( ! extra_length ) return ; memory_length = qp -> d_memory_end - qp -> d_memory ; q_length = qp -> d_read <= qp -> d_write ? ( size_t ) ( qp -> d_write - qp -> d_read ) : memory_length - ( qp -> d_read - qp -> d_write ) ; available_length = memory_length - q_length - 1 ; if ( message_show ( MSG_INFO ) ) message ( "push_front<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>`%s\'" , ( unsigned ) extra_length , info ) ; if ( extra_length > available_length ) { <S2SV_StartBug> memory_length += extra_length - available_length + BLOCK_QUEUE ; <S2SV_EndBug> cp = new_memory ( memory_length , sizeof ( char ) ) ; if ( message_show ( MSG_INFO ) ) message ( "Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p" , qp -> d_memory , cp ) ; if ( qp -> d_read > qp -> d_write ) { size_t tail_len = qp -> d_memory_end - qp -> d_read ; memcpy ( cp , qp -> d_read , tail_len ) ; memcpy ( cp + tail_len , qp -> d_memory , ( size_t ) ( qp -> d_write - qp -> d_memory ) ) ; qp -> d_write = cp + q_length ; qp -> d_read = cp ; } else { <S2SV_StartBug> memcpy ( cp , qp -> d_memory , memory_length ) ; <S2SV_EndBug> qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ; qp -> d_write = cp + ( qp -> d_write - qp -> d_memory ) ; } free ( qp -> d_memory ) ; qp -> d_memory_end = cp + memory_length ; qp -> d_memory = cp ; } begin_length = qp -> d_read - qp -> d_memory ; n_begin = extra_length <= begin_length ? extra_length : begin_length ; memcpy ( qp -> d_read -= n_begin , info + extra_length - n_begin , n_begin ) ; if ( extra_length > begin_length ) { extra_length -= begin_length ; memcpy ( qp -> d_read = qp -> d_memory_end - extra_length , info , extra_length ) ; } }
CWE-476 int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; <S2SV_StartBug> char * fmtname ; <S2SV_EndBug> if ( jas_init ( ) ) { abort ( ) ; } cmdname = argv [ 0 ] ; infile = 0 ; verbose = 0 ; <S2SV_StartBug> while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { <S2SV_EndBug> switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( "%s\\n" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; <S2SV_StartBug> case OPT_INFILE : <S2SV_EndBug> infile = jas_optarg ; break ; case OPT_HELP : default : usage ( ) ; break ; } } <S2SV_StartBug> if ( infile ) { <S2SV_EndBug> if ( ! ( instream = jas_stream_fopen ( infile , "rb" ) ) ) { fprintf ( stderr , "cannot<S2SV_blank>open<S2SV_blank>input<S2SV_blank>image<S2SV_blank>file<S2SV_blank>%s\\n" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , "rb" ) ) ) { fprintf ( stderr , "cannot<S2SV_blank>open<S2SV_blank>standard<S2SV_blank>input\\n" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , "unknown<S2SV_blank>image<S2SV_blank>format\\n" ) ; } <S2SV_StartBug> if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { <S2SV_EndBug> fprintf ( stderr , "cannot<S2SV_blank>load<S2SV_blank>image\\n" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ; numcmpts = jas_image_numcmpts ( image ) ; width = jas_image_cmptwidth ( image , 0 ) ; height = jas_image_cmptheight ( image , 0 ) ; depth = jas_image_cmptprec ( image , 0 ) ; if ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { abort ( ) ; } printf ( "%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n" , fmtname , numcmpts , width , height , depth , ( long ) jas_image_rawsize ( image ) ) ; jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; }
CWE-476 static bool handle_client_startup ( PgSocket * client , PktHdr * pkt ) { const char * passwd ; const uint8_t * key ; bool ok ; SBuf * sbuf = & client -> sbuf ; if ( incomplete_pkt ( pkt ) ) { disconnect_client ( client , true , "client<S2SV_blank>sent<S2SV_blank>partial<S2SV_blank>pkt<S2SV_blank>in<S2SV_blank>startup<S2SV_blank>phase" ) ; return false ; } if ( client -> wait_for_welcome ) { if ( finish_client_login ( client ) ) { sbuf_prepare_skip ( sbuf , pkt -> len ) ; return true ; } else return false ; } switch ( pkt -> type ) { case PKT_SSLREQ : slog_noise ( client , "C:<S2SV_blank>req<S2SV_blank>SSL" ) ; slog_noise ( client , "P:<S2SV_blank>nak" ) ; if ( ! sbuf_answer ( & client -> sbuf , "N" , 1 ) ) { disconnect_client ( client , false , "failed<S2SV_blank>to<S2SV_blank>nak<S2SV_blank>SSL" ) ; return false ; } break ; case PKT_STARTUP_V2 : disconnect_client ( client , true , "Old<S2SV_blank>V2<S2SV_blank>protocol<S2SV_blank>not<S2SV_blank>supported" ) ; return false ; case PKT_STARTUP : if ( client -> pool ) { disconnect_client ( client , true , "client<S2SV_blank>re-sent<S2SV_blank>startup<S2SV_blank>pkt" ) ; return false ; } if ( ! decide_startup_pool ( client , pkt ) ) return false ; if ( client -> pool -> db -> admin ) { if ( ! admin_pre_login ( client ) ) return false ; } if ( cf_auth_type <= AUTH_TRUST || client -> own_user ) { if ( ! finish_client_login ( client ) ) return false ; } else { if ( ! send_client_authreq ( client ) ) { disconnect_client ( client , false , "failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>auth<S2SV_blank>req" ) ; return false ; } } break ; case 'p' : <S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug> disconnect_client ( client , true , "unrequested<S2SV_blank>passwd<S2SV_blank>pkt" ) ; return false ; } ok = mbuf_get_string ( & pkt -> data , & passwd ) ; if ( ok && check_client_passwd ( client , passwd ) ) { if ( ! finish_client_login ( client ) ) return false ; } else { disconnect_client ( client , true , "Auth<S2SV_blank>failed" ) ; return false ; } break ; case PKT_CANCEL : if ( mbuf_avail_for_read ( & pkt -> data ) == BACKENDKEY_LEN && mbuf_get_bytes ( & pkt -> data , BACKENDKEY_LEN , & key ) ) { memcpy ( client -> cancel_key , key , BACKENDKEY_LEN ) ; accept_cancel_request ( client ) ; } else disconnect_client ( client , false , "bad<S2SV_blank>cancel<S2SV_blank>request" ) ; return false ; default : disconnect_client ( client , false , "bad<S2SV_blank>packet" ) ; return false ; } sbuf_prepare_skip ( sbuf , pkt -> len ) ; client -> request_time = get_cached_time ( ) ; return true ; }
CWE-20 static int __vcpu_run ( struct kvm_vcpu * vcpu ) { int r ; struct kvm * kvm = vcpu -> kvm ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; <S2SV_StartBug> r = vapic_enter ( vcpu ) ; <S2SV_EndBug> if ( r ) { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; return r ; } r = 1 ; while ( r > 0 ) { if ( vcpu -> arch . mp_state == KVM_MP_STATE_RUNNABLE && ! vcpu -> arch . apf . halted ) r = vcpu_enter_guest ( vcpu ) ; else { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; kvm_vcpu_block ( vcpu ) ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; if ( kvm_check_request ( KVM_REQ_UNHALT , vcpu ) ) { kvm_apic_accept_events ( vcpu ) ; switch ( vcpu -> arch . mp_state ) { case KVM_MP_STATE_HALTED : vcpu -> arch . pv . pv_unhalted = false ; vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; case KVM_MP_STATE_RUNNABLE : vcpu -> arch . apf . halted = false ; break ; case KVM_MP_STATE_INIT_RECEIVED : break ; default : r = - EINTR ; break ; } } } if ( r <= 0 ) break ; clear_bit ( KVM_REQ_PENDING_TIMER , & vcpu -> requests ) ; if ( kvm_cpu_has_pending_timer ( vcpu ) ) kvm_inject_pending_timer_irqs ( vcpu ) ; if ( dm_request_for_irq_injection ( vcpu ) ) { r = - EINTR ; vcpu -> run -> exit_reason = KVM_EXIT_INTR ; ++ vcpu -> stat . request_irq_exits ; } kvm_check_async_pf_completion ( vcpu ) ; if ( signal_pending ( current ) ) { r = - EINTR ; vcpu -> run -> exit_reason = KVM_EXIT_INTR ; ++ vcpu -> stat . signal_exits ; } if ( need_resched ( ) ) { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; kvm_resched ( vcpu ) ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; } } srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; <S2SV_StartBug> vapic_exit ( vcpu ) ; <S2SV_EndBug> return r ; }
CWE-119 int vp8dx_start_decode ( BOOL_DECODER * br , const unsigned char * source , unsigned int source_sz , <S2SV_StartBug> vp8_decrypt_cb * decrypt_cb , <S2SV_EndBug> void * decrypt_state ) { br -> user_buffer_end = source + source_sz ; br -> user_buffer = source ; br -> value = 0 ; br -> count = - 8 ; br -> range = 255 ; br -> decrypt_cb = decrypt_cb ; br -> decrypt_state = decrypt_state ; if ( source_sz && ! source ) return 1 ; vp8dx_bool_decoder_fill ( br ) ; return 0 ; }
CWE-119 WORD32 ih264d_decode_gaps_in_frame_num ( dec_struct_t * ps_dec , UWORD16 u2_frame_num ) { UWORD32 u4_next_frm_num , u4_start_frm_num ; UWORD32 u4_max_frm_num ; pocstruct_t s_tmp_poc ; WORD32 i4_poc ; dec_slice_params_t * ps_cur_slice ; dec_pic_params_t * ps_pic_params ; WORD8 i1_gap_idx ; WORD32 * i4_gaps_start_frm_num ; dpb_manager_t * ps_dpb_mgr ; WORD32 i4_frame_gaps ; WORD8 * pi1_gaps_per_seq ; WORD32 ret ; ps_cur_slice = ps_dec -> ps_cur_slice ; if ( ps_cur_slice -> u1_field_pic_flag ) { if ( ps_dec -> u2_prev_ref_frame_num == u2_frame_num ) return 0 ; } u4_next_frm_num = ps_dec -> u2_prev_ref_frame_num + 1 ; u4_max_frm_num = ps_dec -> ps_cur_sps -> u2_u4_max_pic_num_minus1 + 1 ; if ( u4_next_frm_num >= u4_max_frm_num ) { u4_next_frm_num -= u4_max_frm_num ; } if ( u4_next_frm_num == u2_frame_num ) { return ( 0 ) ; } if ( ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) && ( u4_next_frm_num >= u2_frame_num ) ) { return ( 0 ) ; } u4_start_frm_num = u4_next_frm_num ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_pic_params = ps_dec -> ps_cur_pps ; <S2SV_StartBug> ps_cur_slice -> u1_field_pic_flag = 0 ; <S2SV_EndBug> i4_frame_gaps = 0 ; ps_dpb_mgr = ps_dec -> ps_dpb_mgr ; i4_gaps_start_frm_num = ps_dpb_mgr -> ai4_gaps_start_frm_num ; for ( i1_gap_idx = 0 ; i1_gap_idx < MAX_FRAMES ; i1_gap_idx ++ ) { if ( INVALID_FRAME_NUM == i4_gaps_start_frm_num [ i1_gap_idx ] ) break ; } if ( MAX_FRAMES == i1_gap_idx ) { UWORD32 i4_error_code ; i4_error_code = ERROR_DBP_MANAGER_T ; return i4_error_code ; } i4_poc = 0 ; i4_gaps_start_frm_num [ i1_gap_idx ] = u4_start_frm_num ; ps_dpb_mgr -> ai4_gaps_end_frm_num [ i1_gap_idx ] = u2_frame_num - 1 ; pi1_gaps_per_seq = ps_dpb_mgr -> ai1_gaps_per_seq ; pi1_gaps_per_seq [ i1_gap_idx ] = 0 ; while ( u4_next_frm_num != u2_frame_num ) { ih264d_delete_nonref_nondisplay_pics ( ps_dpb_mgr ) ; if ( ps_pic_params -> ps_sps -> u1_pic_order_cnt_type ) { ret = ih264d_decode_pic_order_cnt ( 0 , u4_next_frm_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pic_params , 1 , 0 , 0 , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = u4_next_frm_num ; } if ( ps_dpb_mgr -> i1_poc_buf_id_entries >= ps_dec -> u1_max_dec_frame_buffering ) { ret = ih264d_assign_display_seq ( ps_dec ) ; if ( ret != OK ) return ret ; } ret = ih264d_insert_pic_in_display_list ( ps_dec -> ps_dpb_mgr , ( WORD8 ) DO_NOT_DISP , ( WORD32 ) ( ps_dec -> i4_prev_max_display_seq + i4_poc ) , u4_next_frm_num ) ; if ( ret != OK ) return ret ; pi1_gaps_per_seq [ i1_gap_idx ] ++ ; ret = ih264d_do_mmco_for_gaps ( ps_dpb_mgr , ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ; if ( ret != OK ) return ret ; ih264d_delete_nonref_nondisplay_pics ( ps_dpb_mgr ) ; u4_next_frm_num ++ ; if ( u4_next_frm_num >= u4_max_frm_num ) { u4_next_frm_num -= u4_max_frm_num ; } i4_frame_gaps ++ ; } return OK ; }
CWE-476 unsigned int ipt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; const struct iphdr * ip ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ipt_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; ip = ip_hdr ( skb ) ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . fragoff = ntohs ( ip -> frag_off ) & IP_OFFSET ; acpar . thoff = ip_hdrlen ( skb ) ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ipt_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; if ( ! ip_packet_match ( ip , indev , outdev , & e -> ip , acpar . fragoff ) ) { no_match : e = ipt_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ipt_get_target ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = ipt_next_entry ( e ) ; } continue ; } if ( table_base + v != ipt_next_entry ( e ) && <S2SV_StartBug> ! ( e -> ip . flags & IPT_F_GOTO ) ) <S2SV_EndBug> jumpstack [ stackidx ++ ] = e ; <S2SV_StartBug> e = get_entry ( table_base , v ) ; <S2SV_EndBug> continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { ip = ip_hdr ( skb ) ; e = ipt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }
CWE-119 static void set_ppflags ( const vpx_codec_alg_priv_t * ctx , vp9_ppflags_t * flags ) { flags -> post_proc_flag = <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> ( ctx -> dbg_color_ref_frame_flag ? VP9D_DEBUG_CLR_FRM_REF_BLKS : 0 ) | ( ctx -> dbg_color_mb_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_color_b_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_display_mv_flag ? VP9D_DEBUG_DRAW_MV : 0 ) | # endif ctx -> postproc_cfg . post_proc_flag ; flags -> deblocking_level = ctx -> postproc_cfg . deblocking_level ; flags -> noise_level = ctx -> postproc_cfg . noise_level ; <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER <S2SV_EndBug> flags -> display_ref_frame_flag = ctx -> dbg_color_ref_frame_flag ; flags -> display_mb_modes_flag = ctx -> dbg_color_mb_modes_flag ; flags -> display_b_modes_flag = ctx -> dbg_color_b_modes_flag ; flags -> display_mv_flag = ctx -> dbg_display_mv_flag ; # endif }
CWE-125 <S2SV_StartBug> static void <S2SV_EndBug> ip_printts ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; int hoplen ; const char * type ; if ( length < 4 ) { ND_PRINT ( ( ndo , "[bad<S2SV_blank>length<S2SV_blank>%u]" , length ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } ND_PRINT ( ( ndo , "<S2SV_blank>TS{" ) ) ; hoplen = ( ( cp [ 3 ] & 0xF ) != IPOPT_TS_TSONLY ) ? 8 : 4 ; if ( ( length - 4 ) & ( hoplen - 1 ) ) ND_PRINT ( ( ndo , "[bad<S2SV_blank>length<S2SV_blank>%u]" , length ) ) ; <S2SV_StartBug> ptr = cp [ 2 ] - 1 ; <S2SV_EndBug> len = 0 ; if ( ptr < 4 || ( ( ptr - 4 ) & ( hoplen - 1 ) ) || ptr > length + 1 ) ND_PRINT ( ( ndo , "[bad<S2SV_blank>ptr<S2SV_blank>%u]" , cp [ 2 ] ) ) ; <S2SV_StartBug> switch ( cp [ 3 ] & 0xF ) { <S2SV_EndBug> case IPOPT_TS_TSONLY : ND_PRINT ( ( ndo , "TSONLY" ) ) ; break ; case IPOPT_TS_TSANDADDR : ND_PRINT ( ( ndo , "TS+ADDR" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , "PRESPEC2.0" ) ) ; break ; case 3 : ND_PRINT ( ( ndo , "PRESPEC" ) ) ; break ; default : ND_PRINT ( ( ndo , "[bad<S2SV_blank>ts<S2SV_blank>type<S2SV_blank>%d]" , cp [ 3 ] & 0xF ) ) ; goto done ; } type = "<S2SV_blank>" ; for ( len = 4 ; len < length ; len += hoplen ) { if ( ptr == len ) <S2SV_StartBug> type = "<S2SV_blank>^<S2SV_blank>" ; <S2SV_EndBug> ND_PRINT ( ( ndo , "%s%d@%s" , type , EXTRACT_32BITS ( & cp [ len + hoplen - 4 ] ) , hoplen != 8 ? "" : ipaddr_string ( ndo , & cp [ len ] ) ) ) ; type = "<S2SV_blank>" ; } done : ND_PRINT ( ( ndo , "%s" , ptr == len ? "<S2SV_blank>^<S2SV_blank>" : "" ) ) ; if ( cp [ 3 ] >> 4 ) ND_PRINT ( ( ndo , "<S2SV_blank>[%d<S2SV_blank>hops<S2SV_blank>not<S2SV_blank>recorded]}<S2SV_blank>" , cp [ 3 ] >> 4 ) ) ; else ND_PRINT ( ( ndo , "}" ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static __u8 * pl_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 60 && rdesc [ 39 ] == 0x2a && rdesc [ 40 ] == 0xf5 && <S2SV_EndBug> rdesc [ 41 ] == 0x00 && rdesc [ 59 ] == 0x26 && rdesc [ 60 ] == 0xf9 && rdesc [ 61 ] == 0x00 ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Petalynx<S2SV_blank>Maxter<S2SV_blank>Remote<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc [ 60 ] = 0xfa ; rdesc [ 40 ] = 0xfa ; } return rdesc ; }
CWE-476 jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; <S2SV_StartBug> box -> info = boxinfo ; <S2SV_EndBug> box -> ops = & boxinfo -> ops ; box -> len = len ; JAS_DBGLOG ( 10 , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n" , \'"\' , boxinfo -> name , \'"\' , box -> type , box -> len ) ) ; if ( box -> len == 1 ) { if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( "warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { <S2SV_StartBug> box -> ops = & jp2_boxinfo_unk . ops ; <S2SV_EndBug> jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ; goto error ; } <S2SV_StartBug> jas_stream_rewind ( tmpstream ) ; <S2SV_EndBug> if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( "cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }
CWE-119 void vp8_reset_mb_tokens_context ( MACROBLOCKD * x ) { ENTROPY_CONTEXT * a_ctx = ( ( ENTROPY_CONTEXT * ) x -> above_context ) ; ENTROPY_CONTEXT * l_ctx = ( ( ENTROPY_CONTEXT * ) x -> left_context ) ; <S2SV_StartBug> vpx_memset ( a_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( l_ctx , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> if ( ! x -> mode_info_context -> mbmi . is_4x4 ) { a_ctx [ 8 ] = l_ctx [ 8 ] = 0 ; } }
CWE-190 void * <S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> { <S2SV_StartBug> alloc_limit_assert ( "checked_xmalloc" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug> }
CWE-264 static int msr_open ( struct inode * inode , struct file * file ) { unsigned int cpu ; <S2SV_StartBug> struct cpuinfo_x86 * c ; <S2SV_EndBug> cpu = iminor ( file -> f_path . dentry -> d_inode ) ; if ( cpu >= nr_cpu_ids || ! cpu_online ( cpu ) ) return - ENXIO ; c = & cpu_data ( cpu ) ; if ( ! cpu_has ( c , X86_FEATURE_MSR ) ) return - EIO ; return 0 ; }
CWE-119 static int magicmouse_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct magicmouse_sc * msc = hid_get_drvdata ( hdev ) ; struct input_dev * input = msc -> input ; int x = 0 , y = 0 , ii , clicks = 0 , npoints ; switch ( data [ 0 ] ) { case TRACKPAD_REPORT_ID : if ( size < 4 || ( ( size - 4 ) % 9 ) != 0 ) return 0 ; npoints = ( size - 4 ) / 9 ; <S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 9 + 4 ) ; clicks = data [ 1 ] ; break ; case MOUSE_REPORT_ID : if ( size < 6 || ( ( size - 6 ) % 8 ) != 0 ) return 0 ; <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> msc -> ntouches = 0 ; for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 8 + 6 ) ; x = ( int ) ( ( ( data [ 3 ] & 0x0c ) << 28 ) | ( data [ 1 ] << 22 ) ) >> 22 ; y = ( int ) ( ( ( data [ 3 ] & 0x30 ) << 26 ) | ( data [ 2 ] << 22 ) ) >> 22 ; clicks = data [ 3 ] ; break ; case DOUBLE_REPORT_ID : magicmouse_raw_event ( hdev , report , data + 2 , data [ 1 ] ) ; magicmouse_raw_event ( hdev , report , data + 2 + data [ 1 ] , size - 2 - data [ 1 ] ) ; break ; default : return 0 ; } if ( input -> id . product == USB_DEVICE_ID_APPLE_MAGICMOUSE ) { magicmouse_emit_buttons ( msc , clicks & 3 ) ; input_report_rel ( input , REL_X , x ) ; input_report_rel ( input , REL_Y , y ) ; } else { input_report_key ( input , BTN_MOUSE , clicks & 1 ) ; input_mt_report_pointer_emulation ( input , true ) ; } input_sync ( input ) ; return 1 ; }
CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> offset += tim . length - 3 ; length -= tim . length - 3 ; if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , "(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
CWE-20 int net_get ( int s , void * arg , int * len ) { struct net_hdr nh ; int plen ; if ( net_read_exact ( s , & nh , sizeof ( nh ) ) == - 1 ) { return - 1 ; } plen = ntohl ( nh . nh_len ) ; if ( ! ( plen <= * len ) ) printf ( "PLEN<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>len<S2SV_blank>%d\\n" , plen , nh . nh_type , * len ) ; <S2SV_StartBug> assert ( plen <= * len ) ; <S2SV_EndBug> * len = plen ; if ( ( * len ) && ( net_read_exact ( s , arg , * len ) == - 1 ) ) { return - 1 ; } return nh . nh_type ; }
CWE-119 static int get_refresh_mask ( VP9_COMP * cpi ) { <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( ! cpi -> multi_arf_enabled && cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame ) { # else if ( cpi -> refresh_golden_frame && ! cpi -> refresh_alt_ref_frame && ! cpi -> use_svc ) { # endif return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> alt_fb_idx ) ; } else { int arf_idx = cpi -> alt_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> multi_arf_enabled ) { <S2SV_EndBug> int sn = cpi -> sequence_number ; <S2SV_StartBug> arf_idx = ( cpi -> frame_coding_order [ sn ] < 0 ) ? <S2SV_EndBug> cpi -> arf_buffer_idx [ sn + 1 ] : cpi -> arf_buffer_idx [ sn ] ; } <S2SV_StartBug> # endif <S2SV_EndBug> return ( cpi -> refresh_last_frame << cpi -> lst_fb_idx ) | ( cpi -> refresh_golden_frame << cpi -> gld_fb_idx ) | ( cpi -> refresh_alt_ref_frame << arf_idx ) ; } }
CWE-416 void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , "%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }
CWE-284 static int a2dp_ctrl_receive ( struct a2dp_stream_common * common , void * buffer , int length ) { <S2SV_StartBug> int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( "ack<S2SV_blank>failed<S2SV_blank>(%s)" , strerror ( errno ) ) ; if ( errno == EINTR ) { <S2SV_StartBug> ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( "ack<S2SV_blank>failed<S2SV_blank>(%s)" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } else { skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } return ret ; }
CWE-119 static TEE_Result set_rmem_param ( const struct optee_msg_param_rmem * rmem , struct param_mem * mem ) <S2SV_StartBug> { <S2SV_EndBug> uint64_t shm_ref = READ_ONCE ( rmem -> shm_ref ) ; mem -> mobj = mobj_reg_shm_get_by_cookie ( shm_ref ) ; if ( ! mem -> mobj ) return TEE_ERROR_BAD_PARAMETERS ; mem -> offs = READ_ONCE ( rmem -> offs ) ; mem -> size = READ_ONCE ( rmem -> size ) ; <S2SV_StartBug> return TEE_SUCCESS ; <S2SV_EndBug> }
CWE-787 static struct prog_entry * predicate_parse ( const char * str , int nr_parens , int nr_preds , parse_pred_fn parse_pred , void * data , struct filter_parse_error * pe ) { struct prog_entry * prog_stack ; struct prog_entry * prog ; const char * ptr = str ; char * inverts = NULL ; int * op_stack ; int * top ; int invert = 0 ; int ret = - ENOMEM ; int len ; int N = 0 ; int i ; nr_preds += 2 ; op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; if ( ! op_stack ) return ERR_PTR ( - ENOMEM ) ; prog_stack = kmalloc_array ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; if ( ! prog_stack ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; if ( ! inverts ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } top = op_stack ; prog = prog_stack ; * top = 0 ; while ( * ptr ) { const char * next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case '(' : if ( top - op_stack > nr_parens ) return ERR_PTR ( - EINVAL ) ; * ( ++ top ) = invert ; continue ; case '!' : if ( ! is_not ( next ) ) break ; invert = ! invert ; continue ; } if ( N >= nr_preds ) { parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } inverts [ N ] = invert ; prog [ N ] . target = N - 1 ; len = parse_pred ( next , data , ptr - str , pe , & prog [ N ] . pred ) ; if ( len < 0 ) { ret = len ; goto out_free ; } ptr = next + len ; N ++ ; ret = - 1 ; while ( 1 ) { next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case ')' : case '\\0' : break ; case '&' : case '|' : if ( next [ 1 ] == next [ 0 ] ) { ptr ++ ; break ; } default : parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } invert = * top & INVERT ; if ( * top & PROCESS_AND ) { update_preds ( prog , N - 1 , invert ) ; * top &= ~ PROCESS_AND ; } if ( * next == '&' ) { * top |= PROCESS_AND ; break ; } if ( * top & PROCESS_OR ) { update_preds ( prog , N - 1 , ! invert ) ; * top &= ~ PROCESS_OR ; } if ( * next == '|' ) { * top |= PROCESS_OR ; break ; } if ( ! * next ) goto out ; if ( top == op_stack ) { ret = - 1 ; parse_error ( pe , FILT_ERR_TOO_MANY_CLOSE , ptr - str ) ; goto out_free ; } top -- ; } } out : if ( top != op_stack ) { parse_error ( pe , FILT_ERR_TOO_MANY_OPEN , ptr - str ) ; goto out_free ; } <S2SV_StartBug> prog [ N ] . pred = NULL ; <S2SV_EndBug> prog [ N ] . target = 1 ; prog [ N + 1 ] . pred = NULL ; prog [ N + 1 ] . target = 0 ; prog [ N - 1 ] . target = N ; prog [ N - 1 ] . when_to_branch = false ; for ( i = N - 1 ; i -- ; ) { int target = prog [ i ] . target ; if ( prog [ i ] . when_to_branch == prog [ target ] . when_to_branch ) prog [ i ] . target = prog [ target ] . target ; } for ( i = 0 ; i < N ; i ++ ) { invert = inverts [ i ] ^ prog [ i ] . when_to_branch ; prog [ i ] . when_to_branch = invert ; if ( WARN_ON ( prog [ i ] . target <= i ) ) { ret = - EINVAL ; goto out_free ; } } return prog ; out_free : kfree ( op_stack ) ; kfree ( prog_stack ) ; kfree ( inverts ) ; return ERR_PTR ( ret ) ; }
CWE-000 int __gfs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; int len ; char * data ; const char * name = gfs2_acl_name ( type ) ; if ( acl && acl -> a_count > GFS2_ACL_MAX_ENTRIES ( GFS2_SB ( inode ) ) ) return - E2BIG ; if ( type == ACL_TYPE_ACCESS ) { umode_t mode = inode -> i_mode ; <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; if ( error == 0 ) acl = NULL ; <S2SV_StartBug> if ( mode != inode -> i_mode ) { <S2SV_EndBug> inode -> i_mode = mode ; mark_inode_dirty ( inode ) ; <S2SV_StartBug> } <S2SV_EndBug> } if ( acl ) { len = posix_acl_to_xattr ( & init_user_ns , acl , NULL , 0 ) ; if ( len == 0 ) return 0 ; data = kmalloc ( len , GFP_NOFS ) ; if ( data == NULL ) return - ENOMEM ; error = posix_acl_to_xattr ( & init_user_ns , acl , data , len ) ; if ( error < 0 ) goto out ; } else { data = NULL ; len = 0 ; } error = __gfs2_xattr_set ( inode , name , data , len , 0 , GFS2_EATYPE_SYS ) ; if ( error ) goto out ; set_cached_acl ( inode , type , acl ) ; out : kfree ( data ) ; return error ; }
CWE-20 static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; <S2SV_StartBug> DPRINTF ( 4 , ( "enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n" , <S2SV_EndBug> filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , "Unknown<S2SV_blank>filegen<S2SV_blank>flag<S2SV_blank>token<S2SV_blank>%d" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , "Unknown<S2SV_blank>filegen<S2SV_blank>option<S2SV_blank>token<S2SV_blank>%d" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
CWE-125 static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , <S2SV_StartBug> int tstype ) <S2SV_EndBug> { struct sock_exterr_skb * serr ; <S2SV_StartBug> int err ; <S2SV_EndBug> serr = SKB_EXT_ERR ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = ENOMSG ; serr -> ee . ee_origin = SO_EE_ORIGIN_TIMESTAMPING ; <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }
CWE-20 void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , ":<S2SV_blank>%u" , key -> datalen ) ; }
CWE-125 void isakmp_rfc3948_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 ) { <S2SV_StartBug> if ( length == 1 && bp [ 0 ] == 0xff ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "isakmp-nat-keep-alive" ) ) ; return ; } if ( length < 4 ) { goto trunc ; <S2SV_StartBug> } <S2SV_EndBug> if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) { ND_PRINT ( ( ndo , "NONESP-encap:<S2SV_blank>" ) ) ; isakmp_print ( ndo , bp + 4 , length - 4 , bp2 ) ; return ; } { int nh , enh , padlen ; int advance ; ND_PRINT ( ( ndo , "UDP-encap:<S2SV_blank>" ) ) ; advance = esp_print ( ndo , bp , length , bp2 , & enh , & padlen ) ; if ( advance <= 0 ) return ; bp += advance ; length -= advance + padlen ; nh = enh & 0xff ; ip_print_inner ( ndo , bp , length , nh , bp2 ) ; return ; } trunc : ND_PRINT ( ( ndo , "[|isakmp]" ) ) ; return ; }
CWE-190 static int vdbePmaReadBlob ( PmaReader * p , int nByte , u8 * * ppOut ) { int iBuf ; int nAvail ; if ( p -> aMap ) { * ppOut = & p -> aMap [ p -> iReadOff ] ; p -> iReadOff += nByte ; return SQLITE_OK ; } assert ( p -> aBuffer ) ; iBuf = p -> iReadOff % p -> nBuffer ; if ( iBuf == 0 ) { int nRead ; int rc ; if ( ( p -> iEof - p -> iReadOff ) > ( i64 ) p -> nBuffer ) { nRead = p -> nBuffer ; } else { nRead = ( int ) ( p -> iEof - p -> iReadOff ) ; } assert ( nRead > 0 ) ; rc = sqlite3OsRead ( p -> pFd , p -> aBuffer , nRead , p -> iReadOff ) ; assert ( rc != SQLITE_IOERR_SHORT_READ ) ; if ( rc != SQLITE_OK ) return rc ; } nAvail = p -> nBuffer - iBuf ; if ( nByte <= nAvail ) { * ppOut = & p -> aBuffer [ iBuf ] ; p -> iReadOff += nByte ; } else { int nRem ; if ( p -> nAlloc < nByte ) { u8 * aNew ; <S2SV_StartBug> int nNew = MAX ( 128 , p -> nAlloc * 2 ) ; <S2SV_EndBug> while ( nByte > nNew ) nNew = nNew * 2 ; aNew = sqlite3Realloc ( p -> aAlloc , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; p -> nAlloc = nNew ; p -> aAlloc = aNew ; } memcpy ( p -> aAlloc , & p -> aBuffer [ iBuf ] , nAvail ) ; p -> iReadOff += nAvail ; nRem = nByte - nAvail ; while ( nRem > 0 ) { int rc ; int nCopy ; u8 * aNext ; nCopy = nRem ; if ( nRem > p -> nBuffer ) nCopy = p -> nBuffer ; rc = vdbePmaReadBlob ( p , nCopy , & aNext ) ; if ( rc != SQLITE_OK ) return rc ; assert ( aNext != p -> aAlloc ) ; memcpy ( & p -> aAlloc [ nByte - nRem ] , aNext , nCopy ) ; nRem -= nCopy ; } * ppOut = p -> aAlloc ; } return SQLITE_OK ; }
CWE-119 static int mov_read_dref ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) { AVStream * st ; MOVStreamContext * sc ; int entries , i , j ; if ( c -> fc -> nb_streams < 1 ) return 0 ; st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; sc = st -> priv_data ; avio_rb32 ( pb ) ; entries = avio_rb32 ( pb ) ; if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) ) return AVERROR_INVALIDDATA ; av_free ( sc -> drefs ) ; <S2SV_StartBug> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; <S2SV_EndBug> if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ; sc -> drefs_count = entries ; for ( i = 0 ; i < sc -> drefs_count ; i ++ ) { MOVDref * dref = & sc -> drefs [ i ] ; uint32_t size = avio_rb32 ( pb ) ; int64_t next = avio_tell ( pb ) + size - 4 ; if ( size < 12 ) return AVERROR_INVALIDDATA ; dref -> type = avio_rl32 ( pb ) ; avio_rb32 ( pb ) ; av_dlog ( c -> fc , "type<S2SV_blank>%.4s<S2SV_blank>size<S2SV_blank>%d\\n" , ( char * ) & dref -> type , size ) ; if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 ) { uint16_t volume_len , len ; int16_t type ; avio_skip ( pb , 10 ) ; volume_len = avio_r8 ( pb ) ; volume_len = FFMIN ( volume_len , 27 ) ; avio_read ( pb , dref -> volume , 27 ) ; dref -> volume [ volume_len ] = 0 ; av_log ( c -> fc , AV_LOG_DEBUG , "volume<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%d\\n" , dref -> volume , volume_len ) ; avio_skip ( pb , 12 ) ; len = avio_r8 ( pb ) ; len = FFMIN ( len , 63 ) ; avio_read ( pb , dref -> filename , 63 ) ; dref -> filename [ len ] = 0 ; av_log ( c -> fc , AV_LOG_DEBUG , "filename<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%d\\n" , dref -> filename , len ) ; avio_skip ( pb , 16 ) ; dref -> nlvl_from = avio_rb16 ( pb ) ; dref -> nlvl_to = avio_rb16 ( pb ) ; av_log ( c -> fc , AV_LOG_DEBUG , "nlvl<S2SV_blank>from<S2SV_blank>%d,<S2SV_blank>nlvl<S2SV_blank>to<S2SV_blank>%d\\n" , dref -> nlvl_from , dref -> nlvl_to ) ; avio_skip ( pb , 16 ) ; for ( type = 0 ; type != - 1 && avio_tell ( pb ) < next ; ) { if ( url_feof ( pb ) ) return AVERROR_EOF ; type = avio_rb16 ( pb ) ; len = avio_rb16 ( pb ) ; av_log ( c -> fc , AV_LOG_DEBUG , "type<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%d\\n" , type , len ) ; if ( len & 1 ) len += 1 ; if ( type == 2 ) { av_free ( dref -> path ) ; dref -> path = av_mallocz ( len + 1 ) ; if ( ! dref -> path ) return AVERROR ( ENOMEM ) ; avio_read ( pb , dref -> path , len ) ; if ( len > volume_len && ! strncmp ( dref -> path , dref -> volume , volume_len ) ) { len -= volume_len ; memmove ( dref -> path , dref -> path + volume_len , len ) ; dref -> path [ len ] = 0 ; } for ( j = 0 ; j < len ; j ++ ) if ( dref -> path [ j ] == ':' ) dref -> path [ j ] = '/' ; av_log ( c -> fc , AV_LOG_DEBUG , "path<S2SV_blank>%s\\n" , dref -> path ) ; } else if ( type == 0 ) { av_free ( dref -> dir ) ; dref -> dir = av_malloc ( len + 1 ) ; if ( ! dref -> dir ) return AVERROR ( ENOMEM ) ; avio_read ( pb , dref -> dir , len ) ; dref -> dir [ len ] = 0 ; for ( j = 0 ; j < len ; j ++ ) if ( dref -> dir [ j ] == ':' ) dref -> dir [ j ] = '/' ; av_log ( c -> fc , AV_LOG_DEBUG , "dir<S2SV_blank>%s\\n" , dref -> dir ) ; } else avio_skip ( pb , len ) ; } } avio_seek ( pb , next , SEEK_SET ) ; } return 0 ; }
CWE-362 int sctp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct sctp_association * asoc ; struct sctp_endpoint * ep = NULL ; struct sctp_ep_common * rcvr ; struct sctp_transport * transport = NULL ; struct sctp_chunk * chunk ; struct sctphdr * sh ; union sctp_addr src ; union sctp_addr dest ; int family ; struct sctp_af * af ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; SCTP_INC_STATS_BH ( SCTP_MIB_INSCTPPACKS ) ; if ( skb_linearize ( skb ) ) goto discard_it ; sh = sctp_hdr ( skb ) ; __skb_pull ( skb , skb_transport_offset ( skb ) ) ; if ( skb -> len < sizeof ( struct sctphdr ) ) goto discard_it ; if ( ! skb_csum_unnecessary ( skb ) && sctp_rcv_checksum ( skb ) < 0 ) goto discard_it ; skb_pull ( skb , sizeof ( struct sctphdr ) ) ; if ( skb -> len < sizeof ( struct sctp_chunkhdr ) ) goto discard_it ; family = ipver2af ( ip_hdr ( skb ) -> version ) ; af = sctp_get_af_specific ( family ) ; if ( unlikely ( ! af ) ) goto discard_it ; af -> from_skb ( & src , skb , 1 ) ; af -> from_skb ( & dest , skb , 0 ) ; if ( ! af -> addr_valid ( & src , NULL , skb ) || ! af -> addr_valid ( & dest , NULL , skb ) ) goto discard_it ; asoc = __sctp_rcv_lookup ( skb , & src , & dest , & transport ) ; if ( ! asoc ) ep = __sctp_rcv_lookup_endpoint ( & dest ) ; rcvr = asoc ? & asoc -> base : & ep -> base ; sk = rcvr -> sk ; if ( sk -> sk_bound_dev_if && ( sk -> sk_bound_dev_if != af -> skb_iif ( skb ) ) ) { if ( asoc ) { sctp_association_put ( asoc ) ; asoc = NULL ; } else { sctp_endpoint_put ( ep ) ; ep = NULL ; } sk = sctp_get_ctl_sock ( ) ; ep = sctp_sk ( sk ) -> ep ; sctp_endpoint_hold ( ep ) ; rcvr = & ep -> base ; } if ( ! asoc ) { if ( sctp_rcv_ootb ( skb ) ) { SCTP_INC_STATS_BH ( SCTP_MIB_OUTOFBLUES ) ; goto discard_release ; } } if ( ! xfrm_policy_check ( sk , XFRM_POLICY_IN , skb , family ) ) goto discard_release ; nf_reset ( skb ) ; if ( sk_filter ( sk , skb ) ) goto discard_release ; chunk = sctp_chunkify ( skb , asoc , sk ) ; if ( ! chunk ) goto discard_release ; SCTP_INPUT_CB ( skb ) -> chunk = chunk ; chunk -> rcvr = rcvr ; chunk -> sctp_hdr = sh ; sctp_init_addrs ( chunk , & src , & dest ) ; chunk -> transport = transport ; sctp_bh_lock_sock ( sk ) ; <S2SV_StartBug> if ( sock_owned_by_user ( sk ) ) { <S2SV_EndBug> SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ; sctp_add_backlog ( sk , skb ) ; } else { SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_SOFTIRQ ) ; sctp_inq_push ( & chunk -> rcvr -> inqueue , chunk ) ; } sctp_bh_unlock_sock ( sk ) ; if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; return 0 ; discard_it : SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_DISCARDS ) ; kfree_skb ( skb ) ; return 0 ; discard_release : if ( asoc ) sctp_association_put ( asoc ) ; else sctp_endpoint_put ( ep ) ; goto discard_it ; }
CWE-20 int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; <S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> atomic_inc ( & key -> user -> nikeys ) ; <S2SV_StartBug> key -> reject_error = - error ; <S2SV_EndBug> smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; if ( keyring && link_ret == 0 ) __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret == 0 ? link_ret : ret ; }
CWE-399 static long vhost_net_set_backend ( struct vhost_net * n , unsigned index , int fd ) { struct socket * sock , * oldsock ; struct vhost_virtqueue * vq ; struct vhost_net_virtqueue * nvq ; struct vhost_net_ubuf_ref * ubufs , * oldubufs = NULL ; int r ; mutex_lock ( & n -> dev . mutex ) ; r = vhost_dev_check_owner ( & n -> dev ) ; if ( r ) goto err ; if ( index >= VHOST_NET_VQ_MAX ) { r = - ENOBUFS ; goto err ; } vq = & n -> vqs [ index ] . vq ; nvq = & n -> vqs [ index ] ; mutex_lock ( & vq -> mutex ) ; if ( ! vhost_vq_access_ok ( vq ) ) { r = - EFAULT ; goto err_vq ; } sock = get_socket ( fd ) ; if ( IS_ERR ( sock ) ) { r = PTR_ERR ( sock ) ; goto err_vq ; } oldsock = rcu_dereference_protected ( vq -> private_data , lockdep_is_held ( & vq -> mutex ) ) ; if ( sock != oldsock ) { ubufs = vhost_net_ubuf_alloc ( vq , sock && vhost_sock_zcopy ( sock ) ) ; if ( IS_ERR ( ubufs ) ) { r = PTR_ERR ( ubufs ) ; goto err_ubufs ; } vhost_net_disable_vq ( n , vq ) ; rcu_assign_pointer ( vq -> private_data , sock ) ; r = vhost_init_used ( vq ) ; if ( r ) goto err_used ; r = vhost_net_enable_vq ( n , vq ) ; if ( r ) goto err_used ; oldubufs = nvq -> ubufs ; nvq -> ubufs = ubufs ; n -> tx_packets = 0 ; n -> tx_zcopy_err = 0 ; n -> tx_flush = false ; } mutex_unlock ( & vq -> mutex ) ; if ( oldubufs ) { <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( oldubufs ) ; <S2SV_EndBug> mutex_lock ( & vq -> mutex ) ; vhost_zerocopy_signal_used ( n , vq ) ; mutex_unlock ( & vq -> mutex ) ; } if ( oldsock ) { vhost_net_flush_vq ( n , index ) ; fput ( oldsock -> file ) ; } mutex_unlock ( & n -> dev . mutex ) ; return 0 ; err_used : rcu_assign_pointer ( vq -> private_data , oldsock ) ; vhost_net_enable_vq ( n , vq ) ; if ( ubufs ) <S2SV_StartBug> vhost_net_ubuf_put_and_wait ( ubufs ) ; <S2SV_EndBug> err_ubufs : fput ( sock -> file ) ; err_vq : mutex_unlock ( & vq -> mutex ) ; err : mutex_unlock ( & n -> dev . mutex ) ; return r ; }
CWE-399 static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = bufhi ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; # endif } break ; default : printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_load,<S2SV_blank>PC=%08lx\\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } return 0 ; } else { die ( "Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel" , regs , 0 ) ; return - 1 ; } }
CWE-125 <S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
CWE-416 struct ipv6_txoptions * ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) { struct ipv6_txoptions * opt2 ; opt2 = sock_kmalloc ( sk , opt -> tot_len , GFP_ATOMIC ) ; if ( opt2 ) { long dif = ( char * ) opt2 - ( char * ) opt ; memcpy ( opt2 , opt , opt -> tot_len ) ; if ( opt2 -> hopopt ) * ( ( char * * ) & opt2 -> hopopt ) += dif ; if ( opt2 -> dst0opt ) * ( ( char * * ) & opt2 -> dst0opt ) += dif ; if ( opt2 -> dst1opt ) * ( ( char * * ) & opt2 -> dst1opt ) += dif ; if ( opt2 -> srcrt ) * ( ( char * * ) & opt2 -> srcrt ) += dif ; <S2SV_StartBug> } <S2SV_EndBug> return opt2 ; }
CWE-119 static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) { <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ; <S2SV_StartBug> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <S2SV_EndBug> } } }
CWE-000 static void zend_throw_or_error ( int fetch_type , zend_class_entry * exception_ce , const char * format , ... ) { va_list va ; char * message = NULL ; va_start ( va , format ) ; zend_vspprintf ( & message , 0 , format , va ) ; if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { <S2SV_StartBug> zend_throw_error ( exception_ce , message ) ; <S2SV_EndBug> } else { zend_error ( E_ERROR , "%s" , message ) ; } efree ( message ) ; va_end ( va ) ; }
CWE-20 static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; <S2SV_StartBug> int idx , ret = - EINVAL ; <S2SV_EndBug> if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; <S2SV_StartBug> BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { <S2SV_EndBug> if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO "failed<S2SV_blank>to<S2SV_blank>back<S2SV_blank>to<S2SV_blank>remapped<S2SV_blank>mode,<S2SV_blank>irq:<S2SV_blank>%u\\n" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO "%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>update<S2SV_blank>PI<S2SV_blank>IRTE\\n" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
CWE-119 static void finish_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * name , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( "missing<S2SV_blank>blob<S2SV_blank>object<S2SV_blank>\'%s\'" , oid_to_hex ( & obj -> oid ) ) ; if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ; }
CWE-119 int main ( int argc , char * * argv ) { test_cmp_parameters inParam ; FILE * fbase = NULL , * ftest = NULL ; int same = 0 ; <S2SV_StartBug> char lbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strbase [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char ltest [ 256 ] ; <S2SV_EndBug> <S2SV_StartBug> char strtest [ 256 ] ; <S2SV_EndBug> if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) { compare_dump_files_help_display ( ) ; goto cleanup ; } printf ( "******Parameters*********<S2SV_blank>\\n" ) ; printf ( "<S2SV_blank>base_filename<S2SV_blank>=<S2SV_blank>%s\\n" "<S2SV_blank>test_filename<S2SV_blank>=<S2SV_blank>%s\\n" , inParam . base_filename , inParam . test_filename ) ; printf ( "*************************<S2SV_blank>\\n" ) ; printf ( "Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>" , inParam . base_filename ) ; if ( ( fbase = fopen ( inParam . base_filename , "rb" ) ) == NULL ) { goto cleanup ; } printf ( "Ok.\\n" ) ; printf ( "Try<S2SV_blank>to<S2SV_blank>open:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>...<S2SV_blank>" , inParam . test_filename ) ; if ( ( ftest = fopen ( inParam . test_filename , "rb" ) ) == NULL ) { goto cleanup ; } printf ( "Ok.\\n" ) ; while ( fgets ( lbase , sizeof ( lbase ) , fbase ) && fgets ( ltest , sizeof ( ltest ) , ftest ) ) { <S2SV_StartBug> int nbase = sscanf ( lbase , "%255[^\\r\\n]" , strbase ) ; <S2SV_EndBug> <S2SV_StartBug> int ntest = sscanf ( ltest , "%255[^\\r\\n]" , strtest ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( nbase != 255 && ntest != 255 ) ; <S2SV_EndBug> if ( nbase != 1 || ntest != 1 ) { fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>line<S2SV_blank>from<S2SV_blank>files\\n" ) ; goto cleanup ; } if ( strcmp ( strbase , strtest ) != 0 ) { fprintf ( stderr , "<%s><S2SV_blank>vs.<S2SV_blank><%s>\\n" , strbase , strtest ) ; goto cleanup ; } } same = 1 ; printf ( "\\n*****<S2SV_blank>TEST<S2SV_blank>SUCCEED:<S2SV_blank>Files<S2SV_blank>are<S2SV_blank>the<S2SV_blank>same.<S2SV_blank>*****\\n" ) ; cleanup : if ( fbase ) fclose ( fbase ) ; if ( ftest ) fclose ( ftest ) ; free ( inParam . base_filename ) ; free ( inParam . test_filename ) ; return same ? EXIT_SUCCESS : EXIT_FAILURE ; }
CWE-362 static void bt_for_each ( struct blk_mq_hw_ctx * hctx , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <S2SV_EndBug> if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
CWE-189 static void ecryptfs_decode_from_filename ( unsigned char * dst , size_t * dst_size , const unsigned char * src , size_t src_size ) { u8 current_bit_offset = 0 ; size_t src_byte_offset = 0 ; size_t dst_byte_offset = 0 ; if ( dst == NULL ) { ( * dst_size ) = ecryptfs_max_decoded_size ( src_size ) ; goto out ; } while ( src_byte_offset < src_size ) { unsigned char src_byte = filename_rev_map [ ( int ) src [ src_byte_offset ] ] ; switch ( current_bit_offset ) { case 0 : dst [ dst_byte_offset ] = ( src_byte << 2 ) ; current_bit_offset = 6 ; break ; case 6 : dst [ dst_byte_offset ++ ] |= ( src_byte >> 4 ) ; dst [ dst_byte_offset ] = ( ( src_byte & 0xF ) << 4 ) ; current_bit_offset = 4 ; break ; case 4 : dst [ dst_byte_offset ++ ] |= ( src_byte >> 2 ) ; dst [ dst_byte_offset ] = ( src_byte << 6 ) ; current_bit_offset = 2 ; break ; case 2 : dst [ dst_byte_offset ++ ] |= ( src_byte ) ; <S2SV_StartBug> dst [ dst_byte_offset ] = 0 ; <S2SV_EndBug> current_bit_offset = 0 ; break ; } src_byte_offset ++ ; } ( * dst_size ) = dst_byte_offset ; out : return ; }
CWE-264 static void timer_enter_running ( Timer * t ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; int r ; assert ( t ) ; if ( unit_stop_pending ( UNIT ( t ) ) ) return ; r = manager_add_job ( UNIT ( t ) -> manager , JOB_START , UNIT_TRIGGER ( UNIT ( t ) ) , JOB_REPLACE , true , & error , NULL ) ; if ( r < 0 ) goto fail ; dual_timestamp_get ( & t -> last_trigger ) ; if ( t -> stamp_path ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> timer_set_state ( t , TIMER_RUNNING ) ; return ; fail : log_unit_warning ( UNIT ( t ) , "Failed<S2SV_blank>to<S2SV_blank>queue<S2SV_blank>unit<S2SV_blank>startup<S2SV_blank>job:<S2SV_blank>%s" , bus_error_message ( & error , r ) ) ; timer_enter_dead ( t , TIMER_FAILURE_RESOURCES ) ; }
CWE-119 static int rd_inter16x16_uv ( VP8_COMP * cpi , MACROBLOCK * x , int * rate , int * distortion , int fullpixel ) <S2SV_StartBug> { <S2SV_EndBug> vp8_build_inter16x16_predictors_mbuv ( & x -> e_mbd ) ; vp8_subtract_mbuv ( x -> src_diff , x -> src . u_buffer , x -> src . v_buffer , x -> src . uv_stride , & x -> e_mbd . predictor [ 256 ] , & x -> e_mbd . predictor [ 320 ] , 8 ) ; vp8_transform_mbuv ( x ) ; vp8_quantize_mbuv ( x ) ; * rate = rd_cost_mbuv ( x ) ; * distortion = vp8_mbuverror ( x ) / 4 ; return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ; }
CWE-119 static void tokenadd ( struct jv_parser * p , char c ) { assert ( p -> tokenpos <= p -> tokenlen ) ; <S2SV_StartBug> if ( p -> tokenpos == p -> tokenlen ) { <S2SV_EndBug> p -> tokenlen = p -> tokenlen * 2 + 256 ; p -> tokenbuf = jv_mem_realloc ( p -> tokenbuf , p -> tokenlen ) ; } assert ( p -> tokenpos < p -> tokenlen ) ; p -> tokenbuf [ p -> tokenpos ++ ] = c ; }
CWE-119 static void tree_to_node ( void * data , BLOCK_SIZE bsize , variance_node * node ) { int i ; <S2SV_StartBug> switch ( bsize ) { <S2SV_EndBug> case BLOCK_64X64 : { v64x64 * vt = ( v64x64 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_32X32 : { v32x32 * vt = ( v32x32 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_16X16 : { v16x16 * vt = ( v16x16 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_8X8 : { v8x8 * vt = ( v8x8 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) <S2SV_StartBug> node -> split [ i ] = & vt -> split [ i ] ; <S2SV_EndBug> break ; } default : { assert ( 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> } }
CWE-119 static void copy_fields ( const FieldMatchContext * fm , AVFrame * dst , const AVFrame * src , int field ) { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane ++ ) <S2SV_EndBug> av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ; }
CWE-190 static jas_image_cmpt_t * jas_image_cmpt_create ( int_fast32_t tlx , int_fast32_t tly , int_fast32_t hstep , int_fast32_t vstep , int_fast32_t width , int_fast32_t height , uint_fast16_t depth , bool sgnd , uint_fast32_t inmem ) { jas_image_cmpt_t * cmpt ; size_t size ; cmpt = 0 ; if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) { goto error ; } if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) || ! jas_safe_intfast32_add ( tly , height , 0 ) ) { goto error ; } if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) { goto error ; } cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ; cmpt -> tlx_ = tlx ; cmpt -> tly_ = tly ; cmpt -> hstep_ = hstep ; cmpt -> vstep_ = vstep ; cmpt -> width_ = width ; cmpt -> height_ = height ; cmpt -> prec_ = depth ; cmpt -> sgnd_ = sgnd ; cmpt -> stream_ = 0 ; cmpt -> cps_ = ( depth + 7 ) / 8 ; if ( ! jas_safe_size_mul ( cmpt -> width_ , cmpt -> height_ , & size ) || ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { goto error ; } <S2SV_StartBug> cmpt -> stream_ = ( inmem ) ? jas_stream_memopen ( 0 , size ) : <S2SV_EndBug> jas_stream_tmpfile ( ) ; if ( ! cmpt -> stream_ ) { goto error ; } if ( jas_stream_seek ( cmpt -> stream_ , size - 1 , SEEK_SET ) < 0 || jas_stream_putc ( cmpt -> stream_ , 0 ) == EOF || jas_stream_seek ( cmpt -> stream_ , 0 , SEEK_SET ) < 0 ) { goto error ; } return cmpt ; error : if ( cmpt ) { jas_image_cmpt_destroy ( cmpt ) ; } return 0 ; }
CWE-200 void * vips_tracked_malloc ( size_t size ) { void * buf ; vips_tracked_init ( ) ; size += 16 ; <S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> # ifdef DEBUG g_assert_not_reached ( ) ; # endif vips_error ( "vips_tracked" , _ ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; g_warning ( _ ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; return ( NULL ) ; } g_mutex_lock ( vips_tracked_mutex ) ; * ( ( size_t * ) buf ) = size ; buf = ( void * ) ( ( char * ) buf + 16 ) ; vips_tracked_mem += size ; if ( vips_tracked_mem > vips_tracked_mem_highwater ) vips_tracked_mem_highwater = vips_tracked_mem ; vips_tracked_allocs += 1 ; # ifdef DEBUG_VERBOSE printf ( "vips_tracked_malloc:<S2SV_blank>%p,<S2SV_blank>%zd<S2SV_blank>bytes\\n" , buf , size ) ; # endif g_mutex_unlock ( vips_tracked_mutex ) ; VIPS_GATE_MALLOC ( size ) ; return ( buf ) ; }
CWE-20 static int lua_websocket_read ( lua_State * L ) { apr_socket_t * sock ; apr_status_t rv ; <S2SV_StartBug> int n = 0 ; <S2SV_EndBug> apr_size_t len = 1 ; apr_size_t plen = 0 ; unsigned short payload_short = 0 ; apr_uint64_t payload_long = 0 ; unsigned char * mask_bytes ; char byte ; int plaintext ; request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1 ; mask_bytes = apr_pcalloc ( r -> pool , 4 ) ; <S2SV_StartBug> sock = ap_get_conn_socket ( r -> connection ) ; <S2SV_EndBug> if ( plaintext ) { rv = apr_socket_recv ( sock , & byte , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; } if ( rv == APR_SUCCESS ) { unsigned char ubyte , fin , opcode , mask , payload ; ubyte = ( unsigned char ) byte ; fin = ubyte >> ( CHAR_BIT - 1 ) ; opcode = ubyte & 0xf ; if ( plaintext ) { rv = apr_socket_recv ( sock , & byte , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; } if ( rv == APR_SUCCESS ) { ubyte = ( unsigned char ) byte ; mask = ubyte >> ( CHAR_BIT - 1 ) ; payload = ubyte & 0x7f ; plen = payload ; if ( payload == 126 ) { len = 2 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ) ; } payload_short = ntohs ( payload_short ) ; if ( rv == APR_SUCCESS ) { plen = payload_short ; } else { return 0 ; } } if ( payload == 127 ) { len = 8 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ) ; } if ( rv == APR_SUCCESS ) { plen = ap_ntoh64 ( & payload_long ) ; } else { return 0 ; } } ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , "Websocket:<S2SV_blank>Reading<S2SV_blank>%" APR_SIZE_T_FMT "<S2SV_blank>(%s)<S2SV_blank>bytes,<S2SV_blank>masking<S2SV_blank>is<S2SV_blank>%s.<S2SV_blank>%s" , plen , ( payload >= 126 ) ? "extra<S2SV_blank>payload" : "no<S2SV_blank>extra<S2SV_blank>payload" , mask ? "on" : "off" , fin ? "This<S2SV_blank>is<S2SV_blank>a<S2SV_blank>final<S2SV_blank>frame" : "more<S2SV_blank>to<S2SV_blank>follow" ) ; if ( mask ) { len = 4 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ) ; } if ( rv != APR_SUCCESS ) { return 0 ; } } if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 ) { apr_size_t remaining = plen ; apr_size_t received ; apr_off_t at = 0 ; char * buffer = apr_palloc ( r -> pool , plen + 1 ) ; buffer [ plen ] = 0 ; if ( plaintext ) { while ( remaining > 0 ) { received = remaining ; rv = apr_socket_recv ( sock , buffer + at , & received ) ; if ( received > 0 ) { remaining -= received ; at += received ; } } ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , "Websocket:<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%" APR_OFF_T_FMT "<S2SV_blank>bytes,<S2SV_blank>pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack" , at ) ; } else { rv = lua_websocket_readbytes ( r -> connection , buffer , remaining ) ; ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , "Websocket:<S2SV_blank>SSL<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%" APR_SIZE_T_FMT "<S2SV_blank>bytes,<S2SV_blank>" "pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack" , remaining ) ; } if ( mask ) { for ( n = 0 ; n < plen ; n ++ ) { buffer [ n ] ^= mask_bytes [ n % 4 ] ; } } lua_pushlstring ( L , buffer , ( size_t ) plen ) ; lua_pushboolean ( L , fin ) ; return 2 ; } if ( opcode == 0x09 ) { char frame [ 2 ] ; plen = 2 ; frame [ 0 ] = 0x8A ; frame [ 1 ] = 0 ; apr_socket_send ( sock , frame , & plen ) ; <S2SV_StartBug> lua_websocket_read ( L ) ; <S2SV_EndBug> } } } return 0 ; }
CWE-000 static long madvise_willneed ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { struct file * file = vma -> vm_file ; <S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> if ( ! file ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_swapin_readahead ( vma , start , end ) ; return 0 ; } if ( shmem_mapping ( file -> f_mapping ) ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ; return 0 ; } # else if ( ! file ) return - EBADF ; # endif if ( IS_DAX ( file_inode ( file ) ) ) { return 0 ; } <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; if ( end > vma -> vm_end ) end = vma -> vm_end ; end = ( ( end - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; force_page_cache_readahead ( file -> f_mapping , file , start , end - start ) ; return 0 ; }
CWE-119 static int sd2_parse_rsrc_fork ( SF_PRIVATE * psf ) { SD2_RSRC rsrc ; int k , marker , error = 0 ; psf_use_rsrc ( psf , SF_TRUE ) ; memset ( & rsrc , 0 , sizeof ( rsrc ) ) ; rsrc . rsrc_len = psf_get_filelen ( psf ) ; psf_log_printf ( psf , "Resource<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>(0x%04X)\\n" , rsrc . rsrc_len , rsrc . rsrc_len ) ; if ( rsrc . rsrc_len > SIGNED_SIZEOF ( psf -> header ) ) { rsrc . rsrc_data = calloc ( 1 , rsrc . rsrc_len ) ; rsrc . need_to_free_rsrc_data = SF_TRUE ; } else { rsrc . rsrc_data = psf -> header ; rsrc . need_to_free_rsrc_data = SF_FALSE ; } ; psf_fread ( rsrc . rsrc_data , rsrc . rsrc_len , 1 , psf ) ; psf -> headindex = psf -> headend = rsrc . rsrc_len ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0 ) ; rsrc . map_offset = read_rsrc_int ( & rsrc , 4 ) ; rsrc . data_length = read_rsrc_int ( & rsrc , 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 12 ) ; if ( rsrc . data_offset == 0x51607 && rsrc . map_offset == 0x20000 ) { psf_log_printf ( psf , "Trying<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>0x52<S2SV_blank>bytes.\\n" ) ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0x52 + 0 ) + 0x52 ; rsrc . map_offset = read_rsrc_int ( & rsrc , 0x52 + 4 ) + 0x52 ; rsrc . data_length = read_rsrc_int ( & rsrc , 0x52 + 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 0x52 + 12 ) ; } ; psf_log_printf ( psf , "<S2SV_blank><S2SV_blank>data<S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n" "<S2SV_blank><S2SV_blank>data<S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n" , rsrc . data_offset , rsrc . map_offset , rsrc . data_length , rsrc . map_length ) ; if ( rsrc . data_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>rsrc.data_offset<S2SV_blank>(%d,<S2SV_blank>0x%x)<S2SV_blank>><S2SV_blank>len\\n" , rsrc . data_offset , rsrc . data_offset ) ; error = SFE_SD2_BAD_DATA_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>rsrc.map_offset<S2SV_blank>><S2SV_blank>len\\n" ) ; error = SFE_SD2_BAD_MAP_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_length > rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>rsrc.data_length<S2SV_blank>><S2SV_blank>len\\n" ) ; error = SFE_SD2_BAD_DATA_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_length > rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>rsrc.map_length<S2SV_blank>><S2SV_blank>len\\n" ) ; error = SFE_SD2_BAD_MAP_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_offset + rsrc . data_length != rsrc . map_offset || rsrc . map_offset + rsrc . map_length != rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>This<S2SV_blank>does<S2SV_blank>not<S2SV_blank>look<S2SV_blank>like<S2SV_blank>a<S2SV_blank>MacOSX<S2SV_blank>resource<S2SV_blank>fork.\\n" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset + 28 >= rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>map<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>+<S2SV_blank>28<S2SV_blank>><S2SV_blank>%d).\\n" , rsrc . map_offset , rsrc . rsrc_len ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . string_offset = rsrc . map_offset + read_rsrc_short ( & rsrc , rsrc . map_offset + 26 ) ; if ( rsrc . string_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>string<S2SV_blank>offset<S2SV_blank>(%d).\\n" , rsrc . string_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . type_offset = rsrc . map_offset + 30 ; <S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> if ( rsrc . type_count < 1 ) { psf_log_printf ( psf , "Bad<S2SV_blank>type<S2SV_blank>count.\\n" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . item_offset = rsrc . type_offset + rsrc . type_count * 8 ; if ( rsrc . item_offset < 0 || rsrc . item_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>item<S2SV_blank>offset<S2SV_blank>(%d).\\n" , rsrc . item_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . str_index = - 1 ; for ( k = 0 ; k < rsrc . type_count ; k ++ ) <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> if ( marker == STR_MARKER ) { rsrc . str_index = k ; rsrc . str_count = read_rsrc_short ( & rsrc , rsrc . type_offset + k * 8 + 4 ) + 1 ; error = parse_str_rsrc ( psf , & rsrc ) ; goto parse_rsrc_fork_cleanup ; } ; } ; psf_log_printf ( psf , "No<S2SV_blank>\'STR<S2SV_blank>\'<S2SV_blank>resource.\\n" ) ; error = SFE_SD2_BAD_RSRC ; parse_rsrc_fork_cleanup : psf_use_rsrc ( psf , SF_FALSE ) ; if ( rsrc . need_to_free_rsrc_data ) free ( rsrc . rsrc_data ) ; return error ; }
CWE-119 void vp8_rtcd ( ) { <S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> once ( setup_rtcd_internal ) ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_scaling_mode_t * data = va_arg ( args , vpx_scaling_mode_t * ) ; if ( data ) { int res ; vpx_scaling_mode_t scalemode = * ( vpx_scaling_mode_t * ) data ; res = vp8_set_internal_size ( ctx -> cpi , ( VPX_SCALING ) scalemode . h_scaling_mode , ( VPX_SCALING ) scalemode . v_scaling_mode ) ; if ( ! res ) { ctx -> next_frame_flag |= FRAMEFLAGS_KEY ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }
CWE-000 static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> buf [ 0 ] = CP2112_GPIO_SET ; buf [ 1 ] = value ? 0xff : 0 ; buf [ 2 ] = 1 << offset ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_SET , buf , CP2112_GPIO_SET_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) hid_err ( hdev , "error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>values:<S2SV_blank>%d\\n" , ret ) ; <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> }
CWE-119 static int http_open ( URLContext * h , const char * uri , int flags , AVDictionary * * options ) { HTTPContext * s = h -> priv_data ; int ret ; if ( s -> seekable == 1 ) h -> is_streamed = 0 ; else h -> is_streamed = 1 ; <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> location = av_strdup ( uri ) ; if ( ! s -> location ) return AVERROR ( ENOMEM ) ; if ( options ) av_dict_copy ( & s -> chained_options , * options , 0 ) ; if ( s -> headers ) { int len = strlen ( s -> headers ) ; if ( len < 2 || strcmp ( "\\r\\n" , s -> headers + len - 2 ) ) { av_log ( h , AV_LOG_WARNING , "No<S2SV_blank>trailing<S2SV_blank>CRLF<S2SV_blank>found<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>header.\\n" ) ; ret = av_reallocp ( & s -> headers , len + 3 ) ; if ( ret < 0 ) return ret ; s -> headers [ len ] = '\\r' ; s -> headers [ len + 1 ] = '\\n' ; s -> headers [ len + 2 ] = '\\0' ; } } if ( s -> listen ) { return http_listen ( h , uri , flags , options ) ; } ret = http_open_cnx ( h , options ) ; if ( ret < 0 ) av_dict_free ( & s -> chained_options ) ; return ret ; }
CWE-264 static int validate_group ( struct perf_event * event ) { struct perf_event * sibling , * leader = event -> group_leader ; struct pmu_hw_events fake_pmu ; DECLARE_BITMAP ( fake_used_mask , ARMPMU_MAX_HWEVENTS ) ; memset ( fake_used_mask , 0 , sizeof ( fake_used_mask ) ) ; fake_pmu . used_mask = fake_used_mask ; <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , leader ) ) <S2SV_EndBug> return - EINVAL ; list_for_each_entry ( sibling , & leader -> sibling_list , group_entry ) { <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , sibling ) ) <S2SV_EndBug> return - EINVAL ; } <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , event ) ) <S2SV_EndBug> return - EINVAL ; return 0 ; }
CWE-000 void impeg2d_dec_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <S2SV_EndBug> { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }
CWE-119 static void yv12_extend_frame_left_right_c ( YV12_BUFFER_CONFIG * ybf , unsigned char * y_src , unsigned char * u_src , unsigned char * v_src ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr1 , * dest_ptr2 ; unsigned int Border ; int plane_stride ; int plane_height ; int plane_width ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; plane_height = 16 ; plane_width = ybf -> y_width ; src_ptr1 = y_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } plane_stride = ybf -> uv_stride ; plane_height = 8 ; plane_width = ybf -> uv_width ; Border /= 2 ; src_ptr1 = u_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } src_ptr1 = v_src ; src_ptr2 = src_ptr1 + plane_width - 1 ; dest_ptr1 = src_ptr1 - Border ; dest_ptr2 = src_ptr2 + 1 ; for ( i = 0 ; i < plane_height ; i ++ ) { <S2SV_StartBug> vpx_memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; <S2SV_EndBug> vpx_memset ( dest_ptr2 , src_ptr2 [ 0 ] , Border ) ; src_ptr1 += plane_stride ; src_ptr2 += plane_stride ; dest_ptr1 += plane_stride ; dest_ptr2 += plane_stride ; } }
CWE-190 SYSCALL_DEFINE1 ( timer_getoverrun , timer_t , timer_id ) { struct k_itimer * timr ; int overrun ; unsigned long flags ; timr = lock_timer ( timer_id , & flags ) ; if ( ! timr ) return - EINVAL ; <S2SV_StartBug> overrun = timr -> it_overrun_last ; <S2SV_EndBug> unlock_timer ( timr , flags ) ; return overrun ; }
CWE-264 static void mincore_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , unsigned char * vec ) { unsigned long next ; pmd_t * pmd ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( mincore_huge_pmd ( vma , pmd , addr , next , vec ) ) { vec += ( next - addr ) >> PAGE_SHIFT ; continue ; } } <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> mincore_unmapped_range ( vma , addr , next , vec ) ; else mincore_pte_range ( vma , pmd , addr , next , vec ) ; vec += ( next - addr ) >> PAGE_SHIFT ; } while ( pmd ++ , addr = next , addr != end ) ; }
CWE-20 static int snd_hrtimer_stop ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
CWE-000 int msPostGISLayerSetTimeFilter ( layerObj * lp , const char * timestring , const char * timefield ) { char * * atimes , * * aranges = NULL ; int numtimes = 0 , i = 0 , numranges = 0 ; size_t buffer_size = 512 ; char buffer [ 512 ] , bufferTmp [ 512 ] ; buffer [ 0 ] = '\\0' ; bufferTmp [ 0 ] = '\\0' ; if ( ! lp || ! timestring || ! timefield ) <S2SV_StartBug> return MS_FALSE ; <S2SV_EndBug> if ( strstr ( timestring , "," ) == NULL && strstr ( timestring , "/" ) == NULL ) { createPostgresTimeCompareSimple ( timefield , timestring , buffer , buffer_size ) ; } else { atimes = msStringSplit ( timestring , ',' , & numtimes ) ; if ( atimes == NULL || numtimes < 1 ) return MS_FALSE ; strlcat ( buffer , "(" , buffer_size ) ; for ( i = 0 ; i < numtimes ; i ++ ) { if ( i != 0 ) { strlcat ( buffer , "<S2SV_blank>OR<S2SV_blank>" , buffer_size ) ; } strlcat ( buffer , "(" , buffer_size ) ; aranges = msStringSplit ( atimes [ i ] , '/' , & numranges ) ; if ( ! aranges ) return MS_FALSE ; if ( numranges == 1 ) { createPostgresTimeCompareSimple ( timefield , atimes [ i ] , bufferTmp , buffer_size ) ; strlcat ( buffer , bufferTmp , buffer_size ) ; } else if ( numranges == 2 ) { createPostgresTimeCompareRange ( timefield , aranges [ 0 ] , aranges [ 1 ] , bufferTmp , buffer_size ) ; strlcat ( buffer , bufferTmp , buffer_size ) ; } else { return MS_FALSE ; } msFreeCharArray ( aranges , numranges ) ; strlcat ( buffer , ")" , buffer_size ) ; } strlcat ( buffer , ")" , buffer_size ) ; msFreeCharArray ( atimes , numtimes ) ; } if ( ! * buffer ) { return MS_FALSE ; } if ( lp -> filteritem ) free ( lp -> filteritem ) ; lp -> filteritem = msStrdup ( timefield ) ; if ( & lp -> filter ) { if ( lp -> filter . type == MS_EXPRESSION ) { snprintf ( bufferTmp , buffer_size , "(%s)<S2SV_blank>and<S2SV_blank>%s" , lp -> filter . string , buffer ) ; loadExpressionString ( & lp -> filter , bufferTmp ) ; } else { freeExpression ( & lp -> filter ) ; loadExpressionString ( & lp -> filter , buffer ) ; } } return MS_TRUE ; }
CWE-119 static Image * ReadHALDImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; size_t cube_size , level ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; level = 0 ; if ( * image_info -> filename != '\\0' ) level = StringToUnsignedLong ( image_info -> filename ) ; if ( level < 2 ) level = 8 ; status = MagickTrue ; cube_size = level * level ; image -> columns = ( size_t ) ( level * cube_size ) ; image -> rows = ( size_t ) ( level * cube_size ) ; <S2SV_StartBug> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += ( ssize_t ) level ) <S2SV_EndBug> { ssize_t blue , green , red ; register PixelPacket * restrict q ; if ( status == MagickFalse ) continue ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , ( size_t ) level , exception ) ; if ( q == ( PixelPacket * ) NULL ) { status = MagickFalse ; continue ; } blue = y / ( ssize_t ) level ; for ( green = 0 ; green < ( ssize_t ) cube_size ; green ++ ) { for ( red = 0 ; red < ( ssize_t ) cube_size ; red ++ ) { SetPixelRed ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * red / ( cube_size - 1.0 ) ) ) ) ; SetPixelGreen ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * green / ( cube_size - 1.0 ) ) ) ) ; SetPixelBlue ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * blue / ( cube_size - 1.0 ) ) ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) status = MagickFalse ; } return ( GetFirstImageInList ( image ) ) ; }
CWE-200 static void tty_set_termios_ldisc ( struct tty_struct * tty , int num ) { down_write ( & tty -> termios_rwsem ) ; tty -> termios . c_line = num ; up_write ( & tty -> termios_rwsem ) ; <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) { <S2SV_StartBug> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; }
CWE-119 void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; <S2SV_StartBug> int hstartcol ; <S2SV_EndBug> if ( bufsize > QMFB_SPLITBUFSIZE ) { <S2SV_StartBug> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <S2SV_EndBug> abort ( ) ; } } if ( numrows >= 2 ) { <S2SV_StartBug> hstartcol = ( numrows + 1 - parity ) >> 1 ; <S2SV_EndBug> <S2SV_StartBug> m = numrows - hstartcol ; <S2SV_EndBug> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } <S2SV_StartBug> dstptr = & a [ hstartcol * stride ] ; <S2SV_EndBug> srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += JPC_QMFB_COLGRPSIZE ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
CWE-119 void vp9_adapt_mv_probs ( VP9_COMMON * cm , int allow_hp ) { int i , j ; <S2SV_StartBug> nmv_context * fc = & cm -> fc . nmvc ; <S2SV_EndBug> const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ; const nmv_context_counts * counts = & cm -> counts . mv ; <S2SV_StartBug> adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ; <S2SV_EndBug> for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * comp = & fc -> comps [ i ] ; const nmv_component * pre_comp = & pre_fc -> comps [ i ] ; const nmv_component_counts * c = & counts -> comps [ i ] ; <S2SV_StartBug> comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , <S2SV_EndBug> comp -> classes ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ; <S2SV_EndBug> for ( j = 0 ; j < MV_OFFSET_BITS ; ++ j ) <S2SV_StartBug> comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; <S2SV_EndBug> for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , <S2SV_EndBug> comp -> class0_fp [ j ] ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; <S2SV_EndBug> if ( allow_hp ) { <S2SV_StartBug> comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ; <S2SV_EndBug> } } }
CWE-119 static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vp9_ref_frame_t * data = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_StartBug> if ( data ) { <S2SV_EndBug> YV12_BUFFER_CONFIG * fb ; <S2SV_StartBug> vp9_get_reference_dec ( ctx -> pbi , data -> idx , & fb ) ; <S2SV_EndBug> yuvconfig2image ( & data -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
CWE-190 void silk_NLSF_stabilize ( opus_int16 * NLSF_Q15 , const opus_int16 * NDeltaMin_Q15 , const opus_int L ) { opus_int i , I = 0 , k , loops ; opus_int16 center_freq_Q15 ; opus_int32 diff_Q15 , min_diff_Q15 , min_center_Q15 , max_center_Q15 ; silk_assert ( NDeltaMin_Q15 [ L ] >= 1 ) ; for ( loops = 0 ; loops < MAX_LOOPS ; loops ++ ) { min_diff_Q15 = NLSF_Q15 [ 0 ] - NDeltaMin_Q15 [ 0 ] ; I = 0 ; for ( i = 1 ; i <= L - 1 ; i ++ ) { diff_Q15 = NLSF_Q15 [ i ] - ( NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ; if ( diff_Q15 < min_diff_Q15 ) { min_diff_Q15 = diff_Q15 ; I = i ; } } diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15 [ L - 1 ] + NDeltaMin_Q15 [ L ] ) ; if ( diff_Q15 < min_diff_Q15 ) { min_diff_Q15 = diff_Q15 ; I = L ; } if ( min_diff_Q15 >= 0 ) { return ; } if ( I == 0 ) { NLSF_Q15 [ 0 ] = NDeltaMin_Q15 [ 0 ] ; } else if ( I == L ) { NLSF_Q15 [ L - 1 ] = ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ; } else { min_center_Q15 = 0 ; for ( k = 0 ; k < I ; k ++ ) { min_center_Q15 += NDeltaMin_Q15 [ k ] ; } min_center_Q15 += silk_RSHIFT ( NDeltaMin_Q15 [ I ] , 1 ) ; max_center_Q15 = 1 << 15 ; for ( k = L ; k > I ; k -- ) { max_center_Q15 -= NDeltaMin_Q15 [ k ] ; } max_center_Q15 -= silk_RSHIFT ( NDeltaMin_Q15 [ I ] , 1 ) ; center_freq_Q15 = ( opus_int16 ) silk_LIMIT_32 ( silk_RSHIFT_ROUND ( ( opus_int32 ) NLSF_Q15 [ I - 1 ] + ( opus_int32 ) NLSF_Q15 [ I ] , 1 ) , min_center_Q15 , max_center_Q15 ) ; NLSF_Q15 [ I - 1 ] = center_freq_Q15 - silk_RSHIFT ( NDeltaMin_Q15 [ I ] , 1 ) ; NLSF_Q15 [ I ] = NLSF_Q15 [ I - 1 ] + NDeltaMin_Q15 [ I ] ; } } if ( loops == MAX_LOOPS ) { silk_insertion_sort_increasing_all_values_int16 ( & NLSF_Q15 [ 0 ] , L ) ; NLSF_Q15 [ 0 ] = silk_max_int ( NLSF_Q15 [ 0 ] , NDeltaMin_Q15 [ 0 ] ) ; for ( i = 1 ; i < L ; i ++ ) <S2SV_StartBug> NLSF_Q15 [ i ] = silk_max_int ( NLSF_Q15 [ i ] , NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ; <S2SV_EndBug> NLSF_Q15 [ L - 1 ] = silk_min_int ( NLSF_Q15 [ L - 1 ] , ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ) ; for ( i = L - 2 ; i >= 0 ; i -- ) NLSF_Q15 [ i ] = silk_min_int ( NLSF_Q15 [ i ] , NLSF_Q15 [ i + 1 ] - NDeltaMin_Q15 [ i + 1 ] ) ; } }
CWE-20 int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( "%d<S2SV_blank>-=<S2SV_blank>%d\\n" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }
CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , "USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\n" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , "device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\n" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , "no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\n" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }
CWE-125 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , "<S2SV_blank>wb-prep:" ) ) ; <S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> return ( - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , "<S2SV_blank>%u/%s:%u" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , "%c%s:%u" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , ">" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
CWE-20 static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; <S2SV_StartBug> guint pkt_len ; <S2SV_EndBug> int pktnum , hr , min , sec , csec ; char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , "%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\'t<S2SV_blank>valid" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\0' ; } while ( strcmp ( line , "OFFSET<S2SV_blank>0001-0203" ) != 0 ) ; <S2SV_StartBug> num_items_scanned = sscanf ( line + 64 , "LEN=%9u" , & pkt_len ) ; <S2SV_EndBug> if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; <S2SV_StartBug> * err_info = g_strdup ( "toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item" ) ; <S2SV_EndBug> return FALSE ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; phdr -> ts . secs = hr * 3600 + min * 60 + sec ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> caplen = pkt_len ; phdr -> len = pkt_len ; switch ( channel [ 0 ] ) { case 'B' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = ( guint8 ) strtol ( & channel [ 1 ] , NULL , 10 ) ; break ; case 'D' : phdr -> pkt_encap = WTAP_ENCAP_ISDN ; pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; pseudo_header -> isdn . channel = 0 ; break ; default : phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; pseudo_header -> eth . fcs_len = - 1 ; break ; } ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid" ) ; return FALSE ; } } return TRUE ; }
CWE-264 static int rio_ioctl ( struct net_device * dev , struct ifreq * rq , int cmd ) { int phy_addr ; struct netdev_private * np = netdev_priv ( dev ) ; <S2SV_StartBug> struct mii_data * miidata = ( struct mii_data * ) & rq -> ifr_ifru ; <S2SV_EndBug> struct netdev_desc * desc ; int i ; phy_addr = np -> phy_addr ; switch ( cmd ) { <S2SV_StartBug> case SIOCDEVPRIVATE : <S2SV_EndBug> break ; <S2SV_StartBug> case SIOCDEVPRIVATE + 1 : <S2SV_EndBug> <S2SV_StartBug> miidata -> out_value = mii_read ( dev , phy_addr , miidata -> reg_num ) ; <S2SV_EndBug> break ; <S2SV_StartBug> case SIOCDEVPRIVATE + 2 : <S2SV_EndBug> <S2SV_StartBug> mii_write ( dev , phy_addr , miidata -> reg_num , miidata -> in_value ) ; <S2SV_EndBug> break ; case SIOCDEVPRIVATE + 3 : break ; case SIOCDEVPRIVATE + 4 : break ; case SIOCDEVPRIVATE + 5 : netif_stop_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 6 : netif_wake_queue ( dev ) ; break ; case SIOCDEVPRIVATE + 7 : printk ( "tx_full=%x<S2SV_blank>cur_tx=%lx<S2SV_blank>old_tx=%lx<S2SV_blank>cur_rx=%lx<S2SV_blank>old_rx=%lx\\n" , netif_queue_stopped ( dev ) , np -> cur_tx , np -> old_tx , np -> cur_rx , np -> old_rx ) ; break ; case SIOCDEVPRIVATE + 8 : printk ( "TX<S2SV_blank>ring:\\n" ) ; for ( i = 0 ; i < TX_RING_SIZE ; i ++ ) { desc = & np -> tx_ring [ i ] ; printk ( "%02x:cur:%08x<S2SV_blank>next:%08x<S2SV_blank>status:%08x<S2SV_blank>frag1:%08x<S2SV_blank>frag0:%08x" , i , ( u32 ) ( np -> tx_ring_dma + i * sizeof ( * desc ) ) , ( u32 ) le64_to_cpu ( desc -> next_desc ) , ( u32 ) le64_to_cpu ( desc -> status ) , ( u32 ) ( le64_to_cpu ( desc -> fraginfo ) >> 32 ) , ( u32 ) le64_to_cpu ( desc -> fraginfo ) ) ; printk ( "\\n" ) ; } printk ( "\\n" ) ; break ; default : return - EOPNOTSUPP ; } return 0 ; }
CWE-000 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; <S2SV_StartBug> if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) <S2SV_EndBug> return - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; return 0 ; }
CWE-119 <S2SV_StartBug> void sum_2_variances ( const var * a , const var * b , var * r ) { <S2SV_EndBug> fill_variance ( a -> sum_square_error + b -> sum_square_error , <S2SV_StartBug> a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ; <S2SV_EndBug> }
CWE-000 static void sas_resume_port ( struct asd_sas_phy * phy ) { struct domain_device * dev ; struct asd_sas_port * port = phy -> port ; struct sas_ha_struct * sas_ha = phy -> ha ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; if ( si -> dft -> lldd_port_formed ) si -> dft -> lldd_port_formed ( phy ) ; if ( port -> suspended ) port -> suspended = 0 ; else { return ; } list_for_each_entry ( dev , & port -> dev_list , dev_list_node ) { int i , rc ; rc = sas_notify_lldd_dev_found ( dev ) ; if ( rc ) { <S2SV_StartBug> sas_unregister_dev ( port , dev ) ; <S2SV_EndBug> continue ; } if ( dev -> dev_type == SAS_EDGE_EXPANDER_DEVICE || dev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) { dev -> ex_dev . ex_change_count = - 1 ; for ( i = 0 ; i < dev -> ex_dev . num_phys ; i ++ ) { struct ex_phy * phy = & dev -> ex_dev . ex_phy [ i ] ; phy -> phy_change_count = - 1 ; } } } sas_discover_event ( port , DISCE_RESUME ) ; }
CWE-284 void preproc_mount_mnt_dir ( void ) { if ( ! tmpfs_mounted ) { if ( arg_debug ) printf ( "Mounting<S2SV_blank>tmpfs<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>directory\\n" , RUN_MNT_DIR ) ; if ( mount ( "tmpfs" , RUN_MNT_DIR , "tmpfs" , MS_NOSUID | MS_STRICTATIME , "mode=755,gid=0" ) < 0 ) errExit ( "mounting<S2SV_blank>/run/firejail/mnt" ) ; tmpfs_mounted = 1 ; fs_logger2 ( "tmpfs" , RUN_MNT_DIR ) ; # ifdef HAVE_SECCOMP <S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ; else { copy_file ( PATH_SECCOMP_32 , RUN_SECCOMP_32 , getuid ( ) , getgid ( ) , 0644 ) ; } if ( arg_allow_debuggers ) copy_file ( PATH_SECCOMP_DEFAULT_DEBUG , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; else copy_file ( PATH_SECCOMP_DEFAULT , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; if ( arg_memory_deny_write_execute ) copy_file ( PATH_SECCOMP_MDWX , RUN_SECCOMP_MDWX , getuid ( ) , getgid ( ) , 0644 ) ; create_empty_file_as_root ( RUN_SECCOMP_PROTOCOL , 0644 ) ; if ( set_perms ( RUN_SECCOMP_PROTOCOL , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( "set_perms" ) ; create_empty_file_as_root ( RUN_SECCOMP_POSTEXEC , 0644 ) ; if ( set_perms ( RUN_SECCOMP_POSTEXEC , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( "set_perms" ) ; # endif } }
CWE-119 static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , "%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , "%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; bychunk = ( tw == w && tl == rowsperstrip ) ; } } # define T 1 # define F 0 # define pack ( a , b , c , d , e ) ( ( long ) ( ( ( a ) << 11 ) | ( ( b ) << 3 ) | ( ( c ) << 2 ) | ( ( d ) << 1 ) | ( e ) ) ) switch ( pack ( shortv , config , TIFFIsTiled ( in ) , TIFFIsTiled ( out ) , bychunk ) ) { case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , T ) : return cpContigStrips2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , T ) : return cpContigStrips2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , T ) : return cpSeparateStrips2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , T ) : return cpSeparateStrips2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , T ) : return cpContigTiles2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , T ) : return cpContigTiles2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , T ) : return cpSeparateTiles2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , T ) : return cpSeparateTiles2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , T ) : return cpContigTiles2ContigStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , T ) : return cpContigTiles2SeparateStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , T ) : return cpSeparateTiles2ContigStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , T ) : return cpSeparateTiles2SeparateStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , F ) : return bias ? cpBiasedContig2Contig : cpContig2ContigByRow ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , T ) : return cpDecodedStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , T ) : return cpContig2SeparateByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , T ) : return cpSeparate2ContigByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , T ) : return cpSeparate2SeparateByRow ; } # undef pack # undef F # undef T fprintf ( stderr , "tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n" , TIFFFileName ( in ) ) ; return ( NULL ) ; }
CWE-119 void vp9_get_tile_n_bits ( int mi_cols , int * min_log2_tile_cols , int * max_log2_tile_cols ) { <S2SV_StartBug> const int sb_cols = mi_cols_aligned_to_sb ( mi_cols ) >> MI_BLOCK_SIZE_LOG2 ; <S2SV_EndBug> <S2SV_StartBug> int min_log2 = 0 , max_log2 = 0 ; <S2SV_EndBug> while ( ( sb_cols >> max_log2 ) >= MIN_TILE_WIDTH_B64 ) ++ max_log2 ; -- max_log2 ; if ( max_log2 < 0 ) max_log2 = 0 ; while ( ( MAX_TILE_WIDTH_B64 << min_log2 ) < sb_cols ) ++ min_log2 ; assert ( min_log2 <= max_log2 ) ; <S2SV_StartBug> * min_log2_tile_cols = min_log2 ; <S2SV_EndBug> <S2SV_StartBug> * max_log2_tile_cols = max_log2 ; <S2SV_EndBug> }
CWE-200 static long media_device_enum_entities ( struct media_device * mdev , struct media_entity_desc __user * uent ) { struct media_entity * ent ; struct media_entity_desc u_ent ; <S2SV_StartBug> if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) ) <S2SV_EndBug> return - EFAULT ; ent = find_entity ( mdev , u_ent . id ) ; if ( ent == NULL ) return - EINVAL ; u_ent . id = ent -> id ; if ( ent -> name ) { strncpy ( u_ent . name , ent -> name , sizeof ( u_ent . name ) ) ; u_ent . name [ sizeof ( u_ent . name ) - 1 ] = '\\0' ; } else { memset ( u_ent . name , 0 , sizeof ( u_ent . name ) ) ; } u_ent . type = ent -> type ; u_ent . revision = ent -> revision ; u_ent . flags = ent -> flags ; u_ent . group_id = ent -> group_id ; u_ent . pads = ent -> num_pads ; u_ent . links = ent -> num_links - ent -> num_backlinks ; memcpy ( & u_ent . raw , & ent -> info , sizeof ( ent -> info ) ) ; if ( copy_to_user ( uent , & u_ent , sizeof ( u_ent ) ) ) return - EFAULT ; return 0 ; }
CWE-000 static int install_process_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> } return commit_creds ( new ) ; }
CWE-119 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; uint32 strip , nstrips = TIFFNumberOfStrips ( in ) ; uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( "" , "TIFF<S2SV_blank>scanline<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero!" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( "" , "Strip<S2SV_blank>%d:<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>strip<S2SV_blank>size<S2SV_blank>%lu" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( "" , "Error<S2SV_blank>reading<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>after<S2SV_blank>%lu<S2SV_blank>rows" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } <S2SV_StartBug> bufp += bytes_read ; <S2SV_EndBug> } return 1 ; }
CWE-119 vpx_codec_err_t vpx_codec_encode ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ! ctx || ( img && ! duration ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { unsigned int num_enc = ctx -> priv -> enc . total_encoders ; FLOATING_POINT_INIT ( ) ; if ( num_enc == 1 ) <S2SV_StartBug> res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <S2SV_EndBug> duration , flags , deadline ) ; else { int i ; ctx += num_enc - 1 ; if ( img ) img += num_enc - 1 ; for ( i = num_enc - 1 ; i >= 0 ; i -- ) { <S2SV_StartBug> if ( ( res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , <S2SV_EndBug> duration , flags , deadline ) ) ) break ; ctx -- ; if ( img ) img -- ; } ctx ++ ; } FLOATING_POINT_RESTORE ( ) ; } return SAVE_STATUS ( ctx , res ) ; }
CWE-399 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
CWE-119 void vp9_temporal_filter_apply_c ( uint8_t * frame1 , unsigned int stride , uint8_t * frame2 , <S2SV_StartBug> unsigned int block_size , <S2SV_EndBug> int strength , int filter_weight , unsigned int * accumulator , uint16_t * count ) { unsigned int i , j , k ; int modifier ; int byte = 0 ; <S2SV_StartBug> for ( i = 0 , k = 0 ; i < block_size ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < block_size ; j ++ , k ++ ) { <S2SV_EndBug> int src_byte = frame1 [ byte ] ; int pixel_value = * frame2 ++ ; modifier = src_byte - pixel_value ; modifier *= modifier ; modifier *= 3 ; <S2SV_StartBug> modifier += 1 << ( strength - 1 ) ; <S2SV_EndBug> modifier >>= strength ; if ( modifier > 16 ) modifier = 16 ; modifier = 16 - modifier ; modifier *= filter_weight ; count [ k ] += modifier ; accumulator [ k ] += modifier * pixel_value ; byte ++ ; } <S2SV_StartBug> byte += stride - block_size ; <S2SV_EndBug> } }
CWE-416 static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; <S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr -> l2tp_family != AF_INET ) <S2SV_EndBug> return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }
CWE-000 static int udf_readdir ( struct file * file , struct dir_context * ctx ) { struct inode * dir = file_inode ( file ) ; struct udf_inode_info * iinfo = UDF_I ( dir ) ; struct udf_fileident_bh fibh = { . sbh = NULL , . ebh = NULL } ; struct fileIdentDesc * fi = NULL ; struct fileIdentDesc cfi ; int block , iblock ; loff_t nf_pos ; int flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint16_t liu ; uint8_t lfi ; loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; struct buffer_head * tmp , * bha [ 16 ] ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; int i , num , ret = 0 ; struct extent_position epos = { NULL , 0 , { 0 , 0 } } ; if ( ctx -> pos == 0 ) { if ( ! dir_emit_dot ( file , ctx ) ) return 0 ; ctx -> pos = 1 ; } nf_pos = ( ctx -> pos - 1 ) << 2 ; if ( nf_pos >= size ) goto out ; fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) { ret = - ENOMEM ; goto out ; } if ( nf_pos == 0 ) nf_pos = udf_ext0_offset ( dir ) ; fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( iinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , nf_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) { ret = - ENOENT ; goto out ; } block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else { offset = 0 ; } if ( ! ( fibh . sbh = fibh . ebh = udf_tread ( dir -> i_sb , block ) ) ) { ret = - EIO ; goto out ; } if ( ! ( offset & ( ( 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ) - 1 ) ) ) { i = 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ; if ( i + offset > ( elen >> dir -> i_sb -> s_blocksize_bits ) ) i = ( elen >> dir -> i_sb -> s_blocksize_bits ) - offset ; for ( num = 0 ; i > 0 ; i -- ) { block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset + i ) ; tmp = udf_tgetblk ( dir -> i_sb , block ) ; if ( tmp && ! buffer_uptodate ( tmp ) && ! buffer_locked ( tmp ) ) bha [ num ++ ] = tmp ; else brelse ( tmp ) ; } if ( num ) { ll_rw_block ( READA , num , bha ) ; for ( i = 0 ; i < num ; i ++ ) brelse ( bha [ i ] ) ; } } } while ( nf_pos < size ) { struct kernel_lb_addr tloc ; ctx -> pos = ( nf_pos >> 2 ) + 1 ; fi = udf_fileident_read ( dir , & nf_pos , & fibh , & cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out ; liu = le16_to_cpu ( cfi . lengthOfImpUse ) ; lfi = cfi . lengthFileIdent ; if ( fibh . sbh == fibh . ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh . soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) { nameptr = ( char * ) ( fibh . ebh -> b_data + poffset - lfi ) ; } else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh . ebh -> b_data , poffset ) ; } } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( cfi . fileCharacteristics & FID_FILE_CHAR_PARENT ) { if ( ! dir_emit_dotdot ( file , ctx ) ) goto out ; continue ; } <S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> if ( ! flen ) continue ; tloc = lelb_to_cpu ( cfi . icb . extLocation ) ; iblock = udf_get_lb_pblock ( dir -> i_sb , & tloc , 0 ) ; if ( ! dir_emit ( ctx , fname , flen , iblock , DT_UNKNOWN ) ) goto out ; } ctx -> pos = ( nf_pos >> 2 ) + 1 ; out : if ( fibh . sbh != fibh . ebh ) brelse ( fibh . ebh ) ; brelse ( fibh . sbh ) ; brelse ( epos . bh ) ; kfree ( fname ) ; return ret ; }
CWE-125 static inline unsigned short ReadPropertyUnsignedShort ( const EndianType endian , const unsigned char * buffer ) { unsigned short value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> } <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> }
CWE-20 static inline int mk_vhost_fdt_open ( int id , unsigned int hash , struct session_request * sr ) { int i ; int fd ; struct vhost_fdt_hash_table * ht = NULL ; struct vhost_fdt_hash_chain * hc ; if ( config -> fdt == MK_FALSE ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } ht = mk_vhost_fdt_table_lookup ( id , sr -> host_conf ) ; if ( mk_unlikely ( ! ht ) ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } hc = mk_vhost_fdt_chain_lookup ( hash , ht ) ; if ( hc ) { hc -> readers ++ ; return hc -> fd ; } fd = open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; if ( fd == - 1 ) { return - 1 ; } if ( ht -> av_slots <= 0 ) { return fd ; } for ( i = 0 ; i < VHOST_FDT_HASHTABLE_CHAINS ; i ++ ) { hc = & ht -> chain [ i ] ; if ( hc -> fd == - 1 ) { hc -> fd = fd ; hc -> hash = hash ; hc -> readers ++ ; ht -> av_slots -- ; sr -> vhost_fdt_id = id ; sr -> vhost_fdt_hash = hash ; <S2SV_StartBug> return fd ; <S2SV_EndBug> } } return - 1 ; }
CWE-20 static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ; <S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( TestClearPageMlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ; <S2SV_StartBug> } <S2SV_EndBug> pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = NULL ; } <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }
CWE-000 static int cp2112_gpio_direction_output ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_CONFIG_LENGTH ) { hid_err ( hdev , "error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n" , ret ) ; goto fail ; } buf [ 1 ] |= 1 << offset ; buf [ 2 ] = gpio_push_pull ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) { hid_err ( hdev , "error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n" , ret ) ; goto fail ; } <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> cp2112_gpio_set ( chip , offset , value ) ; return 0 ; fail : <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> return ret < 0 ? ret : - EIO ; }
CWE-399 int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; <S2SV_StartBug> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , "remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; if ( ! handle ) goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , "superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , "get_write_access" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , "orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; NEXT_ORPHAN ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; NEXT_ORPHAN ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }
CWE-000 static gchar * read_file ( gchar * filepath ) { FILE * f ; size_t length ; gchar * ret = NULL ; <S2SV_StartBug> f = fopen ( filepath , "rb" ) ; <S2SV_EndBug> if ( f ) { fseek ( f , 0 , SEEK_END ) ; length = ( size_t ) ftell ( f ) ; fseek ( f , 0 , SEEK_SET ) ; ret = MALLOC ( length + 1 ) ; if ( ret ) { if ( fread ( ret , length , 1 , f ) != 1 ) { log_message ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>of<S2SV_blank>%s" , filepath ) ; } ret [ length ] = '\\0' ; } else log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>Dbus<S2SV_blank>file<S2SV_blank>%s" , filepath ) ; fclose ( f ) ; } return ret ; }
CWE-264 static inline int ip_ufo_append_data ( struct sock * sk , struct sk_buff_head * queue , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int maxfraglen , unsigned int flags ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = maxfraglen - fragheaderlen ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; <S2SV_StartBug> __skb_queue_tail ( queue , skb ) ; <S2SV_EndBug> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }
CWE-119 vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <S2SV_StartBug> vpx_codec_enc_cfg_t * cfg , <S2SV_EndBug> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <S2SV_StartBug> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <S2SV_EndBug> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <S2SV_StartBug> if ( ctx -> priv ) <S2SV_EndBug> ctx -> priv -> iface = ctx -> iface ; } return SAVE_STATUS ( ctx , res ) ; }
CWE-284 int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry , struct inode * * delegated_inode , unsigned int flags ) { int error ; bool is_dir = d_is_dir ( old_dentry ) ; const unsigned char * old_name ; struct inode * source = old_dentry -> d_inode ; struct inode * target = new_dentry -> d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir -> i_sb -> s_max_links ; <S2SV_StartBug> if ( source == target ) <S2SV_EndBug> return 0 ; error = may_delete ( old_dir , old_dentry , is_dir ) ; if ( error ) return error ; if ( ! target ) { error = may_create ( new_dir , new_dentry ) ; } else { new_is_dir = d_is_dir ( new_dentry ) ; if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ; else error = may_delete ( new_dir , new_dentry , new_is_dir ) ; } if ( error ) return error ; if ( ! old_dir -> i_op -> rename && ! old_dir -> i_op -> rename2 ) return - EPERM ; if ( flags && ! old_dir -> i_op -> rename2 ) return - EINVAL ; if ( new_dir != old_dir ) { if ( is_dir ) { error = inode_permission ( source , MAY_WRITE ) ; if ( error ) return error ; } if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) { error = inode_permission ( target , MAY_WRITE ) ; if ( error ) return error ; } } error = security_inode_rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) return error ; old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } if ( ! old_dir -> i_op -> rename2 ) { error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry ) ; } else { WARN_ON ( old_dir -> i_op -> rename != NULL ) ; error = old_dir -> i_op -> rename2 ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; } if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , old_dentry -> d_name . name , new_is_dir , NULL , new_dentry ) ; } } fsnotify_oldname_free ( old_name ) ; return error ; }
CWE-20 static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) <S2SV_StartBug> goto read_error ; <S2SV_EndBug> m -> msg_namelen = 0 ; skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }
CWE-000 int xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , "%s(%d):<S2SV_blank>" , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext , <S2SV_StartBug> "Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n" , ctxt -> inputNr + 1 , input -> cur ) ; <S2SV_EndBug> } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }
CWE-264 int rpc_type_of_NPPVariable ( int variable ) { int type ; switch ( variable ) { case NPPVpluginNameString : case NPPVpluginDescriptionString : <S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> type = RPC_TYPE_STRING ; break ; case NPPVpluginWindowSize : case NPPVpluginTimerInterval : type = RPC_TYPE_INT32 ; break ; case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug> break ; case NPPVpluginScriptableNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }
CWE-264 static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , <S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> { struct desc_struct seg_desc , old_desc ; u8 dpl , rpl ; unsigned err_vec = GP_VECTOR ; u32 err_code = 0 ; bool null_selector = ! ( selector & ~ 0x3 ) ; ulong desc_addr ; int ret ; u16 dummy ; u32 base3 = 0 ; memset ( & seg_desc , 0 , sizeof seg_desc ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) { ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , NULL , seg ) ; set_desc_base ( & seg_desc , selector << 4 ) ; goto load ; } else if ( seg <= VCPU_SREG_GS && ctxt -> mode == X86EMUL_MODE_VM86 ) { set_desc_base ( & seg_desc , selector << 4 ) ; set_desc_limit ( & seg_desc , 0xffff ) ; seg_desc . type = 3 ; seg_desc . p = 1 ; seg_desc . s = 1 ; seg_desc . dpl = 3 ; goto load ; } rpl = selector & 3 ; if ( ( seg == VCPU_SREG_CS || ( seg == VCPU_SREG_SS && ( ctxt -> mode != X86EMUL_MODE_PROT64 || rpl != cpl ) ) || seg == VCPU_SREG_TR ) && null_selector ) goto exception ; if ( seg == VCPU_SREG_TR && ( selector & ( 1 << 2 ) ) ) goto exception ; if ( null_selector ) goto load ; ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; err_code = selector & 0xfffc ; err_vec = in_task_switch ? TS_VECTOR : GP_VECTOR ; if ( seg <= VCPU_SREG_GS && ! seg_desc . s ) goto exception ; if ( ! seg_desc . p ) { err_vec = ( seg == VCPU_SREG_SS ) ? SS_VECTOR : NP_VECTOR ; goto exception ; } dpl = seg_desc . dpl ; switch ( seg ) { case VCPU_SREG_SS : if ( rpl != cpl || ( seg_desc . type & 0xa ) != 0x2 || dpl != cpl ) goto exception ; break ; case VCPU_SREG_CS : if ( ! ( seg_desc . type & 8 ) ) goto exception ; if ( seg_desc . type & 4 ) { if ( dpl > cpl ) goto exception ; } else { if ( rpl > cpl || dpl != cpl ) goto exception ; } if ( seg_desc . d && seg_desc . l ) { u64 efer = 0 ; ctxt -> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( efer & EFER_LMA ) goto exception ; } selector = ( selector & 0xfffc ) | cpl ; break ; case VCPU_SREG_TR : if ( seg_desc . s || ( seg_desc . type != 1 && seg_desc . type != 9 ) ) goto exception ; old_desc = seg_desc ; seg_desc . type |= 2 ; ret = ctxt -> ops -> cmpxchg_emulated ( ctxt , desc_addr , & old_desc , & seg_desc , sizeof ( seg_desc ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; break ; case VCPU_SREG_LDTR : if ( seg_desc . s || seg_desc . type != 2 ) goto exception ; break ; default : if ( ( seg_desc . type & 0xa ) == 0x8 || ( ( ( seg_desc . type & 0xc ) != 0xc ) && ( rpl > dpl && cpl > dpl ) ) ) goto exception ; break ; } if ( seg_desc . s ) { seg_desc . type |= 1 ; ret = write_segment_descriptor ( ctxt , selector , & seg_desc ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } else if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) { ret = ctxt -> ops -> read_std ( ctxt , desc_addr + 8 , & base3 , sizeof ( base3 ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } load : ctxt -> ops -> set_segment ( ctxt , selector , & seg_desc , base3 , seg ) ; <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ; }
CWE-476 static int tower_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct device * idev = & interface -> dev ; struct usb_device * udev = interface_to_usbdev ( interface ) ; struct lego_usb_tower * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; struct tower_get_version_reply get_version_reply ; int i ; int retval = - ENOMEM ; int result ; dev = kmalloc ( sizeof ( struct lego_usb_tower ) , GFP_KERNEL ) ; if ( ! dev ) goto exit ; mutex_init ( & dev -> lock ) ; dev -> udev = udev ; dev -> open_count = 0 ; dev -> read_buffer = NULL ; dev -> read_buffer_length = 0 ; dev -> read_packet_length = 0 ; spin_lock_init ( & dev -> read_buffer_lock ) ; dev -> packet_timeout_jiffies = msecs_to_jiffies ( packet_timeout ) ; dev -> read_last_arrival = jiffies ; init_waitqueue_head ( & dev -> read_wait ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> interrupt_in_buffer = NULL ; dev -> interrupt_in_endpoint = NULL ; dev -> interrupt_in_urb = NULL ; dev -> interrupt_in_running = 0 ; dev -> interrupt_in_done = 0 ; dev -> interrupt_out_buffer = NULL ; dev -> interrupt_out_endpoint = NULL ; dev -> interrupt_out_urb = NULL ; dev -> interrupt_out_busy = 0 ; iface_desc = interface -> cur_altsetting ; for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_xfer_int ( endpoint ) ) { if ( usb_endpoint_dir_in ( endpoint ) ) dev -> interrupt_in_endpoint = endpoint ; else dev -> interrupt_out_endpoint = endpoint ; } } if ( dev -> interrupt_in_endpoint == NULL ) { dev_err ( idev , "interrupt<S2SV_blank>in<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n" ) ; goto error ; } if ( dev -> interrupt_out_endpoint == NULL ) { dev_err ( idev , "interrupt<S2SV_blank>out<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n" ) ; goto error ; } dev -> read_buffer = kmalloc ( read_buffer_size , GFP_KERNEL ) ; if ( ! dev -> read_buffer ) goto error ; dev -> interrupt_in_buffer = kmalloc ( usb_endpoint_maxp ( dev -> interrupt_in_endpoint ) , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_buffer ) goto error ; dev -> interrupt_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_in_urb ) goto error ; dev -> interrupt_out_buffer = kmalloc ( write_buffer_size , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_buffer ) goto error ; dev -> interrupt_out_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! dev -> interrupt_out_urb ) goto error ; dev -> interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev -> interrupt_in_endpoint -> bInterval ; dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ; <S2SV_StartBug> usb_set_intfdata ( interface , dev ) ; <S2SV_EndBug> retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>" "%d<S2SV_blank>minor<S2SV_blank>%d\\n" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ; result = usb_control_msg ( udev , usb_rcvctrlpipe ( udev , 0 ) , LEGO_USB_TOWER_REQUEST_GET_VERSION , USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE , 0 , 0 , & get_version_reply , sizeof ( get_version_reply ) , 1000 ) ; if ( result < 0 ) { dev_err ( idev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>get<S2SV_blank>version<S2SV_blank>control<S2SV_blank>request<S2SV_blank>failed\\n" ) ; retval = result ; goto error ; } dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>firmware<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d<S2SV_blank>" "build<S2SV_blank>%d\\n" , get_version_reply . major , get_version_reply . minor , le16_to_cpu ( get_version_reply . build_no ) ) ; <S2SV_StartBug> exit : <S2SV_EndBug> return retval ; error : tower_delete ( dev ) ; return retval ; }
CWE-20 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , "nreslevels<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> if ( c -> nreslevels < s -> reduction_factor ) <S2SV_EndBug> <S2SV_StartBug> c -> nreslevels2decode = 1 ; <S2SV_EndBug> else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , "cblk<S2SV_blank>size<S2SV_blank>invalid\\n" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , "cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , "extra<S2SV_blank>cblk<S2SV_blank>styles<S2SV_blank>%X\\n" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC ) { int i ; for ( i = 0 ; i < c -> nreslevels ; i ++ ) { byte = bytestream2_get_byte ( & s -> g ) ; c -> log2_prec_widths [ i ] = byte & 0x0F ; c -> log2_prec_heights [ i ] = ( byte >> 4 ) & 0x0F ; } } else { memset ( c -> log2_prec_widths , 15 , sizeof ( c -> log2_prec_widths ) ) ; memset ( c -> log2_prec_heights , 15 , sizeof ( c -> log2_prec_heights ) ) ; } return 0 ; }
CWE-476 static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }
CWE-119 int vp9_rc_pick_q_and_bounds ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { int q ; <S2SV_StartBug> if ( cpi -> pass == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) <S2SV_EndBug> q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ; else q = rc_pick_q_and_bounds_one_pass_vbr ( cpi , bottom_index , top_index ) ; } else { q = rc_pick_q_and_bounds_two_pass ( cpi , bottom_index , top_index ) ; } if ( cpi -> sf . use_nonrd_pick_mode ) { <S2SV_StartBug> if ( q == 0 ) <S2SV_EndBug> q ++ ; if ( cpi -> sf . force_frame_boost == 1 ) q -= cpi -> sf . max_delta_qindex ; if ( q < * bottom_index ) * bottom_index = q ; else if ( q > * top_index ) * top_index = q ; } return q ; }
CWE-476 static OM_uint32 acc_ctx_cont ( OM_uint32 * minstat , gss_buffer_t buf , gss_ctx_id_t * ctx , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 ret , tmpmin ; gss_OID supportedMech ; spnego_gss_ctx_id_t sc ; unsigned int len ; unsigned char * ptr , * bufstart ; sc = ( spnego_gss_ctx_id_t ) * ctx ; ret = GSS_S_DEFECTIVE_TOKEN ; * negState = REJECT ; * minstat = 0 ; supportedMech = GSS_C_NO_OID ; * return_token = ERROR_TOKEN_SEND ; * responseToken = * mechListMIC = GSS_C_NO_BUFFER ; ptr = bufstart = buf -> value ; # define REMAIN ( buf -> length - ( ptr - bufstart ) ) <S2SV_StartBug> if ( REMAIN > INT_MAX ) <S2SV_EndBug> return GSS_S_DEFECTIVE_TOKEN ; if ( * ptr == HEADER_ID ) { ret = g_verify_token_header ( gss_mech_spnego , & len , & ptr , 0 , REMAIN ) ; if ( ret ) { * minstat = ret ; return GSS_S_DEFECTIVE_TOKEN ; } } if ( * ptr != ( CONTEXT | 0x01 ) ) { return GSS_S_DEFECTIVE_TOKEN ; } ret = get_negTokenResp ( minstat , ptr , REMAIN , negState , & supportedMech , responseToken , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; if ( * responseToken == GSS_C_NO_BUFFER && * mechListMIC == GSS_C_NO_BUFFER ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } if ( supportedMech != GSS_C_NO_OID ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } sc -> firstpass = 0 ; * negState = ACCEPT_INCOMPLETE ; * return_token = CONT_TOKEN_SEND ; cleanup : if ( supportedMech != GSS_C_NO_OID ) { generic_gss_release_oid ( & tmpmin , & supportedMech ) ; } return ret ; # undef REMAIN }
CWE-284 static void * btif_hh_poll_event_thread ( void * arg ) { btif_hh_device_t * p_dev = arg ; APPL_TRACE_DEBUG ( "%s:<S2SV_blank>Thread<S2SV_blank>created<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d" , __FUNCTION__ , p_dev -> fd ) ; struct pollfd pfds [ 1 ] ; int ret ; pfds [ 0 ] . fd = p_dev -> fd ; pfds [ 0 ] . events = POLLIN ; uhid_set_non_blocking ( p_dev -> fd ) ; while ( p_dev -> hh_keep_polling ) { <S2SV_StartBug> ret = poll ( pfds , 1 , 50 ) ; <S2SV_EndBug> if ( ret < 0 ) { APPL_TRACE_ERROR ( "%s:<S2SV_blank>Cannot<S2SV_blank>poll<S2SV_blank>for<S2SV_blank>fds:<S2SV_blank>%s\\n" , __FUNCTION__ , strerror ( errno ) ) ; break ; } if ( pfds [ 0 ] . revents & POLLIN ) { APPL_TRACE_DEBUG ( "btif_hh_poll_event_thread:<S2SV_blank>POLLIN" ) ; ret = uhid_event ( p_dev ) ; if ( ret ) { break ; } } } p_dev -> hh_poll_thread_id = - 1 ; return 0 ; }
CWE-189 static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , "copy_from_user<S2SV_blank>error\\n" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; <S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , "usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n" , status ) ; <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> } else { status = count ; } <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }
CWE-125 static int jpc_pi_nextpcrl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <S2SV_StartBug> xstep = picomp -> hsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; <S2SV_StartBug> ystep = picomp -> vsamp * ( 1 << <S2SV_EndBug> ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
CWE-119 int vp9_compute_qdelta_by_rate ( const RATE_CONTROL * rc , FRAME_TYPE frame_type , <S2SV_StartBug> int qindex , double rate_target_ratio ) { <S2SV_EndBug> int target_index = rc -> worst_quality ; int i ; <S2SV_StartBug> const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 ) ; <S2SV_EndBug> const int target_bits_per_mb = ( int ) ( rate_target_ratio * base_bits_per_mb ) ; for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { <S2SV_StartBug> target_index = i ; <S2SV_EndBug> <S2SV_StartBug> if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 ) <= target_bits_per_mb ) <S2SV_EndBug> break ; } return target_index - qindex ; }
CWE-119 <S2SV_StartBug> static void read_inter_mode_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) { <S2SV_EndBug> int i , j ; for ( i = 0 ; i < INTER_MODE_CONTEXTS ; ++ i ) for ( j = 0 ; j < INTER_MODES - 1 ; ++ j ) vp9_diff_update_prob ( r , & fc -> inter_mode_probs [ i ] [ j ] ) ; }
CWE-476 static int jp2_cmap_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cmap_t * cmap = & box -> data . cmap ; jp2_cmapent_t * ent ; <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> cmap -> numchans = ( box -> datalen ) / 4 ; if ( ! ( cmap -> ents = jas_alloc2 ( cmap -> numchans , sizeof ( jp2_cmapent_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < cmap -> numchans ; ++ i ) { ent = & cmap -> ents [ i ] ; if ( jp2_getuint16 ( in , & ent -> cmptno ) || jp2_getuint8 ( in , & ent -> map ) || jp2_getuint8 ( in , & ent -> pcol ) ) { return - 1 ; } } return 0 ; }
CWE-119 static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ; <S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }
CWE-000 static int read_tfra ( MOVContext * mov , AVIOContext * f ) { MOVFragmentIndex * index = NULL ; int version , fieldlength , i , j ; int64_t pos = avio_tell ( f ) ; uint32_t size = avio_rb32 ( f ) ; void * tmp ; if ( avio_rb32 ( f ) != MKBETAG ( 't' , 'f' , 'r' , 'a' ) ) { return 1 ; } av_log ( mov -> fc , AV_LOG_VERBOSE , "found<S2SV_blank>tfra\\n" ) ; index = av_mallocz ( sizeof ( MOVFragmentIndex ) ) ; if ( ! index ) { return AVERROR ( ENOMEM ) ; } tmp = av_realloc_array ( mov -> fragment_index_data , mov -> fragment_index_count + 1 , sizeof ( MOVFragmentIndex * ) ) ; if ( ! tmp ) { av_freep ( & index ) ; return AVERROR ( ENOMEM ) ; } mov -> fragment_index_data = tmp ; mov -> fragment_index_data [ mov -> fragment_index_count ++ ] = index ; version = avio_r8 ( f ) ; avio_rb24 ( f ) ; index -> track_id = avio_rb32 ( f ) ; fieldlength = avio_rb32 ( f ) ; index -> item_count = avio_rb32 ( f ) ; index -> items = av_mallocz_array ( index -> item_count , sizeof ( MOVFragmentIndexItem ) ) ; if ( ! index -> items ) { index -> item_count = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < index -> item_count ; i ++ ) { <S2SV_StartBug> int64_t time , offset ; <S2SV_EndBug> if ( version == 1 ) { time = avio_rb64 ( f ) ; offset = avio_rb64 ( f ) ; } else { time = avio_rb32 ( f ) ; offset = avio_rb32 ( f ) ; } index -> items [ i ] . time = time ; index -> items [ i ] . moof_offset = offset ; for ( j = 0 ; j < ( ( fieldlength >> 4 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 2 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; for ( j = 0 ; j < ( ( fieldlength >> 0 ) & 3 ) + 1 ; j ++ ) avio_r8 ( f ) ; } avio_seek ( f , pos + size , SEEK_SET ) ; return 0 ; }
CWE-000 static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } source [ nread ] = '\\0' ; plen -= nread ; <S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( openreply , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; error : if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_OPEN , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } return 0 ; }
CWE-119 EAS_BOOL WT_CheckSampleEnd ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame , EAS_BOOL update ) { EAS_U32 endPhaseAccum ; EAS_U32 endPhaseFrac ; EAS_I32 numSamples ; EAS_BOOL done = EAS_FALSE ; endPhaseFrac = pWTVoice -> phaseFrac + ( pWTIntFrame -> frame . phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS ) ; endPhaseAccum = pWTVoice -> phaseAccum + GET_PHASE_INT_PART ( endPhaseFrac ) ; if ( endPhaseAccum >= pWTVoice -> loopEnd ) { numSamples = ( EAS_I32 ) ( pWTVoice -> loopEnd - pWTVoice -> phaseAccum ) ; numSamples = ( EAS_I32 ) ( ( numSamples << NUM_PHASE_FRAC_BITS ) - pWTVoice -> phaseFrac ) ; if ( pWTIntFrame -> frame . phaseIncrement ) { pWTIntFrame -> numSamples = 1 + ( numSamples / pWTIntFrame -> frame . phaseIncrement ) ; } else { pWTIntFrame -> numSamples = numSamples ; } <S2SV_StartBug> done = EAS_TRUE ; <S2SV_EndBug> } if ( update ) { pWTVoice -> phaseFrac = endPhaseFrac ; pWTVoice -> phaseAccum = endPhaseAccum ; } return done ; }
CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { # if CONFIG_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; # else <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> # endif }
CWE-476 unsigned int ip6t_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = NF_DROP ; const char * indev , * outdev ; const void * table_base ; struct ip6t_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; stackidx = 0 ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; acpar . hotdrop = false ; acpar . state = state ; WARN_ON ( ! ( table -> valid_hooks & ( 1 << hook ) ) ) ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct ip6t_entry * * ) private -> jumpstack [ cpu ] ; if ( static_key_false ( & xt_tee_enabled ) ) jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ) ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; do { const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; struct xt_counters * counter ; WARN_ON ( ! e ) ; acpar . thoff = 0 ; if ( ! ip6_packet_match ( skb , indev , outdev , & e -> ipv6 , & acpar . thoff , & acpar . fragoff , & acpar . hotdrop ) ) { no_match : e = ip6t_next_entry ( e ) ; continue ; } xt_ematch_foreach ( ematch , e ) { acpar . match = ematch -> u . kernel . match ; acpar . matchinfo = ematch -> data ; if ( ! acpar . match -> match ( skb , & acpar ) ) goto no_match ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , skb -> len , 1 ) ; t = ip6t_get_target_c ( e ) ; WARN_ON ( ! t -> u . kernel . target ) ; # if IS_ENABLED ( CONFIG_NETFILTER_XT_TARGET_TRACE ) if ( unlikely ( skb -> nf_trace ) ) trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ) ; # endif if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) e = get_entry ( table_base , private -> underflow [ hook ] ) ; else e = ip6t_next_entry ( jumpstack [ -- stackidx ] ) ; continue ; } if ( table_base + v != ip6t_next_entry ( e ) && ! ( e -> ipv6 . flags & IP6T_F_GOTO ) ) { <S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) e = ip6t_next_entry ( e ) ; else break ; } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }
CWE-416 static ssize_t ucma_process_join ( struct ucma_file * file , struct rdma_ucm_join_mcast * cmd , int out_len ) { struct rdma_ucm_create_id_resp resp ; struct ucma_context * ctx ; struct ucma_multicast * mc ; struct sockaddr * addr ; int ret ; u8 join_state ; if ( out_len < sizeof ( resp ) ) return - ENOSPC ; addr = ( struct sockaddr * ) & cmd -> addr ; if ( cmd -> addr_size != rdma_addr_size ( addr ) ) return - EINVAL ; if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER ) join_state = BIT ( FULLMEMBER_JOIN ) ; else if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER ) join_state = BIT ( SENDONLY_FULLMEMBER_JOIN ) ; else return - EINVAL ; ctx = ucma_get_ctx_dev ( file , cmd -> id ) ; if ( IS_ERR ( ctx ) ) return PTR_ERR ( ctx ) ; mutex_lock ( & file -> mut ) ; mc = ucma_alloc_multicast ( ctx ) ; if ( ! mc ) { ret = - ENOMEM ; goto err1 ; } mc -> join_state = join_state ; mc -> uid = cmd -> uid ; memcpy ( & mc -> addr , addr , cmd -> addr_size ) ; ret = rdma_join_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr , join_state , mc ) ; if ( ret ) goto err2 ; resp . id = mc -> id ; if ( copy_to_user ( u64_to_user_ptr ( cmd -> response ) , & resp , sizeof ( resp ) ) ) { ret = - EFAULT ; goto err3 ; } <S2SV_StartBug> mutex_unlock ( & file -> mut ) ; <S2SV_EndBug> ucma_put_ctx ( ctx ) ; return 0 ; err3 : rdma_leave_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr ) ; ucma_cleanup_mc_events ( mc ) ; err2 : mutex_lock ( & mut ) ; idr_remove ( & multicast_idr , mc -> id ) ; mutex_unlock ( & mut ) ; list_del ( & mc -> list ) ; kfree ( mc ) ; err1 : mutex_unlock ( & file -> mut ) ; ucma_put_ctx ( ctx ) ; return ret ; }
CWE-000 static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }
CWE-362 int rds_sendmsg ( struct socket * sock , struct msghdr * msg , size_t payload_len ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; __be32 daddr ; __be16 dport ; struct rds_message * rm = NULL ; struct rds_connection * conn ; int ret = 0 ; int queued = 0 , allocated_mr = 0 ; int nonblock = msg -> msg_flags & MSG_DONTWAIT ; long timeo = sock_sndtimeo ( sk , nonblock ) ; if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( msg -> msg_namelen ) { if ( msg -> msg_namelen < sizeof ( * usin ) || usin -> sin_family != AF_INET ) { ret = - EINVAL ; goto out ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; } else { lock_sock ( sk ) ; daddr = rs -> rs_conn_addr ; dport = rs -> rs_conn_port ; release_sock ( sk ) ; } <S2SV_StartBug> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ret = - ENOTCONN ; <S2SV_EndBug> goto out ; <S2SV_StartBug> } <S2SV_EndBug> if ( payload_len > rds_sk_sndbuf ( rs ) ) { ret = - EMSGSIZE ; goto out ; } ret = rds_rm_size ( msg , payload_len ) ; if ( ret < 0 ) goto out ; rm = rds_message_alloc ( ret , GFP_KERNEL ) ; if ( ! rm ) { ret = - ENOMEM ; goto out ; } if ( payload_len ) { rm -> data . op_sg = rds_message_alloc_sgs ( rm , ceil ( payload_len , PAGE_SIZE ) ) ; if ( ! rm -> data . op_sg ) { ret = - ENOMEM ; goto out ; } ret = rds_message_copy_from_user ( rm , & msg -> msg_iter ) ; if ( ret ) goto out ; } rm -> data . op_active = 1 ; rm -> m_daddr = daddr ; if ( rs -> rs_conn && rs -> rs_conn -> c_faddr == daddr ) conn = rs -> rs_conn ; else { conn = rds_conn_create_outgoing ( sock_net ( sock -> sk ) , rs -> rs_bound_addr , daddr , rs -> rs_transport , sock -> sk -> sk_allocation ) ; if ( IS_ERR ( conn ) ) { ret = PTR_ERR ( conn ) ; goto out ; } rs -> rs_conn = conn ; } ret = rds_cmsg_send ( rs , rm , msg , & allocated_mr ) ; if ( ret ) goto out ; if ( rm -> rdma . op_active && ! conn -> c_trans -> xmit_rdma ) { printk_ratelimited ( KERN_NOTICE "rdma_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_rdma<S2SV_blank>%p\\n" , & rm -> rdma , conn -> c_trans -> xmit_rdma ) ; ret = - EOPNOTSUPP ; goto out ; } if ( rm -> atomic . op_active && ! conn -> c_trans -> xmit_atomic ) { printk_ratelimited ( KERN_NOTICE "atomic_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_atomic<S2SV_blank>%p\\n" , & rm -> atomic , conn -> c_trans -> xmit_atomic ) ; ret = - EOPNOTSUPP ; goto out ; } rds_conn_connect_if_down ( conn ) ; ret = rds_cong_wait ( conn -> c_fcong , dport , nonblock , rs ) ; if ( ret ) { rs -> rs_seen_congestion = 1 ; goto out ; } while ( ! rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) ) { rds_stats_inc ( s_send_queue_full ) ; if ( nonblock ) { ret = - EAGAIN ; goto out ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) , timeo ) ; rdsdebug ( "sendmsg<S2SV_blank>woke<S2SV_blank>queued<S2SV_blank>%d<S2SV_blank>timeo<S2SV_blank>%ld\\n" , queued , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; goto out ; } rds_stats_inc ( s_send_queued ) ; ret = rds_send_xmit ( conn ) ; if ( ret == - ENOMEM || ret == - EAGAIN ) queue_delayed_work ( rds_wq , & conn -> c_send_w , 1 ) ; rds_message_put ( rm ) ; return payload_len ; out : if ( allocated_mr ) rds_rdma_unuse ( rs , rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , 1 ) ; if ( rm ) rds_message_put ( rm ) ; return ret ; }
CWE-000 static gboolean _handle_carbons ( xmpp_stanza_t * const stanza ) { xmpp_stanza_t * carbons = xmpp_stanza_get_child_by_ns ( stanza , STANZA_NS_CARBONS ) ; if ( ! carbons ) { return FALSE ; } const char * name = xmpp_stanza_get_name ( carbons ) ; if ( ! name ) { log_error ( "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>stanza<S2SV_blank>name<S2SV_blank>for<S2SV_blank>Carbon" ) ; return TRUE ; } if ( g_strcmp0 ( name , "private" ) == 0 ) { log_info ( "Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>private<S2SV_blank>element." ) ; return FALSE ; } if ( ( g_strcmp0 ( name , "received" ) != 0 ) && ( g_strcmp0 ( name , "sent" ) != 0 ) ) { log_warning ( "Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>unrecognised<S2SV_blank>stanza<S2SV_blank>name:<S2SV_blank>%s" , name ) ; return TRUE ; } xmpp_stanza_t * forwarded = xmpp_stanza_get_child_by_ns ( carbons , STANZA_NS_FORWARD ) ; if ( ! forwarded ) { log_warning ( "Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>forwarded<S2SV_blank>element" ) ; return TRUE ; } xmpp_stanza_t * message = xmpp_stanza_get_child_by_name ( forwarded , STANZA_NAME_MESSAGE ) ; if ( ! message ) { log_warning ( "Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message<S2SV_blank>element" ) ; return TRUE ; } char * message_txt = xmpp_message_get_body ( message ) ; if ( ! message_txt ) { log_warning ( "Carbon<S2SV_blank>received<S2SV_blank>with<S2SV_blank>no<S2SV_blank>message." ) ; return TRUE ; } <S2SV_StartBug> const gchar * to = xmpp_stanza_get_to ( message ) ; <S2SV_EndBug> const gchar * from = xmpp_stanza_get_from ( message ) ; if ( ! to ) to = from ; Jid * jid_from = jid_create ( from ) ; <S2SV_StartBug> Jid * jid_to = jid_create ( to ) ; <S2SV_EndBug> Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; char * enc_message = NULL ; xmpp_stanza_t * x = xmpp_stanza_get_child_by_ns ( message , STANZA_NS_ENCRYPTED ) ; if ( x ) { enc_message = xmpp_stanza_get_text ( x ) ; } if ( g_strcmp0 ( my_jid -> barejid , jid_to -> barejid ) == 0 ) { sv_ev_incoming_carbon ( jid_from -> barejid , jid_from -> resourcepart , message_txt , enc_message ) ; } else { sv_ev_outgoing_carbon ( jid_to -> barejid , message_txt , enc_message ) ; } xmpp_ctx_t * ctx = connection_get_ctx ( ) ; xmpp_free ( ctx , message_txt ) ; xmpp_free ( ctx , enc_message ) ; jid_destroy ( jid_from ) ; jid_destroy ( jid_to ) ; jid_destroy ( my_jid ) ; return TRUE ; }
CWE-119 void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( "mvs.stt" , "a" ) ; mb_index = 0 ; fprintf ( mvs , "Mb<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , "%2d<S2SV_blank>" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , "\\n" ) ; mb_index ++ ; } fprintf ( mvs , "\\n" ) ; mb_index = 0 ; fprintf ( mvs , "Mb<S2SV_blank>mv<S2SV_blank>ref<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , "%2d<S2SV_blank>" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , "\\n" ) ; mb_index ++ ; } fprintf ( mvs , "\\n" ) ; mb_index = 0 ; fprintf ( mvs , "UV<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , "%2d<S2SV_blank>" , mi [ mb_index ] . mbmi . uv_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , "\\n" ) ; } <S2SV_StartBug> fprintf ( mvs , "\\n" ) ; <S2SV_EndBug> mb_index = 0 ; fprintf ( mvs , "Mbs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; if ( mi [ mb_index ] . mbmi . mode == B_PRED ) fprintf ( mvs , "%2d<S2SV_blank>" , mi [ mb_index ] . bmi [ bindex ] . as_mode ) ; else fprintf ( mvs , "xx<S2SV_blank>" ) ; } fprintf ( mvs , "\\n" ) ; } } fprintf ( mvs , "\\n" ) ; mb_index = 0 ; fprintf ( mvs , "MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , "%5d:%-5d" , mi [ mb_index ] . mbmi . mv . as_mv . row / 2 , mi [ mb_index ] . mbmi . mv . as_mv . col / 2 ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , "\\n" ) ; } fprintf ( mvs , "\\n" ) ; <S2SV_StartBug> mb_index = 0 ; <S2SV_EndBug> fprintf ( mvs , "MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; fprintf ( mvs , "%3d:%-3d<S2SV_blank>" , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . row , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . col ) ; } fprintf ( mvs , "\\n" ) ; } } fprintf ( mvs , "\\n" ) ; fclose ( mvs ) ; }
CWE-264 static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }
CWE-20 int mk_request_error ( int http_status , struct client_session * cs , struct session_request * sr ) { int ret , fd ; mk_ptr_t message , * page = 0 ; struct error_page * entry ; struct mk_list * head ; struct file_info finfo ; mk_header_set_http_status ( sr , http_status ) ; if ( http_status != MK_CLIENT_LENGTH_REQUIRED && http_status != MK_CLIENT_BAD_REQUEST && http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE ) { mk_list_foreach ( head , & sr -> host_conf -> error_pages ) { entry = mk_list_entry ( head , struct error_page , _head ) ; if ( entry -> status != http_status ) { continue ; } ret = mk_file_get_info ( entry -> real_path , & finfo ) ; if ( ret == - 1 ) { break ; } fd = open ( entry -> real_path , config -> open_flags ) ; if ( fd == - 1 ) { break ; } sr -> fd_file = fd ; <S2SV_StartBug> sr -> bytes_to_send = finfo . size ; <S2SV_EndBug> sr -> headers . content_length = finfo . size ; sr -> headers . real_length = finfo . size ; memcpy ( & sr -> file_info , & finfo , sizeof ( struct file_info ) ) ; mk_header_send ( cs -> socket , cs , sr ) ; return mk_http_send_file ( cs , sr ) ; } } mk_ptr_reset ( & message ) ; switch ( http_status ) { case MK_CLIENT_BAD_REQUEST : page = mk_request_set_default_page ( "Bad<S2SV_blank>Request" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_CLIENT_FORBIDDEN : page = mk_request_set_default_page ( "Forbidden" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_CLIENT_NOT_FOUND : mk_string_build ( & message . data , & message . len , "The<S2SV_blank>requested<S2SV_blank>URL<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found<S2SV_blank>on<S2SV_blank>this<S2SV_blank>server." ) ; page = mk_request_set_default_page ( "Not<S2SV_blank>Found" , message , sr -> host_conf -> host_signature ) ; mk_ptr_free ( & message ) ; break ; case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE : mk_string_build ( & message . data , & message . len , "The<S2SV_blank>request<S2SV_blank>entity<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large." ) ; page = mk_request_set_default_page ( "Entity<S2SV_blank>too<S2SV_blank>large" , message , sr -> host_conf -> host_signature ) ; mk_ptr_free ( & message ) ; break ; case MK_CLIENT_METHOD_NOT_ALLOWED : page = mk_request_set_default_page ( "Method<S2SV_blank>Not<S2SV_blank>Allowed" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_CLIENT_REQUEST_TIMEOUT : case MK_CLIENT_LENGTH_REQUIRED : break ; case MK_SERVER_NOT_IMPLEMENTED : page = mk_request_set_default_page ( "Method<S2SV_blank>Not<S2SV_blank>Implemented" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_SERVER_INTERNAL_ERROR : page = mk_request_set_default_page ( "Internal<S2SV_blank>Server<S2SV_blank>Error" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_SERVER_HTTP_VERSION_UNSUP : mk_ptr_reset ( & message ) ; page = mk_request_set_default_page ( "HTTP<S2SV_blank>Version<S2SV_blank>Not<S2SV_blank>Supported" , message , sr -> host_conf -> host_signature ) ; break ; } if ( page ) { sr -> headers . content_length = page -> len ; } sr -> headers . location = NULL ; sr -> headers . cgi = SH_NOCGI ; sr -> headers . pconnections_left = 0 ; sr -> headers . last_modified = - 1 ; if ( ! page ) { mk_ptr_reset ( & sr -> headers . content_type ) ; } else { mk_ptr_set ( & sr -> headers . content_type , "text/html\\r\\n" ) ; } mk_header_send ( cs -> socket , cs , sr ) ; if ( page ) { if ( sr -> method != MK_HTTP_METHOD_HEAD ) mk_socket_send ( cs -> socket , page -> data , page -> len ) ; mk_ptr_free ( page ) ; mk_mem_free ( page ) ; } mk_server_cork_flag ( cs -> socket , TCP_CORK_OFF ) ; return EXIT_ERROR ; }
CWE-119 const char * vpx_svc_get_message ( const SvcContext * svc_ctx ) { <S2SV_StartBug> const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || si == NULL ) return NULL ; return si -> message_buffer ; }
CWE-125 static VarLenData * * get_html_data ( MAPI_Attr * a ) { VarLenData * * body = XCALLOC ( VarLenData * , a -> num_values + 1 ) ; int j ; for ( j = 0 ; j < a -> num_values ; j ++ ) <S2SV_StartBug> { <S2SV_EndBug> body [ j ] = XMALLOC ( VarLenData , 1 ) ; body [ j ] -> len = a -> values [ j ] . len ; body [ j ] -> data = CHECKED_XCALLOC ( unsigned char , a -> values [ j ] . len ) ; memmove ( body [ j ] -> data , a -> values [ j ] . data . buf , body [ j ] -> len ) ; } <S2SV_StartBug> return body ; <S2SV_EndBug> }
CWE-476 BOOL security_decrypt ( BYTE * data , int length , rdpRdp * rdp ) <S2SV_StartBug> { <S2SV_EndBug> if ( rdp -> decrypt_use_count >= 4096 ) { security_key_update ( rdp -> decrypt_key , rdp -> decrypt_update_key , rdp -> rc4_key_len ) ; crypto_rc4_free ( rdp -> rc4_decrypt_key ) ; rdp -> rc4_decrypt_key = crypto_rc4_init ( rdp -> decrypt_key , rdp -> rc4_key_len ) ; rdp -> decrypt_use_count = 0 ; } crypto_rc4 ( rdp -> rc4_decrypt_key , length , data , data ) ; rdp -> decrypt_use_count += 1 ; rdp -> decrypt_checksum_use_count ++ ; return TRUE ; }
CWE-000 static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , "params<S2SV_blank>=<S2SV_blank>" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , "\\n" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( "value" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , "arguments" , sizeof ( "arguments" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_index_update ( params , hkey . num , ( void * ) & tmp , sizeof ( zval * ) , ( void * ) & ptr ) ; } } else { if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_find ( params , hkey . str , hkey . len , ( void * ) & ptr ) ; } else { zend_hash_index_find ( params , hkey . num , ( void * ) & ptr ) ; } zdata_ptr = & zdata ; if ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , "value" , sizeof ( "value" ) , ( void * ) & ptr ) && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & zdata_ptr ) ) { zval * * test_ptr ; while ( Z_TYPE_PP ( zdata_ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( zdata_ptr ) , ( void * ) & test_ptr ) ) { <S2SV_StartBug> if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY ) { <S2SV_EndBug> if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { if ( SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } else { if ( SUCCESS == zend_hash_index_find ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) & ptr ) ) { zdata_ptr = test_ptr ; } else if ( hkey . num ) { Z_ADDREF_PP ( test_ptr ) ; zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } else { Z_ADDREF_PP ( test_ptr ) ; zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; break ; } } } else { Z_ADDREF_PP ( test_ptr ) ; if ( Z_TYPE_PP ( ptr ) != IS_ARRAY ) { zval_dtor ( * ptr ) ; array_init ( * ptr ) ; } if ( HASH_KEY_IS_STRING == zend_hash_get_current_key_ex ( Z_ARRVAL_PP ( zdata_ptr ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ) { zend_hash_update ( Z_ARRVAL_PP ( ptr ) , hkey . str , hkey . len , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else if ( hkey . num ) { zend_hash_index_update ( Z_ARRVAL_PP ( ptr ) , hkey . num , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } else { zend_hash_next_index_insert ( Z_ARRVAL_PP ( ptr ) , ( void * ) test_ptr , sizeof ( zval * ) , ( void * ) & ptr ) ; } break ; } } } } while ( Z_TYPE_PP ( ptr ) == IS_ARRAY && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ) , ( void * ) & ptr ) ) ; * current_param = ptr ; }
CWE-476 rdpCredssp * credssp_new ( freerdp * instance , rdpTransport * transport , rdpSettings * settings ) { rdpCredssp * credssp ; credssp = ( rdpCredssp * ) malloc ( sizeof ( rdpCredssp ) ) ; ZeroMemory ( credssp , sizeof ( rdpCredssp ) ) ; if ( credssp != NULL ) { HKEY hKey ; LONG status ; DWORD dwType ; DWORD dwSize ; credssp -> instance = instance ; credssp -> settings = settings ; credssp -> server = settings -> ServerMode ; credssp -> transport = transport ; credssp -> send_seq_num = 0 ; credssp -> recv_seq_num = 0 ; ZeroMemory ( & credssp -> negoToken , sizeof ( SecBuffer ) ) ; ZeroMemory ( & credssp -> pubKeyAuth , sizeof ( SecBuffer ) ) ; <S2SV_StartBug> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <S2SV_EndBug> if ( credssp -> server ) { status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( "Software\\\\FreeRDP\\\\Server" ) , 0 , KEY_READ | KEY_WOW64_64KEY , & hKey ) ; if ( status == ERROR_SUCCESS ) { status = RegQueryValueEx ( hKey , _T ( "SspiModule" ) , NULL , & dwType , NULL , & dwSize ) ; if ( status == ERROR_SUCCESS ) { credssp -> SspiModule = ( LPTSTR ) malloc ( dwSize + sizeof ( TCHAR ) ) ; status = RegQueryValueEx ( hKey , _T ( "SspiModule" ) , NULL , & dwType , ( BYTE * ) credssp -> SspiModule , & dwSize ) ; if ( status == ERROR_SUCCESS ) { _tprintf ( _T ( "Using<S2SV_blank>SSPI<S2SV_blank>Module:<S2SV_blank>%s\\n" ) , credssp -> SspiModule ) ; RegCloseKey ( hKey ) ; } } } } } return credssp ; }
CWE-476 static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }
CWE-284 static void uipc_flush_ch_locked ( tUIPC_CH_ID ch_id ) { char buf [ UIPC_FLUSH_BUFFER_SIZE ] ; struct pollfd pfd ; int ret ; pfd . events = POLLIN ; pfd . fd = uipc_main . ch [ ch_id ] . fd ; if ( uipc_main . ch [ ch_id ] . fd == UIPC_DISCONNECTED ) { BTIF_TRACE_EVENT ( "%s()<S2SV_blank>-<S2SV_blank>fd<S2SV_blank>disconnected.<S2SV_blank>Exiting" , __FUNCTION__ ) ; return ; } while ( 1 ) { <S2SV_StartBug> ret = poll ( & pfd , 1 , 1 ) ; <S2SV_EndBug> BTIF_TRACE_VERBOSE ( "%s()<S2SV_blank>-<S2SV_blank>polling<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>revents:<S2SV_blank>0x%x,<S2SV_blank>ret<S2SV_blank>%d" , __FUNCTION__ , pfd . fd , pfd . revents , ret ) ; if ( pfd . revents & ( POLLERR | POLLHUP ) ) { BTIF_TRACE_EVENT ( "%s()<S2SV_blank>-<S2SV_blank>POLLERR<S2SV_blank>or<S2SV_blank>POLLHUP.<S2SV_blank>Exiting" , __FUNCTION__ ) ; return ; } if ( ret <= 0 ) { BTIF_TRACE_EVENT ( "%s()<S2SV_blank>-<S2SV_blank>error<S2SV_blank>(%d).<S2SV_blank>Exiting" , __FUNCTION__ , ret ) ; return ; } <S2SV_StartBug> read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ; <S2SV_EndBug> } }
CWE-000 void bpf_int_jit_compile ( struct bpf_prog * prog ) { struct bpf_binary_header * header = NULL ; int proglen , oldproglen = 0 ; struct jit_context ctx = { } ; u8 * image = NULL ; int * addrs ; int pass ; int i ; if ( ! bpf_jit_enable ) return ; if ( ! prog || ! prog -> len ) return ; addrs = kmalloc ( prog -> len * sizeof ( * addrs ) , GFP_KERNEL ) ; if ( ! addrs ) return ; for ( proglen = 0 , i = 0 ; i < prog -> len ; i ++ ) { proglen += 64 ; addrs [ i ] = proglen ; } ctx . cleanup_addr = proglen ; <S2SV_StartBug> for ( pass = 0 ; pass < 10 ; pass ++ ) { <S2SV_EndBug> proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ; if ( proglen <= 0 ) { image = NULL ; if ( header ) bpf_jit_binary_free ( header ) ; goto out ; } if ( image ) { if ( proglen != oldproglen ) { pr_err ( "bpf_jit:<S2SV_blank>proglen=%d<S2SV_blank>!=<S2SV_blank>oldproglen=%d\\n" , proglen , oldproglen ) ; goto out ; } break ; } if ( proglen == oldproglen ) { header = bpf_jit_binary_alloc ( proglen , & image , 1 , jit_fill_hole ) ; if ( ! header ) goto out ; } oldproglen = proglen ; } if ( bpf_jit_enable > 1 ) bpf_jit_dump ( prog -> len , proglen , 0 , image ) ; if ( image ) { bpf_flush_icache ( header , image + proglen ) ; set_memory_ro ( ( unsigned long ) header , header -> pages ) ; prog -> bpf_func = ( void * ) image ; prog -> jited = true ; } out : kfree ( addrs ) ; }
CWE-787 static void write_version ( FILE * fp , const char * fname , const char * dirname , xref_t * xref ) { long start ; char * c , * new_fname , data ; FILE * new_fp ; start = ftell ( fp ) ; if ( ( c = strstr ( fname , ".pdf" ) ) ) * c = '\\0' ; <S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , "%s/%s-version-%d.pdf" , dirname , fname , xref -> version ) ; if ( ! ( new_fp = fopen ( new_fname , "w" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , new_fname ) ; fseek ( fp , start , SEEK_SET ) ; free ( new_fname ) ; return ; } fseek ( fp , 0 , SEEK_SET ) ; while ( fread ( & data , 1 , 1 , fp ) ) fwrite ( & data , 1 , 1 , new_fp ) ; fprintf ( new_fp , "\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF" , xref -> start ) ; fclose ( new_fp ) ; free ( new_fname ) ; fseek ( fp , start , SEEK_SET ) ; }
CWE-476 int rds_cmsg_atomic ( struct rds_sock * rs , struct rds_message * rm , struct cmsghdr * cmsg ) { struct page * page = NULL ; struct rds_atomic_args * args ; int ret = 0 ; if ( cmsg -> cmsg_len < CMSG_LEN ( sizeof ( struct rds_atomic_args ) ) || rm -> atomic . op_active ) return - EINVAL ; args = CMSG_DATA ( cmsg ) ; switch ( cmsg -> cmsg_type ) { case RDS_CMSG_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> m_fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = args -> m_fadd . nocarry_mask ; break ; case RDS_CMSG_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = ~ 0 ; rm -> atomic . op_m_cswp . swap_mask = ~ 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> m_cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> m_cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = args -> m_cswp . compare_mask ; rm -> atomic . op_m_cswp . swap_mask = args -> m_cswp . swap_mask ; break ; default : BUG ( ) ; } rm -> atomic . op_notify = ! ! ( args -> flags & RDS_RDMA_NOTIFY_ME ) ; rm -> atomic . op_silent = ! ! ( args -> flags & RDS_RDMA_SILENT ) ; rm -> atomic . op_active = 1 ; rm -> atomic . op_recverr = rs -> rs_recverr ; rm -> atomic . op_sg = rds_message_alloc_sgs ( rm , 1 ) ; if ( ! rm -> atomic . op_sg ) { ret = - ENOMEM ; goto err ; } if ( args -> local_addr & 0x7 ) { ret = - EFAULT ; goto err ; } ret = rds_pin_pages ( args -> local_addr , 1 , & page , 1 ) ; if ( ret != 1 ) goto err ; ret = 0 ; sg_set_page ( rm -> atomic . op_sg , page , 8 , offset_in_page ( args -> local_addr ) ) ; if ( rm -> atomic . op_notify || rm -> atomic . op_recverr ) { rm -> atomic . op_notifier = kmalloc ( sizeof ( * rm -> atomic . op_notifier ) , GFP_KERNEL ) ; if ( ! rm -> atomic . op_notifier ) { ret = - ENOMEM ; goto err ; } rm -> atomic . op_notifier -> n_user_token = args -> user_token ; rm -> atomic . op_notifier -> n_status = RDS_RDMA_SUCCESS ; } rm -> atomic . op_rkey = rds_rdma_cookie_key ( args -> cookie ) ; rm -> atomic . op_remote_addr = args -> remote_addr + rds_rdma_cookie_offset ( args -> cookie ) ; return ret ; err : if ( page ) put_page ( page ) ; <S2SV_StartBug> kfree ( rm -> atomic . op_notifier ) ; <S2SV_EndBug> return ret ; }
CWE-399 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> power_pmu_stop ( event , 0 ) ; } }
CWE-416 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MaxTextExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; pwp_image = AcquireImage ( image_info ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , "SFW95" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , "UnableToWriteFile" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( "SFW94A" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MaxTextExtent , "slide_%02ld.sfw" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "UnexpectedEndOfFile" , "`%s\':<S2SV_blank>%s" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
CWE-284 static inline int btif_hl_close_select_thread ( void ) { int result = 0 ; char sig_on = btif_hl_signal_select_exit ; BTIF_TRACE_DEBUG ( "btif_hl_signal_select_exit" ) ; <S2SV_StartBug> result = send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> if ( btif_is_enabled ( ) ) { if ( select_thread_id != - 1 ) { pthread_join ( select_thread_id , NULL ) ; select_thread_id = - 1 ; } } list_free ( soc_queue ) ; return result ; }
CWE-000 IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice ( dec_state_t * ps_dec ) { UWORD32 i ; yuv_buf_t * ps_cur_frm_buf = & ps_dec -> s_cur_frm_buf ; stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD8 * pu1_vld_buf ; WORD16 i2_dc_diff ; UWORD32 u4_frame_width = ps_dec -> u2_frame_width ; UWORD32 u4_frm_offset = 0 ; if ( ps_dec -> u2_picture_structure != FRAME_PICTURE ) { u4_frame_width <<= 1 ; if ( ps_dec -> u2_picture_structure == BOTTOM_FIELD ) { u4_frm_offset = ps_dec -> u2_frame_width ; } } do { UWORD32 u4_x_offset , u4_y_offset ; UWORD32 u4_blk_pos ; WORD16 i2_dc_val ; UWORD32 u4_dst_x_offset = u4_frm_offset + ( ps_dec -> u2_mb_x << 4 ) ; UWORD32 u4_dst_y_offset = ( ps_dec -> u2_mb_y << 4 ) * u4_frame_width ; UWORD8 * pu1_vld_buf8 = ps_cur_frm_buf -> pu1_y + u4_dst_x_offset + u4_dst_y_offset ; UWORD32 u4_dst_wd = u4_frame_width ; <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , MB_STUFFING_CODE_LEN ) == MB_STUFFING_CODE ) <S2SV_EndBug> impeg2d_bit_stream_flush ( ps_stream , MB_STUFFING_CODE_LEN ) ; impeg2d_bit_stream_flush ( ps_stream , 1 ) ; if ( impeg2d_bit_stream_get ( ps_stream , 1 ) != 0x01 ) { } for ( i = 0 ; i < NUM_LUMA_BLKS ; ++ i ) { u4_x_offset = gai2_impeg2_blk_x_off [ i ] ; u4_y_offset = gai2_impeg2_blk_y_off_frm [ i ] ; u4_blk_pos = ( u4_y_offset * u4_dst_wd ) + u4_x_offset ; pu1_vld_buf = pu1_vld_buf8 + u4_blk_pos ; i2_dc_diff = impeg2d_get_luma_dc_diff ( ps_stream ) ; i2_dc_val = ps_dec -> u2_def_dc_pred [ Y_LUMA ] + i2_dc_diff ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = i2_dc_val ; i2_dc_val = CLIP_U8 ( i2_dc_val ) ; ps_dec -> pf_memset_8bit_8x8_block ( pu1_vld_buf , i2_dc_val , u4_dst_wd ) ; } u4_dst_x_offset >>= 1 ; u4_dst_y_offset >>= 2 ; u4_dst_wd >>= 1 ; pu1_vld_buf = ps_cur_frm_buf -> pu1_u + u4_dst_x_offset + u4_dst_y_offset ; i2_dc_diff = impeg2d_get_chroma_dc_diff ( ps_stream ) ; i2_dc_val = ps_dec -> u2_def_dc_pred [ U_CHROMA ] + i2_dc_diff ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = i2_dc_val ; i2_dc_val = CLIP_U8 ( i2_dc_val ) ; ps_dec -> pf_memset_8bit_8x8_block ( pu1_vld_buf , i2_dc_val , u4_dst_wd ) ; pu1_vld_buf = ps_cur_frm_buf -> pu1_v + u4_dst_x_offset + u4_dst_y_offset ; i2_dc_diff = impeg2d_get_chroma_dc_diff ( ps_stream ) ; i2_dc_val = ps_dec -> u2_def_dc_pred [ V_CHROMA ] + i2_dc_diff ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = i2_dc_val ; i2_dc_val = CLIP_U8 ( i2_dc_val ) ; ps_dec -> pf_memset_8bit_8x8_block ( pu1_vld_buf , i2_dc_val , u4_dst_wd ) ; ps_dec -> u2_num_mbs_left -- ; ps_dec -> u2_mb_x ++ ; if ( ps_dec -> s_bit_stream . u4_offset > ps_dec -> s_bit_stream . u4_max_offset ) { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR ; } else if ( ps_dec -> u2_mb_x == ps_dec -> u2_num_horiz_mb ) { ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y ++ ; } impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } while ( ps_dec -> u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , 23 ) != 0x0 ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
CWE-000 int ceph_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int ret = 0 , size = 0 ; const char * name = NULL ; char * value = NULL ; struct iattr newattrs ; umode_t new_mode = inode -> i_mode , old_mode = inode -> i_mode ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & new_mode ) ; <S2SV_EndBug> if ( ret < 0 ) goto out ; if ( ret == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { ret = acl ? - EINVAL : 0 ; goto out ; } name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : ret = - EINVAL ; goto out ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_NOFS ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out_free ; } if ( new_mode != old_mode ) { newattrs . ia_mode = new_mode ; newattrs . ia_valid = ATTR_MODE ; ret = __ceph_setattr ( inode , & newattrs ) ; if ( ret ) goto out_free ; } ret = __ceph_setxattr ( inode , name , value , size , 0 ) ; if ( ret ) { if ( new_mode != old_mode ) { newattrs . ia_mode = old_mode ; newattrs . ia_valid = ATTR_MODE ; __ceph_setattr ( inode , & newattrs ) ; } goto out_free ; } ceph_set_cached_acl ( inode , type , acl ) ; out_free : kfree ( value ) ; out : return ret ; }
CWE-125 static void rpl_dao_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dao * dao = ( const struct nd_rpl_dao * ) bp ; const char * dagid_str = "<elided>" ; ND_TCHECK ( * dao ) ; if ( length < ND_RPL_DAO_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAO_MIN_LEN ; length -= ND_RPL_DAO_MIN_LEN ; if ( RPL_DAO_D ( dao -> rpl_flags ) ) { ND_TCHECK2 ( dao -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , dao -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , "<S2SV_blank>[dagid:%s,seq:%u,instance:%u%s%s,%02x]" , dagid_str , dao -> rpl_daoseq , dao -> rpl_instanceid , RPL_DAO_K ( dao -> rpl_flags ) ? ",acK" : "" , RPL_DAO_D ( dao -> rpl_flags ) ? ",Dagid" : "" , dao -> rpl_flags ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , "<S2SV_blank>[|length<S2SV_blank>too<S2SV_blank>short]" ) ) ; return ; }
CWE-119 <S2SV_StartBug> static void encode_quantization ( VP9_COMMON * cm , <S2SV_EndBug> <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ; <S2SV_EndBug> write_delta_q ( wb , cm -> y_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_ac_delta_q ) ; }
CWE-119 <S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap * base = data ; int bitmap_pos ; bitmap_pos = bitmap_position ( object -> oid . hash ) ; <S2SV_StartBug> if ( bitmap_pos < 0 ) { <S2SV_EndBug> char * name = path_name ( path , last ) ; bitmap_pos = ext_index_add_object ( object , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> } bitmap_set ( base , bitmap_pos ) ; }
CWE-119 <S2SV_StartBug> static void utee_param_to_param ( struct tee_ta_param * p , struct utee_params * up ) <S2SV_EndBug> { size_t n ; uint32_t types = up -> types ; p -> types = types ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { uintptr_t a = up -> vals [ n * 2 ] ; size_t b = up -> vals [ n * 2 + 1 ] ; <S2SV_StartBug> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { <S2SV_EndBug> <S2SV_StartBug> case TEE_PARAM_TYPE_MEMREF_INPUT : <S2SV_EndBug> case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : p -> u [ n ] . mem . mobj = & mobj_virt ; p -> u [ n ] . mem . offs = a ; p -> u [ n ] . mem . size = b ; <S2SV_StartBug> break ; <S2SV_EndBug> case TEE_PARAM_TYPE_VALUE_INPUT : case TEE_PARAM_TYPE_VALUE_INOUT : p -> u [ n ] . val . a = a ; p -> u [ n ] . val . b = b ; break ; default : memset ( & p -> u [ n ] , 0 , sizeof ( p -> u [ n ] ) ) ; break ; } <S2SV_StartBug> } <S2SV_EndBug> }
CWE-000 static void sas_eh_finish_cmd ( struct scsi_cmnd * cmd ) { struct sas_ha_struct * sas_ha = SHOST_TO_SAS_HA ( cmd -> device -> host ) ; <S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> sas_end_task ( cmd , task ) ; <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug> }
CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_MRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_MRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_mrtree_set ( rt1 , pair -> key , it2 -> data ) ; } if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
CWE-787 static void __local_bh_enable ( unsigned int cnt ) { <S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> }
CWE-119 void safe_fprintf ( FILE * f , const char * fmt , ... ) { char fmtbuff_stack [ 256 ] ; char outbuff [ 256 ] ; char * fmtbuff_heap ; char * fmtbuff ; int fmtbuff_length ; int length , n ; va_list ap ; const char * p ; unsigned i ; wchar_t wc ; char try_wc ; fmtbuff_heap = NULL ; fmtbuff_length = sizeof ( fmtbuff_stack ) ; fmtbuff = fmtbuff_stack ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; while ( length < 0 || length >= fmtbuff_length ) { if ( length >= fmtbuff_length ) fmtbuff_length = length + 1 ; else if ( fmtbuff_length < 8192 ) fmtbuff_length *= 2 ; else if ( fmtbuff_length < 1000000 ) fmtbuff_length += fmtbuff_length / 4 ; else { length = fmtbuff_length ; fmtbuff_heap [ length - 1 ] = '\\0' ; break ; } free ( fmtbuff_heap ) ; fmtbuff_heap = malloc ( fmtbuff_length ) ; if ( fmtbuff_heap != NULL ) { fmtbuff = fmtbuff_heap ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; } else { length = sizeof ( fmtbuff_stack ) - 1 ; break ; } } if ( mbtowc ( NULL , NULL , 1 ) == - 1 ) { free ( fmtbuff_heap ) ; return ; } p = fmtbuff ; i = 0 ; try_wc = 1 ; while ( * p != '\\0' ) { if ( try_wc && ( n = mbtowc ( & wc , p , length ) ) != - 1 ) { length -= n ; if ( iswprint ( wc ) && wc != L'\\\\' ) { while ( n -- > 0 ) outbuff [ i ++ ] = * p ++ ; } else { while ( n -- > 0 ) i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; } } else { i += ( unsigned ) bsdtar_expand_char ( outbuff , i , * p ++ ) ; try_wc = 0 ; } <S2SV_StartBug> if ( i > ( sizeof ( outbuff ) - 20 ) ) { <S2SV_EndBug> outbuff [ i ] = '\\0' ; fprintf ( f , "%s" , outbuff ) ; i = 0 ; } } outbuff [ i ] = '\\0' ; fprintf ( f , "%s" , outbuff ) ; free ( fmtbuff_heap ) ; }
CWE-119 BOOL SQLWriteFileDSN ( LPCSTR pszFileName , LPCSTR pszAppName , LPCSTR pszKeyName , LPCSTR pszString ) { HINI hIni ; char szFileName [ ODBC_FILENAME_MAX + 1 ] ; if ( pszFileName [ 0 ] == '/' ) { <S2SV_StartBug> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <S2SV_EndBug> } else { char szPath [ ODBC_FILENAME_MAX + 1 ] ; * szPath = '\\0' ; _odbcinst_FileINI ( szPath ) ; snprintf ( szFileName , sizeof ( szFileName ) - 5 , "%s/%s" , szPath , pszFileName ) ; } if ( strlen ( szFileName ) < 4 || strcmp ( szFileName + strlen ( szFileName ) - 4 , ".dsn" ) ) { strcat ( szFileName , ".dsn" ) ; } # ifdef __OS2__ if ( iniOpen ( & hIni , szFileName , "#;" , '[' , ']' , '=' , TRUE , 0L ) != INI_SUCCESS ) # else if ( iniOpen ( & hIni , szFileName , "#;" , '[' , ']' , '=' , TRUE ) != INI_SUCCESS ) # endif { inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_INVALID_PATH , "" ) ; return FALSE ; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) == INI_SUCCESS ) { iniObjectDelete ( hIni ) ; } } else if ( pszString == NULL ) { if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , "" ) == INI_SUCCESS ) { iniPropertyDelete ( hIni ) ; } } else { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) != INI_SUCCESS ) { iniObjectInsert ( hIni , ( char * ) pszAppName ) ; } if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , "" ) == INI_SUCCESS ) { iniObjectSeek ( hIni , ( char * ) pszAppName ) ; iniPropertyUpdate ( hIni , ( char * ) pszKeyName , ( char * ) pszString ) ; } else { iniObjectSeek ( hIni , ( char * ) pszAppName ) ; iniPropertyInsert ( hIni , ( char * ) pszKeyName , ( char * ) pszString ) ; } } if ( iniCommit ( hIni ) != INI_SUCCESS ) { iniClose ( hIni ) ; inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_REQUEST_FAILED , "" ) ; return FALSE ; } iniClose ( hIni ) ; return TRUE ; }
CWE-189 static int cdf_check_stream_offset ( const cdf_stream_t * sst , const cdf_header_t * h , const void * p , size_t tail , int line ) { const char * b = ( const char * ) sst -> sst_tab ; const char * e = ( ( const char * ) p ) + tail ; <S2SV_StartBug> ( void ) & line ; <S2SV_EndBug> <S2SV_StartBug> if ( e >= b && ( size_t ) ( e - b ) <= CDF_SEC_SIZE ( h ) * sst -> sst_len ) <S2SV_EndBug> return 0 ; DPRINTF ( ( "%d:<S2SV_blank>offset<S2SV_blank>begin<S2SV_blank>%p<S2SV_blank><<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>||<S2SV_blank>%" SIZE_T_FORMAT "u" "<S2SV_blank>><S2SV_blank>%" SIZE_T_FORMAT "u<S2SV_blank>[%" SIZE_T_FORMAT "u<S2SV_blank>%" SIZE_T_FORMAT "u]\\n" , line , b , e , ( size_t ) ( e - b ) , <S2SV_StartBug> CDF_SEC_SIZE ( h ) * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; <S2SV_EndBug> errno = EFTYPE ; return - 1 ; }
CWE-119 <S2SV_StartBug> void vp9_fht8x8_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct8x8_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 64 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <S2SV_EndBug> const transform_2d ht = FHT_8 [ tx_type ] ; for ( i = 0 ; i < 8 ; ++ i ) { for ( j = 0 ; j < 8 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 8 ; ++ j ) <S2SV_StartBug> outptr [ j * 8 + i ] = temp_out [ j ] ; <S2SV_EndBug> } for ( i = 0 ; i < 8 ; ++ i ) { for ( j = 0 ; j < 8 ; ++ j ) temp_in [ j ] = out [ j + i * 8 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 8 ; ++ j ) output [ j + i * 8 ] = ( temp_out [ j ] + ( temp_out [ j ] < 0 ) ) >> 1 ; } } }
CWE-000 static bool generic_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { <S2SV_StartBug> return true ; <S2SV_EndBug> }
CWE-200 static int do_video_set_spu_palette ( unsigned int fd , unsigned int cmd , struct compat_video_spu_palette __user * up ) { struct video_spu_palette __user * up_native ; compat_uptr_t palp ; int length , err ; err = get_user ( palp , & up -> palette ) ; <S2SV_StartBug> err |= get_user ( length , & up -> length ) ; <S2SV_EndBug> up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ; err = put_user ( compat_ptr ( palp ) , & up_native -> palette ) ; err |= put_user ( length , & up_native -> length ) ; if ( err ) return - EFAULT ; err = sys_ioctl ( fd , cmd , ( unsigned long ) up_native ) ; return err ; }
CWE-119 const vpx_image_t * vpx_codec_get_preview_frame ( vpx_codec_ctx_t * ctx ) { vpx_image_t * img = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_preview ) ctx -> err = VPX_CODEC_INCAPABLE ; else <S2SV_StartBug> img = ctx -> iface -> enc . get_preview ( ctx -> priv -> alg_priv ) ; <S2SV_EndBug> } return img ; }
CWE-119 static MV_REFERENCE_FRAME get_frame_type ( const VP9_COMP * cpi ) { if ( frame_is_intra_only ( & cpi -> common ) ) return INTRA_FRAME ; else if ( cpi -> rc . is_src_frame_alt_ref && cpi -> refresh_golden_frame ) return ALTREF_FRAME ; else if ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) <S2SV_StartBug> return LAST_FRAME ; <S2SV_EndBug> else <S2SV_StartBug> return GOLDEN_FRAME ; <S2SV_EndBug> }
CWE-416 static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <S2SV_StartBug> size_t e ; <S2SV_EndBug> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }
CWE-000 <S2SV_StartBug> static void oidc_scrub_headers ( request_rec * r ) { <S2SV_EndBug> oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ; if ( cfg -> scrub_request_headers != 0 ) { oidc_scrub_request_headers ( r , OIDC_DEFAULT_HEADER_PREFIX , oidc_cfg_dir_authn_header ( r ) ) ; if ( ( strstr ( cfg -> claim_prefix , OIDC_DEFAULT_HEADER_PREFIX ) != cfg -> claim_prefix ) ) { oidc_scrub_request_headers ( r , cfg -> claim_prefix , NULL ) ; } } }
CWE-264 static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ; cpl = tss -> cs & 3 ; } <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }
CWE-119 int32_t DownmixLib_Create ( const effect_uuid_t * uuid , <S2SV_StartBug> int32_t sessionId , <S2SV_EndBug> <S2SV_StartBug> int32_t ioId , <S2SV_EndBug> effect_handle_t * pHandle ) { int ret ; int i ; downmix_module_t * module ; const effect_descriptor_t * desc ; ALOGV ( "DownmixLib_Create()" ) ; # ifdef DOWNMIX_TEST_CHANNEL_INDEX ALOGI ( "DOWNMIX_TEST_CHANNEL_INDEX:<S2SV_blank>should<S2SV_blank>work:" ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; Downmix_testIndexComputation ( CHANNEL_MASK_QUAD_SIDE | CHANNEL_MASK_QUAD_BACK ) ; Downmix_testIndexComputation ( CHANNEL_MASK_5POINT1_SIDE | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; Downmix_testIndexComputation ( CHANNEL_MASK_5POINT1_BACK | AUDIO_CHANNEL_OUT_BACK_CENTER ) ; ALOGI ( "DOWNMIX_TEST_CHANNEL_INDEX:<S2SV_blank>should<S2SV_blank>NOT<S2SV_blank>work:" ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_LEFT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT | AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_SIDE_LEFT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT ) ; Downmix_testIndexComputation ( AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT ) ; # endif if ( pHandle == NULL || uuid == NULL ) { return - EINVAL ; } for ( i = 0 ; i < kNbEffects ; i ++ ) { desc = gDescriptors [ i ] ; if ( memcmp ( uuid , & desc -> uuid , sizeof ( effect_uuid_t ) ) == 0 ) { break ; } } if ( i == kNbEffects ) { return - ENOENT ; } module = malloc ( sizeof ( downmix_module_t ) ) ; module -> itfe = & gDownmixInterface ; module -> context . state = DOWNMIX_STATE_UNINITIALIZED ; ret = Downmix_Init ( module ) ; if ( ret < 0 ) { ALOGW ( "DownmixLib_Create()<S2SV_blank>init<S2SV_blank>failed" ) ; free ( module ) ; return ret ; } * pHandle = ( effect_handle_t ) module ; ALOGV ( "DownmixLib_Create()<S2SV_blank>%p<S2SV_blank>,<S2SV_blank>size<S2SV_blank>%zu" , module , sizeof ( downmix_module_t ) ) ; return 0 ; }
CWE-20 static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; pr_debug ( "%p<S2SV_blank>%zu\\n" , sk , len ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( "Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( "Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n" , ui_cb -> dsap , ui_cb -> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; sockaddr -> sa_family = AF_NFC ; sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
CWE-119 static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { <S2SV_StartBug> gint64 offset ; <S2SV_EndBug> int pkt_len ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ; <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <S2SV_EndBug> <S2SV_StartBug> wth -> frame_buffer , err , err_info ) ; <S2SV_EndBug> }
CWE-000 static int orinoco_ioctl_set_auth ( struct net_device * dev , struct iw_request_info * info , union iwreq_data * wrqu , char * extra ) { struct orinoco_private * priv = ndev_priv ( dev ) ; hermes_t * hw = & priv -> hw ; struct iw_param * param = & wrqu -> param ; unsigned long flags ; int ret = - EINPROGRESS ; if ( orinoco_lock ( priv , & flags ) != 0 ) return - EBUSY ; switch ( param -> flags & IW_AUTH_INDEX ) { case IW_AUTH_WPA_VERSION : case IW_AUTH_CIPHER_PAIRWISE : case IW_AUTH_CIPHER_GROUP : case IW_AUTH_RX_UNENCRYPTED_EAPOL : case IW_AUTH_PRIVACY_INVOKED : case IW_AUTH_DROP_UNENCRYPTED : break ; case IW_AUTH_KEY_MGMT : priv -> key_mgmt = param -> value ; break ; case IW_AUTH_TKIP_COUNTERMEASURES : if ( param -> value ) { priv -> tkip_cm_active = 1 ; <S2SV_StartBug> ret = hermes_enable_port ( hw , 0 ) ; <S2SV_EndBug> } else { priv -> tkip_cm_active = 0 ; ret = hermes_disable_port ( hw , 0 ) ; } break ; case IW_AUTH_80211_AUTH_ALG : if ( param -> value & IW_AUTH_ALG_SHARED_KEY ) priv -> wep_restrict = 1 ; else if ( param -> value & IW_AUTH_ALG_OPEN_SYSTEM ) priv -> wep_restrict = 0 ; else ret = - EINVAL ; break ; case IW_AUTH_WPA_ENABLED : if ( priv -> has_wpa ) { priv -> wpa_enabled = param -> value ? 1 : 0 ; } else { if ( param -> value ) ret = - EOPNOTSUPP ; priv -> wpa_enabled = 0 ; } break ; default : ret = - EOPNOTSUPP ; } orinoco_unlock ( priv , & flags ) ; return ret ; }
CWE-119 static vpx_codec_err_t ctrl_set_scale_mode ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_scaling_mode_t * const mode = va_arg ( args , vpx_scaling_mode_t * ) ; if ( mode ) { const int res = vp9_set_internal_size ( ctx -> cpi , ( VPX_SCALING ) mode -> h_scaling_mode , ( VPX_SCALING ) mode -> v_scaling_mode ) ; return ( res == 0 ) ? VPX_CODEC_OK : VPX_CODEC_INVALID_PARAM ; } else { return VPX_CODEC_INVALID_PARAM ; } }
CWE-119 static inline int object_common2 ( UNSERIALIZE_PARAMETER , long elements ) { zval * retval_ptr = NULL ; zval fname ; if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_OBJPROP_PP ( rval ) , elements , 1 ) ) { if ( Z_TYPE_PP ( rval ) == IS_OBJECT ) { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ZVAL_NULL ( * rval ) ; return 0 ; } if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( Z_OBJCE_PP ( rval ) != PHP_IC_ENTRY && zend_hash_exists ( & Z_OBJCE_PP ( rval ) -> function_table , "__wakeup" , sizeof ( "__wakeup" ) ) ) { INIT_PZVAL ( & fname ) ; ZVAL_STRINGL ( & fname , "__wakeup" , sizeof ( "__wakeup" ) - 1 , 0 ) ; BG ( serialize_lock ) ++ ; call_user_function_ex ( CG ( function_table ) , rval , & fname , & retval_ptr , 0 , 0 , 1 , NULL TSRMLS_CC ) ; BG ( serialize_lock ) -- ; } if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; }
CWE-000 static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ; <S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ; <S2SV_StartBug> int name_len ; <S2SV_EndBug> avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }
CWE-000 int snmp_helper ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { struct snmp_ctx * ctx = ( struct snmp_ctx * ) context ; <S2SV_StartBug> __be32 * pdata = ( __be32 * ) data ; <S2SV_EndBug> if ( * pdata == ctx -> from ) { pr_debug ( "%s:<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n" , __func__ , ( void * ) & ctx -> from , ( void * ) & ctx -> to ) ; if ( * ctx -> check ) fast_csum ( ctx , ( unsigned char * ) data - ctx -> begin ) ; * pdata = ctx -> to ; } return 1 ; }
CWE-125 void rpki_rtr_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { <S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> const u_char * tptr ; const rpki_rtr_pdu * pdu_header ; tptr = pptr ; tlen = len ; if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ",<S2SV_blank>RPKI-RTR" ) ) ; return ; } <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; pdu_header = ( const rpki_rtr_pdu * ) tptr ; pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; ND_TCHECK2 ( * tptr , pdu_len ) ; if ( ! pdu_type || ! pdu_len ) { break ; } if ( tlen < pdu_len ) { goto trunc ; } <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> goto trunc ; tlen -= pdu_len ; <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> } <S2SV_StartBug> return ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , "\\n\\t%s" , tstr ) ) ; }
CWE-119 void vp9_save_layer_context ( VP9_COMP * const cpi ) { <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> lc -> rc = cpi -> rc ; lc -> twopass = cpi -> twopass ; lc -> target_bandwidth = ( int ) oxcf -> target_bandwidth ; <S2SV_StartBug> lc -> starting_buffer_level = oxcf -> starting_buffer_level ; <S2SV_EndBug> lc -> optimal_buffer_level = oxcf -> optimal_buffer_level ; lc -> maximum_buffer_size = oxcf -> maximum_buffer_size ; <S2SV_StartBug> lc -> framerate = cpi -> output_framerate ; <S2SV_EndBug> }
CWE-119 static struct grub_ext4_extent_header * grub_ext4_find_leaf ( struct grub_ext2_data * data , char * buf , struct grub_ext4_extent_header * ext_block , grub_uint32_t fileblock ) { struct grub_ext4_extent_idx * index ; while ( 1 ) { int i ; grub_disk_addr_t block ; index = ( struct grub_ext4_extent_idx * ) ( ext_block + 1 ) ; if ( grub_le_to_cpu16 ( ext_block -> magic ) != EXT4_EXT_MAGIC ) return 0 ; if ( ext_block -> depth == 0 ) return ext_block ; for ( i = 0 ; i < grub_le_to_cpu16 ( ext_block -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( index [ i ] . block ) ) break ; } if ( -- i < 0 ) return 0 ; block = grub_le_to_cpu16 ( index [ i ] . leaf_hi ) ; block = ( block << 32 ) + grub_le_to_cpu32 ( index [ i ] . leaf ) ; if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> ext_block = ( struct grub_ext4_extent_header * ) buf ; } }
CWE-000 static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , "%s/%s" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( "path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long" ) ; return - 1 ; } <S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> }
CWE-119 static void mark_commit ( struct commit * c , void * data ) { <S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> }
CWE-000 matvar_t * Mat_VarReadNextInfo4 ( mat_t * mat ) { int M , O , data_type , class_type ; mat_int32_t tmp ; long nBytes ; size_t readresult ; matvar_t * matvar = NULL ; union { mat_uint32_t u ; mat_uint8_t c [ 4 ] ; } endian ; if ( mat == NULL || mat -> fp == NULL ) return NULL ; else if ( NULL == ( matvar = Mat_VarCalloc ( ) ) ) return NULL ; readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } endian . u = 0x01020304 ; if ( tmp < 0 || tmp > 4052 ) { if ( Mat_int32Swap ( & tmp ) > 4052 ) { Mat_VarFree ( matvar ) ; return NULL ; } } M = ( int ) floor ( tmp / 1000.0 ) ; switch ( M ) { case 0 : mat -> byteswap = endian . c [ 0 ] != 4 ; break ; case 1 : mat -> byteswap = endian . c [ 0 ] != 1 ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } tmp -= M * 1000 ; O = ( int ) floor ( tmp / 100.0 ) ; if ( 0 != O ) { Mat_VarFree ( matvar ) ; return NULL ; } tmp -= O * 100 ; data_type = ( int ) floor ( tmp / 10.0 ) ; switch ( data_type ) { case 0 : matvar -> data_type = MAT_T_DOUBLE ; break ; case 1 : matvar -> data_type = MAT_T_SINGLE ; break ; case 2 : matvar -> data_type = MAT_T_INT32 ; break ; case 3 : matvar -> data_type = MAT_T_INT16 ; break ; case 4 : matvar -> data_type = MAT_T_UINT16 ; break ; case 5 : matvar -> data_type = MAT_T_UINT8 ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } tmp -= data_type * 10 ; class_type = ( int ) floor ( tmp / 1.0 ) ; switch ( class_type ) { case 0 : matvar -> class_type = MAT_C_DOUBLE ; break ; case 1 : matvar -> class_type = MAT_C_CHAR ; break ; case 2 : matvar -> class_type = MAT_C_SPARSE ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } matvar -> rank = 2 ; matvar -> dims = ( size_t * ) calloc ( 2 , sizeof ( * matvar -> dims ) ) ; if ( NULL == matvar -> dims ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; matvar -> dims [ 0 ] = tmp ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; matvar -> dims [ 1 ] = tmp ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & ( matvar -> isComplex ) , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } if ( matvar -> isComplex && MAT_C_CHAR == matvar -> class_type ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; if ( tmp < 1 ) { Mat_VarFree ( matvar ) ; return NULL ; } matvar -> name = ( char * ) malloc ( tmp ) ; if ( NULL == matvar -> name ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( matvar -> name , 1 , tmp , ( FILE * ) mat -> fp ) ; if ( tmp != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; <S2SV_StartBug> } <S2SV_EndBug> matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ; if ( matvar -> internal -> datapos == - 1L ) { Mat_VarFree ( matvar ) ; Mat_Critical ( "Couldn\'t<S2SV_blank>determine<S2SV_blank>file<S2SV_blank>position" ) ; return NULL ; } { int err ; size_t tmp2 = Mat_SizeOf ( matvar -> data_type ) ; if ( matvar -> isComplex ) tmp2 *= 2 ; err = SafeMulDims ( matvar , & tmp2 ) ; if ( err ) { Mat_VarFree ( matvar ) ; Mat_Critical ( "Integer<S2SV_blank>multiplication<S2SV_blank>overflow" ) ; return NULL ; } nBytes = ( long ) tmp2 ; } ( void ) fseek ( ( FILE * ) mat -> fp , nBytes , SEEK_CUR ) ; return matvar ; }
CWE-000 static int snd_ctl_elem_write ( struct snd_card * card , struct snd_ctl_file * file , struct snd_ctl_elem_value * control ) { struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int index_offset ; int result ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_id ( card , & control -> id ) ; if ( kctl == NULL ) { result = - ENOENT ; } else { index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_WRITE ) || kctl -> put == NULL || ( file && vd -> owner && vd -> owner != file ) ) { result = - EPERM ; } else { snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; result = kctl -> put ( kctl , control ) ; } if ( result > 0 ) { <S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , <S2SV_StartBug> & control -> id ) ; <S2SV_EndBug> return 0 ; } } up_read ( & card -> controls_rwsem ) ; return result ; }
CWE-000 int pidfile_write ( const char * pid_file , int pid ) { FILE * pidfile = NULL ; <S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , "w" ) ; if ( ! pidfile ) { log_message ( LOG_INFO , "pidfile_write<S2SV_blank>:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>pidfile" , pid_file ) ; return 0 ; } fprintf ( pidfile , "%d\\n" , pid ) ; fclose ( pidfile ) ; return 1 ; }
CWE-000 int evm_update_evmxattr ( struct dentry * dentry , const char * xattr_name , const char * xattr_value , size_t xattr_value_len ) { struct inode * inode = dentry -> d_inode ; struct evm_ima_xattr_data xattr_data ; int rc = 0 ; rc = evm_calc_hmac ( dentry , xattr_name , xattr_value , xattr_value_len , xattr_data . digest ) ; if ( rc == 0 ) { xattr_data . type = EVM_XATTR_HMAC ; rc = __vfs_setxattr_noperm ( dentry , XATTR_NAME_EVM , & xattr_data , sizeof ( xattr_data ) , 0 ) ; } <S2SV_StartBug> else if ( rc == - ENODATA ) <S2SV_EndBug> rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ; <S2SV_StartBug> return rc ; <S2SV_EndBug> }
CWE-125 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , "lsl" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , "lsr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , "asr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
CWE-000 static xsltCompMatchPtr xsltCompilePatternInternal ( const xmlChar * pattern , xmlDocPtr doc , xmlNodePtr node , xsltStylesheetPtr style , xsltTransformContextPtr runtime , int novar ) { xsltParserContextPtr ctxt = NULL ; xsltCompMatchPtr element , first = NULL , previous = NULL ; int current , start , end , level , j ; if ( pattern == NULL ) { xsltTransformError ( NULL , NULL , node , "xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n" ) ; return ( NULL ) ; } ctxt = xsltNewParserContext ( style , runtime ) ; if ( ctxt == NULL ) return ( NULL ) ; ctxt -> doc = doc ; ctxt -> elem = node ; current = end = 0 ; while ( pattern [ current ] != 0 ) { start = current ; while ( IS_BLANK_CH ( pattern [ current ] ) ) current ++ ; end = current ; level = 0 ; while ( ( pattern [ end ] != 0 ) && ( ( pattern [ end ] != '|' ) || ( level != 0 ) ) ) { if ( pattern [ end ] == '[' ) level ++ ; else if ( pattern [ end ] == ']' ) level -- ; else if ( pattern [ end ] == '\\'' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != '\\'' ) ) end ++ ; } else if ( pattern [ end ] == \'"\' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != \'"\' ) ) end ++ ; } <S2SV_StartBug> end ++ ; <S2SV_EndBug> } if ( current == end ) { xsltTransformError ( NULL , NULL , node , "xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n" ) ; goto error ; } element = xsltNewCompMatch ( ) ; if ( element == NULL ) { goto error ; } if ( first == NULL ) first = element ; else if ( previous != NULL ) previous -> next = element ; previous = element ; ctxt -> comp = element ; ctxt -> base = xmlStrndup ( & pattern [ start ] , end - start ) ; if ( ctxt -> base == NULL ) goto error ; ctxt -> cur = & ( ctxt -> base ) [ current - start ] ; element -> pattern = ctxt -> base ; element -> nsList = xmlGetNsList ( doc , node ) ; j = 0 ; if ( element -> nsList != NULL ) { while ( element -> nsList [ j ] != NULL ) j ++ ; } element -> nsNr = j ; # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , "xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsing<S2SV_blank>\'%s\'\\n" , element -> pattern ) ; # endif element -> priority = 0 ; xsltCompileLocationPathPattern ( ctxt , novar ) ; if ( ctxt -> error ) { xsltTransformError ( NULL , style , node , "xsltCompilePattern<S2SV_blank>:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>\'%s\'\\n" , element -> pattern ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltReverseCompMatch ( ctxt , element ) ; if ( element -> priority == 0 ) { if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_ELEM ) || ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) || ( element -> steps [ 0 ] . op == XSLT_OP_PI ) ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value2 != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_NS ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value == NULL ) && ( element -> steps [ 0 ] . value2 == NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_PI ) || ( element -> steps [ 0 ] . op == XSLT_OP_TEXT ) || ( element -> steps [ 0 ] . op == XSLT_OP_ALL ) || ( element -> steps [ 0 ] . op == XSLT_OP_NODE ) || ( element -> steps [ 0 ] . op == XSLT_OP_COMMENT ) ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else { element -> priority = 0.5 ; } } # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , "xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsed<S2SV_blank>%s,<S2SV_blank>default<S2SV_blank>priority<S2SV_blank>%f\\n" , element -> pattern , element -> priority ) ; # endif if ( pattern [ end ] == '|' ) end ++ ; current = end ; } if ( end == 0 ) { xsltTransformError ( NULL , style , node , "xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n" ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltFreeParserContext ( ctxt ) ; return ( first ) ; error : if ( ctxt != NULL ) xsltFreeParserContext ( ctxt ) ; if ( first != NULL ) xsltFreeCompMatchList ( first ) ; return ( NULL ) ; }
CWE-119 static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , "%i" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
CWE-000 static __u8 * cp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { unsigned long quirks = ( unsigned long ) hid_get_drvdata ( hdev ) ; unsigned int i ; <S2SV_StartBug> if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) <S2SV_EndBug> return rdesc ; for ( i = 0 ; i < * rsize - 4 ; i ++ ) if ( rdesc [ i ] == 0x29 && rdesc [ i + 2 ] == 0x19 ) { rdesc [ i ] = 0x19 ; rdesc [ i + 2 ] = 0x29 ; swap ( rdesc [ i + 3 ] , rdesc [ i + 1 ] ) ; } return rdesc ; }
CWE-200 static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( "sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; }
CWE-20 static void __iov_iter_advance_iov ( struct iov_iter * i , size_t bytes ) { if ( likely ( i -> nr_segs == 1 ) ) { i -> iov_offset += bytes ; } else { const struct iovec * iov = i -> iov ; size_t base = i -> iov_offset ; <S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> int copy = min ( bytes , iov -> iov_len - base ) ; bytes -= copy ; base += copy ; if ( iov -> iov_len == base ) { iov ++ ; base = 0 ; } } i -> iov = iov ; i -> iov_offset = base ; } }
CWE-000 static int __reiserfs_set_acl ( struct reiserfs_transaction_handle * th , struct inode * inode , int type , struct posix_acl * acl ) { char * name ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { if ( error == 0 ) acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = reiserfs_posix_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = reiserfs_xattr_set_handle ( th , inode , name , value , size , 0 ) ; if ( error == - ENODATA ) { error = 0 ; if ( type == ACL_TYPE_ACCESS ) { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; } } kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
CWE-190 static int decode_level3_header ( LHAFileHeader * * header , LHAInputStream * stream ) { unsigned int header_len ; if ( lha_decode_uint16 ( & RAW_DATA ( header , 0 ) ) != 4 ) { return 0 ; } if ( ! extend_raw_data ( header , stream , LEVEL_3_HEADER_LEN - RAW_DATA_LEN ( header ) ) ) { return 0 ; } header_len = lha_decode_uint32 ( & RAW_DATA ( header , 24 ) ) ; <S2SV_StartBug> if ( header_len > LEVEL_3_MAX_HEADER_LEN ) { <S2SV_EndBug> return 0 ; } if ( ! extend_raw_data ( header , stream , header_len - RAW_DATA_LEN ( header ) ) ) { return 0 ; } memcpy ( ( * header ) -> compress_method , & RAW_DATA ( header , 2 ) , 5 ) ; ( * header ) -> compress_method [ 5 ] = '\\0' ; ( * header ) -> compressed_length = lha_decode_uint32 ( & RAW_DATA ( header , 7 ) ) ; ( * header ) -> length = lha_decode_uint32 ( & RAW_DATA ( header , 11 ) ) ; ( * header ) -> timestamp = lha_decode_uint32 ( & RAW_DATA ( header , 15 ) ) ; ( * header ) -> crc = lha_decode_uint16 ( & RAW_DATA ( header , 21 ) ) ; ( * header ) -> os_type = RAW_DATA ( header , 23 ) ; if ( ! decode_extended_headers ( header , 28 ) ) { return 0 ; } return 1 ; }
CWE-399 static int inotify_release ( struct inode * ignored , struct file * file ) { struct fsnotify_group * group = file -> private_data ; <S2SV_StartBug> struct user_struct * user = group -> inotify_data . user ; <S2SV_EndBug> pr_debug ( "%s:<S2SV_blank>group=%p\\n" , __func__ , group ) ; fsnotify_clear_marks_by_group ( group ) ; fsnotify_put_group ( group ) ; <S2SV_StartBug> atomic_dec ( & user -> inotify_devs ) ; <S2SV_EndBug> return 0 ; }
CWE-476 static int dissect_usb_ms_bulk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data ) { usb_conv_info_t * usb_conv_info ; usb_ms_conv_info_t * usb_ms_conv_info ; proto_tree * tree ; proto_item * ti ; guint32 signature = 0 ; int offset = 0 ; gboolean is_request ; itl_nexus_t * itl ; itlq_nexus_t * itlq ; if ( data == NULL ) return 0 ; usb_conv_info = ( usb_conv_info_t * ) data ; usb_ms_conv_info = ( usb_ms_conv_info_t * ) usb_conv_info -> class_data ; if ( ! usb_ms_conv_info ) { usb_ms_conv_info = wmem_new ( wmem_file_scope ( ) , usb_ms_conv_info_t ) ; usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> is_request = ( pinfo -> srcport == NO_ENDPOINT ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "USBMS" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_protocol_format ( parent_tree , proto_usb_ms , tvb , 0 , - 1 , "USB<S2SV_blank>Mass<S2SV_blank>Storage" ) ; tree = proto_item_add_subtree ( ti , ett_usb_ms ) ; signature = tvb_get_letohl ( tvb , offset ) ; if ( is_request && ( signature == 0x43425355 ) && ( tvb_reported_length ( tvb ) == 31 ) ) { tvbuff_t * cdb_tvb ; int cdbrlen , cdblen ; guint8 lun , flags ; guint32 datalen ; proto_tree_add_item ( tree , hf_usb_ms_dCBWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWDataTransferLength , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; datalen = tvb_get_letohl ( tvb , offset ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWFlags , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; flags = tvb_get_guint8 ( tvb , offset ) ; offset += 1 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTarget , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; proto_tree_add_item ( tree , hf_usb_ms_dCBWLUN , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; lun = tvb_get_guint8 ( tvb , offset ) & 0x0f ; offset += 1 ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , lun ) ; if ( ! itl ) { itl = wmem_new ( wmem_file_scope ( ) , itl_nexus_t ) ; itl -> cmdset = 0xff ; itl -> conversation = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itl , lun , itl ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { itlq = wmem_new ( wmem_file_scope ( ) , itlq_nexus_t ) ; itlq -> lun = lun ; itlq -> scsi_opcode = 0xffff ; itlq -> task_flags = 0 ; if ( datalen ) { if ( flags & 0x80 ) { itlq -> task_flags |= SCSI_DATA_READ ; } else { itlq -> task_flags |= SCSI_DATA_WRITE ; } } itlq -> data_length = datalen ; itlq -> bidir_data_length = 0 ; itlq -> fc_time = pinfo -> abs_ts ; itlq -> first_exchange_frame = pinfo -> num ; itlq -> last_exchange_frame = 0 ; itlq -> flags = 0 ; itlq -> alloc_len = 0 ; itlq -> extra_data = NULL ; wmem_tree_insert32 ( usb_ms_conv_info -> itlq , pinfo -> num , itlq ) ; } proto_tree_add_item ( tree , hf_usb_ms_dCBWCBLength , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; cdbrlen = tvb_get_guint8 ( tvb , offset ) & 0x1f ; offset += 1 ; cdblen = cdbrlen ; if ( cdblen > tvb_captured_length_remaining ( tvb , offset ) ) { cdblen = tvb_captured_length_remaining ( tvb , offset ) ; } if ( cdblen ) { cdb_tvb = tvb_new_subset ( tvb , offset , cdblen , cdbrlen ) ; dissect_scsi_cdb ( cdb_tvb , pinfo , parent_tree , SCSI_DEV_UNKNOWN , itlq , itl ) ; } return tvb_captured_length ( tvb ) ; } if ( ( ! is_request ) && ( signature == 0x53425355 ) && ( tvb_reported_length ( tvb ) == 13 ) ) { guint8 status ; proto_tree_add_item ( tree , hf_usb_ms_dCSWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWDataResidue , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCSWStatus , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; status = tvb_get_guint8 ( tvb , offset ) ; itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itlq -> last_exchange_frame = pinfo -> num ; itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } if ( ! status ) { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0 ) ; } else { dissect_scsi_rsp ( tvb , pinfo , parent_tree , itlq , itl , 0x02 ) ; } return tvb_captured_length ( tvb ) ; } itlq = ( itlq_nexus_t * ) wmem_tree_lookup32_le ( usb_ms_conv_info -> itlq , pinfo -> num ) ; if ( ! itlq ) { return tvb_captured_length ( tvb ) ; } itl = ( itl_nexus_t * ) wmem_tree_lookup32 ( usb_ms_conv_info -> itl , itlq -> lun ) ; if ( ! itl ) { return tvb_captured_length ( tvb ) ; } dissect_scsi_payload ( tvb , pinfo , parent_tree , is_request , itlq , itl , 0 ) ; return tvb_captured_length ( tvb ) ; }
CWE-125 static int readContigTilesIntoBuffer ( TIFF * in , uint8 * buf , uint32 imagelength , uint32 imagewidth , uint32 tw , uint32 tl , tsample_t spp , uint16 bps ) { int status = 1 ; tsample_t sample = 0 ; tsample_t count = spp ; uint32 row , col , trow ; uint32 nrow , ncol ; uint32 dst_rowsize , shift_width ; uint32 bytes_per_sample , bytes_per_pixel ; uint32 trailing_bits , prev_trailing_bits ; uint32 tile_rowsize = TIFFTileRowSize ( in ) ; uint32 src_offset , dst_offset ; uint32 row_offset , col_offset ; uint8 * bufp = ( uint8 * ) buf ; unsigned char * src = NULL ; unsigned char * dst = NULL ; tsize_t tbytes = 0 , tile_buffsize = 0 ; tsize_t tilesize = TIFFTileSize ( in ) ; unsigned char * tilebuf = NULL ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( ( bps % 8 ) == 0 ) shift_width = 0 ; else { if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; } tile_buffsize = tilesize ; if ( tilesize == 0 || tile_rowsize == 0 ) { TIFFError ( "readContigTilesIntoBuffer" , "Tile<S2SV_blank>size<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero" ) ; exit ( - 1 ) ; } if ( tilesize < ( tsize_t ) ( tl * tile_rowsize ) ) { # ifdef DEBUG2 TIFFError ( "readContigTilesIntoBuffer" , "Tilesize<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>alternate<S2SV_blank>calculation<S2SV_blank>%u" , tilesize , tl * tile_rowsize ) ; # endif tile_buffsize = tl * tile_rowsize ; if ( tl != ( tile_buffsize / tile_rowsize ) ) { TIFFError ( "readContigTilesIntoBuffer" , "Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size." ) ; exit ( - 1 ) ; } } <S2SV_StartBug> tilebuf = _TIFFmalloc ( tile_buffsize ) ; <S2SV_EndBug> if ( tilebuf == 0 ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> dst_rowsize = ( ( imagewidth * bps * spp ) + 7 ) / 8 ; for ( row = 0 ; row < imagelength ; row += tl ) { nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; for ( col = 0 ; col < imagewidth ; col += tw ) { tbytes = TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) ; if ( tbytes < tilesize && ! ignore ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>row<S2SV_blank>%lu<S2SV_blank>col<S2SV_blank>%lu,<S2SV_blank>Read<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>%lu" , ( unsigned long ) col , ( unsigned long ) row , ( unsigned long ) tbytes , ( unsigned long ) tilesize ) ; status = 0 ; _TIFFfree ( tilebuf ) ; return status ; } row_offset = row * dst_rowsize ; col_offset = ( ( col * bps * spp ) + 7 ) / 8 ; bufp = buf + row_offset + col_offset ; if ( col + tw > imagewidth ) ncol = imagewidth - col ; else ncol = tw ; if ( ( ( bps % 8 ) == 0 ) && ( count == spp ) ) { for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; _TIFFmemcpy ( bufp , tilebuf + src_offset , ( ncol * spp * bps ) / 8 ) ; bufp += ( imagewidth * bps * spp ) / 8 ; } } else { prev_trailing_bits = trailing_bits = 0 ; trailing_bits = ( ncol * bps * spp ) % 8 ; for ( trow = 0 ; trow < nrow ; trow ++ ) { src_offset = trow * tile_rowsize ; src = tilebuf + src_offset ; dst_offset = ( row + trow ) * dst_rowsize ; dst = buf + dst_offset + col_offset ; switch ( shift_width ) { case 0 : if ( extractContigSamplesBytes ( src , dst , ncol , sample , spp , bps , count , 0 , ncol ) ) { TIFFError ( "readContigTilesIntoBuffer" , "Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 1 : if ( bps == 1 ) { if ( extractContigSamplesShifted8bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( "readContigTilesIntoBuffer" , "Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; } else if ( extractContigSamplesShifted16bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( "readContigTilesIntoBuffer" , "Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 2 : if ( extractContigSamplesShifted24bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( "readContigTilesIntoBuffer" , "Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; case 3 : case 4 : case 5 : if ( extractContigSamplesShifted32bits ( src , dst , ncol , sample , spp , bps , count , 0 , ncol , prev_trailing_bits ) ) { TIFFError ( "readContigTilesIntoBuffer" , "Unable<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>row<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>tile<S2SV_blank>%lu" , row , ( unsigned long ) TIFFCurrentTile ( in ) ) ; return 1 ; } break ; default : TIFFError ( "readContigTilesIntoBuffer" , "Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d" , bps ) ; return 1 ; } } prev_trailing_bits += trailing_bits ; } } } _TIFFfree ( tilebuf ) ; return status ; }
CWE-000 static int ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ea_idebug ( inode , "buffer=%p,<S2SV_blank>buffer_size=%ld" , buffer , ( long ) buffer_size ) ; error = 0 ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , "reading<S2SV_blank>block<S2SV_blank>%llu" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , "b_count=%d,<S2SV_blank>refcount=%d" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { EXT4_ERROR_INODE ( inode , "bad<S2SV_blank>block<S2SV_blank>%llu" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; cleanup : brelse ( bh ) ; return error ; }
CWE-399 static void xen_netbk_tx_submit ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops ; struct sk_buff * skb ; while ( ( skb = __skb_dequeue ( & netbk -> tx_queue ) ) != NULL ) { struct xen_netif_tx_request * txp ; struct xenvif * vif ; u16 pending_idx ; unsigned data_len ; pending_idx = * ( ( u16 * ) skb -> data ) ; vif = netbk -> pending_tx_info [ pending_idx ] . vif ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; if ( unlikely ( xen_netbk_tx_check_gop ( netbk , skb , & gop ) ) ) { netdev_dbg ( vif -> dev , "netback<S2SV_blank>grant<S2SV_blank>failed.\\n" ) ; skb_shinfo ( skb ) -> nr_frags = 0 ; kfree_skb ( skb ) ; continue ; } data_len = skb -> len ; memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ; if ( data_len < txp -> size ) { txp -> offset += data_len ; txp -> size -= data_len ; } else { <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } if ( txp -> flags & XEN_NETTXF_csum_blank ) skb -> ip_summed = CHECKSUM_PARTIAL ; else if ( txp -> flags & XEN_NETTXF_data_validated ) skb -> ip_summed = CHECKSUM_UNNECESSARY ; xen_netbk_fill_frags ( netbk , skb ) ; if ( skb_headlen ( skb ) < PKT_PROT_LEN && skb_is_nonlinear ( skb ) ) { int target = min_t ( int , skb -> len , PKT_PROT_LEN ) ; __pskb_pull_tail ( skb , target - skb_headlen ( skb ) ) ; } skb -> dev = vif -> dev ; skb -> protocol = eth_type_trans ( skb , skb -> dev ) ; if ( checksum_setup ( vif , skb ) ) { netdev_dbg ( vif -> dev , "Can\'t<S2SV_blank>setup<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>net_tx_action\\n" ) ; kfree_skb ( skb ) ; continue ; } vif -> dev -> stats . rx_bytes += skb -> len ; vif -> dev -> stats . rx_packets ++ ; xenvif_receive_skb ( vif , skb ) ; } }
CWE-000 static int find_high_bit ( unsigned int x ) { int i ; for ( i = 31 ; i >= 0 ; i -- ) { <S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> } return 0 ; }
CWE-264 void hostap_setup_dev ( struct net_device * dev , local_info_t * local , int type ) { struct hostap_interface * iface ; iface = netdev_priv ( dev ) ; <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> if ( iface ) { iface -> wireless_data . spy_data = & iface -> spy_data ; dev -> wireless_data = & iface -> wireless_data ; } dev -> wireless_handlers = & hostap_iw_handler_def ; dev -> watchdog_timeo = TX_TIMEOUT ; switch ( type ) { case HOSTAP_INTERFACE_AP : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_mgmt_netdev_ops ; dev -> type = ARPHRD_IEEE80211 ; dev -> header_ops = & hostap_80211_ops ; break ; case HOSTAP_INTERFACE_MASTER : dev -> netdev_ops = & hostap_master_ops ; break ; default : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_netdev_ops ; } dev -> mtu = local -> mtu ; SET_ETHTOOL_OPS ( dev , & prism2_ethtool_ops ) ; }
CWE-264 int regset_tls_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct user_desc infobuf [ GDT_ENTRY_TLS_ENTRIES ] ; const struct user_desc * info ; <S2SV_StartBug> if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || <S2SV_EndBug> ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ; if ( kbuf ) info = kbuf ; else if ( __copy_from_user ( infobuf , ubuf , count ) ) return - EFAULT ; else info = infobuf ; <S2SV_StartBug> set_tls_desc ( target , <S2SV_EndBug> GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ; return 0 ; }
CWE-119 static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> vpx_ref_frame_t * const frame = va_arg ( args , vpx_ref_frame_t * ) ; if ( frame != NULL ) { YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; vp9_set_reference_enc ( ctx -> cpi , ref_frame_to_vp9_reframe ( frame -> frame_type ) , & sd ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
CWE-000 <S2SV_StartBug> void close_connection ( h2o_http2_conn_t * conn ) <S2SV_EndBug> { conn -> state = H2O_HTTP2_CONN_STATE_IS_CLOSING ; if ( conn -> _write . buf_in_flight != NULL || h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { } else { close_connection_now ( conn ) ; <S2SV_StartBug> } <S2SV_EndBug> }
CWE-119 static void send_auth ( char * username , char * password ) { struct mt_packet data ; unsigned short width = 0 ; unsigned short height = 0 ; char * terminal = getenv ( "TERM" ) ; char md5data [ 100 ] ; unsigned char md5sum [ 17 ] ; <S2SV_StartBug> int plen ; <S2SV_EndBug> md5_state_t state ; # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( md5data , sizeof ( md5data ) ) ; mlock ( md5sum , sizeof ( md5data ) ) ; # endif <S2SV_StartBug> md5data [ 0 ] = 0 ; <S2SV_EndBug> <S2SV_StartBug> strncpy ( md5data + 1 , password , 82 ) ; <S2SV_EndBug> md5data [ 83 ] = '\\0' ; <S2SV_StartBug> memcpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ; <S2SV_EndBug> md5_init ( & state ) ; <S2SV_StartBug> md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ; <S2SV_EndBug> md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ; md5sum [ 0 ] = 0 ; init_packet ( & data , MT_PTYPE_DATA , srcmac , dstmac , sessionkey , outcounter ) ; plen = add_control_packet ( & data , MT_CPTYPE_PASSWORD , md5sum , 17 ) ; plen += add_control_packet ( & data , MT_CPTYPE_USERNAME , username , strlen ( username ) ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_TYPE , terminal , strlen ( terminal ) ) ; if ( is_a_tty && get_terminal_size ( & width , & height ) != - 1 ) { width = htole16 ( width ) ; height = htole16 ( height ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_WIDTH , & width , 2 ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_HEIGHT , & height , 2 ) ; } outcounter += plen ; send_udp ( & data , 1 ) ; }
CWE-20 static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }
CWE-000 static int valid_host ( cupsd_client_t * con ) { cupsd_alias_t * a ; cupsd_netif_t * netif ; const char * end ; char * ptr ; strlcpy ( con -> clientname , httpGetField ( con -> http , HTTP_FIELD_HOST ) , sizeof ( con -> clientname ) ) ; if ( ( ptr = strrchr ( con -> clientname , ':' ) ) != NULL && ! strchr ( ptr , ']' ) ) { * ptr ++ = '\\0' ; con -> clientport = atoi ( ptr ) ; } else con -> clientport = con -> serverport ; if ( httpAddrLocalhost ( httpGetAddress ( con -> http ) ) ) { return ( ! _cups_strcasecmp ( con -> clientname , "localhost" ) || ! _cups_strcasecmp ( con -> clientname , "localhost." ) || <S2SV_StartBug> # ifdef __linux <S2SV_EndBug> ! _cups_strcasecmp ( con -> clientname , "localhost.localdomain" ) || # endif ! strcmp ( con -> clientname , "127.0.0.1" ) || ! strcmp ( con -> clientname , "[::1]" ) ) ; } # if defined ( HAVE_DNSSD ) || defined ( HAVE_AVAHI ) if ( ( end = strrchr ( con -> clientname , '.' ) ) != NULL && end > con -> clientname && ! end [ 1 ] ) { for ( end -- ; end > con -> clientname && * end != '.' ; end -- ) ; } if ( end && ( ! _cups_strcasecmp ( end , ".local" ) || ! _cups_strcasecmp ( end , ".local." ) ) ) return ( 1 ) ; # endif if ( isdigit ( con -> clientname [ 0 ] & 255 ) || con -> clientname [ 0 ] == '[' ) { http_addrlist_t * addrlist ; if ( ( addrlist = httpAddrGetList ( con -> clientname , AF_UNSPEC , NULL ) ) != NULL ) { httpAddrFreeList ( addrlist ) ; return ( 1 ) ; } } for ( a = ( cupsd_alias_t * ) cupsArrayFirst ( ServerAlias ) ; a ; a = ( cupsd_alias_t * ) cupsArrayNext ( ServerAlias ) ) { if ( ! strcmp ( a -> name , "*" ) ) return ( 1 ) ; if ( ! _cups_strncasecmp ( con -> clientname , a -> name , a -> namelen ) ) { end = con -> clientname + a -> namelen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } # if defined ( HAVE_DNSSD ) || defined ( HAVE_AVAHI ) for ( a = ( cupsd_alias_t * ) cupsArrayFirst ( DNSSDAlias ) ; a ; a = ( cupsd_alias_t * ) cupsArrayNext ( DNSSDAlias ) ) { if ( ! strcmp ( a -> name , "*" ) ) return ( 1 ) ; if ( ! _cups_strncasecmp ( con -> clientname , a -> name , a -> namelen ) ) { end = con -> clientname + a -> namelen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } # endif for ( netif = ( cupsd_netif_t * ) cupsArrayFirst ( NetIFList ) ; netif ; netif = ( cupsd_netif_t * ) cupsArrayNext ( NetIFList ) ) { if ( ! _cups_strncasecmp ( con -> clientname , netif -> hostname , netif -> hostlen ) ) { end = con -> clientname + netif -> hostlen ; if ( ! * end || ( * end == '.' && ! end [ 1 ] ) ) return ( 1 ) ; } } return ( 0 ) ; }
CWE-000 static zend_bool add_post_var ( zval * arr , post_var_data_t * var , zend_bool eof ) { <S2SV_StartBug> char * ksep , * vsep , * val ; <S2SV_EndBug> size_t klen , vlen ; size_t new_vlen ; if ( var -> ptr >= var -> end ) { return 0 ; } <S2SV_StartBug> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <S2SV_EndBug> if ( ! vsep ) { <S2SV_StartBug> if ( ! eof ) { <S2SV_EndBug> return 0 ; } else { vsep = var -> end ; } } ksep = memchr ( var -> ptr , '=' , vsep - var -> ptr ) ; if ( ksep ) { * ksep = '\\0' ; klen = ksep - var -> ptr ; vlen = vsep - ++ ksep ; } else { ksep = "" ; klen = vsep - var -> ptr ; vlen = 0 ; } php_url_decode ( var -> ptr , klen ) ; val = estrndup ( ksep , vlen ) ; if ( vlen ) { vlen = php_url_decode ( val , vlen ) ; } if ( sapi_module . input_filter ( PARSE_POST , var -> ptr , & val , vlen , & new_vlen ) ) { php_register_variable_safe ( var -> ptr , val , new_vlen , arr ) ; } efree ( val ) ; var -> ptr = vsep + ( vsep != var -> end ) ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
CWE-189 Datum hstore_recv ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; int32 i ; int32 pcount ; StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; pcount = pq_getmsgint ( buf , 4 ) ; if ( pcount == 0 ) { out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; } <S2SV_StartBug> pairs = palloc ( pcount * sizeof ( Pairs ) ) ; <S2SV_EndBug> for ( i = 0 ; i < pcount ; ++ i ) { int rawlen = pq_getmsgint ( buf , 4 ) ; int len ; if ( rawlen < 0 ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( "null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key" ) ) ) ; pairs [ i ] . key = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( len ) ; pairs [ i ] . needfree = true ; rawlen = pq_getmsgint ( buf , 4 ) ; if ( rawlen < 0 ) { pairs [ i ] . val = NULL ; pairs [ i ] . vallen = 0 ; pairs [ i ] . isnull = true ; } else { pairs [ i ] . val = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . vallen = hstoreCheckValLen ( len ) ; pairs [ i ] . isnull = false ; } } pcount = hstoreUniquePairs ( pairs , pcount , & buflen ) ; out = hstorePairs ( pairs , pcount , buflen ) ; PG_RETURN_POINTER ( out ) ; }
CWE-787 static char * get_header ( FILE * fp ) { <S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> header = calloc ( 1 , 1024 ) ; <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> fseek ( fp , 0 , SEEK_SET ) ; SAFE_E ( fread ( header , 1 , 1023 , fp ) , 1023 , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>PDF<S2SV_blank>header.\\n" ) ; fseek ( fp , start , SEEK_SET ) ; return header ; }
CWE-362 static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) <S2SV_StartBug> { <S2SV_EndBug> ++ vcpu -> stat . insn_emulation_fail ; <S2SV_StartBug> trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_EndBug> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ; <S2SV_StartBug> kvm_queue_exception ( vcpu , UD_VECTOR ) ; <S2SV_EndBug> <S2SV_StartBug> return EMULATE_FAIL ; <S2SV_EndBug> }
CWE-20 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }
CWE-476 static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ; <S2SV_StartBug> if ( pkt == NULL ) <S2SV_EndBug> continue ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }
CWE-20 static void ikev2_parent_outI1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( "ikev2<S2SV_blank>parent<S2SV_blank>outI1:<S2SV_blank>calculated<S2SV_blank>ke+nonce,<S2SV_blank>sending<S2SV_blank>I1" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , "%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_outI1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_cur_state ( ) ; reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }
CWE-119 static void setup_features ( VP8_COMP * cpi ) { if ( cpi -> mb . e_mbd . segmentation_enabled ) { cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; } else { cpi -> mb . e_mbd . update_mb_segmentation_map = 0 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 0 ; } cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 0 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> set_default_lf_deltas ( cpi ) ; }
CWE-000 static Status accept_xsmp_connection ( SmsConn sms_conn , GsmXsmpServer * server , unsigned long * mask_ret , SmsCallbacks * callbacks_ret , char * * failure_reason_ret ) { IceConn ice_conn ; <S2SV_StartBug> GsmXSMPClient * client ; <S2SV_EndBug> if ( server -> priv -> xsmp_sockets == NULL ) { g_debug ( "GsmXsmpServer:<S2SV_blank>In<S2SV_blank>shutdown,<S2SV_blank>rejecting<S2SV_blank>new<S2SV_blank>client" ) ; * failure_reason_ret = strdup ( _ ( "Refusing<S2SV_blank>new<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>because<S2SV_blank>the<S2SV_blank>session<S2SV_blank>is<S2SV_blank>currently<S2SV_blank>being<S2SV_blank>shut<S2SV_blank>down\\n" ) ) ; return FALSE ; } ice_conn = SmsGetIceConnection ( sms_conn ) ; <S2SV_StartBug> client = ice_conn -> context ; <S2SV_EndBug> <S2SV_StartBug> g_return_val_if_fail ( client != NULL , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ; <S2SV_EndBug> return TRUE ; }
CWE-20 int arch_dup_task_struct ( struct task_struct * dst , struct task_struct * src ) { flush_fp_to_thread ( src ) ; flush_altivec_to_thread ( src ) ; flush_vsx_to_thread ( src ) ; flush_spe_to_thread ( src ) ; <S2SV_StartBug> * dst = * src ; <S2SV_EndBug> clear_task_ebb ( dst ) ; return 0 ; }
CWE-119 <S2SV_StartBug> void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run , <S2SV_EndBug> BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> TOKENEXTRA * t_backup = * t ; const int ctx = vp9_get_skip_context ( xd ) ; <S2SV_StartBug> const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , <S2SV_EndBug> SEG_LVL_SKIP ) ; <S2SV_StartBug> struct tokenize_b_args arg = { cpi , xd , t } ; <S2SV_EndBug> if ( mbmi -> skip ) { if ( ! dry_run ) <S2SV_StartBug> cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ; <S2SV_EndBug> reset_skip_context ( xd , bsize ) ; <S2SV_StartBug> if ( dry_run ) <S2SV_EndBug> * t = t_backup ; return ; } if ( ! dry_run ) { <S2SV_StartBug> cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ; <S2SV_EndBug> vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ; } else { vp9_foreach_transformed_block ( xd , bsize , set_entropy_context_b , & arg ) ; <S2SV_StartBug> * t = t_backup ; <S2SV_EndBug> } }
CWE-119 bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[\\"%s\\"]}" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[]}" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , "Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , "JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , "result" ) ; err_val = json_object_get ( val , "error" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( "(unknown<S2SV_blank>reason)" ) ; applog ( LOG_INFO , "JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s" , ss ) ; free ( ss ) ; goto out ; } sessionid = json_array_string ( json_array_get ( res_val , 0 ) , 1 ) ; if ( ! sessionid ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } mutex_lock ( & pool -> pool_lock ) ; pool -> sessionid = sessionid ; free ( pool -> nonce1 ) ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; pool -> n2size = n2size ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , "Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( val ) json_decref ( val ) ; if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , "Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && pool -> sessionid ) { mutex_lock ( & pool -> pool_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh" ) ; goto resend ; } applog ( LOG_DEBUG , "Initiate<S2SV_blank>stratum<S2SV_blank>failed" ) ; if ( pool -> sock != INVSOCK ) { shutdown ( pool -> sock , SHUT_RDWR ) ; pool -> sock = INVSOCK ; } } return ret ; }
CWE-416 static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }
CWE-119 static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }
CWE-119 static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size , <S2SV_StartBug> vp9_coeff_stats * coef_branch_ct ) { <S2SV_EndBug> <S2SV_StartBug> vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <S2SV_EndBug> vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ; unsigned int ( * eob_branch_ct ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { vp9_tree_probs_from_distribution ( vp9_coef_tree , coef_branch_ct [ i ] [ j ] [ k ] [ l ] , coef_counts [ i ] [ j ] [ k ] [ l ] ) ; coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 1 ] = eob_branch_ct [ i ] [ j ] [ k ] [ l ] - coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 0 ] ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) coef_probs [ i ] [ j ] [ k ] [ l ] [ m ] = get_binary_prob ( coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 0 ] , coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 1 ] ) ; } } } } }
CWE-284 void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ; <S2SV_StartBug> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) <S2SV_EndBug> <S2SV_StartBug> pthread_mutex_unlock ( & slot_lock ) ; <S2SV_EndBug> <S2SV_StartBug> BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; <S2SV_EndBug> } else { LOG_ERROR ( "%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>read<S2SV_blank>while<S2SV_blank>disconnected,<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( "%s<S2SV_blank>socket<S2SV_blank>signaled<S2SV_blank>for<S2SV_blank>write<S2SV_blank>while<S2SV_blank>disconnected<S2SV_blank>(or<S2SV_blank>write<S2SV_blank>failure),<S2SV_blank>slot:<S2SV_blank>%d,<S2SV_blank>channel:<S2SV_blank>%d" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; <S2SV_StartBug> if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) <S2SV_EndBug> cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; }
CWE-000 int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , "\\r\\n***<S2SV_blank>pulse<S2SV_blank>DTR<S2SV_blank>***\\r\\n" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , "***<S2SV_blank>FAILED\\r\\n" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , "\\r\\n***<S2SV_blank>DTR:<S2SV_blank>%s<S2SV_blank>***\\r\\n" , dtr_up ? "up" : "down" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , "\\r\\n***<S2SV_blank>baud:<S2SV_blank>%d<S2SV_blank>(%d)<S2SV_blank>***\\r\\n" , opts . baud , newbaud ) ; } else { fd_printf ( STO , "\\r\\n***<S2SV_blank>baud:<S2SV_blank>%d<S2SV_blank>***\\r\\n" , opts . baud ) ; } set_tty_write_sz ( newbaud ) ; break ; case KEY_FLOW : opts . flow = flow_next ( opts . flow ) ; term_set_flowcntrl ( tty_fd , opts . flow ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newflow = term_get_flowcntrl ( tty_fd ) ; if ( opts . flow != newflow ) { fd_printf ( STO , "\\r\\n***<S2SV_blank>flow:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>***\\r\\n" , flow_str [ opts . flow ] , flow_str [ newflow ] ) ; } else { fd_printf ( STO , "\\r\\n***<S2SV_blank>flow:<S2SV_blank>%s<S2SV_blank>***\\r\\n" , flow_str [ opts . flow ] ) ; } break ; case KEY_PARITY : opts . parity = parity_next ( opts . parity ) ; term_set_parity ( tty_fd , opts . parity ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newparity = term_get_parity ( tty_fd ) ; if ( opts . parity != newparity ) { fd_printf ( STO , "\\r\\n***<S2SV_blank>parity:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>***\\r\\n" , parity_str [ opts . parity ] , parity_str [ newparity ] ) ; } else { fd_printf ( STO , "\\r\\n***<S2SV_blank>parity:<S2SV_blank>%s<S2SV_blank>***\\r\\n" , parity_str [ opts . parity ] ) ; } break ; case KEY_BITS : opts . databits = bits_next ( opts . databits ) ; term_set_databits ( tty_fd , opts . databits ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbits = term_get_databits ( tty_fd ) ; if ( opts . databits != newbits ) { fd_printf ( STO , "\\r\\n***<S2SV_blank>databits:<S2SV_blank>%d<S2SV_blank>(%d)<S2SV_blank>***\\r\\n" , opts . databits , newbits ) ; } else { fd_printf ( STO , "\\r\\n***<S2SV_blank>databits:<S2SV_blank>%d<S2SV_blank>***\\r\\n" , opts . databits ) ; } break ; case KEY_LECHO : opts . lecho = ! opts . lecho ; fd_printf ( STO , "\\r\\n***<S2SV_blank>local<S2SV_blank>echo:<S2SV_blank>%s<S2SV_blank>***\\r\\n" , opts . lecho ? "yes" : "no" ) ; break ; case KEY_SEND : case KEY_RECEIVE : xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; if ( xfr_cmd [ 0 ] == '\\0' ) { fd_printf ( STO , "\\r\\n***<S2SV_blank>command<S2SV_blank>disabled<S2SV_blank>***\\r\\n" ) ; break ; } fname = read_filename ( ) ; if ( fname == NULL ) { fd_printf ( STO , "***<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>filename<S2SV_blank>***\\r\\n" ) ; break ; } <S2SV_StartBug> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; <S2SV_EndBug> free ( fname ) ; break ; case KEY_BREAK : term_break ( tty_fd ) ; fd_printf ( STO , "\\r\\n***<S2SV_blank>break<S2SV_blank>sent<S2SV_blank>***\\r\\n" ) ; break ; default : break ; } return 0 ; }
CWE-119 char * suhosin_decrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key , char * * where TSRMLS_DC ) { <S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> char buffer2 [ 4096 ] ; int o_name_len = name_len ; <S2SV_StartBug> char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; <S2SV_EndBug> int l ; <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> buf = estrndup ( name , name_len ) ; <S2SV_StartBug> } else { <S2SV_EndBug> memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { decrypt_return_plain : <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , value , value_len ) ; * where += value_len ; return * where ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto decrypt_return_plain ; } } <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_decrypt_string ( buf2 , value_len , buf , name_len , key , & l , SUHOSIN_G ( cookie_checkraddr ) TSRMLS_CC ) ; if ( d == NULL ) { goto skip_cookie ; } d_url = php_url_encode ( d , l , & l ) ; efree ( d ) ; memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , d_url , l ) ; * where += l ; efree ( d_url ) ; skip_cookie : <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return * where ; }
CWE-399 static void do_local_notify ( xmlNode * notify_src , const char * client_id , gboolean sync_reply , gboolean from_peer ) { cib_client_t * client_obj = NULL ; int local_rc = pcmk_ok ; if ( client_id != NULL ) { client_obj = g_hash_table_lookup ( client_list , client_id ) ; } else { crm_trace ( "No<S2SV_blank>client<S2SV_blank>to<S2SV_blank>sent<S2SV_blank>the<S2SV_blank>response<S2SV_blank>to.<S2SV_blank>F_CIB_CLIENTID<S2SV_blank>not<S2SV_blank>set." ) ; } if ( client_obj == NULL ) { local_rc = - ECONNRESET ; } else { int rid = 0 ; if ( sync_reply ) { <S2SV_StartBug> CRM_LOG_ASSERT ( client_obj -> request_id ) ; <S2SV_EndBug> rid = client_obj -> request_id ; client_obj -> request_id = 0 ; crm_trace ( "Sending<S2SV_blank>response<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s" , <S2SV_StartBug> rid , client_obj -> name , from_peer ? "(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)" : "" ) ; <S2SV_EndBug> } else { crm_trace ( "Sending<S2SV_blank>an<S2SV_blank>event<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s" , client_obj -> name , from_peer ? "(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)" : "" ) ; } if ( client_obj -> ipc && crm_ipcs_send ( client_obj -> ipc , rid , notify_src , ! sync_reply ) < 0 ) { local_rc = - ENOMSG ; # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client_obj -> session ) { crm_send_remote_msg ( client_obj -> session , notify_src , client_obj -> encrypted ) ; # endif } else if ( client_obj -> ipc == NULL ) { crm_err ( "Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s" , client_obj -> name ) ; } } if ( local_rc != pcmk_ok && client_obj != NULL ) { crm_warn ( "%sSync<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s" , sync_reply ? "" : "A-" , client_obj ? client_obj -> name : "<unknown>" , pcmk_strerror ( local_rc ) ) ; } }
CWE-000 int nfs3svc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
CWE-399 void xsltGenerateIdFunction ( xmlXPathParserContextPtr ctxt , int nargs ) { <S2SV_StartBug> xmlNodePtr cur = NULL ; <S2SV_EndBug> long val ; xmlChar str [ 30 ] ; xmlDocPtr doc ; if ( nargs == 0 ) { cur = ctxt -> context -> node ; } else if ( nargs == 1 ) { <S2SV_StartBug> xmlXPathObjectPtr obj ; <S2SV_EndBug> xmlNodeSetPtr nodelist ; int i , ret ; if ( ( ctxt -> value == NULL ) || ( ctxt -> value -> type != XPATH_NODESET ) ) { ctxt -> error = XPATH_INVALID_TYPE ; xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , "generate-id()<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>arg<S2SV_blank>expecting<S2SV_blank>a<S2SV_blank>node-set\\n" ) ; return ; } obj = valuePop ( ctxt ) ; nodelist = obj -> nodesetval ; if ( ( nodelist == NULL ) || ( nodelist -> nodeNr <= 0 ) ) { xmlXPathFreeObject ( obj ) ; valuePush ( ctxt , xmlXPathNewCString ( "" ) ) ; return ; } cur = nodelist -> nodeTab [ 0 ] ; for ( i = 1 ; i < nodelist -> nodeNr ; i ++ ) { ret = xmlXPathCmpNodes ( cur , nodelist -> nodeTab [ i ] ) ; if ( ret == - 1 ) cur = nodelist -> nodeTab [ i ] ; } <S2SV_StartBug> xmlXPathFreeObject ( obj ) ; <S2SV_EndBug> } else { xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , "generate-id()<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>args<S2SV_blank>%d\\n" , nargs ) ; ctxt -> error = XPATH_INVALID_ARITY ; return ; } if ( cur -> type != XML_NAMESPACE_DECL ) doc = cur -> doc ; else { xmlNsPtr ns = ( xmlNsPtr ) cur ; if ( ns -> context != NULL ) doc = ns -> context ; else doc = ctxt -> context -> doc ; } <S2SV_StartBug> val = ( long ) ( ( char * ) cur - ( char * ) doc ) ; <S2SV_EndBug> if ( val >= 0 ) { sprintf ( ( char * ) str , "idp%ld" , val ) ; } else { sprintf ( ( char * ) str , "idm%ld" , - val ) ; } valuePush ( ctxt , xmlXPathNewString ( str ) ) ; }
CWE-119 int vp8_get_preview_raw_frame ( VP8_COMP * cpi , YV12_BUFFER_CONFIG * dest , vp8_ppflags_t * flags ) { if ( cpi -> common . refresh_alt_ref_frame ) return - 1 ; else { int ret ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif # if CONFIG_POSTPROC cpi -> common . show_frame_mi = cpi -> common . mi ; ret = vp8_post_proc_frame ( & cpi -> common , dest , flags ) ; # else <S2SV_StartBug> if ( cpi -> common . frame_to_show ) <S2SV_EndBug> { * dest = * cpi -> common . frame_to_show ; dest -> y_width = cpi -> common . Width ; dest -> y_height = cpi -> common . Height ; dest -> uv_height = cpi -> common . Height / 2 ; ret = 0 ; } else { ret = - 1 ; } # endif vp8_clear_system_state ( ) ; return ret ; } }
CWE-119 vpx_codec_err_t vpx_svc_set_options ( SvcContext * svc_ctx , const char * options ) { <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || options == NULL || si == NULL ) { return VPX_CODEC_INVALID_PARAM ; } strncpy ( si -> options , options , sizeof ( si -> options ) ) ; si -> options [ sizeof ( si -> options ) - 1 ] = '\\0' ; return VPX_CODEC_OK ; }
CWE-284 static inline int btif_hl_select_wake_reset ( void ) { char sig_recv = 0 ; BTIF_TRACE_DEBUG ( "btif_hl_select_wake_reset" ) ; <S2SV_StartBug> recv ( signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> return ( int ) sig_recv ; }
CWE-000 int sshkey_load_file ( int fd , struct sshbuf * blob ) { u_char buf [ 1024 ] ; size_t len ; struct stat st ; <S2SV_StartBug> int r ; <S2SV_EndBug> if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ; if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { if ( errno == EPIPE ) break ; r = SSH_ERR_SYSTEM_ERROR ; goto out ; } if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) goto out ; if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } } if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size != ( off_t ) sshbuf_len ( blob ) ) { r = SSH_ERR_FILE_CHANGED ; goto out ; } r = 0 ; out : explicit_bzero ( buf , sizeof ( buf ) ) ; if ( r != 0 ) sshbuf_reset ( blob ) ; return r ; }
CWE-20 static MagickBooleanType ReadUncompressedRGBA ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { PixelPacket * q ; ssize_t alphaBits , x , y ; unsigned short color ; alphaBits = 0 ; if ( dds_info -> pixelformat . rgb_bitcount == 16 ) { if ( IsBitMask ( dds_info -> pixelformat , 0x7c00 , 0x03e0 , 0x001f , 0x8000 ) ) alphaBits = 1 ; else if ( IsBitMask ( dds_info -> pixelformat , 0x00ff , 0x00ff , 0x00ff , 0xff00 ) ) { alphaBits = 2 ; ( void ) SetImageType ( image , GrayscaleMatteType ) ; } else if ( IsBitMask ( dds_info -> pixelformat , 0x0f00 , 0x00f0 , 0x000f , 0xf000 ) ) alphaBits = 4 ; else ThrowBinaryException ( CorruptImageError , "ImageTypeNotSupported" , image -> filename ) ; } for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , dds_info -> width , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x ++ ) { if ( dds_info -> pixelformat . rgb_bitcount == 16 ) { color = ReadBlobShort ( image ) ; if ( alphaBits == 1 ) { SetPixelAlpha ( q , ( color & ( 1 << 15 ) ) ? QuantumRange : 0 ) ; SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color << 1 ) >> 11 ) / 31.0 ) * 255 ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color << 6 ) >> 11 ) / 31.0 ) * 255 ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color << 11 ) >> 11 ) / 31.0 ) * 255 ) ) ) ; } else if ( alphaBits == 2 ) { SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ( color >> 8 ) ) ) ; SetPixelGray ( q , ScaleCharToQuantum ( ( unsigned char ) color ) ) ; } else { SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( color >> 12 ) / 15.0 ) * 255 ) ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color << 4 ) >> 12 ) / 15.0 ) * 255 ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color << 8 ) >> 12 ) / 15.0 ) * 255 ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ( ( ( ( unsigned short ) ( color << 12 ) >> 12 ) / 15.0 ) * 255 ) ) ) ; } } else { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } <S2SV_StartBug> SkipRGBMipmaps ( image , dds_info , 4 ) ; <S2SV_EndBug> return MagickTrue ; }
CWE-189 static void add_bytes_c ( uint8_t * dst , uint8_t * src , int w ) { long i ; <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src + i ) ; long b = * ( long * ) ( dst + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] += src [ i + 0 ] ; }
CWE-125 static void rtc_irq_eoi_tracking_reset ( struct kvm_ioapic * ioapic ) { ioapic -> rtc_status . pending_eoi = 0 ; <S2SV_StartBug> bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <S2SV_EndBug> }
CWE-264 FepClient * fep_client_open ( const char * address ) { FepClient * client ; struct sockaddr_un sun ; ssize_t sun_len ; int retval ; if ( ! address ) address = getenv ( "LIBFEP_CONTROL_SOCK" ) ; if ( ! address ) return NULL ; if ( strlen ( address ) + 1 >= sizeof ( sun . sun_path ) ) { fep_log ( FEP_LOG_LEVEL_WARNING , "unix<S2SV_blank>domain<S2SV_blank>socket<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>%d<S2SV_blank>+<S2SV_blank>1<S2SV_blank>>=<S2SV_blank>%d" , strlen ( address ) , sizeof ( sun . sun_path ) ) ; free ( address ) ; return NULL ; } client = xzalloc ( sizeof ( FepClient ) ) ; client -> filter_running = false ; client -> messages = NULL ; memset ( & sun , 0 , sizeof ( struct sockaddr_un ) ) ; sun . sun_family = AF_UNIX ; <S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> memcpy ( sun . sun_path + 1 , address , strlen ( address ) ) ; <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ; <S2SV_EndBug> # else memcpy ( sun . sun_path , address , strlen ( address ) ) ; sun_len = sizeof ( struct sockaddr_un ) ; # endif client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; if ( client -> control < 0 ) { free ( client ) ; return NULL ; } retval = connect ( client -> control , ( const struct sockaddr * ) & sun , sun_len ) ; if ( retval < 0 ) { close ( client -> control ) ; free ( client ) ; return NULL ; } return client ; }
CWE-264 int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( "%s:<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>null!" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = "camera_metadata" , . alignment = METADATA_ALIGNMENT } , { . name = "camera_metadata_buffer_entry" , . alignment = ENTRY_ALIGNMENT } , { . name = "camera_metadata_data" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( "%s:<S2SV_blank>Metadata<S2SV_blank>pointer<S2SV_blank>is<S2SV_blank>not<S2SV_blank>aligned<S2SV_blank>(actual<S2SV_blank>%p,<S2SV_blank>" "expected<S2SV_blank>%p)<S2SV_blank>to<S2SV_blank>type<S2SV_blank>%s" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( "%s:<S2SV_blank>Metadata<S2SV_blank>size<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>expected<S2SV_blank>size<S2SV_blank>(%zu)" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>count<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>entry<S2SV_blank>capacity<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity ) ; return ERROR ; } <S2SV_StartBug> const metadata_uptrdiff_t entries_end = <S2SV_EndBug> metadata -> entries_start + metadata -> entry_capacity ; if ( entries_end < metadata -> entries_start || entries_end > metadata -> data_start ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>start<S2SV_blank>+<S2SV_blank>capacity<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>data<S2SV_blank>start<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , ( metadata -> entries_start + metadata -> entry_capacity ) , metadata -> data_start ) ; return ERROR ; } const metadata_uptrdiff_t data_end = metadata -> data_start + metadata -> data_capacity ; if ( data_end < metadata -> data_start || data_end > metadata -> size ) { ALOGE ( "%s:<S2SV_blank>Data<S2SV_blank>start<S2SV_blank>+<S2SV_blank>capacity<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>total<S2SV_blank>size<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , ( metadata -> data_start + metadata -> data_capacity ) , metadata -> size ) ; return ERROR ; } const metadata_size_t entry_count = metadata -> entry_count ; camera_metadata_buffer_entry_t * entries = get_entries ( metadata ) ; for ( size_t i = 0 ; i < entry_count ; ++ i ) { if ( ( uintptr_t ) & entries [ i ] != ALIGN_TO ( & entries [ i ] , ENTRY_ALIGNMENT ) ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>bad<S2SV_blank>alignment<S2SV_blank>(address<S2SV_blank>%p)," "<S2SV_blank>expected<S2SV_blank>alignment<S2SV_blank>%zu" , __FUNCTION__ , i , & entries [ i ] , ENTRY_ALIGNMENT ) ; return ERROR ; } camera_metadata_buffer_entry_t entry = entries [ i ] ; if ( entry . type >= NUM_TYPES ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>a<S2SV_blank>bad<S2SV_blank>type<S2SV_blank>%d" , __FUNCTION__ , i , entry . type ) ; return ERROR ; } uint32_t tag_section = entry . tag >> 16 ; int tag_type = get_camera_metadata_tag_type ( entry . tag ) ; if ( tag_type != ( int ) entry . type && tag_section < VENDOR_SECTION ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>tag<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%d" , __FUNCTION__ , i , tag_type , entry . type ) ; return ERROR ; } size_t data_size ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , entry . type , entry . count ) != OK ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>invalid.<S2SV_blank>type:<S2SV_blank>%u<S2SV_blank>count:<S2SV_blank>%u" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; } if ( data_size != 0 ) { camera_metadata_data_t * data = ( camera_metadata_data_t * ) ( get_data ( metadata ) + entry . data . offset ) ; if ( ( uintptr_t ) data != ALIGN_TO ( data , DATA_ALIGNMENT ) ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>bad<S2SV_blank>data<S2SV_blank>alignment<S2SV_blank>(address<S2SV_blank>%p)," "<S2SV_blank>expected<S2SV_blank>align<S2SV_blank>%zu,<S2SV_blank>(tag<S2SV_blank>name<S2SV_blank>%s,<S2SV_blank>data<S2SV_blank>size<S2SV_blank>%zu)" , __FUNCTION__ , i , data , DATA_ALIGNMENT , get_camera_metadata_tag_name ( entry . tag ) ? : "unknown" , data_size ) ; return ERROR ; } size_t data_entry_end = entry . data . offset + data_size ; if ( data_entry_end < entry . data . offset || data_entry_end > metadata -> data_capacity ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>(%zu)<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>capacity<S2SV_blank>" "%" PRIu32 , __FUNCTION__ , i , data_entry_end , metadata -> data_capacity ) ; return ERROR ; } } else if ( entry . count == 0 ) { if ( entry . data . offset != 0 ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>index<S2SV_blank>%zu<S2SV_blank>had<S2SV_blank>0<S2SV_blank>items,<S2SV_blank>but<S2SV_blank>offset<S2SV_blank>was<S2SV_blank>non-0<S2SV_blank>" "(%" PRIu32 "),<S2SV_blank>tag<S2SV_blank>name:<S2SV_blank>%s" , __FUNCTION__ , i , entry . data . offset , get_camera_metadata_tag_name ( entry . tag ) ? : "unknown" ) ; return ERROR ; } } } return OK ; }
CWE-190 jas_stream_t * jas_stream_memopen ( char * buf , int bufsize ) { <S2SV_StartBug> jas_stream_t * stream ; <S2SV_EndBug> jas_stream_memobj_t * obj ; JAS_DBGLOG ( 100 , ( "jas_stream_memopen(%p,<S2SV_blank>%d)\\n" , buf , bufsize ) ) ; <S2SV_StartBug> if ( ! ( stream = jas_stream_create ( ) ) ) { <S2SV_EndBug> return 0 ; } stream -> openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY ; jas_stream_initbuf ( stream , JAS_STREAM_FULLBUF , 0 , 0 ) ; stream -> ops_ = & jas_stream_memops ; if ( ! ( obj = jas_malloc ( sizeof ( jas_stream_memobj_t ) ) ) ) { jas_stream_destroy ( stream ) ; return 0 ; } stream -> obj_ = ( void * ) obj ; obj -> myalloc_ = 0 ; obj -> buf_ = 0 ; if ( bufsize <= 0 ) { <S2SV_StartBug> obj -> bufsize_ = 1024 ; <S2SV_EndBug> obj -> growable_ = 1 ; } else { <S2SV_StartBug> obj -> bufsize_ = bufsize ; <S2SV_EndBug> <S2SV_StartBug> obj -> growable_ = 0 ; <S2SV_EndBug> } if ( buf ) { obj -> buf_ = ( unsigned char * ) buf ; } else { obj -> buf_ = jas_malloc ( obj -> bufsize_ ) ; obj -> myalloc_ = 1 ; } if ( ! obj -> buf_ ) { jas_stream_close ( stream ) ; return 0 ; } JAS_DBGLOG ( 100 , ( "jas_stream_memopen<S2SV_blank>buffer<S2SV_blank>buf=%p<S2SV_blank>myalloc=%d\\n" , obj -> buf_ , obj -> myalloc_ ) ) ; if ( bufsize > 0 && buf ) { obj -> len_ = bufsize ; } else { obj -> len_ = 0 ; } obj -> pos_ = 0 ; return stream ; }
CWE-119 int vp9_get_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) { int i ; InternalFrameBufferList * const int_fb_list = ( InternalFrameBufferList * ) cb_priv ; if ( int_fb_list == NULL ) return - 1 ; for ( i = 0 ; i < int_fb_list -> num_internal_frame_buffers ; ++ i ) { if ( ! int_fb_list -> int_fb [ i ] . in_use ) break ; } if ( i == int_fb_list -> num_internal_frame_buffers ) return - 1 ; if ( int_fb_list -> int_fb [ i ] . size < min_size ) { int_fb_list -> int_fb [ i ] . data = ( uint8_t * ) vpx_realloc ( int_fb_list -> int_fb [ i ] . data , min_size ) ; if ( ! int_fb_list -> int_fb [ i ] . data ) return - 1 ; <S2SV_StartBug> int_fb_list -> int_fb [ i ] . size = min_size ; <S2SV_EndBug> } fb -> data = int_fb_list -> int_fb [ i ] . data ; fb -> size = int_fb_list -> int_fb [ i ] . size ; int_fb_list -> int_fb [ i ] . in_use = 1 ; fb -> priv = & int_fb_list -> int_fb [ i ] ; return 0 ; }
CWE-119 UWORD32 ihevcd_cabac_decode_bypass_bins_egk ( cab_ctxt_t * ps_cabac , bitstrm_t * ps_bitstrm , WORD32 k ) { UWORD32 u4_sym ; WORD32 numones ; WORD32 bin ; ASSERT ( ( k >= 0 ) ) ; numones = k ; bin = 1 ; u4_sym = 0 ; <S2SV_StartBug> while ( bin ) <S2SV_EndBug> { IHEVCD_CABAC_DECODE_BYPASS_BIN ( bin , ps_cabac , ps_bitstrm ) ; u4_sym += bin << numones ++ ; } <S2SV_StartBug> numones -= 1 ; <S2SV_EndBug> numones = CLIP3 ( numones , 0 , 16 ) ; if ( numones ) { UWORD32 u4_suffix ; IHEVCD_CABAC_DECODE_BYPASS_BINS ( u4_suffix , ps_cabac , ps_bitstrm , numones ) ; u4_sym += u4_suffix ; } return ( u4_sym ) ; }
CWE-20 static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) { GdkScreen * screen ; char * uri ; GFile * file ; switch ( response_id ) { <S2SV_StartBug> case RESPONSE_RUN : <S2SV_EndBug> { screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; uri = nautilus_file_get_uri ( parameters -> file ) ; DEBUG ( "Launching<S2SV_blank>untrusted<S2SV_blank>launcher<S2SV_blank>%s" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; case RESPONSE_MARK_TRUSTED : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; g_object_unref ( file ) ; } break ; default : { } break ; } gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ; activate_parameters_desktop_free ( parameters ) ; }
CWE-000 void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_PEREF_NO_NAME , "PEReference:<S2SV_blank>no<S2SV_blank>name\\n" ) ; return ; } if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , "PEReference:<S2SV_blank>%s\\n" , name ) ; if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_PEREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , name ) ; } else { if ( ( ctxt -> validate ) && ( ctxt -> vctxt . error != NULL ) ) { xmlValidityError ( ctxt , XML_WAR_UNDECLARED_ENTITY , "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , name , NULL ) ; } else xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , "Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\n" , name , NULL ) ; } else { xmlChar start [ 4 ] ; xmlCharEncoding enc ; if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ; input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_StartBug> if ( xmlPushInput ( ctxt , input ) < 0 ) <S2SV_EndBug> return ; if ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) { GROW if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( ( ctxt -> input -> end - ctxt -> input -> cur ) >= 4 ) { start [ 0 ] = RAW ; start [ 1 ] = NXT ( 1 ) ; start [ 2 ] = NXT ( 2 ) ; start [ 3 ] = NXT ( 3 ) ; enc = xmlDetectCharEncoding ( start , 4 ) ; if ( enc != XML_CHAR_ENCODING_NONE ) { xmlSwitchEncoding ( ctxt , enc ) ; } } if ( ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { xmlParseTextDecl ( ctxt ) ; } } } } ctxt -> hasPErefs = 1 ; }
CWE-119 WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; if ( u4_trailing_ones < 3 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : 1 ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = 2 + ( MIN ( u4_lev_prefix , 15 ) << 1 ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } } else { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = ( u4_lev_prefix - 3 ) ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } if ( u4_total_coeff < ( 16 - u4_isdc ) ) { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 16 ] = ( const UWORD8 ( * ) [ 16 ] ) gau1_ih264d_table_total_zero_11to15 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 4 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 11 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }
CWE-362 static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> limit = ( limit << 12 ) + 0xfff ; return limit ; }
CWE-119 static void y4m_convert_mono_420jpeg ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> int c_sz ; <S2SV_EndBug> _dst += _y4m -> pic_w * _y4m -> pic_h ; c_sz = ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ; memset ( _dst , 128 , c_sz * 2 ) ; }
CWE-119 int yr_object_array_set_item ( YR_OBJECT * object , YR_OBJECT * item , int index ) { YR_OBJECT_ARRAY * array ; int i ; int count ; assert ( index >= 0 ) ; assert ( object -> type == OBJECT_TYPE_ARRAY ) ; array = object_as_array ( object ) ; if ( array -> items == NULL ) { <S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; memset ( array -> items -> objects , 0 , count * sizeof ( YR_OBJECT * ) ) ; array -> items -> count = count ; } else if ( index >= array -> items -> count ) { count = array -> items -> count * 2 ; <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; for ( i = array -> items -> count ; i < count ; i ++ ) array -> items -> objects [ i ] = NULL ; array -> items -> count = count ; } item -> parent = object ; array -> items -> objects [ index ] = item ; return ERROR_SUCCESS ; }
CWE-362 static int smb_send_kvec ( struct TCP_Server_Info * server , struct kvec * iov , size_t n_vec , size_t * sent ) { int rc = 0 ; int i = 0 ; struct msghdr smb_msg ; unsigned int remaining ; size_t first_vec = 0 ; struct socket * ssocket = server -> ssocket ; <S2SV_StartBug> * sent = 0 ; <S2SV_EndBug> if ( ssocket == NULL ) return - ENOTSOCK ; smb_msg . msg_name = ( struct sockaddr * ) & server -> dstaddr ; smb_msg . msg_namelen = sizeof ( struct sockaddr ) ; smb_msg . msg_control = NULL ; smb_msg . msg_controllen = 0 ; if ( server -> noblocksnd ) smb_msg . msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL ; else smb_msg . msg_flags = MSG_NOSIGNAL ; remaining = 0 ; for ( i = 0 ; i < n_vec ; i ++ ) remaining += iov [ i ] . iov_len ; i = 0 ; while ( remaining ) { rc = kernel_sendmsg ( ssocket , & smb_msg , & iov [ first_vec ] , n_vec - first_vec , remaining ) ; if ( rc == - ENOSPC || rc == - EAGAIN ) { WARN_ON_ONCE ( rc == - ENOSPC ) ; i ++ ; if ( i >= 14 || ( ! server -> noblocksnd && ( i > 2 ) ) ) { cERROR ( 1 , "sends<S2SV_blank>on<S2SV_blank>sock<S2SV_blank>%p<S2SV_blank>stuck<S2SV_blank>for<S2SV_blank>15<S2SV_blank>" "seconds" , ssocket ) ; rc = - EAGAIN ; break ; } msleep ( 1 << i ) ; continue ; } if ( rc < 0 ) break ; * sent += rc ; if ( rc == remaining ) { remaining = 0 ; break ; } if ( rc > remaining ) { cERROR ( 1 , "sent<S2SV_blank>%d<S2SV_blank>requested<S2SV_blank>%d" , rc , remaining ) ; break ; } if ( rc == 0 ) { cERROR ( 1 , "tcp<S2SV_blank>sent<S2SV_blank>no<S2SV_blank>data" ) ; msleep ( 500 ) ; continue ; } remaining -= rc ; for ( i = first_vec ; i < n_vec ; i ++ ) { if ( iov [ i ] . iov_len ) { if ( rc > iov [ i ] . iov_len ) { rc -= iov [ i ] . iov_len ; iov [ i ] . iov_len = 0 ; } else { iov [ i ] . iov_base += rc ; iov [ i ] . iov_len -= rc ; first_vec = i ; break ; } } } i = 0 ; rc = 0 ; } return rc ; }
CWE-399 static int dcbnl_cee_fill ( struct sk_buff * skb , struct net_device * netdev ) { struct nlattr * cee , * app ; struct dcb_app_type * itr ; const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; int dcbx , i , err = - EMSGSIZE ; u8 value ; if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) goto nla_put_failure ; cee = nla_nest_start ( skb , DCB_ATTR_CEE ) ; if ( ! cee ) goto nla_put_failure ; if ( ops -> getpgtccfgtx && ops -> getpgbwgcfgtx ) { err = dcbnl_cee_pg_fill ( skb , netdev , 1 ) ; if ( err ) goto nla_put_failure ; } if ( ops -> getpgtccfgrx && ops -> getpgbwgcfgrx ) { err = dcbnl_cee_pg_fill ( skb , netdev , 0 ) ; if ( err ) goto nla_put_failure ; } if ( ops -> getpfccfg ) { struct nlattr * pfc_nest = nla_nest_start ( skb , DCB_ATTR_CEE_PFC ) ; if ( ! pfc_nest ) goto nla_put_failure ; for ( i = DCB_PFC_UP_ATTR_0 ; i <= DCB_PFC_UP_ATTR_7 ; i ++ ) { ops -> getpfccfg ( netdev , i - DCB_PFC_UP_ATTR_0 , & value ) ; if ( nla_put_u8 ( skb , i , value ) ) goto nla_put_failure ; } nla_nest_end ( skb , pfc_nest ) ; } spin_lock ( & dcb_lock ) ; app = nla_nest_start ( skb , DCB_ATTR_CEE_APP_TABLE ) ; if ( ! app ) goto dcb_unlock ; list_for_each_entry ( itr , & dcb_app_list , list ) { if ( itr -> ifindex == netdev -> ifindex ) { struct nlattr * app_nest = nla_nest_start ( skb , DCB_ATTR_APP ) ; if ( ! app_nest ) goto dcb_unlock ; err = nla_put_u8 ( skb , DCB_APP_ATTR_IDTYPE , itr -> app . selector ) ; if ( err ) goto dcb_unlock ; err = nla_put_u16 ( skb , DCB_APP_ATTR_ID , itr -> app . protocol ) ; if ( err ) goto dcb_unlock ; err = nla_put_u8 ( skb , DCB_APP_ATTR_PRIORITY , itr -> app . priority ) ; if ( err ) goto dcb_unlock ; nla_nest_end ( skb , app_nest ) ; } } nla_nest_end ( skb , app ) ; if ( netdev -> dcbnl_ops -> getdcbx ) dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; else dcbx = - EOPNOTSUPP ; spin_unlock ( & dcb_lock ) ; if ( ops -> getfeatcfg ) { struct nlattr * feat = nla_nest_start ( skb , DCB_ATTR_CEE_FEAT ) ; if ( ! feat ) goto nla_put_failure ; for ( i = DCB_FEATCFG_ATTR_ALL + 1 ; i <= DCB_FEATCFG_ATTR_MAX ; i ++ ) if ( ! ops -> getfeatcfg ( netdev , i , & value ) && nla_put_u8 ( skb , i , value ) ) goto nla_put_failure ; nla_nest_end ( skb , feat ) ; } if ( ops -> cee_peer_getpg ) { struct cee_pg pg ; <S2SV_StartBug> err = ops -> cee_peer_getpg ( netdev , & pg ) ; <S2SV_EndBug> if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PG , sizeof ( pg ) , & pg ) ) goto nla_put_failure ; } if ( ops -> cee_peer_getpfc ) { <S2SV_StartBug> struct cee_pfc pfc ; <S2SV_EndBug> err = ops -> cee_peer_getpfc ( netdev , & pfc ) ; if ( ! err && nla_put ( skb , DCB_ATTR_CEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) goto nla_put_failure ; } if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { err = dcbnl_build_peer_app ( netdev , skb , DCB_ATTR_CEE_PEER_APP_TABLE , DCB_ATTR_CEE_PEER_APP_INFO , DCB_ATTR_CEE_PEER_APP ) ; if ( err ) goto nla_put_failure ; } nla_nest_end ( skb , cee ) ; if ( dcbx >= 0 ) { err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; if ( err ) goto nla_put_failure ; } return 0 ; dcb_unlock : spin_unlock ( & dcb_lock ) ; nla_put_failure : return err ; }
CWE-399 static void rpc_init_task ( struct rpc_task * task , const struct rpc_task_setup * task_setup_data ) { memset ( task , 0 , sizeof ( * task ) ) ; atomic_set ( & task -> tk_count , 1 ) ; task -> tk_flags = task_setup_data -> flags ; task -> tk_ops = task_setup_data -> callback_ops ; task -> tk_calldata = task_setup_data -> callback_data ; INIT_LIST_HEAD ( & task -> tk_task ) ; task -> tk_garb_retry = 2 ; task -> tk_cred_retry = 2 ; <S2SV_StartBug> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <S2SV_EndBug> task -> tk_owner = current -> tgid ; task -> tk_workqueue = task_setup_data -> workqueue ; if ( task -> tk_ops -> rpc_call_prepare != NULL ) task -> tk_action = rpc_prepare_task ; task -> tk_start = ktime_get ( ) ; dprintk ( "RPC:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>new<S2SV_blank>task<S2SV_blank>initialized,<S2SV_blank>procpid<S2SV_blank>%u\\n" , task_pid_nr ( current ) ) ; }
CWE-119 vpx_codec_err_t vpx_codec_set_frame_buffer_functions ( vpx_codec_ctx_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { vpx_codec_err_t res ; if ( ! ctx || ! cb_get || ! cb_release ) { res = VPX_CODEC_INVALID_PARAM ; } else if ( ! ctx -> iface || ! ctx -> priv || ! ( ctx -> iface -> caps & VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER ) ) { res = VPX_CODEC_ERROR ; } else { <S2SV_StartBug> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <S2SV_EndBug> cb_priv ) ; } return SAVE_STATUS ( ctx , res ) ; }
CWE-399 void br_mdb_notify ( struct net_device * dev , struct net_bridge_port * port , struct br_ip * group , int type ) { <S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug> entry . ifindex = port -> dev -> ifindex ; entry . addr . proto = group -> proto ; entry . addr . u . ip4 = group -> u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) entry . addr . u . ip6 = group -> u . ip6 ; # endif __br_mdb_notify ( dev , & entry , type ) ; }
CWE-416 PHP_MINIT_FUNCTION ( spl_array ) { REGISTER_SPL_STD_CLASS_EX ( ArrayObject , spl_array_object_new , spl_funcs_ArrayObject ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Aggregate ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Countable ) ; memcpy ( & spl_handler_ArrayObject , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; spl_handler_ArrayObject . clone_obj = spl_array_object_clone ; spl_handler_ArrayObject . read_dimension = spl_array_read_dimension ; spl_handler_ArrayObject . write_dimension = spl_array_write_dimension ; spl_handler_ArrayObject . unset_dimension = spl_array_unset_dimension ; spl_handler_ArrayObject . has_dimension = spl_array_has_dimension ; spl_handler_ArrayObject . count_elements = spl_array_object_count_elements ; spl_handler_ArrayObject . get_properties = spl_array_get_properties ; <S2SV_StartBug> spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ; <S2SV_EndBug> spl_handler_ArrayObject . read_property = spl_array_read_property ; spl_handler_ArrayObject . write_property = spl_array_write_property ; spl_handler_ArrayObject . get_property_ptr_ptr = spl_array_get_property_ptr_ptr ; spl_handler_ArrayObject . has_property = spl_array_has_property ; spl_handler_ArrayObject . unset_property = spl_array_unset_property ; spl_handler_ArrayObject . compare_objects = spl_array_compare_objects ; REGISTER_SPL_STD_CLASS_EX ( ArrayIterator , spl_array_object_new , spl_funcs_ArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Iterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , SeekableIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Countable ) ; memcpy ( & spl_handler_ArrayIterator , & spl_handler_ArrayObject , sizeof ( zend_object_handlers ) ) ; spl_ce_ArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_SUB_CLASS_EX ( RecursiveArrayIterator , ArrayIterator , spl_array_object_new , spl_funcs_RecursiveArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( RecursiveArrayIterator , RecursiveIterator ) ; spl_ce_RecursiveArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , "STD_PROP_LIST" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , "ARRAY_AS_PROPS" , SPL_ARRAY_ARRAY_AS_PROPS ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , "STD_PROP_LIST" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , "ARRAY_AS_PROPS" , SPL_ARRAY_ARRAY_AS_PROPS ) ; REGISTER_SPL_CLASS_CONST_LONG ( RecursiveArrayIterator , "CHILD_ARRAYS_ONLY" , SPL_ARRAY_CHILD_ARRAYS_ONLY ) ; return SUCCESS ; }
CWE-284 void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( ! mp ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; <S2SV_StartBug> umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }
CWE-264 static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; <S2SV_StartBug> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }
CWE-000 int install_process_keyring_to_cred ( struct cred * new ) { struct key * keyring ; if ( new -> process_keyring ) <S2SV_StartBug> return - EEXIST ; <S2SV_EndBug> keyring = keyring_alloc ( "_pid" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> process_keyring = keyring ; return 0 ; }
CWE-189 static u32 apic_get_tmcct ( struct kvm_lapic * apic ) { ktime_t remaining ; s64 ns ; u32 tmcct ; ASSERT ( apic != NULL ) ; <S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug> return 0 ; remaining = hrtimer_get_remaining ( & apic -> lapic_timer . timer ) ; if ( ktime_to_ns ( remaining ) < 0 ) remaining = ktime_set ( 0 , 0 ) ; ns = mod_64 ( ktime_to_ns ( remaining ) , apic -> lapic_timer . period ) ; tmcct = div64_u64 ( ns , ( APIC_BUS_CYCLE_NS * apic -> divide_count ) ) ; return tmcct ; }
CWE-119 void vp8_copy_mem16x16_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 16 ; r ++ ) { <S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; dst [ 8 ] = src [ 8 ] ; dst [ 9 ] = src [ 9 ] ; dst [ 10 ] = src [ 10 ] ; dst [ 11 ] = src [ 11 ] ; dst [ 12 ] = src [ 12 ] ; dst [ 13 ] = src [ 13 ] ; dst [ 14 ] = src [ 14 ] ; dst [ 15 ] = src [ 15 ] ; # else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; ( ( uint32_t * ) dst ) [ 2 ] = ( ( uint32_t * ) src ) [ 2 ] ; ( ( uint32_t * ) dst ) [ 3 ] = ( ( uint32_t * ) src ) [ 3 ] ; # endif src += src_stride ; dst += dst_stride ; } }
CWE-119 void vpx_img_free ( vpx_image_t * img ) { if ( img ) { if ( img -> img_data && img -> img_data_owner ) <S2SV_StartBug> img_buf_free ( img -> img_data ) ; <S2SV_EndBug> if ( img -> self_allocd ) free ( img ) ; } }
CWE-000 static int inet6_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct inet_sock * inet ; struct ipv6_pinfo * np ; struct sock * sk ; struct inet_protosw * answer ; struct proto * answer_prot ; unsigned char answer_flags ; int try_loading_module = 0 ; <S2SV_StartBug> int err ; <S2SV_EndBug> lookup_protocol : err = - ESOCKTNOSUPPORT ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( answer , & inetsw6 [ sock -> type ] , list ) { err = 0 ; if ( protocol == answer -> protocol ) { if ( protocol != IPPROTO_IP ) break ; } else { if ( IPPROTO_IP == protocol ) { protocol = answer -> protocol ; break ; } if ( IPPROTO_IP == answer -> protocol ) break ; } err = - EPROTONOSUPPORT ; } if ( err ) { if ( try_loading_module < 2 ) { rcu_read_unlock ( ) ; if ( ++ try_loading_module == 1 ) request_module ( "net-pf-%d-proto-%d-type-%d" , PF_INET6 , protocol , sock -> type ) ; else request_module ( "net-pf-%d-proto-%d" , PF_INET6 , protocol ) ; goto lookup_protocol ; } else goto out_rcu_unlock ; } err = - EPERM ; if ( sock -> type == SOCK_RAW && ! kern && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) goto out_rcu_unlock ; sock -> ops = answer -> ops ; answer_prot = answer -> prot ; answer_flags = answer -> flags ; rcu_read_unlock ( ) ; WARN_ON ( ! answer_prot -> slab ) ; err = - ENOBUFS ; sk = sk_alloc ( net , PF_INET6 , GFP_KERNEL , answer_prot , kern ) ; if ( ! sk ) goto out ; sock_init_data ( sock , sk ) ; err = 0 ; if ( INET_PROTOSW_REUSE & answer_flags ) sk -> sk_reuse = SK_CAN_REUSE ; inet = inet_sk ( sk ) ; inet -> is_icsk = ( INET_PROTOSW_ICSK & answer_flags ) != 0 ; if ( SOCK_RAW == sock -> type ) { inet -> inet_num = protocol ; if ( IPPROTO_RAW == protocol ) inet -> hdrincl = 1 ; } sk -> sk_destruct = inet_sock_destruct ; sk -> sk_family = PF_INET6 ; sk -> sk_protocol = protocol ; sk -> sk_backlog_rcv = answer -> prot -> backlog_rcv ; inet_sk ( sk ) -> pinet6 = np = inet6_sk_generic ( sk ) ; np -> hop_limit = - 1 ; np -> mcast_hops = IPV6_DEFAULT_MCASTHOPS ; np -> mc_loop = 1 ; np -> pmtudisc = IPV6_PMTUDISC_WANT ; np -> autoflowlabel = ip6_default_np_autolabel ( sock_net ( sk ) ) ; sk -> sk_ipv6only = net -> ipv6 . sysctl . bindv6only ; inet -> uc_ttl = - 1 ; inet -> mc_loop = 1 ; inet -> mc_ttl = 1 ; inet -> mc_index = 0 ; inet -> mc_list = NULL ; inet -> rcv_tos = 0 ; if ( net -> ipv4 . sysctl_ip_no_pmtu_disc ) inet -> pmtudisc = IP_PMTUDISC_DONT ; else inet -> pmtudisc = IP_PMTUDISC_WANT ; sk_refcnt_debug_inc ( sk ) ; if ( inet -> inet_num ) { inet -> inet_sport = htons ( inet -> inet_num ) ; sk -> sk_prot -> hash ( sk ) ; } if ( sk -> sk_prot -> init ) { err = sk -> sk_prot -> init ( sk ) ; if ( err ) { sk_common_release ( sk ) ; goto out ; } } out : return err ; out_rcu_unlock : rcu_read_unlock ( ) ; goto out ; }
CWE-190 SQLITE_PRIVATE int sqlite3VdbeSorterWrite ( const VdbeCursor * pCsr , Mem * pVal ) { VdbeSorter * pSorter ; int rc = SQLITE_OK ; SorterRecord * pNew ; int bFlush ; int nReq ; int nPMA ; int t ; assert ( pCsr -> eCurType == CURTYPE_SORTER ) ; pSorter = pCsr -> uc . pSorter ; getVarint32 ( ( const u8 * ) & pVal -> z [ 1 ] , t ) ; if ( t > 0 && t < 10 && t != 7 ) { pSorter -> typeMask &= SORTER_TYPE_INTEGER ; } else if ( t > 10 && ( t & 0x01 ) ) { pSorter -> typeMask &= SORTER_TYPE_TEXT ; } else { pSorter -> typeMask = 0 ; } assert ( pSorter ) ; nReq = pVal -> n + sizeof ( SorterRecord ) ; nPMA = pVal -> n + sqlite3VarintLen ( pVal -> n ) ; if ( pSorter -> mxPmaSize ) { if ( pSorter -> list . aMemory ) { bFlush = pSorter -> iMemory && ( pSorter -> iMemory + nReq ) > pSorter -> mxPmaSize ; } else { bFlush = ( ( pSorter -> list . szPMA > pSorter -> mxPmaSize ) || ( pSorter -> list . szPMA > pSorter -> mnPmaSize && sqlite3HeapNearlyFull ( ) ) ) ; } if ( bFlush ) { rc = vdbeSorterFlushPMA ( pSorter ) ; pSorter -> list . szPMA = 0 ; pSorter -> iMemory = 0 ; assert ( rc != SQLITE_OK || pSorter -> list . pList == 0 ) ; } } pSorter -> list . szPMA += nPMA ; if ( nPMA > pSorter -> mxKeysize ) { pSorter -> mxKeysize = nPMA ; } if ( pSorter -> list . aMemory ) { int nMin = pSorter -> iMemory + nReq ; if ( nMin > pSorter -> nMemory ) { u8 * aNew ; int iListOff = ( u8 * ) pSorter -> list . pList - pSorter -> list . aMemory ; <S2SV_StartBug> int nNew = pSorter -> nMemory * 2 ; <S2SV_EndBug> while ( nNew < nMin ) nNew = nNew * 2 ; if ( nNew > pSorter -> mxPmaSize ) nNew = pSorter -> mxPmaSize ; if ( nNew < nMin ) nNew = nMin ; aNew = sqlite3Realloc ( pSorter -> list . aMemory , nNew ) ; if ( ! aNew ) return SQLITE_NOMEM_BKPT ; pSorter -> list . pList = ( SorterRecord * ) & aNew [ iListOff ] ; pSorter -> list . aMemory = aNew ; pSorter -> nMemory = nNew ; } pNew = ( SorterRecord * ) & pSorter -> list . aMemory [ pSorter -> iMemory ] ; pSorter -> iMemory += ROUND8 ( nReq ) ; if ( pSorter -> list . pList ) { pNew -> u . iNext = ( int ) ( ( u8 * ) ( pSorter -> list . pList ) - pSorter -> list . aMemory ) ; } } else { pNew = ( SorterRecord * ) sqlite3Malloc ( nReq ) ; if ( pNew == 0 ) { return SQLITE_NOMEM_BKPT ; } pNew -> u . pNext = pSorter -> list . pList ; } memcpy ( SRVAL ( pNew ) , pVal -> z , pVal -> n ) ; pNew -> nVal = pVal -> n ; pSorter -> list . pList = pNew ; return rc ; }
CWE-000 krb5_error_code setup_server_realm ( krb5_principal sprinc ) { krb5_error_code kret ; kdc_realm_t * newrealm ; <S2SV_StartBug> kret = 0 ; <S2SV_EndBug> if ( kdc_numrealms > 1 ) { if ( ! ( newrealm = find_realm_data ( sprinc -> realm . data , ( krb5_ui_4 ) sprinc -> realm . length ) ) ) kret = ENOENT ; else kdc_active_realm = newrealm ; } else kdc_active_realm = kdc_realmlist [ 0 ] ; return ( kret ) ; }
CWE-119 static int udf_symlink_filler ( struct file * file , struct page * page ) { struct inode * inode = page -> mapping -> host ; struct buffer_head * bh = NULL ; unsigned char * symlink ; <S2SV_StartBug> int err = - EIO ; <S2SV_EndBug> unsigned char * p = kmap ( page ) ; struct udf_inode_info * iinfo ; <S2SV_StartBug> uint32_t pos ; <S2SV_EndBug> iinfo = UDF_I ( inode ) ; pos = udf_block_map ( inode , 0 ) ; down_read ( & iinfo -> i_data_sem ) ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { symlink = iinfo -> i_ext . i_data + iinfo -> i_lenEAttr ; } else { bh = sb_bread ( inode -> i_sb , pos ) ; <S2SV_StartBug> if ( ! bh ) <S2SV_EndBug> goto out ; symlink = bh -> b_data ; } udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; brelse ( bh ) ; up_read ( & iinfo -> i_data_sem ) ; SetPageUptodate ( page ) ; kunmap ( page ) ; unlock_page ( page ) ; return 0 ; <S2SV_StartBug> out : <S2SV_EndBug> up_read ( & iinfo -> i_data_sem ) ; SetPageError ( page ) ; <S2SV_StartBug> kunmap ( page ) ; <S2SV_EndBug> unlock_page ( page ) ; return err ; }
CWE-125 static Image * ExtractPostscript ( Image * image , const ImageInfo * image_info , MagickOffsetType PS_Offset , ssize_t PS_Size , ExceptionInfo * exception ) { char postscript_file [ MaxTextExtent ] ; const MagicInfo * magic_info ; FILE * ps_file ; ImageInfo * clone_info ; Image * image2 ; unsigned char magick [ 2 * MaxTextExtent ] ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) return ( image ) ; clone_info -> blob = ( void * ) NULL ; clone_info -> length = 0 ; ( void ) AcquireUniqueFilename ( postscript_file ) ; ps_file = fopen_utf8 ( postscript_file , "wb" ) ; if ( ps_file == ( FILE * ) NULL ) goto FINISH ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; ( void ) ReadBlob ( image , 2 * MaxTextExtent , magick ) ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; while ( PS_Size -- > 0 ) { ( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ; } ( void ) fclose ( ps_file ) ; magic_info = GetMagicInfo ( magick , 2 * MaxTextExtent , exception ) ; if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ; if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <S2SV_StartBug> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> FormatLocaleString ( clone_info -> filename , MaxTextExtent , "%s" , postscript_file ) ; image2 = ReadImage ( clone_info , exception ) ; if ( ! image2 ) goto FINISH_UNL ; ( void ) CopyMagickMemory ( image2 -> filename , image -> filename , MaxTextExtent ) ; ( void ) CopyMagickMemory ( image2 -> magick_filename , image -> magick_filename , MaxTextExtent ) ; ( void ) CopyMagickMemory ( image2 -> magick , image -> magick , MaxTextExtent ) ; image2 -> depth = image -> depth ; DestroyBlob ( image2 ) ; image2 -> blob = ReferenceBlob ( image -> blob ) ; if ( ( image -> rows == 0 ) || ( image -> columns == 0 ) ) DeleteImageFromList ( & image ) ; AppendImageToList ( & image , image2 ) ; FINISH_UNL : ( void ) RelinquishUniqueFileResource ( postscript_file ) ; FINISH : DestroyImageInfo ( clone_info ) ; return ( image ) ; }
CWE-476 static int crypto_rng_init_tfm ( struct crypto_tfm * tfm ) { <S2SV_StartBug> struct crypto_rng * rng = __crypto_rng_cast ( tfm ) ; <S2SV_EndBug> struct rng_alg * alg = crypto_rng_alg ( rng ) ; struct old_rng_alg * oalg = crypto_old_rng_alg ( rng ) ; if ( oalg -> rng_make_random ) { rng -> generate = generate ; rng -> seed = rngapi_reset ; rng -> seedsize = oalg -> seedsize ; return 0 ; } rng -> generate = alg -> generate ; rng -> seed = alg -> seed ; rng -> seedsize = alg -> seedsize ; return 0 ; }
CWE-125 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; <S2SV_StartBug> while ( offset + 1 <= packet_len ) { <S2SV_EndBug> <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; <S2SV_StartBug> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + <S2SV_EndBug> offset ) ; } return offset ; }
CWE-119 SQLWCHAR * _multi_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 2 ) ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; chr [ len ++ ] = 0 ; return chr ; }
CWE-119 static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; <S2SV_StartBug> const int mb_row = mi_row >> 1 ; <S2SV_EndBug> const int mb_col = mi_col >> 1 ; const int idx_map = mb_row * cm -> mb_cols + mb_col ; const struct segmentation * const seg = & cm -> seg ; set_skip_context ( xd , mi_row , mi_col ) ; <S2SV_StartBug> x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ; <S2SV_EndBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ; <S2SV_EndBug> x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_col_min = - ( ( ( mi_col + mi_width ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_row_max = ( cm -> mi_rows - mi_row ) * MI_SIZE + VP9_INTERP_EXTEND ; x -> mv_col_max = ( cm -> mi_cols - mi_col ) * MI_SIZE + VP9_INTERP_EXTEND ; assert ( ! ( mi_col & ( mi_width - 1 ) ) && ! ( mi_row & ( mi_height - 1 ) ) ) ; set_mi_row_col ( xd , tile , mi_row , mi_height , mi_col , mi_width , cm -> mi_rows , cm -> mi_cols ) ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; <S2SV_StartBug> x -> rddiv = cpi -> RDDIV ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult = cpi -> RDMULT ; <S2SV_EndBug> if ( seg -> enabled ) { if ( cpi -> oxcf . aq_mode != VARIANCE_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> } vp9_init_plane_quantizers ( cpi , x ) ; x -> encode_breakout = cpi -> segment_encode_breakout [ mbmi -> segment_id ] ; } else { mbmi -> segment_id = 0 ; x -> encode_breakout = cpi -> encode_breakout ; } <S2SV_StartBug> } <S2SV_EndBug>
CWE-000 static int cp2112_gpio_direction_input ( struct gpio_chip * chip , unsigned offset ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; int ret ; mutex_lock ( & dev -> lock ) ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_CONFIG_LENGTH ) { hid_err ( hdev , "error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n" , ret ) ; goto exit ; } buf [ 1 ] &= ~ ( 1 << offset ) ; buf [ 2 ] = gpio_push_pull ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) { hid_err ( hdev , "error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n" , ret ) ; goto exit ; } ret = 0 ; exit : mutex_unlock ( & dev -> lock ) ; <S2SV_StartBug> return ret <= 0 ? ret : - EIO ; <S2SV_EndBug> }
CWE-125 static MagickBooleanType ReadPSDChannelPixels ( Image * image , const size_t channels , const size_t row , const ssize_t type , const unsigned char * pixels , ExceptionInfo * exception ) { Quantum pixel ; register const unsigned char * p ; register Quantum * q ; register ssize_t x ; size_t packet_size ; unsigned short nibble ; p = pixels ; q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return MagickFalse ; packet_size = GetPSDPacketSize ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( packet_size == 1 ) pixel = ScaleCharToQuantum ( * p ++ ) ; else { p = PushShortPixel ( MSBEndian , p , & nibble ) ; pixel = ScaleShortToQuantum ( nibble ) ; } switch ( type ) { case - 1 : { SetPixelAlpha ( image , pixel , q ) ; break ; } case - 2 : case 0 : { SetPixelRed ( image , pixel , q ) ; if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ; if ( image -> storage_class == PseudoClass ) { if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ; else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; if ( image -> depth == 1 ) { ssize_t bit , number_bits ; number_bits = image -> columns - x ; if ( number_bits > 8 ) number_bits = 8 ; for ( bit = 0 ; bit < number_bits ; bit ++ ) { SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) <S2SV_StartBug> GetPixelIndex ( image , q ) , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; x ++ ; } x -- ; continue ; } } break ; } case 1 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelGreen ( image , pixel , q ) ; break ; } case 2 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelBlue ( image , pixel , q ) ; break ; } case 3 : { if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ; else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } case 4 : { if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } return ( SyncAuthenticPixels ( image , exception ) ) ; }
CWE-284 UINT32 UIPC_Read ( tUIPC_CH_ID ch_id , UINT16 * p_msg_evt , UINT8 * p_buf , UINT32 len ) { int n ; int n_read = 0 ; int fd = uipc_main . ch [ ch_id ] . fd ; struct pollfd pfd ; UNUSED ( p_msg_evt ) ; if ( ch_id >= UIPC_CH_NUM ) { BTIF_TRACE_ERROR ( "UIPC_Read<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>ch<S2SV_blank>id<S2SV_blank>%d" , ch_id ) ; return 0 ; } if ( fd == UIPC_DISCONNECTED ) { BTIF_TRACE_ERROR ( "UIPC_Read<S2SV_blank>:<S2SV_blank>channel<S2SV_blank>%d<S2SV_blank>closed" , ch_id ) ; return 0 ; } while ( n_read < ( int ) len ) { pfd . fd = fd ; pfd . events = POLLIN | POLLHUP ; <S2SV_StartBug> if ( poll ( & pfd , 1 , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) == 0 ) <S2SV_EndBug> { BTIF_TRACE_EVENT ( "poll<S2SV_blank>timeout<S2SV_blank>(%d<S2SV_blank>ms)" , uipc_main . ch [ ch_id ] . read_poll_tmo_ms ) ; break ; } if ( pfd . revents & ( POLLHUP | POLLNVAL ) ) { BTIF_TRACE_EVENT ( "poll<S2SV_blank>:<S2SV_blank>channel<S2SV_blank>detached<S2SV_blank>remotely" ) ; UIPC_LOCK ( ) ; uipc_close_locked ( ch_id ) ; UIPC_UNLOCK ( ) ; return 0 ; } <S2SV_StartBug> n = recv ( fd , p_buf + n_read , len - n_read , 0 ) ; <S2SV_EndBug> if ( n == 0 ) { BTIF_TRACE_EVENT ( "UIPC_Read<S2SV_blank>:<S2SV_blank>channel<S2SV_blank>detached<S2SV_blank>remotely" ) ; UIPC_LOCK ( ) ; uipc_close_locked ( ch_id ) ; UIPC_UNLOCK ( ) ; return 0 ; } if ( n < 0 ) { BTIF_TRACE_EVENT ( "UIPC_Read<S2SV_blank>:<S2SV_blank>read<S2SV_blank>failed<S2SV_blank>(%s)" , strerror ( errno ) ) ; return 0 ; } n_read += n ; } return n_read ; }
CWE-000 int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; <S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , "control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }
CWE-119 static void fwnet_receive_broadcast ( struct fw_iso_context * context , u32 cycle , size_t header_length , void * header , void * data ) { struct fwnet_device * dev ; struct fw_iso_packet packet ; __be16 * hdr_ptr ; __be32 * buf_ptr ; int retval ; u32 length ; <S2SV_StartBug> u16 source_node_id ; <S2SV_EndBug> u32 specifier_id ; u32 ver ; unsigned long offset ; unsigned long flags ; dev = data ; hdr_ptr = header ; length = be16_to_cpup ( hdr_ptr ) ; spin_lock_irqsave ( & dev -> lock , flags ) ; offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ; buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ; if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) dev -> broadcast_rcv_next_ptr = 0 ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_StartBug> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 <S2SV_EndBug> | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ; ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ; source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ; if ( specifier_id == IANA_SPECIFIER_ID && <S2SV_StartBug> ( ver == RFC2734_SW_VERSION <S2SV_EndBug> # if IS_ENABLED ( CONFIG_IPV6 ) <S2SV_StartBug> || ver == RFC3146_SW_VERSION <S2SV_EndBug> # endif <S2SV_StartBug> ) ) { <S2SV_EndBug> buf_ptr += 2 ; length -= IEEE1394_GASP_HDR_SIZE ; fwnet_incoming_packet ( dev , buf_ptr , length , source_node_id , context -> card -> generation , true ) ; <S2SV_StartBug> } <S2SV_EndBug> packet . payload_length = dev -> rcv_buffer_size ; packet . interrupt = 1 ; packet . skip = 0 ; packet . tag = 3 ; packet . sy = 0 ; packet . header_length = IEEE1394_GASP_HDR_SIZE ; spin_lock_irqsave ( & dev -> lock , flags ) ; retval = fw_iso_context_queue ( dev -> broadcast_rcv_context , & packet , & dev -> broadcast_rcv_buffer , offset ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; if ( retval >= 0 ) fw_iso_context_queue_flush ( dev -> broadcast_rcv_context ) ; else dev_err ( & dev -> netdev -> dev , "requeue<S2SV_blank>failed\\n" ) ; }
CWE-284 static BOOLEAN flush_incoming_que_on_wr_signal_l ( l2cap_socket * sock ) { uint8_t * buf ; uint32_t len ; while ( packet_get_head_l ( sock , & buf , & len ) ) { <S2SV_StartBug> int sent = send ( sock -> our_fd , buf , len , MSG_DONTWAIT ) ; <S2SV_EndBug> if ( sent == ( signed ) len ) osi_free ( buf ) ; else if ( sent >= 0 ) { packet_put_head_l ( sock , buf + sent , len - sent ) ; osi_free ( buf ) ; if ( ! sent ) return TRUE ; } else { packet_put_head_l ( sock , buf , len ) ; osi_free ( buf ) ; return errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN ; } } return FALSE ; }
CWE-416 ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> return expr ; }
CWE-20 static MagickBooleanType ConcatenateImages ( int argc , char * * argv , ExceptionInfo * exception ) { FILE * input , * output ; <S2SV_StartBug> int <S2SV_EndBug> c ; register ssize_t i ; if ( ExpandFilenames ( & argc , & argv ) == MagickFalse ) ThrowFileException ( exception , ResourceLimitError , "MemoryAllocationFailed" , GetExceptionMessage ( errno ) ) ; output = fopen_utf8 ( argv [ argc - 1 ] , "wb" ) ; if ( output == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , "UnableToOpenFile" , argv [ argc - 1 ] ) ; return ( MagickFalse ) ; } <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> # if 0 fprintf ( stderr , "DEBUG:<S2SV_blank>Concatenate<S2SV_blank>Image:<S2SV_blank>\\"%s\\"\\n" , argv [ i ] ) ; # endif input = fopen_utf8 ( argv [ i ] , "rb" ) ; if ( input == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , "UnableToOpenFile" , argv [ i ] ) ; continue ; } for ( c = fgetc ( input ) ; c != EOF ; c = fgetc ( input ) ) <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( output ) ; <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug> }
CWE-119 <S2SV_StartBug> static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_EndBug> int mi_row , int mi_col , vp9_reader * r ) { <S2SV_StartBug> struct segmentation * const seg = & cm -> seg ; <S2SV_EndBug> const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; int segment_id ; if ( ! seg -> enabled ) return 0 ; <S2SV_StartBug> if ( ! seg -> update_map ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> segment_id = read_segment_id ( r , seg ) ; <S2SV_StartBug> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <S2SV_EndBug> return segment_id ; }
CWE-119 static int do_16x16_zerozero_search ( VP9_COMP * cpi , int_mv * dst_mv ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; unsigned int err ; <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , <S2SV_EndBug> INT_MAX ) ; dst_mv -> as_int = 0 ; return err ; }
CWE-362 struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ; <S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }
CWE-20 static krb5_error_code find_alternate_tgs ( kdc_realm_t * kdc_active_realm , krb5_principal princ , krb5_db_entry * * server_ptr , const char * * status ) { krb5_error_code retval ; krb5_principal * plist = NULL , * pl2 ; krb5_data tmp ; krb5_db_entry * server = NULL ; * server_ptr = NULL ; assert ( is_cross_tgs_principal ( princ ) ) ; if ( ( retval = krb5_walk_realm_tree ( kdc_context , krb5_princ_realm ( kdc_context , princ ) , krb5_princ_component ( kdc_context , princ , 1 ) , & plist , KRB5_REALM_BRANCH_CHAR ) ) ) { goto cleanup ; } for ( pl2 = plist ; * pl2 ; pl2 ++ ) ; while ( -- pl2 > plist ) { tmp = * krb5_princ_realm ( kdc_context , * pl2 ) ; krb5_princ_set_realm ( kdc_context , * pl2 , krb5_princ_realm ( kdc_context , tgs_server ) ) ; retval = db_get_svc_princ ( kdc_context , * pl2 , 0 , & server , status ) ; krb5_princ_set_realm ( kdc_context , * pl2 , & tmp ) ; if ( retval == KRB5_KDB_NOENTRY ) continue ; else if ( retval ) goto cleanup ; log_tgs_alt_tgt ( kdc_context , server -> princ ) ; * server_ptr = server ; server = NULL ; goto cleanup ; } cleanup : <S2SV_StartBug> if ( retval != 0 ) <S2SV_EndBug> * status = "UNKNOWN_SERVER" ; krb5_free_realm_tree ( kdc_context , plist ) ; krb5_db_free_principal ( kdc_context , server ) ; return retval ; }
CWE-125 static void file_add_mapi_attrs ( File * file , MAPI_Attr * * attrs ) { int i ; for ( i = 0 ; attrs [ i ] ; i ++ ) { MAPI_Attr * a = attrs [ i ] ; if ( a -> num_values ) { switch ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : <S2SV_StartBug> if ( file -> name ) XFREE ( file -> name ) ; <S2SV_EndBug> file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : <S2SV_StartBug> file -> len = a -> values [ 0 ] . len ; <S2SV_EndBug> if ( file -> data ) XFREE ( file -> data ) ; file -> data = CHECKED_XMALLOC ( unsigned char , file -> len ) ; memmove ( file -> data , a -> values [ 0 ] . data . buf , file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : <S2SV_StartBug> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <S2SV_EndBug> file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> mime_type , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <S2SV_StartBug> if ( file -> content_id ) XFREE ( file -> content_id ) ; <S2SV_EndBug> file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> content_id , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; default : break ; } } } }
CWE-362 static int ptrace_check_attach ( struct task_struct * child , bool ignore_state ) { int ret = - ESRCH ; read_lock ( & tasklist_lock ) ; <S2SV_StartBug> if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) { <S2SV_EndBug> <S2SV_StartBug> spin_lock_irq ( & child -> sighand -> siglock ) ; <S2SV_EndBug> WARN_ON_ONCE ( task_is_stopped ( child ) ) ; <S2SV_StartBug> if ( ignore_state || ( task_is_traced ( child ) && <S2SV_EndBug> ! ( child -> jobctl & JOBCTL_LISTENING ) ) ) <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> spin_unlock_irq ( & child -> sighand -> siglock ) ; } read_unlock ( & tasklist_lock ) ; <S2SV_StartBug> if ( ! ret && ! ignore_state ) <S2SV_EndBug> <S2SV_StartBug> ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ; <S2SV_EndBug> return ret ; }
CWE-000 static int cp2112_gpio_direction_input ( struct gpio_chip * chip , unsigned offset ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_CONFIG_LENGTH ) { hid_err ( hdev , "error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n" , ret ) ; goto exit ; } buf [ 1 ] &= ~ ( 1 << offset ) ; buf [ 2 ] = gpio_push_pull ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) { hid_err ( hdev , "error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n" , ret ) ; goto exit ; } ret = 0 ; exit : <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> return ret <= 0 ? ret : - EIO ; }
CWE-119 <S2SV_StartBug> static INLINE void write_buffer_4x4 ( int16_t * output , __m128i * res ) { <S2SV_EndBug> const __m128i kOne = _mm_set1_epi16 ( 1 ) ; __m128i in01 = _mm_unpacklo_epi64 ( res [ 0 ] , res [ 1 ] ) ; __m128i in23 = _mm_unpacklo_epi64 ( res [ 2 ] , res [ 3 ] ) ; __m128i out01 = _mm_add_epi16 ( in01 , kOne ) ; __m128i out23 = _mm_add_epi16 ( in23 , kOne ) ; out01 = _mm_srai_epi16 ( out01 , 2 ) ; out23 = _mm_srai_epi16 ( out23 , 2 ) ; <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 0 * 8 ) , out01 ) ; <S2SV_EndBug> <S2SV_StartBug> _mm_store_si128 ( ( __m128i * ) ( output + 1 * 8 ) , out23 ) ; <S2SV_EndBug> }
CWE-119 private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , <S2SV_StartBug> size_t count , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { size_t i ; cdf_timestamp_t tp ; struct timespec ts ; char buf [ 64 ] ; const char * str = NULL ; const char * s ; int len ; <S2SV_StartBug> if ( ! NOTMIME ( ms ) ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2mime ) ; <S2SV_EndBug> for ( i = 0 ; i < count ; i ++ ) { cdf_print_property_name ( buf , sizeof ( buf ) , info [ i ] . pi_id ) ; switch ( info [ i ] . pi_type ) { case CDF_NULL : break ; case CDF_SIGNED16 : if ( NOTMIME ( ms ) && file_printf ( ms , ",<S2SV_blank>%s:<S2SV_blank>%hd" , buf , info [ i ] . pi_s16 ) == - 1 ) return - 1 ; break ; case CDF_SIGNED32 : if ( NOTMIME ( ms ) && file_printf ( ms , ",<S2SV_blank>%s:<S2SV_blank>%d" , buf , info [ i ] . pi_s32 ) == - 1 ) return - 1 ; break ; case CDF_UNSIGNED32 : if ( NOTMIME ( ms ) && file_printf ( ms , ",<S2SV_blank>%s:<S2SV_blank>%u" , buf , info [ i ] . pi_u32 ) == - 1 ) return - 1 ; break ; case CDF_FLOAT : if ( NOTMIME ( ms ) && file_printf ( ms , ",<S2SV_blank>%s:<S2SV_blank>%g" , buf , info [ i ] . pi_f ) == - 1 ) return - 1 ; break ; case CDF_DOUBLE : if ( NOTMIME ( ms ) && file_printf ( ms , ",<S2SV_blank>%s:<S2SV_blank>%g" , buf , info [ i ] . pi_d ) == - 1 ) return - 1 ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : len = info [ i ] . pi_str . s_len ; if ( len > 1 ) { char vbuf [ 1024 ] ; size_t j , k = 1 ; if ( info [ i ] . pi_type == CDF_LENGTH32_WSTRING ) k ++ ; s = info [ i ] . pi_str . s_buf ; for ( j = 0 ; j < sizeof ( vbuf ) && len -- ; j ++ , s += k ) { if ( * s == '\\0' ) break ; if ( isprint ( ( unsigned char ) * s ) ) vbuf [ j ] = * s ; } if ( j == sizeof ( vbuf ) ) -- j ; vbuf [ j ] = '\\0' ; if ( NOTMIME ( ms ) ) { if ( vbuf [ 0 ] ) { if ( file_printf ( ms , ",<S2SV_blank>%s:<S2SV_blank>%s" , buf , vbuf ) == - 1 ) return - 1 ; } } else if ( str == NULL && info [ i ] . pi_id == CDF_PROPERTY_NAME_OF_APPLICATION ) { str = cdf_app_to_mime ( vbuf , app2mime ) ; } } break ; case CDF_FILETIME : tp = info [ i ] . pi_tp ; if ( tp != 0 ) { char tbuf [ 64 ] ; if ( tp < 1000000000000000LL ) { cdf_print_elapsed_time ( tbuf , sizeof ( tbuf ) , tp ) ; if ( NOTMIME ( ms ) && file_printf ( ms , ",<S2SV_blank>%s:<S2SV_blank>%s" , buf , tbuf ) == - 1 ) return - 1 ; } else { char * c , * ec ; cdf_timestamp_to_timespec ( & ts , tp ) ; c = cdf_ctime ( & ts . tv_sec , tbuf ) ; if ( c != NULL && ( ec = strchr ( c , '\\n' ) ) != NULL ) * ec = '\\0' ; if ( NOTMIME ( ms ) && file_printf ( ms , ",<S2SV_blank>%s:<S2SV_blank>%s" , buf , c ) == - 1 ) return - 1 ; } } break ; case CDF_CLIPBOARD : break ; default : return - 1 ; } } if ( ! NOTMIME ( ms ) ) { if ( str == NULL ) return 0 ; if ( file_printf ( ms , "application/%s" , str ) == - 1 ) return - 1 ; } return 1 ; }
CWE-476 static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( "warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }
CWE-125 int yr_re_match ( RE * re , const char * target ) { return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) , <S2SV_StartBug> re -> flags | RE_FLAGS_SCAN , <S2SV_EndBug> NULL , NULL ) ; }
CWE-119 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; unsigned int npages = DIV_ROUND_UP ( buflen , PAGE_SIZE ) ; int ret = - ENOMEM , i ; if ( npages == 0 ) npages = 1 ; if ( npages > ARRAY_SIZE ( pages ) ) return - ERANGE ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; dprintk ( "%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\n" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; if ( res . acl_flags & NFS4_ACL_TRUNC ) { if ( buf == NULL ) goto out_ok ; ret = - ERANGE ; goto out_free ; } nfs4_write_cached_acl ( inode , pages , res . acl_data_offset , res . acl_len ) ; <S2SV_StartBug> if ( buf ) <S2SV_EndBug> <S2SV_StartBug> _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ; <S2SV_EndBug> out_ok : ret = res . acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }
CWE-000 OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }
CWE-416 static void put_crypt_info ( struct fscrypt_info * ci ) { if ( ! ci ) return ; <S2SV_StartBug> key_put ( ci -> ci_keyring_key ) ; <S2SV_EndBug> crypto_free_skcipher ( ci -> ci_ctfm ) ; kmem_cache_free ( fscrypt_info_cachep , ci ) ; }
CWE-000 static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; <S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
CWE-119 <S2SV_StartBug> static void write_inter_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> assert ( is_inter_mode ( mode ) ) ; vp9_write_token ( w , vp9_inter_mode_tree , probs , & inter_mode_encodings [ INTER_OFFSET ( mode ) ] ) ; }
CWE-119 <S2SV_StartBug> void impeg2d_dec_p_mb_params ( dec_state_t * ps_dec ) <S2SV_EndBug> { stream_t * ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_mb_addr_incr ; UWORD16 u2_total_len ; UWORD16 u2_len ; UWORD16 u2_mb_type ; UWORD32 u4_next_word ; const dec_mb_params_t * ps_dec_mb_params ; if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) { impeg2d_bit_stream_flush ( ps_stream , 1 ) ; } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; if ( 0 == ps_dec -> u2_first_mb ) { if ( ps_dec -> u2_is_mpeg2 && ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) { u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; } impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; } } u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; { u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; u2_len = BITS ( u2_mb_type , 15 , 8 ) ; u2_total_len = u2_len ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << u2_len ) ; } { if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) { WORD32 i4_motion_type ; ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; u2_total_len += MB_MOTION_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_MOTION_TYPE_LEN ) ; i4_motion_type = ps_dec -> u2_motion_type ; if ( ( i4_motion_type == 0 ) || ( i4_motion_type == 4 ) || ( i4_motion_type > 7 ) ) { i4_motion_type = 1 ; } } } { if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) { ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; u2_total_len += MB_DCT_TYPE_LEN ; u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_DCT_TYPE_LEN ) ; } } if ( u2_mb_type & MB_QUANT ) { UWORD16 u2_quant_scale_code ; u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; u2_total_len += MB_QUANT_SCALE_CODE_LEN ; } impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; if ( u2_mb_type & MB_FORW_OR_BACK ) { UWORD16 refPic = ! ( u2_mb_type & MB_MV_FORW ) ; UWORD16 index = ( ps_dec -> u2_motion_type ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = ( e_pred_direction_t ) refPic ; ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ index ] ; ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; <S2SV_StartBug> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; <S2SV_EndBug> } else if ( u2_mb_type & MB_TYPE_INTRA ) { ps_dec -> u2_prev_intra_mb = 1 ; impeg2d_dec_intra_mb ( ps_dec ) ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> e_mb_pred = FORW ; ps_dec -> u2_motion_type = 0 ; impeg2d_dec_0mv_coded_mb ( ps_dec ) ; } if ( ( u2_mb_type & MB_TYPE_INTRA ) ) { ps_dec -> u2_cbp = 0x3f ; ps_dec -> u2_prev_intra_mb = 1 ; } else { ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; if ( ( ps_dec -> u2_coded_mb ) ) { UWORD16 cbpValue ; cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; ps_dec -> u2_cbp = cbpValue & 0xFF ; impeg2d_bit_stream_flush ( ps_stream , ( cbpValue >> 8 ) & 0x0FF ) ; } else { ps_dec -> u2_cbp = 0 ; } } <S2SV_StartBug> } <S2SV_EndBug>
CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; vpx_codec_err_t res ; VpxVideoReader * reader = NULL ; const VpxInterface * decoder = NULL ; const VpxVideoInfo * info = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments." ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading." , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , "wb" ) ) ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing" , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( "Unknown<S2SV_blank>input<S2SV_blank>codec." ) ; <S2SV_StartBug> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , <S2SV_EndBug> VPX_CODEC_USE_POSTPROC ) ; if ( res == VPX_CODEC_INCAPABLE ) die_codec ( & codec , "Postproc<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>decoder." ) ; if ( res ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder." ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; ++ frame_cnt ; if ( frame_cnt % 30 == 1 ) { vp8_postproc_cfg_t pp = { 0 , 0 , 0 } ; if ( vpx_codec_control ( & codec , VP8_SET_POSTPROC , & pp ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>off<S2SV_blank>postproc." ) ; } else if ( frame_cnt % 30 == 16 ) { vp8_postproc_cfg_t pp = { VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE , 4 , 0 } ; if ( vpx_codec_control ( & codec , VP8_SET_POSTPROC , & pp ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>on<S2SV_blank>postproc." ) ; } ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 15000 ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { vpx_img_write ( img , outfile ) ; } } printf ( "Processed<S2SV_blank>%d<S2SV_blank>frames.\\n" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec" ) ; printf ( "Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }
CWE-119 void vp9_encode_sb ( MACROBLOCK * x , BLOCK_SIZE bsize ) { MACROBLOCKD * const xd = & x -> e_mbd ; struct optimize_ctx ctx ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; struct encode_b_args arg = { x , & ctx , & mbmi -> skip } ; int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) { <S2SV_EndBug> if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ; if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) { const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi ) : mbmi -> tx_size ; <S2SV_EndBug> vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ; } vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block , & arg ) ; } }
CWE-000 static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , "%s" , "cipher" ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
CWE-20 static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , "%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\n" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , "%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\n" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , "<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , "\\n<%d<S2SV_blank><S2SV_blank><S2SV_blank>" , c -> sfd ) ; } fprintf ( stderr , "<S2SV_blank>0x%02x" , req -> bytes [ ii ] ) ; } fprintf ( stderr , "\\n" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , "Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\n" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } c -> msgcurr = 0 ; c -> msgused = 0 ; c -> iovused = 0 ; if ( add_msghdr ( c ) != 0 ) { out_string ( c , "SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory" ) ; return 0 ; } c -> cmd = c -> binary_header . request . opcode ; c -> keylen = c -> binary_header . request . keylen ; c -> opaque = c -> binary_header . request . opaque ; c -> cas = 0 ; dispatch_bin_command ( c ) ; c -> rbytes -= sizeof ( c -> binary_header ) ; c -> rcurr += sizeof ( c -> binary_header ) ; } } else { char * el , * cont ; if ( c -> rbytes == 0 ) return 0 ; el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; if ( ! el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } <S2SV_StartBug> if ( strcmp ( ptr , "get<S2SV_blank>" ) && strcmp ( ptr , "gets<S2SV_blank>" ) ) { <S2SV_EndBug> conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } cont = el + 1 ; if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { el -- ; } * el = '\\0' ; assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; process_command ( c , c -> rcurr ) ; c -> rbytes -= ( cont - c -> rcurr ) ; c -> rcurr = cont ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; } return 1 ; }
CWE-190 <S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug> { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }
CWE-200 static int userauth_hostbased ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct sshbuf * b ; struct sshkey * key = NULL ; char * pkalg , * cuser , * chost ; u_char * pkblob , * sig ; size_t alen , blen , slen ; int r , pktype , authenticated = 0 ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( "%s:<S2SV_blank>packet<S2SV_blank>parsing:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; debug ( "%s:<S2SV_blank>cuser<S2SV_blank>%s<S2SV_blank>chost<S2SV_blank>%s<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>slen<S2SV_blank>%zu" , __func__ , cuser , chost , pkalg , slen ) ; # ifdef DEBUG_PK debug ( "signature:" ) ; sshbuf_dump_data ( sig , siglen , stderr ) ; # endif pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { logit ( "%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( "%s:<S2SV_blank>key_from_blob:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( "%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( "%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>" "(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { error ( "Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>peer<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>" "signature<S2SV_blank>format" ) ; goto done ; } if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) { logit ( "%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>HostbasedAcceptedKeyTypes" , __func__ , sshkey_type ( key ) ) ; goto done ; } <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> fatal ( "%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed" , __func__ ) ; if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , "hostbased" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( "%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif auth2_record_info ( authctxt , "client<S2SV_blank>user<S2SV_blank>\\"%.100s\\",<S2SV_blank>client<S2SV_blank>host<S2SV_blank>\\"%.100s\\"" , cuser , chost ) ; authenticated = 0 ; if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ; auth2_record_key ( authctxt , authenticated , key ) ; sshbuf_free ( b ) ; done : debug2 ( "%s:<S2SV_blank>authenticated<S2SV_blank>%d" , __func__ , authenticated ) ; sshkey_free ( key ) ; free ( pkalg ) ; free ( pkblob ) ; free ( cuser ) ; free ( chost ) ; free ( sig ) ; return authenticated ; }
CWE-119 static char * get_pid_environ_val ( pid_t pid , char * val ) { <S2SV_StartBug> char temp [ 500 ] ; <S2SV_EndBug> int i = 0 ; int foundit = 0 ; FILE * fp ; sprintf ( temp , "/proc/%d/environ" , pid ) ; fp = fopen ( temp , "r" ) ; if ( fp == NULL ) return NULL ; for ( ; ; ) { <S2SV_StartBug> temp [ i ] = fgetc ( fp ) ; <S2SV_EndBug> if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) { char * ret ; temp [ i ] = 0 ; ret = malloc ( strlen ( temp ) + 10 ) ; sprintf ( ret , "%s" , temp ) ; fclose ( fp ) ; return ret ; } switch ( temp [ i ] ) { case EOF : fclose ( fp ) ; return NULL ; case '=' : temp [ i ] = 0 ; if ( ! strcmp ( temp , val ) ) { foundit = 1 ; } i = 0 ; break ; case '\\0' : i = 0 ; break ; default : i ++ ; } } }
CWE-000 static int parse_token ( char * * name , char * * value , char * * cp ) { char * end ; if ( ! name || ! value || ! cp ) return - BLKID_ERR_PARAM ; if ( ! ( * value = strchr ( * cp , '=' ) ) ) return 0 ; * * value = '\\0' ; * name = strip_line ( * cp ) ; * value = skip_over_blank ( * value + 1 ) ; if ( * * value == \'"\' ) { <S2SV_StartBug> end = strchr ( * value + 1 , \'"\' ) ; <S2SV_EndBug> if ( ! end ) { DBG ( READ , ul_debug ( "unbalanced<S2SV_blank>quotes<S2SV_blank>at:<S2SV_blank>%s" , * value ) ) ; * cp = * value ; return - BLKID_ERR_CACHE ; } ( * value ) ++ ; * end = '\\0' ; <S2SV_StartBug> end ++ ; <S2SV_EndBug> } else { end = skip_over_word ( * value ) ; if ( * end ) { * end = '\\0' ; end ++ ; } } * cp = end ; return 1 ; }
CWE-119 static int pit_ioport_read ( struct kvm_io_device * this , gpa_t addr , int len , void * data ) { struct kvm_pit * pit = dev_to_pit ( this ) ; struct kvm_kpit_state * pit_state = & pit -> pit_state ; struct kvm * kvm = pit -> kvm ; int ret , count ; struct kvm_kpit_channel_state * s ; if ( ! pit_in_range ( addr ) ) return - EOPNOTSUPP ; addr &= KVM_PIT_CHANNEL_MASK ; <S2SV_StartBug> s = & pit_state -> channels [ addr ] ; <S2SV_EndBug> mutex_lock ( & pit_state -> lock ) ; if ( s -> status_latched ) { s -> status_latched = 0 ; ret = s -> status ; } else if ( s -> count_latched ) { switch ( s -> count_latched ) { default : case RW_STATE_LSB : ret = s -> latched_count & 0xff ; s -> count_latched = 0 ; break ; case RW_STATE_MSB : ret = s -> latched_count >> 8 ; s -> count_latched = 0 ; break ; case RW_STATE_WORD0 : ret = s -> latched_count & 0xff ; s -> count_latched = RW_STATE_MSB ; break ; } } else { switch ( s -> read_state ) { default : case RW_STATE_LSB : count = pit_get_count ( kvm , addr ) ; ret = count & 0xff ; break ; case RW_STATE_MSB : count = pit_get_count ( kvm , addr ) ; ret = ( count >> 8 ) & 0xff ; break ; case RW_STATE_WORD0 : count = pit_get_count ( kvm , addr ) ; ret = count & 0xff ; s -> read_state = RW_STATE_WORD1 ; break ; case RW_STATE_WORD1 : count = pit_get_count ( kvm , addr ) ; ret = ( count >> 8 ) & 0xff ; s -> read_state = RW_STATE_WORD0 ; break ; } } if ( len > sizeof ( ret ) ) len = sizeof ( ret ) ; memcpy ( data , ( char * ) & ret , len ) ; mutex_unlock ( & pit_state -> lock ) ; return 0 ; }
CWE-20 static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , "%s()\\n" , __func__ ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , "%s(),<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>frame<S2SV_blank>(%zd<S2SV_blank><<S2SV_blank>%zd)!\\n" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , "%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\n" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }
CWE-119 gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } } if ( iter -> is_emoji == ( gboolean ) 2 ) iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; if ( iter -> is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ) { iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; <S2SV_StartBug> return TRUE ; <S2SV_EndBug> } } iter -> is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; return TRUE ; }
CWE-119 MagickExport void * AcquireAlignedMemory ( const size_t count , const size_t quantum ) { # define AlignedExtent ( size , alignment ) ( ( ( size ) + ( ( alignment ) - 1 ) ) & ~ ( ( alignment ) - 1 ) ) size_t alignment , extent , size ; void * memory ; <S2SV_StartBug> if ( CheckMemoryOverflow ( count , quantum ) != MagickFalse ) <S2SV_EndBug> return ( ( void * ) NULL ) ; memory = NULL ; alignment = CACHE_LINE_SIZE ; size = count * quantum ; extent = AlignedExtent ( size , alignment ) ; if ( ( size == 0 ) || ( alignment < sizeof ( void * ) ) || ( extent < size ) ) return ( ( void * ) NULL ) ; # if defined ( MAGICKCORE_HAVE_POSIX_MEMALIGN ) if ( posix_memalign ( & memory , alignment , extent ) != 0 ) memory = NULL ; # elif defined ( MAGICKCORE_HAVE__ALIGNED_MALLOC ) memory = _aligned_malloc ( extent , alignment ) ; # else { void * p ; extent = ( size + alignment - 1 ) + sizeof ( void * ) ; if ( extent > size ) { p = malloc ( extent ) ; if ( p != NULL ) { memory = ( void * ) AlignedExtent ( ( size_t ) p + sizeof ( void * ) , alignment ) ; * ( ( void * * ) memory - 1 ) = p ; } } } # endif return ( memory ) ; }
CWE-119 static int fuse_notify_inval_entry ( struct fuse_conn * fc , unsigned int size , struct fuse_copy_state * cs ) { struct fuse_notify_inval_entry_out outarg ; int err = - ENOMEM ; char * buf ; struct qstr name ; buf = kzalloc ( FUSE_NAME_MAX + 1 , GFP_KERNEL ) ; if ( ! buf ) goto err ; err = - EINVAL ; if ( size < sizeof ( outarg ) ) goto err ; err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ; if ( err ) goto err ; err = - ENAMETOOLONG ; if ( outarg . namelen > FUSE_NAME_MAX ) goto err ; <S2SV_StartBug> name . name = buf ; <S2SV_EndBug> name . len = outarg . namelen ; <S2SV_StartBug> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; <S2SV_EndBug> if ( err ) goto err ; fuse_copy_finish ( cs ) ; buf [ outarg . namelen ] = 0 ; name . hash = full_name_hash ( name . name , name . len ) ; down_read ( & fc -> killsb ) ; err = - ENOENT ; if ( fc -> sb ) err = fuse_reverse_inval_entry ( fc -> sb , outarg . parent , & name ) ; up_read ( & fc -> killsb ) ; kfree ( buf ) ; return err ; err : kfree ( buf ) ; fuse_copy_finish ( cs ) ; return err ; }
CWE-399 static int rock_continue ( struct rock_state * rs ) { int ret = 1 ; int blocksize = 1 << rs -> inode -> i_blkbits ; const int min_de_size = offsetof ( struct rock_ridge , u ) ; kfree ( rs -> buffer ) ; rs -> buffer = NULL ; if ( ( unsigned ) rs -> cont_offset > blocksize - min_de_size || ( unsigned ) rs -> cont_size > blocksize || ( unsigned ) ( rs -> cont_offset + rs -> cont_size ) > blocksize ) { printk ( KERN_NOTICE "rock:<S2SV_blank>corrupted<S2SV_blank>directory<S2SV_blank>entry.<S2SV_blank>" "extent=%d,<S2SV_blank>offset=%d,<S2SV_blank>size=%d\\n" , rs -> cont_extent , rs -> cont_offset , rs -> cont_size ) ; ret = - EIO ; goto out ; } if ( rs -> cont_extent ) { struct buffer_head * bh ; rs -> buffer = kmalloc ( rs -> cont_size , GFP_KERNEL ) ; if ( ! rs -> buffer ) { ret = - ENOMEM ; goto out ; } ret = - EIO ; <S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> if ( bh ) { memcpy ( rs -> buffer , bh -> b_data + rs -> cont_offset , rs -> cont_size ) ; put_bh ( bh ) ; rs -> chr = rs -> buffer ; rs -> len = rs -> cont_size ; rs -> cont_extent = 0 ; rs -> cont_size = 0 ; rs -> cont_offset = 0 ; return 0 ; } printk ( "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>rock-ridge<S2SV_blank>attributes\\n" ) ; } out : kfree ( rs -> buffer ) ; rs -> buffer = NULL ; return ret ; }
CWE-000 static void process_open ( u_int32_t id ) { u_int32_t pflags ; Attrib a ; char * name ; int r , handle , fd , flags , mode , status = SSH2_FX_FAILURE ; if ( ( r = sshbuf_get_cstring ( iqueue , & name , NULL ) ) != 0 || ( r = sshbuf_get_u32 ( iqueue , & pflags ) ) != 0 || ( r = decode_attrib ( iqueue , & a ) ) != 0 ) fatal ( "%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; debug3 ( "request<S2SV_blank>%u:<S2SV_blank>open<S2SV_blank>flags<S2SV_blank>%d" , id , pflags ) ; flags = flags_from_portable ( pflags ) ; mode = ( a . flags & SSH2_FILEXFER_ATTR_PERMISSIONS ) ? a . perm : 0666 ; logit ( "open<S2SV_blank>\\"%s\\"<S2SV_blank>flags<S2SV_blank>%s<S2SV_blank>mode<S2SV_blank>0%o" , name , string_from_portable ( pflags ) , mode ) ; if ( readonly && <S2SV_StartBug> ( ( flags & O_ACCMODE ) == O_WRONLY || <S2SV_EndBug> <S2SV_StartBug> ( flags & O_ACCMODE ) == O_RDWR ) ) { <S2SV_EndBug> verbose ( "Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode" ) ; status = SSH2_FX_PERMISSION_DENIED ; } else { fd = open ( name , flags , mode ) ; if ( fd < 0 ) { status = errno_to_portable ( errno ) ; } else { handle = handle_new ( HANDLE_FILE , name , fd , flags , NULL ) ; if ( handle < 0 ) { close ( fd ) ; } else { send_handle ( id , handle ) ; status = SSH2_FX_OK ; } } } if ( status != SSH2_FX_OK ) send_status ( id , status ) ; free ( name ) ; }
CWE-119 <S2SV_StartBug> static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_MODE tx_mode , <S2SV_EndBug> <S2SV_StartBug> BLOCK_SIZE bsize , int allow_select , vp9_reader * r ) { <S2SV_EndBug> const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ; if ( allow_select && tx_mode == TX_MODE_SELECT && bsize >= BLOCK_8X8 ) return read_selected_tx_size ( cm , xd , max_tx_size , r ) ; else return MIN ( max_tx_size , tx_mode_to_biggest_tx_size [ tx_mode ] ) ; }
CWE-189 <S2SV_StartBug> static void <S2SV_EndBug> _copy_from_pages ( char * p , struct page * * pages , size_t pgbase , size_t len ) { struct page * * pgfrom ; char * vfrom ; size_t copy ; pgfrom = pages + ( pgbase >> PAGE_CACHE_SHIFT ) ; pgbase &= ~ PAGE_CACHE_MASK ; do { copy = PAGE_CACHE_SIZE - pgbase ; if ( copy > len ) copy = len ; vfrom = kmap_atomic ( * pgfrom , KM_USER0 ) ; memcpy ( p , vfrom + pgbase , copy ) ; kunmap_atomic ( vfrom , KM_USER0 ) ; pgbase += copy ; if ( pgbase == PAGE_CACHE_SIZE ) { pgbase = 0 ; pgfrom ++ ; } p += copy ; } while ( ( len -= copy ) != 0 ) ; }
CWE-476 struct key * key_get_instantiation_authkey ( key_serial_t target_id ) { char description [ 16 ] ; struct keyring_search_context ctx = { . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , <S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * authkey ; key_ref_t authkey_ref ; sprintf ( description , "%x" , target_id ) ; authkey_ref = search_process_keyrings ( & ctx ) ; if ( IS_ERR ( authkey_ref ) ) { authkey = ERR_CAST ( authkey_ref ) ; if ( authkey == ERR_PTR ( - EAGAIN ) ) authkey = ERR_PTR ( - ENOKEY ) ; goto error ; } authkey = key_ref_to_ptr ( authkey_ref ) ; if ( test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { key_put ( authkey ) ; authkey = ERR_PTR ( - EKEYREVOKED ) ; } error : return authkey ; }
CWE-416 static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { <S2SV_StartBug> struct dentry * dir ; <S2SV_EndBug> struct fscrypt_info * ci ; int dir_has_key , cached_with_key ; if ( flags & LOOKUP_RCU ) return - ECHILD ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } <S2SV_StartBug> ci = d_inode ( dir ) -> i_crypt_info ; <S2SV_EndBug> if ( ci && ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ci = NULL ; spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; <S2SV_StartBug> dir_has_key = ( ci != NULL ) ; <S2SV_EndBug> dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
CWE-362 void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( "%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }
CWE-125 size_t compile_tree ( struct filter_op * * fop ) { int i = 1 ; struct filter_op * array = NULL ; struct unfold_elm * ue ; <S2SV_StartBug> BUG_IF ( tree_root == NULL ) ; <S2SV_EndBug> fprintf ( stdout , "<S2SV_blank>Unfolding<S2SV_blank>the<S2SV_blank>meta-tree<S2SV_blank>" ) ; fflush ( stdout ) ; unfold_blk ( & tree_root ) ; fprintf ( stdout , "<S2SV_blank>done.\\n\\n" ) ; labels_to_offsets ( ) ; TAILQ_FOREACH ( ue , & unfolded_tree , next ) { if ( ue -> label == 0 ) { SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ; i ++ ; } } SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; array [ i - 1 ] . opcode = FOP_EXIT ; * fop = array ; return ( i ) ; }
CWE-200 int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <S2SV_StartBug> int copied , error = - EINVAL ; <S2SV_EndBug> if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( "%d<S2SV_blank>-=<S2SV_blank>%d\\n" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }
CWE-119 <S2SV_StartBug> static void usage ( char * progname ) { <S2SV_EndBug> printf ( "Usage:\\n" ) ; printf ( "%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>" , <S2SV_StartBug> progname ) ; <S2SV_EndBug> printf ( "<output_yuv><S2SV_blank>[<frames>]\\n" ) ; }
CWE-264 static int wrmsr_interception ( struct vcpu_svm * svm ) { struct msr_data msr ; u32 ecx = svm -> vcpu . arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( svm -> vcpu . arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( svm -> vcpu . arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; <S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( & svm -> vcpu , 0 ) ; } else { trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( & svm -> vcpu ) ; } return 1 ; }
CWE-284 static inline int btif_hl_select_wakeup ( void ) { char sig_on = btif_hl_signal_select_wakeup ; BTIF_TRACE_DEBUG ( "btif_hl_select_wakeup" ) ; <S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> }
CWE-000 static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { <S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> }
CWE-362 <S2SV_StartBug> static struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , <S2SV_EndBug> struct btrfs_path * path , const char * name , int name_len ) { struct btrfs_dir_item * dir_item ; unsigned long name_ptr ; u32 total_len ; u32 cur = 0 ; u32 this_len ; struct extent_buffer * leaf ; leaf = path -> nodes [ 0 ] ; dir_item = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , struct btrfs_dir_item ) ; if ( verify_dir_item ( root , leaf , dir_item ) ) return NULL ; total_len = btrfs_item_size_nr ( leaf , path -> slots [ 0 ] ) ; while ( cur < total_len ) { this_len = sizeof ( * dir_item ) + btrfs_dir_name_len ( leaf , dir_item ) + btrfs_dir_data_len ( leaf , dir_item ) ; name_ptr = ( unsigned long ) ( dir_item + 1 ) ; if ( btrfs_dir_name_len ( leaf , dir_item ) == name_len && memcmp_extent_buffer ( leaf , name , name_ptr , name_len ) == 0 ) return dir_item ; cur += this_len ; dir_item = ( struct btrfs_dir_item * ) ( ( char * ) dir_item + this_len ) ; } return NULL ; }
CWE-399 static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ; <S2SV_StartBug> struct address_space * mapping ; <S2SV_EndBug> mapping = ( struct address_space * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { update_and_free_page ( h , page ) ; h -> surplus_huge_pages -- ; h -> surplus_huge_pages_node [ nid ] -- ; } else { enqueue_huge_page ( h , page ) ; } spin_unlock ( & hugetlb_lock ) ; <S2SV_StartBug> if ( mapping ) <S2SV_EndBug> hugetlb_put_quota ( mapping , 1 ) ; }
CWE-119 static void opl3_setup_voice ( int dev , int voice , int chn ) { <S2SV_StartBug> struct channel_info * info = <S2SV_EndBug> & synth_devs [ dev ] -> chn_info [ chn ] ; opl3_set_instr ( dev , voice , info -> pgm_num ) ; devc -> voc [ voice ] . bender = 0 ; devc -> voc [ voice ] . bender_range = info -> bender_range ; devc -> voc [ voice ] . volume = info -> controllers [ CTL_MAIN_VOLUME ] ; devc -> voc [ voice ] . panning = ( info -> controllers [ CTL_PAN ] * 2 ) - 128 ; }
CWE-399 static gdImagePtr gdImageScaleTwoPass ( const gdImagePtr src , const unsigned int new_width , const unsigned int new_height ) { const unsigned int src_width = src -> sx ; const unsigned int src_height = src -> sy ; gdImagePtr tmp_im = NULL ; gdImagePtr dst = NULL ; if ( src_width == new_width && src_height == new_height ) { return gdImageClone ( src ) ; } if ( ! src -> trueColor ) { gdImagePaletteToTrueColor ( src ) ; } if ( src_width == new_width ) { tmp_im = src ; } else { tmp_im = gdImageCreateTrueColor ( new_width , src_height ) ; if ( tmp_im == NULL ) { return NULL ; } gdImageSetInterpolationMethod ( tmp_im , src -> interpolation_id ) ; _gdScalePass ( src , src_width , tmp_im , new_width , src_height , HORIZONTAL ) ; } if ( src_height == new_height ) { assert ( tmp_im != src ) ; return tmp_im ; } dst = gdImageCreateTrueColor ( new_width , new_height ) ; if ( dst != NULL ) { gdImageSetInterpolationMethod ( dst , src -> interpolation_id ) ; _gdScalePass ( tmp_im , src_height , dst , new_height , new_width , VERTICAL ) ; } if ( src != tmp_im ) { <S2SV_StartBug> gdFree ( tmp_im ) ; <S2SV_EndBug> } return dst ; }
CWE-200 static int get_bitmap_file ( struct mddev * mddev , void __user * arg ) { mdu_bitmap_file_t * file = NULL ; char * ptr ; int err ; <S2SV_StartBug> file = kmalloc ( sizeof ( * file ) , GFP_NOIO ) ; <S2SV_EndBug> if ( ! file ) return - ENOMEM ; err = 0 ; spin_lock ( & mddev -> lock ) ; if ( ! mddev -> bitmap_info . file ) file -> pathname [ 0 ] = '\\0' ; else if ( ( ptr = file_path ( mddev -> bitmap_info . file , file -> pathname , sizeof ( file -> pathname ) ) ) , IS_ERR ( ptr ) ) err = PTR_ERR ( ptr ) ; else memmove ( file -> pathname , ptr , sizeof ( file -> pathname ) - ( ptr - file -> pathname ) ) ; spin_unlock ( & mddev -> lock ) ; if ( err == 0 && copy_to_user ( arg , file , sizeof ( * file ) ) ) err = - EFAULT ; kfree ( file ) ; return err ; }
CWE-119 static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; <S2SV_EndBug> if ( data ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; <S2SV_StartBug> image2yuvconfig ( & frame -> img , & sd ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_copy_reference_dec ( ctx -> pbi , <S2SV_EndBug> ( VP9_REFFRAME ) frame -> frame_type , & sd ) ; } else { return VPX_CODEC_INVALID_PARAM ; } }
CWE-119 int vp8cx_encode_inter_macroblock ( VP8_COMP * cpi , MACROBLOCK * x , TOKENEXTRA * * t , int recon_yoffset , int recon_uvoffset , int mb_row , int mb_col ) { MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error = 0 ; int rate ; int distortion ; x -> skip = 0 ; if ( xd -> segmentation_enabled ) x -> encode_breakout = cpi -> segment_encode_breakout [ xd -> mode_info_context -> mbmi . segment_id ] ; else x -> encode_breakout = cpi -> oxcf . encode_breakout ; # if CONFIG_TEMPORAL_DENOISING x -> best_reference_frame = INTRA_FRAME ; x -> best_zeromv_reference_frame = INTRA_FRAME ; x -> best_sse_inter_mode = 0 ; x -> best_sse_mv . as_int = 0 ; x -> need_to_clamp_best_mvs = 0 ; # endif if ( cpi -> sf . RD ) { int zbin_mode_boost_enabled = x -> zbin_mode_boost_enabled ; if ( cpi -> sf . use_fastquant_for_pick ) { x -> quantize_b = vp8_fast_quantize_b ; <S2SV_StartBug> x -> quantize_b_pair = vp8_fast_quantize_b_pair ; <S2SV_EndBug> x -> zbin_mode_boost_enabled = 0 ; } vp8_rd_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate , <S2SV_StartBug> & distortion , & intra_error ) ; <S2SV_EndBug> if ( cpi -> sf . improved_quant ) { <S2SV_StartBug> x -> quantize_b = vp8_regular_quantize_b ; <S2SV_EndBug> x -> quantize_b_pair = vp8_regular_quantize_b_pair ; } x -> zbin_mode_boost_enabled = zbin_mode_boost_enabled ; } else { vp8_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate , & distortion , & intra_error , mb_row , mb_col ) ; } x -> prediction_error += distortion ; x -> intra_error += intra_error ; if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; } # if 0 cpi -> frame_distortion += distortion ; cpi -> last_mb_distortion = distortion ; # endif if ( xd -> segmentation_enabled ) { if ( cpi -> current_layer == 0 && cpi -> cyclic_refresh_mode_enabled ) { if ( ( xd -> mode_info_context -> mbmi . segment_id == 1 ) && ( ( xd -> mode_info_context -> mbmi . ref_frame != LAST_FRAME ) || ( xd -> mode_info_context -> mbmi . mode != ZEROMV ) ) ) { xd -> mode_info_context -> mbmi . segment_id = 0 ; vp8cx_mb_init_quantizer ( cpi , x , 1 ) ; } } } { x -> zbin_mode_boost = 0 ; if ( x -> zbin_mode_boost_enabled ) { if ( xd -> mode_info_context -> mbmi . ref_frame != INTRA_FRAME ) { if ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) { if ( xd -> mode_info_context -> mbmi . ref_frame != LAST_FRAME && cpi -> oxcf . number_of_layers == 1 ) x -> zbin_mode_boost = GF_ZEROMV_ZBIN_BOOST ; else x -> zbin_mode_boost = LF_ZEROMV_ZBIN_BOOST ; } else if ( xd -> mode_info_context -> mbmi . mode == SPLITMV ) x -> zbin_mode_boost = 0 ; else x -> zbin_mode_boost = MV_ZBIN_BOOST ; } } if ( cpi -> sf . improved_quant ) vp8_update_zbin_extra ( cpi , x ) ; } x -> count_mb_ref_frame_usage [ xd -> mode_info_context -> mbmi . ref_frame ] ++ ; if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_encode_intra16x16mbuv ( x ) ; if ( xd -> mode_info_context -> mbmi . mode == B_PRED ) { vp8_encode_intra4x4mby ( x ) ; } else { vp8_encode_intra16x16mby ( x ) ; } sum_intra_stats ( cpi , x ) ; } else { int ref_fb_idx ; if ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ref_fb_idx = cpi -> common . lst_fb_idx ; else if ( xd -> mode_info_context -> mbmi . ref_frame == GOLDEN_FRAME ) ref_fb_idx = cpi -> common . gld_fb_idx ; else ref_fb_idx = cpi -> common . alt_fb_idx ; xd -> pre . y_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . y_buffer + recon_yoffset ; xd -> pre . u_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . u_buffer + recon_uvoffset ; xd -> pre . v_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . v_buffer + recon_uvoffset ; if ( ! x -> skip ) { vp8_encode_inter16x16 ( x ) ; } else vp8_build_inter16x16_predictors_mb ( xd , xd -> dst . y_buffer , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . y_stride , xd -> dst . uv_stride ) ; } if ( ! x -> skip ) { vp8_tokenize_mb ( cpi , x , t ) ; if ( xd -> mode_info_context -> mbmi . mode != B_PRED ) vp8_inverse_transform_mby ( xd ) ; vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } else { xd -> mode_info_context -> mbmi . mb_skip_coeff = 1 ; if ( cpi -> common . mb_no_coeff_skip ) { x -> skip_true_count ++ ; vp8_fix_contexts ( xd ) ; } else { vp8_stuff_mb ( cpi , x , t ) ; } } return rate ; }
CWE-119 static int compare_tile_buffers ( const void * a , const void * b ) { const TileBuffer * const buf1 = ( const TileBuffer * ) a ; const TileBuffer * const buf2 = ( const TileBuffer * ) b ; <S2SV_StartBug> if ( buf1 -> size < buf2 -> size ) { <S2SV_EndBug> return 1 ; } else if ( buf1 -> size == buf2 -> size ) { return 0 ; } else { return - 1 ; } }
