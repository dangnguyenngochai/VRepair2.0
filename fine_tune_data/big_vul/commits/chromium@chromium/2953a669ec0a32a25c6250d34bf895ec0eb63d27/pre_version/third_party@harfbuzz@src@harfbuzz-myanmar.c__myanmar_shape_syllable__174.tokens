static HB_Bool myanmar_shape_syllable ( HB_Bool openType , HB_ShaperItem * item , HB_Bool invalid ) //<S2SV> { //<S2SV> # ifndef NO_OPENTYPE //<S2SV> const int availableGlyphs = item -> num_glyphs ; //<S2SV> # endif //<S2SV> const HB_UChar16 * uc = item -> string + item -> item . pos ; //<S2SV> int vowel_e = - 1 ; //<S2SV> int kinzi = - 1 ; //<S2SV> int medial_ra = - 1 ; //<S2SV> int base = - 1 ; //<S2SV> int i ; //<S2SV> int len = 0 ; //<S2SV> unsigned short reordered [ 32 ] ; //<S2SV> unsigned char properties [ 32 ] ; //<S2SV> enum { //<S2SV> AboveForm = 0x01 , //<S2SV> PreForm = 0x02 , //<S2SV> PostForm = 0x04 , //<S2SV> BelowForm = 0x08 //<S2SV> } ; //<S2SV> HB_Bool lastWasVirama = FALSE ; //<S2SV> int basePos = - 1 ; //<S2SV> memset ( properties , 0 , 32 * sizeof ( unsigned char ) ) ; //<S2SV> assert ( item -> item . length < 32 ) ; //<S2SV> # ifdef MYANMAR_DEBUG //<S2SV> printf ( "original:" ) ; //<S2SV> for ( i = 0 ; i < ( int ) item -> item . length ; i ++ ) { //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d:<S2SV_blank>%4x" , i , uc [ i ] ) ; //<S2SV> } //<S2SV> # endif //<S2SV> for ( i = 0 ; i < ( int ) item -> item . length ; ++ i ) { //<S2SV> HB_UChar16 chr = uc [ i ] ; //<S2SV> if ( chr == Mymr_C_VOWEL_E ) { //<S2SV> vowel_e = i ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( i == 0 //<S2SV> && chr == Mymr_C_NGA //<S2SV> && i + 2 < ( int ) item -> item . length //<S2SV> && uc [ i + 1 ] == Mymr_C_VIRAMA ) { //<S2SV> int mc = getMyanmarCharClass ( uc [ i + 2 ] ) ; //<S2SV> if ( ( mc & Mymr_CF_CONSONANT ) == Mymr_CF_CONSONANT ) { //<S2SV> kinzi = i ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> if ( base >= 0 //<S2SV> && chr == Mymr_C_VIRAMA //<S2SV> && i + 1 < ( int ) item -> item . length //<S2SV> && uc [ i + 1 ] == Mymr_C_RA ) { //<S2SV> medial_ra = i ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( base < 0 ) //<S2SV> base = i ; //<S2SV> } //<S2SV> MMDEBUG ( "\\n<S2SV_blank><S2SV_blank>base=%d,<S2SV_blank>vowel_e=%d,<S2SV_blank>kinzi=%d,<S2SV_blank>medial_ra=%d" , base , vowel_e , kinzi , medial_ra ) ; //<S2SV> if ( vowel_e >= 0 ) { //<S2SV> reordered [ 0 ] = Mymr_C_VOWEL_E ; //<S2SV> len = 1 ; //<S2SV> } //<S2SV> if ( medial_ra >= 0 ) { //<S2SV> reordered [ len ] = Mymr_C_VIRAMA ; //<S2SV> reordered [ len + 1 ] = Mymr_C_RA ; //<S2SV> properties [ len ] = PreForm ; //<S2SV> properties [ len + 1 ] = PreForm ; //<S2SV> len += 2 ; //<S2SV> } //<S2SV> if ( invalid ) { //<S2SV> reordered [ len ] = C_DOTTED_CIRCLE ; //<S2SV> ++ len ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ( int ) item -> item . length ; ++ i ) { //<S2SV> hb_uint16 chr = uc [ i ] ; //<S2SV> MymrCharClass cc ; //<S2SV> if ( i == vowel_e ) //<S2SV> continue ; //<S2SV> if ( i == medial_ra || i == kinzi ) { //<S2SV> ++ i ; //<S2SV> continue ; //<S2SV> } //<S2SV> cc = getMyanmarCharClass ( uc [ i ] ) ; //<S2SV> if ( kinzi >= 0 && i > base && ( cc & Mymr_CF_AFTER_KINZI ) ) { //<S2SV> reordered [ len ] = Mymr_C_NGA ; //<S2SV> reordered [ len + 1 ] = Mymr_C_VIRAMA ; //<S2SV> properties [ len - 1 ] = AboveForm ; //<S2SV> properties [ len ] = AboveForm ; //<S2SV> len += 2 ; //<S2SV> kinzi = - 1 ; //<S2SV> } //<S2SV> if ( lastWasVirama ) { //<S2SV> int prop = 0 ; //<S2SV> switch ( cc & Mymr_CF_POS_MASK ) { //<S2SV> case Mymr_CF_POS_BEFORE : //<S2SV> prop = PreForm ; //<S2SV> break ; //<S2SV> case Mymr_CF_POS_BELOW : //<S2SV> prop = BelowForm ; //<S2SV> break ; //<S2SV> case Mymr_CF_POS_ABOVE : //<S2SV> prop = AboveForm ; //<S2SV> break ; //<S2SV> case Mymr_CF_POS_AFTER : //<S2SV> prop = PostForm ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> properties [ len - 1 ] = prop ; //<S2SV> properties [ len ] = prop ; //<S2SV> if ( basePos >= 0 && basePos == len - 2 ) //<S2SV> properties [ len - 2 ] = prop ; //<S2SV> } //<S2SV> lastWasVirama = ( chr == Mymr_C_VIRAMA ) ; //<S2SV> if ( i == base ) //<S2SV> basePos = len ; //<S2SV> if ( ( chr != Mymr_C_SIGN_ZWNJ && chr != Mymr_C_SIGN_ZWJ ) || ! len ) { //<S2SV> reordered [ len ] = chr ; //<S2SV> ++ len ; //<S2SV> } //<S2SV> } //<S2SV> if ( kinzi >= 0 ) { //<S2SV> reordered [ len ] = Mymr_C_NGA ; //<S2SV> reordered [ len + 1 ] = Mymr_C_VIRAMA ; //<S2SV> properties [ len ] = AboveForm ; //<S2SV> properties [ len + 1 ] = AboveForm ; //<S2SV> len += 2 ; //<S2SV> } //<S2SV> if ( ! item -> font -> klass -> convertStringToGlyphIndices ( item -> font , //<S2SV> reordered , len , //<S2SV> item -> glyphs , & item -> num_glyphs , //<S2SV> item -> item . bidiLevel % 2 ) ) //<S2SV> return FALSE ; //<S2SV> MMDEBUG ( "after<S2SV_blank>shaping:<S2SV_blank>len=%d" , len ) ; //<S2SV> for ( i = 0 ; i < len ; i ++ ) { //<S2SV> item -> attributes [ i ] . mark = FALSE ; //<S2SV> item -> attributes [ i ] . clusterStart = FALSE ; //<S2SV> item -> attributes [ i ] . justification = 0 ; //<S2SV> item -> attributes [ i ] . zeroWidth = FALSE ; //<S2SV> MMDEBUG ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d:<S2SV_blank>%4x<S2SV_blank>property=%x" , i , reordered [ i ] , properties [ i ] ) ; //<S2SV> } //<S2SV> # ifndef NO_OPENTYPE //<S2SV> if ( openType ) { //<S2SV> hb_uint32 where [ 32 ] ; //<S2SV> for ( i = 0 ; i < len ; ++ i ) { //<S2SV> where [ i ] = ~ ( PreSubstProperty //<S2SV> | BelowSubstProperty //<S2SV> | AboveSubstProperty //<S2SV> | PostSubstProperty //<S2SV> | CligProperty //<S2SV> | PositioningProperties ) ; //<S2SV> if ( properties [ i ] & PreForm ) //<S2SV> where [ i ] &= ~ PreFormProperty ; //<S2SV> if ( properties [ i ] & BelowForm ) //<S2SV> where [ i ] &= ~ BelowFormProperty ; //<S2SV> if ( properties [ i ] & AboveForm ) //<S2SV> where [ i ] &= ~ AboveFormProperty ; //<S2SV> if ( properties [ i ] & PostForm ) //<S2SV> where [ i ] &= ~ PostFormProperty ; //<S2SV> } //<S2SV> HB_OpenTypeShape ( item , where ) ; //<S2SV> if ( ! HB_OpenTypePosition ( item , availableGlyphs , FALSE ) ) //<S2SV> return FALSE ; //<S2SV> } else //<S2SV> # endif //<S2SV> { //<S2SV> MMDEBUG ( "Not<S2SV_blank>using<S2SV_blank>openType" ) ; //<S2SV> HB_HeuristicPosition ( item ) ; //<S2SV> } //<S2SV> item -> attributes [ 0 ] . clusterStart = TRUE ; //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 