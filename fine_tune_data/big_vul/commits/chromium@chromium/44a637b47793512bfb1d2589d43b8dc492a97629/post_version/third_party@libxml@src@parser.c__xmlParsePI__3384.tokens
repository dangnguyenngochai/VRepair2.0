void //<S2SV> xmlParsePI ( xmlParserCtxtPtr ctxt ) { //<S2SV> xmlChar * buf = NULL ; //<S2SV> int len = 0 ; //<S2SV> int size = XML_PARSER_BUFFER_SIZE ; //<S2SV> int cur , l ; //<S2SV> const xmlChar * target ; //<S2SV> xmlParserInputState state ; //<S2SV> int count = 0 ; //<S2SV> if ( ( RAW == '<' ) && ( NXT ( 1 ) == '?' ) ) { //<S2SV> xmlParserInputPtr input = ctxt -> input ; //<S2SV> state = ctxt -> instate ; //<S2SV> ctxt -> instate = XML_PARSER_PI ; //<S2SV> SKIP ( 2 ) ; //<S2SV> SHRINK ; //<S2SV> target = xmlParsePITarget ( ctxt ) ; //<S2SV> if ( target != NULL ) { //<S2SV> if ( ( RAW == '?' ) && ( NXT ( 1 ) == '>' ) ) { //<S2SV> if ( input != ctxt -> input ) { //<S2SV> xmlFatalErrMsg ( ctxt , XML_ERR_ENTITY_BOUNDARY , //<S2SV> "PI<S2SV_blank>declaration<S2SV_blank>doesn\'t<S2SV_blank>start<S2SV_blank>and<S2SV_blank>stop<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>entity\\n" ) ; //<S2SV> } //<S2SV> SKIP ( 2 ) ; //<S2SV> if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && //<S2SV> ( ctxt -> sax -> processingInstruction != NULL ) ) //<S2SV> ctxt -> sax -> processingInstruction ( ctxt -> userData , //<S2SV> target , NULL ) ; //<S2SV> if ( ctxt -> instate != XML_PARSER_EOF ) //<S2SV> ctxt -> instate = state ; //<S2SV> return ; //<S2SV> } //<S2SV> buf = ( xmlChar * ) xmlMallocAtomic ( size * sizeof ( xmlChar ) ) ; //<S2SV> if ( buf == NULL ) { //<S2SV> xmlErrMemory ( ctxt , NULL ) ; //<S2SV> ctxt -> instate = state ; //<S2SV> return ; //<S2SV> } //<S2SV> cur = CUR ; //<S2SV> if ( ! IS_BLANK ( cur ) ) { //<S2SV> xmlFatalErrMsgStr ( ctxt , XML_ERR_SPACE_REQUIRED , //<S2SV> "ParsePI:<S2SV_blank>PI<S2SV_blank>%s<S2SV_blank>space<S2SV_blank>expected\\n" , target ) ; //<S2SV> } //<S2SV> SKIP_BLANKS ; //<S2SV> cur = CUR_CHAR ( l ) ; //<S2SV> while ( IS_CHAR ( cur ) && //<S2SV> ( ( cur != '?' ) || ( NXT ( 1 ) != '>' ) ) ) { //<S2SV> if ( len + 5 >= size ) { //<S2SV> xmlChar * tmp ; //<S2SV> size *= 2 ; //<S2SV> tmp = ( xmlChar * ) xmlRealloc ( buf , size * sizeof ( xmlChar ) ) ; //<S2SV> if ( tmp == NULL ) { //<S2SV> xmlErrMemory ( ctxt , NULL ) ; //<S2SV> xmlFree ( buf ) ; //<S2SV> ctxt -> instate = state ; //<S2SV> return ; //<S2SV> } //<S2SV> buf = tmp ; //<S2SV> } //<S2SV> count ++ ; //<S2SV> if ( count > 50 ) { //<S2SV> GROW ; //<S2SV> count = 0 ; //<S2SV> } //<S2SV> COPY_BUF ( l , buf , len , cur ) ; //<S2SV> NEXTL ( l ) ; //<S2SV> cur = CUR_CHAR ( l ) ; //<S2SV> if ( cur == 0 ) { //<S2SV> SHRINK ; //<S2SV> GROW ; //<S2SV> cur = CUR_CHAR ( l ) ; //<S2SV> } //<S2SV> } //<S2SV> buf [ len ] = 0 ; //<S2SV> if ( cur != '?' ) { //<S2SV> xmlFatalErrMsgStr ( ctxt , XML_ERR_PI_NOT_FINISHED , //<S2SV> "ParsePI:<S2SV_blank>PI<S2SV_blank>%s<S2SV_blank>never<S2SV_blank>end<S2SV_blank>...\\n" , target ) ; //<S2SV> } else { //<S2SV> if ( input != ctxt -> input ) { //<S2SV> xmlFatalErrMsg ( ctxt , XML_ERR_SPACE_REQUIRED , //<S2SV> "PI<S2SV_blank>declaration<S2SV_blank>doesn\'t<S2SV_blank>start<S2SV_blank>and<S2SV_blank>stop<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>entity\\n" ) ; //<S2SV> } //<S2SV> SKIP ( 2 ) ; //<S2SV> # ifdef LIBXML_CATALOG_ENABLED //<S2SV> if ( ( ( state == XML_PARSER_MISC ) || //<S2SV> ( state == XML_PARSER_START ) ) && //<S2SV> ( xmlStrEqual ( target , XML_CATALOG_PI ) ) ) { //<S2SV> xmlCatalogAllow allow = xmlCatalogGetDefaults ( ) ; //<S2SV> if ( ( allow == XML_CATA_ALLOW_DOCUMENT ) || //<S2SV> ( allow == XML_CATA_ALLOW_ALL ) ) //<S2SV> xmlParseCatalogPI ( ctxt , buf ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && //<S2SV> ( ctxt -> sax -> processingInstruction != NULL ) ) //<S2SV> ctxt -> sax -> processingInstruction ( ctxt -> userData , //<S2SV> target , buf ) ; //<S2SV> } //<S2SV> xmlFree ( buf ) ; //<S2SV> } else { //<S2SV> xmlFatalErr ( ctxt , XML_ERR_PI_NOT_STARTED , NULL ) ; //<S2SV> } //<S2SV> if ( ctxt -> instate != XML_PARSER_EOF ) //<S2SV> ctxt -> instate = state ; //<S2SV> } //<S2SV> } //<S2SV> 