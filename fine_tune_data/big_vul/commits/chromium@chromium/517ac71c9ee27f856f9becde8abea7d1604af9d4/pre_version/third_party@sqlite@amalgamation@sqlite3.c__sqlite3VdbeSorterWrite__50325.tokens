SQLITE_PRIVATE int sqlite3VdbeSorterWrite ( //<S2SV> const VdbeCursor * pCsr , //<S2SV> Mem * pVal //<S2SV> ) { //<S2SV> VdbeSorter * pSorter ; //<S2SV> int rc = SQLITE_OK ; //<S2SV> SorterRecord * pNew ; //<S2SV> int bFlush ; //<S2SV> int nReq ; //<S2SV> int nPMA ; //<S2SV> int t ; //<S2SV> assert ( pCsr -> eCurType == CURTYPE_SORTER ) ; //<S2SV> pSorter = pCsr -> uc . pSorter ; //<S2SV> getVarint32 ( ( const u8 * ) & pVal -> z [ 1 ] , t ) ; //<S2SV> if ( t > 0 && t < 10 && t != 7 ) { //<S2SV> pSorter -> typeMask &= SORTER_TYPE_INTEGER ; //<S2SV> } else if ( t > 10 && ( t & 0x01 ) ) { //<S2SV> pSorter -> typeMask &= SORTER_TYPE_TEXT ; //<S2SV> } else { //<S2SV> pSorter -> typeMask = 0 ; //<S2SV> } //<S2SV> assert ( pSorter ) ; //<S2SV> nReq = pVal -> n + sizeof ( SorterRecord ) ; //<S2SV> nPMA = pVal -> n + sqlite3VarintLen ( pVal -> n ) ; //<S2SV> if ( pSorter -> mxPmaSize ) { //<S2SV> if ( pSorter -> list . aMemory ) { //<S2SV> bFlush = pSorter -> iMemory && ( pSorter -> iMemory + nReq ) > pSorter -> mxPmaSize ; //<S2SV> } else { //<S2SV> bFlush = ( //<S2SV> ( pSorter -> list . szPMA > pSorter -> mxPmaSize ) //<S2SV> || ( pSorter -> list . szPMA > pSorter -> mnPmaSize && sqlite3HeapNearlyFull ( ) ) //<S2SV> ) ; //<S2SV> } //<S2SV> if ( bFlush ) { //<S2SV> rc = vdbeSorterFlushPMA ( pSorter ) ; //<S2SV> pSorter -> list . szPMA = 0 ; //<S2SV> pSorter -> iMemory = 0 ; //<S2SV> assert ( rc != SQLITE_OK || pSorter -> list . pList == 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> pSorter -> list . szPMA += nPMA ; //<S2SV> if ( nPMA > pSorter -> mxKeysize ) { //<S2SV> pSorter -> mxKeysize = nPMA ; //<S2SV> } //<S2SV> if ( pSorter -> list . aMemory ) { //<S2SV> int nMin = pSorter -> iMemory + nReq ; //<S2SV> if ( nMin > pSorter -> nMemory ) { //<S2SV> u8 * aNew ; //<S2SV> int iListOff = ( u8 * ) pSorter -> list . pList - pSorter -> list . aMemory ; //<S2SV> int nNew = pSorter -> nMemory * 2 ; //<S2SV> while ( nNew < nMin ) nNew = nNew * 2 ; //<S2SV> if ( nNew > pSorter -> mxPmaSize ) nNew = pSorter -> mxPmaSize ; //<S2SV> if ( nNew < nMin ) nNew = nMin ; //<S2SV> aNew = sqlite3Realloc ( pSorter -> list . aMemory , nNew ) ; //<S2SV> if ( ! aNew ) return SQLITE_NOMEM_BKPT ; //<S2SV> pSorter -> list . pList = ( SorterRecord * ) & aNew [ iListOff ] ; //<S2SV> pSorter -> list . aMemory = aNew ; //<S2SV> pSorter -> nMemory = nNew ; //<S2SV> } //<S2SV> pNew = ( SorterRecord * ) & pSorter -> list . aMemory [ pSorter -> iMemory ] ; //<S2SV> pSorter -> iMemory += ROUND8 ( nReq ) ; //<S2SV> if ( pSorter -> list . pList ) { //<S2SV> pNew -> u . iNext = ( int ) ( ( u8 * ) ( pSorter -> list . pList ) - pSorter -> list . aMemory ) ; //<S2SV> } //<S2SV> } else { //<S2SV> pNew = ( SorterRecord * ) sqlite3Malloc ( nReq ) ; //<S2SV> if ( pNew == 0 ) { //<S2SV> return SQLITE_NOMEM_BKPT ; //<S2SV> } //<S2SV> pNew -> u . pNext = pSorter -> list . pList ; //<S2SV> } //<S2SV> memcpy ( SRVAL ( pNew ) , pVal -> z , pVal -> n ) ; //<S2SV> pNew -> nVal = pVal -> n ; //<S2SV> pSorter -> list . pList = pNew ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 