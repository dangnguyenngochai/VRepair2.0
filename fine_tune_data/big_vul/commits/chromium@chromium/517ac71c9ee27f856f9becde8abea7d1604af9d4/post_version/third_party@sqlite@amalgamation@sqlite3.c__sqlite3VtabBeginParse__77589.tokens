SQLITE_PRIVATE void sqlite3VtabBeginParse ( //<S2SV> Parse * pParse , //<S2SV> Token * pName1 , //<S2SV> Token * pName2 , //<S2SV> Token * pModuleName , //<S2SV> int ifNotExists //<S2SV> ) { //<S2SV> Table * pTable ; //<S2SV> sqlite3 * db ; //<S2SV> sqlite3StartTable ( pParse , pName1 , pName2 , 0 , 0 , 1 , ifNotExists ) ; //<S2SV> pTable = pParse -> pNewTable ; //<S2SV> if ( pTable == 0 ) return ; //<S2SV> assert ( 0 == pTable -> pIndex ) ; //<S2SV> db = pParse -> db ; //<S2SV> assert ( pTable -> nModuleArg == 0 ) ; //<S2SV> addModuleArgument ( pParse , pTable , sqlite3NameFromToken ( db , pModuleName ) ) ; //<S2SV> addModuleArgument ( pParse , pTable , 0 ) ; //<S2SV> addModuleArgument ( pParse , pTable , sqlite3DbStrDup ( db , pTable -> zName ) ) ; //<S2SV> assert ( ( pParse -> sNameToken . z == pName2 -> z && pName2 -> z != 0 ) //<S2SV> || ( pParse -> sNameToken . z == pName1 -> z && pName2 -> z == 0 ) //<S2SV> ) ; //<S2SV> pParse -> sNameToken . n = ( int ) ( //<S2SV> & pModuleName -> z [ pModuleName -> n ] - pParse -> sNameToken . z //<S2SV> ) ; //<S2SV> # ifndef SQLITE_OMIT_AUTHORIZATION //<S2SV> if ( pTable -> azModuleArg ) { //<S2SV> int iDb = sqlite3SchemaToIndex ( db , pTable -> pSchema ) ; //<S2SV> assert ( iDb >= 0 ) ; //<S2SV> sqlite3AuthCheck ( pParse , SQLITE_CREATE_VTABLE , pTable -> zName , //<S2SV> pTable -> azModuleArg [ 0 ] , pParse -> db -> aDb [ iDb ] . zDbSName ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> 