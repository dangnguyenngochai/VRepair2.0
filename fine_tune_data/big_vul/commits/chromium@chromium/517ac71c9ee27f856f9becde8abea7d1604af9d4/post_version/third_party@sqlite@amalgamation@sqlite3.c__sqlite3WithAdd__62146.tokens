SQLITE_PRIVATE With * sqlite3WithAdd ( //<S2SV> Parse * pParse , //<S2SV> With * pWith , //<S2SV> Token * pName , //<S2SV> ExprList * pArglist , //<S2SV> Select * pQuery //<S2SV> ) { //<S2SV> sqlite3 * db = pParse -> db ; //<S2SV> With * pNew ; //<S2SV> char * zName ; //<S2SV> zName = sqlite3NameFromToken ( pParse -> db , pName ) ; //<S2SV> if ( zName && pWith ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < pWith -> nCte ; i ++ ) { //<S2SV> if ( sqlite3StrICmp ( zName , pWith -> a [ i ] . zName ) == 0 ) { //<S2SV> sqlite3ErrorMsg ( pParse , "duplicate<S2SV_blank>WITH<S2SV_blank>table<S2SV_blank>name:<S2SV_blank>%s" , zName ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( pWith ) { //<S2SV> sqlite3_int64 nByte = sizeof ( * pWith ) + ( sizeof ( pWith -> a [ 1 ] ) * pWith -> nCte ) ; //<S2SV> pNew = sqlite3DbRealloc ( db , pWith , nByte ) ; //<S2SV> } else { //<S2SV> pNew = sqlite3DbMallocZero ( db , sizeof ( * pWith ) ) ; //<S2SV> } //<S2SV> assert ( ( pNew != 0 && zName != 0 ) || db -> mallocFailed ) ; //<S2SV> if ( db -> mallocFailed ) { //<S2SV> sqlite3ExprListDelete ( db , pArglist ) ; //<S2SV> sqlite3SelectDelete ( db , pQuery ) ; //<S2SV> sqlite3DbFree ( db , zName ) ; //<S2SV> pNew = pWith ; //<S2SV> } else { //<S2SV> pNew -> a [ pNew -> nCte ] . pSelect = pQuery ; //<S2SV> pNew -> a [ pNew -> nCte ] . pCols = pArglist ; //<S2SV> pNew -> a [ pNew -> nCte ] . zName = zName ; //<S2SV> pNew -> a [ pNew -> nCte ] . zCteErr = 0 ; //<S2SV> pNew -> nCte ++ ; //<S2SV> } //<S2SV> return pNew ; //<S2SV> } //<S2SV> 