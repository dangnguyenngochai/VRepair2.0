int sandbox ( void * sandbox_arg ) { //<S2SV> ( void ) sandbox_arg ; //<S2SV> pid_t child_pid = getpid ( ) ; //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Initializing<S2SV_blank>child<S2SV_blank>process\\n" ) ; //<S2SV> close ( parent_to_child_fds [ 1 ] ) ; //<S2SV> close ( child_to_parent_fds [ 0 ] ) ; //<S2SV> wait_for_other ( parent_to_child_fds [ 0 ] ) ; //<S2SV> if ( arg_debug && child_pid == 1 ) //<S2SV> printf ( "PID<S2SV_blank>namespace<S2SV_blank>installed\\n" ) ; //<S2SV> if ( cfg . hostname ) { //<S2SV> if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) //<S2SV> errExit ( "sethostname" ) ; //<S2SV> } //<S2SV> if ( mount ( NULL , "/" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) { //<S2SV> chk_chroot ( ) ; //<S2SV> } //<S2SV> preproc_mount_mnt_dir ( ) ; //<S2SV> if ( mount ( LIBDIR "/firejail" , RUN_FIREJAIL_LIB_DIR , "none" , MS_BIND , NULL ) < 0 ) //<S2SV> errExit ( "mounting<S2SV_blank>" RUN_FIREJAIL_LIB_DIR ) ; //<S2SV> if ( cfg . name ) //<S2SV> fs_logger2 ( "sandbox<S2SV_blank>name:" , cfg . name ) ; //<S2SV> fs_logger2int ( "sandbox<S2SV_blank>pid:" , ( int ) sandbox_pid ) ; //<S2SV> if ( cfg . chrootdir ) //<S2SV> fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>chroot" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>overlay" ) ; //<S2SV> else //<S2SV> fs_logger ( "sandbox<S2SV_blank>filesystem:<S2SV_blank>local" ) ; //<S2SV> fs_logger ( "install<S2SV_blank>mount<S2SV_blank>namespace" ) ; //<S2SV> if ( arg_netfilter && any_bridge_configured ( ) ) { //<S2SV> netfilter ( arg_netfilter_file ) ; //<S2SV> } //<S2SV> if ( arg_netfilter6 && any_bridge_configured ( ) ) { //<S2SV> netfilter6 ( arg_netfilter6_file ) ; //<S2SV> } //<S2SV> int gw_cfg_failed = 0 ; //<S2SV> if ( arg_nonetwork ) { //<S2SV> net_if_up ( "lo" ) ; //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Network<S2SV_blank>namespace<S2SV_blank>enabled,<S2SV_blank>only<S2SV_blank>loopback<S2SV_blank>interface<S2SV_blank>available\\n" ) ; //<S2SV> } //<S2SV> else if ( arg_netns ) { //<S2SV> netns ( arg_netns ) ; //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Network<S2SV_blank>namespace<S2SV_blank>\'%s\'<S2SV_blank>activated\\n" , arg_netns ) ; //<S2SV> } //<S2SV> else if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { //<S2SV> net_if_up ( "lo" ) ; //<S2SV> if ( mac_not_zero ( cfg . bridge0 . macsandbox ) ) //<S2SV> net_config_mac ( cfg . bridge0 . devsandbox , cfg . bridge0 . macsandbox ) ; //<S2SV> sandbox_if_up ( & cfg . bridge0 ) ; //<S2SV> if ( mac_not_zero ( cfg . bridge1 . macsandbox ) ) //<S2SV> net_config_mac ( cfg . bridge1 . devsandbox , cfg . bridge1 . macsandbox ) ; //<S2SV> sandbox_if_up ( & cfg . bridge1 ) ; //<S2SV> if ( mac_not_zero ( cfg . bridge2 . macsandbox ) ) //<S2SV> net_config_mac ( cfg . bridge2 . devsandbox , cfg . bridge2 . macsandbox ) ; //<S2SV> sandbox_if_up ( & cfg . bridge2 ) ; //<S2SV> if ( mac_not_zero ( cfg . bridge3 . macsandbox ) ) //<S2SV> net_config_mac ( cfg . bridge3 . devsandbox , cfg . bridge3 . macsandbox ) ; //<S2SV> sandbox_if_up ( & cfg . bridge3 ) ; //<S2SV> if ( cfg . interface0 . configured && cfg . interface0 . ip ) { //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface0 . ip ) , cfg . interface0 . dev ) ; //<S2SV> net_config_interface ( cfg . interface0 . dev , cfg . interface0 . ip , cfg . interface0 . mask , cfg . interface0 . mtu ) ; //<S2SV> } //<S2SV> if ( cfg . interface1 . configured && cfg . interface1 . ip ) { //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface1 . ip ) , cfg . interface1 . dev ) ; //<S2SV> net_config_interface ( cfg . interface1 . dev , cfg . interface1 . ip , cfg . interface1 . mask , cfg . interface1 . mtu ) ; //<S2SV> } //<S2SV> if ( cfg . interface2 . configured && cfg . interface2 . ip ) { //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface2 . ip ) , cfg . interface2 . dev ) ; //<S2SV> net_config_interface ( cfg . interface2 . dev , cfg . interface2 . ip , cfg . interface2 . mask , cfg . interface2 . mtu ) ; //<S2SV> } //<S2SV> if ( cfg . interface3 . configured && cfg . interface3 . ip ) { //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Configuring<S2SV_blank>%d.%d.%d.%d<S2SV_blank>address<S2SV_blank>on<S2SV_blank>interface<S2SV_blank>%s\\n" , PRINT_IP ( cfg . interface3 . ip ) , cfg . interface3 . dev ) ; //<S2SV> net_config_interface ( cfg . interface3 . dev , cfg . interface3 . ip , cfg . interface3 . mask , cfg . interface3 . mtu ) ; //<S2SV> } //<S2SV> if ( cfg . defaultgw ) { //<S2SV> if ( net_add_route ( 0 , 0 , cfg . defaultgw ) ) { //<S2SV> fwarning ( "cannot<S2SV_blank>configure<S2SV_blank>default<S2SV_blank>route\\n" ) ; //<S2SV> gw_cfg_failed = 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Network<S2SV_blank>namespace<S2SV_blank>enabled\\n" ) ; //<S2SV> } //<S2SV> if ( ! arg_quiet ) { //<S2SV> if ( any_bridge_configured ( ) || any_interface_configured ( ) || cfg . defaultgw || cfg . dns1 ) { //<S2SV> fmessage ( "\\n" ) ; //<S2SV> if ( any_bridge_configured ( ) || any_interface_configured ( ) ) { //<S2SV> if ( arg_scan ) //<S2SV> sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 3 , PATH_FNET , "printif" , "scan" ) ; //<S2SV> else //<S2SV> sbox_run ( SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP , 2 , PATH_FNET , "printif" ) ; //<S2SV> } //<S2SV> if ( cfg . defaultgw != 0 ) { //<S2SV> if ( gw_cfg_failed ) //<S2SV> fmessage ( "Default<S2SV_blank>gateway<S2SV_blank>configuration<S2SV_blank>failed\\n" ) ; //<S2SV> else //<S2SV> fmessage ( "Default<S2SV_blank>gateway<S2SV_blank>%d.%d.%d.%d\\n" , PRINT_IP ( cfg . defaultgw ) ) ; //<S2SV> } //<S2SV> if ( cfg . dns1 != NULL ) //<S2SV> fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns1 ) ; //<S2SV> if ( cfg . dns2 != NULL ) //<S2SV> fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns2 ) ; //<S2SV> if ( cfg . dns3 != NULL ) //<S2SV> fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns3 ) ; //<S2SV> if ( cfg . dns4 != NULL ) //<S2SV> fmessage ( "DNS<S2SV_blank>server<S2SV_blank>%s\\n" , cfg . dns4 ) ; //<S2SV> fmessage ( "\\n" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( arg_nonetwork || any_bridge_configured ( ) || any_interface_configured ( ) ) { //<S2SV> } //<S2SV> else { //<S2SV> EUID_USER ( ) ; //<S2SV> env_ibus_load ( ) ; //<S2SV> EUID_ROOT ( ) ; //<S2SV> } //<S2SV> # ifdef HAVE_SECCOMP //<S2SV> if ( cfg . protocol ) { //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Build<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\n" , cfg . protocol ) ; //<S2SV> int rv = sbox_run ( SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP , 5 , //<S2SV> PATH_FSECCOMP , "protocol" , "build" , cfg . protocol , RUN_SECCOMP_PROTOCOL ) ; //<S2SV> if ( rv ) //<S2SV> exit ( rv ) ; //<S2SV> } //<S2SV> if ( arg_seccomp && ( cfg . seccomp_list || cfg . seccomp_list_drop || cfg . seccomp_list_keep ) ) //<S2SV> arg_seccomp_postexec = 1 ; //<S2SV> # endif //<S2SV> bool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec ; //<S2SV> if ( getuid ( ) != 0 && ( arg_appimage || cfg . chrootdir || arg_overlay ) ) { //<S2SV> enforce_filters ( ) ; //<S2SV> need_preload = arg_trace || arg_tracelog ; //<S2SV> } //<S2SV> if ( need_preload ) //<S2SV> fs_trace_preload ( ) ; //<S2SV> if ( cfg . hosts_file ) //<S2SV> fs_store_hosts_file ( ) ; //<S2SV> # ifdef HAVE_CHROOT //<S2SV> if ( cfg . chrootdir ) { //<S2SV> fs_chroot ( cfg . chrootdir ) ; //<S2SV> if ( need_preload ) //<S2SV> fs_trace_preload ( ) ; //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> # ifdef HAVE_OVERLAYFS //<S2SV> if ( arg_overlay ) //<S2SV> fs_overlayfs ( ) ; //<S2SV> else //<S2SV> # endif //<S2SV> fs_basic_fs ( ) ; //<S2SV> if ( arg_private ) { //<S2SV> if ( cfg . home_private ) { //<S2SV> if ( cfg . chrootdir ) //<S2SV> fwarning ( "private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fwarning ( "private=directory<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; //<S2SV> else //<S2SV> fs_private_homedir ( ) ; //<S2SV> } //<S2SV> else if ( cfg . home_private_keep ) { //<S2SV> if ( cfg . chrootdir ) //<S2SV> fwarning ( "private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fwarning ( "private-home=<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; //<S2SV> else //<S2SV> fs_private_home_list ( ) ; //<S2SV> } //<S2SV> else //<S2SV> fs_private ( ) ; //<S2SV> } //<S2SV> if ( arg_private_dev ) //<S2SV> fs_private_dev ( ) ; //<S2SV> if ( arg_private_etc ) { //<S2SV> if ( cfg . chrootdir ) //<S2SV> fwarning ( "private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fwarning ( "private-etc<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; //<S2SV> else { //<S2SV> fs_private_dir_list ( "/etc" , RUN_ETC_DIR , cfg . etc_private_keep ) ; //<S2SV> if ( need_preload ) //<S2SV> fs_trace_preload ( ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( arg_private_opt ) { //<S2SV> if ( cfg . chrootdir ) //<S2SV> fwarning ( "private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fwarning ( "private-opt<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; //<S2SV> else { //<S2SV> fs_private_dir_list ( "/opt" , RUN_OPT_DIR , cfg . opt_private_keep ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( arg_private_srv ) { //<S2SV> if ( cfg . chrootdir ) //<S2SV> fwarning ( "private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fwarning ( "private-srv<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; //<S2SV> else { //<S2SV> fs_private_dir_list ( "/srv" , RUN_SRV_DIR , cfg . srv_private_keep ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( arg_private_bin && ! arg_appimage ) { //<S2SV> if ( cfg . chrootdir ) //<S2SV> fwarning ( "private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fwarning ( "private-bin<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; //<S2SV> else { //<S2SV> if ( arg_x11_xorg ) { //<S2SV> EUID_USER ( ) ; //<S2SV> char * tmp ; //<S2SV> if ( asprintf ( & tmp , "%s,xauth" , cfg . bin_private_keep ) == - 1 ) //<S2SV> errExit ( "asprintf" ) ; //<S2SV> cfg . bin_private_keep = tmp ; //<S2SV> EUID_ROOT ( ) ; //<S2SV> } //<S2SV> fs_private_bin_list ( ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( arg_private_lib && ! arg_appimage ) { //<S2SV> if ( cfg . chrootdir ) //<S2SV> fwarning ( "private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fwarning ( "private-lib<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; //<S2SV> else { //<S2SV> fs_private_lib ( ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( arg_private_cache ) { //<S2SV> if ( cfg . chrootdir ) //<S2SV> fwarning ( "private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>chroot\\n" ) ; //<S2SV> else if ( arg_overlay ) //<S2SV> fwarning ( "private-cache<S2SV_blank>feature<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>overlay\\n" ) ; //<S2SV> else //<S2SV> fs_private_cache ( ) ; //<S2SV> } //<S2SV> if ( arg_private_tmp ) { //<S2SV> EUID_USER ( ) ; //<S2SV> fs_private_tmp ( ) ; //<S2SV> EUID_ROOT ( ) ; //<S2SV> } //<S2SV> if ( arg_nodbus ) //<S2SV> dbus_session_disable ( ) ; //<S2SV> if ( cfg . hostname ) //<S2SV> fs_hostname ( cfg . hostname ) ; //<S2SV> if ( cfg . hosts_file ) //<S2SV> fs_mount_hosts_file ( ) ; //<S2SV> if ( arg_netns ) //<S2SV> netns_mounts ( arg_netns ) ; //<S2SV> fs_proc_sys_dev_boot ( ) ; //<S2SV> if ( checkcfg ( CFG_DISABLE_MNT ) ) //<S2SV> fs_mnt ( 1 ) ; //<S2SV> else if ( arg_disable_mnt ) //<S2SV> fs_mnt ( 0 ) ; //<S2SV> fs_whitelist ( ) ; //<S2SV> fs_blacklist ( ) ; //<S2SV> if ( arg_nosound ) { //<S2SV> pulseaudio_disable ( ) ; //<S2SV> fs_dev_disable_sound ( ) ; //<S2SV> } //<S2SV> else if ( ! arg_noautopulse ) //<S2SV> pulseaudio_init ( ) ; //<S2SV> if ( arg_no3d ) //<S2SV> fs_dev_disable_3d ( ) ; //<S2SV> if ( arg_notv ) //<S2SV> fs_dev_disable_tv ( ) ; //<S2SV> if ( arg_nodvd ) //<S2SV> fs_dev_disable_dvd ( ) ; //<S2SV> if ( arg_nou2f ) //<S2SV> fs_dev_disable_u2f ( ) ; //<S2SV> if ( arg_novideo ) //<S2SV> fs_dev_disable_video ( ) ; //<S2SV> if ( need_preload ) //<S2SV> fs_trace ( ) ; //<S2SV> fs_resolvconf ( ) ; //<S2SV> fs_logger_print ( ) ; //<S2SV> fs_logger_change_owner ( ) ; //<S2SV> EUID_USER ( ) ; //<S2SV> int cwd = 0 ; //<S2SV> if ( cfg . cwd ) { //<S2SV> if ( chdir ( cfg . cwd ) == 0 ) //<S2SV> cwd = 1 ; //<S2SV> } //<S2SV> if ( ! cwd ) { //<S2SV> if ( chdir ( "/" ) < 0 ) //<S2SV> errExit ( "chdir" ) ; //<S2SV> if ( cfg . homedir ) { //<S2SV> struct stat s ; //<S2SV> if ( stat ( cfg . homedir , & s ) == 0 ) { //<S2SV> if ( chdir ( cfg . homedir ) < 0 ) //<S2SV> errExit ( "chdir" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( arg_debug ) { //<S2SV> char * cpath = get_current_dir_name ( ) ; //<S2SV> if ( cpath ) { //<S2SV> printf ( "Current<S2SV_blank>directory:<S2SV_blank>%s\\n" , cpath ) ; //<S2SV> free ( cpath ) ; //<S2SV> } //<S2SV> } //<S2SV> EUID_ROOT ( ) ; //<S2SV> fs_x11 ( ) ; //<S2SV> if ( arg_x11_xorg ) //<S2SV> x11_xorg ( ) ; //<S2SV> save_umask ( ) ; //<S2SV> save_nonewprivs ( ) ; //<S2SV> save_cpu ( ) ; //<S2SV> save_cgroup ( ) ; //<S2SV> # ifdef HAVE_SECCOMP //<S2SV> # ifdef SYS_socket //<S2SV> if ( cfg . protocol ) { //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Install<S2SV_blank>protocol<S2SV_blank>filter:<S2SV_blank>%s\\n" , cfg . protocol ) ; //<S2SV> seccomp_load ( RUN_SECCOMP_PROTOCOL ) ; //<S2SV> protocol_filter_save ( ) ; //<S2SV> } //<S2SV> else { //<S2SV> int rv = unlink ( RUN_SECCOMP_PROTOCOL ) ; //<S2SV> ( void ) rv ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( arg_seccomp == 1 ) { //<S2SV> if ( cfg . seccomp_list_keep ) //<S2SV> seccomp_filter_keep ( ) ; //<S2SV> else //<S2SV> seccomp_filter_drop ( ) ; //<S2SV> } //<S2SV> else { //<S2SV> int rv = unlink ( RUN_SECCOMP_CFG ) ; //<S2SV> rv |= unlink ( RUN_SECCOMP_32 ) ; //<S2SV> ( void ) rv ; //<S2SV> } //<S2SV> if ( arg_memory_deny_write_execute ) { //<S2SV> if ( arg_debug ) //<S2SV> printf ( "Install<S2SV_blank>memory<S2SV_blank>write&execute<S2SV_blank>filter\\n" ) ; //<S2SV> seccomp_load ( RUN_SECCOMP_MDWX ) ; //<S2SV> } //<S2SV> else { //<S2SV> int rv = unlink ( RUN_SECCOMP_MDWX ) ; //<S2SV> ( void ) rv ; //<S2SV> } //<S2SV> fs_rdonly ( RUN_SECCOMP_DIR ) ; //<S2SV> # endif //<S2SV> set_caps ( ) ; //<S2SV> FILE * rj = create_ready_for_join_file ( ) ; //<S2SV> save_nogroups ( ) ; //<S2SV> if ( arg_noroot ) { //<S2SV> int rv = unshare ( CLONE_NEWUSER ) ; //<S2SV> if ( rv == - 1 ) { //<S2SV> fwarning ( "cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>user<S2SV_blank>namespace,<S2SV_blank>going<S2SV_blank>forward<S2SV_blank>without<S2SV_blank>it...\\n" ) ; //<S2SV> arg_noroot = 0 ; //<S2SV> } //<S2SV> } //<S2SV> notify_other ( child_to_parent_fds [ 1 ] ) ; //<S2SV> close ( child_to_parent_fds [ 1 ] ) ; //<S2SV> wait_for_other ( parent_to_child_fds [ 0 ] ) ; //<S2SV> close ( parent_to_child_fds [ 0 ] ) ; //<S2SV> if ( arg_noroot ) { //<S2SV> if ( arg_debug ) //<S2SV> printf ( "noroot<S2SV_blank>user<S2SV_blank>namespace<S2SV_blank>installed\\n" ) ; //<S2SV> set_caps ( ) ; //<S2SV> } //<S2SV> if ( arg_nonewprivs ) { //<S2SV> prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) ; //<S2SV> if ( prctl ( PR_GET_NO_NEW_PRIVS , 0 , 0 , 0 , 0 ) != 1 ) { //<S2SV> fwarning ( "cannot<S2SV_blank>set<S2SV_blank>NO_NEW_PRIVS,<S2SV_blank>it<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>3.5<S2SV_blank>or<S2SV_blank>newer.\\n" ) ; //<S2SV> if ( force_nonewprivs ) { //<S2SV> fprintf ( stderr , "Error:<S2SV_blank>NO_NEW_PRIVS<S2SV_blank>required<S2SV_blank>for<S2SV_blank>this<S2SV_blank>sandbox,<S2SV_blank>exiting<S2SV_blank>...\\n" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( arg_debug ) //<S2SV> printf ( "NO_NEW_PRIVS<S2SV_blank>set\\n" ) ; //<S2SV> } //<S2SV> drop_privs ( arg_nogroups ) ; //<S2SV> prctl ( PR_SET_PDEATHSIG , SIGKILL , 0 , 0 , 0 ) ; //<S2SV> if ( cfg . cpus ) //<S2SV> set_cpu_affinity ( ) ; //<S2SV> pid_t app_pid = fork ( ) ; //<S2SV> if ( app_pid == - 1 ) //<S2SV> errExit ( "fork" ) ; //<S2SV> if ( app_pid == 0 ) { //<S2SV> # ifdef HAVE_APPARMOR //<S2SV> if ( checkcfg ( CFG_APPARMOR ) && arg_apparmor ) { //<S2SV> errno = 0 ; //<S2SV> if ( aa_change_onexec ( "firejail-default" ) ) { //<S2SV> fwarning ( "Cannot<S2SV_blank>confine<S2SV_blank>the<S2SV_blank>application<S2SV_blank>using<S2SV_blank>AppArmor.\\n" //<S2SV> "Maybe<S2SV_blank>firejail-default<S2SV_blank>AppArmor<S2SV_blank>profile<S2SV_blank>is<S2SV_blank>not<S2SV_blank>loaded<S2SV_blank>into<S2SV_blank>the<S2SV_blank>kernel.\\n" //<S2SV> "As<S2SV_blank>root,<S2SV_blank>run<S2SV_blank>\\"aa-enforce<S2SV_blank>firejail-default\\"<S2SV_blank>to<S2SV_blank>load<S2SV_blank>it.\\n" ) ; //<S2SV> } //<S2SV> else if ( arg_debug ) //<S2SV> printf ( "AppArmor<S2SV_blank>enabled\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( arg_nice ) //<S2SV> set_nice ( cfg . nice ) ; //<S2SV> set_rlimits ( ) ; //<S2SV> start_application ( 0 , rj ) ; //<S2SV> } //<S2SV> fclose ( rj ) ; //<S2SV> int status = monitor_application ( app_pid ) ; //<S2SV> flush_stdin ( ) ; //<S2SV> if ( WIFEXITED ( status ) ) { //<S2SV> return WEXITSTATUS ( status ) ; //<S2SV> } else { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> 