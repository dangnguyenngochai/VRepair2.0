static int asn1_decode_entry ( sc_context_t * ctx , struct sc_asn1_entry * entry , //<S2SV> const u8 * obj , size_t objlen , int depth ) //<S2SV> { //<S2SV> void * parm = entry -> parm ; //<S2SV> int ( * callback_func ) ( sc_context_t * nctx , void * arg , const u8 * nobj , //<S2SV> size_t nobjlen , int ndepth ) ; //<S2SV> size_t * len = ( size_t * ) entry -> arg ; //<S2SV> int r = 0 ; //<S2SV> callback_func = parm ; //<S2SV> sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "%*.*sdecoding<S2SV_blank>\'%s\',<S2SV_blank>raw<S2SV_blank>data:%s%s\\n" , //<S2SV> depth , depth , "" , entry -> name , //<S2SV> sc_dump_hex ( obj , objlen > 16 ? 16 : objlen ) , //<S2SV> objlen > 16 ? "..." : "" ) ; //<S2SV> switch ( entry -> type ) { //<S2SV> case SC_ASN1_STRUCT : //<S2SV> if ( parm != NULL ) //<S2SV> r = asn1_decode ( ctx , ( struct sc_asn1_entry * ) parm , obj , //<S2SV> objlen , NULL , NULL , 0 , depth + 1 ) ; //<S2SV> break ; //<S2SV> case SC_ASN1_NULL : //<S2SV> break ; //<S2SV> case SC_ASN1_BOOLEAN : //<S2SV> if ( parm != NULL ) { //<S2SV> if ( objlen != 1 ) { //<S2SV> sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , //<S2SV> "invalid<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>length:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u\\n" , //<S2SV> objlen ) ; //<S2SV> r = SC_ERROR_INVALID_ASN1_OBJECT ; //<S2SV> } else //<S2SV> * ( ( int * ) parm ) = obj [ 0 ] ? 1 : 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> case SC_ASN1_INTEGER : //<S2SV> case SC_ASN1_ENUMERATED : //<S2SV> if ( parm != NULL ) { //<S2SV> r = sc_asn1_decode_integer ( obj , objlen , ( int * ) entry -> parm ) ; //<S2SV> sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "%*.*sdecoding<S2SV_blank>\'%s\'<S2SV_blank>returned<S2SV_blank>%d\\n" , depth , depth , "" , //<S2SV> entry -> name , * ( ( int * ) entry -> parm ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case SC_ASN1_BIT_STRING_NI : //<S2SV> case SC_ASN1_BIT_STRING : //<S2SV> if ( parm != NULL ) { //<S2SV> int invert = entry -> type == SC_ASN1_BIT_STRING ? 1 : 0 ; //<S2SV> assert ( len != NULL ) ; //<S2SV> if ( objlen < 1 ) { //<S2SV> r = SC_ERROR_INVALID_ASN1_OBJECT ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( entry -> flags & SC_ASN1_ALLOC ) { //<S2SV> u8 * * buf = ( u8 * * ) parm ; //<S2SV> * buf = malloc ( objlen - 1 ) ; //<S2SV> if ( * buf == NULL ) { //<S2SV> r = SC_ERROR_OUT_OF_MEMORY ; //<S2SV> break ; //<S2SV> } //<S2SV> * len = objlen - 1 ; //<S2SV> parm = * buf ; //<S2SV> } //<S2SV> r = decode_bit_string ( obj , objlen , ( u8 * ) parm , * len , invert ) ; //<S2SV> if ( r >= 0 ) { //<S2SV> * len = r ; //<S2SV> r = 0 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case SC_ASN1_BIT_FIELD : //<S2SV> if ( parm != NULL ) //<S2SV> r = decode_bit_field ( obj , objlen , ( u8 * ) parm , * len ) ; //<S2SV> break ; //<S2SV> case SC_ASN1_OCTET_STRING : //<S2SV> if ( parm != NULL ) { //<S2SV> size_t c ; //<S2SV> assert ( len != NULL ) ; //<S2SV> if ( ( entry -> flags & SC_ASN1_UNSIGNED ) //<S2SV> && objlen > 1 && obj [ 0 ] == 0x00 ) { //<S2SV> objlen -- ; //<S2SV> obj ++ ; //<S2SV> } //<S2SV> if ( entry -> flags & SC_ASN1_ALLOC ) { //<S2SV> u8 * * buf = ( u8 * * ) parm ; //<S2SV> * buf = malloc ( objlen ) ; //<S2SV> if ( * buf == NULL ) { //<S2SV> r = SC_ERROR_OUT_OF_MEMORY ; //<S2SV> break ; //<S2SV> } //<S2SV> c = * len = objlen ; //<S2SV> parm = * buf ; //<S2SV> } else //<S2SV> c = objlen > * len ? * len : objlen ; //<S2SV> memcpy ( parm , obj , c ) ; //<S2SV> * len = c ; //<S2SV> } //<S2SV> break ; //<S2SV> case SC_ASN1_GENERALIZEDTIME : //<S2SV> if ( parm != NULL ) { //<S2SV> size_t c ; //<S2SV> assert ( len != NULL ) ; //<S2SV> if ( entry -> flags & SC_ASN1_ALLOC ) { //<S2SV> u8 * * buf = ( u8 * * ) parm ; //<S2SV> * buf = malloc ( objlen ) ; //<S2SV> if ( * buf == NULL ) { //<S2SV> r = SC_ERROR_OUT_OF_MEMORY ; //<S2SV> break ; //<S2SV> } //<S2SV> c = * len = objlen ; //<S2SV> parm = * buf ; //<S2SV> } else //<S2SV> c = objlen > * len ? * len : objlen ; //<S2SV> memcpy ( parm , obj , c ) ; //<S2SV> * len = c ; //<S2SV> } //<S2SV> break ; //<S2SV> case SC_ASN1_OBJECT : //<S2SV> if ( parm != NULL ) //<S2SV> r = sc_asn1_decode_object_id ( obj , objlen , ( struct sc_object_id * ) parm ) ; //<S2SV> break ; //<S2SV> case SC_ASN1_PRINTABLESTRING : //<S2SV> case SC_ASN1_UTF8STRING : //<S2SV> if ( parm != NULL ) { //<S2SV> assert ( len != NULL ) ; //<S2SV> if ( entry -> flags & SC_ASN1_ALLOC ) { //<S2SV> u8 * * buf = ( u8 * * ) parm ; //<S2SV> * buf = malloc ( objlen + 1 ) ; //<S2SV> if ( * buf == NULL ) { //<S2SV> r = SC_ERROR_OUT_OF_MEMORY ; //<S2SV> break ; //<S2SV> } //<S2SV> * len = objlen + 1 ; //<S2SV> parm = * buf ; //<S2SV> } //<S2SV> r = sc_asn1_decode_utf8string ( obj , objlen , ( u8 * ) parm , len ) ; //<S2SV> if ( entry -> flags & SC_ASN1_ALLOC ) { //<S2SV> * len -= 1 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case SC_ASN1_PATH : //<S2SV> if ( entry -> parm != NULL ) //<S2SV> r = asn1_decode_path ( ctx , obj , objlen , ( sc_path_t * ) parm , depth ) ; //<S2SV> break ; //<S2SV> case SC_ASN1_PKCS15_ID : //<S2SV> if ( entry -> parm != NULL ) { //<S2SV> struct sc_pkcs15_id * id = ( struct sc_pkcs15_id * ) parm ; //<S2SV> size_t c = objlen > sizeof ( id -> value ) ? sizeof ( id -> value ) : objlen ; //<S2SV> memcpy ( id -> value , obj , c ) ; //<S2SV> id -> len = c ; //<S2SV> } //<S2SV> break ; //<S2SV> case SC_ASN1_PKCS15_OBJECT : //<S2SV> if ( entry -> parm != NULL ) //<S2SV> r = asn1_decode_p15_object ( ctx , obj , objlen , ( struct sc_asn1_pkcs15_object * ) parm , depth ) ; //<S2SV> break ; //<S2SV> case SC_ASN1_ALGORITHM_ID : //<S2SV> if ( entry -> parm != NULL ) //<S2SV> r = sc_asn1_decode_algorithm_id ( ctx , obj , objlen , ( struct sc_algorithm_id * ) parm , depth ) ; //<S2SV> break ; //<S2SV> case SC_ASN1_SE_INFO : //<S2SV> if ( entry -> parm != NULL ) //<S2SV> r = asn1_decode_se_info ( ctx , obj , objlen , ( sc_pkcs15_sec_env_info_t * * * ) entry -> parm , len , depth ) ; //<S2SV> break ; //<S2SV> case SC_ASN1_CALLBACK : //<S2SV> if ( entry -> parm != NULL ) //<S2SV> r = callback_func ( ctx , entry -> arg , obj , objlen , depth ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "invalid<S2SV_blank>ASN.1<S2SV_blank>type:<S2SV_blank>%d\\n" , entry -> type ) ; //<S2SV> return SC_ERROR_INVALID_ASN1_OBJECT ; //<S2SV> } //<S2SV> if ( r ) { //<S2SV> sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , "decoding<S2SV_blank>of<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>\'%s\'<S2SV_blank>failed:<S2SV_blank>%s\\n" , entry -> name , //<S2SV> sc_strerror ( r ) ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> entry -> flags |= SC_ASN1_PRESENT ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 