static int tcos_select_file ( sc_card_t * card , //<S2SV> const sc_path_t * in_path , //<S2SV> sc_file_t * * file_out ) //<S2SV> { //<S2SV> sc_context_t * ctx ; //<S2SV> sc_apdu_t apdu ; //<S2SV> sc_file_t * file = NULL ; //<S2SV> u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; //<S2SV> unsigned int i ; //<S2SV> int r , pathlen ; //<S2SV> assert ( card != NULL && in_path != NULL ) ; //<S2SV> ctx = card -> ctx ; //<S2SV> memcpy ( path , in_path -> value , in_path -> len ) ; //<S2SV> pathlen = in_path -> len ; //<S2SV> sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; //<S2SV> switch ( in_path -> type ) { //<S2SV> case SC_PATH_TYPE_FILE_ID : //<S2SV> if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; //<S2SV> case SC_PATH_TYPE_FROM_CURRENT : //<S2SV> apdu . p1 = 9 ; //<S2SV> break ; //<S2SV> case SC_PATH_TYPE_DF_NAME : //<S2SV> apdu . p1 = 4 ; //<S2SV> break ; //<S2SV> case SC_PATH_TYPE_PATH : //<S2SV> apdu . p1 = 8 ; //<S2SV> if ( pathlen >= 2 && memcmp ( path , "\\x3F\\x00" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; //<S2SV> if ( pathlen == 0 ) apdu . p1 = 0 ; //<S2SV> break ; //<S2SV> case SC_PATH_TYPE_PARENT : //<S2SV> apdu . p1 = 3 ; //<S2SV> pathlen = 0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; //<S2SV> } //<S2SV> if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; //<S2SV> apdu . lc = pathlen ; //<S2SV> apdu . data = path ; //<S2SV> apdu . datalen = pathlen ; //<S2SV> if ( file_out != NULL ) { //<S2SV> apdu . resp = buf ; //<S2SV> apdu . resplen = sizeof ( buf ) ; //<S2SV> apdu . le = 256 ; //<S2SV> } else { //<S2SV> apdu . resplen = 0 ; //<S2SV> apdu . le = 0 ; //<S2SV> apdu . p2 = 0x0C ; //<S2SV> apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; //<S2SV> } //<S2SV> r = sc_transmit_apdu ( card , & apdu ) ; //<S2SV> SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , "APDU<S2SV_blank>transmit<S2SV_blank>failed" ) ; //<S2SV> r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; //<S2SV> if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; //<S2SV> if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { //<S2SV> sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\n" , apdu . resp [ 0 ] ) ; //<S2SV> SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; //<S2SV> } //<S2SV> file = sc_file_new ( ) ; //<S2SV> if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; //<S2SV> * file_out = file ; //<S2SV> file -> path = * in_path ; //<S2SV> for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { //<S2SV> int j , len = apdu . resp [ i + 1 ] ; //<S2SV> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; //<S2SV> switch ( type ) { //<S2SV> case 0x80 : //<S2SV> case 0x81 : //<S2SV> file -> size = 0 ; //<S2SV> for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; //<S2SV> break ; //<S2SV> case 0x82 : //<S2SV> file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; //<S2SV> file -> ef_structure = d [ 0 ] & 7 ; //<S2SV> switch ( ( d [ 0 ] >> 3 ) & 7 ) { //<S2SV> case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; //<S2SV> case 7 : file -> type = SC_FILE_TYPE_DF ; break ; //<S2SV> default : //<S2SV> sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\n" , d [ 0 ] ) ; //<S2SV> SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0x83 : //<S2SV> file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; //<S2SV> break ; //<S2SV> case 0x84 : //<S2SV> memcpy ( file -> name , d , len ) ; //<S2SV> file -> namelen = len ; //<S2SV> break ; //<S2SV> case 0x86 : //<S2SV> sc_file_set_sec_attr ( file , d , len ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; //<S2SV> } //<S2SV> } //<S2SV> file -> magic = SC_FILE_MAGIC ; //<S2SV> parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 