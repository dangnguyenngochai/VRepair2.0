static int gemsafe_get_cert_len ( sc_card_t * card ) //<S2SV> { //<S2SV> int r ; //<S2SV> u8 ibuf [ GEMSAFE_MAX_OBJLEN ] ; //<S2SV> u8 * iptr ; //<S2SV> struct sc_path path ; //<S2SV> struct sc_file * file ; //<S2SV> size_t objlen , certlen ; //<S2SV> unsigned int ind , i = 0 ; //<S2SV> sc_format_path ( GEMSAFE_PATH , & path ) ; //<S2SV> r = sc_select_file ( card , & path , & file ) ; //<S2SV> if ( r != SC_SUCCESS || ! file ) //<S2SV> return SC_ERROR_INTERNAL ; //<S2SV> r = sc_read_binary ( card , 0 , ibuf , GEMSAFE_READ_QUANTUM , 0 ) ; //<S2SV> if ( r < 0 ) //<S2SV> return SC_ERROR_INTERNAL ; //<S2SV> objlen = ( ( ( size_t ) ibuf [ 0 ] ) << 8 ) | ibuf [ 1 ] ; //<S2SV> sc_log ( card -> ctx , "Stored<S2SV_blank>object<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , //<S2SV> objlen ) ; //<S2SV> if ( objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN ) { //<S2SV> sc_log ( card -> ctx , "Invalid<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , //<S2SV> objlen ) ; //<S2SV> return SC_ERROR_INTERNAL ; //<S2SV> } //<S2SV> ind = 2 ; //<S2SV> while ( ibuf [ ind ] == 0x01 ) { //<S2SV> if ( ibuf [ ind + 1 ] == 0xFE ) { //<S2SV> gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; //<S2SV> sc_log ( card -> ctx , "Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>allocated<S2SV_blank>and<S2SV_blank>uses<S2SV_blank>key_ref<S2SV_blank>%d" , //<S2SV> i + 1 , gemsafe_prkeys [ i ] . ref ) ; //<S2SV> ind += 9 ; //<S2SV> } //<S2SV> else { //<S2SV> gemsafe_prkeys [ i ] . label = NULL ; //<S2SV> gemsafe_cert [ i ] . label = NULL ; //<S2SV> sc_log ( card -> ctx , "Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unallocated" , i + 1 ) ; //<S2SV> ind += 8 ; //<S2SV> } //<S2SV> i ++ ; //<S2SV> } //<S2SV> for ( ; i < gemsafe_cert_max ; i ++ ) { //<S2SV> gemsafe_prkeys [ i ] . label = NULL ; //<S2SV> gemsafe_cert [ i ] . label = NULL ; //<S2SV> } //<S2SV> iptr = ibuf + GEMSAFE_READ_QUANTUM ; //<S2SV> while ( ( size_t ) ( iptr - ibuf ) < objlen ) { //<S2SV> r = sc_read_binary ( card , iptr - ibuf , iptr , //<S2SV> MIN ( GEMSAFE_READ_QUANTUM , objlen - ( iptr - ibuf ) ) , 0 ) ; //<S2SV> if ( r < 0 ) { //<S2SV> sc_log ( card -> ctx , "Could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>cert<S2SV_blank>object" ) ; //<S2SV> return SC_ERROR_INTERNAL ; //<S2SV> } //<S2SV> iptr += GEMSAFE_READ_QUANTUM ; //<S2SV> } //<S2SV> i = 0 ; //<S2SV> while ( ind < objlen - 1 ) { //<S2SV> if ( ibuf [ ind ] == 0x30 && ibuf [ ind + 1 ] == 0x82 ) { //<S2SV> while ( i < gemsafe_cert_max && gemsafe_cert [ i ] . label == NULL ) //<S2SV> i ++ ; //<S2SV> if ( i == gemsafe_cert_max ) { //<S2SV> sc_log ( card -> ctx , "Warning:<S2SV_blank>Found<S2SV_blank>orphaned<S2SV_blank>certificate<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d" , ind ) ; //<S2SV> return SC_SUCCESS ; //<S2SV> } //<S2SV> if ( ind + 3 >= sizeof ibuf ) //<S2SV> return SC_ERROR_INVALID_DATA ; //<S2SV> certlen = ( ( ( ( size_t ) ibuf [ ind + 2 ] ) << 8 ) | ibuf [ ind + 3 ] ) + 4 ; //<S2SV> sc_log ( card -> ctx , //<S2SV> "Found<S2SV_blank>certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%" SC_FORMAT_LEN_SIZE_T "u" , //<S2SV> i + 1 , ind , certlen ) ; //<S2SV> gemsafe_cert [ i ] . index = ind ; //<S2SV> gemsafe_cert [ i ] . count = certlen ; //<S2SV> ind += certlen ; //<S2SV> i ++ ; //<S2SV> } else //<S2SV> ind ++ ; //<S2SV> } //<S2SV> for ( ; i < gemsafe_cert_max ; i ++ ) { //<S2SV> if ( gemsafe_cert [ i ] . label ) { //<S2SV> sc_log ( card -> ctx , "Warning:<S2SV_blank>Certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>missing" , i + 1 ) ; //<S2SV> gemsafe_prkeys [ i ] . label = NULL ; //<S2SV> gemsafe_cert [ i ] . label = NULL ; //<S2SV> } //<S2SV> } //<S2SV> return SC_SUCCESS ; //<S2SV> } //<S2SV> 