SYSCALL_DEFINE6 ( sendto , int , fd , void __user * , buff , size_t , len , //<S2SV> unsigned int , flags , struct sockaddr __user * , addr , //<S2SV> int , addr_len ) //<S2SV> { //<S2SV> struct socket * sock ; //<S2SV> struct sockaddr_storage address ; //<S2SV> int err ; //<S2SV> struct msghdr msg ; //<S2SV> struct iovec iov ; //<S2SV> int fput_needed ; //<S2SV> if ( len > INT_MAX ) //<S2SV> len = INT_MAX ; //<S2SV> if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) //<S2SV> return - EFAULT ; //<S2SV> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; //<S2SV> if ( ! sock ) //<S2SV> goto out ; //<S2SV> iov . iov_base = buff ; //<S2SV> iov . iov_len = len ; //<S2SV> msg . msg_name = NULL ; //<S2SV> iov_iter_init ( & msg . msg_iter , WRITE , & iov , 1 , len ) ; //<S2SV> msg . msg_control = NULL ; //<S2SV> msg . msg_controllen = 0 ; //<S2SV> msg . msg_namelen = 0 ; //<S2SV> if ( addr ) { //<S2SV> err = move_addr_to_kernel ( addr , addr_len , & address ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out_put ; //<S2SV> msg . msg_name = ( struct sockaddr * ) & address ; //<S2SV> msg . msg_namelen = addr_len ; //<S2SV> } //<S2SV> if ( sock -> file -> f_flags & O_NONBLOCK ) //<S2SV> flags |= MSG_DONTWAIT ; //<S2SV> msg . msg_flags = flags ; //<S2SV> err = sock_sendmsg ( sock , & msg , len ) ; //<S2SV> out_put : //<S2SV> fput_light ( sock -> file , fput_needed ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 