SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , //<S2SV> unsigned int , flags , struct sockaddr __user * , addr , //<S2SV> int __user * , addr_len ) //<S2SV> { //<S2SV> struct socket * sock ; //<S2SV> struct iovec iov ; //<S2SV> struct msghdr msg ; //<S2SV> struct sockaddr_storage address ; //<S2SV> int err , err2 ; //<S2SV> int fput_needed ; //<S2SV> if ( size > INT_MAX ) //<S2SV> size = INT_MAX ; //<S2SV> if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) //<S2SV> return - EFAULT ; //<S2SV> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; //<S2SV> if ( ! sock ) //<S2SV> goto out ; //<S2SV> msg . msg_control = NULL ; //<S2SV> msg . msg_controllen = 0 ; //<S2SV> iov . iov_len = size ; //<S2SV> iov . iov_base = ubuf ; //<S2SV> iov_iter_init ( & msg . msg_iter , READ , & iov , 1 , size ) ; //<S2SV> msg . msg_name = addr ? ( struct sockaddr * ) & address : NULL ; //<S2SV> msg . msg_namelen = 0 ; //<S2SV> if ( sock -> file -> f_flags & O_NONBLOCK ) //<S2SV> flags |= MSG_DONTWAIT ; //<S2SV> err = sock_recvmsg ( sock , & msg , size , flags ) ; //<S2SV> if ( err >= 0 && addr != NULL ) { //<S2SV> err2 = move_addr_to_user ( & address , //<S2SV> msg . msg_namelen , addr , addr_len ) ; //<S2SV> if ( err2 < 0 ) //<S2SV> err = err2 ; //<S2SV> } //<S2SV> fput_light ( sock -> file , fput_needed ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 