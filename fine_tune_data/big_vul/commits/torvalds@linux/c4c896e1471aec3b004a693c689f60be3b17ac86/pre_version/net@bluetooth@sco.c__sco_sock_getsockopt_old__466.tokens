static int sco_sock_getsockopt_old ( struct socket * sock , int optname , char __user * optval , int __user * optlen ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct sco_options opts ; //<S2SV> struct sco_conninfo cinfo ; //<S2SV> int len , err = 0 ; //<S2SV> BT_DBG ( "sk<S2SV_blank>%p" , sk ) ; //<S2SV> if ( get_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> lock_sock ( sk ) ; //<S2SV> switch ( optname ) { //<S2SV> case SCO_OPTIONS : //<S2SV> if ( sk -> sk_state != BT_CONNECTED ) { //<S2SV> err = - ENOTCONN ; //<S2SV> break ; //<S2SV> } //<S2SV> opts . mtu = sco_pi ( sk ) -> conn -> mtu ; //<S2SV> BT_DBG ( "mtu<S2SV_blank>%d" , opts . mtu ) ; //<S2SV> len = min_t ( unsigned int , len , sizeof ( opts ) ) ; //<S2SV> if ( copy_to_user ( optval , ( char * ) & opts , len ) ) //<S2SV> err = - EFAULT ; //<S2SV> break ; //<S2SV> case SCO_CONNINFO : //<S2SV> if ( sk -> sk_state != BT_CONNECTED ) { //<S2SV> err = - ENOTCONN ; //<S2SV> break ; //<S2SV> } //<S2SV> cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ; //<S2SV> memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ; //<S2SV> len = min_t ( unsigned int , len , sizeof ( cinfo ) ) ; //<S2SV> if ( copy_to_user ( optval , ( char * ) & cinfo , len ) ) //<S2SV> err = - EFAULT ; //<S2SV> break ; //<S2SV> default : //<S2SV> err = - ENOPROTOOPT ; //<S2SV> break ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 