static int recv_msg ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * m , size_t buf_len , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct tipc_port * tport = tipc_sk_port ( sk ) ; //<S2SV> struct sk_buff * buf ; //<S2SV> struct tipc_msg * msg ; //<S2SV> long timeout ; //<S2SV> unsigned int sz ; //<S2SV> u32 err ; //<S2SV> int res ; //<S2SV> if ( unlikely ( ! buf_len ) ) //<S2SV> return - EINVAL ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { //<S2SV> res = - ENOTCONN ; //<S2SV> goto exit ; //<S2SV> } //<S2SV> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; //<S2SV> restart : //<S2SV> while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { //<S2SV> if ( sock -> state == SS_DISCONNECTING ) { //<S2SV> res = - ENOTCONN ; //<S2SV> goto exit ; //<S2SV> } //<S2SV> if ( timeout <= 0L ) { //<S2SV> res = timeout ? timeout : - EWOULDBLOCK ; //<S2SV> goto exit ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , //<S2SV> tipc_rx_ready ( sock ) , //<S2SV> timeout ) ; //<S2SV> lock_sock ( sk ) ; //<S2SV> } //<S2SV> buf = skb_peek ( & sk -> sk_receive_queue ) ; //<S2SV> msg = buf_msg ( buf ) ; //<S2SV> sz = msg_data_sz ( msg ) ; //<S2SV> err = msg_errcode ( msg ) ; //<S2SV> if ( ( ! sz ) && ( ! err ) ) { //<S2SV> advance_rx_queue ( sk ) ; //<S2SV> goto restart ; //<S2SV> } //<S2SV> set_orig_addr ( m , msg ) ; //<S2SV> res = anc_data_recv ( m , msg , tport ) ; //<S2SV> if ( res ) //<S2SV> goto exit ; //<S2SV> if ( ! err ) { //<S2SV> if ( unlikely ( buf_len < sz ) ) { //<S2SV> sz = buf_len ; //<S2SV> m -> msg_flags |= MSG_TRUNC ; //<S2SV> } //<S2SV> res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , //<S2SV> m -> msg_iov , sz ) ; //<S2SV> if ( res ) //<S2SV> goto exit ; //<S2SV> res = sz ; //<S2SV> } else { //<S2SV> if ( ( sock -> state == SS_READY ) || //<S2SV> ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) //<S2SV> res = 0 ; //<S2SV> else //<S2SV> res = - ECONNRESET ; //<S2SV> } //<S2SV> if ( likely ( ! ( flags & MSG_PEEK ) ) ) { //<S2SV> if ( ( sock -> state != SS_READY ) && //<S2SV> ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) //<S2SV> tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; //<S2SV> advance_rx_queue ( sk ) ; //<S2SV> } //<S2SV> exit : //<S2SV> release_sock ( sk ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> 