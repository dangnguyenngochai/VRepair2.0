static int rfcomm_get_dev_list ( void __user * arg ) //<S2SV> { //<S2SV> struct rfcomm_dev * dev ; //<S2SV> struct rfcomm_dev_list_req * dl ; //<S2SV> struct rfcomm_dev_info * di ; //<S2SV> int n = 0 , size , err ; //<S2SV> u16 dev_num ; //<S2SV> BT_DBG ( "" ) ; //<S2SV> if ( get_user ( dev_num , ( u16 __user * ) arg ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) //<S2SV> return - EINVAL ; //<S2SV> size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; //<S2SV> dl = kmalloc ( size , GFP_KERNEL ) ; //<S2SV> if ( ! dl ) //<S2SV> return - ENOMEM ; //<S2SV> di = dl -> dev_info ; //<S2SV> spin_lock ( & rfcomm_dev_lock ) ; //<S2SV> list_for_each_entry ( dev , & rfcomm_dev_list , list ) { //<S2SV> if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) //<S2SV> continue ; //<S2SV> ( di + n ) -> id = dev -> id ; //<S2SV> ( di + n ) -> flags = dev -> flags ; //<S2SV> ( di + n ) -> state = dev -> dlc -> state ; //<S2SV> ( di + n ) -> channel = dev -> channel ; //<S2SV> bacpy ( & ( di + n ) -> src , & dev -> src ) ; //<S2SV> bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; //<S2SV> if ( ++ n >= dev_num ) //<S2SV> break ; //<S2SV> } //<S2SV> spin_unlock ( & rfcomm_dev_lock ) ; //<S2SV> dl -> dev_num = n ; //<S2SV> size = sizeof ( * dl ) + n * sizeof ( * di ) ; //<S2SV> err = copy_to_user ( arg , dl , size ) ; //<S2SV> kfree ( dl ) ; //<S2SV> return err ? - EFAULT : 0 ; //<S2SV> } //<S2SV> 