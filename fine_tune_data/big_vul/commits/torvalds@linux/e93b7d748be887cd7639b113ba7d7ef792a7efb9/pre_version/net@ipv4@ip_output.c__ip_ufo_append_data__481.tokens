static inline int ip_ufo_append_data ( struct sock * sk , //<S2SV> struct sk_buff_head * queue , //<S2SV> int getfrag ( void * from , char * to , int offset , int len , //<S2SV> int odd , struct sk_buff * skb ) , //<S2SV> void * from , int length , int hh_len , int fragheaderlen , //<S2SV> int transhdrlen , int maxfraglen , unsigned int flags ) //<S2SV> { //<S2SV> struct sk_buff * skb ; //<S2SV> int err ; //<S2SV> if ( ( skb = skb_peek_tail ( queue ) ) == NULL ) { //<S2SV> skb = sock_alloc_send_skb ( sk , //<S2SV> hh_len + fragheaderlen + transhdrlen + 20 , //<S2SV> ( flags & MSG_DONTWAIT ) , & err ) ; //<S2SV> if ( skb == NULL ) //<S2SV> return err ; //<S2SV> skb_reserve ( skb , hh_len ) ; //<S2SV> skb_put ( skb , fragheaderlen + transhdrlen ) ; //<S2SV> skb_reset_network_header ( skb ) ; //<S2SV> skb -> transport_header = skb -> network_header + fragheaderlen ; //<S2SV> skb -> ip_summed = CHECKSUM_PARTIAL ; //<S2SV> skb -> csum = 0 ; //<S2SV> skb_shinfo ( skb ) -> gso_size = maxfraglen - fragheaderlen ; //<S2SV> skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; //<S2SV> __skb_queue_tail ( queue , skb ) ; //<S2SV> } //<S2SV> return skb_append_datato_frags ( sk , skb , getfrag , from , //<S2SV> ( length - transhdrlen ) ) ; //<S2SV> } //<S2SV> 