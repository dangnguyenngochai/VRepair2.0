static int xen_netbk_tx_check_gop ( struct xen_netbk * netbk , //<S2SV> struct sk_buff * skb , //<S2SV> struct gnttab_copy * * gopp ) //<S2SV> { //<S2SV> struct gnttab_copy * gop = * gopp ; //<S2SV> u16 pending_idx = * ( ( u16 * ) skb -> data ) ; //<S2SV> struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; //<S2SV> int nr_frags = shinfo -> nr_frags ; //<S2SV> int i , err , start ; //<S2SV> err = gop -> status ; //<S2SV> if ( unlikely ( err ) ) //<S2SV> xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ; //<S2SV> start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; //<S2SV> for ( i = start ; i < nr_frags ; i ++ ) { //<S2SV> int j , newerr ; //<S2SV> pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ; //<S2SV> newerr = ( ++ gop ) -> status ; //<S2SV> if ( likely ( ! newerr ) ) { //<S2SV> if ( unlikely ( err ) ) //<S2SV> xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_ERROR ) ; //<S2SV> if ( err ) //<S2SV> continue ; //<S2SV> pending_idx = * ( ( u16 * ) skb -> data ) ; //<S2SV> xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ; //<S2SV> for ( j = start ; j < i ; j ++ ) { //<S2SV> pending_idx = frag_get_pending_idx ( & shinfo -> frags [ j ] ) ; //<S2SV> xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ; //<S2SV> } //<S2SV> err = newerr ; //<S2SV> } //<S2SV> * gopp = gop + 1 ; //<S2SV> return err ; //<S2SV> } //<S2SV> 