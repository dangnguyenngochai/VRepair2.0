int rds_sendmsg ( struct socket * sock , struct msghdr * msg , size_t payload_len ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct rds_sock * rs = rds_sk_to_rs ( sk ) ; //<S2SV> DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; //<S2SV> __be32 daddr ; //<S2SV> __be16 dport ; //<S2SV> struct rds_message * rm = NULL ; //<S2SV> struct rds_connection * conn ; //<S2SV> int ret = 0 ; //<S2SV> int queued = 0 , allocated_mr = 0 ; //<S2SV> int nonblock = msg -> msg_flags & MSG_DONTWAIT ; //<S2SV> long timeo = sock_sndtimeo ( sk , nonblock ) ; //<S2SV> if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) ) { //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( msg -> msg_namelen ) { //<S2SV> if ( msg -> msg_namelen < sizeof ( * usin ) || usin -> sin_family != AF_INET ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> daddr = usin -> sin_addr . s_addr ; //<S2SV> dport = usin -> sin_port ; //<S2SV> } else { //<S2SV> lock_sock ( sk ) ; //<S2SV> daddr = rs -> rs_conn_addr ; //<S2SV> dport = rs -> rs_conn_port ; //<S2SV> release_sock ( sk ) ; //<S2SV> } //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { //<S2SV> release_sock ( sk ) ; //<S2SV> ret = - ENOTCONN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> if ( payload_len > rds_sk_sndbuf ( rs ) ) { //<S2SV> ret = - EMSGSIZE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = rds_rm_size ( msg , payload_len ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto out ; //<S2SV> rm = rds_message_alloc ( ret , GFP_KERNEL ) ; //<S2SV> if ( ! rm ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( payload_len ) { //<S2SV> rm -> data . op_sg = rds_message_alloc_sgs ( rm , ceil ( payload_len , PAGE_SIZE ) ) ; //<S2SV> if ( ! rm -> data . op_sg ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = rds_message_copy_from_user ( rm , & msg -> msg_iter ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> rm -> data . op_active = 1 ; //<S2SV> rm -> m_daddr = daddr ; //<S2SV> if ( rs -> rs_conn && rs -> rs_conn -> c_faddr == daddr ) //<S2SV> conn = rs -> rs_conn ; //<S2SV> else { //<S2SV> conn = rds_conn_create_outgoing ( sock_net ( sock -> sk ) , //<S2SV> rs -> rs_bound_addr , daddr , //<S2SV> rs -> rs_transport , //<S2SV> sock -> sk -> sk_allocation ) ; //<S2SV> if ( IS_ERR ( conn ) ) { //<S2SV> ret = PTR_ERR ( conn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rs -> rs_conn = conn ; //<S2SV> } //<S2SV> ret = rds_cmsg_send ( rs , rm , msg , & allocated_mr ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> if ( rm -> rdma . op_active && ! conn -> c_trans -> xmit_rdma ) { //<S2SV> printk_ratelimited ( KERN_NOTICE "rdma_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_rdma<S2SV_blank>%p\\n" , //<S2SV> & rm -> rdma , conn -> c_trans -> xmit_rdma ) ; //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( rm -> atomic . op_active && ! conn -> c_trans -> xmit_atomic ) { //<S2SV> printk_ratelimited ( KERN_NOTICE "atomic_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_atomic<S2SV_blank>%p\\n" , //<S2SV> & rm -> atomic , conn -> c_trans -> xmit_atomic ) ; //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rds_conn_connect_if_down ( conn ) ; //<S2SV> ret = rds_cong_wait ( conn -> c_fcong , dport , nonblock , rs ) ; //<S2SV> if ( ret ) { //<S2SV> rs -> rs_seen_congestion = 1 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> while ( ! rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , //<S2SV> dport , & queued ) ) { //<S2SV> rds_stats_inc ( s_send_queue_full ) ; //<S2SV> if ( nonblock ) { //<S2SV> ret = - EAGAIN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , //<S2SV> rds_send_queue_rm ( rs , conn , rm , //<S2SV> rs -> rs_bound_port , //<S2SV> dport , //<S2SV> & queued ) , //<S2SV> timeo ) ; //<S2SV> rdsdebug ( "sendmsg<S2SV_blank>woke<S2SV_blank>queued<S2SV_blank>%d<S2SV_blank>timeo<S2SV_blank>%ld\\n" , queued , timeo ) ; //<S2SV> if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) //<S2SV> continue ; //<S2SV> ret = timeo ; //<S2SV> if ( ret == 0 ) //<S2SV> ret = - ETIMEDOUT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rds_stats_inc ( s_send_queued ) ; //<S2SV> ret = rds_send_xmit ( conn ) ; //<S2SV> if ( ret == - ENOMEM || ret == - EAGAIN ) //<S2SV> queue_delayed_work ( rds_wq , & conn -> c_send_w , 1 ) ; //<S2SV> rds_message_put ( rm ) ; //<S2SV> return payload_len ; //<S2SV> out : //<S2SV> if ( allocated_mr ) //<S2SV> rds_rdma_unuse ( rs , rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , 1 ) ; //<S2SV> if ( rm ) //<S2SV> rds_message_put ( rm ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 