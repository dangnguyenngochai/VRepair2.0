static int crypto_report_one ( struct crypto_alg * alg , //<S2SV> struct crypto_user_alg * ualg , struct sk_buff * skb ) //<S2SV> { //<S2SV> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; //<S2SV> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , //<S2SV> sizeof ( ualg -> cru_driver_name ) ) ; //<S2SV> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , //<S2SV> CRYPTO_MAX_ALG_NAME ) ; //<S2SV> ualg -> cru_flags = alg -> cra_flags ; //<S2SV> ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; //<S2SV> if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) //<S2SV> goto nla_put_failure ; //<S2SV> if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { //<S2SV> struct crypto_report_larval rl ; //<S2SV> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , "%s" , "larval" ) ; //<S2SV> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , //<S2SV> sizeof ( struct crypto_report_larval ) , & rl ) ) //<S2SV> goto nla_put_failure ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( alg -> cra_type && alg -> cra_type -> report ) { //<S2SV> if ( alg -> cra_type -> report ( skb , alg ) ) //<S2SV> goto nla_put_failure ; //<S2SV> goto out ; //<S2SV> } //<S2SV> switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { //<S2SV> case CRYPTO_ALG_TYPE_CIPHER : //<S2SV> if ( crypto_report_cipher ( skb , alg ) ) //<S2SV> goto nla_put_failure ; //<S2SV> break ; //<S2SV> case CRYPTO_ALG_TYPE_COMPRESS : //<S2SV> if ( crypto_report_comp ( skb , alg ) ) //<S2SV> goto nla_put_failure ; //<S2SV> break ; //<S2SV> } //<S2SV> out : //<S2SV> return 0 ; //<S2SV> nla_put_failure : //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> 