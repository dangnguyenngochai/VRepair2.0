static __be32 nfsd3_proc_setacl ( struct svc_rqst * rqstp , //<S2SV> struct nfsd3_setaclargs * argp , //<S2SV> struct nfsd3_attrstat * resp ) //<S2SV> { //<S2SV> struct inode * inode ; //<S2SV> svc_fh * fh ; //<S2SV> __be32 nfserr = 0 ; //<S2SV> int error ; //<S2SV> fh = fh_copy ( & resp -> fh , & argp -> fh ) ; //<S2SV> nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; //<S2SV> if ( nfserr ) //<S2SV> goto out ; //<S2SV> inode = d_inode ( fh -> fh_dentry ) ; //<S2SV> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { //<S2SV> error = - EOPNOTSUPP ; //<S2SV> goto out_errno ; //<S2SV> } //<S2SV> error = fh_want_write ( fh ) ; //<S2SV> if ( error ) //<S2SV> goto out_errno ; //<S2SV> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; //<S2SV> if ( error ) //<S2SV> goto out_drop_write ; //<S2SV> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , //<S2SV> ACL_TYPE_DEFAULT ) ; //<S2SV> out_drop_write : //<S2SV> fh_drop_write ( fh ) ; //<S2SV> out_errno : //<S2SV> nfserr = nfserrno ( error ) ; //<S2SV> out : //<S2SV> posix_acl_release ( argp -> acl_access ) ; //<S2SV> posix_acl_release ( argp -> acl_default ) ; //<S2SV> RETURN_STATUS ( nfserr ) ; //<S2SV> } //<S2SV> 