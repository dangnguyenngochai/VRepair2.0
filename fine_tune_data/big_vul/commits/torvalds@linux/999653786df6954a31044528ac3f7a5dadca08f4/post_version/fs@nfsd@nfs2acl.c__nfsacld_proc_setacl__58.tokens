static __be32 nfsacld_proc_setacl ( struct svc_rqst * rqstp , //<S2SV> struct nfsd3_setaclargs * argp , //<S2SV> struct nfsd_attrstat * resp ) //<S2SV> { //<S2SV> struct inode * inode ; //<S2SV> svc_fh * fh ; //<S2SV> __be32 nfserr = 0 ; //<S2SV> int error ; //<S2SV> dprintk ( "nfsd:<S2SV_blank>SETACL(2acl)<S2SV_blank><S2SV_blank><S2SV_blank>%s\\n" , SVCFH_fmt ( & argp -> fh ) ) ; //<S2SV> fh = fh_copy ( & resp -> fh , & argp -> fh ) ; //<S2SV> nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; //<S2SV> if ( nfserr ) //<S2SV> goto out ; //<S2SV> inode = d_inode ( fh -> fh_dentry ) ; //<S2SV> error = fh_want_write ( fh ) ; //<S2SV> if ( error ) //<S2SV> goto out_errno ; //<S2SV> fh_lock ( fh ) ; //<S2SV> error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ; //<S2SV> if ( error ) //<S2SV> goto out_drop_lock ; //<S2SV> error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default ) ; //<S2SV> if ( error ) //<S2SV> goto out_drop_lock ; //<S2SV> fh_unlock ( fh ) ; //<S2SV> fh_drop_write ( fh ) ; //<S2SV> nfserr = fh_getattr ( fh , & resp -> stat ) ; //<S2SV> out : //<S2SV> posix_acl_release ( argp -> acl_access ) ; //<S2SV> posix_acl_release ( argp -> acl_default ) ; //<S2SV> return nfserr ; //<S2SV> out_drop_lock : //<S2SV> fh_unlock ( fh ) ; //<S2SV> fh_drop_write ( fh ) ; //<S2SV> out_errno : //<S2SV> nfserr = nfserrno ( error ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 