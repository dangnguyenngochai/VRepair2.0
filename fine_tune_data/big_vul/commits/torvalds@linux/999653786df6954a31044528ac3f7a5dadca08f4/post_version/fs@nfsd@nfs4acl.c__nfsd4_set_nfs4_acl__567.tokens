__be32 //<S2SV> nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , //<S2SV> struct nfs4_acl * acl ) //<S2SV> { //<S2SV> __be32 error ; //<S2SV> int host_error ; //<S2SV> struct dentry * dentry ; //<S2SV> struct inode * inode ; //<S2SV> struct posix_acl * pacl = NULL , * dpacl = NULL ; //<S2SV> unsigned int flags = 0 ; //<S2SV> error = fh_verify ( rqstp , fhp , 0 , NFSD_MAY_SATTR ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> dentry = fhp -> fh_dentry ; //<S2SV> inode = d_inode ( dentry ) ; //<S2SV> if ( S_ISDIR ( inode -> i_mode ) ) //<S2SV> flags = NFS4_ACL_DIR ; //<S2SV> host_error = nfs4_acl_nfsv4_to_posix ( acl , & pacl , & dpacl , flags ) ; //<S2SV> if ( host_error == - EINVAL ) //<S2SV> return nfserr_attrnotsupp ; //<S2SV> if ( host_error < 0 ) //<S2SV> goto out_nfserr ; //<S2SV> fh_lock ( fhp ) ; //<S2SV> host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl ) ; //<S2SV> if ( host_error < 0 ) //<S2SV> goto out_drop_lock ; //<S2SV> if ( S_ISDIR ( inode -> i_mode ) ) { //<S2SV> host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl ) ; //<S2SV> } //<S2SV> out_drop_lock : //<S2SV> fh_unlock ( fhp ) ; //<S2SV> posix_acl_release ( pacl ) ; //<S2SV> posix_acl_release ( dpacl ) ; //<S2SV> out_nfserr : //<S2SV> if ( host_error == - EOPNOTSUPP ) //<S2SV> return nfserr_attrnotsupp ; //<S2SV> else //<S2SV> return nfserrno ( host_error ) ; //<S2SV> } //<S2SV> 