SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) //<S2SV> { //<S2SV> struct fsnotify_group * group ; //<S2SV> struct user_struct * user ; //<S2SV> int ret ; //<S2SV> BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; //<S2SV> BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; //<S2SV> if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) //<S2SV> return - EINVAL ; //<S2SV> user = get_current_user ( ) ; //<S2SV> if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= //<S2SV> inotify_max_user_instances ) ) { //<S2SV> ret = - EMFILE ; //<S2SV> goto out_free_uid ; //<S2SV> } //<S2SV> group = inotify_new_group ( user , inotify_max_queued_events ) ; //<S2SV> if ( IS_ERR ( group ) ) { //<S2SV> ret = PTR_ERR ( group ) ; //<S2SV> goto out_free_uid ; //<S2SV> } //<S2SV> atomic_inc ( & user -> inotify_devs ) ; //<S2SV> ret = anon_inode_getfd ( "inotify" , & inotify_fops , group , //<S2SV> O_RDONLY | flags ) ; //<S2SV> if ( ret >= 0 ) //<S2SV> return ret ; //<S2SV> fsnotify_put_group ( group ) ; //<S2SV> atomic_dec ( & user -> inotify_devs ) ; //<S2SV> out_free_uid : //<S2SV> free_uid ( user ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 