static bool ldm_frag_add ( const u8 * data , int size , struct list_head * frags ) //<S2SV> { //<S2SV> struct frag * f ; //<S2SV> struct list_head * item ; //<S2SV> int rec , num , group ; //<S2SV> BUG_ON ( ! data || ! frags ) ; //<S2SV> if ( size < 2 * VBLK_SIZE_HEAD ) { //<S2SV> ldm_error ( "Value<S2SV_blank>of<S2SV_blank>size<S2SV_blank>is<S2SV_blank>to<S2SV_blank>small." ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> group = get_unaligned_be32 ( data + 0x08 ) ; //<S2SV> rec = get_unaligned_be16 ( data + 0x0C ) ; //<S2SV> num = get_unaligned_be16 ( data + 0x0E ) ; //<S2SV> if ( ( num < 1 ) || ( num > 4 ) ) { //<S2SV> ldm_error ( "A<S2SV_blank>VBLK<S2SV_blank>claims<S2SV_blank>to<S2SV_blank>have<S2SV_blank>%d<S2SV_blank>parts." , num ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( rec >= num ) { //<S2SV> ldm_error ( "REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)" , rec , num ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> list_for_each ( item , frags ) { //<S2SV> f = list_entry ( item , struct frag , list ) ; //<S2SV> if ( f -> group == group ) //<S2SV> goto found ; //<S2SV> } //<S2SV> f = kmalloc ( sizeof ( * f ) + size * num , GFP_KERNEL ) ; //<S2SV> if ( ! f ) { //<S2SV> ldm_crit ( "Out<S2SV_blank>of<S2SV_blank>memory." ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> f -> group = group ; //<S2SV> f -> num = num ; //<S2SV> f -> rec = rec ; //<S2SV> f -> map = 0xFF << num ; //<S2SV> list_add_tail ( & f -> list , frags ) ; //<S2SV> found : //<S2SV> if ( rec >= f -> num ) { //<S2SV> ldm_error ( "REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)" , rec , f -> num ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( f -> map & ( 1 << rec ) ) { //<S2SV> ldm_error ( "Duplicate<S2SV_blank>VBLK,<S2SV_blank>part<S2SV_blank>%d." , rec ) ; //<S2SV> f -> map &= 0x7F ; //<S2SV> return false ; //<S2SV> } //<S2SV> f -> map |= ( 1 << rec ) ; //<S2SV> data += VBLK_SIZE_HEAD ; //<S2SV> size -= VBLK_SIZE_HEAD ; //<S2SV> memcpy ( f -> data + rec * ( size - VBLK_SIZE_HEAD ) + VBLK_SIZE_HEAD , data , size ) ; //<S2SV> return true ; //<S2SV> } //<S2SV> 