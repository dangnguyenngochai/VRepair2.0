static int ax25_create ( struct net * net , struct socket * sock , int protocol , //<S2SV> int kern ) //<S2SV> { //<S2SV> struct sock * sk ; //<S2SV> ax25_cb * ax25 ; //<S2SV> if ( ! net_eq ( net , & init_net ) ) //<S2SV> return - EAFNOSUPPORT ; //<S2SV> switch ( sock -> type ) { //<S2SV> case SOCK_DGRAM : //<S2SV> if ( protocol == 0 || protocol == PF_AX25 ) //<S2SV> protocol = AX25_P_TEXT ; //<S2SV> break ; //<S2SV> case SOCK_SEQPACKET : //<S2SV> switch ( protocol ) { //<S2SV> case 0 : //<S2SV> case PF_AX25 : //<S2SV> protocol = AX25_P_TEXT ; //<S2SV> break ; //<S2SV> case AX25_P_SEGMENT : //<S2SV> # ifdef CONFIG_INET //<S2SV> case AX25_P_ARP : //<S2SV> case AX25_P_IP : //<S2SV> # endif //<S2SV> # ifdef CONFIG_NETROM //<S2SV> case AX25_P_NETROM : //<S2SV> # endif //<S2SV> # ifdef CONFIG_ROSE //<S2SV> case AX25_P_ROSE : //<S2SV> # endif //<S2SV> return - ESOCKTNOSUPPORT ; //<S2SV> # ifdef CONFIG_NETROM_MODULE //<S2SV> case AX25_P_NETROM : //<S2SV> if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) //<S2SV> return - ESOCKTNOSUPPORT ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef CONFIG_ROSE_MODULE //<S2SV> case AX25_P_ROSE : //<S2SV> if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) //<S2SV> return - ESOCKTNOSUPPORT ; //<S2SV> # endif //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case SOCK_RAW : //<S2SV> break ; //<S2SV> default : //<S2SV> return - ESOCKTNOSUPPORT ; //<S2SV> } //<S2SV> sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; //<S2SV> if ( sk == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; //<S2SV> if ( ! ax25 ) { //<S2SV> sk_free ( sk ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> sock_init_data ( sock , sk ) ; //<S2SV> sk -> sk_destruct = ax25_free_sock ; //<S2SV> sock -> ops = & ax25_proto_ops ; //<S2SV> sk -> sk_protocol = protocol ; //<S2SV> ax25 -> sk = sk ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 