static int irda_create ( struct net * net , struct socket * sock , int protocol , //<S2SV> int kern ) //<S2SV> { //<S2SV> struct sock * sk ; //<S2SV> struct irda_sock * self ; //<S2SV> if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) //<S2SV> return - EINVAL ; //<S2SV> if ( net != & init_net ) //<S2SV> return - EAFNOSUPPORT ; //<S2SV> switch ( sock -> type ) { //<S2SV> case SOCK_STREAM : //<S2SV> case SOCK_SEQPACKET : //<S2SV> case SOCK_DGRAM : //<S2SV> break ; //<S2SV> default : //<S2SV> return - ESOCKTNOSUPPORT ; //<S2SV> } //<S2SV> sk = sk_alloc ( net , PF_IRDA , GFP_KERNEL , & irda_proto , kern ) ; //<S2SV> if ( sk == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> self = irda_sk ( sk ) ; //<S2SV> pr_debug ( "%s()<S2SV_blank>:<S2SV_blank>self<S2SV_blank>is<S2SV_blank>%p\\n" , __func__ , self ) ; //<S2SV> init_waitqueue_head ( & self -> query_wait ) ; //<S2SV> switch ( sock -> type ) { //<S2SV> case SOCK_STREAM : //<S2SV> sock -> ops = & irda_stream_ops ; //<S2SV> self -> max_sdu_size_rx = TTP_SAR_DISABLE ; //<S2SV> break ; //<S2SV> case SOCK_SEQPACKET : //<S2SV> sock -> ops = & irda_seqpacket_ops ; //<S2SV> self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; //<S2SV> break ; //<S2SV> case SOCK_DGRAM : //<S2SV> switch ( protocol ) { //<S2SV> # ifdef CONFIG_IRDA_ULTRA //<S2SV> case IRDAPROTO_ULTRA : //<S2SV> sock -> ops = & irda_ultra_ops ; //<S2SV> self -> max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER ; //<S2SV> self -> max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case IRDAPROTO_UNITDATA : //<S2SV> sock -> ops = & irda_dgram_ops ; //<S2SV> self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; //<S2SV> break ; //<S2SV> default : //<S2SV> sk_free ( sk ) ; //<S2SV> return - ESOCKTNOSUPPORT ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> sk_free ( sk ) ; //<S2SV> return - ESOCKTNOSUPPORT ; //<S2SV> } //<S2SV> sock_init_data ( sock , sk ) ; //<S2SV> sk -> sk_family = PF_IRDA ; //<S2SV> sk -> sk_protocol = protocol ; //<S2SV> self -> ckey = irlmp_register_client ( 0 , NULL , NULL , NULL ) ; //<S2SV> self -> mask . word = 0xffff ; //<S2SV> self -> rx_flow = self -> tx_flow = FLOW_START ; //<S2SV> self -> nslots = DISCOVERY_DEFAULT_SLOTS ; //<S2SV> self -> daddr = DEV_ADDR_ANY ; //<S2SV> self -> saddr = 0x0 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 