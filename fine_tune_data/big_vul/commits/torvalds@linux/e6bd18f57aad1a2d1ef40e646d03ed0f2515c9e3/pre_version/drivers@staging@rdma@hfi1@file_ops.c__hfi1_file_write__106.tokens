static ssize_t hfi1_file_write ( struct file * fp , const char __user * data , //<S2SV> size_t count , loff_t * offset ) //<S2SV> { //<S2SV> const struct hfi1_cmd __user * ucmd ; //<S2SV> struct hfi1_filedata * fd = fp -> private_data ; //<S2SV> struct hfi1_ctxtdata * uctxt = fd -> uctxt ; //<S2SV> struct hfi1_cmd cmd ; //<S2SV> struct hfi1_user_info uinfo ; //<S2SV> struct hfi1_tid_info tinfo ; //<S2SV> unsigned long addr ; //<S2SV> ssize_t consumed = 0 , copy = 0 , ret = 0 ; //<S2SV> void * dest = NULL ; //<S2SV> __u64 user_val = 0 ; //<S2SV> int uctxt_required = 1 ; //<S2SV> int must_be_root = 0 ; //<S2SV> if ( count < sizeof ( cmd ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> ucmd = ( const struct hfi1_cmd __user * ) data ; //<S2SV> if ( copy_from_user ( & cmd , ucmd , sizeof ( cmd ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> consumed = sizeof ( cmd ) ; //<S2SV> switch ( cmd . type ) { //<S2SV> case HFI1_CMD_ASSIGN_CTXT : //<S2SV> uctxt_required = 0 ; //<S2SV> copy = sizeof ( uinfo ) ; //<S2SV> dest = & uinfo ; //<S2SV> break ; //<S2SV> case HFI1_CMD_SDMA_STATUS_UPD : //<S2SV> case HFI1_CMD_CREDIT_UPD : //<S2SV> copy = 0 ; //<S2SV> break ; //<S2SV> case HFI1_CMD_TID_UPDATE : //<S2SV> case HFI1_CMD_TID_FREE : //<S2SV> case HFI1_CMD_TID_INVAL_READ : //<S2SV> copy = sizeof ( tinfo ) ; //<S2SV> dest = & tinfo ; //<S2SV> break ; //<S2SV> case HFI1_CMD_USER_INFO : //<S2SV> case HFI1_CMD_RECV_CTRL : //<S2SV> case HFI1_CMD_POLL_TYPE : //<S2SV> case HFI1_CMD_ACK_EVENT : //<S2SV> case HFI1_CMD_CTXT_INFO : //<S2SV> case HFI1_CMD_SET_PKEY : //<S2SV> case HFI1_CMD_CTXT_RESET : //<S2SV> copy = 0 ; //<S2SV> user_val = cmd . addr ; //<S2SV> break ; //<S2SV> case HFI1_CMD_EP_INFO : //<S2SV> case HFI1_CMD_EP_ERASE_CHIP : //<S2SV> case HFI1_CMD_EP_ERASE_RANGE : //<S2SV> case HFI1_CMD_EP_READ_RANGE : //<S2SV> case HFI1_CMD_EP_WRITE_RANGE : //<S2SV> uctxt_required = 0 ; //<S2SV> must_be_root = 1 ; //<S2SV> copy = 0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> ret = - EINVAL ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> if ( copy ) { //<S2SV> if ( copy_from_user ( dest , ( void __user * ) cmd . addr , copy ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> consumed += copy ; //<S2SV> } //<S2SV> if ( uctxt_required && ! uctxt ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> if ( must_be_root && ! capable ( CAP_SYS_ADMIN ) ) { //<S2SV> ret = - EPERM ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> switch ( cmd . type ) { //<S2SV> case HFI1_CMD_ASSIGN_CTXT : //<S2SV> ret = assign_ctxt ( fp , & uinfo ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto bail ; //<S2SV> ret = setup_ctxt ( fp ) ; //<S2SV> if ( ret ) //<S2SV> goto bail ; //<S2SV> ret = user_init ( fp ) ; //<S2SV> break ; //<S2SV> case HFI1_CMD_CTXT_INFO : //<S2SV> ret = get_ctxt_info ( fp , ( void __user * ) ( unsigned long ) //<S2SV> user_val , cmd . len ) ; //<S2SV> break ; //<S2SV> case HFI1_CMD_USER_INFO : //<S2SV> ret = get_base_info ( fp , ( void __user * ) ( unsigned long ) //<S2SV> user_val , cmd . len ) ; //<S2SV> break ; //<S2SV> case HFI1_CMD_SDMA_STATUS_UPD : //<S2SV> break ; //<S2SV> case HFI1_CMD_CREDIT_UPD : //<S2SV> if ( uctxt && uctxt -> sc ) //<S2SV> sc_return_credits ( uctxt -> sc ) ; //<S2SV> break ; //<S2SV> case HFI1_CMD_TID_UPDATE : //<S2SV> ret = hfi1_user_exp_rcv_setup ( fp , & tinfo ) ; //<S2SV> if ( ! ret ) { //<S2SV> addr = ( unsigned long ) cmd . addr + //<S2SV> offsetof ( struct hfi1_tid_info , tidcnt ) ; //<S2SV> if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , //<S2SV> sizeof ( tinfo . tidcnt ) + //<S2SV> sizeof ( tinfo . length ) ) ) //<S2SV> ret = - EFAULT ; //<S2SV> } //<S2SV> break ; //<S2SV> case HFI1_CMD_TID_INVAL_READ : //<S2SV> ret = hfi1_user_exp_rcv_invalid ( fp , & tinfo ) ; //<S2SV> if ( ret ) //<S2SV> break ; //<S2SV> addr = ( unsigned long ) cmd . addr + //<S2SV> offsetof ( struct hfi1_tid_info , tidcnt ) ; //<S2SV> if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , //<S2SV> sizeof ( tinfo . tidcnt ) ) ) //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> case HFI1_CMD_TID_FREE : //<S2SV> ret = hfi1_user_exp_rcv_clear ( fp , & tinfo ) ; //<S2SV> if ( ret ) //<S2SV> break ; //<S2SV> addr = ( unsigned long ) cmd . addr + //<S2SV> offsetof ( struct hfi1_tid_info , tidcnt ) ; //<S2SV> if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , //<S2SV> sizeof ( tinfo . tidcnt ) ) ) //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> case HFI1_CMD_RECV_CTRL : //<S2SV> ret = manage_rcvq ( uctxt , fd -> subctxt , ( int ) user_val ) ; //<S2SV> break ; //<S2SV> case HFI1_CMD_POLL_TYPE : //<S2SV> uctxt -> poll_type = ( typeof ( uctxt -> poll_type ) ) user_val ; //<S2SV> break ; //<S2SV> case HFI1_CMD_ACK_EVENT : //<S2SV> ret = user_event_ack ( uctxt , fd -> subctxt , user_val ) ; //<S2SV> break ; //<S2SV> case HFI1_CMD_SET_PKEY : //<S2SV> if ( HFI1_CAP_IS_USET ( PKEY_CHECK ) ) //<S2SV> ret = set_ctxt_pkey ( uctxt , fd -> subctxt , user_val ) ; //<S2SV> else //<S2SV> ret = - EPERM ; //<S2SV> break ; //<S2SV> case HFI1_CMD_CTXT_RESET : { //<S2SV> struct send_context * sc ; //<S2SV> struct hfi1_devdata * dd ; //<S2SV> if ( ! uctxt || ! uctxt -> dd || ! uctxt -> sc ) { //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> dd = uctxt -> dd ; //<S2SV> sc = uctxt -> sc ; //<S2SV> wait_event_interruptible_timeout ( //<S2SV> sc -> halt_wait , ( sc -> flags & SCF_HALTED ) , //<S2SV> msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; //<S2SV> if ( ! ( sc -> flags & SCF_HALTED ) ) { //<S2SV> ret = - ENOLCK ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( sc -> flags & SCF_FROZEN ) { //<S2SV> wait_event_interruptible_timeout ( //<S2SV> dd -> event_queue , //<S2SV> ! ( ACCESS_ONCE ( dd -> flags ) & HFI1_FROZEN ) , //<S2SV> msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; //<S2SV> if ( dd -> flags & HFI1_FROZEN ) { //<S2SV> ret = - ENOLCK ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( dd -> flags & HFI1_FORCED_FREEZE ) { //<S2SV> ret = - ENODEV ; //<S2SV> break ; //<S2SV> } //<S2SV> sc_disable ( sc ) ; //<S2SV> ret = sc_enable ( sc ) ; //<S2SV> hfi1_rcvctrl ( dd , HFI1_RCVCTRL_CTXT_ENB , //<S2SV> uctxt -> ctxt ) ; //<S2SV> } else { //<S2SV> ret = sc_restart ( sc ) ; //<S2SV> } //<S2SV> if ( ! ret ) //<S2SV> sc_return_credits ( sc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case HFI1_CMD_EP_INFO : //<S2SV> case HFI1_CMD_EP_ERASE_CHIP : //<S2SV> case HFI1_CMD_EP_ERASE_RANGE : //<S2SV> case HFI1_CMD_EP_READ_RANGE : //<S2SV> case HFI1_CMD_EP_WRITE_RANGE : //<S2SV> ret = handle_eprom_command ( fp , & cmd ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ret >= 0 ) //<S2SV> ret = consumed ; //<S2SV> bail : //<S2SV> return ret ; //<S2SV> } //<S2SV> 