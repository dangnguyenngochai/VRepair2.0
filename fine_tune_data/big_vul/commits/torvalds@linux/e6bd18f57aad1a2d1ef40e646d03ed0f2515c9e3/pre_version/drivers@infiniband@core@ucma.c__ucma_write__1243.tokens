static ssize_t ucma_write ( struct file * filp , const char __user * buf , //<S2SV> size_t len , loff_t * pos ) //<S2SV> { //<S2SV> struct ucma_file * file = filp -> private_data ; //<S2SV> struct rdma_ucm_cmd_hdr hdr ; //<S2SV> ssize_t ret ; //<S2SV> if ( len < sizeof ( hdr ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( hdr . cmd >= ARRAY_SIZE ( ucma_cmd_table ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( hdr . in + sizeof ( hdr ) > len ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! ucma_cmd_table [ hdr . cmd ] ) //<S2SV> return - ENOSYS ; //<S2SV> ret = ucma_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; //<S2SV> if ( ! ret ) //<S2SV> ret = len ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 