static ssize_t qib_write ( struct file * fp , const char __user * data , //<S2SV> size_t count , loff_t * off ) //<S2SV> { //<S2SV> const struct qib_cmd __user * ucmd ; //<S2SV> struct qib_ctxtdata * rcd ; //<S2SV> const void __user * src ; //<S2SV> size_t consumed , copy = 0 ; //<S2SV> struct qib_cmd cmd ; //<S2SV> ssize_t ret = 0 ; //<S2SV> void * dest ; //<S2SV> if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) //<S2SV> return - EACCES ; //<S2SV> if ( count < sizeof ( cmd . type ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> ucmd = ( const struct qib_cmd __user * ) data ; //<S2SV> if ( copy_from_user ( & cmd . type , & ucmd -> type , sizeof ( cmd . type ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> consumed = sizeof ( cmd . type ) ; //<S2SV> switch ( cmd . type ) { //<S2SV> case QIB_CMD_ASSIGN_CTXT : //<S2SV> case QIB_CMD_USER_INIT : //<S2SV> copy = sizeof ( cmd . cmd . user_info ) ; //<S2SV> dest = & cmd . cmd . user_info ; //<S2SV> src = & ucmd -> cmd . user_info ; //<S2SV> break ; //<S2SV> case QIB_CMD_RECV_CTRL : //<S2SV> copy = sizeof ( cmd . cmd . recv_ctrl ) ; //<S2SV> dest = & cmd . cmd . recv_ctrl ; //<S2SV> src = & ucmd -> cmd . recv_ctrl ; //<S2SV> break ; //<S2SV> case QIB_CMD_CTXT_INFO : //<S2SV> copy = sizeof ( cmd . cmd . ctxt_info ) ; //<S2SV> dest = & cmd . cmd . ctxt_info ; //<S2SV> src = & ucmd -> cmd . ctxt_info ; //<S2SV> break ; //<S2SV> case QIB_CMD_TID_UPDATE : //<S2SV> case QIB_CMD_TID_FREE : //<S2SV> copy = sizeof ( cmd . cmd . tid_info ) ; //<S2SV> dest = & cmd . cmd . tid_info ; //<S2SV> src = & ucmd -> cmd . tid_info ; //<S2SV> break ; //<S2SV> case QIB_CMD_SET_PART_KEY : //<S2SV> copy = sizeof ( cmd . cmd . part_key ) ; //<S2SV> dest = & cmd . cmd . part_key ; //<S2SV> src = & ucmd -> cmd . part_key ; //<S2SV> break ; //<S2SV> case QIB_CMD_DISARM_BUFS : //<S2SV> case QIB_CMD_PIOAVAILUPD : //<S2SV> copy = 0 ; //<S2SV> src = NULL ; //<S2SV> dest = NULL ; //<S2SV> break ; //<S2SV> case QIB_CMD_POLL_TYPE : //<S2SV> copy = sizeof ( cmd . cmd . poll_type ) ; //<S2SV> dest = & cmd . cmd . poll_type ; //<S2SV> src = & ucmd -> cmd . poll_type ; //<S2SV> break ; //<S2SV> case QIB_CMD_ARMLAUNCH_CTRL : //<S2SV> copy = sizeof ( cmd . cmd . armlaunch_ctrl ) ; //<S2SV> dest = & cmd . cmd . armlaunch_ctrl ; //<S2SV> src = & ucmd -> cmd . armlaunch_ctrl ; //<S2SV> break ; //<S2SV> case QIB_CMD_SDMA_INFLIGHT : //<S2SV> copy = sizeof ( cmd . cmd . sdma_inflight ) ; //<S2SV> dest = & cmd . cmd . sdma_inflight ; //<S2SV> src = & ucmd -> cmd . sdma_inflight ; //<S2SV> break ; //<S2SV> case QIB_CMD_SDMA_COMPLETE : //<S2SV> copy = sizeof ( cmd . cmd . sdma_complete ) ; //<S2SV> dest = & cmd . cmd . sdma_complete ; //<S2SV> src = & ucmd -> cmd . sdma_complete ; //<S2SV> break ; //<S2SV> case QIB_CMD_ACK_EVENT : //<S2SV> copy = sizeof ( cmd . cmd . event_mask ) ; //<S2SV> dest = & cmd . cmd . event_mask ; //<S2SV> src = & ucmd -> cmd . event_mask ; //<S2SV> break ; //<S2SV> default : //<S2SV> ret = - EINVAL ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> if ( copy ) { //<S2SV> if ( ( count - consumed ) < copy ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> if ( copy_from_user ( dest , src , copy ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> consumed += copy ; //<S2SV> } //<S2SV> rcd = ctxt_fp ( fp ) ; //<S2SV> if ( ! rcd && cmd . type != QIB_CMD_ASSIGN_CTXT ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> switch ( cmd . type ) { //<S2SV> case QIB_CMD_ASSIGN_CTXT : //<S2SV> ret = qib_assign_ctxt ( fp , & cmd . cmd . user_info ) ; //<S2SV> if ( ret ) //<S2SV> goto bail ; //<S2SV> break ; //<S2SV> case QIB_CMD_USER_INIT : //<S2SV> ret = qib_do_user_init ( fp , & cmd . cmd . user_info ) ; //<S2SV> if ( ret ) //<S2SV> goto bail ; //<S2SV> ret = qib_get_base_info ( fp , ( void __user * ) ( unsigned long ) //<S2SV> cmd . cmd . user_info . spu_base_info , //<S2SV> cmd . cmd . user_info . spu_base_info_size ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_RECV_CTRL : //<S2SV> ret = qib_manage_rcvq ( rcd , subctxt_fp ( fp ) , cmd . cmd . recv_ctrl ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_CTXT_INFO : //<S2SV> ret = qib_ctxt_info ( fp , ( struct qib_ctxt_info __user * ) //<S2SV> ( unsigned long ) cmd . cmd . ctxt_info ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_TID_UPDATE : //<S2SV> ret = qib_tid_update ( rcd , fp , & cmd . cmd . tid_info ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_TID_FREE : //<S2SV> ret = qib_tid_free ( rcd , subctxt_fp ( fp ) , & cmd . cmd . tid_info ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_SET_PART_KEY : //<S2SV> ret = qib_set_part_key ( rcd , cmd . cmd . part_key ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_DISARM_BUFS : //<S2SV> ( void ) qib_disarm_piobufs_ifneeded ( rcd ) ; //<S2SV> ret = disarm_req_delay ( rcd ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_PIOAVAILUPD : //<S2SV> qib_force_pio_avail_update ( rcd -> dd ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_POLL_TYPE : //<S2SV> rcd -> poll_type = cmd . cmd . poll_type ; //<S2SV> break ; //<S2SV> case QIB_CMD_ARMLAUNCH_CTRL : //<S2SV> rcd -> dd -> f_set_armlaunch ( rcd -> dd , cmd . cmd . armlaunch_ctrl ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_SDMA_INFLIGHT : //<S2SV> ret = qib_sdma_get_inflight ( user_sdma_queue_fp ( fp ) , //<S2SV> ( u32 __user * ) ( unsigned long ) //<S2SV> cmd . cmd . sdma_inflight ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_SDMA_COMPLETE : //<S2SV> ret = qib_sdma_get_complete ( rcd -> ppd , //<S2SV> user_sdma_queue_fp ( fp ) , //<S2SV> ( u32 __user * ) ( unsigned long ) //<S2SV> cmd . cmd . sdma_complete ) ; //<S2SV> break ; //<S2SV> case QIB_CMD_ACK_EVENT : //<S2SV> ret = qib_user_event_ack ( rcd , subctxt_fp ( fp ) , //<S2SV> cmd . cmd . event_mask ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ret >= 0 ) //<S2SV> ret = consumed ; //<S2SV> bail : //<S2SV> return ret ; //<S2SV> } //<S2SV> 