static struct sk_buff * //<S2SV> batadv_frag_merge_packets ( struct hlist_head * chain , struct sk_buff * skb ) //<S2SV> { //<S2SV> struct batadv_frag_packet * packet ; //<S2SV> struct batadv_frag_list_entry * entry ; //<S2SV> struct sk_buff * skb_out = NULL ; //<S2SV> int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; //<S2SV> packet = ( struct batadv_frag_packet * ) skb -> data ; //<S2SV> size = ntohs ( packet -> total_size ) ; //<S2SV> if ( size > batadv_frag_size_limit ( ) ) //<S2SV> goto free ; //<S2SV> entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; //<S2SV> hlist_del ( & entry -> list ) ; //<S2SV> skb_out = entry -> skb ; //<S2SV> kfree ( entry ) ; //<S2SV> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { //<S2SV> kfree_skb ( skb_out ) ; //<S2SV> skb_out = NULL ; //<S2SV> goto free ; //<S2SV> } //<S2SV> skb_pull_rcsum ( skb_out , hdr_size ) ; //<S2SV> memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; //<S2SV> skb_set_mac_header ( skb_out , - ETH_HLEN ) ; //<S2SV> skb_reset_network_header ( skb_out ) ; //<S2SV> skb_reset_transport_header ( skb_out ) ; //<S2SV> hlist_for_each_entry ( entry , chain , list ) { //<S2SV> size = entry -> skb -> len - hdr_size ; //<S2SV> memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , //<S2SV> size ) ; //<S2SV> } //<S2SV> free : //<S2SV> batadv_frag_clear_chain ( chain ) ; //<S2SV> return skb_out ; //<S2SV> } //<S2SV> 