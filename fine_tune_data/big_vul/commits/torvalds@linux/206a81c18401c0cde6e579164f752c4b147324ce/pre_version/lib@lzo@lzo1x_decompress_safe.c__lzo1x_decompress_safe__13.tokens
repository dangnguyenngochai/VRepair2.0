int lzo1x_decompress_safe ( const unsigned char * in , size_t in_len , //<S2SV> unsigned char * out , size_t * out_len ) //<S2SV> { //<S2SV> unsigned char * op ; //<S2SV> const unsigned char * ip ; //<S2SV> size_t t , next ; //<S2SV> size_t state = 0 ; //<S2SV> const unsigned char * m_pos ; //<S2SV> const unsigned char * const ip_end = in + in_len ; //<S2SV> unsigned char * const op_end = out + * out_len ; //<S2SV> op = out ; //<S2SV> ip = in ; //<S2SV> if ( unlikely ( in_len < 3 ) ) //<S2SV> goto input_overrun ; //<S2SV> if ( * ip > 17 ) { //<S2SV> t = * ip ++ - 17 ; //<S2SV> if ( t < 4 ) { //<S2SV> next = t ; //<S2SV> goto match_next ; //<S2SV> } //<S2SV> goto copy_literal_run ; //<S2SV> } //<S2SV> for ( ; ; ) { //<S2SV> t = * ip ++ ; //<S2SV> if ( t < 16 ) { //<S2SV> if ( likely ( state == 0 ) ) { //<S2SV> if ( unlikely ( t == 0 ) ) { //<S2SV> while ( unlikely ( * ip == 0 ) ) { //<S2SV> t += 255 ; //<S2SV> ip ++ ; //<S2SV> NEED_IP ( 1 ) ; //<S2SV> } //<S2SV> t += 15 + * ip ++ ; //<S2SV> } //<S2SV> t += 3 ; //<S2SV> copy_literal_run : //<S2SV> # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) //<S2SV> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { //<S2SV> const unsigned char * ie = ip + t ; //<S2SV> unsigned char * oe = op + t ; //<S2SV> do { //<S2SV> COPY8 ( op , ip ) ; //<S2SV> op += 8 ; //<S2SV> ip += 8 ; //<S2SV> COPY8 ( op , ip ) ; //<S2SV> op += 8 ; //<S2SV> ip += 8 ; //<S2SV> } while ( ip < ie ) ; //<S2SV> ip = ie ; //<S2SV> op = oe ; //<S2SV> } else //<S2SV> # endif //<S2SV> { //<S2SV> NEED_OP ( t ) ; //<S2SV> NEED_IP ( t + 3 ) ; //<S2SV> do { //<S2SV> * op ++ = * ip ++ ; //<S2SV> } while ( -- t > 0 ) ; //<S2SV> } //<S2SV> state = 4 ; //<S2SV> continue ; //<S2SV> } else if ( state != 4 ) { //<S2SV> next = t & 3 ; //<S2SV> m_pos = op - 1 ; //<S2SV> m_pos -= t >> 2 ; //<S2SV> m_pos -= * ip ++ << 2 ; //<S2SV> TEST_LB ( m_pos ) ; //<S2SV> NEED_OP ( 2 ) ; //<S2SV> op [ 0 ] = m_pos [ 0 ] ; //<S2SV> op [ 1 ] = m_pos [ 1 ] ; //<S2SV> op += 2 ; //<S2SV> goto match_next ; //<S2SV> } else { //<S2SV> next = t & 3 ; //<S2SV> m_pos = op - ( 1 + M2_MAX_OFFSET ) ; //<S2SV> m_pos -= t >> 2 ; //<S2SV> m_pos -= * ip ++ << 2 ; //<S2SV> t = 3 ; //<S2SV> } //<S2SV> } else if ( t >= 64 ) { //<S2SV> next = t & 3 ; //<S2SV> m_pos = op - 1 ; //<S2SV> m_pos -= ( t >> 2 ) & 7 ; //<S2SV> m_pos -= * ip ++ << 3 ; //<S2SV> t = ( t >> 5 ) - 1 + ( 3 - 1 ) ; //<S2SV> } else if ( t >= 32 ) { //<S2SV> t = ( t & 31 ) + ( 3 - 1 ) ; //<S2SV> if ( unlikely ( t == 2 ) ) { //<S2SV> while ( unlikely ( * ip == 0 ) ) { //<S2SV> t += 255 ; //<S2SV> ip ++ ; //<S2SV> NEED_IP ( 1 ) ; //<S2SV> } //<S2SV> t += 31 + * ip ++ ; //<S2SV> NEED_IP ( 2 ) ; //<S2SV> } //<S2SV> m_pos = op - 1 ; //<S2SV> next = get_unaligned_le16 ( ip ) ; //<S2SV> ip += 2 ; //<S2SV> m_pos -= next >> 2 ; //<S2SV> next &= 3 ; //<S2SV> } else { //<S2SV> m_pos = op ; //<S2SV> m_pos -= ( t & 8 ) << 11 ; //<S2SV> t = ( t & 7 ) + ( 3 - 1 ) ; //<S2SV> if ( unlikely ( t == 2 ) ) { //<S2SV> while ( unlikely ( * ip == 0 ) ) { //<S2SV> t += 255 ; //<S2SV> ip ++ ; //<S2SV> NEED_IP ( 1 ) ; //<S2SV> } //<S2SV> t += 7 + * ip ++ ; //<S2SV> NEED_IP ( 2 ) ; //<S2SV> } //<S2SV> next = get_unaligned_le16 ( ip ) ; //<S2SV> ip += 2 ; //<S2SV> m_pos -= next >> 2 ; //<S2SV> next &= 3 ; //<S2SV> if ( m_pos == op ) //<S2SV> goto eof_found ; //<S2SV> m_pos -= 0x4000 ; //<S2SV> } //<S2SV> TEST_LB ( m_pos ) ; //<S2SV> # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) //<S2SV> if ( op - m_pos >= 8 ) { //<S2SV> unsigned char * oe = op + t ; //<S2SV> if ( likely ( HAVE_OP ( t + 15 ) ) ) { //<S2SV> do { //<S2SV> COPY8 ( op , m_pos ) ; //<S2SV> op += 8 ; //<S2SV> m_pos += 8 ; //<S2SV> COPY8 ( op , m_pos ) ; //<S2SV> op += 8 ; //<S2SV> m_pos += 8 ; //<S2SV> } while ( op < oe ) ; //<S2SV> op = oe ; //<S2SV> if ( HAVE_IP ( 6 ) ) { //<S2SV> state = next ; //<S2SV> COPY4 ( op , ip ) ; //<S2SV> op += next ; //<S2SV> ip += next ; //<S2SV> continue ; //<S2SV> } //<S2SV> } else { //<S2SV> NEED_OP ( t ) ; //<S2SV> do { //<S2SV> * op ++ = * m_pos ++ ; //<S2SV> } while ( op < oe ) ; //<S2SV> } //<S2SV> } else //<S2SV> # endif //<S2SV> { //<S2SV> unsigned char * oe = op + t ; //<S2SV> NEED_OP ( t ) ; //<S2SV> op [ 0 ] = m_pos [ 0 ] ; //<S2SV> op [ 1 ] = m_pos [ 1 ] ; //<S2SV> op += 2 ; //<S2SV> m_pos += 2 ; //<S2SV> do { //<S2SV> * op ++ = * m_pos ++ ; //<S2SV> } while ( op < oe ) ; //<S2SV> } //<S2SV> match_next : //<S2SV> state = next ; //<S2SV> t = next ; //<S2SV> # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) //<S2SV> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { //<S2SV> COPY4 ( op , ip ) ; //<S2SV> op += t ; //<S2SV> ip += t ; //<S2SV> } else //<S2SV> # endif //<S2SV> { //<S2SV> NEED_IP ( t + 3 ) ; //<S2SV> NEED_OP ( t ) ; //<S2SV> while ( t > 0 ) { //<S2SV> * op ++ = * ip ++ ; //<S2SV> t -- ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> eof_found : //<S2SV> * out_len = op - out ; //<S2SV> return ( t != 3 ? LZO_E_ERROR : //<S2SV> ip == ip_end ? LZO_E_OK : //<S2SV> ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ; //<S2SV> input_overrun : //<S2SV> * out_len = op - out ; //<S2SV> return LZO_E_INPUT_OVERRUN ; //<S2SV> output_overrun : //<S2SV> * out_len = op - out ; //<S2SV> return LZO_E_OUTPUT_OVERRUN ; //<S2SV> lookbehind_overrun : //<S2SV> * out_len = op - out ; //<S2SV> return LZO_E_LOOKBEHIND_OVERRUN ; //<S2SV> } //<S2SV> 