static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , //<S2SV> struct vsock_sock * vsk , //<S2SV> struct msghdr * msg , size_t len , //<S2SV> int flags ) //<S2SV> { //<S2SV> int err ; //<S2SV> int noblock ; //<S2SV> struct vmci_datagram * dg ; //<S2SV> size_t payload_len ; //<S2SV> struct sk_buff * skb ; //<S2SV> noblock = flags & MSG_DONTWAIT ; //<S2SV> if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> msg -> msg_namelen = 0 ; //<S2SV> err = 0 ; //<S2SV> skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( ! skb ) //<S2SV> return - EAGAIN ; //<S2SV> dg = ( struct vmci_datagram * ) skb -> data ; //<S2SV> if ( ! dg ) //<S2SV> goto out ; //<S2SV> payload_len = dg -> payload_size ; //<S2SV> if ( payload_len != skb -> len - sizeof ( * dg ) ) { //<S2SV> err = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( payload_len > len ) { //<S2SV> payload_len = len ; //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> } //<S2SV> err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , //<S2SV> payload_len ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> if ( msg -> msg_name ) { //<S2SV> struct sockaddr_vm * vm_addr ; //<S2SV> vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; //<S2SV> vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; //<S2SV> msg -> msg_namelen = sizeof ( * vm_addr ) ; //<S2SV> } //<S2SV> err = payload_len ; //<S2SV> out : //<S2SV> skb_free_datagram ( & vsk -> sk , skb ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 