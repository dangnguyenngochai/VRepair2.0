static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) //<S2SV> { //<S2SV> struct ipv6_txoptions * opt_to_free = NULL ; //<S2SV> struct ipv6_txoptions opt_space ; //<S2SV> DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; //<S2SV> struct in6_addr * daddr , * final_p , final ; //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct raw6_sock * rp = raw6_sk ( sk ) ; //<S2SV> struct ipv6_txoptions * opt = NULL ; //<S2SV> struct ip6_flowlabel * flowlabel = NULL ; //<S2SV> struct dst_entry * dst = NULL ; //<S2SV> struct raw6_frag_vec rfv ; //<S2SV> struct flowi6 fl6 ; //<S2SV> int addr_len = msg -> msg_namelen ; //<S2SV> int hlimit = - 1 ; //<S2SV> int tclass = - 1 ; //<S2SV> int dontfrag = - 1 ; //<S2SV> u16 proto ; //<S2SV> int err ; //<S2SV> if ( len > INT_MAX ) //<S2SV> return - EMSGSIZE ; //<S2SV> if ( msg -> msg_flags & MSG_OOB ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; //<S2SV> fl6 . flowi6_mark = sk -> sk_mark ; //<S2SV> if ( sin6 ) { //<S2SV> if ( addr_len < SIN6_LEN_RFC2133 ) //<S2SV> return - EINVAL ; //<S2SV> if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) //<S2SV> return - EAFNOSUPPORT ; //<S2SV> proto = ntohs ( sin6 -> sin6_port ) ; //<S2SV> if ( ! proto ) //<S2SV> proto = inet -> inet_num ; //<S2SV> else if ( proto != inet -> inet_num ) //<S2SV> return - EINVAL ; //<S2SV> if ( proto > 255 ) //<S2SV> return - EINVAL ; //<S2SV> daddr = & sin6 -> sin6_addr ; //<S2SV> if ( np -> sndflow ) { //<S2SV> fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; //<S2SV> if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { //<S2SV> flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; //<S2SV> if ( ! flowlabel ) //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> if ( sk -> sk_state == TCP_ESTABLISHED && //<S2SV> ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) //<S2SV> daddr = & sk -> sk_v6_daddr ; //<S2SV> if ( addr_len >= sizeof ( struct sockaddr_in6 ) && //<S2SV> sin6 -> sin6_scope_id && //<S2SV> __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) //<S2SV> fl6 . flowi6_oif = sin6 -> sin6_scope_id ; //<S2SV> } else { //<S2SV> if ( sk -> sk_state != TCP_ESTABLISHED ) //<S2SV> return - EDESTADDRREQ ; //<S2SV> proto = inet -> inet_num ; //<S2SV> daddr = & sk -> sk_v6_daddr ; //<S2SV> fl6 . flowlabel = np -> flow_label ; //<S2SV> } //<S2SV> if ( fl6 . flowi6_oif == 0 ) //<S2SV> fl6 . flowi6_oif = sk -> sk_bound_dev_if ; //<S2SV> if ( msg -> msg_controllen ) { //<S2SV> opt = & opt_space ; //<S2SV> memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; //<S2SV> opt -> tot_len = sizeof ( struct ipv6_txoptions ) ; //<S2SV> err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , //<S2SV> & hlimit , & tclass , & dontfrag ) ; //<S2SV> if ( err < 0 ) { //<S2SV> fl6_sock_release ( flowlabel ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { //<S2SV> flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; //<S2SV> if ( ! flowlabel ) //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) //<S2SV> opt = NULL ; //<S2SV> } //<S2SV> if ( ! opt ) { //<S2SV> opt = txopt_get ( np ) ; //<S2SV> opt_to_free = opt ; //<S2SV> } //<S2SV> if ( flowlabel ) //<S2SV> opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; //<S2SV> opt = ipv6_fixup_options ( & opt_space , opt ) ; //<S2SV> fl6 . flowi6_proto = proto ; //<S2SV> rfv . msg = msg ; //<S2SV> rfv . hlen = 0 ; //<S2SV> err = rawv6_probe_proto_opt ( & rfv , & fl6 ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> if ( ! ipv6_addr_any ( daddr ) ) //<S2SV> fl6 . daddr = * daddr ; //<S2SV> else //<S2SV> fl6 . daddr . s6_addr [ 15 ] = 0x1 ; //<S2SV> if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) //<S2SV> fl6 . saddr = np -> saddr ; //<S2SV> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; //<S2SV> if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) //<S2SV> fl6 . flowi6_oif = np -> mcast_oif ; //<S2SV> else if ( ! fl6 . flowi6_oif ) //<S2SV> fl6 . flowi6_oif = np -> ucast_oif ; //<S2SV> security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; //<S2SV> if ( inet -> hdrincl ) //<S2SV> fl6 . flowi6_flags |= FLOWI_FLAG_KNOWN_NH ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; //<S2SV> if ( IS_ERR ( dst ) ) { //<S2SV> err = PTR_ERR ( dst ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( hlimit < 0 ) //<S2SV> hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; //<S2SV> if ( tclass < 0 ) //<S2SV> tclass = np -> tclass ; //<S2SV> if ( dontfrag < 0 ) //<S2SV> dontfrag = np -> dontfrag ; //<S2SV> if ( msg -> msg_flags & MSG_CONFIRM ) //<S2SV> goto do_confirm ; //<S2SV> back_from_confirm : //<S2SV> if ( inet -> hdrincl ) //<S2SV> err = rawv6_send_hdrinc ( sk , msg , len , & fl6 , & dst , msg -> msg_flags ) ; //<S2SV> else { //<S2SV> lock_sock ( sk ) ; //<S2SV> err = ip6_append_data ( sk , raw6_getfrag , & rfv , //<S2SV> len , 0 , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , //<S2SV> msg -> msg_flags , dontfrag ) ; //<S2SV> if ( err ) //<S2SV> ip6_flush_pending_frames ( sk ) ; //<S2SV> else if ( ! ( msg -> msg_flags & MSG_MORE ) ) //<S2SV> err = rawv6_push_pending_frames ( sk , & fl6 , rp ) ; //<S2SV> release_sock ( sk ) ; //<S2SV> } //<S2SV> done : //<S2SV> dst_release ( dst ) ; //<S2SV> out : //<S2SV> fl6_sock_release ( flowlabel ) ; //<S2SV> txopt_put ( opt_to_free ) ; //<S2SV> return err < 0 ? err : len ; //<S2SV> do_confirm : //<S2SV> dst_confirm ( dst ) ; //<S2SV> if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) //<S2SV> goto back_from_confirm ; //<S2SV> err = 0 ; //<S2SV> goto done ; //<S2SV> } //<S2SV> 