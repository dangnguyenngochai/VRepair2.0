struct dst_entry * inet6_csk_route_req ( const struct sock * sk , //<S2SV> struct flowi6 * fl6 , //<S2SV> const struct request_sock * req , //<S2SV> u8 proto ) //<S2SV> { //<S2SV> struct inet_request_sock * ireq = inet_rsk ( req ) ; //<S2SV> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct in6_addr * final_p , final ; //<S2SV> struct dst_entry * dst ; //<S2SV> memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; //<S2SV> fl6 -> flowi6_proto = proto ; //<S2SV> fl6 -> daddr = ireq -> ir_v6_rmt_addr ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> final_p = fl6_update_dst ( fl6 , rcu_dereference ( np -> opt ) , & final ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> fl6 -> saddr = ireq -> ir_v6_loc_addr ; //<S2SV> fl6 -> flowi6_oif = ireq -> ir_iif ; //<S2SV> fl6 -> flowi6_mark = ireq -> ir_mark ; //<S2SV> fl6 -> fl6_dport = ireq -> ir_rmt_port ; //<S2SV> fl6 -> fl6_sport = htons ( ireq -> ir_num ) ; //<S2SV> security_req_classify_flow ( req , flowi6_to_flowi ( fl6 ) ) ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; //<S2SV> if ( IS_ERR ( dst ) ) //<S2SV> return NULL ; //<S2SV> return dst ; //<S2SV> } //<S2SV> 