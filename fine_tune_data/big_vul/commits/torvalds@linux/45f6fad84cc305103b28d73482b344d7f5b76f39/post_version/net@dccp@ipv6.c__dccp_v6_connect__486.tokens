static int dccp_v6_connect ( struct sock * sk , struct sockaddr * uaddr , //<S2SV> int addr_len ) //<S2SV> { //<S2SV> struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; //<S2SV> struct inet_connection_sock * icsk = inet_csk ( sk ) ; //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct dccp_sock * dp = dccp_sk ( sk ) ; //<S2SV> struct in6_addr * saddr = NULL , * final_p , final ; //<S2SV> struct ipv6_txoptions * opt ; //<S2SV> struct flowi6 fl6 ; //<S2SV> struct dst_entry * dst ; //<S2SV> int addr_type ; //<S2SV> int err ; //<S2SV> dp -> dccps_role = DCCP_ROLE_CLIENT ; //<S2SV> if ( addr_len < SIN6_LEN_RFC2133 ) //<S2SV> return - EINVAL ; //<S2SV> if ( usin -> sin6_family != AF_INET6 ) //<S2SV> return - EAFNOSUPPORT ; //<S2SV> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; //<S2SV> if ( np -> sndflow ) { //<S2SV> fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; //<S2SV> IP6_ECN_flow_init ( fl6 . flowlabel ) ; //<S2SV> if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { //<S2SV> struct ip6_flowlabel * flowlabel ; //<S2SV> flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; //<S2SV> if ( flowlabel == NULL ) //<S2SV> return - EINVAL ; //<S2SV> fl6_sock_release ( flowlabel ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ipv6_addr_any ( & usin -> sin6_addr ) ) //<S2SV> usin -> sin6_addr . s6_addr [ 15 ] = 1 ; //<S2SV> addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; //<S2SV> if ( addr_type & IPV6_ADDR_MULTICAST ) //<S2SV> return - ENETUNREACH ; //<S2SV> if ( addr_type & IPV6_ADDR_LINKLOCAL ) { //<S2SV> if ( addr_len >= sizeof ( struct sockaddr_in6 ) && //<S2SV> usin -> sin6_scope_id ) { //<S2SV> if ( sk -> sk_bound_dev_if && //<S2SV> sk -> sk_bound_dev_if != usin -> sin6_scope_id ) //<S2SV> return - EINVAL ; //<S2SV> sk -> sk_bound_dev_if = usin -> sin6_scope_id ; //<S2SV> } //<S2SV> if ( ! sk -> sk_bound_dev_if ) //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> sk -> sk_v6_daddr = usin -> sin6_addr ; //<S2SV> np -> flow_label = fl6 . flowlabel ; //<S2SV> if ( addr_type == IPV6_ADDR_MAPPED ) { //<S2SV> u32 exthdrlen = icsk -> icsk_ext_hdr_len ; //<S2SV> struct sockaddr_in sin ; //<S2SV> SOCK_DEBUG ( sk , "connect:<S2SV_blank>ipv4<S2SV_blank>mapped\\n" ) ; //<S2SV> if ( __ipv6_only_sock ( sk ) ) //<S2SV> return - ENETUNREACH ; //<S2SV> sin . sin_family = AF_INET ; //<S2SV> sin . sin_port = usin -> sin6_port ; //<S2SV> sin . sin_addr . s_addr = usin -> sin6_addr . s6_addr32 [ 3 ] ; //<S2SV> icsk -> icsk_af_ops = & dccp_ipv6_mapped ; //<S2SV> sk -> sk_backlog_rcv = dccp_v4_do_rcv ; //<S2SV> err = dccp_v4_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; //<S2SV> if ( err ) { //<S2SV> icsk -> icsk_ext_hdr_len = exthdrlen ; //<S2SV> icsk -> icsk_af_ops = & dccp_ipv6_af_ops ; //<S2SV> sk -> sk_backlog_rcv = dccp_v6_do_rcv ; //<S2SV> goto failure ; //<S2SV> } //<S2SV> np -> saddr = sk -> sk_v6_rcv_saddr ; //<S2SV> return err ; //<S2SV> } //<S2SV> if ( ! ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) //<S2SV> saddr = & sk -> sk_v6_rcv_saddr ; //<S2SV> fl6 . flowi6_proto = IPPROTO_DCCP ; //<S2SV> fl6 . daddr = sk -> sk_v6_daddr ; //<S2SV> fl6 . saddr = saddr ? * saddr : np -> saddr ; //<S2SV> fl6 . flowi6_oif = sk -> sk_bound_dev_if ; //<S2SV> fl6 . fl6_dport = usin -> sin6_port ; //<S2SV> fl6 . fl6_sport = inet -> inet_sport ; //<S2SV> security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; //<S2SV> opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; //<S2SV> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; //<S2SV> if ( IS_ERR ( dst ) ) { //<S2SV> err = PTR_ERR ( dst ) ; //<S2SV> goto failure ; //<S2SV> } //<S2SV> if ( saddr == NULL ) { //<S2SV> saddr = & fl6 . saddr ; //<S2SV> sk -> sk_v6_rcv_saddr = * saddr ; //<S2SV> } //<S2SV> np -> saddr = * saddr ; //<S2SV> inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; //<S2SV> __ip6_dst_store ( sk , dst , NULL , NULL ) ; //<S2SV> icsk -> icsk_ext_hdr_len = 0 ; //<S2SV> if ( opt ) //<S2SV> icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; //<S2SV> inet -> inet_dport = usin -> sin6_port ; //<S2SV> dccp_set_state ( sk , DCCP_REQUESTING ) ; //<S2SV> err = inet6_hash_connect ( & dccp_death_row , sk ) ; //<S2SV> if ( err ) //<S2SV> goto late_failure ; //<S2SV> dp -> dccps_iss = secure_dccpv6_sequence_number ( np -> saddr . s6_addr32 , //<S2SV> sk -> sk_v6_daddr . s6_addr32 , //<S2SV> inet -> inet_sport , //<S2SV> inet -> inet_dport ) ; //<S2SV> err = dccp_connect ( sk ) ; //<S2SV> if ( err ) //<S2SV> goto late_failure ; //<S2SV> return 0 ; //<S2SV> late_failure : //<S2SV> dccp_set_state ( sk , DCCP_CLOSED ) ; //<S2SV> __sk_dst_reset ( sk ) ; //<S2SV> failure : //<S2SV> inet -> inet_dport = 0 ; //<S2SV> sk -> sk_route_caps = 0 ; //<S2SV> return err ; //<S2SV> } //<S2SV> 