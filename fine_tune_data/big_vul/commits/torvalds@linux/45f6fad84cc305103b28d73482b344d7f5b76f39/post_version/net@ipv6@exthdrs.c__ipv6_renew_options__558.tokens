struct ipv6_txoptions * //<S2SV> ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , //<S2SV> int newtype , //<S2SV> struct ipv6_opt_hdr __user * newopt , int newoptlen ) //<S2SV> { //<S2SV> int tot_len = 0 ; //<S2SV> char * p ; //<S2SV> struct ipv6_txoptions * opt2 ; //<S2SV> int err ; //<S2SV> if ( opt ) { //<S2SV> if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) //<S2SV> tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; //<S2SV> if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) //<S2SV> tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; //<S2SV> if ( newtype != IPV6_RTHDR && opt -> srcrt ) //<S2SV> tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; //<S2SV> if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) //<S2SV> tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; //<S2SV> } //<S2SV> if ( newopt && newoptlen ) //<S2SV> tot_len += CMSG_ALIGN ( newoptlen ) ; //<S2SV> if ( ! tot_len ) //<S2SV> return NULL ; //<S2SV> tot_len += sizeof ( * opt2 ) ; //<S2SV> opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; //<S2SV> if ( ! opt2 ) //<S2SV> return ERR_PTR ( - ENOBUFS ) ; //<S2SV> memset ( opt2 , 0 , tot_len ) ; //<S2SV> atomic_set ( & opt2 -> refcnt , 1 ) ; //<S2SV> opt2 -> tot_len = tot_len ; //<S2SV> p = ( char * ) ( opt2 + 1 ) ; //<S2SV> err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , //<S2SV> newtype != IPV6_HOPOPTS , //<S2SV> & opt2 -> hopopt , & p ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , //<S2SV> newtype != IPV6_RTHDRDSTOPTS , //<S2SV> & opt2 -> dst0opt , & p ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> err = ipv6_renew_option ( opt ? opt -> srcrt : NULL , newopt , newoptlen , //<S2SV> newtype != IPV6_RTHDR , //<S2SV> ( struct ipv6_opt_hdr * * ) & opt2 -> srcrt , & p ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> err = ipv6_renew_option ( opt ? opt -> dst1opt : NULL , newopt , newoptlen , //<S2SV> newtype != IPV6_DSTOPTS , //<S2SV> & opt2 -> dst1opt , & p ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> opt2 -> opt_nflen = ( opt2 -> hopopt ? ipv6_optlen ( opt2 -> hopopt ) : 0 ) + //<S2SV> ( opt2 -> dst0opt ? ipv6_optlen ( opt2 -> dst0opt ) : 0 ) + //<S2SV> ( opt2 -> srcrt ? ipv6_optlen ( opt2 -> srcrt ) : 0 ) ; //<S2SV> opt2 -> opt_flen = ( opt2 -> dst1opt ? ipv6_optlen ( opt2 -> dst1opt ) : 0 ) ; //<S2SV> return opt2 ; //<S2SV> out : //<S2SV> sock_kfree_s ( sk , opt2 , opt2 -> tot_len ) ; //<S2SV> return ERR_PTR ( err ) ; //<S2SV> } //<S2SV> 