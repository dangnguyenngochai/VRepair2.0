static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) //<S2SV> { //<S2SV> struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct in6_addr * daddr , * final_p , final ; //<S2SV> struct dst_entry * dst ; //<S2SV> struct flowi6 fl6 ; //<S2SV> struct ip6_flowlabel * flowlabel = NULL ; //<S2SV> struct ipv6_txoptions * opt ; //<S2SV> int addr_type ; //<S2SV> int err ; //<S2SV> if ( usin -> sin6_family == AF_INET ) { //<S2SV> if ( __ipv6_only_sock ( sk ) ) //<S2SV> return - EAFNOSUPPORT ; //<S2SV> err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; //<S2SV> goto ipv4_connected ; //<S2SV> } //<S2SV> if ( addr_len < SIN6_LEN_RFC2133 ) //<S2SV> return - EINVAL ; //<S2SV> if ( usin -> sin6_family != AF_INET6 ) //<S2SV> return - EAFNOSUPPORT ; //<S2SV> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; //<S2SV> if ( np -> sndflow ) { //<S2SV> fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; //<S2SV> if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { //<S2SV> flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; //<S2SV> if ( ! flowlabel ) //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; //<S2SV> if ( addr_type == IPV6_ADDR_ANY ) { //<S2SV> usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; //<S2SV> } //<S2SV> daddr = & usin -> sin6_addr ; //<S2SV> if ( addr_type == IPV6_ADDR_MAPPED ) { //<S2SV> struct sockaddr_in sin ; //<S2SV> if ( __ipv6_only_sock ( sk ) ) { //<S2SV> err = - ENETUNREACH ; //<S2SV> goto out ; //<S2SV> } //<S2SV> sin . sin_family = AF_INET ; //<S2SV> sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; //<S2SV> sin . sin_port = usin -> sin6_port ; //<S2SV> err = __ip4_datagram_connect ( sk , //<S2SV> ( struct sockaddr * ) & sin , //<S2SV> sizeof ( sin ) ) ; //<S2SV> ipv4_connected : //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> ipv6_addr_set_v4mapped ( inet -> inet_daddr , & sk -> sk_v6_daddr ) ; //<S2SV> if ( ipv6_addr_any ( & np -> saddr ) || //<S2SV> ipv6_mapped_addr_any ( & np -> saddr ) ) //<S2SV> ipv6_addr_set_v4mapped ( inet -> inet_saddr , & np -> saddr ) ; //<S2SV> if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) || //<S2SV> ipv6_mapped_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { //<S2SV> ipv6_addr_set_v4mapped ( inet -> inet_rcv_saddr , //<S2SV> & sk -> sk_v6_rcv_saddr ) ; //<S2SV> if ( sk -> sk_prot -> rehash ) //<S2SV> sk -> sk_prot -> rehash ( sk ) ; //<S2SV> } //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( __ipv6_addr_needs_scope_id ( addr_type ) ) { //<S2SV> if ( addr_len >= sizeof ( struct sockaddr_in6 ) && //<S2SV> usin -> sin6_scope_id ) { //<S2SV> if ( sk -> sk_bound_dev_if && //<S2SV> sk -> sk_bound_dev_if != usin -> sin6_scope_id ) { //<S2SV> err = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> sk -> sk_bound_dev_if = usin -> sin6_scope_id ; //<S2SV> } //<S2SV> if ( ! sk -> sk_bound_dev_if && ( addr_type & IPV6_ADDR_MULTICAST ) ) //<S2SV> sk -> sk_bound_dev_if = np -> mcast_oif ; //<S2SV> if ( ! sk -> sk_bound_dev_if ) { //<S2SV> err = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> sk -> sk_v6_daddr = * daddr ; //<S2SV> np -> flow_label = fl6 . flowlabel ; //<S2SV> inet -> inet_dport = usin -> sin6_port ; //<S2SV> fl6 . flowi6_proto = sk -> sk_protocol ; //<S2SV> fl6 . daddr = sk -> sk_v6_daddr ; //<S2SV> fl6 . saddr = np -> saddr ; //<S2SV> fl6 . flowi6_oif = sk -> sk_bound_dev_if ; //<S2SV> fl6 . flowi6_mark = sk -> sk_mark ; //<S2SV> fl6 . fl6_dport = inet -> inet_dport ; //<S2SV> fl6 . fl6_sport = inet -> inet_sport ; //<S2SV> if ( ! fl6 . flowi6_oif && ( addr_type & IPV6_ADDR_MULTICAST ) ) //<S2SV> fl6 . flowi6_oif = np -> mcast_oif ; //<S2SV> security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> opt = flowlabel ? flowlabel -> opt : rcu_dereference ( np -> opt ) ; //<S2SV> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; //<S2SV> err = 0 ; //<S2SV> if ( IS_ERR ( dst ) ) { //<S2SV> err = PTR_ERR ( dst ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ipv6_addr_any ( & np -> saddr ) ) //<S2SV> np -> saddr = fl6 . saddr ; //<S2SV> if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { //<S2SV> sk -> sk_v6_rcv_saddr = fl6 . saddr ; //<S2SV> inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; //<S2SV> if ( sk -> sk_prot -> rehash ) //<S2SV> sk -> sk_prot -> rehash ( sk ) ; //<S2SV> } //<S2SV> ip6_dst_store ( sk , dst , //<S2SV> ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? //<S2SV> & sk -> sk_v6_daddr : NULL , //<S2SV> # ifdef CONFIG_IPV6_SUBTREES //<S2SV> ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? //<S2SV> & np -> saddr : //<S2SV> # endif //<S2SV> NULL ) ; //<S2SV> sk -> sk_state = TCP_ESTABLISHED ; //<S2SV> sk_set_txhash ( sk ) ; //<S2SV> out : //<S2SV> fl6_sock_release ( flowlabel ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 