int inet6_sk_rebuild_header ( struct sock * sk ) //<S2SV> { //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct dst_entry * dst ; //<S2SV> dst = __sk_dst_check ( sk , np -> dst_cookie ) ; //<S2SV> if ( ! dst ) { //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct in6_addr * final_p , final ; //<S2SV> struct flowi6 fl6 ; //<S2SV> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; //<S2SV> fl6 . flowi6_proto = sk -> sk_protocol ; //<S2SV> fl6 . daddr = sk -> sk_v6_daddr ; //<S2SV> fl6 . saddr = np -> saddr ; //<S2SV> fl6 . flowlabel = np -> flow_label ; //<S2SV> fl6 . flowi6_oif = sk -> sk_bound_dev_if ; //<S2SV> fl6 . flowi6_mark = sk -> sk_mark ; //<S2SV> fl6 . fl6_dport = inet -> inet_dport ; //<S2SV> fl6 . fl6_sport = inet -> inet_sport ; //<S2SV> security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , //<S2SV> & final ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; //<S2SV> if ( IS_ERR ( dst ) ) { //<S2SV> sk -> sk_route_caps = 0 ; //<S2SV> sk -> sk_err_soft = - PTR_ERR ( dst ) ; //<S2SV> return PTR_ERR ( dst ) ; //<S2SV> } //<S2SV> __ip6_dst_store ( sk , dst , NULL , NULL ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 