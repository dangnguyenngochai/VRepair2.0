static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , //<S2SV> struct sk_buff * skb , //<S2SV> struct request_sock * req , //<S2SV> struct dst_entry * dst , //<S2SV> struct request_sock * req_unhash , //<S2SV> bool * own_req ) //<S2SV> { //<S2SV> struct inet_request_sock * ireq = inet_rsk ( req ) ; //<S2SV> struct ipv6_pinfo * newnp ; //<S2SV> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct inet_sock * newinet ; //<S2SV> struct dccp6_sock * newdp6 ; //<S2SV> struct sock * newsk ; //<S2SV> if ( skb -> protocol == htons ( ETH_P_IP ) ) { //<S2SV> newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , //<S2SV> req_unhash , own_req ) ; //<S2SV> if ( newsk == NULL ) //<S2SV> return NULL ; //<S2SV> newdp6 = ( struct dccp6_sock * ) newsk ; //<S2SV> newinet = inet_sk ( newsk ) ; //<S2SV> newinet -> pinet6 = & newdp6 -> inet6 ; //<S2SV> newnp = inet6_sk ( newsk ) ; //<S2SV> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; //<S2SV> newnp -> saddr = newsk -> sk_v6_rcv_saddr ; //<S2SV> inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; //<S2SV> newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; //<S2SV> newnp -> pktoptions = NULL ; //<S2SV> newnp -> opt = NULL ; //<S2SV> newnp -> mcast_oif = inet6_iif ( skb ) ; //<S2SV> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; //<S2SV> dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; //<S2SV> return newsk ; //<S2SV> } //<S2SV> if ( sk_acceptq_is_full ( sk ) ) //<S2SV> goto out_overflow ; //<S2SV> if ( ! dst ) { //<S2SV> struct flowi6 fl6 ; //<S2SV> dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; //<S2SV> if ( ! dst ) //<S2SV> goto out ; //<S2SV> } //<S2SV> newsk = dccp_create_openreq_child ( sk , req , skb ) ; //<S2SV> if ( newsk == NULL ) //<S2SV> goto out_nonewsk ; //<S2SV> __ip6_dst_store ( newsk , dst , NULL , NULL ) ; //<S2SV> newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | //<S2SV> NETIF_F_TSO ) ; //<S2SV> newdp6 = ( struct dccp6_sock * ) newsk ; //<S2SV> newinet = inet_sk ( newsk ) ; //<S2SV> newinet -> pinet6 = & newdp6 -> inet6 ; //<S2SV> newnp = inet6_sk ( newsk ) ; //<S2SV> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; //<S2SV> newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; //<S2SV> newnp -> saddr = ireq -> ir_v6_loc_addr ; //<S2SV> newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; //<S2SV> newsk -> sk_bound_dev_if = ireq -> ir_iif ; //<S2SV> newinet -> inet_opt = NULL ; //<S2SV> newnp -> rxopt . all = np -> rxopt . all ; //<S2SV> newnp -> pktoptions = NULL ; //<S2SV> newnp -> opt = NULL ; //<S2SV> newnp -> mcast_oif = inet6_iif ( skb ) ; //<S2SV> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; //<S2SV> if ( np -> opt != NULL ) //<S2SV> newnp -> opt = ipv6_dup_options ( newsk , np -> opt ) ; //<S2SV> inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; //<S2SV> if ( newnp -> opt != NULL ) //<S2SV> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + //<S2SV> newnp -> opt -> opt_flen ) ; //<S2SV> dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; //<S2SV> newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; //<S2SV> newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; //<S2SV> if ( __inet_inherit_port ( sk , newsk ) < 0 ) { //<S2SV> inet_csk_prepare_forced_close ( newsk ) ; //<S2SV> dccp_done ( newsk ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; //<S2SV> if ( * own_req && ireq -> pktopts ) { //<S2SV> newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; //<S2SV> consume_skb ( ireq -> pktopts ) ; //<S2SV> ireq -> pktopts = NULL ; //<S2SV> if ( newnp -> pktoptions ) //<S2SV> skb_set_owner_r ( newnp -> pktoptions , newsk ) ; //<S2SV> } //<S2SV> return newsk ; //<S2SV> out_overflow : //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; //<S2SV> out_nonewsk : //<S2SV> dst_release ( dst ) ; //<S2SV> out : //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 