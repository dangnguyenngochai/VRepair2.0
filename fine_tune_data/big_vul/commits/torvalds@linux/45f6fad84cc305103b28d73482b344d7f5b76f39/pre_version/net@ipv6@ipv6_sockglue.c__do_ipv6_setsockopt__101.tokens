static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , //<S2SV> char __user * optval , unsigned int optlen ) //<S2SV> { //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct net * net = sock_net ( sk ) ; //<S2SV> int val , valbool ; //<S2SV> int retv = - ENOPROTOOPT ; //<S2SV> bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; //<S2SV> if ( ! optval ) //<S2SV> val = 0 ; //<S2SV> else { //<S2SV> if ( optlen >= sizeof ( int ) ) { //<S2SV> if ( get_user ( val , ( int __user * ) optval ) ) //<S2SV> return - EFAULT ; //<S2SV> } else //<S2SV> val = 0 ; //<S2SV> } //<S2SV> valbool = ( val != 0 ) ; //<S2SV> if ( ip6_mroute_opt ( optname ) ) //<S2SV> return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; //<S2SV> if ( needs_rtnl ) //<S2SV> rtnl_lock ( ) ; //<S2SV> lock_sock ( sk ) ; //<S2SV> switch ( optname ) { //<S2SV> case IPV6_ADDRFORM : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val == PF_INET ) { //<S2SV> struct ipv6_txoptions * opt ; //<S2SV> struct sk_buff * pktopt ; //<S2SV> if ( sk -> sk_type == SOCK_RAW ) //<S2SV> break ; //<S2SV> if ( sk -> sk_protocol == IPPROTO_UDP || //<S2SV> sk -> sk_protocol == IPPROTO_UDPLITE ) { //<S2SV> struct udp_sock * up = udp_sk ( sk ) ; //<S2SV> if ( up -> pending == AF_INET6 ) { //<S2SV> retv = - EBUSY ; //<S2SV> break ; //<S2SV> } //<S2SV> } else if ( sk -> sk_protocol != IPPROTO_TCP ) //<S2SV> break ; //<S2SV> if ( sk -> sk_state != TCP_ESTABLISHED ) { //<S2SV> retv = - ENOTCONN ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ipv6_only_sock ( sk ) || //<S2SV> ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { //<S2SV> retv = - EADDRNOTAVAIL ; //<S2SV> break ; //<S2SV> } //<S2SV> fl6_free_socklist ( sk ) ; //<S2SV> ipv6_sock_mc_close ( sk ) ; //<S2SV> sk_refcnt_debug_dec ( sk ) ; //<S2SV> if ( sk -> sk_protocol == IPPROTO_TCP ) { //<S2SV> struct inet_connection_sock * icsk = inet_csk ( sk ) ; //<S2SV> local_bh_disable ( ) ; //<S2SV> sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; //<S2SV> sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; //<S2SV> local_bh_enable ( ) ; //<S2SV> sk -> sk_prot = & tcp_prot ; //<S2SV> icsk -> icsk_af_ops = & ipv4_specific ; //<S2SV> sk -> sk_socket -> ops = & inet_stream_ops ; //<S2SV> sk -> sk_family = PF_INET ; //<S2SV> tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; //<S2SV> } else { //<S2SV> struct proto * prot = & udp_prot ; //<S2SV> if ( sk -> sk_protocol == IPPROTO_UDPLITE ) //<S2SV> prot = & udplite_prot ; //<S2SV> local_bh_disable ( ) ; //<S2SV> sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; //<S2SV> sock_prot_inuse_add ( net , prot , 1 ) ; //<S2SV> local_bh_enable ( ) ; //<S2SV> sk -> sk_prot = prot ; //<S2SV> sk -> sk_socket -> ops = & inet_dgram_ops ; //<S2SV> sk -> sk_family = PF_INET ; //<S2SV> } //<S2SV> opt = xchg ( & np -> opt , NULL ) ; //<S2SV> if ( opt ) //<S2SV> sock_kfree_s ( sk , opt , opt -> tot_len ) ; //<S2SV> pktopt = xchg ( & np -> pktoptions , NULL ) ; //<S2SV> kfree_skb ( pktopt ) ; //<S2SV> sk -> sk_destruct = inet_sock_destruct ; //<S2SV> sk_refcnt_debug_inc ( sk ) ; //<S2SV> module_put ( THIS_MODULE ) ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> goto e_inval ; //<S2SV> case IPV6_V6ONLY : //<S2SV> if ( optlen < sizeof ( int ) || //<S2SV> inet_sk ( sk ) -> inet_num ) //<S2SV> goto e_inval ; //<S2SV> sk -> sk_ipv6only = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVPKTINFO : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . rxinfo = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_2292PKTINFO : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . rxoinfo = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVHOPLIMIT : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . rxhlim = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_2292HOPLIMIT : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . rxohlim = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVRTHDR : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . srcrt = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_2292RTHDR : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . osrcrt = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVHOPOPTS : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . hopopts = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_2292HOPOPTS : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . ohopopts = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVDSTOPTS : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . dstopts = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_2292DSTOPTS : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . odstopts = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_TCLASS : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val < - 1 || val > 0xff ) //<S2SV> goto e_inval ; //<S2SV> if ( val == - 1 ) //<S2SV> val = 0 ; //<S2SV> np -> tclass = val ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVTCLASS : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . rxtclass = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_FLOWINFO : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . rxflow = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVPATHMTU : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . rxpmtu = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_TRANSPARENT : //<S2SV> if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && //<S2SV> ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { //<S2SV> retv = - EPERM ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> inet_sk ( sk ) -> transparent = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVORIGDSTADDR : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> rxopt . bits . rxorigdstaddr = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_HOPOPTS : //<S2SV> case IPV6_RTHDRDSTOPTS : //<S2SV> case IPV6_RTHDR : //<S2SV> case IPV6_DSTOPTS : //<S2SV> { //<S2SV> struct ipv6_txoptions * opt ; //<S2SV> if ( optlen == 0 ) //<S2SV> optval = NULL ; //<S2SV> else if ( ! optval ) //<S2SV> goto e_inval ; //<S2SV> else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || //<S2SV> optlen & 0x7 || optlen > 8 * 255 ) //<S2SV> goto e_inval ; //<S2SV> retv = - EPERM ; //<S2SV> if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) //<S2SV> break ; //<S2SV> opt = ipv6_renew_options ( sk , np -> opt , optname , //<S2SV> ( struct ipv6_opt_hdr __user * ) optval , //<S2SV> optlen ) ; //<S2SV> if ( IS_ERR ( opt ) ) { //<S2SV> retv = PTR_ERR ( opt ) ; //<S2SV> break ; //<S2SV> } //<S2SV> retv = - EINVAL ; //<S2SV> if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { //<S2SV> struct ipv6_rt_hdr * rthdr = opt -> srcrt ; //<S2SV> switch ( rthdr -> type ) { //<S2SV> # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) //<S2SV> case IPV6_SRCRT_TYPE_2 : //<S2SV> if ( rthdr -> hdrlen != 2 || //<S2SV> rthdr -> segments_left != 1 ) //<S2SV> goto sticky_done ; //<S2SV> break ; //<S2SV> # endif //<S2SV> default : //<S2SV> goto sticky_done ; //<S2SV> } //<S2SV> } //<S2SV> retv = 0 ; //<S2SV> opt = ipv6_update_options ( sk , opt ) ; //<S2SV> sticky_done : //<S2SV> if ( opt ) //<S2SV> sock_kfree_s ( sk , opt , opt -> tot_len ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_PKTINFO : //<S2SV> { //<S2SV> struct in6_pktinfo pkt ; //<S2SV> if ( optlen == 0 ) //<S2SV> goto e_inval ; //<S2SV> else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) //<S2SV> goto e_inval ; //<S2SV> if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { //<S2SV> retv = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) //<S2SV> goto e_inval ; //<S2SV> np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; //<S2SV> np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_2292PKTOPTIONS : //<S2SV> { //<S2SV> struct ipv6_txoptions * opt = NULL ; //<S2SV> struct msghdr msg ; //<S2SV> struct flowi6 fl6 ; //<S2SV> int junk ; //<S2SV> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; //<S2SV> fl6 . flowi6_oif = sk -> sk_bound_dev_if ; //<S2SV> fl6 . flowi6_mark = sk -> sk_mark ; //<S2SV> if ( optlen == 0 ) //<S2SV> goto update ; //<S2SV> retv = - EINVAL ; //<S2SV> if ( optlen > 64 * 1024 ) //<S2SV> break ; //<S2SV> opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; //<S2SV> retv = - ENOBUFS ; //<S2SV> if ( ! opt ) //<S2SV> break ; //<S2SV> memset ( opt , 0 , sizeof ( * opt ) ) ; //<S2SV> opt -> tot_len = sizeof ( * opt ) + optlen ; //<S2SV> retv = - EFAULT ; //<S2SV> if ( copy_from_user ( opt + 1 , optval , optlen ) ) //<S2SV> goto done ; //<S2SV> msg . msg_controllen = optlen ; //<S2SV> msg . msg_control = ( void * ) ( opt + 1 ) ; //<S2SV> retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , //<S2SV> & junk , & junk ) ; //<S2SV> if ( retv ) //<S2SV> goto done ; //<S2SV> update : //<S2SV> retv = 0 ; //<S2SV> opt = ipv6_update_options ( sk , opt ) ; //<S2SV> done : //<S2SV> if ( opt ) //<S2SV> sock_kfree_s ( sk , opt , opt -> tot_len ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_UNICAST_HOPS : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val > 255 || val < - 1 ) //<S2SV> goto e_inval ; //<S2SV> np -> hop_limit = val ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_MULTICAST_HOPS : //<S2SV> if ( sk -> sk_type == SOCK_STREAM ) //<S2SV> break ; //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val > 255 || val < - 1 ) //<S2SV> goto e_inval ; //<S2SV> np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_MULTICAST_LOOP : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val != valbool ) //<S2SV> goto e_inval ; //<S2SV> np -> mc_loop = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_UNICAST_IF : //<S2SV> { //<S2SV> struct net_device * dev = NULL ; //<S2SV> int ifindex ; //<S2SV> if ( optlen != sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; //<S2SV> if ( ifindex == 0 ) { //<S2SV> np -> ucast_oif = 0 ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> dev = dev_get_by_index ( net , ifindex ) ; //<S2SV> retv = - EADDRNOTAVAIL ; //<S2SV> if ( ! dev ) //<S2SV> break ; //<S2SV> dev_put ( dev ) ; //<S2SV> retv = - EINVAL ; //<S2SV> if ( sk -> sk_bound_dev_if ) //<S2SV> break ; //<S2SV> np -> ucast_oif = ifindex ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_MULTICAST_IF : //<S2SV> if ( sk -> sk_type == SOCK_STREAM ) //<S2SV> break ; //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val ) { //<S2SV> struct net_device * dev ; //<S2SV> if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) //<S2SV> goto e_inval ; //<S2SV> dev = dev_get_by_index ( net , val ) ; //<S2SV> if ( ! dev ) { //<S2SV> retv = - ENODEV ; //<S2SV> break ; //<S2SV> } //<S2SV> dev_put ( dev ) ; //<S2SV> } //<S2SV> np -> mcast_oif = val ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_ADD_MEMBERSHIP : //<S2SV> case IPV6_DROP_MEMBERSHIP : //<S2SV> { //<S2SV> struct ipv6_mreq mreq ; //<S2SV> if ( optlen < sizeof ( struct ipv6_mreq ) ) //<S2SV> goto e_inval ; //<S2SV> retv = - EPROTO ; //<S2SV> if ( inet_sk ( sk ) -> is_icsk ) //<S2SV> break ; //<S2SV> retv = - EFAULT ; //<S2SV> if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) //<S2SV> break ; //<S2SV> if ( optname == IPV6_ADD_MEMBERSHIP ) //<S2SV> retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; //<S2SV> else //<S2SV> retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_JOIN_ANYCAST : //<S2SV> case IPV6_LEAVE_ANYCAST : //<S2SV> { //<S2SV> struct ipv6_mreq mreq ; //<S2SV> if ( optlen < sizeof ( struct ipv6_mreq ) ) //<S2SV> goto e_inval ; //<S2SV> retv = - EFAULT ; //<S2SV> if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) //<S2SV> break ; //<S2SV> if ( optname == IPV6_JOIN_ANYCAST ) //<S2SV> retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; //<S2SV> else //<S2SV> retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case MCAST_JOIN_GROUP : //<S2SV> case MCAST_LEAVE_GROUP : //<S2SV> { //<S2SV> struct group_req greq ; //<S2SV> struct sockaddr_in6 * psin6 ; //<S2SV> if ( optlen < sizeof ( struct group_req ) ) //<S2SV> goto e_inval ; //<S2SV> retv = - EFAULT ; //<S2SV> if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) //<S2SV> break ; //<S2SV> if ( greq . gr_group . ss_family != AF_INET6 ) { //<S2SV> retv = - EADDRNOTAVAIL ; //<S2SV> break ; //<S2SV> } //<S2SV> psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; //<S2SV> if ( optname == MCAST_JOIN_GROUP ) //<S2SV> retv = ipv6_sock_mc_join ( sk , greq . gr_interface , //<S2SV> & psin6 -> sin6_addr ) ; //<S2SV> else //<S2SV> retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , //<S2SV> & psin6 -> sin6_addr ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case MCAST_JOIN_SOURCE_GROUP : //<S2SV> case MCAST_LEAVE_SOURCE_GROUP : //<S2SV> case MCAST_BLOCK_SOURCE : //<S2SV> case MCAST_UNBLOCK_SOURCE : //<S2SV> { //<S2SV> struct group_source_req greqs ; //<S2SV> int omode , add ; //<S2SV> if ( optlen < sizeof ( struct group_source_req ) ) //<S2SV> goto e_inval ; //<S2SV> if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { //<S2SV> retv = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( greqs . gsr_group . ss_family != AF_INET6 || //<S2SV> greqs . gsr_source . ss_family != AF_INET6 ) { //<S2SV> retv = - EADDRNOTAVAIL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( optname == MCAST_BLOCK_SOURCE ) { //<S2SV> omode = MCAST_EXCLUDE ; //<S2SV> add = 1 ; //<S2SV> } else if ( optname == MCAST_UNBLOCK_SOURCE ) { //<S2SV> omode = MCAST_EXCLUDE ; //<S2SV> add = 0 ; //<S2SV> } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { //<S2SV> struct sockaddr_in6 * psin6 ; //<S2SV> psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; //<S2SV> retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , //<S2SV> & psin6 -> sin6_addr ) ; //<S2SV> if ( retv && retv != - EADDRINUSE ) //<S2SV> break ; //<S2SV> omode = MCAST_INCLUDE ; //<S2SV> add = 1 ; //<S2SV> } else { //<S2SV> omode = MCAST_INCLUDE ; //<S2SV> add = 0 ; //<S2SV> } //<S2SV> retv = ip6_mc_source ( add , omode , sk , & greqs ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case MCAST_MSFILTER : //<S2SV> { //<S2SV> struct group_filter * gsf ; //<S2SV> if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) //<S2SV> goto e_inval ; //<S2SV> if ( optlen > sysctl_optmem_max ) { //<S2SV> retv = - ENOBUFS ; //<S2SV> break ; //<S2SV> } //<S2SV> gsf = kmalloc ( optlen , GFP_KERNEL ) ; //<S2SV> if ( ! gsf ) { //<S2SV> retv = - ENOBUFS ; //<S2SV> break ; //<S2SV> } //<S2SV> retv = - EFAULT ; //<S2SV> if ( copy_from_user ( gsf , optval , optlen ) ) { //<S2SV> kfree ( gsf ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( gsf -> gf_numsrc >= 0x1ffffffU || //<S2SV> gsf -> gf_numsrc > sysctl_mld_max_msf ) { //<S2SV> kfree ( gsf ) ; //<S2SV> retv = - ENOBUFS ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { //<S2SV> kfree ( gsf ) ; //<S2SV> retv = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> retv = ip6_mc_msfilter ( sk , gsf ) ; //<S2SV> kfree ( gsf ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_ROUTER_ALERT : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> retv = ip6_ra_control ( sk , val ) ; //<S2SV> break ; //<S2SV> case IPV6_MTU_DISCOVER : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) //<S2SV> goto e_inval ; //<S2SV> np -> pmtudisc = val ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_MTU : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val && val < IPV6_MIN_MTU ) //<S2SV> goto e_inval ; //<S2SV> np -> frag_size = val ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_RECVERR : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> recverr = valbool ; //<S2SV> if ( ! val ) //<S2SV> skb_queue_purge ( & sk -> sk_error_queue ) ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_FLOWINFO_SEND : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> np -> sndflow = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_FLOWLABEL_MGR : //<S2SV> retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; //<S2SV> break ; //<S2SV> case IPV6_IPSEC_POLICY : //<S2SV> case IPV6_XFRM_POLICY : //<S2SV> retv = - EPERM ; //<S2SV> if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) //<S2SV> break ; //<S2SV> retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; //<S2SV> break ; //<S2SV> case IPV6_ADDR_PREFERENCES : //<S2SV> { //<S2SV> unsigned int pref = 0 ; //<S2SV> unsigned int prefmask = ~ 0 ; //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> retv = - EINVAL ; //<S2SV> switch ( val & ( IPV6_PREFER_SRC_PUBLIC | //<S2SV> IPV6_PREFER_SRC_TMP | //<S2SV> IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { //<S2SV> case IPV6_PREFER_SRC_PUBLIC : //<S2SV> pref |= IPV6_PREFER_SRC_PUBLIC ; //<S2SV> break ; //<S2SV> case IPV6_PREFER_SRC_TMP : //<S2SV> pref |= IPV6_PREFER_SRC_TMP ; //<S2SV> break ; //<S2SV> case IPV6_PREFER_SRC_PUBTMP_DEFAULT : //<S2SV> break ; //<S2SV> case 0 : //<S2SV> goto pref_skip_pubtmp ; //<S2SV> default : //<S2SV> goto e_inval ; //<S2SV> } //<S2SV> prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | //<S2SV> IPV6_PREFER_SRC_TMP ) ; //<S2SV> pref_skip_pubtmp : //<S2SV> switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { //<S2SV> case IPV6_PREFER_SRC_HOME : //<S2SV> break ; //<S2SV> case IPV6_PREFER_SRC_COA : //<S2SV> pref |= IPV6_PREFER_SRC_COA ; //<S2SV> case 0 : //<S2SV> goto pref_skip_coa ; //<S2SV> default : //<S2SV> goto e_inval ; //<S2SV> } //<S2SV> prefmask &= ~ IPV6_PREFER_SRC_COA ; //<S2SV> pref_skip_coa : //<S2SV> switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { //<S2SV> case IPV6_PREFER_SRC_CGA : //<S2SV> case IPV6_PREFER_SRC_NONCGA : //<S2SV> case 0 : //<S2SV> break ; //<S2SV> default : //<S2SV> goto e_inval ; //<S2SV> } //<S2SV> np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_MINHOPCOUNT : //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> goto e_inval ; //<S2SV> if ( val < 0 || val > 255 ) //<S2SV> goto e_inval ; //<S2SV> np -> min_hopcount = val ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_DONTFRAG : //<S2SV> np -> dontfrag = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> case IPV6_AUTOFLOWLABEL : //<S2SV> np -> autoflowlabel = valbool ; //<S2SV> retv = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> if ( needs_rtnl ) //<S2SV> rtnl_unlock ( ) ; //<S2SV> return retv ; //<S2SV> e_inval : //<S2SV> release_sock ( sk ) ; //<S2SV> if ( needs_rtnl ) //<S2SV> rtnl_unlock ( ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> 