static int do_ipv6_getsockopt ( struct sock * sk , int level , int optname , //<S2SV> char __user * optval , int __user * optlen , unsigned int flags ) //<S2SV> { //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> int len ; //<S2SV> int val ; //<S2SV> if ( ip6_mroute_opt ( optname ) ) //<S2SV> return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ; //<S2SV> if ( get_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> switch ( optname ) { //<S2SV> case IPV6_ADDRFORM : //<S2SV> if ( sk -> sk_protocol != IPPROTO_UDP && //<S2SV> sk -> sk_protocol != IPPROTO_UDPLITE && //<S2SV> sk -> sk_protocol != IPPROTO_TCP ) //<S2SV> return - ENOPROTOOPT ; //<S2SV> if ( sk -> sk_state != TCP_ESTABLISHED ) //<S2SV> return - ENOTCONN ; //<S2SV> val = sk -> sk_family ; //<S2SV> break ; //<S2SV> case MCAST_MSFILTER : //<S2SV> { //<S2SV> struct group_filter gsf ; //<S2SV> int err ; //<S2SV> if ( len < GROUP_FILTER_SIZE ( 0 ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( gsf . gf_group . ss_family != AF_INET6 ) //<S2SV> return - EADDRNOTAVAIL ; //<S2SV> lock_sock ( sk ) ; //<S2SV> err = ip6_mc_msfget ( sk , & gsf , //<S2SV> ( struct group_filter __user * ) optval , optlen ) ; //<S2SV> release_sock ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> case IPV6_2292PKTOPTIONS : //<S2SV> { //<S2SV> struct msghdr msg ; //<S2SV> struct sk_buff * skb ; //<S2SV> if ( sk -> sk_type != SOCK_STREAM ) //<S2SV> return - ENOPROTOOPT ; //<S2SV> msg . msg_control = optval ; //<S2SV> msg . msg_controllen = len ; //<S2SV> msg . msg_flags = flags ; //<S2SV> lock_sock ( sk ) ; //<S2SV> skb = np -> pktoptions ; //<S2SV> if ( skb ) //<S2SV> ip6_datagram_recv_ctl ( sk , & msg , skb ) ; //<S2SV> release_sock ( sk ) ; //<S2SV> if ( ! skb ) { //<S2SV> if ( np -> rxopt . bits . rxinfo ) { //<S2SV> struct in6_pktinfo src_info ; //<S2SV> src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : //<S2SV> np -> sticky_pktinfo . ipi6_ifindex ; //<S2SV> src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : np -> sticky_pktinfo . ipi6_addr ; //<S2SV> put_cmsg ( & msg , SOL_IPV6 , IPV6_PKTINFO , sizeof ( src_info ) , & src_info ) ; //<S2SV> } //<S2SV> if ( np -> rxopt . bits . rxhlim ) { //<S2SV> int hlim = np -> mcast_hops ; //<S2SV> put_cmsg ( & msg , SOL_IPV6 , IPV6_HOPLIMIT , sizeof ( hlim ) , & hlim ) ; //<S2SV> } //<S2SV> if ( np -> rxopt . bits . rxtclass ) { //<S2SV> int tclass = ( int ) ip6_tclass ( np -> rcv_flowinfo ) ; //<S2SV> put_cmsg ( & msg , SOL_IPV6 , IPV6_TCLASS , sizeof ( tclass ) , & tclass ) ; //<S2SV> } //<S2SV> if ( np -> rxopt . bits . rxoinfo ) { //<S2SV> struct in6_pktinfo src_info ; //<S2SV> src_info . ipi6_ifindex = np -> mcast_oif ? np -> mcast_oif : //<S2SV> np -> sticky_pktinfo . ipi6_ifindex ; //<S2SV> src_info . ipi6_addr = np -> mcast_oif ? sk -> sk_v6_daddr : //<S2SV> np -> sticky_pktinfo . ipi6_addr ; //<S2SV> put_cmsg ( & msg , SOL_IPV6 , IPV6_2292PKTINFO , sizeof ( src_info ) , & src_info ) ; //<S2SV> } //<S2SV> if ( np -> rxopt . bits . rxohlim ) { //<S2SV> int hlim = np -> mcast_hops ; //<S2SV> put_cmsg ( & msg , SOL_IPV6 , IPV6_2292HOPLIMIT , sizeof ( hlim ) , & hlim ) ; //<S2SV> } //<S2SV> if ( np -> rxopt . bits . rxflow ) { //<S2SV> __be32 flowinfo = np -> rcv_flowinfo ; //<S2SV> put_cmsg ( & msg , SOL_IPV6 , IPV6_FLOWINFO , sizeof ( flowinfo ) , & flowinfo ) ; //<S2SV> } //<S2SV> } //<S2SV> len -= msg . msg_controllen ; //<S2SV> return put_user ( len , optlen ) ; //<S2SV> } //<S2SV> case IPV6_MTU : //<S2SV> { //<S2SV> struct dst_entry * dst ; //<S2SV> val = 0 ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> dst = __sk_dst_get ( sk ) ; //<S2SV> if ( dst ) //<S2SV> val = dst_mtu ( dst ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> if ( ! val ) //<S2SV> return - ENOTCONN ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_V6ONLY : //<S2SV> val = sk -> sk_ipv6only ; //<S2SV> break ; //<S2SV> case IPV6_RECVPKTINFO : //<S2SV> val = np -> rxopt . bits . rxinfo ; //<S2SV> break ; //<S2SV> case IPV6_2292PKTINFO : //<S2SV> val = np -> rxopt . bits . rxoinfo ; //<S2SV> break ; //<S2SV> case IPV6_RECVHOPLIMIT : //<S2SV> val = np -> rxopt . bits . rxhlim ; //<S2SV> break ; //<S2SV> case IPV6_2292HOPLIMIT : //<S2SV> val = np -> rxopt . bits . rxohlim ; //<S2SV> break ; //<S2SV> case IPV6_RECVRTHDR : //<S2SV> val = np -> rxopt . bits . srcrt ; //<S2SV> break ; //<S2SV> case IPV6_2292RTHDR : //<S2SV> val = np -> rxopt . bits . osrcrt ; //<S2SV> break ; //<S2SV> case IPV6_HOPOPTS : //<S2SV> case IPV6_RTHDRDSTOPTS : //<S2SV> case IPV6_RTHDR : //<S2SV> case IPV6_DSTOPTS : //<S2SV> { //<S2SV> lock_sock ( sk ) ; //<S2SV> len = ipv6_getsockopt_sticky ( sk , np -> opt , //<S2SV> optname , optval , len ) ; //<S2SV> release_sock ( sk ) ; //<S2SV> if ( len < 0 ) //<S2SV> return len ; //<S2SV> return put_user ( len , optlen ) ; //<S2SV> } //<S2SV> case IPV6_RECVHOPOPTS : //<S2SV> val = np -> rxopt . bits . hopopts ; //<S2SV> break ; //<S2SV> case IPV6_2292HOPOPTS : //<S2SV> val = np -> rxopt . bits . ohopopts ; //<S2SV> break ; //<S2SV> case IPV6_RECVDSTOPTS : //<S2SV> val = np -> rxopt . bits . dstopts ; //<S2SV> break ; //<S2SV> case IPV6_2292DSTOPTS : //<S2SV> val = np -> rxopt . bits . odstopts ; //<S2SV> break ; //<S2SV> case IPV6_TCLASS : //<S2SV> val = np -> tclass ; //<S2SV> break ; //<S2SV> case IPV6_RECVTCLASS : //<S2SV> val = np -> rxopt . bits . rxtclass ; //<S2SV> break ; //<S2SV> case IPV6_FLOWINFO : //<S2SV> val = np -> rxopt . bits . rxflow ; //<S2SV> break ; //<S2SV> case IPV6_RECVPATHMTU : //<S2SV> val = np -> rxopt . bits . rxpmtu ; //<S2SV> break ; //<S2SV> case IPV6_PATHMTU : //<S2SV> { //<S2SV> struct dst_entry * dst ; //<S2SV> struct ip6_mtuinfo mtuinfo ; //<S2SV> if ( len < sizeof ( mtuinfo ) ) //<S2SV> return - EINVAL ; //<S2SV> len = sizeof ( mtuinfo ) ; //<S2SV> memset ( & mtuinfo , 0 , sizeof ( mtuinfo ) ) ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> dst = __sk_dst_get ( sk ) ; //<S2SV> if ( dst ) //<S2SV> mtuinfo . ip6m_mtu = dst_mtu ( dst ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> if ( ! mtuinfo . ip6m_mtu ) //<S2SV> return - ENOTCONN ; //<S2SV> if ( put_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_to_user ( optval , & mtuinfo , len ) ) //<S2SV> return - EFAULT ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> case IPV6_TRANSPARENT : //<S2SV> val = inet_sk ( sk ) -> transparent ; //<S2SV> break ; //<S2SV> case IPV6_RECVORIGDSTADDR : //<S2SV> val = np -> rxopt . bits . rxorigdstaddr ; //<S2SV> break ; //<S2SV> case IPV6_UNICAST_HOPS : //<S2SV> case IPV6_MULTICAST_HOPS : //<S2SV> { //<S2SV> struct dst_entry * dst ; //<S2SV> if ( optname == IPV6_UNICAST_HOPS ) //<S2SV> val = np -> hop_limit ; //<S2SV> else //<S2SV> val = np -> mcast_hops ; //<S2SV> if ( val < 0 ) { //<S2SV> rcu_read_lock ( ) ; //<S2SV> dst = __sk_dst_get ( sk ) ; //<S2SV> if ( dst ) //<S2SV> val = ip6_dst_hoplimit ( dst ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> } //<S2SV> if ( val < 0 ) //<S2SV> val = sock_net ( sk ) -> ipv6 . devconf_all -> hop_limit ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPV6_MULTICAST_LOOP : //<S2SV> val = np -> mc_loop ; //<S2SV> break ; //<S2SV> case IPV6_MULTICAST_IF : //<S2SV> val = np -> mcast_oif ; //<S2SV> break ; //<S2SV> case IPV6_UNICAST_IF : //<S2SV> val = ( __force int ) htonl ( ( __u32 ) np -> ucast_oif ) ; //<S2SV> break ; //<S2SV> case IPV6_MTU_DISCOVER : //<S2SV> val = np -> pmtudisc ; //<S2SV> break ; //<S2SV> case IPV6_RECVERR : //<S2SV> val = np -> recverr ; //<S2SV> break ; //<S2SV> case IPV6_FLOWINFO_SEND : //<S2SV> val = np -> sndflow ; //<S2SV> break ; //<S2SV> case IPV6_FLOWLABEL_MGR : //<S2SV> { //<S2SV> struct in6_flowlabel_req freq ; //<S2SV> int flags ; //<S2SV> if ( len < sizeof ( freq ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & freq , optval , sizeof ( freq ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( freq . flr_action != IPV6_FL_A_GET ) //<S2SV> return - EINVAL ; //<S2SV> len = sizeof ( freq ) ; //<S2SV> flags = freq . flr_flags ; //<S2SV> memset ( & freq , 0 , sizeof ( freq ) ) ; //<S2SV> val = ipv6_flowlabel_opt_get ( sk , & freq , flags ) ; //<S2SV> if ( val < 0 ) //<S2SV> return val ; //<S2SV> if ( put_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_to_user ( optval , & freq , len ) ) //<S2SV> return - EFAULT ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> case IPV6_ADDR_PREFERENCES : //<S2SV> val = 0 ; //<S2SV> if ( np -> srcprefs & IPV6_PREFER_SRC_TMP ) //<S2SV> val |= IPV6_PREFER_SRC_TMP ; //<S2SV> else if ( np -> srcprefs & IPV6_PREFER_SRC_PUBLIC ) //<S2SV> val |= IPV6_PREFER_SRC_PUBLIC ; //<S2SV> else { //<S2SV> val |= IPV6_PREFER_SRC_PUBTMP_DEFAULT ; //<S2SV> } //<S2SV> if ( np -> srcprefs & IPV6_PREFER_SRC_COA ) //<S2SV> val |= IPV6_PREFER_SRC_COA ; //<S2SV> else //<S2SV> val |= IPV6_PREFER_SRC_HOME ; //<S2SV> break ; //<S2SV> case IPV6_MINHOPCOUNT : //<S2SV> val = np -> min_hopcount ; //<S2SV> break ; //<S2SV> case IPV6_DONTFRAG : //<S2SV> val = np -> dontfrag ; //<S2SV> break ; //<S2SV> case IPV6_AUTOFLOWLABEL : //<S2SV> val = np -> autoflowlabel ; //<S2SV> break ; //<S2SV> default : //<S2SV> return - ENOPROTOOPT ; //<S2SV> } //<S2SV> len = min_t ( unsigned int , sizeof ( int ) , len ) ; //<S2SV> if ( put_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_to_user ( optval , & val , len ) ) //<S2SV> return - EFAULT ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 