struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) //<S2SV> { //<S2SV> struct tcp_options_received tcp_opt ; //<S2SV> struct inet_request_sock * ireq ; //<S2SV> struct tcp_request_sock * treq ; //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct tcp_sock * tp = tcp_sk ( sk ) ; //<S2SV> const struct tcphdr * th = tcp_hdr ( skb ) ; //<S2SV> __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; //<S2SV> struct sock * ret = sk ; //<S2SV> struct request_sock * req ; //<S2SV> int mss ; //<S2SV> struct dst_entry * dst ; //<S2SV> __u8 rcv_wscale ; //<S2SV> if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) //<S2SV> goto out ; //<S2SV> if ( tcp_synq_no_recent_overflow ( sk ) ) //<S2SV> goto out ; //<S2SV> mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; //<S2SV> if ( mss == 0 ) { //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; //<S2SV> memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; //<S2SV> tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; //<S2SV> if ( ! cookie_timestamp_decode ( & tcp_opt ) ) //<S2SV> goto out ; //<S2SV> ret = NULL ; //<S2SV> req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; //<S2SV> if ( ! req ) //<S2SV> goto out ; //<S2SV> ireq = inet_rsk ( req ) ; //<S2SV> treq = tcp_rsk ( req ) ; //<S2SV> treq -> tfo_listener = false ; //<S2SV> if ( security_inet_conn_request ( sk , skb , req ) ) //<S2SV> goto out_free ; //<S2SV> req -> mss = mss ; //<S2SV> ireq -> ir_rmt_port = th -> source ; //<S2SV> ireq -> ir_num = ntohs ( th -> dest ) ; //<S2SV> ireq -> ir_v6_rmt_addr = ipv6_hdr ( skb ) -> saddr ; //<S2SV> ireq -> ir_v6_loc_addr = ipv6_hdr ( skb ) -> daddr ; //<S2SV> if ( ipv6_opt_accepted ( sk , skb , & TCP_SKB_CB ( skb ) -> header . h6 ) || //<S2SV> np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo || //<S2SV> np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) { //<S2SV> atomic_inc ( & skb -> users ) ; //<S2SV> ireq -> pktopts = skb ; //<S2SV> } //<S2SV> ireq -> ir_iif = sk -> sk_bound_dev_if ; //<S2SV> if ( ! sk -> sk_bound_dev_if && //<S2SV> ipv6_addr_type ( & ireq -> ir_v6_rmt_addr ) & IPV6_ADDR_LINKLOCAL ) //<S2SV> ireq -> ir_iif = tcp_v6_iif ( skb ) ; //<S2SV> ireq -> ir_mark = inet_request_mark ( sk , skb ) ; //<S2SV> req -> num_retrans = 0 ; //<S2SV> ireq -> snd_wscale = tcp_opt . snd_wscale ; //<S2SV> ireq -> sack_ok = tcp_opt . sack_ok ; //<S2SV> ireq -> wscale_ok = tcp_opt . wscale_ok ; //<S2SV> ireq -> tstamp_ok = tcp_opt . saw_tstamp ; //<S2SV> req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; //<S2SV> treq -> snt_synack . v64 = 0 ; //<S2SV> treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; //<S2SV> treq -> snt_isn = cookie ; //<S2SV> { //<S2SV> struct in6_addr * final_p , final ; //<S2SV> struct flowi6 fl6 ; //<S2SV> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; //<S2SV> fl6 . flowi6_proto = IPPROTO_TCP ; //<S2SV> fl6 . daddr = ireq -> ir_v6_rmt_addr ; //<S2SV> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; //<S2SV> fl6 . saddr = ireq -> ir_v6_loc_addr ; //<S2SV> fl6 . flowi6_oif = sk -> sk_bound_dev_if ; //<S2SV> fl6 . flowi6_mark = ireq -> ir_mark ; //<S2SV> fl6 . fl6_dport = ireq -> ir_rmt_port ; //<S2SV> fl6 . fl6_sport = inet_sk ( sk ) -> inet_sport ; //<S2SV> security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; //<S2SV> if ( IS_ERR ( dst ) ) //<S2SV> goto out_free ; //<S2SV> } //<S2SV> req -> rsk_window_clamp = tp -> window_clamp ? : dst_metric ( dst , RTAX_WINDOW ) ; //<S2SV> tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , //<S2SV> & req -> rsk_rcv_wnd , & req -> rsk_window_clamp , //<S2SV> ireq -> wscale_ok , & rcv_wscale , //<S2SV> dst_metric ( dst , RTAX_INITRWND ) ) ; //<S2SV> ireq -> rcv_wscale = rcv_wscale ; //<S2SV> ireq -> ecn_ok = cookie_ecn_ok ( & tcp_opt , sock_net ( sk ) , dst ) ; //<S2SV> ret = tcp_get_cookie_sock ( sk , skb , req , dst ) ; //<S2SV> out : //<S2SV> return ret ; //<S2SV> out_free : //<S2SV> reqsk_free ( req ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 