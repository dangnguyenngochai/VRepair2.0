static int iowarrior_probe ( struct usb_interface * interface , //<S2SV> const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct usb_device * udev = interface_to_usbdev ( interface ) ; //<S2SV> struct iowarrior * dev = NULL ; //<S2SV> struct usb_host_interface * iface_desc ; //<S2SV> struct usb_endpoint_descriptor * endpoint ; //<S2SV> int i ; //<S2SV> int retval = - ENOMEM ; //<S2SV> dev = kzalloc ( sizeof ( struct iowarrior ) , GFP_KERNEL ) ; //<S2SV> if ( dev == NULL ) { //<S2SV> dev_err ( & interface -> dev , "Out<S2SV_blank>of<S2SV_blank>memory\\n" ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> mutex_init ( & dev -> mutex ) ; //<S2SV> atomic_set ( & dev -> intr_idx , 0 ) ; //<S2SV> atomic_set ( & dev -> read_idx , 0 ) ; //<S2SV> spin_lock_init ( & dev -> intr_idx_lock ) ; //<S2SV> atomic_set ( & dev -> overflow_flag , 0 ) ; //<S2SV> init_waitqueue_head ( & dev -> read_wait ) ; //<S2SV> atomic_set ( & dev -> write_busy , 0 ) ; //<S2SV> init_waitqueue_head ( & dev -> write_wait ) ; //<S2SV> dev -> udev = udev ; //<S2SV> dev -> interface = interface ; //<S2SV> iface_desc = interface -> cur_altsetting ; //<S2SV> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; //<S2SV> for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { //<S2SV> endpoint = & iface_desc -> endpoint [ i ] . desc ; //<S2SV> if ( usb_endpoint_is_int_in ( endpoint ) ) //<S2SV> dev -> int_in_endpoint = endpoint ; //<S2SV> if ( usb_endpoint_is_int_out ( endpoint ) ) //<S2SV> dev -> int_out_endpoint = endpoint ; //<S2SV> } //<S2SV> dev -> report_size = usb_endpoint_maxp ( dev -> int_in_endpoint ) ; //<S2SV> if ( ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) && //<S2SV> ( dev -> product_id == USB_DEVICE_ID_CODEMERCS_IOW56 ) ) //<S2SV> dev -> report_size = 7 ; //<S2SV> dev -> int_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! dev -> int_in_urb ) { //<S2SV> dev_err ( & interface -> dev , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>interrupt_in_urb\\n" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> dev -> int_in_buffer = kmalloc ( dev -> report_size , GFP_KERNEL ) ; //<S2SV> if ( ! dev -> int_in_buffer ) { //<S2SV> dev_err ( & interface -> dev , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>int_in_buffer\\n" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> usb_fill_int_urb ( dev -> int_in_urb , dev -> udev , //<S2SV> usb_rcvintpipe ( dev -> udev , //<S2SV> dev -> int_in_endpoint -> bEndpointAddress ) , //<S2SV> dev -> int_in_buffer , dev -> report_size , //<S2SV> iowarrior_callback , dev , //<S2SV> dev -> int_in_endpoint -> bInterval ) ; //<S2SV> dev -> read_queue = //<S2SV> kmalloc ( ( ( dev -> report_size + 1 ) * MAX_INTERRUPT_BUFFER ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! dev -> read_queue ) { //<S2SV> dev_err ( & interface -> dev , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>read_queue\\n" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; //<S2SV> usb_string ( udev , udev -> descriptor . iSerialNumber , dev -> chip_serial , //<S2SV> sizeof ( dev -> chip_serial ) ) ; //<S2SV> if ( strlen ( dev -> chip_serial ) != 8 ) //<S2SV> memset ( dev -> chip_serial , 0x00 , sizeof ( dev -> chip_serial ) ) ; //<S2SV> if ( dev -> interface -> cur_altsetting -> desc . bInterfaceNumber == 0 ) { //<S2SV> usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , //<S2SV> 0x0A , //<S2SV> USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , //<S2SV> 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; //<S2SV> } //<S2SV> dev -> present = 1 ; //<S2SV> usb_set_intfdata ( interface , dev ) ; //<S2SV> retval = usb_register_dev ( interface , & iowarrior_class ) ; //<S2SV> if ( retval ) { //<S2SV> dev_err ( & interface -> dev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; //<S2SV> usb_set_intfdata ( interface , NULL ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> dev -> minor = interface -> minor ; //<S2SV> dev_info ( & interface -> dev , "IOWarrior<S2SV_blank>product=0x%x,<S2SV_blank>serial=%s<S2SV_blank>interface=%d<S2SV_blank>" //<S2SV> "now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>iowarrior%d\\n" , dev -> product_id , dev -> chip_serial , //<S2SV> iface_desc -> desc . bInterfaceNumber , dev -> minor - IOWARRIOR_MINOR_BASE ) ; //<S2SV> return retval ; //<S2SV> error : //<S2SV> iowarrior_delete ( dev ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 