static enum hrtimer_restart posix_timer_fn ( struct hrtimer * timer ) //<S2SV> { //<S2SV> struct k_itimer * timr ; //<S2SV> unsigned long flags ; //<S2SV> int si_private = 0 ; //<S2SV> enum hrtimer_restart ret = HRTIMER_NORESTART ; //<S2SV> timr = container_of ( timer , struct k_itimer , it . real . timer ) ; //<S2SV> spin_lock_irqsave ( & timr -> it_lock , flags ) ; //<S2SV> timr -> it_active = 0 ; //<S2SV> if ( timr -> it_interval != 0 ) //<S2SV> si_private = ++ timr -> it_requeue_pending ; //<S2SV> if ( posix_timer_event ( timr , si_private ) ) { //<S2SV> if ( timr -> it_interval != 0 ) { //<S2SV> ktime_t now = hrtimer_cb_get_time ( timer ) ; //<S2SV> # ifdef CONFIG_HIGH_RES_TIMERS //<S2SV> { //<S2SV> ktime_t kj = NSEC_PER_SEC / HZ ; //<S2SV> if ( timr -> it_interval < kj ) //<S2SV> now = ktime_add ( now , kj ) ; //<S2SV> } //<S2SV> # endif //<S2SV> timr -> it_overrun += hrtimer_forward ( timer , now , //<S2SV> timr -> it_interval ) ; //<S2SV> ret = HRTIMER_RESTART ; //<S2SV> ++ timr -> it_requeue_pending ; //<S2SV> timr -> it_active = 1 ; //<S2SV> } //<S2SV> } //<S2SV> unlock_timer ( timr , flags ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 