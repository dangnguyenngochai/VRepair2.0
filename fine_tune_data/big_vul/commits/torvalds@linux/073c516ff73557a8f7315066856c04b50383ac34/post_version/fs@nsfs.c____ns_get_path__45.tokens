static void * __ns_get_path ( struct path * path , struct ns_common * ns ) //<S2SV> { //<S2SV> struct vfsmount * mnt = nsfs_mnt ; //<S2SV> struct qstr qname = { . name = "" , } ; //<S2SV> struct dentry * dentry ; //<S2SV> struct inode * inode ; //<S2SV> unsigned long d ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> d = atomic_long_read ( & ns -> stashed ) ; //<S2SV> if ( ! d ) //<S2SV> goto slow ; //<S2SV> dentry = ( struct dentry * ) d ; //<S2SV> if ( ! lockref_get_not_dead ( & dentry -> d_lockref ) ) //<S2SV> goto slow ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> ns -> ops -> put ( ns ) ; //<S2SV> got_it : //<S2SV> path -> mnt = mntget ( mnt ) ; //<S2SV> path -> dentry = dentry ; //<S2SV> return NULL ; //<S2SV> slow : //<S2SV> rcu_read_unlock ( ) ; //<S2SV> inode = new_inode_pseudo ( mnt -> mnt_sb ) ; //<S2SV> if ( ! inode ) { //<S2SV> ns -> ops -> put ( ns ) ; //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> } //<S2SV> inode -> i_ino = ns -> inum ; //<S2SV> inode -> i_mtime = inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; //<S2SV> inode -> i_flags |= S_IMMUTABLE ; //<S2SV> inode -> i_mode = S_IFREG | S_IRUGO ; //<S2SV> inode -> i_fop = & ns_file_operations ; //<S2SV> inode -> i_private = ns ; //<S2SV> dentry = d_alloc_pseudo ( mnt -> mnt_sb , & qname ) ; //<S2SV> if ( ! dentry ) { //<S2SV> iput ( inode ) ; //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> } //<S2SV> d_instantiate ( dentry , inode ) ; //<S2SV> dentry -> d_flags |= DCACHE_RCUACCESS ; //<S2SV> dentry -> d_fsdata = ( void * ) ns -> ops ; //<S2SV> d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ; //<S2SV> if ( d ) { //<S2SV> d_delete ( dentry ) ; //<S2SV> dput ( dentry ) ; //<S2SV> cpu_relax ( ) ; //<S2SV> return ERR_PTR ( - EAGAIN ) ; //<S2SV> } //<S2SV> goto got_it ; //<S2SV> } //<S2SV> 