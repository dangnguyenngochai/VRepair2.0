static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , //<S2SV> struct pipe_inode_info * opipe , //<S2SV> size_t len , unsigned int flags ) //<S2SV> { //<S2SV> struct pipe_buffer * ibuf , * obuf ; //<S2SV> int ret = 0 , nbuf ; //<S2SV> bool input_wakeup = false ; //<S2SV> retry : //<S2SV> ret = ipipe_prep ( ipipe , flags ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> ret = opipe_prep ( opipe , flags ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> pipe_double_lock ( ipipe , opipe ) ; //<S2SV> do { //<S2SV> if ( ! opipe -> readers ) { //<S2SV> send_sig ( SIGPIPE , current , 0 ) ; //<S2SV> if ( ! ret ) //<S2SV> ret = - EPIPE ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! ipipe -> nrbufs && ! ipipe -> writers ) //<S2SV> break ; //<S2SV> if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { //<S2SV> if ( ret ) //<S2SV> break ; //<S2SV> if ( flags & SPLICE_F_NONBLOCK ) { //<S2SV> ret = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> pipe_unlock ( ipipe ) ; //<S2SV> pipe_unlock ( opipe ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> ibuf = ipipe -> bufs + ipipe -> curbuf ; //<S2SV> nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; //<S2SV> obuf = opipe -> bufs + nbuf ; //<S2SV> if ( len >= ibuf -> len ) { //<S2SV> * obuf = * ibuf ; //<S2SV> ibuf -> ops = NULL ; //<S2SV> opipe -> nrbufs ++ ; //<S2SV> ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; //<S2SV> ipipe -> nrbufs -- ; //<S2SV> input_wakeup = true ; //<S2SV> } else { //<S2SV> if ( ! pipe_buf_get ( ipipe , ibuf ) ) { //<S2SV> if ( ret == 0 ) //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> * obuf = * ibuf ; //<S2SV> obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; //<S2SV> obuf -> len = len ; //<S2SV> opipe -> nrbufs ++ ; //<S2SV> ibuf -> offset += obuf -> len ; //<S2SV> ibuf -> len -= obuf -> len ; //<S2SV> } //<S2SV> ret += obuf -> len ; //<S2SV> len -= obuf -> len ; //<S2SV> } while ( len ) ; //<S2SV> pipe_unlock ( ipipe ) ; //<S2SV> pipe_unlock ( opipe ) ; //<S2SV> if ( ret > 0 ) //<S2SV> wakeup_pipe_readers ( opipe ) ; //<S2SV> if ( input_wakeup ) //<S2SV> wakeup_pipe_writers ( ipipe ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 