static ssize_t //<S2SV> sg_write ( struct file * filp , const char __user * buf , size_t count , loff_t * ppos ) //<S2SV> { //<S2SV> int mxsize , cmd_size , k ; //<S2SV> int input_size , blocking ; //<S2SV> unsigned char opcode ; //<S2SV> Sg_device * sdp ; //<S2SV> Sg_fd * sfp ; //<S2SV> Sg_request * srp ; //<S2SV> struct sg_header old_hdr ; //<S2SV> sg_io_hdr_t * hp ; //<S2SV> unsigned char cmnd [ SG_MAX_CDB_SIZE ] ; //<S2SV> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) //<S2SV> return - ENXIO ; //<S2SV> SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , //<S2SV> "sg_write:<S2SV_blank>count=%d\\n" , ( int ) count ) ) ; //<S2SV> if ( atomic_read ( & sdp -> detaching ) ) //<S2SV> return - ENODEV ; //<S2SV> if ( ! ( ( filp -> f_flags & O_NONBLOCK ) || //<S2SV> scsi_block_when_processing_errors ( sdp -> device ) ) ) //<S2SV> return - ENXIO ; //<S2SV> if ( ! access_ok ( VERIFY_READ , buf , count ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( count < SZ_SG_HEADER ) //<S2SV> return - EIO ; //<S2SV> if ( __copy_from_user ( & old_hdr , buf , SZ_SG_HEADER ) ) //<S2SV> return - EFAULT ; //<S2SV> blocking = ! ( filp -> f_flags & O_NONBLOCK ) ; //<S2SV> if ( old_hdr . reply_len < 0 ) //<S2SV> return sg_new_write ( sfp , filp , buf , count , //<S2SV> blocking , 0 , 0 , NULL ) ; //<S2SV> if ( count < ( SZ_SG_HEADER + 6 ) ) //<S2SV> return - EIO ; //<S2SV> if ( ! ( srp = sg_add_request ( sfp ) ) ) { //<S2SV> SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sdp , //<S2SV> "sg_write:<S2SV_blank>queue<S2SV_blank>full\\n" ) ) ; //<S2SV> return - EDOM ; //<S2SV> } //<S2SV> buf += SZ_SG_HEADER ; //<S2SV> __get_user ( opcode , buf ) ; //<S2SV> if ( sfp -> next_cmd_len > 0 ) { //<S2SV> cmd_size = sfp -> next_cmd_len ; //<S2SV> sfp -> next_cmd_len = 0 ; //<S2SV> } else { //<S2SV> cmd_size = COMMAND_SIZE ( opcode ) ; //<S2SV> if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte ) //<S2SV> cmd_size = 12 ; //<S2SV> } //<S2SV> SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sdp , //<S2SV> "sg_write:<S2SV_blank><S2SV_blank><S2SV_blank>scsi<S2SV_blank>opcode=0x%02x,<S2SV_blank>cmd_size=%d\\n" , ( int ) opcode , cmd_size ) ) ; //<S2SV> input_size = count - cmd_size ; //<S2SV> mxsize = ( input_size > old_hdr . reply_len ) ? input_size : old_hdr . reply_len ; //<S2SV> mxsize -= SZ_SG_HEADER ; //<S2SV> input_size -= SZ_SG_HEADER ; //<S2SV> if ( input_size < 0 ) { //<S2SV> sg_remove_request ( sfp , srp ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> hp = & srp -> header ; //<S2SV> hp -> interface_id = '\\0' ; //<S2SV> hp -> cmd_len = ( unsigned char ) cmd_size ; //<S2SV> hp -> iovec_count = 0 ; //<S2SV> hp -> mx_sb_len = 0 ; //<S2SV> if ( input_size > 0 ) //<S2SV> hp -> dxfer_direction = ( old_hdr . reply_len > SZ_SG_HEADER ) ? //<S2SV> SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV ; //<S2SV> else //<S2SV> hp -> dxfer_direction = ( mxsize > 0 ) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE ; //<S2SV> hp -> dxfer_len = mxsize ; //<S2SV> if ( ( hp -> dxfer_direction == SG_DXFER_TO_DEV ) || //<S2SV> ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) ) //<S2SV> hp -> dxferp = ( char __user * ) buf + cmd_size ; //<S2SV> else //<S2SV> hp -> dxferp = NULL ; //<S2SV> hp -> sbp = NULL ; //<S2SV> hp -> timeout = old_hdr . reply_len ; //<S2SV> hp -> flags = input_size ; //<S2SV> hp -> pack_id = old_hdr . pack_id ; //<S2SV> hp -> usr_ptr = NULL ; //<S2SV> if ( __copy_from_user ( cmnd , buf , cmd_size ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) { //<S2SV> static char cmd [ TASK_COMM_LEN ] ; //<S2SV> if ( strcmp ( current -> comm , cmd ) ) { //<S2SV> printk_ratelimited ( KERN_WARNING //<S2SV> "sg_write:<S2SV_blank>data<S2SV_blank>in/out<S2SV_blank>%d/%d<S2SV_blank>bytes<S2SV_blank>" //<S2SV> "for<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>0x%x--<S2SV_blank>guessing<S2SV_blank>" //<S2SV> "data<S2SV_blank>in;\\n<S2SV_blank><S2SV_blank><S2SV_blank>program<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>setting<S2SV_blank>" //<S2SV> "count<S2SV_blank>and/or<S2SV_blank>reply_len<S2SV_blank>properly\\n" , //<S2SV> old_hdr . reply_len - ( int ) SZ_SG_HEADER , //<S2SV> input_size , ( unsigned int ) cmnd [ 0 ] , //<S2SV> current -> comm ) ; //<S2SV> strcpy ( cmd , current -> comm ) ; //<S2SV> } //<S2SV> } //<S2SV> k = sg_common_write ( sfp , srp , cmnd , sfp -> timeout , blocking ) ; //<S2SV> return ( k < 0 ) ? k : count ; //<S2SV> } //<S2SV> 