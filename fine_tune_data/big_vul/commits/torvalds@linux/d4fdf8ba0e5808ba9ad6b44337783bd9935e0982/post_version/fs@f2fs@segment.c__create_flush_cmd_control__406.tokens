int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) //<S2SV> { //<S2SV> dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; //<S2SV> struct flush_cmd_control * fcc ; //<S2SV> int err = 0 ; //<S2SV> if ( SM_I ( sbi ) -> fcc_info ) { //<S2SV> fcc = SM_I ( sbi ) -> fcc_info ; //<S2SV> goto init_thread ; //<S2SV> } //<S2SV> fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; //<S2SV> if ( ! fcc ) //<S2SV> return - ENOMEM ; //<S2SV> atomic_set ( & fcc -> issued_flush , 0 ) ; //<S2SV> atomic_set ( & fcc -> issing_flush , 0 ) ; //<S2SV> init_waitqueue_head ( & fcc -> flush_wait_queue ) ; //<S2SV> init_llist_head ( & fcc -> issue_list ) ; //<S2SV> SM_I ( sbi ) -> fcc_info = fcc ; //<S2SV> if ( ! test_opt ( sbi , FLUSH_MERGE ) ) //<S2SV> return err ; //<S2SV> init_thread : //<S2SV> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , //<S2SV> "f2fs_flush-%u:%u" , MAJOR ( dev ) , MINOR ( dev ) ) ; //<S2SV> if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { //<S2SV> err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; //<S2SV> kfree ( fcc ) ; //<S2SV> SM_I ( sbi ) -> fcc_info = NULL ; //<S2SV> return err ; //<S2SV> } //<S2SV> return err ; //<S2SV> } //<S2SV> 