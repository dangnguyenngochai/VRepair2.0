int build_segment_manager ( struct f2fs_sb_info * sbi ) //<S2SV> { //<S2SV> struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; //<S2SV> struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; //<S2SV> struct f2fs_sm_info * sm_info ; //<S2SV> int err ; //<S2SV> sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; //<S2SV> if ( ! sm_info ) //<S2SV> return - ENOMEM ; //<S2SV> sbi -> sm_info = sm_info ; //<S2SV> sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; //<S2SV> sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; //<S2SV> sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; //<S2SV> sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; //<S2SV> sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; //<S2SV> sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; //<S2SV> sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; //<S2SV> sm_info -> rec_prefree_segments = sm_info -> main_segments * //<S2SV> DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; //<S2SV> if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) //<S2SV> sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; //<S2SV> if ( ! test_opt ( sbi , LFS ) ) //<S2SV> sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; //<S2SV> sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; //<S2SV> sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ; //<S2SV> sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ; //<S2SV> sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ; //<S2SV> INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ; //<S2SV> if ( ! f2fs_readonly ( sbi -> sb ) ) { //<S2SV> err = create_flush_cmd_control ( sbi ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } //<S2SV> err = create_discard_cmd_control ( sbi ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = build_sit_info ( sbi ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = build_free_segmap ( sbi ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = build_curseg ( sbi ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> build_sit_entries ( sbi ) ; //<S2SV> init_free_segmap ( sbi ) ; //<S2SV> err = build_dirty_segmap ( sbi ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> init_min_max_mtime ( sbi ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 