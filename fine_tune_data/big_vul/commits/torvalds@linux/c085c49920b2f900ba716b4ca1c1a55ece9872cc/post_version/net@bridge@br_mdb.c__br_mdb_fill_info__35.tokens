static int br_mdb_fill_info ( struct sk_buff * skb , struct netlink_callback * cb , //<S2SV> struct net_device * dev ) //<S2SV> { //<S2SV> struct net_bridge * br = netdev_priv ( dev ) ; //<S2SV> struct net_bridge_mdb_htable * mdb ; //<S2SV> struct nlattr * nest , * nest2 ; //<S2SV> int i , err = 0 ; //<S2SV> int idx = 0 , s_idx = cb -> args [ 1 ] ; //<S2SV> if ( br -> multicast_disabled ) //<S2SV> return 0 ; //<S2SV> mdb = rcu_dereference ( br -> mdb ) ; //<S2SV> if ( ! mdb ) //<S2SV> return 0 ; //<S2SV> nest = nla_nest_start ( skb , MDBA_MDB ) ; //<S2SV> if ( nest == NULL ) //<S2SV> return - EMSGSIZE ; //<S2SV> for ( i = 0 ; i < mdb -> max ; i ++ ) { //<S2SV> struct net_bridge_mdb_entry * mp ; //<S2SV> struct net_bridge_port_group * p , * * pp ; //<S2SV> struct net_bridge_port * port ; //<S2SV> hlist_for_each_entry_rcu ( mp , & mdb -> mhash [ i ] , hlist [ mdb -> ver ] ) { //<S2SV> if ( idx < s_idx ) //<S2SV> goto skip ; //<S2SV> nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; //<S2SV> if ( nest2 == NULL ) { //<S2SV> err = - EMSGSIZE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> for ( pp = & mp -> ports ; //<S2SV> ( p = rcu_dereference ( * pp ) ) != NULL ; //<S2SV> pp = & p -> next ) { //<S2SV> port = p -> port ; //<S2SV> if ( port ) { //<S2SV> struct br_mdb_entry e ; //<S2SV> memset ( & e , 0 , sizeof ( e ) ) ; //<S2SV> e . ifindex = port -> dev -> ifindex ; //<S2SV> e . state = p -> state ; //<S2SV> if ( p -> addr . proto == htons ( ETH_P_IP ) ) //<S2SV> e . addr . u . ip4 = p -> addr . u . ip4 ; //<S2SV> # if IS_ENABLED ( CONFIG_IPV6 ) //<S2SV> if ( p -> addr . proto == htons ( ETH_P_IPV6 ) ) //<S2SV> e . addr . u . ip6 = p -> addr . u . ip6 ; //<S2SV> # endif //<S2SV> e . addr . proto = p -> addr . proto ; //<S2SV> if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( e ) , & e ) ) { //<S2SV> nla_nest_cancel ( skb , nest2 ) ; //<S2SV> err = - EMSGSIZE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> nla_nest_end ( skb , nest2 ) ; //<S2SV> skip : //<S2SV> idx ++ ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> cb -> args [ 1 ] = idx ; //<S2SV> nla_nest_end ( skb , nest ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 