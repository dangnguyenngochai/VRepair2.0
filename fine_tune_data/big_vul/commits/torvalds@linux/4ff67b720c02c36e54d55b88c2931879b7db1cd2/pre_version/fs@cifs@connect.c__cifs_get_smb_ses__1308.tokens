static struct cifsSesInfo * //<S2SV> cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) //<S2SV> { //<S2SV> int rc = - ENOMEM , xid ; //<S2SV> struct cifsSesInfo * ses ; //<S2SV> xid = GetXid ( ) ; //<S2SV> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; //<S2SV> if ( ses ) { //<S2SV> cFYI ( 1 , "Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)" , ses -> status ) ; //<S2SV> cifs_put_tcp_session ( server ) ; //<S2SV> mutex_lock ( & ses -> session_mutex ) ; //<S2SV> rc = cifs_negotiate_protocol ( xid , ses ) ; //<S2SV> if ( rc ) { //<S2SV> mutex_unlock ( & ses -> session_mutex ) ; //<S2SV> cifs_put_smb_ses ( ses ) ; //<S2SV> FreeXid ( xid ) ; //<S2SV> return ERR_PTR ( rc ) ; //<S2SV> } //<S2SV> if ( ses -> need_reconnect ) { //<S2SV> cFYI ( 1 , "Session<S2SV_blank>needs<S2SV_blank>reconnect" ) ; //<S2SV> rc = cifs_setup_session ( xid , ses , //<S2SV> volume_info -> local_nls ) ; //<S2SV> if ( rc ) { //<S2SV> mutex_unlock ( & ses -> session_mutex ) ; //<S2SV> cifs_put_smb_ses ( ses ) ; //<S2SV> FreeXid ( xid ) ; //<S2SV> return ERR_PTR ( rc ) ; //<S2SV> } //<S2SV> } //<S2SV> mutex_unlock ( & ses -> session_mutex ) ; //<S2SV> FreeXid ( xid ) ; //<S2SV> return ses ; //<S2SV> } //<S2SV> cFYI ( 1 , "Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found" ) ; //<S2SV> ses = sesInfoAlloc ( ) ; //<S2SV> if ( ses == NULL ) //<S2SV> goto get_ses_fail ; //<S2SV> ses -> server = server ; //<S2SV> if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) //<S2SV> sprintf ( ses -> serverName , "%pI6" , //<S2SV> & server -> addr . sockAddr6 . sin6_addr ) ; //<S2SV> else //<S2SV> sprintf ( ses -> serverName , "%pI4" , //<S2SV> & server -> addr . sockAddr . sin_addr . s_addr ) ; //<S2SV> if ( volume_info -> username ) //<S2SV> strncpy ( ses -> userName , volume_info -> username , //<S2SV> MAX_USERNAME_SIZE ) ; //<S2SV> if ( volume_info -> password ) { //<S2SV> ses -> password = kstrdup ( volume_info -> password , GFP_KERNEL ) ; //<S2SV> if ( ! ses -> password ) //<S2SV> goto get_ses_fail ; //<S2SV> } //<S2SV> if ( volume_info -> domainname ) { //<S2SV> int len = strlen ( volume_info -> domainname ) ; //<S2SV> ses -> domainName = kmalloc ( len + 1 , GFP_KERNEL ) ; //<S2SV> if ( ses -> domainName ) //<S2SV> strcpy ( ses -> domainName , volume_info -> domainname ) ; //<S2SV> } //<S2SV> ses -> linux_uid = volume_info -> linux_uid ; //<S2SV> ses -> overrideSecFlg = volume_info -> secFlg ; //<S2SV> mutex_lock ( & ses -> session_mutex ) ; //<S2SV> rc = cifs_negotiate_protocol ( xid , ses ) ; //<S2SV> if ( ! rc ) //<S2SV> rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; //<S2SV> mutex_unlock ( & ses -> session_mutex ) ; //<S2SV> if ( rc ) //<S2SV> goto get_ses_fail ; //<S2SV> write_lock ( & cifs_tcp_ses_lock ) ; //<S2SV> list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; //<S2SV> write_unlock ( & cifs_tcp_ses_lock ) ; //<S2SV> FreeXid ( xid ) ; //<S2SV> return ses ; //<S2SV> get_ses_fail : //<S2SV> sesInfoFree ( ses ) ; //<S2SV> FreeXid ( xid ) ; //<S2SV> return ERR_PTR ( rc ) ; //<S2SV> } //<S2SV> 