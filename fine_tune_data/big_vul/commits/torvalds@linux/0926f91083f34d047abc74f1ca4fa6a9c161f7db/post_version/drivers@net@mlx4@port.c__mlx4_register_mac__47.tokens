int mlx4_register_mac ( struct mlx4_dev * dev , u8 port , u64 mac , int * index ) //<S2SV> { //<S2SV> struct mlx4_mac_table * table = & mlx4_priv ( dev ) -> port [ port ] . mac_table ; //<S2SV> int i , err = 0 ; //<S2SV> int free = - 1 ; //<S2SV> mlx4_dbg ( dev , "Registering<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n" , ( unsigned long long ) mac ) ; //<S2SV> mutex_lock ( & table -> mutex ) ; //<S2SV> for ( i = 0 ; i < MLX4_MAX_MAC_NUM - 1 ; i ++ ) { //<S2SV> if ( free < 0 && ! table -> refs [ i ] ) { //<S2SV> free = i ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( mac == ( MLX4_MAC_MASK & be64_to_cpu ( table -> entries [ i ] ) ) ) { //<S2SV> * index = i ; //<S2SV> ++ table -> refs [ i ] ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> if ( free < 0 ) { //<S2SV> err = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> mlx4_dbg ( dev , "Free<S2SV_blank>MAC<S2SV_blank>index<S2SV_blank>is<S2SV_blank>%d\\n" , free ) ; //<S2SV> if ( table -> total == table -> max ) { //<S2SV> err = - ENOSPC ; //<S2SV> goto out ; //<S2SV> } //<S2SV> table -> refs [ free ] = 1 ; //<S2SV> table -> entries [ free ] = cpu_to_be64 ( mac | MLX4_MAC_VALID ) ; //<S2SV> err = mlx4_set_port_mac_table ( dev , port , table -> entries ) ; //<S2SV> if ( unlikely ( err ) ) { //<S2SV> mlx4_err ( dev , "Failed<S2SV_blank>adding<S2SV_blank>MAC:<S2SV_blank>0x%llx\\n" , ( unsigned long long ) mac ) ; //<S2SV> table -> refs [ free ] = 0 ; //<S2SV> table -> entries [ free ] = 0 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> * index = free ; //<S2SV> ++ table -> total ; //<S2SV> out : //<S2SV> mutex_unlock ( & table -> mutex ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 