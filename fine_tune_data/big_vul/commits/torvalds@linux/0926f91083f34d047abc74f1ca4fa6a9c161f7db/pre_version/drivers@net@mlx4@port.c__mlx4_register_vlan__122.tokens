int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) //<S2SV> { //<S2SV> struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; //<S2SV> int i , err = 0 ; //<S2SV> int free = - 1 ; //<S2SV> mutex_lock ( & table -> mutex ) ; //<S2SV> for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { //<S2SV> if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { //<S2SV> free = i ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( table -> refs [ i ] && //<S2SV> ( vlan == ( MLX4_VLAN_MASK & //<S2SV> be32_to_cpu ( table -> entries [ i ] ) ) ) ) { //<S2SV> * index = i ; //<S2SV> ++ table -> refs [ i ] ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> if ( table -> total == table -> max ) { //<S2SV> err = - ENOSPC ; //<S2SV> goto out ; //<S2SV> } //<S2SV> table -> refs [ free ] = 1 ; //<S2SV> table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; //<S2SV> err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; //<S2SV> if ( unlikely ( err ) ) { //<S2SV> mlx4_warn ( dev , "Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n" , vlan ) ; //<S2SV> table -> refs [ free ] = 0 ; //<S2SV> table -> entries [ free ] = 0 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> * index = free ; //<S2SV> ++ table -> total ; //<S2SV> out : //<S2SV> mutex_unlock ( & table -> mutex ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 