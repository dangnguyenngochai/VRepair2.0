static int nl80211_start_sched_scan ( struct sk_buff * skb , //<S2SV> struct genl_info * info ) //<S2SV> { //<S2SV> struct cfg80211_sched_scan_request * request ; //<S2SV> struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; //<S2SV> struct net_device * dev = info -> user_ptr [ 1 ] ; //<S2SV> struct nlattr * attr ; //<S2SV> struct wiphy * wiphy ; //<S2SV> int err , tmp , n_ssids = 0 , n_channels , i ; //<S2SV> u32 interval ; //<S2SV> enum ieee80211_band band ; //<S2SV> size_t ie_len ; //<S2SV> if ( ! ( rdev -> wiphy . flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN ) || //<S2SV> ! rdev -> ops -> sched_scan_start ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( rdev -> sched_scan_req ) //<S2SV> return - EINPROGRESS ; //<S2SV> if ( ! info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) //<S2SV> return - EINVAL ; //<S2SV> interval = nla_get_u32 ( info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) ; //<S2SV> if ( interval == 0 ) //<S2SV> return - EINVAL ; //<S2SV> wiphy = & rdev -> wiphy ; //<S2SV> if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { //<S2SV> n_channels = validate_scan_freqs ( //<S2SV> info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; //<S2SV> if ( ! n_channels ) //<S2SV> return - EINVAL ; //<S2SV> } else { //<S2SV> n_channels = 0 ; //<S2SV> for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) //<S2SV> if ( wiphy -> bands [ band ] ) //<S2SV> n_channels += wiphy -> bands [ band ] -> n_channels ; //<S2SV> } //<S2SV> if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) //<S2SV> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , //<S2SV> tmp ) //<S2SV> n_ssids ++ ; //<S2SV> if ( n_ssids > wiphy -> max_scan_ssids ) //<S2SV> return - EINVAL ; //<S2SV> if ( info -> attrs [ NL80211_ATTR_IE ] ) //<S2SV> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; //<S2SV> else //<S2SV> ie_len = 0 ; //<S2SV> if ( ie_len > wiphy -> max_scan_ie_len ) //<S2SV> return - EINVAL ; //<S2SV> request = kzalloc ( sizeof ( * request ) //<S2SV> + sizeof ( * request -> ssids ) * n_ssids //<S2SV> + sizeof ( * request -> channels ) * n_channels //<S2SV> + ie_len , GFP_KERNEL ) ; //<S2SV> if ( ! request ) //<S2SV> return - ENOMEM ; //<S2SV> if ( n_ssids ) //<S2SV> request -> ssids = ( void * ) & request -> channels [ n_channels ] ; //<S2SV> request -> n_ssids = n_ssids ; //<S2SV> if ( ie_len ) { //<S2SV> if ( request -> ssids ) //<S2SV> request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; //<S2SV> else //<S2SV> request -> ie = ( void * ) ( request -> channels + n_channels ) ; //<S2SV> } //<S2SV> i = 0 ; //<S2SV> if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { //<S2SV> nla_for_each_nested ( attr , //<S2SV> info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , //<S2SV> tmp ) { //<S2SV> struct ieee80211_channel * chan ; //<S2SV> chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; //<S2SV> if ( ! chan ) { //<S2SV> err = - EINVAL ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> if ( chan -> flags & IEEE80211_CHAN_DISABLED ) //<S2SV> continue ; //<S2SV> request -> channels [ i ] = chan ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> } else { //<S2SV> for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { //<S2SV> int j ; //<S2SV> if ( ! wiphy -> bands [ band ] ) //<S2SV> continue ; //<S2SV> for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { //<S2SV> struct ieee80211_channel * chan ; //<S2SV> chan = & wiphy -> bands [ band ] -> channels [ j ] ; //<S2SV> if ( chan -> flags & IEEE80211_CHAN_DISABLED ) //<S2SV> continue ; //<S2SV> request -> channels [ i ] = chan ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! i ) { //<S2SV> err = - EINVAL ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> request -> n_channels = i ; //<S2SV> i = 0 ; //<S2SV> if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { //<S2SV> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , //<S2SV> tmp ) { //<S2SV> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; //<S2SV> if ( request -> ssids [ i ] . ssid_len > //<S2SV> IEEE80211_MAX_SSID_LEN ) { //<S2SV> err = - EINVAL ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , //<S2SV> nla_len ( attr ) ) ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> } //<S2SV> if ( info -> attrs [ NL80211_ATTR_IE ] ) { //<S2SV> request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; //<S2SV> memcpy ( ( void * ) request -> ie , //<S2SV> nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , //<S2SV> request -> ie_len ) ; //<S2SV> } //<S2SV> request -> dev = dev ; //<S2SV> request -> wiphy = & rdev -> wiphy ; //<S2SV> request -> interval = interval ; //<S2SV> err = rdev -> ops -> sched_scan_start ( & rdev -> wiphy , dev , request ) ; //<S2SV> if ( ! err ) { //<S2SV> rdev -> sched_scan_req = request ; //<S2SV> nl80211_send_sched_scan ( rdev , dev , //<S2SV> NL80211_CMD_START_SCHED_SCAN ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> out_free : //<S2SV> kfree ( request ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 