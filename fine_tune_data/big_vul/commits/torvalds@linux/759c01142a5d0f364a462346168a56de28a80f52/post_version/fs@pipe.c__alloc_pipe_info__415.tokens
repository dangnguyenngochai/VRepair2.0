struct pipe_inode_info * alloc_pipe_info ( void ) //<S2SV> { //<S2SV> struct pipe_inode_info * pipe ; //<S2SV> pipe = kzalloc ( sizeof ( struct pipe_inode_info ) , GFP_KERNEL ) ; //<S2SV> if ( pipe ) { //<S2SV> unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; //<S2SV> struct user_struct * user = get_current_user ( ) ; //<S2SV> if ( ! too_many_pipe_buffers_hard ( user ) ) { //<S2SV> if ( too_many_pipe_buffers_soft ( user ) ) //<S2SV> pipe_bufs = 1 ; //<S2SV> pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * pipe_bufs , GFP_KERNEL ) ; //<S2SV> } //<S2SV> if ( pipe -> bufs ) { //<S2SV> init_waitqueue_head ( & pipe -> wait ) ; //<S2SV> pipe -> r_counter = pipe -> w_counter = 1 ; //<S2SV> pipe -> buffers = pipe_bufs ; //<S2SV> pipe -> user = user ; //<S2SV> account_pipe_buffers ( pipe , 0 , pipe_bufs ) ; //<S2SV> mutex_init ( & pipe -> mutex ) ; //<S2SV> return pipe ; //<S2SV> } //<S2SV> free_uid ( user ) ; //<S2SV> kfree ( pipe ) ; //<S2SV> } //<S2SV> return NULL ; //<S2SV> } //<S2SV> 