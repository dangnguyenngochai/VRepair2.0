long pipe_fcntl ( struct file * file , unsigned int cmd , unsigned long arg ) //<S2SV> { //<S2SV> struct pipe_inode_info * pipe ; //<S2SV> long ret ; //<S2SV> pipe = get_pipe_info ( file ) ; //<S2SV> if ( ! pipe ) //<S2SV> return - EBADF ; //<S2SV> __pipe_lock ( pipe ) ; //<S2SV> switch ( cmd ) { //<S2SV> case F_SETPIPE_SZ : { //<S2SV> unsigned int size , nr_pages ; //<S2SV> size = round_pipe_size ( arg ) ; //<S2SV> nr_pages = size >> PAGE_SHIFT ; //<S2SV> ret = - EINVAL ; //<S2SV> if ( ! nr_pages ) //<S2SV> goto out ; //<S2SV> if ( ! capable ( CAP_SYS_RESOURCE ) && size > pipe_max_size ) { //<S2SV> ret = - EPERM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = pipe_set_size ( pipe , nr_pages ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case F_GETPIPE_SZ : //<S2SV> ret = pipe -> buffers * PAGE_SIZE ; //<S2SV> break ; //<S2SV> default : //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> out : //<S2SV> __pipe_unlock ( pipe ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 