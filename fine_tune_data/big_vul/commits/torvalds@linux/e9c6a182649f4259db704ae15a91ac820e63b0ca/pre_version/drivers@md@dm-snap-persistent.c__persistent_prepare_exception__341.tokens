static int persistent_prepare_exception ( struct dm_exception_store * store , //<S2SV> struct dm_exception * e ) //<S2SV> { //<S2SV> struct pstore * ps = get_info ( store ) ; //<S2SV> uint32_t stride ; //<S2SV> chunk_t next_free ; //<S2SV> sector_t size = get_dev_size ( dm_snap_cow ( store -> snap ) -> bdev ) ; //<S2SV> if ( size < ( ( ps -> next_free + 1 ) * store -> chunk_size ) ) //<S2SV> return - ENOSPC ; //<S2SV> e -> new_chunk = ps -> next_free ; //<S2SV> stride = ( ps -> exceptions_per_area + 1 ) ; //<S2SV> next_free = ++ ps -> next_free ; //<S2SV> if ( sector_div ( next_free , stride ) == 1 ) //<S2SV> ps -> next_free ++ ; //<S2SV> atomic_inc ( & ps -> pending_count ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 