static int udf_read_inode ( struct inode * inode , bool hidden_inode ) //<S2SV> { //<S2SV> struct buffer_head * bh = NULL ; //<S2SV> struct fileEntry * fe ; //<S2SV> struct extendedFileEntry * efe ; //<S2SV> uint16_t ident ; //<S2SV> struct udf_inode_info * iinfo = UDF_I ( inode ) ; //<S2SV> struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; //<S2SV> struct kernel_lb_addr * iloc = & iinfo -> i_location ; //<S2SV> unsigned int link_count ; //<S2SV> unsigned int indirections = 0 ; //<S2SV> int ret = - EIO ; //<S2SV> reread : //<S2SV> if ( iloc -> logicalBlockNum >= //<S2SV> sbi -> s_partmaps [ iloc -> partitionReferenceNum ] . s_partition_len ) { //<S2SV> udf_debug ( "block=%d,<S2SV_blank>partition=%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n" , //<S2SV> iloc -> logicalBlockNum , iloc -> partitionReferenceNum ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; //<S2SV> if ( ! bh ) { //<S2SV> udf_err ( inode -> i_sb , "(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n" , inode -> i_ino ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && //<S2SV> ident != TAG_IDENT_USE ) { //<S2SV> udf_err ( inode -> i_sb , "(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n" , //<S2SV> inode -> i_ino , ident ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> fe = ( struct fileEntry * ) bh -> b_data ; //<S2SV> efe = ( struct extendedFileEntry * ) bh -> b_data ; //<S2SV> if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { //<S2SV> struct buffer_head * ibh ; //<S2SV> ibh = udf_read_ptagged ( inode -> i_sb , iloc , 1 , & ident ) ; //<S2SV> if ( ident == TAG_IDENT_IE && ibh ) { //<S2SV> struct kernel_lb_addr loc ; //<S2SV> struct indirectEntry * ie ; //<S2SV> ie = ( struct indirectEntry * ) ibh -> b_data ; //<S2SV> loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; //<S2SV> if ( ie -> indirectICB . extLength ) { //<S2SV> brelse ( ibh ) ; //<S2SV> memcpy ( & iinfo -> i_location , & loc , //<S2SV> sizeof ( struct kernel_lb_addr ) ) ; //<S2SV> if ( ++ indirections > UDF_MAX_ICB_NESTING ) { //<S2SV> udf_err ( inode -> i_sb , //<S2SV> "too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy" //<S2SV> "<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n" , //<S2SV> UDF_MAX_ICB_NESTING ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> brelse ( bh ) ; //<S2SV> goto reread ; //<S2SV> } //<S2SV> } //<S2SV> brelse ( ibh ) ; //<S2SV> } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { //<S2SV> udf_err ( inode -> i_sb , "unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n" , //<S2SV> le16_to_cpu ( fe -> icbTag . strategyType ) ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) //<S2SV> iinfo -> i_strat4096 = 0 ; //<S2SV> else //<S2SV> iinfo -> i_strat4096 = 1 ; //<S2SV> iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & //<S2SV> ICBTAG_FLAG_AD_MASK ; //<S2SV> iinfo -> i_unique = 0 ; //<S2SV> iinfo -> i_lenEAttr = 0 ; //<S2SV> iinfo -> i_lenExtents = 0 ; //<S2SV> iinfo -> i_lenAlloc = 0 ; //<S2SV> iinfo -> i_next_alloc_block = 0 ; //<S2SV> iinfo -> i_next_alloc_goal = 0 ; //<S2SV> if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { //<S2SV> iinfo -> i_efe = 1 ; //<S2SV> iinfo -> i_use = 0 ; //<S2SV> ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - //<S2SV> sizeof ( struct extendedFileEntry ) ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> memcpy ( iinfo -> i_ext . i_data , //<S2SV> bh -> b_data + sizeof ( struct extendedFileEntry ) , //<S2SV> inode -> i_sb -> s_blocksize - //<S2SV> sizeof ( struct extendedFileEntry ) ) ; //<S2SV> } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { //<S2SV> iinfo -> i_efe = 0 ; //<S2SV> iinfo -> i_use = 0 ; //<S2SV> ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - //<S2SV> sizeof ( struct fileEntry ) ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> memcpy ( iinfo -> i_ext . i_data , //<S2SV> bh -> b_data + sizeof ( struct fileEntry ) , //<S2SV> inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; //<S2SV> } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { //<S2SV> iinfo -> i_efe = 0 ; //<S2SV> iinfo -> i_use = 1 ; //<S2SV> iinfo -> i_lenAlloc = le32_to_cpu ( //<S2SV> ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> //<S2SV> lengthAllocDescs ) ; //<S2SV> ret = udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - //<S2SV> sizeof ( struct unallocSpaceEntry ) ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> memcpy ( iinfo -> i_ext . i_data , //<S2SV> bh -> b_data + sizeof ( struct unallocSpaceEntry ) , //<S2SV> inode -> i_sb -> s_blocksize - //<S2SV> sizeof ( struct unallocSpaceEntry ) ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> ret = - EIO ; //<S2SV> read_lock ( & sbi -> s_cred_lock ) ; //<S2SV> i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; //<S2SV> if ( ! uid_valid ( inode -> i_uid ) || //<S2SV> UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || //<S2SV> UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) //<S2SV> inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; //<S2SV> i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; //<S2SV> if ( ! gid_valid ( inode -> i_gid ) || //<S2SV> UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || //<S2SV> UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) //<S2SV> inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; //<S2SV> if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && //<S2SV> sbi -> s_fmode != UDF_INVALID_MODE ) //<S2SV> inode -> i_mode = sbi -> s_fmode ; //<S2SV> else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && //<S2SV> sbi -> s_dmode != UDF_INVALID_MODE ) //<S2SV> inode -> i_mode = sbi -> s_dmode ; //<S2SV> else //<S2SV> inode -> i_mode = udf_convert_permissions ( fe ) ; //<S2SV> inode -> i_mode &= ~ sbi -> s_umask ; //<S2SV> read_unlock ( & sbi -> s_cred_lock ) ; //<S2SV> link_count = le16_to_cpu ( fe -> fileLinkCount ) ; //<S2SV> if ( ! link_count ) { //<S2SV> if ( ! hidden_inode ) { //<S2SV> ret = - ESTALE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> link_count = 1 ; //<S2SV> } //<S2SV> set_nlink ( inode , link_count ) ; //<S2SV> inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; //<S2SV> iinfo -> i_lenExtents = inode -> i_size ; //<S2SV> if ( iinfo -> i_efe == 0 ) { //<S2SV> inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << //<S2SV> ( inode -> i_sb -> s_blocksize_bits - 9 ) ; //<S2SV> if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) //<S2SV> inode -> i_atime = sbi -> s_record_time ; //<S2SV> if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , //<S2SV> fe -> modificationTime ) ) //<S2SV> inode -> i_mtime = sbi -> s_record_time ; //<S2SV> if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) //<S2SV> inode -> i_ctime = sbi -> s_record_time ; //<S2SV> iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; //<S2SV> iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; //<S2SV> iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; //<S2SV> iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; //<S2SV> } else { //<S2SV> inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << //<S2SV> ( inode -> i_sb -> s_blocksize_bits - 9 ) ; //<S2SV> if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) //<S2SV> inode -> i_atime = sbi -> s_record_time ; //<S2SV> if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , //<S2SV> efe -> modificationTime ) ) //<S2SV> inode -> i_mtime = sbi -> s_record_time ; //<S2SV> if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) //<S2SV> iinfo -> i_crtime = sbi -> s_record_time ; //<S2SV> if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) //<S2SV> inode -> i_ctime = sbi -> s_record_time ; //<S2SV> iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; //<S2SV> iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; //<S2SV> iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; //<S2SV> iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; //<S2SV> } //<S2SV> inode -> i_generation = iinfo -> i_unique ; //<S2SV> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { //<S2SV> if ( iinfo -> i_lenAlloc != inode -> i_size ) //<S2SV> goto out ; //<S2SV> if ( inode -> i_size > inode -> i_sb -> s_blocksize - //<S2SV> udf_file_entry_alloc_offset ( inode ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> switch ( fe -> icbTag . fileType ) { //<S2SV> case ICBTAG_FILE_TYPE_DIRECTORY : //<S2SV> inode -> i_op = & udf_dir_inode_operations ; //<S2SV> inode -> i_fop = & udf_dir_operations ; //<S2SV> inode -> i_mode |= S_IFDIR ; //<S2SV> inc_nlink ( inode ) ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_REALTIME : //<S2SV> case ICBTAG_FILE_TYPE_REGULAR : //<S2SV> case ICBTAG_FILE_TYPE_UNDEF : //<S2SV> case ICBTAG_FILE_TYPE_VAT20 : //<S2SV> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) //<S2SV> inode -> i_data . a_ops = & udf_adinicb_aops ; //<S2SV> else //<S2SV> inode -> i_data . a_ops = & udf_aops ; //<S2SV> inode -> i_op = & udf_file_inode_operations ; //<S2SV> inode -> i_fop = & udf_file_operations ; //<S2SV> inode -> i_mode |= S_IFREG ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_BLOCK : //<S2SV> inode -> i_mode |= S_IFBLK ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_CHAR : //<S2SV> inode -> i_mode |= S_IFCHR ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_FIFO : //<S2SV> init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_SOCKET : //<S2SV> init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_SYMLINK : //<S2SV> inode -> i_data . a_ops = & udf_symlink_aops ; //<S2SV> inode -> i_op = & udf_symlink_inode_operations ; //<S2SV> inode -> i_mode = S_IFLNK | S_IRWXUGO ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_MAIN : //<S2SV> udf_debug ( "METADATA<S2SV_blank>FILE-----\\n" ) ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_MIRROR : //<S2SV> udf_debug ( "METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n" ) ; //<S2SV> break ; //<S2SV> case ICBTAG_FILE_TYPE_BITMAP : //<S2SV> udf_debug ( "METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> udf_err ( inode -> i_sb , "(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n" , //<S2SV> inode -> i_ino , fe -> icbTag . fileType ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { //<S2SV> struct deviceSpec * dsea = //<S2SV> ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; //<S2SV> if ( dsea ) { //<S2SV> init_special_inode ( inode , inode -> i_mode , //<S2SV> MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , //<S2SV> le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; //<S2SV> } else //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = 0 ; //<S2SV> out : //<S2SV> brelse ( bh ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 