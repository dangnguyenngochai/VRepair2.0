static int hci_sock_getsockopt ( struct socket * sock , int level , int optname , //<S2SV> char __user * optval , int __user * optlen ) //<S2SV> { //<S2SV> struct hci_ufilter uf ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> int len , opt , err = 0 ; //<S2SV> BT_DBG ( "sk<S2SV_blank>%p,<S2SV_blank>opt<S2SV_blank>%d" , sk , optname ) ; //<S2SV> if ( get_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( hci_pi ( sk ) -> channel != HCI_CHANNEL_RAW ) { //<S2SV> err = - EINVAL ; //<S2SV> goto done ; //<S2SV> } //<S2SV> switch ( optname ) { //<S2SV> case HCI_DATA_DIR : //<S2SV> if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_DIR ) //<S2SV> opt = 1 ; //<S2SV> else //<S2SV> opt = 0 ; //<S2SV> if ( put_user ( opt , optval ) ) //<S2SV> err = - EFAULT ; //<S2SV> break ; //<S2SV> case HCI_TIME_STAMP : //<S2SV> if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_TSTAMP ) //<S2SV> opt = 1 ; //<S2SV> else //<S2SV> opt = 0 ; //<S2SV> if ( put_user ( opt , optval ) ) //<S2SV> err = - EFAULT ; //<S2SV> break ; //<S2SV> case HCI_FILTER : //<S2SV> { //<S2SV> struct hci_filter * f = & hci_pi ( sk ) -> filter ; //<S2SV> memset ( & uf , 0 , sizeof ( uf ) ) ; //<S2SV> uf . type_mask = f -> type_mask ; //<S2SV> uf . opcode = f -> opcode ; //<S2SV> uf . event_mask [ 0 ] = * ( ( u32 * ) f -> event_mask + 0 ) ; //<S2SV> uf . event_mask [ 1 ] = * ( ( u32 * ) f -> event_mask + 1 ) ; //<S2SV> } //<S2SV> len = min_t ( unsigned int , len , sizeof ( uf ) ) ; //<S2SV> if ( copy_to_user ( optval , & uf , len ) ) //<S2SV> err = - EFAULT ; //<S2SV> break ; //<S2SV> default : //<S2SV> err = - ENOPROTOOPT ; //<S2SV> break ; //<S2SV> } //<S2SV> done : //<S2SV> release_sock ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 