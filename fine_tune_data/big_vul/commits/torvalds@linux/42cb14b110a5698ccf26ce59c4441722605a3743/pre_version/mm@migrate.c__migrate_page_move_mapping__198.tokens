int migrate_page_move_mapping ( struct address_space * mapping , //<S2SV> struct page * newpage , struct page * page , //<S2SV> struct buffer_head * head , enum migrate_mode mode , //<S2SV> int extra_count ) //<S2SV> { //<S2SV> int expected_count = 1 + extra_count ; //<S2SV> void * * pslot ; //<S2SV> if ( ! mapping ) { //<S2SV> if ( page_count ( page ) != expected_count ) //<S2SV> return - EAGAIN ; //<S2SV> set_page_memcg ( newpage , page_memcg ( page ) ) ; //<S2SV> newpage -> index = page -> index ; //<S2SV> newpage -> mapping = page -> mapping ; //<S2SV> if ( PageSwapBacked ( page ) ) //<S2SV> SetPageSwapBacked ( newpage ) ; //<S2SV> return MIGRATEPAGE_SUCCESS ; //<S2SV> } //<S2SV> spin_lock_irq ( & mapping -> tree_lock ) ; //<S2SV> pslot = radix_tree_lookup_slot ( & mapping -> page_tree , //<S2SV> page_index ( page ) ) ; //<S2SV> expected_count += 1 + page_has_private ( page ) ; //<S2SV> if ( page_count ( page ) != expected_count || //<S2SV> radix_tree_deref_slot_protected ( pslot , & mapping -> tree_lock ) != page ) { //<S2SV> spin_unlock_irq ( & mapping -> tree_lock ) ; //<S2SV> return - EAGAIN ; //<S2SV> } //<S2SV> if ( ! page_freeze_refs ( page , expected_count ) ) { //<S2SV> spin_unlock_irq ( & mapping -> tree_lock ) ; //<S2SV> return - EAGAIN ; //<S2SV> } //<S2SV> if ( mode == MIGRATE_ASYNC && head && //<S2SV> ! buffer_migrate_lock_buffers ( head , mode ) ) { //<S2SV> page_unfreeze_refs ( page , expected_count ) ; //<S2SV> spin_unlock_irq ( & mapping -> tree_lock ) ; //<S2SV> return - EAGAIN ; //<S2SV> } //<S2SV> set_page_memcg ( newpage , page_memcg ( page ) ) ; //<S2SV> newpage -> index = page -> index ; //<S2SV> newpage -> mapping = page -> mapping ; //<S2SV> if ( PageSwapBacked ( page ) ) //<S2SV> SetPageSwapBacked ( newpage ) ; //<S2SV> get_page ( newpage ) ; //<S2SV> if ( PageSwapCache ( page ) ) { //<S2SV> SetPageSwapCache ( newpage ) ; //<S2SV> set_page_private ( newpage , page_private ( page ) ) ; //<S2SV> } //<S2SV> radix_tree_replace_slot ( pslot , newpage ) ; //<S2SV> page_unfreeze_refs ( page , expected_count - 1 ) ; //<S2SV> __dec_zone_page_state ( page , NR_FILE_PAGES ) ; //<S2SV> __inc_zone_page_state ( newpage , NR_FILE_PAGES ) ; //<S2SV> if ( ! PageSwapCache ( page ) && PageSwapBacked ( page ) ) { //<S2SV> __dec_zone_page_state ( page , NR_SHMEM ) ; //<S2SV> __inc_zone_page_state ( newpage , NR_SHMEM ) ; //<S2SV> } //<S2SV> spin_unlock_irq ( & mapping -> tree_lock ) ; //<S2SV> return MIGRATEPAGE_SUCCESS ; //<S2SV> } //<S2SV> 