void migrate_page_copy ( struct page * newpage , struct page * page ) //<S2SV> { //<S2SV> int cpupid ; //<S2SV> if ( PageHuge ( page ) || PageTransHuge ( page ) ) //<S2SV> copy_huge_page ( newpage , page ) ; //<S2SV> else //<S2SV> copy_highpage ( newpage , page ) ; //<S2SV> if ( PageError ( page ) ) //<S2SV> SetPageError ( newpage ) ; //<S2SV> if ( PageReferenced ( page ) ) //<S2SV> SetPageReferenced ( newpage ) ; //<S2SV> if ( PageUptodate ( page ) ) //<S2SV> SetPageUptodate ( newpage ) ; //<S2SV> if ( TestClearPageActive ( page ) ) { //<S2SV> VM_BUG_ON_PAGE ( PageUnevictable ( page ) , page ) ; //<S2SV> SetPageActive ( newpage ) ; //<S2SV> } else if ( TestClearPageUnevictable ( page ) ) //<S2SV> SetPageUnevictable ( newpage ) ; //<S2SV> if ( PageChecked ( page ) ) //<S2SV> SetPageChecked ( newpage ) ; //<S2SV> if ( PageMappedToDisk ( page ) ) //<S2SV> SetPageMappedToDisk ( newpage ) ; //<S2SV> if ( PageDirty ( page ) ) { //<S2SV> clear_page_dirty_for_io ( page ) ; //<S2SV> if ( PageSwapBacked ( page ) ) //<S2SV> SetPageDirty ( newpage ) ; //<S2SV> else //<S2SV> __set_page_dirty_nobuffers ( newpage ) ; //<S2SV> } //<S2SV> if ( page_is_young ( page ) ) //<S2SV> set_page_young ( newpage ) ; //<S2SV> if ( page_is_idle ( page ) ) //<S2SV> set_page_idle ( newpage ) ; //<S2SV> cpupid = page_cpupid_xchg_last ( page , - 1 ) ; //<S2SV> page_cpupid_xchg_last ( newpage , cpupid ) ; //<S2SV> ksm_migrate_page ( newpage , page ) ; //<S2SV> if ( PageSwapCache ( page ) ) //<S2SV> ClearPageSwapCache ( page ) ; //<S2SV> ClearPagePrivate ( page ) ; //<S2SV> set_page_private ( page , 0 ) ; //<S2SV> if ( PageWriteback ( newpage ) ) //<S2SV> end_page_writeback ( newpage ) ; //<S2SV> } //<S2SV> 