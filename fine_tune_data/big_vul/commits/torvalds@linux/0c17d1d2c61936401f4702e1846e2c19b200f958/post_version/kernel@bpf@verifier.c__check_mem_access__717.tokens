static int check_mem_access ( struct bpf_verifier_env * env , int insn_idx , u32 regno , int off , //<S2SV> int bpf_size , enum bpf_access_type t , //<S2SV> int value_regno ) //<S2SV> { //<S2SV> struct bpf_verifier_state * state = env -> cur_state ; //<S2SV> struct bpf_reg_state * regs = cur_regs ( env ) ; //<S2SV> struct bpf_reg_state * reg = regs + regno ; //<S2SV> int size , err = 0 ; //<S2SV> size = bpf_size_to_bytes ( bpf_size ) ; //<S2SV> if ( size < 0 ) //<S2SV> return size ; //<S2SV> err = check_ptr_alignment ( env , reg , off , size ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> off += reg -> off ; //<S2SV> if ( reg -> type == PTR_TO_MAP_VALUE ) { //<S2SV> if ( t == BPF_WRITE && value_regno >= 0 && //<S2SV> is_pointer_value ( env , value_regno ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>map\\n" , value_regno ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> err = check_map_access ( env , regno , off , size , false ) ; //<S2SV> if ( ! err && t == BPF_READ && value_regno >= 0 ) //<S2SV> mark_reg_unknown ( env , regs , value_regno ) ; //<S2SV> } else if ( reg -> type == PTR_TO_CTX ) { //<S2SV> enum bpf_reg_type reg_type = SCALAR_VALUE ; //<S2SV> if ( t == BPF_WRITE && value_regno >= 0 && //<S2SV> is_pointer_value ( env , value_regno ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>ctx\\n" , value_regno ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( reg -> off ) { //<S2SV> verbose ( env , //<S2SV> "dereference<S2SV_blank>of<S2SV_blank>modified<S2SV_blank>ctx<S2SV_blank>ptr<S2SV_blank>R%d<S2SV_blank>off=%d+%d,<S2SV_blank>ctx+const<S2SV_blank>is<S2SV_blank>allowed,<S2SV_blank>ctx+const+const<S2SV_blank>is<S2SV_blank>not\\n" , //<S2SV> regno , reg -> off , off - reg -> off ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( ! tnum_is_const ( reg -> var_off ) || reg -> var_off . value ) { //<S2SV> char tn_buf [ 48 ] ; //<S2SV> tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; //<S2SV> verbose ( env , //<S2SV> "variable<S2SV_blank>ctx<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d" , //<S2SV> tn_buf , off , size ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> err = check_ctx_access ( env , insn_idx , off , size , t , & reg_type ) ; //<S2SV> if ( ! err && t == BPF_READ && value_regno >= 0 ) { //<S2SV> if ( reg_type == SCALAR_VALUE ) //<S2SV> mark_reg_unknown ( env , regs , value_regno ) ; //<S2SV> else //<S2SV> mark_reg_known_zero ( env , regs , //<S2SV> value_regno ) ; //<S2SV> regs [ value_regno ] . id = 0 ; //<S2SV> regs [ value_regno ] . off = 0 ; //<S2SV> regs [ value_regno ] . range = 0 ; //<S2SV> regs [ value_regno ] . type = reg_type ; //<S2SV> } //<S2SV> } else if ( reg -> type == PTR_TO_STACK ) { //<S2SV> if ( ! tnum_is_const ( reg -> var_off ) ) { //<S2SV> char tn_buf [ 48 ] ; //<S2SV> tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; //<S2SV> verbose ( env , "variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d" , //<S2SV> tn_buf , off , size ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> off += reg -> var_off . value ; //<S2SV> if ( off >= 0 || off < - MAX_BPF_STACK ) { //<S2SV> verbose ( env , "invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\n" , off , //<S2SV> size ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( env -> prog -> aux -> stack_depth < - off ) //<S2SV> env -> prog -> aux -> stack_depth = - off ; //<S2SV> if ( t == BPF_WRITE ) //<S2SV> err = check_stack_write ( env , state , off , size , //<S2SV> value_regno ) ; //<S2SV> else //<S2SV> err = check_stack_read ( env , state , off , size , //<S2SV> value_regno ) ; //<S2SV> } else if ( reg_is_pkt_pointer ( reg ) ) { //<S2SV> if ( t == BPF_WRITE && ! may_access_direct_pkt_data ( env , NULL , t ) ) { //<S2SV> verbose ( env , "cannot<S2SV_blank>write<S2SV_blank>into<S2SV_blank>packet\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( t == BPF_WRITE && value_regno >= 0 && //<S2SV> is_pointer_value ( env , value_regno ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>packet\\n" , //<S2SV> value_regno ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> err = check_packet_access ( env , regno , off , size , false ) ; //<S2SV> if ( ! err && t == BPF_READ && value_regno >= 0 ) //<S2SV> mark_reg_unknown ( env , regs , value_regno ) ; //<S2SV> } else { //<S2SV> verbose ( env , "R%d<S2SV_blank>invalid<S2SV_blank>mem<S2SV_blank>access<S2SV_blank>\'%s\'\\n" , regno , //<S2SV> reg_type_str [ reg -> type ] ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( ! err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ && //<S2SV> regs [ value_regno ] . type == SCALAR_VALUE ) { //<S2SV> coerce_reg_to_size ( & regs [ value_regno ] , size ) ; //<S2SV> } //<S2SV> return err ; //<S2SV> } //<S2SV> 