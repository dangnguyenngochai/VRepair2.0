int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) //<S2SV> { //<S2SV> unsigned int offset = sizeof ( struct ipv6hdr ) ; //<S2SV> unsigned int packet_len = skb_tail_pointer ( skb ) - //<S2SV> skb_network_header ( skb ) ; //<S2SV> int found_rhdr = 0 ; //<S2SV> * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; //<S2SV> while ( offset <= packet_len ) { //<S2SV> struct ipv6_opt_hdr * exthdr ; //<S2SV> unsigned int len ; //<S2SV> switch ( * * nexthdr ) { //<S2SV> case NEXTHDR_HOP : //<S2SV> break ; //<S2SV> case NEXTHDR_ROUTING : //<S2SV> found_rhdr = 1 ; //<S2SV> break ; //<S2SV> case NEXTHDR_DEST : //<S2SV> # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) //<S2SV> if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) //<S2SV> break ; //<S2SV> # endif //<S2SV> if ( found_rhdr ) //<S2SV> return offset ; //<S2SV> break ; //<S2SV> default : //<S2SV> return offset ; //<S2SV> } //<S2SV> if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) //<S2SV> return - EINVAL ; //<S2SV> exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + //<S2SV> offset ) ; //<S2SV> len = ipv6_optlen ( exthdr ) ; //<S2SV> if ( len + offset >= IPV6_MAXPLEN ) //<S2SV> return - EINVAL ; //<S2SV> offset += len ; //<S2SV> * nexthdr = & exthdr -> nexthdr ; //<S2SV> } //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> 