int propagate_mnt ( struct mount * dest_mnt , struct mountpoint * dest_mp , //<S2SV> struct mount * source_mnt , struct hlist_head * tree_list ) //<S2SV> { //<S2SV> struct mount * m , * n ; //<S2SV> int ret = 0 ; //<S2SV> user_ns = current -> nsproxy -> mnt_ns -> user_ns ; //<S2SV> last_dest = dest_mnt ; //<S2SV> last_source = source_mnt ; //<S2SV> mp = dest_mp ; //<S2SV> list = tree_list ; //<S2SV> dest_master = dest_mnt -> mnt_master ; //<S2SV> for ( n = next_peer ( dest_mnt ) ; n != dest_mnt ; n = next_peer ( n ) ) { //<S2SV> ret = propagate_one ( n ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> for ( m = next_group ( dest_mnt , dest_mnt ) ; m ; //<S2SV> m = next_group ( m , dest_mnt ) ) { //<S2SV> n = m ; //<S2SV> do { //<S2SV> ret = propagate_one ( n ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> n = next_peer ( n ) ; //<S2SV> } while ( n != m ) ; //<S2SV> } //<S2SV> out : //<S2SV> read_seqlock_excl ( & mount_lock ) ; //<S2SV> hlist_for_each_entry ( n , tree_list , mnt_hash ) { //<S2SV> m = n -> mnt_parent ; //<S2SV> if ( m -> mnt_master != dest_mnt -> mnt_master ) //<S2SV> CLEAR_MNT_MARK ( m -> mnt_master ) ; //<S2SV> } //<S2SV> read_sequnlock_excl ( & mount_lock ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 