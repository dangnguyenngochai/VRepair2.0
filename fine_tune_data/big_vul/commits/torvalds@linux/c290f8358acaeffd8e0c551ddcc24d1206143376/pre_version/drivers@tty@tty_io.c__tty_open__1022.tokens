static int tty_open ( struct inode * inode , struct file * filp ) //<S2SV> { //<S2SV> struct tty_struct * tty = NULL ; //<S2SV> int noctty , retval ; //<S2SV> struct tty_driver * driver ; //<S2SV> int index ; //<S2SV> dev_t device = inode -> i_rdev ; //<S2SV> unsigned saved_flags = filp -> f_flags ; //<S2SV> nonseekable_open ( inode , filp ) ; //<S2SV> retry_open : //<S2SV> noctty = filp -> f_flags & O_NOCTTY ; //<S2SV> index = - 1 ; //<S2SV> retval = 0 ; //<S2SV> mutex_lock ( & tty_mutex ) ; //<S2SV> tty_lock ( ) ; //<S2SV> if ( device == MKDEV ( TTYAUX_MAJOR , 0 ) ) { //<S2SV> tty = get_current_tty ( ) ; //<S2SV> if ( ! tty ) { //<S2SV> tty_unlock ( ) ; //<S2SV> mutex_unlock ( & tty_mutex ) ; //<S2SV> return - ENXIO ; //<S2SV> } //<S2SV> driver = tty_driver_kref_get ( tty -> driver ) ; //<S2SV> index = tty -> index ; //<S2SV> filp -> f_flags |= O_NONBLOCK ; //<S2SV> tty_kref_put ( tty ) ; //<S2SV> goto got_driver ; //<S2SV> } //<S2SV> # ifdef CONFIG_VT //<S2SV> if ( device == MKDEV ( TTY_MAJOR , 0 ) ) { //<S2SV> extern struct tty_driver * console_driver ; //<S2SV> driver = tty_driver_kref_get ( console_driver ) ; //<S2SV> index = fg_console ; //<S2SV> noctty = 1 ; //<S2SV> goto got_driver ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( device == MKDEV ( TTYAUX_MAJOR , 1 ) ) { //<S2SV> struct tty_driver * console_driver = console_device ( & index ) ; //<S2SV> if ( console_driver ) { //<S2SV> driver = tty_driver_kref_get ( console_driver ) ; //<S2SV> if ( driver ) { //<S2SV> filp -> f_flags |= O_NONBLOCK ; //<S2SV> noctty = 1 ; //<S2SV> goto got_driver ; //<S2SV> } //<S2SV> } //<S2SV> tty_unlock ( ) ; //<S2SV> mutex_unlock ( & tty_mutex ) ; //<S2SV> return - ENODEV ; //<S2SV> } //<S2SV> driver = get_tty_driver ( device , & index ) ; //<S2SV> if ( ! driver ) { //<S2SV> tty_unlock ( ) ; //<S2SV> mutex_unlock ( & tty_mutex ) ; //<S2SV> return - ENODEV ; //<S2SV> } //<S2SV> got_driver : //<S2SV> if ( ! tty ) { //<S2SV> tty = tty_driver_lookup_tty ( driver , inode , index ) ; //<S2SV> if ( IS_ERR ( tty ) ) { //<S2SV> tty_unlock ( ) ; //<S2SV> mutex_unlock ( & tty_mutex ) ; //<S2SV> return PTR_ERR ( tty ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( tty ) { //<S2SV> retval = tty_reopen ( tty ) ; //<S2SV> if ( retval ) //<S2SV> tty = ERR_PTR ( retval ) ; //<S2SV> } else //<S2SV> tty = tty_init_dev ( driver , index , 0 ) ; //<S2SV> mutex_unlock ( & tty_mutex ) ; //<S2SV> tty_driver_kref_put ( driver ) ; //<S2SV> if ( IS_ERR ( tty ) ) { //<S2SV> tty_unlock ( ) ; //<S2SV> return PTR_ERR ( tty ) ; //<S2SV> } //<S2SV> retval = tty_add_file ( tty , filp ) ; //<S2SV> if ( retval ) { //<S2SV> tty_unlock ( ) ; //<S2SV> tty_release ( inode , filp ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> check_tty_count ( tty , "tty_open" ) ; //<S2SV> if ( tty -> driver -> type == TTY_DRIVER_TYPE_PTY && //<S2SV> tty -> driver -> subtype == PTY_TYPE_MASTER ) //<S2SV> noctty = 1 ; //<S2SV> # ifdef TTY_DEBUG_HANGUP //<S2SV> printk ( KERN_DEBUG "opening<S2SV_blank>%s..." , tty -> name ) ; //<S2SV> # endif //<S2SV> if ( tty -> ops -> open ) //<S2SV> retval = tty -> ops -> open ( tty , filp ) ; //<S2SV> else //<S2SV> retval = - ENODEV ; //<S2SV> filp -> f_flags = saved_flags ; //<S2SV> if ( ! retval && test_bit ( TTY_EXCLUSIVE , & tty -> flags ) && //<S2SV> ! capable ( CAP_SYS_ADMIN ) ) //<S2SV> retval = - EBUSY ; //<S2SV> if ( retval ) { //<S2SV> # ifdef TTY_DEBUG_HANGUP //<S2SV> printk ( KERN_DEBUG "error<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>opening<S2SV_blank>%s..." , retval , //<S2SV> tty -> name ) ; //<S2SV> # endif //<S2SV> tty_unlock ( ) ; //<S2SV> tty_release ( inode , filp ) ; //<S2SV> if ( retval != - ERESTARTSYS ) //<S2SV> return retval ; //<S2SV> if ( signal_pending ( current ) ) //<S2SV> return retval ; //<S2SV> schedule ( ) ; //<S2SV> tty_lock ( ) ; //<S2SV> if ( filp -> f_op == & hung_up_tty_fops ) //<S2SV> filp -> f_op = & tty_fops ; //<S2SV> tty_unlock ( ) ; //<S2SV> goto retry_open ; //<S2SV> } //<S2SV> tty_unlock ( ) ; //<S2SV> mutex_lock ( & tty_mutex ) ; //<S2SV> tty_lock ( ) ; //<S2SV> spin_lock_irq ( & current -> sighand -> siglock ) ; //<S2SV> if ( ! noctty && //<S2SV> current -> signal -> leader && //<S2SV> ! current -> signal -> tty && //<S2SV> tty -> session == NULL ) //<S2SV> __proc_set_tty ( current , tty ) ; //<S2SV> spin_unlock_irq ( & current -> sighand -> siglock ) ; //<S2SV> tty_unlock ( ) ; //<S2SV> mutex_unlock ( & tty_mutex ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 