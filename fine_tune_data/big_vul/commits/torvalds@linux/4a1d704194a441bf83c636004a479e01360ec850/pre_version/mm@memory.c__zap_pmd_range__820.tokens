static inline unsigned long zap_pmd_range ( struct mmu_gather * tlb , //<S2SV> struct vm_area_struct * vma , pud_t * pud , //<S2SV> unsigned long addr , unsigned long end , //<S2SV> struct zap_details * details ) //<S2SV> { //<S2SV> pmd_t * pmd ; //<S2SV> unsigned long next ; //<S2SV> pmd = pmd_offset ( pud , addr ) ; //<S2SV> do { //<S2SV> next = pmd_addr_end ( addr , end ) ; //<S2SV> if ( pmd_trans_huge ( * pmd ) ) { //<S2SV> if ( next - addr != HPAGE_PMD_SIZE ) { //<S2SV> VM_BUG_ON ( ! rwsem_is_locked ( & tlb -> mm -> mmap_sem ) ) ; //<S2SV> split_huge_page_pmd ( vma -> vm_mm , pmd ) ; //<S2SV> } else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( pmd_none_or_clear_bad ( pmd ) ) //<S2SV> continue ; //<S2SV> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; //<S2SV> cond_resched ( ) ; //<S2SV> } while ( pmd ++ , addr = next , addr != end ) ; //<S2SV> return addr ; //<S2SV> } //<S2SV> 