static int //<S2SV> mountpoint_last ( struct nameidata * nd , struct path * path ) //<S2SV> { //<S2SV> int error = 0 ; //<S2SV> struct dentry * dentry ; //<S2SV> struct dentry * dir = nd -> path . dentry ; //<S2SV> if ( nd -> flags & LOOKUP_RCU ) { //<S2SV> if ( unlazy_walk ( nd , NULL ) ) { //<S2SV> error = - ECHILD ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> nd -> flags &= ~ LOOKUP_PARENT ; //<S2SV> if ( unlikely ( nd -> last_type != LAST_NORM ) ) { //<S2SV> error = handle_dots ( nd , nd -> last_type ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> dentry = dget ( nd -> path . dentry ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> mutex_lock ( & dir -> d_inode -> i_mutex ) ; //<S2SV> dentry = d_lookup ( dir , & nd -> last ) ; //<S2SV> if ( ! dentry ) { //<S2SV> dentry = d_alloc ( dir , & nd -> last ) ; //<S2SV> if ( ! dentry ) { //<S2SV> error = - ENOMEM ; //<S2SV> mutex_unlock ( & dir -> d_inode -> i_mutex ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> dentry = lookup_real ( dir -> d_inode , dentry , nd -> flags ) ; //<S2SV> error = PTR_ERR ( dentry ) ; //<S2SV> if ( IS_ERR ( dentry ) ) { //<S2SV> mutex_unlock ( & dir -> d_inode -> i_mutex ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> mutex_unlock ( & dir -> d_inode -> i_mutex ) ; //<S2SV> done : //<S2SV> if ( ! dentry -> d_inode || d_is_negative ( dentry ) ) { //<S2SV> error = - ENOENT ; //<S2SV> dput ( dentry ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> path -> dentry = dentry ; //<S2SV> path -> mnt = nd -> path . mnt ; //<S2SV> if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) //<S2SV> return 1 ; //<S2SV> mntget ( path -> mnt ) ; //<S2SV> follow_mount ( path ) ; //<S2SV> error = 0 ; //<S2SV> out : //<S2SV> terminate_walk ( nd ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 