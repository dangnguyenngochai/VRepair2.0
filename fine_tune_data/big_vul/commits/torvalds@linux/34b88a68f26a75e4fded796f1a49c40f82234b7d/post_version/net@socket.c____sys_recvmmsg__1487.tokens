int __sys_recvmmsg ( int fd , struct mmsghdr __user * mmsg , unsigned int vlen , //<S2SV> unsigned int flags , struct timespec * timeout ) //<S2SV> { //<S2SV> int fput_needed , err , datagrams ; //<S2SV> struct socket * sock ; //<S2SV> struct mmsghdr __user * entry ; //<S2SV> struct compat_mmsghdr __user * compat_entry ; //<S2SV> struct msghdr msg_sys ; //<S2SV> struct timespec end_time ; //<S2SV> if ( timeout && //<S2SV> poll_select_set_timeout ( & end_time , timeout -> tv_sec , //<S2SV> timeout -> tv_nsec ) ) //<S2SV> return - EINVAL ; //<S2SV> datagrams = 0 ; //<S2SV> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; //<S2SV> if ( ! sock ) //<S2SV> return err ; //<S2SV> err = sock_error ( sock -> sk ) ; //<S2SV> if ( err ) //<S2SV> goto out_put ; //<S2SV> entry = mmsg ; //<S2SV> compat_entry = ( struct compat_mmsghdr __user * ) mmsg ; //<S2SV> while ( datagrams < vlen ) { //<S2SV> if ( MSG_CMSG_COMPAT & flags ) { //<S2SV> err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) compat_entry , //<S2SV> & msg_sys , flags & ~ MSG_WAITFORONE , //<S2SV> datagrams ) ; //<S2SV> if ( err < 0 ) //<S2SV> break ; //<S2SV> err = __put_user ( err , & compat_entry -> msg_len ) ; //<S2SV> ++ compat_entry ; //<S2SV> } else { //<S2SV> err = ___sys_recvmsg ( sock , //<S2SV> ( struct user_msghdr __user * ) entry , //<S2SV> & msg_sys , flags & ~ MSG_WAITFORONE , //<S2SV> datagrams ) ; //<S2SV> if ( err < 0 ) //<S2SV> break ; //<S2SV> err = put_user ( err , & entry -> msg_len ) ; //<S2SV> ++ entry ; //<S2SV> } //<S2SV> if ( err ) //<S2SV> break ; //<S2SV> ++ datagrams ; //<S2SV> if ( flags & MSG_WAITFORONE ) //<S2SV> flags |= MSG_DONTWAIT ; //<S2SV> if ( timeout ) { //<S2SV> ktime_get_ts ( timeout ) ; //<S2SV> * timeout = timespec_sub ( end_time , * timeout ) ; //<S2SV> if ( timeout -> tv_sec < 0 ) { //<S2SV> timeout -> tv_sec = timeout -> tv_nsec = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( timeout -> tv_nsec == 0 && timeout -> tv_sec == 0 ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( msg_sys . msg_flags & MSG_OOB ) //<S2SV> break ; //<S2SV> cond_resched ( ) ; //<S2SV> } //<S2SV> if ( err == 0 ) //<S2SV> goto out_put ; //<S2SV> if ( datagrams == 0 ) { //<S2SV> datagrams = err ; //<S2SV> goto out_put ; //<S2SV> } //<S2SV> if ( err != - EAGAIN ) { //<S2SV> sock -> sk -> sk_err = - err ; //<S2SV> } //<S2SV> out_put : //<S2SV> fput_light ( sock -> file , fput_needed ) ; //<S2SV> return datagrams ; //<S2SV> } //<S2SV> 