int ocfs2_setattr ( struct dentry * dentry , struct iattr * attr ) //<S2SV> { //<S2SV> int status = 0 , size_change ; //<S2SV> int inode_locked = 0 ; //<S2SV> struct inode * inode = d_inode ( dentry ) ; //<S2SV> struct super_block * sb = inode -> i_sb ; //<S2SV> struct ocfs2_super * osb = OCFS2_SB ( sb ) ; //<S2SV> struct buffer_head * bh = NULL ; //<S2SV> handle_t * handle = NULL ; //<S2SV> struct dquot * transfer_to [ MAXQUOTAS ] = { } ; //<S2SV> int qtype ; //<S2SV> int had_lock ; //<S2SV> struct ocfs2_lock_holder oh ; //<S2SV> trace_ocfs2_setattr ( inode , dentry , //<S2SV> ( unsigned long long ) OCFS2_I ( inode ) -> ip_blkno , //<S2SV> dentry -> d_name . len , dentry -> d_name . name , //<S2SV> attr -> ia_valid , attr -> ia_mode , //<S2SV> from_kuid ( & init_user_ns , attr -> ia_uid ) , //<S2SV> from_kgid ( & init_user_ns , attr -> ia_gid ) ) ; //<S2SV> if ( S_ISLNK ( inode -> i_mode ) ) //<S2SV> attr -> ia_valid &= ~ ATTR_SIZE ; //<S2SV> # define OCFS2_VALID_ATTRS ( ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE | ATTR_GID | ATTR_UID | ATTR_MODE ) //<S2SV> if ( ! ( attr -> ia_valid & OCFS2_VALID_ATTRS ) ) //<S2SV> return 0 ; //<S2SV> status = setattr_prepare ( dentry , attr ) ; //<S2SV> if ( status ) //<S2SV> return status ; //<S2SV> if ( is_quota_modification ( inode , attr ) ) { //<S2SV> status = dquot_initialize ( inode ) ; //<S2SV> if ( status ) //<S2SV> return status ; //<S2SV> } //<S2SV> size_change = S_ISREG ( inode -> i_mode ) && attr -> ia_valid & ATTR_SIZE ; //<S2SV> if ( size_change ) { //<S2SV> inode_dio_wait ( inode ) ; //<S2SV> status = ocfs2_rw_lock ( inode , 1 ) ; //<S2SV> if ( status < 0 ) { //<S2SV> mlog_errno ( status ) ; //<S2SV> goto bail ; //<S2SV> } //<S2SV> } //<S2SV> had_lock = ocfs2_inode_lock_tracker ( inode , & bh , 1 , & oh ) ; //<S2SV> if ( had_lock < 0 ) { //<S2SV> status = had_lock ; //<S2SV> goto bail_unlock_rw ; //<S2SV> } else if ( had_lock ) { //<S2SV> mlog ( ML_ERROR , "Another<S2SV_blank>case<S2SV_blank>of<S2SV_blank>recursive<S2SV_blank>locking:\\n" ) ; //<S2SV> dump_stack ( ) ; //<S2SV> } //<S2SV> inode_locked = 1 ; //<S2SV> if ( size_change ) { //<S2SV> status = inode_newsize_ok ( inode , attr -> ia_size ) ; //<S2SV> if ( status ) //<S2SV> goto bail_unlock ; //<S2SV> if ( i_size_read ( inode ) >= attr -> ia_size ) { //<S2SV> if ( ocfs2_should_order_data ( inode ) ) { //<S2SV> status = ocfs2_begin_ordered_truncate ( inode , //<S2SV> attr -> ia_size ) ; //<S2SV> if ( status ) //<S2SV> goto bail_unlock ; //<S2SV> } //<S2SV> status = ocfs2_truncate_file ( inode , bh , attr -> ia_size ) ; //<S2SV> } else //<S2SV> status = ocfs2_extend_file ( inode , bh , attr -> ia_size ) ; //<S2SV> if ( status < 0 ) { //<S2SV> if ( status != - ENOSPC ) //<S2SV> mlog_errno ( status ) ; //<S2SV> status = - ENOSPC ; //<S2SV> goto bail_unlock ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || //<S2SV> ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { //<S2SV> if ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) //<S2SV> && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , //<S2SV> OCFS2_FEATURE_RO_COMPAT_USRQUOTA ) ) { //<S2SV> transfer_to [ USRQUOTA ] = dqget ( sb , make_kqid_uid ( attr -> ia_uid ) ) ; //<S2SV> if ( IS_ERR ( transfer_to [ USRQUOTA ] ) ) { //<S2SV> status = PTR_ERR ( transfer_to [ USRQUOTA ] ) ; //<S2SV> goto bail_unlock ; //<S2SV> } //<S2SV> } //<S2SV> if ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) //<S2SV> && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , //<S2SV> OCFS2_FEATURE_RO_COMPAT_GRPQUOTA ) ) { //<S2SV> transfer_to [ GRPQUOTA ] = dqget ( sb , make_kqid_gid ( attr -> ia_gid ) ) ; //<S2SV> if ( IS_ERR ( transfer_to [ GRPQUOTA ] ) ) { //<S2SV> status = PTR_ERR ( transfer_to [ GRPQUOTA ] ) ; //<S2SV> goto bail_unlock ; //<S2SV> } //<S2SV> } //<S2SV> handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS + //<S2SV> 2 * ocfs2_quota_trans_credits ( sb ) ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> status = PTR_ERR ( handle ) ; //<S2SV> mlog_errno ( status ) ; //<S2SV> goto bail_unlock ; //<S2SV> } //<S2SV> status = __dquot_transfer ( inode , transfer_to ) ; //<S2SV> if ( status < 0 ) //<S2SV> goto bail_commit ; //<S2SV> } else { //<S2SV> handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> status = PTR_ERR ( handle ) ; //<S2SV> mlog_errno ( status ) ; //<S2SV> goto bail_unlock ; //<S2SV> } //<S2SV> } //<S2SV> setattr_copy ( inode , attr ) ; //<S2SV> mark_inode_dirty ( inode ) ; //<S2SV> status = ocfs2_mark_inode_dirty ( handle , inode , bh ) ; //<S2SV> if ( status < 0 ) //<S2SV> mlog_errno ( status ) ; //<S2SV> bail_commit : //<S2SV> ocfs2_commit_trans ( osb , handle ) ; //<S2SV> bail_unlock : //<S2SV> if ( status && inode_locked ) { //<S2SV> ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; //<S2SV> inode_locked = 0 ; //<S2SV> } //<S2SV> bail_unlock_rw : //<S2SV> if ( size_change ) //<S2SV> ocfs2_rw_unlock ( inode , 1 ) ; //<S2SV> bail : //<S2SV> for ( qtype = 0 ; qtype < OCFS2_MAXQUOTAS ; qtype ++ ) //<S2SV> dqput ( transfer_to [ qtype ] ) ; //<S2SV> if ( ! status && attr -> ia_valid & ATTR_MODE ) { //<S2SV> status = ocfs2_acl_chmod ( inode , bh ) ; //<S2SV> if ( status < 0 ) //<S2SV> mlog_errno ( status ) ; //<S2SV> } //<S2SV> if ( inode_locked ) //<S2SV> ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; //<S2SV> brelse ( bh ) ; //<S2SV> return status ; //<S2SV> } //<S2SV> 