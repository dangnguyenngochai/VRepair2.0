static int hfsplus_readdir ( struct file * filp , void * dirent , filldir_t filldir ) //<S2SV> { //<S2SV> struct inode * inode = filp -> f_path . dentry -> d_inode ; //<S2SV> struct super_block * sb = inode -> i_sb ; //<S2SV> int len , err ; //<S2SV> char strbuf [ HFSPLUS_MAX_STRLEN + 1 ] ; //<S2SV> hfsplus_cat_entry entry ; //<S2SV> struct hfs_find_data fd ; //<S2SV> struct hfsplus_readdir_data * rd ; //<S2SV> u16 type ; //<S2SV> if ( filp -> f_pos >= inode -> i_size ) //<S2SV> return 0 ; //<S2SV> err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & fd ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> hfsplus_cat_build_key ( sb , fd . search_key , inode -> i_ino , NULL ) ; //<S2SV> err = hfs_brec_find ( & fd ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> switch ( ( u32 ) filp -> f_pos ) { //<S2SV> case 0 : //<S2SV> if ( filldir ( dirent , "." , 1 , 0 , inode -> i_ino , DT_DIR ) ) //<S2SV> goto out ; //<S2SV> filp -> f_pos ++ ; //<S2SV> case 1 : //<S2SV> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , //<S2SV> fd . entrylength ) ; //<S2SV> if ( be16_to_cpu ( entry . type ) != HFSPLUS_FOLDER_THREAD ) { //<S2SV> printk ( KERN_ERR "hfs:<S2SV_blank>bad<S2SV_blank>catalog<S2SV_blank>folder<S2SV_blank>thread\\n" ) ; //<S2SV> err = - EIO ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( fd . entrylength < HFSPLUS_MIN_THREAD_SZ ) { //<S2SV> printk ( KERN_ERR "hfs:<S2SV_blank>truncated<S2SV_blank>catalog<S2SV_blank>thread\\n" ) ; //<S2SV> err = - EIO ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( filldir ( dirent , ".." , 2 , 1 , //<S2SV> be32_to_cpu ( entry . thread . parentID ) , DT_DIR ) ) //<S2SV> goto out ; //<S2SV> filp -> f_pos ++ ; //<S2SV> default : //<S2SV> if ( filp -> f_pos >= inode -> i_size ) //<S2SV> goto out ; //<S2SV> err = hfs_brec_goto ( & fd , filp -> f_pos - 1 ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> } //<S2SV> for ( ; ; ) { //<S2SV> if ( be32_to_cpu ( fd . key -> cat . parent ) != inode -> i_ino ) { //<S2SV> printk ( KERN_ERR "hfs:<S2SV_blank>walked<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>dir\\n" ) ; //<S2SV> err = - EIO ; //<S2SV> goto out ; //<S2SV> } //<S2SV> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , //<S2SV> fd . entrylength ) ; //<S2SV> type = be16_to_cpu ( entry . type ) ; //<S2SV> len = HFSPLUS_MAX_STRLEN ; //<S2SV> err = hfsplus_uni2asc ( sb , & fd . key -> cat . name , strbuf , & len ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> if ( type == HFSPLUS_FOLDER ) { //<S2SV> if ( fd . entrylength < //<S2SV> sizeof ( struct hfsplus_cat_folder ) ) { //<S2SV> printk ( KERN_ERR "hfs:<S2SV_blank>small<S2SV_blank>dir<S2SV_blank>entry\\n" ) ; //<S2SV> err = - EIO ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( HFSPLUS_SB ( sb ) -> hidden_dir && //<S2SV> HFSPLUS_SB ( sb ) -> hidden_dir -> i_ino == //<S2SV> be32_to_cpu ( entry . folder . id ) ) //<S2SV> goto next ; //<S2SV> if ( filldir ( dirent , strbuf , len , filp -> f_pos , //<S2SV> be32_to_cpu ( entry . folder . id ) , DT_DIR ) ) //<S2SV> break ; //<S2SV> } else if ( type == HFSPLUS_FILE ) { //<S2SV> if ( fd . entrylength < sizeof ( struct hfsplus_cat_file ) ) { //<S2SV> printk ( KERN_ERR "hfs:<S2SV_blank>small<S2SV_blank>file<S2SV_blank>entry\\n" ) ; //<S2SV> err = - EIO ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( filldir ( dirent , strbuf , len , filp -> f_pos , //<S2SV> be32_to_cpu ( entry . file . id ) , DT_REG ) ) //<S2SV> break ; //<S2SV> } else { //<S2SV> printk ( KERN_ERR "hfs:<S2SV_blank>bad<S2SV_blank>catalog<S2SV_blank>entry<S2SV_blank>type\\n" ) ; //<S2SV> err = - EIO ; //<S2SV> goto out ; //<S2SV> } //<S2SV> next : //<S2SV> filp -> f_pos ++ ; //<S2SV> if ( filp -> f_pos >= inode -> i_size ) //<S2SV> goto out ; //<S2SV> err = hfs_brec_goto ( & fd , 1 ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> } //<S2SV> rd = filp -> private_data ; //<S2SV> if ( ! rd ) { //<S2SV> rd = kmalloc ( sizeof ( struct hfsplus_readdir_data ) , GFP_KERNEL ) ; //<S2SV> if ( ! rd ) { //<S2SV> err = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> filp -> private_data = rd ; //<S2SV> rd -> file = filp ; //<S2SV> list_add ( & rd -> list , & HFSPLUS_I ( inode ) -> open_dir_list ) ; //<S2SV> } //<S2SV> memcpy ( & rd -> key , fd . key , sizeof ( struct hfsplus_cat_key ) ) ; //<S2SV> out : //<S2SV> hfs_find_exit ( & fd ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 