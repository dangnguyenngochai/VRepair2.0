static int sctp_process_param ( struct sctp_association * asoc , //<S2SV> union sctp_params param , //<S2SV> const union sctp_addr * peer_addr , //<S2SV> gfp_t gfp ) //<S2SV> { //<S2SV> struct net * net = sock_net ( asoc -> base . sk ) ; //<S2SV> union sctp_addr addr ; //<S2SV> int i ; //<S2SV> __u16 sat ; //<S2SV> int retval = 1 ; //<S2SV> sctp_scope_t scope ; //<S2SV> time_t stale ; //<S2SV> struct sctp_af * af ; //<S2SV> union sctp_addr_param * addr_param ; //<S2SV> struct sctp_transport * t ; //<S2SV> struct sctp_endpoint * ep = asoc -> ep ; //<S2SV> switch ( param . p -> type ) { //<S2SV> case SCTP_PARAM_IPV6_ADDRESS : //<S2SV> if ( PF_INET6 != asoc -> base . sk -> sk_family ) //<S2SV> break ; //<S2SV> goto do_addr_param ; //<S2SV> case SCTP_PARAM_IPV4_ADDRESS : //<S2SV> if ( ipv6_only_sock ( asoc -> base . sk ) ) //<S2SV> break ; //<S2SV> do_addr_param : //<S2SV> af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; //<S2SV> af -> from_addr_param ( & addr , param . addr , htons ( asoc -> peer . port ) , 0 ) ; //<S2SV> scope = sctp_scope ( peer_addr ) ; //<S2SV> if ( sctp_in_scope ( net , & addr , scope ) ) //<S2SV> if ( ! sctp_assoc_add_peer ( asoc , & addr , gfp , SCTP_UNCONFIRMED ) ) //<S2SV> return 0 ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_COOKIE_PRESERVATIVE : //<S2SV> if ( ! net -> sctp . cookie_preserve_enable ) //<S2SV> break ; //<S2SV> stale = ntohl ( param . life -> lifespan_increment ) ; //<S2SV> asoc -> cookie_life = ktime_add_ms ( asoc -> cookie_life , stale ) ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_HOST_NAME_ADDRESS : //<S2SV> pr_debug ( "%s:<S2SV_blank>unimplemented<S2SV_blank>SCTP_HOST_NAME_ADDRESS\\n" , __func__ ) ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_SUPPORTED_ADDRESS_TYPES : //<S2SV> asoc -> peer . ipv4_address = 0 ; //<S2SV> asoc -> peer . ipv6_address = 0 ; //<S2SV> if ( peer_addr -> sa . sa_family == AF_INET6 ) //<S2SV> asoc -> peer . ipv6_address = 1 ; //<S2SV> else if ( peer_addr -> sa . sa_family == AF_INET ) //<S2SV> asoc -> peer . ipv4_address = 1 ; //<S2SV> sat = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; //<S2SV> if ( sat ) //<S2SV> sat /= sizeof ( __u16 ) ; //<S2SV> for ( i = 0 ; i < sat ; ++ i ) { //<S2SV> switch ( param . sat -> types [ i ] ) { //<S2SV> case SCTP_PARAM_IPV4_ADDRESS : //<S2SV> asoc -> peer . ipv4_address = 1 ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_IPV6_ADDRESS : //<S2SV> if ( PF_INET6 == asoc -> base . sk -> sk_family ) //<S2SV> asoc -> peer . ipv6_address = 1 ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_HOST_NAME_ADDRESS : //<S2SV> asoc -> peer . hostname_address = 1 ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case SCTP_PARAM_STATE_COOKIE : //<S2SV> asoc -> peer . cookie_len = //<S2SV> ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; //<S2SV> asoc -> peer . cookie = param . cookie -> body ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_HEARTBEAT_INFO : //<S2SV> break ; //<S2SV> case SCTP_PARAM_UNRECOGNIZED_PARAMETERS : //<S2SV> break ; //<S2SV> case SCTP_PARAM_ECN_CAPABLE : //<S2SV> asoc -> peer . ecn_capable = 1 ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_ADAPTATION_LAYER_IND : //<S2SV> asoc -> peer . adaptation_ind = ntohl ( param . aind -> adaptation_ind ) ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_SET_PRIMARY : //<S2SV> if ( ! net -> sctp . addip_enable ) //<S2SV> goto fall_through ; //<S2SV> addr_param = param . v + sizeof ( sctp_addip_param_t ) ; //<S2SV> af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; //<S2SV> af -> from_addr_param ( & addr , addr_param , //<S2SV> htons ( asoc -> peer . port ) , 0 ) ; //<S2SV> if ( ! af -> addr_valid ( & addr , NULL , NULL ) ) //<S2SV> break ; //<S2SV> t = sctp_assoc_lookup_paddr ( asoc , & addr ) ; //<S2SV> if ( ! t ) //<S2SV> break ; //<S2SV> sctp_assoc_set_primary ( asoc , t ) ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_SUPPORTED_EXT : //<S2SV> sctp_process_ext_param ( asoc , param ) ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_FWD_TSN_SUPPORT : //<S2SV> if ( net -> sctp . prsctp_enable ) { //<S2SV> asoc -> peer . prsctp_capable = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> goto fall_through ; //<S2SV> case SCTP_PARAM_RANDOM : //<S2SV> if ( ! ep -> auth_enable ) //<S2SV> goto fall_through ; //<S2SV> asoc -> peer . peer_random = kmemdup ( param . p , //<S2SV> ntohs ( param . p -> length ) , gfp ) ; //<S2SV> if ( ! asoc -> peer . peer_random ) { //<S2SV> retval = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case SCTP_PARAM_HMAC_ALGO : //<S2SV> if ( ! ep -> auth_enable ) //<S2SV> goto fall_through ; //<S2SV> asoc -> peer . peer_hmacs = kmemdup ( param . p , //<S2SV> ntohs ( param . p -> length ) , gfp ) ; //<S2SV> if ( ! asoc -> peer . peer_hmacs ) { //<S2SV> retval = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> sctp_auth_asoc_set_default_hmac ( asoc , param . hmac_algo ) ; //<S2SV> break ; //<S2SV> case SCTP_PARAM_CHUNKS : //<S2SV> if ( ! ep -> auth_enable ) //<S2SV> goto fall_through ; //<S2SV> asoc -> peer . peer_chunks = kmemdup ( param . p , //<S2SV> ntohs ( param . p -> length ) , gfp ) ; //<S2SV> if ( ! asoc -> peer . peer_chunks ) //<S2SV> retval = 0 ; //<S2SV> break ; //<S2SV> fall_through : //<S2SV> default : //<S2SV> pr_debug ( "%s:<S2SV_blank>ignoring<S2SV_blank>param:%d<S2SV_blank>for<S2SV_blank>association:%p.\\n" , //<S2SV> __func__ , ntohs ( param . p -> type ) , asoc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> return retval ; //<S2SV> } //<S2SV> 