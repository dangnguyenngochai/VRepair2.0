static int skcipher_accept_parent ( void * private , struct sock * sk ) //<S2SV> { //<S2SV> struct skcipher_ctx * ctx ; //<S2SV> struct alg_sock * ask = alg_sk ( sk ) ; //<S2SV> unsigned int len = sizeof ( * ctx ) + crypto_skcipher_reqsize ( private ) ; //<S2SV> ctx = sock_kmalloc ( sk , len , GFP_KERNEL ) ; //<S2SV> if ( ! ctx ) //<S2SV> return - ENOMEM ; //<S2SV> ctx -> iv = sock_kmalloc ( sk , crypto_skcipher_ivsize ( private ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! ctx -> iv ) { //<S2SV> sock_kfree_s ( sk , ctx , len ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> memset ( ctx -> iv , 0 , crypto_skcipher_ivsize ( private ) ) ; //<S2SV> INIT_LIST_HEAD ( & ctx -> tsgl ) ; //<S2SV> ctx -> len = len ; //<S2SV> ctx -> used = 0 ; //<S2SV> ctx -> more = 0 ; //<S2SV> ctx -> merge = 0 ; //<S2SV> ctx -> enc = 0 ; //<S2SV> atomic_set ( & ctx -> inflight , 0 ) ; //<S2SV> af_alg_init_completion ( & ctx -> completion ) ; //<S2SV> ask -> private = ctx ; //<S2SV> skcipher_request_set_tfm ( & ctx -> req , private ) ; //<S2SV> skcipher_request_set_callback ( & ctx -> req , CRYPTO_TFM_REQ_MAY_BACKLOG , //<S2SV> af_alg_complete , & ctx -> completion ) ; //<S2SV> sk -> sk_destruct = skcipher_sock_destruct ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 