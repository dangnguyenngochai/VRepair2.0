static int gtco_probe ( struct usb_interface * usbinterface , //<S2SV> const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct gtco * gtco ; //<S2SV> struct input_dev * input_dev ; //<S2SV> struct hid_descriptor * hid_desc ; //<S2SV> char * report ; //<S2SV> int result = 0 , retry ; //<S2SV> int error ; //<S2SV> struct usb_endpoint_descriptor * endpoint ; //<S2SV> gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; //<S2SV> input_dev = input_allocate_device ( ) ; //<S2SV> if ( ! gtco || ! input_dev ) { //<S2SV> dev_err ( & usbinterface -> dev , "No<S2SV_blank>more<S2SV_blank>memory\\n" ) ; //<S2SV> error = - ENOMEM ; //<S2SV> goto err_free_devs ; //<S2SV> } //<S2SV> gtco -> inputdevice = input_dev ; //<S2SV> gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; //<S2SV> gtco -> intf = usbinterface ; //<S2SV> gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , //<S2SV> GFP_KERNEL , & gtco -> buf_dma ) ; //<S2SV> if ( ! gtco -> buffer ) { //<S2SV> dev_err ( & usbinterface -> dev , "No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>us<S2SV_blank>buffers\\n" ) ; //<S2SV> error = - ENOMEM ; //<S2SV> goto err_free_devs ; //<S2SV> } //<S2SV> gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! gtco -> urbinfo ) { //<S2SV> dev_err ( & usbinterface -> dev , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>URB\\n" ) ; //<S2SV> error = - ENOMEM ; //<S2SV> goto err_free_buf ; //<S2SV> } //<S2SV> if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { //<S2SV> dev_err ( & usbinterface -> dev , //<S2SV> "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; //<S2SV> error = - EINVAL ; //<S2SV> goto err_free_urb ; //<S2SV> } //<S2SV> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; //<S2SV> dev_dbg ( & usbinterface -> dev , "gtco<S2SV_blank>#<S2SV_blank>interfaces:<S2SV_blank>%d\\n" , usbinterface -> num_altsetting ) ; //<S2SV> dev_dbg ( & usbinterface -> dev , "num<S2SV_blank>endpoints:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; //<S2SV> dev_dbg ( & usbinterface -> dev , "interface<S2SV_blank>class:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; //<S2SV> dev_dbg ( & usbinterface -> dev , "endpoint:<S2SV_blank>attribute:0x%x<S2SV_blank>type:0x%x\\n" , endpoint -> bmAttributes , endpoint -> bDescriptorType ) ; //<S2SV> if ( usb_endpoint_xfer_int ( endpoint ) ) //<S2SV> dev_dbg ( & usbinterface -> dev , "endpoint:<S2SV_blank>we<S2SV_blank>have<S2SV_blank>interrupt<S2SV_blank>endpoint\\n" ) ; //<S2SV> dev_dbg ( & usbinterface -> dev , "endpoint<S2SV_blank>extra<S2SV_blank>len:%d\\n" , usbinterface -> altsetting [ 0 ] . extralen ) ; //<S2SV> if ( usb_get_extra_descriptor ( usbinterface -> cur_altsetting , //<S2SV> HID_DEVICE_TYPE , & hid_desc ) != 0 ) { //<S2SV> dev_err ( & usbinterface -> dev , //<S2SV> "Can\'t<S2SV_blank>retrieve<S2SV_blank>exta<S2SV_blank>USB<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>get<S2SV_blank>hid<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>length\\n" ) ; //<S2SV> error = - EIO ; //<S2SV> goto err_free_urb ; //<S2SV> } //<S2SV> dev_dbg ( & usbinterface -> dev , //<S2SV> "Extra<S2SV_blank>descriptor<S2SV_blank>success:<S2SV_blank>type:%d<S2SV_blank><S2SV_blank>len:%d\\n" , //<S2SV> hid_desc -> bDescriptorType , hid_desc -> wDescriptorLength ) ; //<S2SV> report = kzalloc ( le16_to_cpu ( hid_desc -> wDescriptorLength ) , GFP_KERNEL ) ; //<S2SV> if ( ! report ) { //<S2SV> dev_err ( & usbinterface -> dev , "No<S2SV_blank>more<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>report\\n" ) ; //<S2SV> error = - ENOMEM ; //<S2SV> goto err_free_urb ; //<S2SV> } //<S2SV> for ( retry = 0 ; retry < 3 ; retry ++ ) { //<S2SV> result = usb_control_msg ( gtco -> usbdev , //<S2SV> usb_rcvctrlpipe ( gtco -> usbdev , 0 ) , //<S2SV> USB_REQ_GET_DESCRIPTOR , //<S2SV> USB_RECIP_INTERFACE | USB_DIR_IN , //<S2SV> REPORT_DEVICE_TYPE << 8 , //<S2SV> 0 , //<S2SV> report , //<S2SV> le16_to_cpu ( hid_desc -> wDescriptorLength ) , //<S2SV> 5000 ) ; //<S2SV> dev_dbg ( & usbinterface -> dev , "usb_control_msg<S2SV_blank>result:<S2SV_blank>%d\\n" , result ) ; //<S2SV> if ( result == le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { //<S2SV> parse_hid_report_descriptor ( gtco , report , result ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> kfree ( report ) ; //<S2SV> if ( result != le16_to_cpu ( hid_desc -> wDescriptorLength ) ) { //<S2SV> dev_err ( & usbinterface -> dev , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>HID<S2SV_blank>Report<S2SV_blank>Descriptor<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%d\\n" , //<S2SV> hid_desc -> wDescriptorLength ) ; //<S2SV> error = - EIO ; //<S2SV> goto err_free_urb ; //<S2SV> } //<S2SV> usb_make_path ( gtco -> usbdev , gtco -> usbpath , sizeof ( gtco -> usbpath ) ) ; //<S2SV> strlcat ( gtco -> usbpath , "/input0" , sizeof ( gtco -> usbpath ) ) ; //<S2SV> input_dev -> open = gtco_input_open ; //<S2SV> input_dev -> close = gtco_input_close ; //<S2SV> input_dev -> name = "GTCO_CalComp" ; //<S2SV> input_dev -> phys = gtco -> usbpath ; //<S2SV> input_set_drvdata ( input_dev , gtco ) ; //<S2SV> gtco_setup_caps ( input_dev ) ; //<S2SV> usb_to_input_id ( gtco -> usbdev , & input_dev -> id ) ; //<S2SV> input_dev -> dev . parent = & usbinterface -> dev ; //<S2SV> endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; //<S2SV> usb_fill_int_urb ( gtco -> urbinfo , //<S2SV> gtco -> usbdev , //<S2SV> usb_rcvintpipe ( gtco -> usbdev , //<S2SV> endpoint -> bEndpointAddress ) , //<S2SV> gtco -> buffer , //<S2SV> REPORT_MAX_SIZE , //<S2SV> gtco_urb_callback , //<S2SV> gtco , //<S2SV> endpoint -> bInterval ) ; //<S2SV> gtco -> urbinfo -> transfer_dma = gtco -> buf_dma ; //<S2SV> gtco -> urbinfo -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; //<S2SV> usb_set_intfdata ( usbinterface , gtco ) ; //<S2SV> error = input_register_device ( input_dev ) ; //<S2SV> if ( error ) //<S2SV> goto err_free_urb ; //<S2SV> return 0 ; //<S2SV> err_free_urb : //<S2SV> usb_free_urb ( gtco -> urbinfo ) ; //<S2SV> err_free_buf : //<S2SV> usb_free_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , //<S2SV> gtco -> buffer , gtco -> buf_dma ) ; //<S2SV> err_free_devs : //<S2SV> input_free_device ( input_dev ) ; //<S2SV> kfree ( gtco ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 