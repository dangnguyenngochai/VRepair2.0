static int ext4_write_end ( struct file * file , //<S2SV> struct address_space * mapping , //<S2SV> loff_t pos , unsigned len , unsigned copied , //<S2SV> struct page * page , void * fsdata ) //<S2SV> { //<S2SV> handle_t * handle = ext4_journal_current_handle ( ) ; //<S2SV> struct inode * inode = mapping -> host ; //<S2SV> loff_t old_size = inode -> i_size ; //<S2SV> int ret = 0 , ret2 ; //<S2SV> int i_size_changed = 0 ; //<S2SV> trace_ext4_write_end ( inode , pos , len , copied ) ; //<S2SV> if ( ext4_has_inline_data ( inode ) ) { //<S2SV> ret = ext4_write_inline_data_end ( inode , pos , len , //<S2SV> copied , page ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto errout ; //<S2SV> copied = ret ; //<S2SV> } else //<S2SV> copied = block_write_end ( file , mapping , pos , //<S2SV> len , copied , page , fsdata ) ; //<S2SV> i_size_changed = ext4_update_inode_size ( inode , pos + copied ) ; //<S2SV> unlock_page ( page ) ; //<S2SV> put_page ( page ) ; //<S2SV> if ( old_size < pos ) //<S2SV> pagecache_isize_extended ( inode , old_size , pos ) ; //<S2SV> if ( i_size_changed ) //<S2SV> ext4_mark_inode_dirty ( handle , inode ) ; //<S2SV> if ( pos + len > inode -> i_size && ext4_can_truncate ( inode ) ) //<S2SV> ext4_orphan_add ( handle , inode ) ; //<S2SV> errout : //<S2SV> ret2 = ext4_journal_stop ( handle ) ; //<S2SV> if ( ! ret ) //<S2SV> ret = ret2 ; //<S2SV> if ( pos + len > inode -> i_size ) { //<S2SV> ext4_truncate_failed_write ( inode ) ; //<S2SV> if ( inode -> i_nlink ) //<S2SV> ext4_orphan_del ( NULL , inode ) ; //<S2SV> } //<S2SV> return ret ? ret : copied ; //<S2SV> } //<S2SV> 