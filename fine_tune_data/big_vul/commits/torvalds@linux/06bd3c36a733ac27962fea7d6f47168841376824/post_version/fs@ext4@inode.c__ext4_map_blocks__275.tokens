int ext4_map_blocks ( handle_t * handle , struct inode * inode , //<S2SV> struct ext4_map_blocks * map , int flags ) //<S2SV> { //<S2SV> struct extent_status es ; //<S2SV> int retval ; //<S2SV> int ret = 0 ; //<S2SV> # ifdef ES_AGGRESSIVE_TEST //<S2SV> struct ext4_map_blocks orig_map ; //<S2SV> memcpy ( & orig_map , map , sizeof ( * map ) ) ; //<S2SV> # endif //<S2SV> map -> m_flags = 0 ; //<S2SV> ext_debug ( "ext4_map_blocks():<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>flag<S2SV_blank>%d,<S2SV_blank>max_blocks<S2SV_blank>%u," //<S2SV> "logical<S2SV_blank>block<S2SV_blank>%lu\\n" , inode -> i_ino , flags , map -> m_len , //<S2SV> ( unsigned long ) map -> m_lblk ) ; //<S2SV> if ( unlikely ( map -> m_len > INT_MAX ) ) //<S2SV> map -> m_len = INT_MAX ; //<S2SV> if ( unlikely ( map -> m_lblk >= EXT_MAX_BLOCKS ) ) //<S2SV> return - EFSCORRUPTED ; //<S2SV> if ( ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { //<S2SV> if ( ext4_es_is_written ( & es ) || ext4_es_is_unwritten ( & es ) ) { //<S2SV> map -> m_pblk = ext4_es_pblock ( & es ) + //<S2SV> map -> m_lblk - es . es_lblk ; //<S2SV> map -> m_flags |= ext4_es_is_written ( & es ) ? //<S2SV> EXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN ; //<S2SV> retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; //<S2SV> if ( retval > map -> m_len ) //<S2SV> retval = map -> m_len ; //<S2SV> map -> m_len = retval ; //<S2SV> } else if ( ext4_es_is_delayed ( & es ) || ext4_es_is_hole ( & es ) ) { //<S2SV> map -> m_pblk = 0 ; //<S2SV> retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; //<S2SV> if ( retval > map -> m_len ) //<S2SV> retval = map -> m_len ; //<S2SV> map -> m_len = retval ; //<S2SV> retval = 0 ; //<S2SV> } else { //<S2SV> BUG_ON ( 1 ) ; //<S2SV> } //<S2SV> # ifdef ES_AGGRESSIVE_TEST //<S2SV> ext4_map_blocks_es_recheck ( handle , inode , map , //<S2SV> & orig_map , flags ) ; //<S2SV> # endif //<S2SV> goto found ; //<S2SV> } //<S2SV> down_read ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { //<S2SV> retval = ext4_ext_map_blocks ( handle , inode , map , flags & //<S2SV> EXT4_GET_BLOCKS_KEEP_SIZE ) ; //<S2SV> } else { //<S2SV> retval = ext4_ind_map_blocks ( handle , inode , map , flags & //<S2SV> EXT4_GET_BLOCKS_KEEP_SIZE ) ; //<S2SV> } //<S2SV> if ( retval > 0 ) { //<S2SV> unsigned int status ; //<S2SV> if ( unlikely ( retval != map -> m_len ) ) { //<S2SV> ext4_warning ( inode -> i_sb , //<S2SV> "ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>" //<S2SV> "%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d" , //<S2SV> inode -> i_ino , retval , map -> m_len ) ; //<S2SV> WARN_ON ( 1 ) ; //<S2SV> } //<S2SV> status = map -> m_flags & EXT4_MAP_UNWRITTEN ? //<S2SV> EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; //<S2SV> if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && //<S2SV> ! ( status & EXTENT_STATUS_WRITTEN ) && //<S2SV> ext4_find_delalloc_range ( inode , map -> m_lblk , //<S2SV> map -> m_lblk + map -> m_len - 1 ) ) //<S2SV> status |= EXTENT_STATUS_DELAYED ; //<S2SV> ret = ext4_es_insert_extent ( inode , map -> m_lblk , //<S2SV> map -> m_len , map -> m_pblk , status ) ; //<S2SV> if ( ret < 0 ) //<S2SV> retval = ret ; //<S2SV> } //<S2SV> up_read ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; //<S2SV> found : //<S2SV> if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { //<S2SV> ret = check_block_validity ( inode , map ) ; //<S2SV> if ( ret != 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) //<S2SV> return retval ; //<S2SV> if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) //<S2SV> if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) //<S2SV> return retval ; //<S2SV> map -> m_flags &= ~ EXT4_MAP_FLAGS ; //<S2SV> down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { //<S2SV> retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ; //<S2SV> } else { //<S2SV> retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ; //<S2SV> if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) { //<S2SV> ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ; //<S2SV> } //<S2SV> if ( ( retval > 0 ) && //<S2SV> ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) //<S2SV> ext4_da_update_reserve_space ( inode , retval , 1 ) ; //<S2SV> } //<S2SV> if ( retval > 0 ) { //<S2SV> unsigned int status ; //<S2SV> if ( unlikely ( retval != map -> m_len ) ) { //<S2SV> ext4_warning ( inode -> i_sb , //<S2SV> "ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>" //<S2SV> "%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d" , //<S2SV> inode -> i_ino , retval , map -> m_len ) ; //<S2SV> WARN_ON ( 1 ) ; //<S2SV> } //<S2SV> if ( flags & EXT4_GET_BLOCKS_ZERO && //<S2SV> map -> m_flags & EXT4_MAP_MAPPED && //<S2SV> map -> m_flags & EXT4_MAP_NEW ) { //<S2SV> ret = ext4_issue_zeroout ( inode , map -> m_lblk , //<S2SV> map -> m_pblk , map -> m_len ) ; //<S2SV> if ( ret ) { //<S2SV> retval = ret ; //<S2SV> goto out_sem ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && //<S2SV> ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { //<S2SV> if ( ext4_es_is_written ( & es ) ) //<S2SV> goto out_sem ; //<S2SV> } //<S2SV> status = map -> m_flags & EXT4_MAP_UNWRITTEN ? //<S2SV> EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; //<S2SV> if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && //<S2SV> ! ( status & EXTENT_STATUS_WRITTEN ) && //<S2SV> ext4_find_delalloc_range ( inode , map -> m_lblk , //<S2SV> map -> m_lblk + map -> m_len - 1 ) ) //<S2SV> status |= EXTENT_STATUS_DELAYED ; //<S2SV> ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , //<S2SV> map -> m_pblk , status ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> retval = ret ; //<S2SV> goto out_sem ; //<S2SV> } //<S2SV> } //<S2SV> out_sem : //<S2SV> up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; //<S2SV> if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { //<S2SV> ret = check_block_validity ( inode , map ) ; //<S2SV> if ( ret != 0 ) //<S2SV> return ret ; //<S2SV> if ( map -> m_flags & EXT4_MAP_NEW && //<S2SV> ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && //<S2SV> ! ( flags & EXT4_GET_BLOCKS_ZERO ) && //<S2SV> ! IS_NOQUOTA ( inode ) && //<S2SV> ext4_should_order_data ( inode ) ) { //<S2SV> ret = ext4_jbd2_file_inode ( handle , inode ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> return retval ; //<S2SV> } //<S2SV> 