static ssize_t aio_run_iocb ( struct kiocb * req , unsigned opcode , //<S2SV> char __user * buf , size_t len , bool compat ) //<S2SV> { //<S2SV> struct file * file = req -> ki_filp ; //<S2SV> ssize_t ret ; //<S2SV> unsigned long nr_segs ; //<S2SV> int rw ; //<S2SV> fmode_t mode ; //<S2SV> aio_rw_op * rw_op ; //<S2SV> rw_iter_op * iter_op ; //<S2SV> struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; //<S2SV> struct iov_iter iter ; //<S2SV> switch ( opcode ) { //<S2SV> case IOCB_CMD_PREAD : //<S2SV> case IOCB_CMD_PREADV : //<S2SV> mode = FMODE_READ ; //<S2SV> rw = READ ; //<S2SV> rw_op = file -> f_op -> aio_read ; //<S2SV> iter_op = file -> f_op -> read_iter ; //<S2SV> goto rw_common ; //<S2SV> case IOCB_CMD_PWRITE : //<S2SV> case IOCB_CMD_PWRITEV : //<S2SV> mode = FMODE_WRITE ; //<S2SV> rw = WRITE ; //<S2SV> rw_op = file -> f_op -> aio_write ; //<S2SV> iter_op = file -> f_op -> write_iter ; //<S2SV> goto rw_common ; //<S2SV> rw_common : //<S2SV> if ( unlikely ( ! ( file -> f_mode & mode ) ) ) //<S2SV> return - EBADF ; //<S2SV> if ( ! rw_op && ! iter_op ) //<S2SV> return - EINVAL ; //<S2SV> if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) //<S2SV> ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , //<S2SV> & len , & iovec , compat ) ; //<S2SV> else //<S2SV> ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , //<S2SV> len , iovec ) ; //<S2SV> if ( ! ret ) //<S2SV> ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> if ( iovec != inline_vecs ) //<S2SV> kfree ( iovec ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> len = ret ; //<S2SV> if ( req -> ki_pos < 0 ) { //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( rw == WRITE ) //<S2SV> file_start_write ( file ) ; //<S2SV> if ( iter_op ) { //<S2SV> iov_iter_init ( & iter , rw , iovec , nr_segs , len ) ; //<S2SV> ret = iter_op ( req , & iter ) ; //<S2SV> } else { //<S2SV> ret = rw_op ( req , iovec , nr_segs , req -> ki_pos ) ; //<S2SV> } //<S2SV> if ( rw == WRITE ) //<S2SV> file_end_write ( file ) ; //<S2SV> break ; //<S2SV> case IOCB_CMD_FDSYNC : //<S2SV> if ( ! file -> f_op -> aio_fsync ) //<S2SV> return - EINVAL ; //<S2SV> ret = file -> f_op -> aio_fsync ( req , 1 ) ; //<S2SV> break ; //<S2SV> case IOCB_CMD_FSYNC : //<S2SV> if ( ! file -> f_op -> aio_fsync ) //<S2SV> return - EINVAL ; //<S2SV> ret = file -> f_op -> aio_fsync ( req , 0 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> pr_debug ( "EINVAL:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( iovec != inline_vecs ) //<S2SV> kfree ( iovec ) ; //<S2SV> if ( ret != - EIOCBQUEUED ) { //<S2SV> if ( unlikely ( ret == - ERESTARTSYS || ret == - ERESTARTNOINTR || //<S2SV> ret == - ERESTARTNOHAND || //<S2SV> ret == - ERESTART_RESTARTBLOCK ) ) //<S2SV> ret = - EINTR ; //<S2SV> aio_complete ( req , ret , 0 ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 