static int futex_wait ( u32 __user * uaddr , int fshared , //<S2SV> u32 val , ktime_t * abs_time , u32 bitset , int clockrt ) //<S2SV> { //<S2SV> struct hrtimer_sleeper timeout , * to = NULL ; //<S2SV> struct restart_block * restart ; //<S2SV> struct futex_hash_bucket * hb ; //<S2SV> struct futex_q q ; //<S2SV> int ret ; //<S2SV> if ( ! bitset ) //<S2SV> return - EINVAL ; //<S2SV> q . pi_state = NULL ; //<S2SV> q . bitset = bitset ; //<S2SV> q . rt_waiter = NULL ; //<S2SV> q . requeue_pi_key = NULL ; //<S2SV> if ( abs_time ) { //<S2SV> to = & timeout ; //<S2SV> hrtimer_init_on_stack ( & to -> timer , clockrt ? CLOCK_REALTIME : //<S2SV> CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; //<S2SV> hrtimer_init_sleeper ( to , current ) ; //<S2SV> hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , //<S2SV> current -> timer_slack_ns ) ; //<S2SV> } //<S2SV> retry : //<S2SV> ret = futex_wait_setup ( uaddr , val , fshared , & q , & hb ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> futex_wait_queue_me ( hb , & q , to ) ; //<S2SV> ret = 0 ; //<S2SV> if ( ! unqueue_me ( & q ) ) //<S2SV> goto out_put_key ; //<S2SV> ret = - ETIMEDOUT ; //<S2SV> if ( to && ! to -> task ) //<S2SV> goto out_put_key ; //<S2SV> if ( ! signal_pending ( current ) ) { //<S2SV> put_futex_key ( fshared , & q . key ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> ret = - ERESTARTSYS ; //<S2SV> if ( ! abs_time ) //<S2SV> goto out_put_key ; //<S2SV> restart = & current_thread_info ( ) -> restart_block ; //<S2SV> restart -> fn = futex_wait_restart ; //<S2SV> restart -> futex . uaddr = ( u32 * ) uaddr ; //<S2SV> restart -> futex . val = val ; //<S2SV> restart -> futex . time = abs_time -> tv64 ; //<S2SV> restart -> futex . bitset = bitset ; //<S2SV> restart -> futex . flags = FLAGS_HAS_TIMEOUT ; //<S2SV> if ( fshared ) //<S2SV> restart -> futex . flags |= FLAGS_SHARED ; //<S2SV> if ( clockrt ) //<S2SV> restart -> futex . flags |= FLAGS_CLOCKRT ; //<S2SV> ret = - ERESTART_RESTARTBLOCK ; //<S2SV> out_put_key : //<S2SV> put_futex_key ( fshared , & q . key ) ; //<S2SV> out : //<S2SV> if ( to ) { //<S2SV> hrtimer_cancel ( & to -> timer ) ; //<S2SV> destroy_hrtimer_on_stack ( & to -> timer ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 