static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) //<S2SV> { //<S2SV> struct bpf_insn * insn = env -> prog -> insnsi ; //<S2SV> int insn_cnt = env -> prog -> len ; //<S2SV> int i , j ; //<S2SV> for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { //<S2SV> if ( BPF_CLASS ( insn -> code ) == BPF_LDX && //<S2SV> ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { //<S2SV> verbose ( "BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( BPF_CLASS ( insn -> code ) == BPF_STX && //<S2SV> ( ( BPF_MODE ( insn -> code ) != BPF_MEM && //<S2SV> BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { //<S2SV> verbose ( "BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { //<S2SV> struct bpf_map * map ; //<S2SV> struct fd f ; //<S2SV> if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || //<S2SV> insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || //<S2SV> insn [ 1 ] . off != 0 ) { //<S2SV> verbose ( "invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( insn -> src_reg == 0 ) //<S2SV> goto next_insn ; //<S2SV> if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { //<S2SV> verbose ( "unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> f = fdget ( insn -> imm ) ; //<S2SV> map = __bpf_map_get ( f ) ; //<S2SV> if ( IS_ERR ( map ) ) { //<S2SV> verbose ( "fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n" , //<S2SV> insn -> imm ) ; //<S2SV> return PTR_ERR ( map ) ; //<S2SV> } //<S2SV> insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; //<S2SV> insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; //<S2SV> for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) //<S2SV> if ( env -> used_maps [ j ] == map ) { //<S2SV> fdput ( f ) ; //<S2SV> goto next_insn ; //<S2SV> } //<S2SV> if ( env -> used_map_cnt >= MAX_USED_MAPS ) { //<S2SV> fdput ( f ) ; //<S2SV> return - E2BIG ; //<S2SV> } //<S2SV> map = bpf_map_inc ( map , false ) ; //<S2SV> if ( IS_ERR ( map ) ) { //<S2SV> fdput ( f ) ; //<S2SV> return PTR_ERR ( map ) ; //<S2SV> } //<S2SV> env -> used_maps [ env -> used_map_cnt ++ ] = map ; //<S2SV> fdput ( f ) ; //<S2SV> next_insn : //<S2SV> insn ++ ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 