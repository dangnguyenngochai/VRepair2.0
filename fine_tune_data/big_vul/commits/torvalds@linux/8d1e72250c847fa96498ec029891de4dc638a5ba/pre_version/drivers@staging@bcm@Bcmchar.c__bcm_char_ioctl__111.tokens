static long bcm_char_ioctl ( struct file * filp , UINT cmd , ULONG arg ) //<S2SV> { //<S2SV> struct bcm_tarang_data * pTarang = filp -> private_data ; //<S2SV> void __user * argp = ( void __user * ) arg ; //<S2SV> struct bcm_mini_adapter * Adapter = pTarang -> Adapter ; //<S2SV> INT Status = STATUS_FAILURE ; //<S2SV> int timeout = 0 ; //<S2SV> struct bcm_ioctl_buffer IoBuffer ; //<S2SV> int bytes ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Parameters<S2SV_blank>Passed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>IOCTL<S2SV_blank>cmd=0x%X<S2SV_blank>arg=0x%lX" , cmd , arg ) ; //<S2SV> if ( _IOC_TYPE ( cmd ) != BCM_IOCTL ) //<S2SV> return - EFAULT ; //<S2SV> if ( _IOC_DIR ( cmd ) & _IOC_READ ) //<S2SV> Status = ! access_ok ( VERIFY_WRITE , argp , _IOC_SIZE ( cmd ) ) ; //<S2SV> else if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) //<S2SV> Status = ! access_ok ( VERIFY_READ , argp , _IOC_SIZE ( cmd ) ) ; //<S2SV> else if ( _IOC_NONE == ( _IOC_DIR ( cmd ) & _IOC_NONE ) ) //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> if ( Status ) //<S2SV> return - EFAULT ; //<S2SV> if ( Adapter -> device_removed ) //<S2SV> return - EFAULT ; //<S2SV> if ( FALSE == Adapter -> fw_download_done ) { //<S2SV> switch ( cmd ) { //<S2SV> case IOCTL_MAC_ADDR_REQ : //<S2SV> case IOCTL_LINK_REQ : //<S2SV> case IOCTL_CM_REQUEST : //<S2SV> case IOCTL_SS_INFO_REQ : //<S2SV> case IOCTL_SEND_CONTROL_MESSAGE : //<S2SV> case IOCTL_IDLE_REQ : //<S2SV> case IOCTL_BCM_GPIO_SET_REQUEST : //<S2SV> case IOCTL_BCM_GPIO_STATUS_REQUEST : //<S2SV> return - EACCES ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> Status = vendorextnIoctl ( Adapter , cmd , arg ) ; //<S2SV> if ( Status != CONTINUE_COMMON_PATH ) //<S2SV> return Status ; //<S2SV> switch ( cmd ) { //<S2SV> case IOCTL_BCM_REGISTER_READ_PRIVATE : { //<S2SV> struct bcm_rdm_buffer sRdmBuffer = { 0 } ; //<S2SV> PCHAR temp_buff ; //<S2SV> UINT Bufflen ; //<S2SV> u16 temp_value ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . OutputLength > USHRT_MAX || //<S2SV> IoBuffer . OutputLength == 0 ) { //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> Bufflen = IoBuffer . OutputLength ; //<S2SV> temp_value = 4 - ( Bufflen % 4 ) ; //<S2SV> Bufflen += temp_value % 4 ; //<S2SV> temp_buff = kmalloc ( Bufflen , GFP_KERNEL ) ; //<S2SV> if ( ! temp_buff ) //<S2SV> return - ENOMEM ; //<S2SV> bytes = rdmalt ( Adapter , ( UINT ) sRdmBuffer . Register , //<S2SV> ( PUINT ) temp_buff , Bufflen ) ; //<S2SV> if ( bytes > 0 ) { //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { //<S2SV> kfree ( temp_buff ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> } else { //<S2SV> Status = bytes ; //<S2SV> } //<S2SV> kfree ( temp_buff ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_REGISTER_WRITE_PRIVATE : { //<S2SV> struct bcm_wrm_buffer sWrmBuffer = { 0 } ; //<S2SV> UINT uiTempVar = 0 ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; //<S2SV> if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && //<S2SV> ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_2 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_3 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_4 ) ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> Status = wrmalt ( Adapter , ( UINT ) sWrmBuffer . Register , //<S2SV> ( PUINT ) sWrmBuffer . Data , sizeof ( ULONG ) ) ; //<S2SV> if ( Status == STATUS_SUCCESS ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>Done\\n" ) ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>Failed\\n" ) ; //<S2SV> Status = - EFAULT ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_REGISTER_READ : //<S2SV> case IOCTL_BCM_EEPROM_REGISTER_READ : { //<S2SV> struct bcm_rdm_buffer sRdmBuffer = { 0 } ; //<S2SV> PCHAR temp_buff = NULL ; //<S2SV> UINT uiTempVar = 0 ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Rdms\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . OutputLength > USHRT_MAX || //<S2SV> IoBuffer . OutputLength == 0 ) { //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> temp_buff = kmalloc ( IoBuffer . OutputLength , GFP_KERNEL ) ; //<S2SV> if ( ! temp_buff ) //<S2SV> return STATUS_FAILURE ; //<S2SV> if ( ( ( ( ULONG ) sRdmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || //<S2SV> ( ( ULONG ) sRdmBuffer . Register & 0x3 ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "RDM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n" , //<S2SV> ( int ) sRdmBuffer . Register ) ; //<S2SV> kfree ( temp_buff ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> uiTempVar = sRdmBuffer . Register & EEPROM_REJECT_MASK ; //<S2SV> bytes = rdmaltWithLock ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , IoBuffer . OutputLength ) ; //<S2SV> if ( bytes > 0 ) { //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { //<S2SV> kfree ( temp_buff ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> } else { //<S2SV> Status = bytes ; //<S2SV> } //<S2SV> kfree ( temp_buff ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_REGISTER_WRITE : //<S2SV> case IOCTL_BCM_EEPROM_REGISTER_WRITE : { //<S2SV> struct bcm_wrm_buffer sWrmBuffer = { 0 } ; //<S2SV> UINT uiTempVar = 0 ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( ( ( ( ULONG ) sWrmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || //<S2SV> ( ( ULONG ) sWrmBuffer . Register & 0x3 ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n" , ( int ) sWrmBuffer . Register ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; //<S2SV> if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && //<S2SV> ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_2 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_3 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && //<S2SV> ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> Status = wrmaltWithLock ( Adapter , ( UINT ) sWrmBuffer . Register , //<S2SV> ( PUINT ) sWrmBuffer . Data , sWrmBuffer . Length ) ; //<S2SV> if ( Status == STATUS_SUCCESS ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>Done\\n" ) ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>Failed\\n" ) ; //<S2SV> Status = - EFAULT ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_GPIO_SET_REQUEST : { //<S2SV> UCHAR ucResetValue [ 4 ] ; //<S2SV> UINT value = 0 ; //<S2SV> UINT uiBit = 0 ; //<S2SV> UINT uiOperation = 0 ; //<S2SV> struct bcm_gpio_info gpio_info = { 0 } ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> uiBit = gpio_info . uiGpioNumber ; //<S2SV> uiOperation = gpio_info . uiGpioValue ; //<S2SV> value = ( 1 << uiBit ) ; //<S2SV> if ( IsReqGpioIsLedInNVM ( Adapter , value ) == FALSE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>LED<S2SV_blank>!!!" , value ) ; //<S2SV> Status = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( uiOperation ) { //<S2SV> Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; //<S2SV> if ( Status == STATUS_SUCCESS ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n" ) ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n" , uiBit ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } else { //<S2SV> Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; //<S2SV> if ( Status == STATUS_SUCCESS ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n" ) ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Failed<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n" , uiBit ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; //<S2SV> if ( bytes < 0 ) { //<S2SV> Status = bytes ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , //<S2SV> "GPIO_MODE_REGISTER<S2SV_blank>read<S2SV_blank>failed" ) ; //<S2SV> break ; //<S2SV> } else { //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> * ( UINT * ) ucResetValue |= ( 1 << uiBit ) ; //<S2SV> Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , //<S2SV> ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; //<S2SV> if ( Status == STATUS_SUCCESS ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>to<S2SV_blank>output<S2SV_blank>Mode\\n" ) ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>GPIO<S2SV_blank>in<S2SV_blank>Output<S2SV_blank>Mode\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case BCM_LED_THREAD_STATE_CHANGE_REQ : { //<S2SV> struct bcm_user_thread_req threadReq = { 0 } ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "User<S2SV_blank>made<S2SV_blank>LED<S2SV_blank>thread<S2SV_blank>InActive" ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode" ) ; //<S2SV> Status = - EACCES ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( threadReq ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & threadReq , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( Adapter -> LEDInfo . led_thread_running ) { //<S2SV> if ( threadReq . ThreadState == LED_THREAD_ACTIVATION_REQ ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Activating<S2SV_blank>thread<S2SV_blank>req" ) ; //<S2SV> Adapter -> DriverState = LED_THREAD_ACTIVE ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "DeActivating<S2SV_blank>Thread<S2SV_blank>req....." ) ; //<S2SV> Adapter -> DriverState = LED_THREAD_INACTIVE ; //<S2SV> } //<S2SV> wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_GPIO_STATUS_REQUEST : { //<S2SV> ULONG uiBit = 0 ; //<S2SV> UCHAR ucRead [ 4 ] ; //<S2SV> struct bcm_gpio_info gpio_info = { 0 } ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) //<S2SV> return - EACCES ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> uiBit = gpio_info . uiGpioNumber ; //<S2SV> bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , //<S2SV> ( PUINT ) ucRead , sizeof ( UINT ) ) ; //<S2SV> if ( bytes < 0 ) { //<S2SV> Status = bytes ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "RDM<S2SV_blank>Failed\\n" ) ; //<S2SV> return Status ; //<S2SV> } else { //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_GPIO_MULTI_REQUEST : { //<S2SV> UCHAR ucResetValue [ 4 ] ; //<S2SV> struct bcm_gpio_multi_info gpio_multi_info [ MAX_IDX ] ; //<S2SV> struct bcm_gpio_multi_info * pgpio_multi_info = ( struct bcm_gpio_multi_info * ) gpio_multi_info ; //<S2SV> memset ( pgpio_multi_info , 0 , MAX_IDX * sizeof ( struct bcm_gpio_multi_info ) ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( gpio_multi_info ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & gpio_multi_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , //<S2SV> "Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!" , //<S2SV> pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; //<S2SV> Status = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) & //<S2SV> ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand ) ) { //<S2SV> * ( UINT * ) ucResetValue = pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & //<S2SV> pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & //<S2SV> pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ; //<S2SV> if ( * ( UINT * ) ucResetValue ) //<S2SV> Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , //<S2SV> ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; //<S2SV> if ( Status != STATUS_SUCCESS ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_SET_REG<S2SV_blank>Failed." ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> * ( UINT * ) ucResetValue = ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & //<S2SV> pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & //<S2SV> ( ~ ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ) ) ) ; //<S2SV> if ( * ( UINT * ) ucResetValue ) //<S2SV> Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; //<S2SV> if ( Status != STATUS_SUCCESS ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_CLR_REG<S2SV_blank>Failed." ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> } //<S2SV> if ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) { //<S2SV> bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; //<S2SV> if ( bytes < 0 ) { //<S2SV> Status = bytes ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "RDM<S2SV_blank>to<S2SV_blank>GPIO_PIN_STATE_REGISTER<S2SV_blank>Failed." ) ; //<S2SV> return Status ; //<S2SV> } else { //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue = ( * ( UINT * ) ucResetValue & //<S2SV> pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) ; //<S2SV> } //<S2SV> Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_info , IoBuffer . OutputLength ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d" , Status ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_GPIO_MODE_REQUEST : { //<S2SV> UCHAR ucResetValue [ 4 ] ; //<S2SV> struct bcm_gpio_multi_mode gpio_multi_mode [ MAX_IDX ] ; //<S2SV> struct bcm_gpio_multi_mode * pgpio_multi_mode = ( struct bcm_gpio_multi_mode * ) gpio_multi_mode ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( gpio_multi_mode ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( & gpio_multi_mode , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) //<S2SV> return - EFAULT ; //<S2SV> bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; //<S2SV> if ( bytes < 0 ) { //<S2SV> Status = bytes ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Read<S2SV_blank>of<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>failed" ) ; //<S2SV> return Status ; //<S2SV> } else { //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , //<S2SV> "Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!" , //<S2SV> pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; //<S2SV> Status = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) { //<S2SV> * ( UINT * ) ucResetValue |= ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode & //<S2SV> pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; //<S2SV> * ( UINT * ) ucResetValue &= ~ ( ( ~ pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode ) & //<S2SV> pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; //<S2SV> pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; //<S2SV> Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; //<S2SV> if ( Status == STATUS_SUCCESS ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , //<S2SV> "WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Done" ) ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Failed" ) ; //<S2SV> Status = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> } else { //<S2SV> pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; //<S2SV> } //<S2SV> Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_mode , IoBuffer . OutputLength ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d" , Status ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_MAC_ADDR_REQ : //<S2SV> case IOCTL_LINK_REQ : //<S2SV> case IOCTL_CM_REQUEST : //<S2SV> case IOCTL_SS_INFO_REQ : //<S2SV> case IOCTL_SEND_CONTROL_MESSAGE : //<S2SV> case IOCTL_IDLE_REQ : { //<S2SV> PVOID pvBuffer = NULL ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength < sizeof ( struct bcm_link_request ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( IoBuffer . InputLength > MAX_CNTL_PKT_SIZE ) //<S2SV> return - EINVAL ; //<S2SV> pvBuffer = memdup_user ( IoBuffer . InputBuffer , //<S2SV> IoBuffer . InputLength ) ; //<S2SV> if ( IS_ERR ( pvBuffer ) ) //<S2SV> return PTR_ERR ( pvBuffer ) ; //<S2SV> down ( & Adapter -> LowPowerModeSync ) ; //<S2SV> Status = wait_event_interruptible_timeout ( Adapter -> lowpower_mode_wait_queue , //<S2SV> ! Adapter -> bPreparingForLowPowerMode , //<S2SV> ( 1 * HZ ) ) ; //<S2SV> if ( Status == - ERESTARTSYS ) //<S2SV> goto cntrlEnd ; //<S2SV> if ( Adapter -> bPreparingForLowPowerMode ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , //<S2SV> "Preparing<S2SV_blank>Idle<S2SV_blank>Mode<S2SV_blank>is<S2SV_blank>still<S2SV_blank>True<S2SV_blank>-<S2SV_blank>Hence<S2SV_blank>Rejecting<S2SV_blank>control<S2SV_blank>message\\n" ) ; //<S2SV> Status = STATUS_FAILURE ; //<S2SV> goto cntrlEnd ; //<S2SV> } //<S2SV> Status = CopyBufferToControlPacket ( Adapter , ( PVOID ) pvBuffer ) ; //<S2SV> cntrlEnd : //<S2SV> up ( & Adapter -> LowPowerModeSync ) ; //<S2SV> kfree ( pvBuffer ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_BUFFER_DOWNLOAD_START : { //<S2SV> if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , //<S2SV> "IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n" , current -> pid ) ; //<S2SV> if ( down_trylock ( & Adapter -> fw_download_sema ) ) //<S2SV> return - EBUSY ; //<S2SV> Adapter -> bBinDownloaded = FALSE ; //<S2SV> Adapter -> fw_download_process_pid = current -> pid ; //<S2SV> Adapter -> bCfgDownloaded = FALSE ; //<S2SV> Adapter -> fw_download_done = FALSE ; //<S2SV> netif_carrier_off ( Adapter -> dev ) ; //<S2SV> netif_stop_queue ( Adapter -> dev ) ; //<S2SV> Status = reset_card_proc ( Adapter ) ; //<S2SV> if ( Status ) { //<S2SV> pr_err ( PFX "%s:<S2SV_blank>reset_card_proc<S2SV_blank>Failed!\\n" , Adapter -> dev -> name ) ; //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> mdelay ( 10 ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> case IOCTL_BCM_BUFFER_DOWNLOAD : { //<S2SV> struct bcm_firmware_info * psFwInfo = NULL ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n" , current -> pid ) ; //<S2SV> if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "Invalid<S2SV_blank>way<S2SV_blank>to<S2SV_blank>download<S2SV_blank>buffer.<S2SV_blank>Use<S2SV_blank>Start<S2SV_blank>and<S2SV_blank>then<S2SV_blank>call<S2SV_blank>this!!!\\n" ) ; //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> Status = - EINVAL ; //<S2SV> return Status ; //<S2SV> } //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "Length<S2SV_blank>for<S2SV_blank>FW<S2SV_blank>DLD<S2SV_blank>is<S2SV_blank>:<S2SV_blank>%lx\\n" , IoBuffer . InputLength ) ; //<S2SV> if ( IoBuffer . InputLength > sizeof ( struct bcm_firmware_info ) ) { //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> psFwInfo = kmalloc ( sizeof ( * psFwInfo ) , GFP_KERNEL ) ; //<S2SV> if ( ! psFwInfo ) { //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> if ( copy_from_user ( psFwInfo , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) { //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> kfree ( psFwInfo ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( ! psFwInfo -> pvMappedFirmwareAddress || //<S2SV> ( psFwInfo -> u32FirmwareLength == 0 ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Something<S2SV_blank>else<S2SV_blank>is<S2SV_blank>wrong<S2SV_blank>%lu\\n" , //<S2SV> psFwInfo -> u32FirmwareLength ) ; //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> kfree ( psFwInfo ) ; //<S2SV> Status = - EINVAL ; //<S2SV> return Status ; //<S2SV> } //<S2SV> Status = bcm_ioctl_fw_download ( Adapter , psFwInfo ) ; //<S2SV> if ( Status != STATUS_SUCCESS ) { //<S2SV> if ( psFwInfo -> u32StartingAddress == CONFIG_BEGIN_ADDR ) //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "IOCTL:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n" ) ; //<S2SV> else //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n" ) ; //<S2SV> if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { //<S2SV> Adapter -> DriverState = DRIVER_INIT ; //<S2SV> Adapter -> LEDInfo . bLedInitDone = FALSE ; //<S2SV> wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( Status != STATUS_SUCCESS ) //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , "IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Uploaded\\n" ) ; //<S2SV> kfree ( psFwInfo ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> case IOCTL_BCM_BUFFER_DOWNLOAD_STOP : { //<S2SV> if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "FW<S2SV_blank>download<S2SV_blank>blocked<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n" ) ; //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> Adapter -> bBinDownloaded = TRUE ; //<S2SV> Adapter -> bCfgDownloaded = TRUE ; //<S2SV> atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; //<S2SV> Adapter -> CurrNumRecvDescs = 0 ; //<S2SV> Adapter -> downloadDDR = 0 ; //<S2SV> Status = run_card_proc ( Adapter ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Firm<S2SV_blank>Download<S2SV_blank>Failed\\n" ) ; //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> return Status ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , //<S2SV> DBG_LVL_ALL , "Firm<S2SV_blank>Download<S2SV_blank>Over...\\n" ) ; //<S2SV> } //<S2SV> mdelay ( 10 ) ; //<S2SV> if ( StartInterruptUrb ( ( struct bcm_interface_adapter * ) Adapter -> pvInterfaceAdapter ) ) //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>interrupt...\\n" ) ; //<S2SV> timeout = 5 * HZ ; //<S2SV> Adapter -> waiting_to_fw_download_done = FALSE ; //<S2SV> wait_event_timeout ( Adapter -> ioctl_fw_dnld_wait_queue , //<S2SV> Adapter -> waiting_to_fw_download_done , timeout ) ; //<S2SV> Adapter -> fw_download_process_pid = INVALID_PID ; //<S2SV> Adapter -> fw_download_done = TRUE ; //<S2SV> atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; //<S2SV> Adapter -> CurrNumRecvDescs = 0 ; //<S2SV> Adapter -> PrevNumRecvDescs = 0 ; //<S2SV> atomic_set ( & Adapter -> cntrlpktCnt , 0 ) ; //<S2SV> Adapter -> LinkUpStatus = 0 ; //<S2SV> Adapter -> LinkStatus = 0 ; //<S2SV> if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { //<S2SV> Adapter -> DriverState = FW_DOWNLOAD_DONE ; //<S2SV> wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; //<S2SV> } //<S2SV> if ( ! timeout ) //<S2SV> Status = - ENODEV ; //<S2SV> up ( & Adapter -> fw_download_sema ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> case IOCTL_BE_BUCKET_SIZE : //<S2SV> Status = 0 ; //<S2SV> if ( get_user ( Adapter -> BEBucketSize , ( unsigned long __user * ) arg ) ) //<S2SV> Status = - EFAULT ; //<S2SV> break ; //<S2SV> case IOCTL_RTPS_BUCKET_SIZE : //<S2SV> Status = 0 ; //<S2SV> if ( get_user ( Adapter -> rtPSBucketSize , ( unsigned long __user * ) arg ) ) //<S2SV> Status = - EFAULT ; //<S2SV> break ; //<S2SV> case IOCTL_CHIP_RESET : { //<S2SV> INT NVMAccess = down_trylock ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( NVMAccess ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "<S2SV_blank>IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> down ( & Adapter -> RxAppControlQueuelock ) ; //<S2SV> Status = reset_card_proc ( Adapter ) ; //<S2SV> flushAllAppQ ( ) ; //<S2SV> up ( & Adapter -> RxAppControlQueuelock ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> ResetCounters ( Adapter ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_QOS_THRESHOLD : { //<S2SV> USHORT uiLoopIndex ; //<S2SV> Status = 0 ; //<S2SV> for ( uiLoopIndex = 0 ; uiLoopIndex < NO_OF_QUEUES ; uiLoopIndex ++ ) { //<S2SV> if ( get_user ( Adapter -> PackInfo [ uiLoopIndex ] . uiThreshold , //<S2SV> ( unsigned long __user * ) arg ) ) { //<S2SV> Status = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_DUMP_PACKET_INFO : //<S2SV> DumpPackInfo ( Adapter ) ; //<S2SV> DumpPhsRules ( & Adapter -> stBCMPhsContext ) ; //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> break ; //<S2SV> case IOCTL_GET_PACK_INFO : //<S2SV> if ( copy_to_user ( argp , & Adapter -> PackInfo , sizeof ( struct bcm_packet_info ) * NO_OF_QUEUES ) ) //<S2SV> return - EFAULT ; //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> break ; //<S2SV> case IOCTL_BCM_SWITCH_TRANSFER_MODE : { //<S2SV> UINT uiData = 0 ; //<S2SV> if ( copy_from_user ( & uiData , argp , sizeof ( UINT ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( uiData ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>ETH_PACKET_TUNNELING_MODE\\n" ) ; //<S2SV> Adapter -> TransferMode = ETH_PACKET_TUNNELING_MODE ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>IP_PACKET_ONLY_MODE\\n" ) ; //<S2SV> Adapter -> TransferMode = IP_PACKET_ONLY_MODE ; //<S2SV> } //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_GET_DRIVER_VERSION : { //<S2SV> ulong len ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> len = min_t ( ulong , IoBuffer . OutputLength , strlen ( DRV_VERSION ) + 1 ) ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , DRV_VERSION , len ) ) //<S2SV> return - EFAULT ; //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_GET_CURRENT_STATUS : { //<S2SV> struct bcm_link_state link_state ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "copy_from_user<S2SV_blank>failed..\\n" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( IoBuffer . OutputLength != sizeof ( link_state ) ) { //<S2SV> Status = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> memset ( & link_state , 0 , sizeof ( link_state ) ) ; //<S2SV> link_state . bIdleMode = Adapter -> IdleMode ; //<S2SV> link_state . bShutdownMode = Adapter -> bShutStatus ; //<S2SV> link_state . ucLinkStatus = Adapter -> LinkStatus ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , & link_state , min_t ( size_t , sizeof ( link_state ) , IoBuffer . OutputLength ) ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy_to_user<S2SV_blank>Failed..\\n" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_SET_MAC_TRACING : { //<S2SV> UINT tracing_flag ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_from_user ( & tracing_flag , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( tracing_flag ) //<S2SV> Adapter -> pTarangs -> MacTracingEnabled = TRUE ; //<S2SV> else //<S2SV> Adapter -> pTarangs -> MacTracingEnabled = FALSE ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_GET_DSX_INDICATION : { //<S2SV> ULONG ulSFId = 0 ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . OutputLength < sizeof ( struct bcm_add_indication_alt ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "Mismatch<S2SV_blank>req:<S2SV_blank>%lx<S2SV_blank>needed<S2SV_blank>is<S2SV_blank>=0x%zx!!!" , //<S2SV> IoBuffer . OutputLength , sizeof ( struct bcm_add_indication_alt ) ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( copy_from_user ( & ulSFId , IoBuffer . InputBuffer , sizeof ( ulSFId ) ) ) //<S2SV> return - EFAULT ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Get<S2SV_blank>DSX<S2SV_blank>Data<S2SV_blank>SF<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>=%lx\\n" , ulSFId ) ; //<S2SV> get_dsx_sf_data_to_application ( Adapter , ulSFId , IoBuffer . OutputBuffer ) ; //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_GET_HOST_MIBS : { //<S2SV> PVOID temp_buff ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . OutputLength != sizeof ( struct bcm_host_stats_mibs ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , //<S2SV> "Length<S2SV_blank>Check<S2SV_blank>failed<S2SV_blank>%lu<S2SV_blank>%zd\\n" , //<S2SV> IoBuffer . OutputLength , sizeof ( struct bcm_host_stats_mibs ) ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> temp_buff = kzalloc ( sizeof ( struct bcm_host_stats_mibs ) , GFP_KERNEL ) ; //<S2SV> if ( ! temp_buff ) //<S2SV> return STATUS_FAILURE ; //<S2SV> Status = ProcessGetHostMibs ( Adapter , temp_buff ) ; //<S2SV> GetDroppedAppCntrlPktMibs ( temp_buff , pTarang ) ; //<S2SV> if ( Status != STATUS_FAILURE ) //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , sizeof ( struct bcm_host_stats_mibs ) ) ) { //<S2SV> kfree ( temp_buff ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> kfree ( temp_buff ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE : //<S2SV> if ( ( FALSE == Adapter -> bTriedToWakeUpFromlowPowerMode ) && ( TRUE == Adapter -> IdleMode ) ) { //<S2SV> Adapter -> usIdleModePattern = ABORT_IDLE_MODE ; //<S2SV> Adapter -> bWakeUpDevice = TRUE ; //<S2SV> wake_up ( & Adapter -> process_rx_cntrlpkt ) ; //<S2SV> } //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> break ; //<S2SV> case IOCTL_BCM_BULK_WRM : { //<S2SV> struct bcm_bulk_wrm_buffer * pBulkBuffer ; //<S2SV> UINT uiTempVar = 0 ; //<S2SV> PCHAR pvBuffer = NULL ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n" ) ; //<S2SV> Status = - EACCES ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . InputLength < sizeof ( ULONG ) * 2 ) //<S2SV> return - EINVAL ; //<S2SV> pvBuffer = memdup_user ( IoBuffer . InputBuffer , //<S2SV> IoBuffer . InputLength ) ; //<S2SV> if ( IS_ERR ( pvBuffer ) ) //<S2SV> return PTR_ERR ( pvBuffer ) ; //<S2SV> pBulkBuffer = ( struct bcm_bulk_wrm_buffer * ) pvBuffer ; //<S2SV> if ( ( ( ULONG ) pBulkBuffer -> Register & 0x0F000000 ) != 0x0F000000 || //<S2SV> ( ( ULONG ) pBulkBuffer -> Register & 0x3 ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n" , ( int ) pBulkBuffer -> Register ) ; //<S2SV> kfree ( pvBuffer ) ; //<S2SV> Status = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> uiTempVar = pBulkBuffer -> Register & EEPROM_REJECT_MASK ; //<S2SV> if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && //<S2SV> ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_2 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_3 ) || //<S2SV> ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && //<S2SV> ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { //<S2SV> kfree ( pvBuffer ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n" ) ; //<S2SV> Status = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( pBulkBuffer -> SwapEndian == FALSE ) //<S2SV> Status = wrmWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PCHAR ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; //<S2SV> else //<S2SV> Status = wrmaltWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PUINT ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; //<S2SV> if ( Status != STATUS_SUCCESS ) //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>Failed\\n" ) ; //<S2SV> kfree ( pvBuffer ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_GET_NVM_SIZE : //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( Adapter -> eNVMType == NVM_EEPROM || Adapter -> eNVMType == NVM_FLASH ) { //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiNVMDSDSize , sizeof ( UINT ) ) ) //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> break ; //<S2SV> case IOCTL_BCM_CAL_INIT : { //<S2SV> UINT uiSectorSize = 0 ; //<S2SV> if ( Adapter -> eNVMType == NVM_FLASH ) { //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_from_user ( & uiSectorSize , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( ( uiSectorSize < MIN_SECTOR_SIZE ) || ( uiSectorSize > MAX_SECTOR_SIZE ) ) { //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , //<S2SV> sizeof ( UINT ) ) ) //<S2SV> return - EFAULT ; //<S2SV> } else { //<S2SV> if ( IsFlash2x ( Adapter ) ) { //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) //<S2SV> return - EFAULT ; //<S2SV> } else { //<S2SV> if ( ( TRUE == Adapter -> bShutStatus ) || ( TRUE == Adapter -> IdleMode ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> Adapter -> uiSectorSize = uiSectorSize ; //<S2SV> BcmUpdateSectorSize ( Adapter , Adapter -> uiSectorSize ) ; //<S2SV> } //<S2SV> } //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> } else { //<S2SV> Status = STATUS_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_SET_DEBUG : //<S2SV> # ifdef DEBUG //<S2SV> { //<S2SV> struct bcm_user_debug_state sUserDebugState ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "In<S2SV_blank>SET_DEBUG<S2SV_blank>ioctl\\n" ) ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_from_user ( & sUserDebugState , IoBuffer . InputBuffer , sizeof ( struct bcm_user_debug_state ) ) ) //<S2SV> return - EFAULT ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "IOCTL_BCM_SET_DEBUG:<S2SV_blank>OnOff=%d<S2SV_blank>Type<S2SV_blank>=<S2SV_blank>0x%x<S2SV_blank>" , //<S2SV> sUserDebugState . OnOff , sUserDebugState . Type ) ; //<S2SV> sUserDebugState . Subtype = 1 << sUserDebugState . Subtype ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "actual<S2SV_blank>Subtype=0x%x\\n" , sUserDebugState . Subtype ) ; //<S2SV> Adapter -> stDebugState . type |= sUserDebugState . Type ; //<S2SV> if ( sUserDebugState . OnOff ) //<S2SV> Adapter -> stDebugState . subtype [ sUserDebugState . Type ] |= sUserDebugState . Subtype ; //<S2SV> else //<S2SV> Adapter -> stDebugState . subtype [ sUserDebugState . Type ] &= ~ sUserDebugState . Subtype ; //<S2SV> BCM_SHOW_DEBUG_BITMAP ( Adapter ) ; //<S2SV> } //<S2SV> # endif //<S2SV> break ; //<S2SV> case IOCTL_BCM_NVM_READ : //<S2SV> case IOCTL_BCM_NVM_WRITE : { //<S2SV> struct bcm_nvm_readwrite stNVMReadWrite ; //<S2SV> PUCHAR pReadData = NULL ; //<S2SV> ULONG ulDSDMagicNumInUsrBuff = 0 ; //<S2SV> struct timeval tv0 , tv1 ; //<S2SV> memset ( & tv0 , 0 , sizeof ( struct timeval ) ) ; //<S2SV> memset ( & tv1 , 0 , sizeof ( struct timeval ) ) ; //<S2SV> if ( ( Adapter -> eNVMType == NVM_FLASH ) && ( Adapter -> uiFlashLayoutMajorVersion == 0 ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "The<S2SV_blank>Flash<S2SV_blank>Control<S2SV_blank>Section<S2SV_blank>is<S2SV_blank>Corrupted.<S2SV_blank>Hence<S2SV_blank>Rejection<S2SV_blank>on<S2SV_blank>NVM<S2SV_blank>Read/Write\\n" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( IsFlash2x ( Adapter ) ) { //<S2SV> if ( ( Adapter -> eActiveDSD != DSD0 ) && //<S2SV> ( Adapter -> eActiveDSD != DSD1 ) && //<S2SV> ( Adapter -> eActiveDSD != DSD2 ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "No<S2SV_blank>DSD<S2SV_blank>is<S2SV_blank>active..hence<S2SV_blank>NVM<S2SV_blank>Command<S2SV_blank>is<S2SV_blank>blocked" ) ; //<S2SV> return STATUS_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_from_user ( & stNVMReadWrite , //<S2SV> ( IOCTL_BCM_NVM_READ == cmd ) ? IoBuffer . OutputBuffer : IoBuffer . InputBuffer , //<S2SV> sizeof ( struct bcm_nvm_readwrite ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( stNVMReadWrite . uiNumBytes > Adapter -> uiNVMDSDSize ) //<S2SV> return STATUS_FAILURE ; //<S2SV> if ( stNVMReadWrite . uiOffset > Adapter -> uiNVMDSDSize - stNVMReadWrite . uiNumBytes ) { //<S2SV> return STATUS_FAILURE ; //<S2SV> } //<S2SV> pReadData = memdup_user ( stNVMReadWrite . pBuffer , //<S2SV> stNVMReadWrite . uiNumBytes ) ; //<S2SV> if ( IS_ERR ( pReadData ) ) //<S2SV> return PTR_ERR ( pReadData ) ; //<S2SV> do_gettimeofday ( & tv0 ) ; //<S2SV> if ( IOCTL_BCM_NVM_READ == cmd ) { //<S2SV> down ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadData ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( Status != STATUS_SUCCESS ) { //<S2SV> kfree ( pReadData ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> if ( copy_to_user ( stNVMReadWrite . pBuffer , pReadData , stNVMReadWrite . uiNumBytes ) ) { //<S2SV> kfree ( pReadData ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> } else { //<S2SV> down ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadData ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> Adapter -> bHeaderChangeAllowed = TRUE ; //<S2SV> if ( IsFlash2x ( Adapter ) ) { //<S2SV> Status = BcmFlash2xCorruptSig ( Adapter , Adapter -> eActiveDSD ) ; //<S2SV> if ( Status != STATUS_SUCCESS ) { //<S2SV> if ( ( ( stNVMReadWrite . uiOffset + stNVMReadWrite . uiNumBytes ) != Adapter -> uiNVMDSDSize ) || //<S2SV> ( stNVMReadWrite . uiNumBytes < SIGNATURE_SIZE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.." ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadData ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> ulDSDMagicNumInUsrBuff = ntohl ( * ( PUINT ) ( pReadData + stNVMReadWrite . uiNumBytes - SIGNATURE_SIZE ) ) ; //<S2SV> if ( ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.." ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadData ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> Status = BeceemNVMWrite ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes , stNVMReadWrite . bVerify ) ; //<S2SV> if ( IsFlash2x ( Adapter ) ) //<S2SV> BcmFlash2xWriteSig ( Adapter , Adapter -> eActiveDSD ) ; //<S2SV> Adapter -> bHeaderChangeAllowed = FALSE ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( Status != STATUS_SUCCESS ) { //<S2SV> kfree ( pReadData ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> } //<S2SV> do_gettimeofday ( & tv1 ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "<S2SV_blank>timetaken<S2SV_blank>by<S2SV_blank>Write/read<S2SV_blank>:%ld<S2SV_blank>msec\\n" , ( tv1 . tv_sec - tv0 . tv_sec ) * 1000 + ( tv1 . tv_usec - tv0 . tv_usec ) / 1000 ) ; //<S2SV> kfree ( pReadData ) ; //<S2SV> return STATUS_SUCCESS ; //<S2SV> } //<S2SV> case IOCTL_BCM_FLASH2X_SECTION_READ : { //<S2SV> struct bcm_flash2x_readwrite sFlash2xRead = { 0 } ; //<S2SV> PUCHAR pReadBuff = NULL ; //<S2SV> UINT NOB = 0 ; //<S2SV> UINT BuffSize = 0 ; //<S2SV> UINT ReadBytes = 0 ; //<S2SV> UINT ReadOffset = 0 ; //<S2SV> void __user * OutPutBuff ; //<S2SV> if ( IsFlash2x ( Adapter ) != TRUE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_FLASH2X_SECTION_READ<S2SV_blank>Called" ) ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_from_user ( & sFlash2xRead , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) //<S2SV> return - EFAULT ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.Section<S2SV_blank>:%x" , sFlash2xRead . Section ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.offset<S2SV_blank>:%x" , sFlash2xRead . offset ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x" , sFlash2xRead . numOfBytes ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n" , sFlash2xRead . bVerify ) ; //<S2SV> if ( validateFlash2xReadWrite ( Adapter , & sFlash2xRead ) == FALSE ) //<S2SV> return STATUS_FAILURE ; //<S2SV> NOB = sFlash2xRead . numOfBytes ; //<S2SV> if ( NOB > Adapter -> uiSectorSize ) //<S2SV> BuffSize = Adapter -> uiSectorSize ; //<S2SV> else //<S2SV> BuffSize = NOB ; //<S2SV> ReadOffset = sFlash2xRead . offset ; //<S2SV> OutPutBuff = IoBuffer . OutputBuffer ; //<S2SV> pReadBuff = ( PCHAR ) kzalloc ( BuffSize , GFP_KERNEL ) ; //<S2SV> if ( pReadBuff == NULL ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> down ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadBuff ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> while ( NOB ) { //<S2SV> if ( NOB > Adapter -> uiSectorSize ) //<S2SV> ReadBytes = Adapter -> uiSectorSize ; //<S2SV> else //<S2SV> ReadBytes = NOB ; //<S2SV> Status = BcmFlash2xBulkRead ( Adapter , ( PUINT ) pReadBuff , sFlash2xRead . Section , ReadOffset , ReadBytes ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; //<S2SV> break ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; //<S2SV> Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d" , Status ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadBuff ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> NOB = NOB - ReadBytes ; //<S2SV> if ( NOB ) { //<S2SV> ReadOffset = ReadOffset + ReadBytes ; //<S2SV> OutPutBuff = OutPutBuff + ReadBytes ; //<S2SV> } //<S2SV> } //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadBuff ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_FLASH2X_SECTION_WRITE : { //<S2SV> struct bcm_flash2x_readwrite sFlash2xWrite = { 0 } ; //<S2SV> PUCHAR pWriteBuff ; //<S2SV> void __user * InputAddr ; //<S2SV> UINT NOB = 0 ; //<S2SV> UINT BuffSize = 0 ; //<S2SV> UINT WriteOffset = 0 ; //<S2SV> UINT WriteBytes = 0 ; //<S2SV> if ( IsFlash2x ( Adapter ) != TRUE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> Adapter -> bAllDSDWriteAllow = FALSE ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_FLASH2X_SECTION_WRITE<S2SV_blank>Called" ) ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( copy_from_user ( & sFlash2xWrite , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) //<S2SV> return - EFAULT ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.Section<S2SV_blank>:%x" , sFlash2xWrite . Section ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.offset<S2SV_blank>:%d" , sFlash2xWrite . offset ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x" , sFlash2xWrite . numOfBytes ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n" , sFlash2xWrite . bVerify ) ; //<S2SV> if ( ( sFlash2xWrite . Section != VSA0 ) && ( sFlash2xWrite . Section != VSA1 ) && ( sFlash2xWrite . Section != VSA2 ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Only<S2SV_blank>VSA<S2SV_blank>write<S2SV_blank>is<S2SV_blank>allowed" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( validateFlash2xReadWrite ( Adapter , & sFlash2xWrite ) == FALSE ) //<S2SV> return STATUS_FAILURE ; //<S2SV> InputAddr = sFlash2xWrite . pDataBuff ; //<S2SV> WriteOffset = sFlash2xWrite . offset ; //<S2SV> NOB = sFlash2xWrite . numOfBytes ; //<S2SV> if ( NOB > Adapter -> uiSectorSize ) //<S2SV> BuffSize = Adapter -> uiSectorSize ; //<S2SV> else //<S2SV> BuffSize = NOB ; //<S2SV> pWriteBuff = kmalloc ( BuffSize , GFP_KERNEL ) ; //<S2SV> if ( pWriteBuff == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> WriteBytes = Adapter -> uiSectorSize ; //<S2SV> if ( WriteOffset % Adapter -> uiSectorSize ) //<S2SV> WriteBytes = Adapter -> uiSectorSize - ( WriteOffset % Adapter -> uiSectorSize ) ; //<S2SV> if ( NOB < WriteBytes ) //<S2SV> WriteBytes = NOB ; //<S2SV> down ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pWriteBuff ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> BcmFlash2xCorruptSig ( Adapter , sFlash2xWrite . Section ) ; //<S2SV> do { //<S2SV> Status = copy_from_user ( pWriteBuff , InputAddr , WriteBytes ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>to<S2SV_blank>user<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d" , Status ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pWriteBuff ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pWriteBuff , WriteBytes ) ; //<S2SV> Status = BcmFlash2xBulkWrite ( Adapter , ( PUINT ) pWriteBuff , sFlash2xWrite . Section , WriteOffset , WriteBytes , sFlash2xWrite . bVerify ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; //<S2SV> break ; //<S2SV> } //<S2SV> NOB = NOB - WriteBytes ; //<S2SV> if ( NOB ) { //<S2SV> WriteOffset = WriteOffset + WriteBytes ; //<S2SV> InputAddr = InputAddr + WriteBytes ; //<S2SV> if ( NOB > Adapter -> uiSectorSize ) //<S2SV> WriteBytes = Adapter -> uiSectorSize ; //<S2SV> else //<S2SV> WriteBytes = NOB ; //<S2SV> } //<S2SV> } while ( NOB > 0 ) ; //<S2SV> BcmFlash2xWriteSig ( Adapter , sFlash2xWrite . Section ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pWriteBuff ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP : { //<S2SV> struct bcm_flash2x_bitmap * psFlash2xBitMap ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP<S2SV_blank>Called" ) ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . OutputLength != sizeof ( struct bcm_flash2x_bitmap ) ) //<S2SV> return - EINVAL ; //<S2SV> psFlash2xBitMap = kzalloc ( sizeof ( struct bcm_flash2x_bitmap ) , GFP_KERNEL ) ; //<S2SV> if ( psFlash2xBitMap == NULL ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Memory<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> down ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( psFlash2xBitMap ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> BcmGetFlash2xSectionalBitMap ( Adapter , psFlash2xBitMap ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , psFlash2xBitMap , sizeof ( struct bcm_flash2x_bitmap ) ) ) { //<S2SV> kfree ( psFlash2xBitMap ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> kfree ( psFlash2xBitMap ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_SET_ACTIVE_SECTION : { //<S2SV> enum bcm_flash2x_section_val eFlash2xSectionVal = 0 ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_SET_ACTIVE_SECTION<S2SV_blank>Called" ) ; //<S2SV> if ( IsFlash2x ( Adapter ) != TRUE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> down ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> Status = BcmSetActiveSection ( Adapter , eFlash2xSectionVal ) ; //<S2SV> if ( Status ) //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>it\'s<S2SV_blank>priority<S2SV_blank>Highest.<S2SV_blank>Status<S2SV_blank>%d" , Status ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION : { //<S2SV> Adapter -> bAllDSDWriteAllow = FALSE ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_IDENTIFY_ACTIVE_SECTION<S2SV_blank>called" ) ; //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_COPY_SECTION : { //<S2SV> struct bcm_flash2x_copy_section sCopySectStrut = { 0 } ; //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_COPY_SECTION<S2SV_blank><S2SV_blank>Called" ) ; //<S2SV> Adapter -> bAllDSDWriteAllow = FALSE ; //<S2SV> if ( IsFlash2x ( Adapter ) != TRUE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> Status = copy_from_user ( & sCopySectStrut , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_copy_section ) ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>Copy_Section_Struct<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Source<S2SV_blank>SEction<S2SV_blank>:%x" , sCopySectStrut . SrcSection ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Destination<S2SV_blank>SEction<S2SV_blank>:%x" , sCopySectStrut . DstSection ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "offset<S2SV_blank>:%x" , sCopySectStrut . offset ) ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "NOB<S2SV_blank>:%x" , sCopySectStrut . numOfBytes ) ; //<S2SV> if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . SrcSection ) == FALSE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Source<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>" , sCopySectStrut . SrcSection ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . DstSection ) == FALSE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Destinatio<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>" , sCopySectStrut . DstSection ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( sCopySectStrut . SrcSection == sCopySectStrut . DstSection ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Source<S2SV_blank>and<S2SV_blank>Destination<S2SV_blank>section<S2SV_blank>should<S2SV_blank>be<S2SV_blank>different" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> down ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( sCopySectStrut . SrcSection == ISO_IMAGE1 || sCopySectStrut . SrcSection == ISO_IMAGE2 ) { //<S2SV> if ( IsNonCDLessDevice ( Adapter ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>is<S2SV_blank>Non-CDLess<S2SV_blank>hence<S2SV_blank>won\'t<S2SV_blank>have<S2SV_blank>ISO<S2SV_blank>!!" ) ; //<S2SV> Status = - EINVAL ; //<S2SV> } else if ( sCopySectStrut . numOfBytes == 0 ) { //<S2SV> Status = BcmCopyISO ( Adapter , sCopySectStrut ) ; //<S2SV> } else { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Partial<S2SV_blank>Copy<S2SV_blank>of<S2SV_blank>ISO<S2SV_blank>section<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Allowed.." ) ; //<S2SV> Status = STATUS_FAILURE ; //<S2SV> } //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> return Status ; //<S2SV> } //<S2SV> Status = BcmCopySection ( Adapter , sCopySectStrut . SrcSection , //<S2SV> sCopySectStrut . DstSection , sCopySectStrut . offset , sCopySectStrut . numOfBytes ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_GET_FLASH_CS_INFO : { //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "<S2SV_blank>IOCTL_BCM_GET_FLASH_CS_INFO<S2SV_blank>Called" ) ; //<S2SV> Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( Adapter -> eNVMType != NVM_FLASH ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Connected<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>flash" ) ; //<S2SV> Status = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( IsFlash2x ( Adapter ) == TRUE ) { //<S2SV> if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash2x_cs_info ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlash2xCSInfo , sizeof ( struct bcm_flash2x_cs_info ) ) ) //<S2SV> return - EFAULT ; //<S2SV> } else { //<S2SV> if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash_cs_info ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlashCSInfo , sizeof ( struct bcm_flash_cs_info ) ) ) //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_SELECT_DSD : { //<S2SV> UINT SectOfset = 0 ; //<S2SV> enum bcm_flash2x_section_val eFlash2xSectionVal ; //<S2SV> eFlash2xSectionVal = NO_SECTION_VAL ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_SELECT_DSD<S2SV_blank>Called" ) ; //<S2SV> if ( IsFlash2x ( Adapter ) != TRUE ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Read<S2SV_blank>Section<S2SV_blank>:%d" , eFlash2xSectionVal ) ; //<S2SV> if ( ( eFlash2xSectionVal != DSD0 ) && //<S2SV> ( eFlash2xSectionVal != DSD1 ) && //<S2SV> ( eFlash2xSectionVal != DSD2 ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Passed<S2SV_blank>section<%x><S2SV_blank>is<S2SV_blank>not<S2SV_blank>DSD<S2SV_blank>section" , eFlash2xSectionVal ) ; //<S2SV> return STATUS_FAILURE ; //<S2SV> } //<S2SV> SectOfset = BcmGetSectionValStartOffset ( Adapter , eFlash2xSectionVal ) ; //<S2SV> if ( SectOfset == INVALID_OFFSET ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Provided<S2SV_blank>Section<S2SV_blank>val<S2SV_blank><%d><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>2.x" , eFlash2xSectionVal ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> Adapter -> bAllDSDWriteAllow = TRUE ; //<S2SV> Adapter -> ulFlashCalStart = SectOfset ; //<S2SV> Adapter -> eActiveDSD = eFlash2xSectionVal ; //<S2SV> } //<S2SV> Status = STATUS_SUCCESS ; //<S2SV> break ; //<S2SV> case IOCTL_BCM_NVM_RAW_READ : { //<S2SV> struct bcm_nvm_readwrite stNVMRead ; //<S2SV> INT NOB ; //<S2SV> INT BuffSize ; //<S2SV> INT ReadOffset = 0 ; //<S2SV> UINT ReadBytes = 0 ; //<S2SV> PUCHAR pReadBuff ; //<S2SV> void __user * OutPutBuff ; //<S2SV> if ( Adapter -> eNVMType != NVM_FLASH ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "NVM<S2SV_blank>TYPE<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Flash" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "copy_from_user<S2SV_blank>1<S2SV_blank>failed\\n" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( copy_from_user ( & stNVMRead , IoBuffer . OutputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) //<S2SV> return - EFAULT ; //<S2SV> NOB = stNVMRead . uiNumBytes ; //<S2SV> if ( NOB > DEFAULT_BUFF_SIZE ) //<S2SV> BuffSize = DEFAULT_BUFF_SIZE ; //<S2SV> else //<S2SV> BuffSize = NOB ; //<S2SV> ReadOffset = stNVMRead . uiOffset ; //<S2SV> OutPutBuff = stNVMRead . pBuffer ; //<S2SV> pReadBuff = kzalloc ( BuffSize , GFP_KERNEL ) ; //<S2SV> if ( pReadBuff == NULL ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure" ) ; //<S2SV> Status = - ENOMEM ; //<S2SV> break ; //<S2SV> } //<S2SV> down ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> if ( ( Adapter -> IdleMode == TRUE ) || //<S2SV> ( Adapter -> bShutStatus == TRUE ) || //<S2SV> ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; //<S2SV> kfree ( pReadBuff ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> Adapter -> bFlashRawRead = TRUE ; //<S2SV> while ( NOB ) { //<S2SV> if ( NOB > DEFAULT_BUFF_SIZE ) //<S2SV> ReadBytes = DEFAULT_BUFF_SIZE ; //<S2SV> else //<S2SV> ReadBytes = NOB ; //<S2SV> Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadBuff , ReadOffset , ReadBytes ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; //<S2SV> break ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; //<S2SV> Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d" , Status ) ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadBuff ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> NOB = NOB - ReadBytes ; //<S2SV> if ( NOB ) { //<S2SV> ReadOffset = ReadOffset + ReadBytes ; //<S2SV> OutPutBuff = OutPutBuff + ReadBytes ; //<S2SV> } //<S2SV> } //<S2SV> Adapter -> bFlashRawRead = FALSE ; //<S2SV> up ( & Adapter -> NVMRdmWrmLock ) ; //<S2SV> kfree ( pReadBuff ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case IOCTL_BCM_CNTRLMSG_MASK : { //<S2SV> ULONG RxCntrlMsgBitMask = 0 ; //<S2SV> Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "copy<S2SV_blank>of<S2SV_blank>Ioctl<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( IoBuffer . InputLength != sizeof ( unsigned long ) ) { //<S2SV> Status = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> Status = copy_from_user ( & RxCntrlMsgBitMask , IoBuffer . InputBuffer , IoBuffer . InputLength ) ; //<S2SV> if ( Status ) { //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "copy<S2SV_blank>of<S2SV_blank>control<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space" ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\n<S2SV_blank>Got<S2SV_blank>user<S2SV_blank>defined<S2SV_blank>cntrl<S2SV_blank>msg<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>:%lx" , RxCntrlMsgBitMask ) ; //<S2SV> pTarang -> RxCntrlMsgBitMask = RxCntrlMsgBitMask ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_GET_DEVICE_DRIVER_INFO : { //<S2SV> struct bcm_driver_info DevInfo ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n" ) ; //<S2SV> DevInfo . MaxRDMBufferSize = BUFFER_4K ; //<S2SV> DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ; //<S2SV> DevInfo . u32RxAlignmentCorrection = 0 ; //<S2SV> DevInfo . u32NVMType = Adapter -> eNVMType ; //<S2SV> DevInfo . u32InterfaceType = BCM_USB ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . OutputLength < sizeof ( DevInfo ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , & DevInfo , sizeof ( DevInfo ) ) ) //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_BCM_TIME_SINCE_NET_ENTRY : { //<S2SV> struct bcm_time_elapsed stTimeElapsedSinceNetEntry = { 0 } ; //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_TIME_SINCE_NET_ENTRY<S2SV_blank>called" ) ; //<S2SV> if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( IoBuffer . OutputLength < sizeof ( struct bcm_time_elapsed ) ) //<S2SV> return - EINVAL ; //<S2SV> stTimeElapsedSinceNetEntry . ul64TimeElapsedSinceNetEntry = get_seconds ( ) - Adapter -> liTimeSinceLastNetEntry ; //<S2SV> if ( copy_to_user ( IoBuffer . OutputBuffer , & stTimeElapsedSinceNetEntry , sizeof ( struct bcm_time_elapsed ) ) ) //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> break ; //<S2SV> case IOCTL_CLOSE_NOTIFICATION : //<S2SV> BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_CLOSE_NOTIFICATION" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> pr_info ( DRV_NAME ":<S2SV_blank>unknown<S2SV_blank>ioctl<S2SV_blank>cmd=%#x\\n" , cmd ) ; //<S2SV> Status = STATUS_FAILURE ; //<S2SV> break ; //<S2SV> } //<S2SV> return Status ; //<S2SV> } //<S2SV> 