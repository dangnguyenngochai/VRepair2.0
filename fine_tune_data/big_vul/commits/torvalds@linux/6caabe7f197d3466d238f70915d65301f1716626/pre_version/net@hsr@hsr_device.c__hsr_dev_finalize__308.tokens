int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , //<S2SV> unsigned char multicast_spec , u8 protocol_version ) //<S2SV> { //<S2SV> struct hsr_priv * hsr ; //<S2SV> struct hsr_port * port ; //<S2SV> int res ; //<S2SV> hsr = netdev_priv ( hsr_dev ) ; //<S2SV> INIT_LIST_HEAD ( & hsr -> ports ) ; //<S2SV> INIT_LIST_HEAD ( & hsr -> node_db ) ; //<S2SV> INIT_LIST_HEAD ( & hsr -> self_node_db ) ; //<S2SV> ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; //<S2SV> res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , //<S2SV> slave [ 1 ] -> dev_addr ) ; //<S2SV> if ( res < 0 ) //<S2SV> return res ; //<S2SV> spin_lock_init ( & hsr -> seqnr_lock ) ; //<S2SV> hsr -> sequence_nr = HSR_SEQNR_START ; //<S2SV> hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; //<S2SV> timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; //<S2SV> timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; //<S2SV> ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; //<S2SV> hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; //<S2SV> hsr -> protVersion = protocol_version ; //<S2SV> netif_carrier_off ( hsr_dev ) ; //<S2SV> res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; //<S2SV> if ( res ) //<S2SV> return res ; //<S2SV> res = register_netdevice ( hsr_dev ) ; //<S2SV> if ( res ) //<S2SV> goto fail ; //<S2SV> res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; //<S2SV> if ( res ) //<S2SV> goto fail ; //<S2SV> res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; //<S2SV> if ( res ) //<S2SV> goto fail ; //<S2SV> mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; //<S2SV> return 0 ; //<S2SV> fail : //<S2SV> hsr_for_each_port ( hsr , port ) //<S2SV> hsr_del_port ( port ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> 