int common_timer_set ( struct k_itimer * timr , int flags , //<S2SV> struct itimerspec64 * new_setting , //<S2SV> struct itimerspec64 * old_setting ) //<S2SV> { //<S2SV> const struct k_clock * kc = timr -> kclock ; //<S2SV> bool sigev_none ; //<S2SV> ktime_t expires ; //<S2SV> if ( old_setting ) //<S2SV> common_timer_get ( timr , old_setting ) ; //<S2SV> timr -> it_interval = 0 ; //<S2SV> if ( kc -> timer_try_to_cancel ( timr ) < 0 ) //<S2SV> return TIMER_RETRY ; //<S2SV> timr -> it_active = 0 ; //<S2SV> timr -> it_requeue_pending = ( timr -> it_requeue_pending + 2 ) & //<S2SV> ~ REQUEUE_PENDING ; //<S2SV> timr -> it_overrun_last = 0 ; //<S2SV> if ( ! new_setting -> it_value . tv_sec && ! new_setting -> it_value . tv_nsec ) //<S2SV> return 0 ; //<S2SV> timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; //<S2SV> expires = timespec64_to_ktime ( new_setting -> it_value ) ; //<S2SV> sigev_none = timr -> it_sigev_notify == SIGEV_NONE ; //<S2SV> kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; //<S2SV> timr -> it_active = ! sigev_none ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 