void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) //<S2SV> { //<S2SV> const struct k_clock * kc = timr -> kclock ; //<S2SV> ktime_t now , remaining , iv ; //<S2SV> struct timespec64 ts64 ; //<S2SV> bool sig_none ; //<S2SV> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; //<S2SV> iv = timr -> it_interval ; //<S2SV> if ( iv ) { //<S2SV> cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; //<S2SV> } else if ( ! timr -> it_active ) { //<S2SV> if ( ! sig_none ) //<S2SV> return ; //<S2SV> } //<S2SV> kc -> clock_get ( timr -> it_clock , & ts64 ) ; //<S2SV> now = timespec64_to_ktime ( ts64 ) ; //<S2SV> if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) //<S2SV> timr -> it_overrun += kc -> timer_forward ( timr , now ) ; //<S2SV> remaining = kc -> timer_remaining ( timr , now ) ; //<S2SV> if ( remaining <= 0 ) { //<S2SV> if ( ! sig_none ) //<S2SV> cur_setting -> it_value . tv_nsec = 1 ; //<S2SV> } else { //<S2SV> cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; //<S2SV> } //<S2SV> } //<S2SV> 