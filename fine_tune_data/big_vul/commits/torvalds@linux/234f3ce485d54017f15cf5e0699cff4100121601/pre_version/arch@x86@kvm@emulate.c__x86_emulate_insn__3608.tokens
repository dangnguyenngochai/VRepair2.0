int x86_emulate_insn ( struct x86_emulate_ctxt * ctxt ) //<S2SV> { //<S2SV> const struct x86_emulate_ops * ops = ctxt -> ops ; //<S2SV> int rc = X86EMUL_CONTINUE ; //<S2SV> int saved_dst_type = ctxt -> dst . type ; //<S2SV> ctxt -> mem_read . pos = 0 ; //<S2SV> if ( ctxt -> lock_prefix && ( ! ( ctxt -> d & Lock ) || ctxt -> dst . type != OP_MEM ) ) { //<S2SV> rc = emulate_ud ( ctxt ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( ctxt -> d & SrcMask ) == SrcMemFAddr && ctxt -> src . type != OP_MEM ) { //<S2SV> rc = emulate_ud ( ctxt ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( unlikely ( ctxt -> d & //<S2SV> ( No64 | Undefined | Sse | Mmx | Intercept | CheckPerm | Priv | Prot | String ) ) ) { //<S2SV> if ( ( ctxt -> mode == X86EMUL_MODE_PROT64 && ( ctxt -> d & No64 ) ) || //<S2SV> ( ctxt -> d & Undefined ) ) { //<S2SV> rc = emulate_ud ( ctxt ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( ( ctxt -> d & ( Sse | Mmx ) ) && ( ( ops -> get_cr ( ctxt , 0 ) & X86_CR0_EM ) ) ) //<S2SV> || ( ( ctxt -> d & Sse ) && ! ( ops -> get_cr ( ctxt , 4 ) & X86_CR4_OSFXSR ) ) ) { //<S2SV> rc = emulate_ud ( ctxt ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( ctxt -> d & ( Sse | Mmx ) ) && ( ops -> get_cr ( ctxt , 0 ) & X86_CR0_TS ) ) { //<S2SV> rc = emulate_nm ( ctxt ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ctxt -> d & Mmx ) { //<S2SV> rc = flush_pending_x87_faults ( ctxt ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> fetch_possible_mmx_operand ( ctxt , & ctxt -> src ) ; //<S2SV> fetch_possible_mmx_operand ( ctxt , & ctxt -> src2 ) ; //<S2SV> if ( ! ( ctxt -> d & Mov ) ) //<S2SV> fetch_possible_mmx_operand ( ctxt , & ctxt -> dst ) ; //<S2SV> } //<S2SV> if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { //<S2SV> rc = emulator_check_intercept ( ctxt , ctxt -> intercept , //<S2SV> X86_ICPT_PRE_EXCEPT ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( ctxt -> d & Priv ) && ops -> cpl ( ctxt ) ) { //<S2SV> if ( ctxt -> d & PrivUD ) //<S2SV> rc = emulate_ud ( ctxt ) ; //<S2SV> else //<S2SV> rc = emulate_gp ( ctxt , 0 ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( ctxt -> d & Prot ) && ctxt -> mode < X86EMUL_MODE_PROT16 ) { //<S2SV> rc = emulate_ud ( ctxt ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ctxt -> d & CheckPerm ) { //<S2SV> rc = ctxt -> check_perm ( ctxt ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { //<S2SV> rc = emulator_check_intercept ( ctxt , ctxt -> intercept , //<S2SV> X86_ICPT_POST_EXCEPT ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) { //<S2SV> if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) { //<S2SV> ctxt -> eip = ctxt -> _eip ; //<S2SV> ctxt -> eflags &= ~ EFLG_RF ; //<S2SV> goto done ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( ctxt -> src . type == OP_MEM ) && ! ( ctxt -> d & NoAccess ) ) { //<S2SV> rc = segmented_read ( ctxt , ctxt -> src . addr . mem , //<S2SV> ctxt -> src . valptr , ctxt -> src . bytes ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> ctxt -> src . orig_val64 = ctxt -> src . val64 ; //<S2SV> } //<S2SV> if ( ctxt -> src2 . type == OP_MEM ) { //<S2SV> rc = segmented_read ( ctxt , ctxt -> src2 . addr . mem , //<S2SV> & ctxt -> src2 . val , ctxt -> src2 . bytes ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( ctxt -> d & DstMask ) == ImplicitOps ) //<S2SV> goto special_insn ; //<S2SV> if ( ( ctxt -> dst . type == OP_MEM ) && ! ( ctxt -> d & Mov ) ) { //<S2SV> rc = segmented_read ( ctxt , ctxt -> dst . addr . mem , //<S2SV> & ctxt -> dst . val , ctxt -> dst . bytes ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> } //<S2SV> ctxt -> dst . orig_val = ctxt -> dst . val ; //<S2SV> special_insn : //<S2SV> if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { //<S2SV> rc = emulator_check_intercept ( ctxt , ctxt -> intercept , //<S2SV> X86_ICPT_POST_MEMACCESS ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) //<S2SV> ctxt -> eflags |= EFLG_RF ; //<S2SV> else //<S2SV> ctxt -> eflags &= ~ EFLG_RF ; //<S2SV> if ( ctxt -> execute ) { //<S2SV> if ( ctxt -> d & Fastop ) { //<S2SV> void ( * fop ) ( struct fastop * ) = ( void * ) ctxt -> execute ; //<S2SV> rc = fastop ( ctxt , fop ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> goto writeback ; //<S2SV> } //<S2SV> rc = ctxt -> execute ( ctxt ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> goto writeback ; //<S2SV> } //<S2SV> if ( ctxt -> opcode_len == 2 ) //<S2SV> goto twobyte_insn ; //<S2SV> else if ( ctxt -> opcode_len == 3 ) //<S2SV> goto threebyte_insn ; //<S2SV> switch ( ctxt -> b ) { //<S2SV> case 0x63 : //<S2SV> if ( ctxt -> mode != X86EMUL_MODE_PROT64 ) //<S2SV> goto cannot_emulate ; //<S2SV> ctxt -> dst . val = ( s32 ) ctxt -> src . val ; //<S2SV> break ; //<S2SV> case 0x70 ... 0x7f : //<S2SV> if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) //<S2SV> jmp_rel ( ctxt , ctxt -> src . val ) ; //<S2SV> break ; //<S2SV> case 0x8d : //<S2SV> ctxt -> dst . val = ctxt -> src . addr . mem . ea ; //<S2SV> break ; //<S2SV> case 0x90 ... 0x97 : //<S2SV> if ( ctxt -> dst . addr . reg == reg_rmw ( ctxt , VCPU_REGS_RAX ) ) //<S2SV> ctxt -> dst . type = OP_NONE ; //<S2SV> else //<S2SV> rc = em_xchg ( ctxt ) ; //<S2SV> break ; //<S2SV> case 0x98 : //<S2SV> switch ( ctxt -> op_bytes ) { //<S2SV> case 2 : ctxt -> dst . val = ( s8 ) ctxt -> dst . val ; break ; //<S2SV> case 4 : ctxt -> dst . val = ( s16 ) ctxt -> dst . val ; break ; //<S2SV> case 8 : ctxt -> dst . val = ( s32 ) ctxt -> dst . val ; break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0xcc : //<S2SV> rc = emulate_int ( ctxt , 3 ) ; //<S2SV> break ; //<S2SV> case 0xcd : //<S2SV> rc = emulate_int ( ctxt , ctxt -> src . val ) ; //<S2SV> break ; //<S2SV> case 0xce : //<S2SV> if ( ctxt -> eflags & EFLG_OF ) //<S2SV> rc = emulate_int ( ctxt , 4 ) ; //<S2SV> break ; //<S2SV> case 0xe9 : //<S2SV> case 0xeb : //<S2SV> jmp_rel ( ctxt , ctxt -> src . val ) ; //<S2SV> ctxt -> dst . type = OP_NONE ; //<S2SV> break ; //<S2SV> case 0xf4 : //<S2SV> ctxt -> ops -> halt ( ctxt ) ; //<S2SV> break ; //<S2SV> case 0xf5 : //<S2SV> ctxt -> eflags ^= EFLG_CF ; //<S2SV> break ; //<S2SV> case 0xf8 : //<S2SV> ctxt -> eflags &= ~ EFLG_CF ; //<S2SV> break ; //<S2SV> case 0xf9 : //<S2SV> ctxt -> eflags |= EFLG_CF ; //<S2SV> break ; //<S2SV> case 0xfc : //<S2SV> ctxt -> eflags &= ~ EFLG_DF ; //<S2SV> break ; //<S2SV> case 0xfd : //<S2SV> ctxt -> eflags |= EFLG_DF ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto cannot_emulate ; //<S2SV> } //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> writeback : //<S2SV> if ( ctxt -> d & SrcWrite ) { //<S2SV> BUG_ON ( ctxt -> src . type == OP_MEM || ctxt -> src . type == OP_MEM_STR ) ; //<S2SV> rc = writeback ( ctxt , & ctxt -> src ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ! ( ctxt -> d & NoWrite ) ) { //<S2SV> rc = writeback ( ctxt , & ctxt -> dst ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> } //<S2SV> ctxt -> dst . type = saved_dst_type ; //<S2SV> if ( ( ctxt -> d & SrcMask ) == SrcSI ) //<S2SV> string_addr_inc ( ctxt , VCPU_REGS_RSI , & ctxt -> src ) ; //<S2SV> if ( ( ctxt -> d & DstMask ) == DstDI ) //<S2SV> string_addr_inc ( ctxt , VCPU_REGS_RDI , & ctxt -> dst ) ; //<S2SV> if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) { //<S2SV> unsigned int count ; //<S2SV> struct read_cache * r = & ctxt -> io_read ; //<S2SV> if ( ( ctxt -> d & SrcMask ) == SrcSI ) //<S2SV> count = ctxt -> src . count ; //<S2SV> else //<S2SV> count = ctxt -> dst . count ; //<S2SV> register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , //<S2SV> - count ) ; //<S2SV> if ( ! string_insn_completed ( ctxt ) ) { //<S2SV> if ( ( r -> end != 0 || reg_read ( ctxt , VCPU_REGS_RCX ) & 0x3ff ) && //<S2SV> ( r -> end == 0 || r -> end != r -> pos ) ) { //<S2SV> ctxt -> mem_read . end = 0 ; //<S2SV> writeback_registers ( ctxt ) ; //<S2SV> return EMULATION_RESTART ; //<S2SV> } //<S2SV> goto done ; //<S2SV> } //<S2SV> ctxt -> eflags &= ~ EFLG_RF ; //<S2SV> } //<S2SV> ctxt -> eip = ctxt -> _eip ; //<S2SV> done : //<S2SV> if ( rc == X86EMUL_PROPAGATE_FAULT ) { //<S2SV> WARN_ON ( ctxt -> exception . vector > 0x1f ) ; //<S2SV> ctxt -> have_exception = true ; //<S2SV> } //<S2SV> if ( rc == X86EMUL_INTERCEPTED ) //<S2SV> return EMULATION_INTERCEPTED ; //<S2SV> if ( rc == X86EMUL_CONTINUE ) //<S2SV> writeback_registers ( ctxt ) ; //<S2SV> return ( rc == X86EMUL_UNHANDLEABLE ) ? EMULATION_FAILED : EMULATION_OK ; //<S2SV> twobyte_insn : //<S2SV> switch ( ctxt -> b ) { //<S2SV> case 0x09 : //<S2SV> ( ctxt -> ops -> wbinvd ) ( ctxt ) ; //<S2SV> break ; //<S2SV> case 0x08 : //<S2SV> case 0x0d : //<S2SV> case 0x18 : //<S2SV> case 0x1f : //<S2SV> break ; //<S2SV> case 0x20 : //<S2SV> ctxt -> dst . val = ops -> get_cr ( ctxt , ctxt -> modrm_reg ) ; //<S2SV> break ; //<S2SV> case 0x21 : //<S2SV> ops -> get_dr ( ctxt , ctxt -> modrm_reg , & ctxt -> dst . val ) ; //<S2SV> break ; //<S2SV> case 0x40 ... 0x4f : //<S2SV> if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) //<S2SV> ctxt -> dst . val = ctxt -> src . val ; //<S2SV> else if ( ctxt -> mode != X86EMUL_MODE_PROT64 || //<S2SV> ctxt -> op_bytes != 4 ) //<S2SV> ctxt -> dst . type = OP_NONE ; //<S2SV> break ; //<S2SV> case 0x80 ... 0x8f : //<S2SV> if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) //<S2SV> jmp_rel ( ctxt , ctxt -> src . val ) ; //<S2SV> break ; //<S2SV> case 0x90 ... 0x9f : //<S2SV> ctxt -> dst . val = test_cc ( ctxt -> b , ctxt -> eflags ) ; //<S2SV> break ; //<S2SV> case 0xae : //<S2SV> break ; //<S2SV> case 0xb6 ... 0xb7 : //<S2SV> ctxt -> dst . bytes = ctxt -> op_bytes ; //<S2SV> ctxt -> dst . val = ( ctxt -> src . bytes == 1 ) ? ( u8 ) ctxt -> src . val //<S2SV> : ( u16 ) ctxt -> src . val ; //<S2SV> break ; //<S2SV> case 0xbe ... 0xbf : //<S2SV> ctxt -> dst . bytes = ctxt -> op_bytes ; //<S2SV> ctxt -> dst . val = ( ctxt -> src . bytes == 1 ) ? ( s8 ) ctxt -> src . val : //<S2SV> ( s16 ) ctxt -> src . val ; //<S2SV> break ; //<S2SV> case 0xc3 : //<S2SV> ctxt -> dst . bytes = ctxt -> op_bytes ; //<S2SV> ctxt -> dst . val = ( ctxt -> op_bytes == 8 ) ? ( u64 ) ctxt -> src . val : //<S2SV> ( u32 ) ctxt -> src . val ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto cannot_emulate ; //<S2SV> } //<S2SV> threebyte_insn : //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto done ; //<S2SV> goto writeback ; //<S2SV> cannot_emulate : //<S2SV> return EMULATION_FAILED ; //<S2SV> } //<S2SV> 