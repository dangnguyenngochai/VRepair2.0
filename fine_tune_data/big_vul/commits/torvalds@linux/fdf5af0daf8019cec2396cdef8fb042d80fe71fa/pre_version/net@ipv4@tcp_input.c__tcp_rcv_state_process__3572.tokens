int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , //<S2SV> const struct tcphdr * th , unsigned int len ) //<S2SV> { //<S2SV> struct tcp_sock * tp = tcp_sk ( sk ) ; //<S2SV> struct inet_connection_sock * icsk = inet_csk ( sk ) ; //<S2SV> int queued = 0 ; //<S2SV> int res ; //<S2SV> tp -> rx_opt . saw_tstamp = 0 ; //<S2SV> switch ( sk -> sk_state ) { //<S2SV> case TCP_CLOSE : //<S2SV> goto discard ; //<S2SV> case TCP_LISTEN : //<S2SV> if ( th -> ack ) //<S2SV> return 1 ; //<S2SV> if ( th -> rst ) //<S2SV> goto discard ; //<S2SV> if ( th -> syn ) { //<S2SV> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) //<S2SV> return 1 ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> goto discard ; //<S2SV> case TCP_SYN_SENT : //<S2SV> queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; //<S2SV> if ( queued >= 0 ) //<S2SV> return queued ; //<S2SV> tcp_urg ( sk , skb , th ) ; //<S2SV> __kfree_skb ( skb ) ; //<S2SV> tcp_data_snd_check ( sk ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> res = tcp_validate_incoming ( sk , skb , th , 0 ) ; //<S2SV> if ( res <= 0 ) //<S2SV> return - res ; //<S2SV> if ( th -> ack ) { //<S2SV> int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; //<S2SV> switch ( sk -> sk_state ) { //<S2SV> case TCP_SYN_RECV : //<S2SV> if ( acceptable ) { //<S2SV> tp -> copied_seq = tp -> rcv_nxt ; //<S2SV> smp_mb ( ) ; //<S2SV> tcp_set_state ( sk , TCP_ESTABLISHED ) ; //<S2SV> sk -> sk_state_change ( sk ) ; //<S2SV> if ( sk -> sk_socket ) //<S2SV> sk_wake_async ( sk , //<S2SV> SOCK_WAKE_IO , POLL_OUT ) ; //<S2SV> tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; //<S2SV> tp -> snd_wnd = ntohs ( th -> window ) << //<S2SV> tp -> rx_opt . snd_wscale ; //<S2SV> tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; //<S2SV> if ( tp -> rx_opt . tstamp_ok ) //<S2SV> tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; //<S2SV> icsk -> icsk_af_ops -> rebuild_header ( sk ) ; //<S2SV> tcp_init_metrics ( sk ) ; //<S2SV> tcp_init_congestion_control ( sk ) ; //<S2SV> tp -> lsndtime = tcp_time_stamp ; //<S2SV> tcp_mtup_init ( sk ) ; //<S2SV> tcp_initialize_rcv_mss ( sk ) ; //<S2SV> tcp_init_buffer_space ( sk ) ; //<S2SV> tcp_fast_path_on ( tp ) ; //<S2SV> } else { //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case TCP_FIN_WAIT1 : //<S2SV> if ( tp -> snd_una == tp -> write_seq ) { //<S2SV> tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; //<S2SV> sk -> sk_shutdown |= SEND_SHUTDOWN ; //<S2SV> dst_confirm ( __sk_dst_get ( sk ) ) ; //<S2SV> if ( ! sock_flag ( sk , SOCK_DEAD ) ) //<S2SV> sk -> sk_state_change ( sk ) ; //<S2SV> else { //<S2SV> int tmo ; //<S2SV> if ( tp -> linger2 < 0 || //<S2SV> ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && //<S2SV> after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { //<S2SV> tcp_done ( sk ) ; //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> tmo = tcp_fin_time ( sk ) ; //<S2SV> if ( tmo > TCP_TIMEWAIT_LEN ) { //<S2SV> inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; //<S2SV> } else if ( th -> fin || sock_owned_by_user ( sk ) ) { //<S2SV> inet_csk_reset_keepalive_timer ( sk , tmo ) ; //<S2SV> } else { //<S2SV> tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; //<S2SV> goto discard ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TCP_CLOSING : //<S2SV> if ( tp -> snd_una == tp -> write_seq ) { //<S2SV> tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; //<S2SV> goto discard ; //<S2SV> } //<S2SV> break ; //<S2SV> case TCP_LAST_ACK : //<S2SV> if ( tp -> snd_una == tp -> write_seq ) { //<S2SV> tcp_update_metrics ( sk ) ; //<S2SV> tcp_done ( sk ) ; //<S2SV> goto discard ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } else //<S2SV> goto discard ; //<S2SV> tcp_urg ( sk , skb , th ) ; //<S2SV> switch ( sk -> sk_state ) { //<S2SV> case TCP_CLOSE_WAIT : //<S2SV> case TCP_CLOSING : //<S2SV> case TCP_LAST_ACK : //<S2SV> if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) //<S2SV> break ; //<S2SV> case TCP_FIN_WAIT1 : //<S2SV> case TCP_FIN_WAIT2 : //<S2SV> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { //<S2SV> if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && //<S2SV> after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; //<S2SV> tcp_reset ( sk ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> case TCP_ESTABLISHED : //<S2SV> tcp_data_queue ( sk , skb ) ; //<S2SV> queued = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( sk -> sk_state != TCP_CLOSE ) { //<S2SV> tcp_data_snd_check ( sk ) ; //<S2SV> tcp_ack_snd_check ( sk ) ; //<S2SV> } //<S2SV> if ( ! queued ) { //<S2SV> discard : //<S2SV> __kfree_skb ( skb ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 