static int wanxl_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) //<S2SV> { //<S2SV> const size_t size = sizeof ( sync_serial_settings ) ; //<S2SV> sync_serial_settings line ; //<S2SV> port_t * port = dev_to_port ( dev ) ; //<S2SV> if ( cmd != SIOCWANDEV ) //<S2SV> return hdlc_ioctl ( dev , ifr , cmd ) ; //<S2SV> switch ( ifr -> ifr_settings . type ) { //<S2SV> case IF_GET_IFACE : //<S2SV> ifr -> ifr_settings . type = IF_IFACE_SYNC_SERIAL ; //<S2SV> if ( ifr -> ifr_settings . size < size ) { //<S2SV> ifr -> ifr_settings . size = size ; //<S2SV> return - ENOBUFS ; //<S2SV> } //<S2SV> line . clock_type = get_status ( port ) -> clocking ; //<S2SV> line . clock_rate = 0 ; //<S2SV> line . loopback = 0 ; //<S2SV> if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & line , size ) ) //<S2SV> return - EFAULT ; //<S2SV> return 0 ; //<S2SV> case IF_IFACE_SYNC_SERIAL : //<S2SV> if ( ! capable ( CAP_NET_ADMIN ) ) //<S2SV> return - EPERM ; //<S2SV> if ( dev -> flags & IFF_UP ) //<S2SV> return - EBUSY ; //<S2SV> if ( copy_from_user ( & line , ifr -> ifr_settings . ifs_ifsu . sync , //<S2SV> size ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( line . clock_type != CLOCK_EXT && //<S2SV> line . clock_type != CLOCK_TXFROMRX ) //<S2SV> return - EINVAL ; //<S2SV> if ( line . loopback != 0 ) //<S2SV> return - EINVAL ; //<S2SV> get_status ( port ) -> clocking = line . clock_type ; //<S2SV> return 0 ; //<S2SV> default : //<S2SV> return hdlc_ioctl ( dev , ifr , cmd ) ; //<S2SV> } //<S2SV> } //<S2SV> 