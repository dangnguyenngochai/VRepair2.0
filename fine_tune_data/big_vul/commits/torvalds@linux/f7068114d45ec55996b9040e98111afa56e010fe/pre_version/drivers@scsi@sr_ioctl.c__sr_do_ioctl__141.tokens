int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) //<S2SV> { //<S2SV> struct scsi_device * SDev ; //<S2SV> struct scsi_sense_hdr sshdr ; //<S2SV> int result , err = 0 , retries = 0 ; //<S2SV> SDev = cd -> device ; //<S2SV> retry : //<S2SV> if ( ! scsi_block_when_processing_errors ( SDev ) ) { //<S2SV> err = - ENODEV ; //<S2SV> goto out ; //<S2SV> } //<S2SV> result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , //<S2SV> cgc -> buffer , cgc -> buflen , //<S2SV> ( unsigned char * ) cgc -> sense , & sshdr , //<S2SV> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; //<S2SV> if ( driver_byte ( result ) != 0 ) { //<S2SV> switch ( sshdr . sense_key ) { //<S2SV> case UNIT_ATTENTION : //<S2SV> SDev -> changed = 1 ; //<S2SV> if ( ! cgc -> quiet ) //<S2SV> sr_printk ( KERN_INFO , cd , //<S2SV> "disc<S2SV_blank>change<S2SV_blank>detected.\\n" ) ; //<S2SV> if ( retries ++ < 10 ) //<S2SV> goto retry ; //<S2SV> err = - ENOMEDIUM ; //<S2SV> break ; //<S2SV> case NOT_READY : //<S2SV> if ( sshdr . asc == 0x04 && //<S2SV> sshdr . ascq == 0x01 ) { //<S2SV> if ( ! cgc -> quiet ) //<S2SV> sr_printk ( KERN_INFO , cd , //<S2SV> "CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n" ) ; //<S2SV> if ( retries ++ < 10 ) { //<S2SV> ssleep ( 2 ) ; //<S2SV> goto retry ; //<S2SV> } else { //<S2SV> err = - ENOMEDIUM ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! cgc -> quiet ) //<S2SV> sr_printk ( KERN_INFO , cd , //<S2SV> "CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>" //<S2SV> "is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n" ) ; //<S2SV> err = - ENOMEDIUM ; //<S2SV> break ; //<S2SV> case ILLEGAL_REQUEST : //<S2SV> err = - EIO ; //<S2SV> if ( sshdr . asc == 0x20 && //<S2SV> sshdr . ascq == 0x00 ) //<S2SV> err = - EDRIVE_CANT_DO_THIS ; //<S2SV> break ; //<S2SV> default : //<S2SV> err = - EIO ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> cgc -> stat = err ; //<S2SV> return err ; //<S2SV> } //<S2SV> 