int assoc_array_gc ( struct assoc_array * array , //<S2SV> const struct assoc_array_ops * ops , //<S2SV> bool ( * iterator ) ( void * object , void * iterator_data ) , //<S2SV> void * iterator_data ) //<S2SV> { //<S2SV> struct assoc_array_shortcut * shortcut , * new_s ; //<S2SV> struct assoc_array_node * node , * new_n ; //<S2SV> struct assoc_array_edit * edit ; //<S2SV> struct assoc_array_ptr * cursor , * ptr ; //<S2SV> struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; //<S2SV> unsigned long nr_leaves_on_tree ; //<S2SV> int keylen , slot , nr_free , next_slot , i ; //<S2SV> pr_devel ( "-->%s()\\n" , __func__ ) ; //<S2SV> if ( ! array -> root ) //<S2SV> return 0 ; //<S2SV> edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ) ; //<S2SV> if ( ! edit ) //<S2SV> return - ENOMEM ; //<S2SV> edit -> array = array ; //<S2SV> edit -> ops = ops ; //<S2SV> edit -> ops_for_excised_subtree = ops ; //<S2SV> edit -> set [ 0 ] . ptr = & array -> root ; //<S2SV> edit -> excised_subtree = array -> root ; //<S2SV> new_root = new_parent = NULL ; //<S2SV> new_ptr_pp = & new_root ; //<S2SV> cursor = array -> root ; //<S2SV> descend : //<S2SV> if ( assoc_array_ptr_is_shortcut ( cursor ) ) { //<S2SV> shortcut = assoc_array_ptr_to_shortcut ( cursor ) ; //<S2SV> keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; //<S2SV> keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; //<S2SV> new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + //<S2SV> keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; //<S2SV> if ( ! new_s ) //<S2SV> goto enomem ; //<S2SV> pr_devel ( "dup<S2SV_blank>shortcut<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n" , shortcut , new_s ) ; //<S2SV> memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + //<S2SV> keylen * sizeof ( unsigned long ) ) ) ; //<S2SV> new_s -> back_pointer = new_parent ; //<S2SV> new_s -> parent_slot = shortcut -> parent_slot ; //<S2SV> * new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ) ; //<S2SV> new_ptr_pp = & new_s -> next_node ; //<S2SV> cursor = shortcut -> next_node ; //<S2SV> } //<S2SV> node = assoc_array_ptr_to_node ( cursor ) ; //<S2SV> new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; //<S2SV> if ( ! new_n ) //<S2SV> goto enomem ; //<S2SV> pr_devel ( "dup<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n" , node , new_n ) ; //<S2SV> new_n -> back_pointer = new_parent ; //<S2SV> new_n -> parent_slot = node -> parent_slot ; //<S2SV> * new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ) ; //<S2SV> new_ptr_pp = NULL ; //<S2SV> slot = 0 ; //<S2SV> continue_node : //<S2SV> for ( ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { //<S2SV> ptr = node -> slots [ slot ] ; //<S2SV> if ( ! ptr ) //<S2SV> continue ; //<S2SV> if ( assoc_array_ptr_is_leaf ( ptr ) ) { //<S2SV> if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , //<S2SV> iterator_data ) ) //<S2SV> new_n -> slots [ slot ] = ptr ; //<S2SV> continue ; //<S2SV> } //<S2SV> new_ptr_pp = & new_n -> slots [ slot ] ; //<S2SV> cursor = ptr ; //<S2SV> goto descend ; //<S2SV> } //<S2SV> pr_devel ( "--<S2SV_blank>compress<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>--\\n" , new_n ) ; //<S2SV> new_n -> nr_leaves_on_branch = 0 ; //<S2SV> nr_free = 0 ; //<S2SV> for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { //<S2SV> ptr = new_n -> slots [ slot ] ; //<S2SV> if ( ! ptr ) //<S2SV> nr_free ++ ; //<S2SV> else if ( assoc_array_ptr_is_leaf ( ptr ) ) //<S2SV> new_n -> nr_leaves_on_branch ++ ; //<S2SV> } //<S2SV> pr_devel ( "free=%d,<S2SV_blank>leaves=%lu\\n" , nr_free , new_n -> nr_leaves_on_branch ) ; //<S2SV> next_slot = 0 ; //<S2SV> for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { //<S2SV> struct assoc_array_shortcut * s ; //<S2SV> struct assoc_array_node * child ; //<S2SV> ptr = new_n -> slots [ slot ] ; //<S2SV> if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) ) //<S2SV> continue ; //<S2SV> s = NULL ; //<S2SV> if ( assoc_array_ptr_is_shortcut ( ptr ) ) { //<S2SV> s = assoc_array_ptr_to_shortcut ( ptr ) ; //<S2SV> ptr = s -> next_node ; //<S2SV> } //<S2SV> child = assoc_array_ptr_to_node ( ptr ) ; //<S2SV> new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch ; //<S2SV> if ( child -> nr_leaves_on_branch <= nr_free + 1 ) { //<S2SV> pr_devel ( "[%d]<S2SV_blank>fold<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n" , //<S2SV> slot , child -> nr_leaves_on_branch , nr_free + 1 , //<S2SV> next_slot ) ; //<S2SV> BUG_ON ( s ) ; //<S2SV> new_n -> slots [ slot ] = NULL ; //<S2SV> nr_free ++ ; //<S2SV> if ( slot < next_slot ) //<S2SV> next_slot = slot ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { //<S2SV> struct assoc_array_ptr * p = child -> slots [ i ] ; //<S2SV> if ( ! p ) //<S2SV> continue ; //<S2SV> BUG_ON ( assoc_array_ptr_is_meta ( p ) ) ; //<S2SV> while ( new_n -> slots [ next_slot ] ) //<S2SV> next_slot ++ ; //<S2SV> BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ) ; //<S2SV> new_n -> slots [ next_slot ++ ] = p ; //<S2SV> nr_free -- ; //<S2SV> } //<S2SV> kfree ( child ) ; //<S2SV> } else { //<S2SV> pr_devel ( "[%d]<S2SV_blank>retain<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n" , //<S2SV> slot , child -> nr_leaves_on_branch , nr_free + 1 , //<S2SV> next_slot ) ; //<S2SV> } //<S2SV> } //<S2SV> pr_devel ( "after:<S2SV_blank>%lu\\n" , new_n -> nr_leaves_on_branch ) ; //<S2SV> nr_leaves_on_tree = new_n -> nr_leaves_on_branch ; //<S2SV> if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 ) { //<S2SV> for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) //<S2SV> if ( ( ptr = new_n -> slots [ slot ] ) ) //<S2SV> break ; //<S2SV> if ( assoc_array_ptr_is_meta ( ptr ) && //<S2SV> assoc_array_ptr_is_shortcut ( ptr ) ) { //<S2SV> pr_devel ( "excise<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>1<S2SV_blank>shortcut\\n" , new_n ) ; //<S2SV> new_s = assoc_array_ptr_to_shortcut ( ptr ) ; //<S2SV> new_parent = new_n -> back_pointer ; //<S2SV> slot = new_n -> parent_slot ; //<S2SV> kfree ( new_n ) ; //<S2SV> if ( ! new_parent ) { //<S2SV> new_s -> back_pointer = NULL ; //<S2SV> new_s -> parent_slot = 0 ; //<S2SV> new_root = ptr ; //<S2SV> goto gc_complete ; //<S2SV> } //<S2SV> if ( assoc_array_ptr_is_shortcut ( new_parent ) ) { //<S2SV> struct assoc_array_shortcut * s = //<S2SV> assoc_array_ptr_to_shortcut ( new_parent ) ; //<S2SV> pr_devel ( "excise<S2SV_blank>preceding<S2SV_blank>shortcut\\n" ) ; //<S2SV> new_parent = new_s -> back_pointer = s -> back_pointer ; //<S2SV> slot = new_s -> parent_slot = s -> parent_slot ; //<S2SV> kfree ( s ) ; //<S2SV> if ( ! new_parent ) { //<S2SV> new_s -> back_pointer = NULL ; //<S2SV> new_s -> parent_slot = 0 ; //<S2SV> new_root = ptr ; //<S2SV> goto gc_complete ; //<S2SV> } //<S2SV> } //<S2SV> new_s -> back_pointer = new_parent ; //<S2SV> new_s -> parent_slot = slot ; //<S2SV> new_n = assoc_array_ptr_to_node ( new_parent ) ; //<S2SV> new_n -> slots [ slot ] = ptr ; //<S2SV> goto ascend_old_tree ; //<S2SV> } //<S2SV> } //<S2SV> ptr = new_n -> back_pointer ; //<S2SV> if ( ! ptr ) //<S2SV> goto gc_complete ; //<S2SV> if ( assoc_array_ptr_is_shortcut ( ptr ) ) { //<S2SV> new_s = assoc_array_ptr_to_shortcut ( ptr ) ; //<S2SV> new_parent = new_s -> back_pointer ; //<S2SV> slot = new_s -> parent_slot ; //<S2SV> if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT ) { //<S2SV> struct assoc_array_node * n ; //<S2SV> pr_devel ( "excise<S2SV_blank>shortcut\\n" ) ; //<S2SV> new_n -> back_pointer = new_parent ; //<S2SV> new_n -> parent_slot = slot ; //<S2SV> kfree ( new_s ) ; //<S2SV> if ( ! new_parent ) { //<S2SV> new_root = assoc_array_node_to_ptr ( new_n ) ; //<S2SV> goto gc_complete ; //<S2SV> } //<S2SV> n = assoc_array_ptr_to_node ( new_parent ) ; //<S2SV> n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ) ; //<S2SV> } //<S2SV> } else { //<S2SV> new_parent = ptr ; //<S2SV> } //<S2SV> new_n = assoc_array_ptr_to_node ( new_parent ) ; //<S2SV> ascend_old_tree : //<S2SV> ptr = node -> back_pointer ; //<S2SV> if ( assoc_array_ptr_is_shortcut ( ptr ) ) { //<S2SV> shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; //<S2SV> slot = shortcut -> parent_slot ; //<S2SV> cursor = shortcut -> back_pointer ; //<S2SV> } else { //<S2SV> slot = node -> parent_slot ; //<S2SV> cursor = ptr ; //<S2SV> } //<S2SV> BUG_ON ( ! ptr ) ; //<S2SV> node = assoc_array_ptr_to_node ( cursor ) ; //<S2SV> slot ++ ; //<S2SV> goto continue_node ; //<S2SV> gc_complete : //<S2SV> edit -> set [ 0 ] . to = new_root ; //<S2SV> assoc_array_apply_edit ( edit ) ; //<S2SV> array -> nr_leaves_on_tree = nr_leaves_on_tree ; //<S2SV> return 0 ; //<S2SV> enomem : //<S2SV> pr_devel ( "enomem\\n" ) ; //<S2SV> assoc_array_destroy_subtree ( new_root , edit -> ops ) ; //<S2SV> kfree ( edit ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> 