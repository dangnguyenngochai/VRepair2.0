static int security_context_to_sid_core ( const char * scontext , u32 scontext_len , //<S2SV> u32 * sid , u32 def_sid , gfp_t gfp_flags , //<S2SV> int force ) //<S2SV> { //<S2SV> char * scontext2 , * str = NULL ; //<S2SV> struct context context ; //<S2SV> int rc = 0 ; //<S2SV> if ( ! ss_initialized ) { //<S2SV> int i ; //<S2SV> for ( i = 1 ; i < SECINITSID_NUM ; i ++ ) { //<S2SV> if ( ! strcmp ( initial_sid_to_string [ i ] , scontext ) ) { //<S2SV> * sid = i ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> * sid = SECINITSID_KERNEL ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> * sid = SECSID_NULL ; //<S2SV> scontext2 = kmalloc ( scontext_len + 1 , gfp_flags ) ; //<S2SV> if ( ! scontext2 ) //<S2SV> return - ENOMEM ; //<S2SV> memcpy ( scontext2 , scontext , scontext_len ) ; //<S2SV> scontext2 [ scontext_len ] = 0 ; //<S2SV> if ( force ) { //<S2SV> rc = - ENOMEM ; //<S2SV> str = kstrdup ( scontext2 , gfp_flags ) ; //<S2SV> if ( ! str ) //<S2SV> goto out ; //<S2SV> } //<S2SV> read_lock ( & policy_rwlock ) ; //<S2SV> rc = string_to_context_struct ( & policydb , & sidtab , scontext2 , //<S2SV> scontext_len , & context , def_sid ) ; //<S2SV> if ( rc == - EINVAL && force ) { //<S2SV> context . str = str ; //<S2SV> context . len = scontext_len ; //<S2SV> str = NULL ; //<S2SV> } else if ( rc ) //<S2SV> goto out_unlock ; //<S2SV> rc = sidtab_context_to_sid ( & sidtab , & context , sid ) ; //<S2SV> context_destroy ( & context ) ; //<S2SV> out_unlock : //<S2SV> read_unlock ( & policy_rwlock ) ; //<S2SV> out : //<S2SV> kfree ( scontext2 ) ; //<S2SV> kfree ( str ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 