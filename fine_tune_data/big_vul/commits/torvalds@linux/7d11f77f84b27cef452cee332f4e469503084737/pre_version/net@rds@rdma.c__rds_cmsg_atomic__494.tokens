int rds_cmsg_atomic ( struct rds_sock * rs , struct rds_message * rm , //<S2SV> struct cmsghdr * cmsg ) //<S2SV> { //<S2SV> struct page * page = NULL ; //<S2SV> struct rds_atomic_args * args ; //<S2SV> int ret = 0 ; //<S2SV> if ( cmsg -> cmsg_len < CMSG_LEN ( sizeof ( struct rds_atomic_args ) ) //<S2SV> || rm -> atomic . op_active ) //<S2SV> return - EINVAL ; //<S2SV> args = CMSG_DATA ( cmsg ) ; //<S2SV> switch ( cmsg -> cmsg_type ) { //<S2SV> case RDS_CMSG_ATOMIC_FADD : //<S2SV> rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; //<S2SV> rm -> atomic . op_m_fadd . add = args -> fadd . add ; //<S2SV> rm -> atomic . op_m_fadd . nocarry_mask = 0 ; //<S2SV> break ; //<S2SV> case RDS_CMSG_MASKED_ATOMIC_FADD : //<S2SV> rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; //<S2SV> rm -> atomic . op_m_fadd . add = args -> m_fadd . add ; //<S2SV> rm -> atomic . op_m_fadd . nocarry_mask = args -> m_fadd . nocarry_mask ; //<S2SV> break ; //<S2SV> case RDS_CMSG_ATOMIC_CSWP : //<S2SV> rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; //<S2SV> rm -> atomic . op_m_cswp . compare = args -> cswp . compare ; //<S2SV> rm -> atomic . op_m_cswp . swap = args -> cswp . swap ; //<S2SV> rm -> atomic . op_m_cswp . compare_mask = ~ 0 ; //<S2SV> rm -> atomic . op_m_cswp . swap_mask = ~ 0 ; //<S2SV> break ; //<S2SV> case RDS_CMSG_MASKED_ATOMIC_CSWP : //<S2SV> rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; //<S2SV> rm -> atomic . op_m_cswp . compare = args -> m_cswp . compare ; //<S2SV> rm -> atomic . op_m_cswp . swap = args -> m_cswp . swap ; //<S2SV> rm -> atomic . op_m_cswp . compare_mask = args -> m_cswp . compare_mask ; //<S2SV> rm -> atomic . op_m_cswp . swap_mask = args -> m_cswp . swap_mask ; //<S2SV> break ; //<S2SV> default : //<S2SV> BUG ( ) ; //<S2SV> } //<S2SV> rm -> atomic . op_notify = ! ! ( args -> flags & RDS_RDMA_NOTIFY_ME ) ; //<S2SV> rm -> atomic . op_silent = ! ! ( args -> flags & RDS_RDMA_SILENT ) ; //<S2SV> rm -> atomic . op_active = 1 ; //<S2SV> rm -> atomic . op_recverr = rs -> rs_recverr ; //<S2SV> rm -> atomic . op_sg = rds_message_alloc_sgs ( rm , 1 ) ; //<S2SV> if ( ! rm -> atomic . op_sg ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( args -> local_addr & 0x7 ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto err ; //<S2SV> } //<S2SV> ret = rds_pin_pages ( args -> local_addr , 1 , & page , 1 ) ; //<S2SV> if ( ret != 1 ) //<S2SV> goto err ; //<S2SV> ret = 0 ; //<S2SV> sg_set_page ( rm -> atomic . op_sg , page , 8 , offset_in_page ( args -> local_addr ) ) ; //<S2SV> if ( rm -> atomic . op_notify || rm -> atomic . op_recverr ) { //<S2SV> rm -> atomic . op_notifier = kmalloc ( sizeof ( * rm -> atomic . op_notifier ) , GFP_KERNEL ) ; //<S2SV> if ( ! rm -> atomic . op_notifier ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto err ; //<S2SV> } //<S2SV> rm -> atomic . op_notifier -> n_user_token = args -> user_token ; //<S2SV> rm -> atomic . op_notifier -> n_status = RDS_RDMA_SUCCESS ; //<S2SV> } //<S2SV> rm -> atomic . op_rkey = rds_rdma_cookie_key ( args -> cookie ) ; //<S2SV> rm -> atomic . op_remote_addr = args -> remote_addr + rds_rdma_cookie_offset ( args -> cookie ) ; //<S2SV> return ret ; //<S2SV> err : //<S2SV> if ( page ) //<S2SV> put_page ( page ) ; //<S2SV> kfree ( rm -> atomic . op_notifier ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 