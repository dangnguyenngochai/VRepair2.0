static int complete_emulated_mmio ( struct kvm_vcpu * vcpu ) //<S2SV> { //<S2SV> struct kvm_run * run = vcpu -> run ; //<S2SV> struct kvm_mmio_fragment * frag ; //<S2SV> unsigned len ; //<S2SV> BUG_ON ( ! vcpu -> mmio_needed ) ; //<S2SV> frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ; //<S2SV> len = min ( 8u , frag -> len ) ; //<S2SV> if ( ! vcpu -> mmio_is_write ) //<S2SV> memcpy ( frag -> data , run -> mmio . data , len ) ; //<S2SV> if ( frag -> len <= 8 ) { //<S2SV> frag ++ ; //<S2SV> vcpu -> mmio_cur_fragment ++ ; //<S2SV> } else { //<S2SV> frag -> data += len ; //<S2SV> frag -> gpa += len ; //<S2SV> frag -> len -= len ; //<S2SV> } //<S2SV> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { //<S2SV> vcpu -> mmio_needed = 0 ; //<S2SV> if ( vcpu -> mmio_is_write ) //<S2SV> return 1 ; //<S2SV> vcpu -> mmio_read_completed = 1 ; //<S2SV> return complete_emulated_io ( vcpu ) ; //<S2SV> } //<S2SV> run -> exit_reason = KVM_EXIT_MMIO ; //<S2SV> run -> mmio . phys_addr = frag -> gpa ; //<S2SV> if ( vcpu -> mmio_is_write ) //<S2SV> memcpy ( run -> mmio . data , frag -> data , min ( 8u , frag -> len ) ) ; //<S2SV> run -> mmio . len = min ( 8u , frag -> len ) ; //<S2SV> run -> mmio . is_write = vcpu -> mmio_is_write ; //<S2SV> vcpu -> arch . complete_userspace_io = complete_emulated_mmio ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 