static int br_multicast_add_group ( struct net_bridge * br , //<S2SV> struct net_bridge_port * port , //<S2SV> struct br_ip * group ) //<S2SV> { //<S2SV> struct net_bridge_mdb_entry * mp ; //<S2SV> struct net_bridge_port_group * p ; //<S2SV> struct net_bridge_port_group __rcu * * pp ; //<S2SV> unsigned long now = jiffies ; //<S2SV> int err ; //<S2SV> spin_lock ( & br -> multicast_lock ) ; //<S2SV> if ( ! netif_running ( br -> dev ) || //<S2SV> ( port && port -> state == BR_STATE_DISABLED ) ) //<S2SV> goto out ; //<S2SV> mp = br_multicast_new_group ( br , port , group ) ; //<S2SV> err = PTR_ERR ( mp ) ; //<S2SV> if ( IS_ERR ( mp ) ) //<S2SV> goto err ; //<S2SV> if ( ! port ) { //<S2SV> if ( hlist_unhashed ( & mp -> mglist ) ) //<S2SV> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; //<S2SV> mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> for ( pp = & mp -> ports ; //<S2SV> ( p = mlock_dereference ( * pp , br ) ) != NULL ; //<S2SV> pp = & p -> next ) { //<S2SV> if ( p -> port == port ) //<S2SV> goto found ; //<S2SV> if ( ( unsigned long ) p -> port < ( unsigned long ) port ) //<S2SV> break ; //<S2SV> } //<S2SV> p = kzalloc ( sizeof ( * p ) , GFP_ATOMIC ) ; //<S2SV> err = - ENOMEM ; //<S2SV> if ( unlikely ( ! p ) ) //<S2SV> goto err ; //<S2SV> p -> addr = * group ; //<S2SV> p -> port = port ; //<S2SV> p -> next = * pp ; //<S2SV> hlist_add_head ( & p -> mglist , & port -> mglist ) ; //<S2SV> setup_timer ( & p -> timer , br_multicast_port_group_expired , //<S2SV> ( unsigned long ) p ) ; //<S2SV> setup_timer ( & p -> query_timer , br_multicast_port_group_query_expired , //<S2SV> ( unsigned long ) p ) ; //<S2SV> rcu_assign_pointer ( * pp , p ) ; //<S2SV> found : //<S2SV> mod_timer ( & p -> timer , now + br -> multicast_membership_interval ) ; //<S2SV> out : //<S2SV> err = 0 ; //<S2SV> err : //<S2SV> spin_unlock ( & br -> multicast_lock ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 