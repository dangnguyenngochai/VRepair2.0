static int do_check ( struct bpf_verifier_env * env ) //<S2SV> { //<S2SV> struct bpf_verifier_state * state ; //<S2SV> struct bpf_insn * insns = env -> prog -> insnsi ; //<S2SV> struct bpf_reg_state * regs ; //<S2SV> int insn_cnt = env -> prog -> len ; //<S2SV> int insn_idx , prev_insn_idx = 0 ; //<S2SV> int insn_processed = 0 ; //<S2SV> bool do_print_state = false ; //<S2SV> state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; //<S2SV> if ( ! state ) //<S2SV> return - ENOMEM ; //<S2SV> env -> cur_state = state ; //<S2SV> init_reg_state ( env , state -> regs ) ; //<S2SV> state -> parent = NULL ; //<S2SV> insn_idx = 0 ; //<S2SV> for ( ; ; ) { //<S2SV> struct bpf_insn * insn ; //<S2SV> u8 class ; //<S2SV> int err ; //<S2SV> if ( insn_idx >= insn_cnt ) { //<S2SV> verbose ( env , "invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n" , //<S2SV> insn_idx , insn_cnt ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> insn = & insns [ insn_idx ] ; //<S2SV> class = BPF_CLASS ( insn -> code ) ; //<S2SV> if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { //<S2SV> verbose ( env , //<S2SV> "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n" , //<S2SV> insn_processed ) ; //<S2SV> return - E2BIG ; //<S2SV> } //<S2SV> err = is_state_visited ( env , insn_idx ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( err == 1 ) { //<S2SV> if ( env -> log . level ) { //<S2SV> if ( do_print_state ) //<S2SV> verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n" , //<S2SV> prev_insn_idx , insn_idx ) ; //<S2SV> else //<S2SV> verbose ( env , "%d:<S2SV_blank>safe\\n" , insn_idx ) ; //<S2SV> } //<S2SV> goto process_bpf_exit ; //<S2SV> } //<S2SV> if ( need_resched ( ) ) //<S2SV> cond_resched ( ) ; //<S2SV> if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { //<S2SV> if ( env -> log . level > 1 ) //<S2SV> verbose ( env , "%d:" , insn_idx ) ; //<S2SV> else //<S2SV> verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:" , //<S2SV> prev_insn_idx , insn_idx ) ; //<S2SV> print_verifier_state ( env , state ) ; //<S2SV> do_print_state = false ; //<S2SV> } //<S2SV> if ( env -> log . level ) { //<S2SV> verbose ( env , "%d:<S2SV_blank>" , insn_idx ) ; //<S2SV> print_bpf_insn ( verbose , env , insn , //<S2SV> env -> allow_ptr_leaks ) ; //<S2SV> } //<S2SV> err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> regs = cur_regs ( env ) ; //<S2SV> if ( class == BPF_ALU || class == BPF_ALU64 ) { //<S2SV> err = check_alu_op ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( class == BPF_LDX ) { //<S2SV> enum bpf_reg_type * prev_src_type , src_reg_type ; //<S2SV> err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> src_reg_type = regs [ insn -> src_reg ] . type ; //<S2SV> err = check_mem_access ( env , insn_idx , insn -> src_reg , insn -> off , //<S2SV> BPF_SIZE ( insn -> code ) , BPF_READ , //<S2SV> insn -> dst_reg ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; //<S2SV> if ( * prev_src_type == NOT_INIT ) { //<S2SV> * prev_src_type = src_reg_type ; //<S2SV> } else if ( src_reg_type != * prev_src_type && //<S2SV> ( src_reg_type == PTR_TO_CTX || //<S2SV> * prev_src_type == PTR_TO_CTX ) ) { //<S2SV> verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else if ( class == BPF_STX ) { //<S2SV> enum bpf_reg_type * prev_dst_type , dst_reg_type ; //<S2SV> if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { //<S2SV> err = check_xadd ( env , insn_idx , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> insn_idx ++ ; //<S2SV> continue ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> dst_reg_type = regs [ insn -> dst_reg ] . type ; //<S2SV> err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , //<S2SV> BPF_SIZE ( insn -> code ) , BPF_WRITE , //<S2SV> insn -> src_reg ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; //<S2SV> if ( * prev_dst_type == NOT_INIT ) { //<S2SV> * prev_dst_type = dst_reg_type ; //<S2SV> } else if ( dst_reg_type != * prev_dst_type && //<S2SV> ( dst_reg_type == PTR_TO_CTX || //<S2SV> * prev_dst_type == PTR_TO_CTX ) ) { //<S2SV> verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else if ( class == BPF_ST ) { //<S2SV> if ( BPF_MODE ( insn -> code ) != BPF_MEM || //<S2SV> insn -> src_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , //<S2SV> BPF_SIZE ( insn -> code ) , BPF_WRITE , //<S2SV> - 1 ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( class == BPF_JMP ) { //<S2SV> u8 opcode = BPF_OP ( insn -> code ) ; //<S2SV> if ( opcode == BPF_CALL ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> off != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_call ( env , insn -> imm , insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( opcode == BPF_JA ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> imm != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> insn_idx += insn -> off + 1 ; //<S2SV> continue ; //<S2SV> } else if ( opcode == BPF_EXIT ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> imm != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( is_pointer_value ( env , BPF_REG_0 ) ) { //<S2SV> verbose ( env , "R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> err = check_return_code ( env ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> process_bpf_exit : //<S2SV> err = pop_stack ( env , & prev_insn_idx , & insn_idx ) ; //<S2SV> if ( err < 0 ) { //<S2SV> if ( err != - ENOENT ) //<S2SV> return err ; //<S2SV> break ; //<S2SV> } else { //<S2SV> do_print_state = true ; //<S2SV> continue ; //<S2SV> } //<S2SV> } else { //<S2SV> err = check_cond_jmp_op ( env , insn , & insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } //<S2SV> } else if ( class == BPF_LD ) { //<S2SV> u8 mode = BPF_MODE ( insn -> code ) ; //<S2SV> if ( mode == BPF_ABS || mode == BPF_IND ) { //<S2SV> err = check_ld_abs ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( mode == BPF_IMM ) { //<S2SV> err = check_ld_imm ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> insn_idx ++ ; //<S2SV> } else { //<S2SV> verbose ( env , "invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else { //<S2SV> verbose ( env , "unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n" , class ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> insn_idx ++ ; //<S2SV> } //<S2SV> verbose ( env , "processed<S2SV_blank>%d<S2SV_blank>insns,<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>%d\\n" , insn_processed , //<S2SV> env -> prog -> aux -> stack_depth ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 