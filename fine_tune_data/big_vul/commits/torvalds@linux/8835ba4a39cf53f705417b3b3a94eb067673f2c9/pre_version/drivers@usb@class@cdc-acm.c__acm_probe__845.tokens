static int acm_probe ( struct usb_interface * intf , //<S2SV> const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct usb_cdc_union_desc * union_header = NULL ; //<S2SV> struct usb_cdc_country_functional_desc * cfd = NULL ; //<S2SV> unsigned char * buffer = intf -> altsetting -> extra ; //<S2SV> int buflen = intf -> altsetting -> extralen ; //<S2SV> struct usb_interface * control_interface ; //<S2SV> struct usb_interface * data_interface ; //<S2SV> struct usb_endpoint_descriptor * epctrl = NULL ; //<S2SV> struct usb_endpoint_descriptor * epread = NULL ; //<S2SV> struct usb_endpoint_descriptor * epwrite = NULL ; //<S2SV> struct usb_device * usb_dev = interface_to_usbdev ( intf ) ; //<S2SV> struct acm * acm ; //<S2SV> int minor ; //<S2SV> int ctrlsize , readsize ; //<S2SV> u8 * buf ; //<S2SV> u8 ac_management_function = 0 ; //<S2SV> u8 call_management_function = 0 ; //<S2SV> int call_interface_num = - 1 ; //<S2SV> int data_interface_num = - 1 ; //<S2SV> unsigned long quirks ; //<S2SV> int num_rx_buf ; //<S2SV> int i ; //<S2SV> unsigned int elength = 0 ; //<S2SV> int combined_interfaces = 0 ; //<S2SV> struct device * tty_dev ; //<S2SV> int rv = - ENOMEM ; //<S2SV> quirks = ( unsigned long ) id -> driver_info ; //<S2SV> if ( quirks == IGNORE_DEVICE ) //<S2SV> return - ENODEV ; //<S2SV> num_rx_buf = ( quirks == SINGLE_RX_URB ) ? 1 : ACM_NR ; //<S2SV> if ( quirks == NO_UNION_NORMAL ) { //<S2SV> data_interface = usb_ifnum_to_if ( usb_dev , 1 ) ; //<S2SV> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; //<S2SV> goto skip_normal_probe ; //<S2SV> } //<S2SV> if ( ! buffer ) { //<S2SV> dev_err ( & intf -> dev , "Weird<S2SV_blank>descriptor<S2SV_blank>references\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( ! buflen ) { //<S2SV> if ( intf -> cur_altsetting -> endpoint && //<S2SV> intf -> cur_altsetting -> endpoint -> extralen && //<S2SV> intf -> cur_altsetting -> endpoint -> extra ) { //<S2SV> dev_dbg ( & intf -> dev , //<S2SV> "Seeking<S2SV_blank>extra<S2SV_blank>descriptors<S2SV_blank>on<S2SV_blank>endpoint\\n" ) ; //<S2SV> buflen = intf -> cur_altsetting -> endpoint -> extralen ; //<S2SV> buffer = intf -> cur_altsetting -> endpoint -> extra ; //<S2SV> } else { //<S2SV> dev_err ( & intf -> dev , //<S2SV> "Zero<S2SV_blank>length<S2SV_blank>descriptor<S2SV_blank>references\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> while ( buflen > 0 ) { //<S2SV> elength = buffer [ 0 ] ; //<S2SV> if ( ! elength ) { //<S2SV> dev_err ( & intf -> dev , "skipping<S2SV_blank>garbage<S2SV_blank>byte\\n" ) ; //<S2SV> elength = 1 ; //<S2SV> goto next_desc ; //<S2SV> } //<S2SV> if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { //<S2SV> dev_err ( & intf -> dev , "skipping<S2SV_blank>garbage\\n" ) ; //<S2SV> goto next_desc ; //<S2SV> } //<S2SV> switch ( buffer [ 2 ] ) { //<S2SV> case USB_CDC_UNION_TYPE : //<S2SV> if ( elength < sizeof ( struct usb_cdc_union_desc ) ) //<S2SV> goto next_desc ; //<S2SV> if ( union_header ) { //<S2SV> dev_err ( & intf -> dev , "More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>" //<S2SV> "union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n" ) ; //<S2SV> goto next_desc ; //<S2SV> } //<S2SV> union_header = ( struct usb_cdc_union_desc * ) buffer ; //<S2SV> break ; //<S2SV> case USB_CDC_COUNTRY_TYPE : //<S2SV> if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) //<S2SV> goto next_desc ; //<S2SV> cfd = ( struct usb_cdc_country_functional_desc * ) buffer ; //<S2SV> break ; //<S2SV> case USB_CDC_HEADER_TYPE : //<S2SV> break ; //<S2SV> case USB_CDC_ACM_TYPE : //<S2SV> if ( elength < 4 ) //<S2SV> goto next_desc ; //<S2SV> ac_management_function = buffer [ 3 ] ; //<S2SV> break ; //<S2SV> case USB_CDC_CALL_MANAGEMENT_TYPE : //<S2SV> if ( elength < 5 ) //<S2SV> goto next_desc ; //<S2SV> call_management_function = buffer [ 3 ] ; //<S2SV> call_interface_num = buffer [ 4 ] ; //<S2SV> break ; //<S2SV> default : //<S2SV> dev_dbg ( & intf -> dev , "Ignoring<S2SV_blank>descriptor:<S2SV_blank>" //<S2SV> "type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n" , //<S2SV> buffer [ 2 ] , elength ) ; //<S2SV> break ; //<S2SV> } //<S2SV> next_desc : //<S2SV> buflen -= elength ; //<S2SV> buffer += elength ; //<S2SV> } //<S2SV> if ( ! union_header ) { //<S2SV> if ( call_interface_num > 0 ) { //<S2SV> dev_dbg ( & intf -> dev , "No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>using<S2SV_blank>call<S2SV_blank>management<S2SV_blank>descriptor\\n" ) ; //<S2SV> if ( quirks & NO_DATA_INTERFACE ) //<S2SV> data_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; //<S2SV> else //<S2SV> data_interface = usb_ifnum_to_if ( usb_dev , ( data_interface_num = call_interface_num ) ) ; //<S2SV> control_interface = intf ; //<S2SV> } else { //<S2SV> if ( intf -> cur_altsetting -> desc . bNumEndpoints != 3 ) { //<S2SV> dev_dbg ( & intf -> dev , "No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>giving<S2SV_blank>up\\n" ) ; //<S2SV> return - ENODEV ; //<S2SV> } else { //<S2SV> dev_warn ( & intf -> dev , "No<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>testing<S2SV_blank>for<S2SV_blank>castrated<S2SV_blank>device\\n" ) ; //<S2SV> combined_interfaces = 1 ; //<S2SV> control_interface = data_interface = intf ; //<S2SV> goto look_for_collapsed_interface ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> control_interface = usb_ifnum_to_if ( usb_dev , union_header -> bMasterInterface0 ) ; //<S2SV> data_interface = usb_ifnum_to_if ( usb_dev , ( data_interface_num = union_header -> bSlaveInterface0 ) ) ; //<S2SV> } //<S2SV> if ( ! control_interface || ! data_interface ) { //<S2SV> dev_dbg ( & intf -> dev , "no<S2SV_blank>interfaces\\n" ) ; //<S2SV> return - ENODEV ; //<S2SV> } //<S2SV> if ( data_interface_num != call_interface_num ) //<S2SV> dev_dbg ( & intf -> dev , "Separate<S2SV_blank>call<S2SV_blank>control<S2SV_blank>interface.<S2SV_blank>That<S2SV_blank>is<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>supported.\\n" ) ; //<S2SV> if ( control_interface == data_interface ) { //<S2SV> dev_warn ( & intf -> dev , "Control<S2SV_blank>and<S2SV_blank>data<S2SV_blank>interfaces<S2SV_blank>are<S2SV_blank>not<S2SV_blank>separated!\\n" ) ; //<S2SV> combined_interfaces = 1 ; //<S2SV> quirks |= NO_CAP_LINE ; //<S2SV> if ( data_interface -> cur_altsetting -> desc . bNumEndpoints != 3 ) { //<S2SV> dev_err ( & intf -> dev , "This<S2SV_blank>needs<S2SV_blank>exactly<S2SV_blank>3<S2SV_blank>endpoints\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> look_for_collapsed_interface : //<S2SV> for ( i = 0 ; i < 3 ; i ++ ) { //<S2SV> struct usb_endpoint_descriptor * ep ; //<S2SV> ep = & data_interface -> cur_altsetting -> endpoint [ i ] . desc ; //<S2SV> if ( usb_endpoint_is_int_in ( ep ) ) //<S2SV> epctrl = ep ; //<S2SV> else if ( usb_endpoint_is_bulk_out ( ep ) ) //<S2SV> epwrite = ep ; //<S2SV> else if ( usb_endpoint_is_bulk_in ( ep ) ) //<S2SV> epread = ep ; //<S2SV> else //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( ! epctrl || ! epread || ! epwrite ) //<S2SV> return - ENODEV ; //<S2SV> else //<S2SV> goto made_compressed_probe ; //<S2SV> } //<S2SV> skip_normal_probe : //<S2SV> if ( data_interface -> cur_altsetting -> desc . bInterfaceClass //<S2SV> != CDC_DATA_INTERFACE_TYPE ) { //<S2SV> if ( control_interface -> cur_altsetting -> desc . bInterfaceClass //<S2SV> == CDC_DATA_INTERFACE_TYPE ) { //<S2SV> dev_dbg ( & intf -> dev , //<S2SV> "Your<S2SV_blank>device<S2SV_blank>has<S2SV_blank>switched<S2SV_blank>interfaces.\\n" ) ; //<S2SV> swap ( control_interface , data_interface ) ; //<S2SV> } else { //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! combined_interfaces && intf != control_interface ) //<S2SV> return - ENODEV ; //<S2SV> if ( ! combined_interfaces && usb_interface_claimed ( data_interface ) ) { //<S2SV> dev_dbg ( & intf -> dev , "The<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>isn\'t<S2SV_blank>available\\n" ) ; //<S2SV> return - EBUSY ; //<S2SV> } //<S2SV> if ( data_interface -> cur_altsetting -> desc . bNumEndpoints < 2 || //<S2SV> control_interface -> cur_altsetting -> desc . bNumEndpoints == 0 ) //<S2SV> return - EINVAL ; //<S2SV> epctrl = & control_interface -> cur_altsetting -> endpoint [ 0 ] . desc ; //<S2SV> epread = & data_interface -> cur_altsetting -> endpoint [ 0 ] . desc ; //<S2SV> epwrite = & data_interface -> cur_altsetting -> endpoint [ 1 ] . desc ; //<S2SV> if ( ! usb_endpoint_dir_in ( epread ) ) { //<S2SV> dev_dbg ( & intf -> dev , //<S2SV> "The<S2SV_blank>data<S2SV_blank>interface<S2SV_blank>has<S2SV_blank>switched<S2SV_blank>endpoints\\n" ) ; //<S2SV> swap ( epread , epwrite ) ; //<S2SV> } //<S2SV> made_compressed_probe : //<S2SV> dev_dbg ( & intf -> dev , "interfaces<S2SV_blank>are<S2SV_blank>valid\\n" ) ; //<S2SV> acm = kzalloc ( sizeof ( struct acm ) , GFP_KERNEL ) ; //<S2SV> if ( acm == NULL ) //<S2SV> goto alloc_fail ; //<S2SV> minor = acm_alloc_minor ( acm ) ; //<S2SV> if ( minor < 0 ) { //<S2SV> dev_err ( & intf -> dev , "no<S2SV_blank>more<S2SV_blank>free<S2SV_blank>acm<S2SV_blank>devices\\n" ) ; //<S2SV> kfree ( acm ) ; //<S2SV> return - ENODEV ; //<S2SV> } //<S2SV> ctrlsize = usb_endpoint_maxp ( epctrl ) ; //<S2SV> readsize = usb_endpoint_maxp ( epread ) * //<S2SV> ( quirks == SINGLE_RX_URB ? 1 : 2 ) ; //<S2SV> acm -> combined_interfaces = combined_interfaces ; //<S2SV> acm -> writesize = usb_endpoint_maxp ( epwrite ) * 20 ; //<S2SV> acm -> control = control_interface ; //<S2SV> acm -> data = data_interface ; //<S2SV> acm -> minor = minor ; //<S2SV> acm -> dev = usb_dev ; //<S2SV> acm -> ctrl_caps = ac_management_function ; //<S2SV> if ( quirks & NO_CAP_LINE ) //<S2SV> acm -> ctrl_caps &= ~ USB_CDC_CAP_LINE ; //<S2SV> acm -> ctrlsize = ctrlsize ; //<S2SV> acm -> readsize = readsize ; //<S2SV> acm -> rx_buflimit = num_rx_buf ; //<S2SV> INIT_WORK ( & acm -> work , acm_softint ) ; //<S2SV> init_waitqueue_head ( & acm -> wioctl ) ; //<S2SV> spin_lock_init ( & acm -> write_lock ) ; //<S2SV> spin_lock_init ( & acm -> read_lock ) ; //<S2SV> mutex_init ( & acm -> mutex ) ; //<S2SV> acm -> rx_endpoint = usb_rcvbulkpipe ( usb_dev , epread -> bEndpointAddress ) ; //<S2SV> acm -> is_int_ep = usb_endpoint_xfer_int ( epread ) ; //<S2SV> if ( acm -> is_int_ep ) //<S2SV> acm -> bInterval = epread -> bInterval ; //<S2SV> tty_port_init ( & acm -> port ) ; //<S2SV> acm -> port . ops = & acm_port_ops ; //<S2SV> init_usb_anchor ( & acm -> delayed ) ; //<S2SV> acm -> quirks = quirks ; //<S2SV> buf = usb_alloc_coherent ( usb_dev , ctrlsize , GFP_KERNEL , & acm -> ctrl_dma ) ; //<S2SV> if ( ! buf ) //<S2SV> goto alloc_fail2 ; //<S2SV> acm -> ctrl_buffer = buf ; //<S2SV> if ( acm_write_buffers_alloc ( acm ) < 0 ) //<S2SV> goto alloc_fail4 ; //<S2SV> acm -> ctrlurb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! acm -> ctrlurb ) //<S2SV> goto alloc_fail5 ; //<S2SV> for ( i = 0 ; i < num_rx_buf ; i ++ ) { //<S2SV> struct acm_rb * rb = & ( acm -> read_buffers [ i ] ) ; //<S2SV> struct urb * urb ; //<S2SV> rb -> base = usb_alloc_coherent ( acm -> dev , readsize , GFP_KERNEL , //<S2SV> & rb -> dma ) ; //<S2SV> if ( ! rb -> base ) //<S2SV> goto alloc_fail6 ; //<S2SV> rb -> index = i ; //<S2SV> rb -> instance = acm ; //<S2SV> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! urb ) //<S2SV> goto alloc_fail6 ; //<S2SV> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; //<S2SV> urb -> transfer_dma = rb -> dma ; //<S2SV> if ( acm -> is_int_ep ) { //<S2SV> usb_fill_int_urb ( urb , acm -> dev , //<S2SV> acm -> rx_endpoint , //<S2SV> rb -> base , //<S2SV> acm -> readsize , //<S2SV> acm_read_bulk_callback , rb , //<S2SV> acm -> bInterval ) ; //<S2SV> } else { //<S2SV> usb_fill_bulk_urb ( urb , acm -> dev , //<S2SV> acm -> rx_endpoint , //<S2SV> rb -> base , //<S2SV> acm -> readsize , //<S2SV> acm_read_bulk_callback , rb ) ; //<S2SV> } //<S2SV> acm -> read_urbs [ i ] = urb ; //<S2SV> __set_bit ( i , & acm -> read_urbs_free ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ACM_NW ; i ++ ) { //<S2SV> struct acm_wb * snd = & ( acm -> wb [ i ] ) ; //<S2SV> snd -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( snd -> urb == NULL ) //<S2SV> goto alloc_fail7 ; //<S2SV> if ( usb_endpoint_xfer_int ( epwrite ) ) //<S2SV> usb_fill_int_urb ( snd -> urb , usb_dev , //<S2SV> usb_sndintpipe ( usb_dev , epwrite -> bEndpointAddress ) , //<S2SV> NULL , acm -> writesize , acm_write_bulk , snd , epwrite -> bInterval ) ; //<S2SV> else //<S2SV> usb_fill_bulk_urb ( snd -> urb , usb_dev , //<S2SV> usb_sndbulkpipe ( usb_dev , epwrite -> bEndpointAddress ) , //<S2SV> NULL , acm -> writesize , acm_write_bulk , snd ) ; //<S2SV> snd -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; //<S2SV> if ( quirks & SEND_ZERO_PACKET ) //<S2SV> snd -> urb -> transfer_flags |= URB_ZERO_PACKET ; //<S2SV> snd -> instance = acm ; //<S2SV> } //<S2SV> usb_set_intfdata ( intf , acm ) ; //<S2SV> i = device_create_file ( & intf -> dev , & dev_attr_bmCapabilities ) ; //<S2SV> if ( i < 0 ) //<S2SV> goto alloc_fail7 ; //<S2SV> if ( cfd ) { //<S2SV> acm -> country_codes = kmalloc ( cfd -> bLength - 4 , GFP_KERNEL ) ; //<S2SV> if ( ! acm -> country_codes ) //<S2SV> goto skip_countries ; //<S2SV> acm -> country_code_size = cfd -> bLength - 4 ; //<S2SV> memcpy ( acm -> country_codes , ( u8 * ) & cfd -> wCountyCode0 , //<S2SV> cfd -> bLength - 4 ) ; //<S2SV> acm -> country_rel_date = cfd -> iCountryCodeRelDate ; //<S2SV> i = device_create_file ( & intf -> dev , & dev_attr_wCountryCodes ) ; //<S2SV> if ( i < 0 ) { //<S2SV> kfree ( acm -> country_codes ) ; //<S2SV> acm -> country_codes = NULL ; //<S2SV> acm -> country_code_size = 0 ; //<S2SV> goto skip_countries ; //<S2SV> } //<S2SV> i = device_create_file ( & intf -> dev , //<S2SV> & dev_attr_iCountryCodeRelDate ) ; //<S2SV> if ( i < 0 ) { //<S2SV> device_remove_file ( & intf -> dev , & dev_attr_wCountryCodes ) ; //<S2SV> kfree ( acm -> country_codes ) ; //<S2SV> acm -> country_codes = NULL ; //<S2SV> acm -> country_code_size = 0 ; //<S2SV> goto skip_countries ; //<S2SV> } //<S2SV> } //<S2SV> skip_countries : //<S2SV> usb_fill_int_urb ( acm -> ctrlurb , usb_dev , //<S2SV> usb_rcvintpipe ( usb_dev , epctrl -> bEndpointAddress ) , //<S2SV> acm -> ctrl_buffer , ctrlsize , acm_ctrl_irq , acm , //<S2SV> epctrl -> bInterval ? epctrl -> bInterval : 16 ) ; //<S2SV> acm -> ctrlurb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; //<S2SV> acm -> ctrlurb -> transfer_dma = acm -> ctrl_dma ; //<S2SV> dev_info ( & intf -> dev , "ttyACM%d:<S2SV_blank>USB<S2SV_blank>ACM<S2SV_blank>device\\n" , minor ) ; //<S2SV> acm -> line . dwDTERate = cpu_to_le32 ( 9600 ) ; //<S2SV> acm -> line . bDataBits = 8 ; //<S2SV> acm_set_line ( acm , & acm -> line ) ; //<S2SV> usb_driver_claim_interface ( & acm_driver , data_interface , acm ) ; //<S2SV> usb_set_intfdata ( data_interface , acm ) ; //<S2SV> usb_get_intf ( control_interface ) ; //<S2SV> tty_dev = tty_port_register_device ( & acm -> port , acm_tty_driver , minor , //<S2SV> & control_interface -> dev ) ; //<S2SV> if ( IS_ERR ( tty_dev ) ) { //<S2SV> rv = PTR_ERR ( tty_dev ) ; //<S2SV> goto alloc_fail8 ; //<S2SV> } //<S2SV> if ( quirks & CLEAR_HALT_CONDITIONS ) { //<S2SV> usb_clear_halt ( usb_dev , usb_rcvbulkpipe ( usb_dev , epread -> bEndpointAddress ) ) ; //<S2SV> usb_clear_halt ( usb_dev , usb_sndbulkpipe ( usb_dev , epwrite -> bEndpointAddress ) ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> alloc_fail8 : //<S2SV> if ( acm -> country_codes ) { //<S2SV> device_remove_file ( & acm -> control -> dev , //<S2SV> & dev_attr_wCountryCodes ) ; //<S2SV> device_remove_file ( & acm -> control -> dev , //<S2SV> & dev_attr_iCountryCodeRelDate ) ; //<S2SV> kfree ( acm -> country_codes ) ; //<S2SV> } //<S2SV> device_remove_file ( & acm -> control -> dev , & dev_attr_bmCapabilities ) ; //<S2SV> alloc_fail7 : //<S2SV> usb_set_intfdata ( intf , NULL ) ; //<S2SV> for ( i = 0 ; i < ACM_NW ; i ++ ) //<S2SV> usb_free_urb ( acm -> wb [ i ] . urb ) ; //<S2SV> alloc_fail6 : //<S2SV> for ( i = 0 ; i < num_rx_buf ; i ++ ) //<S2SV> usb_free_urb ( acm -> read_urbs [ i ] ) ; //<S2SV> acm_read_buffers_free ( acm ) ; //<S2SV> usb_free_urb ( acm -> ctrlurb ) ; //<S2SV> alloc_fail5 : //<S2SV> acm_write_buffers_free ( acm ) ; //<S2SV> alloc_fail4 : //<S2SV> usb_free_coherent ( usb_dev , ctrlsize , acm -> ctrl_buffer , acm -> ctrl_dma ) ; //<S2SV> alloc_fail2 : //<S2SV> acm_release_minor ( acm ) ; //<S2SV> kfree ( acm ) ; //<S2SV> alloc_fail : //<S2SV> return rv ; //<S2SV> } //<S2SV> 