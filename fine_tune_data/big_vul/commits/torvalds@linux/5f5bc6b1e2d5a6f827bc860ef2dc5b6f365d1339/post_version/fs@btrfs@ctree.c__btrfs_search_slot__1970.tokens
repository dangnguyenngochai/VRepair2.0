int btrfs_search_slot ( struct btrfs_trans_handle * trans , struct btrfs_root //<S2SV> * root , struct btrfs_key * key , struct btrfs_path * p , int //<S2SV> ins_len , int cow ) //<S2SV> { //<S2SV> struct extent_buffer * b ; //<S2SV> int slot ; //<S2SV> int ret ; //<S2SV> int err ; //<S2SV> int level ; //<S2SV> int lowest_unlock = 1 ; //<S2SV> int root_lock ; //<S2SV> int write_lock_level = 0 ; //<S2SV> u8 lowest_level = 0 ; //<S2SV> int min_write_lock_level ; //<S2SV> int prev_cmp ; //<S2SV> lowest_level = p -> lowest_level ; //<S2SV> WARN_ON ( lowest_level && ins_len > 0 ) ; //<S2SV> WARN_ON ( p -> nodes [ 0 ] != NULL ) ; //<S2SV> BUG_ON ( ! cow && ins_len ) ; //<S2SV> if ( ins_len < 0 ) { //<S2SV> lowest_unlock = 2 ; //<S2SV> write_lock_level = 2 ; //<S2SV> } else if ( ins_len > 0 ) { //<S2SV> write_lock_level = 1 ; //<S2SV> } //<S2SV> if ( ! cow ) //<S2SV> write_lock_level = - 1 ; //<S2SV> if ( cow && ( p -> keep_locks || p -> lowest_level ) ) //<S2SV> write_lock_level = BTRFS_MAX_LEVEL ; //<S2SV> min_write_lock_level = write_lock_level ; //<S2SV> again : //<S2SV> prev_cmp = - 1 ; //<S2SV> root_lock = BTRFS_READ_LOCK ; //<S2SV> level = 0 ; //<S2SV> if ( p -> search_commit_root ) { //<S2SV> if ( p -> need_commit_sem ) //<S2SV> down_read ( & root -> fs_info -> commit_root_sem ) ; //<S2SV> b = root -> commit_root ; //<S2SV> extent_buffer_get ( b ) ; //<S2SV> level = btrfs_header_level ( b ) ; //<S2SV> if ( p -> need_commit_sem ) //<S2SV> up_read ( & root -> fs_info -> commit_root_sem ) ; //<S2SV> if ( ! p -> skip_locking ) //<S2SV> btrfs_tree_read_lock ( b ) ; //<S2SV> } else { //<S2SV> if ( p -> skip_locking ) { //<S2SV> b = btrfs_root_node ( root ) ; //<S2SV> level = btrfs_header_level ( b ) ; //<S2SV> } else { //<S2SV> b = btrfs_read_lock_root_node ( root ) ; //<S2SV> level = btrfs_header_level ( b ) ; //<S2SV> if ( level <= write_lock_level ) { //<S2SV> btrfs_tree_read_unlock ( b ) ; //<S2SV> free_extent_buffer ( b ) ; //<S2SV> b = btrfs_lock_root_node ( root ) ; //<S2SV> root_lock = BTRFS_WRITE_LOCK ; //<S2SV> level = btrfs_header_level ( b ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> p -> nodes [ level ] = b ; //<S2SV> if ( ! p -> skip_locking ) //<S2SV> p -> locks [ level ] = root_lock ; //<S2SV> while ( b ) { //<S2SV> level = btrfs_header_level ( b ) ; //<S2SV> if ( cow ) { //<S2SV> if ( ! should_cow_block ( trans , root , b ) ) //<S2SV> goto cow_done ; //<S2SV> if ( level > write_lock_level || //<S2SV> ( level + 1 > write_lock_level && //<S2SV> level + 1 < BTRFS_MAX_LEVEL && //<S2SV> p -> nodes [ level + 1 ] ) ) { //<S2SV> write_lock_level = level + 1 ; //<S2SV> btrfs_release_path ( p ) ; //<S2SV> goto again ; //<S2SV> } //<S2SV> btrfs_set_path_blocking ( p ) ; //<S2SV> err = btrfs_cow_block ( trans , root , b , //<S2SV> p -> nodes [ level + 1 ] , //<S2SV> p -> slots [ level + 1 ] , & b ) ; //<S2SV> if ( err ) { //<S2SV> ret = err ; //<S2SV> goto done ; //<S2SV> } //<S2SV> } //<S2SV> cow_done : //<S2SV> p -> nodes [ level ] = b ; //<S2SV> btrfs_clear_path_blocking ( p , NULL , 0 ) ; //<S2SV> if ( ! ins_len && ! p -> keep_locks ) { //<S2SV> int u = level + 1 ; //<S2SV> if ( u < BTRFS_MAX_LEVEL && p -> locks [ u ] ) { //<S2SV> btrfs_tree_unlock_rw ( p -> nodes [ u ] , p -> locks [ u ] ) ; //<S2SV> p -> locks [ u ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> ret = key_search ( b , key , level , & prev_cmp , & slot ) ; //<S2SV> if ( level != 0 ) { //<S2SV> int dec = 0 ; //<S2SV> if ( ret && slot > 0 ) { //<S2SV> dec = 1 ; //<S2SV> slot -= 1 ; //<S2SV> } //<S2SV> p -> slots [ level ] = slot ; //<S2SV> err = setup_nodes_for_search ( trans , root , p , b , level , //<S2SV> ins_len , & write_lock_level ) ; //<S2SV> if ( err == - EAGAIN ) //<S2SV> goto again ; //<S2SV> if ( err ) { //<S2SV> ret = err ; //<S2SV> goto done ; //<S2SV> } //<S2SV> b = p -> nodes [ level ] ; //<S2SV> slot = p -> slots [ level ] ; //<S2SV> if ( slot == 0 && ins_len && //<S2SV> write_lock_level < level + 1 ) { //<S2SV> write_lock_level = level + 1 ; //<S2SV> btrfs_release_path ( p ) ; //<S2SV> goto again ; //<S2SV> } //<S2SV> unlock_up ( p , level , lowest_unlock , //<S2SV> min_write_lock_level , & write_lock_level ) ; //<S2SV> if ( level == lowest_level ) { //<S2SV> if ( dec ) //<S2SV> p -> slots [ level ] ++ ; //<S2SV> goto done ; //<S2SV> } //<S2SV> err = read_block_for_search ( trans , root , p , //<S2SV> & b , level , slot , key , 0 ) ; //<S2SV> if ( err == - EAGAIN ) //<S2SV> goto again ; //<S2SV> if ( err ) { //<S2SV> ret = err ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ! p -> skip_locking ) { //<S2SV> level = btrfs_header_level ( b ) ; //<S2SV> if ( level <= write_lock_level ) { //<S2SV> err = btrfs_try_tree_write_lock ( b ) ; //<S2SV> if ( ! err ) { //<S2SV> btrfs_set_path_blocking ( p ) ; //<S2SV> btrfs_tree_lock ( b ) ; //<S2SV> btrfs_clear_path_blocking ( p , b , //<S2SV> BTRFS_WRITE_LOCK ) ; //<S2SV> } //<S2SV> p -> locks [ level ] = BTRFS_WRITE_LOCK ; //<S2SV> } else { //<S2SV> err = btrfs_try_tree_read_lock ( b ) ; //<S2SV> if ( ! err ) { //<S2SV> btrfs_set_path_blocking ( p ) ; //<S2SV> btrfs_tree_read_lock ( b ) ; //<S2SV> btrfs_clear_path_blocking ( p , b , //<S2SV> BTRFS_READ_LOCK ) ; //<S2SV> } //<S2SV> p -> locks [ level ] = BTRFS_READ_LOCK ; //<S2SV> } //<S2SV> p -> nodes [ level ] = b ; //<S2SV> } //<S2SV> } else { //<S2SV> p -> slots [ level ] = slot ; //<S2SV> if ( ins_len > 0 && //<S2SV> btrfs_leaf_free_space ( root , b ) < ins_len ) { //<S2SV> if ( write_lock_level < 1 ) { //<S2SV> write_lock_level = 1 ; //<S2SV> btrfs_release_path ( p ) ; //<S2SV> goto again ; //<S2SV> } //<S2SV> btrfs_set_path_blocking ( p ) ; //<S2SV> err = split_leaf ( trans , root , key , //<S2SV> p , ins_len , ret == 0 ) ; //<S2SV> btrfs_clear_path_blocking ( p , NULL , 0 ) ; //<S2SV> BUG_ON ( err > 0 ) ; //<S2SV> if ( err ) { //<S2SV> ret = err ; //<S2SV> goto done ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! p -> search_for_split ) //<S2SV> unlock_up ( p , level , lowest_unlock , //<S2SV> min_write_lock_level , & write_lock_level ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> } //<S2SV> ret = 1 ; //<S2SV> done : //<S2SV> if ( ! p -> leave_spinning ) //<S2SV> btrfs_set_path_blocking ( p ) ; //<S2SV> if ( ret < 0 && ! p -> skip_release_on_error ) //<S2SV> btrfs_release_path ( p ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 