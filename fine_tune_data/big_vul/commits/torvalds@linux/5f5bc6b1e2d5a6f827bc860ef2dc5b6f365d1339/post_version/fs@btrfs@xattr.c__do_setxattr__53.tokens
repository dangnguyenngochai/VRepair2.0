static int do_setxattr ( struct btrfs_trans_handle * trans , //<S2SV> struct inode * inode , const char * name , //<S2SV> const void * value , size_t size , int flags ) //<S2SV> { //<S2SV> struct btrfs_dir_item * di = NULL ; //<S2SV> struct btrfs_root * root = BTRFS_I ( inode ) -> root ; //<S2SV> struct btrfs_path * path ; //<S2SV> size_t name_len = strlen ( name ) ; //<S2SV> int ret = 0 ; //<S2SV> if ( name_len + size > BTRFS_MAX_XATTR_SIZE ( root ) ) //<S2SV> return - ENOSPC ; //<S2SV> path = btrfs_alloc_path ( ) ; //<S2SV> if ( ! path ) //<S2SV> return - ENOMEM ; //<S2SV> path -> skip_release_on_error = 1 ; //<S2SV> if ( ! value ) { //<S2SV> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , //<S2SV> name , name_len , - 1 ) ; //<S2SV> if ( ! di && ( flags & XATTR_REPLACE ) ) //<S2SV> ret = - ENODATA ; //<S2SV> else if ( di ) //<S2SV> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( flags & XATTR_REPLACE ) { //<S2SV> ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; //<S2SV> di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , //<S2SV> name , name_len , 0 ) ; //<S2SV> if ( ! di ) { //<S2SV> ret = - ENODATA ; //<S2SV> goto out ; //<S2SV> } //<S2SV> btrfs_release_path ( path ) ; //<S2SV> di = NULL ; //<S2SV> } //<S2SV> ret = btrfs_insert_xattr_item ( trans , root , path , btrfs_ino ( inode ) , //<S2SV> name , name_len , value , size ) ; //<S2SV> if ( ret == - EOVERFLOW ) { //<S2SV> ret = 0 ; //<S2SV> btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; //<S2SV> di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; //<S2SV> if ( ! di && ! ( flags & XATTR_REPLACE ) ) { //<S2SV> ret = - ENOSPC ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } else if ( ret == - EEXIST ) { //<S2SV> ret = 0 ; //<S2SV> di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; //<S2SV> ASSERT ( di ) ; //<S2SV> } else if ( ret ) { //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( di && ( flags & XATTR_CREATE ) ) { //<S2SV> ret = - EEXIST ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( di ) { //<S2SV> const int slot = path -> slots [ 0 ] ; //<S2SV> struct extent_buffer * leaf = path -> nodes [ 0 ] ; //<S2SV> const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; //<S2SV> const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; //<S2SV> const u32 data_size = sizeof ( * di ) + name_len + size ; //<S2SV> struct btrfs_item * item ; //<S2SV> unsigned long data_ptr ; //<S2SV> char * ptr ; //<S2SV> if ( size > old_data_len ) { //<S2SV> if ( btrfs_leaf_free_space ( root , leaf ) < //<S2SV> ( size - old_data_len ) ) { //<S2SV> ret = - ENOSPC ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { //<S2SV> if ( size > old_data_len ) //<S2SV> btrfs_extend_item ( root , path , //<S2SV> size - old_data_len ) ; //<S2SV> else if ( size < old_data_len ) //<S2SV> btrfs_truncate_item ( root , path , data_size , 1 ) ; //<S2SV> } else { //<S2SV> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> btrfs_extend_item ( root , path , data_size ) ; //<S2SV> } //<S2SV> item = btrfs_item_nr ( slot ) ; //<S2SV> ptr = btrfs_item_ptr ( leaf , slot , char ) ; //<S2SV> ptr += btrfs_item_size ( leaf , item ) - data_size ; //<S2SV> di = ( struct btrfs_dir_item * ) ptr ; //<S2SV> btrfs_set_dir_data_len ( leaf , di , size ) ; //<S2SV> data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; //<S2SV> write_extent_buffer ( leaf , value , data_ptr , size ) ; //<S2SV> btrfs_mark_buffer_dirty ( leaf ) ; //<S2SV> } else { //<S2SV> } //<S2SV> out : //<S2SV> btrfs_free_path ( path ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 