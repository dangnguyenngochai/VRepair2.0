static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , //<S2SV> struct usb_host_config * config , unsigned char * buffer , int size ) //<S2SV> { //<S2SV> struct device * ddev = & dev -> dev ; //<S2SV> unsigned char * buffer0 = buffer ; //<S2SV> int cfgno ; //<S2SV> int nintf , nintf_orig ; //<S2SV> int i , j , n ; //<S2SV> struct usb_interface_cache * intfc ; //<S2SV> unsigned char * buffer2 ; //<S2SV> int size2 ; //<S2SV> struct usb_descriptor_header * header ; //<S2SV> int len , retval ; //<S2SV> u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; //<S2SV> unsigned iad_num = 0 ; //<S2SV> memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; //<S2SV> if ( config -> desc . bDescriptorType != USB_DT_CONFIG || //<S2SV> config -> desc . bLength < USB_DT_CONFIG_SIZE || //<S2SV> config -> desc . bLength > size ) { //<S2SV> dev_err ( ddev , "invalid<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>config<S2SV_blank>index<S2SV_blank>%d:<S2SV_blank>" //<S2SV> "type<S2SV_blank>=<S2SV_blank>0x%X,<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%d\\n" , cfgidx , //<S2SV> config -> desc . bDescriptorType , config -> desc . bLength ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> cfgno = config -> desc . bConfigurationValue ; //<S2SV> buffer += config -> desc . bLength ; //<S2SV> size -= config -> desc . bLength ; //<S2SV> nintf = nintf_orig = config -> desc . bNumInterfaces ; //<S2SV> if ( nintf > USB_MAXINTERFACES ) { //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>interfaces:<S2SV_blank>%d,<S2SV_blank>" //<S2SV> "using<S2SV_blank>maximum<S2SV_blank>allowed:<S2SV_blank>%d\\n" , //<S2SV> cfgno , nintf , USB_MAXINTERFACES ) ; //<S2SV> nintf = USB_MAXINTERFACES ; //<S2SV> } //<S2SV> n = 0 ; //<S2SV> for ( ( buffer2 = buffer , size2 = size ) ; //<S2SV> size2 > 0 ; //<S2SV> ( buffer2 += header -> bLength , size2 -= header -> bLength ) ) { //<S2SV> if ( size2 < sizeof ( struct usb_descriptor_header ) ) { //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>descriptor<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>excess<S2SV_blank>" //<S2SV> "byte%s,<S2SV_blank>ignoring\\n" , //<S2SV> cfgno , size2 , plural ( size2 ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> header = ( struct usb_descriptor_header * ) buffer2 ; //<S2SV> if ( ( header -> bLength > size2 ) || ( header -> bLength < 2 ) ) { //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>descriptor<S2SV_blank>" //<S2SV> "of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping<S2SV_blank>remainder<S2SV_blank>of<S2SV_blank>the<S2SV_blank>config\\n" , //<S2SV> cfgno , header -> bLength ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( header -> bDescriptorType == USB_DT_INTERFACE ) { //<S2SV> struct usb_interface_descriptor * d ; //<S2SV> int inum ; //<S2SV> d = ( struct usb_interface_descriptor * ) header ; //<S2SV> if ( d -> bLength < USB_DT_INTERFACE_SIZE ) { //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>" //<S2SV> "interface<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>" //<S2SV> "skipping\\n" , cfgno , d -> bLength ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> inum = d -> bInterfaceNumber ; //<S2SV> if ( ( dev -> quirks & USB_QUIRK_HONOR_BNUMINTERFACES ) && //<S2SV> n >= nintf_orig ) { //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>more<S2SV_blank>interface<S2SV_blank>" //<S2SV> "descriptors,<S2SV_blank>than<S2SV_blank>it<S2SV_blank>declares<S2SV_blank>in<S2SV_blank>" //<S2SV> "bNumInterfaces,<S2SV_blank>ignoring<S2SV_blank>interface<S2SV_blank>" //<S2SV> "number:<S2SV_blank>%d\\n" , cfgno , inum ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( inum >= nintf_orig ) //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>" //<S2SV> "interface<S2SV_blank>number:<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n" , //<S2SV> cfgno , inum , nintf_orig - 1 ) ; //<S2SV> for ( i = 0 ; i < n ; ++ i ) { //<S2SV> if ( inums [ i ] == inum ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( i < n ) { //<S2SV> if ( nalts [ i ] < 255 ) //<S2SV> ++ nalts [ i ] ; //<S2SV> } else if ( n < USB_MAXINTERFACES ) { //<S2SV> inums [ n ] = inum ; //<S2SV> nalts [ n ] = 1 ; //<S2SV> ++ n ; //<S2SV> } //<S2SV> } else if ( header -> bDescriptorType == //<S2SV> USB_DT_INTERFACE_ASSOCIATION ) { //<S2SV> struct usb_interface_assoc_descriptor * d ; //<S2SV> d = ( struct usb_interface_assoc_descriptor * ) header ; //<S2SV> if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { //<S2SV> dev_warn ( ddev , //<S2SV> "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n" , //<S2SV> cfgno , d -> bLength ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( iad_num == USB_MAXIADS ) { //<S2SV> dev_warn ( ddev , "found<S2SV_blank>more<S2SV_blank>Interface<S2SV_blank>" //<S2SV> "Association<S2SV_blank>Descriptors<S2SV_blank>" //<S2SV> "than<S2SV_blank>allocated<S2SV_blank>for<S2SV_blank>in<S2SV_blank>" //<S2SV> "configuration<S2SV_blank>%d\\n" , cfgno ) ; //<S2SV> } else { //<S2SV> config -> intf_assoc [ iad_num ] = d ; //<S2SV> iad_num ++ ; //<S2SV> } //<S2SV> } else if ( header -> bDescriptorType == USB_DT_DEVICE || //<S2SV> header -> bDescriptorType == USB_DT_CONFIG ) //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>contains<S2SV_blank>an<S2SV_blank>unexpected<S2SV_blank>" //<S2SV> "descriptor<S2SV_blank>of<S2SV_blank>type<S2SV_blank>0x%X,<S2SV_blank>skipping\\n" , //<S2SV> cfgno , header -> bDescriptorType ) ; //<S2SV> } //<S2SV> size = buffer2 - buffer ; //<S2SV> config -> desc . wTotalLength = cpu_to_le16 ( buffer2 - buffer0 ) ; //<S2SV> if ( n != nintf ) //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>interface%s,<S2SV_blank>different<S2SV_blank>from<S2SV_blank>" //<S2SV> "the<S2SV_blank>descriptor\'s<S2SV_blank>value:<S2SV_blank>%d\\n" , //<S2SV> cfgno , n , plural ( n ) , nintf_orig ) ; //<S2SV> else if ( n == 0 ) //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>interfaces?\\n" , cfgno ) ; //<S2SV> config -> desc . bNumInterfaces = nintf = n ; //<S2SV> for ( i = 0 ; i < nintf ; ++ i ) { //<S2SV> for ( j = 0 ; j < nintf ; ++ j ) { //<S2SV> if ( inums [ j ] == i ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( j >= nintf ) //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>interface<S2SV_blank>number<S2SV_blank>" //<S2SV> "%d\\n" , cfgno , i ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < nintf ; ++ i ) { //<S2SV> j = nalts [ i ] ; //<S2SV> if ( j > USB_MAXALTSETTING ) { //<S2SV> dev_warn ( ddev , "too<S2SV_blank>many<S2SV_blank>alternate<S2SV_blank>settings<S2SV_blank>for<S2SV_blank>" //<S2SV> "config<S2SV_blank>%d<S2SV_blank>interface<S2SV_blank>%d:<S2SV_blank>%d,<S2SV_blank>" //<S2SV> "using<S2SV_blank>maximum<S2SV_blank>allowed:<S2SV_blank>%d\\n" , //<S2SV> cfgno , inums [ i ] , j , USB_MAXALTSETTING ) ; //<S2SV> nalts [ i ] = j = USB_MAXALTSETTING ; //<S2SV> } //<S2SV> len = sizeof ( * intfc ) + sizeof ( struct usb_host_interface ) * j ; //<S2SV> config -> intf_cache [ i ] = intfc = kzalloc ( len , GFP_KERNEL ) ; //<S2SV> if ( ! intfc ) //<S2SV> return - ENOMEM ; //<S2SV> kref_init ( & intfc -> ref ) ; //<S2SV> } //<S2SV> config -> extra = buffer ; //<S2SV> i = find_next_descriptor ( buffer , size , USB_DT_INTERFACE , //<S2SV> USB_DT_INTERFACE , & n ) ; //<S2SV> config -> extralen = i ; //<S2SV> if ( n > 0 ) //<S2SV> dev_dbg ( ddev , "skipped<S2SV_blank>%d<S2SV_blank>descriptor%s<S2SV_blank>after<S2SV_blank>%s\\n" , //<S2SV> n , plural ( n ) , "configuration" ) ; //<S2SV> buffer += i ; //<S2SV> size -= i ; //<S2SV> while ( size > 0 ) { //<S2SV> retval = usb_parse_interface ( ddev , cfgno , config , //<S2SV> buffer , size , inums , nalts ) ; //<S2SV> if ( retval < 0 ) //<S2SV> return retval ; //<S2SV> buffer += retval ; //<S2SV> size -= retval ; //<S2SV> } //<S2SV> for ( i = 0 ; i < nintf ; ++ i ) { //<S2SV> intfc = config -> intf_cache [ i ] ; //<S2SV> for ( j = 0 ; j < intfc -> num_altsetting ; ++ j ) { //<S2SV> for ( n = 0 ; n < intfc -> num_altsetting ; ++ n ) { //<S2SV> if ( intfc -> altsetting [ n ] . desc . //<S2SV> bAlternateSetting == j ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( n >= intfc -> num_altsetting ) //<S2SV> dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>interface<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>no<S2SV_blank>" //<S2SV> "altsetting<S2SV_blank>%d\\n" , cfgno , inums [ i ] , j ) ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 