static int journal_unmap_buffer ( journal_t * journal , struct buffer_head * bh ) //<S2SV> { //<S2SV> transaction_t * transaction ; //<S2SV> struct journal_head * jh ; //<S2SV> int may_free = 1 ; //<S2SV> int ret ; //<S2SV> BUFFER_TRACE ( bh , "entry" ) ; //<S2SV> if ( ! buffer_jbd ( bh ) ) //<S2SV> goto zap_buffer_unlocked ; //<S2SV> write_lock ( & journal -> j_state_lock ) ; //<S2SV> jbd_lock_bh_state ( bh ) ; //<S2SV> spin_lock ( & journal -> j_list_lock ) ; //<S2SV> jh = jbd2_journal_grab_journal_head ( bh ) ; //<S2SV> if ( ! jh ) //<S2SV> goto zap_buffer_no_jh ; //<S2SV> transaction = jh -> b_transaction ; //<S2SV> if ( transaction == NULL ) { //<S2SV> if ( ! jh -> b_cp_transaction ) { //<S2SV> JBUFFER_TRACE ( jh , "not<S2SV_blank>on<S2SV_blank>any<S2SV_blank>transaction:<S2SV_blank>zap" ) ; //<S2SV> goto zap_buffer ; //<S2SV> } //<S2SV> if ( ! buffer_dirty ( bh ) ) { //<S2SV> goto zap_buffer ; //<S2SV> } //<S2SV> if ( journal -> j_running_transaction ) { //<S2SV> JBUFFER_TRACE ( jh , "checkpointed:<S2SV_blank>add<S2SV_blank>to<S2SV_blank>BJ_Forget" ) ; //<S2SV> ret = __dispose_buffer ( jh , //<S2SV> journal -> j_running_transaction ) ; //<S2SV> jbd2_journal_put_journal_head ( jh ) ; //<S2SV> spin_unlock ( & journal -> j_list_lock ) ; //<S2SV> jbd_unlock_bh_state ( bh ) ; //<S2SV> write_unlock ( & journal -> j_state_lock ) ; //<S2SV> return ret ; //<S2SV> } else { //<S2SV> if ( journal -> j_committing_transaction ) { //<S2SV> JBUFFER_TRACE ( jh , "give<S2SV_blank>to<S2SV_blank>committing<S2SV_blank>trans" ) ; //<S2SV> ret = __dispose_buffer ( jh , //<S2SV> journal -> j_committing_transaction ) ; //<S2SV> jbd2_journal_put_journal_head ( jh ) ; //<S2SV> spin_unlock ( & journal -> j_list_lock ) ; //<S2SV> jbd_unlock_bh_state ( bh ) ; //<S2SV> write_unlock ( & journal -> j_state_lock ) ; //<S2SV> return ret ; //<S2SV> } else { //<S2SV> clear_buffer_jbddirty ( bh ) ; //<S2SV> goto zap_buffer ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( transaction == journal -> j_committing_transaction ) { //<S2SV> JBUFFER_TRACE ( jh , "on<S2SV_blank>committing<S2SV_blank>transaction" ) ; //<S2SV> set_buffer_freed ( bh ) ; //<S2SV> if ( journal -> j_running_transaction && buffer_jbddirty ( bh ) ) //<S2SV> jh -> b_next_transaction = journal -> j_running_transaction ; //<S2SV> jbd2_journal_put_journal_head ( jh ) ; //<S2SV> spin_unlock ( & journal -> j_list_lock ) ; //<S2SV> jbd_unlock_bh_state ( bh ) ; //<S2SV> write_unlock ( & journal -> j_state_lock ) ; //<S2SV> return 0 ; //<S2SV> } else { //<S2SV> J_ASSERT_JH ( jh , transaction == journal -> j_running_transaction ) ; //<S2SV> JBUFFER_TRACE ( jh , "on<S2SV_blank>running<S2SV_blank>transaction" ) ; //<S2SV> may_free = __dispose_buffer ( jh , transaction ) ; //<S2SV> } //<S2SV> zap_buffer : //<S2SV> jbd2_journal_put_journal_head ( jh ) ; //<S2SV> zap_buffer_no_jh : //<S2SV> spin_unlock ( & journal -> j_list_lock ) ; //<S2SV> jbd_unlock_bh_state ( bh ) ; //<S2SV> write_unlock ( & journal -> j_state_lock ) ; //<S2SV> zap_buffer_unlocked : //<S2SV> clear_buffer_dirty ( bh ) ; //<S2SV> J_ASSERT_BH ( bh , ! buffer_jbddirty ( bh ) ) ; //<S2SV> clear_buffer_mapped ( bh ) ; //<S2SV> clear_buffer_req ( bh ) ; //<S2SV> clear_buffer_new ( bh ) ; //<S2SV> clear_buffer_delay ( bh ) ; //<S2SV> clear_buffer_unwritten ( bh ) ; //<S2SV> bh -> b_bdev = NULL ; //<S2SV> return may_free ; //<S2SV> } //<S2SV> 