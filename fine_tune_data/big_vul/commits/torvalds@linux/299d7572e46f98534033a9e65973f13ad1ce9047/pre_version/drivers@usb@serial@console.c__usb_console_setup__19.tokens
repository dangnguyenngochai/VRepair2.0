static int usb_console_setup ( struct console * co , char * options ) //<S2SV> { //<S2SV> struct usbcons_info * info = & usbcons_info ; //<S2SV> int baud = 9600 ; //<S2SV> int bits = 8 ; //<S2SV> int parity = 'n' ; //<S2SV> int doflow = 0 ; //<S2SV> int cflag = CREAD | HUPCL | CLOCAL ; //<S2SV> char * s ; //<S2SV> struct usb_serial * serial ; //<S2SV> struct usb_serial_port * port ; //<S2SV> int retval ; //<S2SV> struct tty_struct * tty = NULL ; //<S2SV> struct ktermios dummy ; //<S2SV> if ( options ) { //<S2SV> baud = simple_strtoul ( options , NULL , 10 ) ; //<S2SV> s = options ; //<S2SV> while ( * s >= '0' && * s <= '9' ) //<S2SV> s ++ ; //<S2SV> if ( * s ) //<S2SV> parity = * s ++ ; //<S2SV> if ( * s ) //<S2SV> bits = * s ++ - '0' ; //<S2SV> if ( * s ) //<S2SV> doflow = ( * s ++ == 'r' ) ; //<S2SV> } //<S2SV> if ( baud == 0 ) //<S2SV> baud = 9600 ; //<S2SV> switch ( bits ) { //<S2SV> case 7 : //<S2SV> cflag |= CS7 ; //<S2SV> break ; //<S2SV> default : //<S2SV> case 8 : //<S2SV> cflag |= CS8 ; //<S2SV> break ; //<S2SV> } //<S2SV> switch ( parity ) { //<S2SV> case 'o' : case 'O' : //<S2SV> cflag |= PARODD ; //<S2SV> break ; //<S2SV> case 'e' : case 'E' : //<S2SV> cflag |= PARENB ; //<S2SV> break ; //<S2SV> } //<S2SV> co -> cflag = cflag ; //<S2SV> port = usb_serial_port_get_by_minor ( co -> index ) ; //<S2SV> if ( port == NULL ) { //<S2SV> pr_err ( "No<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>connected<S2SV_blank>to<S2SV_blank>ttyUSB%i\\n" , co -> index ) ; //<S2SV> return - ENODEV ; //<S2SV> } //<S2SV> serial = port -> serial ; //<S2SV> retval = usb_autopm_get_interface ( serial -> interface ) ; //<S2SV> if ( retval ) //<S2SV> goto error_get_interface ; //<S2SV> tty_port_tty_set ( & port -> port , NULL ) ; //<S2SV> info -> port = port ; //<S2SV> ++ port -> port . count ; //<S2SV> if ( ! tty_port_initialized ( & port -> port ) ) { //<S2SV> if ( serial -> type -> set_termios ) { //<S2SV> tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; //<S2SV> if ( ! tty ) { //<S2SV> retval = - ENOMEM ; //<S2SV> goto reset_open_count ; //<S2SV> } //<S2SV> kref_init ( & tty -> kref ) ; //<S2SV> tty -> driver = usb_serial_tty_driver ; //<S2SV> tty -> index = co -> index ; //<S2SV> init_ldsem ( & tty -> ldisc_sem ) ; //<S2SV> spin_lock_init ( & tty -> files_lock ) ; //<S2SV> INIT_LIST_HEAD ( & tty -> tty_files ) ; //<S2SV> kref_get ( & tty -> driver -> kref ) ; //<S2SV> __module_get ( tty -> driver -> owner ) ; //<S2SV> tty -> ops = & usb_console_fake_tty_ops ; //<S2SV> tty_init_termios ( tty ) ; //<S2SV> tty_port_tty_set ( & port -> port , tty ) ; //<S2SV> } //<S2SV> retval = serial -> type -> open ( NULL , port ) ; //<S2SV> if ( retval ) { //<S2SV> dev_err ( & port -> dev , "could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>USB<S2SV_blank>console<S2SV_blank>port\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( serial -> type -> set_termios ) { //<S2SV> tty -> termios . c_cflag = cflag ; //<S2SV> tty_termios_encode_baud_rate ( & tty -> termios , baud , baud ) ; //<S2SV> memset ( & dummy , 0 , sizeof ( struct ktermios ) ) ; //<S2SV> serial -> type -> set_termios ( tty , port , & dummy ) ; //<S2SV> tty_port_tty_set ( & port -> port , NULL ) ; //<S2SV> tty_kref_put ( tty ) ; //<S2SV> } //<S2SV> tty_port_set_initialized ( & port -> port , 1 ) ; //<S2SV> } //<S2SV> -- port -> port . count ; //<S2SV> port -> port . console = 1 ; //<S2SV> mutex_unlock ( & serial -> disc_mutex ) ; //<S2SV> return retval ; //<S2SV> fail : //<S2SV> tty_port_tty_set ( & port -> port , NULL ) ; //<S2SV> tty_kref_put ( tty ) ; //<S2SV> reset_open_count : //<S2SV> port -> port . count = 0 ; //<S2SV> usb_autopm_put_interface ( serial -> interface ) ; //<S2SV> error_get_interface : //<S2SV> usb_serial_put ( serial ) ; //<S2SV> mutex_unlock ( & serial -> disc_mutex ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 