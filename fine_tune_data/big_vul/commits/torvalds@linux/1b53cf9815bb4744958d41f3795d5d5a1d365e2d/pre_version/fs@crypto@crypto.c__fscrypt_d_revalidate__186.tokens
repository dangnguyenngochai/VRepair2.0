static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) //<S2SV> { //<S2SV> struct dentry * dir ; //<S2SV> struct fscrypt_info * ci ; //<S2SV> int dir_has_key , cached_with_key ; //<S2SV> if ( flags & LOOKUP_RCU ) //<S2SV> return - ECHILD ; //<S2SV> dir = dget_parent ( dentry ) ; //<S2SV> if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { //<S2SV> dput ( dir ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> ci = d_inode ( dir ) -> i_crypt_info ; //<S2SV> if ( ci && ci -> ci_keyring_key && //<S2SV> ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | //<S2SV> ( 1 << KEY_FLAG_REVOKED ) | //<S2SV> ( 1 << KEY_FLAG_DEAD ) ) ) ) //<S2SV> ci = NULL ; //<S2SV> spin_lock ( & dentry -> d_lock ) ; //<S2SV> cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; //<S2SV> spin_unlock ( & dentry -> d_lock ) ; //<S2SV> dir_has_key = ( ci != NULL ) ; //<S2SV> dput ( dir ) ; //<S2SV> if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || //<S2SV> ( ! cached_with_key && dir_has_key ) || //<S2SV> ( cached_with_key && ! dir_has_key ) ) //<S2SV> return 0 ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> 