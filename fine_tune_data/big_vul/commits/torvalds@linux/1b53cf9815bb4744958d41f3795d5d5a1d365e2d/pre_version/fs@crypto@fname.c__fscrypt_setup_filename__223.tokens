int fscrypt_setup_filename ( struct inode * dir , const struct qstr * iname , //<S2SV> int lookup , struct fscrypt_name * fname ) //<S2SV> { //<S2SV> int ret = 0 , bigname = 0 ; //<S2SV> memset ( fname , 0 , sizeof ( struct fscrypt_name ) ) ; //<S2SV> fname -> usr_fname = iname ; //<S2SV> if ( ! dir -> i_sb -> s_cop -> is_encrypted ( dir ) || //<S2SV> fscrypt_is_dot_dotdot ( iname ) ) { //<S2SV> fname -> disk_name . name = ( unsigned char * ) iname -> name ; //<S2SV> fname -> disk_name . len = iname -> len ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> ret = fscrypt_get_crypt_info ( dir ) ; //<S2SV> if ( ret && ret != - EOPNOTSUPP ) //<S2SV> return ret ; //<S2SV> if ( dir -> i_crypt_info ) { //<S2SV> ret = fscrypt_fname_alloc_buffer ( dir , iname -> len , //<S2SV> & fname -> crypto_buf ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> ret = fname_encrypt ( dir , iname , & fname -> crypto_buf ) ; //<S2SV> if ( ret ) //<S2SV> goto errout ; //<S2SV> fname -> disk_name . name = fname -> crypto_buf . name ; //<S2SV> fname -> disk_name . len = fname -> crypto_buf . len ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! lookup ) //<S2SV> return - ENOKEY ; //<S2SV> if ( iname -> name [ 0 ] == '_' ) //<S2SV> bigname = 1 ; //<S2SV> if ( ( bigname && ( iname -> len != 33 ) ) || ( ! bigname && ( iname -> len > 43 ) ) ) //<S2SV> return - ENOENT ; //<S2SV> fname -> crypto_buf . name = kmalloc ( 32 , GFP_KERNEL ) ; //<S2SV> if ( fname -> crypto_buf . name == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> ret = digest_decode ( iname -> name + bigname , iname -> len - bigname , //<S2SV> fname -> crypto_buf . name ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> ret = - ENOENT ; //<S2SV> goto errout ; //<S2SV> } //<S2SV> fname -> crypto_buf . len = ret ; //<S2SV> if ( bigname ) { //<S2SV> memcpy ( & fname -> hash , fname -> crypto_buf . name , 4 ) ; //<S2SV> memcpy ( & fname -> minor_hash , fname -> crypto_buf . name + 4 , 4 ) ; //<S2SV> } else { //<S2SV> fname -> disk_name . name = fname -> crypto_buf . name ; //<S2SV> fname -> disk_name . len = fname -> crypto_buf . len ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> errout : //<S2SV> fscrypt_fname_free_buffer ( & fname -> crypto_buf ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 