static int validate_user_key ( struct fscrypt_info * crypt_info , //<S2SV> struct fscrypt_context * ctx , u8 * raw_key , //<S2SV> const char * prefix ) //<S2SV> { //<S2SV> char * description ; //<S2SV> struct key * keyring_key ; //<S2SV> struct fscrypt_key * master_key ; //<S2SV> const struct user_key_payload * ukp ; //<S2SV> int res ; //<S2SV> description = kasprintf ( GFP_NOFS , "%s%*phN" , prefix , //<S2SV> FS_KEY_DESCRIPTOR_SIZE , //<S2SV> ctx -> master_key_descriptor ) ; //<S2SV> if ( ! description ) //<S2SV> return - ENOMEM ; //<S2SV> keyring_key = request_key ( & key_type_logon , description , NULL ) ; //<S2SV> kfree ( description ) ; //<S2SV> if ( IS_ERR ( keyring_key ) ) //<S2SV> return PTR_ERR ( keyring_key ) ; //<S2SV> down_read ( & keyring_key -> sem ) ; //<S2SV> if ( keyring_key -> type != & key_type_logon ) { //<S2SV> printk_once ( KERN_WARNING //<S2SV> "%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\n" , __func__ ) ; //<S2SV> res = - ENOKEY ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ukp = user_key_payload ( keyring_key ) ; //<S2SV> if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { //<S2SV> res = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> master_key = ( struct fscrypt_key * ) ukp -> data ; //<S2SV> BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; //<S2SV> if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { //<S2SV> printk_once ( KERN_WARNING //<S2SV> "%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n" , //<S2SV> __func__ , master_key -> size ) ; //<S2SV> res = - ENOKEY ; //<S2SV> goto out ; //<S2SV> } //<S2SV> res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; //<S2SV> out : //<S2SV> up_read ( & keyring_key -> sem ) ; //<S2SV> key_put ( keyring_key ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> 