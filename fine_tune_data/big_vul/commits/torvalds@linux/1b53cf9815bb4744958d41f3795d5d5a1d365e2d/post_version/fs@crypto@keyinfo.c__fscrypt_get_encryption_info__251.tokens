int fscrypt_get_encryption_info ( struct inode * inode ) //<S2SV> { //<S2SV> struct fscrypt_info * crypt_info ; //<S2SV> struct fscrypt_context ctx ; //<S2SV> struct crypto_skcipher * ctfm ; //<S2SV> const char * cipher_str ; //<S2SV> int keysize ; //<S2SV> u8 * raw_key = NULL ; //<S2SV> int res ; //<S2SV> if ( inode -> i_crypt_info ) //<S2SV> return 0 ; //<S2SV> res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; //<S2SV> if ( res ) //<S2SV> return res ; //<S2SV> if ( ! inode -> i_sb -> s_cop -> get_context ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; //<S2SV> if ( res < 0 ) { //<S2SV> if ( ! fscrypt_dummy_context_enabled ( inode ) || //<S2SV> inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) //<S2SV> return res ; //<S2SV> memset ( & ctx , 0 , sizeof ( ctx ) ) ; //<S2SV> ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; //<S2SV> ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; //<S2SV> ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; //<S2SV> memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; //<S2SV> } else if ( res != sizeof ( ctx ) ) { //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) //<S2SV> return - EINVAL ; //<S2SV> if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) //<S2SV> return - EINVAL ; //<S2SV> crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; //<S2SV> if ( ! crypt_info ) //<S2SV> return - ENOMEM ; //<S2SV> crypt_info -> ci_flags = ctx . flags ; //<S2SV> crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; //<S2SV> crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; //<S2SV> crypt_info -> ci_ctfm = NULL ; //<S2SV> memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , //<S2SV> sizeof ( crypt_info -> ci_master_key ) ) ; //<S2SV> res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; //<S2SV> if ( res ) //<S2SV> goto out ; //<S2SV> res = - ENOMEM ; //<S2SV> raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; //<S2SV> if ( ! raw_key ) //<S2SV> goto out ; //<S2SV> res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; //<S2SV> if ( res && inode -> i_sb -> s_cop -> key_prefix ) { //<S2SV> int res2 = validate_user_key ( crypt_info , & ctx , raw_key , //<S2SV> inode -> i_sb -> s_cop -> key_prefix ) ; //<S2SV> if ( res2 ) { //<S2SV> if ( res2 == - ENOKEY ) //<S2SV> res = - ENOKEY ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } else if ( res ) { //<S2SV> goto out ; //<S2SV> } //<S2SV> ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; //<S2SV> if ( ! ctfm || IS_ERR ( ctfm ) ) { //<S2SV> res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; //<S2SV> printk ( KERN_DEBUG //<S2SV> "%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n" , //<S2SV> __func__ , res , ( unsigned ) inode -> i_ino ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> crypt_info -> ci_ctfm = ctfm ; //<S2SV> crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; //<S2SV> crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; //<S2SV> res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; //<S2SV> if ( res ) //<S2SV> goto out ; //<S2SV> if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) //<S2SV> crypt_info = NULL ; //<S2SV> out : //<S2SV> if ( res == - ENOKEY ) //<S2SV> res = 0 ; //<S2SV> put_crypt_info ( crypt_info ) ; //<S2SV> kzfree ( raw_key ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> 