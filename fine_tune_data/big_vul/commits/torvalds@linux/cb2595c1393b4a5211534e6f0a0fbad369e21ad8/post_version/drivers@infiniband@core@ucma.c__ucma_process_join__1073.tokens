static ssize_t ucma_process_join ( struct ucma_file * file , //<S2SV> struct rdma_ucm_join_mcast * cmd , int out_len ) //<S2SV> { //<S2SV> struct rdma_ucm_create_id_resp resp ; //<S2SV> struct ucma_context * ctx ; //<S2SV> struct ucma_multicast * mc ; //<S2SV> struct sockaddr * addr ; //<S2SV> int ret ; //<S2SV> u8 join_state ; //<S2SV> if ( out_len < sizeof ( resp ) ) //<S2SV> return - ENOSPC ; //<S2SV> addr = ( struct sockaddr * ) & cmd -> addr ; //<S2SV> if ( cmd -> addr_size != rdma_addr_size ( addr ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER ) //<S2SV> join_state = BIT ( FULLMEMBER_JOIN ) ; //<S2SV> else if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER ) //<S2SV> join_state = BIT ( SENDONLY_FULLMEMBER_JOIN ) ; //<S2SV> else //<S2SV> return - EINVAL ; //<S2SV> ctx = ucma_get_ctx_dev ( file , cmd -> id ) ; //<S2SV> if ( IS_ERR ( ctx ) ) //<S2SV> return PTR_ERR ( ctx ) ; //<S2SV> mutex_lock ( & file -> mut ) ; //<S2SV> mc = ucma_alloc_multicast ( ctx ) ; //<S2SV> if ( ! mc ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto err1 ; //<S2SV> } //<S2SV> mc -> join_state = join_state ; //<S2SV> mc -> uid = cmd -> uid ; //<S2SV> memcpy ( & mc -> addr , addr , cmd -> addr_size ) ; //<S2SV> ret = rdma_join_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr , //<S2SV> join_state , mc ) ; //<S2SV> if ( ret ) //<S2SV> goto err2 ; //<S2SV> resp . id = mc -> id ; //<S2SV> if ( copy_to_user ( u64_to_user_ptr ( cmd -> response ) , //<S2SV> & resp , sizeof ( resp ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto err3 ; //<S2SV> } //<S2SV> mutex_lock ( & mut ) ; //<S2SV> idr_replace ( & multicast_idr , mc , mc -> id ) ; //<S2SV> mutex_unlock ( & mut ) ; //<S2SV> mutex_unlock ( & file -> mut ) ; //<S2SV> ucma_put_ctx ( ctx ) ; //<S2SV> return 0 ; //<S2SV> err3 : //<S2SV> rdma_leave_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr ) ; //<S2SV> ucma_cleanup_mc_events ( mc ) ; //<S2SV> err2 : //<S2SV> mutex_lock ( & mut ) ; //<S2SV> idr_remove ( & multicast_idr , mc -> id ) ; //<S2SV> mutex_unlock ( & mut ) ; //<S2SV> list_del ( & mc -> list ) ; //<S2SV> kfree ( mc ) ; //<S2SV> err1 : //<S2SV> mutex_unlock ( & file -> mut ) ; //<S2SV> ucma_put_ctx ( ctx ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 