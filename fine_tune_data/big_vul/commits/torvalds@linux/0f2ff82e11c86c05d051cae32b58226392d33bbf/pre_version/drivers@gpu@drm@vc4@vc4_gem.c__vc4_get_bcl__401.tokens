static int //<S2SV> vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) //<S2SV> { //<S2SV> struct drm_vc4_submit_cl * args = exec -> args ; //<S2SV> void * temp = NULL ; //<S2SV> void * bin ; //<S2SV> int ret = 0 ; //<S2SV> uint32_t bin_offset = 0 ; //<S2SV> uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , //<S2SV> 16 ) ; //<S2SV> uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; //<S2SV> uint32_t exec_size = uniforms_offset + args -> uniforms_size ; //<S2SV> uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * //<S2SV> args -> shader_rec_count ) ; //<S2SV> struct vc4_bo * bo ; //<S2SV> if ( uniforms_offset < shader_rec_offset || //<S2SV> exec_size < uniforms_offset || //<S2SV> args -> shader_rec_count >= ( UINT_MAX / //<S2SV> sizeof ( struct vc4_shader_state ) ) || //<S2SV> temp_size < exec_size ) { //<S2SV> DRM_ERROR ( "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> temp = drm_malloc_ab ( temp_size , 1 ) ; //<S2SV> if ( ! temp ) { //<S2SV> DRM_ERROR ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>" //<S2SV> "in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n" ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> bin = temp + bin_offset ; //<S2SV> exec -> shader_rec_u = temp + shader_rec_offset ; //<S2SV> exec -> uniforms_u = temp + uniforms_offset ; //<S2SV> exec -> shader_state = temp + exec_size ; //<S2SV> exec -> shader_state_size = args -> shader_rec_count ; //<S2SV> if ( copy_from_user ( bin , //<S2SV> ( void __user * ) ( uintptr_t ) args -> bin_cl , //<S2SV> args -> bin_cl_size ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( copy_from_user ( exec -> shader_rec_u , //<S2SV> ( void __user * ) ( uintptr_t ) args -> shader_rec , //<S2SV> args -> shader_rec_size ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( copy_from_user ( exec -> uniforms_u , //<S2SV> ( void __user * ) ( uintptr_t ) args -> uniforms , //<S2SV> args -> uniforms_size ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> bo = vc4_bo_create ( dev , exec_size , true ) ; //<S2SV> if ( IS_ERR ( bo ) ) { //<S2SV> DRM_ERROR ( "Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n" ) ; //<S2SV> ret = PTR_ERR ( bo ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> exec -> exec_bo = & bo -> base ; //<S2SV> list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , //<S2SV> & exec -> unref_list ) ; //<S2SV> exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; //<S2SV> exec -> bin_u = bin ; //<S2SV> exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; //<S2SV> exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; //<S2SV> exec -> shader_rec_size = args -> shader_rec_size ; //<S2SV> exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; //<S2SV> exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; //<S2SV> exec -> uniforms_size = args -> uniforms_size ; //<S2SV> ret = vc4_validate_bin_cl ( dev , //<S2SV> exec -> exec_bo -> vaddr + bin_offset , //<S2SV> bin , //<S2SV> exec ) ; //<S2SV> if ( ret ) //<S2SV> goto fail ; //<S2SV> ret = vc4_validate_shader_recs ( dev , exec ) ; //<S2SV> if ( ret ) //<S2SV> goto fail ; //<S2SV> ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; //<S2SV> fail : //<S2SV> drm_free_large ( temp ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 