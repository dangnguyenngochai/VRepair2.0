static int do_replace ( struct net * net , const void __user * user , //<S2SV> unsigned int len ) //<S2SV> { //<S2SV> int ret , countersize ; //<S2SV> struct ebt_table_info * newinfo ; //<S2SV> struct ebt_replace tmp ; //<S2SV> if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) //<S2SV> return - EFAULT ; //<S2SV> if ( len != sizeof ( tmp ) + tmp . entries_size ) { //<S2SV> BUGPRINT ( "Wrong<S2SV_blank>len<S2SV_blank>argument\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( tmp . entries_size == 0 ) { //<S2SV> BUGPRINT ( "Entries_size<S2SV_blank>never<S2SV_blank>zero\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / //<S2SV> NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) //<S2SV> return - ENOMEM ; //<S2SV> if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) //<S2SV> return - ENOMEM ; //<S2SV> tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ; //<S2SV> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; //<S2SV> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; //<S2SV> if ( ! newinfo ) //<S2SV> return - ENOMEM ; //<S2SV> if ( countersize ) //<S2SV> memset ( newinfo -> counters , 0 , countersize ) ; //<S2SV> newinfo -> entries = vmalloc ( tmp . entries_size ) ; //<S2SV> if ( ! newinfo -> entries ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto free_newinfo ; //<S2SV> } //<S2SV> if ( copy_from_user ( //<S2SV> newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { //<S2SV> BUGPRINT ( "Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n" ) ; //<S2SV> ret = - EFAULT ; //<S2SV> goto free_entries ; //<S2SV> } //<S2SV> ret = do_replace_finish ( net , & tmp , newinfo ) ; //<S2SV> if ( ret == 0 ) //<S2SV> return ret ; //<S2SV> free_entries : //<S2SV> vfree ( newinfo -> entries ) ; //<S2SV> free_newinfo : //<S2SV> vfree ( newinfo ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 