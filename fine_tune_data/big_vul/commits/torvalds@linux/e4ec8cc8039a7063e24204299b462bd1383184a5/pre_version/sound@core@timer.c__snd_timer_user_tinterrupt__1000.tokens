static void snd_timer_user_tinterrupt ( struct snd_timer_instance * timeri , //<S2SV> unsigned long resolution , //<S2SV> unsigned long ticks ) //<S2SV> { //<S2SV> struct snd_timer_user * tu = timeri -> callback_data ; //<S2SV> struct snd_timer_tread * r , r1 ; //<S2SV> struct timespec tstamp ; //<S2SV> int prev , append = 0 ; //<S2SV> memset ( & tstamp , 0 , sizeof ( tstamp ) ) ; //<S2SV> spin_lock ( & tu -> qlock ) ; //<S2SV> if ( ( tu -> filter & ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_TICK ) ) ) == 0 ) { //<S2SV> spin_unlock ( & tu -> qlock ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( tu -> last_resolution != resolution || ticks > 0 ) { //<S2SV> if ( timer_tstamp_monotonic ) //<S2SV> ktime_get_ts ( & tstamp ) ; //<S2SV> else //<S2SV> getnstimeofday ( & tstamp ) ; //<S2SV> } //<S2SV> if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) ) && //<S2SV> tu -> last_resolution != resolution ) { //<S2SV> r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ; //<S2SV> r1 . tstamp = tstamp ; //<S2SV> r1 . val = resolution ; //<S2SV> snd_timer_user_append_to_tqueue ( tu , & r1 ) ; //<S2SV> tu -> last_resolution = resolution ; //<S2SV> append ++ ; //<S2SV> } //<S2SV> if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_TICK ) ) == 0 ) //<S2SV> goto __wake ; //<S2SV> if ( ticks == 0 ) //<S2SV> goto __wake ; //<S2SV> if ( tu -> qused > 0 ) { //<S2SV> prev = tu -> qtail == 0 ? tu -> queue_size - 1 : tu -> qtail - 1 ; //<S2SV> r = & tu -> tqueue [ prev ] ; //<S2SV> if ( r -> event == SNDRV_TIMER_EVENT_TICK ) { //<S2SV> r -> tstamp = tstamp ; //<S2SV> r -> val += ticks ; //<S2SV> append ++ ; //<S2SV> goto __wake ; //<S2SV> } //<S2SV> } //<S2SV> r1 . event = SNDRV_TIMER_EVENT_TICK ; //<S2SV> r1 . tstamp = tstamp ; //<S2SV> r1 . val = ticks ; //<S2SV> snd_timer_user_append_to_tqueue ( tu , & r1 ) ; //<S2SV> append ++ ; //<S2SV> __wake : //<S2SV> spin_unlock ( & tu -> qlock ) ; //<S2SV> if ( append == 0 ) //<S2SV> return ; //<S2SV> kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; //<S2SV> wake_up ( & tu -> qchange_sleep ) ; //<S2SV> } //<S2SV> 