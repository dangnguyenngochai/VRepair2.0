static long vop_ioctl ( struct file * f , unsigned int cmd , unsigned long arg ) //<S2SV> { //<S2SV> struct vop_vdev * vdev = f -> private_data ; //<S2SV> struct vop_info * vi = vdev -> vi ; //<S2SV> void __user * argp = ( void __user * ) arg ; //<S2SV> int ret ; //<S2SV> switch ( cmd ) { //<S2SV> case MIC_VIRTIO_ADD_DEVICE : //<S2SV> { //<S2SV> struct mic_device_desc dd , * dd_config ; //<S2SV> if ( copy_from_user ( & dd , argp , sizeof ( dd ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( mic_aligned_desc_size ( & dd ) > MIC_MAX_DESC_BLK_SIZE || //<S2SV> dd . num_vq > MIC_MAX_VRINGS ) //<S2SV> return - EINVAL ; //<S2SV> dd_config = kzalloc ( mic_desc_size ( & dd ) , GFP_KERNEL ) ; //<S2SV> if ( ! dd_config ) //<S2SV> return - ENOMEM ; //<S2SV> if ( copy_from_user ( dd_config , argp , mic_desc_size ( & dd ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto free_ret ; //<S2SV> } //<S2SV> if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto free_ret ; //<S2SV> } //<S2SV> mutex_lock ( & vdev -> vdev_mutex ) ; //<S2SV> mutex_lock ( & vi -> vop_mutex ) ; //<S2SV> ret = vop_virtio_add_device ( vdev , dd_config ) ; //<S2SV> if ( ret ) //<S2SV> goto unlock_ret ; //<S2SV> list_add_tail ( & vdev -> list , & vi -> vdev_list ) ; //<S2SV> unlock_ret : //<S2SV> mutex_unlock ( & vi -> vop_mutex ) ; //<S2SV> mutex_unlock ( & vdev -> vdev_mutex ) ; //<S2SV> free_ret : //<S2SV> kfree ( dd_config ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> case MIC_VIRTIO_COPY_DESC : //<S2SV> { //<S2SV> struct mic_copy_desc copy ; //<S2SV> mutex_lock ( & vdev -> vdev_mutex ) ; //<S2SV> ret = vop_vdev_inited ( vdev ) ; //<S2SV> if ( ret ) //<S2SV> goto _unlock_ret ; //<S2SV> if ( copy_from_user ( & copy , argp , sizeof ( copy ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto _unlock_ret ; //<S2SV> } //<S2SV> ret = vop_virtio_copy_desc ( vdev , & copy ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto _unlock_ret ; //<S2SV> if ( copy_to_user ( //<S2SV> & ( ( struct mic_copy_desc __user * ) argp ) -> out_len , //<S2SV> & copy . out_len , sizeof ( copy . out_len ) ) ) //<S2SV> ret = - EFAULT ; //<S2SV> _unlock_ret : //<S2SV> mutex_unlock ( & vdev -> vdev_mutex ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> case MIC_VIRTIO_CONFIG_CHANGE : //<S2SV> { //<S2SV> void * buf ; //<S2SV> mutex_lock ( & vdev -> vdev_mutex ) ; //<S2SV> ret = vop_vdev_inited ( vdev ) ; //<S2SV> if ( ret ) //<S2SV> goto __unlock_ret ; //<S2SV> buf = kzalloc ( vdev -> dd -> config_len , GFP_KERNEL ) ; //<S2SV> if ( ! buf ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto __unlock_ret ; //<S2SV> } //<S2SV> if ( copy_from_user ( buf , argp , vdev -> dd -> config_len ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto done ; //<S2SV> } //<S2SV> ret = vop_virtio_config_change ( vdev , buf ) ; //<S2SV> done : //<S2SV> kfree ( buf ) ; //<S2SV> __unlock_ret : //<S2SV> mutex_unlock ( & vdev -> vdev_mutex ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> default : //<S2SV> return - ENOIOCTLCMD ; //<S2SV> } ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 