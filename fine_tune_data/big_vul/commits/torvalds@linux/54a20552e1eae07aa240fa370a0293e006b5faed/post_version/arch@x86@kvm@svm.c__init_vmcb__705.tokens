static void init_vmcb ( struct vcpu_svm * svm ) //<S2SV> { //<S2SV> struct vmcb_control_area * control = & svm -> vmcb -> control ; //<S2SV> struct vmcb_save_area * save = & svm -> vmcb -> save ; //<S2SV> svm -> vcpu . fpu_active = 1 ; //<S2SV> svm -> vcpu . arch . hflags = 0 ; //<S2SV> set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; //<S2SV> set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; //<S2SV> set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; //<S2SV> set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; //<S2SV> set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; //<S2SV> set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; //<S2SV> set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; //<S2SV> set_dr_intercepts ( svm ) ; //<S2SV> set_exception_intercept ( svm , PF_VECTOR ) ; //<S2SV> set_exception_intercept ( svm , UD_VECTOR ) ; //<S2SV> set_exception_intercept ( svm , MC_VECTOR ) ; //<S2SV> set_exception_intercept ( svm , AC_VECTOR ) ; //<S2SV> set_intercept ( svm , INTERCEPT_INTR ) ; //<S2SV> set_intercept ( svm , INTERCEPT_NMI ) ; //<S2SV> set_intercept ( svm , INTERCEPT_SMI ) ; //<S2SV> set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; //<S2SV> set_intercept ( svm , INTERCEPT_RDPMC ) ; //<S2SV> set_intercept ( svm , INTERCEPT_CPUID ) ; //<S2SV> set_intercept ( svm , INTERCEPT_INVD ) ; //<S2SV> set_intercept ( svm , INTERCEPT_HLT ) ; //<S2SV> set_intercept ( svm , INTERCEPT_INVLPG ) ; //<S2SV> set_intercept ( svm , INTERCEPT_INVLPGA ) ; //<S2SV> set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; //<S2SV> set_intercept ( svm , INTERCEPT_MSR_PROT ) ; //<S2SV> set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; //<S2SV> set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; //<S2SV> set_intercept ( svm , INTERCEPT_VMRUN ) ; //<S2SV> set_intercept ( svm , INTERCEPT_VMMCALL ) ; //<S2SV> set_intercept ( svm , INTERCEPT_VMLOAD ) ; //<S2SV> set_intercept ( svm , INTERCEPT_VMSAVE ) ; //<S2SV> set_intercept ( svm , INTERCEPT_STGI ) ; //<S2SV> set_intercept ( svm , INTERCEPT_CLGI ) ; //<S2SV> set_intercept ( svm , INTERCEPT_SKINIT ) ; //<S2SV> set_intercept ( svm , INTERCEPT_WBINVD ) ; //<S2SV> set_intercept ( svm , INTERCEPT_MONITOR ) ; //<S2SV> set_intercept ( svm , INTERCEPT_MWAIT ) ; //<S2SV> set_intercept ( svm , INTERCEPT_XSETBV ) ; //<S2SV> control -> iopm_base_pa = iopm_base ; //<S2SV> control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; //<S2SV> control -> int_ctl = V_INTR_MASKING_MASK ; //<S2SV> init_seg ( & save -> es ) ; //<S2SV> init_seg ( & save -> ss ) ; //<S2SV> init_seg ( & save -> ds ) ; //<S2SV> init_seg ( & save -> fs ) ; //<S2SV> init_seg ( & save -> gs ) ; //<S2SV> save -> cs . selector = 0xf000 ; //<S2SV> save -> cs . base = 0xffff0000 ; //<S2SV> save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | //<S2SV> SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; //<S2SV> save -> cs . limit = 0xffff ; //<S2SV> save -> gdtr . limit = 0xffff ; //<S2SV> save -> idtr . limit = 0xffff ; //<S2SV> init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; //<S2SV> init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; //<S2SV> svm_set_efer ( & svm -> vcpu , 0 ) ; //<S2SV> save -> dr6 = 0xffff0ff0 ; //<S2SV> kvm_set_rflags ( & svm -> vcpu , 2 ) ; //<S2SV> save -> rip = 0x0000fff0 ; //<S2SV> svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; //<S2SV> svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; //<S2SV> kvm_mmu_reset_context ( & svm -> vcpu ) ; //<S2SV> save -> cr4 = X86_CR4_PAE ; //<S2SV> if ( npt_enabled ) { //<S2SV> control -> nested_ctl = 1 ; //<S2SV> clr_intercept ( svm , INTERCEPT_INVLPG ) ; //<S2SV> clr_exception_intercept ( svm , PF_VECTOR ) ; //<S2SV> clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; //<S2SV> clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; //<S2SV> save -> g_pat = svm -> vcpu . arch . pat ; //<S2SV> save -> cr3 = 0 ; //<S2SV> save -> cr4 = 0 ; //<S2SV> } //<S2SV> svm -> asid_generation = 0 ; //<S2SV> svm -> nested . vmcb = 0 ; //<S2SV> svm -> vcpu . arch . hflags = 0 ; //<S2SV> if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { //<S2SV> control -> pause_filter_count = 3000 ; //<S2SV> set_intercept ( svm , INTERCEPT_PAUSE ) ; //<S2SV> } //<S2SV> mark_all_dirty ( svm -> vmcb ) ; //<S2SV> enable_gif ( svm ) ; //<S2SV> } //<S2SV> 