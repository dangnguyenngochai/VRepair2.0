static void audit_log_execve_info ( struct audit_context * context , //<S2SV> struct audit_buffer * * ab ) //<S2SV> { //<S2SV> int i , len ; //<S2SV> size_t len_sent = 0 ; //<S2SV> const char __user * p ; //<S2SV> char * buf ; //<S2SV> p = ( const char __user * ) current -> mm -> arg_start ; //<S2SV> audit_log_format ( * ab , "argc=%d" , context -> execve . argc ) ; //<S2SV> buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; //<S2SV> if ( ! buf ) { //<S2SV> audit_panic ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> for ( i = 0 ; i < context -> execve . argc ; i ++ ) { //<S2SV> len = audit_log_single_execve_arg ( context , ab , i , //<S2SV> & len_sent , p , buf ) ; //<S2SV> if ( len <= 0 ) //<S2SV> break ; //<S2SV> p += len ; //<S2SV> } //<S2SV> kfree ( buf ) ; //<S2SV> } //<S2SV> 