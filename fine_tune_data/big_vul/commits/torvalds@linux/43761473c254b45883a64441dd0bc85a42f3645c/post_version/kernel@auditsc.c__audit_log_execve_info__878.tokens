static void audit_log_execve_info ( struct audit_context * context , //<S2SV> struct audit_buffer * * ab ) //<S2SV> { //<S2SV> long len_max ; //<S2SV> long len_rem ; //<S2SV> long len_full ; //<S2SV> long len_buf ; //<S2SV> long len_abuf ; //<S2SV> long len_tmp ; //<S2SV> bool require_data ; //<S2SV> bool encode ; //<S2SV> unsigned int iter ; //<S2SV> unsigned int arg ; //<S2SV> char * buf_head ; //<S2SV> char * buf ; //<S2SV> const char __user * p = ( const char __user * ) current -> mm -> arg_start ; //<S2SV> char abuf [ 96 ] ; //<S2SV> WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; //<S2SV> len_max = MAX_EXECVE_AUDIT_LEN ; //<S2SV> buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; //<S2SV> if ( ! buf_head ) { //<S2SV> audit_panic ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> buf = buf_head ; //<S2SV> audit_log_format ( * ab , "argc=%d" , context -> execve . argc ) ; //<S2SV> len_rem = len_max ; //<S2SV> len_buf = 0 ; //<S2SV> len_full = 0 ; //<S2SV> require_data = true ; //<S2SV> encode = false ; //<S2SV> iter = 0 ; //<S2SV> arg = 0 ; //<S2SV> do { //<S2SV> if ( len_full == 0 ) //<S2SV> len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; //<S2SV> if ( require_data ) { //<S2SV> if ( buf != buf_head ) { //<S2SV> memmove ( buf_head , buf , len_buf ) ; //<S2SV> buf = buf_head ; //<S2SV> } //<S2SV> len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , //<S2SV> len_max - len_buf ) ; //<S2SV> if ( len_tmp == - EFAULT ) { //<S2SV> send_sig ( SIGKILL , current , 0 ) ; //<S2SV> goto out ; //<S2SV> } else if ( len_tmp == ( len_max - len_buf ) ) { //<S2SV> require_data = true ; //<S2SV> encode = true ; //<S2SV> len_full = len_full * 2 ; //<S2SV> p += len_tmp ; //<S2SV> } else { //<S2SV> require_data = false ; //<S2SV> if ( ! encode ) //<S2SV> encode = audit_string_contains_control ( //<S2SV> buf , len_tmp ) ; //<S2SV> if ( len_full < len_max ) //<S2SV> len_full = ( encode ? //<S2SV> len_tmp * 2 : len_tmp ) ; //<S2SV> p += len_tmp + 1 ; //<S2SV> } //<S2SV> len_buf += len_tmp ; //<S2SV> buf_head [ len_buf ] = '\\0' ; //<S2SV> len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; //<S2SV> } //<S2SV> if ( len_buf > 0 ) { //<S2SV> if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { //<S2SV> len_rem = len_max ; //<S2SV> audit_log_end ( * ab ) ; //<S2SV> * ab = audit_log_start ( context , //<S2SV> GFP_KERNEL , AUDIT_EXECVE ) ; //<S2SV> if ( ! * ab ) //<S2SV> goto out ; //<S2SV> } //<S2SV> len_tmp = 0 ; //<S2SV> if ( require_data || ( iter > 0 ) || //<S2SV> ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { //<S2SV> if ( iter == 0 ) { //<S2SV> len_tmp += snprintf ( & abuf [ len_tmp ] , //<S2SV> sizeof ( abuf ) - len_tmp , //<S2SV> "<S2SV_blank>a%d_len=%lu" , //<S2SV> arg , len_full ) ; //<S2SV> } //<S2SV> len_tmp += snprintf ( & abuf [ len_tmp ] , //<S2SV> sizeof ( abuf ) - len_tmp , //<S2SV> "<S2SV_blank>a%d[%d]=" , arg , iter ++ ) ; //<S2SV> } else //<S2SV> len_tmp += snprintf ( & abuf [ len_tmp ] , //<S2SV> sizeof ( abuf ) - len_tmp , //<S2SV> "<S2SV_blank>a%d=" , arg ) ; //<S2SV> WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; //<S2SV> abuf [ sizeof ( abuf ) - 1 ] = '\\0' ; //<S2SV> audit_log_format ( * ab , "%s" , abuf ) ; //<S2SV> len_rem -= len_tmp ; //<S2SV> len_tmp = len_buf ; //<S2SV> if ( encode ) { //<S2SV> if ( len_abuf > len_rem ) //<S2SV> len_tmp = len_rem / 2 ; //<S2SV> audit_log_n_hex ( * ab , buf , len_tmp ) ; //<S2SV> len_rem -= len_tmp * 2 ; //<S2SV> len_abuf -= len_tmp * 2 ; //<S2SV> } else { //<S2SV> if ( len_abuf > len_rem ) //<S2SV> len_tmp = len_rem - 2 ; //<S2SV> audit_log_n_string ( * ab , buf , len_tmp ) ; //<S2SV> len_rem -= len_tmp + 2 ; //<S2SV> len_abuf -= len_tmp ; //<S2SV> } //<S2SV> len_buf -= len_tmp ; //<S2SV> buf += len_tmp ; //<S2SV> } //<S2SV> if ( ( len_buf == 0 ) && ! require_data ) { //<S2SV> arg ++ ; //<S2SV> iter = 0 ; //<S2SV> len_full = 0 ; //<S2SV> require_data = true ; //<S2SV> encode = false ; //<S2SV> } //<S2SV> } while ( arg < context -> execve . argc ) ; //<S2SV> out : //<S2SV> kfree ( buf_head ) ; //<S2SV> } //<S2SV> 