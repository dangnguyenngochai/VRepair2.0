struct sk_buff * __skb_recv_datagram ( struct sock * sk , unsigned int flags , //<S2SV> int * peeked , int * off , int * err ) //<S2SV> { //<S2SV> struct sk_buff * skb ; //<S2SV> long timeo ; //<S2SV> int error = sock_error ( sk ) ; //<S2SV> if ( error ) //<S2SV> goto no_packet ; //<S2SV> timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; //<S2SV> do { //<S2SV> unsigned long cpu_flags ; //<S2SV> struct sk_buff_head * queue = & sk -> sk_receive_queue ; //<S2SV> spin_lock_irqsave ( & queue -> lock , cpu_flags ) ; //<S2SV> skb_queue_walk ( queue , skb ) { //<S2SV> * peeked = skb -> peeked ; //<S2SV> if ( flags & MSG_PEEK ) { //<S2SV> if ( * off >= skb -> len && skb -> len ) { //<S2SV> * off -= skb -> len ; //<S2SV> continue ; //<S2SV> } //<S2SV> skb -> peeked = 1 ; //<S2SV> atomic_inc ( & skb -> users ) ; //<S2SV> } else //<S2SV> __skb_unlink ( skb , queue ) ; //<S2SV> spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; //<S2SV> return skb ; //<S2SV> } //<S2SV> spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; //<S2SV> error = - EAGAIN ; //<S2SV> if ( ! timeo ) //<S2SV> goto no_packet ; //<S2SV> } while ( ! wait_for_packet ( sk , err , & timeo ) ) ; //<S2SV> return NULL ; //<S2SV> no_packet : //<S2SV> * err = error ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 