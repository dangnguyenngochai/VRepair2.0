int snd_usbmidi_create ( struct snd_card * card , //<S2SV> struct usb_interface * iface , //<S2SV> struct list_head * midi_list , //<S2SV> const struct snd_usb_audio_quirk * quirk ) //<S2SV> { //<S2SV> struct snd_usb_midi * umidi ; //<S2SV> struct snd_usb_midi_endpoint_info endpoints [ MIDI_MAX_ENDPOINTS ] ; //<S2SV> int out_ports , in_ports ; //<S2SV> int i , err ; //<S2SV> umidi = kzalloc ( sizeof ( * umidi ) , GFP_KERNEL ) ; //<S2SV> if ( ! umidi ) //<S2SV> return - ENOMEM ; //<S2SV> umidi -> dev = interface_to_usbdev ( iface ) ; //<S2SV> umidi -> card = card ; //<S2SV> umidi -> iface = iface ; //<S2SV> umidi -> quirk = quirk ; //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_standard_ops ; //<S2SV> spin_lock_init ( & umidi -> disc_lock ) ; //<S2SV> init_rwsem ( & umidi -> disc_rwsem ) ; //<S2SV> mutex_init ( & umidi -> mutex ) ; //<S2SV> umidi -> usb_id = USB_ID ( le16_to_cpu ( umidi -> dev -> descriptor . idVendor ) , //<S2SV> le16_to_cpu ( umidi -> dev -> descriptor . idProduct ) ) ; //<S2SV> setup_timer ( & umidi -> error_timer , snd_usbmidi_error_timer , //<S2SV> ( unsigned long ) umidi ) ; //<S2SV> memset ( endpoints , 0 , sizeof ( endpoints ) ) ; //<S2SV> switch ( quirk ? quirk -> type : QUIRK_MIDI_STANDARD_INTERFACE ) { //<S2SV> case QUIRK_MIDI_STANDARD_INTERFACE : //<S2SV> err = snd_usbmidi_get_ms_info ( umidi , endpoints ) ; //<S2SV> if ( umidi -> usb_id == USB_ID ( 0x0763 , 0x0150 ) ) //<S2SV> umidi -> usb_protocol_ops = //<S2SV> & snd_usbmidi_maudio_broken_running_status_ops ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_US122L : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_122l_ops ; //<S2SV> case QUIRK_MIDI_FIXED_ENDPOINT : //<S2SV> memcpy ( & endpoints [ 0 ] , quirk -> data , //<S2SV> sizeof ( struct snd_usb_midi_endpoint_info ) ) ; //<S2SV> err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_YAMAHA : //<S2SV> err = snd_usbmidi_detect_yamaha ( umidi , & endpoints [ 0 ] ) ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_ROLAND : //<S2SV> err = snd_usbmidi_detect_roland ( umidi , & endpoints [ 0 ] ) ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_MIDIMAN : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_midiman_ops ; //<S2SV> memcpy ( & endpoints [ 0 ] , quirk -> data , //<S2SV> sizeof ( struct snd_usb_midi_endpoint_info ) ) ; //<S2SV> err = 0 ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_NOVATION : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_novation_ops ; //<S2SV> err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_RAW_BYTES : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_raw_ops ; //<S2SV> if ( umidi -> usb_id == USB_ID ( 0x07fd , 0x0001 ) ) //<S2SV> usb_set_interface ( umidi -> dev , 0 , 0 ) ; //<S2SV> err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_EMAGIC : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_emagic_ops ; //<S2SV> memcpy ( & endpoints [ 0 ] , quirk -> data , //<S2SV> sizeof ( struct snd_usb_midi_endpoint_info ) ) ; //<S2SV> err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_CME : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_cme_ops ; //<S2SV> err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_AKAI : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_akai_ops ; //<S2SV> err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; //<S2SV> endpoints [ 1 ] . out_cables = 0 ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_FTDI : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_ftdi_ops ; //<S2SV> err = usb_control_msg ( umidi -> dev , usb_sndctrlpipe ( umidi -> dev , 0 ) , //<S2SV> 3 , 0x40 , 0x60 , 0 , NULL , 0 , 1000 ) ; //<S2SV> if ( err < 0 ) //<S2SV> break ; //<S2SV> err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; //<S2SV> break ; //<S2SV> case QUIRK_MIDI_CH345 : //<S2SV> umidi -> usb_protocol_ops = & snd_usbmidi_ch345_broken_sysex_ops ; //<S2SV> err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> dev_err ( & umidi -> dev -> dev , "invalid<S2SV_blank>quirk<S2SV_blank>type<S2SV_blank>%d\\n" , //<S2SV> quirk -> type ) ; //<S2SV> err = - ENXIO ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( err < 0 ) { //<S2SV> kfree ( umidi ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> out_ports = 0 ; //<S2SV> in_ports = 0 ; //<S2SV> for ( i = 0 ; i < MIDI_MAX_ENDPOINTS ; ++ i ) { //<S2SV> out_ports += hweight16 ( endpoints [ i ] . out_cables ) ; //<S2SV> in_ports += hweight16 ( endpoints [ i ] . in_cables ) ; //<S2SV> } //<S2SV> err = snd_usbmidi_create_rawmidi ( umidi , out_ports , in_ports ) ; //<S2SV> if ( err < 0 ) { //<S2SV> kfree ( umidi ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> if ( quirk && quirk -> type == QUIRK_MIDI_MIDIMAN ) //<S2SV> err = snd_usbmidi_create_endpoints_midiman ( umidi , & endpoints [ 0 ] ) ; //<S2SV> else //<S2SV> err = snd_usbmidi_create_endpoints ( umidi , endpoints ) ; //<S2SV> if ( err < 0 ) { //<S2SV> snd_usbmidi_free ( umidi ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> usb_autopm_get_interface_no_resume ( umidi -> iface ) ; //<S2SV> list_add_tail ( & umidi -> list , midi_list ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 