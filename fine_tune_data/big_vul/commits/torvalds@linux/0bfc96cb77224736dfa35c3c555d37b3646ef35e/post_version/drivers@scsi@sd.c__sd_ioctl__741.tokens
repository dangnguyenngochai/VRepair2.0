static int sd_ioctl ( struct block_device * bdev , fmode_t mode , //<S2SV> unsigned int cmd , unsigned long arg ) //<S2SV> { //<S2SV> struct gendisk * disk = bdev -> bd_disk ; //<S2SV> struct scsi_disk * sdkp = scsi_disk ( disk ) ; //<S2SV> struct scsi_device * sdp = sdkp -> device ; //<S2SV> void __user * p = ( void __user * ) arg ; //<S2SV> int error ; //<S2SV> SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , "sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>" //<S2SV> "cmd=0x%x\\n" , disk -> disk_name , cmd ) ) ; //<S2SV> error = scsi_verify_blk_ioctl ( bdev , cmd ) ; //<S2SV> if ( error < 0 ) //<S2SV> return error ; //<S2SV> error = scsi_nonblockable_ioctl ( sdp , cmd , p , //<S2SV> ( mode & FMODE_NDELAY ) != 0 ) ; //<S2SV> if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) //<S2SV> goto out ; //<S2SV> switch ( cmd ) { //<S2SV> case SCSI_IOCTL_GET_IDLUN : //<S2SV> case SCSI_IOCTL_GET_BUS_NUMBER : //<S2SV> error = scsi_ioctl ( sdp , cmd , p ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; //<S2SV> if ( error != - ENOTTY ) //<S2SV> break ; //<S2SV> error = scsi_ioctl ( sdp , cmd , p ) ; //<S2SV> break ; //<S2SV> } //<S2SV> out : //<S2SV> return error ; //<S2SV> } //<S2SV> 