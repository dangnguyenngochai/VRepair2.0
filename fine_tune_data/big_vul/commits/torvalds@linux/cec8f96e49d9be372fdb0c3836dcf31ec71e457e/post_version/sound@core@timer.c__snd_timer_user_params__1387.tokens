static int snd_timer_user_params ( struct file * file , //<S2SV> struct snd_timer_params __user * _params ) //<S2SV> { //<S2SV> struct snd_timer_user * tu ; //<S2SV> struct snd_timer_params params ; //<S2SV> struct snd_timer * t ; //<S2SV> struct snd_timer_read * tr ; //<S2SV> struct snd_timer_tread * ttr ; //<S2SV> int err ; //<S2SV> tu = file -> private_data ; //<S2SV> if ( ! tu -> timeri ) //<S2SV> return - EBADFD ; //<S2SV> t = tu -> timeri -> timer ; //<S2SV> if ( ! t ) //<S2SV> return - EBADFD ; //<S2SV> if ( copy_from_user ( & params , _params , sizeof ( params ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( ! ( t -> hw . flags & SNDRV_TIMER_HW_SLAVE ) && params . ticks < 1 ) { //<S2SV> err = - EINVAL ; //<S2SV> goto _end ; //<S2SV> } //<S2SV> if ( params . queue_size > 0 && //<S2SV> ( params . queue_size < 32 || params . queue_size > 1024 ) ) { //<S2SV> err = - EINVAL ; //<S2SV> goto _end ; //<S2SV> } //<S2SV> if ( params . filter & ~ ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_TICK ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_START ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_STOP ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_CONTINUE ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_PAUSE ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_SUSPEND ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_RESUME ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_MSTART ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_MSTOP ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_MCONTINUE ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_MPAUSE ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_MSUSPEND ) | //<S2SV> ( 1 << SNDRV_TIMER_EVENT_MRESUME ) ) ) { //<S2SV> err = - EINVAL ; //<S2SV> goto _end ; //<S2SV> } //<S2SV> snd_timer_stop ( tu -> timeri ) ; //<S2SV> spin_lock_irq ( & t -> lock ) ; //<S2SV> tu -> timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_AUTO | //<S2SV> SNDRV_TIMER_IFLG_EXCLUSIVE | //<S2SV> SNDRV_TIMER_IFLG_EARLY_EVENT ) ; //<S2SV> if ( params . flags & SNDRV_TIMER_PSFLG_AUTO ) //<S2SV> tu -> timeri -> flags |= SNDRV_TIMER_IFLG_AUTO ; //<S2SV> if ( params . flags & SNDRV_TIMER_PSFLG_EXCLUSIVE ) //<S2SV> tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EXCLUSIVE ; //<S2SV> if ( params . flags & SNDRV_TIMER_PSFLG_EARLY_EVENT ) //<S2SV> tu -> timeri -> flags |= SNDRV_TIMER_IFLG_EARLY_EVENT ; //<S2SV> spin_unlock_irq ( & t -> lock ) ; //<S2SV> if ( params . queue_size > 0 && //<S2SV> ( unsigned int ) tu -> queue_size != params . queue_size ) { //<S2SV> if ( tu -> tread ) { //<S2SV> ttr = kmalloc ( params . queue_size * sizeof ( * ttr ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ttr ) { //<S2SV> kfree ( tu -> tqueue ) ; //<S2SV> tu -> queue_size = params . queue_size ; //<S2SV> tu -> tqueue = ttr ; //<S2SV> } //<S2SV> } else { //<S2SV> tr = kmalloc ( params . queue_size * sizeof ( * tr ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( tr ) { //<S2SV> kfree ( tu -> queue ) ; //<S2SV> tu -> queue_size = params . queue_size ; //<S2SV> tu -> queue = tr ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> tu -> qhead = tu -> qtail = tu -> qused = 0 ; //<S2SV> if ( tu -> timeri -> flags & SNDRV_TIMER_IFLG_EARLY_EVENT ) { //<S2SV> if ( tu -> tread ) { //<S2SV> struct snd_timer_tread tread ; //<S2SV> memset ( & tread , 0 , sizeof ( tread ) ) ; //<S2SV> tread . event = SNDRV_TIMER_EVENT_EARLY ; //<S2SV> tread . tstamp . tv_sec = 0 ; //<S2SV> tread . tstamp . tv_nsec = 0 ; //<S2SV> tread . val = 0 ; //<S2SV> snd_timer_user_append_to_tqueue ( tu , & tread ) ; //<S2SV> } else { //<S2SV> struct snd_timer_read * r = & tu -> queue [ 0 ] ; //<S2SV> r -> resolution = 0 ; //<S2SV> r -> ticks = 0 ; //<S2SV> tu -> qused ++ ; //<S2SV> tu -> qtail ++ ; //<S2SV> } //<S2SV> } //<S2SV> tu -> filter = params . filter ; //<S2SV> tu -> ticks = params . ticks ; //<S2SV> err = 0 ; //<S2SV> _end : //<S2SV> if ( copy_to_user ( _params , & params , sizeof ( params ) ) ) //<S2SV> return - EFAULT ; //<S2SV> return err ; //<S2SV> } //<S2SV> 