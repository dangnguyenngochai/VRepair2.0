static int rt_fill_info ( struct net * net , __be32 dst , __be32 src , //<S2SV> struct flowi4 * fl4 , struct sk_buff * skb , u32 portid , //<S2SV> u32 seq , int event , int nowait , unsigned int flags ) //<S2SV> { //<S2SV> struct rtable * rt = skb_rtable ( skb ) ; //<S2SV> struct rtmsg * r ; //<S2SV> struct nlmsghdr * nlh ; //<S2SV> unsigned long expires = 0 ; //<S2SV> u32 error ; //<S2SV> u32 metrics [ RTAX_MAX ] ; //<S2SV> nlh = nlmsg_put ( skb , portid , seq , event , sizeof ( * r ) , flags ) ; //<S2SV> if ( nlh == NULL ) //<S2SV> return - EMSGSIZE ; //<S2SV> r = nlmsg_data ( nlh ) ; //<S2SV> r -> rtm_family = AF_INET ; //<S2SV> r -> rtm_dst_len = 32 ; //<S2SV> r -> rtm_src_len = 0 ; //<S2SV> r -> rtm_tos = fl4 -> flowi4_tos ; //<S2SV> r -> rtm_table = RT_TABLE_MAIN ; //<S2SV> if ( nla_put_u32 ( skb , RTA_TABLE , RT_TABLE_MAIN ) ) //<S2SV> goto nla_put_failure ; //<S2SV> r -> rtm_type = rt -> rt_type ; //<S2SV> r -> rtm_scope = RT_SCOPE_UNIVERSE ; //<S2SV> r -> rtm_protocol = RTPROT_UNSPEC ; //<S2SV> r -> rtm_flags = ( rt -> rt_flags & ~ 0xFFFF ) | RTM_F_CLONED ; //<S2SV> if ( rt -> rt_flags & RTCF_NOTIFY ) //<S2SV> r -> rtm_flags |= RTM_F_NOTIFY ; //<S2SV> if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) //<S2SV> r -> rtm_flags |= RTCF_DOREDIRECT ; //<S2SV> if ( nla_put_be32 ( skb , RTA_DST , dst ) ) //<S2SV> goto nla_put_failure ; //<S2SV> if ( src ) { //<S2SV> r -> rtm_src_len = 32 ; //<S2SV> if ( nla_put_be32 ( skb , RTA_SRC , src ) ) //<S2SV> goto nla_put_failure ; //<S2SV> } //<S2SV> if ( rt -> dst . dev && //<S2SV> nla_put_u32 ( skb , RTA_OIF , rt -> dst . dev -> ifindex ) ) //<S2SV> goto nla_put_failure ; //<S2SV> # ifdef CONFIG_IP_ROUTE_CLASSID //<S2SV> if ( rt -> dst . tclassid && //<S2SV> nla_put_u32 ( skb , RTA_FLOW , rt -> dst . tclassid ) ) //<S2SV> goto nla_put_failure ; //<S2SV> # endif //<S2SV> if ( ! rt_is_input_route ( rt ) && //<S2SV> fl4 -> saddr != src ) { //<S2SV> if ( nla_put_be32 ( skb , RTA_PREFSRC , fl4 -> saddr ) ) //<S2SV> goto nla_put_failure ; //<S2SV> } //<S2SV> if ( rt -> rt_uses_gateway && //<S2SV> nla_put_be32 ( skb , RTA_GATEWAY , rt -> rt_gateway ) ) //<S2SV> goto nla_put_failure ; //<S2SV> expires = rt -> dst . expires ; //<S2SV> if ( expires ) { //<S2SV> unsigned long now = jiffies ; //<S2SV> if ( time_before ( now , expires ) ) //<S2SV> expires -= now ; //<S2SV> else //<S2SV> expires = 0 ; //<S2SV> } //<S2SV> memcpy ( metrics , dst_metrics_ptr ( & rt -> dst ) , sizeof ( metrics ) ) ; //<S2SV> if ( rt -> rt_pmtu && expires ) //<S2SV> metrics [ RTAX_MTU - 1 ] = rt -> rt_pmtu ; //<S2SV> if ( rtnetlink_put_metrics ( skb , metrics ) < 0 ) //<S2SV> goto nla_put_failure ; //<S2SV> if ( fl4 -> flowi4_mark && //<S2SV> nla_put_u32 ( skb , RTA_MARK , fl4 -> flowi4_mark ) ) //<S2SV> goto nla_put_failure ; //<S2SV> error = rt -> dst . error ; //<S2SV> if ( rt_is_input_route ( rt ) ) { //<S2SV> # ifdef CONFIG_IP_MROUTE //<S2SV> if ( ipv4_is_multicast ( dst ) && ! ipv4_is_local_multicast ( dst ) && //<S2SV> IPV4_DEVCONF_ALL ( net , MC_FORWARDING ) ) { //<S2SV> int err = ipmr_get_route ( net , skb , //<S2SV> fl4 -> saddr , fl4 -> daddr , //<S2SV> r , nowait ) ; //<S2SV> if ( err <= 0 ) { //<S2SV> if ( ! nowait ) { //<S2SV> if ( err == 0 ) //<S2SV> return 0 ; //<S2SV> goto nla_put_failure ; //<S2SV> } else { //<S2SV> if ( err == - EMSGSIZE ) //<S2SV> goto nla_put_failure ; //<S2SV> error = err ; //<S2SV> } //<S2SV> } //<S2SV> } else //<S2SV> # endif //<S2SV> if ( nla_put_u32 ( skb , RTA_IIF , skb -> dev -> ifindex ) ) //<S2SV> goto nla_put_failure ; //<S2SV> } //<S2SV> if ( rtnl_put_cacheinfo ( skb , & rt -> dst , 0 , expires , error ) < 0 ) //<S2SV> goto nla_put_failure ; //<S2SV> return nlmsg_end ( skb , nlh ) ; //<S2SV> nla_put_failure : //<S2SV> nlmsg_cancel ( skb , nlh ) ; //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> 