static int __mkroute_input ( struct sk_buff * skb , //<S2SV> const struct fib_result * res , //<S2SV> struct in_device * in_dev , //<S2SV> __be32 daddr , __be32 saddr , u32 tos ) //<S2SV> { //<S2SV> struct fib_nh_exception * fnhe ; //<S2SV> struct rtable * rth ; //<S2SV> int err ; //<S2SV> struct in_device * out_dev ; //<S2SV> unsigned int flags = 0 ; //<S2SV> bool do_cache ; //<S2SV> u32 itag = 0 ; //<S2SV> out_dev = __in_dev_get_rcu ( FIB_RES_DEV ( * res ) ) ; //<S2SV> if ( out_dev == NULL ) { //<S2SV> net_crit_ratelimited ( "Bug<S2SV_blank>in<S2SV_blank>ip_route_input_slow().<S2SV_blank>Please<S2SV_blank>report.\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = fib_validate_source ( skb , saddr , daddr , tos , FIB_RES_OIF ( * res ) , //<S2SV> in_dev -> dev , in_dev , & itag ) ; //<S2SV> if ( err < 0 ) { //<S2SV> ip_handle_martian_source ( in_dev -> dev , in_dev , skb , daddr , //<S2SV> saddr ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> do_cache = res -> fi && ! itag ; //<S2SV> if ( out_dev == in_dev && err && IN_DEV_TX_REDIRECTS ( out_dev ) && //<S2SV> skb -> protocol == htons ( ETH_P_IP ) && //<S2SV> ( IN_DEV_SHARED_MEDIA ( out_dev ) || //<S2SV> inet_addr_onlink ( out_dev , saddr , FIB_RES_GW ( * res ) ) ) ) //<S2SV> IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ; //<S2SV> if ( skb -> protocol != htons ( ETH_P_IP ) ) { //<S2SV> if ( out_dev == in_dev && //<S2SV> IN_DEV_PROXY_ARP_PVLAN ( in_dev ) == 0 ) { //<S2SV> err = - EINVAL ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> fnhe = find_exception ( & FIB_RES_NH ( * res ) , daddr ) ; //<S2SV> if ( do_cache ) { //<S2SV> if ( fnhe != NULL ) //<S2SV> rth = rcu_dereference ( fnhe -> fnhe_rth_input ) ; //<S2SV> else //<S2SV> rth = rcu_dereference ( FIB_RES_NH ( * res ) . nh_rth_input ) ; //<S2SV> if ( rt_cache_valid ( rth ) ) { //<S2SV> skb_dst_set_noref ( skb , & rth -> dst ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> rth = rt_dst_alloc ( out_dev -> dev , //<S2SV> IN_DEV_CONF_GET ( in_dev , NOPOLICY ) , //<S2SV> IN_DEV_CONF_GET ( out_dev , NOXFRM ) , do_cache ) ; //<S2SV> if ( ! rth ) { //<S2SV> err = - ENOBUFS ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> rth -> rt_genid = rt_genid_ipv4 ( dev_net ( rth -> dst . dev ) ) ; //<S2SV> rth -> rt_flags = flags ; //<S2SV> rth -> rt_type = res -> type ; //<S2SV> rth -> rt_is_input = 1 ; //<S2SV> rth -> rt_iif = 0 ; //<S2SV> rth -> rt_pmtu = 0 ; //<S2SV> rth -> rt_gateway = 0 ; //<S2SV> rth -> rt_uses_gateway = 0 ; //<S2SV> INIT_LIST_HEAD ( & rth -> rt_uncached ) ; //<S2SV> RT_CACHE_STAT_INC ( in_slow_tot ) ; //<S2SV> rth -> dst . input = ip_forward ; //<S2SV> rth -> dst . output = ip_output ; //<S2SV> rt_set_nexthop ( rth , daddr , res , fnhe , res -> fi , res -> type , itag ) ; //<S2SV> skb_dst_set ( skb , & rth -> dst ) ; //<S2SV> out : //<S2SV> err = 0 ; //<S2SV> cleanup : //<S2SV> return err ; //<S2SV> } //<S2SV> 