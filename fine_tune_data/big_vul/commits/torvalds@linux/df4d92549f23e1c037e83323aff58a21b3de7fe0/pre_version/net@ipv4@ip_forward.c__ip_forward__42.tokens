int ip_forward ( struct sk_buff * skb ) //<S2SV> { //<S2SV> u32 mtu ; //<S2SV> struct iphdr * iph ; //<S2SV> struct rtable * rt ; //<S2SV> struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; //<S2SV> if ( skb -> pkt_type != PACKET_HOST ) //<S2SV> goto drop ; //<S2SV> if ( skb_warn_if_lro ( skb ) ) //<S2SV> goto drop ; //<S2SV> if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_FWD , skb ) ) //<S2SV> goto drop ; //<S2SV> if ( IPCB ( skb ) -> opt . router_alert && ip_call_ra_chain ( skb ) ) //<S2SV> return NET_RX_SUCCESS ; //<S2SV> skb_forward_csum ( skb ) ; //<S2SV> if ( ip_hdr ( skb ) -> ttl <= 1 ) //<S2SV> goto too_many_hops ; //<S2SV> if ( ! xfrm4_route_forward ( skb ) ) //<S2SV> goto drop ; //<S2SV> rt = skb_rtable ( skb ) ; //<S2SV> if ( opt -> is_strictroute && rt -> rt_uses_gateway ) //<S2SV> goto sr_failed ; //<S2SV> IPCB ( skb ) -> flags |= IPSKB_FORWARDED ; //<S2SV> mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ; //<S2SV> if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) { //<S2SV> IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ; //<S2SV> icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , //<S2SV> htonl ( mtu ) ) ; //<S2SV> goto drop ; //<S2SV> } //<S2SV> if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) //<S2SV> goto drop ; //<S2SV> iph = ip_hdr ( skb ) ; //<S2SV> ip_decrease_ttl ( iph ) ; //<S2SV> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) //<S2SV> ip_rt_send_redirect ( skb ) ; //<S2SV> skb -> priority = rt_tos2priority ( iph -> tos ) ; //<S2SV> return NF_HOOK ( NFPROTO_IPV4 , NF_INET_FORWARD , skb , skb -> dev , //<S2SV> rt -> dst . dev , ip_forward_finish ) ; //<S2SV> sr_failed : //<S2SV> icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_SR_FAILED , 0 ) ; //<S2SV> goto drop ; //<S2SV> too_many_hops : //<S2SV> IP_INC_STATS_BH ( dev_net ( skb_dst ( skb ) -> dev ) , IPSTATS_MIB_INHDRERRORS ) ; //<S2SV> icmp_send ( skb , ICMP_TIME_EXCEEDED , ICMP_EXC_TTL , 0 ) ; //<S2SV> drop : //<S2SV> kfree_skb ( skb ) ; //<S2SV> return NET_RX_DROP ; //<S2SV> } //<S2SV> 