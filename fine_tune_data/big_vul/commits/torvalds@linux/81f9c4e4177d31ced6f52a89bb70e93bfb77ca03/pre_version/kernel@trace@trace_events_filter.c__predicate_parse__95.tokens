static struct prog_entry * //<S2SV> predicate_parse ( const char * str , int nr_parens , int nr_preds , //<S2SV> parse_pred_fn parse_pred , void * data , //<S2SV> struct filter_parse_error * pe ) //<S2SV> { //<S2SV> struct prog_entry * prog_stack ; //<S2SV> struct prog_entry * prog ; //<S2SV> const char * ptr = str ; //<S2SV> char * inverts = NULL ; //<S2SV> int * op_stack ; //<S2SV> int * top ; //<S2SV> int invert = 0 ; //<S2SV> int ret = - ENOMEM ; //<S2SV> int len ; //<S2SV> int N = 0 ; //<S2SV> int i ; //<S2SV> nr_preds += 2 ; //<S2SV> op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; //<S2SV> if ( ! op_stack ) //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> prog_stack = kmalloc_array ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; //<S2SV> if ( ! prog_stack ) { //<S2SV> parse_error ( pe , - ENOMEM , 0 ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; //<S2SV> if ( ! inverts ) { //<S2SV> parse_error ( pe , - ENOMEM , 0 ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> top = op_stack ; //<S2SV> prog = prog_stack ; //<S2SV> * top = 0 ; //<S2SV> while ( * ptr ) { //<S2SV> const char * next = ptr ++ ; //<S2SV> if ( isspace ( * next ) ) //<S2SV> continue ; //<S2SV> switch ( * next ) { //<S2SV> case '(' : //<S2SV> if ( top - op_stack > nr_parens ) //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> * ( ++ top ) = invert ; //<S2SV> continue ; //<S2SV> case '!' : //<S2SV> if ( ! is_not ( next ) ) //<S2SV> break ; //<S2SV> invert = ! invert ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( N >= nr_preds ) { //<S2SV> parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> inverts [ N ] = invert ; //<S2SV> prog [ N ] . target = N - 1 ; //<S2SV> len = parse_pred ( next , data , ptr - str , pe , & prog [ N ] . pred ) ; //<S2SV> if ( len < 0 ) { //<S2SV> ret = len ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> ptr = next + len ; //<S2SV> N ++ ; //<S2SV> ret = - 1 ; //<S2SV> while ( 1 ) { //<S2SV> next = ptr ++ ; //<S2SV> if ( isspace ( * next ) ) //<S2SV> continue ; //<S2SV> switch ( * next ) { //<S2SV> case ')' : //<S2SV> case '\\0' : //<S2SV> break ; //<S2SV> case '&' : //<S2SV> case '|' : //<S2SV> if ( next [ 1 ] == next [ 0 ] ) { //<S2SV> ptr ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , //<S2SV> next - str ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> invert = * top & INVERT ; //<S2SV> if ( * top & PROCESS_AND ) { //<S2SV> update_preds ( prog , N - 1 , invert ) ; //<S2SV> * top &= ~ PROCESS_AND ; //<S2SV> } //<S2SV> if ( * next == '&' ) { //<S2SV> * top |= PROCESS_AND ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( * top & PROCESS_OR ) { //<S2SV> update_preds ( prog , N - 1 , ! invert ) ; //<S2SV> * top &= ~ PROCESS_OR ; //<S2SV> } //<S2SV> if ( * next == '|' ) { //<S2SV> * top |= PROCESS_OR ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! * next ) //<S2SV> goto out ; //<S2SV> if ( top == op_stack ) { //<S2SV> ret = - 1 ; //<S2SV> parse_error ( pe , FILT_ERR_TOO_MANY_CLOSE , ptr - str ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> top -- ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> if ( top != op_stack ) { //<S2SV> parse_error ( pe , FILT_ERR_TOO_MANY_OPEN , ptr - str ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> prog [ N ] . pred = NULL ; //<S2SV> prog [ N ] . target = 1 ; //<S2SV> prog [ N + 1 ] . pred = NULL ; //<S2SV> prog [ N + 1 ] . target = 0 ; //<S2SV> prog [ N - 1 ] . target = N ; //<S2SV> prog [ N - 1 ] . when_to_branch = false ; //<S2SV> for ( i = N - 1 ; i -- ; ) { //<S2SV> int target = prog [ i ] . target ; //<S2SV> if ( prog [ i ] . when_to_branch == prog [ target ] . when_to_branch ) //<S2SV> prog [ i ] . target = prog [ target ] . target ; //<S2SV> } //<S2SV> for ( i = 0 ; i < N ; i ++ ) { //<S2SV> invert = inverts [ i ] ^ prog [ i ] . when_to_branch ; //<S2SV> prog [ i ] . when_to_branch = invert ; //<S2SV> if ( WARN_ON ( prog [ i ] . target <= i ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> } //<S2SV> return prog ; //<S2SV> out_free : //<S2SV> kfree ( op_stack ) ; //<S2SV> kfree ( prog_stack ) ; //<S2SV> kfree ( inverts ) ; //<S2SV> return ERR_PTR ( ret ) ; //<S2SV> } //<S2SV> 