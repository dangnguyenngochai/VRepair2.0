static int ati_remote2_probe ( struct usb_interface * interface , const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct usb_device * udev = interface_to_usbdev ( interface ) ; //<S2SV> struct usb_host_interface * alt = interface -> cur_altsetting ; //<S2SV> struct ati_remote2 * ar2 ; //<S2SV> int r ; //<S2SV> if ( alt -> desc . bInterfaceNumber ) //<S2SV> return - ENODEV ; //<S2SV> ar2 = kzalloc ( sizeof ( struct ati_remote2 ) , GFP_KERNEL ) ; //<S2SV> if ( ! ar2 ) //<S2SV> return - ENOMEM ; //<S2SV> ar2 -> udev = udev ; //<S2SV> ar2 -> intf [ 0 ] = interface ; //<S2SV> ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ; //<S2SV> ar2 -> intf [ 1 ] = usb_ifnum_to_if ( udev , 1 ) ; //<S2SV> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; //<S2SV> if ( r ) //<S2SV> goto fail1 ; //<S2SV> alt = ar2 -> intf [ 1 ] -> cur_altsetting ; //<S2SV> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; //<S2SV> r = ati_remote2_urb_init ( ar2 ) ; //<S2SV> if ( r ) //<S2SV> goto fail2 ; //<S2SV> ar2 -> channel_mask = channel_mask ; //<S2SV> ar2 -> mode_mask = mode_mask ; //<S2SV> r = ati_remote2_setup ( ar2 , ar2 -> channel_mask ) ; //<S2SV> if ( r ) //<S2SV> goto fail2 ; //<S2SV> usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ; //<S2SV> strlcat ( ar2 -> phys , "/input0" , sizeof ( ar2 -> phys ) ) ; //<S2SV> strlcat ( ar2 -> name , "ATI<S2SV_blank>Remote<S2SV_blank>Wonder<S2SV_blank>II" , sizeof ( ar2 -> name ) ) ; //<S2SV> r = sysfs_create_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; //<S2SV> if ( r ) //<S2SV> goto fail2 ; //<S2SV> r = ati_remote2_input_init ( ar2 ) ; //<S2SV> if ( r ) //<S2SV> goto fail3 ; //<S2SV> usb_set_intfdata ( interface , ar2 ) ; //<S2SV> interface -> needs_remote_wakeup = 1 ; //<S2SV> return 0 ; //<S2SV> fail3 : //<S2SV> sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; //<S2SV> fail2 : //<S2SV> ati_remote2_urb_cleanup ( ar2 ) ; //<S2SV> usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ; //<S2SV> fail1 : //<S2SV> kfree ( ar2 ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> 