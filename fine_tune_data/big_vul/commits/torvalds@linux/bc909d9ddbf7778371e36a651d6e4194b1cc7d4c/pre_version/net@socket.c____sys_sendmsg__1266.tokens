static int __sys_sendmsg ( struct socket * sock , struct msghdr __user * msg , //<S2SV> struct msghdr * msg_sys , unsigned flags , //<S2SV> struct used_address * used_address ) //<S2SV> { //<S2SV> struct compat_msghdr __user * msg_compat = //<S2SV> ( struct compat_msghdr __user * ) msg ; //<S2SV> struct sockaddr_storage address ; //<S2SV> struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; //<S2SV> unsigned char ctl [ sizeof ( struct cmsghdr ) + 20 ] //<S2SV> __attribute__ ( ( aligned ( sizeof ( __kernel_size_t ) ) ) ) ; //<S2SV> unsigned char * ctl_buf = ctl ; //<S2SV> int err , ctl_len , iov_size , total_len ; //<S2SV> err = - EFAULT ; //<S2SV> if ( MSG_CMSG_COMPAT & flags ) { //<S2SV> if ( get_compat_msghdr ( msg_sys , msg_compat ) ) //<S2SV> return - EFAULT ; //<S2SV> } else if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) ) //<S2SV> return - EFAULT ; //<S2SV> err = - EMSGSIZE ; //<S2SV> if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) //<S2SV> goto out ; //<S2SV> err = - ENOMEM ; //<S2SV> iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) ; //<S2SV> if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { //<S2SV> iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ) ; //<S2SV> if ( ! iov ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( MSG_CMSG_COMPAT & flags ) { //<S2SV> err = verify_compat_iovec ( msg_sys , iov , //<S2SV> ( struct sockaddr * ) & address , //<S2SV> VERIFY_READ ) ; //<S2SV> } else //<S2SV> err = verify_iovec ( msg_sys , iov , //<S2SV> ( struct sockaddr * ) & address , //<S2SV> VERIFY_READ ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out_freeiov ; //<S2SV> total_len = err ; //<S2SV> err = - ENOBUFS ; //<S2SV> if ( msg_sys -> msg_controllen > INT_MAX ) //<S2SV> goto out_freeiov ; //<S2SV> ctl_len = msg_sys -> msg_controllen ; //<S2SV> if ( ( MSG_CMSG_COMPAT & flags ) && ctl_len ) { //<S2SV> err = //<S2SV> cmsghdr_from_user_compat_to_kern ( msg_sys , sock -> sk , ctl , //<S2SV> sizeof ( ctl ) ) ; //<S2SV> if ( err ) //<S2SV> goto out_freeiov ; //<S2SV> ctl_buf = msg_sys -> msg_control ; //<S2SV> ctl_len = msg_sys -> msg_controllen ; //<S2SV> } else if ( ctl_len ) { //<S2SV> if ( ctl_len > sizeof ( ctl ) ) { //<S2SV> ctl_buf = sock_kmalloc ( sock -> sk , ctl_len , GFP_KERNEL ) ; //<S2SV> if ( ctl_buf == NULL ) //<S2SV> goto out_freeiov ; //<S2SV> } //<S2SV> err = - EFAULT ; //<S2SV> if ( copy_from_user ( ctl_buf , //<S2SV> ( void __user __force * ) msg_sys -> msg_control , //<S2SV> ctl_len ) ) //<S2SV> goto out_freectl ; //<S2SV> msg_sys -> msg_control = ctl_buf ; //<S2SV> } //<S2SV> msg_sys -> msg_flags = flags ; //<S2SV> if ( sock -> file -> f_flags & O_NONBLOCK ) //<S2SV> msg_sys -> msg_flags |= MSG_DONTWAIT ; //<S2SV> if ( used_address && used_address -> name_len == msg_sys -> msg_namelen && //<S2SV> ! memcmp ( & used_address -> name , msg -> msg_name , //<S2SV> used_address -> name_len ) ) { //<S2SV> err = sock_sendmsg_nosec ( sock , msg_sys , total_len ) ; //<S2SV> goto out_freectl ; //<S2SV> } //<S2SV> err = sock_sendmsg ( sock , msg_sys , total_len ) ; //<S2SV> if ( used_address && err >= 0 ) { //<S2SV> used_address -> name_len = msg_sys -> msg_namelen ; //<S2SV> memcpy ( & used_address -> name , msg -> msg_name , //<S2SV> used_address -> name_len ) ; //<S2SV> } //<S2SV> out_freectl : //<S2SV> if ( ctl_buf != ctl ) //<S2SV> sock_kfree_s ( sock -> sk , ctl_buf , ctl_len ) ; //<S2SV> out_freeiov : //<S2SV> if ( iov != iovstack ) //<S2SV> sock_kfree_s ( sock -> sk , iov , iov_size ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 