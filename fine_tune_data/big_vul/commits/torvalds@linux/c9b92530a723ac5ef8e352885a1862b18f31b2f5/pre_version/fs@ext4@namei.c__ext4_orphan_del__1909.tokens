int ext4_orphan_del ( handle_t * handle , struct inode * inode ) //<S2SV> { //<S2SV> struct list_head * prev ; //<S2SV> struct ext4_inode_info * ei = EXT4_I ( inode ) ; //<S2SV> struct ext4_sb_info * sbi ; //<S2SV> __u32 ino_next ; //<S2SV> struct ext4_iloc iloc ; //<S2SV> int err = 0 ; //<S2SV> if ( handle && ! ext4_handle_valid ( handle ) ) //<S2SV> return 0 ; //<S2SV> mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; //<S2SV> if ( list_empty ( & ei -> i_orphan ) ) //<S2SV> goto out ; //<S2SV> ino_next = NEXT_ORPHAN ( inode ) ; //<S2SV> prev = ei -> i_orphan . prev ; //<S2SV> sbi = EXT4_SB ( inode -> i_sb ) ; //<S2SV> jbd_debug ( 4 , "remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n" , inode -> i_ino ) ; //<S2SV> list_del_init ( & ei -> i_orphan ) ; //<S2SV> if ( sbi -> s_journal && ! handle ) //<S2SV> goto out ; //<S2SV> err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; //<S2SV> if ( err ) //<S2SV> goto out_err ; //<S2SV> if ( prev == & sbi -> s_orphan ) { //<S2SV> jbd_debug ( 4 , "superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n" , ino_next ) ; //<S2SV> BUFFER_TRACE ( sbi -> s_sbh , "get_write_access" ) ; //<S2SV> err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; //<S2SV> if ( err ) //<S2SV> goto out_brelse ; //<S2SV> sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; //<S2SV> err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; //<S2SV> } else { //<S2SV> struct ext4_iloc iloc2 ; //<S2SV> struct inode * i_prev = //<S2SV> & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; //<S2SV> jbd_debug ( 4 , "orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n" , //<S2SV> i_prev -> i_ino , ino_next ) ; //<S2SV> err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; //<S2SV> if ( err ) //<S2SV> goto out_brelse ; //<S2SV> NEXT_ORPHAN ( i_prev ) = ino_next ; //<S2SV> err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; //<S2SV> } //<S2SV> if ( err ) //<S2SV> goto out_brelse ; //<S2SV> NEXT_ORPHAN ( inode ) = 0 ; //<S2SV> err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; //<S2SV> out_err : //<S2SV> ext4_std_error ( inode -> i_sb , err ) ; //<S2SV> out : //<S2SV> mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; //<S2SV> return err ; //<S2SV> out_brelse : //<S2SV> brelse ( iloc . bh ) ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> 