int ext4_orphan_add ( handle_t * handle , struct inode * inode ) //<S2SV> { //<S2SV> struct super_block * sb = inode -> i_sb ; //<S2SV> struct ext4_iloc iloc ; //<S2SV> int err = 0 , rc ; //<S2SV> if ( ! ext4_handle_valid ( handle ) ) //<S2SV> return 0 ; //<S2SV> mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; //<S2SV> if ( ! list_empty ( & EXT4_I ( inode ) -> i_orphan ) ) //<S2SV> goto out_unlock ; //<S2SV> J_ASSERT ( ( S_ISREG ( inode -> i_mode ) || S_ISDIR ( inode -> i_mode ) || //<S2SV> S_ISLNK ( inode -> i_mode ) ) || inode -> i_nlink == 0 ) ; //<S2SV> BUFFER_TRACE ( EXT4_SB ( sb ) -> s_sbh , "get_write_access" ) ; //<S2SV> err = ext4_journal_get_write_access ( handle , EXT4_SB ( sb ) -> s_sbh ) ; //<S2SV> if ( err ) //<S2SV> goto out_unlock ; //<S2SV> err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; //<S2SV> if ( err ) //<S2SV> goto out_unlock ; //<S2SV> if ( NEXT_ORPHAN ( inode ) && NEXT_ORPHAN ( inode ) <= //<S2SV> ( le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_inodes_count ) ) ) //<S2SV> goto mem_insert ; //<S2SV> NEXT_ORPHAN ( inode ) = le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_last_orphan ) ; //<S2SV> EXT4_SB ( sb ) -> s_es -> s_last_orphan = cpu_to_le32 ( inode -> i_ino ) ; //<S2SV> err = ext4_handle_dirty_super ( handle , sb ) ; //<S2SV> rc = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; //<S2SV> if ( ! err ) //<S2SV> err = rc ; //<S2SV> mem_insert : //<S2SV> if ( ! err ) //<S2SV> list_add ( & EXT4_I ( inode ) -> i_orphan , & EXT4_SB ( sb ) -> s_orphan ) ; //<S2SV> jbd_debug ( 4 , "superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%lu\\n" , inode -> i_ino ) ; //<S2SV> jbd_debug ( 4 , "orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%d\\n" , //<S2SV> inode -> i_ino , NEXT_ORPHAN ( inode ) ) ; //<S2SV> out_unlock : //<S2SV> mutex_unlock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; //<S2SV> ext4_std_error ( inode -> i_sb , err ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 