static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) //<S2SV> { //<S2SV> struct packet_sock * po = pkt_sk ( sk ) ; //<S2SV> struct packet_fanout * f , * match ; //<S2SV> u8 type = type_flags & 0xff ; //<S2SV> u8 flags = type_flags >> 8 ; //<S2SV> int err ; //<S2SV> switch ( type ) { //<S2SV> case PACKET_FANOUT_ROLLOVER : //<S2SV> if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) //<S2SV> return - EINVAL ; //<S2SV> case PACKET_FANOUT_HASH : //<S2SV> case PACKET_FANOUT_LB : //<S2SV> case PACKET_FANOUT_CPU : //<S2SV> case PACKET_FANOUT_RND : //<S2SV> case PACKET_FANOUT_QM : //<S2SV> case PACKET_FANOUT_CBPF : //<S2SV> case PACKET_FANOUT_EBPF : //<S2SV> break ; //<S2SV> default : //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( ! po -> running ) //<S2SV> return - EINVAL ; //<S2SV> if ( po -> fanout ) //<S2SV> return - EALREADY ; //<S2SV> if ( type == PACKET_FANOUT_ROLLOVER || //<S2SV> ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { //<S2SV> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; //<S2SV> if ( ! po -> rollover ) //<S2SV> return - ENOMEM ; //<S2SV> atomic_long_set ( & po -> rollover -> num , 0 ) ; //<S2SV> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; //<S2SV> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; //<S2SV> } //<S2SV> mutex_lock ( & fanout_mutex ) ; //<S2SV> match = NULL ; //<S2SV> list_for_each_entry ( f , & fanout_list , list ) { //<S2SV> if ( f -> id == id && //<S2SV> read_pnet ( & f -> net ) == sock_net ( sk ) ) { //<S2SV> match = f ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> err = - EINVAL ; //<S2SV> if ( match && match -> flags != flags ) //<S2SV> goto out ; //<S2SV> if ( ! match ) { //<S2SV> err = - ENOMEM ; //<S2SV> match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; //<S2SV> if ( ! match ) //<S2SV> goto out ; //<S2SV> write_pnet ( & match -> net , sock_net ( sk ) ) ; //<S2SV> match -> id = id ; //<S2SV> match -> type = type ; //<S2SV> match -> flags = flags ; //<S2SV> INIT_LIST_HEAD ( & match -> list ) ; //<S2SV> spin_lock_init ( & match -> lock ) ; //<S2SV> atomic_set ( & match -> sk_ref , 0 ) ; //<S2SV> fanout_init_data ( match ) ; //<S2SV> match -> prot_hook . type = po -> prot_hook . type ; //<S2SV> match -> prot_hook . dev = po -> prot_hook . dev ; //<S2SV> match -> prot_hook . func = packet_rcv_fanout ; //<S2SV> match -> prot_hook . af_packet_priv = match ; //<S2SV> match -> prot_hook . id_match = match_fanout_group ; //<S2SV> dev_add_pack ( & match -> prot_hook ) ; //<S2SV> list_add ( & match -> list , & fanout_list ) ; //<S2SV> } //<S2SV> err = - EINVAL ; //<S2SV> if ( match -> type == type && //<S2SV> match -> prot_hook . type == po -> prot_hook . type && //<S2SV> match -> prot_hook . dev == po -> prot_hook . dev ) { //<S2SV> err = - ENOSPC ; //<S2SV> if ( atomic_read ( & match -> sk_ref ) < PACKET_FANOUT_MAX ) { //<S2SV> __dev_remove_pack ( & po -> prot_hook ) ; //<S2SV> po -> fanout = match ; //<S2SV> atomic_inc ( & match -> sk_ref ) ; //<S2SV> __fanout_link ( sk , po ) ; //<S2SV> err = 0 ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> mutex_unlock ( & fanout_mutex ) ; //<S2SV> if ( err ) { //<S2SV> kfree ( po -> rollover ) ; //<S2SV> po -> rollover = NULL ; //<S2SV> } //<S2SV> return err ; //<S2SV> } //<S2SV> 