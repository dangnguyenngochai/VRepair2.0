static int su3000_i2c_transfer ( struct i2c_adapter * adap , struct i2c_msg msg [ ] , //<S2SV> int num ) //<S2SV> { //<S2SV> struct dvb_usb_device * d = i2c_get_adapdata ( adap ) ; //<S2SV> struct dw2102_state * state ; //<S2SV> if ( ! d ) //<S2SV> return - ENODEV ; //<S2SV> state = d -> priv ; //<S2SV> if ( mutex_lock_interruptible ( & d -> i2c_mutex ) < 0 ) //<S2SV> return - EAGAIN ; //<S2SV> if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { //<S2SV> mutex_unlock ( & d -> i2c_mutex ) ; //<S2SV> return - EAGAIN ; //<S2SV> } //<S2SV> switch ( num ) { //<S2SV> case 1 : //<S2SV> switch ( msg [ 0 ] . addr ) { //<S2SV> case SU3000_STREAM_CTRL : //<S2SV> state -> data [ 0 ] = msg [ 0 ] . buf [ 0 ] + 0x36 ; //<S2SV> state -> data [ 1 ] = 3 ; //<S2SV> state -> data [ 2 ] = 0 ; //<S2SV> if ( dvb_usb_generic_rw ( d , state -> data , 3 , //<S2SV> state -> data , 0 , 0 ) < 0 ) //<S2SV> err ( "i2c<S2SV_blank>transfer<S2SV_blank>failed." ) ; //<S2SV> break ; //<S2SV> case DW2102_RC_QUERY : //<S2SV> state -> data [ 0 ] = 0x10 ; //<S2SV> if ( dvb_usb_generic_rw ( d , state -> data , 1 , //<S2SV> state -> data , 2 , 0 ) < 0 ) //<S2SV> err ( "i2c<S2SV_blank>transfer<S2SV_blank>failed." ) ; //<S2SV> msg [ 0 ] . buf [ 1 ] = state -> data [ 0 ] ; //<S2SV> msg [ 0 ] . buf [ 0 ] = state -> data [ 1 ] ; //<S2SV> break ; //<S2SV> default : //<S2SV> state -> data [ 0 ] = 0x08 ; //<S2SV> state -> data [ 1 ] = msg [ 0 ] . addr ; //<S2SV> state -> data [ 2 ] = msg [ 0 ] . len ; //<S2SV> memcpy ( & state -> data [ 3 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; //<S2SV> if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 3 , //<S2SV> state -> data , 1 , 0 ) < 0 ) //<S2SV> err ( "i2c<S2SV_blank>transfer<S2SV_blank>failed." ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 2 : //<S2SV> state -> data [ 0 ] = 0x09 ; //<S2SV> state -> data [ 1 ] = msg [ 0 ] . len ; //<S2SV> state -> data [ 2 ] = msg [ 1 ] . len ; //<S2SV> state -> data [ 3 ] = msg [ 0 ] . addr ; //<S2SV> memcpy ( & state -> data [ 4 ] , msg [ 0 ] . buf , msg [ 0 ] . len ) ; //<S2SV> if ( dvb_usb_generic_rw ( d , state -> data , msg [ 0 ] . len + 4 , //<S2SV> state -> data , msg [ 1 ] . len + 1 , 0 ) < 0 ) //<S2SV> err ( "i2c<S2SV_blank>transfer<S2SV_blank>failed." ) ; //<S2SV> memcpy ( msg [ 1 ] . buf , & state -> data [ 1 ] , msg [ 1 ] . len ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> warn ( "more<S2SV_blank>than<S2SV_blank>2<S2SV_blank>i2c<S2SV_blank>messages<S2SV_blank>at<S2SV_blank>a<S2SV_blank>time<S2SV_blank>is<S2SV_blank>not<S2SV_blank>handled<S2SV_blank>yet." ) ; //<S2SV> break ; //<S2SV> } //<S2SV> mutex_unlock ( & d -> data_mutex ) ; //<S2SV> mutex_unlock ( & d -> i2c_mutex ) ; //<S2SV> return num ; //<S2SV> } //<S2SV> 