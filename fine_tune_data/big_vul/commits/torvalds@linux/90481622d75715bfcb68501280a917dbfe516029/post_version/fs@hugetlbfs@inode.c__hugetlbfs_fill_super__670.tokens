static int //<S2SV> hugetlbfs_fill_super ( struct super_block * sb , void * data , int silent ) //<S2SV> { //<S2SV> struct inode * inode ; //<S2SV> struct dentry * root ; //<S2SV> int ret ; //<S2SV> struct hugetlbfs_config config ; //<S2SV> struct hugetlbfs_sb_info * sbinfo ; //<S2SV> save_mount_options ( sb , data ) ; //<S2SV> config . nr_blocks = - 1 ; //<S2SV> config . nr_inodes = - 1 ; //<S2SV> config . uid = current_fsuid ( ) ; //<S2SV> config . gid = current_fsgid ( ) ; //<S2SV> config . mode = 0755 ; //<S2SV> config . hstate = & default_hstate ; //<S2SV> ret = hugetlbfs_parse_options ( data , & config ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> sbinfo = kmalloc ( sizeof ( struct hugetlbfs_sb_info ) , GFP_KERNEL ) ; //<S2SV> if ( ! sbinfo ) //<S2SV> return - ENOMEM ; //<S2SV> sb -> s_fs_info = sbinfo ; //<S2SV> sbinfo -> hstate = config . hstate ; //<S2SV> spin_lock_init ( & sbinfo -> stat_lock ) ; //<S2SV> sbinfo -> max_inodes = config . nr_inodes ; //<S2SV> sbinfo -> free_inodes = config . nr_inodes ; //<S2SV> sbinfo -> spool = NULL ; //<S2SV> if ( config . nr_blocks != - 1 ) { //<S2SV> sbinfo -> spool = hugepage_new_subpool ( config . nr_blocks ) ; //<S2SV> if ( ! sbinfo -> spool ) //<S2SV> goto out_free ; //<S2SV> } //<S2SV> sb -> s_maxbytes = MAX_LFS_FILESIZE ; //<S2SV> sb -> s_blocksize = huge_page_size ( config . hstate ) ; //<S2SV> sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; //<S2SV> sb -> s_magic = HUGETLBFS_MAGIC ; //<S2SV> sb -> s_op = & hugetlbfs_ops ; //<S2SV> sb -> s_time_gran = 1 ; //<S2SV> inode = hugetlbfs_get_root ( sb , & config ) ; //<S2SV> if ( ! inode ) //<S2SV> goto out_free ; //<S2SV> root = d_alloc_root ( inode ) ; //<S2SV> if ( ! root ) { //<S2SV> iput ( inode ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> sb -> s_root = root ; //<S2SV> return 0 ; //<S2SV> out_free : //<S2SV> if ( sbinfo -> spool ) //<S2SV> kfree ( sbinfo -> spool ) ; //<S2SV> kfree ( sbinfo ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> 