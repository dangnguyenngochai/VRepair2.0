static void free_huge_page ( struct page * page ) //<S2SV> { //<S2SV> struct hstate * h = page_hstate ( page ) ; //<S2SV> int nid = page_to_nid ( page ) ; //<S2SV> struct hugepage_subpool * spool = //<S2SV> ( struct hugepage_subpool * ) page_private ( page ) ; //<S2SV> set_page_private ( page , 0 ) ; //<S2SV> page -> mapping = NULL ; //<S2SV> BUG_ON ( page_count ( page ) ) ; //<S2SV> BUG_ON ( page_mapcount ( page ) ) ; //<S2SV> INIT_LIST_HEAD ( & page -> lru ) ; //<S2SV> spin_lock ( & hugetlb_lock ) ; //<S2SV> if ( h -> surplus_huge_pages_node [ nid ] && huge_page_order ( h ) < MAX_ORDER ) { //<S2SV> update_and_free_page ( h , page ) ; //<S2SV> h -> surplus_huge_pages -- ; //<S2SV> h -> surplus_huge_pages_node [ nid ] -- ; //<S2SV> } else { //<S2SV> enqueue_huge_page ( h , page ) ; //<S2SV> } //<S2SV> spin_unlock ( & hugetlb_lock ) ; //<S2SV> hugepage_subpool_put_pages ( spool , 1 ) ; //<S2SV> } //<S2SV> 