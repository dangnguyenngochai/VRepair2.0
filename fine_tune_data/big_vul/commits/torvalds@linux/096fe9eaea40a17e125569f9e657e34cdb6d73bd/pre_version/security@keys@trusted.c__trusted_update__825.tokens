static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) //<S2SV> { //<S2SV> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; //<S2SV> struct trusted_key_payload * new_p ; //<S2SV> struct trusted_key_options * new_o ; //<S2SV> size_t datalen = prep -> datalen ; //<S2SV> char * datablob ; //<S2SV> int ret = 0 ; //<S2SV> if ( ! p -> migratable ) //<S2SV> return - EPERM ; //<S2SV> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) //<S2SV> return - EINVAL ; //<S2SV> datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; //<S2SV> if ( ! datablob ) //<S2SV> return - ENOMEM ; //<S2SV> new_o = trusted_options_alloc ( ) ; //<S2SV> if ( ! new_o ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> new_p = trusted_payload_alloc ( key ) ; //<S2SV> if ( ! new_p ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> memcpy ( datablob , prep -> data , datalen ) ; //<S2SV> datablob [ datalen ] = '\\0' ; //<S2SV> ret = datablob_parse ( datablob , new_p , new_o ) ; //<S2SV> if ( ret != Opt_update ) { //<S2SV> ret = - EINVAL ; //<S2SV> kfree ( new_p ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! new_o -> keyhandle ) { //<S2SV> ret = - EINVAL ; //<S2SV> kfree ( new_p ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> new_p -> migratable = p -> migratable ; //<S2SV> new_p -> key_len = p -> key_len ; //<S2SV> memcpy ( new_p -> key , p -> key , p -> key_len ) ; //<S2SV> dump_payload ( p ) ; //<S2SV> dump_payload ( new_p ) ; //<S2SV> ret = key_seal ( new_p , new_o ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> pr_info ( "trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n" , ret ) ; //<S2SV> kfree ( new_p ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( new_o -> pcrlock ) { //<S2SV> ret = pcrlock ( new_o -> pcrlock ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> pr_info ( "trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n" , ret ) ; //<S2SV> kfree ( new_p ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> rcu_assign_keypointer ( key , new_p ) ; //<S2SV> call_rcu ( & p -> rcu , trusted_rcu_free ) ; //<S2SV> out : //<S2SV> kfree ( datablob ) ; //<S2SV> kfree ( new_o ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 