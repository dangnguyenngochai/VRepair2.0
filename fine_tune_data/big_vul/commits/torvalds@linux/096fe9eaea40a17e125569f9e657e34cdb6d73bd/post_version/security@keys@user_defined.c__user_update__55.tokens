int user_update ( struct key * key , struct key_preparsed_payload * prep ) //<S2SV> { //<S2SV> struct user_key_payload * upayload , * zap ; //<S2SV> size_t datalen = prep -> datalen ; //<S2SV> int ret ; //<S2SV> ret = - EINVAL ; //<S2SV> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) //<S2SV> goto error ; //<S2SV> ret = - ENOMEM ; //<S2SV> upayload = kmalloc ( sizeof ( * upayload ) + datalen , GFP_KERNEL ) ; //<S2SV> if ( ! upayload ) //<S2SV> goto error ; //<S2SV> upayload -> datalen = datalen ; //<S2SV> memcpy ( upayload -> data , prep -> data , datalen ) ; //<S2SV> zap = upayload ; //<S2SV> ret = key_payload_reserve ( key , datalen ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) //<S2SV> zap = key -> payload . data [ 0 ] ; //<S2SV> else //<S2SV> zap = NULL ; //<S2SV> rcu_assign_keypointer ( key , upayload ) ; //<S2SV> key -> expiry = 0 ; //<S2SV> } //<S2SV> if ( zap ) //<S2SV> kfree_rcu ( zap , rcu ) ; //<S2SV> error : //<S2SV> return ret ; //<S2SV> } //<S2SV> 