static int rfcomm_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct bt_security sec ; //<S2SV> int len , err = 0 ; //<S2SV> BT_DBG ( "sk<S2SV_blank>%p" , sk ) ; //<S2SV> if ( level == SOL_RFCOMM ) //<S2SV> return rfcomm_sock_getsockopt_old ( sock , optname , optval , optlen ) ; //<S2SV> if ( level != SOL_BLUETOOTH ) //<S2SV> return - ENOPROTOOPT ; //<S2SV> if ( get_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> lock_sock ( sk ) ; //<S2SV> switch ( optname ) { //<S2SV> case BT_SECURITY : //<S2SV> if ( sk -> sk_type != SOCK_STREAM ) { //<S2SV> err = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> sec . level = rfcomm_pi ( sk ) -> sec_level ; //<S2SV> sec . key_size = 0 ; //<S2SV> len = min_t ( unsigned int , len , sizeof ( sec ) ) ; //<S2SV> if ( copy_to_user ( optval , ( char * ) & sec , len ) ) //<S2SV> err = - EFAULT ; //<S2SV> break ; //<S2SV> case BT_DEFER_SETUP : //<S2SV> if ( sk -> sk_state != BT_BOUND && sk -> sk_state != BT_LISTEN ) { //<S2SV> err = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( put_user ( test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) , //<S2SV> ( u32 __user * ) optval ) ) //<S2SV> err = - EFAULT ; //<S2SV> break ; //<S2SV> default : //<S2SV> err = - ENOPROTOOPT ; //<S2SV> break ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 