static int //<S2SV> aiptek_probe ( struct usb_interface * intf , const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct usb_device * usbdev = interface_to_usbdev ( intf ) ; //<S2SV> struct usb_endpoint_descriptor * endpoint ; //<S2SV> struct aiptek * aiptek ; //<S2SV> struct input_dev * inputdev ; //<S2SV> int i ; //<S2SV> int speeds [ ] = { 0 , //<S2SV> AIPTEK_PROGRAMMABLE_DELAY_50 , //<S2SV> AIPTEK_PROGRAMMABLE_DELAY_400 , //<S2SV> AIPTEK_PROGRAMMABLE_DELAY_25 , //<S2SV> AIPTEK_PROGRAMMABLE_DELAY_100 , //<S2SV> AIPTEK_PROGRAMMABLE_DELAY_200 , //<S2SV> AIPTEK_PROGRAMMABLE_DELAY_300 //<S2SV> } ; //<S2SV> int err = - ENOMEM ; //<S2SV> speeds [ 0 ] = programmableDelay ; //<S2SV> aiptek = kzalloc ( sizeof ( struct aiptek ) , GFP_KERNEL ) ; //<S2SV> inputdev = input_allocate_device ( ) ; //<S2SV> if ( ! aiptek || ! inputdev ) { //<S2SV> dev_warn ( & intf -> dev , //<S2SV> "cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>or<S2SV_blank>input<S2SV_blank>device\\n" ) ; //<S2SV> goto fail1 ; //<S2SV> } //<S2SV> aiptek -> data = usb_alloc_coherent ( usbdev , AIPTEK_PACKET_LENGTH , //<S2SV> GFP_ATOMIC , & aiptek -> data_dma ) ; //<S2SV> if ( ! aiptek -> data ) { //<S2SV> dev_warn ( & intf -> dev , "cannot<S2SV_blank>allocate<S2SV_blank>usb<S2SV_blank>buffer\\n" ) ; //<S2SV> goto fail1 ; //<S2SV> } //<S2SV> aiptek -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! aiptek -> urb ) { //<S2SV> dev_warn ( & intf -> dev , "cannot<S2SV_blank>allocate<S2SV_blank>urb\\n" ) ; //<S2SV> goto fail2 ; //<S2SV> } //<S2SV> aiptek -> inputdev = inputdev ; //<S2SV> aiptek -> usbdev = usbdev ; //<S2SV> aiptek -> intf = intf ; //<S2SV> aiptek -> ifnum = intf -> altsetting [ 0 ] . desc . bInterfaceNumber ; //<S2SV> aiptek -> inDelay = 0 ; //<S2SV> aiptek -> endDelay = 0 ; //<S2SV> aiptek -> previousJitterable = 0 ; //<S2SV> aiptek -> lastMacro = - 1 ; //<S2SV> aiptek -> curSetting . pointerMode = AIPTEK_POINTER_EITHER_MODE ; //<S2SV> aiptek -> curSetting . coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE ; //<S2SV> aiptek -> curSetting . toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE ; //<S2SV> aiptek -> curSetting . xTilt = AIPTEK_TILT_DISABLE ; //<S2SV> aiptek -> curSetting . yTilt = AIPTEK_TILT_DISABLE ; //<S2SV> aiptek -> curSetting . mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON ; //<S2SV> aiptek -> curSetting . mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON ; //<S2SV> aiptek -> curSetting . mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON ; //<S2SV> aiptek -> curSetting . stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON ; //<S2SV> aiptek -> curSetting . stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON ; //<S2SV> aiptek -> curSetting . jitterDelay = jitterDelay ; //<S2SV> aiptek -> curSetting . programmableDelay = programmableDelay ; //<S2SV> aiptek -> newSetting = aiptek -> curSetting ; //<S2SV> usb_make_path ( usbdev , aiptek -> features . usbPath , //<S2SV> sizeof ( aiptek -> features . usbPath ) ) ; //<S2SV> strlcat ( aiptek -> features . usbPath , "/input0" , //<S2SV> sizeof ( aiptek -> features . usbPath ) ) ; //<S2SV> inputdev -> name = "Aiptek" ; //<S2SV> inputdev -> phys = aiptek -> features . usbPath ; //<S2SV> usb_to_input_id ( usbdev , & inputdev -> id ) ; //<S2SV> inputdev -> dev . parent = & intf -> dev ; //<S2SV> input_set_drvdata ( inputdev , aiptek ) ; //<S2SV> inputdev -> open = aiptek_open ; //<S2SV> inputdev -> close = aiptek_close ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( eventTypes ) ; ++ i ) //<S2SV> __set_bit ( eventTypes [ i ] , inputdev -> evbit ) ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( absEvents ) ; ++ i ) //<S2SV> __set_bit ( absEvents [ i ] , inputdev -> absbit ) ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( relEvents ) ; ++ i ) //<S2SV> __set_bit ( relEvents [ i ] , inputdev -> relbit ) ; //<S2SV> __set_bit ( MSC_SERIAL , inputdev -> mscbit ) ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( buttonEvents ) ; ++ i ) //<S2SV> __set_bit ( buttonEvents [ i ] , inputdev -> keybit ) ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( macroKeyEvents ) ; ++ i ) //<S2SV> __set_bit ( macroKeyEvents [ i ] , inputdev -> keybit ) ; //<S2SV> input_set_abs_params ( inputdev , ABS_X , 0 , 2999 , 0 , 0 ) ; //<S2SV> input_set_abs_params ( inputdev , ABS_Y , 0 , 2249 , 0 , 0 ) ; //<S2SV> input_set_abs_params ( inputdev , ABS_PRESSURE , 0 , 511 , 0 , 0 ) ; //<S2SV> input_set_abs_params ( inputdev , ABS_TILT_X , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; //<S2SV> input_set_abs_params ( inputdev , ABS_TILT_Y , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; //<S2SV> input_set_abs_params ( inputdev , ABS_WHEEL , AIPTEK_WHEEL_MIN , AIPTEK_WHEEL_MAX - 1 , 0 , 0 ) ; //<S2SV> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; //<S2SV> usb_fill_int_urb ( aiptek -> urb , //<S2SV> aiptek -> usbdev , //<S2SV> usb_rcvintpipe ( aiptek -> usbdev , //<S2SV> endpoint -> bEndpointAddress ) , //<S2SV> aiptek -> data , 8 , aiptek_irq , aiptek , //<S2SV> endpoint -> bInterval ) ; //<S2SV> aiptek -> urb -> transfer_dma = aiptek -> data_dma ; //<S2SV> aiptek -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( speeds ) ; ++ i ) { //<S2SV> aiptek -> curSetting . programmableDelay = speeds [ i ] ; //<S2SV> ( void ) aiptek_program_tablet ( aiptek ) ; //<S2SV> if ( input_abs_get_max ( aiptek -> inputdev , ABS_X ) > 0 ) { //<S2SV> dev_info ( & intf -> dev , //<S2SV> "Aiptek<S2SV_blank>using<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>programming<S2SV_blank>speed\\n" , //<S2SV> aiptek -> curSetting . programmableDelay ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( i == ARRAY_SIZE ( speeds ) ) { //<S2SV> dev_info ( & intf -> dev , //<S2SV> "Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n" ) ; //<S2SV> goto fail3 ; //<S2SV> } //<S2SV> usb_set_intfdata ( intf , aiptek ) ; //<S2SV> err = sysfs_create_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; //<S2SV> if ( err ) { //<S2SV> dev_warn ( & intf -> dev , "cannot<S2SV_blank>create<S2SV_blank>sysfs<S2SV_blank>group<S2SV_blank>err:<S2SV_blank>%d\\n" , //<S2SV> err ) ; //<S2SV> goto fail3 ; //<S2SV> } //<S2SV> err = input_register_device ( aiptek -> inputdev ) ; //<S2SV> if ( err ) { //<S2SV> dev_warn ( & intf -> dev , //<S2SV> "input_register_device<S2SV_blank>returned<S2SV_blank>err:<S2SV_blank>%d\\n" , err ) ; //<S2SV> goto fail4 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> fail4 : sysfs_remove_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; //<S2SV> fail3 : usb_free_urb ( aiptek -> urb ) ; //<S2SV> fail2 : usb_free_coherent ( usbdev , AIPTEK_PACKET_LENGTH , aiptek -> data , //<S2SV> aiptek -> data_dma ) ; //<S2SV> fail1 : usb_set_intfdata ( intf , NULL ) ; //<S2SV> input_free_device ( inputdev ) ; //<S2SV> kfree ( aiptek ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 