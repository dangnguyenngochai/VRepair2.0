static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len , int flags ) //<S2SV> { //<S2SV> int noblock = flags & MSG_DONTWAIT ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct iucv_sock * iucv = iucv_sk ( sk ) ; //<S2SV> unsigned int copied , rlen ; //<S2SV> struct sk_buff * skb , * rskb , * cskb ; //<S2SV> int err = 0 ; //<S2SV> if ( ( sk -> sk_state == IUCV_DISCONN ) && //<S2SV> skb_queue_empty ( & iucv -> backlog_skb_q ) && //<S2SV> skb_queue_empty ( & sk -> sk_receive_queue ) && //<S2SV> list_empty ( & iucv -> message_q . list ) ) //<S2SV> return 0 ; //<S2SV> if ( flags & ( MSG_OOB ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; //<S2SV> if ( ! skb ) { //<S2SV> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> return 0 ; //<S2SV> return err ; //<S2SV> } //<S2SV> rlen = skb -> len ; //<S2SV> copied = min_t ( unsigned int , rlen , len ) ; //<S2SV> if ( ! rlen ) //<S2SV> sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; //<S2SV> cskb = skb ; //<S2SV> if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { //<S2SV> if ( ! ( flags & MSG_PEEK ) ) //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( sk -> sk_type == SOCK_SEQPACKET ) { //<S2SV> if ( copied < rlen ) //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> msg -> msg_flags |= MSG_EOR ; //<S2SV> } //<S2SV> err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , //<S2SV> CB_TRGCLS_LEN , CB_TRGCLS ( skb ) ) ; //<S2SV> if ( err ) { //<S2SV> if ( ! ( flags & MSG_PEEK ) ) //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> if ( ! ( flags & MSG_PEEK ) ) { //<S2SV> if ( sk -> sk_type == SOCK_STREAM ) { //<S2SV> skb_pull ( skb , copied ) ; //<S2SV> if ( skb -> len ) { //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> } //<S2SV> kfree_skb ( skb ) ; //<S2SV> if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { //<S2SV> atomic_inc ( & iucv -> msg_recv ) ; //<S2SV> if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { //<S2SV> WARN_ON ( 1 ) ; //<S2SV> iucv_sock_close ( sk ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> } //<S2SV> spin_lock_bh ( & iucv -> message_q . lock ) ; //<S2SV> rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; //<S2SV> while ( rskb ) { //<S2SV> if ( sock_queue_rcv_skb ( sk , rskb ) ) { //<S2SV> skb_queue_head ( & iucv -> backlog_skb_q , //<S2SV> rskb ) ; //<S2SV> break ; //<S2SV> } else { //<S2SV> rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { //<S2SV> if ( ! list_empty ( & iucv -> message_q . list ) ) //<S2SV> iucv_process_message_q ( sk ) ; //<S2SV> if ( atomic_read ( & iucv -> msg_recv ) >= //<S2SV> iucv -> msglimit / 2 ) { //<S2SV> err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; //<S2SV> if ( err ) { //<S2SV> sk -> sk_state = IUCV_DISCONN ; //<S2SV> sk -> sk_state_change ( sk ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> spin_unlock_bh ( & iucv -> message_q . lock ) ; //<S2SV> } //<S2SV> done : //<S2SV> if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) //<S2SV> copied = rlen ; //<S2SV> return copied ; //<S2SV> } //<S2SV> 