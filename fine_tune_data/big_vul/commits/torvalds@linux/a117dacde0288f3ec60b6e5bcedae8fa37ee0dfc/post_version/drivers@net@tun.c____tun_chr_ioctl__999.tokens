static long __tun_chr_ioctl ( struct file * file , unsigned int cmd , //<S2SV> unsigned long arg , int ifreq_len ) //<S2SV> { //<S2SV> struct tun_file * tfile = file -> private_data ; //<S2SV> struct tun_struct * tun ; //<S2SV> void __user * argp = ( void __user * ) arg ; //<S2SV> struct sock_fprog fprog ; //<S2SV> struct ifreq ifr ; //<S2SV> int sndbuf ; //<S2SV> int vnet_hdr_sz ; //<S2SV> int ret ; //<S2SV> if ( cmd == TUNSETIFF || _IOC_TYPE ( cmd ) == 0x89 ) { //<S2SV> if ( copy_from_user ( & ifr , argp , ifreq_len ) ) //<S2SV> return - EFAULT ; //<S2SV> } else //<S2SV> memset ( & ifr , 0 , sizeof ( ifr ) ) ; //<S2SV> if ( cmd == TUNGETFEATURES ) { //<S2SV> return put_user ( IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE | //<S2SV> IFF_VNET_HDR , //<S2SV> ( unsigned int __user * ) argp ) ; //<S2SV> } //<S2SV> rtnl_lock ( ) ; //<S2SV> tun = __tun_get ( tfile ) ; //<S2SV> if ( cmd == TUNSETIFF && ! tun ) { //<S2SV> ifr . ifr_name [ IFNAMSIZ - 1 ] = '\\0' ; //<S2SV> ret = tun_set_iff ( tfile -> net , file , & ifr ) ; //<S2SV> if ( ret ) //<S2SV> goto unlock ; //<S2SV> if ( copy_to_user ( argp , & ifr , ifreq_len ) ) //<S2SV> ret = - EFAULT ; //<S2SV> goto unlock ; //<S2SV> } //<S2SV> ret = - EBADFD ; //<S2SV> if ( ! tun ) //<S2SV> goto unlock ; //<S2SV> tun_debug ( KERN_INFO , tun , "tun_chr_ioctl<S2SV_blank>cmd<S2SV_blank>%d\\n" , cmd ) ; //<S2SV> ret = 0 ; //<S2SV> switch ( cmd ) { //<S2SV> case TUNGETIFF : //<S2SV> ret = tun_get_iff ( current -> nsproxy -> net_ns , tun , & ifr ) ; //<S2SV> if ( ret ) //<S2SV> break ; //<S2SV> if ( copy_to_user ( argp , & ifr , ifreq_len ) ) //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> case TUNSETNOCSUM : //<S2SV> tun_debug ( KERN_INFO , tun , "ignored:<S2SV_blank>set<S2SV_blank>checksum<S2SV_blank>%s\\n" , //<S2SV> arg ? "disabled" : "enabled" ) ; //<S2SV> break ; //<S2SV> case TUNSETPERSIST : //<S2SV> if ( arg ) //<S2SV> tun -> flags |= TUN_PERSIST ; //<S2SV> else //<S2SV> tun -> flags &= ~ TUN_PERSIST ; //<S2SV> tun_debug ( KERN_INFO , tun , "persist<S2SV_blank>%s\\n" , //<S2SV> arg ? "enabled" : "disabled" ) ; //<S2SV> break ; //<S2SV> case TUNSETOWNER : //<S2SV> tun -> owner = ( uid_t ) arg ; //<S2SV> tun_debug ( KERN_INFO , tun , "owner<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n" , tun -> owner ) ; //<S2SV> break ; //<S2SV> case TUNSETGROUP : //<S2SV> tun -> group = ( gid_t ) arg ; //<S2SV> tun_debug ( KERN_INFO , tun , "group<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n" , tun -> group ) ; //<S2SV> break ; //<S2SV> case TUNSETLINK : //<S2SV> if ( tun -> dev -> flags & IFF_UP ) { //<S2SV> tun_debug ( KERN_INFO , tun , //<S2SV> "Linktype<S2SV_blank>set<S2SV_blank>failed<S2SV_blank>because<S2SV_blank>interface<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> ret = - EBUSY ; //<S2SV> } else { //<S2SV> tun -> dev -> type = ( int ) arg ; //<S2SV> tun_debug ( KERN_INFO , tun , "linktype<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d\\n" , //<S2SV> tun -> dev -> type ) ; //<S2SV> ret = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> # ifdef TUN_DEBUG //<S2SV> case TUNSETDEBUG : //<S2SV> tun -> debug = arg ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case TUNSETOFFLOAD : //<S2SV> ret = set_offload ( tun , arg ) ; //<S2SV> break ; //<S2SV> case TUNSETTXFILTER : //<S2SV> ret = - EINVAL ; //<S2SV> if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) //<S2SV> break ; //<S2SV> ret = update_filter ( & tun -> txflt , ( void __user * ) arg ) ; //<S2SV> break ; //<S2SV> case SIOCGIFHWADDR : //<S2SV> memcpy ( ifr . ifr_hwaddr . sa_data , tun -> dev -> dev_addr , ETH_ALEN ) ; //<S2SV> ifr . ifr_hwaddr . sa_family = tun -> dev -> type ; //<S2SV> if ( copy_to_user ( argp , & ifr , ifreq_len ) ) //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> case SIOCSIFHWADDR : //<S2SV> tun_debug ( KERN_DEBUG , tun , "set<S2SV_blank>hw<S2SV_blank>address:<S2SV_blank>%pM\\n" , //<S2SV> ifr . ifr_hwaddr . sa_data ) ; //<S2SV> ret = dev_set_mac_address ( tun -> dev , & ifr . ifr_hwaddr ) ; //<S2SV> break ; //<S2SV> case TUNGETSNDBUF : //<S2SV> sndbuf = tun -> socket . sk -> sk_sndbuf ; //<S2SV> if ( copy_to_user ( argp , & sndbuf , sizeof ( sndbuf ) ) ) //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> case TUNSETSNDBUF : //<S2SV> if ( copy_from_user ( & sndbuf , argp , sizeof ( sndbuf ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> tun -> socket . sk -> sk_sndbuf = sndbuf ; //<S2SV> break ; //<S2SV> case TUNGETVNETHDRSZ : //<S2SV> vnet_hdr_sz = tun -> vnet_hdr_sz ; //<S2SV> if ( copy_to_user ( argp , & vnet_hdr_sz , sizeof ( vnet_hdr_sz ) ) ) //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> case TUNSETVNETHDRSZ : //<S2SV> if ( copy_from_user ( & vnet_hdr_sz , argp , sizeof ( vnet_hdr_sz ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( vnet_hdr_sz < ( int ) sizeof ( struct virtio_net_hdr ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> tun -> vnet_hdr_sz = vnet_hdr_sz ; //<S2SV> break ; //<S2SV> case TUNATTACHFILTER : //<S2SV> ret = - EINVAL ; //<S2SV> if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) //<S2SV> break ; //<S2SV> ret = - EFAULT ; //<S2SV> if ( copy_from_user ( & fprog , argp , sizeof ( fprog ) ) ) //<S2SV> break ; //<S2SV> ret = sk_attach_filter ( & fprog , tun -> socket . sk ) ; //<S2SV> break ; //<S2SV> case TUNDETACHFILTER : //<S2SV> ret = - EINVAL ; //<S2SV> if ( ( tun -> flags & TUN_TYPE_MASK ) != TUN_TAP_DEV ) //<S2SV> break ; //<S2SV> ret = sk_detach_filter ( tun -> socket . sk ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> unlock : //<S2SV> rtnl_unlock ( ) ; //<S2SV> if ( tun ) //<S2SV> tun_put ( tun ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 