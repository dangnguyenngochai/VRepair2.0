static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , //<S2SV> struct mm_walk * walk ) //<S2SV> { //<S2SV> spinlock_t * ptl ; //<S2SV> struct vm_area_struct * vma = walk -> vma ; //<S2SV> pte_t * ptep ; //<S2SV> unsigned char * vec = walk -> private ; //<S2SV> int nr = ( end - addr ) >> PAGE_SHIFT ; //<S2SV> ptl = pmd_trans_huge_lock ( pmd , vma ) ; //<S2SV> if ( ptl ) { //<S2SV> memset ( vec , 1 , nr ) ; //<S2SV> spin_unlock ( ptl ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( pmd_trans_unstable ( pmd ) ) { //<S2SV> memset ( vec , 1 , nr ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; //<S2SV> for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { //<S2SV> pte_t pte = * ptep ; //<S2SV> if ( pte_none ( pte ) ) //<S2SV> * vec = 0 ; //<S2SV> else if ( pte_present ( pte ) ) //<S2SV> * vec = 1 ; //<S2SV> else { //<S2SV> swp_entry_t entry = pte_to_swp_entry ( pte ) ; //<S2SV> * vec = ! ! non_swap_entry ( entry ) ; //<S2SV> } //<S2SV> vec ++ ; //<S2SV> } //<S2SV> pte_unmap_unlock ( ptep - 1 , ptl ) ; //<S2SV> out : //<S2SV> walk -> private += nr ; //<S2SV> cond_resched ( ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 