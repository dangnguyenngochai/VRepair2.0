struct sk_buff * sock_alloc_send_pskb ( struct sock * sk , unsigned long header_len , //<S2SV> unsigned long data_len , int noblock , //<S2SV> int * errcode ) //<S2SV> { //<S2SV> struct sk_buff * skb ; //<S2SV> gfp_t gfp_mask ; //<S2SV> long timeo ; //<S2SV> int err ; //<S2SV> gfp_mask = sk -> sk_allocation ; //<S2SV> if ( gfp_mask & __GFP_WAIT ) //<S2SV> gfp_mask |= __GFP_REPEAT ; //<S2SV> timeo = sock_sndtimeo ( sk , noblock ) ; //<S2SV> while ( 1 ) { //<S2SV> err = sock_error ( sk ) ; //<S2SV> if ( err != 0 ) //<S2SV> goto failure ; //<S2SV> err = - EPIPE ; //<S2SV> if ( sk -> sk_shutdown & SEND_SHUTDOWN ) //<S2SV> goto failure ; //<S2SV> if ( atomic_read ( & sk -> sk_wmem_alloc ) < sk -> sk_sndbuf ) { //<S2SV> skb = alloc_skb ( header_len , gfp_mask ) ; //<S2SV> if ( skb ) { //<S2SV> int npages ; //<S2SV> int i ; //<S2SV> if ( ! data_len ) //<S2SV> break ; //<S2SV> npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; //<S2SV> skb -> truesize += data_len ; //<S2SV> skb_shinfo ( skb ) -> nr_frags = npages ; //<S2SV> for ( i = 0 ; i < npages ; i ++ ) { //<S2SV> struct page * page ; //<S2SV> page = alloc_pages ( sk -> sk_allocation , 0 ) ; //<S2SV> if ( ! page ) { //<S2SV> err = - ENOBUFS ; //<S2SV> skb_shinfo ( skb ) -> nr_frags = i ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto failure ; //<S2SV> } //<S2SV> __skb_fill_page_desc ( skb , i , //<S2SV> page , 0 , //<S2SV> ( data_len >= PAGE_SIZE ? //<S2SV> PAGE_SIZE : //<S2SV> data_len ) ) ; //<S2SV> data_len -= PAGE_SIZE ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> err = - ENOBUFS ; //<S2SV> goto failure ; //<S2SV> } //<S2SV> set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; //<S2SV> set_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ; //<S2SV> err = - EAGAIN ; //<S2SV> if ( ! timeo ) //<S2SV> goto failure ; //<S2SV> if ( signal_pending ( current ) ) //<S2SV> goto interrupted ; //<S2SV> timeo = sock_wait_for_wmem ( sk , timeo ) ; //<S2SV> } //<S2SV> skb_set_owner_w ( skb , sk ) ; //<S2SV> return skb ; //<S2SV> interrupted : //<S2SV> err = sock_intr_errno ( timeo ) ; //<S2SV> failure : //<S2SV> * errcode = err ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 