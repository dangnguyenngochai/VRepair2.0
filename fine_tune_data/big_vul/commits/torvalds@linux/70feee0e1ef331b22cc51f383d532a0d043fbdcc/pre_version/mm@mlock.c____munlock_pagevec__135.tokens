static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) //<S2SV> { //<S2SV> int i ; //<S2SV> int nr = pagevec_count ( pvec ) ; //<S2SV> int delta_munlocked ; //<S2SV> struct pagevec pvec_putback ; //<S2SV> int pgrescued = 0 ; //<S2SV> pagevec_init ( & pvec_putback , 0 ) ; //<S2SV> spin_lock_irq ( zone_lru_lock ( zone ) ) ; //<S2SV> for ( i = 0 ; i < nr ; i ++ ) { //<S2SV> struct page * page = pvec -> pages [ i ] ; //<S2SV> if ( TestClearPageMlocked ( page ) ) { //<S2SV> if ( __munlock_isolate_lru_page ( page , false ) ) //<S2SV> continue ; //<S2SV> else //<S2SV> __munlock_isolation_failed ( page ) ; //<S2SV> } //<S2SV> pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; //<S2SV> pvec -> pages [ i ] = NULL ; //<S2SV> } //<S2SV> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; //<S2SV> __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; //<S2SV> spin_unlock_irq ( zone_lru_lock ( zone ) ) ; //<S2SV> pagevec_release ( & pvec_putback ) ; //<S2SV> for ( i = 0 ; i < nr ; i ++ ) { //<S2SV> struct page * page = pvec -> pages [ i ] ; //<S2SV> if ( page ) { //<S2SV> lock_page ( page ) ; //<S2SV> if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , //<S2SV> & pgrescued ) ) { //<S2SV> get_page ( page ) ; //<S2SV> __munlock_isolated_page ( page ) ; //<S2SV> unlock_page ( page ) ; //<S2SV> put_page ( page ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( pagevec_count ( & pvec_putback ) ) //<S2SV> __putback_lru_fast ( & pvec_putback , pgrescued ) ; //<S2SV> } //<S2SV> 