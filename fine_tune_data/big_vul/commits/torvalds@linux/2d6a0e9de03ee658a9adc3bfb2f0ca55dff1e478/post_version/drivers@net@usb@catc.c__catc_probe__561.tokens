static int catc_probe ( struct usb_interface * intf , const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct device * dev = & intf -> dev ; //<S2SV> struct usb_device * usbdev = interface_to_usbdev ( intf ) ; //<S2SV> struct net_device * netdev ; //<S2SV> struct catc * catc ; //<S2SV> u8 broadcast [ ETH_ALEN ] ; //<S2SV> int pktsz , ret ; //<S2SV> if ( usb_set_interface ( usbdev , //<S2SV> intf -> altsetting -> desc . bInterfaceNumber , 1 ) ) { //<S2SV> dev_err ( dev , "Can\'t<S2SV_blank>set<S2SV_blank>altsetting<S2SV_blank>1.\\n" ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> netdev = alloc_etherdev ( sizeof ( struct catc ) ) ; //<S2SV> if ( ! netdev ) //<S2SV> return - ENOMEM ; //<S2SV> catc = netdev_priv ( netdev ) ; //<S2SV> netdev -> netdev_ops = & catc_netdev_ops ; //<S2SV> netdev -> watchdog_timeo = TX_TIMEOUT ; //<S2SV> netdev -> ethtool_ops = & ops ; //<S2SV> catc -> usbdev = usbdev ; //<S2SV> catc -> netdev = netdev ; //<S2SV> spin_lock_init ( & catc -> tx_lock ) ; //<S2SV> spin_lock_init ( & catc -> ctrl_lock ) ; //<S2SV> init_timer ( & catc -> timer ) ; //<S2SV> catc -> timer . data = ( long ) catc ; //<S2SV> catc -> timer . function = catc_stats_timer ; //<S2SV> catc -> ctrl_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> catc -> tx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> catc -> rx_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> catc -> irq_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ( ! catc -> ctrl_urb ) || ( ! catc -> tx_urb ) || //<S2SV> ( ! catc -> rx_urb ) || ( ! catc -> irq_urb ) ) { //<S2SV> dev_err ( & intf -> dev , "No<S2SV_blank>free<S2SV_blank>urbs<S2SV_blank>available.\\n" ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto fail_free ; //<S2SV> } //<S2SV> if ( le16_to_cpu ( usbdev -> descriptor . idVendor ) == 0x0423 && //<S2SV> le16_to_cpu ( usbdev -> descriptor . idProduct ) == 0xa && //<S2SV> le16_to_cpu ( catc -> usbdev -> descriptor . bcdDevice ) == 0x0130 ) { //<S2SV> dev_dbg ( dev , "Testing<S2SV_blank>for<S2SV_blank>f5u011\\n" ) ; //<S2SV> catc -> is_f5u011 = 1 ; //<S2SV> atomic_set ( & catc -> recq_sz , 0 ) ; //<S2SV> pktsz = RX_PKT_SZ ; //<S2SV> } else { //<S2SV> pktsz = RX_MAX_BURST * ( PKT_SZ + 2 ) ; //<S2SV> } //<S2SV> usb_fill_control_urb ( catc -> ctrl_urb , usbdev , usb_sndctrlpipe ( usbdev , 0 ) , //<S2SV> NULL , NULL , 0 , catc_ctrl_done , catc ) ; //<S2SV> usb_fill_bulk_urb ( catc -> tx_urb , usbdev , usb_sndbulkpipe ( usbdev , 1 ) , //<S2SV> NULL , 0 , catc_tx_done , catc ) ; //<S2SV> usb_fill_bulk_urb ( catc -> rx_urb , usbdev , usb_rcvbulkpipe ( usbdev , 1 ) , //<S2SV> catc -> rx_buf , pktsz , catc_rx_done , catc ) ; //<S2SV> usb_fill_int_urb ( catc -> irq_urb , usbdev , usb_rcvintpipe ( usbdev , 2 ) , //<S2SV> catc -> irq_buf , 2 , catc_irq_done , catc , 1 ) ; //<S2SV> if ( ! catc -> is_f5u011 ) { //<S2SV> u32 * buf ; //<S2SV> int i ; //<S2SV> dev_dbg ( dev , "Checking<S2SV_blank>memory<S2SV_blank>size\\n" ) ; //<S2SV> buf = kmalloc ( 4 , GFP_KERNEL ) ; //<S2SV> if ( ! buf ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto fail_free ; //<S2SV> } //<S2SV> * buf = 0x12345678 ; //<S2SV> catc_write_mem ( catc , 0x7a80 , buf , 4 ) ; //<S2SV> * buf = 0x87654321 ; //<S2SV> catc_write_mem ( catc , 0xfa80 , buf , 4 ) ; //<S2SV> catc_read_mem ( catc , 0x7a80 , buf , 4 ) ; //<S2SV> switch ( * buf ) { //<S2SV> case 0x12345678 : //<S2SV> catc_set_reg ( catc , TxBufCount , 8 ) ; //<S2SV> catc_set_reg ( catc , RxBufCount , 32 ) ; //<S2SV> dev_dbg ( dev , "64k<S2SV_blank>Memory\\n" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> dev_warn ( & intf -> dev , //<S2SV> "Couldn\'t<S2SV_blank>detect<S2SV_blank>memory<S2SV_blank>size,<S2SV_blank>assuming<S2SV_blank>32k\\n" ) ; //<S2SV> case 0x87654321 : //<S2SV> catc_set_reg ( catc , TxBufCount , 4 ) ; //<S2SV> catc_set_reg ( catc , RxBufCount , 16 ) ; //<S2SV> dev_dbg ( dev , "32k<S2SV_blank>Memory\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> kfree ( buf ) ; //<S2SV> dev_dbg ( dev , "Getting<S2SV_blank>MAC<S2SV_blank>from<S2SV_blank>SEEROM.\\n" ) ; //<S2SV> catc_get_mac ( catc , netdev -> dev_addr ) ; //<S2SV> dev_dbg ( dev , "Setting<S2SV_blank>MAC<S2SV_blank>into<S2SV_blank>registers.\\n" ) ; //<S2SV> for ( i = 0 ; i < 6 ; i ++ ) //<S2SV> catc_set_reg ( catc , StationAddr0 - i , netdev -> dev_addr [ i ] ) ; //<S2SV> dev_dbg ( dev , "Filling<S2SV_blank>the<S2SV_blank>multicast<S2SV_blank>list.\\n" ) ; //<S2SV> eth_broadcast_addr ( broadcast ) ; //<S2SV> catc_multicast ( broadcast , catc -> multicast ) ; //<S2SV> catc_multicast ( netdev -> dev_addr , catc -> multicast ) ; //<S2SV> catc_write_mem ( catc , 0xfa80 , catc -> multicast , 64 ) ; //<S2SV> dev_dbg ( dev , "Clearing<S2SV_blank>error<S2SV_blank>counters.\\n" ) ; //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> catc_set_reg ( catc , EthStats + i , 0 ) ; //<S2SV> catc -> last_stats = jiffies ; //<S2SV> dev_dbg ( dev , "Enabling.\\n" ) ; //<S2SV> catc_set_reg ( catc , MaxBurst , RX_MAX_BURST ) ; //<S2SV> catc_set_reg ( catc , OpModes , OpTxMerge | OpRxMerge | OpLenInclude | Op3MemWaits ) ; //<S2SV> catc_set_reg ( catc , LEDCtrl , LEDLink ) ; //<S2SV> catc_set_reg ( catc , RxUnit , RxEnable | RxPolarity | RxMultiCast ) ; //<S2SV> } else { //<S2SV> dev_dbg ( dev , "Performing<S2SV_blank>reset\\n" ) ; //<S2SV> catc_reset ( catc ) ; //<S2SV> catc_get_mac ( catc , netdev -> dev_addr ) ; //<S2SV> dev_dbg ( dev , "Setting<S2SV_blank>RX<S2SV_blank>Mode\\n" ) ; //<S2SV> catc -> rxmode [ 0 ] = RxEnable | RxPolarity | RxMultiCast ; //<S2SV> catc -> rxmode [ 1 ] = 0 ; //<S2SV> f5u011_rxmode ( catc , catc -> rxmode ) ; //<S2SV> } //<S2SV> dev_dbg ( dev , "Init<S2SV_blank>done.\\n" ) ; //<S2SV> printk ( KERN_INFO "%s:<S2SV_blank>%s<S2SV_blank>USB<S2SV_blank>Ethernet<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%pM.\\n" , //<S2SV> netdev -> name , ( catc -> is_f5u011 ) ? "Belkin<S2SV_blank>F5U011" : "CATC<S2SV_blank>EL1210A<S2SV_blank>NetMate" , //<S2SV> usbdev -> bus -> bus_name , usbdev -> devpath , netdev -> dev_addr ) ; //<S2SV> usb_set_intfdata ( intf , catc ) ; //<S2SV> SET_NETDEV_DEV ( netdev , & intf -> dev ) ; //<S2SV> ret = register_netdev ( netdev ) ; //<S2SV> if ( ret ) //<S2SV> goto fail_clear_intfdata ; //<S2SV> return 0 ; //<S2SV> fail_clear_intfdata : //<S2SV> usb_set_intfdata ( intf , NULL ) ; //<S2SV> fail_free : //<S2SV> usb_free_urb ( catc -> ctrl_urb ) ; //<S2SV> usb_free_urb ( catc -> tx_urb ) ; //<S2SV> usb_free_urb ( catc -> rx_urb ) ; //<S2SV> usb_free_urb ( catc -> irq_urb ) ; //<S2SV> free_netdev ( netdev ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 