static int sctp_init_sock ( struct sock * sk ) //<S2SV> { //<S2SV> struct net * net = sock_net ( sk ) ; //<S2SV> struct sctp_sock * sp ; //<S2SV> pr_debug ( "%s:<S2SV_blank>sk:%p\\n" , __func__ , sk ) ; //<S2SV> sp = sctp_sk ( sk ) ; //<S2SV> switch ( sk -> sk_type ) { //<S2SV> case SOCK_SEQPACKET : //<S2SV> sp -> type = SCTP_SOCKET_UDP ; //<S2SV> break ; //<S2SV> case SOCK_STREAM : //<S2SV> sp -> type = SCTP_SOCKET_TCP ; //<S2SV> break ; //<S2SV> default : //<S2SV> return - ESOCKTNOSUPPORT ; //<S2SV> } //<S2SV> sp -> default_stream = 0 ; //<S2SV> sp -> default_ppid = 0 ; //<S2SV> sp -> default_flags = 0 ; //<S2SV> sp -> default_context = 0 ; //<S2SV> sp -> default_timetolive = 0 ; //<S2SV> sp -> default_rcv_context = 0 ; //<S2SV> sp -> max_burst = net -> sctp . max_burst ; //<S2SV> sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; //<S2SV> sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; //<S2SV> sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; //<S2SV> sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; //<S2SV> sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; //<S2SV> sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; //<S2SV> sp -> rtoinfo . srto_max = net -> sctp . rto_max ; //<S2SV> sp -> rtoinfo . srto_min = net -> sctp . rto_min ; //<S2SV> sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; //<S2SV> sp -> assocparams . sasoc_number_peer_destinations = 0 ; //<S2SV> sp -> assocparams . sasoc_peer_rwnd = 0 ; //<S2SV> sp -> assocparams . sasoc_local_rwnd = 0 ; //<S2SV> sp -> assocparams . sasoc_cookie_life = net -> sctp . valid_cookie_life ; //<S2SV> memset ( & sp -> subscribe , 0 , sizeof ( struct sctp_event_subscribe ) ) ; //<S2SV> sp -> hbinterval = net -> sctp . hb_interval ; //<S2SV> sp -> pathmaxrxt = net -> sctp . max_retrans_path ; //<S2SV> sp -> pathmtu = 0 ; //<S2SV> sp -> sackdelay = net -> sctp . sack_timeout ; //<S2SV> sp -> sackfreq = 2 ; //<S2SV> sp -> param_flags = SPP_HB_ENABLE | //<S2SV> SPP_PMTUD_ENABLE | //<S2SV> SPP_SACKDELAY_ENABLE ; //<S2SV> sp -> disable_fragments = 0 ; //<S2SV> sp -> nodelay = 0 ; //<S2SV> sp -> recvrcvinfo = 0 ; //<S2SV> sp -> recvnxtinfo = 0 ; //<S2SV> sp -> v4mapped = 1 ; //<S2SV> sp -> autoclose = 0 ; //<S2SV> sp -> user_frag = 0 ; //<S2SV> sp -> adaptation_ind = 0 ; //<S2SV> sp -> pf = sctp_get_pf_specific ( sk -> sk_family ) ; //<S2SV> atomic_set ( & sp -> pd_mode , 0 ) ; //<S2SV> skb_queue_head_init ( & sp -> pd_lobby ) ; //<S2SV> sp -> frag_interleave = 0 ; //<S2SV> sp -> ep = sctp_endpoint_new ( sk , GFP_KERNEL ) ; //<S2SV> if ( ! sp -> ep ) //<S2SV> return - ENOMEM ; //<S2SV> sp -> hmac = NULL ; //<S2SV> sk -> sk_destruct = sctp_destruct_sock ; //<S2SV> SCTP_DBG_OBJCNT_INC ( sock ) ; //<S2SV> local_bh_disable ( ) ; //<S2SV> percpu_counter_inc ( & sctp_sockets_allocated ) ; //<S2SV> sock_prot_inuse_add ( net , sk -> sk_prot , 1 ) ; //<S2SV> if ( net -> sctp . default_auto_asconf ) { //<S2SV> spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; //<S2SV> list_add_tail ( & sp -> auto_asconf_list , //<S2SV> & net -> sctp . auto_asconf_splist ) ; //<S2SV> sp -> do_auto_asconf = 1 ; //<S2SV> spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; //<S2SV> } else { //<S2SV> sp -> do_auto_asconf = 0 ; //<S2SV> } //<S2SV> local_bh_enable ( ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 