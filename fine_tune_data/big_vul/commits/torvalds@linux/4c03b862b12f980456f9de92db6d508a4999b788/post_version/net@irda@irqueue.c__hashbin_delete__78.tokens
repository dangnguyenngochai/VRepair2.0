int hashbin_delete ( hashbin_t * hashbin , FREE_FUNC free_func ) //<S2SV> { //<S2SV> irda_queue_t * queue ; //<S2SV> unsigned long flags = 0 ; //<S2SV> int i ; //<S2SV> IRDA_ASSERT ( hashbin != NULL , return - 1 ; ) ; //<S2SV> IRDA_ASSERT ( hashbin -> magic == HB_MAGIC , return - 1 ; ) ; //<S2SV> if ( hashbin -> hb_type & HB_LOCK ) //<S2SV> spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; //<S2SV> for ( i = 0 ; i < HASHBIN_SIZE ; i ++ ) { //<S2SV> while ( 1 ) { //<S2SV> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; //<S2SV> if ( ! queue ) //<S2SV> break ; //<S2SV> if ( free_func ) { //<S2SV> if ( hashbin -> hb_type & HB_LOCK ) //<S2SV> spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; //<S2SV> free_func ( queue ) ; //<S2SV> if ( hashbin -> hb_type & HB_LOCK ) //<S2SV> spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> hashbin -> hb_current = NULL ; //<S2SV> hashbin -> magic = ~ HB_MAGIC ; //<S2SV> if ( hashbin -> hb_type & HB_LOCK ) //<S2SV> spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; //<S2SV> kfree ( hashbin ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 