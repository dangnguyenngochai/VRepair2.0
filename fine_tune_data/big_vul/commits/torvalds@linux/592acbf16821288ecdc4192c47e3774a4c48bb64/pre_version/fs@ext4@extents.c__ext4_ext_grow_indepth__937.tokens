static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , //<S2SV> unsigned int flags ) //<S2SV> { //<S2SV> struct ext4_extent_header * neh ; //<S2SV> struct buffer_head * bh ; //<S2SV> ext4_fsblk_t newblock , goal = 0 ; //<S2SV> struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; //<S2SV> int err = 0 ; //<S2SV> if ( ext_depth ( inode ) ) //<S2SV> goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; //<S2SV> if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { //<S2SV> flags |= EXT4_MB_HINT_TRY_GOAL ; //<S2SV> goal -- ; //<S2SV> } else //<S2SV> goal = ext4_inode_to_goal_block ( inode ) ; //<S2SV> newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , //<S2SV> NULL , & err ) ; //<S2SV> if ( newblock == 0 ) //<S2SV> return err ; //<S2SV> bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; //<S2SV> if ( unlikely ( ! bh ) ) //<S2SV> return - ENOMEM ; //<S2SV> lock_buffer ( bh ) ; //<S2SV> err = ext4_journal_get_create_access ( handle , bh ) ; //<S2SV> if ( err ) { //<S2SV> unlock_buffer ( bh ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , //<S2SV> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; //<S2SV> neh = ext_block_hdr ( bh ) ; //<S2SV> if ( ext_depth ( inode ) ) //<S2SV> neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; //<S2SV> else //<S2SV> neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; //<S2SV> neh -> eh_magic = EXT4_EXT_MAGIC ; //<S2SV> ext4_extent_block_csum_set ( inode , neh ) ; //<S2SV> set_buffer_uptodate ( bh ) ; //<S2SV> unlock_buffer ( bh ) ; //<S2SV> err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> neh = ext_inode_hdr ( inode ) ; //<S2SV> neh -> eh_entries = cpu_to_le16 ( 1 ) ; //<S2SV> ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; //<S2SV> if ( neh -> eh_depth == 0 ) { //<S2SV> neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; //<S2SV> EXT_FIRST_INDEX ( neh ) -> ei_block = //<S2SV> EXT_FIRST_EXTENT ( neh ) -> ee_block ; //<S2SV> } //<S2SV> ext_debug ( "new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n" , //<S2SV> le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , //<S2SV> le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , //<S2SV> ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; //<S2SV> le16_add_cpu ( & neh -> eh_depth , 1 ) ; //<S2SV> ext4_mark_inode_dirty ( handle , inode ) ; //<S2SV> out : //<S2SV> brelse ( bh ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 