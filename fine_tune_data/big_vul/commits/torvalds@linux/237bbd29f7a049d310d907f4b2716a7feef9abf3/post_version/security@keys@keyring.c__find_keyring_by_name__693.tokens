struct key * find_keyring_by_name ( const char * name , bool uid_keyring ) //<S2SV> { //<S2SV> struct key * keyring ; //<S2SV> int bucket ; //<S2SV> if ( ! name ) //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> bucket = keyring_hash ( name ) ; //<S2SV> read_lock ( & keyring_name_lock ) ; //<S2SV> if ( keyring_name_hash [ bucket ] . next ) { //<S2SV> list_for_each_entry ( keyring , //<S2SV> & keyring_name_hash [ bucket ] , //<S2SV> name_link //<S2SV> ) { //<S2SV> if ( ! kuid_has_mapping ( current_user_ns ( ) , keyring -> user -> uid ) ) //<S2SV> continue ; //<S2SV> if ( test_bit ( KEY_FLAG_REVOKED , & keyring -> flags ) ) //<S2SV> continue ; //<S2SV> if ( strcmp ( keyring -> description , name ) != 0 ) //<S2SV> continue ; //<S2SV> if ( uid_keyring ) { //<S2SV> if ( ! test_bit ( KEY_FLAG_UID_KEYRING , //<S2SV> & keyring -> flags ) ) //<S2SV> continue ; //<S2SV> } else { //<S2SV> if ( key_permission ( make_key_ref ( keyring , 0 ) , //<S2SV> KEY_NEED_SEARCH ) < 0 ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) //<S2SV> continue ; //<S2SV> keyring -> last_used_at = current_kernel_time ( ) . tv_sec ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> keyring = ERR_PTR ( - ENOKEY ) ; //<S2SV> out : //<S2SV> read_unlock ( & keyring_name_lock ) ; //<S2SV> return keyring ; //<S2SV> } //<S2SV> 