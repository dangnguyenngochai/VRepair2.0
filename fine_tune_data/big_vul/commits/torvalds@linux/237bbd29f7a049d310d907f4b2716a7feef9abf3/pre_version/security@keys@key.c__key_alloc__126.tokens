struct key * key_alloc ( struct key_type * type , const char * desc , //<S2SV> kuid_t uid , kgid_t gid , const struct cred * cred , //<S2SV> key_perm_t perm , unsigned long flags , //<S2SV> struct key_restriction * restrict_link ) //<S2SV> { //<S2SV> struct key_user * user = NULL ; //<S2SV> struct key * key ; //<S2SV> size_t desclen , quotalen ; //<S2SV> int ret ; //<S2SV> key = ERR_PTR ( - EINVAL ) ; //<S2SV> if ( ! desc || ! * desc ) //<S2SV> goto error ; //<S2SV> if ( type -> vet_description ) { //<S2SV> ret = type -> vet_description ( desc ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> key = ERR_PTR ( ret ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> } //<S2SV> desclen = strlen ( desc ) ; //<S2SV> quotalen = desclen + 1 + type -> def_datalen ; //<S2SV> user = key_user_lookup ( uid ) ; //<S2SV> if ( ! user ) //<S2SV> goto no_memory_1 ; //<S2SV> if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { //<S2SV> unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? //<S2SV> key_quota_root_maxkeys : key_quota_maxkeys ; //<S2SV> unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? //<S2SV> key_quota_root_maxbytes : key_quota_maxbytes ; //<S2SV> spin_lock ( & user -> lock ) ; //<S2SV> if ( ! ( flags & KEY_ALLOC_QUOTA_OVERRUN ) ) { //<S2SV> if ( user -> qnkeys + 1 >= maxkeys || //<S2SV> user -> qnbytes + quotalen >= maxbytes || //<S2SV> user -> qnbytes + quotalen < user -> qnbytes ) //<S2SV> goto no_quota ; //<S2SV> } //<S2SV> user -> qnkeys ++ ; //<S2SV> user -> qnbytes += quotalen ; //<S2SV> spin_unlock ( & user -> lock ) ; //<S2SV> } //<S2SV> key = kmem_cache_zalloc ( key_jar , GFP_KERNEL ) ; //<S2SV> if ( ! key ) //<S2SV> goto no_memory_2 ; //<S2SV> key -> index_key . desc_len = desclen ; //<S2SV> key -> index_key . description = kmemdup ( desc , desclen + 1 , GFP_KERNEL ) ; //<S2SV> if ( ! key -> index_key . description ) //<S2SV> goto no_memory_3 ; //<S2SV> refcount_set ( & key -> usage , 1 ) ; //<S2SV> init_rwsem ( & key -> sem ) ; //<S2SV> lockdep_set_class ( & key -> sem , & type -> lock_class ) ; //<S2SV> key -> index_key . type = type ; //<S2SV> key -> user = user ; //<S2SV> key -> quotalen = quotalen ; //<S2SV> key -> datalen = type -> def_datalen ; //<S2SV> key -> uid = uid ; //<S2SV> key -> gid = gid ; //<S2SV> key -> perm = perm ; //<S2SV> key -> restrict_link = restrict_link ; //<S2SV> if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) //<S2SV> key -> flags |= 1 << KEY_FLAG_IN_QUOTA ; //<S2SV> if ( flags & KEY_ALLOC_BUILT_IN ) //<S2SV> key -> flags |= 1 << KEY_FLAG_BUILTIN ; //<S2SV> # ifdef KEY_DEBUGGING //<S2SV> key -> magic = KEY_DEBUG_MAGIC ; //<S2SV> # endif //<S2SV> ret = security_key_alloc ( key , cred , flags ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto security_error ; //<S2SV> atomic_inc ( & user -> nkeys ) ; //<S2SV> key_alloc_serial ( key ) ; //<S2SV> error : //<S2SV> return key ; //<S2SV> security_error : //<S2SV> kfree ( key -> description ) ; //<S2SV> kmem_cache_free ( key_jar , key ) ; //<S2SV> if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { //<S2SV> spin_lock ( & user -> lock ) ; //<S2SV> user -> qnkeys -- ; //<S2SV> user -> qnbytes -= quotalen ; //<S2SV> spin_unlock ( & user -> lock ) ; //<S2SV> } //<S2SV> key_user_put ( user ) ; //<S2SV> key = ERR_PTR ( ret ) ; //<S2SV> goto error ; //<S2SV> no_memory_3 : //<S2SV> kmem_cache_free ( key_jar , key ) ; //<S2SV> no_memory_2 : //<S2SV> if ( ! ( flags & KEY_ALLOC_NOT_IN_QUOTA ) ) { //<S2SV> spin_lock ( & user -> lock ) ; //<S2SV> user -> qnkeys -- ; //<S2SV> user -> qnbytes -= quotalen ; //<S2SV> spin_unlock ( & user -> lock ) ; //<S2SV> } //<S2SV> key_user_put ( user ) ; //<S2SV> no_memory_1 : //<S2SV> key = ERR_PTR ( - ENOMEM ) ; //<S2SV> goto error ; //<S2SV> no_quota : //<S2SV> spin_unlock ( & user -> lock ) ; //<S2SV> key_user_put ( user ) ; //<S2SV> key = ERR_PTR ( - EDQUOT ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> 