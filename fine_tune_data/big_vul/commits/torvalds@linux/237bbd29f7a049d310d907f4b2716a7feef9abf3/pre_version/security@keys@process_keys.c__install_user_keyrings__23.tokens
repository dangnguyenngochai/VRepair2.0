int install_user_keyrings ( void ) //<S2SV> { //<S2SV> struct user_struct * user ; //<S2SV> const struct cred * cred ; //<S2SV> struct key * uid_keyring , * session_keyring ; //<S2SV> key_perm_t user_keyring_perm ; //<S2SV> char buf [ 20 ] ; //<S2SV> int ret ; //<S2SV> uid_t uid ; //<S2SV> user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; //<S2SV> cred = current_cred ( ) ; //<S2SV> user = cred -> user ; //<S2SV> uid = from_kuid ( cred -> user_ns , user -> uid ) ; //<S2SV> kenter ( "%p{%u}" , user , uid ) ; //<S2SV> if ( user -> uid_keyring && user -> session_keyring ) { //<S2SV> kleave ( "<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> mutex_lock ( & key_user_keyring_mutex ) ; //<S2SV> ret = 0 ; //<S2SV> if ( ! user -> uid_keyring ) { //<S2SV> sprintf ( buf , "_uid.%u" , uid ) ; //<S2SV> uid_keyring = find_keyring_by_name ( buf , true ) ; //<S2SV> if ( IS_ERR ( uid_keyring ) ) { //<S2SV> uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , //<S2SV> cred , user_keyring_perm , //<S2SV> KEY_ALLOC_IN_QUOTA , //<S2SV> NULL , NULL ) ; //<S2SV> if ( IS_ERR ( uid_keyring ) ) { //<S2SV> ret = PTR_ERR ( uid_keyring ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> } //<S2SV> sprintf ( buf , "_uid_ses.%u" , uid ) ; //<S2SV> session_keyring = find_keyring_by_name ( buf , true ) ; //<S2SV> if ( IS_ERR ( session_keyring ) ) { //<S2SV> session_keyring = //<S2SV> keyring_alloc ( buf , user -> uid , INVALID_GID , //<S2SV> cred , user_keyring_perm , //<S2SV> KEY_ALLOC_IN_QUOTA , //<S2SV> NULL , NULL ) ; //<S2SV> if ( IS_ERR ( session_keyring ) ) { //<S2SV> ret = PTR_ERR ( session_keyring ) ; //<S2SV> goto error_release ; //<S2SV> } //<S2SV> ret = key_link ( session_keyring , uid_keyring ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto error_release_both ; //<S2SV> } //<S2SV> user -> uid_keyring = uid_keyring ; //<S2SV> user -> session_keyring = session_keyring ; //<S2SV> } //<S2SV> mutex_unlock ( & key_user_keyring_mutex ) ; //<S2SV> kleave ( "<S2SV_blank>=<S2SV_blank>0" ) ; //<S2SV> return 0 ; //<S2SV> error_release_both : //<S2SV> key_put ( session_keyring ) ; //<S2SV> error_release : //<S2SV> key_put ( uid_keyring ) ; //<S2SV> error : //<S2SV> mutex_unlock ( & key_user_keyring_mutex ) ; //<S2SV> kleave ( "<S2SV_blank>=<S2SV_blank>%d" , ret ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 