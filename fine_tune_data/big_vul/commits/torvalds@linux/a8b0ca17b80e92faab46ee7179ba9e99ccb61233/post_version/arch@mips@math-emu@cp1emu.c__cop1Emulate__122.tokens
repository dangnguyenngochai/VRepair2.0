static int cop1Emulate ( struct pt_regs * xcp , struct mips_fpu_struct * ctx , //<S2SV> void * __user * fault_addr ) //<S2SV> { //<S2SV> mips_instruction ir ; //<S2SV> unsigned long emulpc , contpc ; //<S2SV> unsigned int cond ; //<S2SV> if ( ! access_ok ( VERIFY_READ , xcp -> cp0_epc , sizeof ( mips_instruction ) ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; //<S2SV> return SIGBUS ; //<S2SV> } //<S2SV> if ( __get_user ( ir , ( mips_instruction __user * ) xcp -> cp0_epc ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; //<S2SV> return SIGSEGV ; //<S2SV> } //<S2SV> if ( ( xcp -> cp0_cause & CAUSEF_BD ) && ! isBranchInstr ( & ir ) ) //<S2SV> xcp -> cp0_cause &= ~ CAUSEF_BD ; //<S2SV> if ( xcp -> cp0_cause & CAUSEF_BD ) { //<S2SV> emulpc = xcp -> cp0_epc + 4 ; //<S2SV> if ( __compute_return_epc ( xcp ) ) { //<S2SV> # ifdef CP1DBG //<S2SV> printk ( "failed<S2SV_blank>to<S2SV_blank>emulate<S2SV_blank>branch<S2SV_blank>at<S2SV_blank>%p\\n" , //<S2SV> ( void * ) ( xcp -> cp0_epc ) ) ; //<S2SV> # endif //<S2SV> return SIGILL ; //<S2SV> } //<S2SV> if ( ! access_ok ( VERIFY_READ , emulpc , sizeof ( mips_instruction ) ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = ( mips_instruction __user * ) emulpc ; //<S2SV> return SIGBUS ; //<S2SV> } //<S2SV> if ( __get_user ( ir , ( mips_instruction __user * ) emulpc ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = ( mips_instruction __user * ) emulpc ; //<S2SV> return SIGSEGV ; //<S2SV> } //<S2SV> contpc = xcp -> cp0_epc ; //<S2SV> xcp -> cp0_epc = emulpc - 4 ; //<S2SV> } else { //<S2SV> emulpc = xcp -> cp0_epc ; //<S2SV> contpc = xcp -> cp0_epc + 4 ; //<S2SV> } //<S2SV> emul : //<S2SV> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , xcp , 0 ) ; //<S2SV> MIPS_FPU_EMU_INC_STATS ( emulated ) ; //<S2SV> switch ( MIPSInst_OPCODE ( ir ) ) { //<S2SV> case ldc1_op : { //<S2SV> u64 __user * va = ( u64 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + //<S2SV> MIPSInst_SIMM ( ir ) ) ; //<S2SV> u64 val ; //<S2SV> MIPS_FPU_EMU_INC_STATS ( loads ) ; //<S2SV> if ( ! access_ok ( VERIFY_READ , va , sizeof ( u64 ) ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = va ; //<S2SV> return SIGBUS ; //<S2SV> } //<S2SV> if ( __get_user ( val , va ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = va ; //<S2SV> return SIGSEGV ; //<S2SV> } //<S2SV> DITOREG ( val , MIPSInst_RT ( ir ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case sdc1_op : { //<S2SV> u64 __user * va = ( u64 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + //<S2SV> MIPSInst_SIMM ( ir ) ) ; //<S2SV> u64 val ; //<S2SV> MIPS_FPU_EMU_INC_STATS ( stores ) ; //<S2SV> DIFROMREG ( val , MIPSInst_RT ( ir ) ) ; //<S2SV> if ( ! access_ok ( VERIFY_WRITE , va , sizeof ( u64 ) ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = va ; //<S2SV> return SIGBUS ; //<S2SV> } //<S2SV> if ( __put_user ( val , va ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = va ; //<S2SV> return SIGSEGV ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case lwc1_op : { //<S2SV> u32 __user * va = ( u32 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + //<S2SV> MIPSInst_SIMM ( ir ) ) ; //<S2SV> u32 val ; //<S2SV> MIPS_FPU_EMU_INC_STATS ( loads ) ; //<S2SV> if ( ! access_ok ( VERIFY_READ , va , sizeof ( u32 ) ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = va ; //<S2SV> return SIGBUS ; //<S2SV> } //<S2SV> if ( __get_user ( val , va ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = va ; //<S2SV> return SIGSEGV ; //<S2SV> } //<S2SV> SITOREG ( val , MIPSInst_RT ( ir ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case swc1_op : { //<S2SV> u32 __user * va = ( u32 __user * ) ( xcp -> regs [ MIPSInst_RS ( ir ) ] + //<S2SV> MIPSInst_SIMM ( ir ) ) ; //<S2SV> u32 val ; //<S2SV> MIPS_FPU_EMU_INC_STATS ( stores ) ; //<S2SV> SIFROMREG ( val , MIPSInst_RT ( ir ) ) ; //<S2SV> if ( ! access_ok ( VERIFY_WRITE , va , sizeof ( u32 ) ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = va ; //<S2SV> return SIGBUS ; //<S2SV> } //<S2SV> if ( __put_user ( val , va ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = va ; //<S2SV> return SIGSEGV ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case cop1_op : //<S2SV> switch ( MIPSInst_RS ( ir ) ) { //<S2SV> # if defined ( __mips64 ) //<S2SV> case dmfc_op : //<S2SV> if ( MIPSInst_RT ( ir ) != 0 ) { //<S2SV> DIFROMREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , //<S2SV> MIPSInst_RD ( ir ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case dmtc_op : //<S2SV> DITOREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case mfc_op : //<S2SV> if ( MIPSInst_RT ( ir ) != 0 ) { //<S2SV> SIFROMREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , //<S2SV> MIPSInst_RD ( ir ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case mtc_op : //<S2SV> SITOREG ( xcp -> regs [ MIPSInst_RT ( ir ) ] , MIPSInst_RD ( ir ) ) ; //<S2SV> break ; //<S2SV> case cfc_op : { //<S2SV> u32 value ; //<S2SV> if ( MIPSInst_RD ( ir ) == FPCREG_CSR ) { //<S2SV> value = ctx -> fcr31 ; //<S2SV> value = ( value & ~ FPU_CSR_RM ) | //<S2SV> mips_rm [ modeindex ( value ) ] ; //<S2SV> # ifdef CSRTRACE //<S2SV> printk ( "%p<S2SV_blank>gpr[%d]<-csr=%08x\\n" , //<S2SV> ( void * ) ( xcp -> cp0_epc ) , //<S2SV> MIPSInst_RT ( ir ) , value ) ; //<S2SV> # endif //<S2SV> } //<S2SV> else if ( MIPSInst_RD ( ir ) == FPCREG_RID ) //<S2SV> value = 0 ; //<S2SV> else //<S2SV> value = 0 ; //<S2SV> if ( MIPSInst_RT ( ir ) ) //<S2SV> xcp -> regs [ MIPSInst_RT ( ir ) ] = value ; //<S2SV> break ; //<S2SV> } //<S2SV> case ctc_op : { //<S2SV> u32 value ; //<S2SV> if ( MIPSInst_RT ( ir ) == 0 ) //<S2SV> value = 0 ; //<S2SV> else //<S2SV> value = xcp -> regs [ MIPSInst_RT ( ir ) ] ; //<S2SV> if ( MIPSInst_RD ( ir ) == FPCREG_CSR ) { //<S2SV> # ifdef CSRTRACE //<S2SV> printk ( "%p<S2SV_blank>gpr[%d]->csr=%08x\\n" , //<S2SV> ( void * ) ( xcp -> cp0_epc ) , //<S2SV> MIPSInst_RT ( ir ) , value ) ; //<S2SV> # endif //<S2SV> ctx -> fcr31 = ( value & //<S2SV> ~ ( FPU_CSR_RSVD | FPU_CSR_RM ) ) | //<S2SV> ieee_rm [ modeindex ( value ) ] ; //<S2SV> } //<S2SV> if ( ( ctx -> fcr31 >> 5 ) & ctx -> fcr31 & FPU_CSR_ALL_E ) { //<S2SV> return SIGFPE ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case bc_op : { //<S2SV> int likely = 0 ; //<S2SV> if ( xcp -> cp0_cause & CAUSEF_BD ) //<S2SV> return SIGILL ; //<S2SV> # if __mips >= 4 //<S2SV> cond = ctx -> fcr31 & fpucondbit [ MIPSInst_RT ( ir ) >> 2 ] ; //<S2SV> # else //<S2SV> cond = ctx -> fcr31 & FPU_CSR_COND ; //<S2SV> # endif //<S2SV> switch ( MIPSInst_RT ( ir ) & 3 ) { //<S2SV> case bcfl_op : //<S2SV> likely = 1 ; //<S2SV> case bcf_op : //<S2SV> cond = ! cond ; //<S2SV> break ; //<S2SV> case bctl_op : //<S2SV> likely = 1 ; //<S2SV> case bct_op : //<S2SV> break ; //<S2SV> default : //<S2SV> return SIGILL ; //<S2SV> } //<S2SV> xcp -> cp0_cause |= CAUSEF_BD ; //<S2SV> if ( cond ) { //<S2SV> xcp -> cp0_epc += 4 ; //<S2SV> contpc = ( xcp -> cp0_epc + //<S2SV> ( MIPSInst_SIMM ( ir ) << 2 ) ) ; //<S2SV> if ( ! access_ok ( VERIFY_READ , xcp -> cp0_epc , //<S2SV> sizeof ( mips_instruction ) ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; //<S2SV> return SIGBUS ; //<S2SV> } //<S2SV> if ( __get_user ( ir , //<S2SV> ( mips_instruction __user * ) xcp -> cp0_epc ) ) { //<S2SV> MIPS_FPU_EMU_INC_STATS ( errors ) ; //<S2SV> * fault_addr = ( mips_instruction __user * ) xcp -> cp0_epc ; //<S2SV> return SIGSEGV ; //<S2SV> } //<S2SV> switch ( MIPSInst_OPCODE ( ir ) ) { //<S2SV> case lwc1_op : //<S2SV> case swc1_op : //<S2SV> # if ( __mips >= 2 || defined ( __mips64 ) ) //<S2SV> case ldc1_op : //<S2SV> case sdc1_op : //<S2SV> # endif //<S2SV> case cop1_op : //<S2SV> # if __mips >= 4 && __mips != 32 //<S2SV> case cop1x_op : //<S2SV> # endif //<S2SV> goto emul ; //<S2SV> # if __mips >= 4 //<S2SV> case spec_op : //<S2SV> if ( MIPSInst_FUNC ( ir ) == movc_op ) //<S2SV> goto emul ; //<S2SV> break ; //<S2SV> # endif //<S2SV> } //<S2SV> return mips_dsemul ( xcp , ir , contpc ) ; //<S2SV> } //<S2SV> else { //<S2SV> if ( likely ) { //<S2SV> xcp -> cp0_epc += 4 ; //<S2SV> contpc += 4 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> if ( ! ( MIPSInst_RS ( ir ) & 0x10 ) ) //<S2SV> return SIGILL ; //<S2SV> { //<S2SV> int sig ; //<S2SV> if ( ( sig = fpu_emu ( xcp , ctx , ir ) ) ) //<S2SV> return sig ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> # if __mips >= 4 && __mips != 32 //<S2SV> case cop1x_op : { //<S2SV> int sig = fpux_emu ( xcp , ctx , ir , fault_addr ) ; //<S2SV> if ( sig ) //<S2SV> return sig ; //<S2SV> break ; //<S2SV> } //<S2SV> # endif //<S2SV> # if __mips >= 4 //<S2SV> case spec_op : //<S2SV> if ( MIPSInst_FUNC ( ir ) != movc_op ) //<S2SV> return SIGILL ; //<S2SV> cond = fpucondbit [ MIPSInst_RT ( ir ) >> 2 ] ; //<S2SV> if ( ( ( ctx -> fcr31 & cond ) != 0 ) == ( ( MIPSInst_RT ( ir ) & 1 ) != 0 ) ) //<S2SV> xcp -> regs [ MIPSInst_RD ( ir ) ] = //<S2SV> xcp -> regs [ MIPSInst_RS ( ir ) ] ; //<S2SV> break ; //<S2SV> # endif //<S2SV> default : //<S2SV> return SIGILL ; //<S2SV> } //<S2SV> xcp -> cp0_epc = contpc ; //<S2SV> xcp -> cp0_cause &= ~ CAUSEF_BD ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 