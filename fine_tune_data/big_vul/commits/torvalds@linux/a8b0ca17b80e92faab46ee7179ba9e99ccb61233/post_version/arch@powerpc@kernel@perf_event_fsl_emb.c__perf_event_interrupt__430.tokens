static void perf_event_interrupt ( struct pt_regs * regs ) //<S2SV> { //<S2SV> int i ; //<S2SV> struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; //<S2SV> struct perf_event * event ; //<S2SV> unsigned long val ; //<S2SV> int found = 0 ; //<S2SV> int nmi ; //<S2SV> nmi = perf_intr_is_nmi ( regs ) ; //<S2SV> if ( nmi ) //<S2SV> nmi_enter ( ) ; //<S2SV> else //<S2SV> irq_enter ( ) ; //<S2SV> for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { //<S2SV> event = cpuhw -> event [ i ] ; //<S2SV> val = read_pmc ( i ) ; //<S2SV> if ( ( int ) val < 0 ) { //<S2SV> if ( event ) { //<S2SV> found = 1 ; //<S2SV> record_and_restart ( event , val , regs ) ; //<S2SV> } else { //<S2SV> write_pmc ( i , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> mtmsr ( mfmsr ( ) | MSR_PMM ) ; //<S2SV> mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; //<S2SV> isync ( ) ; //<S2SV> if ( nmi ) //<S2SV> nmi_exit ( ) ; //<S2SV> else //<S2SV> irq_exit ( ) ; //<S2SV> } //<S2SV> 