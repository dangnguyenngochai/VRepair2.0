asmlinkage void do_ade ( struct pt_regs * regs ) //<S2SV> { //<S2SV> unsigned int __user * pc ; //<S2SV> mm_segment_t seg ; //<S2SV> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , //<S2SV> 1 , regs , regs -> cp0_badvaddr ) ; //<S2SV> if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) //<S2SV> goto sigbus ; //<S2SV> pc = ( unsigned int __user * ) exception_epc ( regs ) ; //<S2SV> if ( user_mode ( regs ) && ! test_thread_flag ( TIF_FIXADE ) ) //<S2SV> goto sigbus ; //<S2SV> if ( unaligned_action == UNALIGNED_ACTION_SIGNAL ) //<S2SV> goto sigbus ; //<S2SV> else if ( unaligned_action == UNALIGNED_ACTION_SHOW ) //<S2SV> show_registers ( regs ) ; //<S2SV> seg = get_fs ( ) ; //<S2SV> if ( ! user_mode ( regs ) ) //<S2SV> set_fs ( KERNEL_DS ) ; //<S2SV> emulate_load_store_insn ( regs , ( void __user * ) regs -> cp0_badvaddr , pc ) ; //<S2SV> set_fs ( seg ) ; //<S2SV> return ; //<S2SV> sigbus : //<S2SV> die_if_kernel ( "Kernel<S2SV_blank>unaligned<S2SV_blank>instruction<S2SV_blank>access" , regs ) ; //<S2SV> force_sig ( SIGBUS , current ) ; //<S2SV> } //<S2SV> 