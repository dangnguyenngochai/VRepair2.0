static void record_and_restart ( struct perf_event * event , unsigned long val , //<S2SV> struct pt_regs * regs ) //<S2SV> { //<S2SV> u64 period = event -> hw . sample_period ; //<S2SV> s64 prev , delta , left ; //<S2SV> int record = 0 ; //<S2SV> if ( event -> hw . state & PERF_HES_STOPPED ) { //<S2SV> write_pmc ( event -> hw . idx , 0 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> prev = local64_read ( & event -> hw . prev_count ) ; //<S2SV> delta = ( val - prev ) & 0xfffffffful ; //<S2SV> local64_add ( delta , & event -> count ) ; //<S2SV> val = 0 ; //<S2SV> left = local64_read ( & event -> hw . period_left ) - delta ; //<S2SV> if ( period ) { //<S2SV> if ( left <= 0 ) { //<S2SV> left += period ; //<S2SV> if ( left <= 0 ) //<S2SV> left = period ; //<S2SV> record = 1 ; //<S2SV> event -> hw . last_period = event -> hw . sample_period ; //<S2SV> } //<S2SV> if ( left < 0x80000000LL ) //<S2SV> val = 0x80000000LL - left ; //<S2SV> } //<S2SV> write_pmc ( event -> hw . idx , val ) ; //<S2SV> local64_set ( & event -> hw . prev_count , val ) ; //<S2SV> local64_set ( & event -> hw . period_left , left ) ; //<S2SV> perf_event_update_userpage ( event ) ; //<S2SV> if ( record ) { //<S2SV> struct perf_sample_data data ; //<S2SV> perf_sample_data_init ( & data , 0 ) ; //<S2SV> data . period = event -> hw . last_period ; //<S2SV> if ( perf_event_overflow ( event , & data , regs ) ) //<S2SV> fsl_emb_pmu_stop ( event , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> 