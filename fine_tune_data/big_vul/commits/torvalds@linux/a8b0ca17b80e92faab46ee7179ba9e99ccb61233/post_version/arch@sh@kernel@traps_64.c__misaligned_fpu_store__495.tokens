static int misaligned_fpu_store ( struct pt_regs * regs , //<S2SV> __u32 opcode , //<S2SV> int displacement_not_indexed , //<S2SV> int width_shift , //<S2SV> int do_paired_load ) //<S2SV> { //<S2SV> int error ; //<S2SV> int srcreg ; //<S2SV> __u64 address ; //<S2SV> error = generate_and_check_address ( regs , opcode , //<S2SV> displacement_not_indexed , width_shift , & address ) ; //<S2SV> if ( error < 0 ) { //<S2SV> return error ; //<S2SV> } //<S2SV> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ; //<S2SV> srcreg = ( opcode >> 4 ) & 0x3f ; //<S2SV> if ( user_mode ( regs ) ) { //<S2SV> __u64 buffer ; //<S2SV> __u32 buflo = 0xffffffffUL , bufhi = 0xffffffffUL ; //<S2SV> if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( last_task_used_math == current ) { //<S2SV> enable_fpu ( ) ; //<S2SV> save_fpu ( current ) ; //<S2SV> disable_fpu ( ) ; //<S2SV> last_task_used_math = NULL ; //<S2SV> regs -> sr |= SR_FD ; //<S2SV> } //<S2SV> switch ( width_shift ) { //<S2SV> case 2 : //<S2SV> buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> if ( do_paired_load ) { //<S2SV> buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; //<S2SV> bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; //<S2SV> } else { //<S2SV> # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) //<S2SV> bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; //<S2SV> buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; //<S2SV> # else //<S2SV> buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; //<S2SV> bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; //<S2SV> # endif //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_store,<S2SV_blank>PC=%08lx\\n" , //<S2SV> width_shift , ( unsigned long ) regs -> pc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> * ( __u32 * ) & buffer = buflo ; //<S2SV> * ( 1 + ( __u32 * ) & buffer ) = bufhi ; //<S2SV> if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } else { //<S2SV> die ( "Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel" , regs , 0 ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> 