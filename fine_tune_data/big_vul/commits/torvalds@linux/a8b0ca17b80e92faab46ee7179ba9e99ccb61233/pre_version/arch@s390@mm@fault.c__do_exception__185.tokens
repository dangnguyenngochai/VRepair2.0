static inline int do_exception ( struct pt_regs * regs , int access , //<S2SV> unsigned long trans_exc_code ) //<S2SV> { //<S2SV> struct task_struct * tsk ; //<S2SV> struct mm_struct * mm ; //<S2SV> struct vm_area_struct * vma ; //<S2SV> unsigned long address ; //<S2SV> unsigned int flags ; //<S2SV> int fault ; //<S2SV> if ( notify_page_fault ( regs ) ) //<S2SV> return 0 ; //<S2SV> tsk = current ; //<S2SV> mm = tsk -> mm ; //<S2SV> fault = VM_FAULT_BADCONTEXT ; //<S2SV> if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) //<S2SV> goto out ; //<S2SV> address = trans_exc_code & __FAIL_ADDR_MASK ; //<S2SV> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; //<S2SV> flags = FAULT_FLAG_ALLOW_RETRY ; //<S2SV> if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) //<S2SV> flags |= FAULT_FLAG_WRITE ; //<S2SV> retry : //<S2SV> down_read ( & mm -> mmap_sem ) ; //<S2SV> fault = VM_FAULT_BADMAP ; //<S2SV> vma = find_vma ( mm , address ) ; //<S2SV> if ( ! vma ) //<S2SV> goto out_up ; //<S2SV> if ( unlikely ( vma -> vm_start > address ) ) { //<S2SV> if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) //<S2SV> goto out_up ; //<S2SV> if ( expand_stack ( vma , address ) ) //<S2SV> goto out_up ; //<S2SV> } //<S2SV> fault = VM_FAULT_BADACCESS ; //<S2SV> if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) //<S2SV> goto out_up ; //<S2SV> if ( is_vm_hugetlb_page ( vma ) ) //<S2SV> address &= HPAGE_MASK ; //<S2SV> fault = handle_mm_fault ( mm , vma , address , flags ) ; //<S2SV> if ( unlikely ( fault & VM_FAULT_ERROR ) ) //<S2SV> goto out_up ; //<S2SV> if ( flags & FAULT_FLAG_ALLOW_RETRY ) { //<S2SV> if ( fault & VM_FAULT_MAJOR ) { //<S2SV> tsk -> maj_flt ++ ; //<S2SV> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , //<S2SV> regs , address ) ; //<S2SV> } else { //<S2SV> tsk -> min_flt ++ ; //<S2SV> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , //<S2SV> regs , address ) ; //<S2SV> } //<S2SV> if ( fault & VM_FAULT_RETRY ) { //<S2SV> flags &= ~ FAULT_FLAG_ALLOW_RETRY ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> } //<S2SV> clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; //<S2SV> fault = 0 ; //<S2SV> out_up : //<S2SV> up_read ( & mm -> mmap_sem ) ; //<S2SV> out : //<S2SV> return fault ; //<S2SV> } //<S2SV> 