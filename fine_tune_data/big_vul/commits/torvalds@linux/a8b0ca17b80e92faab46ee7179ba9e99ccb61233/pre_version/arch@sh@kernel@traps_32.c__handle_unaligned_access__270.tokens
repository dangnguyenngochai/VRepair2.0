int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , //<S2SV> struct mem_access * ma , int expected , //<S2SV> unsigned long address ) //<S2SV> { //<S2SV> u_int rm ; //<S2SV> int ret , index ; //<S2SV> if ( instruction_size ( instruction ) != 2 ) //<S2SV> return - EINVAL ; //<S2SV> index = ( instruction >> 8 ) & 15 ; //<S2SV> rm = regs -> regs [ index ] ; //<S2SV> if ( ! expected ) { //<S2SV> unaligned_fixups_notify ( current , instruction , regs ) ; //<S2SV> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , //<S2SV> regs , address ) ; //<S2SV> } //<S2SV> ret = - EFAULT ; //<S2SV> switch ( instruction & 0xF000 ) { //<S2SV> case 0x0000 : //<S2SV> if ( instruction == 0x000B ) { //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) //<S2SV> regs -> pc = regs -> pr ; //<S2SV> } //<S2SV> else if ( ( instruction & 0x00FF ) == 0x0023 ) { //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) //<S2SV> regs -> pc += rm + 4 ; //<S2SV> } //<S2SV> else if ( ( instruction & 0x00FF ) == 0x0003 ) { //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> regs -> pr = regs -> pc + 4 ; //<S2SV> regs -> pc += rm + 4 ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> goto simple ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0x1000 : //<S2SV> goto simple ; //<S2SV> case 0x2000 : //<S2SV> goto simple ; //<S2SV> case 0x4000 : //<S2SV> if ( ( instruction & 0x00FF ) == 0x002B ) { //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) //<S2SV> regs -> pc = rm ; //<S2SV> } //<S2SV> else if ( ( instruction & 0x00FF ) == 0x000B ) { //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> regs -> pr = regs -> pc + 4 ; //<S2SV> regs -> pc = rm ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> goto simple ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0x5000 : //<S2SV> goto simple ; //<S2SV> case 0x6000 : //<S2SV> goto simple ; //<S2SV> case 0x8000 : //<S2SV> switch ( instruction & 0x0F00 ) { //<S2SV> case 0x0100 : //<S2SV> goto simple ; //<S2SV> case 0x0500 : //<S2SV> goto simple ; //<S2SV> case 0x0B00 : //<S2SV> break ; //<S2SV> case 0x0F00 : //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) //<S2SV> if ( ( regs -> sr & 0x00000001 ) != 0 ) //<S2SV> regs -> pc += 4 ; //<S2SV> else //<S2SV> # endif //<S2SV> regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0x0900 : //<S2SV> break ; //<S2SV> case 0x0D00 : //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) //<S2SV> if ( ( regs -> sr & 0x00000001 ) == 0 ) //<S2SV> regs -> pc += 4 ; //<S2SV> else //<S2SV> # endif //<S2SV> regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0xA000 : //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) //<S2SV> regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; //<S2SV> break ; //<S2SV> case 0xB000 : //<S2SV> ret = handle_delayslot ( regs , instruction , ma ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> regs -> pr = regs -> pc + 4 ; //<S2SV> regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> return ret ; //<S2SV> simple : //<S2SV> ret = handle_unaligned_ins ( instruction , regs , ma ) ; //<S2SV> if ( ret == 0 ) //<S2SV> regs -> pc += instruction_size ( instruction ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 