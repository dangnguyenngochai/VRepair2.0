static int misaligned_load ( struct pt_regs * regs , //<S2SV> __u32 opcode , //<S2SV> int displacement_not_indexed , //<S2SV> int width_shift , //<S2SV> int do_sign_extend ) //<S2SV> { //<S2SV> int error ; //<S2SV> int destreg ; //<S2SV> __u64 address ; //<S2SV> error = generate_and_check_address ( regs , opcode , //<S2SV> displacement_not_indexed , width_shift , & address ) ; //<S2SV> if ( error < 0 ) { //<S2SV> return error ; //<S2SV> } //<S2SV> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; //<S2SV> destreg = ( opcode >> 4 ) & 0x3f ; //<S2SV> if ( user_mode ( regs ) ) { //<S2SV> __u64 buffer ; //<S2SV> if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> switch ( width_shift ) { //<S2SV> case 1 : //<S2SV> if ( do_sign_extend ) { //<S2SV> regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; //<S2SV> } else { //<S2SV> regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; //<S2SV> } //<S2SV> break ; //<S2SV> case 2 : //<S2SV> regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> regs -> regs [ destreg ] = buffer ; //<S2SV> break ; //<S2SV> default : //<S2SV> printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n" , //<S2SV> width_shift , ( unsigned long ) regs -> pc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } else { //<S2SV> __u64 lo , hi ; //<S2SV> switch ( width_shift ) { //<S2SV> case 1 : //<S2SV> misaligned_kernel_word_load ( address , do_sign_extend , & regs -> regs [ destreg ] ) ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> asm ( "ldlo.l<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0" : "=r" ( lo ) : "r" ( address ) ) ; //<S2SV> asm ( "ldhi.l<S2SV_blank>%1,<S2SV_blank>3,<S2SV_blank>%0" : "=r" ( hi ) : "r" ( address ) ) ; //<S2SV> regs -> regs [ destreg ] = lo | hi ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> asm ( "ldlo.q<S2SV_blank>%1,<S2SV_blank>0,<S2SV_blank>%0" : "=r" ( lo ) : "r" ( address ) ) ; //<S2SV> asm ( "ldhi.q<S2SV_blank>%1,<S2SV_blank>7,<S2SV_blank>%0" : "=r" ( hi ) : "r" ( address ) ) ; //<S2SV> regs -> regs [ destreg ] = lo | hi ; //<S2SV> break ; //<S2SV> default : //<S2SV> printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_load,<S2SV_blank>PC=%08lx\\n" , //<S2SV> width_shift , ( unsigned long ) regs -> pc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 