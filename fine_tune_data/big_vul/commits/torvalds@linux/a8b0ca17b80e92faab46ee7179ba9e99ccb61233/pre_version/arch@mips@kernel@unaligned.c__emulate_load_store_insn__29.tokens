static void emulate_load_store_insn ( struct pt_regs * regs , //<S2SV> void __user * addr , unsigned int __user * pc ) //<S2SV> { //<S2SV> union mips_instruction insn ; //<S2SV> unsigned long value ; //<S2SV> unsigned int res ; //<S2SV> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , //<S2SV> 1 , 0 , regs , 0 ) ; //<S2SV> __get_user ( insn . word , pc ) ; //<S2SV> switch ( insn . i_format . opcode ) { //<S2SV> case ll_op : //<S2SV> case lld_op : //<S2SV> case sc_op : //<S2SV> case scd_op : //<S2SV> case ldl_op : //<S2SV> case ldr_op : //<S2SV> case lwl_op : //<S2SV> case lwr_op : //<S2SV> case sdl_op : //<S2SV> case sdr_op : //<S2SV> case swl_op : //<S2SV> case swr_op : //<S2SV> case lb_op : //<S2SV> case lbu_op : //<S2SV> case sb_op : //<S2SV> goto sigbus ; //<S2SV> case lh_op : //<S2SV> if ( ! access_ok ( VERIFY_READ , addr , 2 ) ) //<S2SV> goto sigbus ; //<S2SV> __asm__ __volatile__ ( ".set\\tnoat\\n" //<S2SV> # ifdef __BIG_ENDIAN //<S2SV> "1:\\tlb\\t%0,<S2SV_blank>0(%2)\\n" //<S2SV> "2:\\tlbu\\t$1,<S2SV_blank>1(%2)\\n\\t" //<S2SV> # endif //<S2SV> # ifdef __LITTLE_ENDIAN //<S2SV> "1:\\tlb\\t%0,<S2SV_blank>1(%2)\\n" //<S2SV> "2:\\tlbu\\t$1,<S2SV_blank>0(%2)\\n\\t" //<S2SV> # endif //<S2SV> "sll\\t%0,<S2SV_blank>0x8\\n\\t" //<S2SV> "or\\t%0,<S2SV_blank>$1\\n\\t" //<S2SV> "li\\t%1,<S2SV_blank>0\\n" //<S2SV> "3:\\t.set\\tat\\n\\t" //<S2SV> ".section\\t.fixup,\\"ax\\"\\n\\t" //<S2SV> "4:\\tli\\t%1,<S2SV_blank>%3\\n\\t" //<S2SV> "j\\t3b\\n\\t" //<S2SV> ".previous\\n\\t" //<S2SV> ".section\\t__ex_table,\\"a\\"\\n\\t" //<S2SV> STR ( PTR ) "\\t1b,<S2SV_blank>4b\\n\\t" //<S2SV> STR ( PTR ) "\\t2b,<S2SV_blank>4b\\n\\t" //<S2SV> ".previous" //<S2SV> : "=&r" ( value ) , "=r" ( res ) //<S2SV> : "r" ( addr ) , "i" ( - EFAULT ) ) ; //<S2SV> if ( res ) //<S2SV> goto fault ; //<S2SV> compute_return_epc ( regs ) ; //<S2SV> regs -> regs [ insn . i_format . rt ] = value ; //<S2SV> break ; //<S2SV> case lw_op : //<S2SV> if ( ! access_ok ( VERIFY_READ , addr , 4 ) ) //<S2SV> goto sigbus ; //<S2SV> __asm__ __volatile__ ( //<S2SV> # ifdef __BIG_ENDIAN //<S2SV> "1:\\tlwl\\t%0,<S2SV_blank>(%2)\\n" //<S2SV> "2:\\tlwr\\t%0,<S2SV_blank>3(%2)\\n\\t" //<S2SV> # endif //<S2SV> # ifdef __LITTLE_ENDIAN //<S2SV> "1:\\tlwl\\t%0,<S2SV_blank>3(%2)\\n" //<S2SV> "2:\\tlwr\\t%0,<S2SV_blank>(%2)\\n\\t" //<S2SV> # endif //<S2SV> "li\\t%1,<S2SV_blank>0\\n" //<S2SV> "3:\\t.section\\t.fixup,\\"ax\\"\\n\\t" //<S2SV> "4:\\tli\\t%1,<S2SV_blank>%3\\n\\t" //<S2SV> "j\\t3b\\n\\t" //<S2SV> ".previous\\n\\t" //<S2SV> ".section\\t__ex_table,\\"a\\"\\n\\t" //<S2SV> STR ( PTR ) "\\t1b,<S2SV_blank>4b\\n\\t" //<S2SV> STR ( PTR ) "\\t2b,<S2SV_blank>4b\\n\\t" //<S2SV> ".previous" //<S2SV> : "=&r" ( value ) , "=r" ( res ) //<S2SV> : "r" ( addr ) , "i" ( - EFAULT ) ) ; //<S2SV> if ( res ) //<S2SV> goto fault ; //<S2SV> compute_return_epc ( regs ) ; //<S2SV> regs -> regs [ insn . i_format . rt ] = value ; //<S2SV> break ; //<S2SV> case lhu_op : //<S2SV> if ( ! access_ok ( VERIFY_READ , addr , 2 ) ) //<S2SV> goto sigbus ; //<S2SV> __asm__ __volatile__ ( //<S2SV> ".set\\tnoat\\n" //<S2SV> # ifdef __BIG_ENDIAN //<S2SV> "1:\\tlbu\\t%0,<S2SV_blank>0(%2)\\n" //<S2SV> "2:\\tlbu\\t$1,<S2SV_blank>1(%2)\\n\\t" //<S2SV> # endif //<S2SV> # ifdef __LITTLE_ENDIAN //<S2SV> "1:\\tlbu\\t%0,<S2SV_blank>1(%2)\\n" //<S2SV> "2:\\tlbu\\t$1,<S2SV_blank>0(%2)\\n\\t" //<S2SV> # endif //<S2SV> "sll\\t%0,<S2SV_blank>0x8\\n\\t" //<S2SV> "or\\t%0,<S2SV_blank>$1\\n\\t" //<S2SV> "li\\t%1,<S2SV_blank>0\\n" //<S2SV> "3:\\t.set\\tat\\n\\t" //<S2SV> ".section\\t.fixup,\\"ax\\"\\n\\t" //<S2SV> "4:\\tli\\t%1,<S2SV_blank>%3\\n\\t" //<S2SV> "j\\t3b\\n\\t" //<S2SV> ".previous\\n\\t" //<S2SV> ".section\\t__ex_table,\\"a\\"\\n\\t" //<S2SV> STR ( PTR ) "\\t1b,<S2SV_blank>4b\\n\\t" //<S2SV> STR ( PTR ) "\\t2b,<S2SV_blank>4b\\n\\t" //<S2SV> ".previous" //<S2SV> : "=&r" ( value ) , "=r" ( res ) //<S2SV> : "r" ( addr ) , "i" ( - EFAULT ) ) ; //<S2SV> if ( res ) //<S2SV> goto fault ; //<S2SV> compute_return_epc ( regs ) ; //<S2SV> regs -> regs [ insn . i_format . rt ] = value ; //<S2SV> break ; //<S2SV> case lwu_op : //<S2SV> # ifdef CONFIG_64BIT //<S2SV> if ( ! access_ok ( VERIFY_READ , addr , 4 ) ) //<S2SV> goto sigbus ; //<S2SV> __asm__ __volatile__ ( //<S2SV> # ifdef __BIG_ENDIAN //<S2SV> "1:\\tlwl\\t%0,<S2SV_blank>(%2)\\n" //<S2SV> "2:\\tlwr\\t%0,<S2SV_blank>3(%2)\\n\\t" //<S2SV> # endif //<S2SV> # ifdef __LITTLE_ENDIAN //<S2SV> "1:\\tlwl\\t%0,<S2SV_blank>3(%2)\\n" //<S2SV> "2:\\tlwr\\t%0,<S2SV_blank>(%2)\\n\\t" //<S2SV> # endif //<S2SV> "dsll\\t%0,<S2SV_blank>%0,<S2SV_blank>32\\n\\t" //<S2SV> "dsrl\\t%0,<S2SV_blank>%0,<S2SV_blank>32\\n\\t" //<S2SV> "li\\t%1,<S2SV_blank>0\\n" //<S2SV> "3:\\t.section\\t.fixup,\\"ax\\"\\n\\t" //<S2SV> "4:\\tli\\t%1,<S2SV_blank>%3\\n\\t" //<S2SV> "j\\t3b\\n\\t" //<S2SV> ".previous\\n\\t" //<S2SV> ".section\\t__ex_table,\\"a\\"\\n\\t" //<S2SV> STR ( PTR ) "\\t1b,<S2SV_blank>4b\\n\\t" //<S2SV> STR ( PTR ) "\\t2b,<S2SV_blank>4b\\n\\t" //<S2SV> ".previous" //<S2SV> : "=&r" ( value ) , "=r" ( res ) //<S2SV> : "r" ( addr ) , "i" ( - EFAULT ) ) ; //<S2SV> if ( res ) //<S2SV> goto fault ; //<S2SV> compute_return_epc ( regs ) ; //<S2SV> regs -> regs [ insn . i_format . rt ] = value ; //<S2SV> break ; //<S2SV> # endif //<S2SV> goto sigill ; //<S2SV> case ld_op : //<S2SV> # ifdef CONFIG_64BIT //<S2SV> if ( ! access_ok ( VERIFY_READ , addr , 8 ) ) //<S2SV> goto sigbus ; //<S2SV> __asm__ __volatile__ ( //<S2SV> # ifdef __BIG_ENDIAN //<S2SV> "1:\\tldl\\t%0,<S2SV_blank>(%2)\\n" //<S2SV> "2:\\tldr\\t%0,<S2SV_blank>7(%2)\\n\\t" //<S2SV> # endif //<S2SV> # ifdef __LITTLE_ENDIAN //<S2SV> "1:\\tldl\\t%0,<S2SV_blank>7(%2)\\n" //<S2SV> "2:\\tldr\\t%0,<S2SV_blank>(%2)\\n\\t" //<S2SV> # endif //<S2SV> "li\\t%1,<S2SV_blank>0\\n" //<S2SV> "3:\\t.section\\t.fixup,\\"ax\\"\\n\\t" //<S2SV> "4:\\tli\\t%1,<S2SV_blank>%3\\n\\t" //<S2SV> "j\\t3b\\n\\t" //<S2SV> ".previous\\n\\t" //<S2SV> ".section\\t__ex_table,\\"a\\"\\n\\t" //<S2SV> STR ( PTR ) "\\t1b,<S2SV_blank>4b\\n\\t" //<S2SV> STR ( PTR ) "\\t2b,<S2SV_blank>4b\\n\\t" //<S2SV> ".previous" //<S2SV> : "=&r" ( value ) , "=r" ( res ) //<S2SV> : "r" ( addr ) , "i" ( - EFAULT ) ) ; //<S2SV> if ( res ) //<S2SV> goto fault ; //<S2SV> compute_return_epc ( regs ) ; //<S2SV> regs -> regs [ insn . i_format . rt ] = value ; //<S2SV> break ; //<S2SV> # endif //<S2SV> goto sigill ; //<S2SV> case sh_op : //<S2SV> if ( ! access_ok ( VERIFY_WRITE , addr , 2 ) ) //<S2SV> goto sigbus ; //<S2SV> value = regs -> regs [ insn . i_format . rt ] ; //<S2SV> __asm__ __volatile__ ( //<S2SV> # ifdef __BIG_ENDIAN //<S2SV> ".set\\tnoat\\n" //<S2SV> "1:\\tsb\\t%1,<S2SV_blank>1(%2)\\n\\t" //<S2SV> "srl\\t$1,<S2SV_blank>%1,<S2SV_blank>0x8\\n" //<S2SV> "2:\\tsb\\t$1,<S2SV_blank>0(%2)\\n\\t" //<S2SV> ".set\\tat\\n\\t" //<S2SV> # endif //<S2SV> # ifdef __LITTLE_ENDIAN //<S2SV> ".set\\tnoat\\n" //<S2SV> "1:\\tsb\\t%1,<S2SV_blank>0(%2)\\n\\t" //<S2SV> "srl\\t$1,%1,<S2SV_blank>0x8\\n" //<S2SV> "2:\\tsb\\t$1,<S2SV_blank>1(%2)\\n\\t" //<S2SV> ".set\\tat\\n\\t" //<S2SV> # endif //<S2SV> "li\\t%0,<S2SV_blank>0\\n" //<S2SV> "3:\\n\\t" //<S2SV> ".section\\t.fixup,\\"ax\\"\\n\\t" //<S2SV> "4:\\tli\\t%0,<S2SV_blank>%3\\n\\t" //<S2SV> "j\\t3b\\n\\t" //<S2SV> ".previous\\n\\t" //<S2SV> ".section\\t__ex_table,\\"a\\"\\n\\t" //<S2SV> STR ( PTR ) "\\t1b,<S2SV_blank>4b\\n\\t" //<S2SV> STR ( PTR ) "\\t2b,<S2SV_blank>4b\\n\\t" //<S2SV> ".previous" //<S2SV> : "=r" ( res ) //<S2SV> : "r" ( value ) , "r" ( addr ) , "i" ( - EFAULT ) ) ; //<S2SV> if ( res ) //<S2SV> goto fault ; //<S2SV> compute_return_epc ( regs ) ; //<S2SV> break ; //<S2SV> case sw_op : //<S2SV> if ( ! access_ok ( VERIFY_WRITE , addr , 4 ) ) //<S2SV> goto sigbus ; //<S2SV> value = regs -> regs [ insn . i_format . rt ] ; //<S2SV> __asm__ __volatile__ ( //<S2SV> # ifdef __BIG_ENDIAN //<S2SV> "1:\\tswl\\t%1,(%2)\\n" //<S2SV> "2:\\tswr\\t%1,<S2SV_blank>3(%2)\\n\\t" //<S2SV> # endif //<S2SV> # ifdef __LITTLE_ENDIAN //<S2SV> "1:\\tswl\\t%1,<S2SV_blank>3(%2)\\n" //<S2SV> "2:\\tswr\\t%1,<S2SV_blank>(%2)\\n\\t" //<S2SV> # endif //<S2SV> "li\\t%0,<S2SV_blank>0\\n" //<S2SV> "3:\\n\\t" //<S2SV> ".section\\t.fixup,\\"ax\\"\\n\\t" //<S2SV> "4:\\tli\\t%0,<S2SV_blank>%3\\n\\t" //<S2SV> "j\\t3b\\n\\t" //<S2SV> ".previous\\n\\t" //<S2SV> ".section\\t__ex_table,\\"a\\"\\n\\t" //<S2SV> STR ( PTR ) "\\t1b,<S2SV_blank>4b\\n\\t" //<S2SV> STR ( PTR ) "\\t2b,<S2SV_blank>4b\\n\\t" //<S2SV> ".previous" //<S2SV> : "=r" ( res ) //<S2SV> : "r" ( value ) , "r" ( addr ) , "i" ( - EFAULT ) ) ; //<S2SV> if ( res ) //<S2SV> goto fault ; //<S2SV> compute_return_epc ( regs ) ; //<S2SV> break ; //<S2SV> case sd_op : //<S2SV> # ifdef CONFIG_64BIT //<S2SV> if ( ! access_ok ( VERIFY_WRITE , addr , 8 ) ) //<S2SV> goto sigbus ; //<S2SV> value = regs -> regs [ insn . i_format . rt ] ; //<S2SV> __asm__ __volatile__ ( //<S2SV> # ifdef __BIG_ENDIAN //<S2SV> "1:\\tsdl\\t%1,(%2)\\n" //<S2SV> "2:\\tsdr\\t%1,<S2SV_blank>7(%2)\\n\\t" //<S2SV> # endif //<S2SV> # ifdef __LITTLE_ENDIAN //<S2SV> "1:\\tsdl\\t%1,<S2SV_blank>7(%2)\\n" //<S2SV> "2:\\tsdr\\t%1,<S2SV_blank>(%2)\\n\\t" //<S2SV> # endif //<S2SV> "li\\t%0,<S2SV_blank>0\\n" //<S2SV> "3:\\n\\t" //<S2SV> ".section\\t.fixup,\\"ax\\"\\n\\t" //<S2SV> "4:\\tli\\t%0,<S2SV_blank>%3\\n\\t" //<S2SV> "j\\t3b\\n\\t" //<S2SV> ".previous\\n\\t" //<S2SV> ".section\\t__ex_table,\\"a\\"\\n\\t" //<S2SV> STR ( PTR ) "\\t1b,<S2SV_blank>4b\\n\\t" //<S2SV> STR ( PTR ) "\\t2b,<S2SV_blank>4b\\n\\t" //<S2SV> ".previous" //<S2SV> : "=r" ( res ) //<S2SV> : "r" ( value ) , "r" ( addr ) , "i" ( - EFAULT ) ) ; //<S2SV> if ( res ) //<S2SV> goto fault ; //<S2SV> compute_return_epc ( regs ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> goto sigill ; //<S2SV> case lwc1_op : //<S2SV> case ldc1_op : //<S2SV> case swc1_op : //<S2SV> case sdc1_op : //<S2SV> goto sigbus ; //<S2SV> case lwc2_op : //<S2SV> cu2_notifier_call_chain ( CU2_LWC2_OP , regs ) ; //<S2SV> break ; //<S2SV> case ldc2_op : //<S2SV> cu2_notifier_call_chain ( CU2_LDC2_OP , regs ) ; //<S2SV> break ; //<S2SV> case swc2_op : //<S2SV> cu2_notifier_call_chain ( CU2_SWC2_OP , regs ) ; //<S2SV> break ; //<S2SV> case sdc2_op : //<S2SV> cu2_notifier_call_chain ( CU2_SDC2_OP , regs ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto sigill ; //<S2SV> } //<S2SV> # ifdef CONFIG_DEBUG_FS //<S2SV> unaligned_instructions ++ ; //<S2SV> # endif //<S2SV> return ; //<S2SV> fault : //<S2SV> if ( fixup_exception ( regs ) ) //<S2SV> return ; //<S2SV> die_if_kernel ( "Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access" , regs ) ; //<S2SV> force_sig ( SIGSEGV , current ) ; //<S2SV> return ; //<S2SV> sigbus : //<S2SV> die_if_kernel ( "Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access" , regs ) ; //<S2SV> force_sig ( SIGBUS , current ) ; //<S2SV> return ; //<S2SV> sigill : //<S2SV> die_if_kernel ( "Unhandled<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>access<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>instruction" , regs ) ; //<S2SV> force_sig ( SIGILL , current ) ; //<S2SV> } //<S2SV> 