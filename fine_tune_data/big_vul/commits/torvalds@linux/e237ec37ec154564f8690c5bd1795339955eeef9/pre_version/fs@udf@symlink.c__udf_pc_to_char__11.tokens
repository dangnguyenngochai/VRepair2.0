static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , //<S2SV> int fromlen , unsigned char * to , int tolen ) //<S2SV> { //<S2SV> struct pathComponent * pc ; //<S2SV> int elen = 0 ; //<S2SV> int comp_len ; //<S2SV> unsigned char * p = to ; //<S2SV> tolen -- ; //<S2SV> while ( elen < fromlen ) { //<S2SV> pc = ( struct pathComponent * ) ( from + elen ) ; //<S2SV> switch ( pc -> componentType ) { //<S2SV> case 1 : //<S2SV> if ( pc -> lengthComponentIdent > 0 ) //<S2SV> break ; //<S2SV> case 2 : //<S2SV> if ( tolen == 0 ) //<S2SV> return - ENAMETOOLONG ; //<S2SV> p = to ; //<S2SV> * p ++ = '/' ; //<S2SV> tolen -- ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> if ( tolen < 3 ) //<S2SV> return - ENAMETOOLONG ; //<S2SV> memcpy ( p , "../" , 3 ) ; //<S2SV> p += 3 ; //<S2SV> tolen -= 3 ; //<S2SV> break ; //<S2SV> case 4 : //<S2SV> if ( tolen < 2 ) //<S2SV> return - ENAMETOOLONG ; //<S2SV> memcpy ( p , "./" , 2 ) ; //<S2SV> p += 2 ; //<S2SV> tolen -= 2 ; //<S2SV> break ; //<S2SV> case 5 : //<S2SV> comp_len = udf_get_filename ( sb , pc -> componentIdent , //<S2SV> pc -> lengthComponentIdent , //<S2SV> p , tolen ) ; //<S2SV> p += comp_len ; //<S2SV> tolen -= comp_len ; //<S2SV> if ( tolen == 0 ) //<S2SV> return - ENAMETOOLONG ; //<S2SV> * p ++ = '/' ; //<S2SV> tolen -- ; //<S2SV> break ; //<S2SV> } //<S2SV> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; //<S2SV> } //<S2SV> if ( p > to + 1 ) //<S2SV> p [ - 1 ] = '\\0' ; //<S2SV> else //<S2SV> p [ 0 ] = '\\0' ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 