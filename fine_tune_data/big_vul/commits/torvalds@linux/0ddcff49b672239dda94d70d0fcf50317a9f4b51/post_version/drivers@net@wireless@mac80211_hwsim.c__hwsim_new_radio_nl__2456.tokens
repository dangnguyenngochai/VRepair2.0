static int hwsim_new_radio_nl ( struct sk_buff * msg , struct genl_info * info ) //<S2SV> { //<S2SV> struct hwsim_new_radio_params param = { 0 } ; //<S2SV> const char * hwname = NULL ; //<S2SV> int ret ; //<S2SV> param . reg_strict = info -> attrs [ HWSIM_ATTR_REG_STRICT_REG ] ; //<S2SV> param . p2p_device = info -> attrs [ HWSIM_ATTR_SUPPORT_P2P_DEVICE ] ; //<S2SV> param . channels = channels ; //<S2SV> param . destroy_on_close = //<S2SV> info -> attrs [ HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE ] ; //<S2SV> if ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) //<S2SV> param . channels = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) ; //<S2SV> if ( info -> attrs [ HWSIM_ATTR_NO_VIF ] ) //<S2SV> param . no_vif = true ; //<S2SV> if ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) { //<S2SV> hwname = kasprintf ( GFP_KERNEL , "%.*s" , //<S2SV> nla_len ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) , //<S2SV> ( char * ) nla_data ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) ) ; //<S2SV> if ( ! hwname ) //<S2SV> return - ENOMEM ; //<S2SV> param . hwname = hwname ; //<S2SV> } //<S2SV> if ( info -> attrs [ HWSIM_ATTR_USE_CHANCTX ] ) //<S2SV> param . use_chanctx = true ; //<S2SV> else //<S2SV> param . use_chanctx = ( param . channels > 1 ) ; //<S2SV> if ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) //<S2SV> param . reg_alpha2 = //<S2SV> nla_data ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) ; //<S2SV> if ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) { //<S2SV> u32 idx = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) ; //<S2SV> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) { //<S2SV> kfree ( hwname ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> param . regd = hwsim_world_regdom_custom [ idx ] ; //<S2SV> } //<S2SV> ret = mac80211_hwsim_new_radio ( info , & param ) ; //<S2SV> kfree ( hwname ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 