static int //<S2SV> vsock_stream_recvmsg ( struct kiocb * kiocb , //<S2SV> struct socket * sock , //<S2SV> struct msghdr * msg , size_t len , int flags ) //<S2SV> { //<S2SV> struct sock * sk ; //<S2SV> struct vsock_sock * vsk ; //<S2SV> int err ; //<S2SV> size_t target ; //<S2SV> ssize_t copied ; //<S2SV> long timeout ; //<S2SV> struct vsock_transport_recv_notify_data recv_data ; //<S2SV> DEFINE_WAIT ( wait ) ; //<S2SV> sk = sock -> sk ; //<S2SV> vsk = vsock_sk ( sk ) ; //<S2SV> err = 0 ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( sk -> sk_state != SS_CONNECTED ) { //<S2SV> if ( sock_flag ( sk , SOCK_DONE ) ) //<S2SV> err = 0 ; //<S2SV> else //<S2SV> err = - ENOTCONN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( flags & MSG_OOB ) { //<S2SV> err = - EOPNOTSUPP ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { //<S2SV> err = 0 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! len ) { //<S2SV> err = 0 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; //<S2SV> if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { //<S2SV> err = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; //<S2SV> copied = 0 ; //<S2SV> err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out ; //<S2SV> prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; //<S2SV> while ( 1 ) { //<S2SV> s64 ready = vsock_stream_has_data ( vsk ) ; //<S2SV> if ( ready < 0 ) { //<S2SV> err = - ENOMEM ; //<S2SV> goto out_wait ; //<S2SV> } else if ( ready > 0 ) { //<S2SV> ssize_t read ; //<S2SV> err = transport -> notify_recv_pre_dequeue ( //<S2SV> vsk , target , & recv_data ) ; //<S2SV> if ( err < 0 ) //<S2SV> break ; //<S2SV> read = transport -> stream_dequeue ( //<S2SV> vsk , msg -> msg_iov , //<S2SV> len - copied , flags ) ; //<S2SV> if ( read < 0 ) { //<S2SV> err = - ENOMEM ; //<S2SV> break ; //<S2SV> } //<S2SV> copied += read ; //<S2SV> err = transport -> notify_recv_post_dequeue ( //<S2SV> vsk , target , read , //<S2SV> ! ( flags & MSG_PEEK ) , & recv_data ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out_wait ; //<S2SV> if ( read >= target || flags & MSG_PEEK ) //<S2SV> break ; //<S2SV> target -= read ; //<S2SV> } else { //<S2SV> if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { //<S2SV> break ; //<S2SV> } //<S2SV> if ( timeout == 0 ) { //<S2SV> err = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> err = transport -> notify_recv_pre_block ( //<S2SV> vsk , target , & recv_data ) ; //<S2SV> if ( err < 0 ) //<S2SV> break ; //<S2SV> release_sock ( sk ) ; //<S2SV> timeout = schedule_timeout ( timeout ) ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( signal_pending ( current ) ) { //<S2SV> err = sock_intr_errno ( timeout ) ; //<S2SV> break ; //<S2SV> } else if ( timeout == 0 ) { //<S2SV> err = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> prepare_to_wait ( sk_sleep ( sk ) , & wait , //<S2SV> TASK_INTERRUPTIBLE ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sk -> sk_err ) //<S2SV> err = - sk -> sk_err ; //<S2SV> else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> err = 0 ; //<S2SV> if ( copied > 0 ) { //<S2SV> if ( ! ( flags & MSG_PEEK ) ) { //<S2SV> if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { //<S2SV> if ( vsock_stream_has_data ( vsk ) <= 0 ) { //<S2SV> sk -> sk_state = SS_UNCONNECTED ; //<S2SV> sock_set_flag ( sk , SOCK_DONE ) ; //<S2SV> sk -> sk_state_change ( sk ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> err = copied ; //<S2SV> } //<S2SV> out_wait : //<S2SV> finish_wait ( sk_sleep ( sk ) , & wait ) ; //<S2SV> out : //<S2SV> release_sock ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 