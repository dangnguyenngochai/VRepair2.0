static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len ) //<S2SV> { //<S2SV> struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct sock * other = NULL ; //<S2SV> int err , size ; //<S2SV> struct sk_buff * skb ; //<S2SV> int sent = 0 ; //<S2SV> struct scm_cookie tmp_scm ; //<S2SV> bool fds_sent = false ; //<S2SV> int max_level ; //<S2SV> if ( NULL == siocb -> scm ) //<S2SV> siocb -> scm = & tmp_scm ; //<S2SV> wait_for_unix_gc ( ) ; //<S2SV> err = scm_send ( sock , msg , siocb -> scm ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> err = - EOPNOTSUPP ; //<S2SV> if ( msg -> msg_flags & MSG_OOB ) //<S2SV> goto out_err ; //<S2SV> if ( msg -> msg_namelen ) { //<S2SV> err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; //<S2SV> goto out_err ; //<S2SV> } else { //<S2SV> err = - ENOTCONN ; //<S2SV> other = unix_peer ( sk ) ; //<S2SV> if ( ! other ) //<S2SV> goto out_err ; //<S2SV> } //<S2SV> if ( sk -> sk_shutdown & SEND_SHUTDOWN ) //<S2SV> goto pipe_err ; //<S2SV> while ( sent < len ) { //<S2SV> size = len - sent ; //<S2SV> if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) //<S2SV> size = ( sk -> sk_sndbuf >> 1 ) - 64 ; //<S2SV> if ( size > SKB_MAX_ALLOC ) //<S2SV> size = SKB_MAX_ALLOC ; //<S2SV> skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , //<S2SV> & err ) ; //<S2SV> if ( skb == NULL ) //<S2SV> goto out_err ; //<S2SV> size = min_t ( int , size , skb_tailroom ( skb ) ) ; //<S2SV> err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; //<S2SV> if ( err < 0 ) { //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> max_level = err + 1 ; //<S2SV> fds_sent = true ; //<S2SV> err = memcpy_fromiovec ( skb_put ( skb , size ) , msg -> msg_iov , size ) ; //<S2SV> if ( err ) { //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> unix_state_lock ( other ) ; //<S2SV> if ( sock_flag ( other , SOCK_DEAD ) || //<S2SV> ( other -> sk_shutdown & RCV_SHUTDOWN ) ) //<S2SV> goto pipe_err_free ; //<S2SV> maybe_add_creds ( skb , sock , other ) ; //<S2SV> skb_queue_tail ( & other -> sk_receive_queue , skb ) ; //<S2SV> if ( max_level > unix_sk ( other ) -> recursion_level ) //<S2SV> unix_sk ( other ) -> recursion_level = max_level ; //<S2SV> unix_state_unlock ( other ) ; //<S2SV> other -> sk_data_ready ( other , size ) ; //<S2SV> sent += size ; //<S2SV> } //<S2SV> scm_destroy ( siocb -> scm ) ; //<S2SV> siocb -> scm = NULL ; //<S2SV> return sent ; //<S2SV> pipe_err_free : //<S2SV> unix_state_unlock ( other ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> pipe_err : //<S2SV> if ( sent == 0 && ! ( msg -> msg_flags & MSG_NOSIGNAL ) ) //<S2SV> send_sig ( SIGPIPE , current , 0 ) ; //<S2SV> err = - EPIPE ; //<S2SV> out_err : //<S2SV> scm_destroy ( siocb -> scm ) ; //<S2SV> siocb -> scm = NULL ; //<S2SV> return sent ? : err ; //<S2SV> } //<S2SV> 