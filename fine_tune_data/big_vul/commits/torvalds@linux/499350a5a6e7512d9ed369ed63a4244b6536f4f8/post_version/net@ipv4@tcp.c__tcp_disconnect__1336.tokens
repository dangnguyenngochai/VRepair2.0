int tcp_disconnect ( struct sock * sk , int flags ) //<S2SV> { //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct inet_connection_sock * icsk = inet_csk ( sk ) ; //<S2SV> struct tcp_sock * tp = tcp_sk ( sk ) ; //<S2SV> int err = 0 ; //<S2SV> int old_state = sk -> sk_state ; //<S2SV> if ( old_state != TCP_CLOSE ) //<S2SV> tcp_set_state ( sk , TCP_CLOSE ) ; //<S2SV> if ( old_state == TCP_LISTEN ) { //<S2SV> inet_csk_listen_stop ( sk ) ; //<S2SV> } else if ( unlikely ( tp -> repair ) ) { //<S2SV> sk -> sk_err = ECONNABORTED ; //<S2SV> } else if ( tcp_need_reset ( old_state ) || //<S2SV> ( tp -> snd_nxt != tp -> write_seq && //<S2SV> ( 1 << old_state ) & ( TCPF_CLOSING | TCPF_LAST_ACK ) ) ) { //<S2SV> tcp_send_active_reset ( sk , gfp_any ( ) ) ; //<S2SV> sk -> sk_err = ECONNRESET ; //<S2SV> } else if ( old_state == TCP_SYN_SENT ) //<S2SV> sk -> sk_err = ECONNRESET ; //<S2SV> tcp_clear_xmit_timers ( sk ) ; //<S2SV> __skb_queue_purge ( & sk -> sk_receive_queue ) ; //<S2SV> tcp_write_queue_purge ( sk ) ; //<S2SV> tcp_fastopen_active_disable_ofo_check ( sk ) ; //<S2SV> skb_rbtree_purge ( & tp -> out_of_order_queue ) ; //<S2SV> inet -> inet_dport = 0 ; //<S2SV> if ( ! ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) ) //<S2SV> inet_reset_saddr ( sk ) ; //<S2SV> sk -> sk_shutdown = 0 ; //<S2SV> sock_reset_flag ( sk , SOCK_DONE ) ; //<S2SV> tp -> srtt_us = 0 ; //<S2SV> tp -> write_seq += tp -> max_window + 2 ; //<S2SV> if ( tp -> write_seq == 0 ) //<S2SV> tp -> write_seq = 1 ; //<S2SV> icsk -> icsk_backoff = 0 ; //<S2SV> tp -> snd_cwnd = 2 ; //<S2SV> icsk -> icsk_probes_out = 0 ; //<S2SV> tp -> packets_out = 0 ; //<S2SV> tp -> snd_ssthresh = TCP_INFINITE_SSTHRESH ; //<S2SV> tp -> snd_cwnd_cnt = 0 ; //<S2SV> tp -> window_clamp = 0 ; //<S2SV> tcp_set_ca_state ( sk , TCP_CA_Open ) ; //<S2SV> tcp_clear_retrans ( tp ) ; //<S2SV> inet_csk_delack_init ( sk ) ; //<S2SV> icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ; //<S2SV> tcp_init_send_head ( sk ) ; //<S2SV> memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ; //<S2SV> __sk_dst_reset ( sk ) ; //<S2SV> tcp_saved_syn_free ( tp ) ; //<S2SV> tcp_free_fastopen_req ( tp ) ; //<S2SV> inet -> defer_connect = 0 ; //<S2SV> WARN_ON ( inet -> inet_num && ! icsk -> icsk_bind_hash ) ; //<S2SV> sk -> sk_error_report ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 