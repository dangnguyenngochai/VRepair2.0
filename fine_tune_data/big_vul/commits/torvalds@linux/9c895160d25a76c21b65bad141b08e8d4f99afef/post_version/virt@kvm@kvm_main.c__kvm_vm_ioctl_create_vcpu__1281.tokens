static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) //<S2SV> { //<S2SV> int r ; //<S2SV> struct kvm_vcpu * vcpu , * v ; //<S2SV> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; //<S2SV> if ( IS_ERR ( vcpu ) ) //<S2SV> return PTR_ERR ( vcpu ) ; //<S2SV> preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; //<S2SV> r = kvm_arch_vcpu_setup ( vcpu ) ; //<S2SV> if ( r ) //<S2SV> goto vcpu_destroy ; //<S2SV> mutex_lock ( & kvm -> lock ) ; //<S2SV> if ( ! kvm_vcpu_compatible ( vcpu ) ) { //<S2SV> r = - EINVAL ; //<S2SV> goto unlock_vcpu_destroy ; //<S2SV> } //<S2SV> if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { //<S2SV> r = - EINVAL ; //<S2SV> goto unlock_vcpu_destroy ; //<S2SV> } //<S2SV> kvm_for_each_vcpu ( r , v , kvm ) //<S2SV> if ( v -> vcpu_id == id ) { //<S2SV> r = - EEXIST ; //<S2SV> goto unlock_vcpu_destroy ; //<S2SV> } //<S2SV> BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; //<S2SV> kvm_get_kvm ( kvm ) ; //<S2SV> r = create_vcpu_fd ( vcpu ) ; //<S2SV> if ( r < 0 ) { //<S2SV> kvm_put_kvm ( kvm ) ; //<S2SV> goto unlock_vcpu_destroy ; //<S2SV> } //<S2SV> kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; //<S2SV> smp_wmb ( ) ; //<S2SV> atomic_inc ( & kvm -> online_vcpus ) ; //<S2SV> mutex_unlock ( & kvm -> lock ) ; //<S2SV> return r ; //<S2SV> unlock_vcpu_destroy : //<S2SV> mutex_unlock ( & kvm -> lock ) ; //<S2SV> vcpu_destroy : //<S2SV> kvm_arch_vcpu_destroy ( vcpu ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> 