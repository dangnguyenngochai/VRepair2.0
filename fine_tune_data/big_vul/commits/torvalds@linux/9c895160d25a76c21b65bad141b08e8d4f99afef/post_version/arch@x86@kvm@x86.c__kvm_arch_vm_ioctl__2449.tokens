long kvm_arch_vm_ioctl ( struct file * filp , //<S2SV> unsigned int ioctl , unsigned long arg ) //<S2SV> { //<S2SV> struct kvm * kvm = filp -> private_data ; //<S2SV> void __user * argp = ( void __user * ) arg ; //<S2SV> int r = - ENOTTY ; //<S2SV> union { //<S2SV> struct kvm_pit_state ps ; //<S2SV> struct kvm_pit_state2 ps2 ; //<S2SV> struct kvm_pit_config pit_config ; //<S2SV> } u ; //<S2SV> switch ( ioctl ) { //<S2SV> case KVM_SET_TSS_ADDR : //<S2SV> r = kvm_vm_ioctl_set_tss_addr ( kvm , arg ) ; //<S2SV> if ( r < 0 ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> case KVM_SET_IDENTITY_MAP_ADDR : { //<S2SV> u64 ident_addr ; //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & ident_addr , argp , sizeof ident_addr ) ) //<S2SV> goto out ; //<S2SV> r = kvm_vm_ioctl_set_identity_map_addr ( kvm , ident_addr ) ; //<S2SV> if ( r < 0 ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_SET_NR_MMU_PAGES : //<S2SV> r = kvm_vm_ioctl_set_nr_mmu_pages ( kvm , arg ) ; //<S2SV> if ( r ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> case KVM_GET_NR_MMU_PAGES : //<S2SV> r = kvm_vm_ioctl_get_nr_mmu_pages ( kvm ) ; //<S2SV> break ; //<S2SV> case KVM_CREATE_IRQCHIP : { //<S2SV> struct kvm_pic * vpic ; //<S2SV> mutex_lock ( & kvm -> lock ) ; //<S2SV> r = - EEXIST ; //<S2SV> if ( kvm -> arch . vpic ) //<S2SV> goto create_irqchip_unlock ; //<S2SV> r = - EINVAL ; //<S2SV> if ( atomic_read ( & kvm -> online_vcpus ) ) //<S2SV> goto create_irqchip_unlock ; //<S2SV> r = - ENOMEM ; //<S2SV> vpic = kvm_create_pic ( kvm ) ; //<S2SV> if ( vpic ) { //<S2SV> r = kvm_ioapic_init ( kvm ) ; //<S2SV> if ( r ) { //<S2SV> mutex_lock ( & kvm -> slots_lock ) ; //<S2SV> kvm_io_bus_unregister_dev ( kvm , KVM_PIO_BUS , //<S2SV> & vpic -> dev_master ) ; //<S2SV> kvm_io_bus_unregister_dev ( kvm , KVM_PIO_BUS , //<S2SV> & vpic -> dev_slave ) ; //<S2SV> kvm_io_bus_unregister_dev ( kvm , KVM_PIO_BUS , //<S2SV> & vpic -> dev_eclr ) ; //<S2SV> mutex_unlock ( & kvm -> slots_lock ) ; //<S2SV> kfree ( vpic ) ; //<S2SV> goto create_irqchip_unlock ; //<S2SV> } //<S2SV> } else //<S2SV> goto create_irqchip_unlock ; //<S2SV> smp_wmb ( ) ; //<S2SV> kvm -> arch . vpic = vpic ; //<S2SV> smp_wmb ( ) ; //<S2SV> r = kvm_setup_default_irq_routing ( kvm ) ; //<S2SV> if ( r ) { //<S2SV> mutex_lock ( & kvm -> slots_lock ) ; //<S2SV> mutex_lock ( & kvm -> irq_lock ) ; //<S2SV> kvm_ioapic_destroy ( kvm ) ; //<S2SV> kvm_destroy_pic ( kvm ) ; //<S2SV> mutex_unlock ( & kvm -> irq_lock ) ; //<S2SV> mutex_unlock ( & kvm -> slots_lock ) ; //<S2SV> } //<S2SV> create_irqchip_unlock : //<S2SV> mutex_unlock ( & kvm -> lock ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_CREATE_PIT : //<S2SV> u . pit_config . flags = KVM_PIT_SPEAKER_DUMMY ; //<S2SV> goto create_pit ; //<S2SV> case KVM_CREATE_PIT2 : //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & u . pit_config , argp , //<S2SV> sizeof ( struct kvm_pit_config ) ) ) //<S2SV> goto out ; //<S2SV> create_pit : //<S2SV> mutex_lock ( & kvm -> slots_lock ) ; //<S2SV> r = - EEXIST ; //<S2SV> if ( kvm -> arch . vpit ) //<S2SV> goto create_pit_unlock ; //<S2SV> r = - ENOMEM ; //<S2SV> kvm -> arch . vpit = kvm_create_pit ( kvm , u . pit_config . flags ) ; //<S2SV> if ( kvm -> arch . vpit ) //<S2SV> r = 0 ; //<S2SV> create_pit_unlock : //<S2SV> mutex_unlock ( & kvm -> slots_lock ) ; //<S2SV> break ; //<S2SV> case KVM_IRQ_LINE_STATUS : //<S2SV> case KVM_IRQ_LINE : { //<S2SV> struct kvm_irq_level irq_event ; //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & irq_event , argp , sizeof irq_event ) ) //<S2SV> goto out ; //<S2SV> r = - ENXIO ; //<S2SV> if ( irqchip_in_kernel ( kvm ) ) { //<S2SV> __s32 status ; //<S2SV> status = kvm_set_irq ( kvm , KVM_USERSPACE_IRQ_SOURCE_ID , //<S2SV> irq_event . irq , irq_event . level ) ; //<S2SV> if ( ioctl == KVM_IRQ_LINE_STATUS ) { //<S2SV> r = - EFAULT ; //<S2SV> irq_event . status = status ; //<S2SV> if ( copy_to_user ( argp , & irq_event , //<S2SV> sizeof irq_event ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> r = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_GET_IRQCHIP : { //<S2SV> struct kvm_irqchip * chip ; //<S2SV> chip = memdup_user ( argp , sizeof ( * chip ) ) ; //<S2SV> if ( IS_ERR ( chip ) ) { //<S2SV> r = PTR_ERR ( chip ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> r = - ENXIO ; //<S2SV> if ( ! irqchip_in_kernel ( kvm ) ) //<S2SV> goto get_irqchip_out ; //<S2SV> r = kvm_vm_ioctl_get_irqchip ( kvm , chip ) ; //<S2SV> if ( r ) //<S2SV> goto get_irqchip_out ; //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_to_user ( argp , chip , sizeof * chip ) ) //<S2SV> goto get_irqchip_out ; //<S2SV> r = 0 ; //<S2SV> get_irqchip_out : //<S2SV> kfree ( chip ) ; //<S2SV> if ( r ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_SET_IRQCHIP : { //<S2SV> struct kvm_irqchip * chip ; //<S2SV> chip = memdup_user ( argp , sizeof ( * chip ) ) ; //<S2SV> if ( IS_ERR ( chip ) ) { //<S2SV> r = PTR_ERR ( chip ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> r = - ENXIO ; //<S2SV> if ( ! irqchip_in_kernel ( kvm ) ) //<S2SV> goto set_irqchip_out ; //<S2SV> r = kvm_vm_ioctl_set_irqchip ( kvm , chip ) ; //<S2SV> if ( r ) //<S2SV> goto set_irqchip_out ; //<S2SV> r = 0 ; //<S2SV> set_irqchip_out : //<S2SV> kfree ( chip ) ; //<S2SV> if ( r ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_GET_PIT : { //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & u . ps , argp , sizeof ( struct kvm_pit_state ) ) ) //<S2SV> goto out ; //<S2SV> r = - ENXIO ; //<S2SV> if ( ! kvm -> arch . vpit ) //<S2SV> goto out ; //<S2SV> r = kvm_vm_ioctl_get_pit ( kvm , & u . ps ) ; //<S2SV> if ( r ) //<S2SV> goto out ; //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_to_user ( argp , & u . ps , sizeof ( struct kvm_pit_state ) ) ) //<S2SV> goto out ; //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_SET_PIT : { //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & u . ps , argp , sizeof u . ps ) ) //<S2SV> goto out ; //<S2SV> r = - ENXIO ; //<S2SV> if ( ! kvm -> arch . vpit ) //<S2SV> goto out ; //<S2SV> r = kvm_vm_ioctl_set_pit ( kvm , & u . ps ) ; //<S2SV> if ( r ) //<S2SV> goto out ; //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_GET_PIT2 : { //<S2SV> r = - ENXIO ; //<S2SV> if ( ! kvm -> arch . vpit ) //<S2SV> goto out ; //<S2SV> r = kvm_vm_ioctl_get_pit2 ( kvm , & u . ps2 ) ; //<S2SV> if ( r ) //<S2SV> goto out ; //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_to_user ( argp , & u . ps2 , sizeof ( u . ps2 ) ) ) //<S2SV> goto out ; //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_SET_PIT2 : { //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & u . ps2 , argp , sizeof ( u . ps2 ) ) ) //<S2SV> goto out ; //<S2SV> r = - ENXIO ; //<S2SV> if ( ! kvm -> arch . vpit ) //<S2SV> goto out ; //<S2SV> r = kvm_vm_ioctl_set_pit2 ( kvm , & u . ps2 ) ; //<S2SV> if ( r ) //<S2SV> goto out ; //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_REINJECT_CONTROL : { //<S2SV> struct kvm_reinject_control control ; //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & control , argp , sizeof ( control ) ) ) //<S2SV> goto out ; //<S2SV> r = kvm_vm_ioctl_reinject ( kvm , & control ) ; //<S2SV> if ( r ) //<S2SV> goto out ; //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_XEN_HVM_CONFIG : { //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & kvm -> arch . xen_hvm_config , argp , //<S2SV> sizeof ( struct kvm_xen_hvm_config ) ) ) //<S2SV> goto out ; //<S2SV> r = - EINVAL ; //<S2SV> if ( kvm -> arch . xen_hvm_config . flags ) //<S2SV> goto out ; //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_SET_CLOCK : { //<S2SV> struct kvm_clock_data user_ns ; //<S2SV> u64 now_ns ; //<S2SV> s64 delta ; //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_from_user ( & user_ns , argp , sizeof ( user_ns ) ) ) //<S2SV> goto out ; //<S2SV> r = - EINVAL ; //<S2SV> if ( user_ns . flags ) //<S2SV> goto out ; //<S2SV> r = 0 ; //<S2SV> local_irq_disable ( ) ; //<S2SV> now_ns = get_kernel_ns ( ) ; //<S2SV> delta = user_ns . clock - now_ns ; //<S2SV> local_irq_enable ( ) ; //<S2SV> kvm -> arch . kvmclock_offset = delta ; //<S2SV> break ; //<S2SV> } //<S2SV> case KVM_GET_CLOCK : { //<S2SV> struct kvm_clock_data user_ns ; //<S2SV> u64 now_ns ; //<S2SV> local_irq_disable ( ) ; //<S2SV> now_ns = get_kernel_ns ( ) ; //<S2SV> user_ns . clock = kvm -> arch . kvmclock_offset + now_ns ; //<S2SV> local_irq_enable ( ) ; //<S2SV> user_ns . flags = 0 ; //<S2SV> memset ( & user_ns . pad , 0 , sizeof ( user_ns . pad ) ) ; //<S2SV> r = - EFAULT ; //<S2SV> if ( copy_to_user ( argp , & user_ns , sizeof ( user_ns ) ) ) //<S2SV> goto out ; //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> ; //<S2SV> } //<S2SV> out : //<S2SV> return r ; //<S2SV> } //<S2SV> 