static void * etm_setup_aux ( int event_cpu , void * * pages , //<S2SV> int nr_pages , bool overwrite ) //<S2SV> { //<S2SV> int cpu ; //<S2SV> cpumask_t * mask ; //<S2SV> struct coresight_device * sink ; //<S2SV> struct etm_event_data * event_data = NULL ; //<S2SV> event_data = alloc_event_data ( event_cpu ) ; //<S2SV> if ( ! event_data ) //<S2SV> return NULL ; //<S2SV> sink = coresight_get_enabled_sink ( true ) ; //<S2SV> if ( ! sink ) //<S2SV> goto err ; //<S2SV> INIT_WORK ( & event_data -> work , free_event_data ) ; //<S2SV> mask = & event_data -> mask ; //<S2SV> for_each_cpu ( cpu , mask ) { //<S2SV> struct coresight_device * csdev ; //<S2SV> csdev = per_cpu ( csdev_src , cpu ) ; //<S2SV> if ( ! csdev ) //<S2SV> goto err ; //<S2SV> event_data -> path [ cpu ] = coresight_build_path ( csdev , sink ) ; //<S2SV> if ( IS_ERR ( event_data -> path [ cpu ] ) ) //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( ! sink_ops ( sink ) -> alloc_buffer ) //<S2SV> goto err ; //<S2SV> cpu = cpumask_first ( mask ) ; //<S2SV> event_data -> snk_config = //<S2SV> sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , //<S2SV> nr_pages , overwrite ) ; //<S2SV> if ( ! event_data -> snk_config ) //<S2SV> goto err ; //<S2SV> out : //<S2SV> return event_data ; //<S2SV> err : //<S2SV> etm_free_aux ( event_data ) ; //<S2SV> event_data = NULL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 