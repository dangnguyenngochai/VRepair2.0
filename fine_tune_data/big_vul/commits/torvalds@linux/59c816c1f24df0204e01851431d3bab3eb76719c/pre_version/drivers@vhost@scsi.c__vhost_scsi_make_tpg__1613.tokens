static struct se_portal_group * //<S2SV> vhost_scsi_make_tpg ( struct se_wwn * wwn , //<S2SV> struct config_group * group , //<S2SV> const char * name ) //<S2SV> { //<S2SV> struct vhost_scsi_tport * tport = container_of ( wwn , //<S2SV> struct vhost_scsi_tport , tport_wwn ) ; //<S2SV> struct vhost_scsi_tpg * tpg ; //<S2SV> unsigned long tpgt ; //<S2SV> int ret ; //<S2SV> if ( strstr ( name , "tpgt_" ) != name ) //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; //<S2SV> if ( ! tpg ) { //<S2SV> pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg" ) ; //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> } //<S2SV> mutex_init ( & tpg -> tv_tpg_mutex ) ; //<S2SV> INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; //<S2SV> tpg -> tport = tport ; //<S2SV> tpg -> tport_tpgt = tpgt ; //<S2SV> ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , //<S2SV> & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> kfree ( tpg ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> mutex_lock ( & vhost_scsi_mutex ) ; //<S2SV> list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; //<S2SV> mutex_unlock ( & vhost_scsi_mutex ) ; //<S2SV> return & tpg -> se_tpg ; //<S2SV> } //<S2SV> 