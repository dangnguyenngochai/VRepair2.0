static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , //<S2SV> struct cftype * cft , struct eventfd_ctx * eventfd ) //<S2SV> { //<S2SV> struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; //<S2SV> struct mem_cgroup_thresholds * thresholds ; //<S2SV> struct mem_cgroup_threshold_ary * new ; //<S2SV> int type = MEMFILE_TYPE ( cft -> private ) ; //<S2SV> u64 usage ; //<S2SV> int i , j , size ; //<S2SV> mutex_lock ( & memcg -> thresholds_lock ) ; //<S2SV> if ( type == _MEM ) //<S2SV> thresholds = & memcg -> thresholds ; //<S2SV> else if ( type == _MEMSWAP ) //<S2SV> thresholds = & memcg -> memsw_thresholds ; //<S2SV> else //<S2SV> BUG ( ) ; //<S2SV> BUG_ON ( ! thresholds ) ; //<S2SV> usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; //<S2SV> __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; //<S2SV> size = 0 ; //<S2SV> for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { //<S2SV> if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) //<S2SV> size ++ ; //<S2SV> } //<S2SV> new = thresholds -> spare ; //<S2SV> if ( ! size ) { //<S2SV> kfree ( new ) ; //<S2SV> new = NULL ; //<S2SV> goto swap_buffers ; //<S2SV> } //<S2SV> new -> size = size ; //<S2SV> new -> current_threshold = - 1 ; //<S2SV> for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { //<S2SV> if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) //<S2SV> continue ; //<S2SV> new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; //<S2SV> if ( new -> entries [ j ] . threshold < usage ) { //<S2SV> ++ new -> current_threshold ; //<S2SV> } //<S2SV> j ++ ; //<S2SV> } //<S2SV> swap_buffers : //<S2SV> thresholds -> spare = thresholds -> primary ; //<S2SV> rcu_assign_pointer ( thresholds -> primary , new ) ; //<S2SV> synchronize_rcu ( ) ; //<S2SV> mutex_unlock ( & memcg -> thresholds_lock ) ; //<S2SV> } //<S2SV> 