static int efx_register_netdev ( struct efx_nic * efx ) //<S2SV> { //<S2SV> struct net_device * net_dev = efx -> net_dev ; //<S2SV> struct efx_channel * channel ; //<S2SV> int rc ; //<S2SV> net_dev -> watchdog_timeo = 5 * HZ ; //<S2SV> net_dev -> irq = efx -> pci_dev -> irq ; //<S2SV> net_dev -> netdev_ops = & efx_netdev_ops ; //<S2SV> SET_ETHTOOL_OPS ( net_dev , & efx_ethtool_ops ) ; //<S2SV> efx -> mac_op -> update_stats ( efx ) ; //<S2SV> memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ; //<S2SV> rtnl_lock ( ) ; //<S2SV> rc = dev_alloc_name ( net_dev , net_dev -> name ) ; //<S2SV> if ( rc < 0 ) //<S2SV> goto fail_locked ; //<S2SV> efx_update_name ( efx ) ; //<S2SV> rc = register_netdevice ( net_dev ) ; //<S2SV> if ( rc ) //<S2SV> goto fail_locked ; //<S2SV> efx_for_each_channel ( channel , efx ) { //<S2SV> struct efx_tx_queue * tx_queue ; //<S2SV> efx_for_each_channel_tx_queue ( tx_queue , channel ) //<S2SV> efx_init_tx_queue_core_txq ( tx_queue ) ; //<S2SV> } //<S2SV> netif_carrier_off ( efx -> net_dev ) ; //<S2SV> rtnl_unlock ( ) ; //<S2SV> rc = device_create_file ( & efx -> pci_dev -> dev , & dev_attr_phy_type ) ; //<S2SV> if ( rc ) { //<S2SV> netif_err ( efx , drv , efx -> net_dev , //<S2SV> "failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>net<S2SV_blank>dev<S2SV_blank>attributes\\n" ) ; //<S2SV> goto fail_registered ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> fail_locked : //<S2SV> rtnl_unlock ( ) ; //<S2SV> netif_err ( efx , drv , efx -> net_dev , "could<S2SV_blank>not<S2SV_blank>register<S2SV_blank>net<S2SV_blank>dev\\n" ) ; //<S2SV> return rc ; //<S2SV> fail_registered : //<S2SV> unregister_netdev ( net_dev ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 