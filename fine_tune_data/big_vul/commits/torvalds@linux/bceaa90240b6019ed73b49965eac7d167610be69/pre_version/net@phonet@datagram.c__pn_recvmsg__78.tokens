static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , //<S2SV> struct msghdr * msg , size_t len , int noblock , //<S2SV> int flags , int * addr_len ) //<S2SV> { //<S2SV> struct sk_buff * skb = NULL ; //<S2SV> struct sockaddr_pn sa ; //<S2SV> int rval = - EOPNOTSUPP ; //<S2SV> int copylen ; //<S2SV> if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | //<S2SV> MSG_CMSG_COMPAT ) ) //<S2SV> goto out_nofree ; //<S2SV> if ( addr_len ) //<S2SV> * addr_len = sizeof ( sa ) ; //<S2SV> skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; //<S2SV> if ( skb == NULL ) //<S2SV> goto out_nofree ; //<S2SV> pn_skb_get_src_sockaddr ( skb , & sa ) ; //<S2SV> copylen = skb -> len ; //<S2SV> if ( len < copylen ) { //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> copylen = len ; //<S2SV> } //<S2SV> rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; //<S2SV> if ( rval ) { //<S2SV> rval = - EFAULT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; //<S2SV> if ( msg -> msg_name != NULL ) //<S2SV> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; //<S2SV> out : //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> out_nofree : //<S2SV> return rval ; //<S2SV> } //<S2SV> 