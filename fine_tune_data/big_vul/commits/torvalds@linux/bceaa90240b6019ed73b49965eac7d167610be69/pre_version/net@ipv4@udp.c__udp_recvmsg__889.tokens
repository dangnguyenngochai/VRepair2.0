int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , //<S2SV> size_t len , int noblock , int flags , int * addr_len ) //<S2SV> { //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; //<S2SV> struct sk_buff * skb ; //<S2SV> unsigned int ulen , copied ; //<S2SV> int peeked , off = 0 ; //<S2SV> int err ; //<S2SV> int is_udplite = IS_UDPLITE ( sk ) ; //<S2SV> bool slow ; //<S2SV> if ( addr_len ) //<S2SV> * addr_len = sizeof ( * sin ) ; //<S2SV> if ( flags & MSG_ERRQUEUE ) //<S2SV> return ip_recv_error ( sk , msg , len ) ; //<S2SV> try_again : //<S2SV> skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , //<S2SV> & peeked , & off , & err ) ; //<S2SV> if ( ! skb ) //<S2SV> goto out ; //<S2SV> ulen = skb -> len - sizeof ( struct udphdr ) ; //<S2SV> copied = len ; //<S2SV> if ( copied > ulen ) //<S2SV> copied = ulen ; //<S2SV> else if ( copied < ulen ) //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { //<S2SV> if ( udp_lib_checksum_complete ( skb ) ) //<S2SV> goto csum_copy_err ; //<S2SV> } //<S2SV> if ( skb_csum_unnecessary ( skb ) ) //<S2SV> err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , //<S2SV> msg -> msg_iov , copied ) ; //<S2SV> else { //<S2SV> err = skb_copy_and_csum_datagram_iovec ( skb , //<S2SV> sizeof ( struct udphdr ) , //<S2SV> msg -> msg_iov ) ; //<S2SV> if ( err == - EINVAL ) //<S2SV> goto csum_copy_err ; //<S2SV> } //<S2SV> if ( unlikely ( err ) ) { //<S2SV> trace_kfree_skb ( skb , udp_recvmsg ) ; //<S2SV> if ( ! peeked ) { //<S2SV> atomic_inc ( & sk -> sk_drops ) ; //<S2SV> UDP_INC_STATS_USER ( sock_net ( sk ) , //<S2SV> UDP_MIB_INERRORS , is_udplite ) ; //<S2SV> } //<S2SV> goto out_free ; //<S2SV> } //<S2SV> if ( ! peeked ) //<S2SV> UDP_INC_STATS_USER ( sock_net ( sk ) , //<S2SV> UDP_MIB_INDATAGRAMS , is_udplite ) ; //<S2SV> sock_recv_ts_and_drops ( msg , sk , skb ) ; //<S2SV> if ( sin ) { //<S2SV> sin -> sin_family = AF_INET ; //<S2SV> sin -> sin_port = udp_hdr ( skb ) -> source ; //<S2SV> sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; //<S2SV> memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; //<S2SV> } //<S2SV> if ( inet -> cmsg_flags ) //<S2SV> ip_cmsg_recv ( msg , skb ) ; //<S2SV> err = copied ; //<S2SV> if ( flags & MSG_TRUNC ) //<S2SV> err = ulen ; //<S2SV> out_free : //<S2SV> skb_free_datagram_locked ( sk , skb ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> csum_copy_err : //<S2SV> slow = lock_sock_fast ( sk ) ; //<S2SV> if ( ! skb_kill_datagram ( sk , skb , flags ) ) { //<S2SV> UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; //<S2SV> UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; //<S2SV> } //<S2SV> unlock_sock_fast ( sk , slow ) ; //<S2SV> if ( noblock ) //<S2SV> return - EAGAIN ; //<S2SV> msg -> msg_flags &= ~ MSG_TRUNC ; //<S2SV> goto try_again ; //<S2SV> } //<S2SV> 