static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , //<S2SV> u16 selector , int seg , u8 cpl , //<S2SV> bool in_task_switch , //<S2SV> struct desc_struct * desc ) //<S2SV> { //<S2SV> struct desc_struct seg_desc , old_desc ; //<S2SV> u8 dpl , rpl ; //<S2SV> unsigned err_vec = GP_VECTOR ; //<S2SV> u32 err_code = 0 ; //<S2SV> bool null_selector = ! ( selector & ~ 0x3 ) ; //<S2SV> ulong desc_addr ; //<S2SV> int ret ; //<S2SV> u16 dummy ; //<S2SV> u32 base3 = 0 ; //<S2SV> memset ( & seg_desc , 0 , sizeof seg_desc ) ; //<S2SV> if ( ctxt -> mode == X86EMUL_MODE_REAL ) { //<S2SV> ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , NULL , seg ) ; //<S2SV> set_desc_base ( & seg_desc , selector << 4 ) ; //<S2SV> goto load ; //<S2SV> } else if ( seg <= VCPU_SREG_GS && ctxt -> mode == X86EMUL_MODE_VM86 ) { //<S2SV> set_desc_base ( & seg_desc , selector << 4 ) ; //<S2SV> set_desc_limit ( & seg_desc , 0xffff ) ; //<S2SV> seg_desc . type = 3 ; //<S2SV> seg_desc . p = 1 ; //<S2SV> seg_desc . s = 1 ; //<S2SV> seg_desc . dpl = 3 ; //<S2SV> goto load ; //<S2SV> } //<S2SV> rpl = selector & 3 ; //<S2SV> if ( ( seg == VCPU_SREG_CS //<S2SV> || ( seg == VCPU_SREG_SS //<S2SV> && ( ctxt -> mode != X86EMUL_MODE_PROT64 || rpl != cpl ) ) //<S2SV> || seg == VCPU_SREG_TR ) //<S2SV> && null_selector ) //<S2SV> goto exception ; //<S2SV> if ( seg == VCPU_SREG_TR && ( selector & ( 1 << 2 ) ) ) //<S2SV> goto exception ; //<S2SV> if ( null_selector ) //<S2SV> goto load ; //<S2SV> ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ; //<S2SV> if ( ret != X86EMUL_CONTINUE ) //<S2SV> return ret ; //<S2SV> err_code = selector & 0xfffc ; //<S2SV> err_vec = in_task_switch ? TS_VECTOR : GP_VECTOR ; //<S2SV> if ( seg <= VCPU_SREG_GS && ! seg_desc . s ) //<S2SV> goto exception ; //<S2SV> if ( ! seg_desc . p ) { //<S2SV> err_vec = ( seg == VCPU_SREG_SS ) ? SS_VECTOR : NP_VECTOR ; //<S2SV> goto exception ; //<S2SV> } //<S2SV> dpl = seg_desc . dpl ; //<S2SV> switch ( seg ) { //<S2SV> case VCPU_SREG_SS : //<S2SV> if ( rpl != cpl || ( seg_desc . type & 0xa ) != 0x2 || dpl != cpl ) //<S2SV> goto exception ; //<S2SV> break ; //<S2SV> case VCPU_SREG_CS : //<S2SV> if ( ! ( seg_desc . type & 8 ) ) //<S2SV> goto exception ; //<S2SV> if ( seg_desc . type & 4 ) { //<S2SV> if ( dpl > cpl ) //<S2SV> goto exception ; //<S2SV> } else { //<S2SV> if ( rpl > cpl || dpl != cpl ) //<S2SV> goto exception ; //<S2SV> } //<S2SV> if ( seg_desc . d && seg_desc . l ) { //<S2SV> u64 efer = 0 ; //<S2SV> ctxt -> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; //<S2SV> if ( efer & EFER_LMA ) //<S2SV> goto exception ; //<S2SV> } //<S2SV> selector = ( selector & 0xfffc ) | cpl ; //<S2SV> break ; //<S2SV> case VCPU_SREG_TR : //<S2SV> if ( seg_desc . s || ( seg_desc . type != 1 && seg_desc . type != 9 ) ) //<S2SV> goto exception ; //<S2SV> old_desc = seg_desc ; //<S2SV> seg_desc . type |= 2 ; //<S2SV> ret = ctxt -> ops -> cmpxchg_emulated ( ctxt , desc_addr , & old_desc , & seg_desc , //<S2SV> sizeof ( seg_desc ) , & ctxt -> exception ) ; //<S2SV> if ( ret != X86EMUL_CONTINUE ) //<S2SV> return ret ; //<S2SV> break ; //<S2SV> case VCPU_SREG_LDTR : //<S2SV> if ( seg_desc . s || seg_desc . type != 2 ) //<S2SV> goto exception ; //<S2SV> break ; //<S2SV> default : //<S2SV> if ( ( seg_desc . type & 0xa ) == 0x8 || //<S2SV> ( ( ( seg_desc . type & 0xc ) != 0xc ) && //<S2SV> ( rpl > dpl && cpl > dpl ) ) ) //<S2SV> goto exception ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( seg_desc . s ) { //<S2SV> seg_desc . type |= 1 ; //<S2SV> ret = write_segment_descriptor ( ctxt , selector , & seg_desc ) ; //<S2SV> if ( ret != X86EMUL_CONTINUE ) //<S2SV> return ret ; //<S2SV> } else if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) { //<S2SV> ret = ctxt -> ops -> read_std ( ctxt , desc_addr + 8 , & base3 , //<S2SV> sizeof ( base3 ) , & ctxt -> exception ) ; //<S2SV> if ( ret != X86EMUL_CONTINUE ) //<S2SV> return ret ; //<S2SV> } //<S2SV> load : //<S2SV> ctxt -> ops -> set_segment ( ctxt , selector , & seg_desc , base3 , seg ) ; //<S2SV> if ( desc ) //<S2SV> * desc = seg_desc ; //<S2SV> return X86EMUL_CONTINUE ; //<S2SV> exception : //<S2SV> return emulate_exception ( ctxt , err_vec , err_code , true ) ; //<S2SV> } //<S2SV> 