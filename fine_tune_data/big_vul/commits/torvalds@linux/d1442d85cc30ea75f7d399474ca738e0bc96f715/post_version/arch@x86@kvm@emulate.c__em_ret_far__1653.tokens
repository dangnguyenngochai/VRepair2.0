static int em_ret_far ( struct x86_emulate_ctxt * ctxt ) //<S2SV> { //<S2SV> int rc ; //<S2SV> unsigned long eip , cs ; //<S2SV> u16 old_cs ; //<S2SV> int cpl = ctxt -> ops -> cpl ( ctxt ) ; //<S2SV> struct desc_struct old_desc , new_desc ; //<S2SV> const struct x86_emulate_ops * ops = ctxt -> ops ; //<S2SV> if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) //<S2SV> ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , //<S2SV> VCPU_SREG_CS ) ; //<S2SV> rc = emulate_pop ( ctxt , & eip , ctxt -> op_bytes ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> return rc ; //<S2SV> rc = emulate_pop ( ctxt , & cs , ctxt -> op_bytes ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> return rc ; //<S2SV> if ( ctxt -> mode >= X86EMUL_MODE_PROT16 && ( cs & 3 ) > cpl ) //<S2SV> return X86EMUL_UNHANDLEABLE ; //<S2SV> rc = __load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS , 0 , false , //<S2SV> & new_desc ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> return rc ; //<S2SV> rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) { //<S2SV> WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; //<S2SV> ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; //<S2SV> } //<S2SV> return rc ; //<S2SV> } //<S2SV> 