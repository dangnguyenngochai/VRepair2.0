static int em_call_far ( struct x86_emulate_ctxt * ctxt ) //<S2SV> { //<S2SV> u16 sel , old_cs ; //<S2SV> ulong old_eip ; //<S2SV> int rc ; //<S2SV> struct desc_struct old_desc , new_desc ; //<S2SV> const struct x86_emulate_ops * ops = ctxt -> ops ; //<S2SV> int cpl = ctxt -> ops -> cpl ( ctxt ) ; //<S2SV> old_eip = ctxt -> _eip ; //<S2SV> ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; //<S2SV> memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; //<S2SV> rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , //<S2SV> & new_desc ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> return X86EMUL_CONTINUE ; //<S2SV> rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto fail ; //<S2SV> ctxt -> src . val = old_cs ; //<S2SV> rc = em_push ( ctxt ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto fail ; //<S2SV> ctxt -> src . val = old_eip ; //<S2SV> rc = em_push ( ctxt ) ; //<S2SV> if ( rc != X86EMUL_CONTINUE ) //<S2SV> goto fail ; //<S2SV> return rc ; //<S2SV> fail : //<S2SV> ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 