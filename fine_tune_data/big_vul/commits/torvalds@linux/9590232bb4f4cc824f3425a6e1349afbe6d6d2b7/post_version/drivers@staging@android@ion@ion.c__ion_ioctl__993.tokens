static long ion_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) //<S2SV> { //<S2SV> struct ion_client * client = filp -> private_data ; //<S2SV> struct ion_device * dev = client -> dev ; //<S2SV> struct ion_handle * cleanup_handle = NULL ; //<S2SV> int ret = 0 ; //<S2SV> unsigned int dir ; //<S2SV> union { //<S2SV> struct ion_fd_data fd ; //<S2SV> struct ion_allocation_data allocation ; //<S2SV> struct ion_handle_data handle ; //<S2SV> struct ion_custom_data custom ; //<S2SV> } data ; //<S2SV> dir = ion_ioctl_dir ( cmd ) ; //<S2SV> if ( _IOC_SIZE ( cmd ) > sizeof ( data ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( dir & _IOC_WRITE ) //<S2SV> if ( copy_from_user ( & data , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) //<S2SV> return - EFAULT ; //<S2SV> switch ( cmd ) { //<S2SV> case ION_IOC_ALLOC : //<S2SV> { //<S2SV> struct ion_handle * handle ; //<S2SV> handle = ion_alloc ( client , data . allocation . len , //<S2SV> data . allocation . align , //<S2SV> data . allocation . heap_id_mask , //<S2SV> data . allocation . flags ) ; //<S2SV> if ( IS_ERR ( handle ) ) //<S2SV> return PTR_ERR ( handle ) ; //<S2SV> data . allocation . handle = handle -> id ; //<S2SV> cleanup_handle = handle ; //<S2SV> break ; //<S2SV> } //<S2SV> case ION_IOC_FREE : //<S2SV> { //<S2SV> struct ion_handle * handle ; //<S2SV> mutex_lock ( & client -> lock ) ; //<S2SV> handle = ion_handle_get_by_id_nolock ( client , data . handle . handle ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> mutex_unlock ( & client -> lock ) ; //<S2SV> return PTR_ERR ( handle ) ; //<S2SV> } //<S2SV> ion_free_nolock ( client , handle ) ; //<S2SV> ion_handle_put_nolock ( handle ) ; //<S2SV> mutex_unlock ( & client -> lock ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case ION_IOC_SHARE : //<S2SV> case ION_IOC_MAP : //<S2SV> { //<S2SV> struct ion_handle * handle ; //<S2SV> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; //<S2SV> if ( IS_ERR ( handle ) ) //<S2SV> return PTR_ERR ( handle ) ; //<S2SV> data . fd . fd = ion_share_dma_buf_fd ( client , handle ) ; //<S2SV> ion_handle_put ( handle ) ; //<S2SV> if ( data . fd . fd < 0 ) //<S2SV> ret = data . fd . fd ; //<S2SV> break ; //<S2SV> } //<S2SV> case ION_IOC_IMPORT : //<S2SV> { //<S2SV> struct ion_handle * handle ; //<S2SV> handle = ion_import_dma_buf_fd ( client , data . fd . fd ) ; //<S2SV> if ( IS_ERR ( handle ) ) //<S2SV> ret = PTR_ERR ( handle ) ; //<S2SV> else //<S2SV> data . handle . handle = handle -> id ; //<S2SV> break ; //<S2SV> } //<S2SV> case ION_IOC_SYNC : //<S2SV> { //<S2SV> ret = ion_sync_for_device ( client , data . fd . fd ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case ION_IOC_CUSTOM : //<S2SV> { //<S2SV> if ( ! dev -> custom_ioctl ) //<S2SV> return - ENOTTY ; //<S2SV> ret = dev -> custom_ioctl ( client , data . custom . cmd , //<S2SV> data . custom . arg ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> return - ENOTTY ; //<S2SV> } //<S2SV> if ( dir & _IOC_READ ) { //<S2SV> if ( copy_to_user ( ( void __user * ) arg , & data , _IOC_SIZE ( cmd ) ) ) { //<S2SV> if ( cleanup_handle ) //<S2SV> ion_free ( client , cleanup_handle ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 