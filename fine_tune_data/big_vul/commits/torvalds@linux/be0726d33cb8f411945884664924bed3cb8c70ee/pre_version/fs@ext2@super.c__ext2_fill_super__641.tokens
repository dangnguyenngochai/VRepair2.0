static int ext2_fill_super ( struct super_block * sb , void * data , int silent ) //<S2SV> { //<S2SV> struct buffer_head * bh ; //<S2SV> struct ext2_sb_info * sbi ; //<S2SV> struct ext2_super_block * es ; //<S2SV> struct inode * root ; //<S2SV> unsigned long block ; //<S2SV> unsigned long sb_block = get_sb_block ( & data ) ; //<S2SV> unsigned long logic_sb_block ; //<S2SV> unsigned long offset = 0 ; //<S2SV> unsigned long def_mount_opts ; //<S2SV> long ret = - EINVAL ; //<S2SV> int blocksize = BLOCK_SIZE ; //<S2SV> int db_count ; //<S2SV> int i , j ; //<S2SV> __le32 features ; //<S2SV> int err ; //<S2SV> err = - ENOMEM ; //<S2SV> sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; //<S2SV> if ( ! sbi ) //<S2SV> goto failed ; //<S2SV> sbi -> s_blockgroup_lock = //<S2SV> kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; //<S2SV> if ( ! sbi -> s_blockgroup_lock ) { //<S2SV> kfree ( sbi ) ; //<S2SV> goto failed ; //<S2SV> } //<S2SV> sb -> s_fs_info = sbi ; //<S2SV> sbi -> s_sb_block = sb_block ; //<S2SV> spin_lock_init ( & sbi -> s_lock ) ; //<S2SV> blocksize = sb_min_blocksize ( sb , BLOCK_SIZE ) ; //<S2SV> if ( ! blocksize ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize" ) ; //<S2SV> goto failed_sbi ; //<S2SV> } //<S2SV> if ( blocksize != BLOCK_SIZE ) { //<S2SV> logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; //<S2SV> offset = ( sb_block * BLOCK_SIZE ) % blocksize ; //<S2SV> } else { //<S2SV> logic_sb_block = sb_block ; //<S2SV> } //<S2SV> if ( ! ( bh = sb_bread ( sb , logic_sb_block ) ) ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock" ) ; //<S2SV> goto failed_sbi ; //<S2SV> } //<S2SV> es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; //<S2SV> sbi -> s_es = es ; //<S2SV> sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; //<S2SV> if ( sb -> s_magic != EXT2_SUPER_MAGIC ) //<S2SV> goto cantfind_ext2 ; //<S2SV> def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; //<S2SV> if ( def_mount_opts & EXT2_DEFM_DEBUG ) //<S2SV> set_opt ( sbi -> s_mount_opt , DEBUG ) ; //<S2SV> if ( def_mount_opts & EXT2_DEFM_BSDGROUPS ) //<S2SV> set_opt ( sbi -> s_mount_opt , GRPID ) ; //<S2SV> if ( def_mount_opts & EXT2_DEFM_UID16 ) //<S2SV> set_opt ( sbi -> s_mount_opt , NO_UID32 ) ; //<S2SV> # ifdef CONFIG_EXT2_FS_XATTR //<S2SV> if ( def_mount_opts & EXT2_DEFM_XATTR_USER ) //<S2SV> set_opt ( sbi -> s_mount_opt , XATTR_USER ) ; //<S2SV> # endif //<S2SV> # ifdef CONFIG_EXT2_FS_POSIX_ACL //<S2SV> if ( def_mount_opts & EXT2_DEFM_ACL ) //<S2SV> set_opt ( sbi -> s_mount_opt , POSIX_ACL ) ; //<S2SV> # endif //<S2SV> if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT2_ERRORS_PANIC ) //<S2SV> set_opt ( sbi -> s_mount_opt , ERRORS_PANIC ) ; //<S2SV> else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT2_ERRORS_CONTINUE ) //<S2SV> set_opt ( sbi -> s_mount_opt , ERRORS_CONT ) ; //<S2SV> else //<S2SV> set_opt ( sbi -> s_mount_opt , ERRORS_RO ) ; //<S2SV> sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; //<S2SV> sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; //<S2SV> set_opt ( sbi -> s_mount_opt , RESERVATION ) ; //<S2SV> if ( ! parse_options ( ( char * ) data , sb ) ) //<S2SV> goto failed_mount ; //<S2SV> sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | //<S2SV> ( ( EXT2_SB ( sb ) -> s_mount_opt & EXT2_MOUNT_POSIX_ACL ) ? //<S2SV> MS_POSIXACL : 0 ) ; //<S2SV> sb -> s_iflags |= SB_I_CGROUPWB ; //<S2SV> if ( le32_to_cpu ( es -> s_rev_level ) == EXT2_GOOD_OLD_REV && //<S2SV> ( EXT2_HAS_COMPAT_FEATURE ( sb , ~ 0U ) || //<S2SV> EXT2_HAS_RO_COMPAT_FEATURE ( sb , ~ 0U ) || //<S2SV> EXT2_HAS_INCOMPAT_FEATURE ( sb , ~ 0U ) ) ) //<S2SV> ext2_msg ( sb , KERN_WARNING , //<S2SV> "warning:<S2SV_blank>feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>" //<S2SV> "running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended" ) ; //<S2SV> features = EXT2_HAS_INCOMPAT_FEATURE ( sb , ~ EXT2_FEATURE_INCOMPAT_SUPP ) ; //<S2SV> if ( features ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>couldn\'t<S2SV_blank>mount<S2SV_blank>because<S2SV_blank>of<S2SV_blank>" //<S2SV> "unsupported<S2SV_blank>optional<S2SV_blank>features<S2SV_blank>(%x)" , //<S2SV> le32_to_cpu ( features ) ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( ! ( sb -> s_flags & MS_RDONLY ) && //<S2SV> ( features = EXT2_HAS_RO_COMPAT_FEATURE ( sb , ~ EXT2_FEATURE_RO_COMPAT_SUPP ) ) ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>couldn\'t<S2SV_blank>mount<S2SV_blank>RDWR<S2SV_blank>because<S2SV_blank>of<S2SV_blank>" //<S2SV> "unsupported<S2SV_blank>optional<S2SV_blank>features<S2SV_blank>(%x)" , //<S2SV> le32_to_cpu ( features ) ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> blocksize = BLOCK_SIZE << le32_to_cpu ( sbi -> s_es -> s_log_block_size ) ; //<S2SV> if ( sbi -> s_mount_opt & EXT2_MOUNT_DAX ) { //<S2SV> if ( blocksize != PAGE_SIZE ) { //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>dax" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( ! sb -> s_bdev -> bd_disk -> fops -> direct_access ) { //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>dax" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> if ( sb -> s_blocksize != blocksize ) { //<S2SV> brelse ( bh ) ; //<S2SV> if ( ! sb_set_blocksize ( sb , blocksize ) ) { //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>bad<S2SV_blank>blocksize<S2SV_blank>%d" , blocksize ) ; //<S2SV> goto failed_sbi ; //<S2SV> } //<S2SV> logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; //<S2SV> offset = ( sb_block * BLOCK_SIZE ) % blocksize ; //<S2SV> bh = sb_bread ( sb , logic_sb_block ) ; //<S2SV> if ( ! bh ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>couldn\'t<S2SV_blank>read" //<S2SV> "superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try" ) ; //<S2SV> goto failed_sbi ; //<S2SV> } //<S2SV> es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; //<S2SV> sbi -> s_es = es ; //<S2SV> if ( es -> s_magic != cpu_to_le16 ( EXT2_SUPER_MAGIC ) ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>magic<S2SV_blank>mismatch" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> sb -> s_maxbytes = ext2_max_size ( sb -> s_blocksize_bits ) ; //<S2SV> sb -> s_max_links = EXT2_LINK_MAX ; //<S2SV> if ( le32_to_cpu ( es -> s_rev_level ) == EXT2_GOOD_OLD_REV ) { //<S2SV> sbi -> s_inode_size = EXT2_GOOD_OLD_INODE_SIZE ; //<S2SV> sbi -> s_first_ino = EXT2_GOOD_OLD_FIRST_INO ; //<S2SV> } else { //<S2SV> sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; //<S2SV> sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; //<S2SV> if ( ( sbi -> s_inode_size < EXT2_GOOD_OLD_INODE_SIZE ) || //<S2SV> ! is_power_of_2 ( sbi -> s_inode_size ) || //<S2SV> ( sbi -> s_inode_size > blocksize ) ) { //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d" , //<S2SV> sbi -> s_inode_size ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> sbi -> s_frag_size = EXT2_MIN_FRAG_SIZE << //<S2SV> le32_to_cpu ( es -> s_log_frag_size ) ; //<S2SV> if ( sbi -> s_frag_size == 0 ) //<S2SV> goto cantfind_ext2 ; //<S2SV> sbi -> s_frags_per_block = sb -> s_blocksize / sbi -> s_frag_size ; //<S2SV> sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; //<S2SV> sbi -> s_frags_per_group = le32_to_cpu ( es -> s_frags_per_group ) ; //<S2SV> sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; //<S2SV> if ( EXT2_INODE_SIZE ( sb ) == 0 ) //<S2SV> goto cantfind_ext2 ; //<S2SV> sbi -> s_inodes_per_block = sb -> s_blocksize / EXT2_INODE_SIZE ( sb ) ; //<S2SV> if ( sbi -> s_inodes_per_block == 0 || sbi -> s_inodes_per_group == 0 ) //<S2SV> goto cantfind_ext2 ; //<S2SV> sbi -> s_itb_per_group = sbi -> s_inodes_per_group / //<S2SV> sbi -> s_inodes_per_block ; //<S2SV> sbi -> s_desc_per_block = sb -> s_blocksize / //<S2SV> sizeof ( struct ext2_group_desc ) ; //<S2SV> sbi -> s_sbh = bh ; //<S2SV> sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; //<S2SV> sbi -> s_addr_per_block_bits = //<S2SV> ilog2 ( EXT2_ADDR_PER_BLOCK ( sb ) ) ; //<S2SV> sbi -> s_desc_per_block_bits = //<S2SV> ilog2 ( EXT2_DESC_PER_BLOCK ( sb ) ) ; //<S2SV> if ( sb -> s_magic != EXT2_SUPER_MAGIC ) //<S2SV> goto cantfind_ext2 ; //<S2SV> if ( sb -> s_blocksize != bh -> b_size ) { //<S2SV> if ( ! silent ) //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>unsupported<S2SV_blank>blocksize" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( sb -> s_blocksize != sbi -> s_frag_size ) { //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>fragsize<S2SV_blank>%lu<S2SV_blank>!=<S2SV_blank>blocksize<S2SV_blank>%lu" //<S2SV> "(not<S2SV_blank>supported<S2SV_blank>yet)" , //<S2SV> sbi -> s_frag_size , sb -> s_blocksize ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( sbi -> s_blocks_per_group > sb -> s_blocksize * 8 ) { //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu" , //<S2SV> sbi -> s_blocks_per_group ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( sbi -> s_frags_per_group > sb -> s_blocksize * 8 ) { //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>#fragments<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu" , //<S2SV> sbi -> s_frags_per_group ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( sbi -> s_inodes_per_group > sb -> s_blocksize * 8 ) { //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>#inodes<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu" , //<S2SV> sbi -> s_inodes_per_group ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( EXT2_BLOCKS_PER_GROUP ( sb ) == 0 ) //<S2SV> goto cantfind_ext2 ; //<S2SV> sbi -> s_groups_count = ( ( le32_to_cpu ( es -> s_blocks_count ) - //<S2SV> le32_to_cpu ( es -> s_first_data_block ) - 1 ) //<S2SV> / EXT2_BLOCKS_PER_GROUP ( sb ) ) + 1 ; //<S2SV> db_count = ( sbi -> s_groups_count + EXT2_DESC_PER_BLOCK ( sb ) - 1 ) / //<S2SV> EXT2_DESC_PER_BLOCK ( sb ) ; //<S2SV> sbi -> s_group_desc = kmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; //<S2SV> if ( sbi -> s_group_desc == NULL ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>memory" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> bgl_lock_init ( sbi -> s_blockgroup_lock ) ; //<S2SV> sbi -> s_debts = kcalloc ( sbi -> s_groups_count , sizeof ( * sbi -> s_debts ) , GFP_KERNEL ) ; //<S2SV> if ( ! sbi -> s_debts ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>memory" ) ; //<S2SV> goto failed_mount_group_desc ; //<S2SV> } //<S2SV> for ( i = 0 ; i < db_count ; i ++ ) { //<S2SV> block = descriptor_loc ( sb , logic_sb_block , i ) ; //<S2SV> sbi -> s_group_desc [ i ] = sb_bread ( sb , block ) ; //<S2SV> if ( ! sbi -> s_group_desc [ i ] ) { //<S2SV> for ( j = 0 ; j < i ; j ++ ) //<S2SV> brelse ( sbi -> s_group_desc [ j ] ) ; //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptors" ) ; //<S2SV> goto failed_mount_group_desc ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ext2_check_descriptors ( sb ) ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "group<S2SV_blank>descriptors<S2SV_blank>corrupted" ) ; //<S2SV> goto failed_mount2 ; //<S2SV> } //<S2SV> sbi -> s_gdb_count = db_count ; //<S2SV> get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; //<S2SV> spin_lock_init ( & sbi -> s_next_gen_lock ) ; //<S2SV> spin_lock_init ( & sbi -> s_rsv_window_lock ) ; //<S2SV> sbi -> s_rsv_window_root = RB_ROOT ; //<S2SV> sbi -> s_rsv_window_head . rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED ; //<S2SV> sbi -> s_rsv_window_head . rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED ; //<S2SV> sbi -> s_rsv_window_head . rsv_alloc_hit = 0 ; //<S2SV> sbi -> s_rsv_window_head . rsv_goal_size = 0 ; //<S2SV> ext2_rsv_window_add ( sb , & sbi -> s_rsv_window_head ) ; //<S2SV> err = percpu_counter_init ( & sbi -> s_freeblocks_counter , //<S2SV> ext2_count_free_blocks ( sb ) , GFP_KERNEL ) ; //<S2SV> if ( ! err ) { //<S2SV> err = percpu_counter_init ( & sbi -> s_freeinodes_counter , //<S2SV> ext2_count_free_inodes ( sb ) , GFP_KERNEL ) ; //<S2SV> } //<S2SV> if ( ! err ) { //<S2SV> err = percpu_counter_init ( & sbi -> s_dirs_counter , //<S2SV> ext2_count_dirs ( sb ) , GFP_KERNEL ) ; //<S2SV> } //<S2SV> if ( err ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>insufficient<S2SV_blank>memory" ) ; //<S2SV> goto failed_mount3 ; //<S2SV> } //<S2SV> sb -> s_op = & ext2_sops ; //<S2SV> sb -> s_export_op = & ext2_export_ops ; //<S2SV> sb -> s_xattr = ext2_xattr_handlers ; //<S2SV> # ifdef CONFIG_QUOTA //<S2SV> sb -> dq_op = & dquot_operations ; //<S2SV> sb -> s_qcop = & dquot_quotactl_ops ; //<S2SV> sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP ; //<S2SV> # endif //<S2SV> root = ext2_iget ( sb , EXT2_ROOT_INO ) ; //<S2SV> if ( IS_ERR ( root ) ) { //<S2SV> ret = PTR_ERR ( root ) ; //<S2SV> goto failed_mount3 ; //<S2SV> } //<S2SV> if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { //<S2SV> iput ( root ) ; //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck" ) ; //<S2SV> goto failed_mount3 ; //<S2SV> } //<S2SV> sb -> s_root = d_make_root ( root ) ; //<S2SV> if ( ! sb -> s_root ) { //<S2SV> ext2_msg ( sb , KERN_ERR , "error:<S2SV_blank>get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed" ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto failed_mount3 ; //<S2SV> } //<S2SV> if ( EXT2_HAS_COMPAT_FEATURE ( sb , EXT3_FEATURE_COMPAT_HAS_JOURNAL ) ) //<S2SV> ext2_msg ( sb , KERN_WARNING , //<S2SV> "warning:<S2SV_blank>mounting<S2SV_blank>ext3<S2SV_blank>filesystem<S2SV_blank>as<S2SV_blank>ext2" ) ; //<S2SV> if ( ext2_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) //<S2SV> sb -> s_flags |= MS_RDONLY ; //<S2SV> ext2_write_super ( sb ) ; //<S2SV> return 0 ; //<S2SV> cantfind_ext2 : //<S2SV> if ( ! silent ) //<S2SV> ext2_msg ( sb , KERN_ERR , //<S2SV> "error:<S2SV_blank>can\'t<S2SV_blank>find<S2SV_blank>an<S2SV_blank>ext2<S2SV_blank>filesystem<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>%s." , //<S2SV> sb -> s_id ) ; //<S2SV> goto failed_mount ; //<S2SV> failed_mount3 : //<S2SV> percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; //<S2SV> percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; //<S2SV> percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; //<S2SV> failed_mount2 : //<S2SV> for ( i = 0 ; i < db_count ; i ++ ) //<S2SV> brelse ( sbi -> s_group_desc [ i ] ) ; //<S2SV> failed_mount_group_desc : //<S2SV> kfree ( sbi -> s_group_desc ) ; //<S2SV> kfree ( sbi -> s_debts ) ; //<S2SV> failed_mount : //<S2SV> brelse ( bh ) ; //<S2SV> failed_sbi : //<S2SV> sb -> s_fs_info = NULL ; //<S2SV> kfree ( sbi -> s_blockgroup_lock ) ; //<S2SV> kfree ( sbi ) ; //<S2SV> failed : //<S2SV> return ret ; //<S2SV> } //<S2SV> 