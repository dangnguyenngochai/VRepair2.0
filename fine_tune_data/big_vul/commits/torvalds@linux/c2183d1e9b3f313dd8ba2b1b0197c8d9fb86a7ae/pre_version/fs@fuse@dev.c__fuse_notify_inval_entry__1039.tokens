static int fuse_notify_inval_entry ( struct fuse_conn * fc , unsigned int size , //<S2SV> struct fuse_copy_state * cs ) //<S2SV> { //<S2SV> struct fuse_notify_inval_entry_out outarg ; //<S2SV> int err = - ENOMEM ; //<S2SV> char * buf ; //<S2SV> struct qstr name ; //<S2SV> buf = kzalloc ( FUSE_NAME_MAX + 1 , GFP_KERNEL ) ; //<S2SV> if ( ! buf ) //<S2SV> goto err ; //<S2SV> err = - EINVAL ; //<S2SV> if ( size < sizeof ( outarg ) ) //<S2SV> goto err ; //<S2SV> err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ; //<S2SV> if ( err ) //<S2SV> goto err ; //<S2SV> err = - ENAMETOOLONG ; //<S2SV> if ( outarg . namelen > FUSE_NAME_MAX ) //<S2SV> goto err ; //<S2SV> name . name = buf ; //<S2SV> name . len = outarg . namelen ; //<S2SV> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; //<S2SV> if ( err ) //<S2SV> goto err ; //<S2SV> fuse_copy_finish ( cs ) ; //<S2SV> buf [ outarg . namelen ] = 0 ; //<S2SV> name . hash = full_name_hash ( name . name , name . len ) ; //<S2SV> down_read ( & fc -> killsb ) ; //<S2SV> err = - ENOENT ; //<S2SV> if ( fc -> sb ) //<S2SV> err = fuse_reverse_inval_entry ( fc -> sb , outarg . parent , & name ) ; //<S2SV> up_read ( & fc -> killsb ) ; //<S2SV> kfree ( buf ) ; //<S2SV> return err ; //<S2SV> err : //<S2SV> kfree ( buf ) ; //<S2SV> fuse_copy_finish ( cs ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 