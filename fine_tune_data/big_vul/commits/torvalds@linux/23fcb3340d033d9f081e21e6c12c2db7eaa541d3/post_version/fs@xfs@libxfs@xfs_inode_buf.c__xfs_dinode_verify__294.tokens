xfs_failaddr_t //<S2SV> xfs_dinode_verify ( //<S2SV> struct xfs_mount * mp , //<S2SV> xfs_ino_t ino , //<S2SV> struct xfs_dinode * dip ) //<S2SV> { //<S2SV> xfs_failaddr_t fa ; //<S2SV> uint16_t mode ; //<S2SV> uint16_t flags ; //<S2SV> uint64_t flags2 ; //<S2SV> uint64_t di_size ; //<S2SV> if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) //<S2SV> return __this_address ; //<S2SV> if ( dip -> di_version >= 3 ) { //<S2SV> if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) //<S2SV> return __this_address ; //<S2SV> if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , //<S2SV> XFS_DINODE_CRC_OFF ) ) //<S2SV> return __this_address ; //<S2SV> if ( be64_to_cpu ( dip -> di_ino ) != ino ) //<S2SV> return __this_address ; //<S2SV> if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) //<S2SV> return __this_address ; //<S2SV> } //<S2SV> di_size = be64_to_cpu ( dip -> di_size ) ; //<S2SV> if ( di_size & ( 1ULL << 63 ) ) //<S2SV> return __this_address ; //<S2SV> mode = be16_to_cpu ( dip -> di_mode ) ; //<S2SV> if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) //<S2SV> return __this_address ; //<S2SV> if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) //<S2SV> return __this_address ; //<S2SV> if ( mode && //<S2SV> be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > //<S2SV> be64_to_cpu ( dip -> di_nblocks ) ) //<S2SV> return __this_address ; //<S2SV> if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) //<S2SV> return __this_address ; //<S2SV> flags = be16_to_cpu ( dip -> di_flags ) ; //<S2SV> if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) //<S2SV> return __this_address ; //<S2SV> switch ( mode & S_IFMT ) { //<S2SV> case S_IFIFO : //<S2SV> case S_IFCHR : //<S2SV> case S_IFBLK : //<S2SV> case S_IFSOCK : //<S2SV> if ( dip -> di_format != XFS_DINODE_FMT_DEV ) //<S2SV> return __this_address ; //<S2SV> break ; //<S2SV> case S_IFREG : //<S2SV> case S_IFLNK : //<S2SV> case S_IFDIR : //<S2SV> fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; //<S2SV> if ( fa ) //<S2SV> return fa ; //<S2SV> break ; //<S2SV> case 0 : //<S2SV> break ; //<S2SV> default : //<S2SV> return __this_address ; //<S2SV> } //<S2SV> if ( XFS_DFORK_Q ( dip ) ) { //<S2SV> fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; //<S2SV> if ( fa ) //<S2SV> return fa ; //<S2SV> } else { //<S2SV> switch ( dip -> di_aformat ) { //<S2SV> case 0 : //<S2SV> case XFS_DINODE_FMT_EXTENTS : //<S2SV> break ; //<S2SV> default : //<S2SV> return __this_address ; //<S2SV> } //<S2SV> if ( dip -> di_anextents ) //<S2SV> return __this_address ; //<S2SV> } //<S2SV> fa = xfs_inode_validate_extsize ( mp , be32_to_cpu ( dip -> di_extsize ) , //<S2SV> mode , flags ) ; //<S2SV> if ( fa ) //<S2SV> return fa ; //<S2SV> if ( dip -> di_version < 3 ) //<S2SV> return NULL ; //<S2SV> flags2 = be64_to_cpu ( dip -> di_flags2 ) ; //<S2SV> if ( ( flags2 & ( XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE ) ) && //<S2SV> ! xfs_sb_version_hasreflink ( & mp -> m_sb ) ) //<S2SV> return __this_address ; //<S2SV> if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( mode & S_IFMT ) != S_IFREG ) //<S2SV> return __this_address ; //<S2SV> if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags & XFS_DIFLAG_REALTIME ) ) //<S2SV> return __this_address ; //<S2SV> if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags2 & XFS_DIFLAG2_DAX ) ) //<S2SV> return __this_address ; //<S2SV> fa = xfs_inode_validate_cowextsize ( mp , be32_to_cpu ( dip -> di_cowextsize ) , //<S2SV> mode , flags , flags2 ) ; //<S2SV> if ( fa ) //<S2SV> return fa ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 