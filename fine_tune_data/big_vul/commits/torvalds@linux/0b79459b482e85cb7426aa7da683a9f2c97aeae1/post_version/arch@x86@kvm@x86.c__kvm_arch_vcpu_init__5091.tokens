int kvm_arch_vcpu_init ( struct kvm_vcpu * vcpu ) //<S2SV> { //<S2SV> struct page * page ; //<S2SV> struct kvm * kvm ; //<S2SV> int r ; //<S2SV> BUG_ON ( vcpu -> kvm == NULL ) ; //<S2SV> kvm = vcpu -> kvm ; //<S2SV> vcpu -> arch . emulate_ctxt . ops = & emulate_ops ; //<S2SV> if ( ! irqchip_in_kernel ( kvm ) || kvm_vcpu_is_bsp ( vcpu ) ) //<S2SV> vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; //<S2SV> else //<S2SV> vcpu -> arch . mp_state = KVM_MP_STATE_UNINITIALIZED ; //<S2SV> page = alloc_page ( GFP_KERNEL | __GFP_ZERO ) ; //<S2SV> if ( ! page ) { //<S2SV> r = - ENOMEM ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> vcpu -> arch . pio_data = page_address ( page ) ; //<S2SV> kvm_set_tsc_khz ( vcpu , max_tsc_khz ) ; //<S2SV> r = kvm_mmu_create ( vcpu ) ; //<S2SV> if ( r < 0 ) //<S2SV> goto fail_free_pio_data ; //<S2SV> if ( irqchip_in_kernel ( kvm ) ) { //<S2SV> r = kvm_create_lapic ( vcpu ) ; //<S2SV> if ( r < 0 ) //<S2SV> goto fail_mmu_destroy ; //<S2SV> } else //<S2SV> static_key_slow_inc ( & kvm_no_apic_vcpu ) ; //<S2SV> vcpu -> arch . mce_banks = kzalloc ( KVM_MAX_MCE_BANKS * sizeof ( u64 ) * 4 , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! vcpu -> arch . mce_banks ) { //<S2SV> r = - ENOMEM ; //<S2SV> goto fail_free_lapic ; //<S2SV> } //<S2SV> vcpu -> arch . mcg_cap = KVM_MAX_MCE_BANKS ; //<S2SV> if ( ! zalloc_cpumask_var ( & vcpu -> arch . wbinvd_dirty_mask , GFP_KERNEL ) ) //<S2SV> goto fail_free_mce_banks ; //<S2SV> r = fx_init ( vcpu ) ; //<S2SV> if ( r ) //<S2SV> goto fail_free_wbinvd_dirty_mask ; //<S2SV> vcpu -> arch . ia32_tsc_adjust_msr = 0x0 ; //<S2SV> vcpu -> arch . pv_time_enabled = false ; //<S2SV> kvm_async_pf_hash_reset ( vcpu ) ; //<S2SV> kvm_pmu_init ( vcpu ) ; //<S2SV> return 0 ; //<S2SV> fail_free_wbinvd_dirty_mask : //<S2SV> free_cpumask_var ( vcpu -> arch . wbinvd_dirty_mask ) ; //<S2SV> fail_free_mce_banks : //<S2SV> kfree ( vcpu -> arch . mce_banks ) ; //<S2SV> fail_free_lapic : //<S2SV> kvm_free_lapic ( vcpu ) ; //<S2SV> fail_mmu_destroy : //<S2SV> kvm_mmu_destroy ( vcpu ) ; //<S2SV> fail_free_pio_data : //<S2SV> free_page ( ( unsigned long ) vcpu -> arch . pio_data ) ; //<S2SV> fail : //<S2SV> return r ; //<S2SV> } //<S2SV> 