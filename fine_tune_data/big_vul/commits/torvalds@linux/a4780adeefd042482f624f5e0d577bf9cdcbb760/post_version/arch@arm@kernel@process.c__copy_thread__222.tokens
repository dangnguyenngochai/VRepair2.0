int //<S2SV> copy_thread ( unsigned long clone_flags , unsigned long stack_start , //<S2SV> unsigned long stk_sz , struct task_struct * p ) //<S2SV> { //<S2SV> struct thread_info * thread = task_thread_info ( p ) ; //<S2SV> struct pt_regs * childregs = task_pt_regs ( p ) ; //<S2SV> memset ( & thread -> cpu_context , 0 , sizeof ( struct cpu_context_save ) ) ; //<S2SV> if ( likely ( ! ( p -> flags & PF_KTHREAD ) ) ) { //<S2SV> * childregs = * current_pt_regs ( ) ; //<S2SV> childregs -> ARM_r0 = 0 ; //<S2SV> if ( stack_start ) //<S2SV> childregs -> ARM_sp = stack_start ; //<S2SV> } else { //<S2SV> memset ( childregs , 0 , sizeof ( struct pt_regs ) ) ; //<S2SV> thread -> cpu_context . r4 = stk_sz ; //<S2SV> thread -> cpu_context . r5 = stack_start ; //<S2SV> childregs -> ARM_cpsr = SVC_MODE ; //<S2SV> } //<S2SV> thread -> cpu_context . pc = ( unsigned long ) ret_from_fork ; //<S2SV> thread -> cpu_context . sp = ( unsigned long ) childregs ; //<S2SV> clear_ptrace_hw_breakpoint ( p ) ; //<S2SV> if ( clone_flags & CLONE_SETTLS ) //<S2SV> thread -> tp_value [ 0 ] = childregs -> ARM_r3 ; //<S2SV> thread -> tp_value [ 1 ] = get_tpuser ( ) ; //<S2SV> thread_notify ( THREAD_NOTIFY_COPY , thread ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 