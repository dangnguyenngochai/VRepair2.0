STATIC int //<S2SV> xfs_attr_node_addname ( xfs_da_args_t * args ) //<S2SV> { //<S2SV> xfs_da_state_t * state ; //<S2SV> xfs_da_state_blk_t * blk ; //<S2SV> xfs_inode_t * dp ; //<S2SV> xfs_mount_t * mp ; //<S2SV> int committed , retval , error ; //<S2SV> trace_xfs_attr_node_addname ( args ) ; //<S2SV> dp = args -> dp ; //<S2SV> mp = dp -> i_mount ; //<S2SV> restart : //<S2SV> state = xfs_da_state_alloc ( ) ; //<S2SV> state -> args = args ; //<S2SV> state -> mp = mp ; //<S2SV> state -> blocksize = state -> mp -> m_sb . sb_blocksize ; //<S2SV> state -> node_ents = state -> mp -> m_attr_node_ents ; //<S2SV> error = xfs_da3_node_lookup_int ( state , & retval ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> blk = & state -> path . blk [ state -> path . active - 1 ] ; //<S2SV> ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; //<S2SV> if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { //<S2SV> goto out ; //<S2SV> } else if ( retval == EEXIST ) { //<S2SV> if ( args -> flags & ATTR_CREATE ) //<S2SV> goto out ; //<S2SV> trace_xfs_attr_node_replace ( args ) ; //<S2SV> args -> op_flags |= XFS_DA_OP_RENAME ; //<S2SV> args -> blkno2 = args -> blkno ; //<S2SV> args -> index2 = args -> index ; //<S2SV> args -> rmtblkno2 = args -> rmtblkno ; //<S2SV> args -> rmtblkcnt2 = args -> rmtblkcnt ; //<S2SV> args -> rmtvaluelen2 = args -> rmtvaluelen ; //<S2SV> args -> rmtblkno = 0 ; //<S2SV> args -> rmtblkcnt = 0 ; //<S2SV> args -> rmtvaluelen = 0 ; //<S2SV> } //<S2SV> retval = xfs_attr3_leaf_add ( blk -> bp , state -> args ) ; //<S2SV> if ( retval == ENOSPC ) { //<S2SV> if ( state -> path . active == 1 ) { //<S2SV> xfs_da_state_free ( state ) ; //<S2SV> state = NULL ; //<S2SV> xfs_bmap_init ( args -> flist , args -> firstblock ) ; //<S2SV> error = xfs_attr3_leaf_to_node ( args ) ; //<S2SV> if ( ! error ) { //<S2SV> error = xfs_bmap_finish ( & args -> trans , //<S2SV> args -> flist , //<S2SV> & committed ) ; //<S2SV> } //<S2SV> if ( error ) { //<S2SV> ASSERT ( committed ) ; //<S2SV> args -> trans = NULL ; //<S2SV> xfs_bmap_cancel ( args -> flist ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( committed ) //<S2SV> xfs_trans_ijoin ( args -> trans , dp , 0 ) ; //<S2SV> error = xfs_trans_roll ( & args -> trans , dp ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> goto restart ; //<S2SV> } //<S2SV> xfs_bmap_init ( args -> flist , args -> firstblock ) ; //<S2SV> error = xfs_da3_split ( state ) ; //<S2SV> if ( ! error ) { //<S2SV> error = xfs_bmap_finish ( & args -> trans , args -> flist , //<S2SV> & committed ) ; //<S2SV> } //<S2SV> if ( error ) { //<S2SV> ASSERT ( committed ) ; //<S2SV> args -> trans = NULL ; //<S2SV> xfs_bmap_cancel ( args -> flist ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( committed ) //<S2SV> xfs_trans_ijoin ( args -> trans , dp , 0 ) ; //<S2SV> } else { //<S2SV> xfs_da3_fixhashpath ( state , & state -> path ) ; //<S2SV> } //<S2SV> xfs_da_state_free ( state ) ; //<S2SV> state = NULL ; //<S2SV> error = xfs_trans_roll ( & args -> trans , dp ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> if ( args -> rmtblkno > 0 ) { //<S2SV> error = xfs_attr_rmtval_set ( args ) ; //<S2SV> if ( error ) //<S2SV> return ( error ) ; //<S2SV> } //<S2SV> if ( args -> op_flags & XFS_DA_OP_RENAME ) { //<S2SV> error = xfs_attr3_leaf_flipflags ( args ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> args -> index = args -> index2 ; //<S2SV> args -> blkno = args -> blkno2 ; //<S2SV> args -> rmtblkno = args -> rmtblkno2 ; //<S2SV> args -> rmtblkcnt = args -> rmtblkcnt2 ; //<S2SV> args -> rmtvaluelen = args -> rmtvaluelen2 ; //<S2SV> if ( args -> rmtblkno ) { //<S2SV> error = xfs_attr_rmtval_remove ( args ) ; //<S2SV> if ( error ) //<S2SV> return ( error ) ; //<S2SV> } //<S2SV> args -> flags |= XFS_ATTR_INCOMPLETE ; //<S2SV> state = xfs_da_state_alloc ( ) ; //<S2SV> state -> args = args ; //<S2SV> state -> mp = mp ; //<S2SV> state -> blocksize = state -> mp -> m_sb . sb_blocksize ; //<S2SV> state -> node_ents = state -> mp -> m_attr_node_ents ; //<S2SV> state -> inleaf = 0 ; //<S2SV> error = xfs_da3_node_lookup_int ( state , & retval ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> blk = & state -> path . blk [ state -> path . active - 1 ] ; //<S2SV> ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; //<S2SV> error = xfs_attr3_leaf_remove ( blk -> bp , args ) ; //<S2SV> xfs_da3_fixhashpath ( state , & state -> path ) ; //<S2SV> if ( retval && ( state -> path . active > 1 ) ) { //<S2SV> xfs_bmap_init ( args -> flist , args -> firstblock ) ; //<S2SV> error = xfs_da3_join ( state ) ; //<S2SV> if ( ! error ) { //<S2SV> error = xfs_bmap_finish ( & args -> trans , //<S2SV> args -> flist , //<S2SV> & committed ) ; //<S2SV> } //<S2SV> if ( error ) { //<S2SV> ASSERT ( committed ) ; //<S2SV> args -> trans = NULL ; //<S2SV> xfs_bmap_cancel ( args -> flist ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( committed ) //<S2SV> xfs_trans_ijoin ( args -> trans , dp , 0 ) ; //<S2SV> } //<S2SV> error = xfs_trans_roll ( & args -> trans , dp ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> } else if ( args -> rmtblkno > 0 ) { //<S2SV> error = xfs_attr3_leaf_clearflag ( args ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> } //<S2SV> retval = error = 0 ; //<S2SV> out : //<S2SV> if ( state ) //<S2SV> xfs_da_state_free ( state ) ; //<S2SV> if ( error ) //<S2SV> return ( error ) ; //<S2SV> return ( retval ) ; //<S2SV> } //<S2SV> 