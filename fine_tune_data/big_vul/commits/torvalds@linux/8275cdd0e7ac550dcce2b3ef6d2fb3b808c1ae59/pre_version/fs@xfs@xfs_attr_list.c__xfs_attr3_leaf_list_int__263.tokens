int //<S2SV> xfs_attr3_leaf_list_int ( //<S2SV> struct xfs_buf * bp , //<S2SV> struct xfs_attr_list_context * context ) //<S2SV> { //<S2SV> struct attrlist_cursor_kern * cursor ; //<S2SV> struct xfs_attr_leafblock * leaf ; //<S2SV> struct xfs_attr3_icleaf_hdr ichdr ; //<S2SV> struct xfs_attr_leaf_entry * entries ; //<S2SV> struct xfs_attr_leaf_entry * entry ; //<S2SV> int retval ; //<S2SV> int i ; //<S2SV> trace_xfs_attr_list_leaf ( context ) ; //<S2SV> leaf = bp -> b_addr ; //<S2SV> xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; //<S2SV> entries = xfs_attr3_leaf_entryp ( leaf ) ; //<S2SV> cursor = context -> cursor ; //<S2SV> cursor -> initted = 1 ; //<S2SV> if ( context -> resynch ) { //<S2SV> entry = & entries [ 0 ] ; //<S2SV> for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { //<S2SV> if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { //<S2SV> if ( cursor -> offset == context -> dupcnt ) { //<S2SV> context -> dupcnt = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> context -> dupcnt ++ ; //<S2SV> } else if ( be32_to_cpu ( entry -> hashval ) > //<S2SV> cursor -> hashval ) { //<S2SV> context -> dupcnt = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( i == ichdr . count ) { //<S2SV> trace_xfs_attr_list_notfound ( context ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } else { //<S2SV> entry = & entries [ 0 ] ; //<S2SV> i = 0 ; //<S2SV> } //<S2SV> context -> resynch = 0 ; //<S2SV> retval = 0 ; //<S2SV> for ( ; i < ichdr . count ; entry ++ , i ++ ) { //<S2SV> if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { //<S2SV> cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; //<S2SV> cursor -> offset = 0 ; //<S2SV> } //<S2SV> if ( entry -> flags & XFS_ATTR_INCOMPLETE ) //<S2SV> continue ; //<S2SV> if ( entry -> flags & XFS_ATTR_LOCAL ) { //<S2SV> xfs_attr_leaf_name_local_t * name_loc = //<S2SV> xfs_attr3_leaf_name_local ( leaf , i ) ; //<S2SV> retval = context -> put_listent ( context , //<S2SV> entry -> flags , //<S2SV> name_loc -> nameval , //<S2SV> ( int ) name_loc -> namelen , //<S2SV> be16_to_cpu ( name_loc -> valuelen ) , //<S2SV> & name_loc -> nameval [ name_loc -> namelen ] ) ; //<S2SV> if ( retval ) //<S2SV> return retval ; //<S2SV> } else { //<S2SV> xfs_attr_leaf_name_remote_t * name_rmt = //<S2SV> xfs_attr3_leaf_name_remote ( leaf , i ) ; //<S2SV> int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; //<S2SV> if ( context -> put_value ) { //<S2SV> xfs_da_args_t args ; //<S2SV> memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; //<S2SV> args . dp = context -> dp ; //<S2SV> args . whichfork = XFS_ATTR_FORK ; //<S2SV> args . valuelen = valuelen ; //<S2SV> args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; //<S2SV> args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; //<S2SV> args . rmtblkcnt = xfs_attr3_rmt_blocks ( //<S2SV> args . dp -> i_mount , valuelen ) ; //<S2SV> retval = xfs_attr_rmtval_get ( & args ) ; //<S2SV> if ( retval ) //<S2SV> return retval ; //<S2SV> retval = context -> put_listent ( context , //<S2SV> entry -> flags , //<S2SV> name_rmt -> name , //<S2SV> ( int ) name_rmt -> namelen , //<S2SV> valuelen , //<S2SV> args . value ) ; //<S2SV> kmem_free ( args . value ) ; //<S2SV> } else { //<S2SV> retval = context -> put_listent ( context , //<S2SV> entry -> flags , //<S2SV> name_rmt -> name , //<S2SV> ( int ) name_rmt -> namelen , //<S2SV> valuelen , //<S2SV> NULL ) ; //<S2SV> } //<S2SV> if ( retval ) //<S2SV> return retval ; //<S2SV> } //<S2SV> if ( context -> seen_enough ) //<S2SV> break ; //<S2SV> cursor -> offset ++ ; //<S2SV> } //<S2SV> trace_xfs_attr_list_leaf_end ( context ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 