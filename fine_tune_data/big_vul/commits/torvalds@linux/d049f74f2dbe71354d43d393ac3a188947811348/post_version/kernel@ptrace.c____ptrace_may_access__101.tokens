static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) //<S2SV> { //<S2SV> const struct cred * cred = current_cred ( ) , * tcred ; //<S2SV> int dumpable = 0 ; //<S2SV> if ( same_thread_group ( task , current ) ) //<S2SV> return 0 ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> tcred = __task_cred ( task ) ; //<S2SV> if ( uid_eq ( cred -> uid , tcred -> euid ) && //<S2SV> uid_eq ( cred -> uid , tcred -> suid ) && //<S2SV> uid_eq ( cred -> uid , tcred -> uid ) && //<S2SV> gid_eq ( cred -> gid , tcred -> egid ) && //<S2SV> gid_eq ( cred -> gid , tcred -> sgid ) && //<S2SV> gid_eq ( cred -> gid , tcred -> gid ) ) //<S2SV> goto ok ; //<S2SV> if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) //<S2SV> goto ok ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> return - EPERM ; //<S2SV> ok : //<S2SV> rcu_read_unlock ( ) ; //<S2SV> smp_rmb ( ) ; //<S2SV> if ( task -> mm ) //<S2SV> dumpable = get_dumpable ( task -> mm ) ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> if ( dumpable != SUID_DUMP_USER && //<S2SV> ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { //<S2SV> rcu_read_unlock ( ) ; //<S2SV> return - EPERM ; //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> return security_ptrace_access_check ( task , mode ) ; //<S2SV> } //<S2SV> 