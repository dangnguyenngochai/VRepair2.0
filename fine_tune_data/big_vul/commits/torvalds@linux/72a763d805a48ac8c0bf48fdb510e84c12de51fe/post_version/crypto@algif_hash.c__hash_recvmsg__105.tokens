static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct alg_sock * ask = alg_sk ( sk ) ; //<S2SV> struct hash_ctx * ctx = ask -> private ; //<S2SV> unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; //<S2SV> int err ; //<S2SV> if ( len > ds ) //<S2SV> len = ds ; //<S2SV> else if ( len < ds ) //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> msg -> msg_namelen = 0 ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( ctx -> more ) { //<S2SV> ctx -> more = 0 ; //<S2SV> ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; //<S2SV> err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , //<S2SV> & ctx -> completion ) ; //<S2SV> if ( err ) //<S2SV> goto unlock ; //<S2SV> } //<S2SV> err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; //<S2SV> unlock : //<S2SV> release_sock ( sk ) ; //<S2SV> return err ? : len ; //<S2SV> } //<S2SV> 