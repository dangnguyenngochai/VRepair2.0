static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) //<S2SV> { //<S2SV> struct bpf_reg_state * regs = cur_regs ( env ) ; //<S2SV> u8 opcode = BPF_OP ( insn -> code ) ; //<S2SV> int err ; //<S2SV> if ( opcode == BPF_END || opcode == BPF_NEG ) { //<S2SV> if ( opcode == BPF_NEG ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> off != 0 || insn -> imm != 0 ) { //<S2SV> verbose ( env , "BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || //<S2SV> ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || //<S2SV> BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { //<S2SV> verbose ( env , "BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( is_pointer_value ( env , insn -> dst_reg ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n" , //<S2SV> insn -> dst_reg ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( opcode == BPF_MOV ) { //<S2SV> if ( BPF_SRC ( insn -> code ) == BPF_X ) { //<S2SV> if ( insn -> imm != 0 || insn -> off != 0 ) { //<S2SV> verbose ( env , "BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else { //<S2SV> if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { //<S2SV> verbose ( env , "BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( BPF_SRC ( insn -> code ) == BPF_X ) { //<S2SV> if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { //<S2SV> regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; //<S2SV> regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; //<S2SV> } else { //<S2SV> if ( is_pointer_value ( env , insn -> src_reg ) ) { //<S2SV> verbose ( env , //<S2SV> "R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\n" , //<S2SV> insn -> src_reg ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; //<S2SV> regs [ insn -> dst_reg ] . var_off = tnum_cast ( //<S2SV> regs [ insn -> dst_reg ] . var_off , 4 ) ; //<S2SV> __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; //<S2SV> } //<S2SV> } else { //<S2SV> regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; //<S2SV> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; //<S2SV> } //<S2SV> } else if ( opcode > BPF_END ) { //<S2SV> verbose ( env , "invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\n" , opcode ) ; //<S2SV> return - EINVAL ; //<S2SV> } else { //<S2SV> if ( BPF_SRC ( insn -> code ) == BPF_X ) { //<S2SV> if ( insn -> imm != 0 || insn -> off != 0 ) { //<S2SV> verbose ( env , "BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else { //<S2SV> if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { //<S2SV> verbose ( env , "BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && //<S2SV> BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { //<S2SV> verbose ( env , "div<S2SV_blank>by<S2SV_blank>zero\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( ( opcode == BPF_LSH || opcode == BPF_RSH || //<S2SV> opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { //<S2SV> int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; //<S2SV> if ( insn -> imm < 0 || insn -> imm >= size ) { //<S2SV> verbose ( env , "invalid<S2SV_blank>shift<S2SV_blank>%d\\n" , insn -> imm ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> return adjust_reg_min_max_vals ( env , insn ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 