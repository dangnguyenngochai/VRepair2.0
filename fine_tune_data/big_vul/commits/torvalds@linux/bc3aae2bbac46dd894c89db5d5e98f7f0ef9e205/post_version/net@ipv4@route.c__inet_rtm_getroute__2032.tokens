static int inet_rtm_getroute ( struct sk_buff * in_skb , struct nlmsghdr * nlh , //<S2SV> struct netlink_ext_ack * extack ) //<S2SV> { //<S2SV> struct net * net = sock_net ( in_skb -> sk ) ; //<S2SV> struct rtmsg * rtm ; //<S2SV> struct nlattr * tb [ RTA_MAX + 1 ] ; //<S2SV> struct fib_result res = { } ; //<S2SV> struct rtable * rt = NULL ; //<S2SV> struct flowi4 fl4 ; //<S2SV> __be32 dst = 0 ; //<S2SV> __be32 src = 0 ; //<S2SV> u32 iif ; //<S2SV> int err ; //<S2SV> int mark ; //<S2SV> struct sk_buff * skb ; //<S2SV> u32 table_id = RT_TABLE_MAIN ; //<S2SV> kuid_t uid ; //<S2SV> err = nlmsg_parse ( nlh , sizeof ( * rtm ) , tb , RTA_MAX , rtm_ipv4_policy , //<S2SV> extack ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto errout ; //<S2SV> rtm = nlmsg_data ( nlh ) ; //<S2SV> skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ; //<S2SV> if ( ! skb ) { //<S2SV> err = - ENOBUFS ; //<S2SV> goto errout ; //<S2SV> } //<S2SV> skb_reset_mac_header ( skb ) ; //<S2SV> skb_reset_network_header ( skb ) ; //<S2SV> src = tb [ RTA_SRC ] ? nla_get_in_addr ( tb [ RTA_SRC ] ) : 0 ; //<S2SV> dst = tb [ RTA_DST ] ? nla_get_in_addr ( tb [ RTA_DST ] ) : 0 ; //<S2SV> iif = tb [ RTA_IIF ] ? nla_get_u32 ( tb [ RTA_IIF ] ) : 0 ; //<S2SV> mark = tb [ RTA_MARK ] ? nla_get_u32 ( tb [ RTA_MARK ] ) : 0 ; //<S2SV> if ( tb [ RTA_UID ] ) //<S2SV> uid = make_kuid ( current_user_ns ( ) , nla_get_u32 ( tb [ RTA_UID ] ) ) ; //<S2SV> else //<S2SV> uid = ( iif ? INVALID_UID : current_uid ( ) ) ; //<S2SV> ip_hdr ( skb ) -> protocol = IPPROTO_UDP ; //<S2SV> ip_hdr ( skb ) -> saddr = src ; //<S2SV> ip_hdr ( skb ) -> daddr = dst ; //<S2SV> skb_reserve ( skb , MAX_HEADER + sizeof ( struct iphdr ) ) ; //<S2SV> memset ( & fl4 , 0 , sizeof ( fl4 ) ) ; //<S2SV> fl4 . daddr = dst ; //<S2SV> fl4 . saddr = src ; //<S2SV> fl4 . flowi4_tos = rtm -> rtm_tos ; //<S2SV> fl4 . flowi4_oif = tb [ RTA_OIF ] ? nla_get_u32 ( tb [ RTA_OIF ] ) : 0 ; //<S2SV> fl4 . flowi4_mark = mark ; //<S2SV> fl4 . flowi4_uid = uid ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> if ( iif ) { //<S2SV> struct net_device * dev ; //<S2SV> dev = dev_get_by_index_rcu ( net , iif ) ; //<S2SV> if ( ! dev ) { //<S2SV> err = - ENODEV ; //<S2SV> goto errout_free ; //<S2SV> } //<S2SV> skb -> protocol = htons ( ETH_P_IP ) ; //<S2SV> skb -> dev = dev ; //<S2SV> skb -> mark = mark ; //<S2SV> err = ip_route_input_rcu ( skb , dst , src , rtm -> rtm_tos , //<S2SV> dev , & res ) ; //<S2SV> rt = skb_rtable ( skb ) ; //<S2SV> if ( err == 0 && rt -> dst . error ) //<S2SV> err = - rt -> dst . error ; //<S2SV> } else { //<S2SV> rt = ip_route_output_key_hash_rcu ( net , & fl4 , & res , skb ) ; //<S2SV> err = 0 ; //<S2SV> if ( IS_ERR ( rt ) ) //<S2SV> err = PTR_ERR ( rt ) ; //<S2SV> else //<S2SV> skb_dst_set ( skb , & rt -> dst ) ; //<S2SV> } //<S2SV> if ( err ) //<S2SV> goto errout_free ; //<S2SV> if ( rtm -> rtm_flags & RTM_F_NOTIFY ) //<S2SV> rt -> rt_flags |= RTCF_NOTIFY ; //<S2SV> if ( rtm -> rtm_flags & RTM_F_LOOKUP_TABLE ) //<S2SV> table_id = rt -> rt_table_id ; //<S2SV> if ( rtm -> rtm_flags & RTM_F_FIB_MATCH ) { //<S2SV> if ( ! res . fi ) { //<S2SV> err = fib_props [ res . type ] . error ; //<S2SV> if ( ! err ) //<S2SV> err = - EHOSTUNREACH ; //<S2SV> goto errout_free ; //<S2SV> } //<S2SV> err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , //<S2SV> nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , //<S2SV> rt -> rt_type , res . prefix , res . prefixlen , //<S2SV> fl4 . flowi4_tos , res . fi , 0 ) ; //<S2SV> } else { //<S2SV> err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , //<S2SV> NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; //<S2SV> } //<S2SV> if ( err < 0 ) //<S2SV> goto errout_free ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ; //<S2SV> errout : //<S2SV> return err ; //<S2SV> errout_free : //<S2SV> rcu_read_unlock ( ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto errout ; //<S2SV> } //<S2SV> 