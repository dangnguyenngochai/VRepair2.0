static int klsi_105_get_line_state ( struct usb_serial_port * port , //<S2SV> unsigned long * line_state_p ) //<S2SV> { //<S2SV> int rc ; //<S2SV> u8 * status_buf ; //<S2SV> __u16 status ; //<S2SV> dev_info ( & port -> serial -> dev -> dev , "sending<S2SV_blank>SIO<S2SV_blank>Poll<S2SV_blank>request\\n" ) ; //<S2SV> status_buf = kmalloc ( KLSI_STATUSBUF_LEN , GFP_KERNEL ) ; //<S2SV> if ( ! status_buf ) //<S2SV> return - ENOMEM ; //<S2SV> status_buf [ 0 ] = 0xff ; //<S2SV> status_buf [ 1 ] = 0xff ; //<S2SV> rc = usb_control_msg ( port -> serial -> dev , //<S2SV> usb_rcvctrlpipe ( port -> serial -> dev , 0 ) , //<S2SV> KL5KUSB105A_SIO_POLL , //<S2SV> USB_TYPE_VENDOR | USB_DIR_IN , //<S2SV> 0 , //<S2SV> 0 , //<S2SV> status_buf , KLSI_STATUSBUF_LEN , //<S2SV> 10000 //<S2SV> ) ; //<S2SV> if ( rc != KLSI_STATUSBUF_LEN ) { //<S2SV> dev_err ( & port -> dev , "reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n" , rc ) ; //<S2SV> if ( rc >= 0 ) //<S2SV> rc = - EIO ; //<S2SV> } else { //<S2SV> status = get_unaligned_le16 ( status_buf ) ; //<S2SV> dev_info ( & port -> serial -> dev -> dev , "read<S2SV_blank>status<S2SV_blank>%x<S2SV_blank>%x\\n" , //<S2SV> status_buf [ 0 ] , status_buf [ 1 ] ) ; //<S2SV> * line_state_p = klsi_105_status2linestate ( status ) ; //<S2SV> } //<S2SV> kfree ( status_buf ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 