static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , //<S2SV> size_t count , loff_t * offp ) //<S2SV> { //<S2SV> struct f_hidg * hidg = file -> private_data ; //<S2SV> struct usb_request * req ; //<S2SV> unsigned long flags ; //<S2SV> ssize_t status = - ENOMEM ; //<S2SV> if ( ! access_ok ( buffer , count ) ) //<S2SV> return - EFAULT ; //<S2SV> spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; //<S2SV> # define WRITE_COND ( ! hidg -> write_pending ) //<S2SV> try_again : //<S2SV> while ( ! WRITE_COND ) { //<S2SV> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; //<S2SV> if ( file -> f_flags & O_NONBLOCK ) //<S2SV> return - EAGAIN ; //<S2SV> if ( wait_event_interruptible_exclusive ( //<S2SV> hidg -> write_queue , WRITE_COND ) ) //<S2SV> return - ERESTARTSYS ; //<S2SV> spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; //<S2SV> } //<S2SV> hidg -> write_pending = 1 ; //<S2SV> req = hidg -> req ; //<S2SV> count = min_t ( unsigned , count , hidg -> report_length ) ; //<S2SV> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; //<S2SV> status = copy_from_user ( req -> buf , buffer , count ) ; //<S2SV> if ( status != 0 ) { //<S2SV> ERROR ( hidg -> func . config -> cdev , //<S2SV> "copy_from_user<S2SV_blank>error\\n" ) ; //<S2SV> status = - EINVAL ; //<S2SV> goto release_write_pending ; //<S2SV> } //<S2SV> spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; //<S2SV> if ( ! hidg -> req ) { //<S2SV> free_ep_req ( hidg -> in_ep , req ) ; //<S2SV> goto try_again ; //<S2SV> } //<S2SV> req -> status = 0 ; //<S2SV> req -> zero = 0 ; //<S2SV> req -> length = count ; //<S2SV> req -> complete = f_hidg_req_complete ; //<S2SV> req -> context = hidg ; //<S2SV> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; //<S2SV> if ( status < 0 ) { //<S2SV> ERROR ( hidg -> func . config -> cdev , //<S2SV> "usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n" , status ) ; //<S2SV> goto release_write_pending_unlocked ; //<S2SV> } else { //<S2SV> status = count ; //<S2SV> } //<S2SV> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; //<S2SV> return status ; //<S2SV> release_write_pending : //<S2SV> spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; //<S2SV> release_write_pending_unlocked : //<S2SV> hidg -> write_pending = 0 ; //<S2SV> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; //<S2SV> wake_up ( & hidg -> write_queue ) ; //<S2SV> return status ; //<S2SV> } //<S2SV> 