static struct page * follow_page_pte ( struct vm_area_struct * vma , //<S2SV> unsigned long address , pmd_t * pmd , unsigned int flags ) //<S2SV> { //<S2SV> struct mm_struct * mm = vma -> vm_mm ; //<S2SV> struct dev_pagemap * pgmap = NULL ; //<S2SV> struct page * page ; //<S2SV> spinlock_t * ptl ; //<S2SV> pte_t * ptep , pte ; //<S2SV> retry : //<S2SV> if ( unlikely ( pmd_bad ( * pmd ) ) ) //<S2SV> return no_page_table ( vma , flags ) ; //<S2SV> ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; //<S2SV> pte = * ptep ; //<S2SV> if ( ! pte_present ( pte ) ) { //<S2SV> swp_entry_t entry ; //<S2SV> if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) //<S2SV> goto no_page ; //<S2SV> if ( pte_none ( pte ) ) //<S2SV> goto no_page ; //<S2SV> entry = pte_to_swp_entry ( pte ) ; //<S2SV> if ( ! is_migration_entry ( entry ) ) //<S2SV> goto no_page ; //<S2SV> pte_unmap_unlock ( ptep , ptl ) ; //<S2SV> migration_entry_wait ( mm , pmd , address ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) //<S2SV> goto no_page ; //<S2SV> if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { //<S2SV> pte_unmap_unlock ( ptep , ptl ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> page = vm_normal_page ( vma , address , pte ) ; //<S2SV> if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { //<S2SV> pgmap = get_dev_pagemap ( pte_pfn ( pte ) , NULL ) ; //<S2SV> if ( pgmap ) //<S2SV> page = pte_page ( pte ) ; //<S2SV> else //<S2SV> goto no_page ; //<S2SV> } else if ( unlikely ( ! page ) ) { //<S2SV> if ( flags & FOLL_DUMP ) { //<S2SV> page = ERR_PTR ( - EFAULT ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { //<S2SV> page = pte_page ( pte ) ; //<S2SV> } else { //<S2SV> int ret ; //<S2SV> ret = follow_pfn_pte ( vma , address , ptep , flags ) ; //<S2SV> page = ERR_PTR ( ret ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { //<S2SV> int ret ; //<S2SV> get_page ( page ) ; //<S2SV> pte_unmap_unlock ( ptep , ptl ) ; //<S2SV> lock_page ( page ) ; //<S2SV> ret = split_huge_page ( page ) ; //<S2SV> unlock_page ( page ) ; //<S2SV> put_page ( page ) ; //<S2SV> if ( ret ) //<S2SV> return ERR_PTR ( ret ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> if ( flags & FOLL_GET ) { //<S2SV> get_page ( page ) ; //<S2SV> if ( pgmap ) { //<S2SV> put_dev_pagemap ( pgmap ) ; //<S2SV> pgmap = NULL ; //<S2SV> } //<S2SV> } //<S2SV> if ( flags & FOLL_TOUCH ) { //<S2SV> if ( ( flags & FOLL_WRITE ) && //<S2SV> ! pte_dirty ( pte ) && ! PageDirty ( page ) ) //<S2SV> set_page_dirty ( page ) ; //<S2SV> mark_page_accessed ( page ) ; //<S2SV> } //<S2SV> if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { //<S2SV> if ( PageTransCompound ( page ) ) //<S2SV> goto out ; //<S2SV> if ( page -> mapping && trylock_page ( page ) ) { //<S2SV> lru_add_drain ( ) ; //<S2SV> mlock_vma_page ( page ) ; //<S2SV> unlock_page ( page ) ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> pte_unmap_unlock ( ptep , ptl ) ; //<S2SV> return page ; //<S2SV> no_page : //<S2SV> pte_unmap_unlock ( ptep , ptl ) ; //<S2SV> if ( ! pte_none ( pte ) ) //<S2SV> return NULL ; //<S2SV> return no_page_table ( vma , flags ) ; //<S2SV> } //<S2SV> 