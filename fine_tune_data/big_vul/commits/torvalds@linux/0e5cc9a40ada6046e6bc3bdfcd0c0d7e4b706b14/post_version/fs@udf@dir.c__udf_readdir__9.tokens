static int udf_readdir ( struct file * file , struct dir_context * ctx ) //<S2SV> { //<S2SV> struct inode * dir = file_inode ( file ) ; //<S2SV> struct udf_inode_info * iinfo = UDF_I ( dir ) ; //<S2SV> struct udf_fileident_bh fibh = { . sbh = NULL , . ebh = NULL } ; //<S2SV> struct fileIdentDesc * fi = NULL ; //<S2SV> struct fileIdentDesc cfi ; //<S2SV> int block , iblock ; //<S2SV> loff_t nf_pos ; //<S2SV> int flen ; //<S2SV> unsigned char * fname = NULL ; //<S2SV> unsigned char * nameptr ; //<S2SV> uint16_t liu ; //<S2SV> uint8_t lfi ; //<S2SV> loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; //<S2SV> struct buffer_head * tmp , * bha [ 16 ] ; //<S2SV> struct kernel_lb_addr eloc ; //<S2SV> uint32_t elen ; //<S2SV> sector_t offset ; //<S2SV> int i , num , ret = 0 ; //<S2SV> struct extent_position epos = { NULL , 0 , { 0 , 0 } } ; //<S2SV> if ( ctx -> pos == 0 ) { //<S2SV> if ( ! dir_emit_dot ( file , ctx ) ) //<S2SV> return 0 ; //<S2SV> ctx -> pos = 1 ; //<S2SV> } //<S2SV> nf_pos = ( ctx -> pos - 1 ) << 2 ; //<S2SV> if ( nf_pos >= size ) //<S2SV> goto out ; //<S2SV> fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; //<S2SV> if ( ! fname ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( nf_pos == 0 ) //<S2SV> nf_pos = udf_ext0_offset ( dir ) ; //<S2SV> fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; //<S2SV> if ( iinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { //<S2SV> if ( inode_bmap ( dir , nf_pos >> dir -> i_sb -> s_blocksize_bits , //<S2SV> & epos , & eloc , & elen , & offset ) //<S2SV> != ( EXT_RECORDED_ALLOCATED >> 30 ) ) { //<S2SV> ret = - ENOENT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; //<S2SV> if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { //<S2SV> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) //<S2SV> epos . offset -= sizeof ( struct short_ad ) ; //<S2SV> else if ( iinfo -> i_alloc_type == //<S2SV> ICBTAG_FLAG_AD_LONG ) //<S2SV> epos . offset -= sizeof ( struct long_ad ) ; //<S2SV> } else { //<S2SV> offset = 0 ; //<S2SV> } //<S2SV> if ( ! ( fibh . sbh = fibh . ebh = udf_tread ( dir -> i_sb , block ) ) ) { //<S2SV> ret = - EIO ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! ( offset & ( ( 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ) - 1 ) ) ) { //<S2SV> i = 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ; //<S2SV> if ( i + offset > ( elen >> dir -> i_sb -> s_blocksize_bits ) ) //<S2SV> i = ( elen >> dir -> i_sb -> s_blocksize_bits ) - offset ; //<S2SV> for ( num = 0 ; i > 0 ; i -- ) { //<S2SV> block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset + i ) ; //<S2SV> tmp = udf_tgetblk ( dir -> i_sb , block ) ; //<S2SV> if ( tmp && ! buffer_uptodate ( tmp ) && ! buffer_locked ( tmp ) ) //<S2SV> bha [ num ++ ] = tmp ; //<S2SV> else //<S2SV> brelse ( tmp ) ; //<S2SV> } //<S2SV> if ( num ) { //<S2SV> ll_rw_block ( READA , num , bha ) ; //<S2SV> for ( i = 0 ; i < num ; i ++ ) //<S2SV> brelse ( bha [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> while ( nf_pos < size ) { //<S2SV> struct kernel_lb_addr tloc ; //<S2SV> ctx -> pos = ( nf_pos >> 2 ) + 1 ; //<S2SV> fi = udf_fileident_read ( dir , & nf_pos , & fibh , & cfi , & epos , & eloc , //<S2SV> & elen , & offset ) ; //<S2SV> if ( ! fi ) //<S2SV> goto out ; //<S2SV> liu = le16_to_cpu ( cfi . lengthOfImpUse ) ; //<S2SV> lfi = cfi . lengthFileIdent ; //<S2SV> if ( fibh . sbh == fibh . ebh ) { //<S2SV> nameptr = fi -> fileIdent + liu ; //<S2SV> } else { //<S2SV> int poffset ; //<S2SV> poffset = fibh . soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; //<S2SV> if ( poffset >= lfi ) { //<S2SV> nameptr = ( char * ) ( fibh . ebh -> b_data + poffset - lfi ) ; //<S2SV> } else { //<S2SV> nameptr = fname ; //<S2SV> memcpy ( nameptr , fi -> fileIdent + liu , //<S2SV> lfi - poffset ) ; //<S2SV> memcpy ( nameptr + lfi - poffset , //<S2SV> fibh . ebh -> b_data , poffset ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { //<S2SV> if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { //<S2SV> if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( cfi . fileCharacteristics & FID_FILE_CHAR_PARENT ) { //<S2SV> if ( ! dir_emit_dotdot ( file , ctx ) ) //<S2SV> goto out ; //<S2SV> continue ; //<S2SV> } //<S2SV> flen = udf_get_filename ( dir -> i_sb , nameptr , lfi , fname , //<S2SV> UDF_NAME_LEN ) ; //<S2SV> if ( ! flen ) //<S2SV> continue ; //<S2SV> tloc = lelb_to_cpu ( cfi . icb . extLocation ) ; //<S2SV> iblock = udf_get_lb_pblock ( dir -> i_sb , & tloc , 0 ) ; //<S2SV> if ( ! dir_emit ( ctx , fname , flen , iblock , DT_UNKNOWN ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> ctx -> pos = ( nf_pos >> 2 ) + 1 ; //<S2SV> out : //<S2SV> if ( fibh . sbh != fibh . ebh ) //<S2SV> brelse ( fibh . ebh ) ; //<S2SV> brelse ( fibh . sbh ) ; //<S2SV> brelse ( epos . bh ) ; //<S2SV> kfree ( fname ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 