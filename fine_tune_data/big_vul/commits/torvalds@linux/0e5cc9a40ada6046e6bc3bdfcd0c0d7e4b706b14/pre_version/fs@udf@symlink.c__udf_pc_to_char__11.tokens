static void udf_pc_to_char ( struct super_block * sb , unsigned char * from , //<S2SV> int fromlen , unsigned char * to ) //<S2SV> { //<S2SV> struct pathComponent * pc ; //<S2SV> int elen = 0 ; //<S2SV> unsigned char * p = to ; //<S2SV> while ( elen < fromlen ) { //<S2SV> pc = ( struct pathComponent * ) ( from + elen ) ; //<S2SV> switch ( pc -> componentType ) { //<S2SV> case 1 : //<S2SV> if ( pc -> lengthComponentIdent > 0 ) //<S2SV> break ; //<S2SV> case 2 : //<S2SV> p = to ; //<S2SV> * p ++ = '/' ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> memcpy ( p , "../" , 3 ) ; //<S2SV> p += 3 ; //<S2SV> break ; //<S2SV> case 4 : //<S2SV> memcpy ( p , "./" , 2 ) ; //<S2SV> p += 2 ; //<S2SV> break ; //<S2SV> case 5 : //<S2SV> p += udf_get_filename ( sb , pc -> componentIdent , p , //<S2SV> pc -> lengthComponentIdent ) ; //<S2SV> * p ++ = '/' ; //<S2SV> break ; //<S2SV> } //<S2SV> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; //<S2SV> } //<S2SV> if ( p > to + 1 ) //<S2SV> p [ - 1 ] = '\\0' ; //<S2SV> else //<S2SV> p [ 0 ] = '\\0' ; //<S2SV> } //<S2SV> 