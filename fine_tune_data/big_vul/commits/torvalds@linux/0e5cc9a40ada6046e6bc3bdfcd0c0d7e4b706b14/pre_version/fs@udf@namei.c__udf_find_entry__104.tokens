static struct fileIdentDesc * udf_find_entry ( struct inode * dir , //<S2SV> const struct qstr * child , //<S2SV> struct udf_fileident_bh * fibh , //<S2SV> struct fileIdentDesc * cfi ) //<S2SV> { //<S2SV> struct fileIdentDesc * fi = NULL ; //<S2SV> loff_t f_pos ; //<S2SV> int block , flen ; //<S2SV> unsigned char * fname = NULL ; //<S2SV> unsigned char * nameptr ; //<S2SV> uint8_t lfi ; //<S2SV> uint16_t liu ; //<S2SV> loff_t size ; //<S2SV> struct kernel_lb_addr eloc ; //<S2SV> uint32_t elen ; //<S2SV> sector_t offset ; //<S2SV> struct extent_position epos = { } ; //<S2SV> struct udf_inode_info * dinfo = UDF_I ( dir ) ; //<S2SV> int isdotdot = child -> len == 2 && //<S2SV> child -> name [ 0 ] == '.' && child -> name [ 1 ] == '.' ; //<S2SV> size = udf_ext0_offset ( dir ) + dir -> i_size ; //<S2SV> f_pos = udf_ext0_offset ( dir ) ; //<S2SV> fibh -> sbh = fibh -> ebh = NULL ; //<S2SV> fibh -> soffset = fibh -> eoffset = f_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; //<S2SV> if ( dinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { //<S2SV> if ( inode_bmap ( dir , f_pos >> dir -> i_sb -> s_blocksize_bits , & epos , //<S2SV> & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) //<S2SV> goto out_err ; //<S2SV> block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; //<S2SV> if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { //<S2SV> if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) //<S2SV> epos . offset -= sizeof ( struct short_ad ) ; //<S2SV> else if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) //<S2SV> epos . offset -= sizeof ( struct long_ad ) ; //<S2SV> } else //<S2SV> offset = 0 ; //<S2SV> fibh -> sbh = fibh -> ebh = udf_tread ( dir -> i_sb , block ) ; //<S2SV> if ( ! fibh -> sbh ) //<S2SV> goto out_err ; //<S2SV> } //<S2SV> fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; //<S2SV> if ( ! fname ) //<S2SV> goto out_err ; //<S2SV> while ( f_pos < size ) { //<S2SV> fi = udf_fileident_read ( dir , & f_pos , fibh , cfi , & epos , & eloc , //<S2SV> & elen , & offset ) ; //<S2SV> if ( ! fi ) //<S2SV> goto out_err ; //<S2SV> liu = le16_to_cpu ( cfi -> lengthOfImpUse ) ; //<S2SV> lfi = cfi -> lengthFileIdent ; //<S2SV> if ( fibh -> sbh == fibh -> ebh ) { //<S2SV> nameptr = fi -> fileIdent + liu ; //<S2SV> } else { //<S2SV> int poffset ; //<S2SV> poffset = fibh -> soffset + sizeof ( struct fileIdentDesc ) + //<S2SV> liu + lfi ; //<S2SV> if ( poffset >= lfi ) //<S2SV> nameptr = ( uint8_t * ) ( fibh -> ebh -> b_data + //<S2SV> poffset - lfi ) ; //<S2SV> else { //<S2SV> nameptr = fname ; //<S2SV> memcpy ( nameptr , fi -> fileIdent + liu , //<S2SV> lfi - poffset ) ; //<S2SV> memcpy ( nameptr + lfi - poffset , //<S2SV> fibh -> ebh -> b_data , poffset ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { //<S2SV> if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { //<S2SV> if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_PARENT ) && //<S2SV> isdotdot ) //<S2SV> goto out_ok ; //<S2SV> if ( ! lfi ) //<S2SV> continue ; //<S2SV> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; //<S2SV> if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) //<S2SV> goto out_ok ; //<S2SV> } //<S2SV> out_err : //<S2SV> fi = NULL ; //<S2SV> if ( fibh -> sbh != fibh -> ebh ) //<S2SV> brelse ( fibh -> ebh ) ; //<S2SV> brelse ( fibh -> sbh ) ; //<S2SV> out_ok : //<S2SV> brelse ( epos . bh ) ; //<S2SV> kfree ( fname ) ; //<S2SV> return fi ; //<S2SV> } //<S2SV> 