static int __ip6_append_data ( struct sock * sk , //<S2SV> struct flowi6 * fl6 , //<S2SV> struct sk_buff_head * queue , //<S2SV> struct inet_cork * cork , //<S2SV> struct inet6_cork * v6_cork , //<S2SV> struct page_frag * pfrag , //<S2SV> int getfrag ( void * from , char * to , int offset , //<S2SV> int len , int odd , struct sk_buff * skb ) , //<S2SV> void * from , int length , int transhdrlen , //<S2SV> unsigned int flags , struct ipcm6_cookie * ipc6 , //<S2SV> const struct sockcm_cookie * sockc ) //<S2SV> { //<S2SV> struct sk_buff * skb , * skb_prev = NULL ; //<S2SV> unsigned int maxfraglen , fragheaderlen , mtu , orig_mtu ; //<S2SV> int exthdrlen = 0 ; //<S2SV> int dst_exthdrlen = 0 ; //<S2SV> int hh_len ; //<S2SV> int copy ; //<S2SV> int err ; //<S2SV> int offset = 0 ; //<S2SV> __u8 tx_flags = 0 ; //<S2SV> u32 tskey = 0 ; //<S2SV> struct rt6_info * rt = ( struct rt6_info * ) cork -> dst ; //<S2SV> struct ipv6_txoptions * opt = v6_cork -> opt ; //<S2SV> int csummode = CHECKSUM_NONE ; //<S2SV> unsigned int maxnonfragsize , headersize ; //<S2SV> skb = skb_peek_tail ( queue ) ; //<S2SV> if ( ! skb ) { //<S2SV> exthdrlen = opt ? opt -> opt_flen : 0 ; //<S2SV> dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; //<S2SV> } //<S2SV> mtu = cork -> fragsize ; //<S2SV> orig_mtu = mtu ; //<S2SV> hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; //<S2SV> fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + //<S2SV> ( opt ? opt -> opt_nflen : 0 ) ; //<S2SV> maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - //<S2SV> sizeof ( struct frag_hdr ) ; //<S2SV> headersize = sizeof ( struct ipv6hdr ) + //<S2SV> ( opt ? opt -> opt_flen + opt -> opt_nflen : 0 ) + //<S2SV> ( dst_allfrag ( & rt -> dst ) ? //<S2SV> sizeof ( struct frag_hdr ) : 0 ) + //<S2SV> rt -> rt6i_nfheader_len ; //<S2SV> if ( cork -> length + length > mtu - headersize && ipc6 -> dontfrag && //<S2SV> ( sk -> sk_protocol == IPPROTO_UDP || //<S2SV> sk -> sk_protocol == IPPROTO_RAW ) ) { //<S2SV> ipv6_local_rxpmtu ( sk , fl6 , mtu - headersize + //<S2SV> sizeof ( struct ipv6hdr ) ) ; //<S2SV> goto emsgsize ; //<S2SV> } //<S2SV> if ( ip6_sk_ignore_df ( sk ) ) //<S2SV> maxnonfragsize = sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ; //<S2SV> else //<S2SV> maxnonfragsize = mtu ; //<S2SV> if ( cork -> length + length > maxnonfragsize - headersize ) { //<S2SV> emsgsize : //<S2SV> ipv6_local_error ( sk , EMSGSIZE , fl6 , //<S2SV> mtu - headersize + //<S2SV> sizeof ( struct ipv6hdr ) ) ; //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> if ( transhdrlen && sk -> sk_protocol == IPPROTO_UDP && //<S2SV> headersize == sizeof ( struct ipv6hdr ) && //<S2SV> length <= mtu - headersize && //<S2SV> ! ( flags & MSG_MORE ) && //<S2SV> rt -> dst . dev -> features & ( NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM ) ) //<S2SV> csummode = CHECKSUM_PARTIAL ; //<S2SV> if ( sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { //<S2SV> sock_tx_timestamp ( sk , sockc -> tsflags , & tx_flags ) ; //<S2SV> if ( tx_flags & SKBTX_ANY_SW_TSTAMP && //<S2SV> sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) //<S2SV> tskey = sk -> sk_tskey ++ ; //<S2SV> } //<S2SV> cork -> length += length ; //<S2SV> if ( ( ( ( length + fragheaderlen ) > mtu ) || //<S2SV> ( skb && skb_is_gso ( skb ) ) ) && //<S2SV> ( sk -> sk_protocol == IPPROTO_UDP ) && //<S2SV> ( rt -> dst . dev -> features & NETIF_F_UFO ) && ! dst_xfrm ( & rt -> dst ) && //<S2SV> ( sk -> sk_type == SOCK_DGRAM ) && ! udp_get_no_check6_tx ( sk ) ) { //<S2SV> err = ip6_ufo_append_data ( sk , queue , getfrag , from , length , //<S2SV> hh_len , fragheaderlen , exthdrlen , //<S2SV> transhdrlen , mtu , flags , fl6 ) ; //<S2SV> if ( err ) //<S2SV> goto error ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! skb ) //<S2SV> goto alloc_new_skb ; //<S2SV> while ( length > 0 ) { //<S2SV> copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; //<S2SV> if ( copy < length ) //<S2SV> copy = maxfraglen - skb -> len ; //<S2SV> if ( copy <= 0 ) { //<S2SV> char * data ; //<S2SV> unsigned int datalen ; //<S2SV> unsigned int fraglen ; //<S2SV> unsigned int fraggap ; //<S2SV> unsigned int alloclen ; //<S2SV> alloc_new_skb : //<S2SV> if ( skb ) //<S2SV> fraggap = skb -> len - maxfraglen ; //<S2SV> else //<S2SV> fraggap = 0 ; //<S2SV> if ( ! skb || ! skb_prev ) //<S2SV> ip6_append_data_mtu ( & mtu , & maxfraglen , //<S2SV> fragheaderlen , skb , rt , //<S2SV> orig_mtu ) ; //<S2SV> skb_prev = skb ; //<S2SV> datalen = length + fraggap ; //<S2SV> if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) //<S2SV> datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; //<S2SV> if ( ( flags & MSG_MORE ) && //<S2SV> ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) //<S2SV> alloclen = mtu ; //<S2SV> else //<S2SV> alloclen = datalen + fragheaderlen ; //<S2SV> alloclen += dst_exthdrlen ; //<S2SV> if ( datalen != length + fraggap ) { //<S2SV> datalen += rt -> dst . trailer_len ; //<S2SV> } //<S2SV> alloclen += rt -> dst . trailer_len ; //<S2SV> fraglen = datalen + fragheaderlen ; //<S2SV> alloclen += sizeof ( struct frag_hdr ) ; //<S2SV> copy = datalen - transhdrlen - fraggap ; //<S2SV> if ( copy < 0 ) { //<S2SV> err = - EINVAL ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( transhdrlen ) { //<S2SV> skb = sock_alloc_send_skb ( sk , //<S2SV> alloclen + hh_len , //<S2SV> ( flags & MSG_DONTWAIT ) , & err ) ; //<S2SV> } else { //<S2SV> skb = NULL ; //<S2SV> if ( atomic_read ( & sk -> sk_wmem_alloc ) <= //<S2SV> 2 * sk -> sk_sndbuf ) //<S2SV> skb = sock_wmalloc ( sk , //<S2SV> alloclen + hh_len , 1 , //<S2SV> sk -> sk_allocation ) ; //<S2SV> if ( unlikely ( ! skb ) ) //<S2SV> err = - ENOBUFS ; //<S2SV> } //<S2SV> if ( ! skb ) //<S2SV> goto error ; //<S2SV> skb -> protocol = htons ( ETH_P_IPV6 ) ; //<S2SV> skb -> ip_summed = csummode ; //<S2SV> skb -> csum = 0 ; //<S2SV> skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + //<S2SV> dst_exthdrlen ) ; //<S2SV> skb_shinfo ( skb ) -> tx_flags = tx_flags ; //<S2SV> tx_flags = 0 ; //<S2SV> skb_shinfo ( skb ) -> tskey = tskey ; //<S2SV> tskey = 0 ; //<S2SV> data = skb_put ( skb , fraglen ) ; //<S2SV> skb_set_network_header ( skb , exthdrlen ) ; //<S2SV> data += fragheaderlen ; //<S2SV> skb -> transport_header = ( skb -> network_header + //<S2SV> fragheaderlen ) ; //<S2SV> if ( fraggap ) { //<S2SV> skb -> csum = skb_copy_and_csum_bits ( //<S2SV> skb_prev , maxfraglen , //<S2SV> data + transhdrlen , fraggap , 0 ) ; //<S2SV> skb_prev -> csum = csum_sub ( skb_prev -> csum , //<S2SV> skb -> csum ) ; //<S2SV> data += fraggap ; //<S2SV> pskb_trim_unique ( skb_prev , maxfraglen ) ; //<S2SV> } //<S2SV> if ( copy > 0 && //<S2SV> getfrag ( from , data + transhdrlen , offset , //<S2SV> copy , fraggap , skb ) < 0 ) { //<S2SV> err = - EFAULT ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> offset += copy ; //<S2SV> length -= datalen - fraggap ; //<S2SV> transhdrlen = 0 ; //<S2SV> exthdrlen = 0 ; //<S2SV> dst_exthdrlen = 0 ; //<S2SV> if ( ( flags & MSG_CONFIRM ) && ! skb_prev ) //<S2SV> skb_set_dst_pending_confirm ( skb , 1 ) ; //<S2SV> __skb_queue_tail ( queue , skb ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( copy > length ) //<S2SV> copy = length ; //<S2SV> if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { //<S2SV> unsigned int off ; //<S2SV> off = skb -> len ; //<S2SV> if ( getfrag ( from , skb_put ( skb , copy ) , //<S2SV> offset , copy , off , skb ) < 0 ) { //<S2SV> __skb_trim ( skb , off ) ; //<S2SV> err = - EFAULT ; //<S2SV> goto error ; //<S2SV> } //<S2SV> } else { //<S2SV> int i = skb_shinfo ( skb ) -> nr_frags ; //<S2SV> err = - ENOMEM ; //<S2SV> if ( ! sk_page_frag_refill ( sk , pfrag ) ) //<S2SV> goto error ; //<S2SV> if ( ! skb_can_coalesce ( skb , i , pfrag -> page , //<S2SV> pfrag -> offset ) ) { //<S2SV> err = - EMSGSIZE ; //<S2SV> if ( i == MAX_SKB_FRAGS ) //<S2SV> goto error ; //<S2SV> __skb_fill_page_desc ( skb , i , pfrag -> page , //<S2SV> pfrag -> offset , 0 ) ; //<S2SV> skb_shinfo ( skb ) -> nr_frags = ++ i ; //<S2SV> get_page ( pfrag -> page ) ; //<S2SV> } //<S2SV> copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; //<S2SV> if ( getfrag ( from , //<S2SV> page_address ( pfrag -> page ) + pfrag -> offset , //<S2SV> offset , copy , skb -> len , skb ) < 0 ) //<S2SV> goto error_efault ; //<S2SV> pfrag -> offset += copy ; //<S2SV> skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; //<S2SV> skb -> len += copy ; //<S2SV> skb -> data_len += copy ; //<S2SV> skb -> truesize += copy ; //<S2SV> atomic_add ( copy , & sk -> sk_wmem_alloc ) ; //<S2SV> } //<S2SV> offset += copy ; //<S2SV> length -= copy ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> error_efault : //<S2SV> err = - EFAULT ; //<S2SV> error : //<S2SV> cork -> length -= length ; //<S2SV> IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 