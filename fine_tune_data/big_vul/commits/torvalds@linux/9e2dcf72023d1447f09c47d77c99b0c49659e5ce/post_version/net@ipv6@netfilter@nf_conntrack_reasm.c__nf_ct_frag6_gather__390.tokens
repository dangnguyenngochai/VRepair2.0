struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) //<S2SV> { //<S2SV> struct sk_buff * clone ; //<S2SV> struct net_device * dev = skb -> dev ; //<S2SV> struct frag_hdr * fhdr ; //<S2SV> struct nf_ct_frag6_queue * fq ; //<S2SV> struct ipv6hdr * hdr ; //<S2SV> int fhoff , nhoff ; //<S2SV> u8 prevhdr ; //<S2SV> struct sk_buff * ret_skb = NULL ; //<S2SV> if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { //<S2SV> pr_debug ( "payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n" ) ; //<S2SV> return skb ; //<S2SV> } //<S2SV> if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) //<S2SV> return skb ; //<S2SV> clone = skb_clone ( skb , GFP_ATOMIC ) ; //<S2SV> if ( clone == NULL ) { //<S2SV> pr_debug ( "Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n" ) ; //<S2SV> return skb ; //<S2SV> } //<S2SV> NFCT_FRAG6_CB ( clone ) -> orig = skb ; //<S2SV> if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { //<S2SV> pr_debug ( "message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n" ) ; //<S2SV> goto ret_orig ; //<S2SV> } //<S2SV> skb_set_transport_header ( clone , fhoff ) ; //<S2SV> hdr = ipv6_hdr ( clone ) ; //<S2SV> fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; //<S2SV> if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) //<S2SV> nf_ct_frag6_evictor ( ) ; //<S2SV> fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; //<S2SV> if ( fq == NULL ) { //<S2SV> pr_debug ( "Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n" ) ; //<S2SV> goto ret_orig ; //<S2SV> } //<S2SV> spin_lock_bh ( & fq -> q . lock ) ; //<S2SV> if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { //<S2SV> spin_unlock_bh ( & fq -> q . lock ) ; //<S2SV> pr_debug ( "Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n" ) ; //<S2SV> fq_put ( fq ) ; //<S2SV> goto ret_orig ; //<S2SV> } //<S2SV> if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && //<S2SV> fq -> q . meat == fq -> q . len ) { //<S2SV> ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; //<S2SV> if ( ret_skb == NULL ) //<S2SV> pr_debug ( "Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n" ) ; //<S2SV> } //<S2SV> spin_unlock_bh ( & fq -> q . lock ) ; //<S2SV> fq_put ( fq ) ; //<S2SV> return ret_skb ; //<S2SV> ret_orig : //<S2SV> kfree_skb ( clone ) ; //<S2SV> return skb ; //<S2SV> } //<S2SV> 