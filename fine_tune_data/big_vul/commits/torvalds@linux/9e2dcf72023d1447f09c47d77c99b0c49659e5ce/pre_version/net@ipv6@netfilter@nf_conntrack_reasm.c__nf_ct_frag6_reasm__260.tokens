static struct sk_buff * //<S2SV> nf_ct_frag6_reasm ( struct nf_ct_frag6_queue * fq , struct net_device * dev ) //<S2SV> { //<S2SV> struct sk_buff * fp , * op , * head = fq -> q . fragments ; //<S2SV> int payload_len ; //<S2SV> fq_kill ( fq ) ; //<S2SV> WARN_ON ( head == NULL ) ; //<S2SV> WARN_ON ( NFCT_FRAG6_CB ( head ) -> offset != 0 ) ; //<S2SV> payload_len = ( ( head -> data - skb_network_header ( head ) ) - //<S2SV> sizeof ( struct ipv6hdr ) + fq -> q . len - //<S2SV> sizeof ( struct frag_hdr ) ) ; //<S2SV> if ( payload_len > IPV6_MAXPLEN ) { //<S2SV> pr_debug ( "payload<S2SV_blank>len<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\n" ) ; //<S2SV> goto out_oversize ; //<S2SV> } //<S2SV> if ( skb_cloned ( head ) && pskb_expand_head ( head , 0 , 0 , GFP_ATOMIC ) ) { //<S2SV> pr_debug ( "skb<S2SV_blank>is<S2SV_blank>cloned<S2SV_blank>but<S2SV_blank>can\'t<S2SV_blank>expand<S2SV_blank>head" ) ; //<S2SV> goto out_oom ; //<S2SV> } //<S2SV> if ( skb_has_frags ( head ) ) { //<S2SV> struct sk_buff * clone ; //<S2SV> int i , plen = 0 ; //<S2SV> if ( ( clone = alloc_skb ( 0 , GFP_ATOMIC ) ) == NULL ) { //<S2SV> pr_debug ( "Can\'t<S2SV_blank>alloc<S2SV_blank>skb\\n" ) ; //<S2SV> goto out_oom ; //<S2SV> } //<S2SV> clone -> next = head -> next ; //<S2SV> head -> next = clone ; //<S2SV> skb_shinfo ( clone ) -> frag_list = skb_shinfo ( head ) -> frag_list ; //<S2SV> skb_frag_list_init ( head ) ; //<S2SV> for ( i = 0 ; i < skb_shinfo ( head ) -> nr_frags ; i ++ ) //<S2SV> plen += skb_shinfo ( head ) -> frags [ i ] . size ; //<S2SV> clone -> len = clone -> data_len = head -> data_len - plen ; //<S2SV> head -> data_len -= clone -> len ; //<S2SV> head -> len -= clone -> len ; //<S2SV> clone -> csum = 0 ; //<S2SV> clone -> ip_summed = head -> ip_summed ; //<S2SV> NFCT_FRAG6_CB ( clone ) -> orig = NULL ; //<S2SV> atomic_add ( clone -> truesize , & nf_init_frags . mem ) ; //<S2SV> } //<S2SV> skb_network_header ( head ) [ fq -> nhoffset ] = skb_transport_header ( head ) [ 0 ] ; //<S2SV> memmove ( head -> head + sizeof ( struct frag_hdr ) , head -> head , //<S2SV> ( head -> data - head -> head ) - sizeof ( struct frag_hdr ) ) ; //<S2SV> head -> mac_header += sizeof ( struct frag_hdr ) ; //<S2SV> head -> network_header += sizeof ( struct frag_hdr ) ; //<S2SV> skb_shinfo ( head ) -> frag_list = head -> next ; //<S2SV> skb_reset_transport_header ( head ) ; //<S2SV> skb_push ( head , head -> data - skb_network_header ( head ) ) ; //<S2SV> atomic_sub ( head -> truesize , & nf_init_frags . mem ) ; //<S2SV> for ( fp = head -> next ; fp ; fp = fp -> next ) { //<S2SV> head -> data_len += fp -> len ; //<S2SV> head -> len += fp -> len ; //<S2SV> if ( head -> ip_summed != fp -> ip_summed ) //<S2SV> head -> ip_summed = CHECKSUM_NONE ; //<S2SV> else if ( head -> ip_summed == CHECKSUM_COMPLETE ) //<S2SV> head -> csum = csum_add ( head -> csum , fp -> csum ) ; //<S2SV> head -> truesize += fp -> truesize ; //<S2SV> atomic_sub ( fp -> truesize , & nf_init_frags . mem ) ; //<S2SV> } //<S2SV> head -> next = NULL ; //<S2SV> head -> dev = dev ; //<S2SV> head -> tstamp = fq -> q . stamp ; //<S2SV> ipv6_hdr ( head ) -> payload_len = htons ( payload_len ) ; //<S2SV> if ( head -> ip_summed == CHECKSUM_COMPLETE ) //<S2SV> head -> csum = csum_partial ( skb_network_header ( head ) , //<S2SV> skb_network_header_len ( head ) , //<S2SV> head -> csum ) ; //<S2SV> fq -> q . fragments = NULL ; //<S2SV> fp = skb_shinfo ( head ) -> frag_list ; //<S2SV> if ( NFCT_FRAG6_CB ( fp ) -> orig == NULL ) //<S2SV> fp = fp -> next ; //<S2SV> op = NFCT_FRAG6_CB ( head ) -> orig ; //<S2SV> for ( ; fp ; fp = fp -> next ) { //<S2SV> struct sk_buff * orig = NFCT_FRAG6_CB ( fp ) -> orig ; //<S2SV> op -> next = orig ; //<S2SV> op = orig ; //<S2SV> NFCT_FRAG6_CB ( fp ) -> orig = NULL ; //<S2SV> } //<S2SV> return head ; //<S2SV> out_oversize : //<S2SV> if ( net_ratelimit ( ) ) //<S2SV> printk ( KERN_DEBUG "nf_ct_frag6_reasm:<S2SV_blank>payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%d\\n" , payload_len ) ; //<S2SV> goto out_fail ; //<S2SV> out_oom : //<S2SV> if ( net_ratelimit ( ) ) //<S2SV> printk ( KERN_DEBUG "nf_ct_frag6_reasm:<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>reassembly\\n" ) ; //<S2SV> out_fail : //<S2SV> return NULL ; //<S2SV> } //<S2SV> 