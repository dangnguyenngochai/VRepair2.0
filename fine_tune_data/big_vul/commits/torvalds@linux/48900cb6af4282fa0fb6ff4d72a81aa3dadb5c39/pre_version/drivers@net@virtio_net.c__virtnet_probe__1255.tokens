static int virtnet_probe ( struct virtio_device * vdev ) //<S2SV> { //<S2SV> int i , err ; //<S2SV> struct net_device * dev ; //<S2SV> struct virtnet_info * vi ; //<S2SV> u16 max_queue_pairs ; //<S2SV> if ( ! vdev -> config -> get ) { //<S2SV> dev_err ( & vdev -> dev , "%s<S2SV_blank>failure:<S2SV_blank>config<S2SV_blank>access<S2SV_blank>disabled\\n" , //<S2SV> __func__ ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( ! virtnet_validate_features ( vdev ) ) //<S2SV> return - EINVAL ; //<S2SV> err = virtio_cread_feature ( vdev , VIRTIO_NET_F_MQ , //<S2SV> struct virtio_net_config , //<S2SV> max_virtqueue_pairs , & max_queue_pairs ) ; //<S2SV> if ( err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN || //<S2SV> max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX || //<S2SV> ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) //<S2SV> max_queue_pairs = 1 ; //<S2SV> dev = alloc_etherdev_mq ( sizeof ( struct virtnet_info ) , max_queue_pairs ) ; //<S2SV> if ( ! dev ) //<S2SV> return - ENOMEM ; //<S2SV> dev -> priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE ; //<S2SV> dev -> netdev_ops = & virtnet_netdev ; //<S2SV> dev -> features = NETIF_F_HIGHDMA ; //<S2SV> dev -> ethtool_ops = & virtnet_ethtool_ops ; //<S2SV> SET_NETDEV_DEV ( dev , & vdev -> dev ) ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CSUM ) ) { //<S2SV> dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; //<S2SV> if ( csum ) //<S2SV> dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) { //<S2SV> dev -> hw_features |= NETIF_F_TSO | NETIF_F_UFO //<S2SV> | NETIF_F_TSO_ECN | NETIF_F_TSO6 ; //<S2SV> } //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO4 ) ) //<S2SV> dev -> hw_features |= NETIF_F_TSO ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO6 ) ) //<S2SV> dev -> hw_features |= NETIF_F_TSO6 ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_ECN ) ) //<S2SV> dev -> hw_features |= NETIF_F_TSO_ECN ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_UFO ) ) //<S2SV> dev -> hw_features |= NETIF_F_UFO ; //<S2SV> dev -> features |= NETIF_F_GSO_ROBUST ; //<S2SV> if ( gso ) //<S2SV> dev -> features |= dev -> hw_features & ( NETIF_F_ALL_TSO | NETIF_F_UFO ) ; //<S2SV> } //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_CSUM ) ) //<S2SV> dev -> features |= NETIF_F_RXCSUM ; //<S2SV> dev -> vlan_features = dev -> features ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MAC ) ) //<S2SV> virtio_cread_bytes ( vdev , //<S2SV> offsetof ( struct virtio_net_config , mac ) , //<S2SV> dev -> dev_addr , dev -> addr_len ) ; //<S2SV> else //<S2SV> eth_hw_addr_random ( dev ) ; //<S2SV> vi = netdev_priv ( dev ) ; //<S2SV> vi -> dev = dev ; //<S2SV> vi -> vdev = vdev ; //<S2SV> vdev -> priv = vi ; //<S2SV> vi -> stats = alloc_percpu ( struct virtnet_stats ) ; //<S2SV> err = - ENOMEM ; //<S2SV> if ( vi -> stats == NULL ) //<S2SV> goto free ; //<S2SV> for_each_possible_cpu ( i ) { //<S2SV> struct virtnet_stats * virtnet_stats ; //<S2SV> virtnet_stats = per_cpu_ptr ( vi -> stats , i ) ; //<S2SV> u64_stats_init ( & virtnet_stats -> tx_syncp ) ; //<S2SV> u64_stats_init ( & virtnet_stats -> rx_syncp ) ; //<S2SV> } //<S2SV> INIT_WORK ( & vi -> config_work , virtnet_config_changed_work ) ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_TSO4 ) || //<S2SV> virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_TSO6 ) || //<S2SV> virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_ECN ) || //<S2SV> virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_UFO ) ) //<S2SV> vi -> big_packets = true ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) ) //<S2SV> vi -> mergeable_rx_bufs = true ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) || //<S2SV> virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) //<S2SV> vi -> hdr_len = sizeof ( struct virtio_net_hdr_mrg_rxbuf ) ; //<S2SV> else //<S2SV> vi -> hdr_len = sizeof ( struct virtio_net_hdr ) ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_F_ANY_LAYOUT ) || //<S2SV> virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) ) //<S2SV> vi -> any_header_sg = true ; //<S2SV> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) //<S2SV> vi -> has_cvq = true ; //<S2SV> if ( vi -> any_header_sg ) //<S2SV> dev -> needed_headroom = vi -> hdr_len ; //<S2SV> vi -> curr_queue_pairs = 1 ; //<S2SV> vi -> max_queue_pairs = max_queue_pairs ; //<S2SV> err = init_vqs ( vi ) ; //<S2SV> if ( err ) //<S2SV> goto free_stats ; //<S2SV> # ifdef CONFIG_SYSFS //<S2SV> if ( vi -> mergeable_rx_bufs ) //<S2SV> dev -> sysfs_rx_queue_group = & virtio_net_mrg_rx_group ; //<S2SV> # endif //<S2SV> netif_set_real_num_tx_queues ( dev , vi -> curr_queue_pairs ) ; //<S2SV> netif_set_real_num_rx_queues ( dev , vi -> curr_queue_pairs ) ; //<S2SV> err = register_netdev ( dev ) ; //<S2SV> if ( err ) { //<S2SV> pr_debug ( "virtio_net:<S2SV_blank>registering<S2SV_blank>device<S2SV_blank>failed\\n" ) ; //<S2SV> goto free_vqs ; //<S2SV> } //<S2SV> virtio_device_ready ( vdev ) ; //<S2SV> for ( i = 0 ; i < vi -> curr_queue_pairs ; i ++ ) { //<S2SV> try_fill_recv ( vi , & vi -> rq [ i ] , GFP_KERNEL ) ; //<S2SV> if ( vi -> rq [ i ] . vq -> num_free == //<S2SV> virtqueue_get_vring_size ( vi -> rq [ i ] . vq ) ) { //<S2SV> free_unused_bufs ( vi ) ; //<S2SV> err = - ENOMEM ; //<S2SV> goto free_recv_bufs ; //<S2SV> } //<S2SV> } //<S2SV> vi -> nb . notifier_call = & virtnet_cpu_callback ; //<S2SV> err = register_hotcpu_notifier ( & vi -> nb ) ; //<S2SV> if ( err ) { //<S2SV> pr_debug ( "virtio_net:<S2SV_blank>registering<S2SV_blank>cpu<S2SV_blank>notifier<S2SV_blank>failed\\n" ) ; //<S2SV> goto free_recv_bufs ; //<S2SV> } //<S2SV> if ( virtio_has_feature ( vi -> vdev , VIRTIO_NET_F_STATUS ) ) { //<S2SV> netif_carrier_off ( dev ) ; //<S2SV> schedule_work ( & vi -> config_work ) ; //<S2SV> } else { //<S2SV> vi -> status = VIRTIO_NET_S_LINK_UP ; //<S2SV> netif_carrier_on ( dev ) ; //<S2SV> } //<S2SV> pr_debug ( "virtnet:<S2SV_blank>registered<S2SV_blank>device<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>RX<S2SV_blank>and<S2SV_blank>TX<S2SV_blank>vq\'s\\n" , //<S2SV> dev -> name , max_queue_pairs ) ; //<S2SV> return 0 ; //<S2SV> free_recv_bufs : //<S2SV> vi -> vdev -> config -> reset ( vdev ) ; //<S2SV> free_receive_bufs ( vi ) ; //<S2SV> unregister_netdev ( dev ) ; //<S2SV> free_vqs : //<S2SV> cancel_delayed_work_sync ( & vi -> refill ) ; //<S2SV> free_receive_page_frags ( vi ) ; //<S2SV> virtnet_del_vqs ( vi ) ; //<S2SV> free_stats : //<S2SV> free_percpu ( vi -> stats ) ; //<S2SV> free : //<S2SV> free_netdev ( dev ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 