static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , //<S2SV> const struct assoc_array_ops * ops , //<S2SV> const void * index_key , //<S2SV> struct assoc_array_walk_result * result ) //<S2SV> { //<S2SV> struct assoc_array_shortcut * shortcut , * new_s0 ; //<S2SV> struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; //<S2SV> struct assoc_array_ptr * ptr ; //<S2SV> unsigned long dissimilarity , base_seg , blank ; //<S2SV> size_t keylen ; //<S2SV> bool have_meta ; //<S2SV> int level , diff ; //<S2SV> int slot , next_slot , free_slot , i , j ; //<S2SV> node = result -> terminal_node . node ; //<S2SV> level = result -> terminal_node . level ; //<S2SV> edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; //<S2SV> pr_devel ( "-->%s()\\n" , __func__ ) ; //<S2SV> free_slot = - 1 ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { //<S2SV> ptr = node -> slots [ i ] ; //<S2SV> if ( ! ptr ) { //<S2SV> free_slot = i ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( assoc_array_ptr_is_leaf ( ptr ) && //<S2SV> ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , //<S2SV> index_key ) ) { //<S2SV> pr_devel ( "replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\n" , i ) ; //<S2SV> edit -> leaf_p = & node -> slots [ i ] ; //<S2SV> edit -> dead_leaf = node -> slots [ i ] ; //<S2SV> pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[replace]\\n" , __func__ ) ; //<S2SV> return true ; //<S2SV> } //<S2SV> } //<S2SV> if ( free_slot >= 0 ) { //<S2SV> pr_devel ( "insert<S2SV_blank>in<S2SV_blank>free<S2SV_blank>slot<S2SV_blank>%d\\n" , free_slot ) ; //<S2SV> edit -> leaf_p = & node -> slots [ free_slot ] ; //<S2SV> edit -> adjust_count_on = node ; //<S2SV> pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert]\\n" , __func__ ) ; //<S2SV> return true ; //<S2SV> } //<S2SV> new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; //<S2SV> if ( ! new_n0 ) //<S2SV> return false ; //<S2SV> edit -> new_meta [ 0 ] = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> new_n1 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; //<S2SV> if ( ! new_n1 ) //<S2SV> return false ; //<S2SV> edit -> new_meta [ 1 ] = assoc_array_node_to_ptr ( new_n1 ) ; //<S2SV> pr_devel ( "no<S2SV_blank>spare<S2SV_blank>slots\\n" ) ; //<S2SV> have_meta = false ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { //<S2SV> ptr = node -> slots [ i ] ; //<S2SV> if ( assoc_array_ptr_is_meta ( ptr ) ) { //<S2SV> edit -> segment_cache [ i ] = 0xff ; //<S2SV> have_meta = true ; //<S2SV> continue ; //<S2SV> } //<S2SV> base_seg = ops -> get_object_key_chunk ( //<S2SV> assoc_array_ptr_to_leaf ( ptr ) , level ) ; //<S2SV> base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; //<S2SV> edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; //<S2SV> } //<S2SV> if ( have_meta ) { //<S2SV> pr_devel ( "have<S2SV_blank>meta\\n" ) ; //<S2SV> goto split_node ; //<S2SV> } //<S2SV> dissimilarity = 0 ; //<S2SV> base_seg = edit -> segment_cache [ 0 ] ; //<S2SV> for ( i = 1 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) //<S2SV> dissimilarity |= edit -> segment_cache [ i ] ^ base_seg ; //<S2SV> pr_devel ( "only<S2SV_blank>leaves;<S2SV_blank>dissimilarity=%lx\\n" , dissimilarity ) ; //<S2SV> if ( ( dissimilarity & ASSOC_ARRAY_FAN_MASK ) == 0 ) { //<S2SV> if ( ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ^ base_seg ) == 0 ) //<S2SV> goto all_leaves_cluster_together ; //<S2SV> goto present_leaves_cluster_but_not_new_leaf ; //<S2SV> } //<S2SV> split_node : //<S2SV> pr_devel ( "split<S2SV_blank>node\\n" ) ; //<S2SV> edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> new_n0 -> back_pointer = node -> back_pointer ; //<S2SV> new_n0 -> parent_slot = node -> parent_slot ; //<S2SV> new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> new_n1 -> parent_slot = - 1 ; //<S2SV> do_split_node : //<S2SV> pr_devel ( "do_split_node\\n" ) ; //<S2SV> new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; //<S2SV> new_n1 -> nr_leaves_on_branch = 0 ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { //<S2SV> slot = edit -> segment_cache [ i ] ; //<S2SV> if ( slot != 0xff ) //<S2SV> for ( j = i + 1 ; j < ASSOC_ARRAY_FAN_OUT + 1 ; j ++ ) //<S2SV> if ( edit -> segment_cache [ j ] == slot ) //<S2SV> goto found_slot_for_multiple_occupancy ; //<S2SV> } //<S2SV> found_slot_for_multiple_occupancy : //<S2SV> pr_devel ( "same<S2SV_blank>slot:<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>[%02x]\\n" , i , j , slot ) ; //<S2SV> BUG_ON ( i >= ASSOC_ARRAY_FAN_OUT ) ; //<S2SV> BUG_ON ( j >= ASSOC_ARRAY_FAN_OUT + 1 ) ; //<S2SV> BUG_ON ( slot >= ASSOC_ARRAY_FAN_OUT ) ; //<S2SV> new_n1 -> parent_slot = slot ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) //<S2SV> if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) //<S2SV> new_n0 -> slots [ i ] = node -> slots [ i ] ; //<S2SV> else //<S2SV> new_n0 -> slots [ i ] = NULL ; //<S2SV> BUG_ON ( new_n0 -> slots [ slot ] != NULL ) ; //<S2SV> new_n0 -> slots [ slot ] = assoc_array_node_to_ptr ( new_n1 ) ; //<S2SV> free_slot = - 1 ; //<S2SV> next_slot = 0 ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { //<S2SV> if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) //<S2SV> continue ; //<S2SV> if ( edit -> segment_cache [ i ] == slot ) { //<S2SV> new_n1 -> slots [ next_slot ++ ] = node -> slots [ i ] ; //<S2SV> new_n1 -> nr_leaves_on_branch ++ ; //<S2SV> } else { //<S2SV> do { //<S2SV> free_slot ++ ; //<S2SV> } while ( new_n0 -> slots [ free_slot ] != NULL ) ; //<S2SV> new_n0 -> slots [ free_slot ] = node -> slots [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> pr_devel ( "filtered:<S2SV_blank>f=%x<S2SV_blank>n=%x\\n" , free_slot , next_slot ) ; //<S2SV> if ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] != slot ) { //<S2SV> do { //<S2SV> free_slot ++ ; //<S2SV> } while ( new_n0 -> slots [ free_slot ] != NULL ) ; //<S2SV> edit -> leaf_p = & new_n0 -> slots [ free_slot ] ; //<S2SV> edit -> adjust_count_on = new_n0 ; //<S2SV> } else { //<S2SV> edit -> leaf_p = & new_n1 -> slots [ next_slot ++ ] ; //<S2SV> edit -> adjust_count_on = new_n1 ; //<S2SV> } //<S2SV> BUG_ON ( next_slot <= 1 ) ; //<S2SV> edit -> set_backpointers_to = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { //<S2SV> if ( edit -> segment_cache [ i ] == 0xff ) { //<S2SV> ptr = node -> slots [ i ] ; //<S2SV> BUG_ON ( assoc_array_ptr_is_leaf ( ptr ) ) ; //<S2SV> if ( assoc_array_ptr_is_node ( ptr ) ) { //<S2SV> side = assoc_array_ptr_to_node ( ptr ) ; //<S2SV> edit -> set_backpointers [ i ] = & side -> back_pointer ; //<S2SV> } else { //<S2SV> shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; //<S2SV> edit -> set_backpointers [ i ] = & shortcut -> back_pointer ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ptr = node -> back_pointer ; //<S2SV> if ( ! ptr ) //<S2SV> edit -> set [ 0 ] . ptr = & edit -> array -> root ; //<S2SV> else if ( assoc_array_ptr_is_node ( ptr ) ) //<S2SV> edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( ptr ) -> slots [ node -> parent_slot ] ; //<S2SV> else //<S2SV> edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_shortcut ( ptr ) -> next_node ; //<S2SV> edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; //<S2SV> pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n" , __func__ ) ; //<S2SV> return true ; //<S2SV> present_leaves_cluster_but_not_new_leaf : //<S2SV> pr_devel ( "present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n" ) ; //<S2SV> new_n0 -> back_pointer = node -> back_pointer ; //<S2SV> new_n0 -> parent_slot = node -> parent_slot ; //<S2SV> new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; //<S2SV> new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ; //<S2SV> new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; //<S2SV> edit -> adjust_count_on = new_n0 ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) //<S2SV> new_n1 -> slots [ i ] = node -> slots [ i ] ; //<S2SV> new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ; //<S2SV> edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ; //<S2SV> edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; //<S2SV> pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\n" , __func__ ) ; //<S2SV> return true ; //<S2SV> all_leaves_cluster_together : //<S2SV> pr_devel ( "all<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>together\\n" ) ; //<S2SV> diff = INT_MAX ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { //<S2SV> int x = ops -> diff_objects ( assoc_array_ptr_to_leaf ( node -> slots [ i ] ) , //<S2SV> index_key ) ; //<S2SV> if ( x < diff ) { //<S2SV> BUG_ON ( x < 0 ) ; //<S2SV> diff = x ; //<S2SV> } //<S2SV> } //<S2SV> BUG_ON ( diff == INT_MAX ) ; //<S2SV> BUG_ON ( diff < level + ASSOC_ARRAY_LEVEL_STEP ) ; //<S2SV> keylen = round_up ( diff , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; //<S2SV> keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; //<S2SV> new_s0 = kzalloc ( sizeof ( struct assoc_array_shortcut ) + //<S2SV> keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; //<S2SV> if ( ! new_s0 ) //<S2SV> return false ; //<S2SV> edit -> new_meta [ 2 ] = assoc_array_shortcut_to_ptr ( new_s0 ) ; //<S2SV> edit -> set [ 0 ] . to = assoc_array_shortcut_to_ptr ( new_s0 ) ; //<S2SV> new_s0 -> back_pointer = node -> back_pointer ; //<S2SV> new_s0 -> parent_slot = node -> parent_slot ; //<S2SV> new_s0 -> next_node = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> new_n0 -> back_pointer = assoc_array_shortcut_to_ptr ( new_s0 ) ; //<S2SV> new_n0 -> parent_slot = 0 ; //<S2SV> new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; //<S2SV> new_n1 -> parent_slot = - 1 ; //<S2SV> new_s0 -> skip_to_level = level = diff & ~ ASSOC_ARRAY_LEVEL_STEP_MASK ; //<S2SV> pr_devel ( "skip_to_level<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[diff<S2SV_blank>%d]\\n" , level , diff ) ; //<S2SV> BUG_ON ( level <= 0 ) ; //<S2SV> for ( i = 0 ; i < keylen ; i ++ ) //<S2SV> new_s0 -> index_key [ i ] = //<S2SV> ops -> get_key_chunk ( index_key , i * ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; //<S2SV> blank = ULONG_MAX << ( level & ASSOC_ARRAY_KEY_CHUNK_MASK ) ; //<S2SV> pr_devel ( "blank<S2SV_blank>off<S2SV_blank>[%zu]<S2SV_blank>%d:<S2SV_blank>%lx\\n" , keylen - 1 , level , blank ) ; //<S2SV> new_s0 -> index_key [ keylen - 1 ] &= ~ blank ; //<S2SV> for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { //<S2SV> ptr = node -> slots [ i ] ; //<S2SV> base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , //<S2SV> level ) ; //<S2SV> base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; //<S2SV> edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; //<S2SV> } //<S2SV> base_seg = ops -> get_key_chunk ( index_key , level ) ; //<S2SV> base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; //<S2SV> edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = base_seg & ASSOC_ARRAY_FAN_MASK ; //<S2SV> goto do_split_node ; //<S2SV> } //<S2SV> 