int usb_get_bos_descriptor ( struct usb_device * dev ) //<S2SV> { //<S2SV> struct device * ddev = & dev -> dev ; //<S2SV> struct usb_bos_descriptor * bos ; //<S2SV> struct usb_dev_cap_header * cap ; //<S2SV> unsigned char * buffer ; //<S2SV> int length , total_len , num , i ; //<S2SV> int ret ; //<S2SV> bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; //<S2SV> if ( ! bos ) //<S2SV> return - ENOMEM ; //<S2SV> ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; //<S2SV> if ( ret < USB_DT_BOS_SIZE ) { //<S2SV> dev_err ( ddev , "unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor\\n" ) ; //<S2SV> if ( ret >= 0 ) //<S2SV> ret = - ENOMSG ; //<S2SV> kfree ( bos ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> length = bos -> bLength ; //<S2SV> total_len = le16_to_cpu ( bos -> wTotalLength ) ; //<S2SV> num = bos -> bNumDeviceCaps ; //<S2SV> kfree ( bos ) ; //<S2SV> if ( total_len < length ) //<S2SV> return - EINVAL ; //<S2SV> dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; //<S2SV> if ( ! dev -> bos ) //<S2SV> return - ENOMEM ; //<S2SV> buffer = kzalloc ( total_len , GFP_KERNEL ) ; //<S2SV> if ( ! buffer ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto err ; //<S2SV> } //<S2SV> dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; //<S2SV> ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; //<S2SV> if ( ret < total_len ) { //<S2SV> dev_err ( ddev , "unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>BOS<S2SV_blank>descriptor<S2SV_blank>set\\n" ) ; //<S2SV> if ( ret >= 0 ) //<S2SV> ret = - ENOMSG ; //<S2SV> goto err ; //<S2SV> } //<S2SV> total_len -= length ; //<S2SV> for ( i = 0 ; i < num ; i ++ ) { //<S2SV> buffer += length ; //<S2SV> cap = ( struct usb_dev_cap_header * ) buffer ; //<S2SV> length = cap -> bLength ; //<S2SV> if ( total_len < length ) //<S2SV> break ; //<S2SV> total_len -= length ; //<S2SV> if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { //<S2SV> dev_warn ( ddev , "descriptor<S2SV_blank>type<S2SV_blank>invalid,<S2SV_blank>skip\\n" ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> switch ( cap -> bDevCapabilityType ) { //<S2SV> case USB_CAP_TYPE_WIRELESS_USB : //<S2SV> break ; //<S2SV> case USB_CAP_TYPE_EXT : //<S2SV> dev -> bos -> ext_cap = //<S2SV> ( struct usb_ext_cap_descriptor * ) buffer ; //<S2SV> break ; //<S2SV> case USB_SS_CAP_TYPE : //<S2SV> dev -> bos -> ss_cap = //<S2SV> ( struct usb_ss_cap_descriptor * ) buffer ; //<S2SV> break ; //<S2SV> case USB_SSP_CAP_TYPE : //<S2SV> dev -> bos -> ssp_cap = //<S2SV> ( struct usb_ssp_cap_descriptor * ) buffer ; //<S2SV> break ; //<S2SV> case CONTAINER_ID_TYPE : //<S2SV> dev -> bos -> ss_id = //<S2SV> ( struct usb_ss_container_id_descriptor * ) buffer ; //<S2SV> break ; //<S2SV> case USB_PTM_CAP_TYPE : //<S2SV> dev -> bos -> ptm_cap = //<S2SV> ( struct usb_ptm_cap_descriptor * ) buffer ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> err : //<S2SV> usb_release_bos_descriptor ( dev ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 