static int unimac_mdio_probe ( struct platform_device * pdev ) //<S2SV> { //<S2SV> struct unimac_mdio_pdata * pdata = pdev -> dev . platform_data ; //<S2SV> struct unimac_mdio_priv * priv ; //<S2SV> struct device_node * np ; //<S2SV> struct mii_bus * bus ; //<S2SV> struct resource * r ; //<S2SV> int ret ; //<S2SV> np = pdev -> dev . of_node ; //<S2SV> priv = devm_kzalloc ( & pdev -> dev , sizeof ( * priv ) , GFP_KERNEL ) ; //<S2SV> if ( ! priv ) //<S2SV> return - ENOMEM ; //<S2SV> r = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; //<S2SV> priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; //<S2SV> if ( ! priv -> base ) { //<S2SV> dev_err ( & pdev -> dev , "failed<S2SV_blank>to<S2SV_blank>remap<S2SV_blank>register\\n" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> priv -> mii_bus = mdiobus_alloc ( ) ; //<S2SV> if ( ! priv -> mii_bus ) //<S2SV> return - ENOMEM ; //<S2SV> bus = priv -> mii_bus ; //<S2SV> bus -> priv = priv ; //<S2SV> if ( pdata ) { //<S2SV> bus -> name = pdata -> bus_name ; //<S2SV> priv -> wait_func = pdata -> wait_func ; //<S2SV> priv -> wait_func_data = pdata -> wait_func_data ; //<S2SV> bus -> phy_mask = ~ pdata -> phy_mask ; //<S2SV> } else { //<S2SV> bus -> name = "unimac<S2SV_blank>MII<S2SV_blank>bus" ; //<S2SV> priv -> wait_func_data = priv ; //<S2SV> priv -> wait_func = unimac_mdio_poll ; //<S2SV> } //<S2SV> bus -> parent = & pdev -> dev ; //<S2SV> bus -> read = unimac_mdio_read ; //<S2SV> bus -> write = unimac_mdio_write ; //<S2SV> bus -> reset = unimac_mdio_reset ; //<S2SV> snprintf ( bus -> id , MII_BUS_ID_SIZE , "%s-%d" , pdev -> name , pdev -> id ) ; //<S2SV> ret = of_mdiobus_register ( bus , np ) ; //<S2SV> if ( ret ) { //<S2SV> dev_err ( & pdev -> dev , "MDIO<S2SV_blank>bus<S2SV_blank>registration<S2SV_blank>failed\\n" ) ; //<S2SV> goto out_mdio_free ; //<S2SV> } //<S2SV> platform_set_drvdata ( pdev , priv ) ; //<S2SV> dev_info ( & pdev -> dev , "Broadcom<S2SV_blank>UniMAC<S2SV_blank>MDIO<S2SV_blank>bus<S2SV_blank>at<S2SV_blank>0x%p\\n" , priv -> base ) ; //<S2SV> return 0 ; //<S2SV> out_mdio_free : //<S2SV> mdiobus_free ( bus ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 