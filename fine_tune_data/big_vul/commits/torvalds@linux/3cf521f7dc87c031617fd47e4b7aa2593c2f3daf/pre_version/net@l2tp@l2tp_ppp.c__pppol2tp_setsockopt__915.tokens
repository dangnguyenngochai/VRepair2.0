static int pppol2tp_setsockopt ( struct socket * sock , int level , int optname , //<S2SV> char __user * optval , unsigned int optlen ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct l2tp_session * session ; //<S2SV> struct l2tp_tunnel * tunnel ; //<S2SV> struct pppol2tp_session * ps ; //<S2SV> int val ; //<S2SV> int err ; //<S2SV> if ( level != SOL_PPPOL2TP ) //<S2SV> return udp_prot . setsockopt ( sk , level , optname , optval , optlen ) ; //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( get_user ( val , ( int __user * ) optval ) ) //<S2SV> return - EFAULT ; //<S2SV> err = - ENOTCONN ; //<S2SV> if ( sk -> sk_user_data == NULL ) //<S2SV> goto end ; //<S2SV> err = - EBADF ; //<S2SV> session = pppol2tp_sock_to_session ( sk ) ; //<S2SV> if ( session == NULL ) //<S2SV> goto end ; //<S2SV> ps = l2tp_session_priv ( session ) ; //<S2SV> if ( ( session -> session_id == 0 ) && //<S2SV> ( session -> peer_session_id == 0 ) ) { //<S2SV> err = - EBADF ; //<S2SV> tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; //<S2SV> if ( tunnel == NULL ) //<S2SV> goto end_put_sess ; //<S2SV> err = pppol2tp_tunnel_setsockopt ( sk , tunnel , optname , val ) ; //<S2SV> sock_put ( ps -> tunnel_sock ) ; //<S2SV> } else //<S2SV> err = pppol2tp_session_setsockopt ( sk , session , optname , val ) ; //<S2SV> err = 0 ; //<S2SV> end_put_sess : //<S2SV> sock_put ( sk ) ; //<S2SV> end : //<S2SV> return err ; //<S2SV> } //<S2SV> 