unsigned int arpt_do_table ( struct sk_buff * skb , //<S2SV> const struct nf_hook_state * state , //<S2SV> struct xt_table * table ) //<S2SV> { //<S2SV> unsigned int hook = state -> hook ; //<S2SV> static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; //<S2SV> unsigned int verdict = NF_DROP ; //<S2SV> const struct arphdr * arp ; //<S2SV> struct arpt_entry * e , * * jumpstack ; //<S2SV> const char * indev , * outdev ; //<S2SV> const void * table_base ; //<S2SV> unsigned int cpu , stackidx = 0 ; //<S2SV> const struct xt_table_info * private ; //<S2SV> struct xt_action_param acpar ; //<S2SV> unsigned int addend ; //<S2SV> if ( ! pskb_may_pull ( skb , arp_hdr_len ( skb -> dev ) ) ) //<S2SV> return NF_DROP ; //<S2SV> indev = state -> in ? state -> in -> name : nulldevname ; //<S2SV> outdev = state -> out ? state -> out -> name : nulldevname ; //<S2SV> local_bh_disable ( ) ; //<S2SV> addend = xt_write_recseq_begin ( ) ; //<S2SV> private = READ_ONCE ( table -> private ) ; //<S2SV> cpu = smp_processor_id ( ) ; //<S2SV> table_base = private -> entries ; //<S2SV> jumpstack = ( struct arpt_entry * * ) private -> jumpstack [ cpu ] ; //<S2SV> e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; //<S2SV> acpar . state = state ; //<S2SV> acpar . hotdrop = false ; //<S2SV> arp = arp_hdr ( skb ) ; //<S2SV> do { //<S2SV> const struct xt_entry_target * t ; //<S2SV> struct xt_counters * counter ; //<S2SV> if ( ! arp_packet_match ( arp , skb -> dev , indev , outdev , & e -> arp ) ) { //<S2SV> e = arpt_next_entry ( e ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> counter = xt_get_this_cpu_counter ( & e -> counters ) ; //<S2SV> ADD_COUNTER ( * counter , arp_hdr_len ( skb -> dev ) , 1 ) ; //<S2SV> t = arpt_get_target_c ( e ) ; //<S2SV> if ( ! t -> u . kernel . target -> target ) { //<S2SV> int v ; //<S2SV> v = ( ( struct xt_standard_target * ) t ) -> verdict ; //<S2SV> if ( v < 0 ) { //<S2SV> if ( v != XT_RETURN ) { //<S2SV> verdict = ( unsigned int ) ( - v ) - 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( stackidx == 0 ) { //<S2SV> e = get_entry ( table_base , //<S2SV> private -> underflow [ hook ] ) ; //<S2SV> } else { //<S2SV> e = jumpstack [ -- stackidx ] ; //<S2SV> e = arpt_next_entry ( e ) ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> if ( table_base + v //<S2SV> != arpt_next_entry ( e ) ) { //<S2SV> if ( unlikely ( stackidx >= private -> stacksize ) ) { //<S2SV> verdict = NF_DROP ; //<S2SV> break ; //<S2SV> } //<S2SV> jumpstack [ stackidx ++ ] = e ; //<S2SV> } //<S2SV> e = get_entry ( table_base , v ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> acpar . target = t -> u . kernel . target ; //<S2SV> acpar . targinfo = t -> data ; //<S2SV> verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; //<S2SV> if ( verdict == XT_CONTINUE ) { //<S2SV> arp = arp_hdr ( skb ) ; //<S2SV> e = arpt_next_entry ( e ) ; //<S2SV> } else { //<S2SV> break ; //<S2SV> } //<S2SV> } while ( ! acpar . hotdrop ) ; //<S2SV> xt_write_recseq_end ( addend ) ; //<S2SV> local_bh_enable ( ) ; //<S2SV> if ( acpar . hotdrop ) //<S2SV> return NF_DROP ; //<S2SV> else //<S2SV> return verdict ; //<S2SV> } //<S2SV> 