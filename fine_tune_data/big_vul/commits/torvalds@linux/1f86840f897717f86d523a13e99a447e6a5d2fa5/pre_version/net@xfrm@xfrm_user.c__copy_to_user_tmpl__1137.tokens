static int copy_to_user_tmpl ( struct xfrm_policy * xp , struct sk_buff * skb ) //<S2SV> { //<S2SV> struct xfrm_user_tmpl vec [ XFRM_MAX_DEPTH ] ; //<S2SV> int i ; //<S2SV> if ( xp -> xfrm_nr == 0 ) //<S2SV> return 0 ; //<S2SV> for ( i = 0 ; i < xp -> xfrm_nr ; i ++ ) { //<S2SV> struct xfrm_user_tmpl * up = & vec [ i ] ; //<S2SV> struct xfrm_tmpl * kp = & xp -> xfrm_vec [ i ] ; //<S2SV> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; //<S2SV> up -> family = kp -> encap_family ; //<S2SV> memcpy ( & up -> saddr , & kp -> saddr , sizeof ( up -> saddr ) ) ; //<S2SV> up -> reqid = kp -> reqid ; //<S2SV> up -> mode = kp -> mode ; //<S2SV> up -> share = kp -> share ; //<S2SV> up -> optional = kp -> optional ; //<S2SV> up -> aalgos = kp -> aalgos ; //<S2SV> up -> ealgos = kp -> ealgos ; //<S2SV> up -> calgos = kp -> calgos ; //<S2SV> } //<S2SV> return nla_put ( skb , XFRMA_TMPL , //<S2SV> sizeof ( struct xfrm_user_tmpl ) * xp -> xfrm_nr , vec ) ; //<S2SV> } //<S2SV> 