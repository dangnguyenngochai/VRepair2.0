static int netlink_dump ( struct sock * sk ) //<S2SV> { //<S2SV> struct netlink_sock * nlk = nlk_sk ( sk ) ; //<S2SV> struct netlink_callback * cb ; //<S2SV> struct sk_buff * skb = NULL ; //<S2SV> struct nlmsghdr * nlh ; //<S2SV> int len , err = - ENOBUFS ; //<S2SV> int alloc_min_size ; //<S2SV> int alloc_size ; //<S2SV> mutex_lock ( nlk -> cb_mutex ) ; //<S2SV> if ( ! nlk -> cb_running ) { //<S2SV> err = - EINVAL ; //<S2SV> goto errout_skb ; //<S2SV> } //<S2SV> if ( atomic_read ( & sk -> sk_rmem_alloc ) >= sk -> sk_rcvbuf ) //<S2SV> goto errout_skb ; //<S2SV> cb = & nlk -> cb ; //<S2SV> alloc_min_size = max_t ( int , cb -> min_dump_alloc , NLMSG_GOODSIZE ) ; //<S2SV> if ( alloc_min_size < nlk -> max_recvmsg_len ) { //<S2SV> alloc_size = nlk -> max_recvmsg_len ; //<S2SV> skb = alloc_skb ( alloc_size , GFP_KERNEL | //<S2SV> __GFP_NOWARN | __GFP_NORETRY ) ; //<S2SV> } //<S2SV> if ( ! skb ) { //<S2SV> alloc_size = alloc_min_size ; //<S2SV> skb = alloc_skb ( alloc_size , GFP_KERNEL ) ; //<S2SV> } //<S2SV> if ( ! skb ) //<S2SV> goto errout_skb ; //<S2SV> skb_reserve ( skb , skb_tailroom ( skb ) - alloc_size ) ; //<S2SV> netlink_skb_set_owner_r ( skb , sk ) ; //<S2SV> len = cb -> dump ( skb , cb ) ; //<S2SV> if ( len > 0 ) { //<S2SV> mutex_unlock ( nlk -> cb_mutex ) ; //<S2SV> if ( sk_filter ( sk , skb ) ) //<S2SV> kfree_skb ( skb ) ; //<S2SV> else //<S2SV> __netlink_sendskb ( sk , skb ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> nlh = nlmsg_put_answer ( skb , cb , NLMSG_DONE , sizeof ( len ) , NLM_F_MULTI ) ; //<S2SV> if ( ! nlh ) //<S2SV> goto errout_skb ; //<S2SV> nl_dump_check_consistent ( cb , nlh ) ; //<S2SV> memcpy ( nlmsg_data ( nlh ) , & len , sizeof ( len ) ) ; //<S2SV> if ( sk_filter ( sk , skb ) ) //<S2SV> kfree_skb ( skb ) ; //<S2SV> else //<S2SV> __netlink_sendskb ( sk , skb ) ; //<S2SV> if ( cb -> done ) //<S2SV> cb -> done ( cb ) ; //<S2SV> nlk -> cb_running = false ; //<S2SV> mutex_unlock ( nlk -> cb_mutex ) ; //<S2SV> module_put ( cb -> module ) ; //<S2SV> consume_skb ( cb -> skb ) ; //<S2SV> return 0 ; //<S2SV> errout_skb : //<S2SV> mutex_unlock ( nlk -> cb_mutex ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 