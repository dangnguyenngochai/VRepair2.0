static int hwahc_security_create ( struct hwahc * hwahc ) //<S2SV> { //<S2SV> int result ; //<S2SV> struct wusbhc * wusbhc = & hwahc -> wusbhc ; //<S2SV> struct usb_device * usb_dev = hwahc -> wa . usb_dev ; //<S2SV> struct device * dev = & usb_dev -> dev ; //<S2SV> struct usb_security_descriptor * secd ; //<S2SV> struct usb_encryption_descriptor * etd ; //<S2SV> void * itr , * top ; //<S2SV> size_t itr_size , needed , bytes ; //<S2SV> u8 index ; //<S2SV> char buf [ 64 ] ; //<S2SV> index = ( usb_dev -> actconfig - usb_dev -> config ) / //<S2SV> sizeof ( usb_dev -> config [ 0 ] ) ; //<S2SV> itr = usb_dev -> rawdescriptors [ index ] ; //<S2SV> itr_size = le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ; //<S2SV> top = itr + itr_size ; //<S2SV> result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , //<S2SV> le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , //<S2SV> USB_DT_SECURITY , ( void * * ) & secd ) ; //<S2SV> if ( result == - 1 ) { //<S2SV> dev_warn ( dev , "BUG?<S2SV_blank>WUSB<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>security<S2SV_blank>descriptors\\n" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> needed = sizeof ( * secd ) ; //<S2SV> if ( top - ( void * ) secd < needed ) { //<S2SV> dev_err ( dev , "BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>" //<S2SV> "descriptor<S2SV_blank>header<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , //<S2SV> top - ( void * ) secd , needed ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> needed = le16_to_cpu ( secd -> wTotalLength ) ; //<S2SV> if ( top - ( void * ) secd < needed ) { //<S2SV> dev_err ( dev , "BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>" //<S2SV> "descriptors<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , //<S2SV> top - ( void * ) secd , needed ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> itr = ( void * ) secd + sizeof ( * secd ) ; //<S2SV> top = ( void * ) secd + le16_to_cpu ( secd -> wTotalLength ) ; //<S2SV> index = 0 ; //<S2SV> bytes = 0 ; //<S2SV> while ( itr < top ) { //<S2SV> etd = itr ; //<S2SV> if ( top - itr < sizeof ( * etd ) ) { //<S2SV> dev_err ( dev , "BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>security<S2SV_blank>descriptor;<S2SV_blank>" //<S2SV> "not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>left)\\n" , //<S2SV> top - itr , sizeof ( * etd ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( etd -> bLength < sizeof ( * etd ) ) { //<S2SV> dev_err ( dev , "BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>encryption<S2SV_blank>descriptor;<S2SV_blank>" //<S2SV> "descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short<S2SV_blank>" //<S2SV> "(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , //<S2SV> ( size_t ) etd -> bLength , sizeof ( * etd ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> itr += etd -> bLength ; //<S2SV> bytes += snprintf ( buf + bytes , sizeof ( buf ) - bytes , //<S2SV> "%s<S2SV_blank>(0x%02x)<S2SV_blank>" , //<S2SV> wusb_et_name ( etd -> bEncryptionType ) , //<S2SV> etd -> bEncryptionValue ) ; //<S2SV> wusbhc -> ccm1_etd = etd ; //<S2SV> } //<S2SV> dev_info ( dev , "supported<S2SV_blank>encryption<S2SV_blank>types:<S2SV_blank>%s\\n" , buf ) ; //<S2SV> if ( wusbhc -> ccm1_etd == NULL ) { //<S2SV> dev_err ( dev , "E:<S2SV_blank>host<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>CCM-1<S2SV_blank>crypto\\n" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 