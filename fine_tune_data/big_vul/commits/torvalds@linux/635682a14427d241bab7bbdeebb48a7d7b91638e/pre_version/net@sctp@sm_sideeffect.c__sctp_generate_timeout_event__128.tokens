static void sctp_generate_timeout_event ( struct sctp_association * asoc , //<S2SV> sctp_event_timeout_t timeout_type ) //<S2SV> { //<S2SV> struct net * net = sock_net ( asoc -> base . sk ) ; //<S2SV> int error = 0 ; //<S2SV> bh_lock_sock ( asoc -> base . sk ) ; //<S2SV> if ( sock_owned_by_user ( asoc -> base . sk ) ) { //<S2SV> pr_debug ( "%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>timer<S2SV_blank>%d\\n" , __func__ , //<S2SV> timeout_type ) ; //<S2SV> if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) //<S2SV> sctp_association_hold ( asoc ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> if ( asoc -> base . dead ) //<S2SV> goto out_unlock ; //<S2SV> error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , //<S2SV> SCTP_ST_TIMEOUT ( timeout_type ) , //<S2SV> asoc -> state , asoc -> ep , asoc , //<S2SV> ( void * ) timeout_type , GFP_ATOMIC ) ; //<S2SV> if ( error ) //<S2SV> asoc -> base . sk -> sk_err = - error ; //<S2SV> out_unlock : //<S2SV> bh_unlock_sock ( asoc -> base . sk ) ; //<S2SV> sctp_association_put ( asoc ) ; //<S2SV> } //<S2SV> 