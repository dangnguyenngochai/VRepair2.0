void sctp_generate_heartbeat_event ( unsigned long data ) //<S2SV> { //<S2SV> int error = 0 ; //<S2SV> struct sctp_transport * transport = ( struct sctp_transport * ) data ; //<S2SV> struct sctp_association * asoc = transport -> asoc ; //<S2SV> struct sock * sk = asoc -> base . sk ; //<S2SV> struct net * net = sock_net ( sk ) ; //<S2SV> bh_lock_sock ( sk ) ; //<S2SV> if ( sock_owned_by_user ( sk ) ) { //<S2SV> pr_debug ( "%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n" , __func__ ) ; //<S2SV> if ( ! mod_timer ( & transport -> hb_timer , jiffies + ( HZ / 20 ) ) ) //<S2SV> sctp_transport_hold ( transport ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> if ( transport -> dead ) //<S2SV> goto out_unlock ; //<S2SV> error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , //<S2SV> SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_HEARTBEAT ) , //<S2SV> asoc -> state , asoc -> ep , asoc , //<S2SV> transport , GFP_ATOMIC ) ; //<S2SV> if ( error ) //<S2SV> sk -> sk_err = - error ; //<S2SV> out_unlock : //<S2SV> bh_unlock_sock ( sk ) ; //<S2SV> sctp_transport_put ( transport ) ; //<S2SV> } //<S2SV> 