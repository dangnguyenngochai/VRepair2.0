static int //<S2SV> fb_mmap ( struct file * file , struct vm_area_struct * vma ) //<S2SV> { //<S2SV> struct fb_info * info = file_fb_info ( file ) ; //<S2SV> struct fb_ops * fb ; //<S2SV> unsigned long off ; //<S2SV> unsigned long start ; //<S2SV> u32 len ; //<S2SV> if ( ! info ) //<S2SV> return - ENODEV ; //<S2SV> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) //<S2SV> return - EINVAL ; //<S2SV> off = vma -> vm_pgoff << PAGE_SHIFT ; //<S2SV> fb = info -> fbops ; //<S2SV> if ( ! fb ) //<S2SV> return - ENODEV ; //<S2SV> mutex_lock ( & info -> mm_lock ) ; //<S2SV> if ( fb -> fb_mmap ) { //<S2SV> int res ; //<S2SV> res = fb -> fb_mmap ( info , vma ) ; //<S2SV> mutex_unlock ( & info -> mm_lock ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> start = info -> fix . smem_start ; //<S2SV> len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . smem_len ) ; //<S2SV> if ( off >= len ) { //<S2SV> off -= len ; //<S2SV> if ( info -> var . accel_flags ) { //<S2SV> mutex_unlock ( & info -> mm_lock ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> start = info -> fix . mmio_start ; //<S2SV> len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . mmio_len ) ; //<S2SV> } //<S2SV> mutex_unlock ( & info -> mm_lock ) ; //<S2SV> start &= PAGE_MASK ; //<S2SV> if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) //<S2SV> return - EINVAL ; //<S2SV> off += start ; //<S2SV> vma -> vm_pgoff = off >> PAGE_SHIFT ; //<S2SV> vma -> vm_page_prot = vm_get_page_prot ( vma -> vm_flags ) ; //<S2SV> fb_pgprotect ( file , vma , off ) ; //<S2SV> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , //<S2SV> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) //<S2SV> return - EAGAIN ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 