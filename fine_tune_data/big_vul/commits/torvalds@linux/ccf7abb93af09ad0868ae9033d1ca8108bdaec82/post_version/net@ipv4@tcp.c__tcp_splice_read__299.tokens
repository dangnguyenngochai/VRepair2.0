ssize_t tcp_splice_read ( struct socket * sock , loff_t * ppos , //<S2SV> struct pipe_inode_info * pipe , size_t len , //<S2SV> unsigned int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct tcp_splice_state tss = { //<S2SV> . pipe = pipe , //<S2SV> . len = len , //<S2SV> . flags = flags , //<S2SV> } ; //<S2SV> long timeo ; //<S2SV> ssize_t spliced ; //<S2SV> int ret ; //<S2SV> sock_rps_record_flow ( sk ) ; //<S2SV> if ( unlikely ( * ppos ) ) //<S2SV> return - ESPIPE ; //<S2SV> ret = spliced = 0 ; //<S2SV> lock_sock ( sk ) ; //<S2SV> timeo = sock_rcvtimeo ( sk , sock -> file -> f_flags & O_NONBLOCK ) ; //<S2SV> while ( tss . len ) { //<S2SV> ret = __tcp_splice_read ( sk , & tss ) ; //<S2SV> if ( ret < 0 ) //<S2SV> break ; //<S2SV> else if ( ! ret ) { //<S2SV> if ( spliced ) //<S2SV> break ; //<S2SV> if ( sock_flag ( sk , SOCK_DONE ) ) //<S2SV> break ; //<S2SV> if ( sk -> sk_err ) { //<S2SV> ret = sock_error ( sk ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> break ; //<S2SV> if ( sk -> sk_state == TCP_CLOSE ) { //<S2SV> if ( ! sock_flag ( sk , SOCK_DONE ) ) //<S2SV> ret = - ENOTCONN ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! timeo ) { //<S2SV> ret = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) //<S2SV> break ; //<S2SV> sk_wait_data ( sk , & timeo , NULL ) ; //<S2SV> if ( signal_pending ( current ) ) { //<S2SV> ret = sock_intr_errno ( timeo ) ; //<S2SV> break ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> tss . len -= ret ; //<S2SV> spliced += ret ; //<S2SV> if ( ! timeo ) //<S2SV> break ; //<S2SV> release_sock ( sk ) ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || //<S2SV> ( sk -> sk_shutdown & RCV_SHUTDOWN ) || //<S2SV> signal_pending ( current ) ) //<S2SV> break ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> if ( spliced ) //<S2SV> return spliced ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 