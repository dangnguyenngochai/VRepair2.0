static int rfcomm_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) //<S2SV> { //<S2SV> struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> int chan = sa -> rc_channel ; //<S2SV> int err = 0 ; //<S2SV> BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>%pMR" , sk , & sa -> rc_bdaddr ) ; //<S2SV> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) //<S2SV> return - EINVAL ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( sk -> sk_state != BT_OPEN ) { //<S2SV> err = - EBADFD ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( sk -> sk_type != SOCK_STREAM ) { //<S2SV> err = - EINVAL ; //<S2SV> goto done ; //<S2SV> } //<S2SV> write_lock ( & rfcomm_sk_list . lock ) ; //<S2SV> if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) { //<S2SV> err = - EADDRINUSE ; //<S2SV> } else { //<S2SV> bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ; //<S2SV> rfcomm_pi ( sk ) -> channel = chan ; //<S2SV> sk -> sk_state = BT_BOUND ; //<S2SV> } //<S2SV> write_unlock ( & rfcomm_sk_list . lock ) ; //<S2SV> done : //<S2SV> release_sock ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 