static int rfcomm_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) //<S2SV> { //<S2SV> struct sockaddr_rc sa ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> int len , err = 0 ; //<S2SV> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) //<S2SV> return - EINVAL ; //<S2SV> memset ( & sa , 0 , sizeof ( sa ) ) ; //<S2SV> len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; //<S2SV> memcpy ( & sa , addr , len ) ; //<S2SV> BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>%pMR" , sk , & sa . rc_bdaddr ) ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( sk -> sk_state != BT_OPEN ) { //<S2SV> err = - EBADFD ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( sk -> sk_type != SOCK_STREAM ) { //<S2SV> err = - EINVAL ; //<S2SV> goto done ; //<S2SV> } //<S2SV> write_lock ( & rfcomm_sk_list . lock ) ; //<S2SV> if ( sa . rc_channel && //<S2SV> __rfcomm_get_listen_sock_by_addr ( sa . rc_channel , & sa . rc_bdaddr ) ) { //<S2SV> err = - EADDRINUSE ; //<S2SV> } else { //<S2SV> bacpy ( & rfcomm_pi ( sk ) -> src , & sa . rc_bdaddr ) ; //<S2SV> rfcomm_pi ( sk ) -> channel = sa . rc_channel ; //<S2SV> sk -> sk_state = BT_BOUND ; //<S2SV> } //<S2SV> write_unlock ( & rfcomm_sk_list . lock ) ; //<S2SV> done : //<S2SV> release_sock ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 