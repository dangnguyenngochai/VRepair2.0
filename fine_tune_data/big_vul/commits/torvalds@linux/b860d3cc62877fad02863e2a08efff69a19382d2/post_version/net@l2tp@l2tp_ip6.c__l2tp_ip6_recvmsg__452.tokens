static int l2tp_ip6_recvmsg ( struct kiocb * iocb , struct sock * sk , //<S2SV> struct msghdr * msg , size_t len , int noblock , //<S2SV> int flags , int * addr_len ) //<S2SV> { //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) msg -> msg_name ; //<S2SV> size_t copied = 0 ; //<S2SV> int err = - EOPNOTSUPP ; //<S2SV> struct sk_buff * skb ; //<S2SV> if ( flags & MSG_OOB ) //<S2SV> goto out ; //<S2SV> if ( addr_len ) //<S2SV> * addr_len = sizeof ( * lsa ) ; //<S2SV> if ( flags & MSG_ERRQUEUE ) //<S2SV> return ipv6_recv_error ( sk , msg , len ) ; //<S2SV> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; //<S2SV> if ( ! skb ) //<S2SV> goto out ; //<S2SV> copied = skb -> len ; //<S2SV> if ( len < copied ) { //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> copied = len ; //<S2SV> } //<S2SV> err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; //<S2SV> if ( err ) //<S2SV> goto done ; //<S2SV> sock_recv_timestamp ( msg , sk , skb ) ; //<S2SV> if ( lsa ) { //<S2SV> lsa -> l2tp_family = AF_INET6 ; //<S2SV> lsa -> l2tp_unused = 0 ; //<S2SV> lsa -> l2tp_addr = ipv6_hdr ( skb ) -> saddr ; //<S2SV> lsa -> l2tp_flowinfo = 0 ; //<S2SV> lsa -> l2tp_scope_id = 0 ; //<S2SV> lsa -> l2tp_conn_id = 0 ; //<S2SV> if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) //<S2SV> lsa -> l2tp_scope_id = IP6CB ( skb ) -> iif ; //<S2SV> } //<S2SV> if ( np -> rxopt . all ) //<S2SV> ip6_datagram_recv_ctl ( sk , msg , skb ) ; //<S2SV> if ( flags & MSG_TRUNC ) //<S2SV> copied = skb -> len ; //<S2SV> done : //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> out : //<S2SV> return err ? err : copied ; //<S2SV> } //<S2SV> 