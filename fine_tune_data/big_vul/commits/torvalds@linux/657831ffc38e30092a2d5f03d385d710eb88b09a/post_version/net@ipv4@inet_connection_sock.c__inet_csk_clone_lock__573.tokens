struct sock * inet_csk_clone_lock ( const struct sock * sk , //<S2SV> const struct request_sock * req , //<S2SV> const gfp_t priority ) //<S2SV> { //<S2SV> struct sock * newsk = sk_clone_lock ( sk , priority ) ; //<S2SV> if ( newsk ) { //<S2SV> struct inet_connection_sock * newicsk = inet_csk ( newsk ) ; //<S2SV> newsk -> sk_state = TCP_SYN_RECV ; //<S2SV> newicsk -> icsk_bind_hash = NULL ; //<S2SV> inet_sk ( newsk ) -> inet_dport = inet_rsk ( req ) -> ir_rmt_port ; //<S2SV> inet_sk ( newsk ) -> inet_num = inet_rsk ( req ) -> ir_num ; //<S2SV> inet_sk ( newsk ) -> inet_sport = htons ( inet_rsk ( req ) -> ir_num ) ; //<S2SV> newsk -> sk_write_space = sk_stream_write_space ; //<S2SV> sock_reset_flag ( newsk , SOCK_RCU_FREE ) ; //<S2SV> inet_sk ( newsk ) -> mc_list = NULL ; //<S2SV> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; //<S2SV> atomic64_set ( & newsk -> sk_cookie , //<S2SV> atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ; //<S2SV> newicsk -> icsk_retransmits = 0 ; //<S2SV> newicsk -> icsk_backoff = 0 ; //<S2SV> newicsk -> icsk_probes_out = 0 ; //<S2SV> memset ( & newicsk -> icsk_accept_queue , 0 , sizeof ( newicsk -> icsk_accept_queue ) ) ; //<S2SV> security_inet_csk_clone ( newsk , req ) ; //<S2SV> } //<S2SV> return newsk ; //<S2SV> } //<S2SV> 