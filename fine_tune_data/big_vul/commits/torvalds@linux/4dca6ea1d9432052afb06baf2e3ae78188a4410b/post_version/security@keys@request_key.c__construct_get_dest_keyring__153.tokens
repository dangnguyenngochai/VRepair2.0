static int construct_get_dest_keyring ( struct key * * _dest_keyring ) //<S2SV> { //<S2SV> struct request_key_auth * rka ; //<S2SV> const struct cred * cred = current_cred ( ) ; //<S2SV> struct key * dest_keyring = * _dest_keyring , * authkey ; //<S2SV> int ret ; //<S2SV> kenter ( "%p" , dest_keyring ) ; //<S2SV> if ( dest_keyring ) { //<S2SV> key_get ( dest_keyring ) ; //<S2SV> } else { //<S2SV> bool do_perm_check = true ; //<S2SV> switch ( cred -> jit_keyring ) { //<S2SV> case KEY_REQKEY_DEFL_DEFAULT : //<S2SV> case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : //<S2SV> if ( cred -> request_key_auth ) { //<S2SV> authkey = cred -> request_key_auth ; //<S2SV> down_read ( & authkey -> sem ) ; //<S2SV> rka = authkey -> payload . data [ 0 ] ; //<S2SV> if ( ! test_bit ( KEY_FLAG_REVOKED , //<S2SV> & authkey -> flags ) ) //<S2SV> dest_keyring = //<S2SV> key_get ( rka -> dest_keyring ) ; //<S2SV> up_read ( & authkey -> sem ) ; //<S2SV> if ( dest_keyring ) { //<S2SV> do_perm_check = false ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> case KEY_REQKEY_DEFL_THREAD_KEYRING : //<S2SV> dest_keyring = key_get ( cred -> thread_keyring ) ; //<S2SV> if ( dest_keyring ) //<S2SV> break ; //<S2SV> case KEY_REQKEY_DEFL_PROCESS_KEYRING : //<S2SV> dest_keyring = key_get ( cred -> process_keyring ) ; //<S2SV> if ( dest_keyring ) //<S2SV> break ; //<S2SV> case KEY_REQKEY_DEFL_SESSION_KEYRING : //<S2SV> rcu_read_lock ( ) ; //<S2SV> dest_keyring = key_get ( //<S2SV> rcu_dereference ( cred -> session_keyring ) ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> if ( dest_keyring ) //<S2SV> break ; //<S2SV> case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : //<S2SV> dest_keyring = //<S2SV> key_get ( cred -> user -> session_keyring ) ; //<S2SV> break ; //<S2SV> case KEY_REQKEY_DEFL_USER_KEYRING : //<S2SV> dest_keyring = key_get ( cred -> user -> uid_keyring ) ; //<S2SV> break ; //<S2SV> case KEY_REQKEY_DEFL_GROUP_KEYRING : //<S2SV> default : //<S2SV> BUG ( ) ; //<S2SV> } //<S2SV> if ( dest_keyring && do_perm_check ) { //<S2SV> ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , //<S2SV> KEY_NEED_WRITE ) ; //<S2SV> if ( ret ) { //<S2SV> key_put ( dest_keyring ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> * _dest_keyring = dest_keyring ; //<S2SV> kleave ( "<S2SV_blank>[dk<S2SV_blank>%d]" , key_serial ( dest_keyring ) ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 