int vcc_getsockopt ( struct socket * sock , int level , int optname , //<S2SV> char __user * optval , int __user * optlen ) //<S2SV> { //<S2SV> struct atm_vcc * vcc ; //<S2SV> int len ; //<S2SV> if ( get_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( __SO_LEVEL_MATCH ( optname , level ) && len != __SO_SIZE ( optname ) ) //<S2SV> return - EINVAL ; //<S2SV> vcc = ATM_SD ( sock ) ; //<S2SV> switch ( optname ) { //<S2SV> case SO_ATMQOS : //<S2SV> if ( ! test_bit ( ATM_VF_HASQOS , & vcc -> flags ) ) //<S2SV> return - EINVAL ; //<S2SV> return copy_to_user ( optval , & vcc -> qos , sizeof ( vcc -> qos ) ) //<S2SV> ? - EFAULT : 0 ; //<S2SV> case SO_SETCLP : //<S2SV> return put_user ( vcc -> atm_options & ATM_ATMOPT_CLP ? 1 : 0 , //<S2SV> ( unsigned long __user * ) optval ) ? - EFAULT : 0 ; //<S2SV> case SO_ATMPVC : //<S2SV> { //<S2SV> struct sockaddr_atmpvc pvc ; //<S2SV> if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) //<S2SV> return - ENOTCONN ; //<S2SV> pvc . sap_family = AF_ATMPVC ; //<S2SV> pvc . sap_addr . itf = vcc -> dev -> number ; //<S2SV> pvc . sap_addr . vpi = vcc -> vpi ; //<S2SV> pvc . sap_addr . vci = vcc -> vci ; //<S2SV> return copy_to_user ( optval , & pvc , sizeof ( pvc ) ) ? - EFAULT : 0 ; //<S2SV> } //<S2SV> default : //<S2SV> if ( level == SOL_SOCKET ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! vcc -> dev || ! vcc -> dev -> ops -> getsockopt ) //<S2SV> return - EINVAL ; //<S2SV> return vcc -> dev -> ops -> getsockopt ( vcc , level , optname , optval , len ) ; //<S2SV> } //<S2SV> 