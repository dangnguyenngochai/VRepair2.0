static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , //<S2SV> unsigned int dataoff , unsigned int * timeouts ) //<S2SV> { //<S2SV> struct net * net = nf_ct_net ( ct ) ; //<S2SV> struct dccp_net * dn ; //<S2SV> struct dccp_hdr _dh , * dh ; //<S2SV> const char * msg ; //<S2SV> u_int8_t state ; //<S2SV> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ; //<S2SV> BUG_ON ( dh == NULL ) ; //<S2SV> state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; //<S2SV> switch ( state ) { //<S2SV> default : //<S2SV> dn = dccp_pernet ( net ) ; //<S2SV> if ( dn -> dccp_loose == 0 ) { //<S2SV> msg = "nf_ct_dccp:<S2SV_blank>not<S2SV_blank>picking<S2SV_blank>up<S2SV_blank>existing<S2SV_blank>connection<S2SV_blank>" ; //<S2SV> goto out_invalid ; //<S2SV> } //<S2SV> case CT_DCCP_REQUEST : //<S2SV> break ; //<S2SV> case CT_DCCP_INVALID : //<S2SV> msg = "nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>" ; //<S2SV> goto out_invalid ; //<S2SV> } //<S2SV> ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; //<S2SV> ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; //<S2SV> ct -> proto . dccp . state = CT_DCCP_NONE ; //<S2SV> ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; //<S2SV> ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; //<S2SV> ct -> proto . dccp . handshake_seq = 0 ; //<S2SV> return true ; //<S2SV> out_invalid : //<S2SV> if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) //<S2SV> nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , //<S2SV> NULL , "%s" , msg ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> 