static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , //<S2SV> unsigned int dataoff , enum ip_conntrack_info ctinfo , //<S2SV> u_int8_t pf , unsigned int hooknum , //<S2SV> unsigned int * timeouts ) //<S2SV> { //<S2SV> struct net * net = nf_ct_net ( ct ) ; //<S2SV> enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; //<S2SV> struct dccp_hdr _dh , * dh ; //<S2SV> u_int8_t type , old_state , new_state ; //<S2SV> enum ct_dccp_roles role ; //<S2SV> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; //<S2SV> BUG_ON ( dh == NULL ) ; //<S2SV> type = dh -> dccph_type ; //<S2SV> if ( type == DCCP_PKT_RESET && //<S2SV> ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { //<S2SV> nf_ct_kill_acct ( ct , ctinfo , skb ) ; //<S2SV> return NF_ACCEPT ; //<S2SV> } //<S2SV> spin_lock_bh ( & ct -> lock ) ; //<S2SV> role = ct -> proto . dccp . role [ dir ] ; //<S2SV> old_state = ct -> proto . dccp . state ; //<S2SV> new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; //<S2SV> switch ( new_state ) { //<S2SV> case CT_DCCP_REQUEST : //<S2SV> if ( old_state == CT_DCCP_TIMEWAIT && //<S2SV> role == CT_DCCP_ROLE_SERVER ) { //<S2SV> ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; //<S2SV> ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; //<S2SV> } //<S2SV> break ; //<S2SV> case CT_DCCP_RESPOND : //<S2SV> if ( old_state == CT_DCCP_REQUEST ) //<S2SV> ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; //<S2SV> break ; //<S2SV> case CT_DCCP_PARTOPEN : //<S2SV> if ( old_state == CT_DCCP_RESPOND && //<S2SV> type == DCCP_PKT_ACK && //<S2SV> dccp_ack_seq ( dh ) == ct -> proto . dccp . handshake_seq ) //<S2SV> set_bit ( IPS_ASSURED_BIT , & ct -> status ) ; //<S2SV> break ; //<S2SV> case CT_DCCP_IGNORE : //<S2SV> if ( ct -> proto . dccp . last_dir == ! dir && //<S2SV> ct -> proto . dccp . last_pkt == DCCP_PKT_REQUEST && //<S2SV> type == DCCP_PKT_RESPONSE ) { //<S2SV> ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_CLIENT ; //<S2SV> ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_SERVER ; //<S2SV> ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; //<S2SV> new_state = CT_DCCP_RESPOND ; //<S2SV> break ; //<S2SV> } //<S2SV> ct -> proto . dccp . last_dir = dir ; //<S2SV> ct -> proto . dccp . last_pkt = type ; //<S2SV> spin_unlock_bh ( & ct -> lock ) ; //<S2SV> if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) //<S2SV> nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , //<S2SV> "nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>ignored<S2SV_blank>" ) ; //<S2SV> return NF_ACCEPT ; //<S2SV> case CT_DCCP_INVALID : //<S2SV> spin_unlock_bh ( & ct -> lock ) ; //<S2SV> if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) //<S2SV> nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL , //<S2SV> "nf_ct_dccp:<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>transition<S2SV_blank>" ) ; //<S2SV> return - NF_ACCEPT ; //<S2SV> } //<S2SV> ct -> proto . dccp . last_dir = dir ; //<S2SV> ct -> proto . dccp . last_pkt = type ; //<S2SV> ct -> proto . dccp . state = new_state ; //<S2SV> spin_unlock_bh ( & ct -> lock ) ; //<S2SV> if ( new_state != old_state ) //<S2SV> nf_conntrack_event_cache ( IPCT_PROTOINFO , ct ) ; //<S2SV> nf_ct_refresh_acct ( ct , ctinfo , skb , timeouts [ new_state ] ) ; //<S2SV> return NF_ACCEPT ; //<S2SV> } //<S2SV> 