struct dentry * //<S2SV> cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , //<S2SV> struct nameidata * nd ) //<S2SV> { //<S2SV> int xid ; //<S2SV> int rc = 0 ; //<S2SV> __u32 oplock = enable_oplocks ? REQ_OPLOCK : 0 ; //<S2SV> __u16 fileHandle = 0 ; //<S2SV> bool posix_open = false ; //<S2SV> struct cifs_sb_info * cifs_sb ; //<S2SV> struct tcon_link * tlink ; //<S2SV> struct cifs_tcon * pTcon ; //<S2SV> struct cifsFileInfo * cfile ; //<S2SV> struct inode * newInode = NULL ; //<S2SV> char * full_path = NULL ; //<S2SV> struct file * filp ; //<S2SV> xid = GetXid ( ) ; //<S2SV> cFYI ( 1 , "parent<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p<S2SV_blank>name<S2SV_blank>is:<S2SV_blank>%s<S2SV_blank>and<S2SV_blank>dentry<S2SV_blank>=<S2SV_blank>0x%p" , //<S2SV> parent_dir_inode , direntry -> d_name . name , direntry ) ; //<S2SV> cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; //<S2SV> tlink = cifs_sb_tlink ( cifs_sb ) ; //<S2SV> if ( IS_ERR ( tlink ) ) { //<S2SV> FreeXid ( xid ) ; //<S2SV> return ( struct dentry * ) tlink ; //<S2SV> } //<S2SV> pTcon = tlink_tcon ( tlink ) ; //<S2SV> if ( ! ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < direntry -> d_name . len ; i ++ ) //<S2SV> if ( direntry -> d_name . name [ i ] == '\\\\' ) { //<S2SV> cFYI ( 1 , "Invalid<S2SV_blank>file<S2SV_blank>name" ) ; //<S2SV> rc = - EINVAL ; //<S2SV> goto lookup_out ; //<S2SV> } //<S2SV> } //<S2SV> if ( nd && ( nd -> flags & LOOKUP_EXCL ) ) { //<S2SV> d_instantiate ( direntry , NULL ) ; //<S2SV> rc = 0 ; //<S2SV> goto lookup_out ; //<S2SV> } //<S2SV> full_path = build_path_from_dentry ( direntry ) ; //<S2SV> if ( full_path == NULL ) { //<S2SV> rc = - ENOMEM ; //<S2SV> goto lookup_out ; //<S2SV> } //<S2SV> if ( direntry -> d_inode != NULL ) { //<S2SV> cFYI ( 1 , "non-NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup" ) ; //<S2SV> } else { //<S2SV> cFYI ( 1 , "NULL<S2SV_blank>inode<S2SV_blank>in<S2SV_blank>lookup" ) ; //<S2SV> } //<S2SV> cFYI ( 1 , "Full<S2SV_blank>path:<S2SV_blank>%s<S2SV_blank>inode<S2SV_blank>=<S2SV_blank>0x%p" , full_path , direntry -> d_inode ) ; //<S2SV> if ( pTcon -> unix_ext ) { //<S2SV> if ( nd && ! ( nd -> flags & LOOKUP_DIRECTORY ) && //<S2SV> ( nd -> flags & LOOKUP_OPEN ) && ! pTcon -> broken_posix_open && //<S2SV> ( nd -> intent . open . file -> f_flags & O_CREAT ) ) { //<S2SV> rc = cifs_posix_open ( full_path , & newInode , //<S2SV> parent_dir_inode -> i_sb , //<S2SV> nd -> intent . open . create_mode , //<S2SV> nd -> intent . open . file -> f_flags , & oplock , //<S2SV> & fileHandle , xid ) ; //<S2SV> switch ( rc ) { //<S2SV> case 0 : //<S2SV> if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) { //<S2SV> CIFSSMBClose ( xid , pTcon , fileHandle ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case - ENOENT : //<S2SV> posix_open = true ; //<S2SV> case - EOPNOTSUPP : //<S2SV> break ; //<S2SV> default : //<S2SV> pTcon -> broken_posix_open = true ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! posix_open ) //<S2SV> rc = cifs_get_inode_info_unix ( & newInode , full_path , //<S2SV> parent_dir_inode -> i_sb , xid ) ; //<S2SV> } else //<S2SV> rc = cifs_get_inode_info ( & newInode , full_path , NULL , //<S2SV> parent_dir_inode -> i_sb , xid , NULL ) ; //<S2SV> if ( ( rc == 0 ) && ( newInode != NULL ) ) { //<S2SV> d_add ( direntry , newInode ) ; //<S2SV> if ( posix_open ) { //<S2SV> filp = lookup_instantiate_filp ( nd , direntry , //<S2SV> generic_file_open ) ; //<S2SV> if ( IS_ERR ( filp ) ) { //<S2SV> rc = PTR_ERR ( filp ) ; //<S2SV> CIFSSMBClose ( xid , pTcon , fileHandle ) ; //<S2SV> goto lookup_out ; //<S2SV> } //<S2SV> cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , //<S2SV> oplock ) ; //<S2SV> if ( cfile == NULL ) { //<S2SV> fput ( filp ) ; //<S2SV> CIFSSMBClose ( xid , pTcon , fileHandle ) ; //<S2SV> rc = - ENOMEM ; //<S2SV> goto lookup_out ; //<S2SV> } //<S2SV> } //<S2SV> renew_parental_timestamps ( direntry ) ; //<S2SV> } else if ( rc == - ENOENT ) { //<S2SV> rc = 0 ; //<S2SV> direntry -> d_time = jiffies ; //<S2SV> d_add ( direntry , NULL ) ; //<S2SV> } else if ( rc != - EACCES ) { //<S2SV> cERROR ( 1 , "Unexpected<S2SV_blank>lookup<S2SV_blank>error<S2SV_blank>%d" , rc ) ; //<S2SV> } //<S2SV> lookup_out : //<S2SV> kfree ( full_path ) ; //<S2SV> cifs_put_tlink ( tlink ) ; //<S2SV> FreeXid ( xid ) ; //<S2SV> return ERR_PTR ( rc ) ; //<S2SV> } //<S2SV> 