static int powermate_probe ( struct usb_interface * intf , const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct usb_device * udev = interface_to_usbdev ( intf ) ; //<S2SV> struct usb_host_interface * interface ; //<S2SV> struct usb_endpoint_descriptor * endpoint ; //<S2SV> struct powermate_device * pm ; //<S2SV> struct input_dev * input_dev ; //<S2SV> int pipe , maxp ; //<S2SV> int error = - ENOMEM ; //<S2SV> interface = intf -> cur_altsetting ; //<S2SV> endpoint = & interface -> endpoint [ 0 ] . desc ; //<S2SV> if ( ! usb_endpoint_is_int_in ( endpoint ) ) //<S2SV> return - EIO ; //<S2SV> usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , //<S2SV> 0x0a , USB_TYPE_CLASS | USB_RECIP_INTERFACE , //<S2SV> 0 , interface -> desc . bInterfaceNumber , NULL , 0 , //<S2SV> USB_CTRL_SET_TIMEOUT ) ; //<S2SV> pm = kzalloc ( sizeof ( struct powermate_device ) , GFP_KERNEL ) ; //<S2SV> input_dev = input_allocate_device ( ) ; //<S2SV> if ( ! pm || ! input_dev ) //<S2SV> goto fail1 ; //<S2SV> if ( powermate_alloc_buffers ( udev , pm ) ) //<S2SV> goto fail2 ; //<S2SV> pm -> irq = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! pm -> irq ) //<S2SV> goto fail2 ; //<S2SV> pm -> config = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! pm -> config ) //<S2SV> goto fail3 ; //<S2SV> pm -> udev = udev ; //<S2SV> pm -> intf = intf ; //<S2SV> pm -> input = input_dev ; //<S2SV> usb_make_path ( udev , pm -> phys , sizeof ( pm -> phys ) ) ; //<S2SV> strlcat ( pm -> phys , "/input0" , sizeof ( pm -> phys ) ) ; //<S2SV> spin_lock_init ( & pm -> lock ) ; //<S2SV> switch ( le16_to_cpu ( udev -> descriptor . idProduct ) ) { //<S2SV> case POWERMATE_PRODUCT_NEW : //<S2SV> input_dev -> name = pm_name_powermate ; //<S2SV> break ; //<S2SV> case POWERMATE_PRODUCT_OLD : //<S2SV> input_dev -> name = pm_name_soundknob ; //<S2SV> break ; //<S2SV> default : //<S2SV> input_dev -> name = pm_name_soundknob ; //<S2SV> printk ( KERN_WARNING "powermate:<S2SV_blank>unknown<S2SV_blank>product<S2SV_blank>id<S2SV_blank>%04x\\n" , //<S2SV> le16_to_cpu ( udev -> descriptor . idProduct ) ) ; //<S2SV> } //<S2SV> input_dev -> phys = pm -> phys ; //<S2SV> usb_to_input_id ( udev , & input_dev -> id ) ; //<S2SV> input_dev -> dev . parent = & intf -> dev ; //<S2SV> input_set_drvdata ( input_dev , pm ) ; //<S2SV> input_dev -> event = powermate_input_event ; //<S2SV> input_dev -> evbit [ 0 ] = BIT_MASK ( EV_KEY ) | BIT_MASK ( EV_REL ) | //<S2SV> BIT_MASK ( EV_MSC ) ; //<S2SV> input_dev -> keybit [ BIT_WORD ( BTN_0 ) ] = BIT_MASK ( BTN_0 ) ; //<S2SV> input_dev -> relbit [ BIT_WORD ( REL_DIAL ) ] = BIT_MASK ( REL_DIAL ) ; //<S2SV> input_dev -> mscbit [ BIT_WORD ( MSC_PULSELED ) ] = BIT_MASK ( MSC_PULSELED ) ; //<S2SV> pipe = usb_rcvintpipe ( udev , endpoint -> bEndpointAddress ) ; //<S2SV> maxp = usb_maxpacket ( udev , pipe , usb_pipeout ( pipe ) ) ; //<S2SV> if ( maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX ) { //<S2SV> printk ( KERN_WARNING "powermate:<S2SV_blank>Expected<S2SV_blank>payload<S2SV_blank>of<S2SV_blank>%d--%d<S2SV_blank>bytes,<S2SV_blank>found<S2SV_blank>%d<S2SV_blank>bytes!\\n" , //<S2SV> POWERMATE_PAYLOAD_SIZE_MIN , POWERMATE_PAYLOAD_SIZE_MAX , maxp ) ; //<S2SV> maxp = POWERMATE_PAYLOAD_SIZE_MAX ; //<S2SV> } //<S2SV> usb_fill_int_urb ( pm -> irq , udev , pipe , pm -> data , //<S2SV> maxp , powermate_irq , //<S2SV> pm , endpoint -> bInterval ) ; //<S2SV> pm -> irq -> transfer_dma = pm -> data_dma ; //<S2SV> pm -> irq -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; //<S2SV> if ( usb_submit_urb ( pm -> irq , GFP_KERNEL ) ) { //<S2SV> error = - EIO ; //<S2SV> goto fail4 ; //<S2SV> } //<S2SV> error = input_register_device ( pm -> input ) ; //<S2SV> if ( error ) //<S2SV> goto fail5 ; //<S2SV> pm -> requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS ; //<S2SV> powermate_pulse_led ( pm , 0x80 , 255 , 0 , 1 , 0 ) ; //<S2SV> usb_set_intfdata ( intf , pm ) ; //<S2SV> return 0 ; //<S2SV> fail5 : usb_kill_urb ( pm -> irq ) ; //<S2SV> fail4 : usb_free_urb ( pm -> config ) ; //<S2SV> fail3 : usb_free_urb ( pm -> irq ) ; //<S2SV> fail2 : powermate_free_buffers ( udev , pm ) ; //<S2SV> fail1 : input_free_device ( input_dev ) ; //<S2SV> kfree ( pm ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 