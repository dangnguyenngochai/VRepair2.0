static int pfkey_recvmsg ( struct kiocb * kiocb , //<S2SV> struct socket * sock , struct msghdr * msg , size_t len , //<S2SV> int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct pfkey_sock * pfk = pfkey_sk ( sk ) ; //<S2SV> struct sk_buff * skb ; //<S2SV> int copied , err ; //<S2SV> err = - EINVAL ; //<S2SV> if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT ) ) //<S2SV> goto out ; //<S2SV> msg -> msg_namelen = 0 ; //<S2SV> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; //<S2SV> if ( skb == NULL ) //<S2SV> goto out ; //<S2SV> copied = skb -> len ; //<S2SV> if ( copied > len ) { //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> copied = len ; //<S2SV> } //<S2SV> skb_reset_transport_header ( skb ) ; //<S2SV> err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; //<S2SV> if ( err ) //<S2SV> goto out_free ; //<S2SV> sock_recv_ts_and_drops ( msg , sk , skb ) ; //<S2SV> err = ( flags & MSG_TRUNC ) ? skb -> len : copied ; //<S2SV> if ( pfk -> dump . dump != NULL && //<S2SV> 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) //<S2SV> pfkey_do_dump ( pfk ) ; //<S2SV> out_free : //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 