static int //<S2SV> mISDN_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len , int flags ) //<S2SV> { //<S2SV> struct sk_buff * skb ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct sockaddr_mISDN * maddr ; //<S2SV> int copied , err ; //<S2SV> if ( * debug & DEBUG_SOCKET ) //<S2SV> printk ( KERN_DEBUG "%s:<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>flags<S2SV_blank>%x<S2SV_blank>ch.nr<S2SV_blank>%d,<S2SV_blank>proto<S2SV_blank>%x\\n" , //<S2SV> __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , //<S2SV> sk -> sk_protocol ) ; //<S2SV> if ( flags & ( MSG_OOB ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> if ( sk -> sk_state == MISDN_CLOSED ) //<S2SV> return 0 ; //<S2SV> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; //<S2SV> if ( ! skb ) //<S2SV> return err ; //<S2SV> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { //<S2SV> msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; //<S2SV> maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; //<S2SV> maddr -> family = AF_ISDN ; //<S2SV> maddr -> dev = _pms ( sk ) -> dev -> id ; //<S2SV> if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) || //<S2SV> ( sk -> sk_protocol == ISDN_P_LAPD_NT ) ) { //<S2SV> maddr -> channel = ( mISDN_HEAD_ID ( skb ) >> 16 ) & 0xff ; //<S2SV> maddr -> tei = ( mISDN_HEAD_ID ( skb ) >> 8 ) & 0xff ; //<S2SV> maddr -> sapi = mISDN_HEAD_ID ( skb ) & 0xff ; //<S2SV> } else { //<S2SV> maddr -> channel = _pms ( sk ) -> ch . nr ; //<S2SV> maddr -> sapi = _pms ( sk ) -> ch . addr & 0xFF ; //<S2SV> maddr -> tei = ( _pms ( sk ) -> ch . addr >> 8 ) & 0xFF ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( msg -> msg_namelen ) //<S2SV> printk ( KERN_WARNING "%s:<S2SV_blank>too<S2SV_blank>small<S2SV_blank>namelen<S2SV_blank>%d\\n" , //<S2SV> __func__ , msg -> msg_namelen ) ; //<S2SV> msg -> msg_namelen = 0 ; //<S2SV> } //<S2SV> copied = skb -> len + MISDN_HEADER_LEN ; //<S2SV> if ( len < copied ) { //<S2SV> if ( flags & MSG_PEEK ) //<S2SV> atomic_dec ( & skb -> users ) ; //<S2SV> else //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> return - ENOSPC ; //<S2SV> } //<S2SV> memcpy ( skb_push ( skb , MISDN_HEADER_LEN ) , mISDN_HEAD_P ( skb ) , //<S2SV> MISDN_HEADER_LEN ) ; //<S2SV> err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; //<S2SV> mISDN_sock_cmsg ( sk , msg , skb ) ; //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> return err ? : copied ; //<S2SV> } //<S2SV> 