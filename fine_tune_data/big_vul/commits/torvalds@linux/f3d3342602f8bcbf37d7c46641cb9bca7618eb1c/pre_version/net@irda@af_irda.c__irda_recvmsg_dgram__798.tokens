static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t size , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct irda_sock * self = irda_sk ( sk ) ; //<S2SV> struct sk_buff * skb ; //<S2SV> size_t copied ; //<S2SV> int err ; //<S2SV> IRDA_DEBUG ( 4 , "%s()\\n" , __func__ ) ; //<S2SV> msg -> msg_namelen = 0 ; //<S2SV> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , //<S2SV> flags & MSG_DONTWAIT , & err ) ; //<S2SV> if ( ! skb ) //<S2SV> return err ; //<S2SV> skb_reset_transport_header ( skb ) ; //<S2SV> copied = skb -> len ; //<S2SV> if ( copied > size ) { //<S2SV> IRDA_DEBUG ( 2 , "%s(),<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>frame<S2SV_blank>(%zd<S2SV_blank><<S2SV_blank>%zd)!\\n" , //<S2SV> __func__ , copied , size ) ; //<S2SV> copied = size ; //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> } //<S2SV> skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> if ( self -> rx_flow == FLOW_STOP ) { //<S2SV> if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { //<S2SV> IRDA_DEBUG ( 2 , "%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\n" , __func__ ) ; //<S2SV> self -> rx_flow = FLOW_START ; //<S2SV> irttp_flow_request ( self -> tsap , FLOW_START ) ; //<S2SV> } //<S2SV> } //<S2SV> return copied ; //<S2SV> } //<S2SV> 