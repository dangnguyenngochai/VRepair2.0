int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , //<S2SV> size_t size , int msg_flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct rds_sock * rs = rds_sk_to_rs ( sk ) ; //<S2SV> long timeo ; //<S2SV> int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; //<S2SV> struct sockaddr_in * sin ; //<S2SV> struct rds_incoming * inc = NULL ; //<S2SV> timeo = sock_rcvtimeo ( sk , nonblock ) ; //<S2SV> rdsdebug ( "size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n" , size , msg_flags , timeo ) ; //<S2SV> if ( msg_flags & MSG_OOB ) //<S2SV> goto out ; //<S2SV> while ( 1 ) { //<S2SV> if ( ! list_empty ( & rs -> rs_notify_queue ) ) { //<S2SV> ret = rds_notify_queue_get ( rs , msg ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( rs -> rs_cong_notify ) { //<S2SV> ret = rds_notify_cong ( rs , msg ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! rds_next_incoming ( rs , & inc ) ) { //<S2SV> if ( nonblock ) { //<S2SV> ret = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , //<S2SV> ( ! list_empty ( & rs -> rs_notify_queue ) || //<S2SV> rs -> rs_cong_notify || //<S2SV> rds_next_incoming ( rs , & inc ) ) , timeo ) ; //<S2SV> rdsdebug ( "recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n" , inc , //<S2SV> timeo ) ; //<S2SV> if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) //<S2SV> continue ; //<S2SV> ret = timeo ; //<S2SV> if ( ret == 0 ) //<S2SV> ret = - ETIMEDOUT ; //<S2SV> break ; //<S2SV> } //<S2SV> rdsdebug ( "copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n" , inc , //<S2SV> & inc -> i_conn -> c_faddr , //<S2SV> ntohs ( inc -> i_hdr . h_sport ) ) ; //<S2SV> ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , //<S2SV> size ) ; //<S2SV> if ( ret < 0 ) //<S2SV> break ; //<S2SV> if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { //<S2SV> rds_inc_put ( inc ) ; //<S2SV> inc = NULL ; //<S2SV> rds_stats_inc ( s_recv_deliver_raced ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { //<S2SV> if ( msg_flags & MSG_TRUNC ) //<S2SV> ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> } //<S2SV> if ( rds_cmsg_recv ( inc , msg ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rds_stats_inc ( s_recv_delivered ) ; //<S2SV> sin = ( struct sockaddr_in * ) msg -> msg_name ; //<S2SV> if ( sin ) { //<S2SV> sin -> sin_family = AF_INET ; //<S2SV> sin -> sin_port = inc -> i_hdr . h_sport ; //<S2SV> sin -> sin_addr . s_addr = inc -> i_saddr ; //<S2SV> memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; //<S2SV> msg -> msg_namelen = sizeof ( * sin ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> if ( inc ) //<S2SV> rds_inc_put ( inc ) ; //<S2SV> out : //<S2SV> return ret ; //<S2SV> } //<S2SV> 