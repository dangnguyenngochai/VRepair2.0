static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len , int flags ) //<S2SV> { //<S2SV> int noblock = flags & MSG_DONTWAIT ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> unsigned int copied , rlen ; //<S2SV> struct sk_buff * skb , * cskb ; //<S2SV> int err = 0 ; //<S2SV> pr_debug ( "%p<S2SV_blank>%zu\\n" , sk , len ) ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( sk -> sk_state == LLCP_CLOSED && //<S2SV> skb_queue_empty ( & sk -> sk_receive_queue ) ) { //<S2SV> release_sock ( sk ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> if ( flags & ( MSG_OOB ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; //<S2SV> if ( ! skb ) { //<S2SV> pr_err ( "Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d" , //<S2SV> sk -> sk_state , err , sock_error ( sk ) ) ; //<S2SV> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> return 0 ; //<S2SV> return err ; //<S2SV> } //<S2SV> rlen = skb -> len ; //<S2SV> copied = min_t ( unsigned int , rlen , len ) ; //<S2SV> cskb = skb ; //<S2SV> if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { //<S2SV> if ( ! ( flags & MSG_PEEK ) ) //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> sock_recv_timestamp ( msg , sk , skb ) ; //<S2SV> if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { //<S2SV> struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; //<S2SV> struct sockaddr_nfc_llcp * sockaddr = //<S2SV> ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; //<S2SV> msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; //<S2SV> pr_debug ( "Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n" , ui_cb -> dsap , ui_cb -> ssap ) ; //<S2SV> memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; //<S2SV> sockaddr -> sa_family = AF_NFC ; //<S2SV> sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; //<S2SV> sockaddr -> dsap = ui_cb -> dsap ; //<S2SV> sockaddr -> ssap = ui_cb -> ssap ; //<S2SV> } //<S2SV> if ( ! ( flags & MSG_PEEK ) ) { //<S2SV> if ( sk -> sk_type == SOCK_STREAM || //<S2SV> sk -> sk_type == SOCK_DGRAM || //<S2SV> sk -> sk_type == SOCK_RAW ) { //<S2SV> skb_pull ( skb , copied ) ; //<S2SV> if ( skb -> len ) { //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> } //<S2SV> kfree_skb ( skb ) ; //<S2SV> } //<S2SV> done : //<S2SV> if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) //<S2SV> copied = rlen ; //<S2SV> return copied ; //<S2SV> } //<S2SV> 