static int caif_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t size , //<S2SV> int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> int copied = 0 ; //<S2SV> int target ; //<S2SV> int err = 0 ; //<S2SV> long timeo ; //<S2SV> err = - EOPNOTSUPP ; //<S2SV> if ( flags & MSG_OOB ) //<S2SV> goto out ; //<S2SV> err = - EAGAIN ; //<S2SV> if ( sk -> sk_state == CAIF_CONNECTING ) //<S2SV> goto out ; //<S2SV> caif_read_lock ( sk ) ; //<S2SV> target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; //<S2SV> timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; //<S2SV> do { //<S2SV> int chunk ; //<S2SV> struct sk_buff * skb ; //<S2SV> lock_sock ( sk ) ; //<S2SV> skb = skb_dequeue ( & sk -> sk_receive_queue ) ; //<S2SV> caif_check_flow_release ( sk ) ; //<S2SV> if ( skb == NULL ) { //<S2SV> if ( copied >= target ) //<S2SV> goto unlock ; //<S2SV> err = sock_error ( sk ) ; //<S2SV> if ( err ) //<S2SV> goto unlock ; //<S2SV> err = - ECONNRESET ; //<S2SV> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> goto unlock ; //<S2SV> err = - EPIPE ; //<S2SV> if ( sk -> sk_state != CAIF_CONNECTED ) //<S2SV> goto unlock ; //<S2SV> if ( sock_flag ( sk , SOCK_DEAD ) ) //<S2SV> goto unlock ; //<S2SV> release_sock ( sk ) ; //<S2SV> err = - EAGAIN ; //<S2SV> if ( ! timeo ) //<S2SV> break ; //<S2SV> caif_read_unlock ( sk ) ; //<S2SV> timeo = caif_stream_data_wait ( sk , timeo ) ; //<S2SV> if ( signal_pending ( current ) ) { //<S2SV> err = sock_intr_errno ( timeo ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> caif_read_lock ( sk ) ; //<S2SV> continue ; //<S2SV> unlock : //<S2SV> release_sock ( sk ) ; //<S2SV> break ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> chunk = min_t ( unsigned int , skb -> len , size ) ; //<S2SV> if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> if ( copied == 0 ) //<S2SV> copied = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> copied += chunk ; //<S2SV> size -= chunk ; //<S2SV> if ( ! ( flags & MSG_PEEK ) ) { //<S2SV> skb_pull ( skb , chunk ) ; //<S2SV> if ( skb -> len ) { //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> break ; //<S2SV> } //<S2SV> kfree_skb ( skb ) ; //<S2SV> } else { //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } while ( size ) ; //<S2SV> caif_read_unlock ( sk ) ; //<S2SV> out : //<S2SV> return copied ? : err ; //<S2SV> } //<S2SV> 