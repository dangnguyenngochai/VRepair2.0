static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct sk_buff * skb ; //<S2SV> int copied , err ; //<S2SV> int vnet_hdr_len = 0 ; //<S2SV> err = - EINVAL ; //<S2SV> if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) //<S2SV> goto out ; //<S2SV> # if 0 //<S2SV> if ( pkt_sk ( sk ) -> ifindex < 0 ) //<S2SV> return - ENODEV ; //<S2SV> # endif //<S2SV> if ( flags & MSG_ERRQUEUE ) { //<S2SV> err = sock_recv_errqueue ( sk , msg , len , //<S2SV> SOL_PACKET , PACKET_TX_TIMESTAMP ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; //<S2SV> if ( skb == NULL ) //<S2SV> goto out ; //<S2SV> if ( pkt_sk ( sk ) -> has_vnet_hdr ) { //<S2SV> struct virtio_net_hdr vnet_hdr = { 0 } ; //<S2SV> err = - EINVAL ; //<S2SV> vnet_hdr_len = sizeof ( vnet_hdr ) ; //<S2SV> if ( len < vnet_hdr_len ) //<S2SV> goto out_free ; //<S2SV> len -= vnet_hdr_len ; //<S2SV> if ( skb_is_gso ( skb ) ) { //<S2SV> struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; //<S2SV> vnet_hdr . hdr_len = skb_headlen ( skb ) ; //<S2SV> vnet_hdr . gso_size = sinfo -> gso_size ; //<S2SV> if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) //<S2SV> vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; //<S2SV> else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) //<S2SV> vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; //<S2SV> else if ( sinfo -> gso_type & SKB_GSO_UDP ) //<S2SV> vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; //<S2SV> else if ( sinfo -> gso_type & SKB_GSO_FCOE ) //<S2SV> goto out_free ; //<S2SV> else //<S2SV> BUG ( ) ; //<S2SV> if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) //<S2SV> vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; //<S2SV> } else //<S2SV> vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; //<S2SV> if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { //<S2SV> vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; //<S2SV> vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; //<S2SV> vnet_hdr . csum_offset = skb -> csum_offset ; //<S2SV> } else if ( skb -> ip_summed == CHECKSUM_UNNECESSARY ) { //<S2SV> vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID ; //<S2SV> } //<S2SV> err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , //<S2SV> vnet_hdr_len ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out_free ; //<S2SV> } //<S2SV> copied = skb -> len ; //<S2SV> if ( copied > len ) { //<S2SV> copied = len ; //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> } //<S2SV> err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; //<S2SV> if ( err ) //<S2SV> goto out_free ; //<S2SV> sock_recv_ts_and_drops ( msg , sk , skb ) ; //<S2SV> if ( msg -> msg_name ) { //<S2SV> if ( sock -> type == SOCK_PACKET ) { //<S2SV> msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; //<S2SV> } else { //<S2SV> struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; //<S2SV> msg -> msg_namelen = sll -> sll_halen + //<S2SV> offsetof ( struct sockaddr_ll , sll_addr ) ; //<S2SV> } //<S2SV> memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , //<S2SV> msg -> msg_namelen ) ; //<S2SV> } //<S2SV> if ( pkt_sk ( sk ) -> auxdata ) { //<S2SV> struct tpacket_auxdata aux ; //<S2SV> aux . tp_status = TP_STATUS_USER ; //<S2SV> if ( skb -> ip_summed == CHECKSUM_PARTIAL ) //<S2SV> aux . tp_status |= TP_STATUS_CSUMNOTREADY ; //<S2SV> aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; //<S2SV> aux . tp_snaplen = skb -> len ; //<S2SV> aux . tp_mac = 0 ; //<S2SV> aux . tp_net = skb_network_offset ( skb ) ; //<S2SV> if ( vlan_tx_tag_present ( skb ) ) { //<S2SV> aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; //<S2SV> aux . tp_status |= TP_STATUS_VLAN_VALID ; //<S2SV> } else { //<S2SV> aux . tp_vlan_tci = 0 ; //<S2SV> } //<S2SV> aux . tp_padding = 0 ; //<S2SV> put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; //<S2SV> } //<S2SV> err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; //<S2SV> out_free : //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 