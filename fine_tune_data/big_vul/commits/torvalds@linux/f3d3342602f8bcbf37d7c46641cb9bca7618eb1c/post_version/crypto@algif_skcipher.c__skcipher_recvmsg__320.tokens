static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , //<S2SV> struct msghdr * msg , size_t ignored , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct alg_sock * ask = alg_sk ( sk ) ; //<S2SV> struct skcipher_ctx * ctx = ask -> private ; //<S2SV> unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( //<S2SV> & ctx -> req ) ) ; //<S2SV> struct skcipher_sg_list * sgl ; //<S2SV> struct scatterlist * sg ; //<S2SV> unsigned long iovlen ; //<S2SV> struct iovec * iov ; //<S2SV> int err = - EAGAIN ; //<S2SV> int used ; //<S2SV> long copied = 0 ; //<S2SV> lock_sock ( sk ) ; //<S2SV> for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; //<S2SV> iovlen -- , iov ++ ) { //<S2SV> unsigned long seglen = iov -> iov_len ; //<S2SV> char __user * from = iov -> iov_base ; //<S2SV> while ( seglen ) { //<S2SV> sgl = list_first_entry ( & ctx -> tsgl , //<S2SV> struct skcipher_sg_list , list ) ; //<S2SV> sg = sgl -> sg ; //<S2SV> while ( ! sg -> length ) //<S2SV> sg ++ ; //<S2SV> used = ctx -> used ; //<S2SV> if ( ! used ) { //<S2SV> err = skcipher_wait_for_data ( sk , flags ) ; //<S2SV> if ( err ) //<S2SV> goto unlock ; //<S2SV> } //<S2SV> used = min_t ( unsigned long , used , seglen ) ; //<S2SV> used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; //<S2SV> err = used ; //<S2SV> if ( err < 0 ) //<S2SV> goto unlock ; //<S2SV> if ( ctx -> more || used < ctx -> used ) //<S2SV> used -= used % bs ; //<S2SV> err = - EINVAL ; //<S2SV> if ( ! used ) //<S2SV> goto free ; //<S2SV> ablkcipher_request_set_crypt ( & ctx -> req , sg , //<S2SV> ctx -> rsgl . sg , used , //<S2SV> ctx -> iv ) ; //<S2SV> err = af_alg_wait_for_completion ( //<S2SV> ctx -> enc ? //<S2SV> crypto_ablkcipher_encrypt ( & ctx -> req ) : //<S2SV> crypto_ablkcipher_decrypt ( & ctx -> req ) , //<S2SV> & ctx -> completion ) ; //<S2SV> free : //<S2SV> af_alg_free_sg ( & ctx -> rsgl ) ; //<S2SV> if ( err ) //<S2SV> goto unlock ; //<S2SV> copied += used ; //<S2SV> from += used ; //<S2SV> seglen -= used ; //<S2SV> skcipher_pull_sgl ( sk , used ) ; //<S2SV> } //<S2SV> } //<S2SV> err = 0 ; //<S2SV> unlock : //<S2SV> skcipher_wmem_wakeup ( sk ) ; //<S2SV> release_sock ( sk ) ; //<S2SV> return copied ? : err ; //<S2SV> } //<S2SV> 