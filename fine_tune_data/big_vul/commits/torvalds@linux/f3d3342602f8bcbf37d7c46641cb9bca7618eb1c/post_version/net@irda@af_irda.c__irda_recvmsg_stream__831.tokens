static int irda_recvmsg_stream ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t size , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct irda_sock * self = irda_sk ( sk ) ; //<S2SV> int noblock = flags & MSG_DONTWAIT ; //<S2SV> size_t copied = 0 ; //<S2SV> int target , err ; //<S2SV> long timeo ; //<S2SV> IRDA_DEBUG ( 3 , "%s()\\n" , __func__ ) ; //<S2SV> if ( ( err = sock_error ( sk ) ) < 0 ) //<S2SV> return err ; //<S2SV> if ( sock -> flags & __SO_ACCEPTCON ) //<S2SV> return - EINVAL ; //<S2SV> err = - EOPNOTSUPP ; //<S2SV> if ( flags & MSG_OOB ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> err = 0 ; //<S2SV> target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; //<S2SV> timeo = sock_rcvtimeo ( sk , noblock ) ; //<S2SV> do { //<S2SV> int chunk ; //<S2SV> struct sk_buff * skb = skb_dequeue ( & sk -> sk_receive_queue ) ; //<S2SV> if ( skb == NULL ) { //<S2SV> DEFINE_WAIT ( wait ) ; //<S2SV> err = 0 ; //<S2SV> if ( copied >= target ) //<S2SV> break ; //<S2SV> prepare_to_wait_exclusive ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; //<S2SV> err = sock_error ( sk ) ; //<S2SV> if ( err ) //<S2SV> ; //<S2SV> else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> ; //<S2SV> else if ( noblock ) //<S2SV> err = - EAGAIN ; //<S2SV> else if ( signal_pending ( current ) ) //<S2SV> err = sock_intr_errno ( timeo ) ; //<S2SV> else if ( sk -> sk_state != TCP_ESTABLISHED ) //<S2SV> err = - ENOTCONN ; //<S2SV> else if ( skb_peek ( & sk -> sk_receive_queue ) == NULL ) //<S2SV> schedule ( ) ; //<S2SV> finish_wait ( sk_sleep ( sk ) , & wait ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> break ; //<S2SV> continue ; //<S2SV> } //<S2SV> chunk = min_t ( unsigned int , skb -> len , size ) ; //<S2SV> if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> if ( copied == 0 ) //<S2SV> copied = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> copied += chunk ; //<S2SV> size -= chunk ; //<S2SV> if ( ! ( flags & MSG_PEEK ) ) { //<S2SV> skb_pull ( skb , chunk ) ; //<S2SV> if ( skb -> len ) { //<S2SV> IRDA_DEBUG ( 1 , "%s(),<S2SV_blank>back<S2SV_blank>on<S2SV_blank>q!\\n" , //<S2SV> __func__ ) ; //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> break ; //<S2SV> } //<S2SV> kfree_skb ( skb ) ; //<S2SV> } else { //<S2SV> IRDA_DEBUG ( 0 , "%s()<S2SV_blank>questionable!?\\n" , __func__ ) ; //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } while ( size ) ; //<S2SV> if ( self -> rx_flow == FLOW_STOP ) { //<S2SV> if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { //<S2SV> IRDA_DEBUG ( 2 , "%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\n" , __func__ ) ; //<S2SV> self -> rx_flow = FLOW_START ; //<S2SV> irttp_flow_request ( self -> tsap , FLOW_START ) ; //<S2SV> } //<S2SV> } //<S2SV> return copied ; //<S2SV> } //<S2SV> 