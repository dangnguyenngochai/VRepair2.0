static int netlink_recvmsg ( struct kiocb * kiocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len , //<S2SV> int flags ) //<S2SV> { //<S2SV> struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; //<S2SV> struct scm_cookie scm ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct netlink_sock * nlk = nlk_sk ( sk ) ; //<S2SV> int noblock = flags & MSG_DONTWAIT ; //<S2SV> size_t copied ; //<S2SV> struct sk_buff * skb , * data_skb ; //<S2SV> int err , ret ; //<S2SV> if ( flags & MSG_OOB ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> copied = 0 ; //<S2SV> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; //<S2SV> if ( skb == NULL ) //<S2SV> goto out ; //<S2SV> data_skb = skb ; //<S2SV> # ifdef CONFIG_COMPAT_NETLINK_MESSAGES //<S2SV> if ( unlikely ( skb_shinfo ( skb ) -> frag_list ) ) { //<S2SV> if ( flags & MSG_CMSG_COMPAT ) //<S2SV> data_skb = skb_shinfo ( skb ) -> frag_list ; //<S2SV> } //<S2SV> # endif //<S2SV> copied = data_skb -> len ; //<S2SV> if ( len < copied ) { //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> copied = len ; //<S2SV> } //<S2SV> skb_reset_transport_header ( data_skb ) ; //<S2SV> err = skb_copy_datagram_iovec ( data_skb , 0 , msg -> msg_iov , copied ) ; //<S2SV> if ( msg -> msg_name ) { //<S2SV> struct sockaddr_nl * addr = ( struct sockaddr_nl * ) msg -> msg_name ; //<S2SV> addr -> nl_family = AF_NETLINK ; //<S2SV> addr -> nl_pad = 0 ; //<S2SV> addr -> nl_pid = NETLINK_CB ( skb ) . portid ; //<S2SV> addr -> nl_groups = netlink_group_mask ( NETLINK_CB ( skb ) . dst_group ) ; //<S2SV> msg -> msg_namelen = sizeof ( * addr ) ; //<S2SV> } //<S2SV> if ( nlk -> flags & NETLINK_RECV_PKTINFO ) //<S2SV> netlink_cmsg_recv_pktinfo ( msg , skb ) ; //<S2SV> if ( NULL == siocb -> scm ) { //<S2SV> memset ( & scm , 0 , sizeof ( scm ) ) ; //<S2SV> siocb -> scm = & scm ; //<S2SV> } //<S2SV> siocb -> scm -> creds = * NETLINK_CREDS ( skb ) ; //<S2SV> if ( flags & MSG_TRUNC ) //<S2SV> copied = data_skb -> len ; //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> if ( nlk -> cb_running && //<S2SV> atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf / 2 ) { //<S2SV> ret = netlink_dump ( sk ) ; //<S2SV> if ( ret ) { //<S2SV> sk -> sk_err = ret ; //<S2SV> sk -> sk_error_report ( sk ) ; //<S2SV> } //<S2SV> } //<S2SV> scm_recv ( sock , msg , siocb -> scm , flags ) ; //<S2SV> out : //<S2SV> netlink_rcv_wake ( sk ) ; //<S2SV> return err ? : copied ; //<S2SV> } //<S2SV> 