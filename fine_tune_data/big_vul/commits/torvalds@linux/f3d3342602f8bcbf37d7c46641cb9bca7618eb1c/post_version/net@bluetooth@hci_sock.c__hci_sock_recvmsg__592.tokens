static int hci_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len , int flags ) //<S2SV> { //<S2SV> int noblock = flags & MSG_DONTWAIT ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct sk_buff * skb ; //<S2SV> int copied , err ; //<S2SV> BT_DBG ( "sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p" , sock , sk ) ; //<S2SV> if ( flags & ( MSG_OOB ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> if ( sk -> sk_state == BT_CLOSED ) //<S2SV> return 0 ; //<S2SV> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; //<S2SV> if ( ! skb ) //<S2SV> return err ; //<S2SV> copied = skb -> len ; //<S2SV> if ( len < copied ) { //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> copied = len ; //<S2SV> } //<S2SV> skb_reset_transport_header ( skb ) ; //<S2SV> err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; //<S2SV> switch ( hci_pi ( sk ) -> channel ) { //<S2SV> case HCI_CHANNEL_RAW : //<S2SV> hci_sock_cmsg ( sk , msg , skb ) ; //<S2SV> break ; //<S2SV> case HCI_CHANNEL_USER : //<S2SV> case HCI_CHANNEL_CONTROL : //<S2SV> case HCI_CHANNEL_MONITOR : //<S2SV> sock_recv_timestamp ( msg , sk , skb ) ; //<S2SV> break ; //<S2SV> } //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> return err ? : copied ; //<S2SV> } //<S2SV> 