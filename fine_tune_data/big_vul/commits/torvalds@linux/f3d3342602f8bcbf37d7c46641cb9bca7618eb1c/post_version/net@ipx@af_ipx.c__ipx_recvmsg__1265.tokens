static int ipx_recvmsg ( struct kiocb * iocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t size , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct ipx_sock * ipxs = ipx_sk ( sk ) ; //<S2SV> struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; //<S2SV> struct ipxhdr * ipx = NULL ; //<S2SV> struct sk_buff * skb ; //<S2SV> int copied , rc ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( ! ipxs -> port ) { //<S2SV> struct sockaddr_ipx uaddr ; //<S2SV> uaddr . sipx_port = 0 ; //<S2SV> uaddr . sipx_network = 0 ; //<S2SV> # ifdef CONFIG_IPX_INTERN //<S2SV> rc = - ENETDOWN ; //<S2SV> if ( ! ipxs -> intrfc ) //<S2SV> goto out ; //<S2SV> memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ) ; //<S2SV> # endif //<S2SV> rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , //<S2SV> sizeof ( struct sockaddr_ipx ) ) ; //<S2SV> if ( rc ) //<S2SV> goto out ; //<S2SV> } //<S2SV> rc = - ENOTCONN ; //<S2SV> if ( sock_flag ( sk , SOCK_ZAPPED ) ) //<S2SV> goto out ; //<S2SV> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , //<S2SV> flags & MSG_DONTWAIT , & rc ) ; //<S2SV> if ( ! skb ) //<S2SV> goto out ; //<S2SV> ipx = ipx_hdr ( skb ) ; //<S2SV> copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ) ; //<S2SV> if ( copied > size ) { //<S2SV> copied = size ; //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> } //<S2SV> rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , //<S2SV> copied ) ; //<S2SV> if ( rc ) //<S2SV> goto out_free ; //<S2SV> if ( skb -> tstamp . tv64 ) //<S2SV> sk -> sk_stamp = skb -> tstamp ; //<S2SV> if ( sipx ) { //<S2SV> sipx -> sipx_family = AF_IPX ; //<S2SV> sipx -> sipx_port = ipx -> ipx_source . sock ; //<S2SV> memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; //<S2SV> sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; //<S2SV> sipx -> sipx_type = ipx -> ipx_type ; //<S2SV> sipx -> sipx_zero = 0 ; //<S2SV> msg -> msg_namelen = sizeof ( * sipx ) ; //<S2SV> } //<S2SV> rc = copied ; //<S2SV> out_free : //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> out : //<S2SV> release_sock ( sk ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 