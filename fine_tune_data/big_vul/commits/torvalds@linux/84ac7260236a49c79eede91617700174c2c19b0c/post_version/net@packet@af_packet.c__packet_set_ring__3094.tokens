static int packet_set_ring ( struct sock * sk , union tpacket_req_u * req_u , //<S2SV> int closing , int tx_ring ) //<S2SV> { //<S2SV> struct pgv * pg_vec = NULL ; //<S2SV> struct packet_sock * po = pkt_sk ( sk ) ; //<S2SV> int was_running , order = 0 ; //<S2SV> struct packet_ring_buffer * rb ; //<S2SV> struct sk_buff_head * rb_queue ; //<S2SV> __be16 num ; //<S2SV> int err = - EINVAL ; //<S2SV> struct tpacket_req * req = & req_u -> req ; //<S2SV> lock_sock ( sk ) ; //<S2SV> if ( ! closing && tx_ring && ( po -> tp_version > TPACKET_V2 ) ) { //<S2SV> net_warn_ratelimited ( "Tx-ring<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported.\\n" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rb = tx_ring ? & po -> tx_ring : & po -> rx_ring ; //<S2SV> rb_queue = tx_ring ? & sk -> sk_write_queue : & sk -> sk_receive_queue ; //<S2SV> err = - EBUSY ; //<S2SV> if ( ! closing ) { //<S2SV> if ( atomic_read ( & po -> mapped ) ) //<S2SV> goto out ; //<S2SV> if ( packet_read_pending ( rb ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( req -> tp_block_nr ) { //<S2SV> err = - EBUSY ; //<S2SV> if ( unlikely ( rb -> pg_vec ) ) //<S2SV> goto out ; //<S2SV> switch ( po -> tp_version ) { //<S2SV> case TPACKET_V1 : //<S2SV> po -> tp_hdrlen = TPACKET_HDRLEN ; //<S2SV> break ; //<S2SV> case TPACKET_V2 : //<S2SV> po -> tp_hdrlen = TPACKET2_HDRLEN ; //<S2SV> break ; //<S2SV> case TPACKET_V3 : //<S2SV> po -> tp_hdrlen = TPACKET3_HDRLEN ; //<S2SV> break ; //<S2SV> } //<S2SV> err = - EINVAL ; //<S2SV> if ( unlikely ( ( int ) req -> tp_block_size <= 0 ) ) //<S2SV> goto out ; //<S2SV> if ( unlikely ( ! PAGE_ALIGNED ( req -> tp_block_size ) ) ) //<S2SV> goto out ; //<S2SV> if ( po -> tp_version >= TPACKET_V3 && //<S2SV> ( int ) ( req -> tp_block_size - //<S2SV> BLK_PLUS_PRIV ( req_u -> req3 . tp_sizeof_priv ) ) <= 0 ) //<S2SV> goto out ; //<S2SV> if ( unlikely ( req -> tp_frame_size < po -> tp_hdrlen + //<S2SV> po -> tp_reserve ) ) //<S2SV> goto out ; //<S2SV> if ( unlikely ( req -> tp_frame_size & ( TPACKET_ALIGNMENT - 1 ) ) ) //<S2SV> goto out ; //<S2SV> rb -> frames_per_block = req -> tp_block_size / req -> tp_frame_size ; //<S2SV> if ( unlikely ( rb -> frames_per_block == 0 ) ) //<S2SV> goto out ; //<S2SV> if ( unlikely ( ( rb -> frames_per_block * req -> tp_block_nr ) != //<S2SV> req -> tp_frame_nr ) ) //<S2SV> goto out ; //<S2SV> err = - ENOMEM ; //<S2SV> order = get_order ( req -> tp_block_size ) ; //<S2SV> pg_vec = alloc_pg_vec ( req , order ) ; //<S2SV> if ( unlikely ( ! pg_vec ) ) //<S2SV> goto out ; //<S2SV> switch ( po -> tp_version ) { //<S2SV> case TPACKET_V3 : //<S2SV> if ( ! tx_ring ) //<S2SV> init_prb_bdqc ( po , rb , pg_vec , req_u ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> err = - EINVAL ; //<S2SV> if ( unlikely ( req -> tp_frame_nr ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> spin_lock ( & po -> bind_lock ) ; //<S2SV> was_running = po -> running ; //<S2SV> num = po -> num ; //<S2SV> if ( was_running ) { //<S2SV> po -> num = 0 ; //<S2SV> __unregister_prot_hook ( sk , false ) ; //<S2SV> } //<S2SV> spin_unlock ( & po -> bind_lock ) ; //<S2SV> synchronize_net ( ) ; //<S2SV> err = - EBUSY ; //<S2SV> mutex_lock ( & po -> pg_vec_lock ) ; //<S2SV> if ( closing || atomic_read ( & po -> mapped ) == 0 ) { //<S2SV> err = 0 ; //<S2SV> spin_lock_bh ( & rb_queue -> lock ) ; //<S2SV> swap ( rb -> pg_vec , pg_vec ) ; //<S2SV> rb -> frame_max = ( req -> tp_frame_nr - 1 ) ; //<S2SV> rb -> head = 0 ; //<S2SV> rb -> frame_size = req -> tp_frame_size ; //<S2SV> spin_unlock_bh ( & rb_queue -> lock ) ; //<S2SV> swap ( rb -> pg_vec_order , order ) ; //<S2SV> swap ( rb -> pg_vec_len , req -> tp_block_nr ) ; //<S2SV> rb -> pg_vec_pages = req -> tp_block_size / PAGE_SIZE ; //<S2SV> po -> prot_hook . func = ( po -> rx_ring . pg_vec ) ? //<S2SV> tpacket_rcv : packet_rcv ; //<S2SV> skb_queue_purge ( rb_queue ) ; //<S2SV> if ( atomic_read ( & po -> mapped ) ) //<S2SV> pr_err ( "packet_mmap:<S2SV_blank>vma<S2SV_blank>is<S2SV_blank>busy:<S2SV_blank>%d\\n" , //<S2SV> atomic_read ( & po -> mapped ) ) ; //<S2SV> } //<S2SV> mutex_unlock ( & po -> pg_vec_lock ) ; //<S2SV> spin_lock ( & po -> bind_lock ) ; //<S2SV> if ( was_running ) { //<S2SV> po -> num = num ; //<S2SV> register_prot_hook ( sk ) ; //<S2SV> } //<S2SV> spin_unlock ( & po -> bind_lock ) ; //<S2SV> if ( closing && ( po -> tp_version > TPACKET_V2 ) ) { //<S2SV> if ( ! tx_ring ) //<S2SV> prb_shutdown_retire_blk_timer ( po , rb_queue ) ; //<S2SV> } //<S2SV> if ( pg_vec ) //<S2SV> free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; //<S2SV> out : //<S2SV> release_sock ( sk ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 