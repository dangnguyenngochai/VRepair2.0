static void //<S2SV> kvp_respond_to_host ( char * key , char * value , int error ) //<S2SV> { //<S2SV> struct hv_kvp_msg * kvp_msg ; //<S2SV> struct hv_kvp_msg_enumerate * kvp_data ; //<S2SV> char * key_name ; //<S2SV> struct icmsg_hdr * icmsghdrp ; //<S2SV> int keylen , valuelen ; //<S2SV> u32 buf_len ; //<S2SV> struct vmbus_channel * channel ; //<S2SV> u64 req_id ; //<S2SV> if ( ! kvp_transaction . active ) { //<S2SV> pr_warn ( "KVP:<S2SV_blank>Transaction<S2SV_blank>not<S2SV_blank>active\\n" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> buf_len = kvp_transaction . recv_len ; //<S2SV> channel = kvp_transaction . recv_channel ; //<S2SV> req_id = kvp_transaction . recv_req_id ; //<S2SV> kvp_transaction . active = false ; //<S2SV> if ( channel -> onchannel_callback == NULL ) //<S2SV> return ; //<S2SV> icmsghdrp = ( struct icmsg_hdr * ) //<S2SV> & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; //<S2SV> kvp_msg = ( struct hv_kvp_msg * ) //<S2SV> & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + //<S2SV> sizeof ( struct icmsg_hdr ) ] ; //<S2SV> kvp_data = & kvp_msg -> kvp_data ; //<S2SV> key_name = key ; //<S2SV> if ( error ) { //<S2SV> icmsghdrp -> status = HV_E_FAIL ; //<S2SV> goto response_done ; //<S2SV> } //<S2SV> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , //<S2SV> ( wchar_t * ) kvp_data -> data . key ) ; //<S2SV> kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; //<S2SV> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , //<S2SV> ( wchar_t * ) kvp_data -> data . value ) ; //<S2SV> kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; //<S2SV> kvp_data -> data . value_type = REG_SZ ; //<S2SV> icmsghdrp -> status = HV_S_OK ; //<S2SV> response_done : //<S2SV> icmsghdrp -> icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE ; //<S2SV> vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , //<S2SV> VM_PKT_DATA_INBAND , 0 ) ; //<S2SV> } //<S2SV> 