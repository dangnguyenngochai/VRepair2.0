int btrfs_truncate_inode_items ( struct btrfs_trans_handle * trans , //<S2SV> struct btrfs_root * root , //<S2SV> struct inode * inode , //<S2SV> u64 new_size , u32 min_type ) //<S2SV> { //<S2SV> struct btrfs_path * path ; //<S2SV> struct extent_buffer * leaf ; //<S2SV> struct btrfs_file_extent_item * fi ; //<S2SV> struct btrfs_key key ; //<S2SV> struct btrfs_key found_key ; //<S2SV> u64 extent_start = 0 ; //<S2SV> u64 extent_num_bytes = 0 ; //<S2SV> u64 extent_offset = 0 ; //<S2SV> u64 item_end = 0 ; //<S2SV> u64 last_size = new_size ; //<S2SV> u32 found_type = ( u8 ) - 1 ; //<S2SV> int found_extent ; //<S2SV> int del_item ; //<S2SV> int pending_del_nr = 0 ; //<S2SV> int pending_del_slot = 0 ; //<S2SV> int extent_type = - 1 ; //<S2SV> int ret ; //<S2SV> int err = 0 ; //<S2SV> u64 ino = btrfs_ino ( inode ) ; //<S2SV> u64 bytes_deleted = 0 ; //<S2SV> bool be_nice = 0 ; //<S2SV> bool should_throttle = 0 ; //<S2SV> bool should_end = 0 ; //<S2SV> BUG_ON ( new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY ) ; //<S2SV> if ( ! btrfs_is_free_space_inode ( inode ) && //<S2SV> test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) //<S2SV> be_nice = 1 ; //<S2SV> path = btrfs_alloc_path ( ) ; //<S2SV> if ( ! path ) //<S2SV> return - ENOMEM ; //<S2SV> path -> reada = - 1 ; //<S2SV> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || //<S2SV> root == root -> fs_info -> tree_root ) //<S2SV> btrfs_drop_extent_cache ( inode , ALIGN ( new_size , //<S2SV> root -> sectorsize ) , ( u64 ) - 1 , 0 ) ; //<S2SV> if ( min_type == 0 && root == BTRFS_I ( inode ) -> root ) //<S2SV> btrfs_kill_delayed_inode_items ( inode ) ; //<S2SV> key . objectid = ino ; //<S2SV> key . offset = ( u64 ) - 1 ; //<S2SV> key . type = ( u8 ) - 1 ; //<S2SV> search_again : //<S2SV> if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { //<S2SV> if ( btrfs_should_end_transaction ( trans , root ) ) { //<S2SV> err = - EAGAIN ; //<S2SV> goto error ; //<S2SV> } //<S2SV> } //<S2SV> path -> leave_spinning = 1 ; //<S2SV> ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> err = ret ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ret > 0 ) { //<S2SV> if ( path -> slots [ 0 ] == 0 ) //<S2SV> goto out ; //<S2SV> path -> slots [ 0 ] -- ; //<S2SV> } //<S2SV> while ( 1 ) { //<S2SV> fi = NULL ; //<S2SV> leaf = path -> nodes [ 0 ] ; //<S2SV> btrfs_item_key_to_cpu ( leaf , & found_key , path -> slots [ 0 ] ) ; //<S2SV> found_type = found_key . type ; //<S2SV> if ( found_key . objectid != ino ) //<S2SV> break ; //<S2SV> if ( found_type < min_type ) //<S2SV> break ; //<S2SV> item_end = found_key . offset ; //<S2SV> if ( found_type == BTRFS_EXTENT_DATA_KEY ) { //<S2SV> fi = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , //<S2SV> struct btrfs_file_extent_item ) ; //<S2SV> extent_type = btrfs_file_extent_type ( leaf , fi ) ; //<S2SV> if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { //<S2SV> item_end += //<S2SV> btrfs_file_extent_num_bytes ( leaf , fi ) ; //<S2SV> } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { //<S2SV> item_end += btrfs_file_extent_inline_len ( leaf , //<S2SV> path -> slots [ 0 ] , fi ) ; //<S2SV> } //<S2SV> item_end -- ; //<S2SV> } //<S2SV> if ( found_type > min_type ) { //<S2SV> del_item = 1 ; //<S2SV> } else { //<S2SV> if ( item_end < new_size ) //<S2SV> break ; //<S2SV> if ( found_key . offset >= new_size ) //<S2SV> del_item = 1 ; //<S2SV> else //<S2SV> del_item = 0 ; //<S2SV> } //<S2SV> found_extent = 0 ; //<S2SV> if ( found_type != BTRFS_EXTENT_DATA_KEY ) //<S2SV> goto delete ; //<S2SV> if ( del_item ) //<S2SV> last_size = found_key . offset ; //<S2SV> else //<S2SV> last_size = new_size ; //<S2SV> if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { //<S2SV> u64 num_dec ; //<S2SV> extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ; //<S2SV> if ( ! del_item ) { //<S2SV> u64 orig_num_bytes = //<S2SV> btrfs_file_extent_num_bytes ( leaf , fi ) ; //<S2SV> extent_num_bytes = ALIGN ( new_size - //<S2SV> found_key . offset , //<S2SV> root -> sectorsize ) ; //<S2SV> btrfs_set_file_extent_num_bytes ( leaf , fi , //<S2SV> extent_num_bytes ) ; //<S2SV> num_dec = ( orig_num_bytes - //<S2SV> extent_num_bytes ) ; //<S2SV> if ( test_bit ( BTRFS_ROOT_REF_COWS , //<S2SV> & root -> state ) && //<S2SV> extent_start != 0 ) //<S2SV> inode_sub_bytes ( inode , num_dec ) ; //<S2SV> btrfs_mark_buffer_dirty ( leaf ) ; //<S2SV> } else { //<S2SV> extent_num_bytes = //<S2SV> btrfs_file_extent_disk_num_bytes ( leaf , //<S2SV> fi ) ; //<S2SV> extent_offset = found_key . offset - //<S2SV> btrfs_file_extent_offset ( leaf , fi ) ; //<S2SV> num_dec = btrfs_file_extent_num_bytes ( leaf , fi ) ; //<S2SV> if ( extent_start != 0 ) { //<S2SV> found_extent = 1 ; //<S2SV> if ( test_bit ( BTRFS_ROOT_REF_COWS , //<S2SV> & root -> state ) ) //<S2SV> inode_sub_bytes ( inode , num_dec ) ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { //<S2SV> if ( ! del_item && //<S2SV> btrfs_file_extent_compression ( leaf , fi ) == 0 && //<S2SV> btrfs_file_extent_encryption ( leaf , fi ) == 0 && //<S2SV> btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { //<S2SV> u32 size = new_size - found_key . offset ; //<S2SV> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) //<S2SV> inode_sub_bytes ( inode , item_end + 1 - //<S2SV> new_size ) ; //<S2SV> btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ; //<S2SV> size = //<S2SV> btrfs_file_extent_calc_inline_size ( size ) ; //<S2SV> btrfs_truncate_item ( root , path , size , 1 ) ; //<S2SV> } else if ( test_bit ( BTRFS_ROOT_REF_COWS , //<S2SV> & root -> state ) ) { //<S2SV> inode_sub_bytes ( inode , item_end + 1 - //<S2SV> found_key . offset ) ; //<S2SV> } //<S2SV> } //<S2SV> delete : //<S2SV> if ( del_item ) { //<S2SV> if ( ! pending_del_nr ) { //<S2SV> pending_del_slot = path -> slots [ 0 ] ; //<S2SV> pending_del_nr = 1 ; //<S2SV> } else if ( pending_del_nr && //<S2SV> path -> slots [ 0 ] + 1 == pending_del_slot ) { //<S2SV> pending_del_nr ++ ; //<S2SV> pending_del_slot = path -> slots [ 0 ] ; //<S2SV> } else { //<S2SV> BUG ( ) ; //<S2SV> } //<S2SV> } else { //<S2SV> break ; //<S2SV> } //<S2SV> should_throttle = 0 ; //<S2SV> if ( found_extent && //<S2SV> ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || //<S2SV> root == root -> fs_info -> tree_root ) ) { //<S2SV> btrfs_set_path_blocking ( path ) ; //<S2SV> bytes_deleted += extent_num_bytes ; //<S2SV> ret = btrfs_free_extent ( trans , root , extent_start , //<S2SV> extent_num_bytes , 0 , //<S2SV> btrfs_header_owner ( leaf ) , //<S2SV> ino , extent_offset , 0 ) ; //<S2SV> BUG_ON ( ret ) ; //<S2SV> if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) //<S2SV> btrfs_async_run_delayed_refs ( root , //<S2SV> trans -> delayed_ref_updates * 2 , 0 ) ; //<S2SV> if ( be_nice ) { //<S2SV> if ( truncate_space_check ( trans , root , //<S2SV> extent_num_bytes ) ) { //<S2SV> should_end = 1 ; //<S2SV> } //<S2SV> if ( btrfs_should_throttle_delayed_refs ( trans , //<S2SV> root ) ) { //<S2SV> should_throttle = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( found_type == BTRFS_INODE_ITEM_KEY ) //<S2SV> break ; //<S2SV> if ( path -> slots [ 0 ] == 0 || //<S2SV> path -> slots [ 0 ] != pending_del_slot || //<S2SV> should_throttle || should_end ) { //<S2SV> if ( pending_del_nr ) { //<S2SV> ret = btrfs_del_items ( trans , root , path , //<S2SV> pending_del_slot , //<S2SV> pending_del_nr ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , //<S2SV> root , ret ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> pending_del_nr = 0 ; //<S2SV> } //<S2SV> btrfs_release_path ( path ) ; //<S2SV> if ( should_throttle ) { //<S2SV> unsigned long updates = trans -> delayed_ref_updates ; //<S2SV> if ( updates ) { //<S2SV> trans -> delayed_ref_updates = 0 ; //<S2SV> ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; //<S2SV> if ( ret && ! err ) //<S2SV> err = ret ; //<S2SV> } //<S2SV> } //<S2SV> if ( should_end ) { //<S2SV> err = - EAGAIN ; //<S2SV> goto error ; //<S2SV> } //<S2SV> goto search_again ; //<S2SV> } else { //<S2SV> path -> slots [ 0 ] -- ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> if ( pending_del_nr ) { //<S2SV> ret = btrfs_del_items ( trans , root , path , pending_del_slot , //<S2SV> pending_del_nr ) ; //<S2SV> if ( ret ) //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> } //<S2SV> error : //<S2SV> if ( root -> root_key . objectid != BTRFS_TREE_LOG_OBJECTID ) //<S2SV> btrfs_ordered_update_i_size ( inode , last_size , NULL ) ; //<S2SV> btrfs_free_path ( path ) ; //<S2SV> if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { //<S2SV> unsigned long updates = trans -> delayed_ref_updates ; //<S2SV> if ( updates ) { //<S2SV> trans -> delayed_ref_updates = 0 ; //<S2SV> ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; //<S2SV> if ( ret && ! err ) //<S2SV> err = ret ; //<S2SV> } //<S2SV> } //<S2SV> return err ; //<S2SV> } //<S2SV> 