static int do_check ( struct bpf_verifier_env * env ) //<S2SV> { //<S2SV> struct bpf_verifier_state * state = & env -> cur_state ; //<S2SV> struct bpf_insn * insns = env -> prog -> insnsi ; //<S2SV> struct bpf_reg_state * regs = state -> regs ; //<S2SV> int insn_cnt = env -> prog -> len ; //<S2SV> int insn_idx , prev_insn_idx = 0 ; //<S2SV> int insn_processed = 0 ; //<S2SV> bool do_print_state = false ; //<S2SV> init_reg_state ( regs ) ; //<S2SV> insn_idx = 0 ; //<S2SV> env -> varlen_map_value_access = false ; //<S2SV> for ( ; ; ) { //<S2SV> struct bpf_insn * insn ; //<S2SV> u8 class ; //<S2SV> int err ; //<S2SV> if ( insn_idx >= insn_cnt ) { //<S2SV> verbose ( "invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n" , //<S2SV> insn_idx , insn_cnt ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> insn = & insns [ insn_idx ] ; //<S2SV> class = BPF_CLASS ( insn -> code ) ; //<S2SV> if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { //<S2SV> verbose ( "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n" , //<S2SV> insn_processed ) ; //<S2SV> return - E2BIG ; //<S2SV> } //<S2SV> err = is_state_visited ( env , insn_idx ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( err == 1 ) { //<S2SV> if ( log_level ) { //<S2SV> if ( do_print_state ) //<S2SV> verbose ( "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n" , //<S2SV> prev_insn_idx , insn_idx ) ; //<S2SV> else //<S2SV> verbose ( "%d:<S2SV_blank>safe\\n" , insn_idx ) ; //<S2SV> } //<S2SV> goto process_bpf_exit ; //<S2SV> } //<S2SV> if ( log_level && do_print_state ) { //<S2SV> verbose ( "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:" , prev_insn_idx , insn_idx ) ; //<S2SV> print_verifier_state ( & env -> cur_state ) ; //<S2SV> do_print_state = false ; //<S2SV> } //<S2SV> if ( log_level ) { //<S2SV> verbose ( "%d:<S2SV_blank>" , insn_idx ) ; //<S2SV> print_bpf_insn ( insn ) ; //<S2SV> } //<S2SV> err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( class == BPF_ALU || class == BPF_ALU64 ) { //<S2SV> err = check_alu_op ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( class == BPF_LDX ) { //<S2SV> enum bpf_reg_type * prev_src_type , src_reg_type ; //<S2SV> err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_reg_arg ( regs , insn -> dst_reg , DST_OP_NO_MARK ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> src_reg_type = regs [ insn -> src_reg ] . type ; //<S2SV> err = check_mem_access ( env , insn -> src_reg , insn -> off , //<S2SV> BPF_SIZE ( insn -> code ) , BPF_READ , //<S2SV> insn -> dst_reg ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( BPF_SIZE ( insn -> code ) != BPF_W && //<S2SV> BPF_SIZE ( insn -> code ) != BPF_DW ) { //<S2SV> insn_idx ++ ; //<S2SV> continue ; //<S2SV> } //<S2SV> prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; //<S2SV> if ( * prev_src_type == NOT_INIT ) { //<S2SV> * prev_src_type = src_reg_type ; //<S2SV> } else if ( src_reg_type != * prev_src_type && //<S2SV> ( src_reg_type == PTR_TO_CTX || //<S2SV> * prev_src_type == PTR_TO_CTX ) ) { //<S2SV> verbose ( "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else if ( class == BPF_STX ) { //<S2SV> enum bpf_reg_type * prev_dst_type , dst_reg_type ; //<S2SV> if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { //<S2SV> err = check_xadd ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> insn_idx ++ ; //<S2SV> continue ; //<S2SV> } //<S2SV> err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> dst_reg_type = regs [ insn -> dst_reg ] . type ; //<S2SV> err = check_mem_access ( env , insn -> dst_reg , insn -> off , //<S2SV> BPF_SIZE ( insn -> code ) , BPF_WRITE , //<S2SV> insn -> src_reg ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; //<S2SV> if ( * prev_dst_type == NOT_INIT ) { //<S2SV> * prev_dst_type = dst_reg_type ; //<S2SV> } else if ( dst_reg_type != * prev_dst_type && //<S2SV> ( dst_reg_type == PTR_TO_CTX || //<S2SV> * prev_dst_type == PTR_TO_CTX ) ) { //<S2SV> verbose ( "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else if ( class == BPF_ST ) { //<S2SV> if ( BPF_MODE ( insn -> code ) != BPF_MEM || //<S2SV> insn -> src_reg != BPF_REG_0 ) { //<S2SV> verbose ( "BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_mem_access ( env , insn -> dst_reg , insn -> off , //<S2SV> BPF_SIZE ( insn -> code ) , BPF_WRITE , //<S2SV> - 1 ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( class == BPF_JMP ) { //<S2SV> u8 opcode = BPF_OP ( insn -> code ) ; //<S2SV> if ( opcode == BPF_CALL ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> off != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( "BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_call ( env , insn -> imm , insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( opcode == BPF_JA ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> imm != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( "BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> insn_idx += insn -> off + 1 ; //<S2SV> continue ; //<S2SV> } else if ( opcode == BPF_EXIT ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> imm != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( "BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_reg_arg ( regs , BPF_REG_0 , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( is_pointer_value ( env , BPF_REG_0 ) ) { //<S2SV> verbose ( "R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> process_bpf_exit : //<S2SV> insn_idx = pop_stack ( env , & prev_insn_idx ) ; //<S2SV> if ( insn_idx < 0 ) { //<S2SV> break ; //<S2SV> } else { //<S2SV> do_print_state = true ; //<S2SV> continue ; //<S2SV> } //<S2SV> } else { //<S2SV> err = check_cond_jmp_op ( env , insn , & insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } //<S2SV> } else if ( class == BPF_LD ) { //<S2SV> u8 mode = BPF_MODE ( insn -> code ) ; //<S2SV> if ( mode == BPF_ABS || mode == BPF_IND ) { //<S2SV> err = check_ld_abs ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( mode == BPF_IMM ) { //<S2SV> err = check_ld_imm ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> insn_idx ++ ; //<S2SV> } else { //<S2SV> verbose ( "invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> reset_reg_range_values ( regs , insn -> dst_reg ) ; //<S2SV> } else { //<S2SV> verbose ( "unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n" , class ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> insn_idx ++ ; //<S2SV> } //<S2SV> verbose ( "processed<S2SV_blank>%d<S2SV_blank>insns\\n" , insn_processed ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 