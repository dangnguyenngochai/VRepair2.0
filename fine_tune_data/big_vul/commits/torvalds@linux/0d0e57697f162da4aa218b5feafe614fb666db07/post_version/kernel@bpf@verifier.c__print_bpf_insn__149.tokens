static void print_bpf_insn ( const struct bpf_verifier_env * env , //<S2SV> const struct bpf_insn * insn ) //<S2SV> { //<S2SV> u8 class = BPF_CLASS ( insn -> code ) ; //<S2SV> if ( class == BPF_ALU || class == BPF_ALU64 ) { //<S2SV> if ( BPF_SRC ( insn -> code ) == BPF_X ) //<S2SV> verbose ( "(%02x)<S2SV_blank>%sr%d<S2SV_blank>%s<S2SV_blank>%sr%d\\n" , //<S2SV> insn -> code , class == BPF_ALU ? "(u32)<S2SV_blank>" : "" , //<S2SV> insn -> dst_reg , //<S2SV> bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , //<S2SV> class == BPF_ALU ? "(u32)<S2SV_blank>" : "" , //<S2SV> insn -> src_reg ) ; //<S2SV> else //<S2SV> verbose ( "(%02x)<S2SV_blank>%sr%d<S2SV_blank>%s<S2SV_blank>%s%d\\n" , //<S2SV> insn -> code , class == BPF_ALU ? "(u32)<S2SV_blank>" : "" , //<S2SV> insn -> dst_reg , //<S2SV> bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , //<S2SV> class == BPF_ALU ? "(u32)<S2SV_blank>" : "" , //<S2SV> insn -> imm ) ; //<S2SV> } else if ( class == BPF_STX ) { //<S2SV> if ( BPF_MODE ( insn -> code ) == BPF_MEM ) //<S2SV> verbose ( "(%02x)<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>=<S2SV_blank>r%d\\n" , //<S2SV> insn -> code , //<S2SV> bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , //<S2SV> insn -> dst_reg , //<S2SV> insn -> off , insn -> src_reg ) ; //<S2SV> else if ( BPF_MODE ( insn -> code ) == BPF_XADD ) //<S2SV> verbose ( "(%02x)<S2SV_blank>lock<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>+=<S2SV_blank>r%d\\n" , //<S2SV> insn -> code , //<S2SV> bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , //<S2SV> insn -> dst_reg , insn -> off , //<S2SV> insn -> src_reg ) ; //<S2SV> else //<S2SV> verbose ( "BUG_%02x\\n" , insn -> code ) ; //<S2SV> } else if ( class == BPF_ST ) { //<S2SV> if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { //<S2SV> verbose ( "BUG_st_%02x\\n" , insn -> code ) ; //<S2SV> return ; //<S2SV> } //<S2SV> verbose ( "(%02x)<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)<S2SV_blank>=<S2SV_blank>%d\\n" , //<S2SV> insn -> code , //<S2SV> bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , //<S2SV> insn -> dst_reg , //<S2SV> insn -> off , insn -> imm ) ; //<S2SV> } else if ( class == BPF_LDX ) { //<S2SV> if ( BPF_MODE ( insn -> code ) != BPF_MEM ) { //<S2SV> verbose ( "BUG_ldx_%02x\\n" , insn -> code ) ; //<S2SV> return ; //<S2SV> } //<S2SV> verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)(r%d<S2SV_blank>%+d)\\n" , //<S2SV> insn -> code , insn -> dst_reg , //<S2SV> bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , //<S2SV> insn -> src_reg , insn -> off ) ; //<S2SV> } else if ( class == BPF_LD ) { //<S2SV> if ( BPF_MODE ( insn -> code ) == BPF_ABS ) { //<S2SV> verbose ( "(%02x)<S2SV_blank>r0<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)skb[%d]\\n" , //<S2SV> insn -> code , //<S2SV> bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , //<S2SV> insn -> imm ) ; //<S2SV> } else if ( BPF_MODE ( insn -> code ) == BPF_IND ) { //<S2SV> verbose ( "(%02x)<S2SV_blank>r0<S2SV_blank>=<S2SV_blank>*(%s<S2SV_blank>*)skb[r%d<S2SV_blank>+<S2SV_blank>%d]\\n" , //<S2SV> insn -> code , //<S2SV> bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , //<S2SV> insn -> src_reg , insn -> imm ) ; //<S2SV> } else if ( BPF_MODE ( insn -> code ) == BPF_IMM && //<S2SV> BPF_SIZE ( insn -> code ) == BPF_DW ) { //<S2SV> u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; //<S2SV> bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; //<S2SV> if ( map_ptr && ! env -> allow_ptr_leaks ) //<S2SV> imm = 0 ; //<S2SV> verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n" , insn -> code , //<S2SV> insn -> dst_reg , ( unsigned long long ) imm ) ; //<S2SV> } else { //<S2SV> verbose ( "BUG_ld_%02x\\n" , insn -> code ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } else if ( class == BPF_JMP ) { //<S2SV> u8 opcode = BPF_OP ( insn -> code ) ; //<S2SV> if ( opcode == BPF_CALL ) { //<S2SV> verbose ( "(%02x)<S2SV_blank>call<S2SV_blank>%s#%d\\n" , insn -> code , //<S2SV> func_id_name ( insn -> imm ) , insn -> imm ) ; //<S2SV> } else if ( insn -> code == ( BPF_JMP | BPF_JA ) ) { //<S2SV> verbose ( "(%02x)<S2SV_blank>goto<S2SV_blank>pc%+d\\n" , //<S2SV> insn -> code , insn -> off ) ; //<S2SV> } else if ( insn -> code == ( BPF_JMP | BPF_EXIT ) ) { //<S2SV> verbose ( "(%02x)<S2SV_blank>exit\\n" , insn -> code ) ; //<S2SV> } else if ( BPF_SRC ( insn -> code ) == BPF_X ) { //<S2SV> verbose ( "(%02x)<S2SV_blank>if<S2SV_blank>r%d<S2SV_blank>%s<S2SV_blank>r%d<S2SV_blank>goto<S2SV_blank>pc%+d\\n" , //<S2SV> insn -> code , insn -> dst_reg , //<S2SV> bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , //<S2SV> insn -> src_reg , insn -> off ) ; //<S2SV> } else { //<S2SV> verbose ( "(%02x)<S2SV_blank>if<S2SV_blank>r%d<S2SV_blank>%s<S2SV_blank>0x%x<S2SV_blank>goto<S2SV_blank>pc%+d\\n" , //<S2SV> insn -> code , insn -> dst_reg , //<S2SV> bpf_jmp_string [ BPF_OP ( insn -> code ) >> 4 ] , //<S2SV> insn -> imm , insn -> off ) ; //<S2SV> } //<S2SV> } else { //<S2SV> verbose ( "(%02x)<S2SV_blank>%s\\n" , insn -> code , bpf_class_string [ class ] ) ; //<S2SV> } //<S2SV> } //<S2SV> 