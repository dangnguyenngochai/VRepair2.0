static int sanitize_ptr_alu ( struct bpf_verifier_env * env , //<S2SV> struct bpf_insn * insn , //<S2SV> const struct bpf_reg_state * ptr_reg , //<S2SV> struct bpf_reg_state * dst_reg , //<S2SV> bool off_is_neg ) //<S2SV> { //<S2SV> struct bpf_verifier_state * vstate = env -> cur_state ; //<S2SV> struct bpf_insn_aux_data * aux = cur_aux ( env ) ; //<S2SV> bool ptr_is_dst_reg = ptr_reg == dst_reg ; //<S2SV> u8 opcode = BPF_OP ( insn -> code ) ; //<S2SV> u32 alu_state , alu_limit ; //<S2SV> struct bpf_reg_state tmp ; //<S2SV> bool ret ; //<S2SV> if ( env -> allow_ptr_leaks || BPF_SRC ( insn -> code ) == BPF_K ) //<S2SV> return 0 ; //<S2SV> if ( vstate -> speculative ) //<S2SV> goto do_sim ; //<S2SV> alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; //<S2SV> alu_state |= ptr_is_dst_reg ? //<S2SV> BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST ; //<S2SV> if ( retrieve_ptr_limit ( ptr_reg , & alu_limit , opcode , off_is_neg ) ) //<S2SV> return 0 ; //<S2SV> if ( aux -> alu_state && //<S2SV> ( aux -> alu_state != alu_state || //<S2SV> aux -> alu_limit != alu_limit ) ) //<S2SV> return - EACCES ; //<S2SV> aux -> alu_state = alu_state ; //<S2SV> aux -> alu_limit = alu_limit ; //<S2SV> do_sim : //<S2SV> if ( ! ptr_is_dst_reg ) { //<S2SV> tmp = * dst_reg ; //<S2SV> * dst_reg = * ptr_reg ; //<S2SV> } //<S2SV> ret = push_stack ( env , env -> insn_idx + 1 , env -> insn_idx , true ) ; //<S2SV> if ( ! ptr_is_dst_reg ) //<S2SV> * dst_reg = tmp ; //<S2SV> return ! ret ? - EFAULT : 0 ; //<S2SV> } //<S2SV> 