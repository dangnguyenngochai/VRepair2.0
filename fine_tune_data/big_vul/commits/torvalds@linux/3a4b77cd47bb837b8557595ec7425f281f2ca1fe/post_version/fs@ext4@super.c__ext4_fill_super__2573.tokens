static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) //<S2SV> { //<S2SV> char * orig_data = kstrdup ( data , GFP_KERNEL ) ; //<S2SV> struct buffer_head * bh ; //<S2SV> struct ext4_super_block * es = NULL ; //<S2SV> struct ext4_sb_info * sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; //<S2SV> ext4_fsblk_t block ; //<S2SV> ext4_fsblk_t sb_block = get_sb_block ( & data ) ; //<S2SV> ext4_fsblk_t logical_sb_block ; //<S2SV> unsigned long offset = 0 ; //<S2SV> unsigned long journal_devnum = 0 ; //<S2SV> unsigned long def_mount_opts ; //<S2SV> struct inode * root ; //<S2SV> const char * descr ; //<S2SV> int ret = - ENOMEM ; //<S2SV> int blocksize , clustersize ; //<S2SV> unsigned int db_count ; //<S2SV> unsigned int i ; //<S2SV> int needs_recovery , has_huge_files , has_bigalloc ; //<S2SV> __u64 blocks_count ; //<S2SV> int err = 0 ; //<S2SV> unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; //<S2SV> ext4_group_t first_not_zeroed ; //<S2SV> if ( ( data && ! orig_data ) || ! sbi ) //<S2SV> goto out_free_base ; //<S2SV> sbi -> s_blockgroup_lock = //<S2SV> kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; //<S2SV> if ( ! sbi -> s_blockgroup_lock ) //<S2SV> goto out_free_base ; //<S2SV> sb -> s_fs_info = sbi ; //<S2SV> sbi -> s_sb = sb ; //<S2SV> sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; //<S2SV> sbi -> s_sb_block = sb_block ; //<S2SV> if ( sb -> s_bdev -> bd_part ) //<S2SV> sbi -> s_sectors_written_start = //<S2SV> part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; //<S2SV> strreplace ( sb -> s_id , '/' , '!' ) ; //<S2SV> ret = - EINVAL ; //<S2SV> blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; //<S2SV> if ( ! blocksize ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize" ) ; //<S2SV> goto out_fail ; //<S2SV> } //<S2SV> if ( blocksize != EXT4_MIN_BLOCK_SIZE ) { //<S2SV> logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; //<S2SV> offset = do_div ( logical_sb_block , blocksize ) ; //<S2SV> } else { //<S2SV> logical_sb_block = sb_block ; //<S2SV> } //<S2SV> if ( ! ( bh = sb_bread_unmovable ( sb , logical_sb_block ) ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock" ) ; //<S2SV> goto out_fail ; //<S2SV> } //<S2SV> es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; //<S2SV> sbi -> s_es = es ; //<S2SV> sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; //<S2SV> if ( sb -> s_magic != EXT4_SUPER_MAGIC ) //<S2SV> goto cantfind_ext4 ; //<S2SV> sbi -> s_kbytes_written = le64_to_cpu ( es -> s_kbytes_written ) ; //<S2SV> if ( ext4_has_feature_metadata_csum ( sb ) && //<S2SV> ext4_has_feature_gdt_csum ( sb ) ) //<S2SV> ext4_warning ( sb , "metadata_csum<S2SV_blank>and<S2SV_blank>uninit_bg<S2SV_blank>are<S2SV_blank>" //<S2SV> "redundant<S2SV_blank>flags;<S2SV_blank>please<S2SV_blank>run<S2SV_blank>fsck." ) ; //<S2SV> if ( ! ext4_verify_csum_type ( sb , es ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>" //<S2SV> "unknown<S2SV_blank>checksum<S2SV_blank>algorithm." ) ; //<S2SV> silent = 1 ; //<S2SV> goto cantfind_ext4 ; //<S2SV> } //<S2SV> if ( ext4_has_feature_metadata_csum ( sb ) ) { //<S2SV> sbi -> s_chksum_driver = crypto_alloc_shash ( "crc32c" , 0 , 0 ) ; //<S2SV> if ( IS_ERR ( sbi -> s_chksum_driver ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "Cannot<S2SV_blank>load<S2SV_blank>crc32c<S2SV_blank>driver." ) ; //<S2SV> ret = PTR_ERR ( sbi -> s_chksum_driver ) ; //<S2SV> sbi -> s_chksum_driver = NULL ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ext4_superblock_csum_verify ( sb , es ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>" //<S2SV> "invalid<S2SV_blank>superblock<S2SV_blank>checksum.<S2SV_blank><S2SV_blank>Run<S2SV_blank>e2fsck?" ) ; //<S2SV> silent = 1 ; //<S2SV> ret = - EFSBADCRC ; //<S2SV> goto cantfind_ext4 ; //<S2SV> } //<S2SV> if ( ext4_has_feature_csum_seed ( sb ) ) //<S2SV> sbi -> s_csum_seed = le32_to_cpu ( es -> s_checksum_seed ) ; //<S2SV> else if ( ext4_has_metadata_csum ( sb ) ) //<S2SV> sbi -> s_csum_seed = ext4_chksum ( sbi , ~ 0 , es -> s_uuid , //<S2SV> sizeof ( es -> s_uuid ) ) ; //<S2SV> def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; //<S2SV> set_opt ( sb , INIT_INODE_TABLE ) ; //<S2SV> if ( def_mount_opts & EXT4_DEFM_DEBUG ) //<S2SV> set_opt ( sb , DEBUG ) ; //<S2SV> if ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) //<S2SV> set_opt ( sb , GRPID ) ; //<S2SV> if ( def_mount_opts & EXT4_DEFM_UID16 ) //<S2SV> set_opt ( sb , NO_UID32 ) ; //<S2SV> set_opt ( sb , XATTR_USER ) ; //<S2SV> # ifdef CONFIG_EXT4_FS_POSIX_ACL //<S2SV> set_opt ( sb , POSIX_ACL ) ; //<S2SV> # endif //<S2SV> if ( ext4_has_metadata_csum ( sb ) ) //<S2SV> set_opt ( sb , JOURNAL_CHECKSUM ) ; //<S2SV> if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_DATA ) //<S2SV> set_opt ( sb , JOURNAL_DATA ) ; //<S2SV> else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_ORDERED ) //<S2SV> set_opt ( sb , ORDERED_DATA ) ; //<S2SV> else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_WBACK ) //<S2SV> set_opt ( sb , WRITEBACK_DATA ) ; //<S2SV> if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_PANIC ) //<S2SV> set_opt ( sb , ERRORS_PANIC ) ; //<S2SV> else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_CONTINUE ) //<S2SV> set_opt ( sb , ERRORS_CONT ) ; //<S2SV> else //<S2SV> set_opt ( sb , ERRORS_RO ) ; //<S2SV> set_opt ( sb , BLOCK_VALIDITY ) ; //<S2SV> if ( def_mount_opts & EXT4_DEFM_DISCARD ) //<S2SV> set_opt ( sb , DISCARD ) ; //<S2SV> sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; //<S2SV> sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; //<S2SV> sbi -> s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ; //<S2SV> sbi -> s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME ; //<S2SV> sbi -> s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME ; //<S2SV> if ( ( def_mount_opts & EXT4_DEFM_NOBARRIER ) == 0 ) //<S2SV> set_opt ( sb , BARRIER ) ; //<S2SV> if ( ! IS_EXT3_SB ( sb ) && ! IS_EXT2_SB ( sb ) && //<S2SV> ( ( def_mount_opts & EXT4_DEFM_NODELALLOC ) == 0 ) ) //<S2SV> set_opt ( sb , DELALLOC ) ; //<S2SV> sbi -> s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT ; //<S2SV> if ( sbi -> s_es -> s_mount_opts [ 0 ] ) { //<S2SV> char * s_mount_opts = kstrndup ( sbi -> s_es -> s_mount_opts , //<S2SV> sizeof ( sbi -> s_es -> s_mount_opts ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! s_mount_opts ) //<S2SV> goto failed_mount ; //<S2SV> if ( ! parse_options ( s_mount_opts , sb , & journal_devnum , //<S2SV> & journal_ioprio , 0 ) ) { //<S2SV> ext4_msg ( sb , KERN_WARNING , //<S2SV> "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>options<S2SV_blank>in<S2SV_blank>superblock:<S2SV_blank>%s" , //<S2SV> s_mount_opts ) ; //<S2SV> } //<S2SV> kfree ( s_mount_opts ) ; //<S2SV> } //<S2SV> sbi -> s_def_mount_opt = sbi -> s_mount_opt ; //<S2SV> if ( ! parse_options ( ( char * ) data , sb , & journal_devnum , //<S2SV> & journal_ioprio , 0 ) ) //<S2SV> goto failed_mount ; //<S2SV> if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) { //<S2SV> printk_once ( KERN_WARNING "EXT4-fs:<S2SV_blank>Warning:<S2SV_blank>mounting<S2SV_blank>" //<S2SV> "with<S2SV_blank>data=journal<S2SV_blank>disables<S2SV_blank>delayed<S2SV_blank>" //<S2SV> "allocation<S2SV_blank>and<S2SV_blank>O_DIRECT<S2SV_blank>support!\\n" ) ; //<S2SV> if ( test_opt2 ( sb , EXPLICIT_DELALLOC ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>" //<S2SV> "both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>delalloc" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>" //<S2SV> "both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dioread_nolock" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( test_opt ( sb , DAX ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>" //<S2SV> "both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dax" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( test_opt ( sb , DELALLOC ) ) //<S2SV> clear_opt ( sb , DELALLOC ) ; //<S2SV> } else { //<S2SV> sb -> s_iflags |= SB_I_CGROUPWB ; //<S2SV> } //<S2SV> sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | //<S2SV> ( test_opt ( sb , POSIX_ACL ) ? MS_POSIXACL : 0 ) ; //<S2SV> if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV && //<S2SV> ( ext4_has_compat_features ( sb ) || //<S2SV> ext4_has_ro_compat_features ( sb ) || //<S2SV> ext4_has_incompat_features ( sb ) ) ) //<S2SV> ext4_msg ( sb , KERN_WARNING , //<S2SV> "feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>" //<S2SV> "running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended" ) ; //<S2SV> if ( es -> s_creator_os == cpu_to_le32 ( EXT4_OS_HURD ) ) { //<S2SV> set_opt2 ( sb , HURD_COMPAT ) ; //<S2SV> if ( ext4_has_feature_64bit ( sb ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "The<S2SV_blank>Hurd<S2SV_blank>can\'t<S2SV_blank>support<S2SV_blank>64-bit<S2SV_blank>file<S2SV_blank>systems" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> if ( IS_EXT2_SB ( sb ) ) { //<S2SV> if ( ext2_feature_set_ok ( sb ) ) //<S2SV> ext4_msg ( sb , KERN_INFO , "mounting<S2SV_blank>ext2<S2SV_blank>file<S2SV_blank>system<S2SV_blank>" //<S2SV> "using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem" ) ; //<S2SV> else { //<S2SV> ext4_msg ( sb , KERN_ERR , "couldn\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext2<S2SV_blank>due<S2SV_blank>" //<S2SV> "to<S2SV_blank>feature<S2SV_blank>incompatibilities" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> if ( IS_EXT3_SB ( sb ) ) { //<S2SV> if ( ext3_feature_set_ok ( sb ) ) //<S2SV> ext4_msg ( sb , KERN_INFO , "mounting<S2SV_blank>ext3<S2SV_blank>file<S2SV_blank>system<S2SV_blank>" //<S2SV> "using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem" ) ; //<S2SV> else { //<S2SV> ext4_msg ( sb , KERN_ERR , "couldn\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext3<S2SV_blank>due<S2SV_blank>" //<S2SV> "to<S2SV_blank>feature<S2SV_blank>incompatibilities" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ext4_feature_set_ok ( sb , ( sb -> s_flags & MS_RDONLY ) ) ) //<S2SV> goto failed_mount ; //<S2SV> blocksize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_block_size ) ; //<S2SV> if ( blocksize < EXT4_MIN_BLOCK_SIZE || //<S2SV> blocksize > EXT4_MAX_BLOCK_SIZE ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "Unsupported<S2SV_blank>filesystem<S2SV_blank>blocksize<S2SV_blank>%d<S2SV_blank>(%d<S2SV_blank>log_block_size)" , //<S2SV> blocksize , le32_to_cpu ( es -> s_log_block_size ) ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( le32_to_cpu ( es -> s_log_block_size ) > //<S2SV> ( EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "Invalid<S2SV_blank>log<S2SV_blank>block<S2SV_blank>size:<S2SV_blank>%u" , //<S2SV> le32_to_cpu ( es -> s_log_block_size ) ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) > ( blocksize / 4 ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "Number<S2SV_blank>of<S2SV_blank>reserved<S2SV_blank>GDT<S2SV_blank>blocks<S2SV_blank>insanely<S2SV_blank>large:<S2SV_blank>%d" , //<S2SV> le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( sbi -> s_mount_opt & EXT4_MOUNT_DAX ) { //<S2SV> err = bdev_dax_supported ( sb , blocksize ) ; //<S2SV> if ( err ) //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( ext4_has_feature_encrypt ( sb ) && es -> s_encryption_level ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "Unsupported<S2SV_blank>encryption<S2SV_blank>level<S2SV_blank>%d" , //<S2SV> es -> s_encryption_level ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( sb -> s_blocksize != blocksize ) { //<S2SV> if ( ! sb_set_blocksize ( sb , blocksize ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "bad<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%d" , //<S2SV> blocksize ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> brelse ( bh ) ; //<S2SV> logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; //<S2SV> offset = do_div ( logical_sb_block , blocksize ) ; //<S2SV> bh = sb_bread_unmovable ( sb , logical_sb_block ) ; //<S2SV> if ( ! bh ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "Can\'t<S2SV_blank>read<S2SV_blank>superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; //<S2SV> sbi -> s_es = es ; //<S2SV> if ( es -> s_magic != cpu_to_le16 ( EXT4_SUPER_MAGIC ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "Magic<S2SV_blank>mismatch,<S2SV_blank>very<S2SV_blank>weird!" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> has_huge_files = ext4_has_feature_huge_file ( sb ) ; //<S2SV> sbi -> s_bitmap_maxbytes = ext4_max_bitmap_size ( sb -> s_blocksize_bits , //<S2SV> has_huge_files ) ; //<S2SV> sb -> s_maxbytes = ext4_max_size ( sb -> s_blocksize_bits , has_huge_files ) ; //<S2SV> if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV ) { //<S2SV> sbi -> s_inode_size = EXT4_GOOD_OLD_INODE_SIZE ; //<S2SV> sbi -> s_first_ino = EXT4_GOOD_OLD_FIRST_INO ; //<S2SV> } else { //<S2SV> sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; //<S2SV> sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; //<S2SV> if ( ( sbi -> s_inode_size < EXT4_GOOD_OLD_INODE_SIZE ) || //<S2SV> ( ! is_power_of_2 ( sbi -> s_inode_size ) ) || //<S2SV> ( sbi -> s_inode_size > blocksize ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d" , //<S2SV> sbi -> s_inode_size ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) //<S2SV> sb -> s_time_gran = 1 << ( EXT4_EPOCH_BITS - 2 ) ; //<S2SV> } //<S2SV> sbi -> s_desc_size = le16_to_cpu ( es -> s_desc_size ) ; //<S2SV> if ( ext4_has_feature_64bit ( sb ) ) { //<S2SV> if ( sbi -> s_desc_size < EXT4_MIN_DESC_SIZE_64BIT || //<S2SV> sbi -> s_desc_size > EXT4_MAX_DESC_SIZE || //<S2SV> ! is_power_of_2 ( sbi -> s_desc_size ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "unsupported<S2SV_blank>descriptor<S2SV_blank>size<S2SV_blank>%lu" , //<S2SV> sbi -> s_desc_size ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } else //<S2SV> sbi -> s_desc_size = EXT4_MIN_DESC_SIZE ; //<S2SV> sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; //<S2SV> sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; //<S2SV> sbi -> s_inodes_per_block = blocksize / EXT4_INODE_SIZE ( sb ) ; //<S2SV> if ( sbi -> s_inodes_per_block == 0 ) //<S2SV> goto cantfind_ext4 ; //<S2SV> if ( sbi -> s_inodes_per_group < sbi -> s_inodes_per_block || //<S2SV> sbi -> s_inodes_per_group > blocksize * 8 ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "invalid<S2SV_blank>inodes<S2SV_blank>per<S2SV_blank>group:<S2SV_blank>%lu\\n" , //<S2SV> sbi -> s_blocks_per_group ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> sbi -> s_itb_per_group = sbi -> s_inodes_per_group / //<S2SV> sbi -> s_inodes_per_block ; //<S2SV> sbi -> s_desc_per_block = blocksize / EXT4_DESC_SIZE ( sb ) ; //<S2SV> sbi -> s_sbh = bh ; //<S2SV> sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; //<S2SV> sbi -> s_addr_per_block_bits = ilog2 ( EXT4_ADDR_PER_BLOCK ( sb ) ) ; //<S2SV> sbi -> s_desc_per_block_bits = ilog2 ( EXT4_DESC_PER_BLOCK ( sb ) ) ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> sbi -> s_hash_seed [ i ] = le32_to_cpu ( es -> s_hash_seed [ i ] ) ; //<S2SV> sbi -> s_def_hash_version = es -> s_def_hash_version ; //<S2SV> if ( ext4_has_feature_dir_index ( sb ) ) { //<S2SV> i = le32_to_cpu ( es -> s_flags ) ; //<S2SV> if ( i & EXT2_FLAGS_UNSIGNED_HASH ) //<S2SV> sbi -> s_hash_unsigned = 3 ; //<S2SV> else if ( ( i & EXT2_FLAGS_SIGNED_HASH ) == 0 ) { //<S2SV> # ifdef __CHAR_UNSIGNED__ //<S2SV> if ( ! ( sb -> s_flags & MS_RDONLY ) ) //<S2SV> es -> s_flags |= //<S2SV> cpu_to_le32 ( EXT2_FLAGS_UNSIGNED_HASH ) ; //<S2SV> sbi -> s_hash_unsigned = 3 ; //<S2SV> # else //<S2SV> if ( ! ( sb -> s_flags & MS_RDONLY ) ) //<S2SV> es -> s_flags |= //<S2SV> cpu_to_le32 ( EXT2_FLAGS_SIGNED_HASH ) ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> clustersize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_cluster_size ) ; //<S2SV> has_bigalloc = ext4_has_feature_bigalloc ( sb ) ; //<S2SV> if ( has_bigalloc ) { //<S2SV> if ( clustersize < blocksize ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>" //<S2SV> "block<S2SV_blank>size<S2SV_blank>(%d)" , clustersize , blocksize ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( le32_to_cpu ( es -> s_log_cluster_size ) > //<S2SV> ( EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "Invalid<S2SV_blank>log<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>%u" , //<S2SV> le32_to_cpu ( es -> s_log_cluster_size ) ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> sbi -> s_cluster_bits = le32_to_cpu ( es -> s_log_cluster_size ) - //<S2SV> le32_to_cpu ( es -> s_log_block_size ) ; //<S2SV> sbi -> s_clusters_per_group = //<S2SV> le32_to_cpu ( es -> s_clusters_per_group ) ; //<S2SV> if ( sbi -> s_clusters_per_group > blocksize * 8 ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "#clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu" , //<S2SV> sbi -> s_clusters_per_group ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( sbi -> s_blocks_per_group != //<S2SV> ( sbi -> s_clusters_per_group * ( clustersize / blocksize ) ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>and<S2SV_blank>" //<S2SV> "clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>inconsistent" , //<S2SV> sbi -> s_blocks_per_group , //<S2SV> sbi -> s_clusters_per_group ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( clustersize != blocksize ) { //<S2SV> ext4_warning ( sb , "fragment/cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>!=<S2SV_blank>" //<S2SV> "block<S2SV_blank>size<S2SV_blank>(%d)" , clustersize , //<S2SV> blocksize ) ; //<S2SV> clustersize = blocksize ; //<S2SV> } //<S2SV> if ( sbi -> s_blocks_per_group > blocksize * 8 ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu" , //<S2SV> sbi -> s_blocks_per_group ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> sbi -> s_clusters_per_group = sbi -> s_blocks_per_group ; //<S2SV> sbi -> s_cluster_bits = 0 ; //<S2SV> } //<S2SV> sbi -> s_cluster_ratio = clustersize / blocksize ; //<S2SV> if ( sbi -> s_blocks_per_group == clustersize << 3 ) //<S2SV> set_opt2 ( sb , STD_GROUP_SIZE ) ; //<S2SV> err = generic_check_addressable ( sb -> s_blocksize_bits , //<S2SV> ext4_blocks_count ( es ) ) ; //<S2SV> if ( err ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "filesystem" //<S2SV> "<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>safely<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system" ) ; //<S2SV> if ( sizeof ( sector_t ) < 8 ) //<S2SV> ext4_msg ( sb , KERN_WARNING , "CONFIG_LBDAF<S2SV_blank>not<S2SV_blank>enabled" ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( EXT4_BLOCKS_PER_GROUP ( sb ) == 0 ) //<S2SV> goto cantfind_ext4 ; //<S2SV> blocks_count = sb -> s_bdev -> bd_inode -> i_size >> sb -> s_blocksize_bits ; //<S2SV> if ( blocks_count && ext4_blocks_count ( es ) > blocks_count ) { //<S2SV> ext4_msg ( sb , KERN_WARNING , "bad<S2SV_blank>geometry:<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%llu<S2SV_blank>" //<S2SV> "exceeds<S2SV_blank>size<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(%llu<S2SV_blank>blocks)" , //<S2SV> ext4_blocks_count ( es ) , blocks_count ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> if ( le32_to_cpu ( es -> s_first_data_block ) >= ext4_blocks_count ( es ) ) { //<S2SV> ext4_msg ( sb , KERN_WARNING , "bad<S2SV_blank>geometry:<S2SV_blank>first<S2SV_blank>data<S2SV_blank>" //<S2SV> "block<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>filesystem<S2SV_blank>(%llu)" , //<S2SV> le32_to_cpu ( es -> s_first_data_block ) , //<S2SV> ext4_blocks_count ( es ) ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> blocks_count = ( ext4_blocks_count ( es ) - //<S2SV> le32_to_cpu ( es -> s_first_data_block ) + //<S2SV> EXT4_BLOCKS_PER_GROUP ( sb ) - 1 ) ; //<S2SV> do_div ( blocks_count , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; //<S2SV> if ( blocks_count > ( ( uint64_t ) 1 << 32 ) - EXT4_DESC_PER_BLOCK ( sb ) ) { //<S2SV> ext4_msg ( sb , KERN_WARNING , "groups<S2SV_blank>count<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>" //<S2SV> "(block<S2SV_blank>count<S2SV_blank>%llu,<S2SV_blank>first<S2SV_blank>data<S2SV_blank>block<S2SV_blank>%u,<S2SV_blank>" //<S2SV> "blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>%lu)" , sbi -> s_groups_count , //<S2SV> ext4_blocks_count ( es ) , //<S2SV> le32_to_cpu ( es -> s_first_data_block ) , //<S2SV> EXT4_BLOCKS_PER_GROUP ( sb ) ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> sbi -> s_groups_count = blocks_count ; //<S2SV> sbi -> s_blockfile_groups = min_t ( ext4_group_t , sbi -> s_groups_count , //<S2SV> ( EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP ( sb ) ) ) ; //<S2SV> db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / //<S2SV> EXT4_DESC_PER_BLOCK ( sb ) ; //<S2SV> if ( ext4_has_feature_meta_bg ( sb ) ) { //<S2SV> if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { //<S2SV> ext4_msg ( sb , KERN_WARNING , //<S2SV> "first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>" //<S2SV> "(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)" , //<S2SV> le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> } //<S2SV> sbi -> s_group_desc = ext4_kvmalloc ( db_count * //<S2SV> sizeof ( struct buffer_head * ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( sbi -> s_group_desc == NULL ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "not<S2SV_blank>enough<S2SV_blank>memory" ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto failed_mount ; //<S2SV> } //<S2SV> bgl_lock_init ( sbi -> s_blockgroup_lock ) ; //<S2SV> for ( i = 0 ; i < db_count ; i ++ ) { //<S2SV> block = descriptor_loc ( sb , logical_sb_block , i ) ; //<S2SV> sbi -> s_group_desc [ i ] = sb_bread_unmovable ( sb , block ) ; //<S2SV> if ( ! sbi -> s_group_desc [ i ] ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "can\'t<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptor<S2SV_blank>%d" , i ) ; //<S2SV> db_count = i ; //<S2SV> goto failed_mount2 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ext4_check_descriptors ( sb , logical_sb_block , & first_not_zeroed ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "group<S2SV_blank>descriptors<S2SV_blank>corrupted!" ) ; //<S2SV> ret = - EFSCORRUPTED ; //<S2SV> goto failed_mount2 ; //<S2SV> } //<S2SV> sbi -> s_gdb_count = db_count ; //<S2SV> get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; //<S2SV> spin_lock_init ( & sbi -> s_next_gen_lock ) ; //<S2SV> setup_timer ( & sbi -> s_err_report , print_daily_error_info , //<S2SV> ( unsigned long ) sb ) ; //<S2SV> if ( ext4_es_register_shrinker ( sbi ) ) //<S2SV> goto failed_mount3 ; //<S2SV> sbi -> s_stripe = ext4_get_stripe_size ( sbi ) ; //<S2SV> sbi -> s_extent_max_zeroout_kb = 32 ; //<S2SV> sb -> s_op = & ext4_sops ; //<S2SV> sb -> s_export_op = & ext4_export_ops ; //<S2SV> sb -> s_xattr = ext4_xattr_handlers ; //<S2SV> sb -> s_cop = & ext4_cryptops ; //<S2SV> # ifdef CONFIG_QUOTA //<S2SV> sb -> dq_op = & ext4_quota_operations ; //<S2SV> if ( ext4_has_feature_quota ( sb ) ) //<S2SV> sb -> s_qcop = & dquot_quotactl_sysfile_ops ; //<S2SV> else //<S2SV> sb -> s_qcop = & ext4_qctl_operations ; //<S2SV> sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ ; //<S2SV> # endif //<S2SV> memcpy ( sb -> s_uuid , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; //<S2SV> INIT_LIST_HEAD ( & sbi -> s_orphan ) ; //<S2SV> mutex_init ( & sbi -> s_orphan_lock ) ; //<S2SV> sb -> s_root = NULL ; //<S2SV> needs_recovery = ( es -> s_last_orphan != 0 || //<S2SV> ext4_has_feature_journal_needs_recovery ( sb ) ) ; //<S2SV> if ( ext4_has_feature_mmp ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) //<S2SV> if ( ext4_multi_mount_protect ( sb , le64_to_cpu ( es -> s_mmp_block ) ) ) //<S2SV> goto failed_mount3a ; //<S2SV> if ( ! test_opt ( sb , NOLOAD ) && ext4_has_feature_journal ( sb ) ) { //<S2SV> if ( ext4_load_journal ( sb , es , journal_devnum ) ) //<S2SV> goto failed_mount3a ; //<S2SV> } else if ( test_opt ( sb , NOLOAD ) && ! ( sb -> s_flags & MS_RDONLY ) && //<S2SV> ext4_has_feature_journal_needs_recovery ( sb ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "required<S2SV_blank>journal<S2SV_blank>recovery<S2SV_blank>" //<S2SV> "suppressed<S2SV_blank>and<S2SV_blank>not<S2SV_blank>mounted<S2SV_blank>read-only" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } else { //<S2SV> if ( test_opt2 ( sb , EXPLICIT_JOURNAL_CHECKSUM ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>" //<S2SV> "journal_checksum,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>" //<S2SV> "journal_async_commit,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>" //<S2SV> "commit=%lu,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal" , //<S2SV> sbi -> s_commit_interval / HZ ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> if ( EXT4_MOUNT_DATA_FLAGS & //<S2SV> ( sbi -> s_mount_opt ^ sbi -> s_def_mount_opt ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>" //<S2SV> "data=,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> sbi -> s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM ; //<S2SV> clear_opt ( sb , JOURNAL_CHECKSUM ) ; //<S2SV> clear_opt ( sb , DATA_FLAGS ) ; //<S2SV> sbi -> s_journal = NULL ; //<S2SV> needs_recovery = 0 ; //<S2SV> goto no_journal ; //<S2SV> } //<S2SV> if ( ext4_has_feature_64bit ( sb ) && //<S2SV> ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , //<S2SV> JBD2_FEATURE_INCOMPAT_64BIT ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>64-bit<S2SV_blank>journal<S2SV_blank>feature" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> if ( ! set_journal_csum_feature_set ( sb ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>journal<S2SV_blank>checksum<S2SV_blank>" //<S2SV> "feature<S2SV_blank>set" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> switch ( test_opt ( sb , DATA_FLAGS ) ) { //<S2SV> case 0 : //<S2SV> if ( jbd2_journal_check_available_features //<S2SV> ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) //<S2SV> set_opt ( sb , ORDERED_DATA ) ; //<S2SV> else //<S2SV> set_opt ( sb , JOURNAL_DATA ) ; //<S2SV> break ; //<S2SV> case EXT4_MOUNT_ORDERED_DATA : //<S2SV> case EXT4_MOUNT_WRITEBACK_DATA : //<S2SV> if ( ! jbd2_journal_check_available_features //<S2SV> ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "Journal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>" //<S2SV> "requested<S2SV_blank>data<S2SV_blank>journaling<S2SV_blank>mode" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; //<S2SV> sbi -> s_journal -> j_commit_callback = ext4_journal_commit_callback ; //<S2SV> no_journal : //<S2SV> sbi -> s_mb_cache = ext4_xattr_create_cache ( ) ; //<S2SV> if ( ! sbi -> s_mb_cache ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> if ( ( DUMMY_ENCRYPTION_ENABLED ( sbi ) || ext4_has_feature_encrypt ( sb ) ) && //<S2SV> ( blocksize != PAGE_SIZE ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "Unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>fs<S2SV_blank>encryption" ) ; //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> if ( DUMMY_ENCRYPTION_ENABLED ( sbi ) && ! ( sb -> s_flags & MS_RDONLY ) && //<S2SV> ! ext4_has_feature_encrypt ( sb ) ) { //<S2SV> ext4_set_feature_encrypt ( sb ) ; //<S2SV> ext4_commit_super ( sb , 1 ) ; //<S2SV> } //<S2SV> if ( es -> s_overhead_clusters ) //<S2SV> sbi -> s_overhead = le32_to_cpu ( es -> s_overhead_clusters ) ; //<S2SV> else { //<S2SV> err = ext4_calculate_overhead ( sb ) ; //<S2SV> if ( err ) //<S2SV> goto failed_mount_wq ; //<S2SV> } //<S2SV> EXT4_SB ( sb ) -> rsv_conversion_wq = //<S2SV> alloc_workqueue ( "ext4-rsv-conversion" , WQ_MEM_RECLAIM | WQ_UNBOUND , 1 ) ; //<S2SV> if ( ! EXT4_SB ( sb ) -> rsv_conversion_wq ) { //<S2SV> printk ( KERN_ERR "EXT4-fs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>workqueue\\n" ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto failed_mount4 ; //<S2SV> } //<S2SV> root = ext4_iget ( sb , EXT4_ROOT_INO ) ; //<S2SV> if ( IS_ERR ( root ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed" ) ; //<S2SV> ret = PTR_ERR ( root ) ; //<S2SV> root = NULL ; //<S2SV> goto failed_mount4 ; //<S2SV> } //<S2SV> if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck" ) ; //<S2SV> iput ( root ) ; //<S2SV> goto failed_mount4 ; //<S2SV> } //<S2SV> sb -> s_root = d_make_root ( root ) ; //<S2SV> if ( ! sb -> s_root ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "get<S2SV_blank>root<S2SV_blank>dentry<S2SV_blank>failed" ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto failed_mount4 ; //<S2SV> } //<S2SV> if ( ext4_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) //<S2SV> sb -> s_flags |= MS_RDONLY ; //<S2SV> if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) { //<S2SV> sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - //<S2SV> EXT4_GOOD_OLD_INODE_SIZE ; //<S2SV> if ( ext4_has_feature_extra_isize ( sb ) ) { //<S2SV> if ( sbi -> s_want_extra_isize < //<S2SV> le16_to_cpu ( es -> s_want_extra_isize ) ) //<S2SV> sbi -> s_want_extra_isize = //<S2SV> le16_to_cpu ( es -> s_want_extra_isize ) ; //<S2SV> if ( sbi -> s_want_extra_isize < //<S2SV> le16_to_cpu ( es -> s_min_extra_isize ) ) //<S2SV> sbi -> s_want_extra_isize = //<S2SV> le16_to_cpu ( es -> s_min_extra_isize ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > //<S2SV> sbi -> s_inode_size ) { //<S2SV> sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - //<S2SV> EXT4_GOOD_OLD_INODE_SIZE ; //<S2SV> ext4_msg ( sb , KERN_INFO , "required<S2SV_blank>extra<S2SV_blank>inode<S2SV_blank>space<S2SV_blank>not" //<S2SV> "available" ) ; //<S2SV> } //<S2SV> ext4_set_resv_clusters ( sb ) ; //<S2SV> err = ext4_setup_system_zone ( sb ) ; //<S2SV> if ( err ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>system<S2SV_blank>" //<S2SV> "zone<S2SV_blank>(%d)" , err ) ; //<S2SV> goto failed_mount4a ; //<S2SV> } //<S2SV> ext4_ext_init ( sb ) ; //<S2SV> err = ext4_mb_init ( sb ) ; //<S2SV> if ( err ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>mballoc<S2SV_blank>(%d)" , //<S2SV> err ) ; //<S2SV> goto failed_mount5 ; //<S2SV> } //<S2SV> block = ext4_count_free_clusters ( sb ) ; //<S2SV> ext4_free_blocks_count_set ( sbi -> s_es , //<S2SV> EXT4_C2B ( sbi , block ) ) ; //<S2SV> err = percpu_counter_init ( & sbi -> s_freeclusters_counter , block , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! err ) { //<S2SV> unsigned long freei = ext4_count_free_inodes ( sb ) ; //<S2SV> sbi -> s_es -> s_free_inodes_count = cpu_to_le32 ( freei ) ; //<S2SV> err = percpu_counter_init ( & sbi -> s_freeinodes_counter , freei , //<S2SV> GFP_KERNEL ) ; //<S2SV> } //<S2SV> if ( ! err ) //<S2SV> err = percpu_counter_init ( & sbi -> s_dirs_counter , //<S2SV> ext4_count_dirs ( sb ) , GFP_KERNEL ) ; //<S2SV> if ( ! err ) //<S2SV> err = percpu_counter_init ( & sbi -> s_dirtyclusters_counter , 0 , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! err ) //<S2SV> err = percpu_init_rwsem ( & sbi -> s_journal_flag_rwsem ) ; //<S2SV> if ( err ) { //<S2SV> ext4_msg ( sb , KERN_ERR , "insufficient<S2SV_blank>memory" ) ; //<S2SV> goto failed_mount6 ; //<S2SV> } //<S2SV> if ( ext4_has_feature_flex_bg ( sb ) ) //<S2SV> if ( ! ext4_fill_flex_info ( sb ) ) { //<S2SV> ext4_msg ( sb , KERN_ERR , //<S2SV> "unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>" //<S2SV> "flex_bg<S2SV_blank>meta<S2SV_blank>info!" ) ; //<S2SV> goto failed_mount6 ; //<S2SV> } //<S2SV> err = ext4_register_li_request ( sb , first_not_zeroed ) ; //<S2SV> if ( err ) //<S2SV> goto failed_mount6 ; //<S2SV> err = ext4_register_sysfs ( sb ) ; //<S2SV> if ( err ) //<S2SV> goto failed_mount7 ; //<S2SV> # ifdef CONFIG_QUOTA //<S2SV> if ( ext4_has_feature_quota ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) { //<S2SV> err = ext4_enable_quotas ( sb ) ; //<S2SV> if ( err ) //<S2SV> goto failed_mount8 ; //<S2SV> } //<S2SV> # endif //<S2SV> EXT4_SB ( sb ) -> s_mount_state |= EXT4_ORPHAN_FS ; //<S2SV> ext4_orphan_cleanup ( sb , es ) ; //<S2SV> EXT4_SB ( sb ) -> s_mount_state &= ~ EXT4_ORPHAN_FS ; //<S2SV> if ( needs_recovery ) { //<S2SV> ext4_msg ( sb , KERN_INFO , "recovery<S2SV_blank>complete" ) ; //<S2SV> ext4_mark_recovery_complete ( sb , es ) ; //<S2SV> } //<S2SV> if ( EXT4_SB ( sb ) -> s_journal ) { //<S2SV> if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) //<S2SV> descr = "<S2SV_blank>journalled<S2SV_blank>data<S2SV_blank>mode" ; //<S2SV> else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) //<S2SV> descr = "<S2SV_blank>ordered<S2SV_blank>data<S2SV_blank>mode" ; //<S2SV> else //<S2SV> descr = "<S2SV_blank>writeback<S2SV_blank>data<S2SV_blank>mode" ; //<S2SV> } else //<S2SV> descr = "out<S2SV_blank>journal" ; //<S2SV> if ( test_opt ( sb , DISCARD ) ) { //<S2SV> struct request_queue * q = bdev_get_queue ( sb -> s_bdev ) ; //<S2SV> if ( ! blk_queue_discard ( q ) ) //<S2SV> ext4_msg ( sb , KERN_WARNING , //<S2SV> "mounting<S2SV_blank>with<S2SV_blank>\\"discard\\"<S2SV_blank>option,<S2SV_blank>but<S2SV_blank>" //<S2SV> "the<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>discard" ) ; //<S2SV> } //<S2SV> if ( ___ratelimit ( & ext4_mount_msg_ratelimit , "EXT4-fs<S2SV_blank>mount" ) ) //<S2SV> ext4_msg ( sb , KERN_INFO , "mounted<S2SV_blank>filesystem<S2SV_blank>with%s.<S2SV_blank>" //<S2SV> "Opts:<S2SV_blank>%.*s%s%s" , descr , //<S2SV> ( int ) sizeof ( sbi -> s_es -> s_mount_opts ) , //<S2SV> sbi -> s_es -> s_mount_opts , //<S2SV> * sbi -> s_es -> s_mount_opts ? ";<S2SV_blank>" : "" , orig_data ) ; //<S2SV> if ( es -> s_error_count ) //<S2SV> mod_timer ( & sbi -> s_err_report , jiffies + 300 * HZ ) ; //<S2SV> ratelimit_state_init ( & sbi -> s_err_ratelimit_state , 5 * HZ , 10 ) ; //<S2SV> ratelimit_state_init ( & sbi -> s_warning_ratelimit_state , 5 * HZ , 10 ) ; //<S2SV> ratelimit_state_init ( & sbi -> s_msg_ratelimit_state , 5 * HZ , 10 ) ; //<S2SV> kfree ( orig_data ) ; //<S2SV> # ifdef CONFIG_EXT4_FS_ENCRYPTION //<S2SV> memcpy ( sbi -> key_prefix , EXT4_KEY_DESC_PREFIX , //<S2SV> EXT4_KEY_DESC_PREFIX_SIZE ) ; //<S2SV> sbi -> key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE ; //<S2SV> # endif //<S2SV> return 0 ; //<S2SV> cantfind_ext4 : //<S2SV> if ( ! silent ) //<S2SV> ext4_msg ( sb , KERN_ERR , "VFS:<S2SV_blank>Can\'t<S2SV_blank>find<S2SV_blank>ext4<S2SV_blank>filesystem" ) ; //<S2SV> goto failed_mount ; //<S2SV> # ifdef CONFIG_QUOTA //<S2SV> failed_mount8 : //<S2SV> ext4_unregister_sysfs ( sb ) ; //<S2SV> # endif //<S2SV> failed_mount7 : //<S2SV> ext4_unregister_li_request ( sb ) ; //<S2SV> failed_mount6 : //<S2SV> ext4_mb_release ( sb ) ; //<S2SV> if ( sbi -> s_flex_groups ) //<S2SV> kvfree ( sbi -> s_flex_groups ) ; //<S2SV> percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; //<S2SV> percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; //<S2SV> percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; //<S2SV> percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; //<S2SV> failed_mount5 : //<S2SV> ext4_ext_release ( sb ) ; //<S2SV> ext4_release_system_zone ( sb ) ; //<S2SV> failed_mount4a : //<S2SV> dput ( sb -> s_root ) ; //<S2SV> sb -> s_root = NULL ; //<S2SV> failed_mount4 : //<S2SV> ext4_msg ( sb , KERN_ERR , "mount<S2SV_blank>failed" ) ; //<S2SV> if ( EXT4_SB ( sb ) -> rsv_conversion_wq ) //<S2SV> destroy_workqueue ( EXT4_SB ( sb ) -> rsv_conversion_wq ) ; //<S2SV> failed_mount_wq : //<S2SV> if ( sbi -> s_mb_cache ) { //<S2SV> ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; //<S2SV> sbi -> s_mb_cache = NULL ; //<S2SV> } //<S2SV> if ( sbi -> s_journal ) { //<S2SV> jbd2_journal_destroy ( sbi -> s_journal ) ; //<S2SV> sbi -> s_journal = NULL ; //<S2SV> } //<S2SV> failed_mount3a : //<S2SV> ext4_es_unregister_shrinker ( sbi ) ; //<S2SV> failed_mount3 : //<S2SV> del_timer_sync ( & sbi -> s_err_report ) ; //<S2SV> if ( sbi -> s_mmp_tsk ) //<S2SV> kthread_stop ( sbi -> s_mmp_tsk ) ; //<S2SV> failed_mount2 : //<S2SV> for ( i = 0 ; i < db_count ; i ++ ) //<S2SV> brelse ( sbi -> s_group_desc [ i ] ) ; //<S2SV> kvfree ( sbi -> s_group_desc ) ; //<S2SV> failed_mount : //<S2SV> if ( sbi -> s_chksum_driver ) //<S2SV> crypto_free_shash ( sbi -> s_chksum_driver ) ; //<S2SV> # ifdef CONFIG_QUOTA //<S2SV> for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) //<S2SV> kfree ( sbi -> s_qf_names [ i ] ) ; //<S2SV> # endif //<S2SV> ext4_blkdev_remove ( sbi ) ; //<S2SV> brelse ( bh ) ; //<S2SV> out_fail : //<S2SV> sb -> s_fs_info = NULL ; //<S2SV> kfree ( sbi -> s_blockgroup_lock ) ; //<S2SV> out_free_base : //<S2SV> kfree ( sbi ) ; //<S2SV> kfree ( orig_data ) ; //<S2SV> return err ? err : ret ; //<S2SV> } //<S2SV> 