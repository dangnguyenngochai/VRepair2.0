static struct buffer_head * //<S2SV> ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , //<S2SV> struct mb_cache_entry * * pce ) //<S2SV> { //<S2SV> __u32 hash = le32_to_cpu ( header -> h_hash ) ; //<S2SV> struct mb_cache_entry * ce ; //<S2SV> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; //<S2SV> if ( ! header -> h_hash ) //<S2SV> return NULL ; //<S2SV> ea_idebug ( inode , "looking<S2SV_blank>for<S2SV_blank>cached<S2SV_blank>blocks<S2SV_blank>[%x]" , ( int ) hash ) ; //<S2SV> again : //<S2SV> ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , //<S2SV> hash ) ; //<S2SV> while ( ce ) { //<S2SV> struct buffer_head * bh ; //<S2SV> if ( IS_ERR ( ce ) ) { //<S2SV> if ( PTR_ERR ( ce ) == - EAGAIN ) //<S2SV> goto again ; //<S2SV> break ; //<S2SV> } //<S2SV> bh = sb_bread ( inode -> i_sb , ce -> e_block ) ; //<S2SV> if ( ! bh ) { //<S2SV> EXT4_ERROR_INODE ( inode , "block<S2SV_blank>%lu<S2SV_blank>read<S2SV_blank>error" , //<S2SV> ( unsigned long ) ce -> e_block ) ; //<S2SV> } else if ( le32_to_cpu ( BHDR ( bh ) -> h_refcount ) >= //<S2SV> EXT4_XATTR_REFCOUNT_MAX ) { //<S2SV> ea_idebug ( inode , "block<S2SV_blank>%lu<S2SV_blank>refcount<S2SV_blank>%d>=%d" , //<S2SV> ( unsigned long ) ce -> e_block , //<S2SV> le32_to_cpu ( BHDR ( bh ) -> h_refcount ) , //<S2SV> EXT4_XATTR_REFCOUNT_MAX ) ; //<S2SV> } else if ( ext4_xattr_cmp ( header , BHDR ( bh ) ) == 0 ) { //<S2SV> * pce = ce ; //<S2SV> return bh ; //<S2SV> } //<S2SV> brelse ( bh ) ; //<S2SV> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; //<S2SV> } //<S2SV> return NULL ; //<S2SV> } //<S2SV> 