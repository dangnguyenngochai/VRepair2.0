static int //<S2SV> ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) //<S2SV> { //<S2SV> struct inode * inode = d_inode ( dentry ) ; //<S2SV> struct buffer_head * bh = NULL ; //<S2SV> int error ; //<S2SV> struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; //<S2SV> ea_idebug ( inode , "buffer=%p,<S2SV_blank>buffer_size=%ld" , //<S2SV> buffer , ( long ) buffer_size ) ; //<S2SV> error = 0 ; //<S2SV> if ( ! EXT4_I ( inode ) -> i_file_acl ) //<S2SV> goto cleanup ; //<S2SV> ea_idebug ( inode , "reading<S2SV_blank>block<S2SV_blank>%llu" , //<S2SV> ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; //<S2SV> bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; //<S2SV> error = - EIO ; //<S2SV> if ( ! bh ) //<S2SV> goto cleanup ; //<S2SV> ea_bdebug ( bh , "b_count=%d,<S2SV_blank>refcount=%d" , //<S2SV> atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; //<S2SV> if ( ext4_xattr_check_block ( inode , bh ) ) { //<S2SV> EXT4_ERROR_INODE ( inode , "bad<S2SV_blank>block<S2SV_blank>%llu" , //<S2SV> EXT4_I ( inode ) -> i_file_acl ) ; //<S2SV> error = - EFSCORRUPTED ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; //<S2SV> error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; //<S2SV> cleanup : //<S2SV> brelse ( bh ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 