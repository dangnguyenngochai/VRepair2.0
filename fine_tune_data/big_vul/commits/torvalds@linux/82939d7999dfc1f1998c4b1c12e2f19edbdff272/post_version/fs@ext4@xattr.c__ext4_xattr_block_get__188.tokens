static int //<S2SV> ext4_xattr_block_get ( struct inode * inode , int name_index , const char * name , //<S2SV> void * buffer , size_t buffer_size ) //<S2SV> { //<S2SV> struct buffer_head * bh = NULL ; //<S2SV> struct ext4_xattr_entry * entry ; //<S2SV> size_t size ; //<S2SV> int error ; //<S2SV> struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; //<S2SV> ea_idebug ( inode , "name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld" , //<S2SV> name_index , name , buffer , ( long ) buffer_size ) ; //<S2SV> error = - ENODATA ; //<S2SV> if ( ! EXT4_I ( inode ) -> i_file_acl ) //<S2SV> goto cleanup ; //<S2SV> ea_idebug ( inode , "reading<S2SV_blank>block<S2SV_blank>%llu" , //<S2SV> ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; //<S2SV> bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; //<S2SV> if ( ! bh ) //<S2SV> goto cleanup ; //<S2SV> ea_bdebug ( bh , "b_count=%d,<S2SV_blank>refcount=%d" , //<S2SV> atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; //<S2SV> if ( ext4_xattr_check_block ( inode , bh ) ) { //<S2SV> bad_block : //<S2SV> EXT4_ERROR_INODE ( inode , "bad<S2SV_blank>block<S2SV_blank>%llu" , //<S2SV> EXT4_I ( inode ) -> i_file_acl ) ; //<S2SV> error = - EFSCORRUPTED ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; //<S2SV> entry = BFIRST ( bh ) ; //<S2SV> error = ext4_xattr_find_entry ( & entry , name_index , name , bh -> b_size , 1 ) ; //<S2SV> if ( error == - EFSCORRUPTED ) //<S2SV> goto bad_block ; //<S2SV> if ( error ) //<S2SV> goto cleanup ; //<S2SV> size = le32_to_cpu ( entry -> e_value_size ) ; //<S2SV> if ( buffer ) { //<S2SV> error = - ERANGE ; //<S2SV> if ( size > buffer_size ) //<S2SV> goto cleanup ; //<S2SV> memcpy ( buffer , bh -> b_data + le16_to_cpu ( entry -> e_value_offs ) , //<S2SV> size ) ; //<S2SV> } //<S2SV> error = size ; //<S2SV> cleanup : //<S2SV> brelse ( bh ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 