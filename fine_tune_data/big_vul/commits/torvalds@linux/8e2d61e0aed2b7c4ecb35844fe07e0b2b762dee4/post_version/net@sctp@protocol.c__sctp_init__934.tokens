static __init int sctp_init ( void ) //<S2SV> { //<S2SV> int i ; //<S2SV> int status = - EINVAL ; //<S2SV> unsigned long goal ; //<S2SV> unsigned long limit ; //<S2SV> int max_share ; //<S2SV> int order ; //<S2SV> sock_skb_cb_check_size ( sizeof ( struct sctp_ulpevent ) ) ; //<S2SV> status = - ENOBUFS ; //<S2SV> sctp_bucket_cachep = kmem_cache_create ( "sctp_bind_bucket" , //<S2SV> sizeof ( struct sctp_bind_bucket ) , //<S2SV> 0 , SLAB_HWCACHE_ALIGN , //<S2SV> NULL ) ; //<S2SV> if ( ! sctp_bucket_cachep ) //<S2SV> goto out ; //<S2SV> sctp_chunk_cachep = kmem_cache_create ( "sctp_chunk" , //<S2SV> sizeof ( struct sctp_chunk ) , //<S2SV> 0 , SLAB_HWCACHE_ALIGN , //<S2SV> NULL ) ; //<S2SV> if ( ! sctp_chunk_cachep ) //<S2SV> goto err_chunk_cachep ; //<S2SV> status = percpu_counter_init ( & sctp_sockets_allocated , 0 , GFP_KERNEL ) ; //<S2SV> if ( status ) //<S2SV> goto err_percpu_counter_init ; //<S2SV> sctp_max_instreams = SCTP_DEFAULT_INSTREAMS ; //<S2SV> sctp_max_outstreams = SCTP_DEFAULT_OUTSTREAMS ; //<S2SV> idr_init ( & sctp_assocs_id ) ; //<S2SV> limit = nr_free_buffer_pages ( ) / 8 ; //<S2SV> limit = max ( limit , 128UL ) ; //<S2SV> sysctl_sctp_mem [ 0 ] = limit / 4 * 3 ; //<S2SV> sysctl_sctp_mem [ 1 ] = limit ; //<S2SV> sysctl_sctp_mem [ 2 ] = sysctl_sctp_mem [ 0 ] * 2 ; //<S2SV> limit = ( sysctl_sctp_mem [ 1 ] ) << ( PAGE_SHIFT - 7 ) ; //<S2SV> max_share = min ( 4UL * 1024 * 1024 , limit ) ; //<S2SV> sysctl_sctp_rmem [ 0 ] = SK_MEM_QUANTUM ; //<S2SV> sysctl_sctp_rmem [ 1 ] = 1500 * SKB_TRUESIZE ( 1 ) ; //<S2SV> sysctl_sctp_rmem [ 2 ] = max ( sysctl_sctp_rmem [ 1 ] , max_share ) ; //<S2SV> sysctl_sctp_wmem [ 0 ] = SK_MEM_QUANTUM ; //<S2SV> sysctl_sctp_wmem [ 1 ] = 16 * 1024 ; //<S2SV> sysctl_sctp_wmem [ 2 ] = max ( 64 * 1024 , max_share ) ; //<S2SV> if ( totalram_pages >= ( 128 * 1024 ) ) //<S2SV> goal = totalram_pages >> ( 22 - PAGE_SHIFT ) ; //<S2SV> else //<S2SV> goal = totalram_pages >> ( 24 - PAGE_SHIFT ) ; //<S2SV> for ( order = 0 ; ( 1UL << order ) < goal ; order ++ ) //<S2SV> ; //<S2SV> do { //<S2SV> sctp_assoc_hashsize = ( 1UL << order ) * PAGE_SIZE / //<S2SV> sizeof ( struct sctp_hashbucket ) ; //<S2SV> if ( ( sctp_assoc_hashsize > ( 64 * 1024 ) ) && order > 0 ) //<S2SV> continue ; //<S2SV> sctp_assoc_hashtable = ( struct sctp_hashbucket * ) //<S2SV> __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; //<S2SV> } while ( ! sctp_assoc_hashtable && -- order > 0 ) ; //<S2SV> if ( ! sctp_assoc_hashtable ) { //<S2SV> pr_err ( "Failed<S2SV_blank>association<S2SV_blank>hash<S2SV_blank>alloc\\n" ) ; //<S2SV> status = - ENOMEM ; //<S2SV> goto err_ahash_alloc ; //<S2SV> } //<S2SV> for ( i = 0 ; i < sctp_assoc_hashsize ; i ++ ) { //<S2SV> rwlock_init ( & sctp_assoc_hashtable [ i ] . lock ) ; //<S2SV> INIT_HLIST_HEAD ( & sctp_assoc_hashtable [ i ] . chain ) ; //<S2SV> } //<S2SV> sctp_ep_hashsize = 64 ; //<S2SV> sctp_ep_hashtable = //<S2SV> kmalloc ( 64 * sizeof ( struct sctp_hashbucket ) , GFP_KERNEL ) ; //<S2SV> if ( ! sctp_ep_hashtable ) { //<S2SV> pr_err ( "Failed<S2SV_blank>endpoint_hash<S2SV_blank>alloc\\n" ) ; //<S2SV> status = - ENOMEM ; //<S2SV> goto err_ehash_alloc ; //<S2SV> } //<S2SV> for ( i = 0 ; i < sctp_ep_hashsize ; i ++ ) { //<S2SV> rwlock_init ( & sctp_ep_hashtable [ i ] . lock ) ; //<S2SV> INIT_HLIST_HEAD ( & sctp_ep_hashtable [ i ] . chain ) ; //<S2SV> } //<S2SV> do { //<S2SV> sctp_port_hashsize = ( 1UL << order ) * PAGE_SIZE / //<S2SV> sizeof ( struct sctp_bind_hashbucket ) ; //<S2SV> if ( ( sctp_port_hashsize > ( 64 * 1024 ) ) && order > 0 ) //<S2SV> continue ; //<S2SV> sctp_port_hashtable = ( struct sctp_bind_hashbucket * ) //<S2SV> __get_free_pages ( GFP_ATOMIC | __GFP_NOWARN , order ) ; //<S2SV> } while ( ! sctp_port_hashtable && -- order > 0 ) ; //<S2SV> if ( ! sctp_port_hashtable ) { //<S2SV> pr_err ( "Failed<S2SV_blank>bind<S2SV_blank>hash<S2SV_blank>alloc\\n" ) ; //<S2SV> status = - ENOMEM ; //<S2SV> goto err_bhash_alloc ; //<S2SV> } //<S2SV> for ( i = 0 ; i < sctp_port_hashsize ; i ++ ) { //<S2SV> spin_lock_init ( & sctp_port_hashtable [ i ] . lock ) ; //<S2SV> INIT_HLIST_HEAD ( & sctp_port_hashtable [ i ] . chain ) ; //<S2SV> } //<S2SV> pr_info ( "Hash<S2SV_blank>tables<S2SV_blank>configured<S2SV_blank>(established<S2SV_blank>%d<S2SV_blank>bind<S2SV_blank>%d)\\n" , //<S2SV> sctp_assoc_hashsize , sctp_port_hashsize ) ; //<S2SV> sctp_sysctl_register ( ) ; //<S2SV> INIT_LIST_HEAD ( & sctp_address_families ) ; //<S2SV> sctp_v4_pf_init ( ) ; //<S2SV> sctp_v6_pf_init ( ) ; //<S2SV> status = register_pernet_subsys ( & sctp_defaults_ops ) ; //<S2SV> if ( status ) //<S2SV> goto err_register_defaults ; //<S2SV> status = sctp_v4_protosw_init ( ) ; //<S2SV> if ( status ) //<S2SV> goto err_protosw_init ; //<S2SV> status = sctp_v6_protosw_init ( ) ; //<S2SV> if ( status ) //<S2SV> goto err_v6_protosw_init ; //<S2SV> status = register_pernet_subsys ( & sctp_ctrlsock_ops ) ; //<S2SV> if ( status ) //<S2SV> goto err_register_ctrlsock ; //<S2SV> status = sctp_v4_add_protocol ( ) ; //<S2SV> if ( status ) //<S2SV> goto err_add_protocol ; //<S2SV> status = sctp_v6_add_protocol ( ) ; //<S2SV> if ( status ) //<S2SV> goto err_v6_add_protocol ; //<S2SV> out : //<S2SV> return status ; //<S2SV> err_v6_add_protocol : //<S2SV> sctp_v4_del_protocol ( ) ; //<S2SV> err_add_protocol : //<S2SV> unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ; //<S2SV> err_register_ctrlsock : //<S2SV> sctp_v6_protosw_exit ( ) ; //<S2SV> err_v6_protosw_init : //<S2SV> sctp_v4_protosw_exit ( ) ; //<S2SV> err_protosw_init : //<S2SV> unregister_pernet_subsys ( & sctp_defaults_ops ) ; //<S2SV> err_register_defaults : //<S2SV> sctp_v4_pf_exit ( ) ; //<S2SV> sctp_v6_pf_exit ( ) ; //<S2SV> sctp_sysctl_unregister ( ) ; //<S2SV> free_pages ( ( unsigned long ) sctp_port_hashtable , //<S2SV> get_order ( sctp_port_hashsize * //<S2SV> sizeof ( struct sctp_bind_hashbucket ) ) ) ; //<S2SV> err_bhash_alloc : //<S2SV> kfree ( sctp_ep_hashtable ) ; //<S2SV> err_ehash_alloc : //<S2SV> free_pages ( ( unsigned long ) sctp_assoc_hashtable , //<S2SV> get_order ( sctp_assoc_hashsize * //<S2SV> sizeof ( struct sctp_hashbucket ) ) ) ; //<S2SV> err_ahash_alloc : //<S2SV> percpu_counter_destroy ( & sctp_sockets_allocated ) ; //<S2SV> err_percpu_counter_init : //<S2SV> kmem_cache_destroy ( sctp_chunk_cachep ) ; //<S2SV> err_chunk_cachep : //<S2SV> kmem_cache_destroy ( sctp_bucket_cachep ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 