static void ndisc_router_discovery ( struct sk_buff * skb ) //<S2SV> { //<S2SV> struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; //<S2SV> struct neighbour * neigh = NULL ; //<S2SV> struct inet6_dev * in6_dev ; //<S2SV> struct rt6_info * rt = NULL ; //<S2SV> int lifetime ; //<S2SV> struct ndisc_options ndopts ; //<S2SV> int optlen ; //<S2SV> unsigned int pref = 0 ; //<S2SV> __u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; //<S2SV> optlen = ( skb_tail_pointer ( skb ) - skb_transport_header ( skb ) ) - //<S2SV> sizeof ( struct ra_msg ) ; //<S2SV> ND_PRINTK ( 2 , info , //<S2SV> "RA:<S2SV_blank>%s,<S2SV_blank>dev:<S2SV_blank>%s\\n" , //<S2SV> __func__ , skb -> dev -> name ) ; //<S2SV> if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) ) { //<S2SV> ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>source<S2SV_blank>address<S2SV_blank>is<S2SV_blank>not<S2SV_blank>link-local\\n" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( optlen < 0 ) { //<S2SV> ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>short\\n" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> # ifdef CONFIG_IPV6_NDISC_NODETYPE //<S2SV> if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST ) { //<S2SV> ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>from<S2SV_blank>host<S2SV_blank>or<S2SV_blank>unauthorized<S2SV_blank>router\\n" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> # endif //<S2SV> in6_dev = __in6_dev_get ( skb -> dev ) ; //<S2SV> if ( in6_dev == NULL ) { //<S2SV> ND_PRINTK ( 0 , err , "RA:<S2SV_blank>can\'t<S2SV_blank>find<S2SV_blank>inet6<S2SV_blank>device<S2SV_blank>for<S2SV_blank>%s\\n" , //<S2SV> skb -> dev -> name ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) ) { //<S2SV> ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>invalid<S2SV_blank>ND<S2SV_blank>options\\n" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! ipv6_accept_ra ( in6_dev ) ) { //<S2SV> ND_PRINTK ( 2 , info , //<S2SV> "RA:<S2SV_blank>%s,<S2SV_blank>did<S2SV_blank>not<S2SV_blank>accept<S2SV_blank>ra<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n" , //<S2SV> __func__ , skb -> dev -> name ) ; //<S2SV> goto skip_linkparms ; //<S2SV> } //<S2SV> # ifdef CONFIG_IPV6_NDISC_NODETYPE //<S2SV> if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) { //<S2SV> ND_PRINTK ( 2 , info , //<S2SV> "RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT,<S2SV_blank>dev:<S2SV_blank>%s\\n" , //<S2SV> __func__ , skb -> dev -> name ) ; //<S2SV> goto skip_linkparms ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( in6_dev -> if_flags & IF_RS_SENT ) { //<S2SV> in6_dev -> if_flags |= IF_RA_RCVD ; //<S2SV> } //<S2SV> in6_dev -> if_flags = ( in6_dev -> if_flags & ~ ( IF_RA_MANAGED | //<S2SV> IF_RA_OTHERCONF ) ) | //<S2SV> ( ra_msg -> icmph . icmp6_addrconf_managed ? //<S2SV> IF_RA_MANAGED : 0 ) | //<S2SV> ( ra_msg -> icmph . icmp6_addrconf_other ? //<S2SV> IF_RA_OTHERCONF : 0 ) ; //<S2SV> if ( ! in6_dev -> cnf . accept_ra_defrtr ) { //<S2SV> ND_PRINTK ( 2 , info , //<S2SV> "RA:<S2SV_blank>%s,<S2SV_blank>defrtr<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n" , //<S2SV> __func__ , skb -> dev -> name ) ; //<S2SV> goto skip_defrtr ; //<S2SV> } //<S2SV> if ( ! in6_dev -> cnf . accept_ra_from_local && //<S2SV> ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , //<S2SV> NULL , 0 ) ) { //<S2SV> ND_PRINTK ( 2 , info , //<S2SV> "RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>default<S2SV_blank>router<S2SV_blank>ignored\\n" , //<S2SV> skb -> dev -> name ) ; //<S2SV> goto skip_defrtr ; //<S2SV> } //<S2SV> lifetime = ntohs ( ra_msg -> icmph . icmp6_rt_lifetime ) ; //<S2SV> # ifdef CONFIG_IPV6_ROUTER_PREF //<S2SV> pref = ra_msg -> icmph . icmp6_router_pref ; //<S2SV> if ( pref == ICMPV6_ROUTER_PREF_INVALID || //<S2SV> ! in6_dev -> cnf . accept_ra_rtr_pref ) //<S2SV> pref = ICMPV6_ROUTER_PREF_MEDIUM ; //<S2SV> # endif //<S2SV> rt = rt6_get_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev ) ; //<S2SV> if ( rt ) { //<S2SV> neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ) ; //<S2SV> if ( ! neigh ) { //<S2SV> ND_PRINTK ( 0 , err , //<S2SV> "RA:<S2SV_blank>%s<S2SV_blank>got<S2SV_blank>default<S2SV_blank>router<S2SV_blank>without<S2SV_blank>neighbour\\n" , //<S2SV> __func__ ) ; //<S2SV> ip6_rt_put ( rt ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> if ( rt && lifetime == 0 ) { //<S2SV> ip6_del_rt ( rt ) ; //<S2SV> rt = NULL ; //<S2SV> } //<S2SV> ND_PRINTK ( 3 , info , "RA:<S2SV_blank>rt:<S2SV_blank>%p<S2SV_blank><S2SV_blank>lifetime:<S2SV_blank>%d,<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n" , //<S2SV> rt , lifetime , skb -> dev -> name ) ; //<S2SV> if ( rt == NULL && lifetime ) { //<S2SV> ND_PRINTK ( 3 , info , "RA:<S2SV_blank>adding<S2SV_blank>default<S2SV_blank>router\\n" ) ; //<S2SV> rt = rt6_add_dflt_router ( & ipv6_hdr ( skb ) -> saddr , skb -> dev , pref ) ; //<S2SV> if ( rt == NULL ) { //<S2SV> ND_PRINTK ( 0 , err , //<S2SV> "RA:<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>default<S2SV_blank>route\\n" , //<S2SV> __func__ ) ; //<S2SV> return ; //<S2SV> } //<S2SV> neigh = dst_neigh_lookup ( & rt -> dst , & ipv6_hdr ( skb ) -> saddr ) ; //<S2SV> if ( neigh == NULL ) { //<S2SV> ND_PRINTK ( 0 , err , //<S2SV> "RA:<S2SV_blank>%s<S2SV_blank>got<S2SV_blank>default<S2SV_blank>router<S2SV_blank>without<S2SV_blank>neighbour\\n" , //<S2SV> __func__ ) ; //<S2SV> ip6_rt_put ( rt ) ; //<S2SV> return ; //<S2SV> } //<S2SV> neigh -> flags |= NTF_ROUTER ; //<S2SV> } else if ( rt ) { //<S2SV> rt -> rt6i_flags = ( rt -> rt6i_flags & ~ RTF_PREF_MASK ) | RTF_PREF ( pref ) ; //<S2SV> } //<S2SV> if ( rt ) //<S2SV> rt6_set_expires ( rt , jiffies + ( HZ * lifetime ) ) ; //<S2SV> if ( ra_msg -> icmph . icmp6_hop_limit ) { //<S2SV> in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; //<S2SV> if ( rt ) //<S2SV> dst_metric_set ( & rt -> dst , RTAX_HOPLIMIT , //<S2SV> ra_msg -> icmph . icmp6_hop_limit ) ; //<S2SV> } //<S2SV> skip_defrtr : //<S2SV> if ( in6_dev -> nd_parms ) { //<S2SV> unsigned long rtime = ntohl ( ra_msg -> retrans_timer ) ; //<S2SV> if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / HZ ) { //<S2SV> rtime = ( rtime * HZ ) / 1000 ; //<S2SV> if ( rtime < HZ / 10 ) //<S2SV> rtime = HZ / 10 ; //<S2SV> NEIGH_VAR_SET ( in6_dev -> nd_parms , RETRANS_TIME , rtime ) ; //<S2SV> in6_dev -> tstamp = jiffies ; //<S2SV> inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ; //<S2SV> } //<S2SV> rtime = ntohl ( ra_msg -> reachable_time ) ; //<S2SV> if ( rtime && rtime / 1000 < MAX_SCHEDULE_TIMEOUT / ( 3 * HZ ) ) { //<S2SV> rtime = ( rtime * HZ ) / 1000 ; //<S2SV> if ( rtime < HZ / 10 ) //<S2SV> rtime = HZ / 10 ; //<S2SV> if ( rtime != NEIGH_VAR ( in6_dev -> nd_parms , BASE_REACHABLE_TIME ) ) { //<S2SV> NEIGH_VAR_SET ( in6_dev -> nd_parms , //<S2SV> BASE_REACHABLE_TIME , rtime ) ; //<S2SV> NEIGH_VAR_SET ( in6_dev -> nd_parms , //<S2SV> GC_STALETIME , 3 * rtime ) ; //<S2SV> in6_dev -> nd_parms -> reachable_time = neigh_rand_reach_time ( rtime ) ; //<S2SV> in6_dev -> tstamp = jiffies ; //<S2SV> inet6_ifinfo_notify ( RTM_NEWLINK , in6_dev ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> skip_linkparms : //<S2SV> if ( ! neigh ) //<S2SV> neigh = __neigh_lookup ( & nd_tbl , & ipv6_hdr ( skb ) -> saddr , //<S2SV> skb -> dev , 1 ) ; //<S2SV> if ( neigh ) { //<S2SV> u8 * lladdr = NULL ; //<S2SV> if ( ndopts . nd_opts_src_lladdr ) { //<S2SV> lladdr = ndisc_opt_addr_data ( ndopts . nd_opts_src_lladdr , //<S2SV> skb -> dev ) ; //<S2SV> if ( ! lladdr ) { //<S2SV> ND_PRINTK ( 2 , warn , //<S2SV> "RA:<S2SV_blank>invalid<S2SV_blank>link-layer<S2SV_blank>address<S2SV_blank>length\\n" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> neigh_update ( neigh , lladdr , NUD_STALE , //<S2SV> NEIGH_UPDATE_F_WEAK_OVERRIDE | //<S2SV> NEIGH_UPDATE_F_OVERRIDE | //<S2SV> NEIGH_UPDATE_F_OVERRIDE_ISROUTER | //<S2SV> NEIGH_UPDATE_F_ISROUTER ) ; //<S2SV> } //<S2SV> if ( ! ipv6_accept_ra ( in6_dev ) ) { //<S2SV> ND_PRINTK ( 2 , info , //<S2SV> "RA:<S2SV_blank>%s,<S2SV_blank>accept_ra<S2SV_blank>is<S2SV_blank>false<S2SV_blank>for<S2SV_blank>dev:<S2SV_blank>%s\\n" , //<S2SV> __func__ , skb -> dev -> name ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> # ifdef CONFIG_IPV6_ROUTE_INFO //<S2SV> if ( ! in6_dev -> cnf . accept_ra_from_local && //<S2SV> ipv6_chk_addr ( dev_net ( in6_dev -> dev ) , & ipv6_hdr ( skb ) -> saddr , //<S2SV> NULL , 0 ) ) { //<S2SV> ND_PRINTK ( 2 , info , //<S2SV> "RA<S2SV_blank>from<S2SV_blank>local<S2SV_blank>address<S2SV_blank>detected<S2SV_blank>on<S2SV_blank>dev:<S2SV_blank>%s:<S2SV_blank>router<S2SV_blank>info<S2SV_blank>ignored.\\n" , //<S2SV> skb -> dev -> name ) ; //<S2SV> goto skip_routeinfo ; //<S2SV> } //<S2SV> if ( in6_dev -> cnf . accept_ra_rtr_pref && ndopts . nd_opts_ri ) { //<S2SV> struct nd_opt_hdr * p ; //<S2SV> for ( p = ndopts . nd_opts_ri ; //<S2SV> p ; //<S2SV> p = ndisc_next_option ( p , ndopts . nd_opts_ri_end ) ) { //<S2SV> struct route_info * ri = ( struct route_info * ) p ; //<S2SV> # ifdef CONFIG_IPV6_NDISC_NODETYPE //<S2SV> if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT && //<S2SV> ri -> prefix_len == 0 ) //<S2SV> continue ; //<S2SV> # endif //<S2SV> if ( ri -> prefix_len == 0 && //<S2SV> ! in6_dev -> cnf . accept_ra_defrtr ) //<S2SV> continue ; //<S2SV> if ( ri -> prefix_len > in6_dev -> cnf . accept_ra_rt_info_max_plen ) //<S2SV> continue ; //<S2SV> rt6_route_rcv ( skb -> dev , ( u8 * ) p , ( p -> nd_opt_len ) << 3 , //<S2SV> & ipv6_hdr ( skb ) -> saddr ) ; //<S2SV> } //<S2SV> } //<S2SV> skip_routeinfo : //<S2SV> # endif //<S2SV> # ifdef CONFIG_IPV6_NDISC_NODETYPE //<S2SV> if ( skb -> ndisc_nodetype == NDISC_NODETYPE_NODEFAULT ) { //<S2SV> ND_PRINTK ( 2 , info , //<S2SV> "RA:<S2SV_blank>%s,<S2SV_blank>nodetype<S2SV_blank>is<S2SV_blank>NODEFAULT<S2SV_blank>(interior<S2SV_blank>routes),<S2SV_blank>dev:<S2SV_blank>%s\\n" , //<S2SV> __func__ , skb -> dev -> name ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( in6_dev -> cnf . accept_ra_pinfo && ndopts . nd_opts_pi ) { //<S2SV> struct nd_opt_hdr * p ; //<S2SV> for ( p = ndopts . nd_opts_pi ; //<S2SV> p ; //<S2SV> p = ndisc_next_option ( p , ndopts . nd_opts_pi_end ) ) { //<S2SV> addrconf_prefix_rcv ( skb -> dev , ( u8 * ) p , //<S2SV> ( p -> nd_opt_len ) << 3 , //<S2SV> ndopts . nd_opts_src_lladdr != NULL ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ndopts . nd_opts_mtu && in6_dev -> cnf . accept_ra_mtu ) { //<S2SV> __be32 n ; //<S2SV> u32 mtu ; //<S2SV> memcpy ( & n , ( ( u8 * ) ( ndopts . nd_opts_mtu + 1 ) ) + 2 , sizeof ( mtu ) ) ; //<S2SV> mtu = ntohl ( n ) ; //<S2SV> if ( mtu < IPV6_MIN_MTU || mtu > skb -> dev -> mtu ) { //<S2SV> ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>invalid<S2SV_blank>mtu:<S2SV_blank>%d\\n" , mtu ) ; //<S2SV> } else if ( in6_dev -> cnf . mtu6 != mtu ) { //<S2SV> in6_dev -> cnf . mtu6 = mtu ; //<S2SV> if ( rt ) //<S2SV> dst_metric_set ( & rt -> dst , RTAX_MTU , mtu ) ; //<S2SV> rt6_mtu_change ( skb -> dev , mtu ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ndopts . nd_useropts ) { //<S2SV> struct nd_opt_hdr * p ; //<S2SV> for ( p = ndopts . nd_useropts ; //<S2SV> p ; //<S2SV> p = ndisc_next_useropt ( p , ndopts . nd_useropts_end ) ) { //<S2SV> ndisc_ra_useropt ( skb , p ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ndopts . nd_opts_tgt_lladdr || ndopts . nd_opts_rh ) { //<S2SV> ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>invalid<S2SV_blank>RA<S2SV_blank>options\\n" ) ; //<S2SV> } //<S2SV> out : //<S2SV> ip6_rt_put ( rt ) ; //<S2SV> if ( neigh ) //<S2SV> neigh_release ( neigh ) ; //<S2SV> } //<S2SV> 