static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , //<S2SV> size_t msg_len ) //<S2SV> { //<S2SV> struct sock * sk = asoc -> base . sk ; //<S2SV> int err = 0 ; //<S2SV> long current_timeo = * timeo_p ; //<S2SV> DEFINE_WAIT ( wait ) ; //<S2SV> pr_debug ( "%s:<S2SV_blank>asoc:%p,<S2SV_blank>timeo:%ld,<S2SV_blank>msg_len:%zu\\n" , __func__ , asoc , //<S2SV> * timeo_p , msg_len ) ; //<S2SV> sctp_association_hold ( asoc ) ; //<S2SV> for ( ; ; ) { //<S2SV> prepare_to_wait_exclusive ( & asoc -> wait , & wait , //<S2SV> TASK_INTERRUPTIBLE ) ; //<S2SV> if ( ! * timeo_p ) //<S2SV> goto do_nonblock ; //<S2SV> if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || //<S2SV> asoc -> base . dead ) //<S2SV> goto do_error ; //<S2SV> if ( signal_pending ( current ) ) //<S2SV> goto do_interrupted ; //<S2SV> if ( msg_len <= sctp_wspace ( asoc ) ) //<S2SV> break ; //<S2SV> release_sock ( sk ) ; //<S2SV> current_timeo = schedule_timeout ( current_timeo ) ; //<S2SV> if ( sk != asoc -> base . sk ) //<S2SV> goto do_error ; //<S2SV> lock_sock ( sk ) ; //<S2SV> * timeo_p = current_timeo ; //<S2SV> } //<S2SV> out : //<S2SV> finish_wait ( & asoc -> wait , & wait ) ; //<S2SV> sctp_association_put ( asoc ) ; //<S2SV> return err ; //<S2SV> do_error : //<S2SV> err = - EPIPE ; //<S2SV> goto out ; //<S2SV> do_interrupted : //<S2SV> err = sock_intr_errno ( * timeo_p ) ; //<S2SV> goto out ; //<S2SV> do_nonblock : //<S2SV> err = - EAGAIN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 