static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) //<S2SV> { //<S2SV> struct uvesafb_pal_entry * entries ; //<S2SV> int shift = 16 - dac_width ; //<S2SV> int i , err = 0 ; //<S2SV> if ( info -> var . bits_per_pixel == 8 ) { //<S2SV> if ( cmap -> start + cmap -> len > info -> cmap . start + //<S2SV> info -> cmap . len || cmap -> start < info -> cmap . start ) //<S2SV> return - EINVAL ; //<S2SV> entries = kmalloc_array ( cmap -> len , sizeof ( * entries ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! entries ) //<S2SV> return - ENOMEM ; //<S2SV> for ( i = 0 ; i < cmap -> len ; i ++ ) { //<S2SV> entries [ i ] . red = cmap -> red [ i ] >> shift ; //<S2SV> entries [ i ] . green = cmap -> green [ i ] >> shift ; //<S2SV> entries [ i ] . blue = cmap -> blue [ i ] >> shift ; //<S2SV> entries [ i ] . pad = 0 ; //<S2SV> } //<S2SV> err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; //<S2SV> kfree ( entries ) ; //<S2SV> } else { //<S2SV> for ( i = 0 ; i < cmap -> len ; i ++ ) { //<S2SV> err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , //<S2SV> cmap -> green [ i ] , cmap -> blue [ i ] , //<S2SV> 0 , info ) ; //<S2SV> } //<S2SV> } //<S2SV> return err ; //<S2SV> } //<S2SV> 