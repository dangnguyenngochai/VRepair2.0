static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , //<S2SV> struct buffer_head * bh ) //<S2SV> { //<S2SV> struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) //<S2SV> ( bh -> b_data + F2FS_SUPER_OFFSET ) ; //<S2SV> struct super_block * sb = sbi -> sb ; //<S2SV> unsigned int blocksize ; //<S2SV> if ( F2FS_SUPER_MAGIC != le32_to_cpu ( raw_super -> magic ) ) { //<S2SV> f2fs_msg ( sb , KERN_INFO , //<S2SV> "Magic<S2SV_blank>Mismatch,<S2SV_blank>valid(0x%x)<S2SV_blank>-<S2SV_blank>read(0x%x)" , //<S2SV> F2FS_SUPER_MAGIC , le32_to_cpu ( raw_super -> magic ) ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( F2FS_BLKSIZE != PAGE_SIZE ) { //<S2SV> f2fs_msg ( sb , KERN_INFO , //<S2SV> "Invalid<S2SV_blank>page_cache_size<S2SV_blank>(%lu),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n" , //<S2SV> PAGE_SIZE ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> blocksize = 1 << le32_to_cpu ( raw_super -> log_blocksize ) ; //<S2SV> if ( blocksize != F2FS_BLKSIZE ) { //<S2SV> f2fs_msg ( sb , KERN_INFO , //<S2SV> "Invalid<S2SV_blank>blocksize<S2SV_blank>(%u),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n" , //<S2SV> blocksize ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( le32_to_cpu ( raw_super -> log_blocks_per_seg ) != 9 ) { //<S2SV> f2fs_msg ( sb , KERN_INFO , //<S2SV> "Invalid<S2SV_blank>log<S2SV_blank>blocks<S2SV_blank>per<S2SV_blank>segment<S2SV_blank>(%u)\\n" , //<S2SV> le32_to_cpu ( raw_super -> log_blocks_per_seg ) ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( le32_to_cpu ( raw_super -> log_sectorsize ) > //<S2SV> F2FS_MAX_LOG_SECTOR_SIZE || //<S2SV> le32_to_cpu ( raw_super -> log_sectorsize ) < //<S2SV> F2FS_MIN_LOG_SECTOR_SIZE ) { //<S2SV> f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>log<S2SV_blank>sectorsize<S2SV_blank>(%u)" , //<S2SV> le32_to_cpu ( raw_super -> log_sectorsize ) ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( le32_to_cpu ( raw_super -> log_sectors_per_block ) + //<S2SV> le32_to_cpu ( raw_super -> log_sectorsize ) != //<S2SV> F2FS_MAX_LOG_SECTOR_SIZE ) { //<S2SV> f2fs_msg ( sb , KERN_INFO , //<S2SV> "Invalid<S2SV_blank>log<S2SV_blank>sectors<S2SV_blank>per<S2SV_blank>block(%u)<S2SV_blank>log<S2SV_blank>sectorsize(%u)" , //<S2SV> le32_to_cpu ( raw_super -> log_sectors_per_block ) , //<S2SV> le32_to_cpu ( raw_super -> log_sectorsize ) ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( le32_to_cpu ( raw_super -> node_ino ) != 1 || //<S2SV> le32_to_cpu ( raw_super -> meta_ino ) != 2 || //<S2SV> le32_to_cpu ( raw_super -> root_ino ) != 3 ) { //<S2SV> f2fs_msg ( sb , KERN_INFO , //<S2SV> "Invalid<S2SV_blank>Fs<S2SV_blank>Meta<S2SV_blank>Ino:<S2SV_blank>node(%u)<S2SV_blank>meta(%u)<S2SV_blank>root(%u)" , //<S2SV> le32_to_cpu ( raw_super -> node_ino ) , //<S2SV> le32_to_cpu ( raw_super -> meta_ino ) , //<S2SV> le32_to_cpu ( raw_super -> root_ino ) ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( sanity_check_area_boundary ( sbi , bh ) ) //<S2SV> return 1 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 