int //<S2SV> xfs_setattr_nonsize ( //<S2SV> struct xfs_inode * ip , //<S2SV> struct iattr * iattr , //<S2SV> int flags ) //<S2SV> { //<S2SV> xfs_mount_t * mp = ip -> i_mount ; //<S2SV> struct inode * inode = VFS_I ( ip ) ; //<S2SV> int mask = iattr -> ia_valid ; //<S2SV> xfs_trans_t * tp ; //<S2SV> int error ; //<S2SV> kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; //<S2SV> kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; //<S2SV> struct xfs_dquot * udqp = NULL , * gdqp = NULL ; //<S2SV> struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; //<S2SV> ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; //<S2SV> if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { //<S2SV> uint qflags = 0 ; //<S2SV> if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { //<S2SV> uid = iattr -> ia_uid ; //<S2SV> qflags |= XFS_QMOPT_UQUOTA ; //<S2SV> } else { //<S2SV> uid = inode -> i_uid ; //<S2SV> } //<S2SV> if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { //<S2SV> gid = iattr -> ia_gid ; //<S2SV> qflags |= XFS_QMOPT_GQUOTA ; //<S2SV> } else { //<S2SV> gid = inode -> i_gid ; //<S2SV> } //<S2SV> ASSERT ( udqp == NULL ) ; //<S2SV> ASSERT ( gdqp == NULL ) ; //<S2SV> error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , //<S2SV> xfs_kgid_to_gid ( gid ) , //<S2SV> xfs_get_projid ( ip ) , //<S2SV> qflags , & udqp , & gdqp , NULL ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> } //<S2SV> error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 , 0 , & tp ) ; //<S2SV> if ( error ) //<S2SV> goto out_dqrele ; //<S2SV> xfs_ilock ( ip , XFS_ILOCK_EXCL ) ; //<S2SV> xfs_trans_ijoin ( tp , ip , 0 ) ; //<S2SV> if ( mask & ( ATTR_UID | ATTR_GID ) ) { //<S2SV> iuid = inode -> i_uid ; //<S2SV> igid = inode -> i_gid ; //<S2SV> gid = ( mask & ATTR_GID ) ? iattr -> ia_gid : igid ; //<S2SV> uid = ( mask & ATTR_UID ) ? iattr -> ia_uid : iuid ; //<S2SV> if ( XFS_IS_QUOTA_RUNNING ( mp ) && //<S2SV> ( ( XFS_IS_UQUOTA_ON ( mp ) && ! uid_eq ( iuid , uid ) ) || //<S2SV> ( XFS_IS_GQUOTA_ON ( mp ) && ! gid_eq ( igid , gid ) ) ) ) { //<S2SV> ASSERT ( tp ) ; //<S2SV> error = xfs_qm_vop_chown_reserve ( tp , ip , udqp , gdqp , //<S2SV> NULL , capable ( CAP_FOWNER ) ? //<S2SV> XFS_QMOPT_FORCE_RES : 0 ) ; //<S2SV> if ( error ) //<S2SV> goto out_cancel ; //<S2SV> } //<S2SV> } //<S2SV> if ( mask & ( ATTR_UID | ATTR_GID ) ) { //<S2SV> if ( ( inode -> i_mode & ( S_ISUID | S_ISGID ) ) && //<S2SV> ! capable ( CAP_FSETID ) ) //<S2SV> inode -> i_mode &= ~ ( S_ISUID | S_ISGID ) ; //<S2SV> if ( ! uid_eq ( iuid , uid ) ) { //<S2SV> if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_UQUOTA_ON ( mp ) ) { //<S2SV> ASSERT ( mask & ATTR_UID ) ; //<S2SV> ASSERT ( udqp ) ; //<S2SV> olddquot1 = xfs_qm_vop_chown ( tp , ip , //<S2SV> & ip -> i_udquot , udqp ) ; //<S2SV> } //<S2SV> ip -> i_d . di_uid = xfs_kuid_to_uid ( uid ) ; //<S2SV> inode -> i_uid = uid ; //<S2SV> } //<S2SV> if ( ! gid_eq ( igid , gid ) ) { //<S2SV> if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_GQUOTA_ON ( mp ) ) { //<S2SV> ASSERT ( xfs_sb_version_has_pquotino ( & mp -> m_sb ) || //<S2SV> ! XFS_IS_PQUOTA_ON ( mp ) ) ; //<S2SV> ASSERT ( mask & ATTR_GID ) ; //<S2SV> ASSERT ( gdqp ) ; //<S2SV> olddquot2 = xfs_qm_vop_chown ( tp , ip , //<S2SV> & ip -> i_gdquot , gdqp ) ; //<S2SV> } //<S2SV> ip -> i_d . di_gid = xfs_kgid_to_gid ( gid ) ; //<S2SV> inode -> i_gid = gid ; //<S2SV> } //<S2SV> } //<S2SV> if ( mask & ATTR_MODE ) //<S2SV> xfs_setattr_mode ( ip , iattr ) ; //<S2SV> if ( mask & ( ATTR_ATIME | ATTR_CTIME | ATTR_MTIME ) ) //<S2SV> xfs_setattr_time ( ip , iattr ) ; //<S2SV> xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; //<S2SV> XFS_STATS_INC ( mp , xs_ig_attrchg ) ; //<S2SV> if ( mp -> m_flags & XFS_MOUNT_WSYNC ) //<S2SV> xfs_trans_set_sync ( tp ) ; //<S2SV> error = xfs_trans_commit ( tp ) ; //<S2SV> xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; //<S2SV> xfs_qm_dqrele ( olddquot1 ) ; //<S2SV> xfs_qm_dqrele ( olddquot2 ) ; //<S2SV> xfs_qm_dqrele ( udqp ) ; //<S2SV> xfs_qm_dqrele ( gdqp ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> if ( ( mask & ATTR_MODE ) && ! ( flags & XFS_ATTR_NOACL ) ) { //<S2SV> error = posix_acl_chmod ( inode , inode -> i_mode ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> out_cancel : //<S2SV> xfs_trans_cancel ( tp ) ; //<S2SV> xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ; //<S2SV> out_dqrele : //<S2SV> xfs_qm_dqrele ( udqp ) ; //<S2SV> xfs_qm_dqrele ( gdqp ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 