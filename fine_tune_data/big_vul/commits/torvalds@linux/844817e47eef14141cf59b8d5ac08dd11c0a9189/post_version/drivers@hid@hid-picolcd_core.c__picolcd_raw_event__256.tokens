static int picolcd_raw_event ( struct hid_device * hdev , //<S2SV> struct hid_report * report , u8 * raw_data , int size ) //<S2SV> { //<S2SV> struct picolcd_data * data = hid_get_drvdata ( hdev ) ; //<S2SV> unsigned long flags ; //<S2SV> int ret = 0 ; //<S2SV> if ( ! data ) //<S2SV> return 1 ; //<S2SV> if ( size > 64 ) { //<S2SV> hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n" , //<S2SV> size ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( report -> id == REPORT_KEY_STATE ) { //<S2SV> if ( data -> input_keys ) //<S2SV> ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ; //<S2SV> } else if ( report -> id == REPORT_IR_DATA ) { //<S2SV> ret = picolcd_raw_cir ( data , report , raw_data + 1 , size - 1 ) ; //<S2SV> } else { //<S2SV> spin_lock_irqsave ( & data -> lock , flags ) ; //<S2SV> if ( data -> pending ) { //<S2SV> memcpy ( data -> pending -> raw_data , raw_data + 1 , size - 1 ) ; //<S2SV> data -> pending -> raw_size = size - 1 ; //<S2SV> data -> pending -> in_report = report ; //<S2SV> complete ( & data -> pending -> ready ) ; //<S2SV> } //<S2SV> spin_unlock_irqrestore ( & data -> lock , flags ) ; //<S2SV> } //<S2SV> picolcd_debug_raw_event ( data , hdev , report , raw_data , size ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> 