int tpm_open ( struct inode * inode , struct file * file ) //<S2SV> { //<S2SV> int minor = iminor ( inode ) ; //<S2SV> struct tpm_chip * chip = NULL , * pos ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> list_for_each_entry_rcu ( pos , & tpm_chip_list , list ) { //<S2SV> if ( pos -> vendor . miscdev . minor == minor ) { //<S2SV> chip = pos ; //<S2SV> get_device ( chip -> dev ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> if ( ! chip ) //<S2SV> return - ENODEV ; //<S2SV> if ( test_and_set_bit ( 0 , & chip -> is_open ) ) { //<S2SV> dev_dbg ( chip -> dev , "Another<S2SV_blank>process<S2SV_blank>owns<S2SV_blank>this<S2SV_blank>TPM\\n" ) ; //<S2SV> put_device ( chip -> dev ) ; //<S2SV> return - EBUSY ; //<S2SV> } //<S2SV> chip -> data_buffer = kzalloc ( TPM_BUFSIZE , GFP_KERNEL ) ; //<S2SV> if ( chip -> data_buffer == NULL ) { //<S2SV> clear_bit ( 0 , & chip -> is_open ) ; //<S2SV> put_device ( chip -> dev ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> atomic_set ( & chip -> data_pending , 0 ) ; //<S2SV> file -> private_data = chip ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 