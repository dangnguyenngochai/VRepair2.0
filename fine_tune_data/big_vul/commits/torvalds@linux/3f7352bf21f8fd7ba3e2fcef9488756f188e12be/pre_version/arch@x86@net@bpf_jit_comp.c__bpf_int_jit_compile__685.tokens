void bpf_int_jit_compile ( struct bpf_prog * prog ) //<S2SV> { //<S2SV> struct bpf_binary_header * header = NULL ; //<S2SV> int proglen , oldproglen = 0 ; //<S2SV> struct jit_context ctx = { } ; //<S2SV> u8 * image = NULL ; //<S2SV> int * addrs ; //<S2SV> int pass ; //<S2SV> int i ; //<S2SV> if ( ! bpf_jit_enable ) //<S2SV> return ; //<S2SV> if ( ! prog || ! prog -> len ) //<S2SV> return ; //<S2SV> addrs = kmalloc ( prog -> len * sizeof ( * addrs ) , GFP_KERNEL ) ; //<S2SV> if ( ! addrs ) //<S2SV> return ; //<S2SV> for ( proglen = 0 , i = 0 ; i < prog -> len ; i ++ ) { //<S2SV> proglen += 64 ; //<S2SV> addrs [ i ] = proglen ; //<S2SV> } //<S2SV> ctx . cleanup_addr = proglen ; //<S2SV> for ( pass = 0 ; pass < 10 ; pass ++ ) { //<S2SV> proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ; //<S2SV> if ( proglen <= 0 ) { //<S2SV> image = NULL ; //<S2SV> if ( header ) //<S2SV> bpf_jit_binary_free ( header ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( image ) { //<S2SV> if ( proglen != oldproglen ) { //<S2SV> pr_err ( "bpf_jit:<S2SV_blank>proglen=%d<S2SV_blank>!=<S2SV_blank>oldproglen=%d\\n" , //<S2SV> proglen , oldproglen ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> if ( proglen == oldproglen ) { //<S2SV> header = bpf_jit_binary_alloc ( proglen , & image , //<S2SV> 1 , jit_fill_hole ) ; //<S2SV> if ( ! header ) //<S2SV> goto out ; //<S2SV> } //<S2SV> oldproglen = proglen ; //<S2SV> } //<S2SV> if ( bpf_jit_enable > 1 ) //<S2SV> bpf_jit_dump ( prog -> len , proglen , 0 , image ) ; //<S2SV> if ( image ) { //<S2SV> bpf_flush_icache ( header , image + proglen ) ; //<S2SV> set_memory_ro ( ( unsigned long ) header , header -> pages ) ; //<S2SV> prog -> bpf_func = ( void * ) image ; //<S2SV> prog -> jited = true ; //<S2SV> } //<S2SV> out : //<S2SV> kfree ( addrs ) ; //<S2SV> } //<S2SV> 