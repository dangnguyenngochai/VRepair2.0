void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) //<S2SV> { //<S2SV> u32 data , tpr ; //<S2SV> int max_irr , max_isr ; //<S2SV> struct kvm_lapic * apic = vcpu -> arch . apic ; //<S2SV> void * vapic ; //<S2SV> apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; //<S2SV> if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) //<S2SV> return ; //<S2SV> tpr = kvm_apic_get_reg ( apic , APIC_TASKPRI ) & 0xff ; //<S2SV> max_irr = apic_find_highest_irr ( apic ) ; //<S2SV> if ( max_irr < 0 ) //<S2SV> max_irr = 0 ; //<S2SV> max_isr = apic_find_highest_isr ( apic ) ; //<S2SV> if ( max_isr < 0 ) //<S2SV> max_isr = 0 ; //<S2SV> data = ( tpr & 0xff ) | ( ( max_isr & 0xf0 ) << 8 ) | ( max_irr << 24 ) ; //<S2SV> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; //<S2SV> * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ; //<S2SV> kunmap_atomic ( vapic ) ; //<S2SV> } //<S2SV> 