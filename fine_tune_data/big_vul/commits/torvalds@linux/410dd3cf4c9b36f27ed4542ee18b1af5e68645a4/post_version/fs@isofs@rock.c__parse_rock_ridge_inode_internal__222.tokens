static int //<S2SV> parse_rock_ridge_inode_internal ( struct iso_directory_record * de , //<S2SV> struct inode * inode , int flags ) //<S2SV> { //<S2SV> int symlink_len = 0 ; //<S2SV> int cnt , sig ; //<S2SV> unsigned int reloc_block ; //<S2SV> struct inode * reloc ; //<S2SV> struct rock_ridge * rr ; //<S2SV> int rootflag ; //<S2SV> struct rock_state rs ; //<S2SV> int ret = 0 ; //<S2SV> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) //<S2SV> return 0 ; //<S2SV> init_rock_state ( & rs , inode ) ; //<S2SV> setup_rock_ridge ( de , inode , & rs ) ; //<S2SV> if ( flags & RR_REGARD_XA ) { //<S2SV> rs . chr += 14 ; //<S2SV> rs . len -= 14 ; //<S2SV> if ( rs . len < 0 ) //<S2SV> rs . len = 0 ; //<S2SV> } //<S2SV> repeat : //<S2SV> while ( rs . len > 2 ) { //<S2SV> rr = ( struct rock_ridge * ) rs . chr ; //<S2SV> if ( rr -> len < 3 ) //<S2SV> goto out ; //<S2SV> sig = isonum_721 ( rs . chr ) ; //<S2SV> if ( rock_check_overflow ( & rs , sig ) ) //<S2SV> goto eio ; //<S2SV> rs . chr += rr -> len ; //<S2SV> rs . len -= rr -> len ; //<S2SV> if ( rs . len < 0 ) //<S2SV> goto out ; //<S2SV> switch ( sig ) { //<S2SV> # ifndef CONFIG_ZISOFS //<S2SV> case SIG ( 'R' , 'R' ) : //<S2SV> if ( ( rr -> u . RR . flags [ 0 ] & //<S2SV> ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case SIG ( 'S' , 'P' ) : //<S2SV> if ( check_sp ( rr , inode ) ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> case SIG ( 'C' , 'E' ) : //<S2SV> rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; //<S2SV> rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; //<S2SV> rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; //<S2SV> break ; //<S2SV> case SIG ( 'E' , 'R' ) : //<S2SV> ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; //<S2SV> printk ( KERN_DEBUG "ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>" ) ; //<S2SV> { //<S2SV> int p ; //<S2SV> for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) //<S2SV> printk ( "%c" , rr -> u . ER . data [ p ] ) ; //<S2SV> } //<S2SV> printk ( "\\n" ) ; //<S2SV> break ; //<S2SV> case SIG ( 'P' , 'X' ) : //<S2SV> inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; //<S2SV> set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; //<S2SV> i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; //<S2SV> i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; //<S2SV> break ; //<S2SV> case SIG ( 'P' , 'N' ) : //<S2SV> { //<S2SV> int high , low ; //<S2SV> high = isonum_733 ( rr -> u . PN . dev_high ) ; //<S2SV> low = isonum_733 ( rr -> u . PN . dev_low ) ; //<S2SV> if ( ( low & ~ 0xff ) && high == 0 ) { //<S2SV> inode -> i_rdev = //<S2SV> MKDEV ( low >> 8 , low & 0xff ) ; //<S2SV> } else { //<S2SV> inode -> i_rdev = //<S2SV> MKDEV ( high , low ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case SIG ( 'T' , 'F' ) : //<S2SV> cnt = 0 ; //<S2SV> if ( rr -> u . TF . flags & TF_CREATE ) { //<S2SV> inode -> i_ctime . tv_sec = //<S2SV> iso_date ( rr -> u . TF . times [ cnt ++ ] . time , //<S2SV> 0 ) ; //<S2SV> inode -> i_ctime . tv_nsec = 0 ; //<S2SV> } //<S2SV> if ( rr -> u . TF . flags & TF_MODIFY ) { //<S2SV> inode -> i_mtime . tv_sec = //<S2SV> iso_date ( rr -> u . TF . times [ cnt ++ ] . time , //<S2SV> 0 ) ; //<S2SV> inode -> i_mtime . tv_nsec = 0 ; //<S2SV> } //<S2SV> if ( rr -> u . TF . flags & TF_ACCESS ) { //<S2SV> inode -> i_atime . tv_sec = //<S2SV> iso_date ( rr -> u . TF . times [ cnt ++ ] . time , //<S2SV> 0 ) ; //<S2SV> inode -> i_atime . tv_nsec = 0 ; //<S2SV> } //<S2SV> if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { //<S2SV> inode -> i_ctime . tv_sec = //<S2SV> iso_date ( rr -> u . TF . times [ cnt ++ ] . time , //<S2SV> 0 ) ; //<S2SV> inode -> i_ctime . tv_nsec = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> case SIG ( 'S' , 'L' ) : //<S2SV> { //<S2SV> int slen ; //<S2SV> struct SL_component * slp ; //<S2SV> struct SL_component * oldslp ; //<S2SV> slen = rr -> len - 5 ; //<S2SV> slp = & rr -> u . SL . link ; //<S2SV> inode -> i_size = symlink_len ; //<S2SV> while ( slen > 1 ) { //<S2SV> rootflag = 0 ; //<S2SV> switch ( slp -> flags & ~ 1 ) { //<S2SV> case 0 : //<S2SV> inode -> i_size += //<S2SV> slp -> len ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> inode -> i_size += 1 ; //<S2SV> break ; //<S2SV> case 4 : //<S2SV> inode -> i_size += 2 ; //<S2SV> break ; //<S2SV> case 8 : //<S2SV> rootflag = 1 ; //<S2SV> inode -> i_size += 1 ; //<S2SV> break ; //<S2SV> default : //<S2SV> printk ( "Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>" //<S2SV> "not<S2SV_blank>implemented\\n" ) ; //<S2SV> } //<S2SV> slen -= slp -> len + 2 ; //<S2SV> oldslp = slp ; //<S2SV> slp = ( struct SL_component * ) //<S2SV> ( ( ( char * ) slp ) + slp -> len + 2 ) ; //<S2SV> if ( slen < 2 ) { //<S2SV> if ( ( ( rr -> u . SL . //<S2SV> flags & 1 ) != 0 ) //<S2SV> && //<S2SV> ( ( oldslp -> //<S2SV> flags & 1 ) == 0 ) ) //<S2SV> inode -> i_size += //<S2SV> 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! rootflag //<S2SV> && ( oldslp -> flags & 1 ) == 0 ) //<S2SV> inode -> i_size += 1 ; //<S2SV> } //<S2SV> } //<S2SV> symlink_len = inode -> i_size ; //<S2SV> break ; //<S2SV> case SIG ( 'R' , 'E' ) : //<S2SV> printk ( KERN_WARNING "Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>" //<S2SV> "relocated<S2SV_blank>directory\\n" ) ; //<S2SV> goto out ; //<S2SV> case SIG ( 'C' , 'L' ) : //<S2SV> if ( flags & RR_RELOC_DE ) { //<S2SV> printk ( KERN_ERR //<S2SV> "ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>" //<S2SV> "is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> goto eio ; //<S2SV> } //<S2SV> reloc_block = isonum_733 ( rr -> u . CL . location ) ; //<S2SV> if ( reloc_block == ISOFS_I ( inode ) -> i_iget5_block && //<S2SV> ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { //<S2SV> printk ( KERN_ERR //<S2SV> "ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>" //<S2SV> "itself\\n" ) ; //<S2SV> goto eio ; //<S2SV> } //<S2SV> ISOFS_I ( inode ) -> i_first_extent = reloc_block ; //<S2SV> reloc = isofs_iget_reloc ( inode -> i_sb , reloc_block , 0 ) ; //<S2SV> if ( IS_ERR ( reloc ) ) { //<S2SV> ret = PTR_ERR ( reloc ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> inode -> i_mode = reloc -> i_mode ; //<S2SV> set_nlink ( inode , reloc -> i_nlink ) ; //<S2SV> inode -> i_uid = reloc -> i_uid ; //<S2SV> inode -> i_gid = reloc -> i_gid ; //<S2SV> inode -> i_rdev = reloc -> i_rdev ; //<S2SV> inode -> i_size = reloc -> i_size ; //<S2SV> inode -> i_blocks = reloc -> i_blocks ; //<S2SV> inode -> i_atime = reloc -> i_atime ; //<S2SV> inode -> i_ctime = reloc -> i_ctime ; //<S2SV> inode -> i_mtime = reloc -> i_mtime ; //<S2SV> iput ( reloc ) ; //<S2SV> break ; //<S2SV> # ifdef CONFIG_ZISOFS //<S2SV> case SIG ( 'Z' , 'F' ) : { //<S2SV> int algo ; //<S2SV> if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) //<S2SV> break ; //<S2SV> algo = isonum_721 ( rr -> u . ZF . algorithm ) ; //<S2SV> if ( algo == SIG ( 'p' , 'z' ) ) { //<S2SV> int block_shift = //<S2SV> isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; //<S2SV> if ( block_shift > 17 ) { //<S2SV> printk ( KERN_WARNING "isofs:<S2SV_blank>" //<S2SV> "Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>" //<S2SV> "size<S2SV_blank>of<S2SV_blank>2^%d\\n" , //<S2SV> block_shift ) ; //<S2SV> } else { //<S2SV> ISOFS_I ( inode ) -> i_file_format = //<S2SV> isofs_file_compressed ; //<S2SV> ISOFS_I ( inode ) -> i_format_parm [ 0 ] = //<S2SV> isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; //<S2SV> ISOFS_I ( inode ) -> i_format_parm [ 1 ] = //<S2SV> isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; //<S2SV> inode -> i_size = //<S2SV> isonum_733 ( rr -> u . ZF . //<S2SV> real_size ) ; //<S2SV> } //<S2SV> } else { //<S2SV> printk ( KERN_WARNING //<S2SV> "isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>" //<S2SV> "algorithm:<S2SV_blank>%c%c\\n" , //<S2SV> rr -> u . ZF . algorithm [ 0 ] , //<S2SV> rr -> u . ZF . algorithm [ 1 ] ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> # endif //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ret = rock_continue ( & rs ) ; //<S2SV> if ( ret == 0 ) //<S2SV> goto repeat ; //<S2SV> if ( ret == 1 ) //<S2SV> ret = 0 ; //<S2SV> out : //<S2SV> kfree ( rs . buffer ) ; //<S2SV> return ret ; //<S2SV> eio : //<S2SV> ret = - EIO ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 