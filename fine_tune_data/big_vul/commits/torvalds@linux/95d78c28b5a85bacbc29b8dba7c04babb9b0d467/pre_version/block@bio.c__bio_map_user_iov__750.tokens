struct bio * bio_map_user_iov ( struct request_queue * q , //<S2SV> const struct iov_iter * iter , //<S2SV> gfp_t gfp_mask ) //<S2SV> { //<S2SV> int j ; //<S2SV> int nr_pages = 0 ; //<S2SV> struct page * * pages ; //<S2SV> struct bio * bio ; //<S2SV> int cur_page = 0 ; //<S2SV> int ret , offset ; //<S2SV> struct iov_iter i ; //<S2SV> struct iovec iov ; //<S2SV> iov_for_each ( iov , i , * iter ) { //<S2SV> unsigned long uaddr = ( unsigned long ) iov . iov_base ; //<S2SV> unsigned long len = iov . iov_len ; //<S2SV> unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; //<S2SV> unsigned long start = uaddr >> PAGE_SHIFT ; //<S2SV> if ( end < start ) //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> nr_pages += end - start ; //<S2SV> if ( uaddr & queue_dma_alignment ( q ) ) //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> } //<S2SV> if ( ! nr_pages ) //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> bio = bio_kmalloc ( gfp_mask , nr_pages ) ; //<S2SV> if ( ! bio ) //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; //<S2SV> if ( ! pages ) //<S2SV> goto out ; //<S2SV> iov_for_each ( iov , i , * iter ) { //<S2SV> unsigned long uaddr = ( unsigned long ) iov . iov_base ; //<S2SV> unsigned long len = iov . iov_len ; //<S2SV> unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; //<S2SV> unsigned long start = uaddr >> PAGE_SHIFT ; //<S2SV> const int local_nr_pages = end - start ; //<S2SV> const int page_limit = cur_page + local_nr_pages ; //<S2SV> ret = get_user_pages_fast ( uaddr , local_nr_pages , //<S2SV> ( iter -> type & WRITE ) != WRITE , //<S2SV> & pages [ cur_page ] ) ; //<S2SV> if ( ret < local_nr_pages ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto out_unmap ; //<S2SV> } //<S2SV> offset = offset_in_page ( uaddr ) ; //<S2SV> for ( j = cur_page ; j < page_limit ; j ++ ) { //<S2SV> unsigned int bytes = PAGE_SIZE - offset ; //<S2SV> if ( len <= 0 ) //<S2SV> break ; //<S2SV> if ( bytes > len ) //<S2SV> bytes = len ; //<S2SV> if ( bio_add_pc_page ( q , bio , pages [ j ] , bytes , offset ) < //<S2SV> bytes ) //<S2SV> break ; //<S2SV> len -= bytes ; //<S2SV> offset = 0 ; //<S2SV> } //<S2SV> cur_page = j ; //<S2SV> while ( j < page_limit ) //<S2SV> put_page ( pages [ j ++ ] ) ; //<S2SV> } //<S2SV> kfree ( pages ) ; //<S2SV> bio_set_flag ( bio , BIO_USER_MAPPED ) ; //<S2SV> bio_get ( bio ) ; //<S2SV> return bio ; //<S2SV> out_unmap : //<S2SV> for ( j = 0 ; j < nr_pages ; j ++ ) { //<S2SV> if ( ! pages [ j ] ) //<S2SV> break ; //<S2SV> put_page ( pages [ j ] ) ; //<S2SV> } //<S2SV> out : //<S2SV> kfree ( pages ) ; //<S2SV> bio_put ( bio ) ; //<S2SV> return ERR_PTR ( ret ) ; //<S2SV> } //<S2SV> 