static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , //<S2SV> uint32_t guest_irq , bool set ) //<S2SV> { //<S2SV> struct kvm_kernel_irq_routing_entry * e ; //<S2SV> struct kvm_irq_routing_table * irq_rt ; //<S2SV> struct kvm_lapic_irq irq ; //<S2SV> struct kvm_vcpu * vcpu ; //<S2SV> struct vcpu_data vcpu_info ; //<S2SV> int idx , ret = 0 ; //<S2SV> if ( ! kvm_arch_has_assigned_device ( kvm ) || //<S2SV> ! irq_remapping_cap ( IRQ_POSTING_CAP ) || //<S2SV> ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) //<S2SV> return 0 ; //<S2SV> idx = srcu_read_lock ( & kvm -> irq_srcu ) ; //<S2SV> irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; //<S2SV> if ( guest_irq >= irq_rt -> nr_rt_entries || //<S2SV> hlist_empty ( & irq_rt -> map [ guest_irq ] ) ) { //<S2SV> pr_warn_once ( "no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n" , //<S2SV> guest_irq , irq_rt -> nr_rt_entries ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { //<S2SV> if ( e -> type != KVM_IRQ_ROUTING_MSI ) //<S2SV> continue ; //<S2SV> kvm_set_msi_irq ( kvm , e , & irq ) ; //<S2SV> if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { //<S2SV> ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> printk ( KERN_INFO //<S2SV> "failed<S2SV_blank>to<S2SV_blank>back<S2SV_blank>to<S2SV_blank>remapped<S2SV_blank>mode,<S2SV_blank>irq:<S2SV_blank>%u\\n" , //<S2SV> host_irq ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; //<S2SV> vcpu_info . vector = irq . vector ; //<S2SV> trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , //<S2SV> vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; //<S2SV> if ( set ) //<S2SV> ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; //<S2SV> else { //<S2SV> pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; //<S2SV> ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; //<S2SV> pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; //<S2SV> } //<S2SV> if ( ret < 0 ) { //<S2SV> printk ( KERN_INFO "%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>update<S2SV_blank>PI<S2SV_blank>IRTE\\n" , //<S2SV> __func__ ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> ret = 0 ; //<S2SV> out : //<S2SV> srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 