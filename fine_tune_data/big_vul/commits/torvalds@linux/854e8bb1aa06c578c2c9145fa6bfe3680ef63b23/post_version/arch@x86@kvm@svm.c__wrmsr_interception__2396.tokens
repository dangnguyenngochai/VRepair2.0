static int wrmsr_interception ( struct vcpu_svm * svm ) //<S2SV> { //<S2SV> struct msr_data msr ; //<S2SV> u32 ecx = svm -> vcpu . arch . regs [ VCPU_REGS_RCX ] ; //<S2SV> u64 data = ( svm -> vcpu . arch . regs [ VCPU_REGS_RAX ] & - 1u ) //<S2SV> | ( ( u64 ) ( svm -> vcpu . arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; //<S2SV> msr . data = data ; //<S2SV> msr . index = ecx ; //<S2SV> msr . host_initiated = false ; //<S2SV> svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; //<S2SV> if ( kvm_set_msr ( & svm -> vcpu , & msr ) ) { //<S2SV> trace_kvm_msr_write_ex ( ecx , data ) ; //<S2SV> kvm_inject_gp ( & svm -> vcpu , 0 ) ; //<S2SV> } else { //<S2SV> trace_kvm_msr_write ( ecx , data ) ; //<S2SV> skip_emulated_instruction ( & svm -> vcpu ) ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> } //<S2SV> 