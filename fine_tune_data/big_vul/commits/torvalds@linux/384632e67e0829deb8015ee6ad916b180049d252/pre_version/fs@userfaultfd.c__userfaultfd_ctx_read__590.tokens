static ssize_t userfaultfd_ctx_read ( struct userfaultfd_ctx * ctx , int no_wait , //<S2SV> struct uffd_msg * msg ) //<S2SV> { //<S2SV> ssize_t ret ; //<S2SV> DECLARE_WAITQUEUE ( wait , current ) ; //<S2SV> struct userfaultfd_wait_queue * uwq ; //<S2SV> LIST_HEAD ( fork_event ) ; //<S2SV> struct userfaultfd_ctx * fork_nctx = NULL ; //<S2SV> spin_lock ( & ctx -> fd_wqh . lock ) ; //<S2SV> __add_wait_queue ( & ctx -> fd_wqh , & wait ) ; //<S2SV> for ( ; ; ) { //<S2SV> set_current_state ( TASK_INTERRUPTIBLE ) ; //<S2SV> spin_lock ( & ctx -> fault_pending_wqh . lock ) ; //<S2SV> uwq = find_userfault ( ctx ) ; //<S2SV> if ( uwq ) { //<S2SV> write_seqcount_begin ( & ctx -> refile_seq ) ; //<S2SV> list_del ( & uwq -> wq . entry ) ; //<S2SV> __add_wait_queue ( & ctx -> fault_wqh , & uwq -> wq ) ; //<S2SV> write_seqcount_end ( & ctx -> refile_seq ) ; //<S2SV> * msg = uwq -> msg ; //<S2SV> spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; //<S2SV> ret = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; //<S2SV> spin_lock ( & ctx -> event_wqh . lock ) ; //<S2SV> uwq = find_userfault_evt ( ctx ) ; //<S2SV> if ( uwq ) { //<S2SV> * msg = uwq -> msg ; //<S2SV> if ( uwq -> msg . event == UFFD_EVENT_FORK ) { //<S2SV> fork_nctx = ( struct userfaultfd_ctx * ) //<S2SV> ( unsigned long ) //<S2SV> uwq -> msg . arg . reserved . reserved1 ; //<S2SV> list_move ( & uwq -> wq . entry , & fork_event ) ; //<S2SV> spin_unlock ( & ctx -> event_wqh . lock ) ; //<S2SV> ret = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> userfaultfd_event_complete ( ctx , uwq ) ; //<S2SV> spin_unlock ( & ctx -> event_wqh . lock ) ; //<S2SV> ret = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> spin_unlock ( & ctx -> event_wqh . lock ) ; //<S2SV> if ( signal_pending ( current ) ) { //<S2SV> ret = - ERESTARTSYS ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( no_wait ) { //<S2SV> ret = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> spin_unlock ( & ctx -> fd_wqh . lock ) ; //<S2SV> schedule ( ) ; //<S2SV> spin_lock ( & ctx -> fd_wqh . lock ) ; //<S2SV> } //<S2SV> __remove_wait_queue ( & ctx -> fd_wqh , & wait ) ; //<S2SV> __set_current_state ( TASK_RUNNING ) ; //<S2SV> spin_unlock ( & ctx -> fd_wqh . lock ) ; //<S2SV> if ( ! ret && msg -> event == UFFD_EVENT_FORK ) { //<S2SV> ret = resolve_userfault_fork ( ctx , fork_nctx , msg ) ; //<S2SV> if ( ! ret ) { //<S2SV> spin_lock ( & ctx -> event_wqh . lock ) ; //<S2SV> if ( ! list_empty ( & fork_event ) ) { //<S2SV> uwq = list_first_entry ( & fork_event , //<S2SV> typeof ( * uwq ) , //<S2SV> wq . entry ) ; //<S2SV> list_del ( & uwq -> wq . entry ) ; //<S2SV> __add_wait_queue ( & ctx -> event_wqh , & uwq -> wq ) ; //<S2SV> userfaultfd_event_complete ( ctx , uwq ) ; //<S2SV> } //<S2SV> spin_unlock ( & ctx -> event_wqh . lock ) ; //<S2SV> } //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 