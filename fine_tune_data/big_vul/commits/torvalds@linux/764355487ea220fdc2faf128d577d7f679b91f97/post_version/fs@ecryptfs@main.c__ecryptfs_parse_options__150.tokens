static int ecryptfs_parse_options ( struct ecryptfs_sb_info * sbi , char * options , //<S2SV> uid_t * check_ruid ) //<S2SV> { //<S2SV> char * p ; //<S2SV> int rc = 0 ; //<S2SV> int sig_set = 0 ; //<S2SV> int cipher_name_set = 0 ; //<S2SV> int fn_cipher_name_set = 0 ; //<S2SV> int cipher_key_bytes ; //<S2SV> int cipher_key_bytes_set = 0 ; //<S2SV> int fn_cipher_key_bytes ; //<S2SV> int fn_cipher_key_bytes_set = 0 ; //<S2SV> struct ecryptfs_mount_crypt_stat * mount_crypt_stat = //<S2SV> & sbi -> mount_crypt_stat ; //<S2SV> substring_t args [ MAX_OPT_ARGS ] ; //<S2SV> int token ; //<S2SV> char * sig_src ; //<S2SV> char * cipher_name_dst ; //<S2SV> char * cipher_name_src ; //<S2SV> char * fn_cipher_name_dst ; //<S2SV> char * fn_cipher_name_src ; //<S2SV> char * fnek_dst ; //<S2SV> char * fnek_src ; //<S2SV> char * cipher_key_bytes_src ; //<S2SV> char * fn_cipher_key_bytes_src ; //<S2SV> * check_ruid = 0 ; //<S2SV> if ( ! options ) { //<S2SV> rc = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ecryptfs_init_mount_crypt_stat ( mount_crypt_stat ) ; //<S2SV> while ( ( p = strsep ( & options , "," ) ) != NULL ) { //<S2SV> if ( ! * p ) //<S2SV> continue ; //<S2SV> token = match_token ( p , tokens , args ) ; //<S2SV> switch ( token ) { //<S2SV> case ecryptfs_opt_sig : //<S2SV> case ecryptfs_opt_ecryptfs_sig : //<S2SV> sig_src = args [ 0 ] . from ; //<S2SV> rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , //<S2SV> sig_src , 0 ) ; //<S2SV> if ( rc ) { //<S2SV> printk ( KERN_ERR "Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>" //<S2SV> "global<S2SV_blank>sig;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , rc ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> sig_set = 1 ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_cipher : //<S2SV> case ecryptfs_opt_ecryptfs_cipher : //<S2SV> cipher_name_src = args [ 0 ] . from ; //<S2SV> cipher_name_dst = //<S2SV> mount_crypt_stat -> //<S2SV> global_default_cipher_name ; //<S2SV> strncpy ( cipher_name_dst , cipher_name_src , //<S2SV> ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; //<S2SV> cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; //<S2SV> cipher_name_set = 1 ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_ecryptfs_key_bytes : //<S2SV> cipher_key_bytes_src = args [ 0 ] . from ; //<S2SV> cipher_key_bytes = //<S2SV> ( int ) simple_strtol ( cipher_key_bytes_src , //<S2SV> & cipher_key_bytes_src , 0 ) ; //<S2SV> mount_crypt_stat -> global_default_cipher_key_size = //<S2SV> cipher_key_bytes ; //<S2SV> cipher_key_bytes_set = 1 ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_passthrough : //<S2SV> mount_crypt_stat -> flags |= //<S2SV> ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_xattr_metadata : //<S2SV> mount_crypt_stat -> flags |= //<S2SV> ECRYPTFS_XATTR_METADATA_ENABLED ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_encrypted_view : //<S2SV> mount_crypt_stat -> flags |= //<S2SV> ECRYPTFS_XATTR_METADATA_ENABLED ; //<S2SV> mount_crypt_stat -> flags |= //<S2SV> ECRYPTFS_ENCRYPTED_VIEW_ENABLED ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_fnek_sig : //<S2SV> fnek_src = args [ 0 ] . from ; //<S2SV> fnek_dst = //<S2SV> mount_crypt_stat -> global_default_fnek_sig ; //<S2SV> strncpy ( fnek_dst , fnek_src , ECRYPTFS_SIG_SIZE_HEX ) ; //<S2SV> mount_crypt_stat -> global_default_fnek_sig [ //<S2SV> ECRYPTFS_SIG_SIZE_HEX ] = '\\0' ; //<S2SV> rc = ecryptfs_add_global_auth_tok ( //<S2SV> mount_crypt_stat , //<S2SV> mount_crypt_stat -> global_default_fnek_sig , //<S2SV> ECRYPTFS_AUTH_TOK_FNEK ) ; //<S2SV> if ( rc ) { //<S2SV> printk ( KERN_ERR "Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>register<S2SV_blank>" //<S2SV> "global<S2SV_blank>fnek<S2SV_blank>sig<S2SV_blank>[%s];<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , //<S2SV> mount_crypt_stat -> global_default_fnek_sig , //<S2SV> rc ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> mount_crypt_stat -> flags |= //<S2SV> ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES //<S2SV> | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ) ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_fn_cipher : //<S2SV> fn_cipher_name_src = args [ 0 ] . from ; //<S2SV> fn_cipher_name_dst = //<S2SV> mount_crypt_stat -> global_default_fn_cipher_name ; //<S2SV> strncpy ( fn_cipher_name_dst , fn_cipher_name_src , //<S2SV> ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; //<S2SV> mount_crypt_stat -> global_default_fn_cipher_name [ //<S2SV> ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\\0' ; //<S2SV> fn_cipher_name_set = 1 ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_fn_cipher_key_bytes : //<S2SV> fn_cipher_key_bytes_src = args [ 0 ] . from ; //<S2SV> fn_cipher_key_bytes = //<S2SV> ( int ) simple_strtol ( fn_cipher_key_bytes_src , //<S2SV> & fn_cipher_key_bytes_src , 0 ) ; //<S2SV> mount_crypt_stat -> global_default_fn_cipher_key_bytes = //<S2SV> fn_cipher_key_bytes ; //<S2SV> fn_cipher_key_bytes_set = 1 ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_unlink_sigs : //<S2SV> mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_mount_auth_tok_only : //<S2SV> mount_crypt_stat -> flags |= //<S2SV> ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_check_dev_ruid : //<S2SV> * check_ruid = 1 ; //<S2SV> break ; //<S2SV> case ecryptfs_opt_err : //<S2SV> default : //<S2SV> printk ( KERN_WARNING //<S2SV> "%s:<S2SV_blank>eCryptfs:<S2SV_blank>unrecognized<S2SV_blank>option<S2SV_blank>[%s]\\n" , //<S2SV> __func__ , p ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! sig_set ) { //<S2SV> rc = - EINVAL ; //<S2SV> ecryptfs_printk ( KERN_ERR , "You<S2SV_blank>must<S2SV_blank>supply<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>valid<S2SV_blank>" //<S2SV> "auth<S2SV_blank>tok<S2SV_blank>signature<S2SV_blank>as<S2SV_blank>a<S2SV_blank>mount<S2SV_blank>" //<S2SV> "parameter;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>eCryptfs<S2SV_blank>README\\n" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! cipher_name_set ) { //<S2SV> int cipher_name_len = strlen ( ECRYPTFS_DEFAULT_CIPHER ) ; //<S2SV> BUG_ON ( cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE ) ; //<S2SV> strcpy ( mount_crypt_stat -> global_default_cipher_name , //<S2SV> ECRYPTFS_DEFAULT_CIPHER ) ; //<S2SV> } //<S2SV> if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) //<S2SV> && ! fn_cipher_name_set ) //<S2SV> strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , //<S2SV> mount_crypt_stat -> global_default_cipher_name ) ; //<S2SV> if ( ! cipher_key_bytes_set ) //<S2SV> mount_crypt_stat -> global_default_cipher_key_size = 0 ; //<S2SV> if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) //<S2SV> && ! fn_cipher_key_bytes_set ) //<S2SV> mount_crypt_stat -> global_default_fn_cipher_key_bytes = //<S2SV> mount_crypt_stat -> global_default_cipher_key_size ; //<S2SV> mutex_lock ( & key_tfm_list_mutex ) ; //<S2SV> if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , //<S2SV> NULL ) ) { //<S2SV> rc = ecryptfs_add_new_key_tfm ( //<S2SV> NULL , mount_crypt_stat -> global_default_cipher_name , //<S2SV> mount_crypt_stat -> global_default_cipher_key_size ) ; //<S2SV> if ( rc ) { //<S2SV> printk ( KERN_ERR "Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>" //<S2SV> "cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>" //<S2SV> "rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , //<S2SV> mount_crypt_stat -> global_default_cipher_name , //<S2SV> mount_crypt_stat -> global_default_cipher_key_size , //<S2SV> rc ) ; //<S2SV> rc = - EINVAL ; //<S2SV> mutex_unlock ( & key_tfm_list_mutex ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) //<S2SV> && ! ecryptfs_tfm_exists ( //<S2SV> mount_crypt_stat -> global_default_fn_cipher_name , NULL ) ) { //<S2SV> rc = ecryptfs_add_new_key_tfm ( //<S2SV> NULL , mount_crypt_stat -> global_default_fn_cipher_name , //<S2SV> mount_crypt_stat -> global_default_fn_cipher_key_bytes ) ; //<S2SV> if ( rc ) { //<S2SV> printk ( KERN_ERR "Error<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>" //<S2SV> "cipher<S2SV_blank>with<S2SV_blank>name<S2SV_blank>=<S2SV_blank>[%s]<S2SV_blank>and<S2SV_blank>key<S2SV_blank>size<S2SV_blank>=<S2SV_blank>[%td];<S2SV_blank>" //<S2SV> "rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , //<S2SV> mount_crypt_stat -> global_default_fn_cipher_name , //<S2SV> mount_crypt_stat -> global_default_fn_cipher_key_bytes , //<S2SV> rc ) ; //<S2SV> rc = - EINVAL ; //<S2SV> mutex_unlock ( & key_tfm_list_mutex ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> mutex_unlock ( & key_tfm_list_mutex ) ; //<S2SV> rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ) ; //<S2SV> if ( rc ) //<S2SV> printk ( KERN_WARNING "One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>global<S2SV_blank>auth<S2SV_blank>toks<S2SV_blank>could<S2SV_blank>not<S2SV_blank>" //<S2SV> "properly<S2SV_blank>register;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , rc ) ; //<S2SV> out : //<S2SV> return rc ; //<S2SV> } //<S2SV> 