static int //<S2SV> do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) //<S2SV> { //<S2SV> unsigned char arg [ 128 ] ; //<S2SV> int ret = 0 ; //<S2SV> unsigned int copylen ; //<S2SV> struct net * net = sock_net ( sk ) ; //<S2SV> struct netns_ipvs * ipvs = net_ipvs ( net ) ; //<S2SV> BUG_ON ( ! net ) ; //<S2SV> if ( ! capable ( CAP_NET_ADMIN ) ) //<S2SV> return - EPERM ; //<S2SV> if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) //<S2SV> return - EINVAL ; //<S2SV> if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { //<S2SV> pr_err ( "get_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u\\n" , //<S2SV> * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> copylen = get_arglen [ GET_CMDID ( cmd ) ] ; //<S2SV> if ( copylen > 128 ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( arg , user , copylen ) != 0 ) //<S2SV> return - EFAULT ; //<S2SV> if ( cmd == IP_VS_SO_GET_DAEMON ) { //<S2SV> struct ip_vs_daemon_user d [ 2 ] ; //<S2SV> memset ( & d , 0 , sizeof ( d ) ) ; //<S2SV> if ( mutex_lock_interruptible ( & ipvs -> sync_mutex ) ) //<S2SV> return - ERESTARTSYS ; //<S2SV> if ( ipvs -> sync_state & IP_VS_STATE_MASTER ) { //<S2SV> d [ 0 ] . state = IP_VS_STATE_MASTER ; //<S2SV> strlcpy ( d [ 0 ] . mcast_ifn , ipvs -> master_mcast_ifn , //<S2SV> sizeof ( d [ 0 ] . mcast_ifn ) ) ; //<S2SV> d [ 0 ] . syncid = ipvs -> master_syncid ; //<S2SV> } //<S2SV> if ( ipvs -> sync_state & IP_VS_STATE_BACKUP ) { //<S2SV> d [ 1 ] . state = IP_VS_STATE_BACKUP ; //<S2SV> strlcpy ( d [ 1 ] . mcast_ifn , ipvs -> backup_mcast_ifn , //<S2SV> sizeof ( d [ 1 ] . mcast_ifn ) ) ; //<S2SV> d [ 1 ] . syncid = ipvs -> backup_syncid ; //<S2SV> } //<S2SV> if ( copy_to_user ( user , & d , sizeof ( d ) ) != 0 ) //<S2SV> ret = - EFAULT ; //<S2SV> mutex_unlock ( & ipvs -> sync_mutex ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) //<S2SV> return - ERESTARTSYS ; //<S2SV> switch ( cmd ) { //<S2SV> case IP_VS_SO_GET_VERSION : //<S2SV> { //<S2SV> char buf [ 64 ] ; //<S2SV> sprintf ( buf , "IP<S2SV_blank>Virtual<S2SV_blank>Server<S2SV_blank>version<S2SV_blank>%d.%d.%d<S2SV_blank>(size=%d)" , //<S2SV> NVERSION ( IP_VS_VERSION_CODE ) , ip_vs_conn_tab_size ) ; //<S2SV> if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> * len = strlen ( buf ) + 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case IP_VS_SO_GET_INFO : //<S2SV> { //<S2SV> struct ip_vs_getinfo info ; //<S2SV> info . version = IP_VS_VERSION_CODE ; //<S2SV> info . size = ip_vs_conn_tab_size ; //<S2SV> info . num_services = ipvs -> num_services ; //<S2SV> if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) //<S2SV> ret = - EFAULT ; //<S2SV> } //<S2SV> break ; //<S2SV> case IP_VS_SO_GET_SERVICES : //<S2SV> { //<S2SV> struct ip_vs_get_services * get ; //<S2SV> int size ; //<S2SV> get = ( struct ip_vs_get_services * ) arg ; //<S2SV> size = sizeof ( * get ) + //<S2SV> sizeof ( struct ip_vs_service_entry ) * get -> num_services ; //<S2SV> if ( * len != size ) { //<S2SV> pr_err ( "length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , * len , size ) ; //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = __ip_vs_get_service_entries ( net , get , user ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case IP_VS_SO_GET_SERVICE : //<S2SV> { //<S2SV> struct ip_vs_service_entry * entry ; //<S2SV> struct ip_vs_service * svc ; //<S2SV> union nf_inet_addr addr ; //<S2SV> entry = ( struct ip_vs_service_entry * ) arg ; //<S2SV> addr . ip = entry -> addr ; //<S2SV> if ( entry -> fwmark ) //<S2SV> svc = __ip_vs_svc_fwm_find ( net , AF_INET , entry -> fwmark ) ; //<S2SV> else //<S2SV> svc = __ip_vs_service_find ( net , AF_INET , //<S2SV> entry -> protocol , & addr , //<S2SV> entry -> port ) ; //<S2SV> if ( svc ) { //<S2SV> ip_vs_copy_service ( entry , svc ) ; //<S2SV> if ( copy_to_user ( user , entry , sizeof ( * entry ) ) != 0 ) //<S2SV> ret = - EFAULT ; //<S2SV> } else //<S2SV> ret = - ESRCH ; //<S2SV> } //<S2SV> break ; //<S2SV> case IP_VS_SO_GET_DESTS : //<S2SV> { //<S2SV> struct ip_vs_get_dests * get ; //<S2SV> int size ; //<S2SV> get = ( struct ip_vs_get_dests * ) arg ; //<S2SV> size = sizeof ( * get ) + //<S2SV> sizeof ( struct ip_vs_dest_entry ) * get -> num_dests ; //<S2SV> if ( * len != size ) { //<S2SV> pr_err ( "length:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , * len , size ) ; //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = __ip_vs_get_dest_entries ( net , get , user ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case IP_VS_SO_GET_TIMEOUT : //<S2SV> { //<S2SV> struct ip_vs_timeout_user t ; //<S2SV> memset ( & t , 0 , sizeof ( t ) ) ; //<S2SV> __ip_vs_get_timeouts ( net , & t ) ; //<S2SV> if ( copy_to_user ( user , & t , sizeof ( t ) ) != 0 ) //<S2SV> ret = - EFAULT ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> ret = - EINVAL ; //<S2SV> } //<S2SV> out : //<S2SV> mutex_unlock ( & __ip_vs_mutex ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 