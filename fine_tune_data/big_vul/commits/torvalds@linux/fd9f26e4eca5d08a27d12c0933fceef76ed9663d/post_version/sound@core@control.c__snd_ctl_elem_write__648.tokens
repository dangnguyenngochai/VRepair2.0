static int snd_ctl_elem_write ( struct snd_card * card , struct snd_ctl_file * file , //<S2SV> struct snd_ctl_elem_value * control ) //<S2SV> { //<S2SV> struct snd_kcontrol * kctl ; //<S2SV> struct snd_kcontrol_volatile * vd ; //<S2SV> unsigned int index_offset ; //<S2SV> int result ; //<S2SV> down_read ( & card -> controls_rwsem ) ; //<S2SV> kctl = snd_ctl_find_id ( card , & control -> id ) ; //<S2SV> if ( kctl == NULL ) { //<S2SV> result = - ENOENT ; //<S2SV> } else { //<S2SV> index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; //<S2SV> vd = & kctl -> vd [ index_offset ] ; //<S2SV> if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_WRITE ) || //<S2SV> kctl -> put == NULL || //<S2SV> ( file && vd -> owner && vd -> owner != file ) ) { //<S2SV> result = - EPERM ; //<S2SV> } else { //<S2SV> snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; //<S2SV> result = kctl -> put ( kctl , control ) ; //<S2SV> } //<S2SV> if ( result > 0 ) { //<S2SV> struct snd_ctl_elem_id id = control -> id ; //<S2SV> up_read ( & card -> controls_rwsem ) ; //<S2SV> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , & id ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> up_read ( & card -> controls_rwsem ) ; //<S2SV> return result ; //<S2SV> } //<S2SV> 