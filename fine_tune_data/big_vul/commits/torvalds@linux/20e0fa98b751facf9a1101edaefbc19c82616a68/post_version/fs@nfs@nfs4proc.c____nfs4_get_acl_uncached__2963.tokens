static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) //<S2SV> { //<S2SV> struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; //<S2SV> struct nfs_getaclargs args = { //<S2SV> . fh = NFS_FH ( inode ) , //<S2SV> . acl_pages = pages , //<S2SV> . acl_len = buflen , //<S2SV> } ; //<S2SV> struct nfs_getaclres res = { //<S2SV> . acl_len = buflen , //<S2SV> } ; //<S2SV> void * resp_buf ; //<S2SV> struct rpc_message msg = { //<S2SV> . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , //<S2SV> . rpc_argp = & args , //<S2SV> . rpc_resp = & res , //<S2SV> } ; //<S2SV> int ret = - ENOMEM , npages , i , acl_len = 0 ; //<S2SV> npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; //<S2SV> if ( npages == 0 ) //<S2SV> npages = 1 ; //<S2SV> for ( i = 0 ; i < npages ; i ++ ) { //<S2SV> pages [ i ] = alloc_page ( GFP_KERNEL ) ; //<S2SV> if ( ! pages [ i ] ) //<S2SV> goto out_free ; //<S2SV> } //<S2SV> if ( npages > 1 ) { //<S2SV> res . acl_scratch = alloc_page ( GFP_KERNEL ) ; //<S2SV> if ( ! res . acl_scratch ) //<S2SV> goto out_free ; //<S2SV> } //<S2SV> args . acl_len = npages * PAGE_SIZE ; //<S2SV> args . acl_pgbase = 0 ; //<S2SV> if ( buf == NULL ) //<S2SV> res . acl_flags |= NFS4_ACL_LEN_REQUEST ; //<S2SV> resp_buf = page_address ( pages [ 0 ] ) ; //<S2SV> dprintk ( "%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\n" , //<S2SV> __func__ , buf , buflen , npages , args . acl_len ) ; //<S2SV> ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , //<S2SV> & msg , & args . seq_args , & res . seq_res , 0 ) ; //<S2SV> if ( ret ) //<S2SV> goto out_free ; //<S2SV> acl_len = res . acl_len - res . acl_data_offset ; //<S2SV> if ( acl_len > args . acl_len ) //<S2SV> nfs4_write_cached_acl ( inode , NULL , acl_len ) ; //<S2SV> else //<S2SV> nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , //<S2SV> acl_len ) ; //<S2SV> if ( buf ) { //<S2SV> ret = - ERANGE ; //<S2SV> if ( acl_len > buflen ) //<S2SV> goto out_free ; //<S2SV> _copy_from_pages ( buf , pages , res . acl_data_offset , //<S2SV> acl_len ) ; //<S2SV> } //<S2SV> ret = acl_len ; //<S2SV> out_free : //<S2SV> for ( i = 0 ; i < npages ; i ++ ) //<S2SV> if ( pages [ i ] ) //<S2SV> __free_page ( pages [ i ] ) ; //<S2SV> if ( res . acl_scratch ) //<S2SV> __free_page ( res . acl_scratch ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 