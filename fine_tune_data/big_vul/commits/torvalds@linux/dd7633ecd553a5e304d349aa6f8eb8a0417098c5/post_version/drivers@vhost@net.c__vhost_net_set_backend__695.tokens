static long vhost_net_set_backend ( struct vhost_net * n , unsigned index , int fd ) //<S2SV> { //<S2SV> struct socket * sock , * oldsock ; //<S2SV> struct vhost_virtqueue * vq ; //<S2SV> struct vhost_net_virtqueue * nvq ; //<S2SV> struct vhost_net_ubuf_ref * ubufs , * oldubufs = NULL ; //<S2SV> int r ; //<S2SV> mutex_lock ( & n -> dev . mutex ) ; //<S2SV> r = vhost_dev_check_owner ( & n -> dev ) ; //<S2SV> if ( r ) //<S2SV> goto err ; //<S2SV> if ( index >= VHOST_NET_VQ_MAX ) { //<S2SV> r = - ENOBUFS ; //<S2SV> goto err ; //<S2SV> } //<S2SV> vq = & n -> vqs [ index ] . vq ; //<S2SV> nvq = & n -> vqs [ index ] ; //<S2SV> mutex_lock ( & vq -> mutex ) ; //<S2SV> if ( ! vhost_vq_access_ok ( vq ) ) { //<S2SV> r = - EFAULT ; //<S2SV> goto err_vq ; //<S2SV> } //<S2SV> sock = get_socket ( fd ) ; //<S2SV> if ( IS_ERR ( sock ) ) { //<S2SV> r = PTR_ERR ( sock ) ; //<S2SV> goto err_vq ; //<S2SV> } //<S2SV> oldsock = rcu_dereference_protected ( vq -> private_data , //<S2SV> lockdep_is_held ( & vq -> mutex ) ) ; //<S2SV> if ( sock != oldsock ) { //<S2SV> ubufs = vhost_net_ubuf_alloc ( vq , //<S2SV> sock && vhost_sock_zcopy ( sock ) ) ; //<S2SV> if ( IS_ERR ( ubufs ) ) { //<S2SV> r = PTR_ERR ( ubufs ) ; //<S2SV> goto err_ubufs ; //<S2SV> } //<S2SV> vhost_net_disable_vq ( n , vq ) ; //<S2SV> rcu_assign_pointer ( vq -> private_data , sock ) ; //<S2SV> r = vhost_init_used ( vq ) ; //<S2SV> if ( r ) //<S2SV> goto err_used ; //<S2SV> r = vhost_net_enable_vq ( n , vq ) ; //<S2SV> if ( r ) //<S2SV> goto err_used ; //<S2SV> oldubufs = nvq -> ubufs ; //<S2SV> nvq -> ubufs = ubufs ; //<S2SV> n -> tx_packets = 0 ; //<S2SV> n -> tx_zcopy_err = 0 ; //<S2SV> n -> tx_flush = false ; //<S2SV> } //<S2SV> mutex_unlock ( & vq -> mutex ) ; //<S2SV> if ( oldubufs ) { //<S2SV> vhost_net_ubuf_put_wait_and_free ( oldubufs ) ; //<S2SV> mutex_lock ( & vq -> mutex ) ; //<S2SV> vhost_zerocopy_signal_used ( n , vq ) ; //<S2SV> mutex_unlock ( & vq -> mutex ) ; //<S2SV> } //<S2SV> if ( oldsock ) { //<S2SV> vhost_net_flush_vq ( n , index ) ; //<S2SV> fput ( oldsock -> file ) ; //<S2SV> } //<S2SV> mutex_unlock ( & n -> dev . mutex ) ; //<S2SV> return 0 ; //<S2SV> err_used : //<S2SV> rcu_assign_pointer ( vq -> private_data , oldsock ) ; //<S2SV> vhost_net_enable_vq ( n , vq ) ; //<S2SV> if ( ubufs ) //<S2SV> vhost_net_ubuf_put_wait_and_free ( ubufs ) ; //<S2SV> err_ubufs : //<S2SV> fput ( sock -> file ) ; //<S2SV> err_vq : //<S2SV> mutex_unlock ( & vq -> mutex ) ; //<S2SV> err : //<S2SV> mutex_unlock ( & n -> dev . mutex ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> 