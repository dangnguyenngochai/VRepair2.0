static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , //<S2SV> loff_t len ) //<S2SV> { //<S2SV> struct inode * inode = file -> f_path . dentry -> d_inode ; //<S2SV> struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; //<S2SV> struct gfs2_inode * ip = GFS2_I ( inode ) ; //<S2SV> unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; //<S2SV> loff_t bytes , max_bytes ; //<S2SV> struct gfs2_alloc * al ; //<S2SV> int error ; //<S2SV> loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; //<S2SV> loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; //<S2SV> loff_t max_chunk_size = UINT_MAX & bsize_mask ; //<S2SV> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; //<S2SV> if ( mode & ~ FALLOC_FL_KEEP_SIZE ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> offset &= bsize_mask ; //<S2SV> len = next - offset ; //<S2SV> bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; //<S2SV> if ( ! bytes ) //<S2SV> bytes = UINT_MAX ; //<S2SV> bytes &= bsize_mask ; //<S2SV> if ( bytes == 0 ) //<S2SV> bytes = sdp -> sd_sb . sb_bsize ; //<S2SV> gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; //<S2SV> error = gfs2_glock_nq ( & ip -> i_gh ) ; //<S2SV> if ( unlikely ( error ) ) //<S2SV> goto out_uninit ; //<S2SV> if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) //<S2SV> goto out_unlock ; //<S2SV> while ( len > 0 ) { //<S2SV> if ( len < bytes ) //<S2SV> bytes = len ; //<S2SV> al = gfs2_alloc_get ( ip ) ; //<S2SV> if ( ! al ) { //<S2SV> error = - ENOMEM ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> error = gfs2_quota_lock_check ( ip ) ; //<S2SV> if ( error ) //<S2SV> goto out_alloc_put ; //<S2SV> retry : //<S2SV> gfs2_write_calc_reserv ( ip , bytes , & data_blocks , & ind_blocks ) ; //<S2SV> al -> al_requested = data_blocks + ind_blocks ; //<S2SV> error = gfs2_inplace_reserve ( ip ) ; //<S2SV> if ( error ) { //<S2SV> if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize ) { //<S2SV> bytes >>= 1 ; //<S2SV> bytes &= bsize_mask ; //<S2SV> if ( bytes == 0 ) //<S2SV> bytes = sdp -> sd_sb . sb_bsize ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> goto out_qunlock ; //<S2SV> } //<S2SV> max_bytes = bytes ; //<S2SV> calc_max_reserv ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , //<S2SV> & max_bytes , & data_blocks , & ind_blocks ) ; //<S2SV> al -> al_requested = data_blocks + ind_blocks ; //<S2SV> rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + //<S2SV> RES_RG_HDR + gfs2_rg_blocks ( ip ) ; //<S2SV> if ( gfs2_is_jdata ( ip ) ) //<S2SV> rblocks += data_blocks ? data_blocks : 1 ; //<S2SV> error = gfs2_trans_begin ( sdp , rblocks , //<S2SV> PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) ; //<S2SV> if ( error ) //<S2SV> goto out_trans_fail ; //<S2SV> error = fallocate_chunk ( inode , offset , max_bytes , mode ) ; //<S2SV> gfs2_trans_end ( sdp ) ; //<S2SV> if ( error ) //<S2SV> goto out_trans_fail ; //<S2SV> len -= max_bytes ; //<S2SV> offset += max_bytes ; //<S2SV> gfs2_inplace_release ( ip ) ; //<S2SV> gfs2_quota_unlock ( ip ) ; //<S2SV> gfs2_alloc_put ( ip ) ; //<S2SV> } //<S2SV> goto out_unlock ; //<S2SV> out_trans_fail : //<S2SV> gfs2_inplace_release ( ip ) ; //<S2SV> out_qunlock : //<S2SV> gfs2_quota_unlock ( ip ) ; //<S2SV> out_alloc_put : //<S2SV> gfs2_alloc_put ( ip ) ; //<S2SV> out_unlock : //<S2SV> gfs2_glock_dq ( & ip -> i_gh ) ; //<S2SV> out_uninit : //<S2SV> gfs2_holder_uninit ( & ip -> i_gh ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 