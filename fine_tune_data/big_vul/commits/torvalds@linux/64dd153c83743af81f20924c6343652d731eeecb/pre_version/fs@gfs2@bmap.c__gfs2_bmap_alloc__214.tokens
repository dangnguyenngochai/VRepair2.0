static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , //<S2SV> struct buffer_head * bh_map , struct metapath * mp , //<S2SV> const unsigned int sheight , //<S2SV> const unsigned int height , //<S2SV> const unsigned int maxlen ) //<S2SV> { //<S2SV> struct gfs2_inode * ip = GFS2_I ( inode ) ; //<S2SV> struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; //<S2SV> struct buffer_head * dibh = mp -> mp_bh [ 0 ] ; //<S2SV> u64 bn , dblock = 0 ; //<S2SV> unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; //<S2SV> unsigned dblks = 0 ; //<S2SV> unsigned ptrs_per_blk ; //<S2SV> const unsigned end_of_metadata = height - 1 ; //<S2SV> int eob = 0 ; //<S2SV> enum alloc_state state ; //<S2SV> __be64 * ptr ; //<S2SV> __be64 zero_bn = 0 ; //<S2SV> BUG_ON ( sheight < 1 ) ; //<S2SV> BUG_ON ( dibh == NULL ) ; //<S2SV> gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; //<S2SV> if ( height == sheight ) { //<S2SV> struct buffer_head * bh ; //<S2SV> ptr = metapointer ( end_of_metadata , mp ) ; //<S2SV> bh = mp -> mp_bh [ end_of_metadata ] ; //<S2SV> dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , //<S2SV> & eob ) ; //<S2SV> BUG_ON ( dblks < 1 ) ; //<S2SV> state = ALLOC_DATA ; //<S2SV> } else { //<S2SV> ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; //<S2SV> dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; //<S2SV> if ( height == ip -> i_height ) { //<S2SV> iblks = height - sheight ; //<S2SV> state = ALLOC_GROW_DEPTH ; //<S2SV> } else { //<S2SV> state = ALLOC_GROW_HEIGHT ; //<S2SV> iblks = height - ip -> i_height ; //<S2SV> branch_start = metapath_branch_start ( mp ) ; //<S2SV> iblks += ( height - branch_start ) ; //<S2SV> } //<S2SV> } //<S2SV> blks = dblks + iblks ; //<S2SV> i = sheight ; //<S2SV> do { //<S2SV> int error ; //<S2SV> n = blks - alloced ; //<S2SV> error = gfs2_alloc_block ( ip , & bn , & n ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> alloced += n ; //<S2SV> if ( state != ALLOC_DATA || gfs2_is_jdata ( ip ) ) //<S2SV> gfs2_trans_add_unrevoke ( sdp , bn , n ) ; //<S2SV> switch ( state ) { //<S2SV> case ALLOC_GROW_HEIGHT : //<S2SV> if ( i == 1 ) { //<S2SV> ptr = ( __be64 * ) ( dibh -> b_data + //<S2SV> sizeof ( struct gfs2_dinode ) ) ; //<S2SV> zero_bn = * ptr ; //<S2SV> } //<S2SV> for ( ; i - 1 < height - ip -> i_height && n > 0 ; i ++ , n -- ) //<S2SV> gfs2_indirect_init ( mp , ip -> i_gl , i , 0 , bn ++ ) ; //<S2SV> if ( i - 1 == height - ip -> i_height ) { //<S2SV> i -- ; //<S2SV> gfs2_buffer_copy_tail ( mp -> mp_bh [ i ] , //<S2SV> sizeof ( struct gfs2_meta_header ) , //<S2SV> dibh , sizeof ( struct gfs2_dinode ) ) ; //<S2SV> gfs2_buffer_clear_tail ( dibh , //<S2SV> sizeof ( struct gfs2_dinode ) + //<S2SV> sizeof ( __be64 ) ) ; //<S2SV> ptr = ( __be64 * ) ( mp -> mp_bh [ i ] -> b_data + //<S2SV> sizeof ( struct gfs2_meta_header ) ) ; //<S2SV> * ptr = zero_bn ; //<S2SV> state = ALLOC_GROW_DEPTH ; //<S2SV> for ( i = branch_start ; i < height ; i ++ ) { //<S2SV> if ( mp -> mp_bh [ i ] == NULL ) //<S2SV> break ; //<S2SV> brelse ( mp -> mp_bh [ i ] ) ; //<S2SV> mp -> mp_bh [ i ] = NULL ; //<S2SV> } //<S2SV> i = branch_start ; //<S2SV> } //<S2SV> if ( n == 0 ) //<S2SV> break ; //<S2SV> case ALLOC_GROW_DEPTH : //<S2SV> if ( i > 1 && i < height ) //<S2SV> gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ i - 1 ] , 1 ) ; //<S2SV> for ( ; i < height && n > 0 ; i ++ , n -- ) //<S2SV> gfs2_indirect_init ( mp , ip -> i_gl , i , //<S2SV> mp -> mp_list [ i - 1 ] , bn ++ ) ; //<S2SV> if ( i == height ) //<S2SV> state = ALLOC_DATA ; //<S2SV> if ( n == 0 ) //<S2SV> break ; //<S2SV> case ALLOC_DATA : //<S2SV> BUG_ON ( n > dblks ) ; //<S2SV> BUG_ON ( mp -> mp_bh [ end_of_metadata ] == NULL ) ; //<S2SV> gfs2_trans_add_bh ( ip -> i_gl , mp -> mp_bh [ end_of_metadata ] , 1 ) ; //<S2SV> dblks = n ; //<S2SV> ptr = metapointer ( end_of_metadata , mp ) ; //<S2SV> dblock = bn ; //<S2SV> while ( n -- > 0 ) //<S2SV> * ptr ++ = cpu_to_be64 ( bn ++ ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } while ( ( state != ALLOC_DATA ) || ! dblock ) ; //<S2SV> ip -> i_height = height ; //<S2SV> gfs2_add_inode_blocks ( & ip -> i_inode , alloced ) ; //<S2SV> gfs2_dinode_out ( ip , mp -> mp_bh [ 0 ] -> b_data ) ; //<S2SV> map_bh ( bh_map , inode -> i_sb , dblock ) ; //<S2SV> bh_map -> b_size = dblks << inode -> i_blkbits ; //<S2SV> set_buffer_new ( bh_map ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 