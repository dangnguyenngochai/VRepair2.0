static int //<S2SV> do_ip_vs_set_ctl ( struct sock * sk , int cmd , void __user * user , unsigned int len ) //<S2SV> { //<S2SV> int ret ; //<S2SV> unsigned char arg [ MAX_ARG_LEN ] ; //<S2SV> struct ip_vs_service_user * usvc_compat ; //<S2SV> struct ip_vs_service_user_kern usvc ; //<S2SV> struct ip_vs_service * svc ; //<S2SV> struct ip_vs_dest_user * udest_compat ; //<S2SV> struct ip_vs_dest_user_kern udest ; //<S2SV> if ( ! capable ( CAP_NET_ADMIN ) ) //<S2SV> return - EPERM ; //<S2SV> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { //<S2SV> pr_err ( "set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , //<S2SV> len , set_arglen [ SET_CMDID ( cmd ) ] ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( copy_from_user ( arg , user , len ) != 0 ) //<S2SV> return - EFAULT ; //<S2SV> ip_vs_use_count_inc ( ) ; //<S2SV> if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) { //<S2SV> ret = - ERESTARTSYS ; //<S2SV> goto out_dec ; //<S2SV> } //<S2SV> if ( cmd == IP_VS_SO_SET_FLUSH ) { //<S2SV> ret = ip_vs_flush ( ) ; //<S2SV> goto out_unlock ; //<S2SV> } else if ( cmd == IP_VS_SO_SET_TIMEOUT ) { //<S2SV> ret = ip_vs_set_timeout ( ( struct ip_vs_timeout_user * ) arg ) ; //<S2SV> goto out_unlock ; //<S2SV> } else if ( cmd == IP_VS_SO_SET_STARTDAEMON ) { //<S2SV> struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; //<S2SV> ret = start_sync_thread ( dm -> state , dm -> mcast_ifn , dm -> syncid ) ; //<S2SV> goto out_unlock ; //<S2SV> } else if ( cmd == IP_VS_SO_SET_STOPDAEMON ) { //<S2SV> struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; //<S2SV> ret = stop_sync_thread ( dm -> state ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> usvc_compat = ( struct ip_vs_service_user * ) arg ; //<S2SV> udest_compat = ( struct ip_vs_dest_user * ) ( usvc_compat + 1 ) ; //<S2SV> ip_vs_copy_usvc_compat ( & usvc , usvc_compat ) ; //<S2SV> ip_vs_copy_udest_compat ( & udest , udest_compat ) ; //<S2SV> if ( cmd == IP_VS_SO_SET_ZERO ) { //<S2SV> if ( ! usvc . fwmark && ! usvc . addr . ip && ! usvc . port ) { //<S2SV> ret = ip_vs_zero_all ( ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> } //<S2SV> if ( usvc . protocol != IPPROTO_TCP && usvc . protocol != IPPROTO_UDP ) { //<S2SV> pr_err ( "set_ctl:<S2SV_blank>invalid<S2SV_blank>protocol:<S2SV_blank>%d<S2SV_blank>%pI4:%d<S2SV_blank>%s\\n" , //<S2SV> usvc . protocol , & usvc . addr . ip , //<S2SV> ntohs ( usvc . port ) , usvc . sched_name ) ; //<S2SV> ret = - EFAULT ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> if ( usvc . fwmark == 0 ) //<S2SV> svc = __ip_vs_service_get ( usvc . af , usvc . protocol , //<S2SV> & usvc . addr , usvc . port ) ; //<S2SV> else //<S2SV> svc = __ip_vs_svc_fwm_get ( usvc . af , usvc . fwmark ) ; //<S2SV> if ( cmd != IP_VS_SO_SET_ADD //<S2SV> && ( svc == NULL || svc -> protocol != usvc . protocol ) ) { //<S2SV> ret = - ESRCH ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> switch ( cmd ) { //<S2SV> case IP_VS_SO_SET_ADD : //<S2SV> if ( svc != NULL ) //<S2SV> ret = - EEXIST ; //<S2SV> else //<S2SV> ret = ip_vs_add_service ( & usvc , & svc ) ; //<S2SV> break ; //<S2SV> case IP_VS_SO_SET_EDIT : //<S2SV> ret = ip_vs_edit_service ( svc , & usvc ) ; //<S2SV> break ; //<S2SV> case IP_VS_SO_SET_DEL : //<S2SV> ret = ip_vs_del_service ( svc ) ; //<S2SV> if ( ! ret ) //<S2SV> goto out_unlock ; //<S2SV> break ; //<S2SV> case IP_VS_SO_SET_ZERO : //<S2SV> ret = ip_vs_zero_service ( svc ) ; //<S2SV> break ; //<S2SV> case IP_VS_SO_SET_ADDDEST : //<S2SV> ret = ip_vs_add_dest ( svc , & udest ) ; //<S2SV> break ; //<S2SV> case IP_VS_SO_SET_EDITDEST : //<S2SV> ret = ip_vs_edit_dest ( svc , & udest ) ; //<S2SV> break ; //<S2SV> case IP_VS_SO_SET_DELDEST : //<S2SV> ret = ip_vs_del_dest ( svc , & udest ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ret = - EINVAL ; //<S2SV> } //<S2SV> if ( svc ) //<S2SV> ip_vs_service_put ( svc ) ; //<S2SV> out_unlock : //<S2SV> mutex_unlock ( & __ip_vs_mutex ) ; //<S2SV> out_dec : //<S2SV> ip_vs_use_count_dec ( ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 