static struct sk_buff * * gre_gro_receive ( struct sk_buff * * head , //<S2SV> struct sk_buff * skb ) //<S2SV> { //<S2SV> struct sk_buff * * pp = NULL ; //<S2SV> struct sk_buff * p ; //<S2SV> const struct gre_base_hdr * greh ; //<S2SV> unsigned int hlen , grehlen ; //<S2SV> unsigned int off ; //<S2SV> int flush = 1 ; //<S2SV> struct packet_offload * ptype ; //<S2SV> __be16 type ; //<S2SV> if ( NAPI_GRO_CB ( skb ) -> encap_mark ) //<S2SV> goto out ; //<S2SV> NAPI_GRO_CB ( skb ) -> encap_mark = 1 ; //<S2SV> off = skb_gro_offset ( skb ) ; //<S2SV> hlen = off + sizeof ( * greh ) ; //<S2SV> greh = skb_gro_header_fast ( skb , off ) ; //<S2SV> if ( skb_gro_header_hard ( skb , hlen ) ) { //<S2SV> greh = skb_gro_header_slow ( skb , hlen , off ) ; //<S2SV> if ( unlikely ( ! greh ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ( greh -> flags & ~ ( GRE_KEY | GRE_CSUM ) ) != 0 ) //<S2SV> goto out ; //<S2SV> type = greh -> protocol ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> ptype = gro_find_receive_by_type ( type ) ; //<S2SV> if ( ! ptype ) //<S2SV> goto out_unlock ; //<S2SV> grehlen = GRE_HEADER_SECTION ; //<S2SV> if ( greh -> flags & GRE_KEY ) //<S2SV> grehlen += GRE_HEADER_SECTION ; //<S2SV> if ( greh -> flags & GRE_CSUM ) //<S2SV> grehlen += GRE_HEADER_SECTION ; //<S2SV> hlen = off + grehlen ; //<S2SV> if ( skb_gro_header_hard ( skb , hlen ) ) { //<S2SV> greh = skb_gro_header_slow ( skb , hlen , off ) ; //<S2SV> if ( unlikely ( ! greh ) ) //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> if ( ( greh -> flags & GRE_CSUM ) && ! NAPI_GRO_CB ( skb ) -> flush ) { //<S2SV> if ( skb_gro_checksum_simple_validate ( skb ) ) //<S2SV> goto out_unlock ; //<S2SV> skb_gro_checksum_try_convert ( skb , IPPROTO_GRE , 0 , //<S2SV> null_compute_pseudo ) ; //<S2SV> } //<S2SV> for ( p = * head ; p ; p = p -> next ) { //<S2SV> const struct gre_base_hdr * greh2 ; //<S2SV> if ( ! NAPI_GRO_CB ( p ) -> same_flow ) //<S2SV> continue ; //<S2SV> greh2 = ( struct gre_base_hdr * ) ( p -> data + off ) ; //<S2SV> if ( greh2 -> flags != greh -> flags || //<S2SV> greh2 -> protocol != greh -> protocol ) { //<S2SV> NAPI_GRO_CB ( p ) -> same_flow = 0 ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( greh -> flags & GRE_KEY ) { //<S2SV> if ( * ( __be32 * ) ( greh2 + 1 ) != * ( __be32 * ) ( greh + 1 ) ) { //<S2SV> NAPI_GRO_CB ( p ) -> same_flow = 0 ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> skb_gro_pull ( skb , grehlen ) ; //<S2SV> skb_gro_postpull_rcsum ( skb , greh , grehlen ) ; //<S2SV> pp = ptype -> callbacks . gro_receive ( head , skb ) ; //<S2SV> flush = 0 ; //<S2SV> out_unlock : //<S2SV> rcu_read_unlock ( ) ; //<S2SV> out : //<S2SV> NAPI_GRO_CB ( skb ) -> flush |= flush ; //<S2SV> return pp ; //<S2SV> } //<S2SV> 