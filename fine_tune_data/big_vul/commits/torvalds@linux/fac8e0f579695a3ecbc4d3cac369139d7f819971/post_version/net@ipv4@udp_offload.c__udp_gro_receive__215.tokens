struct sk_buff * * udp_gro_receive ( struct sk_buff * * head , struct sk_buff * skb , //<S2SV> struct udphdr * uh ) //<S2SV> { //<S2SV> struct udp_offload_priv * uo_priv ; //<S2SV> struct sk_buff * p , * * pp = NULL ; //<S2SV> struct udphdr * uh2 ; //<S2SV> unsigned int off = skb_gro_offset ( skb ) ; //<S2SV> int flush = 1 ; //<S2SV> if ( NAPI_GRO_CB ( skb ) -> encap_mark || //<S2SV> ( skb -> ip_summed != CHECKSUM_PARTIAL && //<S2SV> NAPI_GRO_CB ( skb ) -> csum_cnt == 0 && //<S2SV> ! NAPI_GRO_CB ( skb ) -> csum_valid ) ) //<S2SV> goto out ; //<S2SV> NAPI_GRO_CB ( skb ) -> encap_mark = 1 ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> uo_priv = rcu_dereference ( udp_offload_base ) ; //<S2SV> for ( ; uo_priv != NULL ; uo_priv = rcu_dereference ( uo_priv -> next ) ) { //<S2SV> if ( net_eq ( read_pnet ( & uo_priv -> net ) , dev_net ( skb -> dev ) ) && //<S2SV> uo_priv -> offload -> port == uh -> dest && //<S2SV> uo_priv -> offload -> callbacks . gro_receive ) //<S2SV> goto unflush ; //<S2SV> } //<S2SV> goto out_unlock ; //<S2SV> unflush : //<S2SV> flush = 0 ; //<S2SV> for ( p = * head ; p ; p = p -> next ) { //<S2SV> if ( ! NAPI_GRO_CB ( p ) -> same_flow ) //<S2SV> continue ; //<S2SV> uh2 = ( struct udphdr * ) ( p -> data + off ) ; //<S2SV> if ( ( * ( u32 * ) & uh -> source != * ( u32 * ) & uh2 -> source ) || //<S2SV> ( ! uh -> check ^ ! uh2 -> check ) ) { //<S2SV> NAPI_GRO_CB ( p ) -> same_flow = 0 ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> skb_gro_pull ( skb , sizeof ( struct udphdr ) ) ; //<S2SV> skb_gro_postpull_rcsum ( skb , uh , sizeof ( struct udphdr ) ) ; //<S2SV> NAPI_GRO_CB ( skb ) -> proto = uo_priv -> offload -> ipproto ; //<S2SV> pp = uo_priv -> offload -> callbacks . gro_receive ( head , skb , //<S2SV> uo_priv -> offload ) ; //<S2SV> out_unlock : //<S2SV> rcu_read_unlock ( ) ; //<S2SV> out : //<S2SV> NAPI_GRO_CB ( skb ) -> flush |= flush ; //<S2SV> return pp ; //<S2SV> } //<S2SV> 