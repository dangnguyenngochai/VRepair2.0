static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) //<S2SV> { //<S2SV> struct sk_buff * * pp = NULL ; //<S2SV> struct packet_offload * ptype ; //<S2SV> __be16 type = skb -> protocol ; //<S2SV> struct list_head * head = & offload_base ; //<S2SV> int same_flow ; //<S2SV> enum gro_result ret ; //<S2SV> int grow ; //<S2SV> if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) //<S2SV> goto normal ; //<S2SV> if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) //<S2SV> goto normal ; //<S2SV> gro_list_prepare ( napi , skb ) ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> list_for_each_entry_rcu ( ptype , head , list ) { //<S2SV> if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) //<S2SV> continue ; //<S2SV> skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; //<S2SV> skb_reset_mac_len ( skb ) ; //<S2SV> NAPI_GRO_CB ( skb ) -> same_flow = 0 ; //<S2SV> NAPI_GRO_CB ( skb ) -> flush = 0 ; //<S2SV> NAPI_GRO_CB ( skb ) -> free = 0 ; //<S2SV> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; //<S2SV> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; //<S2SV> switch ( skb -> ip_summed ) { //<S2SV> case CHECKSUM_COMPLETE : //<S2SV> NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; //<S2SV> NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; //<S2SV> NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; //<S2SV> break ; //<S2SV> case CHECKSUM_UNNECESSARY : //<S2SV> NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; //<S2SV> NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; //<S2SV> NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; //<S2SV> } //<S2SV> pp = ptype -> callbacks . gro_receive ( & napi -> gro_list , skb ) ; //<S2SV> break ; //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> if ( & ptype -> list == head ) //<S2SV> goto normal ; //<S2SV> same_flow = NAPI_GRO_CB ( skb ) -> same_flow ; //<S2SV> ret = NAPI_GRO_CB ( skb ) -> free ? GRO_MERGED_FREE : GRO_MERGED ; //<S2SV> if ( pp ) { //<S2SV> struct sk_buff * nskb = * pp ; //<S2SV> * pp = nskb -> next ; //<S2SV> nskb -> next = NULL ; //<S2SV> napi_gro_complete ( nskb ) ; //<S2SV> napi -> gro_count -- ; //<S2SV> } //<S2SV> if ( same_flow ) //<S2SV> goto ok ; //<S2SV> if ( NAPI_GRO_CB ( skb ) -> flush ) //<S2SV> goto normal ; //<S2SV> if ( unlikely ( napi -> gro_count >= MAX_GRO_SKBS ) ) { //<S2SV> struct sk_buff * nskb = napi -> gro_list ; //<S2SV> while ( nskb -> next ) { //<S2SV> pp = & nskb -> next ; //<S2SV> nskb = * pp ; //<S2SV> } //<S2SV> * pp = NULL ; //<S2SV> nskb -> next = NULL ; //<S2SV> napi_gro_complete ( nskb ) ; //<S2SV> } else { //<S2SV> napi -> gro_count ++ ; //<S2SV> } //<S2SV> NAPI_GRO_CB ( skb ) -> count = 1 ; //<S2SV> NAPI_GRO_CB ( skb ) -> age = jiffies ; //<S2SV> NAPI_GRO_CB ( skb ) -> last = skb ; //<S2SV> skb_shinfo ( skb ) -> gso_size = skb_gro_len ( skb ) ; //<S2SV> skb -> next = napi -> gro_list ; //<S2SV> napi -> gro_list = skb ; //<S2SV> ret = GRO_HELD ; //<S2SV> pull : //<S2SV> grow = skb_gro_offset ( skb ) - skb_headlen ( skb ) ; //<S2SV> if ( grow > 0 ) //<S2SV> gro_pull_from_frag0 ( skb , grow ) ; //<S2SV> ok : //<S2SV> return ret ; //<S2SV> normal : //<S2SV> ret = GRO_NORMAL ; //<S2SV> goto pull ; //<S2SV> } //<S2SV> 