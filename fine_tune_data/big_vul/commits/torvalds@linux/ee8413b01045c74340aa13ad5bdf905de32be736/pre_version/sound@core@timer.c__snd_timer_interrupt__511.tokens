void snd_timer_interrupt ( struct snd_timer * timer , unsigned long ticks_left ) //<S2SV> { //<S2SV> struct snd_timer_instance * ti , * ts , * tmp ; //<S2SV> unsigned long resolution , ticks ; //<S2SV> struct list_head * p , * ack_list_head ; //<S2SV> unsigned long flags ; //<S2SV> int use_tasklet = 0 ; //<S2SV> if ( timer == NULL ) //<S2SV> return ; //<S2SV> spin_lock_irqsave ( & timer -> lock , flags ) ; //<S2SV> if ( timer -> hw . c_resolution ) //<S2SV> resolution = timer -> hw . c_resolution ( timer ) ; //<S2SV> else //<S2SV> resolution = timer -> hw . resolution ; //<S2SV> list_for_each_entry_safe ( ti , tmp , & timer -> active_list_head , //<S2SV> active_list ) { //<S2SV> if ( ! ( ti -> flags & SNDRV_TIMER_IFLG_RUNNING ) ) //<S2SV> continue ; //<S2SV> ti -> pticks += ticks_left ; //<S2SV> ti -> resolution = resolution ; //<S2SV> if ( ti -> cticks < ticks_left ) //<S2SV> ti -> cticks = 0 ; //<S2SV> else //<S2SV> ti -> cticks -= ticks_left ; //<S2SV> if ( ti -> cticks ) //<S2SV> continue ; //<S2SV> if ( ti -> flags & SNDRV_TIMER_IFLG_AUTO ) { //<S2SV> ti -> cticks = ti -> ticks ; //<S2SV> } else { //<S2SV> ti -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; //<S2SV> if ( -- timer -> running ) //<S2SV> list_del ( & ti -> active_list ) ; //<S2SV> } //<S2SV> if ( ( timer -> hw . flags & SNDRV_TIMER_HW_TASKLET ) || //<S2SV> ( ti -> flags & SNDRV_TIMER_IFLG_FAST ) ) //<S2SV> ack_list_head = & timer -> ack_list_head ; //<S2SV> else //<S2SV> ack_list_head = & timer -> sack_list_head ; //<S2SV> if ( list_empty ( & ti -> ack_list ) ) //<S2SV> list_add_tail ( & ti -> ack_list , ack_list_head ) ; //<S2SV> list_for_each_entry ( ts , & ti -> slave_active_head , active_list ) { //<S2SV> ts -> pticks = ti -> pticks ; //<S2SV> ts -> resolution = resolution ; //<S2SV> if ( list_empty ( & ts -> ack_list ) ) //<S2SV> list_add_tail ( & ts -> ack_list , ack_list_head ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) //<S2SV> snd_timer_reschedule ( timer , timer -> sticks ) ; //<S2SV> if ( timer -> running ) { //<S2SV> if ( timer -> hw . flags & SNDRV_TIMER_HW_STOP ) { //<S2SV> timer -> hw . stop ( timer ) ; //<S2SV> timer -> flags |= SNDRV_TIMER_FLG_CHANGE ; //<S2SV> } //<S2SV> if ( ! ( timer -> hw . flags & SNDRV_TIMER_HW_AUTO ) || //<S2SV> ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) ) { //<S2SV> timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; //<S2SV> timer -> hw . start ( timer ) ; //<S2SV> } //<S2SV> } else { //<S2SV> timer -> hw . stop ( timer ) ; //<S2SV> } //<S2SV> while ( ! list_empty ( & timer -> ack_list_head ) ) { //<S2SV> p = timer -> ack_list_head . next ; //<S2SV> ti = list_entry ( p , struct snd_timer_instance , ack_list ) ; //<S2SV> list_del_init ( p ) ; //<S2SV> ticks = ti -> pticks ; //<S2SV> ti -> pticks = 0 ; //<S2SV> ti -> flags |= SNDRV_TIMER_IFLG_CALLBACK ; //<S2SV> spin_unlock ( & timer -> lock ) ; //<S2SV> if ( ti -> callback ) //<S2SV> ti -> callback ( ti , resolution , ticks ) ; //<S2SV> spin_lock ( & timer -> lock ) ; //<S2SV> ti -> flags &= ~ SNDRV_TIMER_IFLG_CALLBACK ; //<S2SV> } //<S2SV> use_tasklet = ! list_empty ( & timer -> sack_list_head ) ; //<S2SV> spin_unlock_irqrestore ( & timer -> lock , flags ) ; //<S2SV> if ( use_tasklet ) //<S2SV> tasklet_schedule ( & timer -> task_queue ) ; //<S2SV> } //<S2SV> 