long do_shmat ( int shmid , char __user * shmaddr , int shmflg , //<S2SV> ulong * raddr , unsigned long shmlba ) //<S2SV> { //<S2SV> struct shmid_kernel * shp ; //<S2SV> unsigned long addr ; //<S2SV> unsigned long size ; //<S2SV> struct file * file ; //<S2SV> int err ; //<S2SV> unsigned long flags ; //<S2SV> unsigned long prot ; //<S2SV> int acc_mode ; //<S2SV> struct ipc_namespace * ns ; //<S2SV> struct shm_file_data * sfd ; //<S2SV> struct path path ; //<S2SV> fmode_t f_mode ; //<S2SV> unsigned long populate = 0 ; //<S2SV> err = - EINVAL ; //<S2SV> if ( shmid < 0 ) //<S2SV> goto out ; //<S2SV> else if ( ( addr = ( ulong ) shmaddr ) ) { //<S2SV> if ( addr & ( shmlba - 1 ) ) { //<S2SV> if ( ( shmflg & SHM_RND ) && addr >= shmlba ) //<S2SV> addr &= ~ ( shmlba - 1 ) ; //<S2SV> else //<S2SV> # ifndef __ARCH_FORCE_SHMLBA //<S2SV> if ( addr & ~ PAGE_MASK ) //<S2SV> # endif //<S2SV> goto out ; //<S2SV> } //<S2SV> flags = MAP_SHARED | MAP_FIXED ; //<S2SV> } else { //<S2SV> if ( ( shmflg & SHM_REMAP ) ) //<S2SV> goto out ; //<S2SV> flags = MAP_SHARED ; //<S2SV> } //<S2SV> if ( shmflg & SHM_RDONLY ) { //<S2SV> prot = PROT_READ ; //<S2SV> acc_mode = S_IRUGO ; //<S2SV> f_mode = FMODE_READ ; //<S2SV> } else { //<S2SV> prot = PROT_READ | PROT_WRITE ; //<S2SV> acc_mode = S_IRUGO | S_IWUGO ; //<S2SV> f_mode = FMODE_READ | FMODE_WRITE ; //<S2SV> } //<S2SV> if ( shmflg & SHM_EXEC ) { //<S2SV> prot |= PROT_EXEC ; //<S2SV> acc_mode |= S_IXUGO ; //<S2SV> } //<S2SV> ns = current -> nsproxy -> ipc_ns ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> shp = shm_obtain_object_check ( ns , shmid ) ; //<S2SV> if ( IS_ERR ( shp ) ) { //<S2SV> err = PTR_ERR ( shp ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> err = - EACCES ; //<S2SV> if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) //<S2SV> goto out_unlock ; //<S2SV> err = security_shm_shmat ( shp , shmaddr , shmflg ) ; //<S2SV> if ( err ) //<S2SV> goto out_unlock ; //<S2SV> ipc_lock_object ( & shp -> shm_perm ) ; //<S2SV> if ( ! ipc_valid_object ( & shp -> shm_perm ) ) { //<S2SV> ipc_unlock_object ( & shp -> shm_perm ) ; //<S2SV> err = - EIDRM ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> path = shp -> shm_file -> f_path ; //<S2SV> path_get ( & path ) ; //<S2SV> shp -> shm_nattch ++ ; //<S2SV> size = i_size_read ( d_inode ( path . dentry ) ) ; //<S2SV> ipc_unlock_object ( & shp -> shm_perm ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> err = - ENOMEM ; //<S2SV> sfd = kzalloc ( sizeof ( * sfd ) , GFP_KERNEL ) ; //<S2SV> if ( ! sfd ) { //<S2SV> path_put ( & path ) ; //<S2SV> goto out_nattch ; //<S2SV> } //<S2SV> file = alloc_file ( & path , f_mode , //<S2SV> is_file_hugepages ( shp -> shm_file ) ? //<S2SV> & shm_file_operations_huge : //<S2SV> & shm_file_operations ) ; //<S2SV> err = PTR_ERR ( file ) ; //<S2SV> if ( IS_ERR ( file ) ) { //<S2SV> kfree ( sfd ) ; //<S2SV> path_put ( & path ) ; //<S2SV> goto out_nattch ; //<S2SV> } //<S2SV> file -> private_data = sfd ; //<S2SV> file -> f_mapping = shp -> shm_file -> f_mapping ; //<S2SV> sfd -> id = shp -> shm_perm . id ; //<S2SV> sfd -> ns = get_ipc_ns ( ns ) ; //<S2SV> sfd -> file = shp -> shm_file ; //<S2SV> sfd -> vm_ops = NULL ; //<S2SV> err = security_mmap_file ( file , prot , flags ) ; //<S2SV> if ( err ) //<S2SV> goto out_fput ; //<S2SV> if ( down_write_killable ( & current -> mm -> mmap_sem ) ) { //<S2SV> err = - EINTR ; //<S2SV> goto out_fput ; //<S2SV> } //<S2SV> if ( addr && ! ( shmflg & SHM_REMAP ) ) { //<S2SV> err = - EINVAL ; //<S2SV> if ( addr + size < addr ) //<S2SV> goto invalid ; //<S2SV> if ( find_vma_intersection ( current -> mm , addr , addr + size ) ) //<S2SV> goto invalid ; //<S2SV> } //<S2SV> addr = do_mmap_pgoff ( file , addr , size , prot , flags , 0 , & populate , NULL ) ; //<S2SV> * raddr = addr ; //<S2SV> err = 0 ; //<S2SV> if ( IS_ERR_VALUE ( addr ) ) //<S2SV> err = ( long ) addr ; //<S2SV> invalid : //<S2SV> up_write ( & current -> mm -> mmap_sem ) ; //<S2SV> if ( populate ) //<S2SV> mm_populate ( addr , populate ) ; //<S2SV> out_fput : //<S2SV> fput ( file ) ; //<S2SV> out_nattch : //<S2SV> down_write ( & shm_ids ( ns ) . rwsem ) ; //<S2SV> shp = shm_lock ( ns , shmid ) ; //<S2SV> shp -> shm_nattch -- ; //<S2SV> if ( shm_may_destroy ( ns , shp ) ) //<S2SV> shm_destroy ( ns , shp ) ; //<S2SV> else //<S2SV> shm_unlock ( shp ) ; //<S2SV> up_write ( & shm_ids ( ns ) . rwsem ) ; //<S2SV> return err ; //<S2SV> out_unlock : //<S2SV> rcu_read_unlock ( ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 