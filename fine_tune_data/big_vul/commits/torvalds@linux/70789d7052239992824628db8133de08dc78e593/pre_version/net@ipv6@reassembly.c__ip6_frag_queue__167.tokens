static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , //<S2SV> struct frag_hdr * fhdr , int nhoff ) //<S2SV> { //<S2SV> struct sk_buff * prev , * next ; //<S2SV> struct net_device * dev ; //<S2SV> int offset , end ; //<S2SV> struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; //<S2SV> if ( fq -> q . last_in & INET_FRAG_COMPLETE ) //<S2SV> goto err ; //<S2SV> offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; //<S2SV> end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - //<S2SV> ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; //<S2SV> if ( ( unsigned int ) end > IPV6_MAXPLEN ) { //<S2SV> IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , //<S2SV> IPSTATS_MIB_INHDRERRORS ) ; //<S2SV> icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , //<S2SV> ( ( u8 * ) & fhdr -> frag_off - //<S2SV> skb_network_header ( skb ) ) ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { //<S2SV> const unsigned char * nh = skb_network_header ( skb ) ; //<S2SV> skb -> csum = csum_sub ( skb -> csum , //<S2SV> csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , //<S2SV> 0 ) ) ; //<S2SV> } //<S2SV> if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { //<S2SV> if ( end < fq -> q . len || //<S2SV> ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end != fq -> q . len ) ) //<S2SV> goto err ; //<S2SV> fq -> q . last_in |= INET_FRAG_LAST_IN ; //<S2SV> fq -> q . len = end ; //<S2SV> } else { //<S2SV> if ( end & 0x7 ) { //<S2SV> IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , //<S2SV> IPSTATS_MIB_INHDRERRORS ) ; //<S2SV> icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , //<S2SV> offsetof ( struct ipv6hdr , payload_len ) ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( end > fq -> q . len ) { //<S2SV> if ( fq -> q . last_in & INET_FRAG_LAST_IN ) //<S2SV> goto err ; //<S2SV> fq -> q . len = end ; //<S2SV> } //<S2SV> } //<S2SV> if ( end == offset ) //<S2SV> goto err ; //<S2SV> if ( ! pskb_pull ( skb , ( u8 * ) ( fhdr + 1 ) - skb -> data ) ) //<S2SV> goto err ; //<S2SV> if ( pskb_trim_rcsum ( skb , end - offset ) ) //<S2SV> goto err ; //<S2SV> prev = fq -> q . fragments_tail ; //<S2SV> if ( ! prev || FRAG6_CB ( prev ) -> offset < offset ) { //<S2SV> next = NULL ; //<S2SV> goto found ; //<S2SV> } //<S2SV> prev = NULL ; //<S2SV> for ( next = fq -> q . fragments ; next != NULL ; next = next -> next ) { //<S2SV> if ( FRAG6_CB ( next ) -> offset >= offset ) //<S2SV> break ; //<S2SV> prev = next ; //<S2SV> } //<S2SV> found : //<S2SV> if ( prev ) { //<S2SV> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; //<S2SV> if ( i > 0 ) { //<S2SV> offset += i ; //<S2SV> if ( end <= offset ) //<S2SV> goto err ; //<S2SV> if ( ! pskb_pull ( skb , i ) ) //<S2SV> goto err ; //<S2SV> if ( skb -> ip_summed != CHECKSUM_UNNECESSARY ) //<S2SV> skb -> ip_summed = CHECKSUM_NONE ; //<S2SV> } //<S2SV> } //<S2SV> while ( next && FRAG6_CB ( next ) -> offset < end ) { //<S2SV> int i = end - FRAG6_CB ( next ) -> offset ; //<S2SV> if ( i < next -> len ) { //<S2SV> if ( ! pskb_pull ( next , i ) ) //<S2SV> goto err ; //<S2SV> FRAG6_CB ( next ) -> offset += i ; //<S2SV> fq -> q . meat -= i ; //<S2SV> if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) //<S2SV> next -> ip_summed = CHECKSUM_NONE ; //<S2SV> break ; //<S2SV> } else { //<S2SV> struct sk_buff * free_it = next ; //<S2SV> next = next -> next ; //<S2SV> if ( prev ) //<S2SV> prev -> next = next ; //<S2SV> else //<S2SV> fq -> q . fragments = next ; //<S2SV> fq -> q . meat -= free_it -> len ; //<S2SV> frag_kfree_skb ( fq -> q . net , free_it ) ; //<S2SV> } //<S2SV> } //<S2SV> FRAG6_CB ( skb ) -> offset = offset ; //<S2SV> skb -> next = next ; //<S2SV> if ( ! next ) //<S2SV> fq -> q . fragments_tail = skb ; //<S2SV> if ( prev ) //<S2SV> prev -> next = skb ; //<S2SV> else //<S2SV> fq -> q . fragments = skb ; //<S2SV> dev = skb -> dev ; //<S2SV> if ( dev ) { //<S2SV> fq -> iif = dev -> ifindex ; //<S2SV> skb -> dev = NULL ; //<S2SV> } //<S2SV> fq -> q . stamp = skb -> tstamp ; //<S2SV> fq -> q . meat += skb -> len ; //<S2SV> atomic_add ( skb -> truesize , & fq -> q . net -> mem ) ; //<S2SV> if ( offset == 0 ) { //<S2SV> fq -> nhoffset = nhoff ; //<S2SV> fq -> q . last_in |= INET_FRAG_FIRST_IN ; //<S2SV> } //<S2SV> if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && //<S2SV> fq -> q . meat == fq -> q . len ) //<S2SV> return ip6_frag_reasm ( fq , prev , dev ) ; //<S2SV> write_lock ( & ip6_frags . lock ) ; //<S2SV> list_move_tail ( & fq -> q . lru_list , & fq -> q . net -> lru_list ) ; //<S2SV> write_unlock ( & ip6_frags . lock ) ; //<S2SV> return - 1 ; //<S2SV> err : //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , //<S2SV> IPSTATS_MIB_REASMFAILS ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> 