static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , //<S2SV> unsigned long arg ) //<S2SV> { //<S2SV> struct vbg_session * session = filp -> private_data ; //<S2SV> size_t returned_size , size ; //<S2SV> struct vbg_ioctl_hdr hdr ; //<S2SV> bool is_vmmdev_req ; //<S2SV> int ret = 0 ; //<S2SV> void * buf ; //<S2SV> if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( hdr . version != VBG_IOCTL_HDR_VERSION ) //<S2SV> return - EINVAL ; //<S2SV> if ( hdr . size_in < sizeof ( hdr ) || //<S2SV> ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) //<S2SV> return - EINVAL ; //<S2SV> size = max ( hdr . size_in , hdr . size_out ) ; //<S2SV> if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) //<S2SV> return - EINVAL ; //<S2SV> if ( size > SZ_16M ) //<S2SV> return - E2BIG ; //<S2SV> is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || //<S2SV> req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; //<S2SV> if ( is_vmmdev_req ) //<S2SV> buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; //<S2SV> else //<S2SV> buf = kmalloc ( size , GFP_KERNEL ) ; //<S2SV> if ( ! buf ) //<S2SV> return - ENOMEM ; //<S2SV> * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; //<S2SV> if ( copy_from_user ( buf + sizeof ( hdr ) , ( void * ) arg + sizeof ( hdr ) , //<S2SV> hdr . size_in - sizeof ( hdr ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( hdr . size_in < size ) //<S2SV> memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; //<S2SV> ret = vbg_core_ioctl ( session , req , buf ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> returned_size = ( ( struct vbg_ioctl_hdr * ) buf ) -> size_out ; //<S2SV> if ( returned_size > size ) { //<S2SV> vbg_debug ( "%s:<S2SV_blank>too<S2SV_blank>much<S2SV_blank>output<S2SV_blank>data<S2SV_blank>%zu<S2SV_blank>><S2SV_blank>%zu\\n" , //<S2SV> __func__ , returned_size , size ) ; //<S2SV> returned_size = size ; //<S2SV> } //<S2SV> if ( copy_to_user ( ( void * ) arg , buf , returned_size ) != 0 ) //<S2SV> ret = - EFAULT ; //<S2SV> out : //<S2SV> if ( is_vmmdev_req ) //<S2SV> vbg_req_free ( buf , size ) ; //<S2SV> else //<S2SV> kfree ( buf ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 