SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo __user * , //<S2SV> infop , int , options , struct rusage __user * , ru ) //<S2SV> { //<S2SV> struct rusage r ; //<S2SV> struct waitid_info info = { . status = 0 } ; //<S2SV> long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; //<S2SV> int signo = 0 ; //<S2SV> if ( err > 0 ) { //<S2SV> signo = SIGCHLD ; //<S2SV> err = 0 ; //<S2SV> } //<S2SV> if ( ! err ) { //<S2SV> if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( ! infop ) //<S2SV> return err ; //<S2SV> user_access_begin ( ) ; //<S2SV> unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; //<S2SV> unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; //<S2SV> unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; //<S2SV> unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; //<S2SV> unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; //<S2SV> unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; //<S2SV> user_access_end ( ) ; //<S2SV> return err ; //<S2SV> Efault : //<S2SV> user_access_end ( ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> 