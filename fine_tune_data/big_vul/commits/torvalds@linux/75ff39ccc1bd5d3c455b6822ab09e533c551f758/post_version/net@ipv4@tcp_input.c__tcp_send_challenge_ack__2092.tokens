static void tcp_send_challenge_ack ( struct sock * sk , const struct sk_buff * skb ) //<S2SV> { //<S2SV> static u32 challenge_timestamp ; //<S2SV> static unsigned int challenge_count ; //<S2SV> struct tcp_sock * tp = tcp_sk ( sk ) ; //<S2SV> u32 count , now ; //<S2SV> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , //<S2SV> LINUX_MIB_TCPACKSKIPPEDCHALLENGE , //<S2SV> & tp -> last_oow_ack_time ) ) //<S2SV> return ; //<S2SV> now = jiffies / HZ ; //<S2SV> if ( now != challenge_timestamp ) { //<S2SV> u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; //<S2SV> challenge_timestamp = now ; //<S2SV> WRITE_ONCE ( challenge_count , half + //<S2SV> prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; //<S2SV> } //<S2SV> count = READ_ONCE ( challenge_count ) ; //<S2SV> if ( count > 0 ) { //<S2SV> WRITE_ONCE ( challenge_count , count - 1 ) ; //<S2SV> NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK ) ; //<S2SV> tcp_send_ack ( sk ) ; //<S2SV> } //<S2SV> } //<S2SV> 