static void tcp_send_challenge_ack ( struct sock * sk , const struct sk_buff * skb ) //<S2SV> { //<S2SV> static u32 challenge_timestamp ; //<S2SV> static unsigned int challenge_count ; //<S2SV> struct tcp_sock * tp = tcp_sk ( sk ) ; //<S2SV> u32 now ; //<S2SV> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , //<S2SV> LINUX_MIB_TCPACKSKIPPEDCHALLENGE , //<S2SV> & tp -> last_oow_ack_time ) ) //<S2SV> return ; //<S2SV> now = jiffies / HZ ; //<S2SV> if ( now != challenge_timestamp ) { //<S2SV> challenge_timestamp = now ; //<S2SV> challenge_count = 0 ; //<S2SV> } //<S2SV> if ( ++ challenge_count <= sysctl_tcp_challenge_ack_limit ) { //<S2SV> NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK ) ; //<S2SV> tcp_send_ack ( sk ) ; //<S2SV> } //<S2SV> } //<S2SV> 