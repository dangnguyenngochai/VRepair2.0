static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) //<S2SV> { //<S2SV> struct tun_struct * tun ; //<S2SV> struct tun_file * tfile = file -> private_data ; //<S2SV> struct net_device * dev ; //<S2SV> int err ; //<S2SV> if ( tfile -> detached ) //<S2SV> return - EINVAL ; //<S2SV> dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; //<S2SV> if ( dev ) { //<S2SV> if ( ifr -> ifr_flags & IFF_TUN_EXCL ) //<S2SV> return - EBUSY ; //<S2SV> if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) //<S2SV> tun = netdev_priv ( dev ) ; //<S2SV> else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) //<S2SV> tun = netdev_priv ( dev ) ; //<S2SV> else //<S2SV> return - EINVAL ; //<S2SV> if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != //<S2SV> ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( tun_not_capable ( tun ) ) //<S2SV> return - EPERM ; //<S2SV> err = security_tun_dev_open ( tun -> security ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( tun -> flags & IFF_MULTI_QUEUE && //<S2SV> ( tun -> numqueues + tun -> numdisabled > 1 ) ) { //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> char * name ; //<S2SV> unsigned long flags = 0 ; //<S2SV> int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? //<S2SV> MAX_TAP_QUEUES : 1 ; //<S2SV> if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) //<S2SV> return - EPERM ; //<S2SV> err = security_tun_dev_create ( ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( ifr -> ifr_flags & IFF_TUN ) { //<S2SV> flags |= IFF_TUN ; //<S2SV> name = "tun%d" ; //<S2SV> } else if ( ifr -> ifr_flags & IFF_TAP ) { //<S2SV> flags |= IFF_TAP ; //<S2SV> name = "tap%d" ; //<S2SV> } else //<S2SV> return - EINVAL ; //<S2SV> if ( * ifr -> ifr_name ) //<S2SV> name = ifr -> ifr_name ; //<S2SV> dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , //<S2SV> NET_NAME_UNKNOWN , tun_setup , queues , //<S2SV> queues ) ; //<S2SV> if ( ! dev ) //<S2SV> return - ENOMEM ; //<S2SV> err = dev_get_valid_name ( net , dev , name ) ; //<S2SV> if ( err ) //<S2SV> goto err_free_dev ; //<S2SV> dev_net_set ( dev , net ) ; //<S2SV> dev -> rtnl_link_ops = & tun_link_ops ; //<S2SV> dev -> ifindex = tfile -> ifindex ; //<S2SV> dev -> sysfs_groups [ 0 ] = & tun_attr_group ; //<S2SV> tun = netdev_priv ( dev ) ; //<S2SV> tun -> dev = dev ; //<S2SV> tun -> flags = flags ; //<S2SV> tun -> txflt . count = 0 ; //<S2SV> tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; //<S2SV> tun -> align = NET_SKB_PAD ; //<S2SV> tun -> filter_attached = false ; //<S2SV> tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; //<S2SV> tun -> rx_batched = 0 ; //<S2SV> tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; //<S2SV> if ( ! tun -> pcpu_stats ) { //<S2SV> err = - ENOMEM ; //<S2SV> goto err_free_dev ; //<S2SV> } //<S2SV> spin_lock_init ( & tun -> lock ) ; //<S2SV> err = security_tun_dev_alloc_security ( & tun -> security ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto err_free_stat ; //<S2SV> tun_net_init ( dev ) ; //<S2SV> tun_flow_init ( tun ) ; //<S2SV> dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | //<S2SV> TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | //<S2SV> NETIF_F_HW_VLAN_STAG_TX ; //<S2SV> dev -> features = dev -> hw_features | NETIF_F_LLTX ; //<S2SV> dev -> vlan_features = dev -> features & //<S2SV> ~ ( NETIF_F_HW_VLAN_CTAG_TX | //<S2SV> NETIF_F_HW_VLAN_STAG_TX ) ; //<S2SV> INIT_LIST_HEAD ( & tun -> disabled ) ; //<S2SV> err = tun_attach ( tun , file , false ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto err_free_flow ; //<S2SV> err = register_netdevice ( tun -> dev ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto err_detach ; //<S2SV> } //<S2SV> netif_carrier_on ( tun -> dev ) ; //<S2SV> tun_debug ( KERN_INFO , tun , "tun_set_iff\\n" ) ; //<S2SV> tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | //<S2SV> ( ifr -> ifr_flags & TUN_FEATURES ) ; //<S2SV> if ( netif_running ( tun -> dev ) ) //<S2SV> netif_tx_wake_all_queues ( tun -> dev ) ; //<S2SV> strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; //<S2SV> return 0 ; //<S2SV> err_detach : //<S2SV> tun_detach_all ( dev ) ; //<S2SV> goto err_free_dev ; //<S2SV> err_free_flow : //<S2SV> tun_flow_uninit ( tun ) ; //<S2SV> security_tun_dev_free_security ( tun -> security ) ; //<S2SV> err_free_stat : //<S2SV> free_percpu ( tun -> pcpu_stats ) ; //<S2SV> err_free_dev : //<S2SV> free_netdev ( dev ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 