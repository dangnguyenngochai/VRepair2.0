long fuse_do_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , //<S2SV> unsigned int flags ) //<S2SV> { //<S2SV> struct fuse_file * ff = file -> private_data ; //<S2SV> struct fuse_conn * fc = ff -> fc ; //<S2SV> struct fuse_ioctl_in inarg = { //<S2SV> . fh = ff -> fh , //<S2SV> . cmd = cmd , //<S2SV> . arg = arg , //<S2SV> . flags = flags //<S2SV> } ; //<S2SV> struct fuse_ioctl_out outarg ; //<S2SV> struct fuse_req * req = NULL ; //<S2SV> struct page * * pages = NULL ; //<S2SV> struct page * iov_page = NULL ; //<S2SV> struct iovec * in_iov = NULL , * out_iov = NULL ; //<S2SV> unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ; //<S2SV> size_t in_size , out_size , transferred ; //<S2SV> int err ; //<S2SV> BUILD_BUG_ON ( sizeof ( struct iovec ) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE ) ; //<S2SV> err = - ENOMEM ; //<S2SV> pages = kzalloc ( sizeof ( pages [ 0 ] ) * FUSE_MAX_PAGES_PER_REQ , GFP_KERNEL ) ; //<S2SV> iov_page = alloc_page ( GFP_KERNEL ) ; //<S2SV> if ( ! pages || ! iov_page ) //<S2SV> goto out ; //<S2SV> if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) { //<S2SV> struct iovec * iov = page_address ( iov_page ) ; //<S2SV> iov -> iov_base = ( void __user * ) arg ; //<S2SV> iov -> iov_len = _IOC_SIZE ( cmd ) ; //<S2SV> if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { //<S2SV> in_iov = iov ; //<S2SV> in_iovs = 1 ; //<S2SV> } //<S2SV> if ( _IOC_DIR ( cmd ) & _IOC_READ ) { //<S2SV> out_iov = iov ; //<S2SV> out_iovs = 1 ; //<S2SV> } //<S2SV> } //<S2SV> retry : //<S2SV> inarg . in_size = in_size = iov_length ( in_iov , in_iovs ) ; //<S2SV> inarg . out_size = out_size = iov_length ( out_iov , out_iovs ) ; //<S2SV> out_size = max_t ( size_t , out_size , PAGE_SIZE ) ; //<S2SV> max_pages = DIV_ROUND_UP ( max ( in_size , out_size ) , PAGE_SIZE ) ; //<S2SV> err = - ENOMEM ; //<S2SV> if ( max_pages > FUSE_MAX_PAGES_PER_REQ ) //<S2SV> goto out ; //<S2SV> while ( num_pages < max_pages ) { //<S2SV> pages [ num_pages ] = alloc_page ( GFP_KERNEL | __GFP_HIGHMEM ) ; //<S2SV> if ( ! pages [ num_pages ] ) //<S2SV> goto out ; //<S2SV> num_pages ++ ; //<S2SV> } //<S2SV> req = fuse_get_req ( fc ) ; //<S2SV> if ( IS_ERR ( req ) ) { //<S2SV> err = PTR_ERR ( req ) ; //<S2SV> req = NULL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages ) ; //<S2SV> req -> num_pages = num_pages ; //<S2SV> req -> in . h . opcode = FUSE_IOCTL ; //<S2SV> req -> in . h . nodeid = ff -> nodeid ; //<S2SV> req -> in . numargs = 1 ; //<S2SV> req -> in . args [ 0 ] . size = sizeof ( inarg ) ; //<S2SV> req -> in . args [ 0 ] . value = & inarg ; //<S2SV> if ( in_size ) { //<S2SV> req -> in . numargs ++ ; //<S2SV> req -> in . args [ 1 ] . size = in_size ; //<S2SV> req -> in . argpages = 1 ; //<S2SV> err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , //<S2SV> false ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> } //<S2SV> req -> out . numargs = 2 ; //<S2SV> req -> out . args [ 0 ] . size = sizeof ( outarg ) ; //<S2SV> req -> out . args [ 0 ] . value = & outarg ; //<S2SV> req -> out . args [ 1 ] . size = out_size ; //<S2SV> req -> out . argpages = 1 ; //<S2SV> req -> out . argvar = 1 ; //<S2SV> fuse_request_send ( fc , req ) ; //<S2SV> err = req -> out . h . error ; //<S2SV> transferred = req -> out . args [ 1 ] . size ; //<S2SV> fuse_put_request ( fc , req ) ; //<S2SV> req = NULL ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> if ( outarg . flags & FUSE_IOCTL_RETRY ) { //<S2SV> char * vaddr ; //<S2SV> err = - EIO ; //<S2SV> if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) //<S2SV> goto out ; //<S2SV> in_iovs = outarg . in_iovs ; //<S2SV> out_iovs = outarg . out_iovs ; //<S2SV> err = - ENOMEM ; //<S2SV> if ( in_iovs > FUSE_IOCTL_MAX_IOV || //<S2SV> out_iovs > FUSE_IOCTL_MAX_IOV || //<S2SV> in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV ) //<S2SV> goto out ; //<S2SV> vaddr = kmap_atomic ( pages [ 0 ] , KM_USER0 ) ; //<S2SV> err = fuse_copy_ioctl_iovec ( page_address ( iov_page ) , vaddr , //<S2SV> transferred , in_iovs + out_iovs , //<S2SV> ( flags & FUSE_IOCTL_COMPAT ) != 0 ) ; //<S2SV> kunmap_atomic ( vaddr , KM_USER0 ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> in_iov = page_address ( iov_page ) ; //<S2SV> out_iov = in_iov + in_iovs ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> err = - EIO ; //<S2SV> if ( transferred > inarg . out_size ) //<S2SV> goto out ; //<S2SV> err = fuse_ioctl_copy_user ( pages , out_iov , out_iovs , transferred , true ) ; //<S2SV> out : //<S2SV> if ( req ) //<S2SV> fuse_put_request ( fc , req ) ; //<S2SV> if ( iov_page ) //<S2SV> __free_page ( iov_page ) ; //<S2SV> while ( num_pages ) //<S2SV> __free_page ( pages [ -- num_pages ] ) ; //<S2SV> kfree ( pages ) ; //<S2SV> return err ? err : outarg . result ; //<S2SV> } //<S2SV> 