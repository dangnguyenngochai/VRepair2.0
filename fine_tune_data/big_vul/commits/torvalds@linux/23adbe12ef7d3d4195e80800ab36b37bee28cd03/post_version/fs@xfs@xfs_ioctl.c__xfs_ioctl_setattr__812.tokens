STATIC int //<S2SV> xfs_ioctl_setattr ( //<S2SV> xfs_inode_t * ip , //<S2SV> struct fsxattr * fa , //<S2SV> int mask ) //<S2SV> { //<S2SV> struct xfs_mount * mp = ip -> i_mount ; //<S2SV> struct xfs_trans * tp ; //<S2SV> unsigned int lock_flags = 0 ; //<S2SV> struct xfs_dquot * udqp = NULL ; //<S2SV> struct xfs_dquot * pdqp = NULL ; //<S2SV> struct xfs_dquot * olddquot = NULL ; //<S2SV> int code ; //<S2SV> trace_xfs_ioctl_setattr ( ip ) ; //<S2SV> if ( mp -> m_flags & XFS_MOUNT_RDONLY ) //<S2SV> return XFS_ERROR ( EROFS ) ; //<S2SV> if ( XFS_FORCED_SHUTDOWN ( mp ) ) //<S2SV> return XFS_ERROR ( EIO ) ; //<S2SV> if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && //<S2SV> ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) //<S2SV> return XFS_ERROR ( EINVAL ) ; //<S2SV> if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) { //<S2SV> code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , //<S2SV> ip -> i_d . di_gid , fa -> fsx_projid , //<S2SV> XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ; //<S2SV> if ( code ) //<S2SV> return code ; //<S2SV> } //<S2SV> tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ; //<S2SV> code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ; //<S2SV> if ( code ) //<S2SV> goto error_return ; //<S2SV> lock_flags = XFS_ILOCK_EXCL ; //<S2SV> xfs_ilock ( ip , lock_flags ) ; //<S2SV> if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) { //<S2SV> code = XFS_ERROR ( EPERM ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> if ( mask & FSX_PROJID ) { //<S2SV> if ( current_user_ns ( ) != & init_user_ns ) { //<S2SV> code = XFS_ERROR ( EINVAL ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> if ( XFS_IS_QUOTA_RUNNING ( mp ) && //<S2SV> XFS_IS_PQUOTA_ON ( mp ) && //<S2SV> xfs_get_projid ( ip ) != fa -> fsx_projid ) { //<S2SV> ASSERT ( tp ) ; //<S2SV> code = xfs_qm_vop_chown_reserve ( tp , ip , udqp , NULL , //<S2SV> pdqp , capable ( CAP_FOWNER ) ? //<S2SV> XFS_QMOPT_FORCE_RES : 0 ) ; //<S2SV> if ( code ) //<S2SV> goto error_return ; //<S2SV> } //<S2SV> } //<S2SV> if ( mask & FSX_EXTSIZE ) { //<S2SV> if ( ip -> i_d . di_nextents && //<S2SV> ( ( ip -> i_d . di_extsize << mp -> m_sb . sb_blocklog ) != //<S2SV> fa -> fsx_extsize ) ) { //<S2SV> code = XFS_ERROR ( EINVAL ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> if ( fa -> fsx_extsize != 0 ) { //<S2SV> xfs_extlen_t size ; //<S2SV> xfs_fsblock_t extsize_fsb ; //<S2SV> extsize_fsb = XFS_B_TO_FSB ( mp , fa -> fsx_extsize ) ; //<S2SV> if ( extsize_fsb > MAXEXTLEN ) { //<S2SV> code = XFS_ERROR ( EINVAL ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> if ( XFS_IS_REALTIME_INODE ( ip ) || //<S2SV> ( ( mask & FSX_XFLAGS ) && //<S2SV> ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) ) { //<S2SV> size = mp -> m_sb . sb_rextsize << //<S2SV> mp -> m_sb . sb_blocklog ; //<S2SV> } else { //<S2SV> size = mp -> m_sb . sb_blocksize ; //<S2SV> if ( extsize_fsb > mp -> m_sb . sb_agblocks / 2 ) { //<S2SV> code = XFS_ERROR ( EINVAL ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> } //<S2SV> if ( fa -> fsx_extsize % size ) { //<S2SV> code = XFS_ERROR ( EINVAL ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( mask & FSX_XFLAGS ) { //<S2SV> if ( ( ip -> i_d . di_nextents || ip -> i_delayed_blks ) && //<S2SV> ( XFS_IS_REALTIME_INODE ( ip ) ) != //<S2SV> ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { //<S2SV> code = XFS_ERROR ( EINVAL ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> if ( ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { //<S2SV> if ( ( mp -> m_sb . sb_rblocks == 0 ) || //<S2SV> ( mp -> m_sb . sb_rextsize == 0 ) || //<S2SV> ( ip -> i_d . di_extsize % mp -> m_sb . sb_rextsize ) ) { //<S2SV> code = XFS_ERROR ( EINVAL ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ip -> i_d . di_flags & //<S2SV> ( XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND ) || //<S2SV> ( fa -> fsx_xflags & //<S2SV> ( XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND ) ) ) && //<S2SV> ! capable ( CAP_LINUX_IMMUTABLE ) ) { //<S2SV> code = XFS_ERROR ( EPERM ) ; //<S2SV> goto error_return ; //<S2SV> } //<S2SV> } //<S2SV> xfs_trans_ijoin ( tp , ip , 0 ) ; //<S2SV> if ( mask & FSX_PROJID ) { //<S2SV> if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && //<S2SV> ! capable_wrt_inode_uidgid ( VFS_I ( ip ) , CAP_FSETID ) ) //<S2SV> ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ; //<S2SV> if ( xfs_get_projid ( ip ) != fa -> fsx_projid ) { //<S2SV> if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) ) { //<S2SV> olddquot = xfs_qm_vop_chown ( tp , ip , //<S2SV> & ip -> i_pdquot , pdqp ) ; //<S2SV> } //<S2SV> xfs_set_projid ( ip , fa -> fsx_projid ) ; //<S2SV> if ( ip -> i_d . di_version == 1 ) //<S2SV> xfs_bump_ino_vers2 ( tp , ip ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( mask & FSX_EXTSIZE ) //<S2SV> ip -> i_d . di_extsize = fa -> fsx_extsize >> mp -> m_sb . sb_blocklog ; //<S2SV> if ( mask & FSX_XFLAGS ) { //<S2SV> xfs_set_diflags ( ip , fa -> fsx_xflags ) ; //<S2SV> xfs_diflags_to_linux ( ip ) ; //<S2SV> } //<S2SV> xfs_trans_ichgtime ( tp , ip , XFS_ICHGTIME_CHG ) ; //<S2SV> xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; //<S2SV> XFS_STATS_INC ( xs_ig_attrchg ) ; //<S2SV> if ( mp -> m_flags & XFS_MOUNT_WSYNC ) //<S2SV> xfs_trans_set_sync ( tp ) ; //<S2SV> code = xfs_trans_commit ( tp , 0 ) ; //<S2SV> xfs_iunlock ( ip , lock_flags ) ; //<S2SV> xfs_qm_dqrele ( olddquot ) ; //<S2SV> xfs_qm_dqrele ( udqp ) ; //<S2SV> xfs_qm_dqrele ( pdqp ) ; //<S2SV> return code ; //<S2SV> error_return : //<S2SV> xfs_qm_dqrele ( udqp ) ; //<S2SV> xfs_qm_dqrele ( pdqp ) ; //<S2SV> xfs_trans_cancel ( tp , 0 ) ; //<S2SV> if ( lock_flags ) //<S2SV> xfs_iunlock ( ip , lock_flags ) ; //<S2SV> return code ; //<S2SV> } //<S2SV> 