static void balloon_process ( struct work_struct * work ) //<S2SV> { //<S2SV> enum bp_state state = BP_DONE ; //<S2SV> long credit ; //<S2SV> do { //<S2SV> mutex_lock ( & balloon_mutex ) ; //<S2SV> credit = current_credit ( ) ; //<S2SV> if ( credit > 0 ) { //<S2SV> if ( balloon_is_inflated ( ) ) //<S2SV> state = increase_reservation ( credit ) ; //<S2SV> else //<S2SV> state = reserve_additional_memory ( ) ; //<S2SV> } //<S2SV> if ( credit < 0 ) { //<S2SV> long n_pages ; //<S2SV> n_pages = min ( - credit , si_mem_available ( ) ) ; //<S2SV> state = decrease_reservation ( n_pages , GFP_BALLOON ) ; //<S2SV> if ( state == BP_DONE && n_pages != - credit && //<S2SV> n_pages < totalreserve_pages ) //<S2SV> state = BP_EAGAIN ; //<S2SV> } //<S2SV> state = update_schedule ( state ) ; //<S2SV> mutex_unlock ( & balloon_mutex ) ; //<S2SV> cond_resched ( ) ; //<S2SV> } while ( credit && state == BP_DONE ) ; //<S2SV> if ( state == BP_EAGAIN ) //<S2SV> schedule_delayed_work ( & balloon_worker , balloon_stats . schedule_delay * HZ ) ; //<S2SV> } //<S2SV> 