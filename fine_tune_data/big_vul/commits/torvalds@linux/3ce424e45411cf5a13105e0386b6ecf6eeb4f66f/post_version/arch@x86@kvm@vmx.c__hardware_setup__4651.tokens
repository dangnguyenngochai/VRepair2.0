static __init int hardware_setup ( void ) //<S2SV> { //<S2SV> int r = - ENOMEM , i , msr ; //<S2SV> rdmsrl_safe ( MSR_EFER , & host_efer ) ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( vmx_msr_index ) ; ++ i ) //<S2SV> kvm_define_shared_msr ( i , vmx_msr_index [ i ] ) ; //<S2SV> vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_io_bitmap_a ) //<S2SV> return r ; //<S2SV> vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_io_bitmap_b ) //<S2SV> goto out ; //<S2SV> vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_msr_bitmap_legacy ) //<S2SV> goto out1 ; //<S2SV> vmx_msr_bitmap_legacy_x2apic = //<S2SV> ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_msr_bitmap_legacy_x2apic ) //<S2SV> goto out2 ; //<S2SV> vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_msr_bitmap_longmode ) //<S2SV> goto out3 ; //<S2SV> vmx_msr_bitmap_longmode_x2apic = //<S2SV> ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_msr_bitmap_longmode_x2apic ) //<S2SV> goto out4 ; //<S2SV> if ( nested ) { //<S2SV> vmx_msr_bitmap_nested = //<S2SV> ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_msr_bitmap_nested ) //<S2SV> goto out5 ; //<S2SV> } //<S2SV> vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_vmread_bitmap ) //<S2SV> goto out6 ; //<S2SV> vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; //<S2SV> if ( ! vmx_vmwrite_bitmap ) //<S2SV> goto out7 ; //<S2SV> memset ( vmx_vmread_bitmap , 0xff , PAGE_SIZE ) ; //<S2SV> memset ( vmx_vmwrite_bitmap , 0xff , PAGE_SIZE ) ; //<S2SV> memset ( vmx_io_bitmap_a , 0xff , PAGE_SIZE ) ; //<S2SV> clear_bit ( 0x80 , vmx_io_bitmap_a ) ; //<S2SV> memset ( vmx_io_bitmap_b , 0xff , PAGE_SIZE ) ; //<S2SV> memset ( vmx_msr_bitmap_legacy , 0xff , PAGE_SIZE ) ; //<S2SV> memset ( vmx_msr_bitmap_longmode , 0xff , PAGE_SIZE ) ; //<S2SV> if ( nested ) //<S2SV> memset ( vmx_msr_bitmap_nested , 0xff , PAGE_SIZE ) ; //<S2SV> if ( setup_vmcs_config ( & vmcs_config ) < 0 ) { //<S2SV> r = - EIO ; //<S2SV> goto out8 ; //<S2SV> } //<S2SV> if ( boot_cpu_has ( X86_FEATURE_NX ) ) //<S2SV> kvm_enable_efer_bits ( EFER_NX ) ; //<S2SV> if ( ! cpu_has_vmx_vpid ( ) ) //<S2SV> enable_vpid = 0 ; //<S2SV> if ( ! cpu_has_vmx_shadow_vmcs ( ) ) //<S2SV> enable_shadow_vmcs = 0 ; //<S2SV> if ( enable_shadow_vmcs ) //<S2SV> init_vmcs_shadow_fields ( ) ; //<S2SV> if ( ! cpu_has_vmx_ept ( ) || //<S2SV> ! cpu_has_vmx_ept_4levels ( ) ) { //<S2SV> enable_ept = 0 ; //<S2SV> enable_unrestricted_guest = 0 ; //<S2SV> enable_ept_ad_bits = 0 ; //<S2SV> } //<S2SV> if ( ! cpu_has_vmx_ept_ad_bits ( ) ) //<S2SV> enable_ept_ad_bits = 0 ; //<S2SV> if ( ! cpu_has_vmx_unrestricted_guest ( ) ) //<S2SV> enable_unrestricted_guest = 0 ; //<S2SV> if ( ! cpu_has_vmx_flexpriority ( ) ) //<S2SV> flexpriority_enabled = 0 ; //<S2SV> if ( ! flexpriority_enabled ) //<S2SV> kvm_x86_ops -> set_apic_access_page_addr = NULL ; //<S2SV> if ( ! cpu_has_vmx_tpr_shadow ( ) ) //<S2SV> kvm_x86_ops -> update_cr8_intercept = NULL ; //<S2SV> if ( enable_ept && ! cpu_has_vmx_ept_2m_page ( ) ) //<S2SV> kvm_disable_largepages ( ) ; //<S2SV> if ( ! cpu_has_vmx_ple ( ) ) //<S2SV> ple_gap = 0 ; //<S2SV> if ( ! cpu_has_vmx_apicv ( ) ) //<S2SV> enable_apicv = 0 ; //<S2SV> if ( cpu_has_vmx_tsc_scaling ( ) ) { //<S2SV> kvm_has_tsc_control = true ; //<S2SV> kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX ; //<S2SV> kvm_tsc_scaling_ratio_frac_bits = 48 ; //<S2SV> } //<S2SV> vmx_disable_intercept_for_msr ( MSR_FS_BASE , false ) ; //<S2SV> vmx_disable_intercept_for_msr ( MSR_GS_BASE , false ) ; //<S2SV> vmx_disable_intercept_for_msr ( MSR_KERNEL_GS_BASE , true ) ; //<S2SV> vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_CS , false ) ; //<S2SV> vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_ESP , false ) ; //<S2SV> vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false ) ; //<S2SV> vmx_disable_intercept_for_msr ( MSR_IA32_BNDCFGS , true ) ; //<S2SV> memcpy ( vmx_msr_bitmap_legacy_x2apic , //<S2SV> vmx_msr_bitmap_legacy , PAGE_SIZE ) ; //<S2SV> memcpy ( vmx_msr_bitmap_longmode_x2apic , //<S2SV> vmx_msr_bitmap_longmode , PAGE_SIZE ) ; //<S2SV> set_bit ( 0 , vmx_vpid_bitmap ) ; //<S2SV> for ( msr = 0x800 ; msr <= 0x8ff ; msr ++ ) //<S2SV> vmx_disable_intercept_msr_read_x2apic ( msr ) ; //<S2SV> vmx_enable_intercept_msr_read_x2apic ( 0x802 ) ; //<S2SV> vmx_enable_intercept_msr_read_x2apic ( 0x839 ) ; //<S2SV> vmx_disable_intercept_msr_write_x2apic ( 0x808 ) ; //<S2SV> vmx_disable_intercept_msr_write_x2apic ( 0x80b ) ; //<S2SV> vmx_disable_intercept_msr_write_x2apic ( 0x83f ) ; //<S2SV> if ( enable_ept ) { //<S2SV> kvm_mmu_set_mask_ptes ( 0ull , //<S2SV> ( enable_ept_ad_bits ) ? VMX_EPT_ACCESS_BIT : 0ull , //<S2SV> ( enable_ept_ad_bits ) ? VMX_EPT_DIRTY_BIT : 0ull , //<S2SV> 0ull , VMX_EPT_EXECUTABLE_MASK ) ; //<S2SV> ept_set_mmio_spte_mask ( ) ; //<S2SV> kvm_enable_tdp ( ) ; //<S2SV> } else //<S2SV> kvm_disable_tdp ( ) ; //<S2SV> update_ple_window_actual_max ( ) ; //<S2SV> if ( ! enable_ept || ! enable_ept_ad_bits || ! cpu_has_vmx_pml ( ) ) //<S2SV> enable_pml = 0 ; //<S2SV> if ( ! enable_pml ) { //<S2SV> kvm_x86_ops -> slot_enable_log_dirty = NULL ; //<S2SV> kvm_x86_ops -> slot_disable_log_dirty = NULL ; //<S2SV> kvm_x86_ops -> flush_log_dirty = NULL ; //<S2SV> kvm_x86_ops -> enable_log_dirty_pt_masked = NULL ; //<S2SV> } //<S2SV> kvm_set_posted_intr_wakeup_handler ( wakeup_handler ) ; //<S2SV> return alloc_kvm_area ( ) ; //<S2SV> out8 : //<S2SV> free_page ( ( unsigned long ) vmx_vmwrite_bitmap ) ; //<S2SV> out7 : //<S2SV> free_page ( ( unsigned long ) vmx_vmread_bitmap ) ; //<S2SV> out6 : //<S2SV> if ( nested ) //<S2SV> free_page ( ( unsigned long ) vmx_msr_bitmap_nested ) ; //<S2SV> out5 : //<S2SV> free_page ( ( unsigned long ) vmx_msr_bitmap_longmode_x2apic ) ; //<S2SV> out4 : //<S2SV> free_page ( ( unsigned long ) vmx_msr_bitmap_longmode ) ; //<S2SV> out3 : //<S2SV> free_page ( ( unsigned long ) vmx_msr_bitmap_legacy_x2apic ) ; //<S2SV> out2 : //<S2SV> free_page ( ( unsigned long ) vmx_msr_bitmap_legacy ) ; //<S2SV> out1 : //<S2SV> free_page ( ( unsigned long ) vmx_io_bitmap_b ) ; //<S2SV> out : //<S2SV> free_page ( ( unsigned long ) vmx_io_bitmap_a ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> 