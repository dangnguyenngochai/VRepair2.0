struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , //<S2SV> const u8 * addr , gfp_t gfp ) //<S2SV> { //<S2SV> struct ieee80211_local * local = sdata -> local ; //<S2SV> struct sta_info * sta ; //<S2SV> struct timespec uptime ; //<S2SV> struct ieee80211_tx_latency_bin_ranges * tx_latency ; //<S2SV> int i ; //<S2SV> sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; //<S2SV> if ( ! sta ) //<S2SV> return NULL ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> tx_latency = rcu_dereference ( local -> tx_latency ) ; //<S2SV> if ( tx_latency ) { //<S2SV> sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * //<S2SV> sizeof ( struct ieee80211_tx_latency_stat ) , //<S2SV> GFP_ATOMIC ) ; //<S2SV> if ( ! sta -> tx_lat ) { //<S2SV> rcu_read_unlock ( ) ; //<S2SV> goto free ; //<S2SV> } //<S2SV> if ( tx_latency -> n_ranges ) { //<S2SV> for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { //<S2SV> sta -> tx_lat [ i ] . bin_count = //<S2SV> tx_latency -> n_ranges + 1 ; //<S2SV> sta -> tx_lat [ i ] . bins = //<S2SV> kcalloc ( sta -> tx_lat [ i ] . bin_count , //<S2SV> sizeof ( u32 ) , GFP_ATOMIC ) ; //<S2SV> if ( ! sta -> tx_lat [ i ] . bins ) { //<S2SV> rcu_read_unlock ( ) ; //<S2SV> goto free ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> spin_lock_init ( & sta -> lock ) ; //<S2SV> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; //<S2SV> INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; //<S2SV> mutex_init ( & sta -> ampdu_mlme . mtx ) ; //<S2SV> # ifdef CONFIG_MAC80211_MESH //<S2SV> if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && //<S2SV> ! sdata -> u . mesh . user_mpm ) //<S2SV> init_timer ( & sta -> plink_timer ) ; //<S2SV> sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; //<S2SV> # endif //<S2SV> memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; //<S2SV> sta -> local = local ; //<S2SV> sta -> sdata = sdata ; //<S2SV> sta -> last_rx = jiffies ; //<S2SV> sta -> sta_state = IEEE80211_STA_NONE ; //<S2SV> do_posix_clock_monotonic_gettime ( & uptime ) ; //<S2SV> sta -> last_connected = uptime . tv_sec ; //<S2SV> ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) //<S2SV> ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; //<S2SV> if ( sta_prepare_rate_control ( local , sta , gfp ) ) //<S2SV> goto free ; //<S2SV> for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { //<S2SV> sta -> timer_to_tid [ i ] = i ; //<S2SV> } //<S2SV> for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { //<S2SV> skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; //<S2SV> skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) //<S2SV> sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; //<S2SV> sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; //<S2SV> if ( sdata -> vif . type == NL80211_IFTYPE_AP || //<S2SV> sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { //<S2SV> struct ieee80211_supported_band * sband = //<S2SV> local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; //<S2SV> u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> //<S2SV> IEEE80211_HT_CAP_SM_PS_SHIFT ; //<S2SV> switch ( smps ) { //<S2SV> case WLAN_HT_SMPS_CONTROL_DISABLED : //<S2SV> sta -> known_smps_mode = IEEE80211_SMPS_OFF ; //<S2SV> break ; //<S2SV> case WLAN_HT_SMPS_CONTROL_STATIC : //<S2SV> sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; //<S2SV> break ; //<S2SV> case WLAN_HT_SMPS_CONTROL_DYNAMIC : //<S2SV> sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; //<S2SV> break ; //<S2SV> default : //<S2SV> WARN_ON ( 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> sta_dbg ( sdata , "Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n" , sta -> sta . addr ) ; //<S2SV> return sta ; //<S2SV> free : //<S2SV> if ( sta -> tx_lat ) { //<S2SV> for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) //<S2SV> kfree ( sta -> tx_lat [ i ] . bins ) ; //<S2SV> kfree ( sta -> tx_lat ) ; //<S2SV> } //<S2SV> kfree ( sta ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 