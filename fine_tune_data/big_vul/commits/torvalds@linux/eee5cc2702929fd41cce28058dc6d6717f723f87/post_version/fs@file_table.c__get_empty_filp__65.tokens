struct file * get_empty_filp ( void ) //<S2SV> { //<S2SV> const struct cred * cred = current_cred ( ) ; //<S2SV> static long old_max ; //<S2SV> struct file * f ; //<S2SV> int error ; //<S2SV> if ( get_nr_files ( ) >= files_stat . max_files && ! capable ( CAP_SYS_ADMIN ) ) { //<S2SV> if ( percpu_counter_sum_positive ( & nr_files ) >= files_stat . max_files ) //<S2SV> goto over ; //<S2SV> } //<S2SV> f = kmem_cache_zalloc ( filp_cachep , GFP_KERNEL ) ; //<S2SV> if ( unlikely ( ! f ) ) //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> percpu_counter_inc ( & nr_files ) ; //<S2SV> f -> f_cred = get_cred ( cred ) ; //<S2SV> error = security_file_alloc ( f ) ; //<S2SV> if ( unlikely ( error ) ) { //<S2SV> file_free ( f ) ; //<S2SV> return ERR_PTR ( error ) ; //<S2SV> } //<S2SV> atomic_long_set ( & f -> f_count , 1 ) ; //<S2SV> rwlock_init ( & f -> f_owner . lock ) ; //<S2SV> spin_lock_init ( & f -> f_lock ) ; //<S2SV> eventpoll_init_file ( f ) ; //<S2SV> return f ; //<S2SV> over : //<S2SV> if ( get_nr_files ( ) > old_max ) { //<S2SV> pr_info ( "VFS:<S2SV_blank>file-max<S2SV_blank>limit<S2SV_blank>%lu<S2SV_blank>reached\\n" , get_max_files ( ) ) ; //<S2SV> old_max = get_nr_files ( ) ; //<S2SV> } //<S2SV> return ERR_PTR ( - ENFILE ) ; //<S2SV> } //<S2SV> 