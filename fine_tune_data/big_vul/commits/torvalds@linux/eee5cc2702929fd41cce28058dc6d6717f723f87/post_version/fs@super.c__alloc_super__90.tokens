static struct super_block * alloc_super ( struct file_system_type * type , int flags ) //<S2SV> { //<S2SV> struct super_block * s = kzalloc ( sizeof ( struct super_block ) , GFP_USER ) ; //<S2SV> static const struct super_operations default_op ; //<S2SV> int i ; //<S2SV> if ( ! s ) //<S2SV> return NULL ; //<S2SV> if ( security_sb_alloc ( s ) ) //<S2SV> goto fail ; //<S2SV> for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { //<S2SV> if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 ) //<S2SV> goto fail ; //<S2SV> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , //<S2SV> & type -> s_writers_key [ i ] , 0 ) ; //<S2SV> } //<S2SV> init_waitqueue_head ( & s -> s_writers . wait ) ; //<S2SV> init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; //<S2SV> s -> s_flags = flags ; //<S2SV> s -> s_bdi = & default_backing_dev_info ; //<S2SV> INIT_HLIST_NODE ( & s -> s_instances ) ; //<S2SV> INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; //<S2SV> INIT_LIST_HEAD ( & s -> s_inodes ) ; //<S2SV> if ( list_lru_init ( & s -> s_dentry_lru ) ) //<S2SV> goto fail ; //<S2SV> if ( list_lru_init ( & s -> s_inode_lru ) ) //<S2SV> goto fail ; //<S2SV> INIT_LIST_HEAD ( & s -> s_mounts ) ; //<S2SV> init_rwsem ( & s -> s_umount ) ; //<S2SV> lockdep_set_class ( & s -> s_umount , & type -> s_umount_key ) ; //<S2SV> down_write_nested ( & s -> s_umount , SINGLE_DEPTH_NESTING ) ; //<S2SV> s -> s_count = 1 ; //<S2SV> atomic_set ( & s -> s_active , 1 ) ; //<S2SV> mutex_init ( & s -> s_vfs_rename_mutex ) ; //<S2SV> lockdep_set_class ( & s -> s_vfs_rename_mutex , & type -> s_vfs_rename_key ) ; //<S2SV> mutex_init ( & s -> s_dquot . dqio_mutex ) ; //<S2SV> mutex_init ( & s -> s_dquot . dqonoff_mutex ) ; //<S2SV> init_rwsem ( & s -> s_dquot . dqptr_sem ) ; //<S2SV> s -> s_maxbytes = MAX_NON_LFS ; //<S2SV> s -> s_op = & default_op ; //<S2SV> s -> s_time_gran = 1000000000 ; //<S2SV> s -> cleancache_poolid = - 1 ; //<S2SV> s -> s_shrink . seeks = DEFAULT_SEEKS ; //<S2SV> s -> s_shrink . scan_objects = super_cache_scan ; //<S2SV> s -> s_shrink . count_objects = super_cache_count ; //<S2SV> s -> s_shrink . batch = 1024 ; //<S2SV> s -> s_shrink . flags = SHRINKER_NUMA_AWARE ; //<S2SV> return s ; //<S2SV> fail : //<S2SV> destroy_super ( s ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 