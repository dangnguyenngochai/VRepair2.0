static int do_dentry_open ( struct file * f , //<S2SV> int ( * open ) ( struct inode * , struct file * ) , //<S2SV> const struct cred * cred ) //<S2SV> { //<S2SV> static const struct file_operations empty_fops = { } ; //<S2SV> struct inode * inode ; //<S2SV> int error ; //<S2SV> f -> f_mode = OPEN_FMODE ( f -> f_flags ) | FMODE_LSEEK | //<S2SV> FMODE_PREAD | FMODE_PWRITE ; //<S2SV> if ( unlikely ( f -> f_flags & O_PATH ) ) //<S2SV> f -> f_mode = FMODE_PATH ; //<S2SV> path_get ( & f -> f_path ) ; //<S2SV> inode = f -> f_inode = f -> f_path . dentry -> d_inode ; //<S2SV> if ( f -> f_mode & FMODE_WRITE ) { //<S2SV> error = __get_file_write_access ( inode , f -> f_path . mnt ) ; //<S2SV> if ( error ) //<S2SV> goto cleanup_file ; //<S2SV> if ( ! special_file ( inode -> i_mode ) ) //<S2SV> file_take_write ( f ) ; //<S2SV> } //<S2SV> f -> f_mapping = inode -> i_mapping ; //<S2SV> if ( unlikely ( f -> f_mode & FMODE_PATH ) ) { //<S2SV> f -> f_op = & empty_fops ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> f -> f_op = fops_get ( inode -> i_fop ) ; //<S2SV> if ( unlikely ( WARN_ON ( ! f -> f_op ) ) ) { //<S2SV> error = - ENODEV ; //<S2SV> goto cleanup_all ; //<S2SV> } //<S2SV> error = security_file_open ( f , cred ) ; //<S2SV> if ( error ) //<S2SV> goto cleanup_all ; //<S2SV> error = break_lease ( inode , f -> f_flags ) ; //<S2SV> if ( error ) //<S2SV> goto cleanup_all ; //<S2SV> if ( ! open ) //<S2SV> open = f -> f_op -> open ; //<S2SV> if ( open ) { //<S2SV> error = open ( inode , f ) ; //<S2SV> if ( error ) //<S2SV> goto cleanup_all ; //<S2SV> } //<S2SV> if ( ( f -> f_mode & ( FMODE_READ | FMODE_WRITE ) ) == FMODE_READ ) //<S2SV> i_readcount_inc ( inode ) ; //<S2SV> f -> f_flags &= ~ ( O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC ) ; //<S2SV> file_ra_state_init ( & f -> f_ra , f -> f_mapping -> host -> i_mapping ) ; //<S2SV> return 0 ; //<S2SV> cleanup_all : //<S2SV> fops_put ( f -> f_op ) ; //<S2SV> if ( f -> f_mode & FMODE_WRITE ) { //<S2SV> put_write_access ( inode ) ; //<S2SV> if ( ! special_file ( inode -> i_mode ) ) { //<S2SV> file_reset_write ( f ) ; //<S2SV> __mnt_drop_write ( f -> f_path . mnt ) ; //<S2SV> } //<S2SV> } //<S2SV> cleanup_file : //<S2SV> path_put ( & f -> f_path ) ; //<S2SV> f -> f_path . mnt = NULL ; //<S2SV> f -> f_path . dentry = NULL ; //<S2SV> f -> f_inode = NULL ; //<S2SV> return error ; //<S2SV> } //<S2SV> 