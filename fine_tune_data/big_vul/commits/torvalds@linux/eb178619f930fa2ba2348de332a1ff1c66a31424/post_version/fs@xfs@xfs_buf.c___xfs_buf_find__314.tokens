xfs_buf_t * //<S2SV> _xfs_buf_find ( //<S2SV> struct xfs_buftarg * btp , //<S2SV> struct xfs_buf_map * map , //<S2SV> int nmaps , //<S2SV> xfs_buf_flags_t flags , //<S2SV> xfs_buf_t * new_bp ) //<S2SV> { //<S2SV> size_t numbytes ; //<S2SV> struct xfs_perag * pag ; //<S2SV> struct rb_node * * rbp ; //<S2SV> struct rb_node * parent ; //<S2SV> xfs_buf_t * bp ; //<S2SV> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; //<S2SV> xfs_daddr_t eofs ; //<S2SV> int numblks = 0 ; //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < nmaps ; i ++ ) //<S2SV> numblks += map [ i ] . bm_len ; //<S2SV> numbytes = BBTOB ( numblks ) ; //<S2SV> ASSERT ( ! ( numbytes < ( 1 << btp -> bt_sshift ) ) ) ; //<S2SV> ASSERT ( ! ( BBTOB ( blkno ) & ( xfs_off_t ) btp -> bt_smask ) ) ; //<S2SV> eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; //<S2SV> if ( blkno >= eofs ) { //<S2SV> xfs_alert ( btp -> bt_mount , //<S2SV> "%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>" , //<S2SV> __func__ , blkno , eofs ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> pag = xfs_perag_get ( btp -> bt_mount , //<S2SV> xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ; //<S2SV> spin_lock ( & pag -> pag_buf_lock ) ; //<S2SV> rbp = & pag -> pag_buf_tree . rb_node ; //<S2SV> parent = NULL ; //<S2SV> bp = NULL ; //<S2SV> while ( * rbp ) { //<S2SV> parent = * rbp ; //<S2SV> bp = rb_entry ( parent , struct xfs_buf , b_rbnode ) ; //<S2SV> if ( blkno < bp -> b_bn ) //<S2SV> rbp = & ( * rbp ) -> rb_left ; //<S2SV> else if ( blkno > bp -> b_bn ) //<S2SV> rbp = & ( * rbp ) -> rb_right ; //<S2SV> else { //<S2SV> if ( bp -> b_length != numblks ) { //<S2SV> ASSERT ( bp -> b_flags & XBF_STALE ) ; //<S2SV> rbp = & ( * rbp ) -> rb_right ; //<S2SV> continue ; //<S2SV> } //<S2SV> atomic_inc ( & bp -> b_hold ) ; //<S2SV> goto found ; //<S2SV> } //<S2SV> } //<S2SV> if ( new_bp ) { //<S2SV> rb_link_node ( & new_bp -> b_rbnode , parent , rbp ) ; //<S2SV> rb_insert_color ( & new_bp -> b_rbnode , & pag -> pag_buf_tree ) ; //<S2SV> new_bp -> b_pag = pag ; //<S2SV> spin_unlock ( & pag -> pag_buf_lock ) ; //<S2SV> } else { //<S2SV> XFS_STATS_INC ( xb_miss_locked ) ; //<S2SV> spin_unlock ( & pag -> pag_buf_lock ) ; //<S2SV> xfs_perag_put ( pag ) ; //<S2SV> } //<S2SV> return new_bp ; //<S2SV> found : //<S2SV> spin_unlock ( & pag -> pag_buf_lock ) ; //<S2SV> xfs_perag_put ( pag ) ; //<S2SV> if ( ! xfs_buf_trylock ( bp ) ) { //<S2SV> if ( flags & XBF_TRYLOCK ) { //<S2SV> xfs_buf_rele ( bp ) ; //<S2SV> XFS_STATS_INC ( xb_busy_locked ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> xfs_buf_lock ( bp ) ; //<S2SV> XFS_STATS_INC ( xb_get_locked_waited ) ; //<S2SV> } //<S2SV> if ( bp -> b_flags & XBF_STALE ) { //<S2SV> ASSERT ( ( bp -> b_flags & _XBF_DELWRI_Q ) == 0 ) ; //<S2SV> ASSERT ( bp -> b_iodone == NULL ) ; //<S2SV> bp -> b_flags &= _XBF_KMEM | _XBF_PAGES ; //<S2SV> bp -> b_ops = NULL ; //<S2SV> } //<S2SV> trace_xfs_buf_find ( bp , flags , _RET_IP_ ) ; //<S2SV> XFS_STATS_INC ( xb_get_locked ) ; //<S2SV> return bp ; //<S2SV> } //<S2SV> 