long do_io_submit ( aio_context_t ctx_id , long nr , //<S2SV> struct iocb __user * __user * iocbpp , bool compat ) //<S2SV> { //<S2SV> struct kioctx * ctx ; //<S2SV> long ret = 0 ; //<S2SV> int i = 0 ; //<S2SV> struct blk_plug plug ; //<S2SV> struct kiocb_batch batch ; //<S2SV> if ( unlikely ( nr < 0 ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( unlikely ( nr > LONG_MAX / sizeof ( * iocbpp ) ) ) //<S2SV> nr = LONG_MAX / sizeof ( * iocbpp ) ; //<S2SV> if ( unlikely ( ! access_ok ( VERIFY_READ , iocbpp , ( nr * sizeof ( * iocbpp ) ) ) ) ) //<S2SV> return - EFAULT ; //<S2SV> ctx = lookup_ioctx ( ctx_id ) ; //<S2SV> if ( unlikely ( ! ctx ) ) { //<S2SV> pr_debug ( "EINVAL:<S2SV_blank>io_submit:<S2SV_blank>invalid<S2SV_blank>context<S2SV_blank>id\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> kiocb_batch_init ( & batch , nr ) ; //<S2SV> blk_start_plug ( & plug ) ; //<S2SV> for ( i = 0 ; i < nr ; i ++ ) { //<S2SV> struct iocb __user * user_iocb ; //<S2SV> struct iocb tmp ; //<S2SV> if ( unlikely ( __get_user ( user_iocb , iocbpp + i ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( unlikely ( copy_from_user ( & tmp , user_iocb , sizeof ( tmp ) ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> ret = io_submit_one ( ctx , user_iocb , & tmp , & batch , compat ) ; //<S2SV> if ( ret ) //<S2SV> break ; //<S2SV> } //<S2SV> blk_finish_plug ( & plug ) ; //<S2SV> kiocb_batch_free ( ctx , & batch ) ; //<S2SV> put_ioctx ( ctx ) ; //<S2SV> return i ? i : ret ; //<S2SV> } //<S2SV> 