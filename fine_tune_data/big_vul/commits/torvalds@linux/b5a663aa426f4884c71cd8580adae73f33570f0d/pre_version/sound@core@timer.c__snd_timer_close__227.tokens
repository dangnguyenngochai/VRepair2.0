int snd_timer_close ( struct snd_timer_instance * timeri ) //<S2SV> { //<S2SV> struct snd_timer * timer = NULL ; //<S2SV> struct snd_timer_instance * slave , * tmp ; //<S2SV> if ( snd_BUG_ON ( ! timeri ) ) //<S2SV> return - ENXIO ; //<S2SV> snd_timer_stop ( timeri ) ; //<S2SV> if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { //<S2SV> spin_lock_irq ( & slave_active_lock ) ; //<S2SV> while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { //<S2SV> spin_unlock_irq ( & slave_active_lock ) ; //<S2SV> udelay ( 10 ) ; //<S2SV> spin_lock_irq ( & slave_active_lock ) ; //<S2SV> } //<S2SV> spin_unlock_irq ( & slave_active_lock ) ; //<S2SV> mutex_lock ( & register_mutex ) ; //<S2SV> list_del ( & timeri -> open_list ) ; //<S2SV> mutex_unlock ( & register_mutex ) ; //<S2SV> } else { //<S2SV> timer = timeri -> timer ; //<S2SV> if ( snd_BUG_ON ( ! timer ) ) //<S2SV> goto out ; //<S2SV> spin_lock_irq ( & timer -> lock ) ; //<S2SV> while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { //<S2SV> spin_unlock_irq ( & timer -> lock ) ; //<S2SV> udelay ( 10 ) ; //<S2SV> spin_lock_irq ( & timer -> lock ) ; //<S2SV> } //<S2SV> spin_unlock_irq ( & timer -> lock ) ; //<S2SV> mutex_lock ( & register_mutex ) ; //<S2SV> list_del ( & timeri -> open_list ) ; //<S2SV> if ( timer && list_empty ( & timer -> open_list_head ) && //<S2SV> timer -> hw . close ) //<S2SV> timer -> hw . close ( timer ) ; //<S2SV> list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , //<S2SV> open_list ) { //<S2SV> spin_lock_irq ( & slave_active_lock ) ; //<S2SV> _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; //<S2SV> list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; //<S2SV> slave -> master = NULL ; //<S2SV> slave -> timer = NULL ; //<S2SV> spin_unlock_irq ( & slave_active_lock ) ; //<S2SV> } //<S2SV> mutex_unlock ( & register_mutex ) ; //<S2SV> } //<S2SV> out : //<S2SV> if ( timeri -> private_free ) //<S2SV> timeri -> private_free ( timeri ) ; //<S2SV> kfree ( timeri -> owner ) ; //<S2SV> kfree ( timeri ) ; //<S2SV> if ( timer ) //<S2SV> module_put ( timer -> module ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 