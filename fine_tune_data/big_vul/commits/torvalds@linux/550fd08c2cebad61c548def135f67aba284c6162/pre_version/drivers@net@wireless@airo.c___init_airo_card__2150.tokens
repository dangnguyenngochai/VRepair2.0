static struct net_device * _init_airo_card ( unsigned short irq , int port , //<S2SV> int is_pcmcia , struct pci_dev * pci , //<S2SV> struct device * dmdev ) //<S2SV> { //<S2SV> struct net_device * dev ; //<S2SV> struct airo_info * ai ; //<S2SV> int i , rc ; //<S2SV> CapabilityRid cap_rid ; //<S2SV> dev = alloc_netdev ( sizeof ( * ai ) , "" , ether_setup ) ; //<S2SV> if ( ! dev ) { //<S2SV> airo_print_err ( "" , "Couldn\'t<S2SV_blank>alloc_etherdev" ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> ai = dev -> ml_priv = netdev_priv ( dev ) ; //<S2SV> ai -> wifidev = NULL ; //<S2SV> ai -> flags = 1 << FLAG_RADIO_DOWN ; //<S2SV> ai -> jobs = 0 ; //<S2SV> ai -> dev = dev ; //<S2SV> if ( pci && ( pci -> device == 0x5000 || pci -> device == 0xa504 ) ) { //<S2SV> airo_print_dbg ( "" , "Found<S2SV_blank>an<S2SV_blank>MPI350<S2SV_blank>card" ) ; //<S2SV> set_bit ( FLAG_MPI , & ai -> flags ) ; //<S2SV> } //<S2SV> spin_lock_init ( & ai -> aux_lock ) ; //<S2SV> sema_init ( & ai -> sem , 1 ) ; //<S2SV> ai -> config . len = 0 ; //<S2SV> ai -> pci = pci ; //<S2SV> init_waitqueue_head ( & ai -> thr_wait ) ; //<S2SV> ai -> tfm = NULL ; //<S2SV> add_airo_dev ( ai ) ; //<S2SV> if ( airo_networks_allocate ( ai ) ) //<S2SV> goto err_out_free ; //<S2SV> airo_networks_initialize ( ai ) ; //<S2SV> skb_queue_head_init ( & ai -> txq ) ; //<S2SV> if ( test_bit ( FLAG_MPI , & ai -> flags ) ) //<S2SV> dev -> netdev_ops = & mpi_netdev_ops ; //<S2SV> else //<S2SV> dev -> netdev_ops = & airo_netdev_ops ; //<S2SV> dev -> wireless_handlers = & airo_handler_def ; //<S2SV> ai -> wireless_data . spy_data = & ai -> spy_data ; //<S2SV> dev -> wireless_data = & ai -> wireless_data ; //<S2SV> dev -> irq = irq ; //<S2SV> dev -> base_addr = port ; //<S2SV> SET_NETDEV_DEV ( dev , dmdev ) ; //<S2SV> reset_card ( dev , 1 ) ; //<S2SV> msleep ( 400 ) ; //<S2SV> if ( ! is_pcmcia ) { //<S2SV> if ( ! request_region ( dev -> base_addr , 64 , DRV_NAME ) ) { //<S2SV> rc = - EBUSY ; //<S2SV> airo_print_err ( dev -> name , "Couldn\'t<S2SV_blank>request<S2SV_blank>region" ) ; //<S2SV> goto err_out_nets ; //<S2SV> } //<S2SV> } //<S2SV> if ( test_bit ( FLAG_MPI , & ai -> flags ) ) { //<S2SV> if ( mpi_map_card ( ai , pci ) ) { //<S2SV> airo_print_err ( "" , "Could<S2SV_blank>not<S2SV_blank>map<S2SV_blank>memory" ) ; //<S2SV> goto err_out_res ; //<S2SV> } //<S2SV> } //<S2SV> if ( probe ) { //<S2SV> if ( setup_card ( ai , dev -> dev_addr , 1 ) != SUCCESS ) { //<S2SV> airo_print_err ( dev -> name , "MAC<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>enabled" ) ; //<S2SV> rc = - EIO ; //<S2SV> goto err_out_map ; //<S2SV> } //<S2SV> } else if ( ! test_bit ( FLAG_MPI , & ai -> flags ) ) { //<S2SV> ai -> bap_read = fast_bap_read ; //<S2SV> set_bit ( FLAG_FLASHING , & ai -> flags ) ; //<S2SV> } //<S2SV> strcpy ( dev -> name , "eth%d" ) ; //<S2SV> rc = register_netdev ( dev ) ; //<S2SV> if ( rc ) { //<S2SV> airo_print_err ( dev -> name , "Couldn\'t<S2SV_blank>register_netdev" ) ; //<S2SV> goto err_out_map ; //<S2SV> } //<S2SV> ai -> wifidev = init_wifidev ( ai , dev ) ; //<S2SV> if ( ! ai -> wifidev ) //<S2SV> goto err_out_reg ; //<S2SV> rc = readCapabilityRid ( ai , & cap_rid , 1 ) ; //<S2SV> if ( rc != SUCCESS ) { //<S2SV> rc = - EIO ; //<S2SV> goto err_out_wifi ; //<S2SV> } //<S2SV> ai -> wep_capable = ( cap_rid . softCap & cpu_to_le16 ( 0x02 ) ) ? 1 : 0 ; //<S2SV> ai -> max_wep_idx = ( cap_rid . softCap & cpu_to_le16 ( 0x80 ) ) ? 3 : 0 ; //<S2SV> airo_print_info ( dev -> name , "Firmware<S2SV_blank>version<S2SV_blank>%x.%x.%02d" , //<S2SV> ( ( le16_to_cpu ( cap_rid . softVer ) >> 8 ) & 0xF ) , //<S2SV> ( le16_to_cpu ( cap_rid . softVer ) & 0xFF ) , //<S2SV> le16_to_cpu ( cap_rid . softSubVer ) ) ; //<S2SV> if ( le16_to_cpu ( cap_rid . softVer ) > 0x530 //<S2SV> || ( le16_to_cpu ( cap_rid . softVer ) == 0x530 //<S2SV> && le16_to_cpu ( cap_rid . softSubVer ) >= 17 ) ) { //<S2SV> airo_print_info ( ai -> dev -> name , "WPA<S2SV_blank>supported." ) ; //<S2SV> set_bit ( FLAG_WPA_CAPABLE , & ai -> flags ) ; //<S2SV> ai -> bssListFirst = RID_WPA_BSSLISTFIRST ; //<S2SV> ai -> bssListNext = RID_WPA_BSSLISTNEXT ; //<S2SV> ai -> bssListRidLen = sizeof ( BSSListRid ) ; //<S2SV> } else { //<S2SV> airo_print_info ( ai -> dev -> name , "WPA<S2SV_blank>unsupported<S2SV_blank>with<S2SV_blank>firmware<S2SV_blank>" //<S2SV> "versions<S2SV_blank>older<S2SV_blank>than<S2SV_blank>5.30.17." ) ; //<S2SV> ai -> bssListFirst = RID_BSSLISTFIRST ; //<S2SV> ai -> bssListNext = RID_BSSLISTNEXT ; //<S2SV> ai -> bssListRidLen = sizeof ( BSSListRid ) - sizeof ( BSSListRidExtra ) ; //<S2SV> } //<S2SV> set_bit ( FLAG_REGISTERED , & ai -> flags ) ; //<S2SV> airo_print_info ( dev -> name , "MAC<S2SV_blank>enabled<S2SV_blank>%pM" , dev -> dev_addr ) ; //<S2SV> if ( probe && ! test_bit ( FLAG_MPI , & ai -> flags ) ) //<S2SV> for ( i = 0 ; i < MAX_FIDS ; i ++ ) //<S2SV> ai -> fids [ i ] = transmit_allocate ( ai , AIRO_DEF_MTU , i >= MAX_FIDS / 2 ) ; //<S2SV> if ( setup_proc_entry ( dev , dev -> ml_priv ) < 0 ) //<S2SV> goto err_out_wifi ; //<S2SV> return dev ; //<S2SV> err_out_wifi : //<S2SV> unregister_netdev ( ai -> wifidev ) ; //<S2SV> free_netdev ( ai -> wifidev ) ; //<S2SV> err_out_reg : //<S2SV> unregister_netdev ( dev ) ; //<S2SV> err_out_map : //<S2SV> if ( test_bit ( FLAG_MPI , & ai -> flags ) && pci ) { //<S2SV> pci_free_consistent ( pci , PCI_SHARED_LEN , ai -> shared , ai -> shared_dma ) ; //<S2SV> iounmap ( ai -> pciaux ) ; //<S2SV> iounmap ( ai -> pcimem ) ; //<S2SV> mpi_unmap_card ( ai -> pci ) ; //<S2SV> } //<S2SV> err_out_res : //<S2SV> if ( ! is_pcmcia ) //<S2SV> release_region ( dev -> base_addr , 64 ) ; //<S2SV> err_out_nets : //<S2SV> airo_networks_free ( ai ) ; //<S2SV> err_out_free : //<S2SV> del_airo_dev ( ai ) ; //<S2SV> free_netdev ( dev ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 