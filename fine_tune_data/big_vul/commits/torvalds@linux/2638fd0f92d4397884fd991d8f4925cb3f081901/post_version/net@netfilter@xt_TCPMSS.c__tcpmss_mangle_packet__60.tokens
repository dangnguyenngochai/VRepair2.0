static int //<S2SV> tcpmss_mangle_packet ( struct sk_buff * skb , //<S2SV> const struct xt_action_param * par , //<S2SV> unsigned int family , //<S2SV> unsigned int tcphoff , //<S2SV> unsigned int minlen ) //<S2SV> { //<S2SV> const struct xt_tcpmss_info * info = par -> targinfo ; //<S2SV> struct tcphdr * tcph ; //<S2SV> int len , tcp_hdrlen ; //<S2SV> unsigned int i ; //<S2SV> __be16 oldval ; //<S2SV> u16 newmss ; //<S2SV> u8 * opt ; //<S2SV> if ( par -> fragoff != 0 ) //<S2SV> return 0 ; //<S2SV> if ( ! skb_make_writable ( skb , skb -> len ) ) //<S2SV> return - 1 ; //<S2SV> len = skb -> len - tcphoff ; //<S2SV> if ( len < ( int ) sizeof ( struct tcphdr ) ) //<S2SV> return - 1 ; //<S2SV> tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; //<S2SV> tcp_hdrlen = tcph -> doff * 4 ; //<S2SV> if ( len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) ) //<S2SV> return - 1 ; //<S2SV> if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { //<S2SV> struct net * net = xt_net ( par ) ; //<S2SV> unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; //<S2SV> unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; //<S2SV> if ( min_mtu <= minlen ) { //<S2SV> net_err_ratelimited ( "unknown<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>path-MTU<S2SV_blank>(%u)\\n" , //<S2SV> min_mtu ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> newmss = min_mtu - minlen ; //<S2SV> } else //<S2SV> newmss = info -> mss ; //<S2SV> opt = ( u_int8_t * ) tcph ; //<S2SV> for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { //<S2SV> if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { //<S2SV> u_int16_t oldmss ; //<S2SV> oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ] ; //<S2SV> if ( oldmss <= newmss ) //<S2SV> return 0 ; //<S2SV> opt [ i + 2 ] = ( newmss & 0xff00 ) >> 8 ; //<S2SV> opt [ i + 3 ] = newmss & 0x00ff ; //<S2SV> inet_proto_csum_replace2 ( & tcph -> check , skb , //<S2SV> htons ( oldmss ) , htons ( newmss ) , //<S2SV> false ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( len > tcp_hdrlen ) //<S2SV> return 0 ; //<S2SV> if ( tcp_hdrlen >= 15 * 4 ) //<S2SV> return 0 ; //<S2SV> if ( skb_tailroom ( skb ) < TCPOLEN_MSS ) { //<S2SV> if ( pskb_expand_head ( skb , 0 , //<S2SV> TCPOLEN_MSS - skb_tailroom ( skb ) , //<S2SV> GFP_ATOMIC ) ) //<S2SV> return - 1 ; //<S2SV> tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; //<S2SV> } //<S2SV> skb_put ( skb , TCPOLEN_MSS ) ; //<S2SV> if ( xt_family ( par ) == NFPROTO_IPV4 ) //<S2SV> newmss = min ( newmss , ( u16 ) 536 ) ; //<S2SV> else //<S2SV> newmss = min ( newmss , ( u16 ) 1220 ) ; //<S2SV> opt = ( u_int8_t * ) tcph + sizeof ( struct tcphdr ) ; //<S2SV> memmove ( opt + TCPOLEN_MSS , opt , len - sizeof ( struct tcphdr ) ) ; //<S2SV> inet_proto_csum_replace2 ( & tcph -> check , skb , //<S2SV> htons ( len ) , htons ( len + TCPOLEN_MSS ) , true ) ; //<S2SV> opt [ 0 ] = TCPOPT_MSS ; //<S2SV> opt [ 1 ] = TCPOLEN_MSS ; //<S2SV> opt [ 2 ] = ( newmss & 0xff00 ) >> 8 ; //<S2SV> opt [ 3 ] = newmss & 0x00ff ; //<S2SV> inet_proto_csum_replace4 ( & tcph -> check , skb , 0 , * ( ( __be32 * ) opt ) , false ) ; //<S2SV> oldval = ( ( __be16 * ) tcph ) [ 6 ] ; //<S2SV> tcph -> doff += TCPOLEN_MSS / 4 ; //<S2SV> inet_proto_csum_replace2 ( & tcph -> check , skb , //<S2SV> oldval , ( ( __be16 * ) tcph ) [ 6 ] , false ) ; //<S2SV> return TCPOLEN_MSS ; //<S2SV> } //<S2SV> 