static int dcbnl_ieee_fill ( struct sk_buff * skb , struct net_device * netdev ) //<S2SV> { //<S2SV> struct nlattr * ieee , * app ; //<S2SV> struct dcb_app_type * itr ; //<S2SV> const struct dcbnl_rtnl_ops * ops = netdev -> dcbnl_ops ; //<S2SV> int dcbx ; //<S2SV> int err ; //<S2SV> if ( nla_put_string ( skb , DCB_ATTR_IFNAME , netdev -> name ) ) //<S2SV> return - EMSGSIZE ; //<S2SV> ieee = nla_nest_start ( skb , DCB_ATTR_IEEE ) ; //<S2SV> if ( ! ieee ) //<S2SV> return - EMSGSIZE ; //<S2SV> if ( ops -> ieee_getets ) { //<S2SV> struct ieee_ets ets ; //<S2SV> memset ( & ets , 0 , sizeof ( ets ) ) ; //<S2SV> err = ops -> ieee_getets ( netdev , & ets ) ; //<S2SV> if ( ! err && //<S2SV> nla_put ( skb , DCB_ATTR_IEEE_ETS , sizeof ( ets ) , & ets ) ) //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> if ( ops -> ieee_getmaxrate ) { //<S2SV> struct ieee_maxrate maxrate ; //<S2SV> memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; //<S2SV> err = ops -> ieee_getmaxrate ( netdev , & maxrate ) ; //<S2SV> if ( ! err ) { //<S2SV> err = nla_put ( skb , DCB_ATTR_IEEE_MAXRATE , //<S2SV> sizeof ( maxrate ) , & maxrate ) ; //<S2SV> if ( err ) //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> } //<S2SV> if ( ops -> ieee_getpfc ) { //<S2SV> struct ieee_pfc pfc ; //<S2SV> memset ( & pfc , 0 , sizeof ( pfc ) ) ; //<S2SV> err = ops -> ieee_getpfc ( netdev , & pfc ) ; //<S2SV> if ( ! err && //<S2SV> nla_put ( skb , DCB_ATTR_IEEE_PFC , sizeof ( pfc ) , & pfc ) ) //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> app = nla_nest_start ( skb , DCB_ATTR_IEEE_APP_TABLE ) ; //<S2SV> if ( ! app ) //<S2SV> return - EMSGSIZE ; //<S2SV> spin_lock ( & dcb_lock ) ; //<S2SV> list_for_each_entry ( itr , & dcb_app_list , list ) { //<S2SV> if ( itr -> ifindex == netdev -> ifindex ) { //<S2SV> err = nla_put ( skb , DCB_ATTR_IEEE_APP , sizeof ( itr -> app ) , //<S2SV> & itr -> app ) ; //<S2SV> if ( err ) { //<S2SV> spin_unlock ( & dcb_lock ) ; //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( netdev -> dcbnl_ops -> getdcbx ) //<S2SV> dcbx = netdev -> dcbnl_ops -> getdcbx ( netdev ) ; //<S2SV> else //<S2SV> dcbx = - EOPNOTSUPP ; //<S2SV> spin_unlock ( & dcb_lock ) ; //<S2SV> nla_nest_end ( skb , app ) ; //<S2SV> if ( ops -> ieee_peer_getets ) { //<S2SV> struct ieee_ets ets ; //<S2SV> memset ( & ets , 0 , sizeof ( ets ) ) ; //<S2SV> err = ops -> ieee_peer_getets ( netdev , & ets ) ; //<S2SV> if ( ! err && //<S2SV> nla_put ( skb , DCB_ATTR_IEEE_PEER_ETS , sizeof ( ets ) , & ets ) ) //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> if ( ops -> ieee_peer_getpfc ) { //<S2SV> struct ieee_pfc pfc ; //<S2SV> memset ( & pfc , 0 , sizeof ( pfc ) ) ; //<S2SV> err = ops -> ieee_peer_getpfc ( netdev , & pfc ) ; //<S2SV> if ( ! err && //<S2SV> nla_put ( skb , DCB_ATTR_IEEE_PEER_PFC , sizeof ( pfc ) , & pfc ) ) //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> if ( ops -> peer_getappinfo && ops -> peer_getapptable ) { //<S2SV> err = dcbnl_build_peer_app ( netdev , skb , //<S2SV> DCB_ATTR_IEEE_PEER_APP , //<S2SV> DCB_ATTR_IEEE_APP_UNSPEC , //<S2SV> DCB_ATTR_IEEE_APP ) ; //<S2SV> if ( err ) //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> nla_nest_end ( skb , ieee ) ; //<S2SV> if ( dcbx >= 0 ) { //<S2SV> err = nla_put_u8 ( skb , DCB_ATTR_DCBX , dcbx ) ; //<S2SV> if ( err ) //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 