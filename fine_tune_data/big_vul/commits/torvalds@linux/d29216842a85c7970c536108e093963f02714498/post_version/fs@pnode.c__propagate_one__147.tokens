static int propagate_one ( struct mount * m ) //<S2SV> { //<S2SV> struct mount * child ; //<S2SV> int type ; //<S2SV> if ( IS_MNT_NEW ( m ) ) //<S2SV> return 0 ; //<S2SV> if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) //<S2SV> return 0 ; //<S2SV> if ( peers ( m , last_dest ) ) { //<S2SV> type = CL_MAKE_SHARED ; //<S2SV> } else { //<S2SV> struct mount * n , * p ; //<S2SV> bool done ; //<S2SV> for ( n = m ; ; n = p ) { //<S2SV> p = n -> mnt_master ; //<S2SV> if ( p == dest_master || IS_MNT_MARKED ( p ) ) //<S2SV> break ; //<S2SV> } //<S2SV> do { //<S2SV> struct mount * parent = last_source -> mnt_parent ; //<S2SV> if ( last_source == first_source ) //<S2SV> break ; //<S2SV> done = parent -> mnt_master == p ; //<S2SV> if ( done && peers ( n , parent ) ) //<S2SV> break ; //<S2SV> last_source = last_source -> mnt_master ; //<S2SV> } while ( ! done ) ; //<S2SV> type = CL_SLAVE ; //<S2SV> if ( IS_MNT_SHARED ( m ) ) //<S2SV> type |= CL_MAKE_SHARED ; //<S2SV> } //<S2SV> if ( m -> mnt_ns -> user_ns != user_ns ) //<S2SV> type |= CL_UNPRIVILEGED ; //<S2SV> child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; //<S2SV> if ( IS_ERR ( child ) ) //<S2SV> return PTR_ERR ( child ) ; //<S2SV> child -> mnt . mnt_flags &= ~ MNT_LOCKED ; //<S2SV> mnt_set_mountpoint ( m , mp , child ) ; //<S2SV> last_dest = m ; //<S2SV> last_source = child ; //<S2SV> if ( m -> mnt_master != dest_master ) { //<S2SV> read_seqlock_excl ( & mount_lock ) ; //<S2SV> SET_MNT_MARK ( m -> mnt_master ) ; //<S2SV> read_sequnlock_excl ( & mount_lock ) ; //<S2SV> } //<S2SV> hlist_add_head ( & child -> mnt_hash , list ) ; //<S2SV> return count_mounts ( m -> mnt_ns , child ) ; //<S2SV> } //<S2SV> 