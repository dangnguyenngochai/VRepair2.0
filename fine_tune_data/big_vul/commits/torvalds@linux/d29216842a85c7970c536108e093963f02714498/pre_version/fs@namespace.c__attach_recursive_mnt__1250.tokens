static int attach_recursive_mnt ( struct mount * source_mnt , //<S2SV> struct mount * dest_mnt , //<S2SV> struct mountpoint * dest_mp , //<S2SV> struct path * parent_path ) //<S2SV> { //<S2SV> HLIST_HEAD ( tree_list ) ; //<S2SV> struct mount * child , * p ; //<S2SV> struct hlist_node * n ; //<S2SV> int err ; //<S2SV> if ( IS_MNT_SHARED ( dest_mnt ) ) { //<S2SV> err = invent_group_ids ( source_mnt , true ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; //<S2SV> lock_mount_hash ( ) ; //<S2SV> if ( err ) //<S2SV> goto out_cleanup_ids ; //<S2SV> for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) //<S2SV> set_mnt_shared ( p ) ; //<S2SV> } else { //<S2SV> lock_mount_hash ( ) ; //<S2SV> } //<S2SV> if ( parent_path ) { //<S2SV> detach_mnt ( source_mnt , parent_path ) ; //<S2SV> attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; //<S2SV> touch_mnt_namespace ( source_mnt -> mnt_ns ) ; //<S2SV> } else { //<S2SV> mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; //<S2SV> commit_tree ( source_mnt , NULL ) ; //<S2SV> } //<S2SV> hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { //<S2SV> struct mount * q ; //<S2SV> hlist_del_init ( & child -> mnt_hash ) ; //<S2SV> q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , //<S2SV> child -> mnt_mountpoint ) ; //<S2SV> commit_tree ( child , q ) ; //<S2SV> } //<S2SV> unlock_mount_hash ( ) ; //<S2SV> return 0 ; //<S2SV> out_cleanup_ids : //<S2SV> while ( ! hlist_empty ( & tree_list ) ) { //<S2SV> child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; //<S2SV> umount_tree ( child , UMOUNT_SYNC ) ; //<S2SV> } //<S2SV> unlock_mount_hash ( ) ; //<S2SV> cleanup_group_ids ( source_mnt , NULL ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 