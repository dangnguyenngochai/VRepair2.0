static struct mnt_namespace * alloc_mnt_ns ( struct user_namespace * user_ns ) //<S2SV> { //<S2SV> struct mnt_namespace * new_ns ; //<S2SV> struct ucounts * ucounts ; //<S2SV> int ret ; //<S2SV> ucounts = inc_mnt_namespaces ( user_ns ) ; //<S2SV> if ( ! ucounts ) //<S2SV> return ERR_PTR ( - ENOSPC ) ; //<S2SV> new_ns = kmalloc ( sizeof ( struct mnt_namespace ) , GFP_KERNEL ) ; //<S2SV> if ( ! new_ns ) { //<S2SV> dec_mnt_namespaces ( ucounts ) ; //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> } //<S2SV> ret = ns_alloc_inum ( & new_ns -> ns ) ; //<S2SV> if ( ret ) { //<S2SV> kfree ( new_ns ) ; //<S2SV> dec_mnt_namespaces ( ucounts ) ; //<S2SV> return ERR_PTR ( ret ) ; //<S2SV> } //<S2SV> new_ns -> ns . ops = & mntns_operations ; //<S2SV> new_ns -> seq = atomic64_add_return ( 1 , & mnt_ns_seq ) ; //<S2SV> atomic_set ( & new_ns -> count , 1 ) ; //<S2SV> new_ns -> root = NULL ; //<S2SV> INIT_LIST_HEAD ( & new_ns -> list ) ; //<S2SV> init_waitqueue_head ( & new_ns -> poll ) ; //<S2SV> new_ns -> event = 0 ; //<S2SV> new_ns -> user_ns = get_user_ns ( user_ns ) ; //<S2SV> new_ns -> ucounts = ucounts ; //<S2SV> return new_ns ; //<S2SV> } //<S2SV> 