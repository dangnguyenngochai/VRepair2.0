struct mnt_namespace * copy_mnt_ns ( unsigned long flags , struct mnt_namespace * ns , //<S2SV> struct user_namespace * user_ns , struct fs_struct * new_fs ) //<S2SV> { //<S2SV> struct mnt_namespace * new_ns ; //<S2SV> struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; //<S2SV> struct mount * p , * q ; //<S2SV> struct mount * old ; //<S2SV> struct mount * new ; //<S2SV> int copy_flags ; //<S2SV> BUG_ON ( ! ns ) ; //<S2SV> if ( likely ( ! ( flags & CLONE_NEWNS ) ) ) { //<S2SV> get_mnt_ns ( ns ) ; //<S2SV> return ns ; //<S2SV> } //<S2SV> old = ns -> root ; //<S2SV> new_ns = alloc_mnt_ns ( user_ns ) ; //<S2SV> if ( IS_ERR ( new_ns ) ) //<S2SV> return new_ns ; //<S2SV> namespace_lock ( ) ; //<S2SV> copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE ; //<S2SV> if ( user_ns != ns -> user_ns ) //<S2SV> copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED ; //<S2SV> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; //<S2SV> if ( IS_ERR ( new ) ) { //<S2SV> namespace_unlock ( ) ; //<S2SV> free_mnt_ns ( new_ns ) ; //<S2SV> return ERR_CAST ( new ) ; //<S2SV> } //<S2SV> new_ns -> root = new ; //<S2SV> list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; //<S2SV> p = old ; //<S2SV> q = new ; //<S2SV> while ( p ) { //<S2SV> q -> mnt_ns = new_ns ; //<S2SV> if ( new_fs ) { //<S2SV> if ( & p -> mnt == new_fs -> root . mnt ) { //<S2SV> new_fs -> root . mnt = mntget ( & q -> mnt ) ; //<S2SV> rootmnt = & p -> mnt ; //<S2SV> } //<S2SV> if ( & p -> mnt == new_fs -> pwd . mnt ) { //<S2SV> new_fs -> pwd . mnt = mntget ( & q -> mnt ) ; //<S2SV> pwdmnt = & p -> mnt ; //<S2SV> } //<S2SV> } //<S2SV> p = next_mnt ( p , old ) ; //<S2SV> q = next_mnt ( q , new ) ; //<S2SV> if ( ! q ) //<S2SV> break ; //<S2SV> while ( p -> mnt . mnt_root != q -> mnt . mnt_root ) //<S2SV> p = next_mnt ( p , old ) ; //<S2SV> } //<S2SV> namespace_unlock ( ) ; //<S2SV> if ( rootmnt ) //<S2SV> mntput ( rootmnt ) ; //<S2SV> if ( pwdmnt ) //<S2SV> mntput ( pwdmnt ) ; //<S2SV> return new_ns ; //<S2SV> } //<S2SV> 