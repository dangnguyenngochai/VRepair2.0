static int try_smi_init ( struct smi_info * new_smi ) //<S2SV> { //<S2SV> int rv = 0 ; //<S2SV> int i ; //<S2SV> char * init_name = NULL ; //<S2SV> pr_info ( "Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\n" , //<S2SV> ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , //<S2SV> si_to_str [ new_smi -> io . si_type ] , //<S2SV> addr_space_to_str [ new_smi -> io . addr_type ] , //<S2SV> new_smi -> io . addr_data , //<S2SV> new_smi -> io . slave_addr , new_smi -> io . irq ) ; //<S2SV> switch ( new_smi -> io . si_type ) { //<S2SV> case SI_KCS : //<S2SV> new_smi -> handlers = & kcs_smi_handlers ; //<S2SV> break ; //<S2SV> case SI_SMIC : //<S2SV> new_smi -> handlers = & smic_smi_handlers ; //<S2SV> break ; //<S2SV> case SI_BT : //<S2SV> new_smi -> handlers = & bt_smi_handlers ; //<S2SV> break ; //<S2SV> default : //<S2SV> rv = - EIO ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> new_smi -> si_num = smi_num ; //<S2SV> if ( ! new_smi -> io . dev ) { //<S2SV> init_name = kasprintf ( GFP_KERNEL , "ipmi_si.%d" , //<S2SV> new_smi -> si_num ) ; //<S2SV> new_smi -> pdev = platform_device_alloc ( "ipmi_si" , //<S2SV> new_smi -> si_num ) ; //<S2SV> if ( ! new_smi -> pdev ) { //<S2SV> pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\n" ) ; //<S2SV> rv = - ENOMEM ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> new_smi -> io . dev = & new_smi -> pdev -> dev ; //<S2SV> new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; //<S2SV> new_smi -> io . dev -> init_name = init_name ; //<S2SV> } //<S2SV> new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; //<S2SV> if ( ! new_smi -> si_sm ) { //<S2SV> rv = - ENOMEM ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , //<S2SV> & new_smi -> io ) ; //<S2SV> rv = new_smi -> io . io_setup ( & new_smi -> io ) ; //<S2SV> if ( rv ) { //<S2SV> dev_err ( new_smi -> io . dev , "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\n" ) ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { //<S2SV> if ( new_smi -> io . addr_source ) //<S2SV> dev_err ( new_smi -> io . dev , //<S2SV> "Interface<S2SV_blank>detection<S2SV_blank>failed\\n" ) ; //<S2SV> rv = - ENODEV ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> rv = try_get_dev_id ( new_smi ) ; //<S2SV> if ( rv ) { //<S2SV> if ( new_smi -> io . addr_source ) //<S2SV> dev_err ( new_smi -> io . dev , //<S2SV> "There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\n" ) ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> setup_oem_data_handler ( new_smi ) ; //<S2SV> setup_xaction_handlers ( new_smi ) ; //<S2SV> check_for_broken_irqs ( new_smi ) ; //<S2SV> new_smi -> waiting_msg = NULL ; //<S2SV> new_smi -> curr_msg = NULL ; //<S2SV> atomic_set ( & new_smi -> req_events , 0 ) ; //<S2SV> new_smi -> run_to_completion = false ; //<S2SV> for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) //<S2SV> atomic_set ( & new_smi -> stats [ i ] , 0 ) ; //<S2SV> new_smi -> interrupt_disabled = true ; //<S2SV> atomic_set ( & new_smi -> need_watch , 0 ) ; //<S2SV> rv = try_enable_event_buffer ( new_smi ) ; //<S2SV> if ( rv == 0 ) //<S2SV> new_smi -> has_event_buffer = true ; //<S2SV> start_clear_flags ( new_smi ) ; //<S2SV> if ( new_smi -> io . irq ) { //<S2SV> new_smi -> interrupt_disabled = false ; //<S2SV> atomic_set ( & new_smi -> req_events , 1 ) ; //<S2SV> } //<S2SV> if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { //<S2SV> rv = platform_device_add ( new_smi -> pdev ) ; //<S2SV> if ( rv ) { //<S2SV> dev_err ( new_smi -> io . dev , //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\n" , //<S2SV> rv ) ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> new_smi -> pdev_registered = true ; //<S2SV> } //<S2SV> dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; //<S2SV> rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; //<S2SV> if ( rv ) { //<S2SV> dev_err ( new_smi -> io . dev , //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\n" , //<S2SV> rv ) ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> new_smi -> dev_group_added = true ; //<S2SV> rv = ipmi_register_smi ( & handlers , //<S2SV> new_smi , //<S2SV> new_smi -> io . dev , //<S2SV> new_smi -> io . slave_addr ) ; //<S2SV> if ( rv ) { //<S2SV> dev_err ( new_smi -> io . dev , //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\n" , //<S2SV> rv ) ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> smi_num ++ ; //<S2SV> dev_info ( new_smi -> io . dev , "IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\n" , //<S2SV> si_to_str [ new_smi -> io . si_type ] ) ; //<S2SV> WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; //<S2SV> out_err : //<S2SV> if ( rv && new_smi -> io . io_cleanup ) { //<S2SV> new_smi -> io . io_cleanup ( & new_smi -> io ) ; //<S2SV> new_smi -> io . io_cleanup = NULL ; //<S2SV> } //<S2SV> kfree ( init_name ) ; //<S2SV> return rv ; //<S2SV> } //<S2SV> 