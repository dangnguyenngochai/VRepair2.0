static void ip_expire ( unsigned long arg ) //<S2SV> { //<S2SV> struct ipq * qp ; //<S2SV> struct net * net ; //<S2SV> qp = container_of ( ( struct inet_frag_queue * ) arg , struct ipq , q ) ; //<S2SV> net = container_of ( qp -> q . net , struct net , ipv4 . frags ) ; //<S2SV> spin_lock ( & qp -> q . lock ) ; //<S2SV> if ( qp -> q . last_in & INET_FRAG_COMPLETE ) //<S2SV> goto out ; //<S2SV> ipq_kill ( qp ) ; //<S2SV> IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMTIMEOUT ) ; //<S2SV> IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMFAILS ) ; //<S2SV> if ( ( qp -> q . last_in & INET_FRAG_FIRST_IN ) && qp -> q . fragments != NULL ) { //<S2SV> struct sk_buff * head = qp -> q . fragments ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> head -> dev = dev_get_by_index_rcu ( net , qp -> iif ) ; //<S2SV> if ( ! head -> dev ) //<S2SV> goto out_rcu_unlock ; //<S2SV> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { //<S2SV> const struct iphdr * iph = ip_hdr ( head ) ; //<S2SV> int err = ip_route_input ( head , iph -> daddr , iph -> saddr , //<S2SV> iph -> tos , head -> dev ) ; //<S2SV> if ( unlikely ( err ) ) //<S2SV> goto out_rcu_unlock ; //<S2SV> if ( skb_rtable ( head ) -> rt_type != RTN_LOCAL ) //<S2SV> goto out_rcu_unlock ; //<S2SV> } //<S2SV> icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ; //<S2SV> out_rcu_unlock : //<S2SV> rcu_read_unlock ( ) ; //<S2SV> } //<S2SV> out : //<S2SV> spin_unlock ( & qp -> q . lock ) ; //<S2SV> ipq_put ( qp ) ; //<S2SV> } //<S2SV> 