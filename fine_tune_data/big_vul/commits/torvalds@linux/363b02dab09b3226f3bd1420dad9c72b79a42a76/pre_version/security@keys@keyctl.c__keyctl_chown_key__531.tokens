long keyctl_chown_key ( key_serial_t id , uid_t user , gid_t group ) //<S2SV> { //<S2SV> struct key_user * newowner , * zapowner = NULL ; //<S2SV> struct key * key ; //<S2SV> key_ref_t key_ref ; //<S2SV> long ret ; //<S2SV> kuid_t uid ; //<S2SV> kgid_t gid ; //<S2SV> uid = make_kuid ( current_user_ns ( ) , user ) ; //<S2SV> gid = make_kgid ( current_user_ns ( ) , group ) ; //<S2SV> ret = - EINVAL ; //<S2SV> if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) //<S2SV> goto error ; //<S2SV> if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) //<S2SV> goto error ; //<S2SV> ret = 0 ; //<S2SV> if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) //<S2SV> goto error ; //<S2SV> key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , //<S2SV> KEY_NEED_SETATTR ) ; //<S2SV> if ( IS_ERR ( key_ref ) ) { //<S2SV> ret = PTR_ERR ( key_ref ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> key = key_ref_to_ptr ( key_ref ) ; //<S2SV> ret = - EACCES ; //<S2SV> down_write ( & key -> sem ) ; //<S2SV> if ( ! capable ( CAP_SYS_ADMIN ) ) { //<S2SV> if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) //<S2SV> goto error_put ; //<S2SV> if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) //<S2SV> goto error_put ; //<S2SV> } //<S2SV> if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) { //<S2SV> ret = - ENOMEM ; //<S2SV> newowner = key_user_lookup ( uid ) ; //<S2SV> if ( ! newowner ) //<S2SV> goto error_put ; //<S2SV> if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { //<S2SV> unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? //<S2SV> key_quota_root_maxkeys : key_quota_maxkeys ; //<S2SV> unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? //<S2SV> key_quota_root_maxbytes : key_quota_maxbytes ; //<S2SV> spin_lock ( & newowner -> lock ) ; //<S2SV> if ( newowner -> qnkeys + 1 >= maxkeys || //<S2SV> newowner -> qnbytes + key -> quotalen >= maxbytes || //<S2SV> newowner -> qnbytes + key -> quotalen < //<S2SV> newowner -> qnbytes ) //<S2SV> goto quota_overrun ; //<S2SV> newowner -> qnkeys ++ ; //<S2SV> newowner -> qnbytes += key -> quotalen ; //<S2SV> spin_unlock ( & newowner -> lock ) ; //<S2SV> spin_lock ( & key -> user -> lock ) ; //<S2SV> key -> user -> qnkeys -- ; //<S2SV> key -> user -> qnbytes -= key -> quotalen ; //<S2SV> spin_unlock ( & key -> user -> lock ) ; //<S2SV> } //<S2SV> atomic_dec ( & key -> user -> nkeys ) ; //<S2SV> atomic_inc ( & newowner -> nkeys ) ; //<S2SV> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { //<S2SV> atomic_dec ( & key -> user -> nikeys ) ; //<S2SV> atomic_inc ( & newowner -> nikeys ) ; //<S2SV> } //<S2SV> zapowner = key -> user ; //<S2SV> key -> user = newowner ; //<S2SV> key -> uid = uid ; //<S2SV> } //<S2SV> if ( group != ( gid_t ) - 1 ) //<S2SV> key -> gid = gid ; //<S2SV> ret = 0 ; //<S2SV> error_put : //<S2SV> up_write ( & key -> sem ) ; //<S2SV> key_put ( key ) ; //<S2SV> if ( zapowner ) //<S2SV> key_user_put ( zapowner ) ; //<S2SV> error : //<S2SV> return ret ; //<S2SV> quota_overrun : //<S2SV> spin_unlock ( & newowner -> lock ) ; //<S2SV> zapowner = newowner ; //<S2SV> ret = - EDQUOT ; //<S2SV> goto error_put ; //<S2SV> } //<S2SV> 