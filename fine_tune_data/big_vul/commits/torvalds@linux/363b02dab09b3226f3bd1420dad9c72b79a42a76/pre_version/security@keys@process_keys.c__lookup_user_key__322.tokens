key_ref_t lookup_user_key ( key_serial_t id , unsigned long lflags , //<S2SV> key_perm_t perm ) //<S2SV> { //<S2SV> struct keyring_search_context ctx = { //<S2SV> . match_data . cmp = lookup_user_key_possessed , //<S2SV> . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , //<S2SV> . flags = KEYRING_SEARCH_NO_STATE_CHECK , //<S2SV> } ; //<S2SV> struct request_key_auth * rka ; //<S2SV> struct key * key ; //<S2SV> key_ref_t key_ref , skey_ref ; //<S2SV> int ret ; //<S2SV> try_again : //<S2SV> ctx . cred = get_current_cred ( ) ; //<S2SV> key_ref = ERR_PTR ( - ENOKEY ) ; //<S2SV> switch ( id ) { //<S2SV> case KEY_SPEC_THREAD_KEYRING : //<S2SV> if ( ! ctx . cred -> thread_keyring ) { //<S2SV> if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) //<S2SV> goto error ; //<S2SV> ret = install_thread_keyring ( ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> key_ref = ERR_PTR ( ret ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> goto reget_creds ; //<S2SV> } //<S2SV> key = ctx . cred -> thread_keyring ; //<S2SV> __key_get ( key ) ; //<S2SV> key_ref = make_key_ref ( key , 1 ) ; //<S2SV> break ; //<S2SV> case KEY_SPEC_PROCESS_KEYRING : //<S2SV> if ( ! ctx . cred -> process_keyring ) { //<S2SV> if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) //<S2SV> goto error ; //<S2SV> ret = install_process_keyring ( ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> key_ref = ERR_PTR ( ret ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> goto reget_creds ; //<S2SV> } //<S2SV> key = ctx . cred -> process_keyring ; //<S2SV> __key_get ( key ) ; //<S2SV> key_ref = make_key_ref ( key , 1 ) ; //<S2SV> break ; //<S2SV> case KEY_SPEC_SESSION_KEYRING : //<S2SV> if ( ! ctx . cred -> session_keyring ) { //<S2SV> ret = install_user_keyrings ( ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto error ; //<S2SV> if ( lflags & KEY_LOOKUP_CREATE ) //<S2SV> ret = join_session_keyring ( NULL ) ; //<S2SV> else //<S2SV> ret = install_session_keyring ( //<S2SV> ctx . cred -> user -> session_keyring ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto error ; //<S2SV> goto reget_creds ; //<S2SV> } else if ( ctx . cred -> session_keyring == //<S2SV> ctx . cred -> user -> session_keyring && //<S2SV> lflags & KEY_LOOKUP_CREATE ) { //<S2SV> ret = join_session_keyring ( NULL ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto error ; //<S2SV> goto reget_creds ; //<S2SV> } //<S2SV> rcu_read_lock ( ) ; //<S2SV> key = rcu_dereference ( ctx . cred -> session_keyring ) ; //<S2SV> __key_get ( key ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> key_ref = make_key_ref ( key , 1 ) ; //<S2SV> break ; //<S2SV> case KEY_SPEC_USER_KEYRING : //<S2SV> if ( ! ctx . cred -> user -> uid_keyring ) { //<S2SV> ret = install_user_keyrings ( ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto error ; //<S2SV> } //<S2SV> key = ctx . cred -> user -> uid_keyring ; //<S2SV> __key_get ( key ) ; //<S2SV> key_ref = make_key_ref ( key , 1 ) ; //<S2SV> break ; //<S2SV> case KEY_SPEC_USER_SESSION_KEYRING : //<S2SV> if ( ! ctx . cred -> user -> session_keyring ) { //<S2SV> ret = install_user_keyrings ( ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto error ; //<S2SV> } //<S2SV> key = ctx . cred -> user -> session_keyring ; //<S2SV> __key_get ( key ) ; //<S2SV> key_ref = make_key_ref ( key , 1 ) ; //<S2SV> break ; //<S2SV> case KEY_SPEC_GROUP_KEYRING : //<S2SV> key_ref = ERR_PTR ( - EINVAL ) ; //<S2SV> goto error ; //<S2SV> case KEY_SPEC_REQKEY_AUTH_KEY : //<S2SV> key = ctx . cred -> request_key_auth ; //<S2SV> if ( ! key ) //<S2SV> goto error ; //<S2SV> __key_get ( key ) ; //<S2SV> key_ref = make_key_ref ( key , 1 ) ; //<S2SV> break ; //<S2SV> case KEY_SPEC_REQUESTOR_KEYRING : //<S2SV> if ( ! ctx . cred -> request_key_auth ) //<S2SV> goto error ; //<S2SV> down_read ( & ctx . cred -> request_key_auth -> sem ) ; //<S2SV> if ( test_bit ( KEY_FLAG_REVOKED , //<S2SV> & ctx . cred -> request_key_auth -> flags ) ) { //<S2SV> key_ref = ERR_PTR ( - EKEYREVOKED ) ; //<S2SV> key = NULL ; //<S2SV> } else { //<S2SV> rka = ctx . cred -> request_key_auth -> payload . data [ 0 ] ; //<S2SV> key = rka -> dest_keyring ; //<S2SV> __key_get ( key ) ; //<S2SV> } //<S2SV> up_read ( & ctx . cred -> request_key_auth -> sem ) ; //<S2SV> if ( ! key ) //<S2SV> goto error ; //<S2SV> key_ref = make_key_ref ( key , 1 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> key_ref = ERR_PTR ( - EINVAL ) ; //<S2SV> if ( id < 1 ) //<S2SV> goto error ; //<S2SV> key = key_lookup ( id ) ; //<S2SV> if ( IS_ERR ( key ) ) { //<S2SV> key_ref = ERR_CAST ( key ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> key_ref = make_key_ref ( key , 0 ) ; //<S2SV> ctx . index_key . type = key -> type ; //<S2SV> ctx . index_key . description = key -> description ; //<S2SV> ctx . index_key . desc_len = strlen ( key -> description ) ; //<S2SV> ctx . match_data . raw_data = key ; //<S2SV> kdebug ( "check<S2SV_blank>possessed" ) ; //<S2SV> skey_ref = search_process_keyrings ( & ctx ) ; //<S2SV> kdebug ( "possessed=%p" , skey_ref ) ; //<S2SV> if ( ! IS_ERR ( skey_ref ) ) { //<S2SV> key_put ( key ) ; //<S2SV> key_ref = skey_ref ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> if ( lflags & KEY_LOOKUP_FOR_UNLINK ) { //<S2SV> ret = 0 ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) ) { //<S2SV> ret = wait_for_key_construction ( key , true ) ; //<S2SV> switch ( ret ) { //<S2SV> case - ERESTARTSYS : //<S2SV> goto invalid_key ; //<S2SV> default : //<S2SV> if ( perm ) //<S2SV> goto invalid_key ; //<S2SV> case 0 : //<S2SV> break ; //<S2SV> } //<S2SV> } else if ( perm ) { //<S2SV> ret = key_validate ( key ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto invalid_key ; //<S2SV> } //<S2SV> ret = - EIO ; //<S2SV> if ( ! ( lflags & KEY_LOOKUP_PARTIAL ) && //<S2SV> ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) //<S2SV> goto invalid_key ; //<S2SV> ret = key_task_permission ( key_ref , ctx . cred , perm ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto invalid_key ; //<S2SV> key -> last_used_at = current_kernel_time ( ) . tv_sec ; //<S2SV> error : //<S2SV> put_cred ( ctx . cred ) ; //<S2SV> return key_ref ; //<S2SV> invalid_key : //<S2SV> key_ref_put ( key_ref ) ; //<S2SV> key_ref = ERR_PTR ( ret ) ; //<S2SV> goto error ; //<S2SV> reget_creds : //<S2SV> put_cred ( ctx . cred ) ; //<S2SV> goto try_again ; //<S2SV> } //<S2SV> 