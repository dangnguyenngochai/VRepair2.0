int key_reject_and_link ( struct key * key , //<S2SV> unsigned timeout , //<S2SV> unsigned error , //<S2SV> struct key * keyring , //<S2SV> struct key * authkey ) //<S2SV> { //<S2SV> struct assoc_array_edit * edit ; //<S2SV> struct timespec now ; //<S2SV> int ret , awaken , link_ret = 0 ; //<S2SV> key_check ( key ) ; //<S2SV> key_check ( keyring ) ; //<S2SV> awaken = 0 ; //<S2SV> ret = - EBUSY ; //<S2SV> if ( keyring ) { //<S2SV> if ( keyring -> restrict_link ) //<S2SV> return - EPERM ; //<S2SV> link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; //<S2SV> } //<S2SV> mutex_lock ( & key_construction_mutex ) ; //<S2SV> if ( key -> state == KEY_IS_UNINSTANTIATED ) { //<S2SV> atomic_inc ( & key -> user -> nikeys ) ; //<S2SV> mark_key_instantiated ( key , - error ) ; //<S2SV> now = current_kernel_time ( ) ; //<S2SV> key -> expiry = now . tv_sec + timeout ; //<S2SV> key_schedule_gc ( key -> expiry + key_gc_delay ) ; //<S2SV> if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) //<S2SV> awaken = 1 ; //<S2SV> ret = 0 ; //<S2SV> if ( keyring && link_ret == 0 ) //<S2SV> __key_link ( key , & edit ) ; //<S2SV> if ( authkey ) //<S2SV> key_revoke ( authkey ) ; //<S2SV> } //<S2SV> mutex_unlock ( & key_construction_mutex ) ; //<S2SV> if ( keyring && link_ret == 0 ) //<S2SV> __key_link_end ( keyring , & key -> index_key , edit ) ; //<S2SV> if ( awaken ) //<S2SV> wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; //<S2SV> return ret == 0 ? link_ret : ret ; //<S2SV> } //<S2SV> 