long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) //<S2SV> { //<S2SV> struct key * key ; //<S2SV> key_ref_t key_ref ; //<S2SV> long ret ; //<S2SV> key_ref = lookup_user_key ( keyid , 0 , 0 ) ; //<S2SV> if ( IS_ERR ( key_ref ) ) { //<S2SV> ret = - ENOKEY ; //<S2SV> goto error ; //<S2SV> } //<S2SV> key = key_ref_to_ptr ( key_ref ) ; //<S2SV> ret = key_read_state ( key ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto error2 ; //<S2SV> ret = key_permission ( key_ref , KEY_NEED_READ ) ; //<S2SV> if ( ret == 0 ) //<S2SV> goto can_read_key ; //<S2SV> if ( ret != - EACCES ) //<S2SV> goto error2 ; //<S2SV> if ( ! is_key_possessed ( key_ref ) ) { //<S2SV> ret = - EACCES ; //<S2SV> goto error2 ; //<S2SV> } //<S2SV> can_read_key : //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> if ( key -> type -> read ) { //<S2SV> down_read ( & key -> sem ) ; //<S2SV> ret = key_validate ( key ) ; //<S2SV> if ( ret == 0 ) //<S2SV> ret = key -> type -> read ( key , buffer , buflen ) ; //<S2SV> up_read ( & key -> sem ) ; //<S2SV> } //<S2SV> error2 : //<S2SV> key_put ( key ) ; //<S2SV> error : //<S2SV> return ret ; //<S2SV> } //<S2SV> 