static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) //<S2SV> { //<S2SV> struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; //<S2SV> struct encrypted_key_payload * new_epayload ; //<S2SV> char * buf ; //<S2SV> char * new_master_desc = NULL ; //<S2SV> const char * format = NULL ; //<S2SV> size_t datalen = prep -> datalen ; //<S2SV> int ret = 0 ; //<S2SV> if ( key_is_negative ( key ) ) //<S2SV> return - ENOKEY ; //<S2SV> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) //<S2SV> return - EINVAL ; //<S2SV> buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; //<S2SV> if ( ! buf ) //<S2SV> return - ENOMEM ; //<S2SV> buf [ datalen ] = 0 ; //<S2SV> memcpy ( buf , prep -> data , datalen ) ; //<S2SV> ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto out ; //<S2SV> ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto out ; //<S2SV> new_epayload = encrypted_key_alloc ( key , epayload -> format , //<S2SV> new_master_desc , epayload -> datalen ) ; //<S2SV> if ( IS_ERR ( new_epayload ) ) { //<S2SV> ret = PTR_ERR ( new_epayload ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> __ekey_init ( new_epayload , epayload -> format , new_master_desc , //<S2SV> epayload -> datalen ) ; //<S2SV> memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; //<S2SV> memcpy ( new_epayload -> payload_data , epayload -> payload_data , //<S2SV> epayload -> payload_datalen ) ; //<S2SV> rcu_assign_keypointer ( key , new_epayload ) ; //<S2SV> call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; //<S2SV> out : //<S2SV> kzfree ( buf ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 