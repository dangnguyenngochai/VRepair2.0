static int __key_instantiate_and_link ( struct key * key , //<S2SV> struct key_preparsed_payload * prep , //<S2SV> struct key * keyring , //<S2SV> struct key * authkey , //<S2SV> struct assoc_array_edit * * _edit ) //<S2SV> { //<S2SV> int ret , awaken ; //<S2SV> key_check ( key ) ; //<S2SV> key_check ( keyring ) ; //<S2SV> awaken = 0 ; //<S2SV> ret = - EBUSY ; //<S2SV> mutex_lock ( & key_construction_mutex ) ; //<S2SV> if ( key -> state == KEY_IS_UNINSTANTIATED ) { //<S2SV> ret = key -> type -> instantiate ( key , prep ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> atomic_inc ( & key -> user -> nikeys ) ; //<S2SV> mark_key_instantiated ( key , 0 ) ; //<S2SV> if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) //<S2SV> awaken = 1 ; //<S2SV> if ( keyring ) { //<S2SV> if ( test_bit ( KEY_FLAG_KEEP , & keyring -> flags ) ) //<S2SV> set_bit ( KEY_FLAG_KEEP , & key -> flags ) ; //<S2SV> __key_link ( key , _edit ) ; //<S2SV> } //<S2SV> if ( authkey ) //<S2SV> key_revoke ( authkey ) ; //<S2SV> if ( prep -> expiry != TIME_T_MAX ) { //<S2SV> key -> expiry = prep -> expiry ; //<S2SV> key_schedule_gc ( prep -> expiry + key_gc_delay ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> mutex_unlock ( & key_construction_mutex ) ; //<S2SV> if ( awaken ) //<S2SV> wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 