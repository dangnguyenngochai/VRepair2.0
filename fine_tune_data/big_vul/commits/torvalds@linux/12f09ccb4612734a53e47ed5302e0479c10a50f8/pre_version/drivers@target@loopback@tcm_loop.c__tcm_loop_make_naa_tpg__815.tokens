struct se_portal_group * tcm_loop_make_naa_tpg ( //<S2SV> struct se_wwn * wwn , //<S2SV> struct config_group * group , //<S2SV> const char * name ) //<S2SV> { //<S2SV> struct tcm_loop_hba * tl_hba = container_of ( wwn , //<S2SV> struct tcm_loop_hba , tl_hba_wwn ) ; //<S2SV> struct tcm_loop_tpg * tl_tpg ; //<S2SV> char * tpgt_str , * end_ptr ; //<S2SV> int ret ; //<S2SV> unsigned short int tpgt ; //<S2SV> tpgt_str = strstr ( name , "tpgt_" ) ; //<S2SV> if ( ! tpgt_str ) { //<S2SV> printk ( KERN_ERR "Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>\\"tpgt_#\\"<S2SV_blank>directory" //<S2SV> "<S2SV_blank>group\\n" ) ; //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> } //<S2SV> tpgt_str += 5 ; //<S2SV> tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; //<S2SV> if ( tpgt > TL_TPGS_PER_HBA ) { //<S2SV> printk ( KERN_ERR "Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:" //<S2SV> "<S2SV_blank>%u\\n" , tpgt , TL_TPGS_PER_HBA ) ; //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> } //<S2SV> tl_tpg = & tl_hba -> tl_hba_tpgs [ tpgt ] ; //<S2SV> tl_tpg -> tl_hba = tl_hba ; //<S2SV> tl_tpg -> tl_tpgt = tpgt ; //<S2SV> ret = core_tpg_register ( & tcm_loop_fabric_configfs -> tf_ops , //<S2SV> wwn , & tl_tpg -> tl_se_tpg , tl_tpg , //<S2SV> TRANSPORT_TPG_TYPE_NORMAL ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> printk ( KERN_INFO "TCM_Loop_ConfigFS:<S2SV_blank>Allocated<S2SV_blank>Emulated<S2SV_blank>%s" //<S2SV> "<S2SV_blank>Target<S2SV_blank>Port<S2SV_blank>%s,t,0x%04x\\n" , tcm_loop_dump_proto_id ( tl_hba ) , //<S2SV> config_item_name ( & wwn -> wwn_group . cg_item ) , tpgt ) ; //<S2SV> return & tl_tpg -> tl_se_tpg ; //<S2SV> } //<S2SV> 