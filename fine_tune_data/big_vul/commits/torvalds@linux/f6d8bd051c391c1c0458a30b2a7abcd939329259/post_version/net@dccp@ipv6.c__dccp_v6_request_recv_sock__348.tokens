static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , //<S2SV> struct sk_buff * skb , //<S2SV> struct request_sock * req , //<S2SV> struct dst_entry * dst ) //<S2SV> { //<S2SV> struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; //<S2SV> struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; //<S2SV> struct inet_sock * newinet ; //<S2SV> struct dccp6_sock * newdp6 ; //<S2SV> struct sock * newsk ; //<S2SV> struct ipv6_txoptions * opt ; //<S2SV> if ( skb -> protocol == htons ( ETH_P_IP ) ) { //<S2SV> newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; //<S2SV> if ( newsk == NULL ) //<S2SV> return NULL ; //<S2SV> newdp6 = ( struct dccp6_sock * ) newsk ; //<S2SV> newinet = inet_sk ( newsk ) ; //<S2SV> newinet -> pinet6 = & newdp6 -> inet6 ; //<S2SV> newnp = inet6_sk ( newsk ) ; //<S2SV> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; //<S2SV> ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; //<S2SV> ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; //<S2SV> ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; //<S2SV> inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; //<S2SV> newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; //<S2SV> newnp -> pktoptions = NULL ; //<S2SV> newnp -> opt = NULL ; //<S2SV> newnp -> mcast_oif = inet6_iif ( skb ) ; //<S2SV> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; //<S2SV> dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; //<S2SV> return newsk ; //<S2SV> } //<S2SV> opt = np -> opt ; //<S2SV> if ( sk_acceptq_is_full ( sk ) ) //<S2SV> goto out_overflow ; //<S2SV> if ( dst == NULL ) { //<S2SV> struct in6_addr * final_p , final ; //<S2SV> struct flowi6 fl6 ; //<S2SV> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; //<S2SV> fl6 . flowi6_proto = IPPROTO_DCCP ; //<S2SV> ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; //<S2SV> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; //<S2SV> ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; //<S2SV> fl6 . flowi6_oif = sk -> sk_bound_dev_if ; //<S2SV> fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; //<S2SV> fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; //<S2SV> security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; //<S2SV> if ( IS_ERR ( dst ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> newsk = dccp_create_openreq_child ( sk , req , skb ) ; //<S2SV> if ( newsk == NULL ) //<S2SV> goto out_nonewsk ; //<S2SV> __ip6_dst_store ( newsk , dst , NULL , NULL ) ; //<S2SV> newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | //<S2SV> NETIF_F_TSO ) ; //<S2SV> newdp6 = ( struct dccp6_sock * ) newsk ; //<S2SV> newinet = inet_sk ( newsk ) ; //<S2SV> newinet -> pinet6 = & newdp6 -> inet6 ; //<S2SV> newnp = inet6_sk ( newsk ) ; //<S2SV> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; //<S2SV> ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; //<S2SV> ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; //<S2SV> ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; //<S2SV> newsk -> sk_bound_dev_if = ireq6 -> iif ; //<S2SV> newinet -> inet_opt = NULL ; //<S2SV> newnp -> rxopt . all = np -> rxopt . all ; //<S2SV> newnp -> pktoptions = NULL ; //<S2SV> if ( ireq6 -> pktopts != NULL ) { //<S2SV> newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; //<S2SV> kfree_skb ( ireq6 -> pktopts ) ; //<S2SV> ireq6 -> pktopts = NULL ; //<S2SV> if ( newnp -> pktoptions ) //<S2SV> skb_set_owner_r ( newnp -> pktoptions , newsk ) ; //<S2SV> } //<S2SV> newnp -> opt = NULL ; //<S2SV> newnp -> mcast_oif = inet6_iif ( skb ) ; //<S2SV> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; //<S2SV> if ( opt != NULL ) { //<S2SV> newnp -> opt = ipv6_dup_options ( newsk , opt ) ; //<S2SV> if ( opt != np -> opt ) //<S2SV> sock_kfree_s ( sk , opt , opt -> tot_len ) ; //<S2SV> } //<S2SV> inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; //<S2SV> if ( newnp -> opt != NULL ) //<S2SV> inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + //<S2SV> newnp -> opt -> opt_flen ) ; //<S2SV> dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; //<S2SV> newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; //<S2SV> newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; //<S2SV> if ( __inet_inherit_port ( sk , newsk ) < 0 ) { //<S2SV> sock_put ( newsk ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> __inet6_hash ( newsk , NULL ) ; //<S2SV> return newsk ; //<S2SV> out_overflow : //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; //<S2SV> out_nonewsk : //<S2SV> dst_release ( dst ) ; //<S2SV> out : //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; //<S2SV> if ( opt != NULL && opt != np -> opt ) //<S2SV> sock_kfree_s ( sk , opt , opt -> tot_len ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 