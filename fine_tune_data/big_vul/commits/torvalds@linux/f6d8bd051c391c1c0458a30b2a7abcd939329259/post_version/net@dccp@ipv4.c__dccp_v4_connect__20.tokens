int dccp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) //<S2SV> { //<S2SV> const struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct dccp_sock * dp = dccp_sk ( sk ) ; //<S2SV> __be16 orig_sport , orig_dport ; //<S2SV> __be32 daddr , nexthop ; //<S2SV> struct flowi4 fl4 ; //<S2SV> struct rtable * rt ; //<S2SV> int err ; //<S2SV> struct ip_options_rcu * inet_opt ; //<S2SV> dp -> dccps_role = DCCP_ROLE_CLIENT ; //<S2SV> if ( addr_len < sizeof ( struct sockaddr_in ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( usin -> sin_family != AF_INET ) //<S2SV> return - EAFNOSUPPORT ; //<S2SV> nexthop = daddr = usin -> sin_addr . s_addr ; //<S2SV> inet_opt = rcu_dereference_protected ( inet -> inet_opt , //<S2SV> sock_owned_by_user ( sk ) ) ; //<S2SV> if ( inet_opt != NULL && inet_opt -> opt . srr ) { //<S2SV> if ( daddr == 0 ) //<S2SV> return - EINVAL ; //<S2SV> nexthop = inet_opt -> opt . faddr ; //<S2SV> } //<S2SV> orig_sport = inet -> inet_sport ; //<S2SV> orig_dport = usin -> sin_port ; //<S2SV> rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , //<S2SV> RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , //<S2SV> IPPROTO_DCCP , //<S2SV> orig_sport , orig_dport , sk , true ) ; //<S2SV> if ( IS_ERR ( rt ) ) //<S2SV> return PTR_ERR ( rt ) ; //<S2SV> if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { //<S2SV> ip_rt_put ( rt ) ; //<S2SV> return - ENETUNREACH ; //<S2SV> } //<S2SV> if ( inet_opt == NULL || ! inet_opt -> opt . srr ) //<S2SV> daddr = rt -> rt_dst ; //<S2SV> if ( inet -> inet_saddr == 0 ) //<S2SV> inet -> inet_saddr = rt -> rt_src ; //<S2SV> inet -> inet_rcv_saddr = inet -> inet_saddr ; //<S2SV> inet -> inet_dport = usin -> sin_port ; //<S2SV> inet -> inet_daddr = daddr ; //<S2SV> inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; //<S2SV> if ( inet_opt ) //<S2SV> inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . optlen ; //<S2SV> dccp_set_state ( sk , DCCP_REQUESTING ) ; //<S2SV> err = inet_hash_connect ( & dccp_death_row , sk ) ; //<S2SV> if ( err != 0 ) //<S2SV> goto failure ; //<S2SV> rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , //<S2SV> inet -> inet_sport , inet -> inet_dport , sk ) ; //<S2SV> if ( IS_ERR ( rt ) ) { //<S2SV> rt = NULL ; //<S2SV> goto failure ; //<S2SV> } //<S2SV> sk_setup_caps ( sk , & rt -> dst ) ; //<S2SV> dp -> dccps_iss = secure_dccp_sequence_number ( inet -> inet_saddr , //<S2SV> inet -> inet_daddr , //<S2SV> inet -> inet_sport , //<S2SV> inet -> inet_dport ) ; //<S2SV> inet -> inet_id = dp -> dccps_iss ^ jiffies ; //<S2SV> err = dccp_connect ( sk ) ; //<S2SV> rt = NULL ; //<S2SV> if ( err != 0 ) //<S2SV> goto failure ; //<S2SV> out : //<S2SV> return err ; //<S2SV> failure : //<S2SV> dccp_set_state ( sk , DCCP_CLOSED ) ; //<S2SV> ip_rt_put ( rt ) ; //<S2SV> sk -> sk_route_caps = 0 ; //<S2SV> inet -> inet_dport = 0 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 