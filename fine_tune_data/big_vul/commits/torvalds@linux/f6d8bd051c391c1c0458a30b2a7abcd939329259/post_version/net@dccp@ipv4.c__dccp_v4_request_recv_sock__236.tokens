struct sock * dccp_v4_request_recv_sock ( struct sock * sk , struct sk_buff * skb , //<S2SV> struct request_sock * req , //<S2SV> struct dst_entry * dst ) //<S2SV> { //<S2SV> struct inet_request_sock * ireq ; //<S2SV> struct inet_sock * newinet ; //<S2SV> struct sock * newsk ; //<S2SV> if ( sk_acceptq_is_full ( sk ) ) //<S2SV> goto exit_overflow ; //<S2SV> if ( dst == NULL && ( dst = inet_csk_route_req ( sk , req ) ) == NULL ) //<S2SV> goto exit ; //<S2SV> newsk = dccp_create_openreq_child ( sk , req , skb ) ; //<S2SV> if ( newsk == NULL ) //<S2SV> goto exit_nonewsk ; //<S2SV> sk_setup_caps ( newsk , dst ) ; //<S2SV> newinet = inet_sk ( newsk ) ; //<S2SV> ireq = inet_rsk ( req ) ; //<S2SV> newinet -> inet_daddr = ireq -> rmt_addr ; //<S2SV> newinet -> inet_rcv_saddr = ireq -> loc_addr ; //<S2SV> newinet -> inet_saddr = ireq -> loc_addr ; //<S2SV> newinet -> inet_opt = ireq -> opt ; //<S2SV> ireq -> opt = NULL ; //<S2SV> newinet -> mc_index = inet_iif ( skb ) ; //<S2SV> newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; //<S2SV> newinet -> inet_id = jiffies ; //<S2SV> dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; //<S2SV> if ( __inet_inherit_port ( sk , newsk ) < 0 ) { //<S2SV> sock_put ( newsk ) ; //<S2SV> goto exit ; //<S2SV> } //<S2SV> __inet_hash_nolisten ( newsk , NULL ) ; //<S2SV> return newsk ; //<S2SV> exit_overflow : //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; //<S2SV> exit_nonewsk : //<S2SV> dst_release ( dst ) ; //<S2SV> exit : //<S2SV> NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 