int inet_sk_rebuild_header ( struct sock * sk ) //<S2SV> { //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct rtable * rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ; //<S2SV> __be32 daddr ; //<S2SV> struct ip_options_rcu * inet_opt ; //<S2SV> int err ; //<S2SV> if ( rt ) //<S2SV> return 0 ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> inet_opt = rcu_dereference ( inet -> inet_opt ) ; //<S2SV> daddr = inet -> inet_daddr ; //<S2SV> if ( inet_opt && inet_opt -> opt . srr ) //<S2SV> daddr = inet_opt -> opt . faddr ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , //<S2SV> inet -> inet_dport , inet -> inet_sport , //<S2SV> sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , //<S2SV> sk -> sk_bound_dev_if ) ; //<S2SV> if ( ! IS_ERR ( rt ) ) { //<S2SV> err = 0 ; //<S2SV> sk_setup_caps ( sk , & rt -> dst ) ; //<S2SV> } else { //<S2SV> err = PTR_ERR ( rt ) ; //<S2SV> sk -> sk_route_caps = 0 ; //<S2SV> if ( ! sysctl_ip_dynaddr || //<S2SV> sk -> sk_state != TCP_SYN_SENT || //<S2SV> ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) || //<S2SV> ( err = inet_sk_reselect_saddr ( sk ) ) != 0 ) //<S2SV> sk -> sk_err_soft = - err ; //<S2SV> } //<S2SV> return err ; //<S2SV> } //<S2SV> 