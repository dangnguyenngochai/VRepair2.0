static int do_anonymous_page ( struct mm_struct * mm , struct vm_area_struct * vma , //<S2SV> unsigned long address , pte_t * page_table , pmd_t * pmd , //<S2SV> unsigned int flags ) //<S2SV> { //<S2SV> struct mem_cgroup * memcg ; //<S2SV> struct page * page ; //<S2SV> spinlock_t * ptl ; //<S2SV> pte_t entry ; //<S2SV> pte_unmap ( page_table ) ; //<S2SV> if ( check_stack_guard_page ( vma , address ) < 0 ) //<S2SV> return VM_FAULT_SIGSEGV ; //<S2SV> if ( ! ( flags & FAULT_FLAG_WRITE ) && ! mm_forbids_zeropage ( mm ) ) { //<S2SV> entry = pte_mkspecial ( pfn_pte ( my_zero_pfn ( address ) , //<S2SV> vma -> vm_page_prot ) ) ; //<S2SV> page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; //<S2SV> if ( ! pte_none ( * page_table ) ) //<S2SV> goto unlock ; //<S2SV> goto setpte ; //<S2SV> } //<S2SV> if ( unlikely ( anon_vma_prepare ( vma ) ) ) //<S2SV> goto oom ; //<S2SV> page = alloc_zeroed_user_highpage_movable ( vma , address ) ; //<S2SV> if ( ! page ) //<S2SV> goto oom ; //<S2SV> if ( mem_cgroup_try_charge ( page , mm , GFP_KERNEL , & memcg ) ) //<S2SV> goto oom_free_page ; //<S2SV> __SetPageUptodate ( page ) ; //<S2SV> entry = mk_pte ( page , vma -> vm_page_prot ) ; //<S2SV> if ( vma -> vm_flags & VM_WRITE ) //<S2SV> entry = pte_mkwrite ( pte_mkdirty ( entry ) ) ; //<S2SV> page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; //<S2SV> if ( ! pte_none ( * page_table ) ) //<S2SV> goto release ; //<S2SV> inc_mm_counter_fast ( mm , MM_ANONPAGES ) ; //<S2SV> page_add_new_anon_rmap ( page , vma , address ) ; //<S2SV> mem_cgroup_commit_charge ( page , memcg , false ) ; //<S2SV> lru_cache_add_active_or_unevictable ( page , vma ) ; //<S2SV> setpte : //<S2SV> set_pte_at ( mm , address , page_table , entry ) ; //<S2SV> update_mmu_cache ( vma , address , page_table ) ; //<S2SV> unlock : //<S2SV> pte_unmap_unlock ( page_table , ptl ) ; //<S2SV> return 0 ; //<S2SV> release : //<S2SV> mem_cgroup_cancel_charge ( page , memcg ) ; //<S2SV> page_cache_release ( page ) ; //<S2SV> goto unlock ; //<S2SV> oom_free_page : //<S2SV> page_cache_release ( page ) ; //<S2SV> oom : //<S2SV> return VM_FAULT_OOM ; //<S2SV> } //<S2SV> 