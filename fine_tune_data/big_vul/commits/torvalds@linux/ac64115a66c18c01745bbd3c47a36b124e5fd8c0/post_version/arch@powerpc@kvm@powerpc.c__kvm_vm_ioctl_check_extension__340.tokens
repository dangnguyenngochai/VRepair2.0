int kvm_vm_ioctl_check_extension ( struct kvm * kvm , long ext ) //<S2SV> { //<S2SV> int r ; //<S2SV> int hv_enabled = kvmppc_hv_ops ? 1 : 0 ; //<S2SV> if ( kvm ) { //<S2SV> hv_enabled = is_kvmppc_hv_enabled ( kvm ) ; //<S2SV> } //<S2SV> switch ( ext ) { //<S2SV> # ifdef CONFIG_BOOKE //<S2SV> case KVM_CAP_PPC_BOOKE_SREGS : //<S2SV> case KVM_CAP_PPC_BOOKE_WATCHDOG : //<S2SV> case KVM_CAP_PPC_EPR : //<S2SV> # else //<S2SV> case KVM_CAP_PPC_SEGSTATE : //<S2SV> case KVM_CAP_PPC_HIOR : //<S2SV> case KVM_CAP_PPC_PAPR : //<S2SV> # endif //<S2SV> case KVM_CAP_PPC_UNSET_IRQ : //<S2SV> case KVM_CAP_PPC_IRQ_LEVEL : //<S2SV> case KVM_CAP_ENABLE_CAP : //<S2SV> case KVM_CAP_ENABLE_CAP_VM : //<S2SV> case KVM_CAP_ONE_REG : //<S2SV> case KVM_CAP_IOEVENTFD : //<S2SV> case KVM_CAP_DEVICE_CTRL : //<S2SV> case KVM_CAP_IMMEDIATE_EXIT : //<S2SV> r = 1 ; //<S2SV> break ; //<S2SV> case KVM_CAP_PPC_PAIRED_SINGLES : //<S2SV> case KVM_CAP_PPC_OSI : //<S2SV> case KVM_CAP_PPC_GET_PVINFO : //<S2SV> # if defined ( CONFIG_KVM_E500V2 ) || defined ( CONFIG_KVM_E500MC ) //<S2SV> case KVM_CAP_SW_TLB : //<S2SV> # endif //<S2SV> r = ! hv_enabled ; //<S2SV> break ; //<S2SV> # ifdef CONFIG_KVM_MPIC //<S2SV> case KVM_CAP_IRQ_MPIC : //<S2SV> r = 1 ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef CONFIG_PPC_BOOK3S_64 //<S2SV> case KVM_CAP_SPAPR_TCE : //<S2SV> case KVM_CAP_SPAPR_TCE_64 : //<S2SV> case KVM_CAP_SPAPR_TCE_VFIO : //<S2SV> case KVM_CAP_PPC_RTAS : //<S2SV> case KVM_CAP_PPC_FIXUP_HCALL : //<S2SV> case KVM_CAP_PPC_ENABLE_HCALL : //<S2SV> # ifdef CONFIG_KVM_XICS //<S2SV> case KVM_CAP_IRQ_XICS : //<S2SV> # endif //<S2SV> r = 1 ; //<S2SV> break ; //<S2SV> case KVM_CAP_PPC_ALLOC_HTAB : //<S2SV> r = hv_enabled ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE //<S2SV> case KVM_CAP_PPC_SMT : //<S2SV> r = 0 ; //<S2SV> if ( kvm ) { //<S2SV> if ( kvm -> arch . emul_smt_mode > 1 ) //<S2SV> r = kvm -> arch . emul_smt_mode ; //<S2SV> else //<S2SV> r = kvm -> arch . smt_mode ; //<S2SV> } else if ( hv_enabled ) { //<S2SV> if ( cpu_has_feature ( CPU_FTR_ARCH_300 ) ) //<S2SV> r = 1 ; //<S2SV> else //<S2SV> r = threads_per_subcore ; //<S2SV> } //<S2SV> break ; //<S2SV> case KVM_CAP_PPC_SMT_POSSIBLE : //<S2SV> r = 1 ; //<S2SV> if ( hv_enabled ) { //<S2SV> if ( ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ) //<S2SV> r = ( ( threads_per_subcore << 1 ) - 1 ) ; //<S2SV> else //<S2SV> r = 8 | 4 | 2 | 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case KVM_CAP_PPC_RMA : //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> case KVM_CAP_PPC_HWRNG : //<S2SV> r = kvmppc_hwrng_present ( ) ; //<S2SV> break ; //<S2SV> case KVM_CAP_PPC_MMU_RADIX : //<S2SV> r = ! ! ( hv_enabled && radix_enabled ( ) ) ; //<S2SV> break ; //<S2SV> case KVM_CAP_PPC_MMU_HASH_V3 : //<S2SV> r = ! ! ( hv_enabled && ! radix_enabled ( ) && //<S2SV> cpu_has_feature ( CPU_FTR_ARCH_300 ) ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case KVM_CAP_SYNC_MMU : //<S2SV> # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE //<S2SV> r = hv_enabled ; //<S2SV> # elif defined ( KVM_ARCH_WANT_MMU_NOTIFIER ) //<S2SV> r = 1 ; //<S2SV> # else //<S2SV> r = 0 ; //<S2SV> # endif //<S2SV> break ; //<S2SV> # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE //<S2SV> case KVM_CAP_PPC_HTAB_FD : //<S2SV> r = hv_enabled ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case KVM_CAP_NR_VCPUS : //<S2SV> if ( hv_enabled ) //<S2SV> r = num_present_cpus ( ) ; //<S2SV> else //<S2SV> r = num_online_cpus ( ) ; //<S2SV> break ; //<S2SV> case KVM_CAP_NR_MEMSLOTS : //<S2SV> r = KVM_USER_MEM_SLOTS ; //<S2SV> break ; //<S2SV> case KVM_CAP_MAX_VCPUS : //<S2SV> r = KVM_MAX_VCPUS ; //<S2SV> break ; //<S2SV> # ifdef CONFIG_PPC_BOOK3S_64 //<S2SV> case KVM_CAP_PPC_GET_SMMU_INFO : //<S2SV> r = 1 ; //<S2SV> break ; //<S2SV> case KVM_CAP_SPAPR_MULTITCE : //<S2SV> r = 1 ; //<S2SV> break ; //<S2SV> case KVM_CAP_SPAPR_RESIZE_HPT : //<S2SV> r = ! ! hv_enabled && ! cpu_has_feature ( CPU_FTR_ARCH_300 ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE //<S2SV> case KVM_CAP_PPC_FWNMI : //<S2SV> r = hv_enabled ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case KVM_CAP_PPC_HTM : //<S2SV> r = cpu_has_feature ( CPU_FTR_TM_COMP ) && hv_enabled ; //<S2SV> break ; //<S2SV> default : //<S2SV> r = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> return r ; //<S2SV> } //<S2SV> 