static ssize_t //<S2SV> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , //<S2SV> unsigned long nr_segs , loff_t ppos ) //<S2SV> { //<S2SV> struct file * filp = iocb -> ki_filp ; //<S2SV> struct pipe_inode_info * pipe = filp -> private_data ; //<S2SV> ssize_t ret ; //<S2SV> int do_wakeup ; //<S2SV> struct iovec * iov = ( struct iovec * ) _iov ; //<S2SV> size_t total_len ; //<S2SV> ssize_t chars ; //<S2SV> total_len = iov_length ( iov , nr_segs ) ; //<S2SV> if ( unlikely ( total_len == 0 ) ) //<S2SV> return 0 ; //<S2SV> do_wakeup = 0 ; //<S2SV> ret = 0 ; //<S2SV> __pipe_lock ( pipe ) ; //<S2SV> if ( ! pipe -> readers ) { //<S2SV> send_sig ( SIGPIPE , current , 0 ) ; //<S2SV> ret = - EPIPE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> chars = total_len & ( PAGE_SIZE - 1 ) ; //<S2SV> if ( pipe -> nrbufs && chars != 0 ) { //<S2SV> int lastbuf = ( pipe -> curbuf + pipe -> nrbufs - 1 ) & //<S2SV> ( pipe -> buffers - 1 ) ; //<S2SV> struct pipe_buffer * buf = pipe -> bufs + lastbuf ; //<S2SV> const struct pipe_buf_operations * ops = buf -> ops ; //<S2SV> int offset = buf -> offset + buf -> len ; //<S2SV> if ( ops -> can_merge && offset + chars <= PAGE_SIZE ) { //<S2SV> int error , atomic = 1 ; //<S2SV> void * addr ; //<S2SV> error = ops -> confirm ( pipe , buf ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> iov_fault_in_pages_read ( iov , chars ) ; //<S2SV> redo1 : //<S2SV> if ( atomic ) //<S2SV> addr = kmap_atomic ( buf -> page ) ; //<S2SV> else //<S2SV> addr = kmap ( buf -> page ) ; //<S2SV> error = pipe_iov_copy_from_user ( offset + addr , iov , //<S2SV> chars , atomic ) ; //<S2SV> if ( atomic ) //<S2SV> kunmap_atomic ( addr ) ; //<S2SV> else //<S2SV> kunmap ( buf -> page ) ; //<S2SV> ret = error ; //<S2SV> do_wakeup = 1 ; //<S2SV> if ( error ) { //<S2SV> if ( atomic ) { //<S2SV> atomic = 0 ; //<S2SV> goto redo1 ; //<S2SV> } //<S2SV> goto out ; //<S2SV> } //<S2SV> buf -> len += chars ; //<S2SV> total_len -= chars ; //<S2SV> ret = chars ; //<S2SV> if ( ! total_len ) //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> for ( ; ; ) { //<S2SV> int bufs ; //<S2SV> if ( ! pipe -> readers ) { //<S2SV> send_sig ( SIGPIPE , current , 0 ) ; //<S2SV> if ( ! ret ) //<S2SV> ret = - EPIPE ; //<S2SV> break ; //<S2SV> } //<S2SV> bufs = pipe -> nrbufs ; //<S2SV> if ( bufs < pipe -> buffers ) { //<S2SV> int newbuf = ( pipe -> curbuf + bufs ) & ( pipe -> buffers - 1 ) ; //<S2SV> struct pipe_buffer * buf = pipe -> bufs + newbuf ; //<S2SV> struct page * page = pipe -> tmp_page ; //<S2SV> char * src ; //<S2SV> int error , atomic = 1 ; //<S2SV> if ( ! page ) { //<S2SV> page = alloc_page ( GFP_HIGHUSER ) ; //<S2SV> if ( unlikely ( ! page ) ) { //<S2SV> ret = ret ? : - ENOMEM ; //<S2SV> break ; //<S2SV> } //<S2SV> pipe -> tmp_page = page ; //<S2SV> } //<S2SV> do_wakeup = 1 ; //<S2SV> chars = PAGE_SIZE ; //<S2SV> if ( chars > total_len ) //<S2SV> chars = total_len ; //<S2SV> iov_fault_in_pages_read ( iov , chars ) ; //<S2SV> redo2 : //<S2SV> if ( atomic ) //<S2SV> src = kmap_atomic ( page ) ; //<S2SV> else //<S2SV> src = kmap ( page ) ; //<S2SV> error = pipe_iov_copy_from_user ( src , iov , chars , //<S2SV> atomic ) ; //<S2SV> if ( atomic ) //<S2SV> kunmap_atomic ( src ) ; //<S2SV> else //<S2SV> kunmap ( page ) ; //<S2SV> if ( unlikely ( error ) ) { //<S2SV> if ( atomic ) { //<S2SV> atomic = 0 ; //<S2SV> goto redo2 ; //<S2SV> } //<S2SV> if ( ! ret ) //<S2SV> ret = error ; //<S2SV> break ; //<S2SV> } //<S2SV> ret += chars ; //<S2SV> buf -> page = page ; //<S2SV> buf -> ops = & anon_pipe_buf_ops ; //<S2SV> buf -> offset = 0 ; //<S2SV> buf -> len = chars ; //<S2SV> buf -> flags = 0 ; //<S2SV> if ( is_packetized ( filp ) ) { //<S2SV> buf -> ops = & packet_pipe_buf_ops ; //<S2SV> buf -> flags = PIPE_BUF_FLAG_PACKET ; //<S2SV> } //<S2SV> pipe -> nrbufs = ++ bufs ; //<S2SV> pipe -> tmp_page = NULL ; //<S2SV> total_len -= chars ; //<S2SV> if ( ! total_len ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( bufs < pipe -> buffers ) //<S2SV> continue ; //<S2SV> if ( filp -> f_flags & O_NONBLOCK ) { //<S2SV> if ( ! ret ) //<S2SV> ret = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( signal_pending ( current ) ) { //<S2SV> if ( ! ret ) //<S2SV> ret = - ERESTARTSYS ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( do_wakeup ) { //<S2SV> wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; //<S2SV> kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; //<S2SV> do_wakeup = 0 ; //<S2SV> } //<S2SV> pipe -> waiting_writers ++ ; //<S2SV> pipe_wait ( pipe ) ; //<S2SV> pipe -> waiting_writers -- ; //<S2SV> } //<S2SV> out : //<S2SV> __pipe_unlock ( pipe ) ; //<S2SV> if ( do_wakeup ) { //<S2SV> wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; //<S2SV> kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; //<S2SV> } //<S2SV> if ( ret > 0 && sb_start_write_trylock ( file_inode ( filp ) -> i_sb ) ) { //<S2SV> int err = file_update_time ( filp ) ; //<S2SV> if ( err ) //<S2SV> ret = err ; //<S2SV> sb_end_write ( file_inode ( filp ) -> i_sb ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 