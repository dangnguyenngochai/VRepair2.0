static ssize_t //<S2SV> pipe_write ( struct kiocb * iocb , struct iov_iter * from ) //<S2SV> { //<S2SV> struct file * filp = iocb -> ki_filp ; //<S2SV> struct pipe_inode_info * pipe = filp -> private_data ; //<S2SV> ssize_t ret = 0 ; //<S2SV> int do_wakeup = 0 ; //<S2SV> size_t total_len = iov_iter_count ( from ) ; //<S2SV> ssize_t chars ; //<S2SV> if ( unlikely ( total_len == 0 ) ) //<S2SV> return 0 ; //<S2SV> __pipe_lock ( pipe ) ; //<S2SV> if ( ! pipe -> readers ) { //<S2SV> send_sig ( SIGPIPE , current , 0 ) ; //<S2SV> ret = - EPIPE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> chars = total_len & ( PAGE_SIZE - 1 ) ; //<S2SV> if ( pipe -> nrbufs && chars != 0 ) { //<S2SV> int lastbuf = ( pipe -> curbuf + pipe -> nrbufs - 1 ) & //<S2SV> ( pipe -> buffers - 1 ) ; //<S2SV> struct pipe_buffer * buf = pipe -> bufs + lastbuf ; //<S2SV> const struct pipe_buf_operations * ops = buf -> ops ; //<S2SV> int offset = buf -> offset + buf -> len ; //<S2SV> if ( ops -> can_merge && offset + chars <= PAGE_SIZE ) { //<S2SV> int error = ops -> confirm ( pipe , buf ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; //<S2SV> if ( unlikely ( ret < chars ) ) { //<S2SV> error = - EFAULT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> do_wakeup = 1 ; //<S2SV> buf -> len += chars ; //<S2SV> ret = chars ; //<S2SV> if ( ! iov_iter_count ( from ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> for ( ; ; ) { //<S2SV> int bufs ; //<S2SV> if ( ! pipe -> readers ) { //<S2SV> send_sig ( SIGPIPE , current , 0 ) ; //<S2SV> if ( ! ret ) //<S2SV> ret = - EPIPE ; //<S2SV> break ; //<S2SV> } //<S2SV> bufs = pipe -> nrbufs ; //<S2SV> if ( bufs < pipe -> buffers ) { //<S2SV> int newbuf = ( pipe -> curbuf + bufs ) & ( pipe -> buffers - 1 ) ; //<S2SV> struct pipe_buffer * buf = pipe -> bufs + newbuf ; //<S2SV> struct page * page = pipe -> tmp_page ; //<S2SV> int copied ; //<S2SV> if ( ! page ) { //<S2SV> page = alloc_page ( GFP_HIGHUSER ) ; //<S2SV> if ( unlikely ( ! page ) ) { //<S2SV> ret = ret ? : - ENOMEM ; //<S2SV> break ; //<S2SV> } //<S2SV> pipe -> tmp_page = page ; //<S2SV> } //<S2SV> do_wakeup = 1 ; //<S2SV> copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from ) ; //<S2SV> if ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { //<S2SV> if ( ! ret ) //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> ret += copied ; //<S2SV> buf -> page = page ; //<S2SV> buf -> ops = & anon_pipe_buf_ops ; //<S2SV> buf -> offset = 0 ; //<S2SV> buf -> len = copied ; //<S2SV> buf -> flags = 0 ; //<S2SV> if ( is_packetized ( filp ) ) { //<S2SV> buf -> ops = & packet_pipe_buf_ops ; //<S2SV> buf -> flags = PIPE_BUF_FLAG_PACKET ; //<S2SV> } //<S2SV> pipe -> nrbufs = ++ bufs ; //<S2SV> pipe -> tmp_page = NULL ; //<S2SV> if ( ! iov_iter_count ( from ) ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( bufs < pipe -> buffers ) //<S2SV> continue ; //<S2SV> if ( filp -> f_flags & O_NONBLOCK ) { //<S2SV> if ( ! ret ) //<S2SV> ret = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( signal_pending ( current ) ) { //<S2SV> if ( ! ret ) //<S2SV> ret = - ERESTARTSYS ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( do_wakeup ) { //<S2SV> wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; //<S2SV> kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; //<S2SV> do_wakeup = 0 ; //<S2SV> } //<S2SV> pipe -> waiting_writers ++ ; //<S2SV> pipe_wait ( pipe ) ; //<S2SV> pipe -> waiting_writers -- ; //<S2SV> } //<S2SV> out : //<S2SV> __pipe_unlock ( pipe ) ; //<S2SV> if ( do_wakeup ) { //<S2SV> wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; //<S2SV> kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; //<S2SV> } //<S2SV> if ( ret > 0 && sb_start_write_trylock ( file_inode ( filp ) -> i_sb ) ) { //<S2SV> int err = file_update_time ( filp ) ; //<S2SV> if ( err ) //<S2SV> ret = err ; //<S2SV> sb_end_write ( file_inode ( filp ) -> i_sb ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 