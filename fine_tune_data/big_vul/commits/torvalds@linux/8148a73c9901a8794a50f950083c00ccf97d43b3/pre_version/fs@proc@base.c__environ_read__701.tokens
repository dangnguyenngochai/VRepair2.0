static ssize_t environ_read ( struct file * file , char __user * buf , //<S2SV> size_t count , loff_t * ppos ) //<S2SV> { //<S2SV> char * page ; //<S2SV> unsigned long src = * ppos ; //<S2SV> int ret = 0 ; //<S2SV> struct mm_struct * mm = file -> private_data ; //<S2SV> unsigned long env_start , env_end ; //<S2SV> if ( ! mm ) //<S2SV> return 0 ; //<S2SV> page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ; //<S2SV> if ( ! page ) //<S2SV> return - ENOMEM ; //<S2SV> ret = 0 ; //<S2SV> if ( ! atomic_inc_not_zero ( & mm -> mm_users ) ) //<S2SV> goto free ; //<S2SV> down_read ( & mm -> mmap_sem ) ; //<S2SV> env_start = mm -> env_start ; //<S2SV> env_end = mm -> env_end ; //<S2SV> up_read ( & mm -> mmap_sem ) ; //<S2SV> while ( count > 0 ) { //<S2SV> size_t this_len , max_len ; //<S2SV> int retval ; //<S2SV> if ( src >= ( env_end - env_start ) ) //<S2SV> break ; //<S2SV> this_len = env_end - ( env_start + src ) ; //<S2SV> max_len = min_t ( size_t , PAGE_SIZE , count ) ; //<S2SV> this_len = min ( max_len , this_len ) ; //<S2SV> retval = access_remote_vm ( mm , ( env_start + src ) , //<S2SV> page , this_len , 0 ) ; //<S2SV> if ( retval <= 0 ) { //<S2SV> ret = retval ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( copy_to_user ( buf , page , retval ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> ret += retval ; //<S2SV> src += retval ; //<S2SV> buf += retval ; //<S2SV> count -= retval ; //<S2SV> } //<S2SV> * ppos = src ; //<S2SV> mmput ( mm ) ; //<S2SV> free : //<S2SV> free_page ( ( unsigned long ) page ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 