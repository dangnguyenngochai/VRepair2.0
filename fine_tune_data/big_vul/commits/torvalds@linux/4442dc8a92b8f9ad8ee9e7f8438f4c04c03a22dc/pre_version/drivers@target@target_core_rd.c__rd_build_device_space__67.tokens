static int rd_build_device_space ( struct rd_dev * rd_dev ) //<S2SV> { //<S2SV> u32 i = 0 , j , page_offset = 0 , sg_per_table , sg_tables , total_sg_needed ; //<S2SV> u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / //<S2SV> sizeof ( struct scatterlist ) ) ; //<S2SV> struct rd_dev_sg_table * sg_table ; //<S2SV> struct page * pg ; //<S2SV> struct scatterlist * sg ; //<S2SV> if ( rd_dev -> rd_page_count <= 0 ) { //<S2SV> pr_err ( "Illegal<S2SV_blank>page<S2SV_blank>count:<S2SV_blank>%u<S2SV_blank>for<S2SV_blank>Ramdisk<S2SV_blank>device\\n" , //<S2SV> rd_dev -> rd_page_count ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( rd_dev -> rd_flags & RDF_NULLIO ) //<S2SV> return 0 ; //<S2SV> total_sg_needed = rd_dev -> rd_page_count ; //<S2SV> sg_tables = ( total_sg_needed / max_sg_per_table ) + 1 ; //<S2SV> sg_table = kzalloc ( sg_tables * sizeof ( struct rd_dev_sg_table ) , GFP_KERNEL ) ; //<S2SV> if ( ! sg_table ) { //<S2SV> pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Ramdisk" //<S2SV> "<S2SV_blank>scatterlist<S2SV_blank>tables\\n" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> rd_dev -> sg_table_array = sg_table ; //<S2SV> rd_dev -> sg_table_count = sg_tables ; //<S2SV> while ( total_sg_needed ) { //<S2SV> sg_per_table = ( total_sg_needed > max_sg_per_table ) ? //<S2SV> max_sg_per_table : total_sg_needed ; //<S2SV> sg = kzalloc ( sg_per_table * sizeof ( struct scatterlist ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! sg ) { //<S2SV> pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist<S2SV_blank>array" //<S2SV> "<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev\\n" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> sg_init_table ( sg , sg_per_table ) ; //<S2SV> sg_table [ i ] . sg_table = sg ; //<S2SV> sg_table [ i ] . rd_sg_count = sg_per_table ; //<S2SV> sg_table [ i ] . page_start_offset = page_offset ; //<S2SV> sg_table [ i ++ ] . page_end_offset = ( page_offset + sg_per_table ) //<S2SV> - 1 ; //<S2SV> for ( j = 0 ; j < sg_per_table ; j ++ ) { //<S2SV> pg = alloc_pages ( GFP_KERNEL , 0 ) ; //<S2SV> if ( ! pg ) { //<S2SV> pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scatterlist" //<S2SV> "<S2SV_blank>pages<S2SV_blank>for<S2SV_blank>struct<S2SV_blank>rd_dev_sg_table\\n" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> sg_assign_page ( & sg [ j ] , pg ) ; //<S2SV> sg [ j ] . length = PAGE_SIZE ; //<S2SV> } //<S2SV> page_offset += sg_per_table ; //<S2SV> total_sg_needed -= sg_per_table ; //<S2SV> } //<S2SV> pr_debug ( "CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Built<S2SV_blank>Ramdisk<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>space<S2SV_blank>of" //<S2SV> "<S2SV_blank>%u<S2SV_blank>pages<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>tables\\n" , rd_dev -> rd_host -> rd_host_id , //<S2SV> rd_dev -> rd_dev_id , rd_dev -> rd_page_count , //<S2SV> rd_dev -> sg_table_count ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 