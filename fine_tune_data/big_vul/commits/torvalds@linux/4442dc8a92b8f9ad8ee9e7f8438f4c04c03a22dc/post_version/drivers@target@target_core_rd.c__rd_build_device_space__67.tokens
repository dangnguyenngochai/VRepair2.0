static int rd_build_device_space ( struct rd_dev * rd_dev ) //<S2SV> { //<S2SV> struct rd_dev_sg_table * sg_table ; //<S2SV> u32 sg_tables , total_sg_needed ; //<S2SV> u32 max_sg_per_table = ( RD_MAX_ALLOCATION_SIZE / //<S2SV> sizeof ( struct scatterlist ) ) ; //<S2SV> int rc ; //<S2SV> if ( rd_dev -> rd_page_count <= 0 ) { //<S2SV> pr_err ( "Illegal<S2SV_blank>page<S2SV_blank>count:<S2SV_blank>%u<S2SV_blank>for<S2SV_blank>Ramdisk<S2SV_blank>device\\n" , //<S2SV> rd_dev -> rd_page_count ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( rd_dev -> rd_flags & RDF_NULLIO ) //<S2SV> return 0 ; //<S2SV> total_sg_needed = rd_dev -> rd_page_count ; //<S2SV> sg_tables = ( total_sg_needed / max_sg_per_table ) + 1 ; //<S2SV> sg_table = kzalloc ( sg_tables * sizeof ( struct rd_dev_sg_table ) , GFP_KERNEL ) ; //<S2SV> if ( ! sg_table ) { //<S2SV> pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Ramdisk" //<S2SV> "<S2SV_blank>scatterlist<S2SV_blank>tables\\n" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> rd_dev -> sg_table_array = sg_table ; //<S2SV> rd_dev -> sg_table_count = sg_tables ; //<S2SV> rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; //<S2SV> if ( rc ) //<S2SV> return rc ; //<S2SV> pr_debug ( "CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Built<S2SV_blank>Ramdisk<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>space<S2SV_blank>of" //<S2SV> "<S2SV_blank>%u<S2SV_blank>pages<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>tables\\n" , rd_dev -> rd_host -> rd_host_id , //<S2SV> rd_dev -> rd_dev_id , rd_dev -> rd_page_count , //<S2SV> rd_dev -> sg_table_count ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 