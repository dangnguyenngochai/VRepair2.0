sctp_disposition_t sctp_sf_do_asconf_ack ( struct net * net , //<S2SV> const struct sctp_endpoint * ep , //<S2SV> const struct sctp_association * asoc , //<S2SV> const sctp_subtype_t type , void * arg , //<S2SV> sctp_cmd_seq_t * commands ) //<S2SV> { //<S2SV> struct sctp_chunk * asconf_ack = arg ; //<S2SV> struct sctp_chunk * last_asconf = asoc -> addip_last_asconf ; //<S2SV> struct sctp_chunk * abort ; //<S2SV> struct sctp_paramhdr * err_param = NULL ; //<S2SV> sctp_addiphdr_t * addip_hdr ; //<S2SV> __u32 sent_serial , rcvd_serial ; //<S2SV> if ( ! sctp_vtag_verify ( asconf_ack , asoc ) ) { //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_REPORT_BAD_TAG , //<S2SV> SCTP_NULL ( ) ) ; //<S2SV> return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; //<S2SV> } //<S2SV> if ( ! net -> sctp . addip_noauth && ! asconf_ack -> auth ) //<S2SV> return sctp_sf_discard_chunk ( net , ep , asoc , type , arg , commands ) ; //<S2SV> if ( ! sctp_chunk_length_valid ( asconf_ack , sizeof ( sctp_addip_chunk_t ) ) ) //<S2SV> return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , //<S2SV> commands ) ; //<S2SV> addip_hdr = ( sctp_addiphdr_t * ) asconf_ack -> skb -> data ; //<S2SV> rcvd_serial = ntohl ( addip_hdr -> serial ) ; //<S2SV> if ( ! sctp_verify_asconf ( asoc , asconf_ack , false , & err_param ) ) //<S2SV> return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , //<S2SV> ( void * ) err_param , commands ) ; //<S2SV> if ( last_asconf ) { //<S2SV> addip_hdr = ( sctp_addiphdr_t * ) last_asconf -> subh . addip_hdr ; //<S2SV> sent_serial = ntohl ( addip_hdr -> serial ) ; //<S2SV> } else { //<S2SV> sent_serial = asoc -> addip_serial - 1 ; //<S2SV> } //<S2SV> if ( ADDIP_SERIAL_gte ( rcvd_serial , sent_serial + 1 ) && //<S2SV> ! ( asoc -> addip_last_asconf ) ) { //<S2SV> abort = sctp_make_abort ( asoc , asconf_ack , //<S2SV> sizeof ( sctp_errhdr_t ) ) ; //<S2SV> if ( abort ) { //<S2SV> sctp_init_cause ( abort , SCTP_ERROR_ASCONF_ACK , 0 ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , //<S2SV> SCTP_CHUNK ( abort ) ) ; //<S2SV> } //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , //<S2SV> SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , //<S2SV> SCTP_ERROR ( ECONNABORTED ) ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , //<S2SV> SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; //<S2SV> SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; //<S2SV> SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; //<S2SV> return SCTP_DISPOSITION_ABORT ; //<S2SV> } //<S2SV> if ( ( rcvd_serial == sent_serial ) && asoc -> addip_last_asconf ) { //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , //<S2SV> SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; //<S2SV> if ( ! sctp_process_asconf_ack ( ( struct sctp_association * ) asoc , //<S2SV> asconf_ack ) ) { //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_SEND_NEXT_ASCONF , //<S2SV> SCTP_NULL ( ) ) ; //<S2SV> return SCTP_DISPOSITION_CONSUME ; //<S2SV> } //<S2SV> abort = sctp_make_abort ( asoc , asconf_ack , //<S2SV> sizeof ( sctp_errhdr_t ) ) ; //<S2SV> if ( abort ) { //<S2SV> sctp_init_cause ( abort , SCTP_ERROR_RSRC_LOW , 0 ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , //<S2SV> SCTP_CHUNK ( abort ) ) ; //<S2SV> } //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , //<S2SV> SCTP_ERROR ( ECONNABORTED ) ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , //<S2SV> SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; //<S2SV> SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; //<S2SV> SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; //<S2SV> return SCTP_DISPOSITION_ABORT ; //<S2SV> } //<S2SV> return SCTP_DISPOSITION_DISCARD ; //<S2SV> } //<S2SV> 