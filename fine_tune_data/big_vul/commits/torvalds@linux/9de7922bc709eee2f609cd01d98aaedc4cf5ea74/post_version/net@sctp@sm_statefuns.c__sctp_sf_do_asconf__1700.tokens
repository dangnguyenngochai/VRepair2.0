sctp_disposition_t sctp_sf_do_asconf ( struct net * net , //<S2SV> const struct sctp_endpoint * ep , //<S2SV> const struct sctp_association * asoc , //<S2SV> const sctp_subtype_t type , void * arg , //<S2SV> sctp_cmd_seq_t * commands ) //<S2SV> { //<S2SV> struct sctp_chunk * chunk = arg ; //<S2SV> struct sctp_chunk * asconf_ack = NULL ; //<S2SV> struct sctp_paramhdr * err_param = NULL ; //<S2SV> sctp_addiphdr_t * hdr ; //<S2SV> __u32 serial ; //<S2SV> if ( ! sctp_vtag_verify ( chunk , asoc ) ) { //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_REPORT_BAD_TAG , //<S2SV> SCTP_NULL ( ) ) ; //<S2SV> return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; //<S2SV> } //<S2SV> if ( ! net -> sctp . addip_noauth && ! chunk -> auth ) //<S2SV> return sctp_sf_discard_chunk ( net , ep , asoc , type , arg , commands ) ; //<S2SV> if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_addip_chunk_t ) ) ) //<S2SV> return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , //<S2SV> commands ) ; //<S2SV> hdr = ( sctp_addiphdr_t * ) chunk -> skb -> data ; //<S2SV> serial = ntohl ( hdr -> serial ) ; //<S2SV> if ( ! sctp_verify_asconf ( asoc , chunk , true , & err_param ) ) //<S2SV> return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , //<S2SV> ( void * ) err_param , commands ) ; //<S2SV> if ( serial == asoc -> peer . addip_serial + 1 ) { //<S2SV> if ( ! chunk -> has_asconf ) //<S2SV> sctp_assoc_clean_asconf_ack_cache ( asoc ) ; //<S2SV> asconf_ack = sctp_process_asconf ( ( struct sctp_association * ) //<S2SV> asoc , chunk ) ; //<S2SV> if ( ! asconf_ack ) //<S2SV> return SCTP_DISPOSITION_NOMEM ; //<S2SV> } else if ( serial < asoc -> peer . addip_serial + 1 ) { //<S2SV> asconf_ack = sctp_assoc_lookup_asconf_ack ( asoc , hdr -> serial ) ; //<S2SV> if ( ! asconf_ack ) //<S2SV> return SCTP_DISPOSITION_DISCARD ; //<S2SV> asconf_ack -> transport = NULL ; //<S2SV> } else { //<S2SV> return SCTP_DISPOSITION_DISCARD ; //<S2SV> } //<S2SV> asconf_ack -> dest = chunk -> source ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( asconf_ack ) ) ; //<S2SV> if ( asoc -> new_transport ) { //<S2SV> sctp_sf_heartbeat ( ep , asoc , type , asoc -> new_transport , commands ) ; //<S2SV> ( ( struct sctp_association * ) asoc ) -> new_transport = NULL ; //<S2SV> } //<S2SV> return SCTP_DISPOSITION_CONSUME ; //<S2SV> } //<S2SV> 