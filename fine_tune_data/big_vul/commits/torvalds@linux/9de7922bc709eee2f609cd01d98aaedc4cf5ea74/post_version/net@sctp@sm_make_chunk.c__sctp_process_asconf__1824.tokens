struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , //<S2SV> struct sctp_chunk * asconf ) //<S2SV> { //<S2SV> sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; //<S2SV> bool all_param_pass = true ; //<S2SV> union sctp_params param ; //<S2SV> sctp_addiphdr_t * hdr ; //<S2SV> union sctp_addr_param * addr_param ; //<S2SV> sctp_addip_param_t * asconf_param ; //<S2SV> struct sctp_chunk * asconf_ack ; //<S2SV> __be16 err_code ; //<S2SV> int length = 0 ; //<S2SV> int chunk_len ; //<S2SV> __u32 serial ; //<S2SV> chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; //<S2SV> hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; //<S2SV> serial = ntohl ( hdr -> serial ) ; //<S2SV> length = sizeof ( sctp_addiphdr_t ) ; //<S2SV> addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; //<S2SV> chunk_len -= length ; //<S2SV> length = ntohs ( addr_param -> p . length ) ; //<S2SV> asconf_param = ( void * ) addr_param + length ; //<S2SV> chunk_len -= length ; //<S2SV> asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; //<S2SV> if ( ! asconf_ack ) //<S2SV> goto done ; //<S2SV> sctp_walk_params ( param , addip , addip_hdr . params ) { //<S2SV> if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || //<S2SV> param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) //<S2SV> continue ; //<S2SV> err_code = sctp_process_asconf_param ( asoc , asconf , //<S2SV> param . addip ) ; //<S2SV> if ( err_code != SCTP_ERROR_NO_ERROR ) //<S2SV> all_param_pass = false ; //<S2SV> if ( ! all_param_pass ) //<S2SV> sctp_add_asconf_response ( asconf_ack , param . addip -> crr_id , //<S2SV> err_code , param . addip ) ; //<S2SV> if ( err_code == SCTP_ERROR_RSRC_LOW ) //<S2SV> goto done ; //<S2SV> } //<S2SV> done : //<S2SV> asoc -> peer . addip_serial ++ ; //<S2SV> if ( asconf_ack ) { //<S2SV> sctp_chunk_hold ( asconf_ack ) ; //<S2SV> list_add_tail ( & asconf_ack -> transmitted_list , //<S2SV> & asoc -> asconf_ack_list ) ; //<S2SV> } //<S2SV> return asconf_ack ; //<S2SV> } //<S2SV> 