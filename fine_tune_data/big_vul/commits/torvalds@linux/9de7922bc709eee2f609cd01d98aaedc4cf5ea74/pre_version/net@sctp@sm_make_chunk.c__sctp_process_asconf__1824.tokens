struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , //<S2SV> struct sctp_chunk * asconf ) //<S2SV> { //<S2SV> sctp_addiphdr_t * hdr ; //<S2SV> union sctp_addr_param * addr_param ; //<S2SV> sctp_addip_param_t * asconf_param ; //<S2SV> struct sctp_chunk * asconf_ack ; //<S2SV> __be16 err_code ; //<S2SV> int length = 0 ; //<S2SV> int chunk_len ; //<S2SV> __u32 serial ; //<S2SV> int all_param_pass = 1 ; //<S2SV> chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; //<S2SV> hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; //<S2SV> serial = ntohl ( hdr -> serial ) ; //<S2SV> length = sizeof ( sctp_addiphdr_t ) ; //<S2SV> addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; //<S2SV> chunk_len -= length ; //<S2SV> length = ntohs ( addr_param -> p . length ) ; //<S2SV> asconf_param = ( void * ) addr_param + length ; //<S2SV> chunk_len -= length ; //<S2SV> asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; //<S2SV> if ( ! asconf_ack ) //<S2SV> goto done ; //<S2SV> while ( chunk_len > 0 ) { //<S2SV> err_code = sctp_process_asconf_param ( asoc , asconf , //<S2SV> asconf_param ) ; //<S2SV> if ( SCTP_ERROR_NO_ERROR != err_code ) //<S2SV> all_param_pass = 0 ; //<S2SV> if ( ! all_param_pass ) //<S2SV> sctp_add_asconf_response ( asconf_ack , //<S2SV> asconf_param -> crr_id , err_code , //<S2SV> asconf_param ) ; //<S2SV> if ( SCTP_ERROR_RSRC_LOW == err_code ) //<S2SV> goto done ; //<S2SV> length = ntohs ( asconf_param -> param_hdr . length ) ; //<S2SV> asconf_param = ( void * ) asconf_param + length ; //<S2SV> chunk_len -= length ; //<S2SV> } //<S2SV> done : //<S2SV> asoc -> peer . addip_serial ++ ; //<S2SV> if ( asconf_ack ) { //<S2SV> sctp_chunk_hold ( asconf_ack ) ; //<S2SV> list_add_tail ( & asconf_ack -> transmitted_list , //<S2SV> & asoc -> asconf_ack_list ) ; //<S2SV> } //<S2SV> return asconf_ack ; //<S2SV> } //<S2SV> 