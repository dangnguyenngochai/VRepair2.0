static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , //<S2SV> struct sctp_association * assoc , //<S2SV> sctp_socket_type_t type ) //<S2SV> { //<S2SV> struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; //<S2SV> struct sctp_sock * newsp = sctp_sk ( newsk ) ; //<S2SV> struct sctp_bind_bucket * pp ; //<S2SV> struct sctp_endpoint * newep = newsp -> ep ; //<S2SV> struct sk_buff * skb , * tmp ; //<S2SV> struct sctp_ulpevent * event ; //<S2SV> int flags = 0 ; //<S2SV> newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; //<S2SV> newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; //<S2SV> inet_sk_copy_descendant ( newsk , oldsk ) ; //<S2SV> newsp -> ep = newep ; //<S2SV> newsp -> hmac = NULL ; //<S2SV> pp = sctp_sk ( oldsk ) -> bind_hash ; //<S2SV> sk_add_bind_node ( newsk , & pp -> owner ) ; //<S2SV> sctp_sk ( newsk ) -> bind_hash = pp ; //<S2SV> inet_sk ( newsk ) -> num = inet_sk ( oldsk ) -> num ; //<S2SV> if ( PF_INET6 == assoc -> base . sk -> sk_family ) //<S2SV> flags = SCTP_ADDR6_ALLOWED ; //<S2SV> if ( assoc -> peer . ipv4_address ) //<S2SV> flags |= SCTP_ADDR4_PEERSUPP ; //<S2SV> if ( assoc -> peer . ipv6_address ) //<S2SV> flags |= SCTP_ADDR6_PEERSUPP ; //<S2SV> sctp_bind_addr_copy ( & newsp -> ep -> base . bind_addr , //<S2SV> & oldsp -> ep -> base . bind_addr , //<S2SV> SCTP_SCOPE_GLOBAL , GFP_KERNEL , flags ) ; //<S2SV> sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { //<S2SV> event = sctp_skb2event ( skb ) ; //<S2SV> if ( event -> asoc == assoc ) { //<S2SV> sctp_sock_rfree_frag ( skb ) ; //<S2SV> __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; //<S2SV> __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; //<S2SV> sctp_skb_set_owner_r_frag ( skb , newsk ) ; //<S2SV> } //<S2SV> } //<S2SV> skb_queue_head_init ( & newsp -> pd_lobby ) ; //<S2SV> sctp_sk ( newsk ) -> pd_mode = assoc -> ulpq . pd_mode ; //<S2SV> if ( sctp_sk ( oldsk ) -> pd_mode ) { //<S2SV> struct sk_buff_head * queue ; //<S2SV> if ( assoc -> ulpq . pd_mode ) { //<S2SV> queue = & newsp -> pd_lobby ; //<S2SV> } else //<S2SV> queue = & newsk -> sk_receive_queue ; //<S2SV> sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { //<S2SV> event = sctp_skb2event ( skb ) ; //<S2SV> if ( event -> asoc == assoc ) { //<S2SV> sctp_sock_rfree_frag ( skb ) ; //<S2SV> __skb_unlink ( skb , & oldsp -> pd_lobby ) ; //<S2SV> __skb_queue_tail ( queue , skb ) ; //<S2SV> sctp_skb_set_owner_r_frag ( skb , newsk ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( assoc -> ulpq . pd_mode ) //<S2SV> sctp_clear_pd ( oldsk ) ; //<S2SV> } //<S2SV> sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { //<S2SV> sctp_sock_rfree_frag ( skb ) ; //<S2SV> sctp_skb_set_owner_r_frag ( skb , newsk ) ; //<S2SV> } //<S2SV> sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { //<S2SV> sctp_sock_rfree_frag ( skb ) ; //<S2SV> sctp_skb_set_owner_r_frag ( skb , newsk ) ; //<S2SV> } //<S2SV> newsp -> type = type ; //<S2SV> sctp_lock_sock ( newsk ) ; //<S2SV> sctp_assoc_migrate ( assoc , newsk ) ; //<S2SV> if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) //<S2SV> newsk -> sk_shutdown |= RCV_SHUTDOWN ; //<S2SV> newsk -> sk_state = SCTP_SS_ESTABLISHED ; //<S2SV> sctp_release_sock ( newsk ) ; //<S2SV> } //<S2SV> 