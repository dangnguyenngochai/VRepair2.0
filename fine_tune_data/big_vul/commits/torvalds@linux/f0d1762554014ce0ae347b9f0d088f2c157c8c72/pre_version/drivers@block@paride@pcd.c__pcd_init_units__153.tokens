static void pcd_init_units ( void ) //<S2SV> { //<S2SV> struct pcd_unit * cd ; //<S2SV> int unit ; //<S2SV> pcd_drive_count = 0 ; //<S2SV> for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { //<S2SV> struct gendisk * disk = alloc_disk ( 1 ) ; //<S2SV> if ( ! disk ) //<S2SV> continue ; //<S2SV> disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , //<S2SV> 1 , BLK_MQ_F_SHOULD_MERGE ) ; //<S2SV> if ( IS_ERR ( disk -> queue ) ) { //<S2SV> disk -> queue = NULL ; //<S2SV> continue ; //<S2SV> } //<S2SV> INIT_LIST_HEAD ( & cd -> rq_list ) ; //<S2SV> disk -> queue -> queuedata = cd ; //<S2SV> blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; //<S2SV> cd -> disk = disk ; //<S2SV> cd -> pi = & cd -> pia ; //<S2SV> cd -> present = 0 ; //<S2SV> cd -> last_sense = 0 ; //<S2SV> cd -> changed = 1 ; //<S2SV> cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; //<S2SV> if ( ( * drives [ unit ] ) [ D_PRT ] ) //<S2SV> pcd_drive_count ++ ; //<S2SV> cd -> name = & cd -> info . name [ 0 ] ; //<S2SV> snprintf ( cd -> name , sizeof ( cd -> info . name ) , "%s%d" , name , unit ) ; //<S2SV> cd -> info . ops = & pcd_dops ; //<S2SV> cd -> info . handle = cd ; //<S2SV> cd -> info . speed = 0 ; //<S2SV> cd -> info . capacity = 1 ; //<S2SV> cd -> info . mask = 0 ; //<S2SV> disk -> major = major ; //<S2SV> disk -> first_minor = unit ; //<S2SV> strcpy ( disk -> disk_name , cd -> name ) ; //<S2SV> disk -> fops = & pcd_bdops ; //<S2SV> disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; //<S2SV> } //<S2SV> } //<S2SV> 