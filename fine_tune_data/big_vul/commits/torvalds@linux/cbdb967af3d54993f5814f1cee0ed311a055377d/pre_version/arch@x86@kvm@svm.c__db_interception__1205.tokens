static int db_interception ( struct vcpu_svm * svm ) //<S2SV> { //<S2SV> struct kvm_run * kvm_run = svm -> vcpu . run ; //<S2SV> if ( ! ( svm -> vcpu . guest_debug & //<S2SV> ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) && //<S2SV> ! svm -> nmi_singlestep ) { //<S2SV> kvm_queue_exception ( & svm -> vcpu , DB_VECTOR ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( svm -> nmi_singlestep ) { //<S2SV> svm -> nmi_singlestep = false ; //<S2SV> if ( ! ( svm -> vcpu . guest_debug & KVM_GUESTDBG_SINGLESTEP ) ) //<S2SV> svm -> vmcb -> save . rflags &= //<S2SV> ~ ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; //<S2SV> update_db_bp_intercept ( & svm -> vcpu ) ; //<S2SV> } //<S2SV> if ( svm -> vcpu . guest_debug & //<S2SV> ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) { //<S2SV> kvm_run -> exit_reason = KVM_EXIT_DEBUG ; //<S2SV> kvm_run -> debug . arch . pc = //<S2SV> svm -> vmcb -> save . cs . base + svm -> vmcb -> save . rip ; //<S2SV> kvm_run -> debug . arch . exception = DB_VECTOR ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> } //<S2SV> 