static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , //<S2SV> struct msghdr * msg , size_t len ) //<S2SV> { //<S2SV> struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct netlink_sock * nlk = nlk_sk ( sk ) ; //<S2SV> struct sockaddr_nl * addr = msg -> msg_name ; //<S2SV> u32 dst_pid ; //<S2SV> u32 dst_group ; //<S2SV> struct sk_buff * skb ; //<S2SV> int err ; //<S2SV> struct scm_cookie scm ; //<S2SV> if ( msg -> msg_flags & MSG_OOB ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> if ( NULL == siocb -> scm ) //<S2SV> siocb -> scm = & scm ; //<S2SV> err = scm_send ( sock , msg , siocb -> scm , true ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( msg -> msg_namelen ) { //<S2SV> err = - EINVAL ; //<S2SV> if ( addr -> nl_family != AF_NETLINK ) //<S2SV> goto out ; //<S2SV> dst_pid = addr -> nl_pid ; //<S2SV> dst_group = ffs ( addr -> nl_groups ) ; //<S2SV> err = - EPERM ; //<S2SV> if ( ( dst_group || dst_pid ) && //<S2SV> ! netlink_capable ( sock , NL_NONROOT_SEND ) ) //<S2SV> goto out ; //<S2SV> } else { //<S2SV> dst_pid = nlk -> dst_pid ; //<S2SV> dst_group = nlk -> dst_group ; //<S2SV> } //<S2SV> if ( ! nlk -> pid ) { //<S2SV> err = netlink_autobind ( sock ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> } //<S2SV> err = - EMSGSIZE ; //<S2SV> if ( len > sk -> sk_sndbuf - 32 ) //<S2SV> goto out ; //<S2SV> err = - ENOBUFS ; //<S2SV> skb = alloc_skb ( len , GFP_KERNEL ) ; //<S2SV> if ( skb == NULL ) //<S2SV> goto out ; //<S2SV> NETLINK_CB ( skb ) . pid = nlk -> pid ; //<S2SV> NETLINK_CB ( skb ) . dst_group = dst_group ; //<S2SV> memcpy ( NETLINK_CREDS ( skb ) , & siocb -> scm -> creds , sizeof ( struct ucred ) ) ; //<S2SV> err = - EFAULT ; //<S2SV> if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) { //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> err = security_netlink_send ( sk , skb ) ; //<S2SV> if ( err ) { //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( dst_group ) { //<S2SV> atomic_inc ( & skb -> users ) ; //<S2SV> netlink_broadcast ( sk , skb , dst_pid , dst_group , GFP_KERNEL ) ; //<S2SV> } //<S2SV> err = netlink_unicast ( sk , skb , dst_pid , msg -> msg_flags & MSG_DONTWAIT ) ; //<S2SV> out : //<S2SV> scm_destroy ( siocb -> scm ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 