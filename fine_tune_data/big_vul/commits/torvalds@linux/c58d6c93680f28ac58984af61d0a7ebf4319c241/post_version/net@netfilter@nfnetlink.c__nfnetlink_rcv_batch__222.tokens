static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , //<S2SV> u_int16_t subsys_id ) //<S2SV> { //<S2SV> struct sk_buff * oskb = skb ; //<S2SV> struct net * net = sock_net ( skb -> sk ) ; //<S2SV> const struct nfnetlink_subsystem * ss ; //<S2SV> const struct nfnl_callback * nc ; //<S2SV> static LIST_HEAD ( err_list ) ; //<S2SV> u32 status ; //<S2SV> int err ; //<S2SV> if ( subsys_id >= NFNL_SUBSYS_COUNT ) //<S2SV> return netlink_ack ( skb , nlh , - EINVAL ) ; //<S2SV> replay : //<S2SV> status = 0 ; //<S2SV> skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; //<S2SV> if ( ! skb ) //<S2SV> return netlink_ack ( oskb , nlh , - ENOMEM ) ; //<S2SV> nfnl_lock ( subsys_id ) ; //<S2SV> ss = nfnl_dereference_protected ( subsys_id ) ; //<S2SV> if ( ! ss ) { //<S2SV> # ifdef CONFIG_MODULES //<S2SV> nfnl_unlock ( subsys_id ) ; //<S2SV> request_module ( "nfnetlink-subsys-%d" , subsys_id ) ; //<S2SV> nfnl_lock ( subsys_id ) ; //<S2SV> ss = nfnl_dereference_protected ( subsys_id ) ; //<S2SV> if ( ! ss ) //<S2SV> # endif //<S2SV> { //<S2SV> nfnl_unlock ( subsys_id ) ; //<S2SV> netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; //<S2SV> return kfree_skb ( skb ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ss -> commit || ! ss -> abort ) { //<S2SV> nfnl_unlock ( subsys_id ) ; //<S2SV> netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; //<S2SV> return kfree_skb ( skb ) ; //<S2SV> } //<S2SV> while ( skb -> len >= nlmsg_total_size ( 0 ) ) { //<S2SV> int msglen , type ; //<S2SV> nlh = nlmsg_hdr ( skb ) ; //<S2SV> err = 0 ; //<S2SV> if ( nlh -> nlmsg_len < NLMSG_HDRLEN || //<S2SV> skb -> len < nlh -> nlmsg_len || //<S2SV> nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) ) { //<S2SV> nfnl_err_reset ( & err_list ) ; //<S2SV> status |= NFNL_BATCH_FAILURE ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ! ( nlh -> nlmsg_flags & NLM_F_REQUEST ) ) { //<S2SV> err = - EINVAL ; //<S2SV> goto ack ; //<S2SV> } //<S2SV> type = nlh -> nlmsg_type ; //<S2SV> if ( type == NFNL_MSG_BATCH_BEGIN ) { //<S2SV> nfnl_err_reset ( & err_list ) ; //<S2SV> status |= NFNL_BATCH_FAILURE ; //<S2SV> goto done ; //<S2SV> } else if ( type == NFNL_MSG_BATCH_END ) { //<S2SV> status |= NFNL_BATCH_DONE ; //<S2SV> goto done ; //<S2SV> } else if ( type < NLMSG_MIN_TYPE ) { //<S2SV> err = - EINVAL ; //<S2SV> goto ack ; //<S2SV> } //<S2SV> if ( NFNL_SUBSYS_ID ( type ) != subsys_id ) { //<S2SV> err = - EINVAL ; //<S2SV> goto ack ; //<S2SV> } //<S2SV> nc = nfnetlink_find_client ( type , ss ) ; //<S2SV> if ( ! nc ) { //<S2SV> err = - EINVAL ; //<S2SV> goto ack ; //<S2SV> } //<S2SV> { //<S2SV> int min_len = nlmsg_total_size ( sizeof ( struct nfgenmsg ) ) ; //<S2SV> u_int8_t cb_id = NFNL_MSG_TYPE ( nlh -> nlmsg_type ) ; //<S2SV> struct nlattr * cda [ ss -> cb [ cb_id ] . attr_count + 1 ] ; //<S2SV> struct nlattr * attr = ( void * ) nlh + min_len ; //<S2SV> int attrlen = nlh -> nlmsg_len - min_len ; //<S2SV> err = nla_parse ( cda , ss -> cb [ cb_id ] . attr_count , //<S2SV> attr , attrlen , ss -> cb [ cb_id ] . policy ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto ack ; //<S2SV> if ( nc -> call_batch ) { //<S2SV> err = nc -> call_batch ( net , net -> nfnl , skb , nlh , //<S2SV> ( const struct nlattr * * ) cda ) ; //<S2SV> } //<S2SV> if ( err == - EAGAIN ) { //<S2SV> status |= NFNL_BATCH_REPLAY ; //<S2SV> goto next ; //<S2SV> } //<S2SV> } //<S2SV> ack : //<S2SV> if ( nlh -> nlmsg_flags & NLM_F_ACK || err ) { //<S2SV> if ( nfnl_err_add ( & err_list , nlh , err ) < 0 ) { //<S2SV> nfnl_err_reset ( & err_list ) ; //<S2SV> netlink_ack ( oskb , nlmsg_hdr ( oskb ) , - ENOMEM ) ; //<S2SV> status |= NFNL_BATCH_FAILURE ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( err ) //<S2SV> status |= NFNL_BATCH_FAILURE ; //<S2SV> } //<S2SV> next : //<S2SV> msglen = NLMSG_ALIGN ( nlh -> nlmsg_len ) ; //<S2SV> if ( msglen > skb -> len ) //<S2SV> msglen = skb -> len ; //<S2SV> skb_pull ( skb , msglen ) ; //<S2SV> } //<S2SV> done : //<S2SV> if ( status & NFNL_BATCH_REPLAY ) { //<S2SV> ss -> abort ( net , oskb ) ; //<S2SV> nfnl_err_reset ( & err_list ) ; //<S2SV> nfnl_unlock ( subsys_id ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto replay ; //<S2SV> } else if ( status == NFNL_BATCH_DONE ) { //<S2SV> ss -> commit ( net , oskb ) ; //<S2SV> } else { //<S2SV> ss -> abort ( net , oskb ) ; //<S2SV> } //<S2SV> nfnl_err_deliver ( & err_list , oskb ) ; //<S2SV> nfnl_unlock ( subsys_id ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> } //<S2SV> 