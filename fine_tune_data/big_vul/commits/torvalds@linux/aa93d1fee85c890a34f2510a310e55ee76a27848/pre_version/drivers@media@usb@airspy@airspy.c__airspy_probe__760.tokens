static int airspy_probe ( struct usb_interface * intf , //<S2SV> const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct airspy * s ; //<S2SV> int ret ; //<S2SV> u8 u8tmp , buf [ BUF_SIZE ] ; //<S2SV> s = kzalloc ( sizeof ( struct airspy ) , GFP_KERNEL ) ; //<S2SV> if ( s == NULL ) { //<S2SV> dev_err ( & intf -> dev , "Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>state\\n" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> mutex_init ( & s -> v4l2_lock ) ; //<S2SV> mutex_init ( & s -> vb_queue_lock ) ; //<S2SV> spin_lock_init ( & s -> queued_bufs_lock ) ; //<S2SV> INIT_LIST_HEAD ( & s -> queued_bufs ) ; //<S2SV> s -> dev = & intf -> dev ; //<S2SV> s -> udev = interface_to_usbdev ( intf ) ; //<S2SV> s -> f_adc = bands [ 0 ] . rangelow ; //<S2SV> s -> f_rf = bands_rf [ 0 ] . rangelow ; //<S2SV> s -> pixelformat = formats [ 0 ] . pixelformat ; //<S2SV> s -> buffersize = formats [ 0 ] . buffersize ; //<S2SV> ret = airspy_ctrl_msg ( s , CMD_BOARD_ID_READ , 0 , 0 , & u8tmp , 1 ) ; //<S2SV> if ( ret == 0 ) //<S2SV> ret = airspy_ctrl_msg ( s , CMD_VERSION_STRING_READ , 0 , 0 , //<S2SV> buf , BUF_SIZE ) ; //<S2SV> if ( ret ) { //<S2SV> dev_err ( s -> dev , "Could<S2SV_blank>not<S2SV_blank>detect<S2SV_blank>board\\n" ) ; //<S2SV> goto err_free_mem ; //<S2SV> } //<S2SV> buf [ BUF_SIZE - 1 ] = '\\0' ; //<S2SV> dev_info ( s -> dev , "Board<S2SV_blank>ID:<S2SV_blank>%02x\\n" , u8tmp ) ; //<S2SV> dev_info ( s -> dev , "Firmware<S2SV_blank>version:<S2SV_blank>%s\\n" , buf ) ; //<S2SV> s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ; //<S2SV> s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ; //<S2SV> s -> vb_queue . drv_priv = s ; //<S2SV> s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ; //<S2SV> s -> vb_queue . ops = & airspy_vb2_ops ; //<S2SV> s -> vb_queue . mem_ops = & vb2_vmalloc_memops ; //<S2SV> s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ; //<S2SV> ret = vb2_queue_init ( & s -> vb_queue ) ; //<S2SV> if ( ret ) { //<S2SV> dev_err ( s -> dev , "Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\n" ) ; //<S2SV> goto err_free_mem ; //<S2SV> } //<S2SV> s -> vdev = airspy_template ; //<S2SV> s -> vdev . queue = & s -> vb_queue ; //<S2SV> s -> vdev . queue -> lock = & s -> vb_queue_lock ; //<S2SV> video_set_drvdata ( & s -> vdev , s ) ; //<S2SV> s -> v4l2_dev . release = airspy_video_release ; //<S2SV> ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ; //<S2SV> if ( ret ) { //<S2SV> dev_err ( s -> dev , "Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\n" , ret ) ; //<S2SV> goto err_free_mem ; //<S2SV> } //<S2SV> v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ; //<S2SV> s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , //<S2SV> V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; //<S2SV> s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , //<S2SV> V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ; //<S2SV> v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ; //<S2SV> s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , //<S2SV> V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; //<S2SV> s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , //<S2SV> V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ; //<S2SV> v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ; //<S2SV> s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , //<S2SV> V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ; //<S2SV> if ( s -> hdl . error ) { //<S2SV> ret = s -> hdl . error ; //<S2SV> dev_err ( s -> dev , "Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\n" ) ; //<S2SV> goto err_free_controls ; //<S2SV> } //<S2SV> v4l2_ctrl_handler_setup ( & s -> hdl ) ; //<S2SV> s -> v4l2_dev . ctrl_handler = & s -> hdl ; //<S2SV> s -> vdev . v4l2_dev = & s -> v4l2_dev ; //<S2SV> s -> vdev . lock = & s -> v4l2_lock ; //<S2SV> ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ; //<S2SV> if ( ret ) { //<S2SV> dev_err ( s -> dev , "Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\n" , //<S2SV> ret ) ; //<S2SV> goto err_unregister_v4l2_dev ; //<S2SV> } //<S2SV> dev_info ( s -> dev , "Registered<S2SV_blank>as<S2SV_blank>%s\\n" , //<S2SV> video_device_node_name ( & s -> vdev ) ) ; //<S2SV> dev_notice ( s -> dev , "SDR<S2SV_blank>API<S2SV_blank>is<S2SV_blank>still<S2SV_blank>slightly<S2SV_blank>experimental<S2SV_blank>and<S2SV_blank>functionality<S2SV_blank>changes<S2SV_blank>may<S2SV_blank>follow\\n" ) ; //<S2SV> return 0 ; //<S2SV> err_free_controls : //<S2SV> v4l2_ctrl_handler_free ( & s -> hdl ) ; //<S2SV> err_unregister_v4l2_dev : //<S2SV> v4l2_device_unregister ( & s -> v4l2_dev ) ; //<S2SV> err_free_mem : //<S2SV> kfree ( s ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 