static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , //<S2SV> struct packet_type * pt , struct net_device * orig_dev ) //<S2SV> { //<S2SV> struct sock * sk ; //<S2SV> struct packet_sock * po ; //<S2SV> struct sockaddr_ll * sll ; //<S2SV> union { //<S2SV> struct tpacket_hdr * h1 ; //<S2SV> struct tpacket2_hdr * h2 ; //<S2SV> void * raw ; //<S2SV> } h ; //<S2SV> u8 * skb_head = skb -> data ; //<S2SV> int skb_len = skb -> len ; //<S2SV> unsigned int snaplen , res ; //<S2SV> unsigned long status = TP_STATUS_LOSING | TP_STATUS_USER ; //<S2SV> unsigned short macoff , netoff , hdrlen ; //<S2SV> struct sk_buff * copy_skb = NULL ; //<S2SV> struct timeval tv ; //<S2SV> struct timespec ts ; //<S2SV> struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; //<S2SV> if ( skb -> pkt_type == PACKET_LOOPBACK ) //<S2SV> goto drop ; //<S2SV> sk = pt -> af_packet_priv ; //<S2SV> po = pkt_sk ( sk ) ; //<S2SV> if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) //<S2SV> goto drop ; //<S2SV> if ( dev -> header_ops ) { //<S2SV> if ( sk -> sk_type != SOCK_DGRAM ) //<S2SV> skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; //<S2SV> else if ( skb -> pkt_type == PACKET_OUTGOING ) { //<S2SV> skb_pull ( skb , skb_network_offset ( skb ) ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( skb -> ip_summed == CHECKSUM_PARTIAL ) //<S2SV> status |= TP_STATUS_CSUMNOTREADY ; //<S2SV> snaplen = skb -> len ; //<S2SV> res = run_filter ( skb , sk , snaplen ) ; //<S2SV> if ( ! res ) //<S2SV> goto drop_n_restore ; //<S2SV> if ( snaplen > res ) //<S2SV> snaplen = res ; //<S2SV> if ( sk -> sk_type == SOCK_DGRAM ) { //<S2SV> macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + //<S2SV> po -> tp_reserve ; //<S2SV> } else { //<S2SV> unsigned maclen = skb_network_offset ( skb ) ; //<S2SV> netoff = TPACKET_ALIGN ( po -> tp_hdrlen + //<S2SV> ( maclen < 16 ? 16 : maclen ) ) + //<S2SV> po -> tp_reserve ; //<S2SV> macoff = netoff - maclen ; //<S2SV> } //<S2SV> if ( macoff + snaplen > po -> rx_ring . frame_size ) { //<S2SV> if ( po -> copy_thresh && //<S2SV> atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize < //<S2SV> ( unsigned ) sk -> sk_rcvbuf ) { //<S2SV> if ( skb_shared ( skb ) ) { //<S2SV> copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; //<S2SV> } else { //<S2SV> copy_skb = skb_get ( skb ) ; //<S2SV> skb_head = skb -> data ; //<S2SV> } //<S2SV> if ( copy_skb ) //<S2SV> skb_set_owner_r ( copy_skb , sk ) ; //<S2SV> } //<S2SV> snaplen = po -> rx_ring . frame_size - macoff ; //<S2SV> if ( ( int ) snaplen < 0 ) //<S2SV> snaplen = 0 ; //<S2SV> } //<S2SV> spin_lock ( & sk -> sk_receive_queue . lock ) ; //<S2SV> h . raw = packet_current_frame ( po , & po -> rx_ring , TP_STATUS_KERNEL ) ; //<S2SV> if ( ! h . raw ) //<S2SV> goto ring_is_full ; //<S2SV> packet_increment_head ( & po -> rx_ring ) ; //<S2SV> po -> stats . tp_packets ++ ; //<S2SV> if ( copy_skb ) { //<S2SV> status |= TP_STATUS_COPY ; //<S2SV> __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; //<S2SV> } //<S2SV> if ( ! po -> stats . tp_drops ) //<S2SV> status &= ~ TP_STATUS_LOSING ; //<S2SV> spin_unlock ( & sk -> sk_receive_queue . lock ) ; //<S2SV> skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; //<S2SV> switch ( po -> tp_version ) { //<S2SV> case TPACKET_V1 : //<S2SV> h . h1 -> tp_len = skb -> len ; //<S2SV> h . h1 -> tp_snaplen = snaplen ; //<S2SV> h . h1 -> tp_mac = macoff ; //<S2SV> h . h1 -> tp_net = netoff ; //<S2SV> if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) //<S2SV> && shhwtstamps -> syststamp . tv64 ) //<S2SV> tv = ktime_to_timeval ( shhwtstamps -> syststamp ) ; //<S2SV> else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) //<S2SV> && shhwtstamps -> hwtstamp . tv64 ) //<S2SV> tv = ktime_to_timeval ( shhwtstamps -> hwtstamp ) ; //<S2SV> else if ( skb -> tstamp . tv64 ) //<S2SV> tv = ktime_to_timeval ( skb -> tstamp ) ; //<S2SV> else //<S2SV> do_gettimeofday ( & tv ) ; //<S2SV> h . h1 -> tp_sec = tv . tv_sec ; //<S2SV> h . h1 -> tp_usec = tv . tv_usec ; //<S2SV> hdrlen = sizeof ( * h . h1 ) ; //<S2SV> break ; //<S2SV> case TPACKET_V2 : //<S2SV> h . h2 -> tp_len = skb -> len ; //<S2SV> h . h2 -> tp_snaplen = snaplen ; //<S2SV> h . h2 -> tp_mac = macoff ; //<S2SV> h . h2 -> tp_net = netoff ; //<S2SV> if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) //<S2SV> && shhwtstamps -> syststamp . tv64 ) //<S2SV> ts = ktime_to_timespec ( shhwtstamps -> syststamp ) ; //<S2SV> else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) //<S2SV> && shhwtstamps -> hwtstamp . tv64 ) //<S2SV> ts = ktime_to_timespec ( shhwtstamps -> hwtstamp ) ; //<S2SV> else if ( skb -> tstamp . tv64 ) //<S2SV> ts = ktime_to_timespec ( skb -> tstamp ) ; //<S2SV> else //<S2SV> getnstimeofday ( & ts ) ; //<S2SV> h . h2 -> tp_sec = ts . tv_sec ; //<S2SV> h . h2 -> tp_nsec = ts . tv_nsec ; //<S2SV> if ( vlan_tx_tag_present ( skb ) ) { //<S2SV> h . h2 -> tp_vlan_tci = vlan_tx_tag_get ( skb ) ; //<S2SV> status |= TP_STATUS_VLAN_VALID ; //<S2SV> } else { //<S2SV> h . h2 -> tp_vlan_tci = 0 ; //<S2SV> } //<S2SV> hdrlen = sizeof ( * h . h2 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> BUG ( ) ; //<S2SV> } //<S2SV> sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; //<S2SV> sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; //<S2SV> sll -> sll_family = AF_PACKET ; //<S2SV> sll -> sll_hatype = dev -> type ; //<S2SV> sll -> sll_protocol = skb -> protocol ; //<S2SV> sll -> sll_pkttype = skb -> pkt_type ; //<S2SV> if ( unlikely ( po -> origdev ) ) //<S2SV> sll -> sll_ifindex = orig_dev -> ifindex ; //<S2SV> else //<S2SV> sll -> sll_ifindex = dev -> ifindex ; //<S2SV> __packet_set_status ( po , h . raw , status ) ; //<S2SV> smp_mb ( ) ; //<S2SV> # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 //<S2SV> { //<S2SV> u8 * start , * end ; //<S2SV> end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; //<S2SV> for ( start = h . raw ; start < end ; start += PAGE_SIZE ) //<S2SV> flush_dcache_page ( pgv_to_page ( start ) ) ; //<S2SV> } //<S2SV> # endif //<S2SV> sk -> sk_data_ready ( sk , 0 ) ; //<S2SV> drop_n_restore : //<S2SV> if ( skb_head != skb -> data && skb_shared ( skb ) ) { //<S2SV> skb -> data = skb_head ; //<S2SV> skb -> len = skb_len ; //<S2SV> } //<S2SV> drop : //<S2SV> kfree_skb ( skb ) ; //<S2SV> return 0 ; //<S2SV> ring_is_full : //<S2SV> po -> stats . tp_drops ++ ; //<S2SV> spin_unlock ( & sk -> sk_receive_queue . lock ) ; //<S2SV> sk -> sk_data_ready ( sk , 0 ) ; //<S2SV> kfree_skb ( copy_skb ) ; //<S2SV> goto drop_n_restore ; //<S2SV> } //<S2SV> 