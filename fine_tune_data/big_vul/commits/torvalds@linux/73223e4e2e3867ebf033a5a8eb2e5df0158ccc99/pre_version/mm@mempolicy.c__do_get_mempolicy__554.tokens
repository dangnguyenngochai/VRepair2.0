static long do_get_mempolicy ( int * policy , nodemask_t * nmask , //<S2SV> unsigned long addr , unsigned long flags ) //<S2SV> { //<S2SV> int err ; //<S2SV> struct mm_struct * mm = current -> mm ; //<S2SV> struct vm_area_struct * vma = NULL ; //<S2SV> struct mempolicy * pol = current -> mempolicy ; //<S2SV> if ( flags & //<S2SV> ~ ( unsigned long ) ( MPOL_F_NODE | MPOL_F_ADDR | MPOL_F_MEMS_ALLOWED ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( flags & MPOL_F_MEMS_ALLOWED ) { //<S2SV> if ( flags & ( MPOL_F_NODE | MPOL_F_ADDR ) ) //<S2SV> return - EINVAL ; //<S2SV> * policy = 0 ; //<S2SV> task_lock ( current ) ; //<S2SV> * nmask = cpuset_current_mems_allowed ; //<S2SV> task_unlock ( current ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( flags & MPOL_F_ADDR ) { //<S2SV> down_read ( & mm -> mmap_sem ) ; //<S2SV> vma = find_vma_intersection ( mm , addr , addr + 1 ) ; //<S2SV> if ( ! vma ) { //<S2SV> up_read ( & mm -> mmap_sem ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( vma -> vm_ops && vma -> vm_ops -> get_policy ) //<S2SV> pol = vma -> vm_ops -> get_policy ( vma , addr ) ; //<S2SV> else //<S2SV> pol = vma -> vm_policy ; //<S2SV> } else if ( addr ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! pol ) //<S2SV> pol = & default_policy ; //<S2SV> if ( flags & MPOL_F_NODE ) { //<S2SV> if ( flags & MPOL_F_ADDR ) { //<S2SV> err = lookup_node ( addr ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out ; //<S2SV> * policy = err ; //<S2SV> } else if ( pol == current -> mempolicy && //<S2SV> pol -> mode == MPOL_INTERLEAVE ) { //<S2SV> * policy = next_node_in ( current -> il_prev , pol -> v . nodes ) ; //<S2SV> } else { //<S2SV> err = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } else { //<S2SV> * policy = pol == & default_policy ? MPOL_DEFAULT : //<S2SV> pol -> mode ; //<S2SV> * policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ; //<S2SV> } //<S2SV> if ( vma ) { //<S2SV> up_read ( & current -> mm -> mmap_sem ) ; //<S2SV> vma = NULL ; //<S2SV> } //<S2SV> err = 0 ; //<S2SV> if ( nmask ) { //<S2SV> if ( mpol_store_user_nodemask ( pol ) ) { //<S2SV> * nmask = pol -> w . user_nodemask ; //<S2SV> } else { //<S2SV> task_lock ( current ) ; //<S2SV> get_policy_nodemask ( pol , nmask ) ; //<S2SV> task_unlock ( current ) ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> mpol_cond_put ( pol ) ; //<S2SV> if ( vma ) //<S2SV> up_read ( & current -> mm -> mmap_sem ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 