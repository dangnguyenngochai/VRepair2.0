static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , //<S2SV> u64 * cookie_ret , struct rds_mr * * mr_ret ) //<S2SV> { //<S2SV> struct rds_mr * mr = NULL , * found ; //<S2SV> unsigned int nr_pages ; //<S2SV> struct page * * pages = NULL ; //<S2SV> struct scatterlist * sg ; //<S2SV> void * trans_private ; //<S2SV> unsigned long flags ; //<S2SV> rds_rdma_cookie_t cookie ; //<S2SV> unsigned int nents ; //<S2SV> long i ; //<S2SV> int ret ; //<S2SV> if ( rs -> rs_bound_addr == 0 ) { //<S2SV> ret = - ENOTCONN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! rs -> rs_transport -> get_mr ) { //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> goto out ; //<S2SV> } //<S2SV> nr_pages = rds_pages_in_vec ( & args -> vec ) ; //<S2SV> if ( nr_pages == 0 ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { //<S2SV> ret = - EMSGSIZE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n" , //<S2SV> args -> vec . addr , args -> vec . bytes , nr_pages ) ; //<S2SV> pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; //<S2SV> if ( ! pages ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; //<S2SV> if ( ! mr ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> refcount_set ( & mr -> r_refcount , 1 ) ; //<S2SV> RB_CLEAR_NODE ( & mr -> r_rb_node ) ; //<S2SV> mr -> r_trans = rs -> rs_transport ; //<S2SV> mr -> r_sock = rs ; //<S2SV> if ( args -> flags & RDS_RDMA_USE_ONCE ) //<S2SV> mr -> r_use_once = 1 ; //<S2SV> if ( args -> flags & RDS_RDMA_INVALIDATE ) //<S2SV> mr -> r_invalidate = 1 ; //<S2SV> if ( args -> flags & RDS_RDMA_READWRITE ) //<S2SV> mr -> r_write = 1 ; //<S2SV> ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto out ; //<S2SV> nents = ret ; //<S2SV> sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; //<S2SV> if ( ! sg ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> WARN_ON ( ! nents ) ; //<S2SV> sg_init_table ( sg , nents ) ; //<S2SV> for ( i = 0 ; i < nents ; i ++ ) //<S2SV> sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; //<S2SV> rdsdebug ( "RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n" , nents ) ; //<S2SV> trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , //<S2SV> & mr -> r_key ) ; //<S2SV> if ( IS_ERR ( trans_private ) ) { //<S2SV> for ( i = 0 ; i < nents ; i ++ ) //<S2SV> put_page ( sg_page ( & sg [ i ] ) ) ; //<S2SV> kfree ( sg ) ; //<S2SV> ret = PTR_ERR ( trans_private ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> mr -> r_trans_private = trans_private ; //<S2SV> rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n" , //<S2SV> mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; //<S2SV> cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; //<S2SV> if ( cookie_ret ) //<S2SV> * cookie_ret = cookie ; //<S2SV> if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; //<S2SV> found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; //<S2SV> spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; //<S2SV> BUG_ON ( found && found != mr ) ; //<S2SV> rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n" , mr -> r_key ) ; //<S2SV> if ( mr_ret ) { //<S2SV> refcount_inc ( & mr -> r_refcount ) ; //<S2SV> * mr_ret = mr ; //<S2SV> } //<S2SV> ret = 0 ; //<S2SV> out : //<S2SV> kfree ( pages ) ; //<S2SV> if ( mr ) //<S2SV> rds_mr_put ( mr ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 