int sctp_rcv ( struct sk_buff * skb ) //<S2SV> { //<S2SV> struct sock * sk ; //<S2SV> struct sctp_association * asoc ; //<S2SV> struct sctp_endpoint * ep = NULL ; //<S2SV> struct sctp_ep_common * rcvr ; //<S2SV> struct sctp_transport * transport = NULL ; //<S2SV> struct sctp_chunk * chunk ; //<S2SV> struct sctphdr * sh ; //<S2SV> union sctp_addr src ; //<S2SV> union sctp_addr dest ; //<S2SV> int family ; //<S2SV> struct sctp_af * af ; //<S2SV> if ( skb -> pkt_type != PACKET_HOST ) //<S2SV> goto discard_it ; //<S2SV> SCTP_INC_STATS_BH ( SCTP_MIB_INSCTPPACKS ) ; //<S2SV> if ( skb_linearize ( skb ) ) //<S2SV> goto discard_it ; //<S2SV> sh = sctp_hdr ( skb ) ; //<S2SV> __skb_pull ( skb , skb_transport_offset ( skb ) ) ; //<S2SV> if ( skb -> len < sizeof ( struct sctphdr ) ) //<S2SV> goto discard_it ; //<S2SV> if ( ! skb_csum_unnecessary ( skb ) && sctp_rcv_checksum ( skb ) < 0 ) //<S2SV> goto discard_it ; //<S2SV> skb_pull ( skb , sizeof ( struct sctphdr ) ) ; //<S2SV> if ( skb -> len < sizeof ( struct sctp_chunkhdr ) ) //<S2SV> goto discard_it ; //<S2SV> family = ipver2af ( ip_hdr ( skb ) -> version ) ; //<S2SV> af = sctp_get_af_specific ( family ) ; //<S2SV> if ( unlikely ( ! af ) ) //<S2SV> goto discard_it ; //<S2SV> af -> from_skb ( & src , skb , 1 ) ; //<S2SV> af -> from_skb ( & dest , skb , 0 ) ; //<S2SV> if ( ! af -> addr_valid ( & src , NULL , skb ) || //<S2SV> ! af -> addr_valid ( & dest , NULL , skb ) ) //<S2SV> goto discard_it ; //<S2SV> asoc = __sctp_rcv_lookup ( skb , & src , & dest , & transport ) ; //<S2SV> if ( ! asoc ) //<S2SV> ep = __sctp_rcv_lookup_endpoint ( & dest ) ; //<S2SV> rcvr = asoc ? & asoc -> base : & ep -> base ; //<S2SV> sk = rcvr -> sk ; //<S2SV> if ( sk -> sk_bound_dev_if && ( sk -> sk_bound_dev_if != af -> skb_iif ( skb ) ) ) //<S2SV> { //<S2SV> if ( asoc ) { //<S2SV> sctp_association_put ( asoc ) ; //<S2SV> asoc = NULL ; //<S2SV> } else { //<S2SV> sctp_endpoint_put ( ep ) ; //<S2SV> ep = NULL ; //<S2SV> } //<S2SV> sk = sctp_get_ctl_sock ( ) ; //<S2SV> ep = sctp_sk ( sk ) -> ep ; //<S2SV> sctp_endpoint_hold ( ep ) ; //<S2SV> rcvr = & ep -> base ; //<S2SV> } //<S2SV> if ( ! asoc ) { //<S2SV> if ( sctp_rcv_ootb ( skb ) ) { //<S2SV> SCTP_INC_STATS_BH ( SCTP_MIB_OUTOFBLUES ) ; //<S2SV> goto discard_release ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! xfrm_policy_check ( sk , XFRM_POLICY_IN , skb , family ) ) //<S2SV> goto discard_release ; //<S2SV> nf_reset ( skb ) ; //<S2SV> if ( sk_filter ( sk , skb ) ) //<S2SV> goto discard_release ; //<S2SV> chunk = sctp_chunkify ( skb , asoc , sk ) ; //<S2SV> if ( ! chunk ) //<S2SV> goto discard_release ; //<S2SV> SCTP_INPUT_CB ( skb ) -> chunk = chunk ; //<S2SV> chunk -> rcvr = rcvr ; //<S2SV> chunk -> sctp_hdr = sh ; //<S2SV> sctp_init_addrs ( chunk , & src , & dest ) ; //<S2SV> chunk -> transport = transport ; //<S2SV> sctp_bh_lock_sock ( sk ) ; //<S2SV> if ( sk != rcvr -> sk ) { //<S2SV> sctp_bh_unlock_sock ( sk ) ; //<S2SV> sk = rcvr -> sk ; //<S2SV> sctp_bh_lock_sock ( sk ) ; //<S2SV> } //<S2SV> if ( sock_owned_by_user ( sk ) ) { //<S2SV> SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_BACKLOG ) ; //<S2SV> sctp_add_backlog ( sk , skb ) ; //<S2SV> } else { //<S2SV> SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_SOFTIRQ ) ; //<S2SV> sctp_inq_push ( & chunk -> rcvr -> inqueue , chunk ) ; //<S2SV> } //<S2SV> sctp_bh_unlock_sock ( sk ) ; //<S2SV> if ( asoc ) //<S2SV> sctp_association_put ( asoc ) ; //<S2SV> else //<S2SV> sctp_endpoint_put ( ep ) ; //<S2SV> return 0 ; //<S2SV> discard_it : //<S2SV> SCTP_INC_STATS_BH ( SCTP_MIB_IN_PKT_DISCARDS ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> return 0 ; //<S2SV> discard_release : //<S2SV> if ( asoc ) //<S2SV> sctp_association_put ( asoc ) ; //<S2SV> else //<S2SV> sctp_endpoint_put ( ep ) ; //<S2SV> goto discard_it ; //<S2SV> } //<S2SV> 