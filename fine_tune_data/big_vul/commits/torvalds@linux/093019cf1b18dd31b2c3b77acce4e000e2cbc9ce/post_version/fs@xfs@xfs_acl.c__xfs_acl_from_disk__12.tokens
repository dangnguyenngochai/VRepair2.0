STATIC struct posix_acl * //<S2SV> xfs_acl_from_disk ( struct xfs_acl * aclp ) //<S2SV> { //<S2SV> struct posix_acl_entry * acl_e ; //<S2SV> struct posix_acl * acl ; //<S2SV> struct xfs_acl_entry * ace ; //<S2SV> unsigned int count , i ; //<S2SV> count = be32_to_cpu ( aclp -> acl_cnt ) ; //<S2SV> if ( count > XFS_ACL_MAX_ENTRIES ) //<S2SV> return ERR_PTR ( - EFSCORRUPTED ) ; //<S2SV> acl = posix_acl_alloc ( count , GFP_KERNEL ) ; //<S2SV> if ( ! acl ) //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> for ( i = 0 ; i < count ; i ++ ) { //<S2SV> acl_e = & acl -> a_entries [ i ] ; //<S2SV> ace = & aclp -> acl_entry [ i ] ; //<S2SV> acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; //<S2SV> acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; //<S2SV> switch ( acl_e -> e_tag ) { //<S2SV> case ACL_USER : //<S2SV> case ACL_GROUP : //<S2SV> acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; //<S2SV> break ; //<S2SV> case ACL_USER_OBJ : //<S2SV> case ACL_GROUP_OBJ : //<S2SV> case ACL_MASK : //<S2SV> case ACL_OTHER : //<S2SV> acl_e -> e_id = ACL_UNDEFINED_ID ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> return acl ; //<S2SV> fail : //<S2SV> posix_acl_release ( acl ) ; //<S2SV> return ERR_PTR ( - EINVAL ) ; //<S2SV> } //<S2SV> 