static int process_one_ticket ( struct ceph_auth_client * ac , //<S2SV> struct ceph_crypto_key * secret , //<S2SV> void * * p , void * end ) //<S2SV> { //<S2SV> struct ceph_x_info * xi = ac -> private ; //<S2SV> int type ; //<S2SV> u8 tkt_struct_v , blob_struct_v ; //<S2SV> struct ceph_x_ticket_handler * th ; //<S2SV> void * dbuf = NULL ; //<S2SV> void * dp , * dend ; //<S2SV> int dlen ; //<S2SV> char is_enc ; //<S2SV> struct timespec validity ; //<S2SV> struct ceph_crypto_key old_key ; //<S2SV> void * ticket_buf = NULL ; //<S2SV> void * tp , * tpend ; //<S2SV> struct ceph_timespec new_validity ; //<S2SV> struct ceph_crypto_key new_session_key ; //<S2SV> struct ceph_buffer * new_ticket_blob ; //<S2SV> unsigned long new_expires , new_renew_after ; //<S2SV> u64 new_secret_id ; //<S2SV> int ret ; //<S2SV> ceph_decode_need ( p , end , sizeof ( u32 ) + 1 , bad ) ; //<S2SV> type = ceph_decode_32 ( p ) ; //<S2SV> dout ( "<S2SV_blank>ticket<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>%s\\n" , type , ceph_entity_type_name ( type ) ) ; //<S2SV> tkt_struct_v = ceph_decode_8 ( p ) ; //<S2SV> if ( tkt_struct_v != 1 ) //<S2SV> goto bad ; //<S2SV> th = get_ticket_handler ( ac , type ) ; //<S2SV> if ( IS_ERR ( th ) ) { //<S2SV> ret = PTR_ERR ( th ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> dlen = ceph_x_decrypt ( secret , p , end , & dbuf , 0 ) ; //<S2SV> if ( dlen <= 0 ) { //<S2SV> ret = dlen ; //<S2SV> goto out ; //<S2SV> } //<S2SV> dout ( "<S2SV_blank>decrypted<S2SV_blank>%d<S2SV_blank>bytes\\n" , dlen ) ; //<S2SV> dp = dbuf ; //<S2SV> dend = dp + dlen ; //<S2SV> tkt_struct_v = ceph_decode_8 ( & dp ) ; //<S2SV> if ( tkt_struct_v != 1 ) //<S2SV> goto bad ; //<S2SV> memcpy ( & old_key , & th -> session_key , sizeof ( old_key ) ) ; //<S2SV> ret = ceph_crypto_key_decode ( & new_session_key , & dp , dend ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ceph_decode_copy ( & dp , & new_validity , sizeof ( new_validity ) ) ; //<S2SV> ceph_decode_timespec ( & validity , & new_validity ) ; //<S2SV> new_expires = get_seconds ( ) + validity . tv_sec ; //<S2SV> new_renew_after = new_expires - ( validity . tv_sec / 4 ) ; //<S2SV> dout ( "<S2SV_blank>expires=%lu<S2SV_blank>renew_after=%lu\\n" , new_expires , //<S2SV> new_renew_after ) ; //<S2SV> ceph_decode_8_safe ( p , end , is_enc , bad ) ; //<S2SV> if ( is_enc ) { //<S2SV> dout ( "<S2SV_blank>encrypted<S2SV_blank>ticket\\n" ) ; //<S2SV> dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 ) ; //<S2SV> if ( dlen < 0 ) { //<S2SV> ret = dlen ; //<S2SV> goto out ; //<S2SV> } //<S2SV> tp = ticket_buf ; //<S2SV> dlen = ceph_decode_32 ( & tp ) ; //<S2SV> } else { //<S2SV> ceph_decode_32_safe ( p , end , dlen , bad ) ; //<S2SV> ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; //<S2SV> if ( ! ticket_buf ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> tp = ticket_buf ; //<S2SV> ceph_decode_need ( p , end , dlen , bad ) ; //<S2SV> ceph_decode_copy ( p , ticket_buf , dlen ) ; //<S2SV> } //<S2SV> tpend = tp + dlen ; //<S2SV> dout ( "<S2SV_blank>ticket<S2SV_blank>blob<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes\\n" , dlen ) ; //<S2SV> ceph_decode_need ( & tp , tpend , 1 + sizeof ( u64 ) , bad ) ; //<S2SV> blob_struct_v = ceph_decode_8 ( & tp ) ; //<S2SV> new_secret_id = ceph_decode_64 ( & tp ) ; //<S2SV> ret = ceph_decode_buffer ( & new_ticket_blob , & tp , tpend ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ceph_crypto_key_destroy ( & th -> session_key ) ; //<S2SV> if ( th -> ticket_blob ) //<S2SV> ceph_buffer_put ( th -> ticket_blob ) ; //<S2SV> th -> session_key = new_session_key ; //<S2SV> th -> ticket_blob = new_ticket_blob ; //<S2SV> th -> validity = new_validity ; //<S2SV> th -> secret_id = new_secret_id ; //<S2SV> th -> expires = new_expires ; //<S2SV> th -> renew_after = new_renew_after ; //<S2SV> dout ( "<S2SV_blank>got<S2SV_blank>ticket<S2SV_blank>service<S2SV_blank>%d<S2SV_blank>(%s)<S2SV_blank>secret_id<S2SV_blank>%lld<S2SV_blank>len<S2SV_blank>%d\\n" , //<S2SV> type , ceph_entity_type_name ( type ) , th -> secret_id , //<S2SV> ( int ) th -> ticket_blob -> vec . iov_len ) ; //<S2SV> xi -> have_keys |= th -> service ; //<S2SV> out : //<S2SV> kfree ( ticket_buf ) ; //<S2SV> kfree ( dbuf ) ; //<S2SV> return ret ; //<S2SV> bad : //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 