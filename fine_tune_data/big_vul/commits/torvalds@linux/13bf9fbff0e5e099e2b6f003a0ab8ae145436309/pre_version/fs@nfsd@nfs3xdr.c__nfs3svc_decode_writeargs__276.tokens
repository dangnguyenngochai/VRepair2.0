int //<S2SV> nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , //<S2SV> struct nfsd3_writeargs * args ) //<S2SV> { //<S2SV> unsigned int len , v , hdr , dlen ; //<S2SV> u32 max_blocksize = svc_max_payload ( rqstp ) ; //<S2SV> struct kvec * head = rqstp -> rq_arg . head ; //<S2SV> struct kvec * tail = rqstp -> rq_arg . tail ; //<S2SV> p = decode_fh ( p , & args -> fh ) ; //<S2SV> if ( ! p ) //<S2SV> return 0 ; //<S2SV> p = xdr_decode_hyper ( p , & args -> offset ) ; //<S2SV> args -> count = ntohl ( * p ++ ) ; //<S2SV> args -> stable = ntohl ( * p ++ ) ; //<S2SV> len = args -> len = ntohl ( * p ++ ) ; //<S2SV> if ( args -> count != args -> len ) //<S2SV> return 0 ; //<S2SV> hdr = ( void * ) p - head -> iov_base ; //<S2SV> dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; //<S2SV> if ( dlen < XDR_QUADLEN ( len ) * 4 ) //<S2SV> return 0 ; //<S2SV> if ( args -> count > max_blocksize ) { //<S2SV> args -> count = max_blocksize ; //<S2SV> len = args -> len = max_blocksize ; //<S2SV> } //<S2SV> rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; //<S2SV> rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; //<S2SV> v = 0 ; //<S2SV> while ( len > rqstp -> rq_vec [ v ] . iov_len ) { //<S2SV> len -= rqstp -> rq_vec [ v ] . iov_len ; //<S2SV> v ++ ; //<S2SV> rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; //<S2SV> rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; //<S2SV> } //<S2SV> rqstp -> rq_vec [ v ] . iov_len = len ; //<S2SV> args -> vlen = v + 1 ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> 