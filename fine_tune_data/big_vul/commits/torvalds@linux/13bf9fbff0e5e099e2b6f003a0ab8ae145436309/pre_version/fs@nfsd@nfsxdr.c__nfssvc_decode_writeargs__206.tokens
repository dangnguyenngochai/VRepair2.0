int //<S2SV> nfssvc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , //<S2SV> struct nfsd_writeargs * args ) //<S2SV> { //<S2SV> unsigned int len , hdr , dlen ; //<S2SV> struct kvec * head = rqstp -> rq_arg . head ; //<S2SV> int v ; //<S2SV> p = decode_fh ( p , & args -> fh ) ; //<S2SV> if ( ! p ) //<S2SV> return 0 ; //<S2SV> p ++ ; //<S2SV> args -> offset = ntohl ( * p ++ ) ; //<S2SV> p ++ ; //<S2SV> len = args -> len = ntohl ( * p ++ ) ; //<S2SV> if ( len > NFSSVC_MAXBLKSIZE_V2 ) //<S2SV> return 0 ; //<S2SV> hdr = ( void * ) p - head -> iov_base ; //<S2SV> dlen = head -> iov_len + rqstp -> rq_arg . page_len - hdr ; //<S2SV> if ( dlen < XDR_QUADLEN ( len ) * 4 ) //<S2SV> return 0 ; //<S2SV> rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; //<S2SV> rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; //<S2SV> v = 0 ; //<S2SV> while ( len > rqstp -> rq_vec [ v ] . iov_len ) { //<S2SV> len -= rqstp -> rq_vec [ v ] . iov_len ; //<S2SV> v ++ ; //<S2SV> rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; //<S2SV> rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; //<S2SV> } //<S2SV> rqstp -> rq_vec [ v ] . iov_len = len ; //<S2SV> args -> vlen = v + 1 ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> 