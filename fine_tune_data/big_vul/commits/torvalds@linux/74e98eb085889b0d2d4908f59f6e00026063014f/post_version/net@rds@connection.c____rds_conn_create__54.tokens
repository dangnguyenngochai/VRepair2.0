static struct rds_connection * __rds_conn_create ( struct net * net , //<S2SV> __be32 laddr , __be32 faddr , //<S2SV> struct rds_transport * trans , gfp_t gfp , //<S2SV> int is_outgoing ) //<S2SV> { //<S2SV> struct rds_connection * conn , * parent = NULL ; //<S2SV> struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; //<S2SV> struct rds_transport * loop_trans ; //<S2SV> unsigned long flags ; //<S2SV> int ret ; //<S2SV> struct rds_transport * otrans = trans ; //<S2SV> if ( ! is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) //<S2SV> goto new_conn ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; //<S2SV> if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && //<S2SV> laddr == faddr && ! is_outgoing ) { //<S2SV> parent = conn ; //<S2SV> conn = parent -> c_passive ; //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> if ( conn ) //<S2SV> goto out ; //<S2SV> new_conn : //<S2SV> conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; //<S2SV> if ( ! conn ) { //<S2SV> conn = ERR_PTR ( - ENOMEM ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> INIT_HLIST_NODE ( & conn -> c_hash_node ) ; //<S2SV> conn -> c_laddr = laddr ; //<S2SV> conn -> c_faddr = faddr ; //<S2SV> spin_lock_init ( & conn -> c_lock ) ; //<S2SV> conn -> c_next_tx_seq = 1 ; //<S2SV> rds_conn_net_set ( conn , net ) ; //<S2SV> init_waitqueue_head ( & conn -> c_waitq ) ; //<S2SV> INIT_LIST_HEAD ( & conn -> c_send_queue ) ; //<S2SV> INIT_LIST_HEAD ( & conn -> c_retrans ) ; //<S2SV> ret = rds_cong_get_maps ( conn ) ; //<S2SV> if ( ret ) { //<S2SV> kmem_cache_free ( rds_conn_slab , conn ) ; //<S2SV> conn = ERR_PTR ( ret ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> loop_trans = rds_trans_get_preferred ( net , faddr ) ; //<S2SV> if ( loop_trans ) { //<S2SV> rds_trans_put ( loop_trans ) ; //<S2SV> conn -> c_loopback = 1 ; //<S2SV> if ( is_outgoing && trans -> t_prefer_loopback ) { //<S2SV> trans = & rds_loop_transport ; //<S2SV> } //<S2SV> } //<S2SV> if ( trans == NULL ) { //<S2SV> kmem_cache_free ( rds_conn_slab , conn ) ; //<S2SV> conn = ERR_PTR ( - ENODEV ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> conn -> c_trans = trans ; //<S2SV> ret = trans -> conn_alloc ( conn , gfp ) ; //<S2SV> if ( ret ) { //<S2SV> kmem_cache_free ( rds_conn_slab , conn ) ; //<S2SV> conn = ERR_PTR ( ret ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> atomic_set ( & conn -> c_state , RDS_CONN_DOWN ) ; //<S2SV> conn -> c_send_gen = 0 ; //<S2SV> conn -> c_reconnect_jiffies = 0 ; //<S2SV> INIT_DELAYED_WORK ( & conn -> c_send_w , rds_send_worker ) ; //<S2SV> INIT_DELAYED_WORK ( & conn -> c_recv_w , rds_recv_worker ) ; //<S2SV> INIT_DELAYED_WORK ( & conn -> c_conn_w , rds_connect_worker ) ; //<S2SV> INIT_WORK ( & conn -> c_down_w , rds_shutdown_worker ) ; //<S2SV> mutex_init ( & conn -> c_cm_lock ) ; //<S2SV> conn -> c_flags = 0 ; //<S2SV> rdsdebug ( "allocated<S2SV_blank>conn<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>%pI4<S2SV_blank>-><S2SV_blank>%pI4<S2SV_blank>over<S2SV_blank>%s<S2SV_blank>%s\\n" , //<S2SV> conn , & laddr , & faddr , //<S2SV> trans -> t_name ? trans -> t_name : "[unknown]" , //<S2SV> is_outgoing ? "(outgoing)" : "" ) ; //<S2SV> spin_lock_irqsave ( & rds_conn_lock , flags ) ; //<S2SV> if ( parent ) { //<S2SV> if ( parent -> c_passive ) { //<S2SV> trans -> conn_free ( conn -> c_transport_data ) ; //<S2SV> kmem_cache_free ( rds_conn_slab , conn ) ; //<S2SV> conn = parent -> c_passive ; //<S2SV> } else { //<S2SV> parent -> c_passive = conn ; //<S2SV> rds_cong_add_conn ( conn ) ; //<S2SV> rds_conn_count ++ ; //<S2SV> } //<S2SV> } else { //<S2SV> struct rds_connection * found ; //<S2SV> if ( ! is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) //<S2SV> found = NULL ; //<S2SV> else //<S2SV> found = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; //<S2SV> if ( found ) { //<S2SV> trans -> conn_free ( conn -> c_transport_data ) ; //<S2SV> kmem_cache_free ( rds_conn_slab , conn ) ; //<S2SV> conn = found ; //<S2SV> } else { //<S2SV> if ( ( is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) || //<S2SV> ( otrans -> t_type != RDS_TRANS_TCP ) ) { //<S2SV> hlist_add_head_rcu ( & conn -> c_hash_node , head ) ; //<S2SV> } //<S2SV> rds_cong_add_conn ( conn ) ; //<S2SV> rds_conn_count ++ ; //<S2SV> } //<S2SV> } //<S2SV> spin_unlock_irqrestore ( & rds_conn_lock , flags ) ; //<S2SV> out : //<S2SV> return conn ; //<S2SV> } //<S2SV> 