static long ec_device_ioctl_xcmd ( struct cros_ec_dev * ec , void __user * arg ) //<S2SV> { //<S2SV> long ret ; //<S2SV> struct cros_ec_command u_cmd ; //<S2SV> struct cros_ec_command * s_cmd ; //<S2SV> if ( copy_from_user ( & u_cmd , arg , sizeof ( u_cmd ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( ( u_cmd . outsize > EC_MAX_MSG_BYTES ) || //<S2SV> ( u_cmd . insize > EC_MAX_MSG_BYTES ) ) //<S2SV> return - EINVAL ; //<S2SV> s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( ! s_cmd ) //<S2SV> return - ENOMEM ; //<S2SV> if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> goto exit ; //<S2SV> } //<S2SV> if ( u_cmd . outsize != s_cmd -> outsize || //<S2SV> u_cmd . insize != s_cmd -> insize ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto exit ; //<S2SV> } //<S2SV> s_cmd -> command += ec -> cmd_offset ; //<S2SV> ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto exit ; //<S2SV> if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + s_cmd -> insize ) ) //<S2SV> ret = - EFAULT ; //<S2SV> exit : //<S2SV> kfree ( s_cmd ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 