static int __jfs_set_acl ( tid_t tid , struct inode * inode , int type , //<S2SV> struct posix_acl * acl ) //<S2SV> { //<S2SV> char * ea_name ; //<S2SV> int rc ; //<S2SV> int size = 0 ; //<S2SV> char * value = NULL ; //<S2SV> switch ( type ) { //<S2SV> case ACL_TYPE_ACCESS : //<S2SV> ea_name = XATTR_NAME_POSIX_ACL_ACCESS ; //<S2SV> if ( acl ) { //<S2SV> rc = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; //<S2SV> if ( rc < 0 ) //<S2SV> return rc ; //<S2SV> inode -> i_ctime = CURRENT_TIME ; //<S2SV> mark_inode_dirty ( inode ) ; //<S2SV> if ( rc == 0 ) //<S2SV> acl = NULL ; //<S2SV> } //<S2SV> break ; //<S2SV> case ACL_TYPE_DEFAULT : //<S2SV> ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; //<S2SV> break ; //<S2SV> default : //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( acl ) { //<S2SV> size = posix_acl_xattr_size ( acl -> a_count ) ; //<S2SV> value = kmalloc ( size , GFP_KERNEL ) ; //<S2SV> if ( ! value ) //<S2SV> return - ENOMEM ; //<S2SV> rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; //<S2SV> if ( rc < 0 ) //<S2SV> goto out ; //<S2SV> } //<S2SV> rc = __jfs_setxattr ( tid , inode , ea_name , value , size , 0 ) ; //<S2SV> out : //<S2SV> kfree ( value ) ; //<S2SV> if ( ! rc ) //<S2SV> set_cached_acl ( inode , type , acl ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 