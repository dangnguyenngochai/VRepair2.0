int __gfs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) //<S2SV> { //<S2SV> int error ; //<S2SV> int len ; //<S2SV> char * data ; //<S2SV> const char * name = gfs2_acl_name ( type ) ; //<S2SV> if ( acl && acl -> a_count > GFS2_ACL_MAX_ENTRIES ( GFS2_SB ( inode ) ) ) //<S2SV> return - E2BIG ; //<S2SV> if ( type == ACL_TYPE_ACCESS ) { //<S2SV> umode_t mode = inode -> i_mode ; //<S2SV> error = posix_acl_equiv_mode ( acl , & mode ) ; //<S2SV> if ( error < 0 ) //<S2SV> return error ; //<S2SV> if ( error == 0 ) //<S2SV> acl = NULL ; //<S2SV> if ( mode != inode -> i_mode ) { //<S2SV> inode -> i_mode = mode ; //<S2SV> mark_inode_dirty ( inode ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( acl ) { //<S2SV> len = posix_acl_to_xattr ( & init_user_ns , acl , NULL , 0 ) ; //<S2SV> if ( len == 0 ) //<S2SV> return 0 ; //<S2SV> data = kmalloc ( len , GFP_NOFS ) ; //<S2SV> if ( data == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> error = posix_acl_to_xattr ( & init_user_ns , acl , data , len ) ; //<S2SV> if ( error < 0 ) //<S2SV> goto out ; //<S2SV> } else { //<S2SV> data = NULL ; //<S2SV> len = 0 ; //<S2SV> } //<S2SV> error = __gfs2_xattr_set ( inode , name , data , len , 0 , GFS2_EATYPE_SYS ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> set_cached_acl ( inode , type , acl ) ; //<S2SV> out : //<S2SV> kfree ( data ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 