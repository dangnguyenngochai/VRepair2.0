static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , //<S2SV> struct dentry * dentry , struct inode * inode , //<S2SV> const char * name , const void * value , //<S2SV> size_t size , int flags ) //<S2SV> { //<S2SV> int retval ; //<S2SV> struct posix_acl * acl ; //<S2SV> struct v9fs_session_info * v9ses ; //<S2SV> v9ses = v9fs_dentry2v9ses ( dentry ) ; //<S2SV> if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) //<S2SV> return v9fs_xattr_set ( dentry , handler -> name , value , size , //<S2SV> flags ) ; //<S2SV> if ( S_ISLNK ( inode -> i_mode ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> if ( ! inode_owner_or_capable ( inode ) ) //<S2SV> return - EPERM ; //<S2SV> if ( value ) { //<S2SV> acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; //<S2SV> if ( IS_ERR ( acl ) ) //<S2SV> return PTR_ERR ( acl ) ; //<S2SV> else if ( acl ) { //<S2SV> retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; //<S2SV> if ( retval ) //<S2SV> goto err_out ; //<S2SV> } //<S2SV> } else //<S2SV> acl = NULL ; //<S2SV> switch ( handler -> flags ) { //<S2SV> case ACL_TYPE_ACCESS : //<S2SV> if ( acl ) { //<S2SV> umode_t mode = inode -> i_mode ; //<S2SV> retval = posix_acl_equiv_mode ( acl , & mode ) ; //<S2SV> if ( retval < 0 ) //<S2SV> goto err_out ; //<S2SV> else { //<S2SV> struct iattr iattr ; //<S2SV> if ( retval == 0 ) { //<S2SV> acl = NULL ; //<S2SV> value = NULL ; //<S2SV> size = 0 ; //<S2SV> } //<S2SV> iattr . ia_mode = ( ( mode & S_IALLUGO ) | //<S2SV> ( inode -> i_mode & ~ S_IALLUGO ) ) ; //<S2SV> iattr . ia_valid = ATTR_MODE ; //<S2SV> v9fs_vfs_setattr_dotl ( dentry , & iattr ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case ACL_TYPE_DEFAULT : //<S2SV> if ( ! S_ISDIR ( inode -> i_mode ) ) { //<S2SV> retval = acl ? - EINVAL : 0 ; //<S2SV> goto err_out ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> BUG ( ) ; //<S2SV> } //<S2SV> retval = v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; //<S2SV> if ( ! retval ) //<S2SV> set_cached_acl ( inode , handler -> flags , acl ) ; //<S2SV> err_out : //<S2SV> posix_acl_release ( acl ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 