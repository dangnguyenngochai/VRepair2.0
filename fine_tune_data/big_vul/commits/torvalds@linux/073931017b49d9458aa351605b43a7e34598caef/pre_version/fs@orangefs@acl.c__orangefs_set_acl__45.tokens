int orangefs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) //<S2SV> { //<S2SV> struct orangefs_inode_s * orangefs_inode = ORANGEFS_I ( inode ) ; //<S2SV> int error = 0 ; //<S2SV> void * value = NULL ; //<S2SV> size_t size = 0 ; //<S2SV> const char * name = NULL ; //<S2SV> switch ( type ) { //<S2SV> case ACL_TYPE_ACCESS : //<S2SV> name = XATTR_NAME_POSIX_ACL_ACCESS ; //<S2SV> if ( acl ) { //<S2SV> umode_t mode = inode -> i_mode ; //<S2SV> error = posix_acl_equiv_mode ( acl , & mode ) ; //<S2SV> if ( error < 0 ) { //<S2SV> gossip_err ( "%s:<S2SV_blank>posix_acl_equiv_mode<S2SV_blank>err:<S2SV_blank>%d\\n" , //<S2SV> __func__ , //<S2SV> error ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> if ( inode -> i_mode != mode ) //<S2SV> SetModeFlag ( orangefs_inode ) ; //<S2SV> inode -> i_mode = mode ; //<S2SV> mark_inode_dirty_sync ( inode ) ; //<S2SV> if ( error == 0 ) //<S2SV> acl = NULL ; //<S2SV> } //<S2SV> break ; //<S2SV> case ACL_TYPE_DEFAULT : //<S2SV> name = XATTR_NAME_POSIX_ACL_DEFAULT ; //<S2SV> break ; //<S2SV> default : //<S2SV> gossip_err ( "%s:<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>%d!\\n" , __func__ , type ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> gossip_debug ( GOSSIP_ACL_DEBUG , //<S2SV> "%s:<S2SV_blank>inode<S2SV_blank>%pU,<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>type<S2SV_blank>%d\\n" , //<S2SV> __func__ , get_khandle_from_ino ( inode ) , //<S2SV> name , //<S2SV> type ) ; //<S2SV> if ( acl ) { //<S2SV> size = posix_acl_xattr_size ( acl -> a_count ) ; //<S2SV> value = kmalloc ( size , GFP_KERNEL ) ; //<S2SV> if ( ! value ) //<S2SV> return - ENOMEM ; //<S2SV> error = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; //<S2SV> if ( error < 0 ) //<S2SV> goto out ; //<S2SV> } //<S2SV> gossip_debug ( GOSSIP_ACL_DEBUG , //<S2SV> "%s:<S2SV_blank>name<S2SV_blank>%s,<S2SV_blank>value<S2SV_blank>%p,<S2SV_blank>size<S2SV_blank>%zd,<S2SV_blank>acl<S2SV_blank>%p\\n" , //<S2SV> __func__ , name , value , size , acl ) ; //<S2SV> error = orangefs_inode_setxattr ( inode , name , value , size , 0 ) ; //<S2SV> out : //<S2SV> kfree ( value ) ; //<S2SV> if ( ! error ) //<S2SV> set_cached_acl ( inode , type , acl ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 