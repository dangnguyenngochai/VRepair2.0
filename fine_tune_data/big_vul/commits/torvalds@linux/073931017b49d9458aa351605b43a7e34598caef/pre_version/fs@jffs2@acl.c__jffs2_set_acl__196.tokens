int jffs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) //<S2SV> { //<S2SV> int rc , xprefix ; //<S2SV> switch ( type ) { //<S2SV> case ACL_TYPE_ACCESS : //<S2SV> xprefix = JFFS2_XPREFIX_ACL_ACCESS ; //<S2SV> if ( acl ) { //<S2SV> umode_t mode = inode -> i_mode ; //<S2SV> rc = posix_acl_equiv_mode ( acl , & mode ) ; //<S2SV> if ( rc < 0 ) //<S2SV> return rc ; //<S2SV> if ( inode -> i_mode != mode ) { //<S2SV> struct iattr attr ; //<S2SV> attr . ia_valid = ATTR_MODE | ATTR_CTIME ; //<S2SV> attr . ia_mode = mode ; //<S2SV> attr . ia_ctime = CURRENT_TIME_SEC ; //<S2SV> rc = jffs2_do_setattr ( inode , & attr ) ; //<S2SV> if ( rc < 0 ) //<S2SV> return rc ; //<S2SV> } //<S2SV> if ( rc == 0 ) //<S2SV> acl = NULL ; //<S2SV> } //<S2SV> break ; //<S2SV> case ACL_TYPE_DEFAULT : //<S2SV> xprefix = JFFS2_XPREFIX_ACL_DEFAULT ; //<S2SV> if ( ! S_ISDIR ( inode -> i_mode ) ) //<S2SV> return acl ? - EACCES : 0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> rc = __jffs2_set_acl ( inode , xprefix , acl ) ; //<S2SV> if ( ! rc ) //<S2SV> set_cached_acl ( inode , type , acl ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 