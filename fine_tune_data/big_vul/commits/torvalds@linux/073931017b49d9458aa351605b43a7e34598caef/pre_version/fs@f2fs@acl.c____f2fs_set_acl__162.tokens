static int __f2fs_set_acl ( struct inode * inode , int type , //<S2SV> struct posix_acl * acl , struct page * ipage ) //<S2SV> { //<S2SV> int name_index ; //<S2SV> void * value = NULL ; //<S2SV> size_t size = 0 ; //<S2SV> int error ; //<S2SV> switch ( type ) { //<S2SV> case ACL_TYPE_ACCESS : //<S2SV> name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; //<S2SV> if ( acl ) { //<S2SV> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; //<S2SV> if ( error < 0 ) //<S2SV> return error ; //<S2SV> set_acl_inode ( inode , inode -> i_mode ) ; //<S2SV> if ( error == 0 ) //<S2SV> acl = NULL ; //<S2SV> } //<S2SV> break ; //<S2SV> case ACL_TYPE_DEFAULT : //<S2SV> name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; //<S2SV> if ( ! S_ISDIR ( inode -> i_mode ) ) //<S2SV> return acl ? - EACCES : 0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( acl ) { //<S2SV> value = f2fs_acl_to_disk ( acl , & size ) ; //<S2SV> if ( IS_ERR ( value ) ) { //<S2SV> clear_inode_flag ( inode , FI_ACL_MODE ) ; //<S2SV> return ( int ) PTR_ERR ( value ) ; //<S2SV> } //<S2SV> } //<S2SV> error = f2fs_setxattr ( inode , name_index , "" , value , size , ipage , 0 ) ; //<S2SV> kfree ( value ) ; //<S2SV> if ( ! error ) //<S2SV> set_cached_acl ( inode , type , acl ) ; //<S2SV> clear_inode_flag ( inode , FI_ACL_MODE ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 