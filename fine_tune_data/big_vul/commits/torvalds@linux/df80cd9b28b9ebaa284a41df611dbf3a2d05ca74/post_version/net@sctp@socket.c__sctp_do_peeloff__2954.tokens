int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) //<S2SV> { //<S2SV> struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; //<S2SV> struct sctp_sock * sp = sctp_sk ( sk ) ; //<S2SV> struct socket * sock ; //<S2SV> int err = 0 ; //<S2SV> if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! asoc ) //<S2SV> return - EINVAL ; //<S2SV> if ( waitqueue_active ( & asoc -> wait ) ) //<S2SV> return - EBUSY ; //<S2SV> if ( ! sctp_style ( sk , UDP ) ) //<S2SV> return - EINVAL ; //<S2SV> err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> sctp_copy_sock ( sock -> sk , sk , asoc ) ; //<S2SV> sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; //<S2SV> sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; //<S2SV> * sockp = sock ; //<S2SV> return err ; //<S2SV> } //<S2SV> 