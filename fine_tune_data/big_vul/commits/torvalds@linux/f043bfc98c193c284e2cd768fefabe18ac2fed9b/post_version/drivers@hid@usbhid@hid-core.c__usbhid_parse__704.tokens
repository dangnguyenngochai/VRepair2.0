static int usbhid_parse ( struct hid_device * hid ) //<S2SV> { //<S2SV> struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; //<S2SV> struct usb_host_interface * interface = intf -> cur_altsetting ; //<S2SV> struct usb_device * dev = interface_to_usbdev ( intf ) ; //<S2SV> struct hid_descriptor * hdesc ; //<S2SV> u32 quirks = 0 ; //<S2SV> unsigned int rsize = 0 ; //<S2SV> char * rdesc ; //<S2SV> int ret , n ; //<S2SV> int num_descriptors ; //<S2SV> size_t offset = offsetof ( struct hid_descriptor , desc ) ; //<S2SV> quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , //<S2SV> le16_to_cpu ( dev -> descriptor . idProduct ) ) ; //<S2SV> if ( quirks & HID_QUIRK_IGNORE ) //<S2SV> return - ENODEV ; //<S2SV> if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { //<S2SV> if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || //<S2SV> interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) //<S2SV> quirks |= HID_QUIRK_NOGET ; //<S2SV> } //<S2SV> if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && //<S2SV> ( ! interface -> desc . bNumEndpoints || //<S2SV> usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { //<S2SV> dbg_hid ( "class<S2SV_blank>descriptor<S2SV_blank>not<S2SV_blank>present\\n" ) ; //<S2SV> return - ENODEV ; //<S2SV> } //<S2SV> if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { //<S2SV> dbg_hid ( "hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; //<S2SV> hid -> country = hdesc -> bCountryCode ; //<S2SV> num_descriptors = min_t ( int , hdesc -> bNumDescriptors , //<S2SV> ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) ; //<S2SV> for ( n = 0 ; n < num_descriptors ; n ++ ) //<S2SV> if ( hdesc -> desc [ n ] . bDescriptorType == HID_DT_REPORT ) //<S2SV> rsize = le16_to_cpu ( hdesc -> desc [ n ] . wDescriptorLength ) ; //<S2SV> if ( ! rsize || rsize > HID_MAX_DESCRIPTOR_SIZE ) { //<S2SV> dbg_hid ( "weird<S2SV_blank>size<S2SV_blank>of<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>(%u)\\n" , rsize ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> rdesc = kmalloc ( rsize , GFP_KERNEL ) ; //<S2SV> if ( ! rdesc ) //<S2SV> return - ENOMEM ; //<S2SV> hid_set_idle ( dev , interface -> desc . bInterfaceNumber , 0 , 0 ) ; //<S2SV> ret = hid_get_class_descriptor ( dev , interface -> desc . bInterfaceNumber , //<S2SV> HID_DT_REPORT , rdesc , rsize ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> dbg_hid ( "reading<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>failed\\n" ) ; //<S2SV> kfree ( rdesc ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> ret = hid_parse_report ( hid , rdesc , rsize ) ; //<S2SV> kfree ( rdesc ) ; //<S2SV> if ( ret ) { //<S2SV> dbg_hid ( "parsing<S2SV_blank>report<S2SV_blank>descriptor<S2SV_blank>failed\\n" ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> hid -> quirks |= quirks ; //<S2SV> return 0 ; //<S2SV> err : //<S2SV> return ret ; //<S2SV> } //<S2SV> 