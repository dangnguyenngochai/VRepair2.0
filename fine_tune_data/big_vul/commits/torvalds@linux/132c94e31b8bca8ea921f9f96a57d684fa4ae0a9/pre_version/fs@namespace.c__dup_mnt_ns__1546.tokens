static struct mnt_namespace * dup_mnt_ns ( struct mnt_namespace * mnt_ns , //<S2SV> struct user_namespace * user_ns , struct fs_struct * fs ) //<S2SV> { //<S2SV> struct mnt_namespace * new_ns ; //<S2SV> struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; //<S2SV> struct mount * p , * q ; //<S2SV> struct mount * old = mnt_ns -> root ; //<S2SV> struct mount * new ; //<S2SV> int copy_flags ; //<S2SV> new_ns = alloc_mnt_ns ( user_ns ) ; //<S2SV> if ( IS_ERR ( new_ns ) ) //<S2SV> return new_ns ; //<S2SV> down_write ( & namespace_sem ) ; //<S2SV> copy_flags = CL_COPY_ALL | CL_EXPIRE ; //<S2SV> if ( user_ns != mnt_ns -> user_ns ) //<S2SV> copy_flags |= CL_SHARED_TO_SLAVE ; //<S2SV> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; //<S2SV> if ( IS_ERR ( new ) ) { //<S2SV> up_write ( & namespace_sem ) ; //<S2SV> free_mnt_ns ( new_ns ) ; //<S2SV> return ERR_CAST ( new ) ; //<S2SV> } //<S2SV> new_ns -> root = new ; //<S2SV> br_write_lock ( & vfsmount_lock ) ; //<S2SV> list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; //<S2SV> br_write_unlock ( & vfsmount_lock ) ; //<S2SV> p = old ; //<S2SV> q = new ; //<S2SV> while ( p ) { //<S2SV> q -> mnt_ns = new_ns ; //<S2SV> if ( fs ) { //<S2SV> if ( & p -> mnt == fs -> root . mnt ) { //<S2SV> fs -> root . mnt = mntget ( & q -> mnt ) ; //<S2SV> rootmnt = & p -> mnt ; //<S2SV> } //<S2SV> if ( & p -> mnt == fs -> pwd . mnt ) { //<S2SV> fs -> pwd . mnt = mntget ( & q -> mnt ) ; //<S2SV> pwdmnt = & p -> mnt ; //<S2SV> } //<S2SV> } //<S2SV> p = next_mnt ( p , old ) ; //<S2SV> q = next_mnt ( q , new ) ; //<S2SV> } //<S2SV> up_write ( & namespace_sem ) ; //<S2SV> if ( rootmnt ) //<S2SV> mntput ( rootmnt ) ; //<S2SV> if ( pwdmnt ) //<S2SV> mntput ( pwdmnt ) ; //<S2SV> return new_ns ; //<S2SV> } //<S2SV> 