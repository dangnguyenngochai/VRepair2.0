static struct mount * clone_mnt ( struct mount * old , struct dentry * root , //<S2SV> int flag ) //<S2SV> { //<S2SV> struct super_block * sb = old -> mnt . mnt_sb ; //<S2SV> struct mount * mnt ; //<S2SV> int err ; //<S2SV> mnt = alloc_vfsmnt ( old -> mnt_devname ) ; //<S2SV> if ( ! mnt ) //<S2SV> return ERR_PTR ( - ENOMEM ) ; //<S2SV> if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) //<S2SV> mnt -> mnt_group_id = 0 ; //<S2SV> else //<S2SV> mnt -> mnt_group_id = old -> mnt_group_id ; //<S2SV> if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { //<S2SV> err = mnt_alloc_group_id ( mnt ) ; //<S2SV> if ( err ) //<S2SV> goto out_free ; //<S2SV> } //<S2SV> mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ MNT_WRITE_HOLD ; //<S2SV> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) //<S2SV> mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; //<S2SV> atomic_inc ( & sb -> s_active ) ; //<S2SV> mnt -> mnt . mnt_sb = sb ; //<S2SV> mnt -> mnt . mnt_root = dget ( root ) ; //<S2SV> mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; //<S2SV> mnt -> mnt_parent = mnt ; //<S2SV> br_write_lock ( & vfsmount_lock ) ; //<S2SV> list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; //<S2SV> br_write_unlock ( & vfsmount_lock ) ; //<S2SV> if ( ( flag & CL_SLAVE ) || //<S2SV> ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { //<S2SV> list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; //<S2SV> mnt -> mnt_master = old ; //<S2SV> CLEAR_MNT_SHARED ( mnt ) ; //<S2SV> } else if ( ! ( flag & CL_PRIVATE ) ) { //<S2SV> if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) //<S2SV> list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; //<S2SV> if ( IS_MNT_SLAVE ( old ) ) //<S2SV> list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; //<S2SV> mnt -> mnt_master = old -> mnt_master ; //<S2SV> } //<S2SV> if ( flag & CL_MAKE_SHARED ) //<S2SV> set_mnt_shared ( mnt ) ; //<S2SV> if ( flag & CL_EXPIRE ) { //<S2SV> if ( ! list_empty ( & old -> mnt_expire ) ) //<S2SV> list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; //<S2SV> } //<S2SV> return mnt ; //<S2SV> out_free : //<S2SV> free_vfsmnt ( mnt ) ; //<S2SV> return ERR_PTR ( err ) ; //<S2SV> } //<S2SV> 