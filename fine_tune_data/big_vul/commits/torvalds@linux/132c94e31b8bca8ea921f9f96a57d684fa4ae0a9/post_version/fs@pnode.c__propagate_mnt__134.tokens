int propagate_mnt ( struct mount * dest_mnt , struct dentry * dest_dentry , //<S2SV> struct mount * source_mnt , struct list_head * tree_list ) //<S2SV> { //<S2SV> struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; //<S2SV> struct mount * m , * child ; //<S2SV> int ret = 0 ; //<S2SV> struct mount * prev_dest_mnt = dest_mnt ; //<S2SV> struct mount * prev_src_mnt = source_mnt ; //<S2SV> LIST_HEAD ( tmp_list ) ; //<S2SV> LIST_HEAD ( umount_list ) ; //<S2SV> for ( m = propagation_next ( dest_mnt , dest_mnt ) ; m ; //<S2SV> m = propagation_next ( m , dest_mnt ) ) { //<S2SV> int type ; //<S2SV> struct mount * source ; //<S2SV> if ( IS_MNT_NEW ( m ) ) //<S2SV> continue ; //<S2SV> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; //<S2SV> if ( m -> mnt_ns -> user_ns != user_ns ) //<S2SV> type |= CL_UNPRIVILEGED ; //<S2SV> child = copy_tree ( source , source -> mnt . mnt_root , type ) ; //<S2SV> if ( IS_ERR ( child ) ) { //<S2SV> ret = PTR_ERR ( child ) ; //<S2SV> list_splice ( tree_list , tmp_list . prev ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( is_subdir ( dest_dentry , m -> mnt . mnt_root ) ) { //<S2SV> mnt_set_mountpoint ( m , dest_dentry , child ) ; //<S2SV> list_add_tail ( & child -> mnt_hash , tree_list ) ; //<S2SV> } else { //<S2SV> list_add_tail ( & child -> mnt_hash , & tmp_list ) ; //<S2SV> } //<S2SV> prev_dest_mnt = m ; //<S2SV> prev_src_mnt = child ; //<S2SV> } //<S2SV> out : //<S2SV> br_write_lock ( & vfsmount_lock ) ; //<S2SV> while ( ! list_empty ( & tmp_list ) ) { //<S2SV> child = list_first_entry ( & tmp_list , struct mount , mnt_hash ) ; //<S2SV> umount_tree ( child , 0 , & umount_list ) ; //<S2SV> } //<S2SV> br_write_unlock ( & vfsmount_lock ) ; //<S2SV> release_mounts ( & umount_list ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 