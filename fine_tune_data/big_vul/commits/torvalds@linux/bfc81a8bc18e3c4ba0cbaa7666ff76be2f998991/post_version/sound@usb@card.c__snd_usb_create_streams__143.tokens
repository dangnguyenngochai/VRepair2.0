static int snd_usb_create_streams ( struct snd_usb_audio * chip , int ctrlif ) //<S2SV> { //<S2SV> struct usb_device * dev = chip -> dev ; //<S2SV> struct usb_host_interface * host_iface ; //<S2SV> struct usb_interface_descriptor * altsd ; //<S2SV> void * control_header ; //<S2SV> int i , protocol ; //<S2SV> int rest_bytes ; //<S2SV> host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ; //<S2SV> control_header = snd_usb_find_csint_desc ( host_iface -> extra , //<S2SV> host_iface -> extralen , //<S2SV> NULL , UAC_HEADER ) ; //<S2SV> altsd = get_iface_desc ( host_iface ) ; //<S2SV> protocol = altsd -> bInterfaceProtocol ; //<S2SV> if ( ! control_header ) { //<S2SV> dev_err ( & dev -> dev , "cannot<S2SV_blank>find<S2SV_blank>UAC_HEADER\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - //<S2SV> control_header ; //<S2SV> if ( rest_bytes <= 0 ) { //<S2SV> dev_err ( & dev -> dev , "invalid<S2SV_blank>control<S2SV_blank>header\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> switch ( protocol ) { //<S2SV> default : //<S2SV> dev_warn ( & dev -> dev , //<S2SV> "unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\n" , //<S2SV> protocol ) ; //<S2SV> case UAC_VERSION_1 : { //<S2SV> struct uac1_ac_header_descriptor * h1 = control_header ; //<S2SV> if ( rest_bytes < sizeof ( * h1 ) ) { //<S2SV> dev_err ( & dev -> dev , "too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( ! h1 -> bInCollection ) { //<S2SV> dev_info ( & dev -> dev , "skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( rest_bytes < h1 -> bLength ) { //<S2SV> dev_err ( & dev -> dev , "invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( h1 -> bLength < sizeof ( * h1 ) + h1 -> bInCollection ) { //<S2SV> dev_err ( & dev -> dev , "invalid<S2SV_blank>UAC_HEADER<S2SV_blank>(v1)\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> for ( i = 0 ; i < h1 -> bInCollection ; i ++ ) //<S2SV> snd_usb_create_stream ( chip , ctrlif , h1 -> baInterfaceNr [ i ] ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case UAC_VERSION_2 : { //<S2SV> struct usb_interface_assoc_descriptor * assoc = //<S2SV> usb_ifnum_to_if ( dev , ctrlif ) -> intf_assoc ; //<S2SV> if ( ! assoc ) { //<S2SV> struct usb_interface * iface = //<S2SV> usb_ifnum_to_if ( dev , ctrlif + 1 ) ; //<S2SV> if ( iface && //<S2SV> iface -> intf_assoc && //<S2SV> iface -> intf_assoc -> bFunctionClass == USB_CLASS_AUDIO && //<S2SV> iface -> intf_assoc -> bFunctionProtocol == UAC_VERSION_2 ) //<S2SV> assoc = iface -> intf_assoc ; //<S2SV> } //<S2SV> if ( ! assoc ) { //<S2SV> dev_err ( & dev -> dev , "Audio<S2SV_blank>class<S2SV_blank>v2<S2SV_blank>interfaces<S2SV_blank>need<S2SV_blank>an<S2SV_blank>interface<S2SV_blank>association\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> for ( i = 0 ; i < assoc -> bInterfaceCount ; i ++ ) { //<S2SV> int intf = assoc -> bFirstInterface + i ; //<S2SV> if ( intf != ctrlif ) //<S2SV> snd_usb_create_stream ( chip , ctrlif , intf ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 