sctp_disposition_t sctp_sf_do_5_1D_ce ( struct net * net , //<S2SV> const struct sctp_endpoint * ep , //<S2SV> const struct sctp_association * asoc , //<S2SV> const sctp_subtype_t type , void * arg , //<S2SV> sctp_cmd_seq_t * commands ) //<S2SV> { //<S2SV> struct sctp_chunk * chunk = arg ; //<S2SV> struct sctp_association * new_asoc ; //<S2SV> sctp_init_chunk_t * peer_init ; //<S2SV> struct sctp_chunk * repl ; //<S2SV> struct sctp_ulpevent * ev , * ai_ev = NULL ; //<S2SV> int error = 0 ; //<S2SV> struct sctp_chunk * err_chk_p ; //<S2SV> struct sock * sk ; //<S2SV> if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { //<S2SV> SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; //<S2SV> return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; //<S2SV> } //<S2SV> if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) //<S2SV> return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; //<S2SV> sk = ep -> base . sk ; //<S2SV> if ( ! sctp_sstate ( sk , LISTENING ) || //<S2SV> ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) //<S2SV> return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; //<S2SV> chunk -> subh . cookie_hdr = //<S2SV> ( struct sctp_signed_cookie * ) chunk -> skb -> data ; //<S2SV> if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - //<S2SV> sizeof ( sctp_chunkhdr_t ) ) ) //<S2SV> goto nomem ; //<S2SV> new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , //<S2SV> & err_chk_p ) ; //<S2SV> if ( ! new_asoc ) { //<S2SV> switch ( error ) { //<S2SV> case - SCTP_IERROR_NOMEM : //<S2SV> goto nomem ; //<S2SV> case - SCTP_IERROR_STALE_COOKIE : //<S2SV> sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , //<S2SV> err_chk_p ) ; //<S2SV> return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; //<S2SV> case - SCTP_IERROR_BAD_SIG : //<S2SV> default : //<S2SV> return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; //<S2SV> } //<S2SV> } //<S2SV> peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; //<S2SV> if ( ! sctp_process_init ( new_asoc , chunk , //<S2SV> & chunk -> subh . cookie_hdr -> c . peer_addr , //<S2SV> peer_init , GFP_ATOMIC ) ) //<S2SV> goto nomem_init ; //<S2SV> error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; //<S2SV> if ( error ) //<S2SV> goto nomem_init ; //<S2SV> if ( chunk -> auth_chunk ) { //<S2SV> struct sctp_chunk auth ; //<S2SV> sctp_ierror_t ret ; //<S2SV> auth . skb = chunk -> auth_chunk ; //<S2SV> auth . asoc = chunk -> asoc ; //<S2SV> auth . sctp_hdr = chunk -> sctp_hdr ; //<S2SV> auth . chunk_hdr = ( sctp_chunkhdr_t * ) skb_push ( chunk -> auth_chunk , //<S2SV> sizeof ( sctp_chunkhdr_t ) ) ; //<S2SV> skb_pull ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; //<S2SV> auth . transport = chunk -> transport ; //<S2SV> ret = sctp_sf_authenticate ( net , ep , new_asoc , type , & auth ) ; //<S2SV> kfree_skb ( chunk -> auth_chunk ) ; //<S2SV> if ( ret != SCTP_IERROR_NO_ERROR ) { //<S2SV> sctp_association_free ( new_asoc ) ; //<S2SV> return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; //<S2SV> } //<S2SV> } //<S2SV> repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; //<S2SV> if ( ! repl ) //<S2SV> goto nomem_init ; //<S2SV> ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , //<S2SV> new_asoc -> c . sinit_num_ostreams , //<S2SV> new_asoc -> c . sinit_max_instreams , //<S2SV> NULL , GFP_ATOMIC ) ; //<S2SV> if ( ! ev ) //<S2SV> goto nomem_ev ; //<S2SV> if ( new_asoc -> peer . adaptation_ind ) { //<S2SV> ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , //<S2SV> GFP_ATOMIC ) ; //<S2SV> if ( ! ai_ev ) //<S2SV> goto nomem_aiev ; //<S2SV> } //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , //<S2SV> SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; //<S2SV> SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; //<S2SV> SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; //<S2SV> if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , //<S2SV> SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; //<S2SV> if ( ai_ev ) //<S2SV> sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , //<S2SV> SCTP_ULPEVENT ( ai_ev ) ) ; //<S2SV> return SCTP_DISPOSITION_CONSUME ; //<S2SV> nomem_aiev : //<S2SV> sctp_ulpevent_free ( ev ) ; //<S2SV> nomem_ev : //<S2SV> sctp_chunk_free ( repl ) ; //<S2SV> nomem_init : //<S2SV> sctp_association_free ( new_asoc ) ; //<S2SV> nomem : //<S2SV> return SCTP_DISPOSITION_NOMEM ; //<S2SV> } //<S2SV> 