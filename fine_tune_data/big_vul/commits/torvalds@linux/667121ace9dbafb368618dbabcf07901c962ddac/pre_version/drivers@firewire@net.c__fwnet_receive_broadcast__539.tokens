static void fwnet_receive_broadcast ( struct fw_iso_context * context , //<S2SV> u32 cycle , size_t header_length , void * header , void * data ) //<S2SV> { //<S2SV> struct fwnet_device * dev ; //<S2SV> struct fw_iso_packet packet ; //<S2SV> __be16 * hdr_ptr ; //<S2SV> __be32 * buf_ptr ; //<S2SV> int retval ; //<S2SV> u32 length ; //<S2SV> u16 source_node_id ; //<S2SV> u32 specifier_id ; //<S2SV> u32 ver ; //<S2SV> unsigned long offset ; //<S2SV> unsigned long flags ; //<S2SV> dev = data ; //<S2SV> hdr_ptr = header ; //<S2SV> length = be16_to_cpup ( hdr_ptr ) ; //<S2SV> spin_lock_irqsave ( & dev -> lock , flags ) ; //<S2SV> offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ; //<S2SV> buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ; //<S2SV> if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) //<S2SV> dev -> broadcast_rcv_next_ptr = 0 ; //<S2SV> spin_unlock_irqrestore ( & dev -> lock , flags ) ; //<S2SV> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 //<S2SV> | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ; //<S2SV> ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ; //<S2SV> source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ; //<S2SV> if ( specifier_id == IANA_SPECIFIER_ID && //<S2SV> ( ver == RFC2734_SW_VERSION //<S2SV> # if IS_ENABLED ( CONFIG_IPV6 ) //<S2SV> || ver == RFC3146_SW_VERSION //<S2SV> # endif //<S2SV> ) ) { //<S2SV> buf_ptr += 2 ; //<S2SV> length -= IEEE1394_GASP_HDR_SIZE ; //<S2SV> fwnet_incoming_packet ( dev , buf_ptr , length , source_node_id , //<S2SV> context -> card -> generation , true ) ; //<S2SV> } //<S2SV> packet . payload_length = dev -> rcv_buffer_size ; //<S2SV> packet . interrupt = 1 ; //<S2SV> packet . skip = 0 ; //<S2SV> packet . tag = 3 ; //<S2SV> packet . sy = 0 ; //<S2SV> packet . header_length = IEEE1394_GASP_HDR_SIZE ; //<S2SV> spin_lock_irqsave ( & dev -> lock , flags ) ; //<S2SV> retval = fw_iso_context_queue ( dev -> broadcast_rcv_context , & packet , //<S2SV> & dev -> broadcast_rcv_buffer , offset ) ; //<S2SV> spin_unlock_irqrestore ( & dev -> lock , flags ) ; //<S2SV> if ( retval >= 0 ) //<S2SV> fw_iso_context_queue_flush ( dev -> broadcast_rcv_context ) ; //<S2SV> else //<S2SV> dev_err ( & dev -> netdev -> dev , "requeue<S2SV_blank>failed\\n" ) ; //<S2SV> } //<S2SV> 