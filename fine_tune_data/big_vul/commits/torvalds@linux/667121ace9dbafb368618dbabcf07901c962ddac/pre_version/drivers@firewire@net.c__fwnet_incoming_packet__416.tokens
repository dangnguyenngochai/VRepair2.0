static int fwnet_incoming_packet ( struct fwnet_device * dev , __be32 * buf , int len , //<S2SV> int source_node_id , int generation , //<S2SV> bool is_broadcast ) //<S2SV> { //<S2SV> struct sk_buff * skb ; //<S2SV> struct net_device * net = dev -> netdev ; //<S2SV> struct rfc2734_header hdr ; //<S2SV> unsigned lf ; //<S2SV> unsigned long flags ; //<S2SV> struct fwnet_peer * peer ; //<S2SV> struct fwnet_partial_datagram * pd ; //<S2SV> int fg_off ; //<S2SV> int dg_size ; //<S2SV> u16 datagram_label ; //<S2SV> int retval ; //<S2SV> u16 ether_type ; //<S2SV> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; //<S2SV> lf = fwnet_get_hdr_lf ( & hdr ) ; //<S2SV> if ( lf == RFC2374_HDR_UNFRAG ) { //<S2SV> ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; //<S2SV> buf ++ ; //<S2SV> len -= RFC2374_UNFRAG_HDR_SIZE ; //<S2SV> skb = dev_alloc_skb ( len + LL_RESERVED_SPACE ( net ) ) ; //<S2SV> if ( unlikely ( ! skb ) ) { //<S2SV> net -> stats . rx_dropped ++ ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> skb_reserve ( skb , LL_RESERVED_SPACE ( net ) ) ; //<S2SV> memcpy ( skb_put ( skb , len ) , buf , len ) ; //<S2SV> return fwnet_finish_incoming_packet ( net , skb , source_node_id , //<S2SV> is_broadcast , ether_type ) ; //<S2SV> } //<S2SV> hdr . w1 = ntohl ( buf [ 1 ] ) ; //<S2SV> buf += 2 ; //<S2SV> len -= RFC2374_FRAG_HDR_SIZE ; //<S2SV> if ( lf == RFC2374_HDR_FIRSTFRAG ) { //<S2SV> ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; //<S2SV> fg_off = 0 ; //<S2SV> } else { //<S2SV> ether_type = 0 ; //<S2SV> fg_off = fwnet_get_hdr_fg_off ( & hdr ) ; //<S2SV> } //<S2SV> datagram_label = fwnet_get_hdr_dgl ( & hdr ) ; //<S2SV> dg_size = fwnet_get_hdr_dg_size ( & hdr ) ; //<S2SV> spin_lock_irqsave ( & dev -> lock , flags ) ; //<S2SV> peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ; //<S2SV> if ( ! peer ) { //<S2SV> retval = - ENOENT ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> pd = fwnet_pd_find ( peer , datagram_label ) ; //<S2SV> if ( pd == NULL ) { //<S2SV> while ( peer -> pdg_size >= FWNET_MAX_FRAGMENTS ) { //<S2SV> fwnet_pd_delete ( list_first_entry ( & peer -> pd_list , //<S2SV> struct fwnet_partial_datagram , pd_link ) ) ; //<S2SV> peer -> pdg_size -- ; //<S2SV> } //<S2SV> pd = fwnet_pd_new ( net , peer , datagram_label , //<S2SV> dg_size , buf , fg_off , len ) ; //<S2SV> if ( pd == NULL ) { //<S2SV> retval = - ENOMEM ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> peer -> pdg_size ++ ; //<S2SV> } else { //<S2SV> if ( fwnet_frag_overlap ( pd , fg_off , len ) || //<S2SV> pd -> datagram_size != dg_size ) { //<S2SV> fwnet_pd_delete ( pd ) ; //<S2SV> pd = fwnet_pd_new ( net , peer , datagram_label , //<S2SV> dg_size , buf , fg_off , len ) ; //<S2SV> if ( pd == NULL ) { //<S2SV> peer -> pdg_size -- ; //<S2SV> retval = - ENOMEM ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( ! fwnet_pd_update ( peer , pd , buf , fg_off , len ) ) { //<S2SV> fwnet_pd_delete ( pd ) ; //<S2SV> peer -> pdg_size -- ; //<S2SV> retval = - ENOMEM ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( lf == RFC2374_HDR_FIRSTFRAG ) //<S2SV> pd -> ether_type = ether_type ; //<S2SV> if ( fwnet_pd_is_complete ( pd ) ) { //<S2SV> ether_type = pd -> ether_type ; //<S2SV> peer -> pdg_size -- ; //<S2SV> skb = skb_get ( pd -> skb ) ; //<S2SV> fwnet_pd_delete ( pd ) ; //<S2SV> spin_unlock_irqrestore ( & dev -> lock , flags ) ; //<S2SV> return fwnet_finish_incoming_packet ( net , skb , source_node_id , //<S2SV> false , ether_type ) ; //<S2SV> } //<S2SV> retval = 0 ; //<S2SV> fail : //<S2SV> spin_unlock_irqrestore ( & dev -> lock , flags ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 