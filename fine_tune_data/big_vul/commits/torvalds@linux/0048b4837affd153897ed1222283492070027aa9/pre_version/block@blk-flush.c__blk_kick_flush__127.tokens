static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) //<S2SV> { //<S2SV> struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; //<S2SV> struct request * first_rq = //<S2SV> list_first_entry ( pending , struct request , flush . list ) ; //<S2SV> struct request * flush_rq = fq -> flush_rq ; //<S2SV> if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) //<S2SV> return false ; //<S2SV> if ( ! list_empty ( & fq -> flush_data_in_flight ) && //<S2SV> time_before ( jiffies , //<S2SV> fq -> flush_pending_since + FLUSH_PENDING_TIMEOUT ) ) //<S2SV> return false ; //<S2SV> fq -> flush_pending_idx ^= 1 ; //<S2SV> blk_rq_init ( q , flush_rq ) ; //<S2SV> if ( q -> mq_ops ) { //<S2SV> flush_rq -> mq_ctx = first_rq -> mq_ctx ; //<S2SV> flush_rq -> tag = first_rq -> tag ; //<S2SV> } //<S2SV> flush_rq -> cmd_type = REQ_TYPE_FS ; //<S2SV> flush_rq -> cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ ; //<S2SV> flush_rq -> rq_disk = first_rq -> rq_disk ; //<S2SV> flush_rq -> end_io = flush_end_io ; //<S2SV> return blk_flush_queue_rq ( flush_rq , false ) ; //<S2SV> } //<S2SV> 