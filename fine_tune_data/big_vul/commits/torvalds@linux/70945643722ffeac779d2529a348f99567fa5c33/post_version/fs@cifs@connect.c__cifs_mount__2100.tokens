int //<S2SV> cifs_mount ( struct super_block * sb , struct cifs_sb_info * cifs_sb , //<S2SV> char * mount_data_global , const char * devname ) //<S2SV> { //<S2SV> int rc ; //<S2SV> int xid ; //<S2SV> struct smb_vol * volume_info ; //<S2SV> struct cifsSesInfo * pSesInfo ; //<S2SV> struct cifsTconInfo * tcon ; //<S2SV> struct TCP_Server_Info * srvTcp ; //<S2SV> char * full_path ; //<S2SV> char * mount_data = mount_data_global ; //<S2SV> struct tcon_link * tlink ; //<S2SV> # ifdef CONFIG_CIFS_DFS_UPCALL //<S2SV> struct dfs_info3_param * referrals = NULL ; //<S2SV> unsigned int num_referrals = 0 ; //<S2SV> int referral_walks_count = 0 ; //<S2SV> try_mount_again : //<S2SV> # endif //<S2SV> rc = 0 ; //<S2SV> tcon = NULL ; //<S2SV> pSesInfo = NULL ; //<S2SV> srvTcp = NULL ; //<S2SV> full_path = NULL ; //<S2SV> tlink = NULL ; //<S2SV> xid = GetXid ( ) ; //<S2SV> volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ) ; //<S2SV> if ( ! volume_info ) { //<S2SV> rc = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) ) { //<S2SV> rc = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( volume_info -> nullauth ) { //<S2SV> cFYI ( 1 , "null<S2SV_blank>user" ) ; //<S2SV> volume_info -> username = "" ; //<S2SV> } else if ( volume_info -> username ) { //<S2SV> cFYI ( 1 , "Username:<S2SV_blank>%s" , volume_info -> username ) ; //<S2SV> } else { //<S2SV> cifserror ( "No<S2SV_blank>username<S2SV_blank>specified" ) ; //<S2SV> rc = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( volume_info -> iocharset == NULL ) { //<S2SV> volume_info -> local_nls = load_nls_default ( ) ; //<S2SV> } else { //<S2SV> volume_info -> local_nls = load_nls ( volume_info -> iocharset ) ; //<S2SV> if ( volume_info -> local_nls == NULL ) { //<S2SV> cERROR ( 1 , "CIFS<S2SV_blank>mount<S2SV_blank>error:<S2SV_blank>iocharset<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found" , //<S2SV> volume_info -> iocharset ) ; //<S2SV> rc = - ELIBACC ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> cifs_sb -> local_nls = volume_info -> local_nls ; //<S2SV> srvTcp = cifs_get_tcp_session ( volume_info ) ; //<S2SV> if ( IS_ERR ( srvTcp ) ) { //<S2SV> rc = PTR_ERR ( srvTcp ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> pSesInfo = cifs_get_smb_ses ( srvTcp , volume_info ) ; //<S2SV> if ( IS_ERR ( pSesInfo ) ) { //<S2SV> rc = PTR_ERR ( pSesInfo ) ; //<S2SV> pSesInfo = NULL ; //<S2SV> goto mount_fail_check ; //<S2SV> } //<S2SV> setup_cifs_sb ( volume_info , cifs_sb ) ; //<S2SV> if ( pSesInfo -> capabilities & CAP_LARGE_FILES ) //<S2SV> sb -> s_maxbytes = MAX_LFS_FILESIZE ; //<S2SV> else //<S2SV> sb -> s_maxbytes = MAX_NON_LFS ; //<S2SV> sb -> s_time_gran = 100 ; //<S2SV> tcon = cifs_get_tcon ( pSesInfo , volume_info ) ; //<S2SV> if ( IS_ERR ( tcon ) ) { //<S2SV> rc = PTR_ERR ( tcon ) ; //<S2SV> tcon = NULL ; //<S2SV> goto remote_path_check ; //<S2SV> } //<S2SV> if ( ! tcon -> ipc ) { //<S2SV> CIFSSMBQFSDeviceInfo ( xid , tcon ) ; //<S2SV> CIFSSMBQFSAttributeInfo ( xid , tcon ) ; //<S2SV> } //<S2SV> if ( tcon -> ses -> capabilities & CAP_UNIX ) //<S2SV> reset_cifs_unix_caps ( xid , tcon , sb , volume_info ) ; //<S2SV> else //<S2SV> tcon -> unix_ext = 0 ; //<S2SV> if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 ) //<S2SV> convert_delimiter ( cifs_sb -> prepath , CIFS_DIR_SEP ( cifs_sb ) ) ; //<S2SV> if ( ( tcon -> unix_ext == 0 ) && ( cifs_sb -> rsize > ( 1024 * 127 ) ) ) { //<S2SV> cifs_sb -> rsize = 1024 * 127 ; //<S2SV> cFYI ( DBG2 , "no<S2SV_blank>very<S2SV_blank>large<S2SV_blank>read<S2SV_blank>support,<S2SV_blank>rsize<S2SV_blank>now<S2SV_blank>127K" ) ; //<S2SV> } //<S2SV> if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_WRITE_X ) ) //<S2SV> cifs_sb -> wsize = min ( cifs_sb -> wsize , //<S2SV> ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) ; //<S2SV> if ( ! ( tcon -> ses -> capabilities & CAP_LARGE_READ_X ) ) //<S2SV> cifs_sb -> rsize = min ( cifs_sb -> rsize , //<S2SV> ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) ) ; //<S2SV> remote_path_check : //<S2SV> if ( ! rc && tcon ) { //<S2SV> full_path = cifs_build_path_to_root ( cifs_sb , tcon ) ; //<S2SV> if ( full_path == NULL ) { //<S2SV> rc = - ENOMEM ; //<S2SV> goto mount_fail_check ; //<S2SV> } //<S2SV> rc = is_path_accessible ( xid , tcon , cifs_sb , full_path ) ; //<S2SV> if ( rc != 0 && rc != - EREMOTE ) { //<S2SV> kfree ( full_path ) ; //<S2SV> goto mount_fail_check ; //<S2SV> } //<S2SV> kfree ( full_path ) ; //<S2SV> } //<S2SV> if ( rc == - EREMOTE ) { //<S2SV> # ifdef CONFIG_CIFS_DFS_UPCALL //<S2SV> if ( referral_walks_count > MAX_NESTED_LINKS ) { //<S2SV> rc = - ELOOP ; //<S2SV> goto mount_fail_check ; //<S2SV> } //<S2SV> if ( ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) == 0 ) //<S2SV> convert_delimiter ( cifs_sb -> prepath , //<S2SV> CIFS_DIR_SEP ( cifs_sb ) ) ; //<S2SV> full_path = build_unc_path_to_root ( volume_info , cifs_sb ) ; //<S2SV> if ( IS_ERR ( full_path ) ) { //<S2SV> rc = PTR_ERR ( full_path ) ; //<S2SV> goto mount_fail_check ; //<S2SV> } //<S2SV> cFYI ( 1 , "Getting<S2SV_blank>referral<S2SV_blank>for:<S2SV_blank>%s" , full_path ) ; //<S2SV> rc = get_dfs_path ( xid , pSesInfo , full_path + 1 , //<S2SV> cifs_sb -> local_nls , & num_referrals , & referrals , //<S2SV> cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR ) ; //<S2SV> if ( ! rc && num_referrals > 0 ) { //<S2SV> char * fake_devname = NULL ; //<S2SV> if ( mount_data != mount_data_global ) //<S2SV> kfree ( mount_data ) ; //<S2SV> mount_data = cifs_compose_mount_options ( //<S2SV> cifs_sb -> mountdata , full_path + 1 , //<S2SV> referrals , & fake_devname ) ; //<S2SV> free_dfs_info_array ( referrals , num_referrals ) ; //<S2SV> kfree ( fake_devname ) ; //<S2SV> kfree ( full_path ) ; //<S2SV> if ( IS_ERR ( mount_data ) ) { //<S2SV> rc = PTR_ERR ( mount_data ) ; //<S2SV> mount_data = NULL ; //<S2SV> goto mount_fail_check ; //<S2SV> } //<S2SV> if ( tcon ) //<S2SV> cifs_put_tcon ( tcon ) ; //<S2SV> else if ( pSesInfo ) //<S2SV> cifs_put_smb_ses ( pSesInfo ) ; //<S2SV> cleanup_volume_info ( & volume_info ) ; //<S2SV> referral_walks_count ++ ; //<S2SV> FreeXid ( xid ) ; //<S2SV> goto try_mount_again ; //<S2SV> } //<S2SV> # else //<S2SV> rc = - EOPNOTSUPP ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( rc ) //<S2SV> goto mount_fail_check ; //<S2SV> tlink = kzalloc ( sizeof * tlink , GFP_KERNEL ) ; //<S2SV> if ( tlink == NULL ) { //<S2SV> rc = - ENOMEM ; //<S2SV> goto mount_fail_check ; //<S2SV> } //<S2SV> tlink -> tl_uid = pSesInfo -> linux_uid ; //<S2SV> tlink -> tl_tcon = tcon ; //<S2SV> tlink -> tl_time = jiffies ; //<S2SV> set_bit ( TCON_LINK_MASTER , & tlink -> tl_flags ) ; //<S2SV> set_bit ( TCON_LINK_IN_TREE , & tlink -> tl_flags ) ; //<S2SV> cifs_sb -> master_tlink = tlink ; //<S2SV> spin_lock ( & cifs_sb -> tlink_tree_lock ) ; //<S2SV> tlink_rb_insert ( & cifs_sb -> tlink_tree , tlink ) ; //<S2SV> spin_unlock ( & cifs_sb -> tlink_tree_lock ) ; //<S2SV> queue_delayed_work ( system_nrt_wq , & cifs_sb -> prune_tlinks , //<S2SV> TLINK_IDLE_EXPIRE ) ; //<S2SV> mount_fail_check : //<S2SV> if ( rc ) { //<S2SV> if ( mount_data != mount_data_global ) //<S2SV> kfree ( mount_data ) ; //<S2SV> if ( tcon ) //<S2SV> cifs_put_tcon ( tcon ) ; //<S2SV> else if ( pSesInfo ) //<S2SV> cifs_put_smb_ses ( pSesInfo ) ; //<S2SV> else //<S2SV> cifs_put_tcp_session ( srvTcp ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> out : //<S2SV> cleanup_volume_info ( & volume_info ) ; //<S2SV> FreeXid ( xid ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 