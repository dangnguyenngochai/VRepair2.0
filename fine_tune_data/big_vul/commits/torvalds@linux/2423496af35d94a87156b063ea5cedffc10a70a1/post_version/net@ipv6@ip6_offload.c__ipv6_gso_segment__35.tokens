static struct sk_buff * ipv6_gso_segment ( struct sk_buff * skb , //<S2SV> netdev_features_t features ) //<S2SV> { //<S2SV> struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; //<S2SV> struct ipv6hdr * ipv6h ; //<S2SV> const struct net_offload * ops ; //<S2SV> int proto ; //<S2SV> struct frag_hdr * fptr ; //<S2SV> unsigned int unfrag_ip6hlen ; //<S2SV> unsigned int payload_len ; //<S2SV> u8 * prevhdr ; //<S2SV> int offset = 0 ; //<S2SV> bool encap , udpfrag ; //<S2SV> int nhoff ; //<S2SV> bool gso_partial ; //<S2SV> skb_reset_network_header ( skb ) ; //<S2SV> nhoff = skb_network_header ( skb ) - skb_mac_header ( skb ) ; //<S2SV> if ( unlikely ( ! pskb_may_pull ( skb , sizeof ( * ipv6h ) ) ) ) //<S2SV> goto out ; //<S2SV> encap = SKB_GSO_CB ( skb ) -> encap_level > 0 ; //<S2SV> if ( encap ) //<S2SV> features &= skb -> dev -> hw_enc_features ; //<S2SV> SKB_GSO_CB ( skb ) -> encap_level += sizeof ( * ipv6h ) ; //<S2SV> ipv6h = ipv6_hdr ( skb ) ; //<S2SV> __skb_pull ( skb , sizeof ( * ipv6h ) ) ; //<S2SV> segs = ERR_PTR ( - EPROTONOSUPPORT ) ; //<S2SV> proto = ipv6_gso_pull_exthdrs ( skb , ipv6h -> nexthdr ) ; //<S2SV> if ( skb -> encapsulation && //<S2SV> skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6 ) ) //<S2SV> udpfrag = proto == IPPROTO_UDP && encap ; //<S2SV> else //<S2SV> udpfrag = proto == IPPROTO_UDP && ! skb -> encapsulation ; //<S2SV> ops = rcu_dereference ( inet6_offloads [ proto ] ) ; //<S2SV> if ( likely ( ops && ops -> callbacks . gso_segment ) ) { //<S2SV> skb_reset_transport_header ( skb ) ; //<S2SV> segs = ops -> callbacks . gso_segment ( skb , features ) ; //<S2SV> } //<S2SV> if ( IS_ERR_OR_NULL ( segs ) ) //<S2SV> goto out ; //<S2SV> gso_partial = ! ! ( skb_shinfo ( segs ) -> gso_type & SKB_GSO_PARTIAL ) ; //<S2SV> for ( skb = segs ; skb ; skb = skb -> next ) { //<S2SV> ipv6h = ( struct ipv6hdr * ) ( skb_mac_header ( skb ) + nhoff ) ; //<S2SV> if ( gso_partial ) //<S2SV> payload_len = skb_shinfo ( skb ) -> gso_size + //<S2SV> SKB_GSO_CB ( skb ) -> data_offset + //<S2SV> skb -> head - ( unsigned char * ) ( ipv6h + 1 ) ; //<S2SV> else //<S2SV> payload_len = skb -> len - nhoff - sizeof ( * ipv6h ) ; //<S2SV> ipv6h -> payload_len = htons ( payload_len ) ; //<S2SV> skb -> network_header = ( u8 * ) ipv6h - skb -> head ; //<S2SV> if ( udpfrag ) { //<S2SV> unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; //<S2SV> if ( unfrag_ip6hlen < 0 ) //<S2SV> return ERR_PTR ( unfrag_ip6hlen ) ; //<S2SV> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; //<S2SV> fptr -> frag_off = htons ( offset ) ; //<S2SV> if ( skb -> next ) //<S2SV> fptr -> frag_off |= htons ( IP6_MF ) ; //<S2SV> offset += ( ntohs ( ipv6h -> payload_len ) - //<S2SV> sizeof ( struct frag_hdr ) ) ; //<S2SV> } //<S2SV> if ( encap ) //<S2SV> skb_reset_inner_headers ( skb ) ; //<S2SV> } //<S2SV> out : //<S2SV> return segs ; //<S2SV> } //<S2SV> 