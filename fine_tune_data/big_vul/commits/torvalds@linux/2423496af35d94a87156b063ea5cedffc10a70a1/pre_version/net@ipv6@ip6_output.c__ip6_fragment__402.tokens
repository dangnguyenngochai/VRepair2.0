int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , //<S2SV> int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) //<S2SV> { //<S2SV> struct sk_buff * frag ; //<S2SV> struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; //<S2SV> struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? //<S2SV> inet6_sk ( skb -> sk ) : NULL ; //<S2SV> struct ipv6hdr * tmp_hdr ; //<S2SV> struct frag_hdr * fh ; //<S2SV> unsigned int mtu , hlen , left , len ; //<S2SV> int hroom , troom ; //<S2SV> __be32 frag_id ; //<S2SV> int ptr , offset = 0 , err = 0 ; //<S2SV> u8 * prevhdr , nexthdr = 0 ; //<S2SV> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; //<S2SV> nexthdr = * prevhdr ; //<S2SV> mtu = ip6_skb_dst_mtu ( skb ) ; //<S2SV> if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) //<S2SV> goto fail_toobig ; //<S2SV> if ( IP6CB ( skb ) -> frag_max_size ) { //<S2SV> if ( IP6CB ( skb ) -> frag_max_size > mtu ) //<S2SV> goto fail_toobig ; //<S2SV> mtu = IP6CB ( skb ) -> frag_max_size ; //<S2SV> if ( mtu < IPV6_MIN_MTU ) //<S2SV> mtu = IPV6_MIN_MTU ; //<S2SV> } //<S2SV> if ( np && np -> frag_size < mtu ) { //<S2SV> if ( np -> frag_size ) //<S2SV> mtu = np -> frag_size ; //<S2SV> } //<S2SV> if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) //<S2SV> goto fail_toobig ; //<S2SV> mtu -= hlen + sizeof ( struct frag_hdr ) ; //<S2SV> frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , //<S2SV> & ipv6_hdr ( skb ) -> saddr ) ; //<S2SV> if ( skb -> ip_summed == CHECKSUM_PARTIAL && //<S2SV> ( err = skb_checksum_help ( skb ) ) ) //<S2SV> goto fail ; //<S2SV> hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; //<S2SV> if ( skb_has_frag_list ( skb ) ) { //<S2SV> unsigned int first_len = skb_pagelen ( skb ) ; //<S2SV> struct sk_buff * frag2 ; //<S2SV> if ( first_len - hlen > mtu || //<S2SV> ( ( first_len - hlen ) & 7 ) || //<S2SV> skb_cloned ( skb ) || //<S2SV> skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) //<S2SV> goto slow_path ; //<S2SV> skb_walk_frags ( skb , frag ) { //<S2SV> if ( frag -> len > mtu || //<S2SV> ( ( frag -> len & 7 ) && frag -> next ) || //<S2SV> skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) //<S2SV> goto slow_path_clean ; //<S2SV> if ( skb_shared ( frag ) ) //<S2SV> goto slow_path_clean ; //<S2SV> BUG_ON ( frag -> sk ) ; //<S2SV> if ( skb -> sk ) { //<S2SV> frag -> sk = skb -> sk ; //<S2SV> frag -> destructor = sock_wfree ; //<S2SV> } //<S2SV> skb -> truesize -= frag -> truesize ; //<S2SV> } //<S2SV> err = 0 ; //<S2SV> offset = 0 ; //<S2SV> * prevhdr = NEXTHDR_FRAGMENT ; //<S2SV> tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; //<S2SV> if ( ! tmp_hdr ) { //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , //<S2SV> IPSTATS_MIB_FRAGFAILS ) ; //<S2SV> err = - ENOMEM ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> frag = skb_shinfo ( skb ) -> frag_list ; //<S2SV> skb_frag_list_init ( skb ) ; //<S2SV> __skb_pull ( skb , hlen ) ; //<S2SV> fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; //<S2SV> __skb_push ( skb , hlen ) ; //<S2SV> skb_reset_network_header ( skb ) ; //<S2SV> memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; //<S2SV> fh -> nexthdr = nexthdr ; //<S2SV> fh -> reserved = 0 ; //<S2SV> fh -> frag_off = htons ( IP6_MF ) ; //<S2SV> fh -> identification = frag_id ; //<S2SV> first_len = skb_pagelen ( skb ) ; //<S2SV> skb -> data_len = first_len - skb_headlen ( skb ) ; //<S2SV> skb -> len = first_len ; //<S2SV> ipv6_hdr ( skb ) -> payload_len = htons ( first_len - //<S2SV> sizeof ( struct ipv6hdr ) ) ; //<S2SV> dst_hold ( & rt -> dst ) ; //<S2SV> for ( ; ; ) { //<S2SV> if ( frag ) { //<S2SV> frag -> ip_summed = CHECKSUM_NONE ; //<S2SV> skb_reset_transport_header ( frag ) ; //<S2SV> fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; //<S2SV> __skb_push ( frag , hlen ) ; //<S2SV> skb_reset_network_header ( frag ) ; //<S2SV> memcpy ( skb_network_header ( frag ) , tmp_hdr , //<S2SV> hlen ) ; //<S2SV> offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; //<S2SV> fh -> nexthdr = nexthdr ; //<S2SV> fh -> reserved = 0 ; //<S2SV> fh -> frag_off = htons ( offset ) ; //<S2SV> if ( frag -> next ) //<S2SV> fh -> frag_off |= htons ( IP6_MF ) ; //<S2SV> fh -> identification = frag_id ; //<S2SV> ipv6_hdr ( frag ) -> payload_len = //<S2SV> htons ( frag -> len - //<S2SV> sizeof ( struct ipv6hdr ) ) ; //<S2SV> ip6_copy_metadata ( frag , skb ) ; //<S2SV> } //<S2SV> err = output ( net , sk , skb ) ; //<S2SV> if ( ! err ) //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , //<S2SV> IPSTATS_MIB_FRAGCREATES ) ; //<S2SV> if ( err || ! frag ) //<S2SV> break ; //<S2SV> skb = frag ; //<S2SV> frag = skb -> next ; //<S2SV> skb -> next = NULL ; //<S2SV> } //<S2SV> kfree ( tmp_hdr ) ; //<S2SV> if ( err == 0 ) { //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , //<S2SV> IPSTATS_MIB_FRAGOKS ) ; //<S2SV> ip6_rt_put ( rt ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> kfree_skb_list ( frag ) ; //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , //<S2SV> IPSTATS_MIB_FRAGFAILS ) ; //<S2SV> ip6_rt_put ( rt ) ; //<S2SV> return err ; //<S2SV> slow_path_clean : //<S2SV> skb_walk_frags ( skb , frag2 ) { //<S2SV> if ( frag2 == frag ) //<S2SV> break ; //<S2SV> frag2 -> sk = NULL ; //<S2SV> frag2 -> destructor = NULL ; //<S2SV> skb -> truesize += frag2 -> truesize ; //<S2SV> } //<S2SV> } //<S2SV> slow_path : //<S2SV> left = skb -> len - hlen ; //<S2SV> ptr = hlen ; //<S2SV> troom = rt -> dst . dev -> needed_tailroom ; //<S2SV> while ( left > 0 ) { //<S2SV> u8 * fragnexthdr_offset ; //<S2SV> len = left ; //<S2SV> if ( len > mtu ) //<S2SV> len = mtu ; //<S2SV> if ( len < left ) { //<S2SV> len &= ~ 7 ; //<S2SV> } //<S2SV> frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + //<S2SV> hroom + troom , GFP_ATOMIC ) ; //<S2SV> if ( ! frag ) { //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , //<S2SV> IPSTATS_MIB_FRAGFAILS ) ; //<S2SV> err = - ENOMEM ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> ip6_copy_metadata ( frag , skb ) ; //<S2SV> skb_reserve ( frag , hroom ) ; //<S2SV> skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; //<S2SV> skb_reset_network_header ( frag ) ; //<S2SV> fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; //<S2SV> frag -> transport_header = ( frag -> network_header + hlen + //<S2SV> sizeof ( struct frag_hdr ) ) ; //<S2SV> if ( skb -> sk ) //<S2SV> skb_set_owner_w ( frag , skb -> sk ) ; //<S2SV> skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; //<S2SV> fragnexthdr_offset = skb_network_header ( frag ) ; //<S2SV> fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; //<S2SV> * fragnexthdr_offset = NEXTHDR_FRAGMENT ; //<S2SV> fh -> nexthdr = nexthdr ; //<S2SV> fh -> reserved = 0 ; //<S2SV> fh -> identification = frag_id ; //<S2SV> BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , //<S2SV> len ) ) ; //<S2SV> left -= len ; //<S2SV> fh -> frag_off = htons ( offset ) ; //<S2SV> if ( left > 0 ) //<S2SV> fh -> frag_off |= htons ( IP6_MF ) ; //<S2SV> ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - //<S2SV> sizeof ( struct ipv6hdr ) ) ; //<S2SV> ptr += len ; //<S2SV> offset += len ; //<S2SV> err = output ( net , sk , frag ) ; //<S2SV> if ( err ) //<S2SV> goto fail ; //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , //<S2SV> IPSTATS_MIB_FRAGCREATES ) ; //<S2SV> } //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , //<S2SV> IPSTATS_MIB_FRAGOKS ) ; //<S2SV> consume_skb ( skb ) ; //<S2SV> return err ; //<S2SV> fail_toobig : //<S2SV> if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) //<S2SV> sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; //<S2SV> skb -> dev = skb_dst ( skb ) -> dev ; //<S2SV> icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; //<S2SV> err = - EMSGSIZE ; //<S2SV> fail : //<S2SV> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , //<S2SV> IPSTATS_MIB_FRAGFAILS ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 