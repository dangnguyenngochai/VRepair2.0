int dccp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , //<S2SV> struct dccp_hdr * dh , unsigned int len ) //<S2SV> { //<S2SV> struct dccp_sock * dp = dccp_sk ( sk ) ; //<S2SV> struct dccp_skb_cb * dcb = DCCP_SKB_CB ( skb ) ; //<S2SV> const int old_state = sk -> sk_state ; //<S2SV> int queued = 0 ; //<S2SV> if ( sk -> sk_state == DCCP_LISTEN ) { //<S2SV> if ( dh -> dccph_type == DCCP_PKT_REQUEST ) { //<S2SV> if ( inet_csk ( sk ) -> icsk_af_ops -> conn_request ( sk , //<S2SV> skb ) < 0 ) //<S2SV> return 1 ; //<S2SV> consume_skb ( skb ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( dh -> dccph_type == DCCP_PKT_RESET ) //<S2SV> goto discard ; //<S2SV> dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; //<S2SV> return 1 ; //<S2SV> } else if ( sk -> sk_state == DCCP_CLOSED ) { //<S2SV> dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( sk -> sk_state != DCCP_REQUESTING && dccp_check_seqno ( sk , skb ) ) //<S2SV> goto discard ; //<S2SV> if ( ( dp -> dccps_role != DCCP_ROLE_CLIENT && //<S2SV> dh -> dccph_type == DCCP_PKT_RESPONSE ) || //<S2SV> ( dp -> dccps_role == DCCP_ROLE_CLIENT && //<S2SV> dh -> dccph_type == DCCP_PKT_REQUEST ) || //<S2SV> ( sk -> sk_state == DCCP_RESPOND && dh -> dccph_type == DCCP_PKT_DATA ) ) { //<S2SV> dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNC ) ; //<S2SV> goto discard ; //<S2SV> } //<S2SV> if ( dccp_parse_options ( sk , NULL , skb ) ) //<S2SV> return 1 ; //<S2SV> if ( dh -> dccph_type == DCCP_PKT_RESET ) { //<S2SV> dccp_rcv_reset ( sk , skb ) ; //<S2SV> return 0 ; //<S2SV> } else if ( dh -> dccph_type == DCCP_PKT_CLOSEREQ ) { //<S2SV> if ( dccp_rcv_closereq ( sk , skb ) ) //<S2SV> return 0 ; //<S2SV> goto discard ; //<S2SV> } else if ( dh -> dccph_type == DCCP_PKT_CLOSE ) { //<S2SV> if ( dccp_rcv_close ( sk , skb ) ) //<S2SV> return 0 ; //<S2SV> goto discard ; //<S2SV> } //<S2SV> switch ( sk -> sk_state ) { //<S2SV> case DCCP_REQUESTING : //<S2SV> queued = dccp_rcv_request_sent_state_process ( sk , skb , dh , len ) ; //<S2SV> if ( queued >= 0 ) //<S2SV> return queued ; //<S2SV> __kfree_skb ( skb ) ; //<S2SV> return 0 ; //<S2SV> case DCCP_PARTOPEN : //<S2SV> dccp_handle_ackvec_processing ( sk , skb ) ; //<S2SV> dccp_deliver_input_to_ccids ( sk , skb ) ; //<S2SV> case DCCP_RESPOND : //<S2SV> queued = dccp_rcv_respond_partopen_state_process ( sk , skb , //<S2SV> dh , len ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( dh -> dccph_type == DCCP_PKT_ACK || //<S2SV> dh -> dccph_type == DCCP_PKT_DATAACK ) { //<S2SV> switch ( old_state ) { //<S2SV> case DCCP_PARTOPEN : //<S2SV> sk -> sk_state_change ( sk ) ; //<S2SV> sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } else if ( unlikely ( dh -> dccph_type == DCCP_PKT_SYNC ) ) { //<S2SV> dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNCACK ) ; //<S2SV> goto discard ; //<S2SV> } //<S2SV> if ( ! queued ) { //<S2SV> discard : //<S2SV> __kfree_skb ( skb ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 