static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , //<S2SV> const char * dev_name , void * raw_data ) //<S2SV> { //<S2SV> struct super_block * s ; //<S2SV> struct ecryptfs_sb_info * sbi ; //<S2SV> struct ecryptfs_dentry_info * root_info ; //<S2SV> const char * err = "Getting<S2SV_blank>sb<S2SV_blank>failed" ; //<S2SV> struct inode * inode ; //<S2SV> struct path path ; //<S2SV> uid_t check_ruid ; //<S2SV> int rc ; //<S2SV> sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; //<S2SV> if ( ! sbi ) { //<S2SV> rc = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ; //<S2SV> if ( rc ) { //<S2SV> err = "Error<S2SV_blank>parsing<S2SV_blank>options" ; //<S2SV> goto out ; //<S2SV> } //<S2SV> s = sget ( fs_type , NULL , set_anon_super , flags , NULL ) ; //<S2SV> if ( IS_ERR ( s ) ) { //<S2SV> rc = PTR_ERR ( s ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rc = bdi_setup_and_register ( & sbi -> bdi , "ecryptfs" , BDI_CAP_MAP_COPY ) ; //<S2SV> if ( rc ) //<S2SV> goto out1 ; //<S2SV> ecryptfs_set_superblock_private ( s , sbi ) ; //<S2SV> s -> s_bdi = & sbi -> bdi ; //<S2SV> sbi = NULL ; //<S2SV> s -> s_op = & ecryptfs_sops ; //<S2SV> s -> s_d_op = & ecryptfs_dops ; //<S2SV> err = "Reading<S2SV_blank>sb<S2SV_blank>failed" ; //<S2SV> rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; //<S2SV> if ( rc ) { //<S2SV> ecryptfs_printk ( KERN_WARNING , "kern_path()<S2SV_blank>failed\\n" ) ; //<S2SV> goto out1 ; //<S2SV> } //<S2SV> if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { //<S2SV> rc = - EINVAL ; //<S2SV> printk ( KERN_ERR "Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>" //<S2SV> "eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>" //<S2SV> "known<S2SV_blank>incompatibilities\\n" ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> if ( check_ruid && ! uid_eq ( path . dentry -> d_inode -> i_uid , current_uid ( ) ) ) { //<S2SV> rc = - EPERM ; //<S2SV> printk ( KERN_ERR "Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>" //<S2SV> "requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n" , //<S2SV> i_uid_read ( path . dentry -> d_inode ) , //<S2SV> from_kuid ( & init_user_ns , current_uid ( ) ) ) ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; //<S2SV> s -> s_flags = flags & ~ MS_POSIXACL ; //<S2SV> s -> s_flags |= path . dentry -> d_sb -> s_flags & ( MS_RDONLY | MS_POSIXACL ) ; //<S2SV> s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; //<S2SV> s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; //<S2SV> s -> s_magic = ECRYPTFS_SUPER_MAGIC ; //<S2SV> inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; //<S2SV> rc = PTR_ERR ( inode ) ; //<S2SV> if ( IS_ERR ( inode ) ) //<S2SV> goto out_free ; //<S2SV> s -> s_root = d_make_root ( inode ) ; //<S2SV> if ( ! s -> s_root ) { //<S2SV> rc = - ENOMEM ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> rc = - ENOMEM ; //<S2SV> root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; //<S2SV> if ( ! root_info ) //<S2SV> goto out_free ; //<S2SV> ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; //<S2SV> root_info -> lower_path = path ; //<S2SV> s -> s_flags |= MS_ACTIVE ; //<S2SV> return dget ( s -> s_root ) ; //<S2SV> out_free : //<S2SV> path_put ( & path ) ; //<S2SV> out1 : //<S2SV> deactivate_locked_super ( s ) ; //<S2SV> out : //<S2SV> if ( sbi ) { //<S2SV> ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; //<S2SV> kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; //<S2SV> } //<S2SV> printk ( KERN_ERR "%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , err , rc ) ; //<S2SV> return ERR_PTR ( rc ) ; //<S2SV> } //<S2SV> 