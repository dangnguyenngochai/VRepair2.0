static int ovl_fill_super ( struct super_block * sb , void * data , int silent ) //<S2SV> { //<S2SV> struct path lowerpath ; //<S2SV> struct path upperpath ; //<S2SV> struct path workpath ; //<S2SV> struct inode * root_inode ; //<S2SV> struct dentry * root_dentry ; //<S2SV> struct ovl_entry * oe ; //<S2SV> struct ovl_fs * ufs ; //<S2SV> struct kstatfs statfs ; //<S2SV> int err ; //<S2SV> err = - ENOMEM ; //<S2SV> ufs = kzalloc ( sizeof ( struct ovl_fs ) , GFP_KERNEL ) ; //<S2SV> if ( ! ufs ) //<S2SV> goto out ; //<S2SV> err = ovl_parse_opt ( ( char * ) data , & ufs -> config ) ; //<S2SV> if ( err ) //<S2SV> goto out_free_config ; //<S2SV> err = - EINVAL ; //<S2SV> if ( ! ufs -> config . upperdir || ! ufs -> config . lowerdir || //<S2SV> ! ufs -> config . workdir ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>missing<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir\\n" ) ; //<S2SV> goto out_free_config ; //<S2SV> } //<S2SV> err = - ENOMEM ; //<S2SV> oe = ovl_alloc_entry ( ) ; //<S2SV> if ( oe == NULL ) //<S2SV> goto out_free_config ; //<S2SV> err = ovl_mount_dir ( ufs -> config . upperdir , & upperpath ) ; //<S2SV> if ( err ) //<S2SV> goto out_free_oe ; //<S2SV> err = ovl_mount_dir ( ufs -> config . lowerdir , & lowerpath ) ; //<S2SV> if ( err ) //<S2SV> goto out_put_upperpath ; //<S2SV> err = ovl_mount_dir ( ufs -> config . workdir , & workpath ) ; //<S2SV> if ( err ) //<S2SV> goto out_put_lowerpath ; //<S2SV> err = - EINVAL ; //<S2SV> if ( ! S_ISDIR ( upperpath . dentry -> d_inode -> i_mode ) || //<S2SV> ! S_ISDIR ( lowerpath . dentry -> d_inode -> i_mode ) || //<S2SV> ! S_ISDIR ( workpath . dentry -> d_inode -> i_mode ) ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>upperdir<S2SV_blank>or<S2SV_blank>lowerdir<S2SV_blank>or<S2SV_blank>workdir<S2SV_blank>not<S2SV_blank>a<S2SV_blank>directory\\n" ) ; //<S2SV> goto out_put_workpath ; //<S2SV> } //<S2SV> if ( upperpath . mnt != workpath . mnt ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>reside<S2SV_blank>under<S2SV_blank>the<S2SV_blank>same<S2SV_blank>mount\\n" ) ; //<S2SV> goto out_put_workpath ; //<S2SV> } //<S2SV> if ( ! ovl_workdir_ok ( workpath . dentry , upperpath . dentry ) ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>workdir<S2SV_blank>and<S2SV_blank>upperdir<S2SV_blank>must<S2SV_blank>be<S2SV_blank>separate<S2SV_blank>subtrees\\n" ) ; //<S2SV> goto out_put_workpath ; //<S2SV> } //<S2SV> if ( ! ovl_is_allowed_fs_type ( upperpath . dentry ) ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>upperdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> goto out_put_workpath ; //<S2SV> } //<S2SV> if ( ! ovl_is_allowed_fs_type ( lowerpath . dentry ) ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>lowerdir<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> goto out_put_workpath ; //<S2SV> } //<S2SV> err = vfs_statfs ( & lowerpath , & statfs ) ; //<S2SV> if ( err ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>statfs<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>lowerpath\\n" ) ; //<S2SV> goto out_put_workpath ; //<S2SV> } //<S2SV> ufs -> lower_namelen = statfs . f_namelen ; //<S2SV> ufs -> upper_mnt = clone_private_mount ( & upperpath ) ; //<S2SV> err = PTR_ERR ( ufs -> upper_mnt ) ; //<S2SV> if ( IS_ERR ( ufs -> upper_mnt ) ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>upperpath\\n" ) ; //<S2SV> goto out_put_workpath ; //<S2SV> } //<S2SV> ufs -> lower_mnt = clone_private_mount ( & lowerpath ) ; //<S2SV> err = PTR_ERR ( ufs -> lower_mnt ) ; //<S2SV> if ( IS_ERR ( ufs -> lower_mnt ) ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>clone<S2SV_blank>lowerpath\\n" ) ; //<S2SV> goto out_put_upper_mnt ; //<S2SV> } //<S2SV> ufs -> workdir = ovl_workdir_create ( ufs -> upper_mnt , workpath . dentry ) ; //<S2SV> err = PTR_ERR ( ufs -> workdir ) ; //<S2SV> if ( IS_ERR ( ufs -> workdir ) ) { //<S2SV> pr_err ( "overlayfs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>directory<S2SV_blank>%s/%s\\n" , //<S2SV> ufs -> config . workdir , OVL_WORKDIR_NAME ) ; //<S2SV> goto out_put_lower_mnt ; //<S2SV> } //<S2SV> ufs -> lower_mnt -> mnt_flags |= MNT_READONLY ; //<S2SV> if ( ufs -> upper_mnt -> mnt_sb -> s_flags & MS_RDONLY ) //<S2SV> sb -> s_flags |= MS_RDONLY ; //<S2SV> sb -> s_d_op = & ovl_dentry_operations ; //<S2SV> err = - ENOMEM ; //<S2SV> root_inode = ovl_new_inode ( sb , S_IFDIR , oe ) ; //<S2SV> if ( ! root_inode ) //<S2SV> goto out_put_workdir ; //<S2SV> root_dentry = d_make_root ( root_inode ) ; //<S2SV> if ( ! root_dentry ) //<S2SV> goto out_put_workdir ; //<S2SV> mntput ( upperpath . mnt ) ; //<S2SV> mntput ( lowerpath . mnt ) ; //<S2SV> path_put ( & workpath ) ; //<S2SV> oe -> __upperdentry = upperpath . dentry ; //<S2SV> oe -> lowerdentry = lowerpath . dentry ; //<S2SV> root_dentry -> d_fsdata = oe ; //<S2SV> sb -> s_magic = OVERLAYFS_SUPER_MAGIC ; //<S2SV> sb -> s_op = & ovl_super_operations ; //<S2SV> sb -> s_root = root_dentry ; //<S2SV> sb -> s_fs_info = ufs ; //<S2SV> return 0 ; //<S2SV> out_put_workdir : //<S2SV> dput ( ufs -> workdir ) ; //<S2SV> out_put_lower_mnt : //<S2SV> mntput ( ufs -> lower_mnt ) ; //<S2SV> out_put_upper_mnt : //<S2SV> mntput ( ufs -> upper_mnt ) ; //<S2SV> out_put_workpath : //<S2SV> path_put ( & workpath ) ; //<S2SV> out_put_lowerpath : //<S2SV> path_put ( & lowerpath ) ; //<S2SV> out_put_upperpath : //<S2SV> path_put ( & upperpath ) ; //<S2SV> out_free_oe : //<S2SV> kfree ( oe ) ; //<S2SV> out_free_config : //<S2SV> kfree ( ufs -> config . lowerdir ) ; //<S2SV> kfree ( ufs -> config . upperdir ) ; //<S2SV> kfree ( ufs -> config . workdir ) ; //<S2SV> kfree ( ufs ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 