static long ext4_zero_range ( struct file * file , loff_t offset , //<S2SV> loff_t len , int mode ) //<S2SV> { //<S2SV> struct inode * inode = file_inode ( file ) ; //<S2SV> handle_t * handle = NULL ; //<S2SV> unsigned int max_blocks ; //<S2SV> loff_t new_size = 0 ; //<S2SV> int ret = 0 ; //<S2SV> int flags ; //<S2SV> int credits ; //<S2SV> int partial_begin , partial_end ; //<S2SV> loff_t start , end ; //<S2SV> ext4_lblk_t lblk ; //<S2SV> unsigned int blkbits = inode -> i_blkbits ; //<S2SV> trace_ext4_zero_range ( inode , offset , len , mode ) ; //<S2SV> if ( ! S_ISREG ( inode -> i_mode ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ext4_should_journal_data ( inode ) ) { //<S2SV> ret = ext4_force_commit ( inode -> i_sb ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> } //<S2SV> start = round_up ( offset , 1 << blkbits ) ; //<S2SV> end = round_down ( ( offset + len ) , 1 << blkbits ) ; //<S2SV> if ( start < offset || end > offset + len ) //<S2SV> return - EINVAL ; //<S2SV> partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; //<S2SV> partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; //<S2SV> lblk = start >> blkbits ; //<S2SV> max_blocks = ( end >> blkbits ) ; //<S2SV> if ( max_blocks < lblk ) //<S2SV> max_blocks = 0 ; //<S2SV> else //<S2SV> max_blocks -= lblk ; //<S2SV> mutex_lock ( & inode -> i_mutex ) ; //<S2SV> if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && //<S2SV> offset + len > i_size_read ( inode ) ) { //<S2SV> new_size = offset + len ; //<S2SV> ret = inode_newsize_ok ( inode , new_size ) ; //<S2SV> if ( ret ) //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; //<S2SV> if ( mode & FALLOC_FL_KEEP_SIZE ) //<S2SV> flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; //<S2SV> if ( partial_begin || partial_end ) { //<S2SV> ret = ext4_alloc_file_blocks ( file , //<S2SV> round_down ( offset , 1 << blkbits ) >> blkbits , //<S2SV> ( round_up ( ( offset + len ) , 1 << blkbits ) - //<S2SV> round_down ( offset , 1 << blkbits ) ) >> blkbits , //<S2SV> new_size , flags , mode ) ; //<S2SV> if ( ret ) //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> if ( max_blocks > 0 ) { //<S2SV> flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | //<S2SV> EXT4_EX_NOCACHE ) ; //<S2SV> ext4_inode_block_unlocked_dio ( inode ) ; //<S2SV> inode_dio_wait ( inode ) ; //<S2SV> down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; //<S2SV> truncate_pagecache_range ( inode , start , end - 1 ) ; //<S2SV> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; //<S2SV> ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , //<S2SV> flags , mode ) ; //<S2SV> up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; //<S2SV> if ( ret ) //<S2SV> goto out_dio ; //<S2SV> } //<S2SV> if ( ! partial_begin && ! partial_end ) //<S2SV> goto out_dio ; //<S2SV> credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; //<S2SV> if ( ext4_should_journal_data ( inode ) ) //<S2SV> credits += 2 ; //<S2SV> handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> ret = PTR_ERR ( handle ) ; //<S2SV> ext4_std_error ( inode -> i_sb , ret ) ; //<S2SV> goto out_dio ; //<S2SV> } //<S2SV> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; //<S2SV> if ( new_size ) { //<S2SV> ext4_update_inode_size ( inode , new_size ) ; //<S2SV> } else { //<S2SV> if ( ( offset + len ) > i_size_read ( inode ) ) //<S2SV> ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; //<S2SV> } //<S2SV> ext4_mark_inode_dirty ( handle , inode ) ; //<S2SV> ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; //<S2SV> if ( file -> f_flags & O_SYNC ) //<S2SV> ext4_handle_sync ( handle ) ; //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> out_dio : //<S2SV> ext4_inode_resume_unlocked_dio ( inode ) ; //<S2SV> out_mutex : //<S2SV> mutex_unlock ( & inode -> i_mutex ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 