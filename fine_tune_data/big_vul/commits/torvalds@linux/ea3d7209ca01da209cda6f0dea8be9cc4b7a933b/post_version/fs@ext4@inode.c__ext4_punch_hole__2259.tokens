int ext4_punch_hole ( struct inode * inode , loff_t offset , loff_t length ) //<S2SV> { //<S2SV> struct super_block * sb = inode -> i_sb ; //<S2SV> ext4_lblk_t first_block , stop_block ; //<S2SV> struct address_space * mapping = inode -> i_mapping ; //<S2SV> loff_t first_block_offset , last_block_offset ; //<S2SV> handle_t * handle ; //<S2SV> unsigned int credits ; //<S2SV> int ret = 0 ; //<S2SV> if ( ! S_ISREG ( inode -> i_mode ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> trace_ext4_punch_hole ( inode , offset , length , 0 ) ; //<S2SV> if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { //<S2SV> ret = filemap_write_and_wait_range ( mapping , offset , //<S2SV> offset + length - 1 ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> } //<S2SV> mutex_lock ( & inode -> i_mutex ) ; //<S2SV> if ( offset >= inode -> i_size ) //<S2SV> goto out_mutex ; //<S2SV> if ( offset + length > inode -> i_size ) { //<S2SV> length = inode -> i_size + //<S2SV> PAGE_CACHE_SIZE - ( inode -> i_size & ( PAGE_CACHE_SIZE - 1 ) ) - //<S2SV> offset ; //<S2SV> } //<S2SV> if ( offset & ( sb -> s_blocksize - 1 ) || //<S2SV> ( offset + length ) & ( sb -> s_blocksize - 1 ) ) { //<S2SV> ret = ext4_inode_attach_jinode ( inode ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> ext4_inode_block_unlocked_dio ( inode ) ; //<S2SV> inode_dio_wait ( inode ) ; //<S2SV> down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; //<S2SV> first_block_offset = round_up ( offset , sb -> s_blocksize ) ; //<S2SV> last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ; //<S2SV> if ( last_block_offset > first_block_offset ) //<S2SV> truncate_pagecache_range ( inode , first_block_offset , //<S2SV> last_block_offset ) ; //<S2SV> if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) //<S2SV> credits = ext4_writepage_trans_blocks ( inode ) ; //<S2SV> else //<S2SV> credits = ext4_blocks_for_truncate ( inode ) ; //<S2SV> handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> ret = PTR_ERR ( handle ) ; //<S2SV> ext4_std_error ( sb , ret ) ; //<S2SV> goto out_dio ; //<S2SV> } //<S2SV> ret = ext4_zero_partial_blocks ( handle , inode , offset , //<S2SV> length ) ; //<S2SV> if ( ret ) //<S2SV> goto out_stop ; //<S2SV> first_block = ( offset + sb -> s_blocksize - 1 ) >> //<S2SV> EXT4_BLOCK_SIZE_BITS ( sb ) ; //<S2SV> stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; //<S2SV> if ( first_block >= stop_block ) //<S2SV> goto out_stop ; //<S2SV> down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> ext4_discard_preallocations ( inode ) ; //<S2SV> ret = ext4_es_remove_extent ( inode , first_block , //<S2SV> stop_block - first_block ) ; //<S2SV> if ( ret ) { //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> goto out_stop ; //<S2SV> } //<S2SV> if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) //<S2SV> ret = ext4_ext_remove_space ( inode , first_block , //<S2SV> stop_block - 1 ) ; //<S2SV> else //<S2SV> ret = ext4_ind_remove_space ( handle , inode , first_block , //<S2SV> stop_block ) ; //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> if ( IS_SYNC ( inode ) ) //<S2SV> ext4_handle_sync ( handle ) ; //<S2SV> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; //<S2SV> ext4_mark_inode_dirty ( handle , inode ) ; //<S2SV> out_stop : //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> out_dio : //<S2SV> up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; //<S2SV> ext4_inode_resume_unlocked_dio ( inode ) ; //<S2SV> out_mutex : //<S2SV> mutex_unlock ( & inode -> i_mutex ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 