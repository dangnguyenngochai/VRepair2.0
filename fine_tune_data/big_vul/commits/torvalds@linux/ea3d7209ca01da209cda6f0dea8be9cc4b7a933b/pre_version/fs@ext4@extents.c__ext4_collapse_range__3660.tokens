int ext4_collapse_range ( struct inode * inode , loff_t offset , loff_t len ) //<S2SV> { //<S2SV> struct super_block * sb = inode -> i_sb ; //<S2SV> ext4_lblk_t punch_start , punch_stop ; //<S2SV> handle_t * handle ; //<S2SV> unsigned int credits ; //<S2SV> loff_t new_size , ioffset ; //<S2SV> int ret ; //<S2SV> if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || //<S2SV> len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! S_ISREG ( inode -> i_mode ) ) //<S2SV> return - EINVAL ; //<S2SV> trace_ext4_collapse_range ( inode , offset , len ) ; //<S2SV> punch_start = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; //<S2SV> punch_stop = ( offset + len ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; //<S2SV> if ( ext4_should_journal_data ( inode ) ) { //<S2SV> ret = ext4_force_commit ( inode -> i_sb ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> } //<S2SV> ioffset = round_down ( offset , PAGE_SIZE ) ; //<S2SV> ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , //<S2SV> LLONG_MAX ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> mutex_lock ( & inode -> i_mutex ) ; //<S2SV> if ( offset + len >= i_size_read ( inode ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> truncate_pagecache ( inode , ioffset ) ; //<S2SV> ext4_inode_block_unlocked_dio ( inode ) ; //<S2SV> inode_dio_wait ( inode ) ; //<S2SV> credits = ext4_writepage_trans_blocks ( inode ) ; //<S2SV> handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> ret = PTR_ERR ( handle ) ; //<S2SV> goto out_dio ; //<S2SV> } //<S2SV> down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> ext4_discard_preallocations ( inode ) ; //<S2SV> ret = ext4_es_remove_extent ( inode , punch_start , //<S2SV> EXT_MAX_BLOCKS - punch_start ) ; //<S2SV> if ( ret ) { //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> goto out_stop ; //<S2SV> } //<S2SV> ret = ext4_ext_remove_space ( inode , punch_start , punch_stop - 1 ) ; //<S2SV> if ( ret ) { //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> goto out_stop ; //<S2SV> } //<S2SV> ext4_discard_preallocations ( inode ) ; //<S2SV> ret = ext4_ext_shift_extents ( inode , handle , punch_stop , //<S2SV> punch_stop - punch_start , SHIFT_LEFT ) ; //<S2SV> if ( ret ) { //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> goto out_stop ; //<S2SV> } //<S2SV> new_size = i_size_read ( inode ) - len ; //<S2SV> i_size_write ( inode , new_size ) ; //<S2SV> EXT4_I ( inode ) -> i_disksize = new_size ; //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> if ( IS_SYNC ( inode ) ) //<S2SV> ext4_handle_sync ( handle ) ; //<S2SV> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; //<S2SV> ext4_mark_inode_dirty ( handle , inode ) ; //<S2SV> out_stop : //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> out_dio : //<S2SV> ext4_inode_resume_unlocked_dio ( inode ) ; //<S2SV> out_mutex : //<S2SV> mutex_unlock ( & inode -> i_mutex ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 