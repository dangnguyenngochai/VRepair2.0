int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) //<S2SV> { //<S2SV> struct page * page = vmf -> page ; //<S2SV> loff_t size ; //<S2SV> unsigned long len ; //<S2SV> int ret ; //<S2SV> struct file * file = vma -> vm_file ; //<S2SV> struct inode * inode = file_inode ( file ) ; //<S2SV> struct address_space * mapping = inode -> i_mapping ; //<S2SV> handle_t * handle ; //<S2SV> get_block_t * get_block ; //<S2SV> int retries = 0 ; //<S2SV> sb_start_pagefault ( inode -> i_sb ) ; //<S2SV> file_update_time ( vma -> vm_file ) ; //<S2SV> if ( test_opt ( inode -> i_sb , DELALLOC ) && //<S2SV> ! ext4_should_journal_data ( inode ) && //<S2SV> ! ext4_nonda_switch ( inode -> i_sb ) ) { //<S2SV> do { //<S2SV> ret = block_page_mkwrite ( vma , vmf , //<S2SV> ext4_da_get_block_prep ) ; //<S2SV> } while ( ret == - ENOSPC && //<S2SV> ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; //<S2SV> goto out_ret ; //<S2SV> } //<S2SV> lock_page ( page ) ; //<S2SV> size = i_size_read ( inode ) ; //<S2SV> if ( page -> mapping != mapping || page_offset ( page ) > size ) { //<S2SV> unlock_page ( page ) ; //<S2SV> ret = VM_FAULT_NOPAGE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( page -> index == size >> PAGE_CACHE_SHIFT ) //<S2SV> len = size & ~ PAGE_CACHE_MASK ; //<S2SV> else //<S2SV> len = PAGE_CACHE_SIZE ; //<S2SV> if ( page_has_buffers ( page ) ) { //<S2SV> if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , //<S2SV> 0 , len , NULL , //<S2SV> ext4_bh_unmapped ) ) { //<S2SV> wait_for_stable_page ( page ) ; //<S2SV> ret = VM_FAULT_LOCKED ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> unlock_page ( page ) ; //<S2SV> if ( ext4_should_dioread_nolock ( inode ) ) //<S2SV> get_block = ext4_get_block_write ; //<S2SV> else //<S2SV> get_block = ext4_get_block ; //<S2SV> retry_alloc : //<S2SV> handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , //<S2SV> ext4_writepage_trans_blocks ( inode ) ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> ret = VM_FAULT_SIGBUS ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = block_page_mkwrite ( vma , vmf , get_block ) ; //<S2SV> if ( ! ret && ext4_should_journal_data ( inode ) ) { //<S2SV> if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , //<S2SV> PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { //<S2SV> unlock_page ( page ) ; //<S2SV> ret = VM_FAULT_SIGBUS ; //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; //<S2SV> } //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) //<S2SV> goto retry_alloc ; //<S2SV> out_ret : //<S2SV> ret = block_page_mkwrite_return ( ret ) ; //<S2SV> out : //<S2SV> sb_end_pagefault ( inode -> i_sb ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 