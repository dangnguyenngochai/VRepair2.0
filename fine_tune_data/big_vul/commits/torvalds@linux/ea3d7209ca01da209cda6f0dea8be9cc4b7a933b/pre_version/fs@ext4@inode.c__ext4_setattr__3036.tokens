int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) //<S2SV> { //<S2SV> struct inode * inode = d_inode ( dentry ) ; //<S2SV> int error , rc = 0 ; //<S2SV> int orphan = 0 ; //<S2SV> const unsigned int ia_valid = attr -> ia_valid ; //<S2SV> error = inode_change_ok ( inode , attr ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> if ( is_quota_modification ( inode , attr ) ) { //<S2SV> error = dquot_initialize ( inode ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> } //<S2SV> if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || //<S2SV> ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { //<S2SV> handle_t * handle ; //<S2SV> handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , //<S2SV> ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + //<S2SV> EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> error = PTR_ERR ( handle ) ; //<S2SV> goto err_out ; //<S2SV> } //<S2SV> error = dquot_transfer ( inode , attr ) ; //<S2SV> if ( error ) { //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> if ( attr -> ia_valid & ATTR_UID ) //<S2SV> inode -> i_uid = attr -> ia_uid ; //<S2SV> if ( attr -> ia_valid & ATTR_GID ) //<S2SV> inode -> i_gid = attr -> ia_gid ; //<S2SV> error = ext4_mark_inode_dirty ( handle , inode ) ; //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> } //<S2SV> if ( attr -> ia_valid & ATTR_SIZE ) { //<S2SV> handle_t * handle ; //<S2SV> loff_t oldsize = inode -> i_size ; //<S2SV> int shrink = ( attr -> ia_size <= inode -> i_size ) ; //<S2SV> if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { //<S2SV> struct ext4_sb_info * sbi = EXT4_SB ( inode -> i_sb ) ; //<S2SV> if ( attr -> ia_size > sbi -> s_bitmap_maxbytes ) //<S2SV> return - EFBIG ; //<S2SV> } //<S2SV> if ( ! S_ISREG ( inode -> i_mode ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( IS_I_VERSION ( inode ) && attr -> ia_size != inode -> i_size ) //<S2SV> inode_inc_iversion ( inode ) ; //<S2SV> if ( ext4_should_order_data ( inode ) && //<S2SV> ( attr -> ia_size < inode -> i_size ) ) { //<S2SV> error = ext4_begin_ordered_truncate ( inode , //<S2SV> attr -> ia_size ) ; //<S2SV> if ( error ) //<S2SV> goto err_out ; //<S2SV> } //<S2SV> if ( attr -> ia_size != inode -> i_size ) { //<S2SV> handle = ext4_journal_start ( inode , EXT4_HT_INODE , 3 ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> error = PTR_ERR ( handle ) ; //<S2SV> goto err_out ; //<S2SV> } //<S2SV> if ( ext4_handle_valid ( handle ) && shrink ) { //<S2SV> error = ext4_orphan_add ( handle , inode ) ; //<S2SV> orphan = 1 ; //<S2SV> } //<S2SV> if ( ! shrink ) { //<S2SV> inode -> i_mtime = ext4_current_time ( inode ) ; //<S2SV> inode -> i_ctime = inode -> i_mtime ; //<S2SV> } //<S2SV> down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> EXT4_I ( inode ) -> i_disksize = attr -> ia_size ; //<S2SV> rc = ext4_mark_inode_dirty ( handle , inode ) ; //<S2SV> if ( ! error ) //<S2SV> error = rc ; //<S2SV> if ( ! error ) //<S2SV> i_size_write ( inode , attr -> ia_size ) ; //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> if ( error ) { //<S2SV> if ( orphan ) //<S2SV> ext4_orphan_del ( NULL , inode ) ; //<S2SV> goto err_out ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! shrink ) //<S2SV> pagecache_isize_extended ( inode , oldsize , inode -> i_size ) ; //<S2SV> if ( orphan ) { //<S2SV> if ( ! ext4_should_journal_data ( inode ) ) { //<S2SV> ext4_inode_block_unlocked_dio ( inode ) ; //<S2SV> inode_dio_wait ( inode ) ; //<S2SV> ext4_inode_resume_unlocked_dio ( inode ) ; //<S2SV> } else //<S2SV> ext4_wait_for_tail_page_commit ( inode ) ; //<S2SV> } //<S2SV> truncate_pagecache ( inode , inode -> i_size ) ; //<S2SV> if ( shrink ) //<S2SV> ext4_truncate ( inode ) ; //<S2SV> } //<S2SV> if ( ! rc ) { //<S2SV> setattr_copy ( inode , attr ) ; //<S2SV> mark_inode_dirty ( inode ) ; //<S2SV> } //<S2SV> if ( orphan && inode -> i_nlink ) //<S2SV> ext4_orphan_del ( NULL , inode ) ; //<S2SV> if ( ! rc && ( ia_valid & ATTR_MODE ) ) //<S2SV> rc = posix_acl_chmod ( inode , inode -> i_mode ) ; //<S2SV> err_out : //<S2SV> ext4_std_error ( inode -> i_sb , error ) ; //<S2SV> if ( ! error ) //<S2SV> error = rc ; //<S2SV> return error ; //<S2SV> } //<S2SV> 