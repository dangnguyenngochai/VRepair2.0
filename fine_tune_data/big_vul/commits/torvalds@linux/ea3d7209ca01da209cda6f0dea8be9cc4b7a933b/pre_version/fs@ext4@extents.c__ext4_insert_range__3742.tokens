int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) //<S2SV> { //<S2SV> struct super_block * sb = inode -> i_sb ; //<S2SV> handle_t * handle ; //<S2SV> struct ext4_ext_path * path ; //<S2SV> struct ext4_extent * extent ; //<S2SV> ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; //<S2SV> unsigned int credits , ee_len ; //<S2SV> int ret = 0 , depth , split_flag = 0 ; //<S2SV> loff_t ioffset ; //<S2SV> if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || //<S2SV> len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! S_ISREG ( inode -> i_mode ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> trace_ext4_insert_range ( inode , offset , len ) ; //<S2SV> offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; //<S2SV> len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; //<S2SV> if ( ext4_should_journal_data ( inode ) ) { //<S2SV> ret = ext4_force_commit ( inode -> i_sb ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> } //<S2SV> ioffset = round_down ( offset , PAGE_SIZE ) ; //<S2SV> ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , //<S2SV> LLONG_MAX ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> mutex_lock ( & inode -> i_mutex ) ; //<S2SV> if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { //<S2SV> ret = - EFBIG ; //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> if ( offset >= i_size_read ( inode ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out_mutex ; //<S2SV> } //<S2SV> truncate_pagecache ( inode , ioffset ) ; //<S2SV> ext4_inode_block_unlocked_dio ( inode ) ; //<S2SV> inode_dio_wait ( inode ) ; //<S2SV> credits = ext4_writepage_trans_blocks ( inode ) ; //<S2SV> handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; //<S2SV> if ( IS_ERR ( handle ) ) { //<S2SV> ret = PTR_ERR ( handle ) ; //<S2SV> goto out_dio ; //<S2SV> } //<S2SV> inode -> i_size += len ; //<S2SV> EXT4_I ( inode ) -> i_disksize += len ; //<S2SV> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; //<S2SV> ret = ext4_mark_inode_dirty ( handle , inode ) ; //<S2SV> if ( ret ) //<S2SV> goto out_stop ; //<S2SV> down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> ext4_discard_preallocations ( inode ) ; //<S2SV> path = ext4_find_extent ( inode , offset_lblk , NULL , 0 ) ; //<S2SV> if ( IS_ERR ( path ) ) { //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> goto out_stop ; //<S2SV> } //<S2SV> depth = ext_depth ( inode ) ; //<S2SV> extent = path [ depth ] . p_ext ; //<S2SV> if ( extent ) { //<S2SV> ee_start_lblk = le32_to_cpu ( extent -> ee_block ) ; //<S2SV> ee_len = ext4_ext_get_actual_len ( extent ) ; //<S2SV> if ( ( offset_lblk > ee_start_lblk ) && //<S2SV> ( offset_lblk < ( ee_start_lblk + ee_len ) ) ) { //<S2SV> if ( ext4_ext_is_unwritten ( extent ) ) //<S2SV> split_flag = EXT4_EXT_MARK_UNWRIT1 | //<S2SV> EXT4_EXT_MARK_UNWRIT2 ; //<S2SV> ret = ext4_split_extent_at ( handle , inode , & path , //<S2SV> offset_lblk , split_flag , //<S2SV> EXT4_EX_NOCACHE | //<S2SV> EXT4_GET_BLOCKS_PRE_IO | //<S2SV> EXT4_GET_BLOCKS_METADATA_NOFAIL ) ; //<S2SV> } //<S2SV> ext4_ext_drop_refs ( path ) ; //<S2SV> kfree ( path ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> goto out_stop ; //<S2SV> } //<S2SV> } //<S2SV> ret = ext4_es_remove_extent ( inode , offset_lblk , //<S2SV> EXT_MAX_BLOCKS - offset_lblk ) ; //<S2SV> if ( ret ) { //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> goto out_stop ; //<S2SV> } //<S2SV> ret = ext4_ext_shift_extents ( inode , handle , //<S2SV> ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk , //<S2SV> len_lblk , SHIFT_RIGHT ) ; //<S2SV> up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; //<S2SV> if ( IS_SYNC ( inode ) ) //<S2SV> ext4_handle_sync ( handle ) ; //<S2SV> out_stop : //<S2SV> ext4_journal_stop ( handle ) ; //<S2SV> out_dio : //<S2SV> ext4_inode_resume_unlocked_dio ( inode ) ; //<S2SV> out_mutex : //<S2SV> mutex_unlock ( & inode -> i_mutex ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 