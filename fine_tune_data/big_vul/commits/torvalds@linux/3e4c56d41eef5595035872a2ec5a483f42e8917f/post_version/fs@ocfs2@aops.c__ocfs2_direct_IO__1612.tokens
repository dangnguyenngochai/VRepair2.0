static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) //<S2SV> { //<S2SV> struct file * file = iocb -> ki_filp ; //<S2SV> struct inode * inode = file -> f_mapping -> host ; //<S2SV> struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; //<S2SV> get_block_t * get_block ; //<S2SV> if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) //<S2SV> return 0 ; //<S2SV> if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && //<S2SV> ! ocfs2_supports_append_dio ( osb ) ) //<S2SV> return 0 ; //<S2SV> if ( iov_iter_rw ( iter ) == READ ) //<S2SV> get_block = ocfs2_lock_get_block ; //<S2SV> else //<S2SV> get_block = ocfs2_dio_wr_get_block ; //<S2SV> return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , //<S2SV> iter , get_block , //<S2SV> ocfs2_dio_end_io , NULL , 0 ) ; //<S2SV> } //<S2SV> 