int asn1_ber_decoder ( const struct asn1_decoder * decoder , //<S2SV> void * context , //<S2SV> const unsigned char * data , //<S2SV> size_t datalen ) //<S2SV> { //<S2SV> const unsigned char * machine = decoder -> machine ; //<S2SV> const asn1_action_t * actions = decoder -> actions ; //<S2SV> size_t machlen = decoder -> machlen ; //<S2SV> enum asn1_opcode op ; //<S2SV> unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; //<S2SV> const char * errmsg ; //<S2SV> size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; //<S2SV> int ret ; //<S2SV> unsigned char flags = 0 ; //<S2SV> # define FLAG_INDEFINITE_LENGTH 0x01 //<S2SV> # define FLAG_MATCHED 0x02 //<S2SV> # define FLAG_LAST_MATCHED 0x04 //<S2SV> # define FLAG_CONS 0x20 //<S2SV> # define NR_CONS_STACK 10 //<S2SV> unsigned short cons_dp_stack [ NR_CONS_STACK ] ; //<S2SV> unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; //<S2SV> unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; //<S2SV> # define NR_JUMP_STACK 10 //<S2SV> unsigned char jump_stack [ NR_JUMP_STACK ] ; //<S2SV> if ( datalen > 65535 ) //<S2SV> return - EMSGSIZE ; //<S2SV> next_op : //<S2SV> pr_debug ( "next_op:<S2SV_blank>pc=\\e[32m%zu\\e[m/%zu<S2SV_blank>dp=\\e[33m%zu\\e[m/%zu<S2SV_blank>C=%d<S2SV_blank>J=%d\\n" , //<S2SV> pc , machlen , dp , datalen , csp , jsp ) ; //<S2SV> if ( unlikely ( pc >= machlen ) ) //<S2SV> goto machine_overrun_error ; //<S2SV> op = machine [ pc ] ; //<S2SV> if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) //<S2SV> goto machine_overrun_error ; //<S2SV> if ( op <= ASN1_OP__MATCHES_TAG ) { //<S2SV> unsigned char tmp ; //<S2SV> if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || //<S2SV> ( op & ASN1_OP_MATCH__SKIP && dp == datalen ) ) { //<S2SV> flags &= ~ FLAG_LAST_MATCHED ; //<S2SV> pc += asn1_op_lengths [ op ] ; //<S2SV> goto next_op ; //<S2SV> } //<S2SV> flags = 0 ; //<S2SV> hdr = 2 ; //<S2SV> if ( unlikely ( dp >= datalen - 1 ) ) //<S2SV> goto data_overrun_error ; //<S2SV> tag = data [ dp ++ ] ; //<S2SV> if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) //<S2SV> goto long_tag_not_supported ; //<S2SV> if ( op & ASN1_OP_MATCH__ANY ) { //<S2SV> pr_debug ( "-<S2SV_blank>any<S2SV_blank>%02x\\n" , tag ) ; //<S2SV> } else { //<S2SV> optag = machine [ pc + 1 ] ; //<S2SV> flags |= optag & FLAG_CONS ; //<S2SV> tmp = optag ^ tag ; //<S2SV> tmp &= ~ ( optag & ASN1_CONS_BIT ) ; //<S2SV> pr_debug ( "-<S2SV_blank>match?<S2SV_blank>%02x<S2SV_blank>%02x<S2SV_blank>%02x\\n" , tag , optag , tmp ) ; //<S2SV> if ( tmp != 0 ) { //<S2SV> if ( op & ASN1_OP_MATCH__SKIP ) { //<S2SV> pc += asn1_op_lengths [ op ] ; //<S2SV> dp -- ; //<S2SV> goto next_op ; //<S2SV> } //<S2SV> goto tag_mismatch ; //<S2SV> } //<S2SV> } //<S2SV> flags |= FLAG_MATCHED ; //<S2SV> len = data [ dp ++ ] ; //<S2SV> if ( len > 0x7f ) { //<S2SV> if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { //<S2SV> if ( unlikely ( ! ( tag & ASN1_CONS_BIT ) ) ) //<S2SV> goto indefinite_len_primitive ; //<S2SV> flags |= FLAG_INDEFINITE_LENGTH ; //<S2SV> if ( unlikely ( 2 > datalen - dp ) ) //<S2SV> goto data_overrun_error ; //<S2SV> } else { //<S2SV> int n = len - 0x80 ; //<S2SV> if ( unlikely ( n > 2 ) ) //<S2SV> goto length_too_long ; //<S2SV> if ( unlikely ( dp >= datalen - n ) ) //<S2SV> goto data_overrun_error ; //<S2SV> hdr += n ; //<S2SV> for ( len = 0 ; n > 0 ; n -- ) { //<S2SV> len <<= 8 ; //<S2SV> len |= data [ dp ++ ] ; //<S2SV> } //<S2SV> if ( unlikely ( len > datalen - dp ) ) //<S2SV> goto data_overrun_error ; //<S2SV> } //<S2SV> } //<S2SV> if ( flags & FLAG_CONS ) { //<S2SV> if ( unlikely ( csp >= NR_CONS_STACK ) ) //<S2SV> goto cons_stack_overflow ; //<S2SV> cons_dp_stack [ csp ] = dp ; //<S2SV> cons_hdrlen_stack [ csp ] = hdr ; //<S2SV> if ( ! ( flags & FLAG_INDEFINITE_LENGTH ) ) { //<S2SV> cons_datalen_stack [ csp ] = datalen ; //<S2SV> datalen = dp + len ; //<S2SV> } else { //<S2SV> cons_datalen_stack [ csp ] = 0 ; //<S2SV> } //<S2SV> csp ++ ; //<S2SV> } //<S2SV> pr_debug ( "-<S2SV_blank>TAG:<S2SV_blank>%02x<S2SV_blank>%zu%s\\n" , //<S2SV> tag , len , flags & FLAG_CONS ? "<S2SV_blank>CONS" : "" ) ; //<S2SV> tdp = dp ; //<S2SV> } //<S2SV> switch ( op ) { //<S2SV> case ASN1_OP_MATCH_ANY_ACT : //<S2SV> case ASN1_OP_COND_MATCH_ANY_ACT : //<S2SV> ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + dp , len ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> goto skip_data ; //<S2SV> case ASN1_OP_MATCH_ACT : //<S2SV> case ASN1_OP_MATCH_ACT_OR_SKIP : //<S2SV> case ASN1_OP_COND_MATCH_ACT_OR_SKIP : //<S2SV> ret = actions [ machine [ pc + 2 ] ] ( context , hdr , tag , data + dp , len ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> goto skip_data ; //<S2SV> case ASN1_OP_MATCH : //<S2SV> case ASN1_OP_MATCH_OR_SKIP : //<S2SV> case ASN1_OP_MATCH_ANY : //<S2SV> case ASN1_OP_COND_MATCH_OR_SKIP : //<S2SV> case ASN1_OP_COND_MATCH_ANY : //<S2SV> skip_data : //<S2SV> if ( ! ( flags & FLAG_CONS ) ) { //<S2SV> if ( flags & FLAG_INDEFINITE_LENGTH ) { //<S2SV> ret = asn1_find_indefinite_length ( //<S2SV> data , datalen , & dp , & len , & errmsg ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto error ; //<S2SV> } else { //<S2SV> dp += len ; //<S2SV> } //<S2SV> pr_debug ( "-<S2SV_blank>LEAF:<S2SV_blank>%zu\\n" , len ) ; //<S2SV> } //<S2SV> pc += asn1_op_lengths [ op ] ; //<S2SV> goto next_op ; //<S2SV> case ASN1_OP_MATCH_JUMP : //<S2SV> case ASN1_OP_MATCH_JUMP_OR_SKIP : //<S2SV> case ASN1_OP_COND_MATCH_JUMP_OR_SKIP : //<S2SV> pr_debug ( "-<S2SV_blank>MATCH_JUMP\\n" ) ; //<S2SV> if ( unlikely ( jsp == NR_JUMP_STACK ) ) //<S2SV> goto jump_stack_overflow ; //<S2SV> jump_stack [ jsp ++ ] = pc + asn1_op_lengths [ op ] ; //<S2SV> pc = machine [ pc + 2 ] ; //<S2SV> goto next_op ; //<S2SV> case ASN1_OP_COND_FAIL : //<S2SV> if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) //<S2SV> goto tag_mismatch ; //<S2SV> pc += asn1_op_lengths [ op ] ; //<S2SV> goto next_op ; //<S2SV> case ASN1_OP_COMPLETE : //<S2SV> if ( unlikely ( jsp != 0 || csp != 0 ) ) { //<S2SV> pr_err ( "ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Stacks<S2SV_blank>not<S2SV_blank>empty<S2SV_blank>at<S2SV_blank>completion<S2SV_blank>(%u,<S2SV_blank>%u)\\n" , //<S2SV> jsp , csp ) ; //<S2SV> return - EBADMSG ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case ASN1_OP_END_SET : //<S2SV> case ASN1_OP_END_SET_ACT : //<S2SV> if ( unlikely ( ! ( flags & FLAG_MATCHED ) ) ) //<S2SV> goto tag_mismatch ; //<S2SV> case ASN1_OP_END_SEQ : //<S2SV> case ASN1_OP_END_SET_OF : //<S2SV> case ASN1_OP_END_SEQ_OF : //<S2SV> case ASN1_OP_END_SEQ_ACT : //<S2SV> case ASN1_OP_END_SET_OF_ACT : //<S2SV> case ASN1_OP_END_SEQ_OF_ACT : //<S2SV> if ( unlikely ( csp <= 0 ) ) //<S2SV> goto cons_stack_underflow ; //<S2SV> csp -- ; //<S2SV> tdp = cons_dp_stack [ csp ] ; //<S2SV> hdr = cons_hdrlen_stack [ csp ] ; //<S2SV> len = datalen ; //<S2SV> datalen = cons_datalen_stack [ csp ] ; //<S2SV> pr_debug ( "-<S2SV_blank>end<S2SV_blank>cons<S2SV_blank>t=%zu<S2SV_blank>dp=%zu<S2SV_blank>l=%zu/%zu\\n" , //<S2SV> tdp , dp , len , datalen ) ; //<S2SV> if ( datalen == 0 ) { //<S2SV> datalen = len ; //<S2SV> if ( unlikely ( datalen - dp < 2 ) ) //<S2SV> goto data_overrun_error ; //<S2SV> if ( data [ dp ++ ] != 0 ) { //<S2SV> if ( op & ASN1_OP_END__OF ) { //<S2SV> dp -- ; //<S2SV> csp ++ ; //<S2SV> pc = machine [ pc + 1 ] ; //<S2SV> pr_debug ( "-<S2SV_blank>continue\\n" ) ; //<S2SV> goto next_op ; //<S2SV> } //<S2SV> goto missing_eoc ; //<S2SV> } //<S2SV> if ( data [ dp ++ ] != 0 ) //<S2SV> goto invalid_eoc ; //<S2SV> len = dp - tdp - 2 ; //<S2SV> } else { //<S2SV> if ( dp < len && ( op & ASN1_OP_END__OF ) ) { //<S2SV> datalen = len ; //<S2SV> csp ++ ; //<S2SV> pc = machine [ pc + 1 ] ; //<S2SV> pr_debug ( "-<S2SV_blank>continue\\n" ) ; //<S2SV> goto next_op ; //<S2SV> } //<S2SV> if ( dp != len ) //<S2SV> goto cons_length_error ; //<S2SV> len -= tdp ; //<S2SV> pr_debug ( "-<S2SV_blank>cons<S2SV_blank>len<S2SV_blank>l=%zu<S2SV_blank>d=%zu\\n" , len , dp - tdp ) ; //<S2SV> } //<S2SV> if ( op & ASN1_OP_END__ACT ) { //<S2SV> unsigned char act ; //<S2SV> if ( op & ASN1_OP_END__OF ) //<S2SV> act = machine [ pc + 2 ] ; //<S2SV> else //<S2SV> act = machine [ pc + 1 ] ; //<S2SV> ret = actions [ act ] ( context , hdr , 0 , data + tdp , len ) ; //<S2SV> } //<S2SV> pc += asn1_op_lengths [ op ] ; //<S2SV> goto next_op ; //<S2SV> case ASN1_OP_MAYBE_ACT : //<S2SV> if ( ! ( flags & FLAG_LAST_MATCHED ) ) { //<S2SV> pc += asn1_op_lengths [ op ] ; //<S2SV> goto next_op ; //<S2SV> } //<S2SV> case ASN1_OP_ACT : //<S2SV> ret = actions [ machine [ pc + 1 ] ] ( context , hdr , tag , data + tdp , len ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> pc += asn1_op_lengths [ op ] ; //<S2SV> goto next_op ; //<S2SV> case ASN1_OP_RETURN : //<S2SV> if ( unlikely ( jsp <= 0 ) ) //<S2SV> goto jump_stack_underflow ; //<S2SV> pc = jump_stack [ -- jsp ] ; //<S2SV> flags |= FLAG_MATCHED | FLAG_LAST_MATCHED ; //<S2SV> goto next_op ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> pr_err ( "ASN.1<S2SV_blank>decoder<S2SV_blank>error:<S2SV_blank>Found<S2SV_blank>reserved<S2SV_blank>opcode<S2SV_blank>(%u)<S2SV_blank>pc=%zu\\n" , //<S2SV> op , pc ) ; //<S2SV> return - EBADMSG ; //<S2SV> data_overrun_error : //<S2SV> errmsg = "Data<S2SV_blank>overrun<S2SV_blank>error" ; //<S2SV> goto error ; //<S2SV> machine_overrun_error : //<S2SV> errmsg = "Machine<S2SV_blank>overrun<S2SV_blank>error" ; //<S2SV> goto error ; //<S2SV> jump_stack_underflow : //<S2SV> errmsg = "Jump<S2SV_blank>stack<S2SV_blank>underflow" ; //<S2SV> goto error ; //<S2SV> jump_stack_overflow : //<S2SV> errmsg = "Jump<S2SV_blank>stack<S2SV_blank>overflow" ; //<S2SV> goto error ; //<S2SV> cons_stack_underflow : //<S2SV> errmsg = "Cons<S2SV_blank>stack<S2SV_blank>underflow" ; //<S2SV> goto error ; //<S2SV> cons_stack_overflow : //<S2SV> errmsg = "Cons<S2SV_blank>stack<S2SV_blank>overflow" ; //<S2SV> goto error ; //<S2SV> cons_length_error : //<S2SV> errmsg = "Cons<S2SV_blank>length<S2SV_blank>error" ; //<S2SV> goto error ; //<S2SV> missing_eoc : //<S2SV> errmsg = "Missing<S2SV_blank>EOC<S2SV_blank>in<S2SV_blank>indefinite<S2SV_blank>len<S2SV_blank>cons" ; //<S2SV> goto error ; //<S2SV> invalid_eoc : //<S2SV> errmsg = "Invalid<S2SV_blank>length<S2SV_blank>EOC" ; //<S2SV> goto error ; //<S2SV> length_too_long : //<S2SV> errmsg = "Unsupported<S2SV_blank>length" ; //<S2SV> goto error ; //<S2SV> indefinite_len_primitive : //<S2SV> errmsg = "Indefinite<S2SV_blank>len<S2SV_blank>primitive<S2SV_blank>not<S2SV_blank>permitted" ; //<S2SV> goto error ; //<S2SV> tag_mismatch : //<S2SV> errmsg = "Unexpected<S2SV_blank>tag" ; //<S2SV> goto error ; //<S2SV> long_tag_not_supported : //<S2SV> errmsg = "Long<S2SV_blank>tag<S2SV_blank>not<S2SV_blank>supported" ; //<S2SV> error : //<S2SV> pr_debug ( "\\nASN1:<S2SV_blank>%s<S2SV_blank>[m=%zu<S2SV_blank>d=%zu<S2SV_blank>ot=%02x<S2SV_blank>t=%02x<S2SV_blank>l=%zu]\\n" , //<S2SV> errmsg , pc , dp , optag , tag , len ) ; //<S2SV> return - EBADMSG ; //<S2SV> } //<S2SV> 