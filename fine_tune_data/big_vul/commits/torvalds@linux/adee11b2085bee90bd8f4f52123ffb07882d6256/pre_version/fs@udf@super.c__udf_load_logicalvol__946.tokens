static int udf_load_logicalvol ( struct super_block * sb , sector_t block , //<S2SV> struct kernel_lb_addr * fileset ) //<S2SV> { //<S2SV> struct logicalVolDesc * lvd ; //<S2SV> int i , j , offset ; //<S2SV> uint8_t type ; //<S2SV> struct udf_sb_info * sbi = UDF_SB ( sb ) ; //<S2SV> struct genericPartitionMap * gpm ; //<S2SV> uint16_t ident ; //<S2SV> struct buffer_head * bh ; //<S2SV> int ret = 0 ; //<S2SV> bh = udf_read_tagged ( sb , block , block , & ident ) ; //<S2SV> if ( ! bh ) //<S2SV> return 1 ; //<S2SV> BUG_ON ( ident != TAG_IDENT_LVD ) ; //<S2SV> lvd = ( struct logicalVolDesc * ) bh -> b_data ; //<S2SV> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; //<S2SV> if ( ret ) //<S2SV> goto out_bh ; //<S2SV> for ( i = 0 , offset = 0 ; //<S2SV> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; //<S2SV> i ++ , offset += gpm -> partitionMapLength ) { //<S2SV> struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; //<S2SV> gpm = ( struct genericPartitionMap * ) //<S2SV> & ( lvd -> partitionMaps [ offset ] ) ; //<S2SV> type = gpm -> partitionMapType ; //<S2SV> if ( type == 1 ) { //<S2SV> struct genericPartitionMap1 * gpm1 = //<S2SV> ( struct genericPartitionMap1 * ) gpm ; //<S2SV> map -> s_partition_type = UDF_TYPE1_MAP15 ; //<S2SV> map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; //<S2SV> map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; //<S2SV> map -> s_partition_func = NULL ; //<S2SV> } else if ( type == 2 ) { //<S2SV> struct udfPartitionMap2 * upm2 = //<S2SV> ( struct udfPartitionMap2 * ) gpm ; //<S2SV> if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , //<S2SV> strlen ( UDF_ID_VIRTUAL ) ) ) { //<S2SV> u16 suf = //<S2SV> le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . //<S2SV> identSuffix ) [ 0 ] ) ; //<S2SV> if ( suf < 0x0200 ) { //<S2SV> map -> s_partition_type = //<S2SV> UDF_VIRTUAL_MAP15 ; //<S2SV> map -> s_partition_func = //<S2SV> udf_get_pblock_virt15 ; //<S2SV> } else { //<S2SV> map -> s_partition_type = //<S2SV> UDF_VIRTUAL_MAP20 ; //<S2SV> map -> s_partition_func = //<S2SV> udf_get_pblock_virt20 ; //<S2SV> } //<S2SV> } else if ( ! strncmp ( upm2 -> partIdent . ident , //<S2SV> UDF_ID_SPARABLE , //<S2SV> strlen ( UDF_ID_SPARABLE ) ) ) { //<S2SV> uint32_t loc ; //<S2SV> struct sparingTable * st ; //<S2SV> struct sparablePartitionMap * spm = //<S2SV> ( struct sparablePartitionMap * ) gpm ; //<S2SV> map -> s_partition_type = UDF_SPARABLE_MAP15 ; //<S2SV> map -> s_type_specific . s_sparing . s_packet_len = //<S2SV> le16_to_cpu ( spm -> packetLength ) ; //<S2SV> for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { //<S2SV> struct buffer_head * bh2 ; //<S2SV> loc = le32_to_cpu ( //<S2SV> spm -> locSparingTable [ j ] ) ; //<S2SV> bh2 = udf_read_tagged ( sb , loc , loc , //<S2SV> & ident ) ; //<S2SV> map -> s_type_specific . s_sparing . //<S2SV> s_spar_map [ j ] = bh2 ; //<S2SV> if ( bh2 == NULL ) //<S2SV> continue ; //<S2SV> st = ( struct sparingTable * ) bh2 -> b_data ; //<S2SV> if ( ident != 0 || strncmp ( //<S2SV> st -> sparingIdent . ident , //<S2SV> UDF_ID_SPARING , //<S2SV> strlen ( UDF_ID_SPARING ) ) ) { //<S2SV> brelse ( bh2 ) ; //<S2SV> map -> s_type_specific . s_sparing . //<S2SV> s_spar_map [ j ] = NULL ; //<S2SV> } //<S2SV> } //<S2SV> map -> s_partition_func = udf_get_pblock_spar15 ; //<S2SV> } else if ( ! strncmp ( upm2 -> partIdent . ident , //<S2SV> UDF_ID_METADATA , //<S2SV> strlen ( UDF_ID_METADATA ) ) ) { //<S2SV> struct udf_meta_data * mdata = //<S2SV> & map -> s_type_specific . s_metadata ; //<S2SV> struct metadataPartitionMap * mdm = //<S2SV> ( struct metadataPartitionMap * ) //<S2SV> & ( lvd -> partitionMaps [ offset ] ) ; //<S2SV> udf_debug ( "Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n" , //<S2SV> i , type , UDF_ID_METADATA ) ; //<S2SV> map -> s_partition_type = UDF_METADATA_MAP25 ; //<S2SV> map -> s_partition_func = udf_get_pblock_meta25 ; //<S2SV> mdata -> s_meta_file_loc = //<S2SV> le32_to_cpu ( mdm -> metadataFileLoc ) ; //<S2SV> mdata -> s_mirror_file_loc = //<S2SV> le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; //<S2SV> mdata -> s_bitmap_file_loc = //<S2SV> le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; //<S2SV> mdata -> s_alloc_unit_size = //<S2SV> le32_to_cpu ( mdm -> allocUnitSize ) ; //<S2SV> mdata -> s_align_unit_size = //<S2SV> le16_to_cpu ( mdm -> alignUnitSize ) ; //<S2SV> if ( mdm -> flags & 0x01 ) //<S2SV> mdata -> s_flags |= MF_DUPLICATE_MD ; //<S2SV> udf_debug ( "Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n" , //<S2SV> le16_to_cpu ( * ( __le16 * ) //<S2SV> mdm -> partIdent . identSuffix ) ) ; //<S2SV> udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n" , //<S2SV> le16_to_cpu ( mdm -> partitionNum ) ) ; //<S2SV> udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n" , //<S2SV> le32_to_cpu ( mdm -> allocUnitSize ) ) ; //<S2SV> udf_debug ( "Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n" , //<S2SV> le32_to_cpu ( mdm -> metadataFileLoc ) ) ; //<S2SV> udf_debug ( "Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n" , //<S2SV> le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; //<S2SV> udf_debug ( "Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n" , //<S2SV> le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; //<S2SV> udf_debug ( "Flags:<S2SV_blank>%d<S2SV_blank>%d\\n" , //<S2SV> mdata -> s_flags , mdm -> flags ) ; //<S2SV> } else { //<S2SV> udf_debug ( "Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n" , //<S2SV> upm2 -> partIdent . ident ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; //<S2SV> map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; //<S2SV> } //<S2SV> udf_debug ( "Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n" , //<S2SV> i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; //<S2SV> } //<S2SV> if ( fileset ) { //<S2SV> struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; //<S2SV> * fileset = lelb_to_cpu ( la -> extLocation ) ; //<S2SV> udf_debug ( "FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n" , //<S2SV> fileset -> logicalBlockNum , //<S2SV> fileset -> partitionReferenceNum ) ; //<S2SV> } //<S2SV> if ( lvd -> integritySeqExt . extLength ) //<S2SV> udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; //<S2SV> out_bh : //<S2SV> brelse ( bh ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 