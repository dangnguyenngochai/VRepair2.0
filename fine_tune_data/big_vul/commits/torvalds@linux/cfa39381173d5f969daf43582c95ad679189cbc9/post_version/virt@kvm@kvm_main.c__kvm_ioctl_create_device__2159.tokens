static int kvm_ioctl_create_device ( struct kvm * kvm , //<S2SV> struct kvm_create_device * cd ) //<S2SV> { //<S2SV> struct kvm_device_ops * ops = NULL ; //<S2SV> struct kvm_device * dev ; //<S2SV> bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; //<S2SV> int ret ; //<S2SV> if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) //<S2SV> return - ENODEV ; //<S2SV> ops = kvm_device_ops_table [ cd -> type ] ; //<S2SV> if ( ops == NULL ) //<S2SV> return - ENODEV ; //<S2SV> if ( test ) //<S2SV> return 0 ; //<S2SV> dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; //<S2SV> if ( ! dev ) //<S2SV> return - ENOMEM ; //<S2SV> dev -> ops = ops ; //<S2SV> dev -> kvm = kvm ; //<S2SV> mutex_lock ( & kvm -> lock ) ; //<S2SV> ret = ops -> create ( dev , cd -> type ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> mutex_unlock ( & kvm -> lock ) ; //<S2SV> kfree ( dev ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> list_add ( & dev -> vm_node , & kvm -> devices ) ; //<S2SV> mutex_unlock ( & kvm -> lock ) ; //<S2SV> if ( ops -> init ) //<S2SV> ops -> init ( dev ) ; //<S2SV> kvm_get_kvm ( kvm ) ; //<S2SV> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> kvm_put_kvm ( kvm ) ; //<S2SV> mutex_lock ( & kvm -> lock ) ; //<S2SV> list_del ( & dev -> vm_node ) ; //<S2SV> mutex_unlock ( & kvm -> lock ) ; //<S2SV> ops -> destroy ( dev ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> cd -> fd = ret ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 