static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , //<S2SV> u32 __user * uaddr2 , int nr_wake , int nr_requeue , //<S2SV> u32 * cmpval , int requeue_pi ) //<S2SV> { //<S2SV> union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; //<S2SV> int drop_count = 0 , task_count = 0 , ret ; //<S2SV> struct futex_pi_state * pi_state = NULL ; //<S2SV> struct futex_hash_bucket * hb1 , * hb2 ; //<S2SV> struct futex_q * this , * next ; //<S2SV> DEFINE_WAKE_Q ( wake_q ) ; //<S2SV> if ( nr_wake < 0 || nr_requeue < 0 ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) //<S2SV> return - ENOSYS ; //<S2SV> if ( requeue_pi ) { //<S2SV> if ( uaddr1 == uaddr2 ) //<S2SV> return - EINVAL ; //<S2SV> if ( refill_pi_state_cache ( ) ) //<S2SV> return - ENOMEM ; //<S2SV> if ( nr_wake != 1 ) //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> retry : //<S2SV> ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; //<S2SV> if ( unlikely ( ret != 0 ) ) //<S2SV> goto out ; //<S2SV> ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , //<S2SV> requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; //<S2SV> if ( unlikely ( ret != 0 ) ) //<S2SV> goto out_put_key1 ; //<S2SV> if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out_put_keys ; //<S2SV> } //<S2SV> hb1 = hash_futex ( & key1 ) ; //<S2SV> hb2 = hash_futex ( & key2 ) ; //<S2SV> retry_private : //<S2SV> hb_waiters_inc ( hb2 ) ; //<S2SV> double_lock_hb ( hb1 , hb2 ) ; //<S2SV> if ( likely ( cmpval != NULL ) ) { //<S2SV> u32 curval ; //<S2SV> ret = get_futex_value_locked ( & curval , uaddr1 ) ; //<S2SV> if ( unlikely ( ret ) ) { //<S2SV> double_unlock_hb ( hb1 , hb2 ) ; //<S2SV> hb_waiters_dec ( hb2 ) ; //<S2SV> ret = get_user ( curval , uaddr1 ) ; //<S2SV> if ( ret ) //<S2SV> goto out_put_keys ; //<S2SV> if ( ! ( flags & FLAGS_SHARED ) ) //<S2SV> goto retry_private ; //<S2SV> put_futex_key ( & key2 ) ; //<S2SV> put_futex_key ( & key1 ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> if ( curval != * cmpval ) { //<S2SV> ret = - EAGAIN ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> } //<S2SV> if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { //<S2SV> ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , //<S2SV> & key2 , & pi_state , nr_requeue ) ; //<S2SV> if ( ret > 0 ) { //<S2SV> WARN_ON ( pi_state ) ; //<S2SV> drop_count ++ ; //<S2SV> task_count ++ ; //<S2SV> ret = lookup_pi_state ( uaddr2 , ret , hb2 , & key2 , & pi_state ) ; //<S2SV> } //<S2SV> switch ( ret ) { //<S2SV> case 0 : //<S2SV> break ; //<S2SV> case - EFAULT : //<S2SV> double_unlock_hb ( hb1 , hb2 ) ; //<S2SV> hb_waiters_dec ( hb2 ) ; //<S2SV> put_futex_key ( & key2 ) ; //<S2SV> put_futex_key ( & key1 ) ; //<S2SV> ret = fault_in_user_writeable ( uaddr2 ) ; //<S2SV> if ( ! ret ) //<S2SV> goto retry ; //<S2SV> goto out ; //<S2SV> case - EAGAIN : //<S2SV> double_unlock_hb ( hb1 , hb2 ) ; //<S2SV> hb_waiters_dec ( hb2 ) ; //<S2SV> put_futex_key ( & key2 ) ; //<S2SV> put_futex_key ( & key1 ) ; //<S2SV> cond_resched ( ) ; //<S2SV> goto retry ; //<S2SV> default : //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> } //<S2SV> plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { //<S2SV> if ( task_count - nr_wake >= nr_requeue ) //<S2SV> break ; //<S2SV> if ( ! match_futex ( & this -> key , & key1 ) ) //<S2SV> continue ; //<S2SV> if ( ( requeue_pi && ! this -> rt_waiter ) || //<S2SV> ( ! requeue_pi && this -> rt_waiter ) || //<S2SV> this -> pi_state ) { //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ++ task_count <= nr_wake && ! requeue_pi ) { //<S2SV> mark_wake_futex ( & wake_q , this ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( requeue_pi ) { //<S2SV> get_pi_state ( pi_state ) ; //<S2SV> this -> pi_state = pi_state ; //<S2SV> ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , //<S2SV> this -> rt_waiter , //<S2SV> this -> task ) ; //<S2SV> if ( ret == 1 ) { //<S2SV> requeue_pi_wake_futex ( this , & key2 , hb2 ) ; //<S2SV> drop_count ++ ; //<S2SV> continue ; //<S2SV> } else if ( ret ) { //<S2SV> this -> pi_state = NULL ; //<S2SV> put_pi_state ( pi_state ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> requeue_futex ( this , hb1 , hb2 , & key2 ) ; //<S2SV> drop_count ++ ; //<S2SV> } //<S2SV> put_pi_state ( pi_state ) ; //<S2SV> out_unlock : //<S2SV> double_unlock_hb ( hb1 , hb2 ) ; //<S2SV> wake_up_q ( & wake_q ) ; //<S2SV> hb_waiters_dec ( hb2 ) ; //<S2SV> while ( -- drop_count >= 0 ) //<S2SV> drop_futex_key_refs ( & key1 ) ; //<S2SV> out_put_keys : //<S2SV> put_futex_key ( & key2 ) ; //<S2SV> out_put_key1 : //<S2SV> put_futex_key ( & key1 ) ; //<S2SV> out : //<S2SV> return ret ? ret : task_count ; //<S2SV> } //<S2SV> 