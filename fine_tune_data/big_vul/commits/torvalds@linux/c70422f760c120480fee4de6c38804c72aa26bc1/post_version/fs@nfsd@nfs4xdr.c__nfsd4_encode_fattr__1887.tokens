static __be32 //<S2SV> nfsd4_encode_fattr ( struct xdr_stream * xdr , struct svc_fh * fhp , //<S2SV> struct svc_export * exp , //<S2SV> struct dentry * dentry , u32 * bmval , //<S2SV> struct svc_rqst * rqstp , int ignore_crossmnt ) //<S2SV> { //<S2SV> u32 bmval0 = bmval [ 0 ] ; //<S2SV> u32 bmval1 = bmval [ 1 ] ; //<S2SV> u32 bmval2 = bmval [ 2 ] ; //<S2SV> struct kstat stat ; //<S2SV> struct svc_fh * tempfh = NULL ; //<S2SV> struct kstatfs statfs ; //<S2SV> __be32 * p ; //<S2SV> int starting_len = xdr -> buf -> len ; //<S2SV> int attrlen_offset ; //<S2SV> __be32 attrlen ; //<S2SV> u32 dummy ; //<S2SV> u64 dummy64 ; //<S2SV> u32 rdattr_err = 0 ; //<S2SV> __be32 status ; //<S2SV> int err ; //<S2SV> struct nfs4_acl * acl = NULL ; //<S2SV> void * context = NULL ; //<S2SV> int contextlen ; //<S2SV> bool contextsupport = false ; //<S2SV> struct nfsd4_compoundres * resp = rqstp -> rq_resp ; //<S2SV> u32 minorversion = resp -> cstate . minorversion ; //<S2SV> struct path path = { //<S2SV> . mnt = exp -> ex_path . mnt , //<S2SV> . dentry = dentry , //<S2SV> } ; //<S2SV> struct nfsd_net * nn = net_generic ( SVC_NET ( rqstp ) , nfsd_net_id ) ; //<S2SV> BUG_ON ( bmval1 & NFSD_WRITEONLY_ATTRS_WORD1 ) ; //<S2SV> BUG_ON ( ! nfsd_attrs_supported ( minorversion , bmval ) ) ; //<S2SV> if ( exp -> ex_fslocs . migrated ) { //<S2SV> status = fattr_handle_absent_fs ( & bmval0 , & bmval1 , & bmval2 , & rdattr_err ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> err = vfs_getattr ( & path , & stat , STATX_BASIC_STATS , AT_STATX_SYNC_AS_STAT ) ; //<S2SV> if ( err ) //<S2SV> goto out_nfserr ; //<S2SV> if ( ( bmval0 & ( FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE | //<S2SV> FATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME ) ) || //<S2SV> ( bmval1 & ( FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE | //<S2SV> FATTR4_WORD1_SPACE_TOTAL ) ) ) { //<S2SV> err = vfs_statfs ( & path , & statfs ) ; //<S2SV> if ( err ) //<S2SV> goto out_nfserr ; //<S2SV> } //<S2SV> if ( ( bmval0 & ( FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID ) ) && ! fhp ) { //<S2SV> tempfh = kmalloc ( sizeof ( struct svc_fh ) , GFP_KERNEL ) ; //<S2SV> status = nfserr_jukebox ; //<S2SV> if ( ! tempfh ) //<S2SV> goto out ; //<S2SV> fh_init ( tempfh , NFS4_FHSIZE ) ; //<S2SV> status = fh_compose ( tempfh , exp , dentry , NULL ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> fhp = tempfh ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_ACL ) { //<S2SV> err = nfsd4_get_nfs4_acl ( rqstp , dentry , & acl ) ; //<S2SV> if ( err == - EOPNOTSUPP ) //<S2SV> bmval0 &= ~ FATTR4_WORD0_ACL ; //<S2SV> else if ( err == - EINVAL ) { //<S2SV> status = nfserr_attrnotsupp ; //<S2SV> goto out ; //<S2SV> } else if ( err != 0 ) //<S2SV> goto out_nfserr ; //<S2SV> } //<S2SV> # ifdef CONFIG_NFSD_V4_SECURITY_LABEL //<S2SV> if ( ( bmval2 & FATTR4_WORD2_SECURITY_LABEL ) || //<S2SV> bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS ) { //<S2SV> if ( exp -> ex_flags & NFSEXP_SECURITY_LABEL ) //<S2SV> err = security_inode_getsecctx ( d_inode ( dentry ) , //<S2SV> & context , & contextlen ) ; //<S2SV> else //<S2SV> err = - EOPNOTSUPP ; //<S2SV> contextsupport = ( err == 0 ) ; //<S2SV> if ( bmval2 & FATTR4_WORD2_SECURITY_LABEL ) { //<S2SV> if ( err == - EOPNOTSUPP ) //<S2SV> bmval2 &= ~ FATTR4_WORD2_SECURITY_LABEL ; //<S2SV> else if ( err ) //<S2SV> goto out_nfserr ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> status = nfsd4_encode_bitmap ( xdr , bmval0 , bmval1 , bmval2 ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> attrlen_offset = xdr -> buf -> len ; //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p ++ ; //<S2SV> if ( bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS ) { //<S2SV> u32 supp [ 3 ] ; //<S2SV> memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; //<S2SV> if ( ! IS_POSIXACL ( dentry -> d_inode ) ) //<S2SV> supp [ 0 ] &= ~ FATTR4_WORD0_ACL ; //<S2SV> if ( ! contextsupport ) //<S2SV> supp [ 2 ] &= ~ FATTR4_WORD2_SECURITY_LABEL ; //<S2SV> if ( ! supp [ 2 ] ) { //<S2SV> p = xdr_reserve_space ( xdr , 12 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 2 ) ; //<S2SV> * p ++ = cpu_to_be32 ( supp [ 0 ] ) ; //<S2SV> * p ++ = cpu_to_be32 ( supp [ 1 ] ) ; //<S2SV> } else { //<S2SV> p = xdr_reserve_space ( xdr , 16 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 3 ) ; //<S2SV> * p ++ = cpu_to_be32 ( supp [ 0 ] ) ; //<S2SV> * p ++ = cpu_to_be32 ( supp [ 1 ] ) ; //<S2SV> * p ++ = cpu_to_be32 ( supp [ 2 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_TYPE ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> dummy = nfs4_file_type ( stat . mode ) ; //<S2SV> if ( dummy == NF4BAD ) { //<S2SV> status = nfserr_serverfault ; //<S2SV> goto out ; //<S2SV> } //<S2SV> * p ++ = cpu_to_be32 ( dummy ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> if ( exp -> ex_flags & NFSEXP_NOSUBTREECHECK ) //<S2SV> * p ++ = cpu_to_be32 ( NFS4_FH_PERSISTENT ) ; //<S2SV> else //<S2SV> * p ++ = cpu_to_be32 ( NFS4_FH_PERSISTENT | //<S2SV> NFS4_FH_VOL_RENAME ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_CHANGE ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = encode_change ( p , & stat , d_inode ( dentry ) , exp ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_SIZE ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , stat . size ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_LINK_SUPPORT ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 1 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 1 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_NAMED_ATTR ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 0 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_FSID ) { //<S2SV> p = xdr_reserve_space ( xdr , 16 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> if ( exp -> ex_fslocs . migrated ) { //<S2SV> p = xdr_encode_hyper ( p , NFS4_REFERRAL_FSID_MAJOR ) ; //<S2SV> p = xdr_encode_hyper ( p , NFS4_REFERRAL_FSID_MINOR ) ; //<S2SV> } else switch ( fsid_source ( fhp ) ) { //<S2SV> case FSIDSOURCE_FSID : //<S2SV> p = xdr_encode_hyper ( p , ( u64 ) exp -> ex_fsid ) ; //<S2SV> p = xdr_encode_hyper ( p , ( u64 ) 0 ) ; //<S2SV> break ; //<S2SV> case FSIDSOURCE_DEV : //<S2SV> * p ++ = cpu_to_be32 ( 0 ) ; //<S2SV> * p ++ = cpu_to_be32 ( MAJOR ( stat . dev ) ) ; //<S2SV> * p ++ = cpu_to_be32 ( 0 ) ; //<S2SV> * p ++ = cpu_to_be32 ( MINOR ( stat . dev ) ) ; //<S2SV> break ; //<S2SV> case FSIDSOURCE_UUID : //<S2SV> p = xdr_encode_opaque_fixed ( p , exp -> ex_uuid , //<S2SV> EX_UUID_LEN ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_UNIQUE_HANDLES ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 0 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_LEASE_TIME ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( nn -> nfsd4_lease ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_RDATTR_ERROR ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( rdattr_err ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_ACL ) { //<S2SV> struct nfs4_ace * ace ; //<S2SV> if ( acl == NULL ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 0 ) ; //<S2SV> goto out_acl ; //<S2SV> } //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( acl -> naces ) ; //<S2SV> for ( ace = acl -> aces ; ace < acl -> aces + acl -> naces ; ace ++ ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 * 3 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( ace -> type ) ; //<S2SV> * p ++ = cpu_to_be32 ( ace -> flag ) ; //<S2SV> * p ++ = cpu_to_be32 ( ace -> access_mask & //<S2SV> NFS4_ACE_MASK_ALL ) ; //<S2SV> status = nfsd4_encode_aclname ( xdr , rqstp , ace ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> out_acl : //<S2SV> if ( bmval0 & FATTR4_WORD0_ACLSUPPORT ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( IS_POSIXACL ( dentry -> d_inode ) ? //<S2SV> ACL4_SUPPORT_ALLOW_ACL | ACL4_SUPPORT_DENY_ACL : 0 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_CANSETTIME ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 1 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_CASE_INSENSITIVE ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 0 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_CASE_PRESERVING ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 1 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 1 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_FILEHANDLE ) { //<S2SV> p = xdr_reserve_space ( xdr , fhp -> fh_handle . fh_size + 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_opaque ( p , & fhp -> fh_handle . fh_base , //<S2SV> fhp -> fh_handle . fh_size ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_FILEID ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , stat . ino ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_FILES_AVAIL ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , ( u64 ) statfs . f_ffree ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_FILES_FREE ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , ( u64 ) statfs . f_ffree ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_FILES_TOTAL ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , ( u64 ) statfs . f_files ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_FS_LOCATIONS ) { //<S2SV> status = nfsd4_encode_fs_locations ( xdr , rqstp , exp ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_HOMOGENEOUS ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 1 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_MAXFILESIZE ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , exp -> ex_path . mnt -> mnt_sb -> s_maxbytes ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_MAXLINK ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 255 ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_MAXNAME ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( statfs . f_namelen ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_MAXREAD ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , ( u64 ) svc_max_payload ( rqstp ) ) ; //<S2SV> } //<S2SV> if ( bmval0 & FATTR4_WORD0_MAXWRITE ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , ( u64 ) svc_max_payload ( rqstp ) ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_MODE ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( stat . mode & S_IALLUGO ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_NO_TRUNC ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 1 ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_NUMLINKS ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( stat . nlink ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_OWNER ) { //<S2SV> status = nfsd4_encode_user ( xdr , rqstp , stat . uid ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_OWNER_GROUP ) { //<S2SV> status = nfsd4_encode_group ( xdr , rqstp , stat . gid ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_RAWDEV ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( ( u32 ) MAJOR ( stat . rdev ) ) ; //<S2SV> * p ++ = cpu_to_be32 ( ( u32 ) MINOR ( stat . rdev ) ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_SPACE_AVAIL ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> dummy64 = ( u64 ) statfs . f_bavail * ( u64 ) statfs . f_bsize ; //<S2SV> p = xdr_encode_hyper ( p , dummy64 ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_SPACE_FREE ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> dummy64 = ( u64 ) statfs . f_bfree * ( u64 ) statfs . f_bsize ; //<S2SV> p = xdr_encode_hyper ( p , dummy64 ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_SPACE_TOTAL ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> dummy64 = ( u64 ) statfs . f_blocks * ( u64 ) statfs . f_bsize ; //<S2SV> p = xdr_encode_hyper ( p , dummy64 ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_SPACE_USED ) { //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> dummy64 = ( u64 ) stat . blocks << 9 ; //<S2SV> p = xdr_encode_hyper ( p , dummy64 ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_TIME_ACCESS ) { //<S2SV> p = xdr_reserve_space ( xdr , 12 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , ( s64 ) stat . atime . tv_sec ) ; //<S2SV> * p ++ = cpu_to_be32 ( stat . atime . tv_nsec ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_TIME_DELTA ) { //<S2SV> p = xdr_reserve_space ( xdr , 12 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( 0 ) ; //<S2SV> * p ++ = cpu_to_be32 ( 1 ) ; //<S2SV> * p ++ = cpu_to_be32 ( 0 ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_TIME_METADATA ) { //<S2SV> p = xdr_reserve_space ( xdr , 12 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , ( s64 ) stat . ctime . tv_sec ) ; //<S2SV> * p ++ = cpu_to_be32 ( stat . ctime . tv_nsec ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_TIME_MODIFY ) { //<S2SV> p = xdr_reserve_space ( xdr , 12 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> p = xdr_encode_hyper ( p , ( s64 ) stat . mtime . tv_sec ) ; //<S2SV> * p ++ = cpu_to_be32 ( stat . mtime . tv_nsec ) ; //<S2SV> } //<S2SV> if ( bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID ) { //<S2SV> struct kstat parent_stat ; //<S2SV> u64 ino = stat . ino ; //<S2SV> p = xdr_reserve_space ( xdr , 8 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> if ( ignore_crossmnt == 0 && //<S2SV> dentry == exp -> ex_path . mnt -> mnt_root ) { //<S2SV> err = get_parent_attributes ( exp , & parent_stat ) ; //<S2SV> if ( err ) //<S2SV> goto out_nfserr ; //<S2SV> ino = parent_stat . ino ; //<S2SV> } //<S2SV> p = xdr_encode_hyper ( p , ino ) ; //<S2SV> } //<S2SV> # ifdef CONFIG_NFSD_PNFS //<S2SV> if ( bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES ) { //<S2SV> status = nfsd4_encode_layout_types ( xdr , exp -> ex_layout_types ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( bmval2 & FATTR4_WORD2_LAYOUT_TYPES ) { //<S2SV> status = nfsd4_encode_layout_types ( xdr , exp -> ex_layout_types ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE ) { //<S2SV> p = xdr_reserve_space ( xdr , 4 ) ; //<S2SV> if ( ! p ) //<S2SV> goto out_resource ; //<S2SV> * p ++ = cpu_to_be32 ( stat . blksize ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT ) { //<S2SV> u32 supp [ 3 ] ; //<S2SV> memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; //<S2SV> supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ; //<S2SV> supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ; //<S2SV> supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ; //<S2SV> status = nfsd4_encode_bitmap ( xdr , supp [ 0 ] , supp [ 1 ] , supp [ 2 ] ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( bmval2 & FATTR4_WORD2_SECURITY_LABEL ) { //<S2SV> status = nfsd4_encode_security_label ( xdr , rqstp , context , //<S2SV> contextlen ) ; //<S2SV> if ( status ) //<S2SV> goto out ; //<S2SV> } //<S2SV> attrlen = htonl ( xdr -> buf -> len - attrlen_offset - 4 ) ; //<S2SV> write_bytes_to_xdr_buf ( xdr -> buf , attrlen_offset , & attrlen , 4 ) ; //<S2SV> status = nfs_ok ; //<S2SV> out : //<S2SV> # ifdef CONFIG_NFSD_V4_SECURITY_LABEL //<S2SV> if ( context ) //<S2SV> security_release_secctx ( context , contextlen ) ; //<S2SV> # endif //<S2SV> kfree ( acl ) ; //<S2SV> if ( tempfh ) { //<S2SV> fh_put ( tempfh ) ; //<S2SV> kfree ( tempfh ) ; //<S2SV> } //<S2SV> if ( status ) //<S2SV> xdr_truncate_encode ( xdr , starting_len ) ; //<S2SV> return status ; //<S2SV> out_nfserr : //<S2SV> status = nfserrno ( err ) ; //<S2SV> goto out ; //<S2SV> out_resource : //<S2SV> status = nfserr_resource ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 