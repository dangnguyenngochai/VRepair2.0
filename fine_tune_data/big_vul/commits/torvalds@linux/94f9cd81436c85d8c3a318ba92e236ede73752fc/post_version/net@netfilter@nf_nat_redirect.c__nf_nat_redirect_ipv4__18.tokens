unsigned int //<S2SV> nf_nat_redirect_ipv4 ( struct sk_buff * skb , //<S2SV> const struct nf_nat_ipv4_multi_range_compat * mr , //<S2SV> unsigned int hooknum ) //<S2SV> { //<S2SV> struct nf_conn * ct ; //<S2SV> enum ip_conntrack_info ctinfo ; //<S2SV> __be32 newdst ; //<S2SV> struct nf_nat_range newrange ; //<S2SV> NF_CT_ASSERT ( hooknum == NF_INET_PRE_ROUTING || //<S2SV> hooknum == NF_INET_LOCAL_OUT ) ; //<S2SV> ct = nf_ct_get ( skb , & ctinfo ) ; //<S2SV> NF_CT_ASSERT ( ct && ( ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ) ) ; //<S2SV> if ( hooknum == NF_INET_LOCAL_OUT ) { //<S2SV> newdst = htonl ( 0x7F000001 ) ; //<S2SV> } else { //<S2SV> struct in_device * indev ; //<S2SV> struct in_ifaddr * ifa ; //<S2SV> newdst = 0 ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> indev = __in_dev_get_rcu ( skb -> dev ) ; //<S2SV> if ( indev && indev -> ifa_list ) { //<S2SV> ifa = indev -> ifa_list ; //<S2SV> newdst = ifa -> ifa_local ; //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> if ( ! newdst ) //<S2SV> return NF_DROP ; //<S2SV> } //<S2SV> memset ( & newrange . min_addr , 0 , sizeof ( newrange . min_addr ) ) ; //<S2SV> memset ( & newrange . max_addr , 0 , sizeof ( newrange . max_addr ) ) ; //<S2SV> newrange . flags = mr -> range [ 0 ] . flags | NF_NAT_RANGE_MAP_IPS ; //<S2SV> newrange . min_addr . ip = newdst ; //<S2SV> newrange . max_addr . ip = newdst ; //<S2SV> newrange . min_proto = mr -> range [ 0 ] . min ; //<S2SV> newrange . max_proto = mr -> range [ 0 ] . max ; //<S2SV> return nf_nat_setup_info ( ct , & newrange , NF_NAT_MANIP_DST ) ; //<S2SV> } //<S2SV> 