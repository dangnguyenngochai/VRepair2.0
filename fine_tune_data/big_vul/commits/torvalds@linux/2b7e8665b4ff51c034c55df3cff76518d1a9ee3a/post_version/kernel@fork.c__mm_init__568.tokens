static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , //<S2SV> struct user_namespace * user_ns ) //<S2SV> { //<S2SV> mm -> mmap = NULL ; //<S2SV> mm -> mm_rb = RB_ROOT ; //<S2SV> mm -> vmacache_seqnum = 0 ; //<S2SV> atomic_set ( & mm -> mm_users , 1 ) ; //<S2SV> atomic_set ( & mm -> mm_count , 1 ) ; //<S2SV> init_rwsem ( & mm -> mmap_sem ) ; //<S2SV> INIT_LIST_HEAD ( & mm -> mmlist ) ; //<S2SV> mm -> core_state = NULL ; //<S2SV> atomic_long_set ( & mm -> nr_ptes , 0 ) ; //<S2SV> mm_nr_pmds_init ( mm ) ; //<S2SV> mm -> map_count = 0 ; //<S2SV> mm -> locked_vm = 0 ; //<S2SV> mm -> pinned_vm = 0 ; //<S2SV> memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; //<S2SV> spin_lock_init ( & mm -> page_table_lock ) ; //<S2SV> mm_init_cpumask ( mm ) ; //<S2SV> mm_init_aio ( mm ) ; //<S2SV> mm_init_owner ( mm , p ) ; //<S2SV> RCU_INIT_POINTER ( mm -> exe_file , NULL ) ; //<S2SV> mmu_notifier_mm_init ( mm ) ; //<S2SV> init_tlb_flush_pending ( mm ) ; //<S2SV> # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS //<S2SV> mm -> pmd_huge_pte = NULL ; //<S2SV> # endif //<S2SV> if ( current -> mm ) { //<S2SV> mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; //<S2SV> mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; //<S2SV> } else { //<S2SV> mm -> flags = default_dump_filter ; //<S2SV> mm -> def_flags = 0 ; //<S2SV> } //<S2SV> if ( mm_alloc_pgd ( mm ) ) //<S2SV> goto fail_nopgd ; //<S2SV> if ( init_new_context ( p , mm ) ) //<S2SV> goto fail_nocontext ; //<S2SV> mm -> user_ns = get_user_ns ( user_ns ) ; //<S2SV> return mm ; //<S2SV> fail_nocontext : //<S2SV> mm_free_pgd ( mm ) ; //<S2SV> fail_nopgd : //<S2SV> free_mm ( mm ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 