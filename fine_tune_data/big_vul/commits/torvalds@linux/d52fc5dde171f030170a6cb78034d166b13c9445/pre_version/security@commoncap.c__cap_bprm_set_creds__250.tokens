int cap_bprm_set_creds ( struct linux_binprm * bprm ) //<S2SV> { //<S2SV> const struct cred * old = current_cred ( ) ; //<S2SV> struct cred * new = bprm -> cred ; //<S2SV> bool effective , has_cap = false ; //<S2SV> int ret ; //<S2SV> effective = false ; //<S2SV> ret = get_file_caps ( bprm , & effective , & has_cap ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( ! issecure ( SECURE_NOROOT ) ) { //<S2SV> if ( has_cap && new -> uid != 0 && new -> euid == 0 ) { //<S2SV> warn_setuid_and_fcaps_mixed ( bprm -> filename ) ; //<S2SV> goto skip ; //<S2SV> } //<S2SV> if ( new -> euid == 0 || new -> uid == 0 ) { //<S2SV> new -> cap_permitted = cap_combine ( old -> cap_bset , //<S2SV> old -> cap_inheritable ) ; //<S2SV> } //<S2SV> if ( new -> euid == 0 ) //<S2SV> effective = true ; //<S2SV> } //<S2SV> skip : //<S2SV> if ( ( new -> euid != old -> uid || //<S2SV> new -> egid != old -> gid || //<S2SV> ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && //<S2SV> bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) { //<S2SV> if ( ! capable ( CAP_SETUID ) ) { //<S2SV> new -> euid = new -> uid ; //<S2SV> new -> egid = new -> gid ; //<S2SV> } //<S2SV> new -> cap_permitted = cap_intersect ( new -> cap_permitted , //<S2SV> old -> cap_permitted ) ; //<S2SV> } //<S2SV> new -> suid = new -> fsuid = new -> euid ; //<S2SV> new -> sgid = new -> fsgid = new -> egid ; //<S2SV> if ( effective ) //<S2SV> new -> cap_effective = new -> cap_permitted ; //<S2SV> else //<S2SV> cap_clear ( new -> cap_effective ) ; //<S2SV> bprm -> cap_effective = effective ; //<S2SV> if ( ! cap_isclear ( new -> cap_effective ) ) { //<S2SV> if ( ! cap_issubset ( CAP_FULL_SET , new -> cap_effective ) || //<S2SV> new -> euid != 0 || new -> uid != 0 || //<S2SV> issecure ( SECURE_NOROOT ) ) { //<S2SV> ret = audit_log_bprm_fcaps ( bprm , new , old ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> new -> securebits &= ~ issecure_mask ( SECURE_KEEP_CAPS ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 