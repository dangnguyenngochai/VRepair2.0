static void handle_rx ( struct vhost_net * net ) //<S2SV> { //<S2SV> struct vhost_net_virtqueue * nvq = & net -> vqs [ VHOST_NET_VQ_RX ] ; //<S2SV> struct vhost_virtqueue * vq = & nvq -> vq ; //<S2SV> unsigned uninitialized_var ( in ) , log ; //<S2SV> struct vhost_log * vq_log ; //<S2SV> struct msghdr msg = { //<S2SV> . msg_name = NULL , //<S2SV> . msg_namelen = 0 , //<S2SV> . msg_control = NULL , //<S2SV> . msg_controllen = 0 , //<S2SV> . msg_iov = vq -> iov , //<S2SV> . msg_flags = MSG_DONTWAIT , //<S2SV> } ; //<S2SV> struct virtio_net_hdr_mrg_rxbuf hdr = { //<S2SV> . hdr . flags = 0 , //<S2SV> . hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE //<S2SV> } ; //<S2SV> size_t total_len = 0 ; //<S2SV> int err , mergeable ; //<S2SV> s16 headcount ; //<S2SV> size_t vhost_hlen , sock_hlen ; //<S2SV> size_t vhost_len , sock_len ; //<S2SV> struct socket * sock ; //<S2SV> mutex_lock ( & vq -> mutex ) ; //<S2SV> sock = vq -> private_data ; //<S2SV> if ( ! sock ) //<S2SV> goto out ; //<S2SV> vhost_disable_notify ( & net -> dev , vq ) ; //<S2SV> vhost_hlen = nvq -> vhost_hlen ; //<S2SV> sock_hlen = nvq -> sock_hlen ; //<S2SV> vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? //<S2SV> vq -> log : NULL ; //<S2SV> mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ; //<S2SV> while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) { //<S2SV> sock_len += sock_hlen ; //<S2SV> vhost_len = sock_len + vhost_hlen ; //<S2SV> headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , //<S2SV> & in , vq_log , & log , //<S2SV> likely ( mergeable ) ? UIO_MAXIOV : 1 ) ; //<S2SV> if ( unlikely ( headcount < 0 ) ) //<S2SV> break ; //<S2SV> if ( unlikely ( headcount > UIO_MAXIOV ) ) { //<S2SV> msg . msg_iovlen = 1 ; //<S2SV> err = sock -> ops -> recvmsg ( NULL , sock , & msg , //<S2SV> 1 , MSG_DONTWAIT | MSG_TRUNC ) ; //<S2SV> pr_debug ( "Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n" , sock_len ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! headcount ) { //<S2SV> if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { //<S2SV> vhost_disable_notify ( & net -> dev , vq ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> if ( unlikely ( ( vhost_hlen ) ) ) //<S2SV> move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; //<S2SV> else //<S2SV> copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; //<S2SV> msg . msg_iovlen = in ; //<S2SV> err = sock -> ops -> recvmsg ( NULL , sock , & msg , //<S2SV> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; //<S2SV> if ( unlikely ( err != sock_len ) ) { //<S2SV> pr_debug ( "Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>" //<S2SV> "<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\n" , err , sock_len ) ; //<S2SV> vhost_discard_vq_desc ( vq , headcount ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( unlikely ( vhost_hlen ) && //<S2SV> memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & hdr , 0 , //<S2SV> vhost_hlen ) ) { //<S2SV> vq_err ( vq , "Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>vnet_hdr<S2SV_blank>at<S2SV_blank>addr<S2SV_blank>%p\\n" , //<S2SV> vq -> iov -> iov_base ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( likely ( mergeable ) && //<S2SV> memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & headcount , //<S2SV> offsetof ( typeof ( hdr ) , num_buffers ) , //<S2SV> sizeof hdr . num_buffers ) ) { //<S2SV> vq_err ( vq , "Failed<S2SV_blank>num_buffers<S2SV_blank>write" ) ; //<S2SV> vhost_discard_vq_desc ( vq , headcount ) ; //<S2SV> break ; //<S2SV> } //<S2SV> vhost_add_used_and_signal_n ( & net -> dev , vq , vq -> heads , //<S2SV> headcount ) ; //<S2SV> if ( unlikely ( vq_log ) ) //<S2SV> vhost_log_write ( vq , vq_log , log , vhost_len ) ; //<S2SV> total_len += vhost_len ; //<S2SV> if ( unlikely ( total_len >= VHOST_NET_WEIGHT ) ) { //<S2SV> vhost_poll_queue ( & vq -> poll ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> mutex_unlock ( & vq -> mutex ) ; //<S2SV> } //<S2SV> 