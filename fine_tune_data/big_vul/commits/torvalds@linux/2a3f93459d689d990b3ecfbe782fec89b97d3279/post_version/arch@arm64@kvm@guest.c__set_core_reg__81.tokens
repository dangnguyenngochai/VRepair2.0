static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) //<S2SV> { //<S2SV> __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; //<S2SV> struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; //<S2SV> int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; //<S2SV> __uint128_t tmp ; //<S2SV> void * valp = & tmp ; //<S2SV> u64 off ; //<S2SV> int err = 0 ; //<S2SV> off = core_reg_offset_from_id ( reg -> id ) ; //<S2SV> if ( off >= nr_regs || //<S2SV> ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) //<S2SV> return - ENOENT ; //<S2SV> if ( validate_core_offset ( reg ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { //<S2SV> err = - EFAULT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { //<S2SV> u64 mode = ( * ( u64 * ) valp ) & PSR_AA32_MODE_MASK ; //<S2SV> switch ( mode ) { //<S2SV> case PSR_AA32_MODE_USR : //<S2SV> if ( ! system_supports_32bit_el0 ( ) ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> case PSR_AA32_MODE_FIQ : //<S2SV> case PSR_AA32_MODE_IRQ : //<S2SV> case PSR_AA32_MODE_SVC : //<S2SV> case PSR_AA32_MODE_ABT : //<S2SV> case PSR_AA32_MODE_UND : //<S2SV> if ( ! vcpu_el1_is_32bit ( vcpu ) ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> case PSR_MODE_EL0t : //<S2SV> case PSR_MODE_EL1t : //<S2SV> case PSR_MODE_EL1h : //<S2SV> if ( vcpu_el1_is_32bit ( vcpu ) ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> default : //<S2SV> err = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 