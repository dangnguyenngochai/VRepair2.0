int rds_ib_xmit ( struct rds_connection * conn , struct rds_message * rm , //<S2SV> unsigned int hdr_off , unsigned int sg , unsigned int off ) //<S2SV> { //<S2SV> struct rds_ib_connection * ic = conn -> c_transport_data ; //<S2SV> struct ib_device * dev = ic -> i_cm_id -> device ; //<S2SV> struct rds_ib_send_work * send = NULL ; //<S2SV> struct rds_ib_send_work * first ; //<S2SV> struct rds_ib_send_work * prev ; //<S2SV> struct ib_send_wr * failed_wr ; //<S2SV> struct scatterlist * scat ; //<S2SV> u32 pos ; //<S2SV> u32 i ; //<S2SV> u32 work_alloc ; //<S2SV> u32 credit_alloc = 0 ; //<S2SV> u32 posted ; //<S2SV> u32 adv_credits = 0 ; //<S2SV> int send_flags = 0 ; //<S2SV> int bytes_sent = 0 ; //<S2SV> int ret ; //<S2SV> int flow_controlled = 0 ; //<S2SV> int nr_sig = 0 ; //<S2SV> BUG_ON ( off % RDS_FRAG_SIZE ) ; //<S2SV> BUG_ON ( hdr_off != 0 && hdr_off != sizeof ( struct rds_header ) ) ; //<S2SV> if ( conn -> c_loopback //<S2SV> && rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { //<S2SV> rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; //<S2SV> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; //<S2SV> } //<S2SV> if ( be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) == 0 ) //<S2SV> i = 1 ; //<S2SV> else //<S2SV> i = ceil ( be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) , RDS_FRAG_SIZE ) ; //<S2SV> work_alloc = rds_ib_ring_alloc ( & ic -> i_send_ring , i , & pos ) ; //<S2SV> if ( work_alloc == 0 ) { //<S2SV> set_bit ( RDS_LL_SEND_FULL , & conn -> c_flags ) ; //<S2SV> rds_ib_stats_inc ( s_ib_tx_ring_full ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ic -> i_flowctl ) { //<S2SV> credit_alloc = rds_ib_send_grab_credits ( ic , work_alloc , & posted , 0 , RDS_MAX_ADV_CREDIT ) ; //<S2SV> adv_credits += posted ; //<S2SV> if ( credit_alloc < work_alloc ) { //<S2SV> rds_ib_ring_unalloc ( & ic -> i_send_ring , work_alloc - credit_alloc ) ; //<S2SV> work_alloc = credit_alloc ; //<S2SV> flow_controlled = 1 ; //<S2SV> } //<S2SV> if ( work_alloc == 0 ) { //<S2SV> set_bit ( RDS_LL_SEND_FULL , & conn -> c_flags ) ; //<S2SV> rds_ib_stats_inc ( s_ib_tx_throttle ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ic -> i_data_op ) { //<S2SV> if ( rm -> data . op_nents ) { //<S2SV> rm -> data . op_count = ib_dma_map_sg ( dev , //<S2SV> rm -> data . op_sg , //<S2SV> rm -> data . op_nents , //<S2SV> DMA_TO_DEVICE ) ; //<S2SV> rdsdebug ( "ic<S2SV_blank>%p<S2SV_blank>mapping<S2SV_blank>rm<S2SV_blank>%p:<S2SV_blank>%d\\n" , ic , rm , rm -> data . op_count ) ; //<S2SV> if ( rm -> data . op_count == 0 ) { //<S2SV> rds_ib_stats_inc ( s_ib_tx_sg_mapping_failure ) ; //<S2SV> rds_ib_ring_unalloc ( & ic -> i_send_ring , work_alloc ) ; //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } else { //<S2SV> rm -> data . op_count = 0 ; //<S2SV> } //<S2SV> rds_message_addref ( rm ) ; //<S2SV> ic -> i_data_op = & rm -> data ; //<S2SV> if ( test_bit ( RDS_MSG_ACK_REQUIRED , & rm -> m_flags ) ) //<S2SV> rm -> m_inc . i_hdr . h_flags |= RDS_FLAG_ACK_REQUIRED ; //<S2SV> if ( test_bit ( RDS_MSG_RETRANSMITTED , & rm -> m_flags ) ) //<S2SV> rm -> m_inc . i_hdr . h_flags |= RDS_FLAG_RETRANSMITTED ; //<S2SV> if ( rm -> rdma . op_active ) { //<S2SV> struct rds_ext_header_rdma ext_hdr ; //<S2SV> ext_hdr . h_rdma_rkey = cpu_to_be32 ( rm -> rdma . op_rkey ) ; //<S2SV> rds_message_add_extension ( & rm -> m_inc . i_hdr , //<S2SV> RDS_EXTHDR_RDMA , & ext_hdr , sizeof ( ext_hdr ) ) ; //<S2SV> } //<S2SV> if ( rm -> m_rdma_cookie ) { //<S2SV> rds_message_add_rdma_dest_extension ( & rm -> m_inc . i_hdr , //<S2SV> rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , //<S2SV> rds_rdma_cookie_offset ( rm -> m_rdma_cookie ) ) ; //<S2SV> } //<S2SV> rm -> m_inc . i_hdr . h_ack = cpu_to_be64 ( rds_ib_piggyb_ack ( ic ) ) ; //<S2SV> rds_message_make_checksum ( & rm -> m_inc . i_hdr ) ; //<S2SV> if ( ic -> i_flowctl ) { //<S2SV> rds_ib_send_grab_credits ( ic , 0 , & posted , 1 , RDS_MAX_ADV_CREDIT - adv_credits ) ; //<S2SV> adv_credits += posted ; //<S2SV> BUG_ON ( adv_credits > 255 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( rm -> rdma . op_active && rm -> rdma . op_fence ) //<S2SV> send_flags = IB_SEND_FENCE ; //<S2SV> send = & ic -> i_sends [ pos ] ; //<S2SV> first = send ; //<S2SV> prev = NULL ; //<S2SV> scat = & ic -> i_data_op -> op_sg [ sg ] ; //<S2SV> i = 0 ; //<S2SV> do { //<S2SV> unsigned int len = 0 ; //<S2SV> send -> s_wr . send_flags = send_flags ; //<S2SV> send -> s_wr . opcode = IB_WR_SEND ; //<S2SV> send -> s_wr . num_sge = 1 ; //<S2SV> send -> s_wr . next = NULL ; //<S2SV> send -> s_queued = jiffies ; //<S2SV> send -> s_op = NULL ; //<S2SV> send -> s_sge [ 0 ] . addr = ic -> i_send_hdrs_dma //<S2SV> + ( pos * sizeof ( struct rds_header ) ) ; //<S2SV> send -> s_sge [ 0 ] . length = sizeof ( struct rds_header ) ; //<S2SV> memcpy ( & ic -> i_send_hdrs [ pos ] , & rm -> m_inc . i_hdr , sizeof ( struct rds_header ) ) ; //<S2SV> if ( i < work_alloc //<S2SV> && scat != & rm -> data . op_sg [ rm -> data . op_count ] ) { //<S2SV> len = min ( RDS_FRAG_SIZE , ib_sg_dma_len ( dev , scat ) - off ) ; //<S2SV> send -> s_wr . num_sge = 2 ; //<S2SV> send -> s_sge [ 1 ] . addr = ib_sg_dma_address ( dev , scat ) + off ; //<S2SV> send -> s_sge [ 1 ] . length = len ; //<S2SV> bytes_sent += len ; //<S2SV> off += len ; //<S2SV> if ( off == ib_sg_dma_len ( dev , scat ) ) { //<S2SV> scat ++ ; //<S2SV> off = 0 ; //<S2SV> } //<S2SV> } //<S2SV> rds_ib_set_wr_signal_state ( ic , send , 0 ) ; //<S2SV> if ( ic -> i_flowctl && flow_controlled && i == ( work_alloc - 1 ) ) //<S2SV> send -> s_wr . send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED ; //<S2SV> if ( send -> s_wr . send_flags & IB_SEND_SIGNALED ) //<S2SV> nr_sig ++ ; //<S2SV> rdsdebug ( "send<S2SV_blank>%p<S2SV_blank>wr<S2SV_blank>%p<S2SV_blank>num_sge<S2SV_blank>%u<S2SV_blank>next<S2SV_blank>%p\\n" , send , //<S2SV> & send -> s_wr , send -> s_wr . num_sge , send -> s_wr . next ) ; //<S2SV> if ( ic -> i_flowctl && adv_credits ) { //<S2SV> struct rds_header * hdr = & ic -> i_send_hdrs [ pos ] ; //<S2SV> hdr -> h_credit = adv_credits ; //<S2SV> rds_message_make_checksum ( hdr ) ; //<S2SV> adv_credits = 0 ; //<S2SV> rds_ib_stats_inc ( s_ib_tx_credit_updates ) ; //<S2SV> } //<S2SV> if ( prev ) //<S2SV> prev -> s_wr . next = & send -> s_wr ; //<S2SV> prev = send ; //<S2SV> pos = ( pos + 1 ) % ic -> i_send_ring . w_nr ; //<S2SV> send = & ic -> i_sends [ pos ] ; //<S2SV> i ++ ; //<S2SV> } while ( i < work_alloc //<S2SV> && scat != & rm -> data . op_sg [ rm -> data . op_count ] ) ; //<S2SV> if ( hdr_off == 0 ) //<S2SV> bytes_sent += sizeof ( struct rds_header ) ; //<S2SV> if ( scat == & rm -> data . op_sg [ rm -> data . op_count ] ) { //<S2SV> prev -> s_op = ic -> i_data_op ; //<S2SV> prev -> s_wr . send_flags |= IB_SEND_SOLICITED ; //<S2SV> ic -> i_data_op = NULL ; //<S2SV> } //<S2SV> if ( i < work_alloc ) { //<S2SV> rds_ib_ring_unalloc ( & ic -> i_send_ring , work_alloc - i ) ; //<S2SV> work_alloc = i ; //<S2SV> } //<S2SV> if ( ic -> i_flowctl && i < credit_alloc ) //<S2SV> rds_ib_send_add_credits ( conn , credit_alloc - i ) ; //<S2SV> if ( nr_sig ) //<S2SV> atomic_add ( nr_sig , & ic -> i_signaled_sends ) ; //<S2SV> failed_wr = & first -> s_wr ; //<S2SV> ret = ib_post_send ( ic -> i_cm_id -> qp , & first -> s_wr , & failed_wr ) ; //<S2SV> rdsdebug ( "ic<S2SV_blank>%p<S2SV_blank>first<S2SV_blank>%p<S2SV_blank>(wr<S2SV_blank>%p)<S2SV_blank>ret<S2SV_blank>%d<S2SV_blank>wr<S2SV_blank>%p\\n" , ic , //<S2SV> first , & first -> s_wr , ret , failed_wr ) ; //<S2SV> BUG_ON ( failed_wr != & first -> s_wr ) ; //<S2SV> if ( ret ) { //<S2SV> printk ( KERN_WARNING "RDS/IB:<S2SV_blank>ib_post_send<S2SV_blank>to<S2SV_blank>%pI4<S2SV_blank>" //<S2SV> "returned<S2SV_blank>%d\\n" , & conn -> c_faddr , ret ) ; //<S2SV> rds_ib_ring_unalloc ( & ic -> i_send_ring , work_alloc ) ; //<S2SV> rds_ib_sub_signaled ( ic , nr_sig ) ; //<S2SV> if ( prev -> s_op ) { //<S2SV> ic -> i_data_op = prev -> s_op ; //<S2SV> prev -> s_op = NULL ; //<S2SV> } //<S2SV> rds_ib_conn_error ( ic -> conn , "ib_post_send<S2SV_blank>failed\\n" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = bytes_sent ; //<S2SV> out : //<S2SV> BUG_ON ( adv_credits ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 