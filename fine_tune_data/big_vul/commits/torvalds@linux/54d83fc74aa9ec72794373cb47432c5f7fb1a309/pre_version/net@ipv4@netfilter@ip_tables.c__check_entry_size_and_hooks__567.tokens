static int //<S2SV> check_entry_size_and_hooks ( struct ipt_entry * e , //<S2SV> struct xt_table_info * newinfo , //<S2SV> const unsigned char * base , //<S2SV> const unsigned char * limit , //<S2SV> const unsigned int * hook_entries , //<S2SV> const unsigned int * underflows , //<S2SV> unsigned int valid_hooks ) //<S2SV> { //<S2SV> unsigned int h ; //<S2SV> int err ; //<S2SV> if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || //<S2SV> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || //<S2SV> ( unsigned char * ) e + e -> next_offset > limit ) { //<S2SV> duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( e -> next_offset //<S2SV> < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { //<S2SV> duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , //<S2SV> e , e -> next_offset ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_entry ( e ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { //<S2SV> if ( ! ( valid_hooks & ( 1 << h ) ) ) //<S2SV> continue ; //<S2SV> if ( ( unsigned char * ) e - base == hook_entries [ h ] ) //<S2SV> newinfo -> hook_entry [ h ] = hook_entries [ h ] ; //<S2SV> if ( ( unsigned char * ) e - base == underflows [ h ] ) { //<S2SV> if ( ! check_underflow ( e ) ) { //<S2SV> pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" //<S2SV> "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" //<S2SV> "ACCEPT/DROP\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> newinfo -> underflow [ h ] = underflows [ h ] ; //<S2SV> } //<S2SV> } //<S2SV> e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; //<S2SV> e -> comefrom = 0 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 