static int //<S2SV> mark_source_chains ( const struct xt_table_info * newinfo , //<S2SV> unsigned int valid_hooks , void * entry0 ) //<S2SV> { //<S2SV> unsigned int hook ; //<S2SV> for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { //<S2SV> unsigned int pos = newinfo -> hook_entry [ hook ] ; //<S2SV> struct ipt_entry * e = ( struct ipt_entry * ) ( entry0 + pos ) ; //<S2SV> if ( ! ( valid_hooks & ( 1 << hook ) ) ) //<S2SV> continue ; //<S2SV> e -> counters . pcnt = pos ; //<S2SV> for ( ; ; ) { //<S2SV> const struct xt_standard_target * t //<S2SV> = ( void * ) ipt_get_target_c ( e ) ; //<S2SV> int visited = e -> comefrom & ( 1 << hook ) ; //<S2SV> if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { //<S2SV> pr_err ( "iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n" , //<S2SV> hook , pos , e -> comefrom ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; //<S2SV> if ( ( unconditional ( e ) && //<S2SV> ( strcmp ( t -> target . u . user . name , //<S2SV> XT_STANDARD_TARGET ) == 0 ) && //<S2SV> t -> verdict < 0 ) || visited ) { //<S2SV> unsigned int oldpos , size ; //<S2SV> if ( ( strcmp ( t -> target . u . user . name , //<S2SV> XT_STANDARD_TARGET ) == 0 ) && //<S2SV> t -> verdict < - NF_MAX_VERDICT - 1 ) { //<S2SV> duprintf ( "mark_source_chains:<S2SV_blank>bad<S2SV_blank>" //<S2SV> "negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , //<S2SV> t -> verdict ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> do { //<S2SV> e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; //<S2SV> # ifdef DEBUG_IP_FIREWALL_USER //<S2SV> if ( e -> comefrom //<S2SV> & ( 1 << NF_INET_NUMHOOKS ) ) { //<S2SV> duprintf ( "Back<S2SV_blank>unset<S2SV_blank>" //<S2SV> "on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>" //<S2SV> "rule<S2SV_blank>%u\\n" , //<S2SV> hook , pos ) ; //<S2SV> } //<S2SV> # endif //<S2SV> oldpos = pos ; //<S2SV> pos = e -> counters . pcnt ; //<S2SV> e -> counters . pcnt = 0 ; //<S2SV> if ( pos == oldpos ) //<S2SV> goto next ; //<S2SV> e = ( struct ipt_entry * ) //<S2SV> ( entry0 + pos ) ; //<S2SV> } while ( oldpos == pos + e -> next_offset ) ; //<S2SV> size = e -> next_offset ; //<S2SV> e = ( struct ipt_entry * ) //<S2SV> ( entry0 + pos + size ) ; //<S2SV> e -> counters . pcnt = pos ; //<S2SV> pos += size ; //<S2SV> } else { //<S2SV> int newpos = t -> verdict ; //<S2SV> if ( strcmp ( t -> target . u . user . name , //<S2SV> XT_STANDARD_TARGET ) == 0 && //<S2SV> newpos >= 0 ) { //<S2SV> if ( newpos > newinfo -> size - //<S2SV> sizeof ( struct ipt_entry ) ) { //<S2SV> duprintf ( "mark_source_chains:<S2SV_blank>" //<S2SV> "bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , //<S2SV> newpos ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> duprintf ( "Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n" , //<S2SV> pos , newpos ) ; //<S2SV> } else { //<S2SV> newpos = pos + e -> next_offset ; //<S2SV> } //<S2SV> e = ( struct ipt_entry * ) //<S2SV> ( entry0 + newpos ) ; //<S2SV> e -> counters . pcnt = pos ; //<S2SV> pos = newpos ; //<S2SV> } //<S2SV> } //<S2SV> next : //<S2SV> duprintf ( "Finished<S2SV_blank>chain<S2SV_blank>%u\\n" , hook ) ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> } //<S2SV> 