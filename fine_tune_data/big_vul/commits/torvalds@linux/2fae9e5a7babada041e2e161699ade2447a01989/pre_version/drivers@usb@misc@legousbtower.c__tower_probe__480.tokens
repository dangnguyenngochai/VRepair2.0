static int tower_probe ( struct usb_interface * interface , const struct usb_device_id * id ) //<S2SV> { //<S2SV> struct device * idev = & interface -> dev ; //<S2SV> struct usb_device * udev = interface_to_usbdev ( interface ) ; //<S2SV> struct lego_usb_tower * dev = NULL ; //<S2SV> struct usb_host_interface * iface_desc ; //<S2SV> struct usb_endpoint_descriptor * endpoint ; //<S2SV> struct tower_get_version_reply get_version_reply ; //<S2SV> int i ; //<S2SV> int retval = - ENOMEM ; //<S2SV> int result ; //<S2SV> dev = kmalloc ( sizeof ( struct lego_usb_tower ) , GFP_KERNEL ) ; //<S2SV> if ( ! dev ) //<S2SV> goto exit ; //<S2SV> mutex_init ( & dev -> lock ) ; //<S2SV> dev -> udev = udev ; //<S2SV> dev -> open_count = 0 ; //<S2SV> dev -> read_buffer = NULL ; //<S2SV> dev -> read_buffer_length = 0 ; //<S2SV> dev -> read_packet_length = 0 ; //<S2SV> spin_lock_init ( & dev -> read_buffer_lock ) ; //<S2SV> dev -> packet_timeout_jiffies = msecs_to_jiffies ( packet_timeout ) ; //<S2SV> dev -> read_last_arrival = jiffies ; //<S2SV> init_waitqueue_head ( & dev -> read_wait ) ; //<S2SV> init_waitqueue_head ( & dev -> write_wait ) ; //<S2SV> dev -> interrupt_in_buffer = NULL ; //<S2SV> dev -> interrupt_in_endpoint = NULL ; //<S2SV> dev -> interrupt_in_urb = NULL ; //<S2SV> dev -> interrupt_in_running = 0 ; //<S2SV> dev -> interrupt_in_done = 0 ; //<S2SV> dev -> interrupt_out_buffer = NULL ; //<S2SV> dev -> interrupt_out_endpoint = NULL ; //<S2SV> dev -> interrupt_out_urb = NULL ; //<S2SV> dev -> interrupt_out_busy = 0 ; //<S2SV> iface_desc = interface -> cur_altsetting ; //<S2SV> for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { //<S2SV> endpoint = & iface_desc -> endpoint [ i ] . desc ; //<S2SV> if ( usb_endpoint_xfer_int ( endpoint ) ) { //<S2SV> if ( usb_endpoint_dir_in ( endpoint ) ) //<S2SV> dev -> interrupt_in_endpoint = endpoint ; //<S2SV> else //<S2SV> dev -> interrupt_out_endpoint = endpoint ; //<S2SV> } //<S2SV> } //<S2SV> if ( dev -> interrupt_in_endpoint == NULL ) { //<S2SV> dev_err ( idev , "interrupt<S2SV_blank>in<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( dev -> interrupt_out_endpoint == NULL ) { //<S2SV> dev_err ( idev , "interrupt<S2SV_blank>out<S2SV_blank>endpoint<S2SV_blank>not<S2SV_blank>found\\n" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> dev -> read_buffer = kmalloc ( read_buffer_size , GFP_KERNEL ) ; //<S2SV> if ( ! dev -> read_buffer ) //<S2SV> goto error ; //<S2SV> dev -> interrupt_in_buffer = kmalloc ( usb_endpoint_maxp ( dev -> interrupt_in_endpoint ) , GFP_KERNEL ) ; //<S2SV> if ( ! dev -> interrupt_in_buffer ) //<S2SV> goto error ; //<S2SV> dev -> interrupt_in_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! dev -> interrupt_in_urb ) //<S2SV> goto error ; //<S2SV> dev -> interrupt_out_buffer = kmalloc ( write_buffer_size , GFP_KERNEL ) ; //<S2SV> if ( ! dev -> interrupt_out_buffer ) //<S2SV> goto error ; //<S2SV> dev -> interrupt_out_urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; //<S2SV> if ( ! dev -> interrupt_out_urb ) //<S2SV> goto error ; //<S2SV> dev -> interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev -> interrupt_in_endpoint -> bInterval ; //<S2SV> dev -> interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev -> interrupt_out_endpoint -> bInterval ; //<S2SV> usb_set_intfdata ( interface , dev ) ; //<S2SV> retval = usb_register_dev ( interface , & tower_class ) ; //<S2SV> if ( retval ) { //<S2SV> dev_err ( idev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; //<S2SV> usb_set_intfdata ( interface , NULL ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> dev -> minor = interface -> minor ; //<S2SV> dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>" //<S2SV> "%d<S2SV_blank>minor<S2SV_blank>%d\\n" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , //<S2SV> USB_MAJOR , dev -> minor ) ; //<S2SV> result = usb_control_msg ( udev , //<S2SV> usb_rcvctrlpipe ( udev , 0 ) , //<S2SV> LEGO_USB_TOWER_REQUEST_GET_VERSION , //<S2SV> USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE , //<S2SV> 0 , //<S2SV> 0 , //<S2SV> & get_version_reply , //<S2SV> sizeof ( get_version_reply ) , //<S2SV> 1000 ) ; //<S2SV> if ( result < 0 ) { //<S2SV> dev_err ( idev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>get<S2SV_blank>version<S2SV_blank>control<S2SV_blank>request<S2SV_blank>failed\\n" ) ; //<S2SV> retval = result ; //<S2SV> goto error ; //<S2SV> } //<S2SV> dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>firmware<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d<S2SV_blank>" //<S2SV> "build<S2SV_blank>%d\\n" , get_version_reply . major , //<S2SV> get_version_reply . minor , //<S2SV> le16_to_cpu ( get_version_reply . build_no ) ) ; //<S2SV> exit : //<S2SV> return retval ; //<S2SV> error : //<S2SV> tower_delete ( dev ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 