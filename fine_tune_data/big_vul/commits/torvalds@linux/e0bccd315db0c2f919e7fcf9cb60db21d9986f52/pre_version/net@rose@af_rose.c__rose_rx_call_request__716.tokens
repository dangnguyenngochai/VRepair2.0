int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) //<S2SV> { //<S2SV> struct sock * sk ; //<S2SV> struct sock * make ; //<S2SV> struct rose_sock * make_rose ; //<S2SV> struct rose_facilities_struct facilities ; //<S2SV> int n , len ; //<S2SV> skb -> sk = NULL ; //<S2SV> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; //<S2SV> len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; //<S2SV> len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; //<S2SV> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { //<S2SV> rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; //<S2SV> if ( sk == NULL || sk_acceptq_is_full ( sk ) || //<S2SV> ( make = rose_make_new ( sk ) ) == NULL ) { //<S2SV> rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> skb -> sk = make ; //<S2SV> make -> sk_state = TCP_ESTABLISHED ; //<S2SV> make_rose = rose_sk ( make ) ; //<S2SV> make_rose -> lci = lci ; //<S2SV> make_rose -> dest_addr = facilities . dest_addr ; //<S2SV> make_rose -> dest_call = facilities . dest_call ; //<S2SV> make_rose -> dest_ndigis = facilities . dest_ndigis ; //<S2SV> for ( n = 0 ; n < facilities . dest_ndigis ; n ++ ) //<S2SV> make_rose -> dest_digis [ n ] = facilities . dest_digis [ n ] ; //<S2SV> make_rose -> source_addr = facilities . source_addr ; //<S2SV> make_rose -> source_call = facilities . source_call ; //<S2SV> make_rose -> source_ndigis = facilities . source_ndigis ; //<S2SV> for ( n = 0 ; n < facilities . source_ndigis ; n ++ ) //<S2SV> make_rose -> source_digis [ n ] = facilities . source_digis [ n ] ; //<S2SV> make_rose -> neighbour = neigh ; //<S2SV> make_rose -> device = dev ; //<S2SV> make_rose -> facilities = facilities ; //<S2SV> make_rose -> neighbour -> use ++ ; //<S2SV> if ( rose_sk ( sk ) -> defer ) { //<S2SV> make_rose -> state = ROSE_STATE_5 ; //<S2SV> } else { //<S2SV> rose_write_internal ( make , ROSE_CALL_ACCEPTED ) ; //<S2SV> make_rose -> state = ROSE_STATE_3 ; //<S2SV> rose_start_idletimer ( make ) ; //<S2SV> } //<S2SV> make_rose -> condition = 0x00 ; //<S2SV> make_rose -> vs = 0 ; //<S2SV> make_rose -> va = 0 ; //<S2SV> make_rose -> vr = 0 ; //<S2SV> make_rose -> vl = 0 ; //<S2SV> sk -> sk_ack_backlog ++ ; //<S2SV> rose_insert_socket ( make ) ; //<S2SV> skb_queue_head ( & sk -> sk_receive_queue , skb ) ; //<S2SV> rose_start_heartbeat ( make ) ; //<S2SV> if ( ! sock_flag ( sk , SOCK_DEAD ) ) //<S2SV> sk -> sk_data_ready ( sk , skb -> len ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> 