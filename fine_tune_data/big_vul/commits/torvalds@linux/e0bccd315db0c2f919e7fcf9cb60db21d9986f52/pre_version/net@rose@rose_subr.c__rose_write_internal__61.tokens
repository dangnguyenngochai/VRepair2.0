void rose_write_internal ( struct sock * sk , int frametype ) //<S2SV> { //<S2SV> struct rose_sock * rose = rose_sk ( sk ) ; //<S2SV> struct sk_buff * skb ; //<S2SV> unsigned char * dptr ; //<S2SV> unsigned char lci1 , lci2 ; //<S2SV> char buffer [ 100 ] ; //<S2SV> int len , faclen = 0 ; //<S2SV> len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; //<S2SV> switch ( frametype ) { //<S2SV> case ROSE_CALL_REQUEST : //<S2SV> len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; //<S2SV> faclen = rose_create_facilities ( buffer , rose ) ; //<S2SV> len += faclen ; //<S2SV> break ; //<S2SV> case ROSE_CALL_ACCEPTED : //<S2SV> case ROSE_CLEAR_REQUEST : //<S2SV> case ROSE_RESET_REQUEST : //<S2SV> len += 2 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) //<S2SV> return ; //<S2SV> skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; //<S2SV> dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; //<S2SV> lci1 = ( rose -> lci >> 8 ) & 0x0F ; //<S2SV> lci2 = ( rose -> lci >> 0 ) & 0xFF ; //<S2SV> switch ( frametype ) { //<S2SV> case ROSE_CALL_REQUEST : //<S2SV> * dptr ++ = ROSE_GFI | lci1 ; //<S2SV> * dptr ++ = lci2 ; //<S2SV> * dptr ++ = frametype ; //<S2SV> * dptr ++ = 0xAA ; //<S2SV> memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; //<S2SV> dptr += ROSE_ADDR_LEN ; //<S2SV> memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; //<S2SV> dptr += ROSE_ADDR_LEN ; //<S2SV> memcpy ( dptr , buffer , faclen ) ; //<S2SV> dptr += faclen ; //<S2SV> break ; //<S2SV> case ROSE_CALL_ACCEPTED : //<S2SV> * dptr ++ = ROSE_GFI | lci1 ; //<S2SV> * dptr ++ = lci2 ; //<S2SV> * dptr ++ = frametype ; //<S2SV> * dptr ++ = 0x00 ; //<S2SV> * dptr ++ = 0 ; //<S2SV> break ; //<S2SV> case ROSE_CLEAR_REQUEST : //<S2SV> * dptr ++ = ROSE_GFI | lci1 ; //<S2SV> * dptr ++ = lci2 ; //<S2SV> * dptr ++ = frametype ; //<S2SV> * dptr ++ = rose -> cause ; //<S2SV> * dptr ++ = rose -> diagnostic ; //<S2SV> break ; //<S2SV> case ROSE_RESET_REQUEST : //<S2SV> * dptr ++ = ROSE_GFI | lci1 ; //<S2SV> * dptr ++ = lci2 ; //<S2SV> * dptr ++ = frametype ; //<S2SV> * dptr ++ = ROSE_DTE_ORIGINATED ; //<S2SV> * dptr ++ = 0 ; //<S2SV> break ; //<S2SV> case ROSE_RR : //<S2SV> case ROSE_RNR : //<S2SV> * dptr ++ = ROSE_GFI | lci1 ; //<S2SV> * dptr ++ = lci2 ; //<S2SV> * dptr = frametype ; //<S2SV> * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; //<S2SV> break ; //<S2SV> case ROSE_CLEAR_CONFIRMATION : //<S2SV> case ROSE_RESET_CONFIRMATION : //<S2SV> * dptr ++ = ROSE_GFI | lci1 ; //<S2SV> * dptr ++ = lci2 ; //<S2SV> * dptr ++ = frametype ; //<S2SV> break ; //<S2SV> default : //<S2SV> printk ( KERN_ERR "ROSE:<S2SV_blank>rose_write_internal<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>frametype<S2SV_blank>%02X\\n" , frametype ) ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> return ; //<S2SV> } //<S2SV> rose_transmit_link ( skb , rose -> neighbour ) ; //<S2SV> } //<S2SV> 