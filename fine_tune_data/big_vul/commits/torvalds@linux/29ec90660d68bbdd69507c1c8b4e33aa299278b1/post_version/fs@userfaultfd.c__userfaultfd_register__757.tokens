static int userfaultfd_register ( struct userfaultfd_ctx * ctx , //<S2SV> unsigned long arg ) //<S2SV> { //<S2SV> struct mm_struct * mm = ctx -> mm ; //<S2SV> struct vm_area_struct * vma , * prev , * cur ; //<S2SV> int ret ; //<S2SV> struct uffdio_register uffdio_register ; //<S2SV> struct uffdio_register __user * user_uffdio_register ; //<S2SV> unsigned long vm_flags , new_flags ; //<S2SV> bool found ; //<S2SV> bool basic_ioctls ; //<S2SV> unsigned long start , end , vma_end ; //<S2SV> user_uffdio_register = ( struct uffdio_register __user * ) arg ; //<S2SV> ret = - EFAULT ; //<S2SV> if ( copy_from_user ( & uffdio_register , user_uffdio_register , //<S2SV> sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) //<S2SV> goto out ; //<S2SV> ret = - EINVAL ; //<S2SV> if ( ! uffdio_register . mode ) //<S2SV> goto out ; //<S2SV> if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | //<S2SV> UFFDIO_REGISTER_MODE_WP ) ) //<S2SV> goto out ; //<S2SV> vm_flags = 0 ; //<S2SV> if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) //<S2SV> vm_flags |= VM_UFFD_MISSING ; //<S2SV> if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { //<S2SV> vm_flags |= VM_UFFD_WP ; //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = validate_range ( mm , uffdio_register . range . start , //<S2SV> uffdio_register . range . len ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> start = uffdio_register . range . start ; //<S2SV> end = start + uffdio_register . range . len ; //<S2SV> ret = - ENOMEM ; //<S2SV> if ( ! mmget_not_zero ( mm ) ) //<S2SV> goto out ; //<S2SV> down_write ( & mm -> mmap_sem ) ; //<S2SV> vma = find_vma_prev ( mm , start , & prev ) ; //<S2SV> if ( ! vma ) //<S2SV> goto out_unlock ; //<S2SV> ret = - EINVAL ; //<S2SV> if ( vma -> vm_start >= end ) //<S2SV> goto out_unlock ; //<S2SV> if ( is_vm_hugetlb_page ( vma ) ) { //<S2SV> unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; //<S2SV> if ( start & ( vma_hpagesize - 1 ) ) //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> found = false ; //<S2SV> basic_ioctls = false ; //<S2SV> for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { //<S2SV> cond_resched ( ) ; //<S2SV> BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ //<S2SV> ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; //<S2SV> ret = - EINVAL ; //<S2SV> if ( ! vma_can_userfault ( cur ) ) //<S2SV> goto out_unlock ; //<S2SV> ret = - EPERM ; //<S2SV> if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) //<S2SV> goto out_unlock ; //<S2SV> if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && //<S2SV> end > cur -> vm_start ) { //<S2SV> unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; //<S2SV> ret = - EINVAL ; //<S2SV> if ( end & ( vma_hpagesize - 1 ) ) //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> ret = - EBUSY ; //<S2SV> if ( cur -> vm_userfaultfd_ctx . ctx && //<S2SV> cur -> vm_userfaultfd_ctx . ctx != ctx ) //<S2SV> goto out_unlock ; //<S2SV> if ( is_vm_hugetlb_page ( cur ) ) //<S2SV> basic_ioctls = true ; //<S2SV> found = true ; //<S2SV> } //<S2SV> BUG_ON ( ! found ) ; //<S2SV> if ( vma -> vm_start < start ) //<S2SV> prev = vma ; //<S2SV> ret = 0 ; //<S2SV> do { //<S2SV> cond_resched ( ) ; //<S2SV> BUG_ON ( ! vma_can_userfault ( vma ) ) ; //<S2SV> BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && //<S2SV> vma -> vm_userfaultfd_ctx . ctx != ctx ) ; //<S2SV> WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; //<S2SV> if ( vma -> vm_userfaultfd_ctx . ctx == ctx && //<S2SV> ( vma -> vm_flags & vm_flags ) == vm_flags ) //<S2SV> goto skip ; //<S2SV> if ( vma -> vm_start > start ) //<S2SV> start = vma -> vm_start ; //<S2SV> vma_end = min ( end , vma -> vm_end ) ; //<S2SV> new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; //<S2SV> prev = vma_merge ( mm , prev , start , vma_end , new_flags , //<S2SV> vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , //<S2SV> vma_policy ( vma ) , //<S2SV> ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; //<S2SV> if ( prev ) { //<S2SV> vma = prev ; //<S2SV> goto next ; //<S2SV> } //<S2SV> if ( vma -> vm_start < start ) { //<S2SV> ret = split_vma ( mm , vma , start , 1 ) ; //<S2SV> if ( ret ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( vma -> vm_end > end ) { //<S2SV> ret = split_vma ( mm , vma , end , 0 ) ; //<S2SV> if ( ret ) //<S2SV> break ; //<S2SV> } //<S2SV> next : //<S2SV> vma -> vm_flags = new_flags ; //<S2SV> vma -> vm_userfaultfd_ctx . ctx = ctx ; //<S2SV> skip : //<S2SV> prev = vma ; //<S2SV> start = vma -> vm_end ; //<S2SV> vma = vma -> vm_next ; //<S2SV> } while ( vma && vma -> vm_start < end ) ; //<S2SV> out_unlock : //<S2SV> up_write ( & mm -> mmap_sem ) ; //<S2SV> mmput ( mm ) ; //<S2SV> if ( ! ret ) { //<S2SV> if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : //<S2SV> UFFD_API_RANGE_IOCTLS , //<S2SV> & user_uffdio_register -> ioctls ) ) //<S2SV> ret = - EFAULT ; //<S2SV> } //<S2SV> out : //<S2SV> return ret ; //<S2SV> } //<S2SV> 