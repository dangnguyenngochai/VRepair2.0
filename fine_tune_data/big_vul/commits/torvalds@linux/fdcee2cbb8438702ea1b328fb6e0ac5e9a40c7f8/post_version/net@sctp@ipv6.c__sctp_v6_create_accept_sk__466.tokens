static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , //<S2SV> struct sctp_association * asoc , //<S2SV> bool kern ) //<S2SV> { //<S2SV> struct sock * newsk ; //<S2SV> struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; //<S2SV> struct sctp6_sock * newsctp6sk ; //<S2SV> struct ipv6_txoptions * opt ; //<S2SV> newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; //<S2SV> if ( ! newsk ) //<S2SV> goto out ; //<S2SV> sock_init_data ( NULL , newsk ) ; //<S2SV> sctp_copy_sock ( newsk , sk , asoc ) ; //<S2SV> sock_reset_flag ( sk , SOCK_ZAPPED ) ; //<S2SV> newsctp6sk = ( struct sctp6_sock * ) newsk ; //<S2SV> inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; //<S2SV> sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; //<S2SV> newnp = inet6_sk ( newsk ) ; //<S2SV> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; //<S2SV> newnp -> ipv6_mc_list = NULL ; //<S2SV> newnp -> ipv6_ac_list = NULL ; //<S2SV> newnp -> ipv6_fl_list = NULL ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> opt = rcu_dereference ( np -> opt ) ; //<S2SV> if ( opt ) //<S2SV> opt = ipv6_dup_options ( newsk , opt ) ; //<S2SV> RCU_INIT_POINTER ( newnp -> opt , opt ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; //<S2SV> newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; //<S2SV> sk_refcnt_debug_inc ( newsk ) ; //<S2SV> if ( newsk -> sk_prot -> init ( newsk ) ) { //<S2SV> sk_common_release ( newsk ) ; //<S2SV> newsk = NULL ; //<S2SV> } //<S2SV> out : //<S2SV> return newsk ; //<S2SV> } //<S2SV> 