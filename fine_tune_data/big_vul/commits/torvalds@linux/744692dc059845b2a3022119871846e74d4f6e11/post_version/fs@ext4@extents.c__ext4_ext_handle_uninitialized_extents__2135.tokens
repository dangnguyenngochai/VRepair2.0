static int //<S2SV> ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , //<S2SV> ext4_lblk_t iblock , unsigned int max_blocks , //<S2SV> struct ext4_ext_path * path , int flags , //<S2SV> unsigned int allocated , struct buffer_head * bh_result , //<S2SV> ext4_fsblk_t newblock ) //<S2SV> { //<S2SV> int ret = 0 ; //<S2SV> int err = 0 ; //<S2SV> ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; //<S2SV> ext_debug ( "ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical" //<S2SV> "block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%d,<S2SV_blank>allocated<S2SV_blank>%u" , //<S2SV> inode -> i_ino , ( unsigned long long ) iblock , max_blocks , //<S2SV> flags , allocated ) ; //<S2SV> ext4_ext_show_leaf ( inode , path ) ; //<S2SV> if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { //<S2SV> ret = ext4_split_unwritten_extents ( handle , //<S2SV> inode , path , iblock , //<S2SV> max_blocks , flags ) ; //<S2SV> if ( io ) //<S2SV> io -> flag = EXT4_IO_UNWRITTEN ; //<S2SV> else //<S2SV> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; //<S2SV> if ( ext4_should_dioread_nolock ( inode ) ) //<S2SV> set_buffer_uninit ( bh_result ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) { //<S2SV> ret = ext4_convert_unwritten_extents_endio ( handle , inode , //<S2SV> path ) ; //<S2SV> if ( ret >= 0 ) //<S2SV> ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; //<S2SV> goto out2 ; //<S2SV> } //<S2SV> if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) //<S2SV> goto map_out ; //<S2SV> if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { //<S2SV> set_buffer_unwritten ( bh_result ) ; //<S2SV> goto out1 ; //<S2SV> } //<S2SV> ret = ext4_ext_convert_to_initialized ( handle , inode , //<S2SV> path , iblock , //<S2SV> max_blocks ) ; //<S2SV> if ( ret >= 0 ) //<S2SV> ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; //<S2SV> out : //<S2SV> if ( ret <= 0 ) { //<S2SV> err = ret ; //<S2SV> goto out2 ; //<S2SV> } else //<S2SV> allocated = ret ; //<S2SV> set_buffer_new ( bh_result ) ; //<S2SV> if ( allocated > max_blocks ) { //<S2SV> unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , //<S2SV> newblock + max_blocks , //<S2SV> allocated - max_blocks ) ; //<S2SV> allocated = max_blocks ; //<S2SV> } //<S2SV> if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) //<S2SV> ext4_da_update_reserve_space ( inode , allocated , 0 ) ; //<S2SV> map_out : //<S2SV> set_buffer_mapped ( bh_result ) ; //<S2SV> out1 : //<S2SV> if ( allocated > max_blocks ) //<S2SV> allocated = max_blocks ; //<S2SV> ext4_ext_show_leaf ( inode , path ) ; //<S2SV> bh_result -> b_bdev = inode -> i_sb -> s_bdev ; //<S2SV> bh_result -> b_blocknr = newblock ; //<S2SV> out2 : //<S2SV> if ( path ) { //<S2SV> ext4_ext_drop_refs ( path ) ; //<S2SV> kfree ( path ) ; //<S2SV> } //<S2SV> return err ? err : allocated ; //<S2SV> } //<S2SV> 