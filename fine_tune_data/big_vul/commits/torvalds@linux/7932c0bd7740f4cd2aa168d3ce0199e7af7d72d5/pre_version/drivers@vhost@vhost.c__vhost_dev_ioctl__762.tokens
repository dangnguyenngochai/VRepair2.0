long vhost_dev_ioctl ( struct vhost_dev * d , unsigned int ioctl , void __user * argp ) //<S2SV> { //<S2SV> struct file * eventfp , * filep = NULL ; //<S2SV> struct eventfd_ctx * ctx = NULL ; //<S2SV> u64 p ; //<S2SV> long r ; //<S2SV> int i , fd ; //<S2SV> if ( ioctl == VHOST_SET_OWNER ) { //<S2SV> r = vhost_dev_set_owner ( d ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> r = vhost_dev_check_owner ( d ) ; //<S2SV> if ( r ) //<S2SV> goto done ; //<S2SV> switch ( ioctl ) { //<S2SV> case VHOST_SET_MEM_TABLE : //<S2SV> r = vhost_set_memory ( d , argp ) ; //<S2SV> break ; //<S2SV> case VHOST_SET_LOG_BASE : //<S2SV> if ( copy_from_user ( & p , argp , sizeof p ) ) { //<S2SV> r = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( u64 ) ( unsigned long ) p != p ) { //<S2SV> r = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( i = 0 ; i < d -> nvqs ; ++ i ) { //<S2SV> struct vhost_virtqueue * vq ; //<S2SV> void __user * base = ( void __user * ) ( unsigned long ) p ; //<S2SV> vq = d -> vqs [ i ] ; //<S2SV> mutex_lock ( & vq -> mutex ) ; //<S2SV> if ( vq -> private_data && ! vq_log_access_ok ( vq , base ) ) //<S2SV> r = - EFAULT ; //<S2SV> else //<S2SV> vq -> log_base = base ; //<S2SV> mutex_unlock ( & vq -> mutex ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case VHOST_SET_LOG_FD : //<S2SV> r = get_user ( fd , ( int __user * ) argp ) ; //<S2SV> if ( r < 0 ) //<S2SV> break ; //<S2SV> eventfp = fd == - 1 ? NULL : eventfd_fget ( fd ) ; //<S2SV> if ( IS_ERR ( eventfp ) ) { //<S2SV> r = PTR_ERR ( eventfp ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( eventfp != d -> log_file ) { //<S2SV> filep = d -> log_file ; //<S2SV> ctx = d -> log_ctx ; //<S2SV> d -> log_ctx = eventfp ? //<S2SV> eventfd_ctx_fileget ( eventfp ) : NULL ; //<S2SV> } else //<S2SV> filep = eventfp ; //<S2SV> for ( i = 0 ; i < d -> nvqs ; ++ i ) { //<S2SV> mutex_lock ( & d -> vqs [ i ] -> mutex ) ; //<S2SV> d -> vqs [ i ] -> log_ctx = d -> log_ctx ; //<S2SV> mutex_unlock ( & d -> vqs [ i ] -> mutex ) ; //<S2SV> } //<S2SV> if ( ctx ) //<S2SV> eventfd_ctx_put ( ctx ) ; //<S2SV> if ( filep ) //<S2SV> fput ( filep ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> r = - ENOIOCTLCMD ; //<S2SV> break ; //<S2SV> } //<S2SV> done : //<S2SV> return r ; //<S2SV> } //<S2SV> 