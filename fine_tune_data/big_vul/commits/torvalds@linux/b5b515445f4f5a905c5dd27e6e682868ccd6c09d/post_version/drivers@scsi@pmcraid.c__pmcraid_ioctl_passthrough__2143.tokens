static long pmcraid_ioctl_passthrough ( //<S2SV> struct pmcraid_instance * pinstance , //<S2SV> unsigned int ioctl_cmd , //<S2SV> unsigned int buflen , //<S2SV> unsigned long arg //<S2SV> ) //<S2SV> { //<S2SV> struct pmcraid_passthrough_ioctl_buffer * buffer ; //<S2SV> struct pmcraid_ioarcb * ioarcb ; //<S2SV> struct pmcraid_cmd * cmd ; //<S2SV> struct pmcraid_cmd * cancel_cmd ; //<S2SV> unsigned long request_buffer ; //<S2SV> unsigned long request_offset ; //<S2SV> unsigned long lock_flags ; //<S2SV> void * ioasa ; //<S2SV> u32 ioasc ; //<S2SV> int request_size ; //<S2SV> int buffer_size ; //<S2SV> u8 access , direction ; //<S2SV> int rc = 0 ; //<S2SV> if ( pinstance -> ioa_reset_in_progress ) { //<S2SV> rc = wait_event_interruptible_timeout ( //<S2SV> pinstance -> reset_wait_q , //<S2SV> ! pinstance -> ioa_reset_in_progress , //<S2SV> msecs_to_jiffies ( 10000 ) ) ; //<S2SV> if ( ! rc ) //<S2SV> return - ETIMEDOUT ; //<S2SV> else if ( rc < 0 ) //<S2SV> return - ERESTARTSYS ; //<S2SV> } //<S2SV> if ( pinstance -> ioa_state != IOA_STATE_OPERATIONAL ) { //<S2SV> pmcraid_err ( "IOA<S2SV_blank>is<S2SV_blank>not<S2SV_blank>operational\\n" ) ; //<S2SV> return - ENOTTY ; //<S2SV> } //<S2SV> buffer_size = sizeof ( struct pmcraid_passthrough_ioctl_buffer ) ; //<S2SV> buffer = kmalloc ( buffer_size , GFP_KERNEL ) ; //<S2SV> if ( ! buffer ) { //<S2SV> pmcraid_err ( "no<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>passthrough<S2SV_blank>buffer\\n" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> request_offset = //<S2SV> offsetof ( struct pmcraid_passthrough_ioctl_buffer , request_buffer ) ; //<S2SV> request_buffer = arg + request_offset ; //<S2SV> rc = __copy_from_user ( buffer , //<S2SV> ( struct pmcraid_passthrough_ioctl_buffer * ) arg , //<S2SV> sizeof ( struct pmcraid_passthrough_ioctl_buffer ) ) ; //<S2SV> ioasa = //<S2SV> ( void * ) ( arg + //<S2SV> offsetof ( struct pmcraid_passthrough_ioctl_buffer , ioasa ) ) ; //<S2SV> if ( rc ) { //<S2SV> pmcraid_err ( "ioctl:<S2SV_blank>can\'t<S2SV_blank>copy<S2SV_blank>passthrough<S2SV_blank>buffer\\n" ) ; //<S2SV> rc = - EFAULT ; //<S2SV> goto out_free_buffer ; //<S2SV> } //<S2SV> request_size = buffer -> ioarcb . data_transfer_length ; //<S2SV> if ( buffer -> ioarcb . request_flags0 & TRANSFER_DIR_WRITE ) { //<S2SV> access = VERIFY_READ ; //<S2SV> direction = DMA_TO_DEVICE ; //<S2SV> } else { //<S2SV> access = VERIFY_WRITE ; //<S2SV> direction = DMA_FROM_DEVICE ; //<S2SV> } //<S2SV> if ( request_size > 0 ) { //<S2SV> rc = access_ok ( access , arg , request_offset + request_size ) ; //<S2SV> if ( ! rc ) { //<S2SV> rc = - EFAULT ; //<S2SV> goto out_free_buffer ; //<S2SV> } //<S2SV> } else if ( request_size < 0 ) { //<S2SV> rc = - EINVAL ; //<S2SV> goto out_free_buffer ; //<S2SV> } //<S2SV> if ( buffer -> ioarcb . add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN ) { //<S2SV> rc = - EINVAL ; //<S2SV> goto out_free_buffer ; //<S2SV> } //<S2SV> cmd = pmcraid_get_free_cmd ( pinstance ) ; //<S2SV> if ( ! cmd ) { //<S2SV> pmcraid_err ( "free<S2SV_blank>command<S2SV_blank>block<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available\\n" ) ; //<S2SV> rc = - ENOMEM ; //<S2SV> goto out_free_buffer ; //<S2SV> } //<S2SV> cmd -> scsi_cmd = NULL ; //<S2SV> ioarcb = & ( cmd -> ioa_cb -> ioarcb ) ; //<S2SV> ioarcb -> resource_handle = buffer -> ioarcb . resource_handle ; //<S2SV> ioarcb -> data_transfer_length = buffer -> ioarcb . data_transfer_length ; //<S2SV> ioarcb -> cmd_timeout = buffer -> ioarcb . cmd_timeout ; //<S2SV> ioarcb -> request_type = buffer -> ioarcb . request_type ; //<S2SV> ioarcb -> request_flags0 = buffer -> ioarcb . request_flags0 ; //<S2SV> ioarcb -> request_flags1 = buffer -> ioarcb . request_flags1 ; //<S2SV> memcpy ( ioarcb -> cdb , buffer -> ioarcb . cdb , PMCRAID_MAX_CDB_LEN ) ; //<S2SV> if ( buffer -> ioarcb . add_cmd_param_length ) { //<S2SV> ioarcb -> add_cmd_param_length = //<S2SV> buffer -> ioarcb . add_cmd_param_length ; //<S2SV> ioarcb -> add_cmd_param_offset = //<S2SV> buffer -> ioarcb . add_cmd_param_offset ; //<S2SV> memcpy ( ioarcb -> add_data . u . add_cmd_params , //<S2SV> buffer -> ioarcb . add_data . u . add_cmd_params , //<S2SV> buffer -> ioarcb . add_cmd_param_length ) ; //<S2SV> } //<S2SV> ioarcb -> hrrq_id = atomic_add_return ( 1 , & ( pinstance -> last_message_id ) ) % //<S2SV> pinstance -> num_hrrq ; //<S2SV> if ( request_size ) { //<S2SV> rc = pmcraid_build_passthrough_ioadls ( cmd , //<S2SV> request_size , //<S2SV> direction ) ; //<S2SV> if ( rc ) { //<S2SV> pmcraid_err ( "couldn\'t<S2SV_blank>build<S2SV_blank>passthrough<S2SV_blank>ioadls\\n" ) ; //<S2SV> goto out_free_buffer ; //<S2SV> } //<S2SV> } else if ( request_size < 0 ) { //<S2SV> rc = - EINVAL ; //<S2SV> goto out_free_buffer ; //<S2SV> } //<S2SV> if ( direction == DMA_TO_DEVICE && request_size > 0 ) { //<S2SV> rc = pmcraid_copy_sglist ( cmd -> sglist , //<S2SV> request_buffer , //<S2SV> request_size , //<S2SV> direction ) ; //<S2SV> if ( rc ) { //<S2SV> pmcraid_err ( "failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>user<S2SV_blank>buffer\\n" ) ; //<S2SV> goto out_free_sglist ; //<S2SV> } //<S2SV> } //<S2SV> cmd -> cmd_done = pmcraid_internal_done ; //<S2SV> init_completion ( & cmd -> wait_for_completion ) ; //<S2SV> cmd -> completion_req = 1 ; //<S2SV> pmcraid_info ( "command(%d)<S2SV_blank>(CDB[0]<S2SV_blank>=<S2SV_blank>%x)<S2SV_blank>for<S2SV_blank>%x\\n" , //<S2SV> le32_to_cpu ( cmd -> ioa_cb -> ioarcb . response_handle ) >> 2 , //<S2SV> cmd -> ioa_cb -> ioarcb . cdb [ 0 ] , //<S2SV> le32_to_cpu ( cmd -> ioa_cb -> ioarcb . resource_handle ) ) ; //<S2SV> spin_lock_irqsave ( pinstance -> host -> host_lock , lock_flags ) ; //<S2SV> _pmcraid_fire_command ( cmd ) ; //<S2SV> spin_unlock_irqrestore ( pinstance -> host -> host_lock , lock_flags ) ; //<S2SV> buffer -> ioarcb . cmd_timeout = 0 ; //<S2SV> if ( buffer -> ioarcb . cmd_timeout == 0 ) { //<S2SV> wait_for_completion ( & cmd -> wait_for_completion ) ; //<S2SV> } else if ( ! wait_for_completion_timeout ( //<S2SV> & cmd -> wait_for_completion , //<S2SV> msecs_to_jiffies ( buffer -> ioarcb . cmd_timeout * 1000 ) ) ) { //<S2SV> pmcraid_info ( "aborting<S2SV_blank>cmd<S2SV_blank>%d<S2SV_blank>(CDB[0]<S2SV_blank>=<S2SV_blank>%x)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>timeout\\n" , //<S2SV> le32_to_cpu ( cmd -> ioa_cb -> ioarcb . response_handle >> 2 ) , //<S2SV> cmd -> ioa_cb -> ioarcb . cdb [ 0 ] ) ; //<S2SV> spin_lock_irqsave ( pinstance -> host -> host_lock , lock_flags ) ; //<S2SV> cancel_cmd = pmcraid_abort_cmd ( cmd ) ; //<S2SV> spin_unlock_irqrestore ( pinstance -> host -> host_lock , lock_flags ) ; //<S2SV> if ( cancel_cmd ) { //<S2SV> wait_for_completion ( & cancel_cmd -> wait_for_completion ) ; //<S2SV> ioasc = cancel_cmd -> ioa_cb -> ioasa . ioasc ; //<S2SV> pmcraid_return_cmd ( cancel_cmd ) ; //<S2SV> if ( ioasc == PMCRAID_IOASC_IOA_WAS_RESET || //<S2SV> PMCRAID_IOASC_SENSE_KEY ( ioasc ) == 0x00 ) { //<S2SV> if ( ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND ) //<S2SV> rc = - ETIMEDOUT ; //<S2SV> goto out_handle_response ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! wait_for_completion_timeout ( //<S2SV> & cmd -> wait_for_completion , //<S2SV> msecs_to_jiffies ( 150 * 1000 ) ) ) { //<S2SV> pmcraid_reset_bringup ( cmd -> drv_inst ) ; //<S2SV> rc = - ETIMEDOUT ; //<S2SV> } //<S2SV> } //<S2SV> out_handle_response : //<S2SV> if ( copy_to_user ( ioasa , & cmd -> ioa_cb -> ioasa , //<S2SV> sizeof ( struct pmcraid_ioasa ) ) ) { //<S2SV> pmcraid_err ( "failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>ioasa<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>user\\n" ) ; //<S2SV> rc = - EFAULT ; //<S2SV> } //<S2SV> else if ( direction == DMA_FROM_DEVICE && request_size > 0 ) { //<S2SV> rc = pmcraid_copy_sglist ( cmd -> sglist , //<S2SV> request_buffer , //<S2SV> request_size , //<S2SV> direction ) ; //<S2SV> if ( rc ) { //<S2SV> pmcraid_err ( "failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>user<S2SV_blank>buffer\\n" ) ; //<S2SV> rc = - EFAULT ; //<S2SV> } //<S2SV> } //<S2SV> out_free_sglist : //<S2SV> pmcraid_release_passthrough_ioadls ( cmd , request_size , direction ) ; //<S2SV> pmcraid_return_cmd ( cmd ) ; //<S2SV> out_free_buffer : //<S2SV> kfree ( buffer ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 