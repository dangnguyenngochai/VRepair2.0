static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) //<S2SV> { //<S2SV> u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; //<S2SV> struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; //<S2SV> struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; //<S2SV> u32 exit_reason = vmx -> exit_reason ; //<S2SV> trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , //<S2SV> vmcs_readl ( EXIT_QUALIFICATION ) , //<S2SV> vmx -> idt_vectoring_info , //<S2SV> intr_info , //<S2SV> vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , //<S2SV> KVM_ISA_VMX ) ; //<S2SV> if ( vmx -> nested . nested_run_pending ) //<S2SV> return false ; //<S2SV> if ( unlikely ( vmx -> fail ) ) { //<S2SV> pr_info_ratelimited ( "%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n" , __func__ , //<S2SV> vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; //<S2SV> return true ; //<S2SV> } //<S2SV> switch ( exit_reason ) { //<S2SV> case EXIT_REASON_EXCEPTION_NMI : //<S2SV> if ( is_nmi ( intr_info ) ) //<S2SV> return false ; //<S2SV> else if ( is_page_fault ( intr_info ) ) //<S2SV> return enable_ept ; //<S2SV> else if ( is_no_device ( intr_info ) && //<S2SV> ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) //<S2SV> return false ; //<S2SV> else if ( is_debug ( intr_info ) && //<S2SV> vcpu -> guest_debug & //<S2SV> ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) //<S2SV> return false ; //<S2SV> else if ( is_breakpoint ( intr_info ) && //<S2SV> vcpu -> guest_debug & KVM_GUESTDBG_USE_SW_BP ) //<S2SV> return false ; //<S2SV> return vmcs12 -> exception_bitmap & //<S2SV> ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; //<S2SV> case EXIT_REASON_EXTERNAL_INTERRUPT : //<S2SV> return false ; //<S2SV> case EXIT_REASON_TRIPLE_FAULT : //<S2SV> return true ; //<S2SV> case EXIT_REASON_PENDING_INTERRUPT : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; //<S2SV> case EXIT_REASON_NMI_WINDOW : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; //<S2SV> case EXIT_REASON_TASK_SWITCH : //<S2SV> return true ; //<S2SV> case EXIT_REASON_CPUID : //<S2SV> if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) //<S2SV> return false ; //<S2SV> return true ; //<S2SV> case EXIT_REASON_HLT : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; //<S2SV> case EXIT_REASON_INVD : //<S2SV> return true ; //<S2SV> case EXIT_REASON_INVLPG : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; //<S2SV> case EXIT_REASON_RDPMC : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; //<S2SV> case EXIT_REASON_RDTSC : case EXIT_REASON_RDTSCP : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; //<S2SV> case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : //<S2SV> case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : //<S2SV> case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : //<S2SV> case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : //<S2SV> case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : //<S2SV> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : //<S2SV> return true ; //<S2SV> case EXIT_REASON_CR_ACCESS : //<S2SV> return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; //<S2SV> case EXIT_REASON_DR_ACCESS : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; //<S2SV> case EXIT_REASON_IO_INSTRUCTION : //<S2SV> return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; //<S2SV> case EXIT_REASON_GDTR_IDTR : case EXIT_REASON_LDTR_TR : //<S2SV> return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_DESC ) ; //<S2SV> case EXIT_REASON_MSR_READ : //<S2SV> case EXIT_REASON_MSR_WRITE : //<S2SV> return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; //<S2SV> case EXIT_REASON_INVALID_STATE : //<S2SV> return true ; //<S2SV> case EXIT_REASON_MWAIT_INSTRUCTION : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; //<S2SV> case EXIT_REASON_MONITOR_TRAP_FLAG : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_TRAP_FLAG ) ; //<S2SV> case EXIT_REASON_MONITOR_INSTRUCTION : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; //<S2SV> case EXIT_REASON_PAUSE_INSTRUCTION : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || //<S2SV> nested_cpu_has2 ( vmcs12 , //<S2SV> SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; //<S2SV> case EXIT_REASON_MCE_DURING_VMENTRY : //<S2SV> return false ; //<S2SV> case EXIT_REASON_TPR_BELOW_THRESHOLD : //<S2SV> return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; //<S2SV> case EXIT_REASON_APIC_ACCESS : //<S2SV> return nested_cpu_has2 ( vmcs12 , //<S2SV> SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; //<S2SV> case EXIT_REASON_APIC_WRITE : //<S2SV> case EXIT_REASON_EOI_INDUCED : //<S2SV> return true ; //<S2SV> case EXIT_REASON_EPT_VIOLATION : //<S2SV> return false ; //<S2SV> case EXIT_REASON_EPT_MISCONFIG : //<S2SV> return false ; //<S2SV> case EXIT_REASON_WBINVD : //<S2SV> return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; //<S2SV> case EXIT_REASON_XSETBV : //<S2SV> return true ; //<S2SV> case EXIT_REASON_XSAVES : case EXIT_REASON_XRSTORS : //<S2SV> return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_XSAVES ) ; //<S2SV> case EXIT_REASON_PREEMPTION_TIMER : //<S2SV> return false ; //<S2SV> default : //<S2SV> return true ; //<S2SV> } //<S2SV> } //<S2SV> 