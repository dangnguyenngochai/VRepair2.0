void sctp_association_free ( struct sctp_association * asoc ) //<S2SV> { //<S2SV> struct sock * sk = asoc -> base . sk ; //<S2SV> struct sctp_transport * transport ; //<S2SV> struct list_head * pos , * temp ; //<S2SV> int i ; //<S2SV> if ( ! list_empty ( & asoc -> asocs ) ) { //<S2SV> list_del ( & asoc -> asocs ) ; //<S2SV> if ( sctp_style ( sk , TCP ) && sctp_sstate ( sk , LISTENING ) ) //<S2SV> sk -> sk_ack_backlog -- ; //<S2SV> } //<S2SV> asoc -> base . dead = true ; //<S2SV> sctp_outq_free ( & asoc -> outqueue ) ; //<S2SV> sctp_ulpq_free ( & asoc -> ulpq ) ; //<S2SV> sctp_inq_free ( & asoc -> base . inqueue ) ; //<S2SV> sctp_tsnmap_free ( & asoc -> peer . tsn_map ) ; //<S2SV> sctp_ssnmap_free ( asoc -> ssnmap ) ; //<S2SV> sctp_bind_addr_free ( & asoc -> base . bind_addr ) ; //<S2SV> for ( i = SCTP_EVENT_TIMEOUT_NONE ; i < SCTP_NUM_TIMEOUT_TYPES ; ++ i ) { //<S2SV> if ( del_timer ( & asoc -> timers [ i ] ) ) //<S2SV> sctp_association_put ( asoc ) ; //<S2SV> } //<S2SV> kfree ( asoc -> peer . cookie ) ; //<S2SV> kfree ( asoc -> peer . peer_random ) ; //<S2SV> kfree ( asoc -> peer . peer_chunks ) ; //<S2SV> kfree ( asoc -> peer . peer_hmacs ) ; //<S2SV> list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { //<S2SV> transport = list_entry ( pos , struct sctp_transport , transports ) ; //<S2SV> list_del_rcu ( pos ) ; //<S2SV> sctp_transport_free ( transport ) ; //<S2SV> } //<S2SV> asoc -> peer . transport_count = 0 ; //<S2SV> sctp_asconf_queue_teardown ( asoc ) ; //<S2SV> if ( asoc -> asconf_addr_del_pending != NULL ) //<S2SV> kfree ( asoc -> asconf_addr_del_pending ) ; //<S2SV> sctp_auth_destroy_keys ( & asoc -> endpoint_shared_keys ) ; //<S2SV> sctp_auth_key_put ( asoc -> asoc_shared_key ) ; //<S2SV> sctp_association_put ( asoc ) ; //<S2SV> } //<S2SV> 