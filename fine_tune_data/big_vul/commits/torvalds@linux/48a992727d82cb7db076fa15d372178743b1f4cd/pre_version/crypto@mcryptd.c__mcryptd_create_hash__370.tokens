static int mcryptd_create_hash ( struct crypto_template * tmpl , struct rtattr * * tb , //<S2SV> struct mcryptd_queue * queue ) //<S2SV> { //<S2SV> struct hashd_instance_ctx * ctx ; //<S2SV> struct ahash_instance * inst ; //<S2SV> struct hash_alg_common * halg ; //<S2SV> struct crypto_alg * alg ; //<S2SV> u32 type = 0 ; //<S2SV> u32 mask = 0 ; //<S2SV> int err ; //<S2SV> mcryptd_check_internal ( tb , & type , & mask ) ; //<S2SV> halg = ahash_attr_alg ( tb [ 1 ] , type , mask ) ; //<S2SV> if ( IS_ERR ( halg ) ) //<S2SV> return PTR_ERR ( halg ) ; //<S2SV> alg = & halg -> base ; //<S2SV> pr_debug ( "crypto:<S2SV_blank>mcryptd<S2SV_blank>hash<S2SV_blank>alg:<S2SV_blank>%s\\n" , alg -> cra_name ) ; //<S2SV> inst = mcryptd_alloc_instance ( alg , ahash_instance_headroom ( ) , //<S2SV> sizeof ( * ctx ) ) ; //<S2SV> err = PTR_ERR ( inst ) ; //<S2SV> if ( IS_ERR ( inst ) ) //<S2SV> goto out_put_alg ; //<S2SV> ctx = ahash_instance_ctx ( inst ) ; //<S2SV> ctx -> queue = queue ; //<S2SV> err = crypto_init_ahash_spawn ( & ctx -> spawn , halg , //<S2SV> ahash_crypto_instance ( inst ) ) ; //<S2SV> if ( err ) //<S2SV> goto out_free_inst ; //<S2SV> type = CRYPTO_ALG_ASYNC ; //<S2SV> if ( alg -> cra_flags & CRYPTO_ALG_INTERNAL ) //<S2SV> type |= CRYPTO_ALG_INTERNAL ; //<S2SV> inst -> alg . halg . base . cra_flags = type ; //<S2SV> inst -> alg . halg . digestsize = halg -> digestsize ; //<S2SV> inst -> alg . halg . statesize = halg -> statesize ; //<S2SV> inst -> alg . halg . base . cra_ctxsize = sizeof ( struct mcryptd_hash_ctx ) ; //<S2SV> inst -> alg . halg . base . cra_init = mcryptd_hash_init_tfm ; //<S2SV> inst -> alg . halg . base . cra_exit = mcryptd_hash_exit_tfm ; //<S2SV> inst -> alg . init = mcryptd_hash_init_enqueue ; //<S2SV> inst -> alg . update = mcryptd_hash_update_enqueue ; //<S2SV> inst -> alg . final = mcryptd_hash_final_enqueue ; //<S2SV> inst -> alg . finup = mcryptd_hash_finup_enqueue ; //<S2SV> inst -> alg . export = mcryptd_hash_export ; //<S2SV> inst -> alg . import = mcryptd_hash_import ; //<S2SV> inst -> alg . setkey = mcryptd_hash_setkey ; //<S2SV> inst -> alg . digest = mcryptd_hash_digest_enqueue ; //<S2SV> err = ahash_register_instance ( tmpl , inst ) ; //<S2SV> if ( err ) { //<S2SV> crypto_drop_ahash ( & ctx -> spawn ) ; //<S2SV> out_free_inst : //<S2SV> kfree ( inst ) ; //<S2SV> } //<S2SV> out_put_alg : //<S2SV> crypto_mod_put ( alg ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 