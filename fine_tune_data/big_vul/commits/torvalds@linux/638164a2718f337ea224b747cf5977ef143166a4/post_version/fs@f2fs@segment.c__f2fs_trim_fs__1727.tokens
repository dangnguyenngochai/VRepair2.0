int f2fs_trim_fs ( struct f2fs_sb_info * sbi , struct fstrim_range * range ) //<S2SV> { //<S2SV> __u64 start = F2FS_BYTES_TO_BLK ( range -> start ) ; //<S2SV> __u64 end = start + F2FS_BYTES_TO_BLK ( range -> len ) - 1 ; //<S2SV> unsigned int start_segno , end_segno ; //<S2SV> struct cp_control cpc ; //<S2SV> int err = 0 ; //<S2SV> if ( start >= MAX_BLKADDR ( sbi ) || range -> len < sbi -> blocksize ) //<S2SV> return - EINVAL ; //<S2SV> cpc . trimmed = 0 ; //<S2SV> if ( end <= MAIN_BLKADDR ( sbi ) ) //<S2SV> goto out ; //<S2SV> if ( is_sbi_flag_set ( sbi , SBI_NEED_FSCK ) ) { //<S2SV> f2fs_msg ( sbi -> sb , KERN_WARNING , //<S2SV> "Found<S2SV_blank>FS<S2SV_blank>corruption,<S2SV_blank>run<S2SV_blank>fsck<S2SV_blank>to<S2SV_blank>fix." ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> start_segno = ( start <= MAIN_BLKADDR ( sbi ) ) ? 0 : GET_SEGNO ( sbi , start ) ; //<S2SV> end_segno = ( end >= MAX_BLKADDR ( sbi ) ) ? MAIN_SEGS ( sbi ) - 1 : //<S2SV> GET_SEGNO ( sbi , end ) ; //<S2SV> cpc . reason = CP_DISCARD ; //<S2SV> cpc . trim_minlen = max_t ( __u64 , 1 , F2FS_BYTES_TO_BLK ( range -> minlen ) ) ; //<S2SV> for ( ; start_segno <= end_segno ; start_segno = cpc . trim_end + 1 ) { //<S2SV> cpc . trim_start = start_segno ; //<S2SV> if ( sbi -> discard_blks == 0 ) //<S2SV> break ; //<S2SV> else if ( sbi -> discard_blks < BATCHED_TRIM_BLOCKS ( sbi ) ) //<S2SV> cpc . trim_end = end_segno ; //<S2SV> else //<S2SV> cpc . trim_end = min_t ( unsigned int , //<S2SV> rounddown ( start_segno + //<S2SV> BATCHED_TRIM_SEGMENTS ( sbi ) , //<S2SV> sbi -> segs_per_sec ) - 1 , end_segno ) ; //<S2SV> mutex_lock ( & sbi -> gc_mutex ) ; //<S2SV> err = write_checkpoint ( sbi , & cpc ) ; //<S2SV> mutex_unlock ( & sbi -> gc_mutex ) ; //<S2SV> if ( err ) //<S2SV> break ; //<S2SV> schedule ( ) ; //<S2SV> } //<S2SV> mark_discard_range_all ( sbi ) ; //<S2SV> f2fs_wait_discard_bios ( sbi , false ) ; //<S2SV> out : //<S2SV> range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 