static int yam_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) //<S2SV> { //<S2SV> struct yam_port * yp = netdev_priv ( dev ) ; //<S2SV> struct yamdrv_ioctl_cfg yi ; //<S2SV> struct yamdrv_ioctl_mcs * ym ; //<S2SV> int ioctl_cmd ; //<S2SV> if ( copy_from_user ( & ioctl_cmd , ifr -> ifr_data , sizeof ( int ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( yp -> magic != YAM_MAGIC ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! capable ( CAP_NET_ADMIN ) ) //<S2SV> return - EPERM ; //<S2SV> if ( cmd != SIOCDEVPRIVATE ) //<S2SV> return - EINVAL ; //<S2SV> switch ( ioctl_cmd ) { //<S2SV> case SIOCYAMRESERVED : //<S2SV> return - EINVAL ; //<S2SV> case SIOCYAMSMCS : //<S2SV> if ( netif_running ( dev ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ( ym = kmalloc ( sizeof ( struct yamdrv_ioctl_mcs ) , GFP_KERNEL ) ) == NULL ) //<S2SV> return - ENOBUFS ; //<S2SV> if ( copy_from_user ( ym , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_mcs ) ) ) { //<S2SV> kfree ( ym ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> if ( ym -> bitrate > YAM_MAXBITRATE ) { //<S2SV> kfree ( ym ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; //<S2SV> kfree ( ym ) ; //<S2SV> break ; //<S2SV> case SIOCYAMSCFG : //<S2SV> if ( ! capable ( CAP_SYS_RAWIO ) ) //<S2SV> return - EPERM ; //<S2SV> if ( copy_from_user ( & yi , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ( yi . cfg . mask & YAM_BITRATE ) && netif_running ( dev ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ( yi . cfg . mask & YAM_BAUDRATE ) && netif_running ( dev ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( yi . cfg . mask & YAM_IOBASE ) { //<S2SV> yp -> iobase = yi . cfg . iobase ; //<S2SV> dev -> base_addr = yi . cfg . iobase ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_IRQ ) { //<S2SV> if ( yi . cfg . irq > 15 ) //<S2SV> return - EINVAL ; //<S2SV> yp -> irq = yi . cfg . irq ; //<S2SV> dev -> irq = yi . cfg . irq ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_BITRATE ) { //<S2SV> if ( yi . cfg . bitrate > YAM_MAXBITRATE ) //<S2SV> return - EINVAL ; //<S2SV> yp -> bitrate = yi . cfg . bitrate ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_BAUDRATE ) { //<S2SV> if ( yi . cfg . baudrate > YAM_MAXBAUDRATE ) //<S2SV> return - EINVAL ; //<S2SV> yp -> baudrate = yi . cfg . baudrate ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_MODE ) { //<S2SV> if ( yi . cfg . mode > YAM_MAXMODE ) //<S2SV> return - EINVAL ; //<S2SV> yp -> dupmode = yi . cfg . mode ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_HOLDDLY ) { //<S2SV> if ( yi . cfg . holddly > YAM_MAXHOLDDLY ) //<S2SV> return - EINVAL ; //<S2SV> yp -> holdd = yi . cfg . holddly ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_TXDELAY ) { //<S2SV> if ( yi . cfg . txdelay > YAM_MAXTXDELAY ) //<S2SV> return - EINVAL ; //<S2SV> yp -> txd = yi . cfg . txdelay ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_TXTAIL ) { //<S2SV> if ( yi . cfg . txtail > YAM_MAXTXTAIL ) //<S2SV> return - EINVAL ; //<S2SV> yp -> txtail = yi . cfg . txtail ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_PERSIST ) { //<S2SV> if ( yi . cfg . persist > YAM_MAXPERSIST ) //<S2SV> return - EINVAL ; //<S2SV> yp -> pers = yi . cfg . persist ; //<S2SV> } //<S2SV> if ( yi . cfg . mask & YAM_SLOTTIME ) { //<S2SV> if ( yi . cfg . slottime > YAM_MAXSLOTTIME ) //<S2SV> return - EINVAL ; //<S2SV> yp -> slot = yi . cfg . slottime ; //<S2SV> yp -> slotcnt = yp -> slot / 10 ; //<S2SV> } //<S2SV> break ; //<S2SV> case SIOCYAMGCFG : //<S2SV> memset ( & yi , 0 , sizeof ( yi ) ) ; //<S2SV> yi . cfg . mask = 0xffffffff ; //<S2SV> yi . cfg . iobase = yp -> iobase ; //<S2SV> yi . cfg . irq = yp -> irq ; //<S2SV> yi . cfg . bitrate = yp -> bitrate ; //<S2SV> yi . cfg . baudrate = yp -> baudrate ; //<S2SV> yi . cfg . mode = yp -> dupmode ; //<S2SV> yi . cfg . txdelay = yp -> txd ; //<S2SV> yi . cfg . holddly = yp -> holdd ; //<S2SV> yi . cfg . txtail = yp -> txtail ; //<S2SV> yi . cfg . persist = yp -> pers ; //<S2SV> yi . cfg . slottime = yp -> slot ; //<S2SV> if ( copy_to_user ( ifr -> ifr_data , & yi , sizeof ( struct yamdrv_ioctl_cfg ) ) ) //<S2SV> return - EFAULT ; //<S2SV> break ; //<S2SV> default : //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 