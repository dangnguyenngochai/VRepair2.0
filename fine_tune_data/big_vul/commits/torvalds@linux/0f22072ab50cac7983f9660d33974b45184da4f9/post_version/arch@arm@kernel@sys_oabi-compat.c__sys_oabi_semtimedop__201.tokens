asmlinkage long sys_oabi_semtimedop ( int semid , //<S2SV> struct oabi_sembuf __user * tsops , //<S2SV> unsigned nsops , //<S2SV> const struct timespec __user * timeout ) //<S2SV> { //<S2SV> struct sembuf * sops ; //<S2SV> struct timespec local_timeout ; //<S2SV> long err ; //<S2SV> int i ; //<S2SV> if ( nsops < 1 || nsops > SEMOPM ) //<S2SV> return - EINVAL ; //<S2SV> sops = kmalloc ( sizeof ( * sops ) * nsops , GFP_KERNEL ) ; //<S2SV> if ( ! sops ) //<S2SV> return - ENOMEM ; //<S2SV> err = 0 ; //<S2SV> for ( i = 0 ; i < nsops ; i ++ ) { //<S2SV> __get_user_error ( sops [ i ] . sem_num , & tsops -> sem_num , err ) ; //<S2SV> __get_user_error ( sops [ i ] . sem_op , & tsops -> sem_op , err ) ; //<S2SV> __get_user_error ( sops [ i ] . sem_flg , & tsops -> sem_flg , err ) ; //<S2SV> tsops ++ ; //<S2SV> } //<S2SV> if ( timeout ) { //<S2SV> err |= copy_from_user ( & local_timeout , timeout , sizeof ( * timeout ) ) ; //<S2SV> timeout = & local_timeout ; //<S2SV> } //<S2SV> if ( err ) { //<S2SV> err = - EFAULT ; //<S2SV> } else { //<S2SV> mm_segment_t fs = get_fs ( ) ; //<S2SV> set_fs ( KERNEL_DS ) ; //<S2SV> err = sys_semtimedop ( semid , sops , nsops , timeout ) ; //<S2SV> set_fs ( fs ) ; //<S2SV> } //<S2SV> kfree ( sops ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 