int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) //<S2SV> { //<S2SV> kuid_t euid ; //<S2SV> kgid_t egid ; //<S2SV> int id ; //<S2SV> int next_id = ids -> next_id ; //<S2SV> if ( size > IPCMNI ) //<S2SV> size = IPCMNI ; //<S2SV> if ( ids -> in_use >= size ) //<S2SV> return - ENOSPC ; //<S2SV> idr_preload ( GFP_KERNEL ) ; //<S2SV> spin_lock_init ( & new -> lock ) ; //<S2SV> new -> deleted = false ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> spin_lock ( & new -> lock ) ; //<S2SV> id = idr_alloc ( & ids -> ipcs_idr , new , //<S2SV> ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , //<S2SV> GFP_NOWAIT ) ; //<S2SV> idr_preload_end ( ) ; //<S2SV> if ( id < 0 ) { //<S2SV> spin_unlock ( & new -> lock ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> return id ; //<S2SV> } //<S2SV> ids -> in_use ++ ; //<S2SV> current_euid_egid ( & euid , & egid ) ; //<S2SV> new -> cuid = new -> uid = euid ; //<S2SV> new -> gid = new -> cgid = egid ; //<S2SV> if ( next_id < 0 ) { //<S2SV> new -> seq = ids -> seq ++ ; //<S2SV> if ( ids -> seq > IPCID_SEQ_MAX ) //<S2SV> ids -> seq = 0 ; //<S2SV> } else { //<S2SV> new -> seq = ipcid_to_seqx ( next_id ) ; //<S2SV> ids -> next_id = - 1 ; //<S2SV> } //<S2SV> new -> id = ipc_buildid ( id , new -> seq ) ; //<S2SV> return id ; //<S2SV> } //<S2SV> 