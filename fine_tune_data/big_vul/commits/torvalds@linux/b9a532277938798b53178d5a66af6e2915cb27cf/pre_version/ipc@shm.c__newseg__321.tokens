static int newseg ( struct ipc_namespace * ns , struct ipc_params * params ) //<S2SV> { //<S2SV> key_t key = params -> key ; //<S2SV> int shmflg = params -> flg ; //<S2SV> size_t size = params -> u . size ; //<S2SV> int error ; //<S2SV> struct shmid_kernel * shp ; //<S2SV> size_t numpages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; //<S2SV> struct file * file ; //<S2SV> char name [ 13 ] ; //<S2SV> int id ; //<S2SV> vm_flags_t acctflag = 0 ; //<S2SV> if ( size < SHMMIN || size > ns -> shm_ctlmax ) //<S2SV> return - EINVAL ; //<S2SV> if ( numpages << PAGE_SHIFT < size ) //<S2SV> return - ENOSPC ; //<S2SV> if ( ns -> shm_tot + numpages < ns -> shm_tot || //<S2SV> ns -> shm_tot + numpages > ns -> shm_ctlall ) //<S2SV> return - ENOSPC ; //<S2SV> shp = ipc_rcu_alloc ( sizeof ( * shp ) ) ; //<S2SV> if ( ! shp ) //<S2SV> return - ENOMEM ; //<S2SV> shp -> shm_perm . key = key ; //<S2SV> shp -> shm_perm . mode = ( shmflg & S_IRWXUGO ) ; //<S2SV> shp -> mlock_user = NULL ; //<S2SV> shp -> shm_perm . security = NULL ; //<S2SV> error = security_shm_alloc ( shp ) ; //<S2SV> if ( error ) { //<S2SV> ipc_rcu_putref ( shp , ipc_rcu_free ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> sprintf ( name , "SYSV%08x" , key ) ; //<S2SV> if ( shmflg & SHM_HUGETLB ) { //<S2SV> struct hstate * hs ; //<S2SV> size_t hugesize ; //<S2SV> hs = hstate_sizelog ( ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; //<S2SV> if ( ! hs ) { //<S2SV> error = - EINVAL ; //<S2SV> goto no_file ; //<S2SV> } //<S2SV> hugesize = ALIGN ( size , huge_page_size ( hs ) ) ; //<S2SV> if ( shmflg & SHM_NORESERVE ) //<S2SV> acctflag = VM_NORESERVE ; //<S2SV> file = hugetlb_file_setup ( name , hugesize , acctflag , //<S2SV> & shp -> mlock_user , HUGETLB_SHMFS_INODE , //<S2SV> ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; //<S2SV> } else { //<S2SV> if ( ( shmflg & SHM_NORESERVE ) && //<S2SV> sysctl_overcommit_memory != OVERCOMMIT_NEVER ) //<S2SV> acctflag = VM_NORESERVE ; //<S2SV> file = shmem_kernel_file_setup ( name , size , acctflag ) ; //<S2SV> } //<S2SV> error = PTR_ERR ( file ) ; //<S2SV> if ( IS_ERR ( file ) ) //<S2SV> goto no_file ; //<S2SV> id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ; //<S2SV> if ( id < 0 ) { //<S2SV> error = id ; //<S2SV> goto no_id ; //<S2SV> } //<S2SV> shp -> shm_cprid = task_tgid_vnr ( current ) ; //<S2SV> shp -> shm_lprid = 0 ; //<S2SV> shp -> shm_atim = shp -> shm_dtim = 0 ; //<S2SV> shp -> shm_ctim = get_seconds ( ) ; //<S2SV> shp -> shm_segsz = size ; //<S2SV> shp -> shm_nattch = 0 ; //<S2SV> shp -> shm_file = file ; //<S2SV> shp -> shm_creator = current ; //<S2SV> list_add ( & shp -> shm_clist , & current -> sysvshm . shm_clist ) ; //<S2SV> file_inode ( file ) -> i_ino = shp -> shm_perm . id ; //<S2SV> ns -> shm_tot += numpages ; //<S2SV> error = shp -> shm_perm . id ; //<S2SV> ipc_unlock_object ( & shp -> shm_perm ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> return error ; //<S2SV> no_id : //<S2SV> if ( is_file_hugepages ( file ) && shp -> mlock_user ) //<S2SV> user_shm_unlock ( size , shp -> mlock_user ) ; //<S2SV> fput ( file ) ; //<S2SV> no_file : //<S2SV> ipc_rcu_putref ( shp , shm_rcu_free ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 