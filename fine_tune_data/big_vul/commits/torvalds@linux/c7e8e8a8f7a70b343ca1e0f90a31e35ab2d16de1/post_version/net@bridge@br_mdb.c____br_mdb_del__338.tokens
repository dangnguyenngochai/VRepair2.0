static int __br_mdb_del ( struct net_bridge * br , struct br_mdb_entry * entry ) //<S2SV> { //<S2SV> struct net_bridge_mdb_htable * mdb ; //<S2SV> struct net_bridge_mdb_entry * mp ; //<S2SV> struct net_bridge_port_group * p ; //<S2SV> struct net_bridge_port_group __rcu * * pp ; //<S2SV> struct br_ip ip ; //<S2SV> int err = - EINVAL ; //<S2SV> if ( ! netif_running ( br -> dev ) || br -> multicast_disabled ) //<S2SV> return - EINVAL ; //<S2SV> if ( timer_pending ( & br -> multicast_querier_timer ) ) //<S2SV> return - EBUSY ; //<S2SV> ip . proto = entry -> addr . proto ; //<S2SV> if ( ip . proto == htons ( ETH_P_IP ) ) //<S2SV> ip . u . ip4 = entry -> addr . u . ip4 ; //<S2SV> # if IS_ENABLED ( CONFIG_IPV6 ) //<S2SV> else //<S2SV> ip . u . ip6 = entry -> addr . u . ip6 ; //<S2SV> # endif //<S2SV> spin_lock_bh ( & br -> multicast_lock ) ; //<S2SV> mdb = mlock_dereference ( br -> mdb , br ) ; //<S2SV> mp = br_mdb_ip_get ( mdb , & ip ) ; //<S2SV> if ( ! mp ) //<S2SV> goto unlock ; //<S2SV> for ( pp = & mp -> ports ; //<S2SV> ( p = mlock_dereference ( * pp , br ) ) != NULL ; //<S2SV> pp = & p -> next ) { //<S2SV> if ( ! p -> port || p -> port -> dev -> ifindex != entry -> ifindex ) //<S2SV> continue ; //<S2SV> if ( p -> port -> state == BR_STATE_DISABLED ) //<S2SV> goto unlock ; //<S2SV> rcu_assign_pointer ( * pp , p -> next ) ; //<S2SV> hlist_del_init ( & p -> mglist ) ; //<S2SV> del_timer ( & p -> timer ) ; //<S2SV> call_rcu_bh ( & p -> rcu , br_multicast_free_pg ) ; //<S2SV> err = 0 ; //<S2SV> if ( ! mp -> ports && ! mp -> mglist && mp -> timer_armed && //<S2SV> netif_running ( br -> dev ) ) //<S2SV> mod_timer ( & mp -> timer , jiffies ) ; //<S2SV> break ; //<S2SV> } //<S2SV> unlock : //<S2SV> spin_unlock_bh ( & br -> multicast_lock ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 