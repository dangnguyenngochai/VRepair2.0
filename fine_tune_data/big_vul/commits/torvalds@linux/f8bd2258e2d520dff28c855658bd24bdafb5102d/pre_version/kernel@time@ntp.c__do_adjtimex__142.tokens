int do_adjtimex ( struct timex * txc ) //<S2SV> { //<S2SV> long mtemp , save_adjust , rem ; //<S2SV> s64 freq_adj ; //<S2SV> int result ; //<S2SV> if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) //<S2SV> return - EPERM ; //<S2SV> if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { //<S2SV> if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && //<S2SV> txc -> modes != ADJ_OFFSET_SS_READ ) //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) //<S2SV> if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) //<S2SV> return - EINVAL ; //<S2SV> if ( txc -> modes & ADJ_TICK ) //<S2SV> if ( txc -> tick < 900000 / USER_HZ || //<S2SV> txc -> tick > 1100000 / USER_HZ ) //<S2SV> return - EINVAL ; //<S2SV> write_seqlock_irq ( & xtime_lock ) ; //<S2SV> result = time_state ; //<S2SV> save_adjust = time_adjust ; //<S2SV> # if 0 //<S2SV> time_status &= ~ STA_CLOCKERR ; //<S2SV> # endif //<S2SV> if ( txc -> modes ) //<S2SV> { //<S2SV> if ( txc -> modes & ADJ_STATUS ) //<S2SV> time_status = ( txc -> status & ~ STA_RONLY ) | //<S2SV> ( time_status & STA_RONLY ) ; //<S2SV> if ( txc -> modes & ADJ_FREQUENCY ) { //<S2SV> if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { //<S2SV> result = - EINVAL ; //<S2SV> goto leave ; //<S2SV> } //<S2SV> time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) //<S2SV> >> ( SHIFT_USEC - SHIFT_NSEC ) ; //<S2SV> } //<S2SV> if ( txc -> modes & ADJ_MAXERROR ) { //<S2SV> if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { //<S2SV> result = - EINVAL ; //<S2SV> goto leave ; //<S2SV> } //<S2SV> time_maxerror = txc -> maxerror ; //<S2SV> } //<S2SV> if ( txc -> modes & ADJ_ESTERROR ) { //<S2SV> if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { //<S2SV> result = - EINVAL ; //<S2SV> goto leave ; //<S2SV> } //<S2SV> time_esterror = txc -> esterror ; //<S2SV> } //<S2SV> if ( txc -> modes & ADJ_TIMECONST ) { //<S2SV> if ( txc -> constant < 0 ) { //<S2SV> result = - EINVAL ; //<S2SV> goto leave ; //<S2SV> } //<S2SV> time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; //<S2SV> } //<S2SV> if ( txc -> modes & ADJ_OFFSET ) { //<S2SV> if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { //<S2SV> time_adjust = txc -> offset ; //<S2SV> } //<S2SV> else if ( time_status & STA_PLL ) { //<S2SV> time_offset = txc -> offset * NSEC_PER_USEC ; //<S2SV> time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; //<S2SV> time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; //<S2SV> if ( time_status & STA_FREQHOLD || time_reftime == 0 ) //<S2SV> time_reftime = xtime . tv_sec ; //<S2SV> mtemp = xtime . tv_sec - time_reftime ; //<S2SV> time_reftime = xtime . tv_sec ; //<S2SV> freq_adj = time_offset * mtemp ; //<S2SV> freq_adj = shift_right ( freq_adj , time_constant * 2 + //<S2SV> ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; //<S2SV> if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) //<S2SV> freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; //<S2SV> freq_adj += time_freq ; //<S2SV> freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; //<S2SV> time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ; //<S2SV> time_offset = div_long_long_rem_signed ( time_offset , //<S2SV> NTP_INTERVAL_FREQ , //<S2SV> & rem ) ; //<S2SV> time_offset <<= SHIFT_UPDATE ; //<S2SV> } //<S2SV> } //<S2SV> if ( txc -> modes & ADJ_TICK ) //<S2SV> tick_usec = txc -> tick ; //<S2SV> if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) //<S2SV> ntp_update_frequency ( ) ; //<S2SV> } //<S2SV> leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) //<S2SV> result = TIME_ERROR ; //<S2SV> if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || //<S2SV> ( txc -> modes == ADJ_OFFSET_SS_READ ) ) //<S2SV> txc -> offset = save_adjust ; //<S2SV> else //<S2SV> txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * //<S2SV> NTP_INTERVAL_FREQ / 1000 ; //<S2SV> txc -> freq = ( time_freq / NSEC_PER_USEC ) << //<S2SV> ( SHIFT_USEC - SHIFT_NSEC ) ; //<S2SV> txc -> maxerror = time_maxerror ; //<S2SV> txc -> esterror = time_esterror ; //<S2SV> txc -> status = time_status ; //<S2SV> txc -> constant = time_constant ; //<S2SV> txc -> precision = 1 ; //<S2SV> txc -> tolerance = MAXFREQ ; //<S2SV> txc -> tick = tick_usec ; //<S2SV> txc -> ppsfreq = 0 ; //<S2SV> txc -> jitter = 0 ; //<S2SV> txc -> shift = 0 ; //<S2SV> txc -> stabil = 0 ; //<S2SV> txc -> jitcnt = 0 ; //<S2SV> txc -> calcnt = 0 ; //<S2SV> txc -> errcnt = 0 ; //<S2SV> txc -> stbcnt = 0 ; //<S2SV> write_sequnlock_irq ( & xtime_lock ) ; //<S2SV> do_gettimeofday ( & txc -> time ) ; //<S2SV> notify_cmos_timer ( ) ; //<S2SV> return ( result ) ; //<S2SV> } //<S2SV> 