static int sgi_timer_set ( struct k_itimer * timr , int flags , //<S2SV> struct itimerspec * new_setting , //<S2SV> struct itimerspec * old_setting ) //<S2SV> { //<S2SV> unsigned long when , period , irqflags ; //<S2SV> int err = 0 ; //<S2SV> cnodeid_t nodeid ; //<S2SV> struct mmtimer * base ; //<S2SV> struct rb_node * n ; //<S2SV> if ( old_setting ) //<S2SV> sgi_timer_get ( timr , old_setting ) ; //<S2SV> sgi_timer_del ( timr ) ; //<S2SV> when = timespec_to_ns ( & new_setting -> it_value ) ; //<S2SV> period = timespec_to_ns ( & new_setting -> it_interval ) ; //<S2SV> if ( when == 0 ) //<S2SV> return 0 ; //<S2SV> base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; //<S2SV> if ( base == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> if ( flags & TIMER_ABSTIME ) { //<S2SV> struct timespec n ; //<S2SV> unsigned long now ; //<S2SV> getnstimeofday ( & n ) ; //<S2SV> now = timespec_to_ns ( & n ) ; //<S2SV> if ( when > now ) //<S2SV> when -= now ; //<S2SV> else //<S2SV> when = 0 ; //<S2SV> } //<S2SV> when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; //<S2SV> period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; //<S2SV> preempt_disable ( ) ; //<S2SV> nodeid = cpu_to_node ( smp_processor_id ( ) ) ; //<S2SV> spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; //<S2SV> base -> timer = timr ; //<S2SV> base -> cpu = smp_processor_id ( ) ; //<S2SV> timr -> it . mmtimer . clock = TIMER_SET ; //<S2SV> timr -> it . mmtimer . node = nodeid ; //<S2SV> timr -> it . mmtimer . incr = period ; //<S2SV> timr -> it . mmtimer . expires = when ; //<S2SV> n = timers [ nodeid ] . next ; //<S2SV> mmtimer_add_list ( base ) ; //<S2SV> if ( timers [ nodeid ] . next == n ) { //<S2SV> spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; //<S2SV> preempt_enable ( ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> if ( n ) //<S2SV> mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; //<S2SV> mmtimer_set_next_timer ( nodeid ) ; //<S2SV> spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; //<S2SV> preempt_enable ( ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 