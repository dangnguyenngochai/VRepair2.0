int //<S2SV> SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) //<S2SV> { //<S2SV> struct smb_rqst rqst ; //<S2SV> struct smb2_negotiate_req * req ; //<S2SV> struct smb2_negotiate_rsp * rsp ; //<S2SV> struct kvec iov [ 1 ] ; //<S2SV> struct kvec rsp_iov ; //<S2SV> int rc = 0 ; //<S2SV> int resp_buftype ; //<S2SV> struct TCP_Server_Info * server = ses -> server ; //<S2SV> int blob_offset , blob_length ; //<S2SV> char * security_blob ; //<S2SV> int flags = CIFS_NEG_OP ; //<S2SV> unsigned int total_len ; //<S2SV> cifs_dbg ( FYI , "Negotiate<S2SV_blank>protocol\\n" ) ; //<S2SV> if ( ! server ) { //<S2SV> WARN ( 1 , "%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\n" , __func__ ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; //<S2SV> if ( rc ) //<S2SV> return rc ; //<S2SV> req -> sync_hdr . SessionId = 0 ; //<S2SV> memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; //<S2SV> memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; //<S2SV> if ( strcmp ( ses -> server -> vals -> version_string , //<S2SV> SMB3ANY_VERSION_STRING ) == 0 ) { //<S2SV> req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; //<S2SV> req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; //<S2SV> req -> DialectCount = cpu_to_le16 ( 2 ) ; //<S2SV> total_len += 4 ; //<S2SV> } else if ( strcmp ( ses -> server -> vals -> version_string , //<S2SV> SMBDEFAULT_VERSION_STRING ) == 0 ) { //<S2SV> req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; //<S2SV> req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; //<S2SV> req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; //<S2SV> req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; //<S2SV> req -> DialectCount = cpu_to_le16 ( 4 ) ; //<S2SV> total_len += 8 ; //<S2SV> } else { //<S2SV> req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; //<S2SV> req -> DialectCount = cpu_to_le16 ( 1 ) ; //<S2SV> total_len += 2 ; //<S2SV> } //<S2SV> if ( ses -> sign ) //<S2SV> req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; //<S2SV> else if ( global_secflags & CIFSSEC_MAY_SIGN ) //<S2SV> req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; //<S2SV> else //<S2SV> req -> SecurityMode = 0 ; //<S2SV> req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; //<S2SV> if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) //<S2SV> memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; //<S2SV> else { //<S2SV> memcpy ( req -> ClientGUID , server -> client_guid , //<S2SV> SMB2_CLIENT_GUID_SIZE ) ; //<S2SV> if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || //<S2SV> ( strcmp ( ses -> server -> vals -> version_string , //<S2SV> SMBDEFAULT_VERSION_STRING ) == 0 ) ) //<S2SV> assemble_neg_contexts ( req , & total_len ) ; //<S2SV> } //<S2SV> iov [ 0 ] . iov_base = ( char * ) req ; //<S2SV> iov [ 0 ] . iov_len = total_len ; //<S2SV> memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; //<S2SV> rqst . rq_iov = iov ; //<S2SV> rqst . rq_nvec = 1 ; //<S2SV> rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; //<S2SV> cifs_small_buf_release ( req ) ; //<S2SV> rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; //<S2SV> if ( rc == - EOPNOTSUPP ) { //<S2SV> cifs_dbg ( VFS , "Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>" //<S2SV> "specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing" //<S2SV> "<S2SV_blank>older<S2SV_blank>servers\\n" ) ; //<S2SV> goto neg_exit ; //<S2SV> } else if ( rc != 0 ) //<S2SV> goto neg_exit ; //<S2SV> if ( strcmp ( ses -> server -> vals -> version_string , //<S2SV> SMB3ANY_VERSION_STRING ) == 0 ) { //<S2SV> if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { //<S2SV> cifs_dbg ( VFS , //<S2SV> "SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; //<S2SV> return - EIO ; //<S2SV> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { //<S2SV> cifs_dbg ( VFS , //<S2SV> "SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> } else if ( strcmp ( ses -> server -> vals -> version_string , //<S2SV> SMBDEFAULT_VERSION_STRING ) == 0 ) { //<S2SV> if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { //<S2SV> cifs_dbg ( VFS , //<S2SV> "SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n" ) ; //<S2SV> return - EIO ; //<S2SV> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { //<S2SV> ses -> server -> ops = & smb21_operations ; //<S2SV> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) //<S2SV> ses -> server -> ops = & smb311_operations ; //<S2SV> } else if ( le16_to_cpu ( rsp -> DialectRevision ) != //<S2SV> ses -> server -> vals -> protocol_id ) { //<S2SV> cifs_dbg ( VFS , "Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\n" , //<S2SV> le16_to_cpu ( rsp -> DialectRevision ) ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> cifs_dbg ( FYI , "mode<S2SV_blank>0x%x\\n" , rsp -> SecurityMode ) ; //<S2SV> if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) //<S2SV> cifs_dbg ( FYI , "negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\n" ) ; //<S2SV> else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) //<S2SV> cifs_dbg ( FYI , "negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\n" ) ; //<S2SV> else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) //<S2SV> cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\n" ) ; //<S2SV> else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) //<S2SV> cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\n" ) ; //<S2SV> else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) //<S2SV> cifs_dbg ( FYI , "negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\n" ) ; //<S2SV> else { //<S2SV> cifs_dbg ( VFS , "Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\n" , //<S2SV> le16_to_cpu ( rsp -> DialectRevision ) ) ; //<S2SV> rc = - EIO ; //<S2SV> goto neg_exit ; //<S2SV> } //<S2SV> server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; //<S2SV> memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , //<S2SV> SMB2_PREAUTH_HASH_SIZE ) ; //<S2SV> server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; //<S2SV> server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , //<S2SV> SMB2_MAX_BUFFER_SIZE ) ; //<S2SV> server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; //<S2SV> server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; //<S2SV> server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; //<S2SV> if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) //<S2SV> cifs_dbg ( FYI , "Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\n" , //<S2SV> server -> sec_mode ) ; //<S2SV> server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; //<S2SV> server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; //<S2SV> security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , //<S2SV> ( struct smb2_sync_hdr * ) rsp ) ; //<S2SV> if ( blob_length == 0 ) { //<S2SV> cifs_dbg ( FYI , "missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\n" ) ; //<S2SV> server -> sec_ntlmssp = true ; //<S2SV> } //<S2SV> rc = cifs_enable_signing ( server , ses -> sign ) ; //<S2SV> if ( rc ) //<S2SV> goto neg_exit ; //<S2SV> if ( blob_length ) { //<S2SV> rc = decode_negTokenInit ( security_blob , blob_length , server ) ; //<S2SV> if ( rc == 1 ) //<S2SV> rc = 0 ; //<S2SV> else if ( rc == 0 ) //<S2SV> rc = - EIO ; //<S2SV> } //<S2SV> if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { //<S2SV> if ( rsp -> NegotiateContextCount ) //<S2SV> rc = smb311_decode_neg_context ( rsp , server , //<S2SV> rsp_iov . iov_len ) ; //<S2SV> else //<S2SV> cifs_dbg ( VFS , "Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\n" ) ; //<S2SV> } //<S2SV> neg_exit : //<S2SV> free_rsp_buf ( resp_buftype , rsp ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 