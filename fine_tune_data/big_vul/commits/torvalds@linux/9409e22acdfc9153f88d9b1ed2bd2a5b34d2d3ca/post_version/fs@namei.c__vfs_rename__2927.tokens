int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , //<S2SV> struct inode * new_dir , struct dentry * new_dentry , //<S2SV> struct inode * * delegated_inode , unsigned int flags ) //<S2SV> { //<S2SV> int error ; //<S2SV> bool is_dir = d_is_dir ( old_dentry ) ; //<S2SV> const unsigned char * old_name ; //<S2SV> struct inode * source = old_dentry -> d_inode ; //<S2SV> struct inode * target = new_dentry -> d_inode ; //<S2SV> bool new_is_dir = false ; //<S2SV> unsigned max_links = new_dir -> i_sb -> s_max_links ; //<S2SV> if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) ) //<S2SV> return 0 ; //<S2SV> error = may_delete ( old_dir , old_dentry , is_dir ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> if ( ! target ) { //<S2SV> error = may_create ( new_dir , new_dentry ) ; //<S2SV> } else { //<S2SV> new_is_dir = d_is_dir ( new_dentry ) ; //<S2SV> if ( ! ( flags & RENAME_EXCHANGE ) ) //<S2SV> error = may_delete ( new_dir , new_dentry , is_dir ) ; //<S2SV> else //<S2SV> error = may_delete ( new_dir , new_dentry , new_is_dir ) ; //<S2SV> } //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> if ( ! old_dir -> i_op -> rename && ! old_dir -> i_op -> rename2 ) //<S2SV> return - EPERM ; //<S2SV> if ( flags && ! old_dir -> i_op -> rename2 ) //<S2SV> return - EINVAL ; //<S2SV> if ( new_dir != old_dir ) { //<S2SV> if ( is_dir ) { //<S2SV> error = inode_permission ( source , MAY_WRITE ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> } //<S2SV> if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) { //<S2SV> error = inode_permission ( target , MAY_WRITE ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> } //<S2SV> } //<S2SV> error = security_inode_rename ( old_dir , old_dentry , new_dir , new_dentry , //<S2SV> flags ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; //<S2SV> dget ( new_dentry ) ; //<S2SV> if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) //<S2SV> lock_two_nondirectories ( source , target ) ; //<S2SV> else if ( target ) //<S2SV> inode_lock ( target ) ; //<S2SV> error = - EBUSY ; //<S2SV> if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) //<S2SV> goto out ; //<S2SV> if ( max_links && new_dir != old_dir ) { //<S2SV> error = - EMLINK ; //<S2SV> if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) //<S2SV> goto out ; //<S2SV> if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && //<S2SV> old_dir -> i_nlink >= max_links ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) //<S2SV> shrink_dcache_parent ( new_dentry ) ; //<S2SV> if ( ! is_dir ) { //<S2SV> error = try_break_deleg ( source , delegated_inode ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( target && ! new_is_dir ) { //<S2SV> error = try_break_deleg ( target , delegated_inode ) ; //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! old_dir -> i_op -> rename2 ) { //<S2SV> error = old_dir -> i_op -> rename ( old_dir , old_dentry , //<S2SV> new_dir , new_dentry ) ; //<S2SV> } else { //<S2SV> WARN_ON ( old_dir -> i_op -> rename != NULL ) ; //<S2SV> error = old_dir -> i_op -> rename2 ( old_dir , old_dentry , //<S2SV> new_dir , new_dentry , flags ) ; //<S2SV> } //<S2SV> if ( error ) //<S2SV> goto out ; //<S2SV> if ( ! ( flags & RENAME_EXCHANGE ) && target ) { //<S2SV> if ( is_dir ) //<S2SV> target -> i_flags |= S_DEAD ; //<S2SV> dont_mount ( new_dentry ) ; //<S2SV> detach_mounts ( new_dentry ) ; //<S2SV> } //<S2SV> if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { //<S2SV> if ( ! ( flags & RENAME_EXCHANGE ) ) //<S2SV> d_move ( old_dentry , new_dentry ) ; //<S2SV> else //<S2SV> d_exchange ( old_dentry , new_dentry ) ; //<S2SV> } //<S2SV> out : //<S2SV> if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) //<S2SV> unlock_two_nondirectories ( source , target ) ; //<S2SV> else if ( target ) //<S2SV> inode_unlock ( target ) ; //<S2SV> dput ( new_dentry ) ; //<S2SV> if ( ! error ) { //<S2SV> fsnotify_move ( old_dir , new_dir , old_name , is_dir , //<S2SV> ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; //<S2SV> if ( flags & RENAME_EXCHANGE ) { //<S2SV> fsnotify_move ( new_dir , old_dir , old_dentry -> d_name . name , //<S2SV> new_is_dir , NULL , new_dentry ) ; //<S2SV> } //<S2SV> } //<S2SV> fsnotify_oldname_free ( old_name ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 