static unsigned int help ( struct sk_buff * skb , //<S2SV> enum ip_conntrack_info ctinfo , //<S2SV> unsigned int protoff , //<S2SV> unsigned int matchoff , //<S2SV> unsigned int matchlen , //<S2SV> struct nf_conntrack_expect * exp ) //<S2SV> { //<S2SV> char buffer [ sizeof ( "4294967296<S2SV_blank>65635" ) ] ; //<S2SV> struct nf_conn * ct = exp -> master ; //<S2SV> union nf_inet_addr newaddr ; //<S2SV> u_int16_t port ; //<S2SV> unsigned int ret ; //<S2SV> newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 ; //<S2SV> exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ; //<S2SV> exp -> dir = IP_CT_DIR_REPLY ; //<S2SV> exp -> expectfn = nf_nat_follow_master ; //<S2SV> for ( port = ntohs ( exp -> saved_proto . tcp . port ) ; port != 0 ; port ++ ) { //<S2SV> int ret ; //<S2SV> exp -> tuple . dst . u . tcp . port = htons ( port ) ; //<S2SV> ret = nf_ct_expect_related ( exp ) ; //<S2SV> if ( ret == 0 ) //<S2SV> break ; //<S2SV> else if ( ret != - EBUSY ) { //<S2SV> port = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( port == 0 ) { //<S2SV> nf_ct_helper_log ( skb , ct , "all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use" ) ; //<S2SV> return NF_DROP ; //<S2SV> } //<S2SV> snprintf ( buffer , sizeof ( buffer ) , "%u<S2SV_blank>%u" , ntohl ( newaddr . ip ) , port ) ; //<S2SV> pr_debug ( "nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\'%s\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\n" , //<S2SV> buffer , & newaddr . ip , port ) ; //<S2SV> ret = nf_nat_mangle_tcp_packet ( skb , ct , ctinfo , protoff , matchoff , //<S2SV> matchlen , buffer , strlen ( buffer ) ) ; //<S2SV> if ( ret != NF_ACCEPT ) { //<S2SV> nf_ct_helper_log ( skb , ct , "cannot<S2SV_blank>mangle<S2SV_blank>packet" ) ; //<S2SV> nf_ct_unexpect_related ( exp ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 