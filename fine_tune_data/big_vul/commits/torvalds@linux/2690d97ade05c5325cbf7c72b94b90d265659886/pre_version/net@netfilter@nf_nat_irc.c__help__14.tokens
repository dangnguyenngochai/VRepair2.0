static unsigned int help ( struct sk_buff * skb , //<S2SV> enum ip_conntrack_info ctinfo , //<S2SV> unsigned int protoff , //<S2SV> unsigned int matchoff , //<S2SV> unsigned int matchlen , //<S2SV> struct nf_conntrack_expect * exp ) //<S2SV> { //<S2SV> char buffer [ sizeof ( "4294967296<S2SV_blank>65635" ) ] ; //<S2SV> u_int16_t port ; //<S2SV> unsigned int ret ; //<S2SV> exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ; //<S2SV> exp -> dir = IP_CT_DIR_REPLY ; //<S2SV> exp -> expectfn = nf_nat_follow_master ; //<S2SV> for ( port = ntohs ( exp -> saved_proto . tcp . port ) ; port != 0 ; port ++ ) { //<S2SV> int ret ; //<S2SV> exp -> tuple . dst . u . tcp . port = htons ( port ) ; //<S2SV> ret = nf_ct_expect_related ( exp ) ; //<S2SV> if ( ret == 0 ) //<S2SV> break ; //<S2SV> else if ( ret != - EBUSY ) { //<S2SV> port = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( port == 0 ) { //<S2SV> nf_ct_helper_log ( skb , exp -> master , "all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use" ) ; //<S2SV> return NF_DROP ; //<S2SV> } //<S2SV> ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo , //<S2SV> protoff , matchoff , matchlen , buffer , //<S2SV> strlen ( buffer ) ) ; //<S2SV> if ( ret != NF_ACCEPT ) { //<S2SV> nf_ct_helper_log ( skb , exp -> master , "cannot<S2SV_blank>mangle<S2SV_blank>packet" ) ; //<S2SV> nf_ct_unexpect_related ( exp ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 