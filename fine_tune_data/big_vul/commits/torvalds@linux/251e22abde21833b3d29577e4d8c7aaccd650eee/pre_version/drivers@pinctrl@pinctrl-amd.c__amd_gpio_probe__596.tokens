static int amd_gpio_probe ( struct platform_device * pdev ) //<S2SV> { //<S2SV> int ret = 0 ; //<S2SV> int irq_base ; //<S2SV> struct resource * res ; //<S2SV> struct amd_gpio * gpio_dev ; //<S2SV> gpio_dev = devm_kzalloc ( & pdev -> dev , //<S2SV> sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; //<S2SV> if ( ! gpio_dev ) //<S2SV> return - ENOMEM ; //<S2SV> spin_lock_init ( & gpio_dev -> lock ) ; //<S2SV> res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; //<S2SV> if ( ! res ) { //<S2SV> dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>io<S2SV_blank>resource.\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , //<S2SV> resource_size ( res ) ) ; //<S2SV> if ( ! gpio_dev -> base ) //<S2SV> return - ENOMEM ; //<S2SV> irq_base = platform_get_irq ( pdev , 0 ) ; //<S2SV> if ( irq_base < 0 ) { //<S2SV> dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>IRQ.\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> gpio_dev -> pdev = pdev ; //<S2SV> gpio_dev -> gc . direction_input = amd_gpio_direction_input ; //<S2SV> gpio_dev -> gc . direction_output = amd_gpio_direction_output ; //<S2SV> gpio_dev -> gc . get = amd_gpio_get_value ; //<S2SV> gpio_dev -> gc . set = amd_gpio_set_value ; //<S2SV> gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; //<S2SV> gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; //<S2SV> gpio_dev -> gc . base = 0 ; //<S2SV> gpio_dev -> gc . label = pdev -> name ; //<S2SV> gpio_dev -> gc . owner = THIS_MODULE ; //<S2SV> gpio_dev -> gc . parent = & pdev -> dev ; //<S2SV> gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS ; //<S2SV> # if defined ( CONFIG_OF_GPIO ) //<S2SV> gpio_dev -> gc . of_node = pdev -> dev . of_node ; //<S2SV> # endif //<S2SV> gpio_dev -> groups = kerncz_groups ; //<S2SV> gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; //<S2SV> amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; //<S2SV> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , //<S2SV> & pdev -> dev , gpio_dev ) ; //<S2SV> if ( IS_ERR ( gpio_dev -> pctrl ) ) { //<S2SV> dev_err ( & pdev -> dev , "Couldn\'t<S2SV_blank>register<S2SV_blank>pinctrl<S2SV_blank>driver\\n" ) ; //<S2SV> return PTR_ERR ( gpio_dev -> pctrl ) ; //<S2SV> } //<S2SV> ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; //<S2SV> if ( ret ) //<S2SV> goto out1 ; //<S2SV> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , //<S2SV> 0 , 0 , TOTAL_NUMBER_OF_PINS ) ; //<S2SV> if ( ret ) { //<S2SV> dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>pin<S2SV_blank>range\\n" ) ; //<S2SV> goto out2 ; //<S2SV> } //<S2SV> ret = gpiochip_irqchip_add ( & gpio_dev -> gc , //<S2SV> & amd_gpio_irqchip , //<S2SV> 0 , //<S2SV> handle_simple_irq , //<S2SV> IRQ_TYPE_NONE ) ; //<S2SV> if ( ret ) { //<S2SV> dev_err ( & pdev -> dev , "could<S2SV_blank>not<S2SV_blank>add<S2SV_blank>irqchip\\n" ) ; //<S2SV> ret = - ENODEV ; //<S2SV> goto out2 ; //<S2SV> } //<S2SV> gpiochip_set_chained_irqchip ( & gpio_dev -> gc , //<S2SV> & amd_gpio_irqchip , //<S2SV> irq_base , //<S2SV> amd_gpio_irq_handler ) ; //<S2SV> platform_set_drvdata ( pdev , gpio_dev ) ; //<S2SV> dev_dbg ( & pdev -> dev , "amd<S2SV_blank>gpio<S2SV_blank>driver<S2SV_blank>loaded\\n" ) ; //<S2SV> return ret ; //<S2SV> out2 : //<S2SV> gpiochip_remove ( & gpio_dev -> gc ) ; //<S2SV> out1 : //<S2SV> pinctrl_unregister ( gpio_dev -> pctrl ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 