static int snd_ctl_elem_user_tlv ( struct snd_kcontrol * kcontrol , //<S2SV> int op_flag , //<S2SV> unsigned int size , //<S2SV> unsigned int __user * tlv ) //<S2SV> { //<S2SV> struct user_element * ue = kcontrol -> private_data ; //<S2SV> int change = 0 ; //<S2SV> void * new_data ; //<S2SV> if ( op_flag > 0 ) { //<S2SV> if ( size > 1024 * 128 ) //<S2SV> return - EINVAL ; //<S2SV> new_data = memdup_user ( tlv , size ) ; //<S2SV> if ( IS_ERR ( new_data ) ) //<S2SV> return PTR_ERR ( new_data ) ; //<S2SV> mutex_lock ( & ue -> card -> user_ctl_lock ) ; //<S2SV> change = ue -> tlv_data_size != size ; //<S2SV> if ( ! change ) //<S2SV> change = memcmp ( ue -> tlv_data , new_data , size ) ; //<S2SV> kfree ( ue -> tlv_data ) ; //<S2SV> ue -> tlv_data = new_data ; //<S2SV> ue -> tlv_data_size = size ; //<S2SV> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; //<S2SV> } else { //<S2SV> int ret = 0 ; //<S2SV> mutex_lock ( & ue -> card -> user_ctl_lock ) ; //<S2SV> if ( ! ue -> tlv_data_size || ! ue -> tlv_data ) { //<S2SV> ret = - ENXIO ; //<S2SV> goto err_unlock ; //<S2SV> } //<S2SV> if ( size < ue -> tlv_data_size ) { //<S2SV> ret = - ENOSPC ; //<S2SV> goto err_unlock ; //<S2SV> } //<S2SV> if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) //<S2SV> ret = - EFAULT ; //<S2SV> err_unlock : //<S2SV> mutex_unlock ( & ue -> card -> user_ctl_lock ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> } //<S2SV> return change ; //<S2SV> } //<S2SV> 