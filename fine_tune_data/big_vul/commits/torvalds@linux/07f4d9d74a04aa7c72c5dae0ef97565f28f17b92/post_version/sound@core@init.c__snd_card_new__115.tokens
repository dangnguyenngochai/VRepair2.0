int snd_card_new ( struct device * parent , int idx , const char * xid , //<S2SV> struct module * module , int extra_size , //<S2SV> struct snd_card * * card_ret ) //<S2SV> { //<S2SV> struct snd_card * card ; //<S2SV> int err ; //<S2SV> if ( snd_BUG_ON ( ! card_ret ) ) //<S2SV> return - EINVAL ; //<S2SV> * card_ret = NULL ; //<S2SV> if ( extra_size < 0 ) //<S2SV> extra_size = 0 ; //<S2SV> card = kzalloc ( sizeof ( * card ) + extra_size , GFP_KERNEL ) ; //<S2SV> if ( ! card ) //<S2SV> return - ENOMEM ; //<S2SV> if ( extra_size > 0 ) //<S2SV> card -> private_data = ( char * ) card + sizeof ( struct snd_card ) ; //<S2SV> if ( xid ) //<S2SV> strlcpy ( card -> id , xid , sizeof ( card -> id ) ) ; //<S2SV> err = 0 ; //<S2SV> mutex_lock ( & snd_card_mutex ) ; //<S2SV> if ( idx < 0 ) //<S2SV> idx = get_slot_from_bitmask ( idx , module_slot_match , module ) ; //<S2SV> if ( idx < 0 ) //<S2SV> idx = get_slot_from_bitmask ( idx , check_empty_slot , module ) ; //<S2SV> if ( idx < 0 ) //<S2SV> err = - ENODEV ; //<S2SV> else if ( idx < snd_ecards_limit ) { //<S2SV> if ( test_bit ( idx , snd_cards_lock ) ) //<S2SV> err = - EBUSY ; //<S2SV> } else if ( idx >= SNDRV_CARDS ) //<S2SV> err = - ENODEV ; //<S2SV> if ( err < 0 ) { //<S2SV> mutex_unlock ( & snd_card_mutex ) ; //<S2SV> dev_err ( parent , "cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>slot<S2SV_blank>for<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>(range<S2SV_blank>0-%i),<S2SV_blank>error:<S2SV_blank>%d\\n" , //<S2SV> idx , snd_ecards_limit - 1 , err ) ; //<S2SV> kfree ( card ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> set_bit ( idx , snd_cards_lock ) ; //<S2SV> if ( idx >= snd_ecards_limit ) //<S2SV> snd_ecards_limit = idx + 1 ; //<S2SV> mutex_unlock ( & snd_card_mutex ) ; //<S2SV> card -> dev = parent ; //<S2SV> card -> number = idx ; //<S2SV> card -> module = module ; //<S2SV> INIT_LIST_HEAD ( & card -> devices ) ; //<S2SV> init_rwsem ( & card -> controls_rwsem ) ; //<S2SV> rwlock_init ( & card -> ctl_files_rwlock ) ; //<S2SV> mutex_init ( & card -> user_ctl_lock ) ; //<S2SV> INIT_LIST_HEAD ( & card -> controls ) ; //<S2SV> INIT_LIST_HEAD ( & card -> ctl_files ) ; //<S2SV> spin_lock_init ( & card -> files_lock ) ; //<S2SV> INIT_LIST_HEAD ( & card -> files_list ) ; //<S2SV> # ifdef CONFIG_PM //<S2SV> mutex_init ( & card -> power_lock ) ; //<S2SV> init_waitqueue_head ( & card -> power_sleep ) ; //<S2SV> # endif //<S2SV> device_initialize ( & card -> card_dev ) ; //<S2SV> card -> card_dev . parent = parent ; //<S2SV> card -> card_dev . class = sound_class ; //<S2SV> card -> card_dev . release = release_card_device ; //<S2SV> card -> card_dev . groups = card_dev_attr_groups ; //<S2SV> err = kobject_set_name ( & card -> card_dev . kobj , "card%d" , idx ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto __error ; //<S2SV> err = snd_ctl_create ( card ) ; //<S2SV> if ( err < 0 ) { //<S2SV> dev_err ( parent , "unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>control<S2SV_blank>minors\\n" ) ; //<S2SV> goto __error ; //<S2SV> } //<S2SV> err = snd_info_card_create ( card ) ; //<S2SV> if ( err < 0 ) { //<S2SV> dev_err ( parent , "unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>card<S2SV_blank>info\\n" ) ; //<S2SV> goto __error_ctl ; //<S2SV> } //<S2SV> * card_ret = card ; //<S2SV> return 0 ; //<S2SV> __error_ctl : //<S2SV> snd_device_free_all ( card ) ; //<S2SV> __error : //<S2SV> put_device ( & card -> card_dev ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 