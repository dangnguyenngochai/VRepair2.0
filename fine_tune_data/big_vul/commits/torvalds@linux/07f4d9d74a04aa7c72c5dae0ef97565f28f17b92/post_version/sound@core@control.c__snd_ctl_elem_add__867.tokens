static int snd_ctl_elem_add ( struct snd_ctl_file * file , //<S2SV> struct snd_ctl_elem_info * info , int replace ) //<S2SV> { //<S2SV> struct snd_card * card = file -> card ; //<S2SV> struct snd_kcontrol kctl , * _kctl ; //<S2SV> unsigned int access ; //<S2SV> long private_size ; //<S2SV> struct user_element * ue ; //<S2SV> int idx , err ; //<S2SV> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) //<S2SV> return - ENOMEM ; //<S2SV> if ( info -> count < 1 ) //<S2SV> return - EINVAL ; //<S2SV> access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : //<S2SV> ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | //<S2SV> SNDRV_CTL_ELEM_ACCESS_INACTIVE | //<S2SV> SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; //<S2SV> info -> id . numid = 0 ; //<S2SV> memset ( & kctl , 0 , sizeof ( kctl ) ) ; //<S2SV> down_write ( & card -> controls_rwsem ) ; //<S2SV> _kctl = snd_ctl_find_id ( card , & info -> id ) ; //<S2SV> err = 0 ; //<S2SV> if ( _kctl ) { //<S2SV> if ( replace ) //<S2SV> err = snd_ctl_remove ( card , _kctl ) ; //<S2SV> else //<S2SV> err = - EBUSY ; //<S2SV> } else { //<S2SV> if ( replace ) //<S2SV> err = - ENOENT ; //<S2SV> } //<S2SV> up_write ( & card -> controls_rwsem ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; //<S2SV> kctl . count = info -> owner ? info -> owner : 1 ; //<S2SV> access |= SNDRV_CTL_ELEM_ACCESS_USER ; //<S2SV> if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) //<S2SV> kctl . info = snd_ctl_elem_user_enum_info ; //<S2SV> else //<S2SV> kctl . info = snd_ctl_elem_user_info ; //<S2SV> if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) //<S2SV> kctl . get = snd_ctl_elem_user_get ; //<S2SV> if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) //<S2SV> kctl . put = snd_ctl_elem_user_put ; //<S2SV> if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { //<S2SV> kctl . tlv . c = snd_ctl_elem_user_tlv ; //<S2SV> access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; //<S2SV> } //<S2SV> switch ( info -> type ) { //<S2SV> case SNDRV_CTL_ELEM_TYPE_BOOLEAN : //<S2SV> case SNDRV_CTL_ELEM_TYPE_INTEGER : //<S2SV> private_size = sizeof ( long ) ; //<S2SV> if ( info -> count > 128 ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> case SNDRV_CTL_ELEM_TYPE_INTEGER64 : //<S2SV> private_size = sizeof ( long long ) ; //<S2SV> if ( info -> count > 64 ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> case SNDRV_CTL_ELEM_TYPE_ENUMERATED : //<S2SV> private_size = sizeof ( unsigned int ) ; //<S2SV> if ( info -> count > 128 || info -> value . enumerated . items == 0 ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> case SNDRV_CTL_ELEM_TYPE_BYTES : //<S2SV> private_size = sizeof ( unsigned char ) ; //<S2SV> if ( info -> count > 512 ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> case SNDRV_CTL_ELEM_TYPE_IEC958 : //<S2SV> private_size = sizeof ( struct snd_aes_iec958 ) ; //<S2SV> if ( info -> count != 1 ) //<S2SV> return - EINVAL ; //<S2SV> break ; //<S2SV> default : //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> private_size *= info -> count ; //<S2SV> ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; //<S2SV> if ( ue == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> ue -> card = card ; //<S2SV> ue -> info = * info ; //<S2SV> ue -> info . access = 0 ; //<S2SV> ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; //<S2SV> ue -> elem_data_size = private_size ; //<S2SV> if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { //<S2SV> err = snd_ctl_elem_init_enum_names ( ue ) ; //<S2SV> if ( err < 0 ) { //<S2SV> kfree ( ue ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> } //<S2SV> kctl . private_free = snd_ctl_elem_user_free ; //<S2SV> _kctl = snd_ctl_new ( & kctl , access ) ; //<S2SV> if ( _kctl == NULL ) { //<S2SV> kfree ( ue -> priv_data ) ; //<S2SV> kfree ( ue ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> _kctl -> private_data = ue ; //<S2SV> for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) //<S2SV> _kctl -> vd [ idx ] . owner = file ; //<S2SV> err = snd_ctl_add ( card , _kctl ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> down_write ( & card -> controls_rwsem ) ; //<S2SV> card -> user_ctl_count ++ ; //<S2SV> up_write ( & card -> controls_rwsem ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 