int prepare_binprm ( struct linux_binprm * bprm ) //<S2SV> { //<S2SV> struct inode * inode = file_inode ( bprm -> file ) ; //<S2SV> umode_t mode = inode -> i_mode ; //<S2SV> int retval ; //<S2SV> bprm -> cred -> euid = current_euid ( ) ; //<S2SV> bprm -> cred -> egid = current_egid ( ) ; //<S2SV> if ( ! ( bprm -> file -> f_path . mnt -> mnt_flags & MNT_NOSUID ) && //<S2SV> ! task_no_new_privs ( current ) && //<S2SV> kuid_has_mapping ( bprm -> cred -> user_ns , inode -> i_uid ) && //<S2SV> kgid_has_mapping ( bprm -> cred -> user_ns , inode -> i_gid ) ) { //<S2SV> if ( mode & S_ISUID ) { //<S2SV> bprm -> per_clear |= PER_CLEAR_ON_SETID ; //<S2SV> bprm -> cred -> euid = inode -> i_uid ; //<S2SV> } //<S2SV> if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) ) { //<S2SV> bprm -> per_clear |= PER_CLEAR_ON_SETID ; //<S2SV> bprm -> cred -> egid = inode -> i_gid ; //<S2SV> } //<S2SV> } //<S2SV> retval = security_bprm_set_creds ( bprm ) ; //<S2SV> if ( retval ) //<S2SV> return retval ; //<S2SV> bprm -> cred_prepared = 1 ; //<S2SV> memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; //<S2SV> return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; //<S2SV> } //<S2SV> 