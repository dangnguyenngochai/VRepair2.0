static ssize_t macvtap_get_user ( struct macvtap_queue * q , struct msghdr * m , //<S2SV> const struct iovec * iv , unsigned long total_len , //<S2SV> size_t count , int noblock ) //<S2SV> { //<S2SV> struct sk_buff * skb ; //<S2SV> struct macvlan_dev * vlan ; //<S2SV> unsigned long len = total_len ; //<S2SV> int err ; //<S2SV> struct virtio_net_hdr vnet_hdr = { 0 } ; //<S2SV> int vnet_hdr_len = 0 ; //<S2SV> int copylen ; //<S2SV> bool zerocopy = false ; //<S2SV> if ( q -> flags & IFF_VNET_HDR ) { //<S2SV> vnet_hdr_len = q -> vnet_hdr_sz ; //<S2SV> err = - EINVAL ; //<S2SV> if ( len < vnet_hdr_len ) //<S2SV> goto err ; //<S2SV> len -= vnet_hdr_len ; //<S2SV> err = memcpy_fromiovecend ( ( void * ) & vnet_hdr , iv , 0 , //<S2SV> sizeof ( vnet_hdr ) ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto err ; //<S2SV> if ( ( vnet_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) && //<S2SV> vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 > //<S2SV> vnet_hdr . hdr_len ) //<S2SV> vnet_hdr . hdr_len = vnet_hdr . csum_start + //<S2SV> vnet_hdr . csum_offset + 2 ; //<S2SV> err = - EINVAL ; //<S2SV> if ( vnet_hdr . hdr_len > len ) //<S2SV> goto err ; //<S2SV> } //<S2SV> err = - EINVAL ; //<S2SV> if ( unlikely ( len < ETH_HLEN ) ) //<S2SV> goto err ; //<S2SV> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) //<S2SV> zerocopy = true ; //<S2SV> if ( zerocopy ) { //<S2SV> copylen = vnet_hdr . hdr_len ; //<S2SV> if ( ! copylen ) //<S2SV> copylen = GOODCOPY_LEN ; //<S2SV> } else //<S2SV> copylen = len ; //<S2SV> skb = macvtap_alloc_skb ( & q -> sk , NET_IP_ALIGN , copylen , //<S2SV> vnet_hdr . hdr_len , noblock , & err ) ; //<S2SV> if ( ! skb ) //<S2SV> goto err ; //<S2SV> if ( zerocopy ) //<S2SV> err = zerocopy_sg_from_iovec ( skb , iv , vnet_hdr_len , count ) ; //<S2SV> else //<S2SV> err = skb_copy_datagram_from_iovec ( skb , 0 , iv , vnet_hdr_len , //<S2SV> len ) ; //<S2SV> if ( err ) //<S2SV> goto err_kfree ; //<S2SV> skb_set_network_header ( skb , ETH_HLEN ) ; //<S2SV> skb_reset_mac_header ( skb ) ; //<S2SV> skb -> protocol = eth_hdr ( skb ) -> h_proto ; //<S2SV> if ( vnet_hdr_len ) { //<S2SV> err = macvtap_skb_from_vnet_hdr ( skb , & vnet_hdr ) ; //<S2SV> if ( err ) //<S2SV> goto err_kfree ; //<S2SV> } //<S2SV> rcu_read_lock_bh ( ) ; //<S2SV> vlan = rcu_dereference_bh ( q -> vlan ) ; //<S2SV> if ( zerocopy ) { //<S2SV> skb_shinfo ( skb ) -> destructor_arg = m -> msg_control ; //<S2SV> skb_shinfo ( skb ) -> tx_flags |= SKBTX_DEV_ZEROCOPY ; //<S2SV> } //<S2SV> if ( vlan ) //<S2SV> macvlan_start_xmit ( skb , vlan -> dev ) ; //<S2SV> else //<S2SV> kfree_skb ( skb ) ; //<S2SV> rcu_read_unlock_bh ( ) ; //<S2SV> return total_len ; //<S2SV> err_kfree : //<S2SV> kfree_skb ( skb ) ; //<S2SV> err : //<S2SV> rcu_read_lock_bh ( ) ; //<S2SV> vlan = rcu_dereference_bh ( q -> vlan ) ; //<S2SV> if ( vlan ) //<S2SV> vlan -> dev -> stats . tx_dropped ++ ; //<S2SV> rcu_read_unlock_bh ( ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 