static void //<S2SV> sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) //<S2SV> { //<S2SV> Sg_request * srp ; //<S2SV> int val ; //<S2SV> unsigned int ms ; //<S2SV> val = 0 ; //<S2SV> list_for_each_entry ( srp , & sfp -> rq_list , entry ) { //<S2SV> if ( val > SG_MAX_QUEUE ) //<S2SV> break ; //<S2SV> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; //<S2SV> rinfo [ val ] . req_state = srp -> done + 1 ; //<S2SV> rinfo [ val ] . problem = //<S2SV> srp -> header . masked_status & //<S2SV> srp -> header . host_status & //<S2SV> srp -> header . driver_status ; //<S2SV> if ( srp -> done ) //<S2SV> rinfo [ val ] . duration = //<S2SV> srp -> header . duration ; //<S2SV> else { //<S2SV> ms = jiffies_to_msecs ( jiffies ) ; //<S2SV> rinfo [ val ] . duration = //<S2SV> ( ms > srp -> header . duration ) ? //<S2SV> ( ms - srp -> header . duration ) : 0 ; //<S2SV> } //<S2SV> rinfo [ val ] . orphan = srp -> orphan ; //<S2SV> rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; //<S2SV> rinfo [ val ] . pack_id = srp -> header . pack_id ; //<S2SV> rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; //<S2SV> val ++ ; //<S2SV> } //<S2SV> } //<S2SV> 