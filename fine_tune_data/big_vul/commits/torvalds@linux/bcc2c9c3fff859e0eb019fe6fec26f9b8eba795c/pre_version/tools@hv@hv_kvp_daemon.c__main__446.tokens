int main ( void ) //<S2SV> { //<S2SV> int fd , len , sock_opt ; //<S2SV> int error ; //<S2SV> struct cn_msg * message ; //<S2SV> struct pollfd pfd ; //<S2SV> struct nlmsghdr * incoming_msg ; //<S2SV> struct cn_msg * incoming_cn_msg ; //<S2SV> struct hv_kvp_msg * hv_msg ; //<S2SV> char * p ; //<S2SV> char * key_value ; //<S2SV> char * key_name ; //<S2SV> daemon ( 1 , 0 ) ; //<S2SV> openlog ( "KVP" , 0 , LOG_USER ) ; //<S2SV> syslog ( LOG_INFO , "KVP<S2SV_blank>starting;<S2SV_blank>pid<S2SV_blank>is:%d" , getpid ( ) ) ; //<S2SV> kvp_get_os_info ( ) ; //<S2SV> if ( kvp_file_init ( ) ) { //<S2SV> syslog ( LOG_ERR , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>the<S2SV_blank>pools" ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; //<S2SV> if ( fd < 0 ) { //<S2SV> syslog ( LOG_ERR , "netlink<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed;<S2SV_blank>error:%d" , fd ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> addr . nl_family = AF_NETLINK ; //<S2SV> addr . nl_pad = 0 ; //<S2SV> addr . nl_pid = 0 ; //<S2SV> addr . nl_groups = CN_KVP_IDX ; //<S2SV> error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; //<S2SV> if ( error < 0 ) { //<S2SV> syslog ( LOG_ERR , "bind<S2SV_blank>failed;<S2SV_blank>error:%d" , error ) ; //<S2SV> close ( fd ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> sock_opt = addr . nl_groups ; //<S2SV> setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; //<S2SV> message = ( struct cn_msg * ) kvp_send_buffer ; //<S2SV> message -> id . idx = CN_KVP_IDX ; //<S2SV> message -> id . val = CN_KVP_VAL ; //<S2SV> hv_msg = ( struct hv_kvp_msg * ) message -> data ; //<S2SV> hv_msg -> kvp_hdr . operation = KVP_OP_REGISTER ; //<S2SV> message -> ack = 0 ; //<S2SV> message -> len = sizeof ( struct hv_kvp_msg ) ; //<S2SV> len = netlink_send ( fd , message ) ; //<S2SV> if ( len < 0 ) { //<S2SV> syslog ( LOG_ERR , "netlink_send<S2SV_blank>failed;<S2SV_blank>error:%d" , len ) ; //<S2SV> close ( fd ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> pfd . fd = fd ; //<S2SV> while ( 1 ) { //<S2SV> pfd . events = POLLIN ; //<S2SV> pfd . revents = 0 ; //<S2SV> poll ( & pfd , 1 , - 1 ) ; //<S2SV> len = recv ( fd , kvp_recv_buffer , sizeof ( kvp_recv_buffer ) , 0 ) ; //<S2SV> if ( len < 0 ) { //<S2SV> syslog ( LOG_ERR , "recv<S2SV_blank>failed;<S2SV_blank>error:%d" , len ) ; //<S2SV> close ( fd ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> incoming_msg = ( struct nlmsghdr * ) kvp_recv_buffer ; //<S2SV> incoming_cn_msg = ( struct cn_msg * ) NLMSG_DATA ( incoming_msg ) ; //<S2SV> hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; //<S2SV> switch ( hv_msg -> kvp_hdr . operation ) { //<S2SV> case KVP_OP_REGISTER : //<S2SV> p = ( char * ) hv_msg -> body . kvp_register . version ; //<S2SV> lic_version = malloc ( strlen ( p ) + 1 ) ; //<S2SV> if ( lic_version ) { //<S2SV> strcpy ( lic_version , p ) ; //<S2SV> syslog ( LOG_INFO , "KVP<S2SV_blank>LIC<S2SV_blank>Version:<S2SV_blank>%s" , //<S2SV> lic_version ) ; //<S2SV> } else { //<S2SV> syslog ( LOG_ERR , "malloc<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> continue ; //<S2SV> case KVP_OP_SET : //<S2SV> if ( kvp_key_add_or_modify ( hv_msg -> kvp_hdr . pool , //<S2SV> hv_msg -> body . kvp_set . data . key , //<S2SV> hv_msg -> body . kvp_set . data . key_size , //<S2SV> hv_msg -> body . kvp_set . data . value , //<S2SV> hv_msg -> body . kvp_set . data . value_size ) ) //<S2SV> strcpy ( hv_msg -> body . kvp_set . data . key , "" ) ; //<S2SV> break ; //<S2SV> case KVP_OP_GET : //<S2SV> if ( kvp_get_value ( hv_msg -> kvp_hdr . pool , //<S2SV> hv_msg -> body . kvp_set . data . key , //<S2SV> hv_msg -> body . kvp_set . data . key_size , //<S2SV> hv_msg -> body . kvp_set . data . value , //<S2SV> hv_msg -> body . kvp_set . data . value_size ) ) //<S2SV> strcpy ( hv_msg -> body . kvp_set . data . key , "" ) ; //<S2SV> break ; //<S2SV> case KVP_OP_DELETE : //<S2SV> if ( kvp_key_delete ( hv_msg -> kvp_hdr . pool , //<S2SV> hv_msg -> body . kvp_delete . key , //<S2SV> hv_msg -> body . kvp_delete . key_size ) ) //<S2SV> strcpy ( hv_msg -> body . kvp_delete . key , "" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> if ( hv_msg -> kvp_hdr . operation != KVP_OP_ENUMERATE ) //<S2SV> goto kvp_done ; //<S2SV> if ( hv_msg -> kvp_hdr . pool != KVP_POOL_AUTO ) { //<S2SV> kvp_pool_enumerate ( hv_msg -> kvp_hdr . pool , //<S2SV> hv_msg -> body . kvp_enum_data . index , //<S2SV> hv_msg -> body . kvp_enum_data . data . key , //<S2SV> HV_KVP_EXCHANGE_MAX_KEY_SIZE , //<S2SV> hv_msg -> body . kvp_enum_data . data . value , //<S2SV> HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; //<S2SV> goto kvp_done ; //<S2SV> } //<S2SV> hv_msg = ( struct hv_kvp_msg * ) incoming_cn_msg -> data ; //<S2SV> key_name = ( char * ) hv_msg -> body . kvp_enum_data . data . key ; //<S2SV> key_value = ( char * ) hv_msg -> body . kvp_enum_data . data . value ; //<S2SV> switch ( hv_msg -> body . kvp_enum_data . index ) { //<S2SV> case FullyQualifiedDomainName : //<S2SV> kvp_get_domain_name ( key_value , //<S2SV> HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; //<S2SV> strcpy ( key_name , "FullyQualifiedDomainName" ) ; //<S2SV> break ; //<S2SV> case IntegrationServicesVersion : //<S2SV> strcpy ( key_name , "IntegrationServicesVersion" ) ; //<S2SV> strcpy ( key_value , lic_version ) ; //<S2SV> break ; //<S2SV> case NetworkAddressIPv4 : //<S2SV> kvp_get_ip_address ( AF_INET , key_value , //<S2SV> HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; //<S2SV> strcpy ( key_name , "NetworkAddressIPv4" ) ; //<S2SV> break ; //<S2SV> case NetworkAddressIPv6 : //<S2SV> kvp_get_ip_address ( AF_INET6 , key_value , //<S2SV> HV_KVP_EXCHANGE_MAX_VALUE_SIZE ) ; //<S2SV> strcpy ( key_name , "NetworkAddressIPv6" ) ; //<S2SV> break ; //<S2SV> case OSBuildNumber : //<S2SV> strcpy ( key_value , os_build ) ; //<S2SV> strcpy ( key_name , "OSBuildNumber" ) ; //<S2SV> break ; //<S2SV> case OSName : //<S2SV> strcpy ( key_value , os_name ) ; //<S2SV> strcpy ( key_name , "OSName" ) ; //<S2SV> break ; //<S2SV> case OSMajorVersion : //<S2SV> strcpy ( key_value , os_major ) ; //<S2SV> strcpy ( key_name , "OSMajorVersion" ) ; //<S2SV> break ; //<S2SV> case OSMinorVersion : //<S2SV> strcpy ( key_value , os_minor ) ; //<S2SV> strcpy ( key_name , "OSMinorVersion" ) ; //<S2SV> break ; //<S2SV> case OSVersion : //<S2SV> strcpy ( key_value , os_build ) ; //<S2SV> strcpy ( key_name , "OSVersion" ) ; //<S2SV> break ; //<S2SV> case ProcessorArchitecture : //<S2SV> strcpy ( key_value , processor_arch ) ; //<S2SV> strcpy ( key_name , "ProcessorArchitecture" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> strcpy ( key_value , "Unknown<S2SV_blank>Key" ) ; //<S2SV> strcpy ( key_name , "" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> kvp_done : //<S2SV> incoming_cn_msg -> id . idx = CN_KVP_IDX ; //<S2SV> incoming_cn_msg -> id . val = CN_KVP_VAL ; //<S2SV> incoming_cn_msg -> ack = 0 ; //<S2SV> incoming_cn_msg -> len = sizeof ( struct hv_kvp_msg ) ; //<S2SV> len = netlink_send ( fd , incoming_cn_msg ) ; //<S2SV> if ( len < 0 ) { //<S2SV> syslog ( LOG_ERR , "net_link<S2SV_blank>send<S2SV_blank>failed;<S2SV_blank>error:%d" , len ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 