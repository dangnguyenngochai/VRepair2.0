int sock_setsockopt ( struct socket * sock , int level , int optname , //<S2SV> char __user * optval , unsigned int optlen ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> int val ; //<S2SV> int valbool ; //<S2SV> struct linger ling ; //<S2SV> int ret = 0 ; //<S2SV> if ( optname == SO_BINDTODEVICE ) //<S2SV> return sock_setbindtodevice ( sk , optval , optlen ) ; //<S2SV> if ( optlen < sizeof ( int ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( get_user ( val , ( int __user * ) optval ) ) //<S2SV> return - EFAULT ; //<S2SV> valbool = val ? 1 : 0 ; //<S2SV> lock_sock ( sk ) ; //<S2SV> switch ( optname ) { //<S2SV> case SO_DEBUG : //<S2SV> if ( val && ! capable ( CAP_NET_ADMIN ) ) //<S2SV> ret = - EACCES ; //<S2SV> else //<S2SV> sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; //<S2SV> break ; //<S2SV> case SO_REUSEADDR : //<S2SV> sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; //<S2SV> break ; //<S2SV> case SO_REUSEPORT : //<S2SV> sk -> sk_reuseport = valbool ; //<S2SV> break ; //<S2SV> case SO_TYPE : //<S2SV> case SO_PROTOCOL : //<S2SV> case SO_DOMAIN : //<S2SV> case SO_ERROR : //<S2SV> ret = - ENOPROTOOPT ; //<S2SV> break ; //<S2SV> case SO_DONTROUTE : //<S2SV> sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; //<S2SV> break ; //<S2SV> case SO_BROADCAST : //<S2SV> sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; //<S2SV> break ; //<S2SV> case SO_SNDBUF : //<S2SV> val = min_t ( u32 , val , sysctl_wmem_max ) ; //<S2SV> set_sndbuf : //<S2SV> sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; //<S2SV> sk -> sk_sndbuf = max_t ( int , val * 2 , SOCK_MIN_SNDBUF ) ; //<S2SV> sk -> sk_write_space ( sk ) ; //<S2SV> break ; //<S2SV> case SO_SNDBUFFORCE : //<S2SV> if ( ! capable ( CAP_NET_ADMIN ) ) { //<S2SV> ret = - EPERM ; //<S2SV> break ; //<S2SV> } //<S2SV> goto set_sndbuf ; //<S2SV> case SO_RCVBUF : //<S2SV> val = min_t ( u32 , val , sysctl_rmem_max ) ; //<S2SV> set_rcvbuf : //<S2SV> sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; //<S2SV> sk -> sk_rcvbuf = max_t ( int , val * 2 , SOCK_MIN_RCVBUF ) ; //<S2SV> break ; //<S2SV> case SO_RCVBUFFORCE : //<S2SV> if ( ! capable ( CAP_NET_ADMIN ) ) { //<S2SV> ret = - EPERM ; //<S2SV> break ; //<S2SV> } //<S2SV> goto set_rcvbuf ; //<S2SV> case SO_KEEPALIVE : //<S2SV> # ifdef CONFIG_INET //<S2SV> if ( sk -> sk_protocol == IPPROTO_TCP && //<S2SV> sk -> sk_type == SOCK_STREAM ) //<S2SV> tcp_set_keepalive ( sk , valbool ) ; //<S2SV> # endif //<S2SV> sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; //<S2SV> break ; //<S2SV> case SO_OOBINLINE : //<S2SV> sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; //<S2SV> break ; //<S2SV> case SO_NO_CHECK : //<S2SV> sk -> sk_no_check_tx = valbool ; //<S2SV> break ; //<S2SV> case SO_PRIORITY : //<S2SV> if ( ( val >= 0 && val <= 6 ) || //<S2SV> ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) //<S2SV> sk -> sk_priority = val ; //<S2SV> else //<S2SV> ret = - EPERM ; //<S2SV> break ; //<S2SV> case SO_LINGER : //<S2SV> if ( optlen < sizeof ( ling ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { //<S2SV> ret = - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! ling . l_onoff ) //<S2SV> sock_reset_flag ( sk , SOCK_LINGER ) ; //<S2SV> else { //<S2SV> # if ( BITS_PER_LONG == 32 ) //<S2SV> if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) //<S2SV> sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; //<S2SV> else //<S2SV> # endif //<S2SV> sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; //<S2SV> sock_set_flag ( sk , SOCK_LINGER ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case SO_BSDCOMPAT : //<S2SV> sock_warn_obsolete_bsdism ( "setsockopt" ) ; //<S2SV> break ; //<S2SV> case SO_PASSCRED : //<S2SV> if ( valbool ) //<S2SV> set_bit ( SOCK_PASSCRED , & sock -> flags ) ; //<S2SV> else //<S2SV> clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; //<S2SV> break ; //<S2SV> case SO_TIMESTAMP : //<S2SV> case SO_TIMESTAMPNS : //<S2SV> if ( valbool ) { //<S2SV> if ( optname == SO_TIMESTAMP ) //<S2SV> sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; //<S2SV> else //<S2SV> sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; //<S2SV> sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; //<S2SV> sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; //<S2SV> } else { //<S2SV> sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; //<S2SV> sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case SO_TIMESTAMPING : //<S2SV> if ( val & ~ SOF_TIMESTAMPING_MASK ) { //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( val & SOF_TIMESTAMPING_OPT_ID && //<S2SV> ! ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) ) { //<S2SV> if ( sk -> sk_protocol == IPPROTO_TCP && //<S2SV> sk -> sk_type == SOCK_STREAM ) { //<S2SV> if ( ( 1 << sk -> sk_state ) & //<S2SV> ( TCPF_CLOSE | TCPF_LISTEN ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> break ; //<S2SV> } //<S2SV> sk -> sk_tskey = tcp_sk ( sk ) -> snd_una ; //<S2SV> } else { //<S2SV> sk -> sk_tskey = 0 ; //<S2SV> } //<S2SV> } //<S2SV> sk -> sk_tsflags = val ; //<S2SV> if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) //<S2SV> sock_enable_timestamp ( sk , //<S2SV> SOCK_TIMESTAMPING_RX_SOFTWARE ) ; //<S2SV> else //<S2SV> sock_disable_timestamp ( sk , //<S2SV> ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; //<S2SV> break ; //<S2SV> case SO_RCVLOWAT : //<S2SV> if ( val < 0 ) //<S2SV> val = INT_MAX ; //<S2SV> sk -> sk_rcvlowat = val ? : 1 ; //<S2SV> break ; //<S2SV> case SO_RCVTIMEO : //<S2SV> ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; //<S2SV> break ; //<S2SV> case SO_SNDTIMEO : //<S2SV> ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; //<S2SV> break ; //<S2SV> case SO_ATTACH_FILTER : //<S2SV> ret = - EINVAL ; //<S2SV> if ( optlen == sizeof ( struct sock_fprog ) ) { //<S2SV> struct sock_fprog fprog ; //<S2SV> ret = - EFAULT ; //<S2SV> if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) //<S2SV> break ; //<S2SV> ret = sk_attach_filter ( & fprog , sk ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case SO_ATTACH_BPF : //<S2SV> ret = - EINVAL ; //<S2SV> if ( optlen == sizeof ( u32 ) ) { //<S2SV> u32 ufd ; //<S2SV> ret = - EFAULT ; //<S2SV> if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) //<S2SV> break ; //<S2SV> ret = sk_attach_bpf ( ufd , sk ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case SO_ATTACH_REUSEPORT_CBPF : //<S2SV> ret = - EINVAL ; //<S2SV> if ( optlen == sizeof ( struct sock_fprog ) ) { //<S2SV> struct sock_fprog fprog ; //<S2SV> ret = - EFAULT ; //<S2SV> if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) //<S2SV> break ; //<S2SV> ret = sk_reuseport_attach_filter ( & fprog , sk ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case SO_ATTACH_REUSEPORT_EBPF : //<S2SV> ret = - EINVAL ; //<S2SV> if ( optlen == sizeof ( u32 ) ) { //<S2SV> u32 ufd ; //<S2SV> ret = - EFAULT ; //<S2SV> if ( copy_from_user ( & ufd , optval , sizeof ( ufd ) ) ) //<S2SV> break ; //<S2SV> ret = sk_reuseport_attach_bpf ( ufd , sk ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case SO_DETACH_FILTER : //<S2SV> ret = sk_detach_filter ( sk ) ; //<S2SV> break ; //<S2SV> case SO_LOCK_FILTER : //<S2SV> if ( sock_flag ( sk , SOCK_FILTER_LOCKED ) && ! valbool ) //<S2SV> ret = - EPERM ; //<S2SV> else //<S2SV> sock_valbool_flag ( sk , SOCK_FILTER_LOCKED , valbool ) ; //<S2SV> break ; //<S2SV> case SO_PASSSEC : //<S2SV> if ( valbool ) //<S2SV> set_bit ( SOCK_PASSSEC , & sock -> flags ) ; //<S2SV> else //<S2SV> clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; //<S2SV> break ; //<S2SV> case SO_MARK : //<S2SV> if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) ) //<S2SV> ret = - EPERM ; //<S2SV> else //<S2SV> sk -> sk_mark = val ; //<S2SV> break ; //<S2SV> case SO_RXQ_OVFL : //<S2SV> sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; //<S2SV> break ; //<S2SV> case SO_WIFI_STATUS : //<S2SV> sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; //<S2SV> break ; //<S2SV> case SO_PEEK_OFF : //<S2SV> if ( sock -> ops -> set_peek_off ) //<S2SV> ret = sock -> ops -> set_peek_off ( sk , val ) ; //<S2SV> else //<S2SV> ret = - EOPNOTSUPP ; //<S2SV> break ; //<S2SV> case SO_NOFCS : //<S2SV> sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; //<S2SV> break ; //<S2SV> case SO_SELECT_ERR_QUEUE : //<S2SV> sock_valbool_flag ( sk , SOCK_SELECT_ERR_QUEUE , valbool ) ; //<S2SV> break ; //<S2SV> # ifdef CONFIG_NET_RX_BUSY_POLL //<S2SV> case SO_BUSY_POLL : //<S2SV> if ( ( val > sk -> sk_ll_usec ) && ! capable ( CAP_NET_ADMIN ) ) //<S2SV> ret = - EPERM ; //<S2SV> else { //<S2SV> if ( val < 0 ) //<S2SV> ret = - EINVAL ; //<S2SV> else //<S2SV> sk -> sk_ll_usec = val ; //<S2SV> } //<S2SV> break ; //<S2SV> # endif //<S2SV> case SO_MAX_PACING_RATE : //<S2SV> sk -> sk_max_pacing_rate = val ; //<S2SV> sk -> sk_pacing_rate = min ( sk -> sk_pacing_rate , //<S2SV> sk -> sk_max_pacing_rate ) ; //<S2SV> break ; //<S2SV> case SO_INCOMING_CPU : //<S2SV> sk -> sk_incoming_cpu = val ; //<S2SV> break ; //<S2SV> case SO_CNX_ADVICE : //<S2SV> if ( val == 1 ) //<S2SV> dst_negative_advice ( sk ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ret = - ENOPROTOOPT ; //<S2SV> break ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 