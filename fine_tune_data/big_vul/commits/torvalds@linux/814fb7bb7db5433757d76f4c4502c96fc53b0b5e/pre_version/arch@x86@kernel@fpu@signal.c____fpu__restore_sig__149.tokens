static int __fpu__restore_sig ( void __user * buf , void __user * buf_fx , int size ) //<S2SV> { //<S2SV> int ia32_fxstate = ( buf != buf_fx ) ; //<S2SV> struct task_struct * tsk = current ; //<S2SV> struct fpu * fpu = & tsk -> thread . fpu ; //<S2SV> int state_size = fpu_kernel_xstate_size ; //<S2SV> u64 xfeatures = 0 ; //<S2SV> int fx_only = 0 ; //<S2SV> ia32_fxstate &= ( IS_ENABLED ( CONFIG_X86_32 ) || //<S2SV> IS_ENABLED ( CONFIG_IA32_EMULATION ) ) ; //<S2SV> if ( ! buf ) { //<S2SV> fpu__clear ( fpu ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! access_ok ( VERIFY_READ , buf , size ) ) //<S2SV> return - EACCES ; //<S2SV> fpu__activate_curr ( fpu ) ; //<S2SV> if ( ! static_cpu_has ( X86_FEATURE_FPU ) ) //<S2SV> return fpregs_soft_set ( current , NULL , //<S2SV> 0 , sizeof ( struct user_i387_ia32_struct ) , //<S2SV> NULL , buf ) != 0 ; //<S2SV> if ( use_xsave ( ) ) { //<S2SV> struct _fpx_sw_bytes fx_sw_user ; //<S2SV> if ( unlikely ( check_for_xstate ( buf_fx , buf_fx , & fx_sw_user ) ) ) { //<S2SV> state_size = sizeof ( struct fxregs_state ) ; //<S2SV> fx_only = 1 ; //<S2SV> trace_x86_fpu_xstate_check_failed ( fpu ) ; //<S2SV> } else { //<S2SV> state_size = fx_sw_user . xstate_size ; //<S2SV> xfeatures = fx_sw_user . xfeatures ; //<S2SV> } //<S2SV> } //<S2SV> if ( ia32_fxstate ) { //<S2SV> struct fpu * fpu = & tsk -> thread . fpu ; //<S2SV> struct user_i387_ia32_struct env ; //<S2SV> int err = 0 ; //<S2SV> fpu__drop ( fpu ) ; //<S2SV> if ( using_compacted_format ( ) ) //<S2SV> err = copy_user_to_xstate ( & fpu -> state . xsave , buf_fx ) ; //<S2SV> else //<S2SV> err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ; //<S2SV> if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) { //<S2SV> fpstate_init ( & fpu -> state ) ; //<S2SV> trace_x86_fpu_init_state ( fpu ) ; //<S2SV> err = - 1 ; //<S2SV> } else { //<S2SV> sanitize_restored_xstate ( tsk , & env , xfeatures , fx_only ) ; //<S2SV> } //<S2SV> fpu -> fpstate_active = 1 ; //<S2SV> preempt_disable ( ) ; //<S2SV> fpu__restore ( fpu ) ; //<S2SV> preempt_enable ( ) ; //<S2SV> return err ; //<S2SV> } else { //<S2SV> user_fpu_begin ( ) ; //<S2SV> if ( copy_user_to_fpregs_zeroing ( buf_fx , xfeatures , fx_only ) ) { //<S2SV> fpu__clear ( fpu ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 