SYSCALL_DEFINE3 ( shmctl , int , shmid , int , cmd , struct shmid_ds __user * , buf ) //<S2SV> { //<S2SV> struct shmid_kernel * shp ; //<S2SV> int err , version ; //<S2SV> struct ipc_namespace * ns ; //<S2SV> if ( cmd < 0 || shmid < 0 ) //<S2SV> return - EINVAL ; //<S2SV> version = ipc_parse_version ( & cmd ) ; //<S2SV> ns = current -> nsproxy -> ipc_ns ; //<S2SV> switch ( cmd ) { //<S2SV> case IPC_INFO : //<S2SV> case SHM_INFO : //<S2SV> case SHM_STAT : //<S2SV> case IPC_STAT : //<S2SV> return shmctl_nolock ( ns , shmid , cmd , version , buf ) ; //<S2SV> case IPC_RMID : //<S2SV> case IPC_SET : //<S2SV> return shmctl_down ( ns , shmid , cmd , buf , version ) ; //<S2SV> case SHM_LOCK : //<S2SV> case SHM_UNLOCK : //<S2SV> { //<S2SV> struct file * shm_file ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> shp = shm_obtain_object_check ( ns , shmid ) ; //<S2SV> if ( IS_ERR ( shp ) ) { //<S2SV> err = PTR_ERR ( shp ) ; //<S2SV> goto out_unlock1 ; //<S2SV> } //<S2SV> audit_ipc_obj ( & ( shp -> shm_perm ) ) ; //<S2SV> err = security_shm_shmctl ( shp , cmd ) ; //<S2SV> if ( err ) //<S2SV> goto out_unlock1 ; //<S2SV> ipc_lock_object ( & shp -> shm_perm ) ; //<S2SV> if ( ! ns_capable ( ns -> user_ns , CAP_IPC_LOCK ) ) { //<S2SV> kuid_t euid = current_euid ( ) ; //<S2SV> err = - EPERM ; //<S2SV> if ( ! uid_eq ( euid , shp -> shm_perm . uid ) && //<S2SV> ! uid_eq ( euid , shp -> shm_perm . cuid ) ) //<S2SV> goto out_unlock0 ; //<S2SV> if ( cmd == SHM_LOCK && ! rlimit ( RLIMIT_MEMLOCK ) ) //<S2SV> goto out_unlock0 ; //<S2SV> } //<S2SV> shm_file = shp -> shm_file ; //<S2SV> if ( shm_file == NULL ) { //<S2SV> err = - EIDRM ; //<S2SV> goto out_unlock0 ; //<S2SV> } //<S2SV> if ( is_file_hugepages ( shm_file ) ) //<S2SV> goto out_unlock0 ; //<S2SV> if ( cmd == SHM_LOCK ) { //<S2SV> struct user_struct * user = current_user ( ) ; //<S2SV> err = shmem_lock ( shm_file , 1 , user ) ; //<S2SV> if ( ! err && ! ( shp -> shm_perm . mode & SHM_LOCKED ) ) { //<S2SV> shp -> shm_perm . mode |= SHM_LOCKED ; //<S2SV> shp -> mlock_user = user ; //<S2SV> } //<S2SV> goto out_unlock0 ; //<S2SV> } //<S2SV> if ( ! ( shp -> shm_perm . mode & SHM_LOCKED ) ) //<S2SV> goto out_unlock0 ; //<S2SV> shmem_lock ( shm_file , 0 , shp -> mlock_user ) ; //<S2SV> shp -> shm_perm . mode &= ~ SHM_LOCKED ; //<S2SV> shp -> mlock_user = NULL ; //<S2SV> get_file ( shm_file ) ; //<S2SV> ipc_unlock_object ( & shp -> shm_perm ) ; //<S2SV> rcu_read_unlock ( ) ; //<S2SV> shmem_unlock_mapping ( shm_file -> f_mapping ) ; //<S2SV> fput ( shm_file ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> default : //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> out_unlock0 : //<S2SV> ipc_unlock_object ( & shp -> shm_perm ) ; //<S2SV> out_unlock1 : //<S2SV> rcu_read_unlock ( ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 