static int ext4_split_extent_at ( handle_t * handle , //<S2SV> struct inode * inode , //<S2SV> struct ext4_ext_path * path , //<S2SV> ext4_lblk_t split , //<S2SV> int split_flag , //<S2SV> int flags ) //<S2SV> { //<S2SV> ext4_fsblk_t newblock ; //<S2SV> ext4_lblk_t ee_block ; //<S2SV> struct ext4_extent * ex , newex , orig_ex ; //<S2SV> struct ext4_extent * ex2 = NULL ; //<S2SV> unsigned int ee_len , depth ; //<S2SV> int err = 0 ; //<S2SV> BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == //<S2SV> ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) ; //<S2SV> ext_debug ( "ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical" //<S2SV> "block<S2SV_blank>%llu\\n" , inode -> i_ino , ( unsigned long long ) split ) ; //<S2SV> ext4_ext_show_leaf ( inode , path ) ; //<S2SV> depth = ext_depth ( inode ) ; //<S2SV> ex = path [ depth ] . p_ext ; //<S2SV> ee_block = le32_to_cpu ( ex -> ee_block ) ; //<S2SV> ee_len = ext4_ext_get_actual_len ( ex ) ; //<S2SV> newblock = split - ee_block + ext4_ext_pblock ( ex ) ; //<S2SV> BUG_ON ( split < ee_block || split >= ( ee_block + ee_len ) ) ; //<S2SV> err = ext4_ext_get_access ( handle , inode , path + depth ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> if ( split == ee_block ) { //<S2SV> if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) //<S2SV> ext4_ext_mark_uninitialized ( ex ) ; //<S2SV> else //<S2SV> ext4_ext_mark_initialized ( ex ) ; //<S2SV> if ( ! ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) //<S2SV> ext4_ext_try_to_merge ( handle , inode , path , ex ) ; //<S2SV> err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> memcpy ( & orig_ex , ex , sizeof ( orig_ex ) ) ; //<S2SV> ex -> ee_len = cpu_to_le16 ( split - ee_block ) ; //<S2SV> if ( split_flag & EXT4_EXT_MARK_UNINIT1 ) //<S2SV> ext4_ext_mark_uninitialized ( ex ) ; //<S2SV> err = ext4_ext_dirty ( handle , inode , path + depth ) ; //<S2SV> if ( err ) //<S2SV> goto fix_extent_len ; //<S2SV> ex2 = & newex ; //<S2SV> ex2 -> ee_block = cpu_to_le32 ( split ) ; //<S2SV> ex2 -> ee_len = cpu_to_le16 ( ee_len - ( split - ee_block ) ) ; //<S2SV> ext4_ext_store_pblock ( ex2 , newblock ) ; //<S2SV> if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) //<S2SV> ext4_ext_mark_uninitialized ( ex2 ) ; //<S2SV> err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; //<S2SV> if ( err == - ENOSPC && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { //<S2SV> if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { //<S2SV> if ( split_flag & EXT4_EXT_DATA_VALID1 ) //<S2SV> err = ext4_ext_zeroout ( inode , ex2 ) ; //<S2SV> else //<S2SV> err = ext4_ext_zeroout ( inode , ex ) ; //<S2SV> } else //<S2SV> err = ext4_ext_zeroout ( inode , & orig_ex ) ; //<S2SV> if ( err ) //<S2SV> goto fix_extent_len ; //<S2SV> ex -> ee_len = cpu_to_le16 ( ee_len ) ; //<S2SV> ext4_ext_try_to_merge ( handle , inode , path , ex ) ; //<S2SV> err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; //<S2SV> goto out ; //<S2SV> } else if ( err ) //<S2SV> goto fix_extent_len ; //<S2SV> out : //<S2SV> ext4_ext_show_leaf ( inode , path ) ; //<S2SV> return err ; //<S2SV> fix_extent_len : //<S2SV> ex -> ee_len = orig_ex . ee_len ; //<S2SV> ext4_ext_dirty ( handle , inode , path + depth ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 