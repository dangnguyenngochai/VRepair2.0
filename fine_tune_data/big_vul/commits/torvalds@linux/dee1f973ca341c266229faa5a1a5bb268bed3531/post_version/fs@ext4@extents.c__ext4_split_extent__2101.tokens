static int ext4_split_extent ( handle_t * handle , //<S2SV> struct inode * inode , //<S2SV> struct ext4_ext_path * path , //<S2SV> struct ext4_map_blocks * map , //<S2SV> int split_flag , //<S2SV> int flags ) //<S2SV> { //<S2SV> ext4_lblk_t ee_block ; //<S2SV> struct ext4_extent * ex ; //<S2SV> unsigned int ee_len , depth ; //<S2SV> int err = 0 ; //<S2SV> int uninitialized ; //<S2SV> int split_flag1 , flags1 ; //<S2SV> depth = ext_depth ( inode ) ; //<S2SV> ex = path [ depth ] . p_ext ; //<S2SV> ee_block = le32_to_cpu ( ex -> ee_block ) ; //<S2SV> ee_len = ext4_ext_get_actual_len ( ex ) ; //<S2SV> uninitialized = ext4_ext_is_uninitialized ( ex ) ; //<S2SV> if ( map -> m_lblk + map -> m_len < ee_block + ee_len ) { //<S2SV> split_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ; //<S2SV> flags1 = flags | EXT4_GET_BLOCKS_PRE_IO ; //<S2SV> if ( uninitialized ) //<S2SV> split_flag1 |= EXT4_EXT_MARK_UNINIT1 | //<S2SV> EXT4_EXT_MARK_UNINIT2 ; //<S2SV> if ( split_flag & EXT4_EXT_DATA_VALID2 ) //<S2SV> split_flag1 |= EXT4_EXT_DATA_VALID1 ; //<S2SV> err = ext4_split_extent_at ( handle , inode , path , //<S2SV> map -> m_lblk + map -> m_len , split_flag1 , flags1 ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> } //<S2SV> ext4_ext_drop_refs ( path ) ; //<S2SV> path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; //<S2SV> if ( IS_ERR ( path ) ) //<S2SV> return PTR_ERR ( path ) ; //<S2SV> if ( map -> m_lblk >= ee_block ) { //<S2SV> split_flag1 = split_flag & ( EXT4_EXT_MAY_ZEROOUT | //<S2SV> EXT4_EXT_DATA_VALID2 ) ; //<S2SV> if ( uninitialized ) //<S2SV> split_flag1 |= EXT4_EXT_MARK_UNINIT1 ; //<S2SV> if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) //<S2SV> split_flag1 |= EXT4_EXT_MARK_UNINIT2 ; //<S2SV> err = ext4_split_extent_at ( handle , inode , path , //<S2SV> map -> m_lblk , split_flag1 , flags ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> } //<S2SV> ext4_ext_show_leaf ( inode , path ) ; //<S2SV> out : //<S2SV> return err ? err : map -> m_len ; //<S2SV> } //<S2SV> 