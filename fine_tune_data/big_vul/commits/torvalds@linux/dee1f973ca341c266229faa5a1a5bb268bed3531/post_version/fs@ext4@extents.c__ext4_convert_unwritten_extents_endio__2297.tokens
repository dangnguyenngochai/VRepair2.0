static int ext4_convert_unwritten_extents_endio ( handle_t * handle , //<S2SV> struct inode * inode , //<S2SV> struct ext4_map_blocks * map , //<S2SV> struct ext4_ext_path * path ) //<S2SV> { //<S2SV> struct ext4_extent * ex ; //<S2SV> ext4_lblk_t ee_block ; //<S2SV> unsigned int ee_len ; //<S2SV> int depth ; //<S2SV> int err = 0 ; //<S2SV> depth = ext_depth ( inode ) ; //<S2SV> ex = path [ depth ] . p_ext ; //<S2SV> ee_block = le32_to_cpu ( ex -> ee_block ) ; //<S2SV> ee_len = ext4_ext_get_actual_len ( ex ) ; //<S2SV> ext_debug ( "ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical" //<S2SV> "block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n" , inode -> i_ino , //<S2SV> ( unsigned long long ) ee_block , ee_len ) ; //<S2SV> if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { //<S2SV> err = ext4_split_unwritten_extents ( handle , inode , map , path , //<S2SV> EXT4_GET_BLOCKS_CONVERT ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out ; //<S2SV> ext4_ext_drop_refs ( path ) ; //<S2SV> path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; //<S2SV> if ( IS_ERR ( path ) ) { //<S2SV> err = PTR_ERR ( path ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> depth = ext_depth ( inode ) ; //<S2SV> ex = path [ depth ] . p_ext ; //<S2SV> } //<S2SV> err = ext4_ext_get_access ( handle , inode , path + depth ) ; //<S2SV> if ( err ) //<S2SV> goto out ; //<S2SV> ext4_ext_mark_initialized ( ex ) ; //<S2SV> ext4_ext_try_to_merge ( handle , inode , path , ex ) ; //<S2SV> err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; //<S2SV> out : //<S2SV> ext4_ext_show_leaf ( inode , path ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 