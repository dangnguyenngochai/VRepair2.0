int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , //<S2SV> int offset , int len , int odd , struct sk_buff * skb ) , //<S2SV> void * from , int length , int transhdrlen , //<S2SV> int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , //<S2SV> struct rt6_info * rt , unsigned int flags , int dontfrag ) //<S2SV> { //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct inet_cork * cork ; //<S2SV> struct sk_buff * skb , * skb_prev = NULL ; //<S2SV> unsigned int maxfraglen , fragheaderlen , mtu ; //<S2SV> int exthdrlen ; //<S2SV> int dst_exthdrlen ; //<S2SV> int hh_len ; //<S2SV> int copy ; //<S2SV> int err ; //<S2SV> int offset = 0 ; //<S2SV> __u8 tx_flags = 0 ; //<S2SV> if ( flags & MSG_PROBE ) //<S2SV> return 0 ; //<S2SV> cork = & inet -> cork . base ; //<S2SV> if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { //<S2SV> if ( opt ) { //<S2SV> if ( WARN_ON ( np -> cork . opt ) ) //<S2SV> return - EINVAL ; //<S2SV> np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; //<S2SV> if ( unlikely ( np -> cork . opt == NULL ) ) //<S2SV> return - ENOBUFS ; //<S2SV> np -> cork . opt -> tot_len = opt -> tot_len ; //<S2SV> np -> cork . opt -> opt_flen = opt -> opt_flen ; //<S2SV> np -> cork . opt -> opt_nflen = opt -> opt_nflen ; //<S2SV> np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , //<S2SV> sk -> sk_allocation ) ; //<S2SV> if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) //<S2SV> return - ENOBUFS ; //<S2SV> np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , //<S2SV> sk -> sk_allocation ) ; //<S2SV> if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) //<S2SV> return - ENOBUFS ; //<S2SV> np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , //<S2SV> sk -> sk_allocation ) ; //<S2SV> if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) //<S2SV> return - ENOBUFS ; //<S2SV> np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , //<S2SV> sk -> sk_allocation ) ; //<S2SV> if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) //<S2SV> return - ENOBUFS ; //<S2SV> } //<S2SV> dst_hold ( & rt -> dst ) ; //<S2SV> cork -> dst = & rt -> dst ; //<S2SV> inet -> cork . fl . u . ip6 = * fl6 ; //<S2SV> np -> cork . hop_limit = hlimit ; //<S2SV> np -> cork . tclass = tclass ; //<S2SV> if ( rt -> dst . flags & DST_XFRM_TUNNEL ) //<S2SV> mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? //<S2SV> rt -> dst . dev -> mtu : dst_mtu ( & rt -> dst ) ; //<S2SV> else //<S2SV> mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? //<S2SV> rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; //<S2SV> if ( np -> frag_size < mtu ) { //<S2SV> if ( np -> frag_size ) //<S2SV> mtu = np -> frag_size ; //<S2SV> } //<S2SV> cork -> fragsize = mtu ; //<S2SV> if ( dst_allfrag ( rt -> dst . path ) ) //<S2SV> cork -> flags |= IPCORK_ALLFRAG ; //<S2SV> cork -> length = 0 ; //<S2SV> exthdrlen = ( opt ? opt -> opt_flen : 0 ) ; //<S2SV> length += exthdrlen ; //<S2SV> transhdrlen += exthdrlen ; //<S2SV> dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; //<S2SV> } else { //<S2SV> rt = ( struct rt6_info * ) cork -> dst ; //<S2SV> fl6 = & inet -> cork . fl . u . ip6 ; //<S2SV> opt = np -> cork . opt ; //<S2SV> transhdrlen = 0 ; //<S2SV> exthdrlen = 0 ; //<S2SV> dst_exthdrlen = 0 ; //<S2SV> mtu = cork -> fragsize ; //<S2SV> } //<S2SV> hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; //<S2SV> fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + //<S2SV> ( opt ? opt -> opt_nflen : 0 ) ; //<S2SV> maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; //<S2SV> if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { //<S2SV> if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { //<S2SV> ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> } //<S2SV> if ( sk -> sk_type == SOCK_DGRAM ) //<S2SV> sock_tx_timestamp ( sk , & tx_flags ) ; //<S2SV> cork -> length += length ; //<S2SV> if ( length > mtu ) { //<S2SV> int proto = sk -> sk_protocol ; //<S2SV> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { //<S2SV> ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; //<S2SV> return - EMSGSIZE ; //<S2SV> } //<S2SV> if ( proto == IPPROTO_UDP && //<S2SV> ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { //<S2SV> err = ip6_ufo_append_data ( sk , getfrag , from , length , //<S2SV> hh_len , fragheaderlen , //<S2SV> transhdrlen , mtu , flags , rt ) ; //<S2SV> if ( err ) //<S2SV> goto error ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) //<S2SV> goto alloc_new_skb ; //<S2SV> while ( length > 0 ) { //<S2SV> copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; //<S2SV> if ( copy < length ) //<S2SV> copy = maxfraglen - skb -> len ; //<S2SV> if ( copy <= 0 ) { //<S2SV> char * data ; //<S2SV> unsigned int datalen ; //<S2SV> unsigned int fraglen ; //<S2SV> unsigned int fraggap ; //<S2SV> unsigned int alloclen ; //<S2SV> alloc_new_skb : //<S2SV> if ( skb ) //<S2SV> fraggap = skb -> len - maxfraglen ; //<S2SV> else //<S2SV> fraggap = 0 ; //<S2SV> if ( skb == NULL || skb_prev == NULL ) //<S2SV> ip6_append_data_mtu ( & mtu , & maxfraglen , //<S2SV> fragheaderlen , skb , rt , //<S2SV> np -> pmtudisc == //<S2SV> IPV6_PMTUDISC_PROBE ) ; //<S2SV> skb_prev = skb ; //<S2SV> datalen = length + fraggap ; //<S2SV> if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) //<S2SV> datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; //<S2SV> if ( ( flags & MSG_MORE ) && //<S2SV> ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) //<S2SV> alloclen = mtu ; //<S2SV> else //<S2SV> alloclen = datalen + fragheaderlen ; //<S2SV> alloclen += dst_exthdrlen ; //<S2SV> if ( datalen != length + fraggap ) { //<S2SV> datalen += rt -> dst . trailer_len ; //<S2SV> } //<S2SV> alloclen += rt -> dst . trailer_len ; //<S2SV> fraglen = datalen + fragheaderlen ; //<S2SV> alloclen += sizeof ( struct frag_hdr ) ; //<S2SV> if ( transhdrlen ) { //<S2SV> skb = sock_alloc_send_skb ( sk , //<S2SV> alloclen + hh_len , //<S2SV> ( flags & MSG_DONTWAIT ) , & err ) ; //<S2SV> } else { //<S2SV> skb = NULL ; //<S2SV> if ( atomic_read ( & sk -> sk_wmem_alloc ) <= //<S2SV> 2 * sk -> sk_sndbuf ) //<S2SV> skb = sock_wmalloc ( sk , //<S2SV> alloclen + hh_len , 1 , //<S2SV> sk -> sk_allocation ) ; //<S2SV> if ( unlikely ( skb == NULL ) ) //<S2SV> err = - ENOBUFS ; //<S2SV> else { //<S2SV> tx_flags = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( skb == NULL ) //<S2SV> goto error ; //<S2SV> skb -> ip_summed = CHECKSUM_NONE ; //<S2SV> skb -> csum = 0 ; //<S2SV> skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + //<S2SV> dst_exthdrlen ) ; //<S2SV> if ( sk -> sk_type == SOCK_DGRAM ) //<S2SV> skb_shinfo ( skb ) -> tx_flags = tx_flags ; //<S2SV> data = skb_put ( skb , fraglen ) ; //<S2SV> skb_set_network_header ( skb , exthdrlen ) ; //<S2SV> data += fragheaderlen ; //<S2SV> skb -> transport_header = ( skb -> network_header + //<S2SV> fragheaderlen ) ; //<S2SV> if ( fraggap ) { //<S2SV> skb -> csum = skb_copy_and_csum_bits ( //<S2SV> skb_prev , maxfraglen , //<S2SV> data + transhdrlen , fraggap , 0 ) ; //<S2SV> skb_prev -> csum = csum_sub ( skb_prev -> csum , //<S2SV> skb -> csum ) ; //<S2SV> data += fraggap ; //<S2SV> pskb_trim_unique ( skb_prev , maxfraglen ) ; //<S2SV> } //<S2SV> copy = datalen - transhdrlen - fraggap ; //<S2SV> if ( copy < 0 ) { //<S2SV> err = - EINVAL ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto error ; //<S2SV> } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { //<S2SV> err = - EFAULT ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> offset += copy ; //<S2SV> length -= datalen - fraggap ; //<S2SV> transhdrlen = 0 ; //<S2SV> exthdrlen = 0 ; //<S2SV> dst_exthdrlen = 0 ; //<S2SV> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( copy > length ) //<S2SV> copy = length ; //<S2SV> if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { //<S2SV> unsigned int off ; //<S2SV> off = skb -> len ; //<S2SV> if ( getfrag ( from , skb_put ( skb , copy ) , //<S2SV> offset , copy , off , skb ) < 0 ) { //<S2SV> __skb_trim ( skb , off ) ; //<S2SV> err = - EFAULT ; //<S2SV> goto error ; //<S2SV> } //<S2SV> } else { //<S2SV> int i = skb_shinfo ( skb ) -> nr_frags ; //<S2SV> struct page_frag * pfrag = sk_page_frag ( sk ) ; //<S2SV> err = - ENOMEM ; //<S2SV> if ( ! sk_page_frag_refill ( sk , pfrag ) ) //<S2SV> goto error ; //<S2SV> if ( ! skb_can_coalesce ( skb , i , pfrag -> page , //<S2SV> pfrag -> offset ) ) { //<S2SV> err = - EMSGSIZE ; //<S2SV> if ( i == MAX_SKB_FRAGS ) //<S2SV> goto error ; //<S2SV> __skb_fill_page_desc ( skb , i , pfrag -> page , //<S2SV> pfrag -> offset , 0 ) ; //<S2SV> skb_shinfo ( skb ) -> nr_frags = ++ i ; //<S2SV> get_page ( pfrag -> page ) ; //<S2SV> } //<S2SV> copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; //<S2SV> if ( getfrag ( from , //<S2SV> page_address ( pfrag -> page ) + pfrag -> offset , //<S2SV> offset , copy , skb -> len , skb ) < 0 ) //<S2SV> goto error_efault ; //<S2SV> pfrag -> offset += copy ; //<S2SV> skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; //<S2SV> skb -> len += copy ; //<S2SV> skb -> data_len += copy ; //<S2SV> skb -> truesize += copy ; //<S2SV> atomic_add ( copy , & sk -> sk_wmem_alloc ) ; //<S2SV> } //<S2SV> offset += copy ; //<S2SV> length -= copy ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> error_efault : //<S2SV> err = - EFAULT ; //<S2SV> error : //<S2SV> cork -> length -= length ; //<S2SV> IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 