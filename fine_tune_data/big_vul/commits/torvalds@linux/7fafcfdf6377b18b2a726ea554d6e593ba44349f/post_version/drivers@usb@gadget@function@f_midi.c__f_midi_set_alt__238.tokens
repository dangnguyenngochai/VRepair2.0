static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) //<S2SV> { //<S2SV> struct f_midi * midi = func_to_midi ( f ) ; //<S2SV> unsigned i ; //<S2SV> int err ; //<S2SV> if ( intf != midi -> ms_id ) //<S2SV> return 0 ; //<S2SV> err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> while ( kfifo_avail ( & midi -> in_req_fifo ) ) { //<S2SV> struct usb_request * req = //<S2SV> midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; //<S2SV> if ( req == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> req -> length = 0 ; //<S2SV> req -> complete = f_midi_complete ; //<S2SV> kfifo_put ( & midi -> in_req_fifo , req ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { //<S2SV> struct usb_request * req = //<S2SV> midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; //<S2SV> if ( req == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> req -> complete = f_midi_complete ; //<S2SV> err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; //<S2SV> if ( err ) { //<S2SV> ERROR ( midi , "%s:<S2SV_blank>couldn\'t<S2SV_blank>enqueue<S2SV_blank>request:<S2SV_blank>%d\\n" , //<S2SV> midi -> out_ep -> name , err ) ; //<S2SV> if ( req -> buf != NULL ) //<S2SV> free_ep_req ( midi -> out_ep , req ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 