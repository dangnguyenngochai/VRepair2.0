static void sas_eh_handle_sas_errors ( struct Scsi_Host * shost , struct list_head * work_q ) //<S2SV> { //<S2SV> struct scsi_cmnd * cmd , * n ; //<S2SV> enum task_disposition res = TASK_IS_DONE ; //<S2SV> int tmf_resp , need_reset ; //<S2SV> struct sas_internal * i = to_sas_internal ( shost -> transportt ) ; //<S2SV> unsigned long flags ; //<S2SV> struct sas_ha_struct * ha = SHOST_TO_SAS_HA ( shost ) ; //<S2SV> LIST_HEAD ( done ) ; //<S2SV> list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { //<S2SV> struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; //<S2SV> struct sas_task * task ; //<S2SV> spin_lock_irqsave ( & dev -> done_lock , flags ) ; //<S2SV> task = TO_SAS_TASK ( cmd ) ; //<S2SV> spin_unlock_irqrestore ( & dev -> done_lock , flags ) ; //<S2SV> if ( ! task ) //<S2SV> list_move_tail ( & cmd -> eh_entry , & done ) ; //<S2SV> } //<S2SV> Again : //<S2SV> list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { //<S2SV> struct sas_task * task = TO_SAS_TASK ( cmd ) ; //<S2SV> list_del_init ( & cmd -> eh_entry ) ; //<S2SV> spin_lock_irqsave ( & task -> task_state_lock , flags ) ; //<S2SV> need_reset = task -> task_state_flags & SAS_TASK_NEED_DEV_RESET ; //<S2SV> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; //<S2SV> if ( need_reset ) { //<S2SV> SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>requests<S2SV_blank>reset\\n" , //<S2SV> __func__ , task ) ; //<S2SV> goto reset ; //<S2SV> } //<S2SV> SAS_DPRINTK ( "trying<S2SV_blank>to<S2SV_blank>find<S2SV_blank>task<S2SV_blank>0x%p\\n" , task ) ; //<S2SV> res = sas_scsi_find_task ( task ) ; //<S2SV> switch ( res ) { //<S2SV> case TASK_IS_DONE : //<S2SV> SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\n" , __func__ , //<S2SV> task ) ; //<S2SV> sas_eh_defer_cmd ( cmd ) ; //<S2SV> continue ; //<S2SV> case TASK_IS_ABORTED : //<S2SV> SAS_DPRINTK ( "%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>aborted\\n" , //<S2SV> __func__ , task ) ; //<S2SV> sas_eh_defer_cmd ( cmd ) ; //<S2SV> continue ; //<S2SV> case TASK_IS_AT_LU : //<S2SV> SAS_DPRINTK ( "task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>lu<S2SV_blank>recover\\n" , task ) ; //<S2SV> reset : //<S2SV> tmf_resp = sas_recover_lu ( task -> dev , cmd ) ; //<S2SV> if ( tmf_resp == TMF_RESP_FUNC_COMPLETE ) { //<S2SV> SAS_DPRINTK ( "dev<S2SV_blank>%016llx<S2SV_blank>LU<S2SV_blank>%llx<S2SV_blank>is<S2SV_blank>" //<S2SV> "recovered\\n" , //<S2SV> SAS_ADDR ( task -> dev ) , //<S2SV> cmd -> device -> lun ) ; //<S2SV> sas_eh_defer_cmd ( cmd ) ; //<S2SV> sas_scsi_clear_queue_lu ( work_q , cmd ) ; //<S2SV> goto Again ; //<S2SV> } //<S2SV> case TASK_IS_NOT_AT_LU : //<S2SV> case TASK_ABORT_FAILED : //<S2SV> SAS_DPRINTK ( "task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>not<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>I_T<S2SV_blank>recover\\n" , //<S2SV> task ) ; //<S2SV> tmf_resp = sas_recover_I_T ( task -> dev ) ; //<S2SV> if ( tmf_resp == TMF_RESP_FUNC_COMPLETE || //<S2SV> tmf_resp == - ENODEV ) { //<S2SV> struct domain_device * dev = task -> dev ; //<S2SV> SAS_DPRINTK ( "I_T<S2SV_blank>%016llx<S2SV_blank>recovered\\n" , //<S2SV> SAS_ADDR ( task -> dev -> sas_addr ) ) ; //<S2SV> sas_eh_finish_cmd ( cmd ) ; //<S2SV> sas_scsi_clear_queue_I_T ( work_q , dev ) ; //<S2SV> goto Again ; //<S2SV> } //<S2SV> try_to_reset_cmd_device ( cmd ) ; //<S2SV> if ( i -> dft -> lldd_clear_nexus_port ) { //<S2SV> struct asd_sas_port * port = task -> dev -> port ; //<S2SV> SAS_DPRINTK ( "clearing<S2SV_blank>nexus<S2SV_blank>for<S2SV_blank>port:%d\\n" , //<S2SV> port -> id ) ; //<S2SV> res = i -> dft -> lldd_clear_nexus_port ( port ) ; //<S2SV> if ( res == TMF_RESP_FUNC_COMPLETE ) { //<S2SV> SAS_DPRINTK ( "clear<S2SV_blank>nexus<S2SV_blank>port:%d<S2SV_blank>" //<S2SV> "succeeded\\n" , port -> id ) ; //<S2SV> sas_eh_finish_cmd ( cmd ) ; //<S2SV> sas_scsi_clear_queue_port ( work_q , //<S2SV> port ) ; //<S2SV> goto Again ; //<S2SV> } //<S2SV> } //<S2SV> if ( i -> dft -> lldd_clear_nexus_ha ) { //<S2SV> SAS_DPRINTK ( "clear<S2SV_blank>nexus<S2SV_blank>ha\\n" ) ; //<S2SV> res = i -> dft -> lldd_clear_nexus_ha ( ha ) ; //<S2SV> if ( res == TMF_RESP_FUNC_COMPLETE ) { //<S2SV> SAS_DPRINTK ( "clear<S2SV_blank>nexus<S2SV_blank>ha<S2SV_blank>" //<S2SV> "succeeded\\n" ) ; //<S2SV> sas_eh_finish_cmd ( cmd ) ; //<S2SV> goto clear_q ; //<S2SV> } //<S2SV> } //<S2SV> SAS_DPRINTK ( "error<S2SV_blank>from<S2SV_blank><S2SV_blank>device<S2SV_blank>%llx,<S2SV_blank>LUN<S2SV_blank>%llx<S2SV_blank>" //<S2SV> "couldn\'t<S2SV_blank>be<S2SV_blank>recovered<S2SV_blank>in<S2SV_blank>any<S2SV_blank>way\\n" , //<S2SV> SAS_ADDR ( task -> dev -> sas_addr ) , //<S2SV> cmd -> device -> lun ) ; //<S2SV> sas_eh_finish_cmd ( cmd ) ; //<S2SV> goto clear_q ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> list_splice_tail ( & done , work_q ) ; //<S2SV> list_splice_tail_init ( & ha -> eh_ata_q , work_q ) ; //<S2SV> return ; //<S2SV> clear_q : //<S2SV> SAS_DPRINTK ( "---<S2SV_blank>Exit<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>clear_q\\n" , __func__ ) ; //<S2SV> list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) //<S2SV> sas_eh_finish_cmd ( cmd ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> 