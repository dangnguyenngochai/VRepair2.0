static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , //<S2SV> u32 val , ktime_t * abs_time , u32 bitset , //<S2SV> u32 __user * uaddr2 ) //<S2SV> { //<S2SV> struct hrtimer_sleeper timeout , * to = NULL ; //<S2SV> struct rt_mutex_waiter rt_waiter ; //<S2SV> struct rt_mutex * pi_mutex = NULL ; //<S2SV> struct futex_hash_bucket * hb ; //<S2SV> union futex_key key2 = FUTEX_KEY_INIT ; //<S2SV> struct futex_q q = futex_q_init ; //<S2SV> int res , ret ; //<S2SV> if ( uaddr == uaddr2 ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! bitset ) //<S2SV> return - EINVAL ; //<S2SV> if ( abs_time ) { //<S2SV> to = & timeout ; //<S2SV> hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? //<S2SV> CLOCK_REALTIME : CLOCK_MONOTONIC , //<S2SV> HRTIMER_MODE_ABS ) ; //<S2SV> hrtimer_init_sleeper ( to , current ) ; //<S2SV> hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , //<S2SV> current -> timer_slack_ns ) ; //<S2SV> } //<S2SV> debug_rt_mutex_init_waiter ( & rt_waiter ) ; //<S2SV> RB_CLEAR_NODE ( & rt_waiter . pi_tree_entry ) ; //<S2SV> RB_CLEAR_NODE ( & rt_waiter . tree_entry ) ; //<S2SV> rt_waiter . task = NULL ; //<S2SV> ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; //<S2SV> if ( unlikely ( ret != 0 ) ) //<S2SV> goto out ; //<S2SV> q . bitset = bitset ; //<S2SV> q . rt_waiter = & rt_waiter ; //<S2SV> q . requeue_pi_key = & key2 ; //<S2SV> ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; //<S2SV> if ( ret ) //<S2SV> goto out_key2 ; //<S2SV> futex_wait_queue_me ( hb , & q , to ) ; //<S2SV> spin_lock ( & hb -> lock ) ; //<S2SV> ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; //<S2SV> spin_unlock ( & hb -> lock ) ; //<S2SV> if ( ret ) //<S2SV> goto out_put_keys ; //<S2SV> if ( ! q . rt_waiter ) { //<S2SV> if ( q . pi_state && ( q . pi_state -> owner != current ) ) { //<S2SV> spin_lock ( q . lock_ptr ) ; //<S2SV> ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; //<S2SV> spin_unlock ( q . lock_ptr ) ; //<S2SV> } //<S2SV> } else { //<S2SV> WARN_ON ( ! q . pi_state ) ; //<S2SV> pi_mutex = & q . pi_state -> pi_mutex ; //<S2SV> ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; //<S2SV> debug_rt_mutex_free_waiter ( & rt_waiter ) ; //<S2SV> spin_lock ( q . lock_ptr ) ; //<S2SV> res = fixup_owner ( uaddr2 , & q , ! ret ) ; //<S2SV> if ( res ) //<S2SV> ret = ( res < 0 ) ? res : 0 ; //<S2SV> unqueue_me_pi ( & q ) ; //<S2SV> } //<S2SV> if ( ret == - EFAULT ) { //<S2SV> if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) //<S2SV> rt_mutex_unlock ( pi_mutex ) ; //<S2SV> } else if ( ret == - EINTR ) { //<S2SV> ret = - EWOULDBLOCK ; //<S2SV> } //<S2SV> out_put_keys : //<S2SV> put_futex_key ( & q . key ) ; //<S2SV> out_key2 : //<S2SV> put_futex_key ( & key2 ) ; //<S2SV> out : //<S2SV> if ( to ) { //<S2SV> hrtimer_cancel ( & to -> timer ) ; //<S2SV> destroy_hrtimer_on_stack ( & to -> timer ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 