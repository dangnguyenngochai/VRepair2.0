static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , //<S2SV> const struct in6_addr * force_saddr ) //<S2SV> { //<S2SV> struct net * net = dev_net ( skb -> dev ) ; //<S2SV> struct inet6_dev * idev = NULL ; //<S2SV> struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; //<S2SV> struct sock * sk ; //<S2SV> struct ipv6_pinfo * np ; //<S2SV> const struct in6_addr * saddr = NULL ; //<S2SV> struct dst_entry * dst ; //<S2SV> struct icmp6hdr tmp_hdr ; //<S2SV> struct flowi6 fl6 ; //<S2SV> struct icmpv6_msg msg ; //<S2SV> struct sockcm_cookie sockc_unused = { 0 } ; //<S2SV> struct ipcm6_cookie ipc6 ; //<S2SV> int iif = 0 ; //<S2SV> int addr_type = 0 ; //<S2SV> int len ; //<S2SV> int err = 0 ; //<S2SV> u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; //<S2SV> if ( ( u8 * ) hdr < skb -> head || //<S2SV> ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) //<S2SV> return ; //<S2SV> addr_type = ipv6_addr_type ( & hdr -> daddr ) ; //<S2SV> if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || //<S2SV> ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) //<S2SV> saddr = & hdr -> daddr ; //<S2SV> if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { //<S2SV> if ( type != ICMPV6_PKT_TOOBIG && //<S2SV> ! ( type == ICMPV6_PARAMPROB && //<S2SV> code == ICMPV6_UNK_OPTION && //<S2SV> ( opt_unrec ( skb , info ) ) ) ) //<S2SV> return ; //<S2SV> saddr = NULL ; //<S2SV> } //<S2SV> addr_type = ipv6_addr_type ( & hdr -> saddr ) ; //<S2SV> if ( __ipv6_addr_needs_scope_id ( addr_type ) ) //<S2SV> iif = skb -> dev -> ifindex ; //<S2SV> else { //<S2SV> dst = skb_dst ( skb ) ; //<S2SV> iif = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; //<S2SV> } //<S2SV> if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) { //<S2SV> net_dbg_ratelimited ( "icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , //<S2SV> & hdr -> saddr , & hdr -> daddr ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( is_ineligible ( skb ) ) { //<S2SV> net_dbg_ratelimited ( "icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , //<S2SV> & hdr -> saddr , & hdr -> daddr ) ; //<S2SV> return ; //<S2SV> } //<S2SV> mip6_addr_swap ( skb ) ; //<S2SV> memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; //<S2SV> fl6 . flowi6_proto = IPPROTO_ICMPV6 ; //<S2SV> fl6 . daddr = hdr -> saddr ; //<S2SV> if ( force_saddr ) //<S2SV> saddr = force_saddr ; //<S2SV> if ( saddr ) //<S2SV> fl6 . saddr = * saddr ; //<S2SV> fl6 . flowi6_mark = mark ; //<S2SV> fl6 . flowi6_oif = iif ; //<S2SV> fl6 . fl6_icmp_type = type ; //<S2SV> fl6 . fl6_icmp_code = code ; //<S2SV> security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; //<S2SV> sk = icmpv6_xmit_lock ( net ) ; //<S2SV> if ( ! sk ) //<S2SV> return ; //<S2SV> sk -> sk_mark = mark ; //<S2SV> np = inet6_sk ( sk ) ; //<S2SV> if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) //<S2SV> goto out ; //<S2SV> tmp_hdr . icmp6_type = type ; //<S2SV> tmp_hdr . icmp6_code = code ; //<S2SV> tmp_hdr . icmp6_cksum = 0 ; //<S2SV> tmp_hdr . icmp6_pointer = htonl ( info ) ; //<S2SV> if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) //<S2SV> fl6 . flowi6_oif = np -> mcast_oif ; //<S2SV> else if ( ! fl6 . flowi6_oif ) //<S2SV> fl6 . flowi6_oif = np -> ucast_oif ; //<S2SV> ipc6 . tclass = np -> tclass ; //<S2SV> fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; //<S2SV> dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; //<S2SV> if ( IS_ERR ( dst ) ) //<S2SV> goto out ; //<S2SV> ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; //<S2SV> ipc6 . dontfrag = np -> dontfrag ; //<S2SV> ipc6 . opt = NULL ; //<S2SV> msg . skb = skb ; //<S2SV> msg . offset = skb_network_offset ( skb ) ; //<S2SV> msg . type = type ; //<S2SV> len = skb -> len - msg . offset ; //<S2SV> len = min_t ( unsigned int , len , IPV6_MIN_MTU - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; //<S2SV> if ( len < 0 ) { //<S2SV> net_dbg_ratelimited ( "icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , //<S2SV> & hdr -> saddr , & hdr -> daddr ) ; //<S2SV> goto out_dst_release ; //<S2SV> } //<S2SV> rcu_read_lock ( ) ; //<S2SV> idev = __in6_dev_get ( skb -> dev ) ; //<S2SV> err = ip6_append_data ( sk , icmpv6_getfrag , & msg , //<S2SV> len + sizeof ( struct icmp6hdr ) , //<S2SV> sizeof ( struct icmp6hdr ) , //<S2SV> & ipc6 , & fl6 , ( struct rt6_info * ) dst , //<S2SV> MSG_DONTWAIT , & sockc_unused ) ; //<S2SV> if ( err ) { //<S2SV> ICMP6_INC_STATS ( net , idev , ICMP6_MIB_OUTERRORS ) ; //<S2SV> ip6_flush_pending_frames ( sk ) ; //<S2SV> } else { //<S2SV> err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , //<S2SV> len + sizeof ( struct icmp6hdr ) ) ; //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> out_dst_release : //<S2SV> dst_release ( dst ) ; //<S2SV> out : //<S2SV> icmpv6_xmit_unlock ( sk ) ; //<S2SV> } //<S2SV> 