static int udf_symlink_filler ( struct file * file , struct page * page ) //<S2SV> { //<S2SV> struct inode * inode = page -> mapping -> host ; //<S2SV> struct buffer_head * bh = NULL ; //<S2SV> unsigned char * symlink ; //<S2SV> int err = - EIO ; //<S2SV> unsigned char * p = kmap ( page ) ; //<S2SV> struct udf_inode_info * iinfo ; //<S2SV> uint32_t pos ; //<S2SV> iinfo = UDF_I ( inode ) ; //<S2SV> pos = udf_block_map ( inode , 0 ) ; //<S2SV> down_read ( & iinfo -> i_data_sem ) ; //<S2SV> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { //<S2SV> symlink = iinfo -> i_ext . i_data + iinfo -> i_lenEAttr ; //<S2SV> } else { //<S2SV> bh = sb_bread ( inode -> i_sb , pos ) ; //<S2SV> if ( ! bh ) //<S2SV> goto out ; //<S2SV> symlink = bh -> b_data ; //<S2SV> } //<S2SV> udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; //<S2SV> brelse ( bh ) ; //<S2SV> up_read ( & iinfo -> i_data_sem ) ; //<S2SV> SetPageUptodate ( page ) ; //<S2SV> kunmap ( page ) ; //<S2SV> unlock_page ( page ) ; //<S2SV> return 0 ; //<S2SV> out : //<S2SV> up_read ( & iinfo -> i_data_sem ) ; //<S2SV> SetPageError ( page ) ; //<S2SV> kunmap ( page ) ; //<S2SV> unlock_page ( page ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 