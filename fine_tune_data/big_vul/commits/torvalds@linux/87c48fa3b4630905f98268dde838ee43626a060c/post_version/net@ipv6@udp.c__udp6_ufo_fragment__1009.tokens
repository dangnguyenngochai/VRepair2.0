static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) //<S2SV> { //<S2SV> struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; //<S2SV> unsigned int mss ; //<S2SV> unsigned int unfrag_ip6hlen , unfrag_len ; //<S2SV> struct frag_hdr * fptr ; //<S2SV> u8 * mac_start , * prevhdr ; //<S2SV> u8 nexthdr ; //<S2SV> u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; //<S2SV> int offset ; //<S2SV> __wsum csum ; //<S2SV> mss = skb_shinfo ( skb ) -> gso_size ; //<S2SV> if ( unlikely ( skb -> len <= mss ) ) //<S2SV> goto out ; //<S2SV> if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { //<S2SV> int type = skb_shinfo ( skb ) -> gso_type ; //<S2SV> if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || //<S2SV> ! ( type & ( SKB_GSO_UDP ) ) ) ) //<S2SV> goto out ; //<S2SV> skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; //<S2SV> segs = NULL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> offset = skb_checksum_start_offset ( skb ) ; //<S2SV> csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; //<S2SV> offset += skb -> csum_offset ; //<S2SV> * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; //<S2SV> skb -> ip_summed = CHECKSUM_NONE ; //<S2SV> if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && //<S2SV> pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) //<S2SV> goto out ; //<S2SV> unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; //<S2SV> nexthdr = * prevhdr ; //<S2SV> * prevhdr = NEXTHDR_FRAGMENT ; //<S2SV> unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + //<S2SV> unfrag_ip6hlen ; //<S2SV> mac_start = skb_mac_header ( skb ) ; //<S2SV> memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ; //<S2SV> skb -> mac_header -= frag_hdr_sz ; //<S2SV> skb -> network_header -= frag_hdr_sz ; //<S2SV> fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; //<S2SV> fptr -> nexthdr = nexthdr ; //<S2SV> fptr -> reserved = 0 ; //<S2SV> ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ; //<S2SV> segs = skb_segment ( skb , features ) ; //<S2SV> out : //<S2SV> return segs ; //<S2SV> } //<S2SV> 