static inline int ip6_ufo_append_data ( struct sock * sk , //<S2SV> int getfrag ( void * from , char * to , int offset , int len , //<S2SV> int odd , struct sk_buff * skb ) , //<S2SV> void * from , int length , int hh_len , int fragheaderlen , //<S2SV> int transhdrlen , int mtu , unsigned int flags ) //<S2SV> { //<S2SV> struct sk_buff * skb ; //<S2SV> int err ; //<S2SV> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { //<S2SV> skb = sock_alloc_send_skb ( sk , //<S2SV> hh_len + fragheaderlen + transhdrlen + 20 , //<S2SV> ( flags & MSG_DONTWAIT ) , & err ) ; //<S2SV> if ( skb == NULL ) //<S2SV> return - ENOMEM ; //<S2SV> skb_reserve ( skb , hh_len ) ; //<S2SV> skb_put ( skb , fragheaderlen + transhdrlen ) ; //<S2SV> skb_reset_network_header ( skb ) ; //<S2SV> skb -> transport_header = skb -> network_header + fragheaderlen ; //<S2SV> skb -> ip_summed = CHECKSUM_PARTIAL ; //<S2SV> skb -> csum = 0 ; //<S2SV> } //<S2SV> err = skb_append_datato_frags ( sk , skb , getfrag , from , //<S2SV> ( length - transhdrlen ) ) ; //<S2SV> if ( ! err ) { //<S2SV> struct frag_hdr fhdr ; //<S2SV> skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - //<S2SV> sizeof ( struct frag_hdr ) ) & ~ 7 ; //<S2SV> skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; //<S2SV> ipv6_select_ident ( & fhdr ) ; //<S2SV> skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; //<S2SV> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> kfree_skb ( skb ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 