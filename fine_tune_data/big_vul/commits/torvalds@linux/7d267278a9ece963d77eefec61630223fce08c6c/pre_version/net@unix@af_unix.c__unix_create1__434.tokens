static struct sock * unix_create1 ( struct net * net , struct socket * sock , int kern ) //<S2SV> { //<S2SV> struct sock * sk = NULL ; //<S2SV> struct unix_sock * u ; //<S2SV> atomic_long_inc ( & unix_nr_socks ) ; //<S2SV> if ( atomic_long_read ( & unix_nr_socks ) > 2 * get_max_files ( ) ) //<S2SV> goto out ; //<S2SV> sk = sk_alloc ( net , PF_UNIX , GFP_KERNEL , & unix_proto , kern ) ; //<S2SV> if ( ! sk ) //<S2SV> goto out ; //<S2SV> sock_init_data ( sock , sk ) ; //<S2SV> lockdep_set_class ( & sk -> sk_receive_queue . lock , //<S2SV> & af_unix_sk_receive_queue_lock_key ) ; //<S2SV> sk -> sk_write_space = unix_write_space ; //<S2SV> sk -> sk_max_ack_backlog = net -> unx . sysctl_max_dgram_qlen ; //<S2SV> sk -> sk_destruct = unix_sock_destructor ; //<S2SV> u = unix_sk ( sk ) ; //<S2SV> u -> path . dentry = NULL ; //<S2SV> u -> path . mnt = NULL ; //<S2SV> spin_lock_init ( & u -> lock ) ; //<S2SV> atomic_long_set ( & u -> inflight , 0 ) ; //<S2SV> INIT_LIST_HEAD ( & u -> link ) ; //<S2SV> mutex_init ( & u -> readlock ) ; //<S2SV> init_waitqueue_head ( & u -> peer_wait ) ; //<S2SV> unix_insert_socket ( unix_sockets_unbound ( sk ) , sk ) ; //<S2SV> out : //<S2SV> if ( sk == NULL ) //<S2SV> atomic_long_dec ( & unix_nr_socks ) ; //<S2SV> else { //<S2SV> local_bh_disable ( ) ; //<S2SV> sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , 1 ) ; //<S2SV> local_bh_enable ( ) ; //<S2SV> } //<S2SV> return sk ; //<S2SV> } //<S2SV> 