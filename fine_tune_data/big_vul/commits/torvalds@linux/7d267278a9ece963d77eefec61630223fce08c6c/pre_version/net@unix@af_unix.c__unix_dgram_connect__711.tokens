static int unix_dgram_connect ( struct socket * sock , struct sockaddr * addr , //<S2SV> int alen , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct net * net = sock_net ( sk ) ; //<S2SV> struct sockaddr_un * sunaddr = ( struct sockaddr_un * ) addr ; //<S2SV> struct sock * other ; //<S2SV> unsigned int hash ; //<S2SV> int err ; //<S2SV> if ( addr -> sa_family != AF_UNSPEC ) { //<S2SV> err = unix_mkname ( sunaddr , alen , & hash ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out ; //<S2SV> alen = err ; //<S2SV> if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && //<S2SV> ! unix_sk ( sk ) -> addr && ( err = unix_autobind ( sock ) ) != 0 ) //<S2SV> goto out ; //<S2SV> restart : //<S2SV> other = unix_find_other ( net , sunaddr , alen , sock -> type , hash , & err ) ; //<S2SV> if ( ! other ) //<S2SV> goto out ; //<S2SV> unix_state_double_lock ( sk , other ) ; //<S2SV> if ( sock_flag ( other , SOCK_DEAD ) ) { //<S2SV> unix_state_double_unlock ( sk , other ) ; //<S2SV> sock_put ( other ) ; //<S2SV> goto restart ; //<S2SV> } //<S2SV> err = - EPERM ; //<S2SV> if ( ! unix_may_send ( sk , other ) ) //<S2SV> goto out_unlock ; //<S2SV> err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; //<S2SV> if ( err ) //<S2SV> goto out_unlock ; //<S2SV> } else { //<S2SV> other = NULL ; //<S2SV> unix_state_double_lock ( sk , other ) ; //<S2SV> } //<S2SV> if ( unix_peer ( sk ) ) { //<S2SV> struct sock * old_peer = unix_peer ( sk ) ; //<S2SV> unix_peer ( sk ) = other ; //<S2SV> unix_state_double_unlock ( sk , other ) ; //<S2SV> if ( other != old_peer ) //<S2SV> unix_dgram_disconnected ( sk , old_peer ) ; //<S2SV> sock_put ( old_peer ) ; //<S2SV> } else { //<S2SV> unix_peer ( sk ) = other ; //<S2SV> unix_state_double_unlock ( sk , other ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> out_unlock : //<S2SV> unix_state_double_unlock ( sk , other ) ; //<S2SV> sock_put ( other ) ; //<S2SV> out : //<S2SV> return err ; //<S2SV> } //<S2SV> 