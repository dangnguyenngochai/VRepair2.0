static void unix_release_sock ( struct sock * sk , int embrion ) //<S2SV> { //<S2SV> struct unix_sock * u = unix_sk ( sk ) ; //<S2SV> struct path path ; //<S2SV> struct sock * skpair ; //<S2SV> struct sk_buff * skb ; //<S2SV> int state ; //<S2SV> unix_remove_socket ( sk ) ; //<S2SV> unix_state_lock ( sk ) ; //<S2SV> sock_orphan ( sk ) ; //<S2SV> sk -> sk_shutdown = SHUTDOWN_MASK ; //<S2SV> path = u -> path ; //<S2SV> u -> path . dentry = NULL ; //<S2SV> u -> path . mnt = NULL ; //<S2SV> state = sk -> sk_state ; //<S2SV> sk -> sk_state = TCP_CLOSE ; //<S2SV> unix_state_unlock ( sk ) ; //<S2SV> wake_up_interruptible_all ( & u -> peer_wait ) ; //<S2SV> skpair = unix_peer ( sk ) ; //<S2SV> if ( skpair != NULL ) { //<S2SV> if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_SEQPACKET ) { //<S2SV> unix_state_lock ( skpair ) ; //<S2SV> skpair -> sk_shutdown = SHUTDOWN_MASK ; //<S2SV> if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) //<S2SV> skpair -> sk_err = ECONNRESET ; //<S2SV> unix_state_unlock ( skpair ) ; //<S2SV> skpair -> sk_state_change ( skpair ) ; //<S2SV> sk_wake_async ( skpair , SOCK_WAKE_WAITD , POLL_HUP ) ; //<S2SV> } //<S2SV> sock_put ( skpair ) ; //<S2SV> unix_peer ( sk ) = NULL ; //<S2SV> } //<S2SV> while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != NULL ) { //<S2SV> if ( state == TCP_LISTEN ) //<S2SV> unix_release_sock ( skb -> sk , 1 ) ; //<S2SV> UNIXCB ( skb ) . consumed = skb -> len ; //<S2SV> kfree_skb ( skb ) ; //<S2SV> } //<S2SV> if ( path . dentry ) //<S2SV> path_put ( & path ) ; //<S2SV> sock_put ( sk ) ; //<S2SV> if ( unix_tot_inflight ) //<S2SV> unix_gc ( ) ; //<S2SV> } //<S2SV> 