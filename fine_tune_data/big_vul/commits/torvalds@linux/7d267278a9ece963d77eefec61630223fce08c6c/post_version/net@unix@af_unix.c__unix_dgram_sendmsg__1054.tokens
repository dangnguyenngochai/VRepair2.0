static int unix_dgram_sendmsg ( struct socket * sock , struct msghdr * msg , //<S2SV> size_t len ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct net * net = sock_net ( sk ) ; //<S2SV> struct unix_sock * u = unix_sk ( sk ) ; //<S2SV> DECLARE_SOCKADDR ( struct sockaddr_un * , sunaddr , msg -> msg_name ) ; //<S2SV> struct sock * other = NULL ; //<S2SV> int namelen = 0 ; //<S2SV> int err ; //<S2SV> unsigned int hash ; //<S2SV> struct sk_buff * skb ; //<S2SV> long timeo ; //<S2SV> struct scm_cookie scm ; //<S2SV> int max_level ; //<S2SV> int data_len = 0 ; //<S2SV> int sk_locked ; //<S2SV> wait_for_unix_gc ( ) ; //<S2SV> err = scm_send ( sock , msg , & scm , false ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> err = - EOPNOTSUPP ; //<S2SV> if ( msg -> msg_flags & MSG_OOB ) //<S2SV> goto out ; //<S2SV> if ( msg -> msg_namelen ) { //<S2SV> err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out ; //<S2SV> namelen = err ; //<S2SV> } else { //<S2SV> sunaddr = NULL ; //<S2SV> err = - ENOTCONN ; //<S2SV> other = unix_peer_get ( sk ) ; //<S2SV> if ( ! other ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr //<S2SV> && ( err = unix_autobind ( sock ) ) != 0 ) //<S2SV> goto out ; //<S2SV> err = - EMSGSIZE ; //<S2SV> if ( len > sk -> sk_sndbuf - 32 ) //<S2SV> goto out ; //<S2SV> if ( len > SKB_MAX_ALLOC ) { //<S2SV> data_len = min_t ( size_t , //<S2SV> len - SKB_MAX_ALLOC , //<S2SV> MAX_SKB_FRAGS * PAGE_SIZE ) ; //<S2SV> data_len = PAGE_ALIGN ( data_len ) ; //<S2SV> BUILD_BUG_ON ( SKB_MAX_ALLOC < PAGE_SIZE ) ; //<S2SV> } //<S2SV> skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , //<S2SV> msg -> msg_flags & MSG_DONTWAIT , & err , //<S2SV> PAGE_ALLOC_COSTLY_ORDER ) ; //<S2SV> if ( skb == NULL ) //<S2SV> goto out ; //<S2SV> err = unix_scm_to_skb ( & scm , skb , true ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto out_free ; //<S2SV> max_level = err + 1 ; //<S2SV> skb_put ( skb , len - data_len ) ; //<S2SV> skb -> data_len = data_len ; //<S2SV> skb -> len = len ; //<S2SV> err = skb_copy_datagram_from_iter ( skb , 0 , & msg -> msg_iter , len ) ; //<S2SV> if ( err ) //<S2SV> goto out_free ; //<S2SV> timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; //<S2SV> restart : //<S2SV> if ( ! other ) { //<S2SV> err = - ECONNRESET ; //<S2SV> if ( sunaddr == NULL ) //<S2SV> goto out_free ; //<S2SV> other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , //<S2SV> hash , & err ) ; //<S2SV> if ( other == NULL ) //<S2SV> goto out_free ; //<S2SV> } //<S2SV> if ( sk_filter ( other , skb ) < 0 ) { //<S2SV> err = len ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> sk_locked = 0 ; //<S2SV> unix_state_lock ( other ) ; //<S2SV> restart_locked : //<S2SV> err = - EPERM ; //<S2SV> if ( ! unix_may_send ( sk , other ) ) //<S2SV> goto out_unlock ; //<S2SV> if ( unlikely ( sock_flag ( other , SOCK_DEAD ) ) ) { //<S2SV> unix_state_unlock ( other ) ; //<S2SV> sock_put ( other ) ; //<S2SV> if ( ! sk_locked ) //<S2SV> unix_state_lock ( sk ) ; //<S2SV> err = 0 ; //<S2SV> if ( unix_peer ( sk ) == other ) { //<S2SV> unix_peer ( sk ) = NULL ; //<S2SV> unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) ; //<S2SV> unix_state_unlock ( sk ) ; //<S2SV> unix_dgram_disconnected ( sk , other ) ; //<S2SV> sock_put ( other ) ; //<S2SV> err = - ECONNREFUSED ; //<S2SV> } else { //<S2SV> unix_state_unlock ( sk ) ; //<S2SV> } //<S2SV> other = NULL ; //<S2SV> if ( err ) //<S2SV> goto out_free ; //<S2SV> goto restart ; //<S2SV> } //<S2SV> err = - EPIPE ; //<S2SV> if ( other -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> goto out_unlock ; //<S2SV> if ( sk -> sk_type != SOCK_SEQPACKET ) { //<S2SV> err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; //<S2SV> if ( err ) //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> if ( unlikely ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) ) { //<S2SV> if ( timeo ) { //<S2SV> timeo = unix_wait_for_peer ( other , timeo ) ; //<S2SV> err = sock_intr_errno ( timeo ) ; //<S2SV> if ( signal_pending ( current ) ) //<S2SV> goto out_free ; //<S2SV> goto restart ; //<S2SV> } //<S2SV> if ( ! sk_locked ) { //<S2SV> unix_state_unlock ( other ) ; //<S2SV> unix_state_double_lock ( sk , other ) ; //<S2SV> } //<S2SV> if ( unix_peer ( sk ) != other || //<S2SV> unix_dgram_peer_wake_me ( sk , other ) ) { //<S2SV> err = - EAGAIN ; //<S2SV> sk_locked = 1 ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> if ( ! sk_locked ) { //<S2SV> sk_locked = 1 ; //<S2SV> goto restart_locked ; //<S2SV> } //<S2SV> } //<S2SV> if ( unlikely ( sk_locked ) ) //<S2SV> unix_state_unlock ( sk ) ; //<S2SV> if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) //<S2SV> __net_timestamp ( skb ) ; //<S2SV> maybe_add_creds ( skb , sock , other ) ; //<S2SV> skb_queue_tail ( & other -> sk_receive_queue , skb ) ; //<S2SV> if ( max_level > unix_sk ( other ) -> recursion_level ) //<S2SV> unix_sk ( other ) -> recursion_level = max_level ; //<S2SV> unix_state_unlock ( other ) ; //<S2SV> other -> sk_data_ready ( other ) ; //<S2SV> sock_put ( other ) ; //<S2SV> scm_destroy ( & scm ) ; //<S2SV> return len ; //<S2SV> out_unlock : //<S2SV> if ( sk_locked ) //<S2SV> unix_state_unlock ( sk ) ; //<S2SV> unix_state_unlock ( other ) ; //<S2SV> out_free : //<S2SV> kfree_skb ( skb ) ; //<S2SV> out : //<S2SV> if ( other ) //<S2SV> sock_put ( other ) ; //<S2SV> scm_destroy ( & scm ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 