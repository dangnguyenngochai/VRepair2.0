static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , //<S2SV> poll_table * wait ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk , * other ; //<S2SV> unsigned int mask , writable ; //<S2SV> sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; //<S2SV> mask = 0 ; //<S2SV> if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) //<S2SV> mask |= POLLERR | //<S2SV> ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; //<S2SV> if ( sk -> sk_shutdown & RCV_SHUTDOWN ) //<S2SV> mask |= POLLRDHUP | POLLIN | POLLRDNORM ; //<S2SV> if ( sk -> sk_shutdown == SHUTDOWN_MASK ) //<S2SV> mask |= POLLHUP ; //<S2SV> if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) //<S2SV> mask |= POLLIN | POLLRDNORM ; //<S2SV> if ( sk -> sk_type == SOCK_SEQPACKET ) { //<S2SV> if ( sk -> sk_state == TCP_CLOSE ) //<S2SV> mask |= POLLHUP ; //<S2SV> if ( sk -> sk_state == TCP_SYN_SENT ) //<S2SV> return mask ; //<S2SV> } //<S2SV> if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) //<S2SV> return mask ; //<S2SV> writable = unix_writable ( sk ) ; //<S2SV> if ( writable ) { //<S2SV> unix_state_lock ( sk ) ; //<S2SV> other = unix_peer ( sk ) ; //<S2SV> if ( other && unix_peer ( other ) != sk && //<S2SV> unix_recvq_full ( other ) && //<S2SV> unix_dgram_peer_wake_me ( sk , other ) ) //<S2SV> writable = 0 ; //<S2SV> unix_state_unlock ( sk ) ; //<S2SV> } //<S2SV> if ( writable ) //<S2SV> mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; //<S2SV> else //<S2SV> set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; //<S2SV> return mask ; //<S2SV> } //<S2SV> 