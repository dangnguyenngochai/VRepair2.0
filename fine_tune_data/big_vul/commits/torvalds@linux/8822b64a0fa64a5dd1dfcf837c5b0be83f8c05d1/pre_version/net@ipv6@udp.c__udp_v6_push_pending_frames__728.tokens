static int udp_v6_push_pending_frames ( struct sock * sk ) //<S2SV> { //<S2SV> struct sk_buff * skb ; //<S2SV> struct udphdr * uh ; //<S2SV> struct udp_sock * up = udp_sk ( sk ) ; //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ; //<S2SV> int err = 0 ; //<S2SV> int is_udplite = IS_UDPLITE ( sk ) ; //<S2SV> __wsum csum = 0 ; //<S2SV> if ( ( skb = skb_peek ( & sk -> sk_write_queue ) ) == NULL ) //<S2SV> goto out ; //<S2SV> uh = udp_hdr ( skb ) ; //<S2SV> uh -> source = fl6 -> fl6_sport ; //<S2SV> uh -> dest = fl6 -> fl6_dport ; //<S2SV> uh -> len = htons ( up -> len ) ; //<S2SV> uh -> check = 0 ; //<S2SV> if ( is_udplite ) //<S2SV> csum = udplite_csum_outgoing ( sk , skb ) ; //<S2SV> else if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { //<S2SV> udp6_hwcsum_outgoing ( sk , skb , & fl6 -> saddr , & fl6 -> daddr , //<S2SV> up -> len ) ; //<S2SV> goto send ; //<S2SV> } else //<S2SV> csum = udp_csum_outgoing ( sk , skb ) ; //<S2SV> uh -> check = csum_ipv6_magic ( & fl6 -> saddr , & fl6 -> daddr , //<S2SV> up -> len , fl6 -> flowi6_proto , csum ) ; //<S2SV> if ( uh -> check == 0 ) //<S2SV> uh -> check = CSUM_MANGLED_0 ; //<S2SV> send : //<S2SV> err = ip6_push_pending_frames ( sk ) ; //<S2SV> if ( err ) { //<S2SV> if ( err == - ENOBUFS && ! inet6_sk ( sk ) -> recverr ) { //<S2SV> UDP6_INC_STATS_USER ( sock_net ( sk ) , //<S2SV> UDP_MIB_SNDBUFERRORS , is_udplite ) ; //<S2SV> err = 0 ; //<S2SV> } //<S2SV> } else //<S2SV> UDP6_INC_STATS_USER ( sock_net ( sk ) , //<S2SV> UDP_MIB_OUTDATAGRAMS , is_udplite ) ; //<S2SV> out : //<S2SV> up -> len = 0 ; //<S2SV> up -> pending = 0 ; //<S2SV> return err ; //<S2SV> } //<S2SV> 