static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , //<S2SV> size_t count , loff_t * fpos ) //<S2SV> { //<S2SV> struct oz_pd * pd ; //<S2SV> struct oz_elt_buf * eb ; //<S2SV> struct oz_elt_info * ei ; //<S2SV> struct oz_elt * elt ; //<S2SV> struct oz_app_hdr * app_hdr ; //<S2SV> struct oz_serial_ctx * ctx ; //<S2SV> spin_lock_bh ( & g_cdev . lock ) ; //<S2SV> pd = g_cdev . active_pd ; //<S2SV> if ( pd ) //<S2SV> oz_pd_get ( pd ) ; //<S2SV> spin_unlock_bh ( & g_cdev . lock ) ; //<S2SV> if ( pd == NULL ) //<S2SV> return - ENXIO ; //<S2SV> if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) //<S2SV> return - EAGAIN ; //<S2SV> eb = & pd -> elt_buff ; //<S2SV> ei = oz_elt_info_alloc ( eb ) ; //<S2SV> if ( ei == NULL ) { //<S2SV> count = 0 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> elt = ( struct oz_elt * ) ei -> data ; //<S2SV> app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; //<S2SV> elt -> length = sizeof ( struct oz_app_hdr ) + count ; //<S2SV> elt -> type = OZ_ELT_APP_DATA ; //<S2SV> ei -> app_id = OZ_APPID_SERIAL ; //<S2SV> ei -> length = elt -> length + sizeof ( struct oz_elt ) ; //<S2SV> app_hdr -> app_id = OZ_APPID_SERIAL ; //<S2SV> if ( copy_from_user ( app_hdr + 1 , buf , count ) ) //<S2SV> goto out ; //<S2SV> spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; //<S2SV> ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; //<S2SV> if ( ctx ) { //<S2SV> app_hdr -> elt_seq_num = ctx -> tx_seq_num ++ ; //<S2SV> if ( ctx -> tx_seq_num == 0 ) //<S2SV> ctx -> tx_seq_num = 1 ; //<S2SV> spin_lock ( & eb -> lock ) ; //<S2SV> if ( oz_queue_elt_info ( eb , 0 , 0 , ei ) == 0 ) //<S2SV> ei = NULL ; //<S2SV> spin_unlock ( & eb -> lock ) ; //<S2SV> } //<S2SV> spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; //<S2SV> out : //<S2SV> if ( ei ) { //<S2SV> count = 0 ; //<S2SV> spin_lock_bh ( & eb -> lock ) ; //<S2SV> oz_elt_info_free ( eb , ei ) ; //<S2SV> spin_unlock_bh ( & eb -> lock ) ; //<S2SV> } //<S2SV> oz_pd_put ( pd ) ; //<S2SV> return count ; //<S2SV> } //<S2SV> 