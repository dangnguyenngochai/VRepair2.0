static void hid_input_field ( struct hid_device * hid , struct hid_field * field , //<S2SV> __u8 * data , int interrupt ) //<S2SV> { //<S2SV> unsigned n ; //<S2SV> unsigned count = field -> report_count ; //<S2SV> unsigned offset = field -> report_offset ; //<S2SV> unsigned size = field -> report_size ; //<S2SV> __s32 min = field -> logical_minimum ; //<S2SV> __s32 max = field -> logical_maximum ; //<S2SV> __s32 * value ; //<S2SV> value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; //<S2SV> if ( ! value ) //<S2SV> return ; //<S2SV> for ( n = 0 ; n < count ; n ++ ) { //<S2SV> value [ n ] = min < 0 ? //<S2SV> snto32 ( hid_field_extract ( hid , data , offset + n * size , //<S2SV> size ) , size ) : //<S2SV> hid_field_extract ( hid , data , offset + n * size , size ) ; //<S2SV> if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && //<S2SV> value [ n ] >= min && value [ n ] <= max && //<S2SV> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) //<S2SV> goto exit ; //<S2SV> } //<S2SV> for ( n = 0 ; n < count ; n ++ ) { //<S2SV> if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { //<S2SV> hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( field -> value [ n ] >= min && field -> value [ n ] <= max //<S2SV> && field -> usage [ field -> value [ n ] - min ] . hid //<S2SV> && search ( value , field -> value [ n ] , count ) ) //<S2SV> hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; //<S2SV> if ( value [ n ] >= min && value [ n ] <= max //<S2SV> && field -> usage [ value [ n ] - min ] . hid //<S2SV> && search ( field -> value , value [ n ] , count ) ) //<S2SV> hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; //<S2SV> } //<S2SV> memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; //<S2SV> exit : //<S2SV> kfree ( value ) ; //<S2SV> } //<S2SV> 