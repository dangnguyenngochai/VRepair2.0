SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) //<S2SV> { //<S2SV> int ufd ; //<S2SV> struct timerfd_ctx * ctx ; //<S2SV> BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; //<S2SV> BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; //<S2SV> if ( ( flags & ~ TFD_CREATE_FLAGS ) || //<S2SV> ( clockid != CLOCK_MONOTONIC && //<S2SV> clockid != CLOCK_REALTIME && //<S2SV> clockid != CLOCK_REALTIME_ALARM && //<S2SV> clockid != CLOCK_BOOTTIME && //<S2SV> clockid != CLOCK_BOOTTIME_ALARM ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! capable ( CAP_WAKE_ALARM ) && //<S2SV> ( clockid == CLOCK_REALTIME_ALARM || //<S2SV> clockid == CLOCK_BOOTTIME_ALARM ) ) //<S2SV> return - EPERM ; //<S2SV> ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; //<S2SV> if ( ! ctx ) //<S2SV> return - ENOMEM ; //<S2SV> init_waitqueue_head ( & ctx -> wqh ) ; //<S2SV> spin_lock_init ( & ctx -> cancel_lock ) ; //<S2SV> ctx -> clockid = clockid ; //<S2SV> if ( isalarm ( ctx ) ) //<S2SV> alarm_init ( & ctx -> t . alarm , //<S2SV> ctx -> clockid == CLOCK_REALTIME_ALARM ? //<S2SV> ALARM_REALTIME : ALARM_BOOTTIME , //<S2SV> timerfd_alarmproc ) ; //<S2SV> else //<S2SV> hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; //<S2SV> ctx -> moffs = ktime_mono_to_real ( 0 ) ; //<S2SV> ufd = anon_inode_getfd ( "[timerfd]" , & timerfd_fops , ctx , //<S2SV> O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; //<S2SV> if ( ufd < 0 ) //<S2SV> kfree ( ctx ) ; //<S2SV> return ufd ; //<S2SV> } //<S2SV> 