long dgnc_mgmt_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) //<S2SV> { //<S2SV> unsigned long flags ; //<S2SV> void __user * uarg = ( void __user * ) arg ; //<S2SV> switch ( cmd ) { //<S2SV> case DIGI_GETDD : //<S2SV> { //<S2SV> struct digi_dinfo ddi ; //<S2SV> spin_lock_irqsave ( & dgnc_global_lock , flags ) ; //<S2SV> memset ( & ddi , 0 , sizeof ( ddi ) ) ; //<S2SV> ddi . dinfo_nboards = dgnc_NumBoards ; //<S2SV> sprintf ( ddi . dinfo_version , "%s" , DG_PART ) ; //<S2SV> spin_unlock_irqrestore ( & dgnc_global_lock , flags ) ; //<S2SV> if ( copy_to_user ( uarg , & ddi , sizeof ( ddi ) ) ) //<S2SV> return - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> case DIGI_GETBD : //<S2SV> { //<S2SV> int brd ; //<S2SV> struct digi_info di ; //<S2SV> if ( copy_from_user ( & brd , uarg , sizeof ( int ) ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( brd < 0 || brd >= dgnc_NumBoards ) //<S2SV> return - ENODEV ; //<S2SV> memset ( & di , 0 , sizeof ( di ) ) ; //<S2SV> di . info_bdnum = brd ; //<S2SV> spin_lock_irqsave ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; //<S2SV> di . info_bdtype = dgnc_Board [ brd ] -> dpatype ; //<S2SV> di . info_bdstate = dgnc_Board [ brd ] -> dpastatus ; //<S2SV> di . info_ioport = 0 ; //<S2SV> di . info_physaddr = ( ulong ) dgnc_Board [ brd ] -> membase ; //<S2SV> di . info_physsize = ( ulong ) dgnc_Board [ brd ] -> membase //<S2SV> - dgnc_Board [ brd ] -> membase_end ; //<S2SV> if ( dgnc_Board [ brd ] -> state != BOARD_FAILED ) //<S2SV> di . info_nports = dgnc_Board [ brd ] -> nasync ; //<S2SV> else //<S2SV> di . info_nports = 0 ; //<S2SV> spin_unlock_irqrestore ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; //<S2SV> if ( copy_to_user ( uarg , & di , sizeof ( di ) ) ) //<S2SV> return - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> case DIGI_GET_NI_INFO : //<S2SV> { //<S2SV> struct channel_t * ch ; //<S2SV> struct ni_info ni ; //<S2SV> unsigned char mstat = 0 ; //<S2SV> uint board = 0 ; //<S2SV> uint channel = 0 ; //<S2SV> if ( copy_from_user ( & ni , uarg , sizeof ( ni ) ) ) //<S2SV> return - EFAULT ; //<S2SV> board = ni . board ; //<S2SV> channel = ni . channel ; //<S2SV> if ( board >= dgnc_NumBoards ) //<S2SV> return - ENODEV ; //<S2SV> if ( channel >= dgnc_Board [ board ] -> nasync ) //<S2SV> return - ENODEV ; //<S2SV> ch = dgnc_Board [ board ] -> channels [ channel ] ; //<S2SV> if ( ! ch || ch -> magic != DGNC_CHANNEL_MAGIC ) //<S2SV> return - ENODEV ; //<S2SV> memset ( & ni , 0 , sizeof ( ni ) ) ; //<S2SV> ni . board = board ; //<S2SV> ni . channel = channel ; //<S2SV> spin_lock_irqsave ( & ch -> ch_lock , flags ) ; //<S2SV> mstat = ( ch -> ch_mostat | ch -> ch_mistat ) ; //<S2SV> if ( mstat & UART_MCR_DTR ) { //<S2SV> ni . mstat |= TIOCM_DTR ; //<S2SV> ni . dtr = TIOCM_DTR ; //<S2SV> } //<S2SV> if ( mstat & UART_MCR_RTS ) { //<S2SV> ni . mstat |= TIOCM_RTS ; //<S2SV> ni . rts = TIOCM_RTS ; //<S2SV> } //<S2SV> if ( mstat & UART_MSR_CTS ) { //<S2SV> ni . mstat |= TIOCM_CTS ; //<S2SV> ni . cts = TIOCM_CTS ; //<S2SV> } //<S2SV> if ( mstat & UART_MSR_RI ) { //<S2SV> ni . mstat |= TIOCM_RI ; //<S2SV> ni . ri = TIOCM_RI ; //<S2SV> } //<S2SV> if ( mstat & UART_MSR_DCD ) { //<S2SV> ni . mstat |= TIOCM_CD ; //<S2SV> ni . dcd = TIOCM_CD ; //<S2SV> } //<S2SV> if ( mstat & UART_MSR_DSR ) //<S2SV> ni . mstat |= TIOCM_DSR ; //<S2SV> ni . iflag = ch -> ch_c_iflag ; //<S2SV> ni . oflag = ch -> ch_c_oflag ; //<S2SV> ni . cflag = ch -> ch_c_cflag ; //<S2SV> ni . lflag = ch -> ch_c_lflag ; //<S2SV> if ( ch -> ch_digi . digi_flags & CTSPACE || //<S2SV> ch -> ch_c_cflag & CRTSCTS ) //<S2SV> ni . hflow = 1 ; //<S2SV> else //<S2SV> ni . hflow = 0 ; //<S2SV> if ( ( ch -> ch_flags & CH_STOPI ) || //<S2SV> ( ch -> ch_flags & CH_FORCED_STOPI ) ) //<S2SV> ni . recv_stopped = 1 ; //<S2SV> else //<S2SV> ni . recv_stopped = 0 ; //<S2SV> if ( ( ch -> ch_flags & CH_STOP ) || ( ch -> ch_flags & CH_FORCED_STOP ) ) //<S2SV> ni . xmit_stopped = 1 ; //<S2SV> else //<S2SV> ni . xmit_stopped = 0 ; //<S2SV> ni . curtx = ch -> ch_txcount ; //<S2SV> ni . currx = ch -> ch_rxcount ; //<S2SV> ni . baud = ch -> ch_old_baud ; //<S2SV> spin_unlock_irqrestore ( & ch -> ch_lock , flags ) ; //<S2SV> if ( copy_to_user ( uarg , & ni , sizeof ( ni ) ) ) //<S2SV> return - EFAULT ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 