static ssize_t bat_socket_read ( struct file * file , char __user * buf , //<S2SV> size_t count , loff_t * ppos ) //<S2SV> { //<S2SV> struct socket_client * socket_client = file -> private_data ; //<S2SV> struct socket_packet * socket_packet ; //<S2SV> size_t packet_len ; //<S2SV> int error ; //<S2SV> if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) //<S2SV> return - EAGAIN ; //<S2SV> if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) //<S2SV> return - EFAULT ; //<S2SV> error = wait_event_interruptible ( socket_client -> queue_wait , //<S2SV> socket_client -> queue_len ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> spin_lock_bh ( & socket_client -> lock ) ; //<S2SV> socket_packet = list_first_entry ( & socket_client -> queue_list , //<S2SV> struct socket_packet , list ) ; //<S2SV> list_del ( & socket_packet -> list ) ; //<S2SV> socket_client -> queue_len -- ; //<S2SV> spin_unlock_bh ( & socket_client -> lock ) ; //<S2SV> error = copy_to_user ( buf , & socket_packet -> icmp_packet , //<S2SV> socket_packet -> icmp_len ) ; //<S2SV> packet_len = socket_packet -> icmp_len ; //<S2SV> kfree ( socket_packet ) ; //<S2SV> if ( error ) //<S2SV> return - EFAULT ; //<S2SV> return packet_len ; //<S2SV> } //<S2SV> 