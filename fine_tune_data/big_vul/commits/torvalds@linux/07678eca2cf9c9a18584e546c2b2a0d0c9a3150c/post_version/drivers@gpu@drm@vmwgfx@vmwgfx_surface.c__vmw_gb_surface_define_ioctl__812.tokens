int vmw_gb_surface_define_ioctl ( struct drm_device * dev , void * data , //<S2SV> struct drm_file * file_priv ) //<S2SV> { //<S2SV> struct vmw_private * dev_priv = vmw_priv ( dev ) ; //<S2SV> struct vmw_user_surface * user_srf ; //<S2SV> struct vmw_surface * srf ; //<S2SV> struct vmw_resource * res ; //<S2SV> struct vmw_resource * tmp ; //<S2SV> union drm_vmw_gb_surface_create_arg * arg = //<S2SV> ( union drm_vmw_gb_surface_create_arg * ) data ; //<S2SV> struct drm_vmw_gb_surface_create_req * req = & arg -> req ; //<S2SV> struct drm_vmw_gb_surface_create_rep * rep = & arg -> rep ; //<S2SV> struct ttm_object_file * tfile = vmw_fpriv ( file_priv ) -> tfile ; //<S2SV> int ret ; //<S2SV> uint32_t size ; //<S2SV> uint32_t backup_handle = 0 ; //<S2SV> if ( req -> multisample_count != 0 ) //<S2SV> return - EINVAL ; //<S2SV> if ( req -> mip_levels > DRM_VMW_MAX_MIP_LEVELS ) //<S2SV> return - EINVAL ; //<S2SV> if ( unlikely ( vmw_user_surface_size == 0 ) ) //<S2SV> vmw_user_surface_size = ttm_round_pot ( sizeof ( * user_srf ) ) + //<S2SV> 128 ; //<S2SV> size = vmw_user_surface_size + 128 ; //<S2SV> ret = vmw_surface_gb_priv_define ( dev , //<S2SV> size , //<S2SV> req -> svga3d_flags , //<S2SV> req -> format , //<S2SV> req -> drm_surface_flags & drm_vmw_surface_flag_scanout , //<S2SV> req -> mip_levels , //<S2SV> req -> multisample_count , //<S2SV> req -> array_size , //<S2SV> req -> base_size , //<S2SV> & srf ) ; //<S2SV> if ( unlikely ( ret != 0 ) ) //<S2SV> return ret ; //<S2SV> user_srf = container_of ( srf , struct vmw_user_surface , srf ) ; //<S2SV> if ( drm_is_primary_client ( file_priv ) ) //<S2SV> user_srf -> master = drm_master_get ( file_priv -> master ) ; //<S2SV> ret = ttm_read_lock ( & dev_priv -> reservation_sem , true ) ; //<S2SV> if ( unlikely ( ret != 0 ) ) //<S2SV> return ret ; //<S2SV> res = & user_srf -> srf . res ; //<S2SV> if ( req -> buffer_handle != SVGA3D_INVALID_ID ) { //<S2SV> ret = vmw_user_dmabuf_lookup ( tfile , req -> buffer_handle , //<S2SV> & res -> backup , //<S2SV> & user_srf -> backup_base ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> if ( res -> backup -> base . num_pages * PAGE_SIZE < //<S2SV> res -> backup_size ) { //<S2SV> DRM_ERROR ( "Surface<S2SV_blank>backup<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small.\\n" ) ; //<S2SV> vmw_dmabuf_unreference ( & res -> backup ) ; //<S2SV> ret = - EINVAL ; //<S2SV> goto out_unlock ; //<S2SV> } else { //<S2SV> backup_handle = req -> buffer_handle ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( req -> drm_surface_flags & drm_vmw_surface_flag_create_buffer ) //<S2SV> ret = vmw_user_dmabuf_alloc ( dev_priv , tfile , //<S2SV> res -> backup_size , //<S2SV> req -> drm_surface_flags & //<S2SV> drm_vmw_surface_flag_shareable , //<S2SV> & backup_handle , //<S2SV> & res -> backup , //<S2SV> & user_srf -> backup_base ) ; //<S2SV> if ( unlikely ( ret != 0 ) ) { //<S2SV> vmw_resource_unreference ( & res ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> tmp = vmw_resource_reference ( res ) ; //<S2SV> ret = ttm_prime_object_init ( tfile , res -> backup_size , & user_srf -> prime , //<S2SV> req -> drm_surface_flags & //<S2SV> drm_vmw_surface_flag_shareable , //<S2SV> VMW_RES_SURFACE , //<S2SV> & vmw_user_surface_base_release , NULL ) ; //<S2SV> if ( unlikely ( ret != 0 ) ) { //<S2SV> vmw_resource_unreference ( & tmp ) ; //<S2SV> vmw_resource_unreference ( & res ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> rep -> handle = user_srf -> prime . base . hash . key ; //<S2SV> rep -> backup_size = res -> backup_size ; //<S2SV> if ( res -> backup ) { //<S2SV> rep -> buffer_map_handle = //<S2SV> drm_vma_node_offset_addr ( & res -> backup -> base . vma_node ) ; //<S2SV> rep -> buffer_size = res -> backup -> base . num_pages * PAGE_SIZE ; //<S2SV> rep -> buffer_handle = backup_handle ; //<S2SV> } else { //<S2SV> rep -> buffer_map_handle = 0 ; //<S2SV> rep -> buffer_size = 0 ; //<S2SV> rep -> buffer_handle = SVGA3D_INVALID_ID ; //<S2SV> } //<S2SV> vmw_resource_unreference ( & res ) ; //<S2SV> out_unlock : //<S2SV> ttm_read_unlock ( & dev_priv -> reservation_sem ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 