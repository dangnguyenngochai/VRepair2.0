static int raw_cmd_copyin ( int cmd , void __user * param , //<S2SV> struct floppy_raw_cmd * * rcmd ) //<S2SV> { //<S2SV> struct floppy_raw_cmd * ptr ; //<S2SV> int ret ; //<S2SV> int i ; //<S2SV> * rcmd = NULL ; //<S2SV> loop : //<S2SV> ptr = kmalloc ( sizeof ( struct floppy_raw_cmd ) , GFP_USER ) ; //<S2SV> if ( ! ptr ) //<S2SV> return - ENOMEM ; //<S2SV> * rcmd = ptr ; //<S2SV> ret = copy_from_user ( ptr , param , sizeof ( * ptr ) ) ; //<S2SV> ptr -> next = NULL ; //<S2SV> ptr -> buffer_length = 0 ; //<S2SV> ptr -> kernel_data = NULL ; //<S2SV> if ( ret ) //<S2SV> return - EFAULT ; //<S2SV> param += sizeof ( struct floppy_raw_cmd ) ; //<S2SV> if ( ptr -> cmd_count > 33 ) //<S2SV> return - EINVAL ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> ptr -> reply [ i ] = 0 ; //<S2SV> ptr -> resultcode = 0 ; //<S2SV> if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) { //<S2SV> if ( ptr -> length <= 0 ) //<S2SV> return - EINVAL ; //<S2SV> ptr -> kernel_data = ( char * ) fd_dma_mem_alloc ( ptr -> length ) ; //<S2SV> fallback_on_nodma_alloc ( & ptr -> kernel_data , ptr -> length ) ; //<S2SV> if ( ! ptr -> kernel_data ) //<S2SV> return - ENOMEM ; //<S2SV> ptr -> buffer_length = ptr -> length ; //<S2SV> } //<S2SV> if ( ptr -> flags & FD_RAW_WRITE ) { //<S2SV> ret = fd_copyin ( ptr -> data , ptr -> kernel_data , ptr -> length ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( ptr -> flags & FD_RAW_MORE ) { //<S2SV> rcmd = & ( ptr -> next ) ; //<S2SV> ptr -> rate &= 0x43 ; //<S2SV> goto loop ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 