int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , //<S2SV> size_t size , int flags ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> struct atm_vcc * vcc ; //<S2SV> struct sk_buff * skb ; //<S2SV> int copied , error = - EINVAL ; //<S2SV> if ( sock -> state != SS_CONNECTED ) //<S2SV> return - ENOTCONN ; //<S2SV> if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> vcc = ATM_SD ( sock ) ; //<S2SV> if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || //<S2SV> test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || //<S2SV> ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) //<S2SV> return 0 ; //<S2SV> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; //<S2SV> if ( ! skb ) //<S2SV> return error ; //<S2SV> copied = skb -> len ; //<S2SV> if ( copied > size ) { //<S2SV> copied = size ; //<S2SV> msg -> msg_flags |= MSG_TRUNC ; //<S2SV> } //<S2SV> error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; //<S2SV> if ( error ) //<S2SV> return error ; //<S2SV> sock_recv_ts_and_drops ( msg , sk , skb ) ; //<S2SV> if ( ! ( flags & MSG_PEEK ) ) { //<S2SV> pr_debug ( "%d<S2SV_blank>-=<S2SV_blank>%d\\n" , atomic_read ( & sk -> sk_rmem_alloc ) , //<S2SV> skb -> truesize ) ; //<S2SV> atm_return ( vcc , skb -> truesize ) ; //<S2SV> } //<S2SV> skb_free_datagram ( sk , skb ) ; //<S2SV> return copied ; //<S2SV> } //<S2SV> 