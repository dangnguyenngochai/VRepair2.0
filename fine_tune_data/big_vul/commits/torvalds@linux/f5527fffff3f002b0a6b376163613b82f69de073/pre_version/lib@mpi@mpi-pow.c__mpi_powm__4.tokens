int mpi_powm ( MPI res , MPI base , MPI exp , MPI mod ) //<S2SV> { //<S2SV> mpi_ptr_t mp_marker = NULL , bp_marker = NULL , ep_marker = NULL ; //<S2SV> mpi_ptr_t xp_marker = NULL ; //<S2SV> mpi_ptr_t tspace = NULL ; //<S2SV> mpi_ptr_t rp , ep , mp , bp ; //<S2SV> mpi_size_t esize , msize , bsize , rsize ; //<S2SV> int esign , msign , bsign , rsign ; //<S2SV> mpi_size_t size ; //<S2SV> int mod_shift_cnt ; //<S2SV> int negative_result ; //<S2SV> int assign_rp = 0 ; //<S2SV> mpi_size_t tsize = 0 ; //<S2SV> int rc = - ENOMEM ; //<S2SV> esize = exp -> nlimbs ; //<S2SV> msize = mod -> nlimbs ; //<S2SV> size = 2 * msize ; //<S2SV> esign = exp -> sign ; //<S2SV> msign = mod -> sign ; //<S2SV> rp = res -> d ; //<S2SV> ep = exp -> d ; //<S2SV> if ( ! msize ) //<S2SV> return - EINVAL ; //<S2SV> if ( ! esize ) { //<S2SV> rp [ 0 ] = 1 ; //<S2SV> res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ; //<S2SV> res -> sign = 0 ; //<S2SV> goto leave ; //<S2SV> } //<S2SV> mp = mp_marker = mpi_alloc_limb_space ( msize ) ; //<S2SV> if ( ! mp ) //<S2SV> goto enomem ; //<S2SV> mod_shift_cnt = count_leading_zeros ( mod -> d [ msize - 1 ] ) ; //<S2SV> if ( mod_shift_cnt ) //<S2SV> mpihelp_lshift ( mp , mod -> d , msize , mod_shift_cnt ) ; //<S2SV> else //<S2SV> MPN_COPY ( mp , mod -> d , msize ) ; //<S2SV> bsize = base -> nlimbs ; //<S2SV> bsign = base -> sign ; //<S2SV> if ( bsize > msize ) { //<S2SV> bp = bp_marker = mpi_alloc_limb_space ( bsize + 1 ) ; //<S2SV> if ( ! bp ) //<S2SV> goto enomem ; //<S2SV> MPN_COPY ( bp , base -> d , bsize ) ; //<S2SV> mpihelp_divrem ( bp + msize , 0 , bp , bsize , mp , msize ) ; //<S2SV> bsize = msize ; //<S2SV> MPN_NORMALIZE ( bp , bsize ) ; //<S2SV> } else //<S2SV> bp = base -> d ; //<S2SV> if ( ! bsize ) { //<S2SV> res -> nlimbs = 0 ; //<S2SV> res -> sign = 0 ; //<S2SV> goto leave ; //<S2SV> } //<S2SV> if ( res -> alloced < size ) { //<S2SV> if ( rp == ep || rp == mp || rp == bp ) { //<S2SV> rp = mpi_alloc_limb_space ( size ) ; //<S2SV> if ( ! rp ) //<S2SV> goto enomem ; //<S2SV> assign_rp = 1 ; //<S2SV> } else { //<S2SV> if ( mpi_resize ( res , size ) < 0 ) //<S2SV> goto enomem ; //<S2SV> rp = res -> d ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( rp == bp ) { //<S2SV> BUG_ON ( bp_marker ) ; //<S2SV> bp = bp_marker = mpi_alloc_limb_space ( bsize ) ; //<S2SV> if ( ! bp ) //<S2SV> goto enomem ; //<S2SV> MPN_COPY ( bp , rp , bsize ) ; //<S2SV> } //<S2SV> if ( rp == ep ) { //<S2SV> ep = ep_marker = mpi_alloc_limb_space ( esize ) ; //<S2SV> if ( ! ep ) //<S2SV> goto enomem ; //<S2SV> MPN_COPY ( ep , rp , esize ) ; //<S2SV> } //<S2SV> if ( rp == mp ) { //<S2SV> BUG_ON ( mp_marker ) ; //<S2SV> mp = mp_marker = mpi_alloc_limb_space ( msize ) ; //<S2SV> if ( ! mp ) //<S2SV> goto enomem ; //<S2SV> MPN_COPY ( mp , rp , msize ) ; //<S2SV> } //<S2SV> } //<S2SV> MPN_COPY ( rp , bp , bsize ) ; //<S2SV> rsize = bsize ; //<S2SV> rsign = bsign ; //<S2SV> { //<S2SV> mpi_size_t i ; //<S2SV> mpi_ptr_t xp ; //<S2SV> int c ; //<S2SV> mpi_limb_t e ; //<S2SV> mpi_limb_t carry_limb ; //<S2SV> struct karatsuba_ctx karactx ; //<S2SV> xp = xp_marker = mpi_alloc_limb_space ( 2 * ( msize + 1 ) ) ; //<S2SV> if ( ! xp ) //<S2SV> goto enomem ; //<S2SV> memset ( & karactx , 0 , sizeof karactx ) ; //<S2SV> negative_result = ( ep [ 0 ] & 1 ) && base -> sign ; //<S2SV> i = esize - 1 ; //<S2SV> e = ep [ i ] ; //<S2SV> c = count_leading_zeros ( e ) ; //<S2SV> e = ( e << c ) << 1 ; //<S2SV> c = BITS_PER_MPI_LIMB - 1 - c ; //<S2SV> for ( ; ; ) { //<S2SV> while ( c ) { //<S2SV> mpi_ptr_t tp ; //<S2SV> mpi_size_t xsize ; //<S2SV> if ( rsize < KARATSUBA_THRESHOLD ) //<S2SV> mpih_sqr_n_basecase ( xp , rp , rsize ) ; //<S2SV> else { //<S2SV> if ( ! tspace ) { //<S2SV> tsize = 2 * rsize ; //<S2SV> tspace = //<S2SV> mpi_alloc_limb_space ( tsize ) ; //<S2SV> if ( ! tspace ) //<S2SV> goto enomem ; //<S2SV> } else if ( tsize < ( 2 * rsize ) ) { //<S2SV> mpi_free_limb_space ( tspace ) ; //<S2SV> tsize = 2 * rsize ; //<S2SV> tspace = //<S2SV> mpi_alloc_limb_space ( tsize ) ; //<S2SV> if ( ! tspace ) //<S2SV> goto enomem ; //<S2SV> } //<S2SV> mpih_sqr_n ( xp , rp , rsize , tspace ) ; //<S2SV> } //<S2SV> xsize = 2 * rsize ; //<S2SV> if ( xsize > msize ) { //<S2SV> mpihelp_divrem ( xp + msize , 0 , xp , xsize , //<S2SV> mp , msize ) ; //<S2SV> xsize = msize ; //<S2SV> } //<S2SV> tp = rp ; //<S2SV> rp = xp ; //<S2SV> xp = tp ; //<S2SV> rsize = xsize ; //<S2SV> if ( ( mpi_limb_signed_t ) e < 0 ) { //<S2SV> if ( bsize < KARATSUBA_THRESHOLD ) { //<S2SV> mpi_limb_t tmp ; //<S2SV> if ( mpihelp_mul //<S2SV> ( xp , rp , rsize , bp , bsize , //<S2SV> & tmp ) < 0 ) //<S2SV> goto enomem ; //<S2SV> } else { //<S2SV> if ( mpihelp_mul_karatsuba_case //<S2SV> ( xp , rp , rsize , bp , bsize , //<S2SV> & karactx ) < 0 ) //<S2SV> goto enomem ; //<S2SV> } //<S2SV> xsize = rsize + bsize ; //<S2SV> if ( xsize > msize ) { //<S2SV> mpihelp_divrem ( xp + msize , 0 , //<S2SV> xp , xsize , mp , //<S2SV> msize ) ; //<S2SV> xsize = msize ; //<S2SV> } //<S2SV> tp = rp ; //<S2SV> rp = xp ; //<S2SV> xp = tp ; //<S2SV> rsize = xsize ; //<S2SV> } //<S2SV> e <<= 1 ; //<S2SV> c -- ; //<S2SV> } //<S2SV> i -- ; //<S2SV> if ( i < 0 ) //<S2SV> break ; //<S2SV> e = ep [ i ] ; //<S2SV> c = BITS_PER_MPI_LIMB ; //<S2SV> } //<S2SV> if ( mod_shift_cnt ) { //<S2SV> carry_limb = //<S2SV> mpihelp_lshift ( res -> d , rp , rsize , mod_shift_cnt ) ; //<S2SV> rp = res -> d ; //<S2SV> if ( carry_limb ) { //<S2SV> rp [ rsize ] = carry_limb ; //<S2SV> rsize ++ ; //<S2SV> } //<S2SV> } else { //<S2SV> MPN_COPY ( res -> d , rp , rsize ) ; //<S2SV> rp = res -> d ; //<S2SV> } //<S2SV> if ( rsize >= msize ) { //<S2SV> mpihelp_divrem ( rp + msize , 0 , rp , rsize , mp , msize ) ; //<S2SV> rsize = msize ; //<S2SV> } //<S2SV> if ( mod_shift_cnt ) //<S2SV> mpihelp_rshift ( rp , rp , rsize , mod_shift_cnt ) ; //<S2SV> MPN_NORMALIZE ( rp , rsize ) ; //<S2SV> mpihelp_release_karatsuba_ctx ( & karactx ) ; //<S2SV> } //<S2SV> if ( negative_result && rsize ) { //<S2SV> if ( mod_shift_cnt ) //<S2SV> mpihelp_rshift ( mp , mp , msize , mod_shift_cnt ) ; //<S2SV> mpihelp_sub ( rp , mp , msize , rp , rsize ) ; //<S2SV> rsize = msize ; //<S2SV> rsign = msign ; //<S2SV> MPN_NORMALIZE ( rp , rsize ) ; //<S2SV> } //<S2SV> res -> nlimbs = rsize ; //<S2SV> res -> sign = rsign ; //<S2SV> leave : //<S2SV> rc = 0 ; //<S2SV> enomem : //<S2SV> if ( assign_rp ) //<S2SV> mpi_assign_limb_space ( res , rp , size ) ; //<S2SV> if ( mp_marker ) //<S2SV> mpi_free_limb_space ( mp_marker ) ; //<S2SV> if ( bp_marker ) //<S2SV> mpi_free_limb_space ( bp_marker ) ; //<S2SV> if ( ep_marker ) //<S2SV> mpi_free_limb_space ( ep_marker ) ; //<S2SV> if ( xp_marker ) //<S2SV> mpi_free_limb_space ( xp_marker ) ; //<S2SV> if ( tspace ) //<S2SV> mpi_free_limb_space ( tspace ) ; //<S2SV> return rc ; //<S2SV> } //<S2SV> 