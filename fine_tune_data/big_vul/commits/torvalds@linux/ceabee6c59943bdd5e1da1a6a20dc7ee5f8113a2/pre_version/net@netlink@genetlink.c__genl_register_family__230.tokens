int genl_register_family ( struct genl_family * family ) //<S2SV> { //<S2SV> int err , i ; //<S2SV> int start = GENL_START_ALLOC , end = GENL_MAX_ID ; //<S2SV> err = genl_validate_ops ( family ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> genl_lock_all ( ) ; //<S2SV> if ( genl_family_find_byname ( family -> name ) ) { //<S2SV> err = - EEXIST ; //<S2SV> goto errout_locked ; //<S2SV> } //<S2SV> if ( family == & genl_ctrl ) { //<S2SV> start = end = GENL_ID_CTRL ; //<S2SV> } else if ( strcmp ( family -> name , "pmcraid" ) == 0 ) { //<S2SV> start = end = GENL_ID_PMCRAID ; //<S2SV> } else if ( strcmp ( family -> name , "VFS_DQUOT" ) == 0 ) { //<S2SV> start = end = GENL_ID_VFS_DQUOT ; //<S2SV> } //<S2SV> if ( family -> maxattr && ! family -> parallel_ops ) { //<S2SV> family -> attrbuf = kmalloc_array ( family -> maxattr + 1 , //<S2SV> sizeof ( struct nlattr * ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( family -> attrbuf == NULL ) { //<S2SV> err = - ENOMEM ; //<S2SV> goto errout_locked ; //<S2SV> } //<S2SV> } else //<S2SV> family -> attrbuf = NULL ; //<S2SV> family -> id = idr_alloc ( & genl_fam_idr , family , //<S2SV> start , end + 1 , GFP_KERNEL ) ; //<S2SV> if ( family -> id < 0 ) { //<S2SV> err = family -> id ; //<S2SV> goto errout_locked ; //<S2SV> } //<S2SV> err = genl_validate_assign_mc_groups ( family ) ; //<S2SV> if ( err ) //<S2SV> goto errout_remove ; //<S2SV> genl_unlock_all ( ) ; //<S2SV> genl_ctrl_event ( CTRL_CMD_NEWFAMILY , family , NULL , 0 ) ; //<S2SV> for ( i = 0 ; i < family -> n_mcgrps ; i ++ ) //<S2SV> genl_ctrl_event ( CTRL_CMD_NEWMCAST_GRP , family , //<S2SV> & family -> mcgrps [ i ] , family -> mcgrp_offset + i ) ; //<S2SV> return 0 ; //<S2SV> errout_remove : //<S2SV> idr_remove ( & genl_fam_idr , family -> id ) ; //<S2SV> kfree ( family -> attrbuf ) ; //<S2SV> errout_locked : //<S2SV> genl_unlock_all ( ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 