int tipc_nl_publ_dump ( struct sk_buff * skb , struct netlink_callback * cb ) //<S2SV> { //<S2SV> int err ; //<S2SV> u32 tsk_portid = cb -> args [ 0 ] ; //<S2SV> u32 last_publ = cb -> args [ 1 ] ; //<S2SV> u32 done = cb -> args [ 2 ] ; //<S2SV> struct net * net = sock_net ( skb -> sk ) ; //<S2SV> struct tipc_sock * tsk ; //<S2SV> if ( ! tsk_portid ) { //<S2SV> struct nlattr * * attrs ; //<S2SV> struct nlattr * sock [ TIPC_NLA_SOCK_MAX + 1 ] ; //<S2SV> err = tipc_nlmsg_parse ( cb -> nlh , & attrs ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( ! attrs [ TIPC_NLA_SOCK ] ) //<S2SV> return - EINVAL ; //<S2SV> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , //<S2SV> attrs [ TIPC_NLA_SOCK ] , //<S2SV> tipc_nl_sock_policy ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( ! sock [ TIPC_NLA_SOCK_REF ] ) //<S2SV> return - EINVAL ; //<S2SV> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; //<S2SV> } //<S2SV> if ( done ) //<S2SV> return 0 ; //<S2SV> tsk = tipc_sk_lookup ( net , tsk_portid ) ; //<S2SV> if ( ! tsk ) //<S2SV> return - EINVAL ; //<S2SV> lock_sock ( & tsk -> sk ) ; //<S2SV> err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ; //<S2SV> if ( ! err ) //<S2SV> done = 1 ; //<S2SV> release_sock ( & tsk -> sk ) ; //<S2SV> sock_put ( & tsk -> sk ) ; //<S2SV> cb -> args [ 0 ] = tsk_portid ; //<S2SV> cb -> args [ 1 ] = last_publ ; //<S2SV> cb -> args [ 2 ] = done ; //<S2SV> return skb -> len ; //<S2SV> } //<S2SV> 