void sctp_assoc_update ( struct sctp_association * asoc , //<S2SV> struct sctp_association * new ) //<S2SV> { //<S2SV> struct sctp_transport * trans ; //<S2SV> struct list_head * pos , * temp ; //<S2SV> asoc -> c = new -> c ; //<S2SV> asoc -> peer . rwnd = new -> peer . rwnd ; //<S2SV> asoc -> peer . sack_needed = new -> peer . sack_needed ; //<S2SV> asoc -> peer . auth_capable = new -> peer . auth_capable ; //<S2SV> asoc -> peer . i = new -> peer . i ; //<S2SV> sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , //<S2SV> asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; //<S2SV> list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { //<S2SV> trans = list_entry ( pos , struct sctp_transport , transports ) ; //<S2SV> if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { //<S2SV> sctp_assoc_rm_peer ( asoc , trans ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) //<S2SV> sctp_transport_reset ( trans ) ; //<S2SV> } //<S2SV> if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { //<S2SV> asoc -> next_tsn = new -> next_tsn ; //<S2SV> asoc -> ctsn_ack_point = new -> ctsn_ack_point ; //<S2SV> asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; //<S2SV> sctp_ssnmap_clear ( asoc -> ssnmap ) ; //<S2SV> sctp_ulpq_flush ( & asoc -> ulpq ) ; //<S2SV> asoc -> overall_error_count = 0 ; //<S2SV> } else { //<S2SV> list_for_each_entry ( trans , & new -> peer . transport_addr_list , //<S2SV> transports ) { //<S2SV> if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) //<S2SV> sctp_assoc_add_peer ( asoc , & trans -> ipaddr , //<S2SV> GFP_ATOMIC , trans -> state ) ; //<S2SV> } //<S2SV> asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; //<S2SV> asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; //<S2SV> if ( ! asoc -> ssnmap ) { //<S2SV> asoc -> ssnmap = new -> ssnmap ; //<S2SV> new -> ssnmap = NULL ; //<S2SV> } //<S2SV> if ( ! asoc -> assoc_id ) { //<S2SV> sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; //<S2SV> } //<S2SV> } //<S2SV> kfree ( asoc -> peer . peer_random ) ; //<S2SV> asoc -> peer . peer_random = new -> peer . peer_random ; //<S2SV> new -> peer . peer_random = NULL ; //<S2SV> kfree ( asoc -> peer . peer_chunks ) ; //<S2SV> asoc -> peer . peer_chunks = new -> peer . peer_chunks ; //<S2SV> new -> peer . peer_chunks = NULL ; //<S2SV> kfree ( asoc -> peer . peer_hmacs ) ; //<S2SV> asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; //<S2SV> new -> peer . peer_hmacs = NULL ; //<S2SV> sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; //<S2SV> } //<S2SV> 