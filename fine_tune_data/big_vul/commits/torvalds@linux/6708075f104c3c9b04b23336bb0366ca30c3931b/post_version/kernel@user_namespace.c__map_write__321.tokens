static ssize_t map_write ( struct file * file , const char __user * buf , //<S2SV> size_t count , loff_t * ppos , //<S2SV> int cap_setid , //<S2SV> struct uid_gid_map * map , //<S2SV> struct uid_gid_map * parent_map ) //<S2SV> { //<S2SV> struct seq_file * seq = file -> private_data ; //<S2SV> struct user_namespace * ns = seq -> private ; //<S2SV> struct uid_gid_map new_map ; //<S2SV> unsigned idx ; //<S2SV> struct uid_gid_extent * extent = NULL ; //<S2SV> unsigned long page = 0 ; //<S2SV> char * kbuf , * pos , * next_line ; //<S2SV> ssize_t ret = - EINVAL ; //<S2SV> mutex_lock ( & id_map_mutex ) ; //<S2SV> ret = - EPERM ; //<S2SV> if ( map -> nr_extents != 0 ) //<S2SV> goto out ; //<S2SV> if ( cap_valid ( cap_setid ) && ! ns_capable ( ns , cap_setid ) ) //<S2SV> goto out ; //<S2SV> ret = - ENOMEM ; //<S2SV> page = __get_free_page ( GFP_TEMPORARY ) ; //<S2SV> kbuf = ( char * ) page ; //<S2SV> if ( ! page ) //<S2SV> goto out ; //<S2SV> ret = - EINVAL ; //<S2SV> if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) //<S2SV> goto out ; //<S2SV> ret = - EFAULT ; //<S2SV> if ( copy_from_user ( kbuf , buf , count ) ) //<S2SV> goto out ; //<S2SV> kbuf [ count ] = '\\0' ; //<S2SV> ret = - EINVAL ; //<S2SV> pos = kbuf ; //<S2SV> new_map . nr_extents = 0 ; //<S2SV> for ( ; pos ; pos = next_line ) { //<S2SV> extent = & new_map . extent [ new_map . nr_extents ] ; //<S2SV> next_line = strchr ( pos , '\\n' ) ; //<S2SV> if ( next_line ) { //<S2SV> * next_line = '\\0' ; //<S2SV> next_line ++ ; //<S2SV> if ( * next_line == '\\0' ) //<S2SV> next_line = NULL ; //<S2SV> } //<S2SV> pos = skip_spaces ( pos ) ; //<S2SV> extent -> first = simple_strtoul ( pos , & pos , 10 ) ; //<S2SV> if ( ! isspace ( * pos ) ) //<S2SV> goto out ; //<S2SV> pos = skip_spaces ( pos ) ; //<S2SV> extent -> lower_first = simple_strtoul ( pos , & pos , 10 ) ; //<S2SV> if ( ! isspace ( * pos ) ) //<S2SV> goto out ; //<S2SV> pos = skip_spaces ( pos ) ; //<S2SV> extent -> count = simple_strtoul ( pos , & pos , 10 ) ; //<S2SV> if ( * pos && ! isspace ( * pos ) ) //<S2SV> goto out ; //<S2SV> pos = skip_spaces ( pos ) ; //<S2SV> if ( * pos != '\\0' ) //<S2SV> goto out ; //<S2SV> if ( ( extent -> first == ( u32 ) - 1 ) || //<S2SV> ( extent -> lower_first == ( u32 ) - 1 ) ) //<S2SV> goto out ; //<S2SV> if ( ( extent -> first + extent -> count ) <= extent -> first ) //<S2SV> goto out ; //<S2SV> if ( ( extent -> lower_first + extent -> count ) <= extent -> lower_first ) //<S2SV> goto out ; //<S2SV> if ( mappings_overlap ( & new_map , extent ) ) //<S2SV> goto out ; //<S2SV> new_map . nr_extents ++ ; //<S2SV> if ( ( new_map . nr_extents == UID_GID_MAP_MAX_EXTENTS ) && //<S2SV> ( next_line != NULL ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( new_map . nr_extents == 0 ) //<S2SV> goto out ; //<S2SV> ret = - EPERM ; //<S2SV> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) //<S2SV> goto out ; //<S2SV> for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { //<S2SV> u32 lower_first ; //<S2SV> extent = & new_map . extent [ idx ] ; //<S2SV> lower_first = map_id_range_down ( parent_map , //<S2SV> extent -> lower_first , //<S2SV> extent -> count ) ; //<S2SV> if ( lower_first == ( u32 ) - 1 ) //<S2SV> goto out ; //<S2SV> extent -> lower_first = lower_first ; //<S2SV> } //<S2SV> memcpy ( map -> extent , new_map . extent , //<S2SV> new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; //<S2SV> smp_wmb ( ) ; //<S2SV> map -> nr_extents = new_map . nr_extents ; //<S2SV> * ppos = count ; //<S2SV> ret = count ; //<S2SV> out : //<S2SV> mutex_unlock ( & id_map_mutex ) ; //<S2SV> if ( page ) //<S2SV> free_page ( page ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 