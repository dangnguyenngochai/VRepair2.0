static struct sock * tcp_v6_syn_recv_sock ( const struct sock * sk , struct sk_buff * skb , //<S2SV> struct request_sock * req , //<S2SV> struct dst_entry * dst , //<S2SV> struct request_sock * req_unhash , //<S2SV> bool * own_req ) //<S2SV> { //<S2SV> struct inet_request_sock * ireq ; //<S2SV> struct ipv6_pinfo * newnp ; //<S2SV> const struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct ipv6_txoptions * opt ; //<S2SV> struct tcp6_sock * newtcp6sk ; //<S2SV> struct inet_sock * newinet ; //<S2SV> struct tcp_sock * newtp ; //<S2SV> struct sock * newsk ; //<S2SV> # ifdef CONFIG_TCP_MD5SIG //<S2SV> struct tcp_md5sig_key * key ; //<S2SV> # endif //<S2SV> struct flowi6 fl6 ; //<S2SV> if ( skb -> protocol == htons ( ETH_P_IP ) ) { //<S2SV> newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst , //<S2SV> req_unhash , own_req ) ; //<S2SV> if ( ! newsk ) //<S2SV> return NULL ; //<S2SV> newtcp6sk = ( struct tcp6_sock * ) newsk ; //<S2SV> inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; //<S2SV> newinet = inet_sk ( newsk ) ; //<S2SV> newnp = inet6_sk ( newsk ) ; //<S2SV> newtp = tcp_sk ( newsk ) ; //<S2SV> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; //<S2SV> newnp -> saddr = newsk -> sk_v6_rcv_saddr ; //<S2SV> inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; //<S2SV> newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; //<S2SV> # ifdef CONFIG_TCP_MD5SIG //<S2SV> newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; //<S2SV> # endif //<S2SV> newnp -> ipv6_mc_list = NULL ; //<S2SV> newnp -> ipv6_ac_list = NULL ; //<S2SV> newnp -> ipv6_fl_list = NULL ; //<S2SV> newnp -> pktoptions = NULL ; //<S2SV> newnp -> opt = NULL ; //<S2SV> newnp -> mcast_oif = tcp_v6_iif ( skb ) ; //<S2SV> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; //<S2SV> newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; //<S2SV> if ( np -> repflow ) //<S2SV> newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; //<S2SV> tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; //<S2SV> return newsk ; //<S2SV> } //<S2SV> ireq = inet_rsk ( req ) ; //<S2SV> if ( sk_acceptq_is_full ( sk ) ) //<S2SV> goto out_overflow ; //<S2SV> if ( ! dst ) { //<S2SV> dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_TCP ) ; //<S2SV> if ( ! dst ) //<S2SV> goto out ; //<S2SV> } //<S2SV> newsk = tcp_create_openreq_child ( sk , req , skb ) ; //<S2SV> if ( ! newsk ) //<S2SV> goto out_nonewsk ; //<S2SV> newsk -> sk_gso_type = SKB_GSO_TCPV6 ; //<S2SV> ip6_dst_store ( newsk , dst , NULL , NULL ) ; //<S2SV> inet6_sk_rx_dst_set ( newsk , skb ) ; //<S2SV> newtcp6sk = ( struct tcp6_sock * ) newsk ; //<S2SV> inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; //<S2SV> newtp = tcp_sk ( newsk ) ; //<S2SV> newinet = inet_sk ( newsk ) ; //<S2SV> newnp = inet6_sk ( newsk ) ; //<S2SV> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; //<S2SV> newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; //<S2SV> newnp -> saddr = ireq -> ir_v6_loc_addr ; //<S2SV> newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; //<S2SV> newsk -> sk_bound_dev_if = ireq -> ir_iif ; //<S2SV> newinet -> inet_opt = NULL ; //<S2SV> newnp -> ipv6_mc_list = NULL ; //<S2SV> newnp -> ipv6_ac_list = NULL ; //<S2SV> newnp -> ipv6_fl_list = NULL ; //<S2SV> newnp -> rxopt . all = np -> rxopt . all ; //<S2SV> newnp -> pktoptions = NULL ; //<S2SV> newnp -> opt = NULL ; //<S2SV> newnp -> mcast_oif = tcp_v6_iif ( skb ) ; //<S2SV> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; //<S2SV> newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; //<S2SV> if ( np -> repflow ) //<S2SV> newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; //<S2SV> opt = ireq -> ipv6_opt ; //<S2SV> if ( ! opt ) //<S2SV> opt = rcu_dereference ( np -> opt ) ; //<S2SV> if ( opt ) { //<S2SV> opt = ipv6_dup_options ( newsk , opt ) ; //<S2SV> RCU_INIT_POINTER ( newnp -> opt , opt ) ; //<S2SV> } //<S2SV> inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; //<S2SV> if ( opt ) //<S2SV> inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + //<S2SV> opt -> opt_flen ; //<S2SV> tcp_ca_openreq_child ( newsk , dst ) ; //<S2SV> tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; //<S2SV> newtp -> advmss = tcp_mss_clamp ( tcp_sk ( sk ) , dst_metric_advmss ( dst ) ) ; //<S2SV> tcp_initialize_rcv_mss ( newsk ) ; //<S2SV> newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; //<S2SV> newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; //<S2SV> # ifdef CONFIG_TCP_MD5SIG //<S2SV> key = tcp_v6_md5_do_lookup ( sk , & newsk -> sk_v6_daddr ) ; //<S2SV> if ( key ) { //<S2SV> tcp_md5_do_add ( newsk , ( union tcp_md5_addr * ) & newsk -> sk_v6_daddr , //<S2SV> AF_INET6 , key -> key , key -> keylen , //<S2SV> sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( __inet_inherit_port ( sk , newsk ) < 0 ) { //<S2SV> inet_csk_prepare_forced_close ( newsk ) ; //<S2SV> tcp_done ( newsk ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; //<S2SV> if ( * own_req ) { //<S2SV> tcp_move_syn ( newtp , req ) ; //<S2SV> if ( ireq -> pktopts ) { //<S2SV> newnp -> pktoptions = skb_clone ( ireq -> pktopts , //<S2SV> sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; //<S2SV> consume_skb ( ireq -> pktopts ) ; //<S2SV> ireq -> pktopts = NULL ; //<S2SV> if ( newnp -> pktoptions ) { //<S2SV> tcp_v6_restore_cb ( newnp -> pktoptions ) ; //<S2SV> skb_set_owner_r ( newnp -> pktoptions , newsk ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return newsk ; //<S2SV> out_overflow : //<S2SV> __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; //<S2SV> out_nonewsk : //<S2SV> dst_release ( dst ) ; //<S2SV> out : //<S2SV> tcp_listendrop ( sk ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 