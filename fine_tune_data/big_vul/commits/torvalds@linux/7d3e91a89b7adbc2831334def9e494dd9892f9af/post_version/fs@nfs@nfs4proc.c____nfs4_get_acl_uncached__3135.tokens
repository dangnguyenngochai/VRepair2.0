static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) //<S2SV> { //<S2SV> struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; //<S2SV> struct nfs_getaclargs args = { //<S2SV> . fh = NFS_FH ( inode ) , //<S2SV> . acl_pages = pages , //<S2SV> . acl_len = buflen , //<S2SV> } ; //<S2SV> struct nfs_getaclres res = { //<S2SV> . acl_len = buflen , //<S2SV> } ; //<S2SV> struct rpc_message msg = { //<S2SV> . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , //<S2SV> . rpc_argp = & args , //<S2SV> . rpc_resp = & res , //<S2SV> } ; //<S2SV> unsigned int npages = DIV_ROUND_UP ( buflen , PAGE_SIZE ) ; //<S2SV> int ret = - ENOMEM , i ; //<S2SV> if ( npages == 0 ) //<S2SV> npages = 1 ; //<S2SV> if ( npages > ARRAY_SIZE ( pages ) ) //<S2SV> return - ERANGE ; //<S2SV> for ( i = 0 ; i < npages ; i ++ ) { //<S2SV> pages [ i ] = alloc_page ( GFP_KERNEL ) ; //<S2SV> if ( ! pages [ i ] ) //<S2SV> goto out_free ; //<S2SV> } //<S2SV> res . acl_scratch = alloc_page ( GFP_KERNEL ) ; //<S2SV> if ( ! res . acl_scratch ) //<S2SV> goto out_free ; //<S2SV> args . acl_len = npages * PAGE_SIZE ; //<S2SV> args . acl_pgbase = 0 ; //<S2SV> dprintk ( "%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\n" , //<S2SV> __func__ , buf , buflen , npages , args . acl_len ) ; //<S2SV> ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , //<S2SV> & msg , & args . seq_args , & res . seq_res , 0 ) ; //<S2SV> if ( ret ) //<S2SV> goto out_free ; //<S2SV> if ( res . acl_flags & NFS4_ACL_TRUNC ) { //<S2SV> if ( buf == NULL ) //<S2SV> goto out_ok ; //<S2SV> ret = - ERANGE ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> nfs4_write_cached_acl ( inode , pages , res . acl_data_offset , res . acl_len ) ; //<S2SV> if ( buf ) { //<S2SV> if ( res . acl_len > buflen ) { //<S2SV> ret = - ERANGE ; //<S2SV> goto out_free ; //<S2SV> } //<S2SV> _copy_from_pages ( buf , pages , res . acl_data_offset , res . acl_len ) ; //<S2SV> } //<S2SV> out_ok : //<S2SV> ret = res . acl_len ; //<S2SV> out_free : //<S2SV> for ( i = 0 ; i < npages ; i ++ ) //<S2SV> if ( pages [ i ] ) //<S2SV> __free_page ( pages [ i ] ) ; //<S2SV> if ( res . acl_scratch ) //<S2SV> __free_page ( res . acl_scratch ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 