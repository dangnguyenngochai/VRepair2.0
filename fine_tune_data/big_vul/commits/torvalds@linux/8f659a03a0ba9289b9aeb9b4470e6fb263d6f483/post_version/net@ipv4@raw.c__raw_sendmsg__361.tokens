static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) //<S2SV> { //<S2SV> struct inet_sock * inet = inet_sk ( sk ) ; //<S2SV> struct net * net = sock_net ( sk ) ; //<S2SV> struct ipcm_cookie ipc ; //<S2SV> struct rtable * rt = NULL ; //<S2SV> struct flowi4 fl4 ; //<S2SV> int free = 0 ; //<S2SV> __be32 daddr ; //<S2SV> __be32 saddr ; //<S2SV> u8 tos ; //<S2SV> int err ; //<S2SV> struct ip_options_data opt_copy ; //<S2SV> struct raw_frag_vec rfv ; //<S2SV> int hdrincl ; //<S2SV> err = - EMSGSIZE ; //<S2SV> if ( len > 0xFFFF ) //<S2SV> goto out ; //<S2SV> hdrincl = inet -> hdrincl ; //<S2SV> err = - EOPNOTSUPP ; //<S2SV> if ( msg -> msg_flags & MSG_OOB ) //<S2SV> goto out ; //<S2SV> if ( msg -> msg_namelen ) { //<S2SV> DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; //<S2SV> err = - EINVAL ; //<S2SV> if ( msg -> msg_namelen < sizeof ( * usin ) ) //<S2SV> goto out ; //<S2SV> if ( usin -> sin_family != AF_INET ) { //<S2SV> pr_info_once ( "%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\n" , //<S2SV> __func__ , current -> comm ) ; //<S2SV> err = - EAFNOSUPPORT ; //<S2SV> if ( usin -> sin_family ) //<S2SV> goto out ; //<S2SV> } //<S2SV> daddr = usin -> sin_addr . s_addr ; //<S2SV> } else { //<S2SV> err = - EDESTADDRREQ ; //<S2SV> if ( sk -> sk_state != TCP_ESTABLISHED ) //<S2SV> goto out ; //<S2SV> daddr = inet -> inet_daddr ; //<S2SV> } //<S2SV> ipc . sockc . tsflags = sk -> sk_tsflags ; //<S2SV> ipc . addr = inet -> inet_saddr ; //<S2SV> ipc . opt = NULL ; //<S2SV> ipc . tx_flags = 0 ; //<S2SV> ipc . ttl = 0 ; //<S2SV> ipc . tos = - 1 ; //<S2SV> ipc . oif = sk -> sk_bound_dev_if ; //<S2SV> if ( msg -> msg_controllen ) { //<S2SV> err = ip_cmsg_send ( sk , msg , & ipc , false ) ; //<S2SV> if ( unlikely ( err ) ) { //<S2SV> kfree ( ipc . opt ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ipc . opt ) //<S2SV> free = 1 ; //<S2SV> } //<S2SV> saddr = ipc . addr ; //<S2SV> ipc . addr = daddr ; //<S2SV> if ( ! ipc . opt ) { //<S2SV> struct ip_options_rcu * inet_opt ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> inet_opt = rcu_dereference ( inet -> inet_opt ) ; //<S2SV> if ( inet_opt ) { //<S2SV> memcpy ( & opt_copy , inet_opt , //<S2SV> sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; //<S2SV> ipc . opt = & opt_copy . opt ; //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> } //<S2SV> if ( ipc . opt ) { //<S2SV> err = - EINVAL ; //<S2SV> if ( hdrincl ) //<S2SV> goto done ; //<S2SV> if ( ipc . opt -> opt . srr ) { //<S2SV> if ( ! daddr ) //<S2SV> goto done ; //<S2SV> daddr = ipc . opt -> opt . faddr ; //<S2SV> } //<S2SV> } //<S2SV> tos = get_rtconn_flags ( & ipc , sk ) ; //<S2SV> if ( msg -> msg_flags & MSG_DONTROUTE ) //<S2SV> tos |= RTO_ONLINK ; //<S2SV> if ( ipv4_is_multicast ( daddr ) ) { //<S2SV> if ( ! ipc . oif ) //<S2SV> ipc . oif = inet -> mc_index ; //<S2SV> if ( ! saddr ) //<S2SV> saddr = inet -> mc_addr ; //<S2SV> } else if ( ! ipc . oif ) //<S2SV> ipc . oif = inet -> uc_index ; //<S2SV> flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , //<S2SV> RT_SCOPE_UNIVERSE , //<S2SV> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , //<S2SV> inet_sk_flowi_flags ( sk ) | //<S2SV> ( hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , //<S2SV> daddr , saddr , 0 , 0 , sk -> sk_uid ) ; //<S2SV> if ( ! hdrincl ) { //<S2SV> rfv . msg = msg ; //<S2SV> rfv . hlen = 0 ; //<S2SV> err = raw_probe_proto_opt ( & rfv , & fl4 ) ; //<S2SV> if ( err ) //<S2SV> goto done ; //<S2SV> } //<S2SV> security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; //<S2SV> rt = ip_route_output_flow ( net , & fl4 , sk ) ; //<S2SV> if ( IS_ERR ( rt ) ) { //<S2SV> err = PTR_ERR ( rt ) ; //<S2SV> rt = NULL ; //<S2SV> goto done ; //<S2SV> } //<S2SV> err = - EACCES ; //<S2SV> if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) //<S2SV> goto done ; //<S2SV> if ( msg -> msg_flags & MSG_CONFIRM ) //<S2SV> goto do_confirm ; //<S2SV> back_from_confirm : //<S2SV> if ( hdrincl ) //<S2SV> err = raw_send_hdrinc ( sk , & fl4 , msg , len , //<S2SV> & rt , msg -> msg_flags , & ipc . sockc ) ; //<S2SV> else { //<S2SV> sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; //<S2SV> if ( ! ipc . addr ) //<S2SV> ipc . addr = fl4 . daddr ; //<S2SV> lock_sock ( sk ) ; //<S2SV> err = ip_append_data ( sk , & fl4 , raw_getfrag , //<S2SV> & rfv , len , 0 , //<S2SV> & ipc , & rt , msg -> msg_flags ) ; //<S2SV> if ( err ) //<S2SV> ip_flush_pending_frames ( sk ) ; //<S2SV> else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { //<S2SV> err = ip_push_pending_frames ( sk , & fl4 ) ; //<S2SV> if ( err == - ENOBUFS && ! inet -> recverr ) //<S2SV> err = 0 ; //<S2SV> } //<S2SV> release_sock ( sk ) ; //<S2SV> } //<S2SV> done : //<S2SV> if ( free ) //<S2SV> kfree ( ipc . opt ) ; //<S2SV> ip_rt_put ( rt ) ; //<S2SV> out : //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> return len ; //<S2SV> do_confirm : //<S2SV> if ( msg -> msg_flags & MSG_PROBE ) //<S2SV> dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; //<S2SV> if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) //<S2SV> goto back_from_confirm ; //<S2SV> err = 0 ; //<S2SV> goto done ; //<S2SV> } //<S2SV> 