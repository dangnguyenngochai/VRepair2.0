static int check_cond_jmp_op ( struct bpf_verifier_env * env , //<S2SV> struct bpf_insn * insn , int * insn_idx ) //<S2SV> { //<S2SV> struct bpf_verifier_state * this_branch = env -> cur_state ; //<S2SV> struct bpf_verifier_state * other_branch ; //<S2SV> struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; //<S2SV> struct bpf_reg_state * dst_reg , * other_branch_regs ; //<S2SV> u8 opcode = BPF_OP ( insn -> code ) ; //<S2SV> int err ; //<S2SV> if ( opcode > BPF_JSLE ) { //<S2SV> verbose ( env , "invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n" , opcode ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( BPF_SRC ( insn -> code ) == BPF_X ) { //<S2SV> if ( insn -> imm != 0 ) { //<S2SV> verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( is_pointer_value ( env , insn -> src_reg ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , //<S2SV> insn -> src_reg ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( insn -> src_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> dst_reg = & regs [ insn -> dst_reg ] ; //<S2SV> if ( BPF_SRC ( insn -> code ) == BPF_K ) { //<S2SV> int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; //<S2SV> if ( pred == 1 ) { //<S2SV> * insn_idx += insn -> off ; //<S2SV> return 0 ; //<S2SV> } else if ( pred == 0 ) { //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; //<S2SV> if ( ! other_branch ) //<S2SV> return - EFAULT ; //<S2SV> other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; //<S2SV> if ( BPF_SRC ( insn -> code ) == BPF_X ) { //<S2SV> if ( dst_reg -> type == SCALAR_VALUE && //<S2SV> regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { //<S2SV> if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) //<S2SV> reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , //<S2SV> dst_reg , regs [ insn -> src_reg ] . var_off . value , //<S2SV> opcode ) ; //<S2SV> else if ( tnum_is_const ( dst_reg -> var_off ) ) //<S2SV> reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , //<S2SV> & regs [ insn -> src_reg ] , //<S2SV> dst_reg -> var_off . value , opcode ) ; //<S2SV> else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) //<S2SV> reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , //<S2SV> & other_branch_regs [ insn -> dst_reg ] , //<S2SV> & regs [ insn -> src_reg ] , //<S2SV> & regs [ insn -> dst_reg ] , opcode ) ; //<S2SV> } //<S2SV> } else if ( dst_reg -> type == SCALAR_VALUE ) { //<S2SV> reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , //<S2SV> dst_reg , insn -> imm , opcode ) ; //<S2SV> } //<S2SV> if ( BPF_SRC ( insn -> code ) == BPF_K && //<S2SV> insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && //<S2SV> reg_type_may_be_null ( dst_reg -> type ) ) { //<S2SV> mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , //<S2SV> opcode == BPF_JNE ) ; //<S2SV> mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , //<S2SV> opcode == BPF_JEQ ) ; //<S2SV> } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , //<S2SV> this_branch , other_branch ) && //<S2SV> is_pointer_value ( env , insn -> dst_reg ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , //<S2SV> insn -> dst_reg ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( env -> log . level ) //<S2SV> print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 