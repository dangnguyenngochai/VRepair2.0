static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , //<S2SV> int insn_idx , int prev_insn_idx ) //<S2SV> { //<S2SV> struct bpf_verifier_state * cur = env -> cur_state ; //<S2SV> struct bpf_verifier_stack_elem * elem ; //<S2SV> int err ; //<S2SV> elem = kzalloc ( sizeof ( struct bpf_verifier_stack_elem ) , GFP_KERNEL ) ; //<S2SV> if ( ! elem ) //<S2SV> goto err ; //<S2SV> elem -> insn_idx = insn_idx ; //<S2SV> elem -> prev_insn_idx = prev_insn_idx ; //<S2SV> elem -> next = env -> head ; //<S2SV> env -> head = elem ; //<S2SV> env -> stack_size ++ ; //<S2SV> err = copy_verifier_state ( & elem -> st , cur ) ; //<S2SV> if ( err ) //<S2SV> goto err ; //<S2SV> if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) { //<S2SV> verbose ( env , "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>complex\\n" ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> return & elem -> st ; //<S2SV> err : //<S2SV> free_verifier_state ( env -> cur_state , true ) ; //<S2SV> env -> cur_state = NULL ; //<S2SV> while ( ! pop_stack ( env , NULL , NULL ) ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 