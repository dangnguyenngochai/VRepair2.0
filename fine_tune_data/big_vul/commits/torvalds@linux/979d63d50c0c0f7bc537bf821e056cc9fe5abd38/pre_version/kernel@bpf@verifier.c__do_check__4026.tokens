static int do_check ( struct bpf_verifier_env * env ) //<S2SV> { //<S2SV> struct bpf_verifier_state * state ; //<S2SV> struct bpf_insn * insns = env -> prog -> insnsi ; //<S2SV> struct bpf_reg_state * regs ; //<S2SV> int insn_cnt = env -> prog -> len , i ; //<S2SV> int insn_processed = 0 ; //<S2SV> bool do_print_state = false ; //<S2SV> env -> prev_linfo = NULL ; //<S2SV> state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; //<S2SV> if ( ! state ) //<S2SV> return - ENOMEM ; //<S2SV> state -> curframe = 0 ; //<S2SV> state -> frame [ 0 ] = kzalloc ( sizeof ( struct bpf_func_state ) , GFP_KERNEL ) ; //<S2SV> if ( ! state -> frame [ 0 ] ) { //<S2SV> kfree ( state ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> env -> cur_state = state ; //<S2SV> init_func_state ( env , state -> frame [ 0 ] , //<S2SV> BPF_MAIN_FUNC , //<S2SV> 0 , //<S2SV> 0 ) ; //<S2SV> for ( ; ; ) { //<S2SV> struct bpf_insn * insn ; //<S2SV> u8 class ; //<S2SV> int err ; //<S2SV> if ( env -> insn_idx >= insn_cnt ) { //<S2SV> verbose ( env , "invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n" , //<S2SV> env -> insn_idx , insn_cnt ) ; //<S2SV> return - EFAULT ; //<S2SV> } //<S2SV> insn = & insns [ env -> insn_idx ] ; //<S2SV> class = BPF_CLASS ( insn -> code ) ; //<S2SV> if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { //<S2SV> verbose ( env , //<S2SV> "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n" , //<S2SV> insn_processed ) ; //<S2SV> return - E2BIG ; //<S2SV> } //<S2SV> err = is_state_visited ( env , env -> insn_idx ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( err == 1 ) { //<S2SV> if ( env -> log . level ) { //<S2SV> if ( do_print_state ) //<S2SV> verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n" , //<S2SV> env -> prev_insn_idx , env -> insn_idx ) ; //<S2SV> else //<S2SV> verbose ( env , "%d:<S2SV_blank>safe\\n" , env -> insn_idx ) ; //<S2SV> } //<S2SV> goto process_bpf_exit ; //<S2SV> } //<S2SV> if ( signal_pending ( current ) ) //<S2SV> return - EAGAIN ; //<S2SV> if ( need_resched ( ) ) //<S2SV> cond_resched ( ) ; //<S2SV> if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { //<S2SV> if ( env -> log . level > 1 ) //<S2SV> verbose ( env , "%d:" , env -> insn_idx ) ; //<S2SV> else //<S2SV> verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:" , //<S2SV> env -> prev_insn_idx , env -> insn_idx ) ; //<S2SV> print_verifier_state ( env , state -> frame [ state -> curframe ] ) ; //<S2SV> do_print_state = false ; //<S2SV> } //<S2SV> if ( env -> log . level ) { //<S2SV> const struct bpf_insn_cbs cbs = { //<S2SV> . cb_print = verbose , //<S2SV> . private_data = env , //<S2SV> } ; //<S2SV> verbose_linfo ( env , env -> insn_idx , ";<S2SV_blank>" ) ; //<S2SV> verbose ( env , "%d:<S2SV_blank>" , env -> insn_idx ) ; //<S2SV> print_bpf_insn ( & cbs , insn , env -> allow_ptr_leaks ) ; //<S2SV> } //<S2SV> if ( bpf_prog_is_dev_bound ( env -> prog -> aux ) ) { //<S2SV> err = bpf_prog_offload_verify_insn ( env , env -> insn_idx , //<S2SV> env -> prev_insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } //<S2SV> regs = cur_regs ( env ) ; //<S2SV> env -> insn_aux_data [ env -> insn_idx ] . seen = true ; //<S2SV> if ( class == BPF_ALU || class == BPF_ALU64 ) { //<S2SV> err = check_alu_op ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( class == BPF_LDX ) { //<S2SV> enum bpf_reg_type * prev_src_type , src_reg_type ; //<S2SV> err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> src_reg_type = regs [ insn -> src_reg ] . type ; //<S2SV> err = check_mem_access ( env , env -> insn_idx , insn -> src_reg , //<S2SV> insn -> off , BPF_SIZE ( insn -> code ) , //<S2SV> BPF_READ , insn -> dst_reg , false ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> prev_src_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; //<S2SV> if ( * prev_src_type == NOT_INIT ) { //<S2SV> * prev_src_type = src_reg_type ; //<S2SV> } else if ( reg_type_mismatch ( src_reg_type , * prev_src_type ) ) { //<S2SV> verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else if ( class == BPF_STX ) { //<S2SV> enum bpf_reg_type * prev_dst_type , dst_reg_type ; //<S2SV> if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { //<S2SV> err = check_xadd ( env , env -> insn_idx , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> env -> insn_idx ++ ; //<S2SV> continue ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> dst_reg_type = regs [ insn -> dst_reg ] . type ; //<S2SV> err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , //<S2SV> insn -> off , BPF_SIZE ( insn -> code ) , //<S2SV> BPF_WRITE , insn -> src_reg , false ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> prev_dst_type = & env -> insn_aux_data [ env -> insn_idx ] . ptr_type ; //<S2SV> if ( * prev_dst_type == NOT_INIT ) { //<S2SV> * prev_dst_type = dst_reg_type ; //<S2SV> } else if ( reg_type_mismatch ( dst_reg_type , * prev_dst_type ) ) { //<S2SV> verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else if ( class == BPF_ST ) { //<S2SV> if ( BPF_MODE ( insn -> code ) != BPF_MEM || //<S2SV> insn -> src_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( is_ctx_reg ( env , insn -> dst_reg ) ) { //<S2SV> verbose ( env , "BPF_ST<S2SV_blank>stores<S2SV_blank>into<S2SV_blank>R%d<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n" , //<S2SV> insn -> dst_reg , //<S2SV> reg_type_str [ reg_state ( env , insn -> dst_reg ) -> type ] ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> err = check_mem_access ( env , env -> insn_idx , insn -> dst_reg , //<S2SV> insn -> off , BPF_SIZE ( insn -> code ) , //<S2SV> BPF_WRITE , - 1 , false ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( class == BPF_JMP ) { //<S2SV> u8 opcode = BPF_OP ( insn -> code ) ; //<S2SV> if ( opcode == BPF_CALL ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> off != 0 || //<S2SV> ( insn -> src_reg != BPF_REG_0 && //<S2SV> insn -> src_reg != BPF_PSEUDO_CALL ) || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( insn -> src_reg == BPF_PSEUDO_CALL ) //<S2SV> err = check_func_call ( env , insn , & env -> insn_idx ) ; //<S2SV> else //<S2SV> err = check_helper_call ( env , insn -> imm , env -> insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( opcode == BPF_JA ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> imm != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> env -> insn_idx += insn -> off + 1 ; //<S2SV> continue ; //<S2SV> } else if ( opcode == BPF_EXIT ) { //<S2SV> if ( BPF_SRC ( insn -> code ) != BPF_K || //<S2SV> insn -> imm != 0 || //<S2SV> insn -> src_reg != BPF_REG_0 || //<S2SV> insn -> dst_reg != BPF_REG_0 ) { //<S2SV> verbose ( env , "BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> if ( state -> curframe ) { //<S2SV> env -> prev_insn_idx = env -> insn_idx ; //<S2SV> err = prepare_func_exit ( env , & env -> insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> do_print_state = true ; //<S2SV> continue ; //<S2SV> } //<S2SV> err = check_reference_leak ( env ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> if ( is_pointer_value ( env , BPF_REG_0 ) ) { //<S2SV> verbose ( env , "R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n" ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> err = check_return_code ( env ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> process_bpf_exit : //<S2SV> err = pop_stack ( env , & env -> prev_insn_idx , //<S2SV> & env -> insn_idx ) ; //<S2SV> if ( err < 0 ) { //<S2SV> if ( err != - ENOENT ) //<S2SV> return err ; //<S2SV> break ; //<S2SV> } else { //<S2SV> do_print_state = true ; //<S2SV> continue ; //<S2SV> } //<S2SV> } else { //<S2SV> err = check_cond_jmp_op ( env , insn , & env -> insn_idx ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } //<S2SV> } else if ( class == BPF_LD ) { //<S2SV> u8 mode = BPF_MODE ( insn -> code ) ; //<S2SV> if ( mode == BPF_ABS || mode == BPF_IND ) { //<S2SV> err = check_ld_abs ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> } else if ( mode == BPF_IMM ) { //<S2SV> err = check_ld_imm ( env , insn ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> env -> insn_idx ++ ; //<S2SV> env -> insn_aux_data [ env -> insn_idx ] . seen = true ; //<S2SV> } else { //<S2SV> verbose ( env , "invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n" ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> } else { //<S2SV> verbose ( env , "unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n" , class ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> env -> insn_idx ++ ; //<S2SV> } //<S2SV> verbose ( env , "processed<S2SV_blank>%d<S2SV_blank>insns<S2SV_blank>(limit<S2SV_blank>%d),<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>" , //<S2SV> insn_processed , BPF_COMPLEXITY_LIMIT_INSNS ) ; //<S2SV> for ( i = 0 ; i < env -> subprog_cnt ; i ++ ) { //<S2SV> u32 depth = env -> subprog_info [ i ] . stack_depth ; //<S2SV> verbose ( env , "%d" , depth ) ; //<S2SV> if ( i + 1 < env -> subprog_cnt ) //<S2SV> verbose ( env , "+" ) ; //<S2SV> } //<S2SV> verbose ( env , "\\n" ) ; //<S2SV> env -> prog -> aux -> stack_depth = env -> subprog_info [ 0 ] . stack_depth ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 