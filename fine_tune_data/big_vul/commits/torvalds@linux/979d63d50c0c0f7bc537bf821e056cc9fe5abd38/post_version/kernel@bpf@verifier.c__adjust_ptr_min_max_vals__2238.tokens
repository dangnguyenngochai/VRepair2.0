static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , //<S2SV> struct bpf_insn * insn , //<S2SV> const struct bpf_reg_state * ptr_reg , //<S2SV> const struct bpf_reg_state * off_reg ) //<S2SV> { //<S2SV> struct bpf_verifier_state * vstate = env -> cur_state ; //<S2SV> struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; //<S2SV> struct bpf_reg_state * regs = state -> regs , * dst_reg ; //<S2SV> bool known = tnum_is_const ( off_reg -> var_off ) ; //<S2SV> s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , //<S2SV> smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; //<S2SV> u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , //<S2SV> umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; //<S2SV> u32 dst = insn -> dst_reg , src = insn -> src_reg ; //<S2SV> u8 opcode = BPF_OP ( insn -> code ) ; //<S2SV> int ret ; //<S2SV> dst_reg = & regs [ dst ] ; //<S2SV> if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || //<S2SV> smin_val > smax_val || umin_val > umax_val ) { //<S2SV> __mark_reg_unknown ( dst_reg ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { //<S2SV> verbose ( env , //<S2SV> "R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n" , //<S2SV> dst ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> switch ( ptr_reg -> type ) { //<S2SV> case PTR_TO_MAP_VALUE_OR_NULL : //<S2SV> verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n" , //<S2SV> dst , reg_type_str [ ptr_reg -> type ] ) ; //<S2SV> return - EACCES ; //<S2SV> case CONST_PTR_TO_MAP : //<S2SV> case PTR_TO_PACKET_END : //<S2SV> case PTR_TO_SOCKET : //<S2SV> case PTR_TO_SOCKET_OR_NULL : //<S2SV> verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited\\n" , //<S2SV> dst , reg_type_str [ ptr_reg -> type ] ) ; //<S2SV> return - EACCES ; //<S2SV> case PTR_TO_MAP_VALUE : //<S2SV> if ( ! env -> allow_ptr_leaks && ! known && ( smin_val < 0 ) != ( smax_val < 0 ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>scalar<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>signed<S2SV_blank>bounds,<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>it<S2SV_blank>prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , //<S2SV> off_reg == dst_reg ? dst : src ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> dst_reg -> type = ptr_reg -> type ; //<S2SV> dst_reg -> id = ptr_reg -> id ; //<S2SV> if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || //<S2SV> ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) //<S2SV> return - EINVAL ; //<S2SV> switch ( opcode ) { //<S2SV> case BPF_ADD : //<S2SV> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n" , dst ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( known && ( ptr_reg -> off + smin_val == //<S2SV> ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { //<S2SV> dst_reg -> smin_value = smin_ptr ; //<S2SV> dst_reg -> smax_value = smax_ptr ; //<S2SV> dst_reg -> umin_value = umin_ptr ; //<S2SV> dst_reg -> umax_value = umax_ptr ; //<S2SV> dst_reg -> var_off = ptr_reg -> var_off ; //<S2SV> dst_reg -> off = ptr_reg -> off + smin_val ; //<S2SV> dst_reg -> raw = ptr_reg -> raw ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( signed_add_overflows ( smin_ptr , smin_val ) || //<S2SV> signed_add_overflows ( smax_ptr , smax_val ) ) { //<S2SV> dst_reg -> smin_value = S64_MIN ; //<S2SV> dst_reg -> smax_value = S64_MAX ; //<S2SV> } else { //<S2SV> dst_reg -> smin_value = smin_ptr + smin_val ; //<S2SV> dst_reg -> smax_value = smax_ptr + smax_val ; //<S2SV> } //<S2SV> if ( umin_ptr + umin_val < umin_ptr || //<S2SV> umax_ptr + umax_val < umax_ptr ) { //<S2SV> dst_reg -> umin_value = 0 ; //<S2SV> dst_reg -> umax_value = U64_MAX ; //<S2SV> } else { //<S2SV> dst_reg -> umin_value = umin_ptr + umin_val ; //<S2SV> dst_reg -> umax_value = umax_ptr + umax_val ; //<S2SV> } //<S2SV> dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; //<S2SV> dst_reg -> off = ptr_reg -> off ; //<S2SV> dst_reg -> raw = ptr_reg -> raw ; //<S2SV> if ( reg_is_pkt_pointer ( ptr_reg ) ) { //<S2SV> dst_reg -> id = ++ env -> id_gen ; //<S2SV> dst_reg -> raw = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> case BPF_SUB : //<S2SV> ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n" , dst ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( dst_reg == off_reg ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n" , //<S2SV> dst ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( ptr_reg -> type == PTR_TO_STACK ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n" , //<S2SV> dst ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( known && ( ptr_reg -> off - smin_val == //<S2SV> ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { //<S2SV> dst_reg -> smin_value = smin_ptr ; //<S2SV> dst_reg -> smax_value = smax_ptr ; //<S2SV> dst_reg -> umin_value = umin_ptr ; //<S2SV> dst_reg -> umax_value = umax_ptr ; //<S2SV> dst_reg -> var_off = ptr_reg -> var_off ; //<S2SV> dst_reg -> id = ptr_reg -> id ; //<S2SV> dst_reg -> off = ptr_reg -> off - smin_val ; //<S2SV> dst_reg -> raw = ptr_reg -> raw ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( signed_sub_overflows ( smin_ptr , smax_val ) || //<S2SV> signed_sub_overflows ( smax_ptr , smin_val ) ) { //<S2SV> dst_reg -> smin_value = S64_MIN ; //<S2SV> dst_reg -> smax_value = S64_MAX ; //<S2SV> } else { //<S2SV> dst_reg -> smin_value = smin_ptr - smax_val ; //<S2SV> dst_reg -> smax_value = smax_ptr - smin_val ; //<S2SV> } //<S2SV> if ( umin_ptr < umax_val ) { //<S2SV> dst_reg -> umin_value = 0 ; //<S2SV> dst_reg -> umax_value = U64_MAX ; //<S2SV> } else { //<S2SV> dst_reg -> umin_value = umin_ptr - umax_val ; //<S2SV> dst_reg -> umax_value = umax_ptr - umin_val ; //<S2SV> } //<S2SV> dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; //<S2SV> dst_reg -> off = ptr_reg -> off ; //<S2SV> dst_reg -> raw = ptr_reg -> raw ; //<S2SV> if ( reg_is_pkt_pointer ( ptr_reg ) ) { //<S2SV> dst_reg -> id = ++ env -> id_gen ; //<S2SV> if ( smin_val < 0 ) //<S2SV> dst_reg -> raw = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> case BPF_AND : //<S2SV> case BPF_OR : //<S2SV> case BPF_XOR : //<S2SV> verbose ( env , "R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n" , //<S2SV> dst , bpf_alu_string [ opcode >> 4 ] ) ; //<S2SV> return - EACCES ; //<S2SV> default : //<S2SV> verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n" , //<S2SV> dst , bpf_alu_string [ opcode >> 4 ] ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) //<S2SV> return - EINVAL ; //<S2SV> __update_reg_bounds ( dst_reg ) ; //<S2SV> __reg_deduce_bounds ( dst_reg ) ; //<S2SV> __reg_bound_offset ( dst_reg ) ; //<S2SV> if ( ! env -> allow_ptr_leaks ) { //<S2SV> if ( dst_reg -> type == PTR_TO_MAP_VALUE && //<S2SV> check_map_access ( env , dst , dst_reg -> off , 1 , false ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>of<S2SV_blank>map<S2SV_blank>value<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>" //<S2SV> "prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , dst ) ; //<S2SV> return - EACCES ; //<S2SV> } else if ( dst_reg -> type == PTR_TO_STACK && //<S2SV> check_stack_access ( env , dst_reg , dst_reg -> off + //<S2SV> dst_reg -> var_off . value , 1 ) ) { //<S2SV> verbose ( env , "R%d<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>" //<S2SV> "prohibited<S2SV_blank>for<S2SV_blank>!root\\n" , dst ) ; //<S2SV> return - EACCES ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 