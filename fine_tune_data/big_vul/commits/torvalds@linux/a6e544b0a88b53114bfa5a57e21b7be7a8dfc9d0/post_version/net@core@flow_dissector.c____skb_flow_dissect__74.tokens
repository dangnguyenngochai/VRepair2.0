bool __skb_flow_dissect ( const struct sk_buff * skb , //<S2SV> struct flow_dissector * flow_dissector , //<S2SV> void * target_container , //<S2SV> void * data , __be16 proto , int nhoff , int hlen ) //<S2SV> { //<S2SV> struct flow_dissector_key_control * key_control ; //<S2SV> struct flow_dissector_key_basic * key_basic ; //<S2SV> struct flow_dissector_key_addrs * key_addrs ; //<S2SV> struct flow_dissector_key_ports * key_ports ; //<S2SV> struct flow_dissector_key_tags * key_tags ; //<S2SV> struct flow_dissector_key_keyid * key_keyid ; //<S2SV> u8 ip_proto = 0 ; //<S2SV> bool ret = false ; //<S2SV> if ( ! data ) { //<S2SV> data = skb -> data ; //<S2SV> proto = skb -> protocol ; //<S2SV> nhoff = skb_network_offset ( skb ) ; //<S2SV> hlen = skb_headlen ( skb ) ; //<S2SV> } //<S2SV> key_control = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_CONTROL , //<S2SV> target_container ) ; //<S2SV> key_basic = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_BASIC , //<S2SV> target_container ) ; //<S2SV> if ( skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_ETH_ADDRS ) ) { //<S2SV> struct ethhdr * eth = eth_hdr ( skb ) ; //<S2SV> struct flow_dissector_key_eth_addrs * key_eth_addrs ; //<S2SV> key_eth_addrs = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_ETH_ADDRS , //<S2SV> target_container ) ; //<S2SV> memcpy ( key_eth_addrs , & eth -> h_dest , sizeof ( * key_eth_addrs ) ) ; //<S2SV> } //<S2SV> again : //<S2SV> switch ( proto ) { //<S2SV> case htons ( ETH_P_IP ) : { //<S2SV> const struct iphdr * iph ; //<S2SV> struct iphdr _iph ; //<S2SV> ip : //<S2SV> iph = __skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , data , hlen , & _iph ) ; //<S2SV> if ( ! iph || iph -> ihl < 5 ) //<S2SV> goto out_bad ; //<S2SV> nhoff += iph -> ihl * 4 ; //<S2SV> ip_proto = iph -> protocol ; //<S2SV> if ( ip_is_fragment ( iph ) ) //<S2SV> ip_proto = 0 ; //<S2SV> if ( ! skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_IPV4_ADDRS ) ) //<S2SV> break ; //<S2SV> key_addrs = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_IPV4_ADDRS , target_container ) ; //<S2SV> memcpy ( & key_addrs -> v4addrs , & iph -> saddr , //<S2SV> sizeof ( key_addrs -> v4addrs ) ) ; //<S2SV> key_control -> addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS ; //<S2SV> break ; //<S2SV> } //<S2SV> case htons ( ETH_P_IPV6 ) : { //<S2SV> const struct ipv6hdr * iph ; //<S2SV> struct ipv6hdr _iph ; //<S2SV> __be32 flow_label ; //<S2SV> ipv6 : //<S2SV> iph = __skb_header_pointer ( skb , nhoff , sizeof ( _iph ) , data , hlen , & _iph ) ; //<S2SV> if ( ! iph ) //<S2SV> goto out_bad ; //<S2SV> ip_proto = iph -> nexthdr ; //<S2SV> nhoff += sizeof ( struct ipv6hdr ) ; //<S2SV> if ( skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_IPV6_ADDRS ) ) { //<S2SV> struct flow_dissector_key_ipv6_addrs * key_ipv6_addrs ; //<S2SV> key_ipv6_addrs = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_IPV6_ADDRS , //<S2SV> target_container ) ; //<S2SV> memcpy ( key_ipv6_addrs , & iph -> saddr , sizeof ( * key_ipv6_addrs ) ) ; //<S2SV> key_control -> addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS ; //<S2SV> } //<S2SV> flow_label = ip6_flowlabel ( iph ) ; //<S2SV> if ( flow_label ) { //<S2SV> if ( skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_FLOW_LABEL ) ) { //<S2SV> key_tags = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_FLOW_LABEL , //<S2SV> target_container ) ; //<S2SV> key_tags -> flow_label = ntohl ( flow_label ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case htons ( ETH_P_8021AD ) : //<S2SV> case htons ( ETH_P_8021Q ) : { //<S2SV> const struct vlan_hdr * vlan ; //<S2SV> struct vlan_hdr _vlan ; //<S2SV> vlan = __skb_header_pointer ( skb , nhoff , sizeof ( _vlan ) , data , hlen , & _vlan ) ; //<S2SV> if ( ! vlan ) //<S2SV> goto out_bad ; //<S2SV> if ( skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_VLANID ) ) { //<S2SV> key_tags = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_VLANID , //<S2SV> target_container ) ; //<S2SV> key_tags -> vlan_id = skb_vlan_tag_get_id ( skb ) ; //<S2SV> } //<S2SV> proto = vlan -> h_vlan_encapsulated_proto ; //<S2SV> nhoff += sizeof ( * vlan ) ; //<S2SV> goto again ; //<S2SV> } //<S2SV> case htons ( ETH_P_PPP_SES ) : { //<S2SV> struct { //<S2SV> struct pppoe_hdr hdr ; //<S2SV> __be16 proto ; //<S2SV> } * hdr , _hdr ; //<S2SV> hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; //<S2SV> if ( ! hdr ) //<S2SV> goto out_bad ; //<S2SV> proto = hdr -> proto ; //<S2SV> nhoff += PPPOE_SES_HLEN ; //<S2SV> switch ( proto ) { //<S2SV> case htons ( PPP_IP ) : //<S2SV> goto ip ; //<S2SV> case htons ( PPP_IPV6 ) : //<S2SV> goto ipv6 ; //<S2SV> default : //<S2SV> goto out_bad ; //<S2SV> } //<S2SV> } //<S2SV> case htons ( ETH_P_TIPC ) : { //<S2SV> struct { //<S2SV> __be32 pre [ 3 ] ; //<S2SV> __be32 srcnode ; //<S2SV> } * hdr , _hdr ; //<S2SV> hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; //<S2SV> if ( ! hdr ) //<S2SV> goto out_bad ; //<S2SV> if ( skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_TIPC_ADDRS ) ) { //<S2SV> key_addrs = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_TIPC_ADDRS , //<S2SV> target_container ) ; //<S2SV> key_addrs -> tipcaddrs . srcnode = hdr -> srcnode ; //<S2SV> key_control -> addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS ; //<S2SV> } //<S2SV> goto out_good ; //<S2SV> } //<S2SV> case htons ( ETH_P_MPLS_UC ) : //<S2SV> case htons ( ETH_P_MPLS_MC ) : { //<S2SV> struct mpls_label * hdr , _hdr [ 2 ] ; //<S2SV> mpls : //<S2SV> hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , //<S2SV> hlen , & _hdr ) ; //<S2SV> if ( ! hdr ) //<S2SV> goto out_bad ; //<S2SV> if ( ( ntohl ( hdr [ 0 ] . entry ) & MPLS_LS_LABEL_MASK ) >> //<S2SV> MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY ) { //<S2SV> if ( skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_MPLS_ENTROPY ) ) { //<S2SV> key_keyid = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_MPLS_ENTROPY , //<S2SV> target_container ) ; //<S2SV> key_keyid -> keyid = hdr [ 1 ] . entry & //<S2SV> htonl ( MPLS_LS_LABEL_MASK ) ; //<S2SV> } //<S2SV> goto out_good ; //<S2SV> } //<S2SV> goto out_good ; //<S2SV> } //<S2SV> case htons ( ETH_P_FCOE ) : //<S2SV> key_control -> thoff = ( u16 ) ( nhoff + FCOE_HEADER_LEN ) ; //<S2SV> default : //<S2SV> goto out_bad ; //<S2SV> } //<S2SV> ip_proto_again : //<S2SV> switch ( ip_proto ) { //<S2SV> case IPPROTO_GRE : { //<S2SV> struct gre_hdr { //<S2SV> __be16 flags ; //<S2SV> __be16 proto ; //<S2SV> } * hdr , _hdr ; //<S2SV> hdr = __skb_header_pointer ( skb , nhoff , sizeof ( _hdr ) , data , hlen , & _hdr ) ; //<S2SV> if ( ! hdr ) //<S2SV> goto out_bad ; //<S2SV> if ( hdr -> flags & ( GRE_VERSION | GRE_ROUTING ) ) //<S2SV> break ; //<S2SV> proto = hdr -> proto ; //<S2SV> nhoff += 4 ; //<S2SV> if ( hdr -> flags & GRE_CSUM ) //<S2SV> nhoff += 4 ; //<S2SV> if ( hdr -> flags & GRE_KEY ) { //<S2SV> const __be32 * keyid ; //<S2SV> __be32 _keyid ; //<S2SV> keyid = __skb_header_pointer ( skb , nhoff , sizeof ( _keyid ) , //<S2SV> data , hlen , & _keyid ) ; //<S2SV> if ( ! keyid ) //<S2SV> goto out_bad ; //<S2SV> if ( skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_GRE_KEYID ) ) { //<S2SV> key_keyid = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_GRE_KEYID , //<S2SV> target_container ) ; //<S2SV> key_keyid -> keyid = * keyid ; //<S2SV> } //<S2SV> nhoff += 4 ; //<S2SV> } //<S2SV> if ( hdr -> flags & GRE_SEQ ) //<S2SV> nhoff += 4 ; //<S2SV> if ( proto == htons ( ETH_P_TEB ) ) { //<S2SV> const struct ethhdr * eth ; //<S2SV> struct ethhdr _eth ; //<S2SV> eth = __skb_header_pointer ( skb , nhoff , //<S2SV> sizeof ( _eth ) , //<S2SV> data , hlen , & _eth ) ; //<S2SV> if ( ! eth ) //<S2SV> goto out_bad ; //<S2SV> proto = eth -> h_proto ; //<S2SV> nhoff += sizeof ( * eth ) ; //<S2SV> } //<S2SV> goto again ; //<S2SV> } //<S2SV> case NEXTHDR_HOP : //<S2SV> case NEXTHDR_ROUTING : //<S2SV> case NEXTHDR_DEST : { //<S2SV> u8 _opthdr [ 2 ] , * opthdr ; //<S2SV> if ( proto != htons ( ETH_P_IPV6 ) ) //<S2SV> break ; //<S2SV> opthdr = __skb_header_pointer ( skb , nhoff , sizeof ( _opthdr ) , //<S2SV> data , hlen , & _opthdr ) ; //<S2SV> if ( ! opthdr ) //<S2SV> goto out_bad ; //<S2SV> ip_proto = opthdr [ 0 ] ; //<S2SV> nhoff += ( opthdr [ 1 ] + 1 ) << 3 ; //<S2SV> goto ip_proto_again ; //<S2SV> } //<S2SV> case IPPROTO_IPIP : //<S2SV> proto = htons ( ETH_P_IP ) ; //<S2SV> goto ip ; //<S2SV> case IPPROTO_IPV6 : //<S2SV> proto = htons ( ETH_P_IPV6 ) ; //<S2SV> goto ipv6 ; //<S2SV> case IPPROTO_MPLS : //<S2SV> proto = htons ( ETH_P_MPLS_UC ) ; //<S2SV> goto mpls ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> if ( skb_flow_dissector_uses_key ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_PORTS ) ) { //<S2SV> key_ports = skb_flow_dissector_target ( flow_dissector , //<S2SV> FLOW_DISSECTOR_KEY_PORTS , //<S2SV> target_container ) ; //<S2SV> key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , //<S2SV> data , hlen ) ; //<S2SV> } //<S2SV> out_good : //<S2SV> ret = true ; //<S2SV> out_bad : //<S2SV> key_basic -> n_proto = proto ; //<S2SV> key_basic -> ip_proto = ip_proto ; //<S2SV> key_control -> thoff = ( u16 ) nhoff ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 