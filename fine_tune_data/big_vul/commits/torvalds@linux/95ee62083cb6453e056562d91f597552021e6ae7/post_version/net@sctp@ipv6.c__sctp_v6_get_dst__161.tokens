static void sctp_v6_get_dst ( struct sctp_transport * t , union sctp_addr * saddr , //<S2SV> struct flowi * fl , struct sock * sk ) //<S2SV> { //<S2SV> struct sctp_association * asoc = t -> asoc ; //<S2SV> struct dst_entry * dst = NULL ; //<S2SV> struct flowi6 * fl6 = & fl -> u . ip6 ; //<S2SV> struct sctp_bind_addr * bp ; //<S2SV> struct ipv6_pinfo * np = inet6_sk ( sk ) ; //<S2SV> struct sctp_sockaddr_entry * laddr ; //<S2SV> union sctp_addr * baddr = NULL ; //<S2SV> union sctp_addr * daddr = & t -> ipaddr ; //<S2SV> union sctp_addr dst_saddr ; //<S2SV> struct in6_addr * final_p , final ; //<S2SV> __u8 matchlen = 0 ; //<S2SV> __u8 bmatchlen ; //<S2SV> sctp_scope_t scope ; //<S2SV> memset ( fl6 , 0 , sizeof ( struct flowi6 ) ) ; //<S2SV> fl6 -> daddr = daddr -> v6 . sin6_addr ; //<S2SV> fl6 -> fl6_dport = daddr -> v6 . sin6_port ; //<S2SV> fl6 -> flowi6_proto = IPPROTO_SCTP ; //<S2SV> if ( ipv6_addr_type ( & daddr -> v6 . sin6_addr ) & IPV6_ADDR_LINKLOCAL ) //<S2SV> fl6 -> flowi6_oif = daddr -> v6 . sin6_scope_id ; //<S2SV> pr_debug ( "%s:<S2SV_blank>dst=%pI6<S2SV_blank>" , __func__ , & fl6 -> daddr ) ; //<S2SV> if ( asoc ) //<S2SV> fl6 -> fl6_sport = htons ( asoc -> base . bind_addr . port ) ; //<S2SV> if ( saddr ) { //<S2SV> fl6 -> saddr = saddr -> v6 . sin6_addr ; //<S2SV> fl6 -> fl6_sport = saddr -> v6 . sin6_port ; //<S2SV> pr_debug ( "src=%pI6<S2SV_blank>-<S2SV_blank>" , & fl6 -> saddr ) ; //<S2SV> } //<S2SV> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , fl6 , final_p , false ) ; //<S2SV> if ( ! asoc || saddr ) //<S2SV> goto out ; //<S2SV> bp = & asoc -> base . bind_addr ; //<S2SV> scope = sctp_scope ( daddr ) ; //<S2SV> if ( ! IS_ERR ( dst ) ) { //<S2SV> sctp_v6_to_addr ( & dst_saddr , & fl6 -> saddr , htons ( bp -> port ) ) ; //<S2SV> rcu_read_lock ( ) ; //<S2SV> list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { //<S2SV> if ( ! laddr -> valid || ( laddr -> state != SCTP_ADDR_SRC ) ) //<S2SV> continue ; //<S2SV> if ( ( laddr -> a . sa . sa_family == AF_INET6 ) && //<S2SV> ( sctp_v6_cmp_addr ( & dst_saddr , & laddr -> a ) ) ) { //<S2SV> rcu_read_unlock ( ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> dst_release ( dst ) ; //<S2SV> dst = NULL ; //<S2SV> } //<S2SV> rcu_read_lock ( ) ; //<S2SV> list_for_each_entry_rcu ( laddr , & bp -> address_list , list ) { //<S2SV> if ( ! laddr -> valid ) //<S2SV> continue ; //<S2SV> if ( ( laddr -> state == SCTP_ADDR_SRC ) && //<S2SV> ( laddr -> a . sa . sa_family == AF_INET6 ) && //<S2SV> ( scope <= sctp_scope ( & laddr -> a ) ) ) { //<S2SV> bmatchlen = sctp_v6_addr_match_len ( daddr , & laddr -> a ) ; //<S2SV> if ( ! baddr || ( matchlen < bmatchlen ) ) { //<S2SV> baddr = & laddr -> a ; //<S2SV> matchlen = bmatchlen ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> rcu_read_unlock ( ) ; //<S2SV> if ( baddr ) { //<S2SV> fl6 -> saddr = baddr -> v6 . sin6_addr ; //<S2SV> fl6 -> fl6_sport = baddr -> v6 . sin6_port ; //<S2SV> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; //<S2SV> dst = ip6_dst_lookup_flow ( sk , fl6 , final_p , false ) ; //<S2SV> } //<S2SV> out : //<S2SV> if ( ! IS_ERR_OR_NULL ( dst ) ) { //<S2SV> struct rt6_info * rt ; //<S2SV> rt = ( struct rt6_info * ) dst ; //<S2SV> t -> dst = dst ; //<S2SV> t -> dst_cookie = rt -> rt6i_node ? rt -> rt6i_node -> fn_sernum : 0 ; //<S2SV> pr_debug ( "rt6_dst:%pI6<S2SV_blank>rt6_src:%pI6\\n" , & rt -> rt6i_dst . addr , //<S2SV> & fl6 -> saddr ) ; //<S2SV> } else { //<S2SV> t -> dst = NULL ; //<S2SV> pr_debug ( "no<S2SV_blank>route\\n" ) ; //<S2SV> } //<S2SV> } //<S2SV> 