static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , //<S2SV> netdev_features_t features ) //<S2SV> { //<S2SV> struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; //<S2SV> unsigned int mss ; //<S2SV> unsigned int unfrag_ip6hlen , unfrag_len ; //<S2SV> struct frag_hdr * fptr ; //<S2SV> u8 * packet_start , * prevhdr ; //<S2SV> u8 nexthdr ; //<S2SV> u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; //<S2SV> int offset ; //<S2SV> __wsum csum ; //<S2SV> int tnl_hlen ; //<S2SV> mss = skb_shinfo ( skb ) -> gso_size ; //<S2SV> if ( unlikely ( skb -> len <= mss ) ) //<S2SV> goto out ; //<S2SV> if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { //<S2SV> int type = skb_shinfo ( skb ) -> gso_type ; //<S2SV> if ( unlikely ( type & ~ ( SKB_GSO_UDP | //<S2SV> SKB_GSO_DODGY | //<S2SV> SKB_GSO_UDP_TUNNEL | //<S2SV> SKB_GSO_GRE | //<S2SV> SKB_GSO_IPIP | //<S2SV> SKB_GSO_SIT | //<S2SV> SKB_GSO_MPLS ) || //<S2SV> ! ( type & ( SKB_GSO_UDP ) ) ) ) //<S2SV> goto out ; //<S2SV> skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; //<S2SV> segs = NULL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) //<S2SV> segs = skb_udp_tunnel_segment ( skb , features ) ; //<S2SV> else { //<S2SV> offset = skb_checksum_start_offset ( skb ) ; //<S2SV> csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; //<S2SV> offset += skb -> csum_offset ; //<S2SV> * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; //<S2SV> skb -> ip_summed = CHECKSUM_NONE ; //<S2SV> tnl_hlen = skb_tnl_header_len ( skb ) ; //<S2SV> if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { //<S2SV> if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) //<S2SV> goto out ; //<S2SV> } //<S2SV> unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; //<S2SV> nexthdr = * prevhdr ; //<S2SV> * prevhdr = NEXTHDR_FRAGMENT ; //<S2SV> unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + //<S2SV> unfrag_ip6hlen + tnl_hlen ; //<S2SV> packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; //<S2SV> memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; //<S2SV> SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; //<S2SV> skb -> mac_header -= frag_hdr_sz ; //<S2SV> skb -> network_header -= frag_hdr_sz ; //<S2SV> fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; //<S2SV> fptr -> nexthdr = nexthdr ; //<S2SV> fptr -> reserved = 0 ; //<S2SV> ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb ) ) ; //<S2SV> segs = skb_segment ( skb , features ) ; //<S2SV> } //<S2SV> out : //<S2SV> return segs ; //<S2SV> } //<S2SV> 