static void hub_activate ( struct usb_hub * hub , enum hub_activation_type type ) //<S2SV> { //<S2SV> struct usb_device * hdev = hub -> hdev ; //<S2SV> struct usb_hcd * hcd ; //<S2SV> int ret ; //<S2SV> int port1 ; //<S2SV> int status ; //<S2SV> bool need_debounce_delay = false ; //<S2SV> unsigned delay ; //<S2SV> if ( type == HUB_INIT2 || type == HUB_INIT3 ) { //<S2SV> device_lock ( hub -> intfdev ) ; //<S2SV> if ( hub -> disconnected ) { //<S2SV> device_unlock ( hub -> intfdev ) ; //<S2SV> kref_put ( & hub -> kref , hub_release ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( type == HUB_INIT2 ) //<S2SV> goto init2 ; //<S2SV> goto init3 ; //<S2SV> } //<S2SV> kref_get ( & hub -> kref ) ; //<S2SV> if ( type != HUB_RESUME ) { //<S2SV> if ( hdev -> parent && hub_is_superspeed ( hdev ) ) { //<S2SV> ret = usb_control_msg ( hdev , usb_sndctrlpipe ( hdev , 0 ) , //<S2SV> HUB_SET_DEPTH , USB_RT_HUB , //<S2SV> hdev -> level - 1 , 0 , NULL , 0 , //<S2SV> USB_CTRL_SET_TIMEOUT ) ; //<S2SV> if ( ret < 0 ) //<S2SV> dev_err ( hub -> intfdev , //<S2SV> "set<S2SV_blank>hub<S2SV_blank>depth<S2SV_blank>failed\\n" ) ; //<S2SV> } //<S2SV> if ( type == HUB_INIT ) { //<S2SV> delay = hub_power_on_good_delay ( hub ) ; //<S2SV> hub_power_on ( hub , false ) ; //<S2SV> INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func2 ) ; //<S2SV> queue_delayed_work ( system_power_efficient_wq , //<S2SV> & hub -> init_work , //<S2SV> msecs_to_jiffies ( delay ) ) ; //<S2SV> usb_autopm_get_interface_no_resume ( //<S2SV> to_usb_interface ( hub -> intfdev ) ) ; //<S2SV> return ; //<S2SV> } else if ( type == HUB_RESET_RESUME ) { //<S2SV> hcd = bus_to_hcd ( hdev -> bus ) ; //<S2SV> if ( hcd -> driver -> update_hub_device ) { //<S2SV> ret = hcd -> driver -> update_hub_device ( hcd , hdev , //<S2SV> & hub -> tt , GFP_NOIO ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> dev_err ( hub -> intfdev , "Host<S2SV_blank>not<S2SV_blank>" //<S2SV> "accepting<S2SV_blank>hub<S2SV_blank>info<S2SV_blank>" //<S2SV> "update.\\n" ) ; //<S2SV> dev_err ( hub -> intfdev , "LS/FS<S2SV_blank>devices<S2SV_blank>" //<S2SV> "and<S2SV_blank>hubs<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work<S2SV_blank>" //<S2SV> "under<S2SV_blank>this<S2SV_blank>hub\\n." ) ; //<S2SV> } //<S2SV> } //<S2SV> hub_power_on ( hub , true ) ; //<S2SV> } else { //<S2SV> hub_power_on ( hub , true ) ; //<S2SV> } //<S2SV> } //<S2SV> init2 : //<S2SV> for ( port1 = 1 ; port1 <= hdev -> maxchild ; ++ port1 ) { //<S2SV> struct usb_port * port_dev = hub -> ports [ port1 - 1 ] ; //<S2SV> struct usb_device * udev = port_dev -> child ; //<S2SV> u16 portstatus , portchange ; //<S2SV> portstatus = portchange = 0 ; //<S2SV> status = hub_port_status ( hub , port1 , & portstatus , & portchange ) ; //<S2SV> if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) ) //<S2SV> dev_dbg ( & port_dev -> dev , "status<S2SV_blank>%04x<S2SV_blank>change<S2SV_blank>%04x\\n" , //<S2SV> portstatus , portchange ) ; //<S2SV> if ( ( portstatus & USB_PORT_STAT_ENABLE ) && ( //<S2SV> type != HUB_RESUME || //<S2SV> ! ( portstatus & USB_PORT_STAT_CONNECTION ) || //<S2SV> ! udev || //<S2SV> udev -> state == USB_STATE_NOTATTACHED ) ) { //<S2SV> portstatus &= ~ USB_PORT_STAT_ENABLE ; //<S2SV> if ( ! hub_is_superspeed ( hdev ) ) //<S2SV> usb_clear_port_feature ( hdev , port1 , //<S2SV> USB_PORT_FEAT_ENABLE ) ; //<S2SV> } //<S2SV> if ( portchange & USB_PORT_STAT_C_CONNECTION ) { //<S2SV> need_debounce_delay = true ; //<S2SV> usb_clear_port_feature ( hub -> hdev , port1 , //<S2SV> USB_PORT_FEAT_C_CONNECTION ) ; //<S2SV> } //<S2SV> if ( portchange & USB_PORT_STAT_C_ENABLE ) { //<S2SV> need_debounce_delay = true ; //<S2SV> usb_clear_port_feature ( hub -> hdev , port1 , //<S2SV> USB_PORT_FEAT_C_ENABLE ) ; //<S2SV> } //<S2SV> if ( portchange & USB_PORT_STAT_C_RESET ) { //<S2SV> need_debounce_delay = true ; //<S2SV> usb_clear_port_feature ( hub -> hdev , port1 , //<S2SV> USB_PORT_FEAT_C_RESET ) ; //<S2SV> } //<S2SV> if ( ( portchange & USB_PORT_STAT_C_BH_RESET ) && //<S2SV> hub_is_superspeed ( hub -> hdev ) ) { //<S2SV> need_debounce_delay = true ; //<S2SV> usb_clear_port_feature ( hub -> hdev , port1 , //<S2SV> USB_PORT_FEAT_C_BH_PORT_RESET ) ; //<S2SV> } //<S2SV> if ( ! ( portstatus & USB_PORT_STAT_CONNECTION ) || //<S2SV> ( portchange & USB_PORT_STAT_C_CONNECTION ) ) //<S2SV> clear_bit ( port1 , hub -> removed_bits ) ; //<S2SV> if ( ! udev || udev -> state == USB_STATE_NOTATTACHED ) { //<S2SV> if ( udev || ( portstatus & USB_PORT_STAT_CONNECTION ) || //<S2SV> ( portstatus & USB_PORT_STAT_OVERCURRENT ) ) //<S2SV> set_bit ( port1 , hub -> change_bits ) ; //<S2SV> } else if ( portstatus & USB_PORT_STAT_ENABLE ) { //<S2SV> bool port_resumed = ( portstatus & //<S2SV> USB_PORT_STAT_LINK_STATE ) == //<S2SV> USB_SS_PORT_LS_U0 ; //<S2SV> if ( portchange || ( hub_is_superspeed ( hub -> hdev ) && //<S2SV> port_resumed ) ) //<S2SV> set_bit ( port1 , hub -> change_bits ) ; //<S2SV> } else if ( udev -> persist_enabled ) { //<S2SV> # ifdef CONFIG_PM //<S2SV> udev -> reset_resume = 1 ; //<S2SV> # endif //<S2SV> if ( test_bit ( port1 , hub -> power_bits ) ) //<S2SV> set_bit ( port1 , hub -> change_bits ) ; //<S2SV> } else { //<S2SV> usb_set_device_state ( udev , USB_STATE_NOTATTACHED ) ; //<S2SV> set_bit ( port1 , hub -> change_bits ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( need_debounce_delay ) { //<S2SV> delay = HUB_DEBOUNCE_STABLE ; //<S2SV> if ( type == HUB_INIT2 ) { //<S2SV> INIT_DELAYED_WORK ( & hub -> init_work , hub_init_func3 ) ; //<S2SV> queue_delayed_work ( system_power_efficient_wq , //<S2SV> & hub -> init_work , //<S2SV> msecs_to_jiffies ( delay ) ) ; //<S2SV> device_unlock ( hub -> intfdev ) ; //<S2SV> return ; //<S2SV> } else { //<S2SV> msleep ( delay ) ; //<S2SV> } //<S2SV> } //<S2SV> init3 : //<S2SV> hub -> quiescing = 0 ; //<S2SV> status = usb_submit_urb ( hub -> urb , GFP_NOIO ) ; //<S2SV> if ( status < 0 ) //<S2SV> dev_err ( hub -> intfdev , "activate<S2SV_blank>--><S2SV_blank>%d\\n" , status ) ; //<S2SV> if ( hub -> has_indicators && blinkenlights ) //<S2SV> queue_delayed_work ( system_power_efficient_wq , //<S2SV> & hub -> leds , LED_CYCLE_PERIOD ) ; //<S2SV> kick_hub_wq ( hub ) ; //<S2SV> if ( type <= HUB_INIT3 ) //<S2SV> usb_autopm_put_interface_async ( to_usb_interface ( hub -> intfdev ) ) ; //<S2SV> if ( type == HUB_INIT2 || type == HUB_INIT3 ) //<S2SV> device_unlock ( hub -> intfdev ) ; //<S2SV> kref_put ( & hub -> kref , hub_release ) ; //<S2SV> } //<S2SV> 