int ring_buffer_resize ( struct ring_buffer * buffer , unsigned long size , //<S2SV> int cpu_id ) //<S2SV> { //<S2SV> struct ring_buffer_per_cpu * cpu_buffer ; //<S2SV> unsigned long nr_pages ; //<S2SV> int cpu , err = 0 ; //<S2SV> if ( ! buffer ) //<S2SV> return size ; //<S2SV> if ( cpu_id != RING_BUFFER_ALL_CPUS && //<S2SV> ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) //<S2SV> return size ; //<S2SV> size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; //<S2SV> size *= BUF_PAGE_SIZE ; //<S2SV> if ( size < BUF_PAGE_SIZE * 2 ) //<S2SV> size = BUF_PAGE_SIZE * 2 ; //<S2SV> nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; //<S2SV> if ( atomic_read ( & buffer -> resize_disabled ) ) //<S2SV> return - EBUSY ; //<S2SV> mutex_lock ( & buffer -> mutex ) ; //<S2SV> if ( cpu_id == RING_BUFFER_ALL_CPUS ) { //<S2SV> for_each_buffer_cpu ( buffer , cpu ) { //<S2SV> cpu_buffer = buffer -> buffers [ cpu ] ; //<S2SV> cpu_buffer -> nr_pages_to_update = nr_pages - //<S2SV> cpu_buffer -> nr_pages ; //<S2SV> if ( cpu_buffer -> nr_pages_to_update <= 0 ) //<S2SV> continue ; //<S2SV> INIT_LIST_HEAD ( & cpu_buffer -> new_pages ) ; //<S2SV> if ( __rb_allocate_pages ( cpu_buffer -> nr_pages_to_update , //<S2SV> & cpu_buffer -> new_pages , cpu ) ) { //<S2SV> err = - ENOMEM ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> } //<S2SV> get_online_cpus ( ) ; //<S2SV> for_each_buffer_cpu ( buffer , cpu ) { //<S2SV> cpu_buffer = buffer -> buffers [ cpu ] ; //<S2SV> if ( ! cpu_buffer -> nr_pages_to_update ) //<S2SV> continue ; //<S2SV> if ( ! cpu_online ( cpu ) ) { //<S2SV> rb_update_pages ( cpu_buffer ) ; //<S2SV> cpu_buffer -> nr_pages_to_update = 0 ; //<S2SV> } else { //<S2SV> schedule_work_on ( cpu , //<S2SV> & cpu_buffer -> update_pages_work ) ; //<S2SV> } //<S2SV> } //<S2SV> for_each_buffer_cpu ( buffer , cpu ) { //<S2SV> cpu_buffer = buffer -> buffers [ cpu ] ; //<S2SV> if ( ! cpu_buffer -> nr_pages_to_update ) //<S2SV> continue ; //<S2SV> if ( cpu_online ( cpu ) ) //<S2SV> wait_for_completion ( & cpu_buffer -> update_done ) ; //<S2SV> cpu_buffer -> nr_pages_to_update = 0 ; //<S2SV> } //<S2SV> put_online_cpus ( ) ; //<S2SV> } else { //<S2SV> if ( ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) //<S2SV> goto out ; //<S2SV> cpu_buffer = buffer -> buffers [ cpu_id ] ; //<S2SV> if ( nr_pages == cpu_buffer -> nr_pages ) //<S2SV> goto out ; //<S2SV> cpu_buffer -> nr_pages_to_update = nr_pages - //<S2SV> cpu_buffer -> nr_pages ; //<S2SV> INIT_LIST_HEAD ( & cpu_buffer -> new_pages ) ; //<S2SV> if ( cpu_buffer -> nr_pages_to_update > 0 && //<S2SV> __rb_allocate_pages ( cpu_buffer -> nr_pages_to_update , //<S2SV> & cpu_buffer -> new_pages , cpu_id ) ) { //<S2SV> err = - ENOMEM ; //<S2SV> goto out_err ; //<S2SV> } //<S2SV> get_online_cpus ( ) ; //<S2SV> if ( ! cpu_online ( cpu_id ) ) //<S2SV> rb_update_pages ( cpu_buffer ) ; //<S2SV> else { //<S2SV> schedule_work_on ( cpu_id , //<S2SV> & cpu_buffer -> update_pages_work ) ; //<S2SV> wait_for_completion ( & cpu_buffer -> update_done ) ; //<S2SV> } //<S2SV> cpu_buffer -> nr_pages_to_update = 0 ; //<S2SV> put_online_cpus ( ) ; //<S2SV> } //<S2SV> out : //<S2SV> if ( atomic_read ( & buffer -> record_disabled ) ) { //<S2SV> atomic_inc ( & buffer -> record_disabled ) ; //<S2SV> synchronize_sched ( ) ; //<S2SV> for_each_buffer_cpu ( buffer , cpu ) { //<S2SV> cpu_buffer = buffer -> buffers [ cpu ] ; //<S2SV> rb_check_pages ( cpu_buffer ) ; //<S2SV> } //<S2SV> atomic_dec ( & buffer -> record_disabled ) ; //<S2SV> } //<S2SV> mutex_unlock ( & buffer -> mutex ) ; //<S2SV> return size ; //<S2SV> out_err : //<S2SV> for_each_buffer_cpu ( buffer , cpu ) { //<S2SV> struct buffer_page * bpage , * tmp ; //<S2SV> cpu_buffer = buffer -> buffers [ cpu ] ; //<S2SV> cpu_buffer -> nr_pages_to_update = 0 ; //<S2SV> if ( list_empty ( & cpu_buffer -> new_pages ) ) //<S2SV> continue ; //<S2SV> list_for_each_entry_safe ( bpage , tmp , & cpu_buffer -> new_pages , //<S2SV> list ) { //<S2SV> list_del_init ( & bpage -> list ) ; //<S2SV> free_buffer_page ( bpage ) ; //<S2SV> } //<S2SV> } //<S2SV> mutex_unlock ( & buffer -> mutex ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 