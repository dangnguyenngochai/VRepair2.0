static ssize_t //<S2SV> cifs_iovec_write ( struct file * file , const struct iovec * iov , //<S2SV> unsigned long nr_segs , loff_t * poffset ) //<S2SV> { //<S2SV> unsigned long nr_pages , i ; //<S2SV> size_t copied , len , cur_len ; //<S2SV> ssize_t total_written = 0 ; //<S2SV> loff_t offset ; //<S2SV> struct iov_iter it ; //<S2SV> struct cifsFileInfo * open_file ; //<S2SV> struct cifs_tcon * tcon ; //<S2SV> struct cifs_sb_info * cifs_sb ; //<S2SV> struct cifs_writedata * wdata , * tmp ; //<S2SV> struct list_head wdata_list ; //<S2SV> int rc ; //<S2SV> pid_t pid ; //<S2SV> len = iov_length ( iov , nr_segs ) ; //<S2SV> if ( ! len ) //<S2SV> return 0 ; //<S2SV> rc = generic_write_checks ( file , poffset , & len , 0 ) ; //<S2SV> if ( rc ) //<S2SV> return rc ; //<S2SV> INIT_LIST_HEAD ( & wdata_list ) ; //<S2SV> cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; //<S2SV> open_file = file -> private_data ; //<S2SV> tcon = tlink_tcon ( open_file -> tlink ) ; //<S2SV> if ( ! tcon -> ses -> server -> ops -> async_writev ) //<S2SV> return - ENOSYS ; //<S2SV> offset = * poffset ; //<S2SV> if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) //<S2SV> pid = open_file -> pid ; //<S2SV> else //<S2SV> pid = current -> tgid ; //<S2SV> iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; //<S2SV> do { //<S2SV> size_t save_len ; //<S2SV> nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; //<S2SV> wdata = cifs_writedata_alloc ( nr_pages , //<S2SV> cifs_uncached_writev_complete ) ; //<S2SV> if ( ! wdata ) { //<S2SV> rc = - ENOMEM ; //<S2SV> break ; //<S2SV> } //<S2SV> rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; //<S2SV> if ( rc ) { //<S2SV> kfree ( wdata ) ; //<S2SV> break ; //<S2SV> } //<S2SV> save_len = cur_len ; //<S2SV> for ( i = 0 ; i < nr_pages ; i ++ ) { //<S2SV> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; //<S2SV> copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , //<S2SV> 0 , copied ) ; //<S2SV> cur_len -= copied ; //<S2SV> iov_iter_advance ( & it , copied ) ; //<S2SV> } //<S2SV> cur_len = save_len - cur_len ; //<S2SV> wdata -> sync_mode = WB_SYNC_ALL ; //<S2SV> wdata -> nr_pages = nr_pages ; //<S2SV> wdata -> offset = ( __u64 ) offset ; //<S2SV> wdata -> cfile = cifsFileInfo_get ( open_file ) ; //<S2SV> wdata -> pid = pid ; //<S2SV> wdata -> bytes = cur_len ; //<S2SV> wdata -> pagesz = PAGE_SIZE ; //<S2SV> wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ) ; //<S2SV> rc = cifs_uncached_retry_writev ( wdata ) ; //<S2SV> if ( rc ) { //<S2SV> kref_put ( & wdata -> refcount , //<S2SV> cifs_uncached_writedata_release ) ; //<S2SV> break ; //<S2SV> } //<S2SV> list_add_tail ( & wdata -> list , & wdata_list ) ; //<S2SV> offset += cur_len ; //<S2SV> len -= cur_len ; //<S2SV> } while ( len > 0 ) ; //<S2SV> if ( ! list_empty ( & wdata_list ) ) //<S2SV> rc = 0 ; //<S2SV> restart_loop : //<S2SV> list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { //<S2SV> if ( ! rc ) { //<S2SV> rc = wait_for_completion_killable ( & wdata -> done ) ; //<S2SV> if ( rc ) //<S2SV> rc = - EINTR ; //<S2SV> else if ( wdata -> result ) //<S2SV> rc = wdata -> result ; //<S2SV> else //<S2SV> total_written += wdata -> bytes ; //<S2SV> if ( rc == - EAGAIN ) { //<S2SV> rc = cifs_uncached_retry_writev ( wdata ) ; //<S2SV> goto restart_loop ; //<S2SV> } //<S2SV> } //<S2SV> list_del_init ( & wdata -> list ) ; //<S2SV> kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; //<S2SV> } //<S2SV> if ( total_written > 0 ) //<S2SV> * poffset += total_written ; //<S2SV> cifs_stats_bytes_written ( tcon , total_written ) ; //<S2SV> return total_written ? total_written : ( ssize_t ) rc ; //<S2SV> } //<S2SV> 