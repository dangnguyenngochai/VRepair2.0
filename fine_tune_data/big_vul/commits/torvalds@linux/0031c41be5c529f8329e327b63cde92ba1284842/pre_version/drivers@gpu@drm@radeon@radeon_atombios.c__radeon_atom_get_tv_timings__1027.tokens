bool radeon_atom_get_tv_timings ( struct radeon_device * rdev , int index , //<S2SV> struct drm_display_mode * mode ) //<S2SV> { //<S2SV> struct radeon_mode_info * mode_info = & rdev -> mode_info ; //<S2SV> ATOM_ANALOG_TV_INFO * tv_info ; //<S2SV> ATOM_ANALOG_TV_INFO_V1_2 * tv_info_v1_2 ; //<S2SV> ATOM_DTD_FORMAT * dtd_timings ; //<S2SV> int data_index = GetIndexIntoMasterTable ( DATA , AnalogTV_Info ) ; //<S2SV> u8 frev , crev ; //<S2SV> u16 data_offset , misc ; //<S2SV> if ( ! atom_parse_data_header ( mode_info -> atom_context , data_index , NULL , //<S2SV> & frev , & crev , & data_offset ) ) //<S2SV> return false ; //<S2SV> switch ( crev ) { //<S2SV> case 1 : //<S2SV> tv_info = ( ATOM_ANALOG_TV_INFO * ) ( mode_info -> atom_context -> bios + data_offset ) ; //<S2SV> if ( index > MAX_SUPPORTED_TV_TIMING ) //<S2SV> return false ; //<S2SV> mode -> crtc_htotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Total ) ; //<S2SV> mode -> crtc_hdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_Disp ) ; //<S2SV> mode -> crtc_hsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) ; //<S2SV> mode -> crtc_hsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncStart ) + //<S2SV> le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_H_SyncWidth ) ; //<S2SV> mode -> crtc_vtotal = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Total ) ; //<S2SV> mode -> crtc_vdisplay = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_Disp ) ; //<S2SV> mode -> crtc_vsync_start = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) ; //<S2SV> mode -> crtc_vsync_end = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncStart ) + //<S2SV> le16_to_cpu ( tv_info -> aModeTimings [ index ] . usCRTC_V_SyncWidth ) ; //<S2SV> mode -> flags = 0 ; //<S2SV> misc = le16_to_cpu ( tv_info -> aModeTimings [ index ] . susModeMiscInfo . usAccess ) ; //<S2SV> if ( misc & ATOM_VSYNC_POLARITY ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_NVSYNC ; //<S2SV> if ( misc & ATOM_HSYNC_POLARITY ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_NHSYNC ; //<S2SV> if ( misc & ATOM_COMPOSITESYNC ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_CSYNC ; //<S2SV> if ( misc & ATOM_INTERLACE ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_INTERLACE ; //<S2SV> if ( misc & ATOM_DOUBLE_CLOCK_MODE ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; //<S2SV> mode -> clock = le16_to_cpu ( tv_info -> aModeTimings [ index ] . usPixelClock ) * 10 ; //<S2SV> if ( index == 1 ) { //<S2SV> mode -> crtc_htotal -= 1 ; //<S2SV> mode -> crtc_vtotal -= 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case 2 : //<S2SV> tv_info_v1_2 = ( ATOM_ANALOG_TV_INFO_V1_2 * ) ( mode_info -> atom_context -> bios + data_offset ) ; //<S2SV> if ( index > MAX_SUPPORTED_TV_TIMING_V1_2 ) //<S2SV> return false ; //<S2SV> dtd_timings = & tv_info_v1_2 -> aModeTimings [ index ] ; //<S2SV> mode -> crtc_htotal = le16_to_cpu ( dtd_timings -> usHActive ) + //<S2SV> le16_to_cpu ( dtd_timings -> usHBlanking_Time ) ; //<S2SV> mode -> crtc_hdisplay = le16_to_cpu ( dtd_timings -> usHActive ) ; //<S2SV> mode -> crtc_hsync_start = le16_to_cpu ( dtd_timings -> usHActive ) + //<S2SV> le16_to_cpu ( dtd_timings -> usHSyncOffset ) ; //<S2SV> mode -> crtc_hsync_end = mode -> crtc_hsync_start + //<S2SV> le16_to_cpu ( dtd_timings -> usHSyncWidth ) ; //<S2SV> mode -> crtc_vtotal = le16_to_cpu ( dtd_timings -> usVActive ) + //<S2SV> le16_to_cpu ( dtd_timings -> usVBlanking_Time ) ; //<S2SV> mode -> crtc_vdisplay = le16_to_cpu ( dtd_timings -> usVActive ) ; //<S2SV> mode -> crtc_vsync_start = le16_to_cpu ( dtd_timings -> usVActive ) + //<S2SV> le16_to_cpu ( dtd_timings -> usVSyncOffset ) ; //<S2SV> mode -> crtc_vsync_end = mode -> crtc_vsync_start + //<S2SV> le16_to_cpu ( dtd_timings -> usVSyncWidth ) ; //<S2SV> mode -> flags = 0 ; //<S2SV> misc = le16_to_cpu ( dtd_timings -> susModeMiscInfo . usAccess ) ; //<S2SV> if ( misc & ATOM_VSYNC_POLARITY ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_NVSYNC ; //<S2SV> if ( misc & ATOM_HSYNC_POLARITY ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_NHSYNC ; //<S2SV> if ( misc & ATOM_COMPOSITESYNC ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_CSYNC ; //<S2SV> if ( misc & ATOM_INTERLACE ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_INTERLACE ; //<S2SV> if ( misc & ATOM_DOUBLE_CLOCK_MODE ) //<S2SV> mode -> flags |= DRM_MODE_FLAG_DBLSCAN ; //<S2SV> mode -> clock = le16_to_cpu ( dtd_timings -> usPixClk ) * 10 ; //<S2SV> break ; //<S2SV> } //<S2SV> return true ; //<S2SV> } //<S2SV> 