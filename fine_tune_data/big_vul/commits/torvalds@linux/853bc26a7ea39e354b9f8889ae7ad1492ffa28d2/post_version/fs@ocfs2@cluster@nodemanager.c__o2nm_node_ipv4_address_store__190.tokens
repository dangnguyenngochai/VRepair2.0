static ssize_t o2nm_node_ipv4_address_store ( struct config_item * item , //<S2SV> const char * page , //<S2SV> size_t count ) //<S2SV> { //<S2SV> struct o2nm_node * node = to_o2nm_node ( item ) ; //<S2SV> struct o2nm_cluster * cluster ; //<S2SV> int ret , i ; //<S2SV> struct rb_node * * p , * parent ; //<S2SV> unsigned int octets [ 4 ] ; //<S2SV> __be32 ipv4_addr = 0 ; //<S2SV> ret = sscanf ( page , "%3u.%3u.%3u.%3u" , & octets [ 3 ] , & octets [ 2 ] , //<S2SV> & octets [ 1 ] , & octets [ 0 ] ) ; //<S2SV> if ( ret != 4 ) //<S2SV> return - EINVAL ; //<S2SV> for ( i = 0 ; i < ARRAY_SIZE ( octets ) ; i ++ ) { //<S2SV> if ( octets [ i ] > 255 ) //<S2SV> return - ERANGE ; //<S2SV> be32_add_cpu ( & ipv4_addr , octets [ i ] << ( i * 8 ) ) ; //<S2SV> } //<S2SV> o2nm_lock_subsystem ( ) ; //<S2SV> cluster = to_o2nm_cluster_from_node ( node ) ; //<S2SV> if ( ! cluster ) { //<S2SV> o2nm_unlock_subsystem ( ) ; //<S2SV> return - EINVAL ; //<S2SV> } //<S2SV> ret = 0 ; //<S2SV> write_lock ( & cluster -> cl_nodes_lock ) ; //<S2SV> if ( o2nm_node_ip_tree_lookup ( cluster , ipv4_addr , & p , & parent ) ) //<S2SV> ret = - EEXIST ; //<S2SV> else if ( test_and_set_bit ( O2NM_NODE_ATTR_ADDRESS , //<S2SV> & node -> nd_set_attributes ) ) //<S2SV> ret = - EBUSY ; //<S2SV> else { //<S2SV> rb_link_node ( & node -> nd_ip_node , parent , p ) ; //<S2SV> rb_insert_color ( & node -> nd_ip_node , & cluster -> cl_node_ip_tree ) ; //<S2SV> } //<S2SV> write_unlock ( & cluster -> cl_nodes_lock ) ; //<S2SV> o2nm_unlock_subsystem ( ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> memcpy ( & node -> nd_ipv4_address , & ipv4_addr , sizeof ( ipv4_addr ) ) ; //<S2SV> return count ; //<S2SV> } //<S2SV> 