static int hmac_create ( struct crypto_template * tmpl , struct rtattr * * tb ) //<S2SV> { //<S2SV> struct shash_instance * inst ; //<S2SV> struct crypto_alg * alg ; //<S2SV> struct shash_alg * salg ; //<S2SV> int err ; //<S2SV> int ds ; //<S2SV> int ss ; //<S2SV> err = crypto_check_attr_type ( tb , CRYPTO_ALG_TYPE_SHASH ) ; //<S2SV> if ( err ) //<S2SV> return err ; //<S2SV> salg = shash_attr_alg ( tb [ 1 ] , 0 , 0 ) ; //<S2SV> if ( IS_ERR ( salg ) ) //<S2SV> return PTR_ERR ( salg ) ; //<S2SV> alg = & salg -> base ; //<S2SV> err = - EINVAL ; //<S2SV> if ( crypto_shash_alg_has_setkey ( salg ) ) //<S2SV> goto out_put_alg ; //<S2SV> ds = salg -> digestsize ; //<S2SV> ss = salg -> statesize ; //<S2SV> if ( ds > alg -> cra_blocksize || //<S2SV> ss < alg -> cra_blocksize ) //<S2SV> goto out_put_alg ; //<S2SV> inst = shash_alloc_instance ( "hmac" , alg ) ; //<S2SV> err = PTR_ERR ( inst ) ; //<S2SV> if ( IS_ERR ( inst ) ) //<S2SV> goto out_put_alg ; //<S2SV> err = crypto_init_shash_spawn ( shash_instance_ctx ( inst ) , salg , //<S2SV> shash_crypto_instance ( inst ) ) ; //<S2SV> if ( err ) //<S2SV> goto out_free_inst ; //<S2SV> inst -> alg . base . cra_priority = alg -> cra_priority ; //<S2SV> inst -> alg . base . cra_blocksize = alg -> cra_blocksize ; //<S2SV> inst -> alg . base . cra_alignmask = alg -> cra_alignmask ; //<S2SV> ss = ALIGN ( ss , alg -> cra_alignmask + 1 ) ; //<S2SV> inst -> alg . digestsize = ds ; //<S2SV> inst -> alg . statesize = ss ; //<S2SV> inst -> alg . base . cra_ctxsize = sizeof ( struct hmac_ctx ) + //<S2SV> ALIGN ( ss * 2 , crypto_tfm_ctx_alignment ( ) ) ; //<S2SV> inst -> alg . base . cra_init = hmac_init_tfm ; //<S2SV> inst -> alg . base . cra_exit = hmac_exit_tfm ; //<S2SV> inst -> alg . init = hmac_init ; //<S2SV> inst -> alg . update = hmac_update ; //<S2SV> inst -> alg . final = hmac_final ; //<S2SV> inst -> alg . finup = hmac_finup ; //<S2SV> inst -> alg . export = hmac_export ; //<S2SV> inst -> alg . import = hmac_import ; //<S2SV> inst -> alg . setkey = hmac_setkey ; //<S2SV> err = shash_register_instance ( tmpl , inst ) ; //<S2SV> if ( err ) { //<S2SV> out_free_inst : //<S2SV> shash_free_instance ( shash_crypto_instance ( inst ) ) ; //<S2SV> } //<S2SV> out_put_alg : //<S2SV> crypto_mod_put ( alg ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 