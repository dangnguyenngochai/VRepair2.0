int sock_getsockopt ( struct socket * sock , int level , int optname , //<S2SV> char __user * optval , int __user * optlen ) //<S2SV> { //<S2SV> struct sock * sk = sock -> sk ; //<S2SV> union { //<S2SV> int val ; //<S2SV> struct linger ling ; //<S2SV> struct timeval tm ; //<S2SV> } v ; //<S2SV> int lv = sizeof ( int ) ; //<S2SV> int len ; //<S2SV> if ( get_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> if ( len < 0 ) //<S2SV> return - EINVAL ; //<S2SV> memset ( & v , 0 , sizeof ( v ) ) ; //<S2SV> switch ( optname ) { //<S2SV> case SO_DEBUG : //<S2SV> v . val = sock_flag ( sk , SOCK_DBG ) ; //<S2SV> break ; //<S2SV> case SO_DONTROUTE : //<S2SV> v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; //<S2SV> break ; //<S2SV> case SO_BROADCAST : //<S2SV> v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; //<S2SV> break ; //<S2SV> case SO_SNDBUF : //<S2SV> v . val = sk -> sk_sndbuf ; //<S2SV> break ; //<S2SV> case SO_RCVBUF : //<S2SV> v . val = sk -> sk_rcvbuf ; //<S2SV> break ; //<S2SV> case SO_REUSEADDR : //<S2SV> v . val = sk -> sk_reuse ; //<S2SV> break ; //<S2SV> case SO_KEEPALIVE : //<S2SV> v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; //<S2SV> break ; //<S2SV> case SO_TYPE : //<S2SV> v . val = sk -> sk_type ; //<S2SV> break ; //<S2SV> case SO_PROTOCOL : //<S2SV> v . val = sk -> sk_protocol ; //<S2SV> break ; //<S2SV> case SO_DOMAIN : //<S2SV> v . val = sk -> sk_family ; //<S2SV> break ; //<S2SV> case SO_ERROR : //<S2SV> v . val = - sock_error ( sk ) ; //<S2SV> if ( v . val == 0 ) //<S2SV> v . val = xchg ( & sk -> sk_err_soft , 0 ) ; //<S2SV> break ; //<S2SV> case SO_OOBINLINE : //<S2SV> v . val = ! ! sock_flag ( sk , SOCK_URGINLINE ) ; //<S2SV> break ; //<S2SV> case SO_NO_CHECK : //<S2SV> v . val = sk -> sk_no_check ; //<S2SV> break ; //<S2SV> case SO_PRIORITY : //<S2SV> v . val = sk -> sk_priority ; //<S2SV> break ; //<S2SV> case SO_LINGER : //<S2SV> lv = sizeof ( v . ling ) ; //<S2SV> v . ling . l_onoff = ! ! sock_flag ( sk , SOCK_LINGER ) ; //<S2SV> v . ling . l_linger = sk -> sk_lingertime / HZ ; //<S2SV> break ; //<S2SV> case SO_BSDCOMPAT : //<S2SV> sock_warn_obsolete_bsdism ( "getsockopt" ) ; //<S2SV> break ; //<S2SV> case SO_TIMESTAMP : //<S2SV> v . val = sock_flag ( sk , SOCK_RCVTSTAMP ) && //<S2SV> ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; //<S2SV> break ; //<S2SV> case SO_TIMESTAMPNS : //<S2SV> v . val = sock_flag ( sk , SOCK_RCVTSTAMPNS ) ; //<S2SV> break ; //<S2SV> case SO_TIMESTAMPING : //<S2SV> v . val = 0 ; //<S2SV> if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE ) ) //<S2SV> v . val |= SOF_TIMESTAMPING_TX_HARDWARE ; //<S2SV> if ( sock_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE ) ) //<S2SV> v . val |= SOF_TIMESTAMPING_TX_SOFTWARE ; //<S2SV> if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE ) ) //<S2SV> v . val |= SOF_TIMESTAMPING_RX_HARDWARE ; //<S2SV> if ( sock_flag ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ) //<S2SV> v . val |= SOF_TIMESTAMPING_RX_SOFTWARE ; //<S2SV> if ( sock_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE ) ) //<S2SV> v . val |= SOF_TIMESTAMPING_SOFTWARE ; //<S2SV> if ( sock_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE ) ) //<S2SV> v . val |= SOF_TIMESTAMPING_SYS_HARDWARE ; //<S2SV> if ( sock_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE ) ) //<S2SV> v . val |= SOF_TIMESTAMPING_RAW_HARDWARE ; //<S2SV> break ; //<S2SV> case SO_RCVTIMEO : //<S2SV> lv = sizeof ( struct timeval ) ; //<S2SV> if ( sk -> sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT ) { //<S2SV> v . tm . tv_sec = 0 ; //<S2SV> v . tm . tv_usec = 0 ; //<S2SV> } else { //<S2SV> v . tm . tv_sec = sk -> sk_rcvtimeo / HZ ; //<S2SV> v . tm . tv_usec = ( ( sk -> sk_rcvtimeo % HZ ) * 1000000 ) / HZ ; //<S2SV> } //<S2SV> break ; //<S2SV> case SO_SNDTIMEO : //<S2SV> lv = sizeof ( struct timeval ) ; //<S2SV> if ( sk -> sk_sndtimeo == MAX_SCHEDULE_TIMEOUT ) { //<S2SV> v . tm . tv_sec = 0 ; //<S2SV> v . tm . tv_usec = 0 ; //<S2SV> } else { //<S2SV> v . tm . tv_sec = sk -> sk_sndtimeo / HZ ; //<S2SV> v . tm . tv_usec = ( ( sk -> sk_sndtimeo % HZ ) * 1000000 ) / HZ ; //<S2SV> } //<S2SV> break ; //<S2SV> case SO_RCVLOWAT : //<S2SV> v . val = sk -> sk_rcvlowat ; //<S2SV> break ; //<S2SV> case SO_SNDLOWAT : //<S2SV> v . val = 1 ; //<S2SV> break ; //<S2SV> case SO_PASSCRED : //<S2SV> v . val = test_bit ( SOCK_PASSCRED , & sock -> flags ) ? 1 : 0 ; //<S2SV> break ; //<S2SV> case SO_PEERCRED : //<S2SV> { //<S2SV> struct ucred peercred ; //<S2SV> if ( len > sizeof ( peercred ) ) //<S2SV> len = sizeof ( peercred ) ; //<S2SV> cred_to_ucred ( sk -> sk_peer_pid , sk -> sk_peer_cred , & peercred ) ; //<S2SV> if ( copy_to_user ( optval , & peercred , len ) ) //<S2SV> return - EFAULT ; //<S2SV> goto lenout ; //<S2SV> } //<S2SV> case SO_PEERNAME : //<S2SV> { //<S2SV> char address [ 128 ] ; //<S2SV> if ( sock -> ops -> getname ( sock , ( struct sockaddr * ) address , & lv , 2 ) ) //<S2SV> return - ENOTCONN ; //<S2SV> if ( lv < len ) //<S2SV> return - EINVAL ; //<S2SV> if ( copy_to_user ( optval , address , len ) ) //<S2SV> return - EFAULT ; //<S2SV> goto lenout ; //<S2SV> } //<S2SV> case SO_ACCEPTCONN : //<S2SV> v . val = sk -> sk_state == TCP_LISTEN ; //<S2SV> break ; //<S2SV> case SO_PASSSEC : //<S2SV> v . val = test_bit ( SOCK_PASSSEC , & sock -> flags ) ? 1 : 0 ; //<S2SV> break ; //<S2SV> case SO_PEERSEC : //<S2SV> return security_socket_getpeersec_stream ( sock , optval , optlen , len ) ; //<S2SV> case SO_MARK : //<S2SV> v . val = sk -> sk_mark ; //<S2SV> break ; //<S2SV> case SO_RXQ_OVFL : //<S2SV> v . val = ! ! sock_flag ( sk , SOCK_RXQ_OVFL ) ; //<S2SV> break ; //<S2SV> case SO_WIFI_STATUS : //<S2SV> v . val = ! ! sock_flag ( sk , SOCK_WIFI_STATUS ) ; //<S2SV> break ; //<S2SV> case SO_PEEK_OFF : //<S2SV> if ( ! sock -> ops -> set_peek_off ) //<S2SV> return - EOPNOTSUPP ; //<S2SV> v . val = sk -> sk_peek_off ; //<S2SV> break ; //<S2SV> case SO_NOFCS : //<S2SV> v . val = ! ! sock_flag ( sk , SOCK_NOFCS ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> return - ENOPROTOOPT ; //<S2SV> } //<S2SV> if ( len > lv ) //<S2SV> len = lv ; //<S2SV> if ( copy_to_user ( optval , & v , len ) ) //<S2SV> return - EFAULT ; //<S2SV> lenout : //<S2SV> if ( put_user ( len , optlen ) ) //<S2SV> return - EFAULT ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 