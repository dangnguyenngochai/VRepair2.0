static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) //<S2SV> { //<S2SV> struct f2fs_nm_info * nm_i = NM_I ( sbi ) ; //<S2SV> struct free_nid * i , * e ; //<S2SV> struct nat_entry * ne ; //<S2SV> int err = - EINVAL ; //<S2SV> bool ret = false ; //<S2SV> if ( unlikely ( nid == 0 ) ) //<S2SV> return false ; //<S2SV> i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; //<S2SV> i -> nid = nid ; //<S2SV> i -> state = NID_NEW ; //<S2SV> if ( radix_tree_preload ( GFP_NOFS ) ) //<S2SV> goto err ; //<S2SV> spin_lock ( & nm_i -> nid_list_lock ) ; //<S2SV> if ( build ) { //<S2SV> ne = __lookup_nat_cache ( nm_i , nid ) ; //<S2SV> if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || //<S2SV> nat_get_blkaddr ( ne ) != NULL_ADDR ) ) //<S2SV> goto err_out ; //<S2SV> e = __lookup_free_nid_list ( nm_i , nid ) ; //<S2SV> if ( e ) { //<S2SV> if ( e -> state == NID_NEW ) //<S2SV> ret = true ; //<S2SV> goto err_out ; //<S2SV> } //<S2SV> } //<S2SV> ret = true ; //<S2SV> err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; //<S2SV> err_out : //<S2SV> spin_unlock ( & nm_i -> nid_list_lock ) ; //<S2SV> radix_tree_preload_end ( ) ; //<S2SV> err : //<S2SV> if ( err ) //<S2SV> kmem_cache_free ( free_nid_slab , i ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 