static int snd_timer_user_tselect ( struct file * file , //<S2SV> struct snd_timer_select __user * _tselect ) //<S2SV> { //<S2SV> struct snd_timer_user * tu ; //<S2SV> struct snd_timer_select tselect ; //<S2SV> char str [ 32 ] ; //<S2SV> int err = 0 ; //<S2SV> tu = file -> private_data ; //<S2SV> if ( tu -> timeri ) { //<S2SV> snd_timer_close ( tu -> timeri ) ; //<S2SV> tu -> timeri = NULL ; //<S2SV> } //<S2SV> if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { //<S2SV> err = - EFAULT ; //<S2SV> goto __err ; //<S2SV> } //<S2SV> sprintf ( str , "application<S2SV_blank>%i" , current -> pid ) ; //<S2SV> if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) //<S2SV> tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; //<S2SV> err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; //<S2SV> if ( err < 0 ) //<S2SV> goto __err ; //<S2SV> kfree ( tu -> queue ) ; //<S2SV> tu -> queue = NULL ; //<S2SV> kfree ( tu -> tqueue ) ; //<S2SV> tu -> tqueue = NULL ; //<S2SV> if ( tu -> tread ) { //<S2SV> tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( tu -> tqueue == NULL ) //<S2SV> err = - ENOMEM ; //<S2SV> } else { //<S2SV> tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , //<S2SV> GFP_KERNEL ) ; //<S2SV> if ( tu -> queue == NULL ) //<S2SV> err = - ENOMEM ; //<S2SV> } //<S2SV> if ( err < 0 ) { //<S2SV> snd_timer_close ( tu -> timeri ) ; //<S2SV> tu -> timeri = NULL ; //<S2SV> } else { //<S2SV> tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; //<S2SV> tu -> timeri -> callback = tu -> tread //<S2SV> ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; //<S2SV> tu -> timeri -> ccallback = snd_timer_user_ccallback ; //<S2SV> tu -> timeri -> callback_data = ( void * ) tu ; //<S2SV> } //<S2SV> __err : //<S2SV> return err ; //<S2SV> } //<S2SV> 