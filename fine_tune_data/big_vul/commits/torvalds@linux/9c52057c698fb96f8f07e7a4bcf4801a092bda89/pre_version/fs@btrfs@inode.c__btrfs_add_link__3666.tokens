int btrfs_add_link ( struct btrfs_trans_handle * trans , //<S2SV> struct inode * parent_inode , struct inode * inode , //<S2SV> const char * name , int name_len , int add_backref , u64 index ) //<S2SV> { //<S2SV> int ret = 0 ; //<S2SV> struct btrfs_key key ; //<S2SV> struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; //<S2SV> u64 ino = btrfs_ino ( inode ) ; //<S2SV> u64 parent_ino = btrfs_ino ( parent_inode ) ; //<S2SV> if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { //<S2SV> memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; //<S2SV> } else { //<S2SV> key . objectid = ino ; //<S2SV> btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; //<S2SV> key . offset = 0 ; //<S2SV> } //<S2SV> if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { //<S2SV> ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , //<S2SV> key . objectid , root -> root_key . objectid , //<S2SV> parent_ino , index , name , name_len ) ; //<S2SV> } else if ( add_backref ) { //<S2SV> ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , //<S2SV> parent_ino , index ) ; //<S2SV> } //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> ret = btrfs_insert_dir_item ( trans , root , name , name_len , //<S2SV> parent_inode , & key , //<S2SV> btrfs_inode_type ( inode ) , index ) ; //<S2SV> if ( ret == - EEXIST ) //<S2SV> goto fail_dir_item ; //<S2SV> else if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> btrfs_i_size_write ( parent_inode , parent_inode -> i_size + //<S2SV> name_len * 2 ) ; //<S2SV> inode_inc_iversion ( parent_inode ) ; //<S2SV> parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; //<S2SV> ret = btrfs_update_inode ( trans , root , parent_inode ) ; //<S2SV> if ( ret ) //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> return ret ; //<S2SV> fail_dir_item : //<S2SV> if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { //<S2SV> u64 local_index ; //<S2SV> int err ; //<S2SV> err = btrfs_del_root_ref ( trans , root -> fs_info -> tree_root , //<S2SV> key . objectid , root -> root_key . objectid , //<S2SV> parent_ino , & local_index , name , name_len ) ; //<S2SV> } else if ( add_backref ) { //<S2SV> u64 local_index ; //<S2SV> int err ; //<S2SV> err = btrfs_del_inode_ref ( trans , root , name , name_len , //<S2SV> ino , parent_ino , & local_index ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 