static noinline int create_pending_snapshot ( struct btrfs_trans_handle * trans , //<S2SV> struct btrfs_fs_info * fs_info , //<S2SV> struct btrfs_pending_snapshot * pending ) //<S2SV> { //<S2SV> struct btrfs_key key ; //<S2SV> struct btrfs_root_item * new_root_item ; //<S2SV> struct btrfs_root * tree_root = fs_info -> tree_root ; //<S2SV> struct btrfs_root * root = pending -> root ; //<S2SV> struct btrfs_root * parent_root ; //<S2SV> struct btrfs_block_rsv * rsv ; //<S2SV> struct inode * parent_inode ; //<S2SV> struct btrfs_path * path ; //<S2SV> struct btrfs_dir_item * dir_item ; //<S2SV> struct dentry * parent ; //<S2SV> struct dentry * dentry ; //<S2SV> struct extent_buffer * tmp ; //<S2SV> struct extent_buffer * old ; //<S2SV> struct timespec cur_time = CURRENT_TIME ; //<S2SV> int ret ; //<S2SV> u64 to_reserve = 0 ; //<S2SV> u64 index = 0 ; //<S2SV> u64 objectid ; //<S2SV> u64 root_flags ; //<S2SV> uuid_le new_uuid ; //<S2SV> path = btrfs_alloc_path ( ) ; //<S2SV> if ( ! path ) { //<S2SV> ret = pending -> error = - ENOMEM ; //<S2SV> goto path_alloc_fail ; //<S2SV> } //<S2SV> new_root_item = kmalloc ( sizeof ( * new_root_item ) , GFP_NOFS ) ; //<S2SV> if ( ! new_root_item ) { //<S2SV> ret = pending -> error = - ENOMEM ; //<S2SV> goto root_item_alloc_fail ; //<S2SV> } //<S2SV> ret = btrfs_find_free_objectid ( tree_root , & objectid ) ; //<S2SV> if ( ret ) { //<S2SV> pending -> error = ret ; //<S2SV> goto no_free_objectid ; //<S2SV> } //<S2SV> btrfs_reloc_pre_snapshot ( trans , pending , & to_reserve ) ; //<S2SV> if ( to_reserve > 0 ) { //<S2SV> ret = btrfs_block_rsv_add ( root , & pending -> block_rsv , //<S2SV> to_reserve , //<S2SV> BTRFS_RESERVE_NO_FLUSH ) ; //<S2SV> if ( ret ) { //<S2SV> pending -> error = ret ; //<S2SV> goto no_free_objectid ; //<S2SV> } //<S2SV> } //<S2SV> ret = btrfs_qgroup_inherit ( trans , fs_info , root -> root_key . objectid , //<S2SV> objectid , pending -> inherit ) ; //<S2SV> if ( ret ) { //<S2SV> pending -> error = ret ; //<S2SV> goto no_free_objectid ; //<S2SV> } //<S2SV> key . objectid = objectid ; //<S2SV> key . offset = ( u64 ) - 1 ; //<S2SV> key . type = BTRFS_ROOT_ITEM_KEY ; //<S2SV> rsv = trans -> block_rsv ; //<S2SV> trans -> block_rsv = & pending -> block_rsv ; //<S2SV> dentry = pending -> dentry ; //<S2SV> parent = dget_parent ( dentry ) ; //<S2SV> parent_inode = parent -> d_inode ; //<S2SV> parent_root = BTRFS_I ( parent_inode ) -> root ; //<S2SV> record_root_in_trans ( trans , parent_root ) ; //<S2SV> ret = btrfs_set_inode_index ( parent_inode , & index ) ; //<S2SV> BUG_ON ( ret ) ; //<S2SV> dir_item = btrfs_lookup_dir_item ( NULL , parent_root , path , //<S2SV> btrfs_ino ( parent_inode ) , //<S2SV> dentry -> d_name . name , //<S2SV> dentry -> d_name . len , 0 ) ; //<S2SV> if ( dir_item != NULL && ! IS_ERR ( dir_item ) ) { //<S2SV> pending -> error = - EEXIST ; //<S2SV> goto fail ; //<S2SV> } else if ( IS_ERR ( dir_item ) ) { //<S2SV> ret = PTR_ERR ( dir_item ) ; //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> btrfs_release_path ( path ) ; //<S2SV> ret = btrfs_run_delayed_items ( trans , root ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> record_root_in_trans ( trans , root ) ; //<S2SV> btrfs_set_root_last_snapshot ( & root -> root_item , trans -> transid ) ; //<S2SV> memcpy ( new_root_item , & root -> root_item , sizeof ( * new_root_item ) ) ; //<S2SV> btrfs_check_and_init_root_item ( new_root_item ) ; //<S2SV> root_flags = btrfs_root_flags ( new_root_item ) ; //<S2SV> if ( pending -> readonly ) //<S2SV> root_flags |= BTRFS_ROOT_SUBVOL_RDONLY ; //<S2SV> else //<S2SV> root_flags &= ~ BTRFS_ROOT_SUBVOL_RDONLY ; //<S2SV> btrfs_set_root_flags ( new_root_item , root_flags ) ; //<S2SV> btrfs_set_root_generation_v2 ( new_root_item , //<S2SV> trans -> transid ) ; //<S2SV> uuid_le_gen ( & new_uuid ) ; //<S2SV> memcpy ( new_root_item -> uuid , new_uuid . b , BTRFS_UUID_SIZE ) ; //<S2SV> memcpy ( new_root_item -> parent_uuid , root -> root_item . uuid , //<S2SV> BTRFS_UUID_SIZE ) ; //<S2SV> new_root_item -> otime . sec = cpu_to_le64 ( cur_time . tv_sec ) ; //<S2SV> new_root_item -> otime . nsec = cpu_to_le32 ( cur_time . tv_nsec ) ; //<S2SV> btrfs_set_root_otransid ( new_root_item , trans -> transid ) ; //<S2SV> memset ( & new_root_item -> stime , 0 , sizeof ( new_root_item -> stime ) ) ; //<S2SV> memset ( & new_root_item -> rtime , 0 , sizeof ( new_root_item -> rtime ) ) ; //<S2SV> btrfs_set_root_stransid ( new_root_item , 0 ) ; //<S2SV> btrfs_set_root_rtransid ( new_root_item , 0 ) ; //<S2SV> old = btrfs_lock_root_node ( root ) ; //<S2SV> ret = btrfs_cow_block ( trans , root , old , NULL , 0 , & old ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_tree_unlock ( old ) ; //<S2SV> free_extent_buffer ( old ) ; //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> btrfs_set_lock_blocking ( old ) ; //<S2SV> ret = btrfs_copy_root ( trans , root , old , & tmp , objectid ) ; //<S2SV> btrfs_tree_unlock ( old ) ; //<S2SV> free_extent_buffer ( old ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> root -> force_cow = 1 ; //<S2SV> smp_wmb ( ) ; //<S2SV> btrfs_set_root_node ( new_root_item , tmp ) ; //<S2SV> key . offset = trans -> transid ; //<S2SV> ret = btrfs_insert_root ( trans , tree_root , & key , new_root_item ) ; //<S2SV> btrfs_tree_unlock ( tmp ) ; //<S2SV> free_extent_buffer ( tmp ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> ret = btrfs_add_root_ref ( trans , tree_root , objectid , //<S2SV> parent_root -> root_key . objectid , //<S2SV> btrfs_ino ( parent_inode ) , index , //<S2SV> dentry -> d_name . name , dentry -> d_name . len ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> key . offset = ( u64 ) - 1 ; //<S2SV> pending -> snap = btrfs_read_fs_root_no_name ( root -> fs_info , & key ) ; //<S2SV> if ( IS_ERR ( pending -> snap ) ) { //<S2SV> ret = PTR_ERR ( pending -> snap ) ; //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> ret = btrfs_reloc_post_snapshot ( trans , pending ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> ret = btrfs_run_delayed_refs ( trans , root , ( unsigned long ) - 1 ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> ret = btrfs_insert_dir_item ( trans , parent_root , //<S2SV> dentry -> d_name . name , dentry -> d_name . len , //<S2SV> parent_inode , & key , //<S2SV> BTRFS_FT_DIR , index ) ; //<S2SV> BUG_ON ( ret == - EEXIST || ret == - EOVERFLOW ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> btrfs_i_size_write ( parent_inode , parent_inode -> i_size + //<S2SV> dentry -> d_name . len * 2 ) ; //<S2SV> parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; //<S2SV> ret = btrfs_update_inode_fallback ( trans , parent_root , parent_inode ) ; //<S2SV> if ( ret ) //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> fail : //<S2SV> dput ( parent ) ; //<S2SV> trans -> block_rsv = rsv ; //<S2SV> no_free_objectid : //<S2SV> kfree ( new_root_item ) ; //<S2SV> root_item_alloc_fail : //<S2SV> btrfs_free_path ( path ) ; //<S2SV> path_alloc_fail : //<S2SV> btrfs_block_rsv_release ( root , & pending -> block_rsv , ( u64 ) - 1 ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 