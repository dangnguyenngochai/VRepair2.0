static int btrfs_rename ( struct inode * old_dir , struct dentry * old_dentry , //<S2SV> struct inode * new_dir , struct dentry * new_dentry ) //<S2SV> { //<S2SV> struct btrfs_trans_handle * trans ; //<S2SV> struct btrfs_root * root = BTRFS_I ( old_dir ) -> root ; //<S2SV> struct btrfs_root * dest = BTRFS_I ( new_dir ) -> root ; //<S2SV> struct inode * new_inode = new_dentry -> d_inode ; //<S2SV> struct inode * old_inode = old_dentry -> d_inode ; //<S2SV> struct timespec ctime = CURRENT_TIME ; //<S2SV> u64 index = 0 ; //<S2SV> u64 root_objectid ; //<S2SV> int ret ; //<S2SV> u64 old_ino = btrfs_ino ( old_inode ) ; //<S2SV> if ( btrfs_ino ( new_dir ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) //<S2SV> return - EPERM ; //<S2SV> if ( old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest ) //<S2SV> return - EXDEV ; //<S2SV> if ( old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID || //<S2SV> ( new_inode && btrfs_ino ( new_inode ) == BTRFS_FIRST_FREE_OBJECTID ) ) //<S2SV> return - ENOTEMPTY ; //<S2SV> if ( S_ISDIR ( old_inode -> i_mode ) && new_inode && //<S2SV> new_inode -> i_size > BTRFS_EMPTY_DIR_SIZE ) //<S2SV> return - ENOTEMPTY ; //<S2SV> ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , //<S2SV> new_dentry -> d_name . name , //<S2SV> new_dentry -> d_name . len ) ; //<S2SV> if ( ret ) { //<S2SV> if ( ret == - EEXIST ) { //<S2SV> if ( ! new_inode ) { //<S2SV> WARN_ON ( 1 ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> } else { //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> ret = 0 ; //<S2SV> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && //<S2SV> old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) //<S2SV> filemap_flush ( old_inode -> i_mapping ) ; //<S2SV> if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) //<S2SV> down_read ( & root -> fs_info -> subvol_sem ) ; //<S2SV> trans = btrfs_start_transaction ( root , 20 ) ; //<S2SV> if ( IS_ERR ( trans ) ) { //<S2SV> ret = PTR_ERR ( trans ) ; //<S2SV> goto out_notrans ; //<S2SV> } //<S2SV> if ( dest != root ) //<S2SV> btrfs_record_root_in_trans ( trans , dest ) ; //<S2SV> ret = btrfs_set_inode_index ( new_dir , & index ) ; //<S2SV> if ( ret ) //<S2SV> goto out_fail ; //<S2SV> if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { //<S2SV> root -> fs_info -> last_trans_log_full_commit = trans -> transid ; //<S2SV> } else { //<S2SV> ret = btrfs_insert_inode_ref ( trans , dest , //<S2SV> new_dentry -> d_name . name , //<S2SV> new_dentry -> d_name . len , //<S2SV> old_ino , //<S2SV> btrfs_ino ( new_dir ) , index ) ; //<S2SV> if ( ret ) //<S2SV> goto out_fail ; //<S2SV> btrfs_pin_log_trans ( root ) ; //<S2SV> } //<S2SV> if ( new_inode && new_inode -> i_size && S_ISREG ( old_inode -> i_mode ) ) //<S2SV> btrfs_add_ordered_operation ( trans , root , old_inode ) ; //<S2SV> inode_inc_iversion ( old_dir ) ; //<S2SV> inode_inc_iversion ( new_dir ) ; //<S2SV> inode_inc_iversion ( old_inode ) ; //<S2SV> old_dir -> i_ctime = old_dir -> i_mtime = ctime ; //<S2SV> new_dir -> i_ctime = new_dir -> i_mtime = ctime ; //<S2SV> old_inode -> i_ctime = ctime ; //<S2SV> if ( old_dentry -> d_parent != new_dentry -> d_parent ) //<S2SV> btrfs_record_unlink_dir ( trans , old_dir , old_inode , 1 ) ; //<S2SV> if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { //<S2SV> root_objectid = BTRFS_I ( old_inode ) -> root -> root_key . objectid ; //<S2SV> ret = btrfs_unlink_subvol ( trans , root , old_dir , root_objectid , //<S2SV> old_dentry -> d_name . name , //<S2SV> old_dentry -> d_name . len ) ; //<S2SV> } else { //<S2SV> ret = __btrfs_unlink_inode ( trans , root , old_dir , //<S2SV> old_dentry -> d_inode , //<S2SV> old_dentry -> d_name . name , //<S2SV> old_dentry -> d_name . len ) ; //<S2SV> if ( ! ret ) //<S2SV> ret = btrfs_update_inode ( trans , root , old_inode ) ; //<S2SV> } //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto out_fail ; //<S2SV> } //<S2SV> if ( new_inode ) { //<S2SV> inode_inc_iversion ( new_inode ) ; //<S2SV> new_inode -> i_ctime = CURRENT_TIME ; //<S2SV> if ( unlikely ( btrfs_ino ( new_inode ) == //<S2SV> BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) ) { //<S2SV> root_objectid = BTRFS_I ( new_inode ) -> location . objectid ; //<S2SV> ret = btrfs_unlink_subvol ( trans , dest , new_dir , //<S2SV> root_objectid , //<S2SV> new_dentry -> d_name . name , //<S2SV> new_dentry -> d_name . len ) ; //<S2SV> BUG_ON ( new_inode -> i_nlink == 0 ) ; //<S2SV> } else { //<S2SV> ret = btrfs_unlink_inode ( trans , dest , new_dir , //<S2SV> new_dentry -> d_inode , //<S2SV> new_dentry -> d_name . name , //<S2SV> new_dentry -> d_name . len ) ; //<S2SV> } //<S2SV> if ( ! ret && new_inode -> i_nlink == 0 ) { //<S2SV> ret = btrfs_orphan_add ( trans , new_dentry -> d_inode ) ; //<S2SV> BUG_ON ( ret ) ; //<S2SV> } //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto out_fail ; //<S2SV> } //<S2SV> } //<S2SV> fixup_inode_flags ( new_dir , old_inode ) ; //<S2SV> ret = btrfs_add_link ( trans , new_dir , old_inode , //<S2SV> new_dentry -> d_name . name , //<S2SV> new_dentry -> d_name . len , 0 , index ) ; //<S2SV> if ( ret ) { //<S2SV> btrfs_abort_transaction ( trans , root , ret ) ; //<S2SV> goto out_fail ; //<S2SV> } //<S2SV> if ( old_ino != BTRFS_FIRST_FREE_OBJECTID ) { //<S2SV> struct dentry * parent = new_dentry -> d_parent ; //<S2SV> btrfs_log_new_name ( trans , old_inode , old_dir , parent ) ; //<S2SV> btrfs_end_log_trans ( root ) ; //<S2SV> } //<S2SV> out_fail : //<S2SV> btrfs_end_transaction ( trans , root ) ; //<S2SV> out_notrans : //<S2SV> if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) //<S2SV> up_read ( & root -> fs_info -> subvol_sem ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 