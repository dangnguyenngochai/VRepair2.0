static noinline int btrfs_mksubvol ( struct path * parent , //<S2SV> char * name , int namelen , //<S2SV> struct btrfs_root * snap_src , //<S2SV> u64 * async_transid , bool readonly , //<S2SV> struct btrfs_qgroup_inherit * * inherit ) //<S2SV> { //<S2SV> struct inode * dir = parent -> dentry -> d_inode ; //<S2SV> struct dentry * dentry ; //<S2SV> int error ; //<S2SV> mutex_lock_nested ( & dir -> i_mutex , I_MUTEX_PARENT ) ; //<S2SV> dentry = lookup_one_len ( name , parent -> dentry , namelen ) ; //<S2SV> error = PTR_ERR ( dentry ) ; //<S2SV> if ( IS_ERR ( dentry ) ) //<S2SV> goto out_unlock ; //<S2SV> error = - EEXIST ; //<S2SV> if ( dentry -> d_inode ) //<S2SV> goto out_dput ; //<S2SV> error = btrfs_may_create ( dir , dentry ) ; //<S2SV> if ( error ) //<S2SV> goto out_dput ; //<S2SV> error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , //<S2SV> dir -> i_ino , name , //<S2SV> namelen ) ; //<S2SV> if ( error ) //<S2SV> goto out_dput ; //<S2SV> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; //<S2SV> if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) //<S2SV> goto out_up_read ; //<S2SV> if ( snap_src ) { //<S2SV> error = create_snapshot ( snap_src , dentry , name , namelen , //<S2SV> async_transid , readonly , inherit ) ; //<S2SV> } else { //<S2SV> error = create_subvol ( BTRFS_I ( dir ) -> root , dentry , //<S2SV> name , namelen , async_transid , inherit ) ; //<S2SV> } //<S2SV> if ( ! error ) //<S2SV> fsnotify_mkdir ( dir , dentry ) ; //<S2SV> out_up_read : //<S2SV> up_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; //<S2SV> out_dput : //<S2SV> dput ( dentry ) ; //<S2SV> out_unlock : //<S2SV> mutex_unlock ( & dir -> i_mutex ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> 