static int set_geometry ( unsigned int cmd , struct floppy_struct * g , //<S2SV> int drive , int type , struct block_device * bdev ) //<S2SV> { //<S2SV> int cnt ; //<S2SV> if ( g -> sect <= 0 || //<S2SV> g -> head <= 0 || //<S2SV> ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) == 0 || //<S2SV> g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || //<S2SV> ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) //<S2SV> return - EINVAL ; //<S2SV> if ( type ) { //<S2SV> if ( ! capable ( CAP_SYS_ADMIN ) ) //<S2SV> return - EPERM ; //<S2SV> mutex_lock ( & open_lock ) ; //<S2SV> if ( lock_fdc ( drive ) ) { //<S2SV> mutex_unlock ( & open_lock ) ; //<S2SV> return - EINTR ; //<S2SV> } //<S2SV> floppy_type [ type ] = * g ; //<S2SV> floppy_type [ type ] . name = "user<S2SV_blank>format" ; //<S2SV> for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) //<S2SV> floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = //<S2SV> floppy_type [ type ] . size + 1 ; //<S2SV> process_fd_request ( ) ; //<S2SV> for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { //<S2SV> struct block_device * bdev = opened_bdev [ cnt ] ; //<S2SV> if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) //<S2SV> continue ; //<S2SV> __invalidate_device ( bdev , true ) ; //<S2SV> } //<S2SV> mutex_unlock ( & open_lock ) ; //<S2SV> } else { //<S2SV> int oldStretch ; //<S2SV> if ( lock_fdc ( drive ) ) //<S2SV> return - EINTR ; //<S2SV> if ( cmd != FDDEFPRM ) { //<S2SV> if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) //<S2SV> return - EINTR ; //<S2SV> } //<S2SV> oldStretch = g -> stretch ; //<S2SV> user_params [ drive ] = * g ; //<S2SV> if ( buffer_drive == drive ) //<S2SV> SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; //<S2SV> current_type [ drive ] = & user_params [ drive ] ; //<S2SV> floppy_sizes [ drive ] = user_params [ drive ] . size ; //<S2SV> if ( cmd == FDDEFPRM ) //<S2SV> DRS -> keep_data = - 1 ; //<S2SV> else //<S2SV> DRS -> keep_data = 1 ; //<S2SV> if ( DRS -> maxblock > user_params [ drive ] . sect || //<S2SV> DRS -> maxtrack || //<S2SV> ( ( user_params [ drive ] . sect ^ oldStretch ) & //<S2SV> ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) //<S2SV> invalidate_drive ( bdev ) ; //<S2SV> else //<S2SV> process_fd_request ( ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 