static ssize_t //<S2SV> pipe_read ( struct kiocb * iocb , const struct iovec * _iov , //<S2SV> unsigned long nr_segs , loff_t pos ) //<S2SV> { //<S2SV> struct file * filp = iocb -> ki_filp ; //<S2SV> struct pipe_inode_info * pipe = filp -> private_data ; //<S2SV> int do_wakeup ; //<S2SV> ssize_t ret ; //<S2SV> struct iovec * iov = ( struct iovec * ) _iov ; //<S2SV> size_t total_len ; //<S2SV> total_len = iov_length ( iov , nr_segs ) ; //<S2SV> if ( unlikely ( total_len == 0 ) ) //<S2SV> return 0 ; //<S2SV> do_wakeup = 0 ; //<S2SV> ret = 0 ; //<S2SV> __pipe_lock ( pipe ) ; //<S2SV> for ( ; ; ) { //<S2SV> int bufs = pipe -> nrbufs ; //<S2SV> if ( bufs ) { //<S2SV> int curbuf = pipe -> curbuf ; //<S2SV> struct pipe_buffer * buf = pipe -> bufs + curbuf ; //<S2SV> const struct pipe_buf_operations * ops = buf -> ops ; //<S2SV> void * addr ; //<S2SV> size_t chars = buf -> len ; //<S2SV> int error , atomic ; //<S2SV> if ( chars > total_len ) //<S2SV> chars = total_len ; //<S2SV> error = ops -> confirm ( pipe , buf ) ; //<S2SV> if ( error ) { //<S2SV> if ( ! ret ) //<S2SV> ret = error ; //<S2SV> break ; //<S2SV> } //<S2SV> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; //<S2SV> redo : //<S2SV> if ( atomic ) //<S2SV> addr = kmap_atomic ( buf -> page ) ; //<S2SV> else //<S2SV> addr = kmap ( buf -> page ) ; //<S2SV> error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; //<S2SV> if ( atomic ) //<S2SV> kunmap_atomic ( addr ) ; //<S2SV> else //<S2SV> kunmap ( buf -> page ) ; //<S2SV> if ( unlikely ( error ) ) { //<S2SV> if ( atomic ) { //<S2SV> atomic = 0 ; //<S2SV> goto redo ; //<S2SV> } //<S2SV> if ( ! ret ) //<S2SV> ret = error ; //<S2SV> break ; //<S2SV> } //<S2SV> ret += chars ; //<S2SV> buf -> offset += chars ; //<S2SV> buf -> len -= chars ; //<S2SV> if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { //<S2SV> total_len = chars ; //<S2SV> buf -> len = 0 ; //<S2SV> } //<S2SV> if ( ! buf -> len ) { //<S2SV> buf -> ops = NULL ; //<S2SV> ops -> release ( pipe , buf ) ; //<S2SV> curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 ) ; //<S2SV> pipe -> curbuf = curbuf ; //<S2SV> pipe -> nrbufs = -- bufs ; //<S2SV> do_wakeup = 1 ; //<S2SV> } //<S2SV> total_len -= chars ; //<S2SV> if ( ! total_len ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( bufs ) //<S2SV> continue ; //<S2SV> if ( ! pipe -> writers ) //<S2SV> break ; //<S2SV> if ( ! pipe -> waiting_writers ) { //<S2SV> if ( ret ) //<S2SV> break ; //<S2SV> if ( filp -> f_flags & O_NONBLOCK ) { //<S2SV> ret = - EAGAIN ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( signal_pending ( current ) ) { //<S2SV> if ( ! ret ) //<S2SV> ret = - ERESTARTSYS ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( do_wakeup ) { //<S2SV> wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; //<S2SV> kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; //<S2SV> } //<S2SV> pipe_wait ( pipe ) ; //<S2SV> } //<S2SV> __pipe_unlock ( pipe ) ; //<S2SV> if ( do_wakeup ) { //<S2SV> wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; //<S2SV> kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; //<S2SV> } //<S2SV> if ( ret > 0 ) //<S2SV> file_accessed ( filp ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 