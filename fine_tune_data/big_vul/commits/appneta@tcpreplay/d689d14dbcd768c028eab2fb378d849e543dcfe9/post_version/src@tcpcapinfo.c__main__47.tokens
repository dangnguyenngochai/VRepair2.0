int //<S2SV> main ( int argc , char * argv [ ] ) //<S2SV> { //<S2SV> int i , fd , swapped , pkthdrlen , ret , optct , backwards , caplentoobig ; //<S2SV> struct pcap_file_header pcap_fh ; //<S2SV> struct pcap_pkthdr pcap_ph ; //<S2SV> struct pcap_sf_patched_pkthdr pcap_patched_ph ; //<S2SV> char buf [ 10000 ] ; //<S2SV> struct stat statinfo ; //<S2SV> uint64_t pktcnt ; //<S2SV> uint32_t readword ; //<S2SV> int32_t last_sec , last_usec , caplen ; //<S2SV> optct = optionProcess ( & tcpcapinfoOptions , argc , argv ) ; //<S2SV> argc -= optct ; //<S2SV> argv += optct ; //<S2SV> # ifdef DEBUG //<S2SV> if ( HAVE_OPT ( DBUG ) ) //<S2SV> debug = OPT_VALUE_DBUG ; //<S2SV> # endif //<S2SV> for ( i = 0 ; i < argc ; i ++ ) { //<S2SV> dbgx ( 1 , "processing:<S2SV_blank><S2SV_blank>%s\\n" , argv [ i ] ) ; //<S2SV> if ( ( fd = open ( argv [ i ] , O_RDONLY ) ) < 0 ) //<S2SV> errx ( - 1 , "Error<S2SV_blank>opening<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s" , argv [ i ] , strerror ( errno ) ) ; //<S2SV> if ( fstat ( fd , & statinfo ) < 0 ) //<S2SV> errx ( - 1 , "Error<S2SV_blank>getting<S2SV_blank>file<S2SV_blank>stat<S2SV_blank>info<S2SV_blank>%s:<S2SV_blank>%s" , argv [ i ] , strerror ( errno ) ) ; //<S2SV> printf ( "file<S2SV_blank>size<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%" PRIu64 "<S2SV_blank>bytes\\n" , ( uint64_t ) statinfo . st_size ) ; //<S2SV> if ( ( ret = read ( fd , & buf , sizeof ( pcap_fh ) ) ) != sizeof ( pcap_fh ) ) //<S2SV> errx ( - 1 , "File<S2SV_blank>too<S2SV_blank>small.<S2SV_blank><S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>pcap_file_header<S2SV_blank>from<S2SV_blank>%s" , argv [ i ] ) ; //<S2SV> dbgx ( 3 , "Read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>file<S2SV_blank>header" , ret ) ; //<S2SV> swapped = 0 ; //<S2SV> memcpy ( & pcap_fh , & buf , sizeof ( pcap_fh ) ) ; //<S2SV> pkthdrlen = 16 ; //<S2SV> switch ( pcap_fh . magic ) { //<S2SV> case TCPDUMP_MAGIC : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(tcpdump)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_not_swapped ) ; //<S2SV> break ; //<S2SV> case SWAPLONG ( TCPDUMP_MAGIC ) : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(tcpdump/swapped)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_swapped ) ; //<S2SV> swapped = 1 ; //<S2SV> break ; //<S2SV> case KUZNETZOV_TCPDUMP_MAGIC : //<S2SV> pkthdrlen = sizeof ( pcap_patched_ph ) ; //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(Kuznetzov)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_not_swapped ) ; //<S2SV> break ; //<S2SV> case SWAPLONG ( KUZNETZOV_TCPDUMP_MAGIC ) : //<S2SV> pkthdrlen = sizeof ( pcap_patched_ph ) ; //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(Kuznetzov/swapped)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_swapped ) ; //<S2SV> swapped = 1 ; //<S2SV> break ; //<S2SV> case FMESQUITA_TCPDUMP_MAGIC : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(Fmesquita)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_not_swapped ) ; //<S2SV> break ; //<S2SV> case SWAPLONG ( FMESQUITA_TCPDUMP_MAGIC ) : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(Fmesquita)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_swapped ) ; //<S2SV> swapped = 1 ; //<S2SV> break ; //<S2SV> case NAVTEL_TCPDUMP_MAGIC : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(Navtel)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_not_swapped ) ; //<S2SV> break ; //<S2SV> case SWAPLONG ( NAVTEL_TCPDUMP_MAGIC ) : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(Navtel/swapped)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_swapped ) ; //<S2SV> swapped = 1 ; //<S2SV> break ; //<S2SV> case NSEC_TCPDUMP_MAGIC : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(Nsec)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_not_swapped ) ; //<S2SV> break ; //<S2SV> case SWAPLONG ( NSEC_TCPDUMP_MAGIC ) : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(Nsec/swapped)<S2SV_blank>(%s)\\n" , pcap_fh . magic , is_swapped ) ; //<S2SV> swapped = 1 ; //<S2SV> break ; //<S2SV> default : //<S2SV> printf ( "magic<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "<S2SV_blank>(unknown)\\n" , pcap_fh . magic ) ; //<S2SV> } //<S2SV> if ( swapped == 1 ) { //<S2SV> pcap_fh . version_major = SWAPSHORT ( pcap_fh . version_major ) ; //<S2SV> pcap_fh . version_minor = SWAPSHORT ( pcap_fh . version_minor ) ; //<S2SV> pcap_fh . thiszone = SWAPLONG ( pcap_fh . thiszone ) ; //<S2SV> pcap_fh . sigfigs = SWAPLONG ( pcap_fh . sigfigs ) ; //<S2SV> pcap_fh . snaplen = SWAPLONG ( pcap_fh . snaplen ) ; //<S2SV> pcap_fh . linktype = SWAPLONG ( pcap_fh . linktype ) ; //<S2SV> } //<S2SV> printf ( "version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%hu.%hu\\n" , pcap_fh . version_major , pcap_fh . version_minor ) ; //<S2SV> printf ( "thiszone<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "\\n" , pcap_fh . thiszone ) ; //<S2SV> printf ( "sigfigs<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "\\n" , pcap_fh . sigfigs ) ; //<S2SV> printf ( "snaplen<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%" PRIu32 "\\n" , pcap_fh . snaplen ) ; //<S2SV> printf ( "linktype<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>0x%08" PRIx32 "\\n" , pcap_fh . linktype ) ; //<S2SV> if ( pcap_fh . version_major != 2 && pcap_fh . version_minor != 4 ) { //<S2SV> printf ( "Sorry,<S2SV_blank>we<S2SV_blank>only<S2SV_blank>support<S2SV_blank>file<S2SV_blank>format<S2SV_blank>version<S2SV_blank>2.4\\n" ) ; //<S2SV> close ( fd ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> dbgx ( 5 , "Packet<S2SV_blank>header<S2SV_blank>len:<S2SV_blank>%d" , pkthdrlen ) ; //<S2SV> if ( pkthdrlen == 24 ) { //<S2SV> printf ( "Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\t\\tIndex\\tProto\\tPktType\\tPktCsum\\tNote\\n" ) ; //<S2SV> } else { //<S2SV> printf ( "Packet\\tOrigLen\\t\\tCaplen\\t\\tTimestamp\\tCsum\\tNote\\n" ) ; //<S2SV> } //<S2SV> pktcnt = 0 ; //<S2SV> last_sec = 0 ; //<S2SV> last_usec = 0 ; //<S2SV> while ( ( ret = read ( fd , & buf , pkthdrlen ) ) == pkthdrlen ) { //<S2SV> pktcnt ++ ; //<S2SV> backwards = 0 ; //<S2SV> caplentoobig = 0 ; //<S2SV> dbgx ( 3 , "Read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>packet<S2SV_blank>%" PRIu64 "<S2SV_blank>header" , ret , pktcnt ) ; //<S2SV> memset ( & pcap_ph , 0 , sizeof ( pcap_ph ) ) ; //<S2SV> if ( pkthdrlen == sizeof ( pcap_patched_ph ) ) { //<S2SV> memcpy ( & pcap_patched_ph , & buf , sizeof ( pcap_patched_ph ) ) ; //<S2SV> if ( swapped == 1 ) { //<S2SV> dbg ( 3 , "Swapping<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>bytes..." ) ; //<S2SV> pcap_patched_ph . caplen = SWAPLONG ( pcap_patched_ph . caplen ) ; //<S2SV> pcap_patched_ph . len = SWAPLONG ( pcap_patched_ph . len ) ; //<S2SV> pcap_patched_ph . ts . tv_sec = SWAPLONG ( pcap_patched_ph . ts . tv_sec ) ; //<S2SV> pcap_patched_ph . ts . tv_usec = SWAPLONG ( pcap_patched_ph . ts . tv_usec ) ; //<S2SV> pcap_patched_ph . index = SWAPLONG ( pcap_patched_ph . index ) ; //<S2SV> pcap_patched_ph . protocol = SWAPSHORT ( pcap_patched_ph . protocol ) ; //<S2SV> } //<S2SV> printf ( "%" PRIu64 "\\t%4" PRIu32 "\\t\\t%4" PRIu32 "\\t\\t%" //<S2SV> PRIx32 ".%" PRIx32 "\\t\\t%4" PRIu32 "\\t%4hu\\t%4hhu" , //<S2SV> pktcnt , pcap_patched_ph . len , pcap_patched_ph . caplen , //<S2SV> pcap_patched_ph . ts . tv_sec , pcap_patched_ph . ts . tv_usec , //<S2SV> pcap_patched_ph . index , pcap_patched_ph . protocol , pcap_patched_ph . pkt_type ) ; //<S2SV> if ( pcap_fh . snaplen < pcap_patched_ph . caplen ) { //<S2SV> caplentoobig = 1 ; //<S2SV> } //<S2SV> caplen = pcap_patched_ph . caplen ; //<S2SV> } else { //<S2SV> memcpy ( & readword , buf , 4 ) ; //<S2SV> pcap_ph . ts . tv_sec = readword ; //<S2SV> memcpy ( & readword , & buf [ 4 ] , 4 ) ; //<S2SV> pcap_ph . ts . tv_usec = readword ; //<S2SV> memcpy ( & pcap_ph . caplen , & buf [ 8 ] , 4 ) ; //<S2SV> memcpy ( & pcap_ph . len , & buf [ 12 ] , 4 ) ; //<S2SV> if ( swapped == 1 ) { //<S2SV> dbg ( 3 , "Swapping<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>bytes..." ) ; //<S2SV> pcap_ph . caplen = SWAPLONG ( pcap_ph . caplen ) ; //<S2SV> pcap_ph . len = SWAPLONG ( pcap_ph . len ) ; //<S2SV> pcap_ph . ts . tv_sec = SWAPLONG ( pcap_ph . ts . tv_sec ) ; //<S2SV> pcap_ph . ts . tv_usec = SWAPLONG ( pcap_ph . ts . tv_usec ) ; //<S2SV> } //<S2SV> printf ( "%" PRIu64 "\\t%4" PRIu32 "\\t\\t%4" PRIu32 "\\t\\t%" //<S2SV> PRIx32 ".%" PRIx32 , //<S2SV> pktcnt , pcap_ph . len , pcap_ph . caplen , //<S2SV> ( unsigned int ) pcap_ph . ts . tv_sec , ( unsigned int ) pcap_ph . ts . tv_usec ) ; //<S2SV> if ( pcap_fh . snaplen < pcap_ph . caplen ) { //<S2SV> caplentoobig = 1 ; //<S2SV> } //<S2SV> caplen = pcap_ph . caplen ; //<S2SV> } //<S2SV> if ( caplentoobig ) { //<S2SV> printf ( "\\n\\nCapture<S2SV_blank>file<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>damaged<S2SV_blank>or<S2SV_blank>corrupt.\\n" //<S2SV> "Contains<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%u,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>snap<S2SV_blank>length<S2SV_blank>%u\\n" , //<S2SV> caplen , pcap_fh . snaplen ) ; //<S2SV> close ( fd ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( last_sec > 0 && last_usec > 0 ) { //<S2SV> if ( ( pcap_ph . ts . tv_sec == last_sec ) ? //<S2SV> ( pcap_ph . ts . tv_usec < last_usec ) : //<S2SV> ( pcap_ph . ts . tv_sec < last_sec ) ) { //<S2SV> backwards = 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( pkthdrlen == sizeof ( pcap_patched_ph ) ) { //<S2SV> last_sec = pcap_patched_ph . ts . tv_sec ; //<S2SV> last_usec = pcap_patched_ph . ts . tv_usec ; //<S2SV> } else { //<S2SV> last_sec = pcap_ph . ts . tv_sec ; //<S2SV> last_usec = pcap_ph . ts . tv_usec ; //<S2SV> } //<S2SV> if ( ( ret = read ( fd , & buf , caplen ) ) != caplen ) { //<S2SV> if ( ret < 0 ) { //<S2SV> printf ( "Error<S2SV_blank>reading<S2SV_blank>file:<S2SV_blank>%s:<S2SV_blank>%s\\n" , argv [ i ] , strerror ( errno ) ) ; //<S2SV> } else { //<S2SV> printf ( "File<S2SV_blank>truncated!<S2SV_blank><S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>jump<S2SV_blank>to<S2SV_blank>next<S2SV_blank>packet.\\n" ) ; //<S2SV> } //<S2SV> close ( fd ) ; //<S2SV> break ; //<S2SV> } //<S2SV> printf ( "\\t%x\\t" , do_checksum_math ( ( u_int16_t * ) buf , caplen ) ) ; //<S2SV> if ( ! backwards && ! caplentoobig ) { //<S2SV> printf ( "OK\\n" ) ; //<S2SV> } else if ( backwards && ! caplentoobig ) { //<S2SV> printf ( "BAD_TS\\n" ) ; //<S2SV> } else if ( caplentoobig && ! backwards ) { //<S2SV> printf ( "TOOBIG\\n" ) ; //<S2SV> } else if ( backwards && caplentoobig ) { //<S2SV> printf ( "BAD_TS|TOOBIG" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> 