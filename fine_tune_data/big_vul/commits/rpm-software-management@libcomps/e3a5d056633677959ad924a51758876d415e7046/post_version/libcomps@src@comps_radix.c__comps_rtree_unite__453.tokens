void comps_rtree_unite ( COMPS_RTree * rt1 , COMPS_RTree * rt2 ) { //<S2SV> COMPS_HSList * tmplist , * tmp_subnodes ; //<S2SV> COMPS_HSListItem * it ; //<S2SV> struct Pair { //<S2SV> COMPS_HSList * subnodes ; //<S2SV> char * key ; //<S2SV> } * pair , * parent_pair ; //<S2SV> pair = malloc ( sizeof ( struct Pair ) ) ; //<S2SV> pair -> subnodes = rt2 -> subnodes ; //<S2SV> pair -> key = NULL ; //<S2SV> tmplist = comps_hslist_create ( ) ; //<S2SV> comps_hslist_init ( tmplist , NULL , NULL , & free ) ; //<S2SV> comps_hslist_append ( tmplist , pair , 0 ) ; //<S2SV> while ( tmplist -> first != NULL ) { //<S2SV> it = tmplist -> first ; //<S2SV> comps_hslist_remove ( tmplist , tmplist -> first ) ; //<S2SV> tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; //<S2SV> parent_pair = ( struct Pair * ) it -> data ; //<S2SV> free ( it ) ; //<S2SV> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { //<S2SV> pair = malloc ( sizeof ( struct Pair ) ) ; //<S2SV> pair -> subnodes = ( ( COMPS_RTreeData * ) it -> data ) -> subnodes ; //<S2SV> if ( parent_pair -> key != NULL ) { //<S2SV> pair -> key = malloc ( sizeof ( char ) //<S2SV> * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) //<S2SV> + strlen ( parent_pair -> key ) + 1 ) ) ; //<S2SV> memcpy ( pair -> key , parent_pair -> key , //<S2SV> sizeof ( char ) * strlen ( parent_pair -> key ) ) ; //<S2SV> memcpy ( pair -> key + strlen ( parent_pair -> key ) , //<S2SV> ( ( COMPS_RTreeData * ) it -> data ) -> key , //<S2SV> sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; //<S2SV> } else { //<S2SV> pair -> key = malloc ( sizeof ( char ) * //<S2SV> ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; //<S2SV> memcpy ( pair -> key , ( ( COMPS_RTreeData * ) it -> data ) -> key , //<S2SV> sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; //<S2SV> } //<S2SV> if ( ( ( COMPS_RTreeData * ) it -> data ) -> data != NULL ) { //<S2SV> comps_rtree_set ( rt1 , //<S2SV> pair -> key , //<S2SV> rt2 -> data_cloner ( ( ( COMPS_RTreeData * ) it -> data ) -> data ) ) ; //<S2SV> } //<S2SV> if ( ( ( COMPS_RTreeData * ) it -> data ) -> subnodes -> first ) { //<S2SV> comps_hslist_append ( tmplist , pair , 0 ) ; //<S2SV> } else { //<S2SV> free ( pair -> key ) ; //<S2SV> free ( pair ) ; //<S2SV> } //<S2SV> } //<S2SV> free ( parent_pair -> key ) ; //<S2SV> free ( parent_pair ) ; //<S2SV> } //<S2SV> comps_hslist_destroy ( & tmplist ) ; //<S2SV> } //<S2SV> 