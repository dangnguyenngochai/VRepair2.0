static int //<S2SV> userauth_hostbased ( struct ssh * ssh ) //<S2SV> { //<S2SV> Authctxt * authctxt = ssh -> authctxt ; //<S2SV> struct sshbuf * b ; //<S2SV> struct sshkey * key = NULL ; //<S2SV> char * pkalg , * cuser , * chost ; //<S2SV> u_char * pkblob , * sig ; //<S2SV> size_t alen , blen , slen ; //<S2SV> int r , pktype , authenticated = 0 ; //<S2SV> if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || //<S2SV> ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || //<S2SV> ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || //<S2SV> ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || //<S2SV> ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>packet<S2SV_blank>parsing:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; //<S2SV> debug ( "%s:<S2SV_blank>cuser<S2SV_blank>%s<S2SV_blank>chost<S2SV_blank>%s<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>slen<S2SV_blank>%zu" , __func__ , //<S2SV> cuser , chost , pkalg , slen ) ; //<S2SV> # ifdef DEBUG_PK //<S2SV> debug ( "signature:" ) ; //<S2SV> sshbuf_dump_data ( sig , siglen , stderr ) ; //<S2SV> # endif //<S2SV> pktype = sshkey_type_from_name ( pkalg ) ; //<S2SV> if ( pktype == KEY_UNSPEC ) { //<S2SV> logit ( "%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s" , //<S2SV> __func__ , pkalg ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { //<S2SV> error ( "%s:<S2SV_blank>key_from_blob:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( key == NULL ) { //<S2SV> error ( "%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s" , __func__ , pkalg ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( key -> type != pktype ) { //<S2SV> error ( "%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>" //<S2SV> "(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)" , __func__ , key -> type , pktype ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( sshkey_type_plain ( key -> type ) == KEY_RSA && //<S2SV> ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { //<S2SV> error ( "Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>peer<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>" //<S2SV> "signature<S2SV_blank>format" ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) { //<S2SV> logit ( "%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>HostbasedAcceptedKeyTypes" , //<S2SV> __func__ , sshkey_type ( key ) ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ! authctxt -> valid || authctxt -> user == NULL ) { //<S2SV> debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( b = sshbuf_new ( ) ) == NULL ) //<S2SV> fatal ( "%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed" , __func__ ) ; //<S2SV> if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || //<S2SV> ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , "hostbased" ) ) != 0 || //<S2SV> ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || //<S2SV> ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; //<S2SV> # ifdef DEBUG_PK //<S2SV> sshbuf_dump ( b , stderr ) ; //<S2SV> # endif //<S2SV> auth2_record_info ( authctxt , //<S2SV> "client<S2SV_blank>user<S2SV_blank>\\"%.100s\\",<S2SV_blank>client<S2SV_blank>host<S2SV_blank>\\"%.100s\\"" , cuser , chost ) ; //<S2SV> authenticated = 0 ; //<S2SV> if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && //<S2SV> PRIVSEP ( sshkey_verify ( key , sig , slen , //<S2SV> sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) //<S2SV> authenticated = 1 ; //<S2SV> auth2_record_key ( authctxt , authenticated , key ) ; //<S2SV> sshbuf_free ( b ) ; //<S2SV> done : //<S2SV> debug2 ( "%s:<S2SV_blank>authenticated<S2SV_blank>%d" , __func__ , authenticated ) ; //<S2SV> sshkey_free ( key ) ; //<S2SV> free ( pkalg ) ; //<S2SV> free ( pkblob ) ; //<S2SV> free ( cuser ) ; //<S2SV> free ( chost ) ; //<S2SV> free ( sig ) ; //<S2SV> return authenticated ; //<S2SV> } //<S2SV> 