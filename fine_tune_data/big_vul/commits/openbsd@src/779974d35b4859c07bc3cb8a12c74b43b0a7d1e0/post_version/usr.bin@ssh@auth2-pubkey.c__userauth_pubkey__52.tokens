static int //<S2SV> userauth_pubkey ( struct ssh * ssh ) //<S2SV> { //<S2SV> Authctxt * authctxt = ssh -> authctxt ; //<S2SV> struct passwd * pw = authctxt -> pw ; //<S2SV> struct sshbuf * b = NULL ; //<S2SV> struct sshkey * key = NULL ; //<S2SV> char * pkalg = NULL , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; //<S2SV> u_char * pkblob = NULL , * sig = NULL , have_sig ; //<S2SV> size_t blen , slen ; //<S2SV> int r , pktype ; //<S2SV> int authenticated = 0 ; //<S2SV> struct sshauthopt * authopts = NULL ; //<S2SV> if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || //<S2SV> ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || //<S2SV> ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>failed:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; //<S2SV> pktype = sshkey_type_from_name ( pkalg ) ; //<S2SV> if ( pktype == KEY_UNSPEC ) { //<S2SV> verbose ( "%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s" , //<S2SV> __func__ , pkalg ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { //<S2SV> error ( "%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>key:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( key == NULL ) { //<S2SV> error ( "%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s" , __func__ , pkalg ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( key -> type != pktype ) { //<S2SV> error ( "%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>" //<S2SV> "(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)" , __func__ , key -> type , pktype ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( sshkey_type_plain ( key -> type ) == KEY_RSA && //<S2SV> ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { //<S2SV> logit ( "Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>client<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>" //<S2SV> "signature<S2SV_blank>scheme" ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( auth2_key_already_used ( authctxt , key ) ) { //<S2SV> logit ( "refusing<S2SV_blank>previously-used<S2SV_blank>%s<S2SV_blank>key" , sshkey_type ( key ) ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) { //<S2SV> logit ( "%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>PubkeyAcceptedKeyTypes" , //<S2SV> __func__ , sshkey_ssh_name ( key ) ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> key_s = format_key ( key ) ; //<S2SV> if ( sshkey_is_cert ( key ) ) //<S2SV> ca_s = format_key ( key -> cert -> signature_key ) ; //<S2SV> if ( have_sig ) { //<S2SV> debug3 ( "%s:<S2SV_blank>have<S2SV_blank>%s<S2SV_blank>signature<S2SV_blank>for<S2SV_blank>%s%s%s" , //<S2SV> __func__ , pkalg , key_s , //<S2SV> ca_s == NULL ? "" : "<S2SV_blank>CA<S2SV_blank>" , //<S2SV> ca_s == NULL ? "" : ca_s ) ; //<S2SV> if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || //<S2SV> ( r = sshpkt_get_end ( ssh ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; //<S2SV> if ( ( b = sshbuf_new ( ) ) == NULL ) //<S2SV> fatal ( "%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed" , __func__ ) ; //<S2SV> if ( ssh -> compat & SSH_OLD_SESSIONID ) { //<S2SV> if ( ( r = sshbuf_put ( b , session_id2 , //<S2SV> session_id2_len ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>sshbuf_put<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , //<S2SV> __func__ , ssh_err ( r ) ) ; //<S2SV> } else { //<S2SV> if ( ( r = sshbuf_put_string ( b , session_id2 , //<S2SV> session_id2_len ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , //<S2SV> __func__ , ssh_err ( r ) ) ; //<S2SV> } //<S2SV> if ( ! authctxt -> valid || authctxt -> user == NULL ) { //<S2SV> debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , //<S2SV> __func__ ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> xasprintf ( & userstyle , "%s%s%s" , authctxt -> user , //<S2SV> authctxt -> style ? ":" : "" , //<S2SV> authctxt -> style ? authctxt -> style : "" ) ; //<S2SV> if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , "publickey" ) ) != 0 || //<S2SV> ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || //<S2SV> ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || //<S2SV> ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>build<S2SV_blank>packet<S2SV_blank>failed:<S2SV_blank>%s" , //<S2SV> __func__ , ssh_err ( r ) ) ; //<S2SV> # ifdef DEBUG_PK //<S2SV> sshbuf_dump ( b , stderr ) ; //<S2SV> # endif //<S2SV> authenticated = 0 ; //<S2SV> if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && //<S2SV> PRIVSEP ( sshkey_verify ( key , sig , slen , //<S2SV> sshbuf_ptr ( b ) , sshbuf_len ( b ) , //<S2SV> ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , //<S2SV> ssh -> compat ) ) == 0 ) { //<S2SV> authenticated = 1 ; //<S2SV> } //<S2SV> sshbuf_free ( b ) ; //<S2SV> auth2_record_key ( authctxt , authenticated , key ) ; //<S2SV> } else { //<S2SV> debug ( "%s:<S2SV_blank>test<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>pkblob<S2SV_blank>%s%s%s" , //<S2SV> __func__ , pkalg , key_s , //<S2SV> ca_s == NULL ? "" : "<S2SV_blank>CA<S2SV_blank>" , //<S2SV> ca_s == NULL ? "" : ca_s ) ; //<S2SV> if ( ( r = sshpkt_get_end ( ssh ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; //<S2SV> if ( ! authctxt -> valid || authctxt -> user == NULL ) { //<S2SV> debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , //<S2SV> __func__ ) ; //<S2SV> goto done ; //<S2SV> } //<S2SV> if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) { //<S2SV> if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) //<S2SV> != 0 || //<S2SV> ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || //<S2SV> ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || //<S2SV> ( r = sshpkt_send ( ssh ) ) != 0 || //<S2SV> ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) //<S2SV> fatal ( "%s:<S2SV_blank>%s" , __func__ , ssh_err ( r ) ) ; //<S2SV> authctxt -> postponed = 1 ; //<S2SV> } //<S2SV> } //<S2SV> done : //<S2SV> if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) { //<S2SV> debug ( "%s:<S2SV_blank>key<S2SV_blank>options<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>existing" , __func__ ) ; //<S2SV> authenticated = 0 ; //<S2SV> } //<S2SV> debug2 ( "%s:<S2SV_blank>authenticated<S2SV_blank>%d<S2SV_blank>pkalg<S2SV_blank>%s" , __func__ , authenticated , pkalg ) ; //<S2SV> sshauthopt_free ( authopts ) ; //<S2SV> sshkey_free ( key ) ; //<S2SV> free ( userstyle ) ; //<S2SV> free ( pkalg ) ; //<S2SV> free ( pkblob ) ; //<S2SV> free ( key_s ) ; //<S2SV> free ( ca_s ) ; //<S2SV> free ( sig ) ; //<S2SV> return authenticated ; //<S2SV> } //<S2SV> 