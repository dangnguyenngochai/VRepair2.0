int //<S2SV> main ( int ac , char * * av ) //<S2SV> { //<S2SV> int c_flag = 0 , d_flag = 0 , D_flag = 0 , k_flag = 0 , s_flag = 0 ; //<S2SV> int sock , fd , ch , result , saved_errno ; //<S2SV> u_int nalloc ; //<S2SV> char * shell , * format , * pidstr , * agentsocket = NULL ; //<S2SV> fd_set * readsetp = NULL , * writesetp = NULL ; //<S2SV> struct rlimit rlim ; //<S2SV> extern int optind ; //<S2SV> extern char * optarg ; //<S2SV> pid_t pid ; //<S2SV> char pidstrbuf [ 1 + 3 * sizeof pid ] ; //<S2SV> struct timeval * tvp = NULL ; //<S2SV> size_t len ; //<S2SV> mode_t prev_mask ; //<S2SV> ssh_malloc_init ( ) ; //<S2SV> sanitise_stdfd ( ) ; //<S2SV> setegid ( getgid ( ) ) ; //<S2SV> setgid ( getgid ( ) ) ; //<S2SV> # ifdef WITH_OPENSSL //<S2SV> OpenSSL_add_all_algorithms ( ) ; //<S2SV> # endif //<S2SV> while ( ( ch = getopt ( ac , av , "cDdksE:a:P:t:" ) ) != - 1 ) { //<S2SV> switch ( ch ) { //<S2SV> case 'E' : //<S2SV> fingerprint_hash = ssh_digest_alg_by_name ( optarg ) ; //<S2SV> if ( fingerprint_hash == - 1 ) //<S2SV> fatal ( "Invalid<S2SV_blank>hash<S2SV_blank>algorithm<S2SV_blank>\\"%s\\"" , optarg ) ; //<S2SV> break ; //<S2SV> case 'c' : //<S2SV> if ( s_flag ) //<S2SV> usage ( ) ; //<S2SV> c_flag ++ ; //<S2SV> break ; //<S2SV> case 'k' : //<S2SV> k_flag ++ ; //<S2SV> break ; //<S2SV> case 'P' : //<S2SV> if ( pkcs11_whitelist != NULL ) //<S2SV> fatal ( "-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified" ) ; //<S2SV> pkcs11_whitelist = xstrdup ( optarg ) ; //<S2SV> break ; //<S2SV> case 's' : //<S2SV> if ( c_flag ) //<S2SV> usage ( ) ; //<S2SV> s_flag ++ ; //<S2SV> break ; //<S2SV> case 'd' : //<S2SV> if ( d_flag || D_flag ) //<S2SV> usage ( ) ; //<S2SV> d_flag ++ ; //<S2SV> break ; //<S2SV> case 'D' : //<S2SV> if ( d_flag || D_flag ) //<S2SV> usage ( ) ; //<S2SV> D_flag ++ ; //<S2SV> break ; //<S2SV> case 'a' : //<S2SV> agentsocket = optarg ; //<S2SV> break ; //<S2SV> case 't' : //<S2SV> if ( ( lifetime = convtime ( optarg ) ) == - 1 ) { //<S2SV> fprintf ( stderr , "Invalid<S2SV_blank>lifetime\\n" ) ; //<S2SV> usage ( ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> usage ( ) ; //<S2SV> } //<S2SV> } //<S2SV> ac -= optind ; //<S2SV> av += optind ; //<S2SV> if ( ac > 0 && ( c_flag || k_flag || s_flag || d_flag || D_flag ) ) //<S2SV> usage ( ) ; //<S2SV> if ( pkcs11_whitelist == NULL ) //<S2SV> pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; //<S2SV> if ( ac == 0 && ! c_flag && ! s_flag ) { //<S2SV> shell = getenv ( "SHELL" ) ; //<S2SV> if ( shell != NULL && ( len = strlen ( shell ) ) > 2 && //<S2SV> strncmp ( shell + len - 3 , "csh" , 3 ) == 0 ) //<S2SV> c_flag = 1 ; //<S2SV> } //<S2SV> if ( k_flag ) { //<S2SV> const char * errstr = NULL ; //<S2SV> pidstr = getenv ( SSH_AGENTPID_ENV_NAME ) ; //<S2SV> if ( pidstr == NULL ) { //<S2SV> fprintf ( stderr , "%s<S2SV_blank>not<S2SV_blank>set,<S2SV_blank>cannot<S2SV_blank>kill<S2SV_blank>agent\\n" , //<S2SV> SSH_AGENTPID_ENV_NAME ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> pid = ( int ) strtonum ( pidstr , 2 , INT_MAX , & errstr ) ; //<S2SV> if ( errstr ) { //<S2SV> fprintf ( stderr , //<S2SV> "%s=\\"%s\\",<S2SV_blank>which<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>good<S2SV_blank>PID:<S2SV_blank>%s\\n" , //<S2SV> SSH_AGENTPID_ENV_NAME , pidstr , errstr ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> if ( kill ( pid , SIGTERM ) == - 1 ) { //<S2SV> perror ( "kill" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> format = c_flag ? "unsetenv<S2SV_blank>%s;\\n" : "unset<S2SV_blank>%s;\\n" ; //<S2SV> printf ( format , SSH_AUTHSOCKET_ENV_NAME ) ; //<S2SV> printf ( format , SSH_AGENTPID_ENV_NAME ) ; //<S2SV> printf ( "echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld<S2SV_blank>killed;\\n" , ( long ) pid ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> parent_pid = getpid ( ) ; //<S2SV> if ( agentsocket == NULL ) { //<S2SV> mktemp_proto ( socket_dir , sizeof ( socket_dir ) ) ; //<S2SV> if ( mkdtemp ( socket_dir ) == NULL ) { //<S2SV> perror ( "mkdtemp:<S2SV_blank>private<S2SV_blank>socket<S2SV_blank>dir" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> snprintf ( socket_name , sizeof socket_name , "%s/agent.%ld" , socket_dir , //<S2SV> ( long ) parent_pid ) ; //<S2SV> } else { //<S2SV> socket_dir [ 0 ] = '\\0' ; //<S2SV> strlcpy ( socket_name , agentsocket , sizeof socket_name ) ; //<S2SV> } //<S2SV> prev_mask = umask ( 0177 ) ; //<S2SV> sock = unix_listener ( socket_name , SSH_LISTEN_BACKLOG , 0 ) ; //<S2SV> if ( sock < 0 ) { //<S2SV> * socket_name = '\\0' ; //<S2SV> cleanup_exit ( 1 ) ; //<S2SV> } //<S2SV> umask ( prev_mask ) ; //<S2SV> if ( D_flag || d_flag ) { //<S2SV> log_init ( __progname , //<S2SV> d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO , //<S2SV> SYSLOG_FACILITY_AUTH , 1 ) ; //<S2SV> format = c_flag ? "setenv<S2SV_blank>%s<S2SV_blank>%s;\\n" : "%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n" ; //<S2SV> printf ( format , SSH_AUTHSOCKET_ENV_NAME , socket_name , //<S2SV> SSH_AUTHSOCKET_ENV_NAME ) ; //<S2SV> printf ( "echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n" , ( long ) parent_pid ) ; //<S2SV> fflush ( stdout ) ; //<S2SV> goto skip ; //<S2SV> } //<S2SV> pid = fork ( ) ; //<S2SV> if ( pid == - 1 ) { //<S2SV> perror ( "fork" ) ; //<S2SV> cleanup_exit ( 1 ) ; //<S2SV> } //<S2SV> if ( pid != 0 ) { //<S2SV> close ( sock ) ; //<S2SV> snprintf ( pidstrbuf , sizeof pidstrbuf , "%ld" , ( long ) pid ) ; //<S2SV> if ( ac == 0 ) { //<S2SV> format = c_flag ? "setenv<S2SV_blank>%s<S2SV_blank>%s;\\n" : "%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n" ; //<S2SV> printf ( format , SSH_AUTHSOCKET_ENV_NAME , socket_name , //<S2SV> SSH_AUTHSOCKET_ENV_NAME ) ; //<S2SV> printf ( format , SSH_AGENTPID_ENV_NAME , pidstrbuf , //<S2SV> SSH_AGENTPID_ENV_NAME ) ; //<S2SV> printf ( "echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n" , ( long ) pid ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> if ( setenv ( SSH_AUTHSOCKET_ENV_NAME , socket_name , 1 ) == - 1 || //<S2SV> setenv ( SSH_AGENTPID_ENV_NAME , pidstrbuf , 1 ) == - 1 ) { //<S2SV> perror ( "setenv" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> execvp ( av [ 0 ] , av ) ; //<S2SV> perror ( av [ 0 ] ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> log_init ( __progname , SYSLOG_LEVEL_INFO , SYSLOG_FACILITY_AUTH , 0 ) ; //<S2SV> if ( setsid ( ) == - 1 ) { //<S2SV> error ( "setsid:<S2SV_blank>%s" , strerror ( errno ) ) ; //<S2SV> cleanup_exit ( 1 ) ; //<S2SV> } //<S2SV> ( void ) chdir ( "/" ) ; //<S2SV> if ( ( fd = open ( _PATH_DEVNULL , O_RDWR , 0 ) ) != - 1 ) { //<S2SV> ( void ) dup2 ( fd , STDIN_FILENO ) ; //<S2SV> ( void ) dup2 ( fd , STDOUT_FILENO ) ; //<S2SV> ( void ) dup2 ( fd , STDERR_FILENO ) ; //<S2SV> if ( fd > 2 ) //<S2SV> close ( fd ) ; //<S2SV> } //<S2SV> rlim . rlim_cur = rlim . rlim_max = 0 ; //<S2SV> if ( setrlimit ( RLIMIT_CORE , & rlim ) < 0 ) { //<S2SV> error ( "setrlimit<S2SV_blank>RLIMIT_CORE:<S2SV_blank>%s" , strerror ( errno ) ) ; //<S2SV> cleanup_exit ( 1 ) ; //<S2SV> } //<S2SV> skip : //<S2SV> cleanup_pid = getpid ( ) ; //<S2SV> # ifdef ENABLE_PKCS11 //<S2SV> pkcs11_init ( 0 ) ; //<S2SV> # endif //<S2SV> new_socket ( AUTH_SOCKET , sock ) ; //<S2SV> if ( ac > 0 ) //<S2SV> parent_alive_interval = 10 ; //<S2SV> idtab_init ( ) ; //<S2SV> signal ( SIGPIPE , SIG_IGN ) ; //<S2SV> signal ( SIGINT , ( d_flag | D_flag ) ? cleanup_handler : SIG_IGN ) ; //<S2SV> signal ( SIGHUP , cleanup_handler ) ; //<S2SV> signal ( SIGTERM , cleanup_handler ) ; //<S2SV> nalloc = 0 ; //<S2SV> if ( pledge ( "stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec" , NULL ) == - 1 ) //<S2SV> fatal ( "%s:<S2SV_blank>pledge:<S2SV_blank>%s" , __progname , strerror ( errno ) ) ; //<S2SV> while ( 1 ) { //<S2SV> prepare_select ( & readsetp , & writesetp , & max_fd , & nalloc , & tvp ) ; //<S2SV> result = select ( max_fd + 1 , readsetp , writesetp , NULL , tvp ) ; //<S2SV> saved_errno = errno ; //<S2SV> if ( parent_alive_interval != 0 ) //<S2SV> check_parent_exists ( ) ; //<S2SV> ( void ) reaper ( ) ; //<S2SV> if ( result < 0 ) { //<S2SV> if ( saved_errno == EINTR ) //<S2SV> continue ; //<S2SV> fatal ( "select:<S2SV_blank>%s" , strerror ( saved_errno ) ) ; //<S2SV> } else if ( result > 0 ) //<S2SV> after_select ( readsetp , writesetp ) ; //<S2SV> } //<S2SV> } //<S2SV> 