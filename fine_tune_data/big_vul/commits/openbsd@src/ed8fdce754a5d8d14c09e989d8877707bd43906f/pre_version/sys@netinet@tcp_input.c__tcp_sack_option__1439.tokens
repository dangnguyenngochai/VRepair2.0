void //<S2SV> tcp_sack_option ( struct tcpcb * tp , struct tcphdr * th , u_char * cp , int optlen ) //<S2SV> { //<S2SV> int tmp_olen ; //<S2SV> u_char * tmp_cp ; //<S2SV> struct sackhole * cur , * p , * temp ; //<S2SV> if ( ! tp -> sack_enable ) //<S2SV> return ; //<S2SV> if ( ( th -> th_flags & TH_ACK ) == 0 ) //<S2SV> return ; //<S2SV> if ( SEQ_LT ( th -> th_ack , tp -> snd_una ) || //<S2SV> SEQ_GT ( th -> th_ack , tp -> snd_max ) ) //<S2SV> return ; //<S2SV> if ( optlen <= 2 || ( optlen - 2 ) % TCPOLEN_SACK != 0 ) //<S2SV> return ; //<S2SV> tmp_cp = cp + 2 ; //<S2SV> tmp_olen = optlen - 2 ; //<S2SV> tcpstat_inc ( tcps_sack_rcv_opts ) ; //<S2SV> if ( tp -> snd_numholes < 0 ) //<S2SV> tp -> snd_numholes = 0 ; //<S2SV> if ( tp -> t_maxseg == 0 ) //<S2SV> panic ( "tcp_sack_option" ) ; //<S2SV> while ( tmp_olen > 0 ) { //<S2SV> struct sackblk sack ; //<S2SV> memcpy ( & sack . start , tmp_cp , sizeof ( tcp_seq ) ) ; //<S2SV> sack . start = ntohl ( sack . start ) ; //<S2SV> memcpy ( & sack . end , tmp_cp + sizeof ( tcp_seq ) , sizeof ( tcp_seq ) ) ; //<S2SV> sack . end = ntohl ( sack . end ) ; //<S2SV> tmp_olen -= TCPOLEN_SACK ; //<S2SV> tmp_cp += TCPOLEN_SACK ; //<S2SV> if ( SEQ_LEQ ( sack . end , sack . start ) ) //<S2SV> continue ; //<S2SV> if ( SEQ_LEQ ( sack . end , tp -> snd_una ) ) //<S2SV> continue ; //<S2SV> if ( SEQ_GT ( th -> th_ack , tp -> snd_una ) ) { //<S2SV> if ( SEQ_LT ( sack . start , th -> th_ack ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( SEQ_GT ( sack . end , tp -> snd_max ) ) //<S2SV> continue ; //<S2SV> if ( tp -> snd_holes == NULL ) { //<S2SV> tp -> snd_holes = ( struct sackhole * ) //<S2SV> pool_get ( & sackhl_pool , PR_NOWAIT ) ; //<S2SV> if ( tp -> snd_holes == NULL ) { //<S2SV> goto done ; //<S2SV> } //<S2SV> cur = tp -> snd_holes ; //<S2SV> cur -> start = th -> th_ack ; //<S2SV> cur -> end = sack . start ; //<S2SV> cur -> rxmit = cur -> start ; //<S2SV> cur -> next = NULL ; //<S2SV> tp -> snd_numholes = 1 ; //<S2SV> tp -> rcv_lastsack = sack . end ; //<S2SV> cur -> dups = min ( tcprexmtthresh , //<S2SV> ( ( sack . end - cur -> end ) / tp -> t_maxseg ) ) ; //<S2SV> if ( cur -> dups < 1 ) //<S2SV> cur -> dups = 1 ; //<S2SV> continue ; //<S2SV> } //<S2SV> p = cur = tp -> snd_holes ; //<S2SV> while ( cur ) { //<S2SV> if ( SEQ_LEQ ( sack . end , cur -> start ) ) //<S2SV> break ; //<S2SV> if ( SEQ_GEQ ( sack . start , cur -> end ) ) { //<S2SV> cur -> dups ++ ; //<S2SV> if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= //<S2SV> tcprexmtthresh ) //<S2SV> cur -> dups = tcprexmtthresh ; //<S2SV> p = cur ; //<S2SV> cur = cur -> next ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( SEQ_LEQ ( sack . start , cur -> start ) ) { //<S2SV> if ( SEQ_GEQ ( sack . end , cur -> end ) ) { //<S2SV> if ( p != cur ) { //<S2SV> p -> next = cur -> next ; //<S2SV> pool_put ( & sackhl_pool , cur ) ; //<S2SV> cur = p -> next ; //<S2SV> } else { //<S2SV> cur = cur -> next ; //<S2SV> pool_put ( & sackhl_pool , p ) ; //<S2SV> p = cur ; //<S2SV> tp -> snd_holes = p ; //<S2SV> } //<S2SV> tp -> snd_numholes -- ; //<S2SV> continue ; //<S2SV> } //<S2SV> cur -> start = sack . end ; //<S2SV> cur -> rxmit = SEQ_MAX ( cur -> rxmit , cur -> start ) ; //<S2SV> p = cur ; //<S2SV> cur = cur -> next ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( SEQ_GEQ ( sack . end , cur -> end ) ) { //<S2SV> cur -> end = sack . start ; //<S2SV> cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; //<S2SV> cur -> dups ++ ; //<S2SV> if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= //<S2SV> tcprexmtthresh ) //<S2SV> cur -> dups = tcprexmtthresh ; //<S2SV> p = cur ; //<S2SV> cur = cur -> next ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( SEQ_LT ( cur -> start , sack . start ) && //<S2SV> SEQ_GT ( cur -> end , sack . end ) ) { //<S2SV> temp = ( struct sackhole * ) //<S2SV> pool_get ( & sackhl_pool , PR_NOWAIT ) ; //<S2SV> if ( temp == NULL ) //<S2SV> goto done ; //<S2SV> temp -> next = cur -> next ; //<S2SV> temp -> start = sack . end ; //<S2SV> temp -> end = cur -> end ; //<S2SV> temp -> dups = cur -> dups ; //<S2SV> temp -> rxmit = SEQ_MAX ( cur -> rxmit , temp -> start ) ; //<S2SV> cur -> end = sack . start ; //<S2SV> cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; //<S2SV> cur -> dups ++ ; //<S2SV> if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= //<S2SV> tcprexmtthresh ) //<S2SV> cur -> dups = tcprexmtthresh ; //<S2SV> cur -> next = temp ; //<S2SV> p = temp ; //<S2SV> cur = p -> next ; //<S2SV> tp -> snd_numholes ++ ; //<S2SV> } //<S2SV> } //<S2SV> if ( SEQ_LT ( tp -> rcv_lastsack , sack . start ) ) { //<S2SV> temp = ( struct sackhole * ) //<S2SV> pool_get ( & sackhl_pool , PR_NOWAIT ) ; //<S2SV> if ( temp == NULL ) //<S2SV> goto done ; //<S2SV> temp -> start = tp -> rcv_lastsack ; //<S2SV> temp -> end = sack . start ; //<S2SV> temp -> dups = min ( tcprexmtthresh , //<S2SV> ( ( sack . end - sack . start ) / tp -> t_maxseg ) ) ; //<S2SV> if ( temp -> dups < 1 ) //<S2SV> temp -> dups = 1 ; //<S2SV> temp -> rxmit = temp -> start ; //<S2SV> temp -> next = 0 ; //<S2SV> p -> next = temp ; //<S2SV> tp -> rcv_lastsack = sack . end ; //<S2SV> tp -> snd_numholes ++ ; //<S2SV> } //<S2SV> } //<S2SV> done : //<S2SV> return ; //<S2SV> } //<S2SV> 