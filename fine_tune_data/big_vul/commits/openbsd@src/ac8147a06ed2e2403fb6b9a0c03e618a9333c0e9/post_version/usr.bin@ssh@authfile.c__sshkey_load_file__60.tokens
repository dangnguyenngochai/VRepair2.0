int //<S2SV> sshkey_load_file ( int fd , struct sshbuf * blob ) //<S2SV> { //<S2SV> u_char buf [ 1024 ] ; //<S2SV> size_t len ; //<S2SV> struct stat st ; //<S2SV> int r , dontmax = 0 ; //<S2SV> if ( fstat ( fd , & st ) < 0 ) //<S2SV> return SSH_ERR_SYSTEM_ERROR ; //<S2SV> if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && //<S2SV> st . st_size > MAX_KEY_FILE_SIZE ) //<S2SV> return SSH_ERR_INVALID_FORMAT ; //<S2SV> if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { //<S2SV> st . st_size = 64 * 1024 ; //<S2SV> dontmax = 1 ; //<S2SV> } //<S2SV> if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || //<S2SV> ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) //<S2SV> return r ; //<S2SV> for ( ; ; ) { //<S2SV> if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { //<S2SV> if ( errno == EPIPE ) //<S2SV> break ; //<S2SV> r = SSH_ERR_SYSTEM_ERROR ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) //<S2SV> goto out ; //<S2SV> if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { //<S2SV> r = SSH_ERR_INVALID_FORMAT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && //<S2SV> st . st_size != ( off_t ) sshbuf_len ( blob ) ) { //<S2SV> r = SSH_ERR_FILE_CHANGED ; //<S2SV> goto out ; //<S2SV> } //<S2SV> r = 0 ; //<S2SV> out : //<S2SV> explicit_bzero ( buf , sizeof ( buf ) ) ; //<S2SV> if ( r != 0 ) //<S2SV> sshbuf_reset ( blob ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> 