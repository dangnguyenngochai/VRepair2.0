void jslTokenAsString ( int token , char * str , size_t len ) { //<S2SV> if ( token > 32 && token < 128 ) { //<S2SV> assert ( len >= 4 ) ; //<S2SV> str [ 0 ] = '\\'' ; //<S2SV> str [ 1 ] = ( char ) token ; //<S2SV> str [ 2 ] = '\\'' ; //<S2SV> str [ 3 ] = 0 ; //<S2SV> return ; //<S2SV> } //<S2SV> switch ( token ) { //<S2SV> case LEX_EOF : strncpy ( str , "EOF" , len ) ; return ; //<S2SV> case LEX_ID : strncpy ( str , "ID" , len ) ; return ; //<S2SV> case LEX_INT : strncpy ( str , "INT" , len ) ; return ; //<S2SV> case LEX_FLOAT : strncpy ( str , "FLOAT" , len ) ; return ; //<S2SV> case LEX_STR : strncpy ( str , "STRING" , len ) ; return ; //<S2SV> case LEX_UNFINISHED_STR : strncpy ( str , "UNFINISHED<S2SV_blank>STRING" , len ) ; return ; //<S2SV> case LEX_TEMPLATE_LITERAL : strncpy ( str , "TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; //<S2SV> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; //<S2SV> case LEX_REGEX : strncpy ( str , "REGEX" , len ) ; return ; //<S2SV> case LEX_UNFINISHED_REGEX : strncpy ( str , "UNFINISHED<S2SV_blank>REGEX" , len ) ; return ; //<S2SV> case LEX_UNFINISHED_COMMENT : strncpy ( str , "UNFINISHED<S2SV_blank>COMMENT" , len ) ; return ; //<S2SV> } //<S2SV> if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { //<S2SV> const char tokenNames [ ] = //<S2SV> "==\\0" //<S2SV> "===\\0" //<S2SV> "!=\\0" //<S2SV> "!==\\0" //<S2SV> "<=\\0" //<S2SV> "<<\\0" //<S2SV> "<<=\\0" //<S2SV> ">=\\0" //<S2SV> ">>\\0" //<S2SV> ">>>\\0" //<S2SV> ">>=\\0" //<S2SV> ">>>=\\0" //<S2SV> "+=\\0" //<S2SV> "-=\\0" //<S2SV> "++\\0" //<S2SV> "--\\0" //<S2SV> "*=\\0" //<S2SV> "/=\\0" //<S2SV> "%=\\0" //<S2SV> "&=\\0" //<S2SV> "&&\\0" //<S2SV> "|=\\0" //<S2SV> "||\\0" //<S2SV> "^=\\0" //<S2SV> "=>\\0" //<S2SV> "if\\0" //<S2SV> "else\\0" //<S2SV> "do\\0" //<S2SV> "while\\0" //<S2SV> "for\\0" //<S2SV> "return\\0" //<S2SV> "continue\\0" //<S2SV> "function\\0" //<S2SV> "return\\0" //<S2SV> "var\\0" //<S2SV> "let\\0" //<S2SV> "const\\0" //<S2SV> "this\\0" //<S2SV> "throw\\0" //<S2SV> "try\\0" //<S2SV> "catch\\0" //<S2SV> "finally\\0" //<S2SV> "true\\0" //<S2SV> "false\\0" //<S2SV> "null\\0" //<S2SV> "undefined\\0" //<S2SV> "new\\0" //<S2SV> "in\\0" //<S2SV> "instanceof\\0" //<S2SV> "switch\\0" //<S2SV> "case\\0" //<S2SV> "default\\0" //<S2SV> "delete\\0" //<S2SV> "typeof\\0" //<S2SV> "void\\0" //<S2SV> "debugger\\0" //<S2SV> "class\\0" //<S2SV> "extends\\0" //<S2SV> "super\\0" //<S2SV> "static\\0" //<S2SV> ; //<S2SV> unsigned int p = 0 ; //<S2SV> int n = token - _LEX_OPERATOR_START ; //<S2SV> while ( n > 0 && p < sizeof ( tokenNames ) ) { //<S2SV> while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; //<S2SV> p ++ ; //<S2SV> n -- ; //<S2SV> } //<S2SV> assert ( n == 0 ) ; //<S2SV> strncpy ( str , & tokenNames [ p ] , len ) ; //<S2SV> return ; //<S2SV> } //<S2SV> assert ( len >= 10 ) ; //<S2SV> espruino_snprintf ( str , len , "?[%d]" , token ) ; //<S2SV> } //<S2SV> 