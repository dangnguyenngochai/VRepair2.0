static VALUE //<S2SV> ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) //<S2SV> { //<S2SV> EVP_CIPHER_CTX * ctx ; //<S2SV> unsigned char * in ; //<S2SV> long in_len , out_len ; //<S2SV> VALUE data , str ; //<S2SV> rb_scan_args ( argc , argv , "11" , & data , & str ) ; //<S2SV> StringValue ( data ) ; //<S2SV> in = ( unsigned char * ) RSTRING_PTR ( data ) ; //<S2SV> if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) //<S2SV> ossl_raise ( rb_eArgError , "data<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty" ) ; //<S2SV> GetCipher ( self , ctx ) ; //<S2SV> out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ; //<S2SV> if ( out_len <= 0 ) { //<S2SV> ossl_raise ( rb_eRangeError , //<S2SV> "data<S2SV_blank>too<S2SV_blank>big<S2SV_blank>to<S2SV_blank>make<S2SV_blank>output<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>bytes" , in_len ) ; //<S2SV> } //<S2SV> if ( NIL_P ( str ) ) { //<S2SV> str = rb_str_new ( 0 , out_len ) ; //<S2SV> } else { //<S2SV> StringValue ( str ) ; //<S2SV> rb_str_resize ( str , out_len ) ; //<S2SV> } //<S2SV> if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) //<S2SV> ossl_raise ( eCipherError , NULL ) ; //<S2SV> assert ( out_len < RSTRING_LEN ( str ) ) ; //<S2SV> rb_str_set_len ( str , out_len ) ; //<S2SV> return str ; //<S2SV> } //<S2SV> 