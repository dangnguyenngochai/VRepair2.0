static VALUE //<S2SV> ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) //<S2SV> { //<S2SV> EVP_CIPHER_CTX * ctx ; //<S2SV> unsigned char key [ EVP_MAX_KEY_LENGTH ] , * p_key = NULL ; //<S2SV> unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ; //<S2SV> VALUE pass , init_v ; //<S2SV> if ( rb_scan_args ( argc , argv , "02" , & pass , & init_v ) > 0 ) { //<S2SV> VALUE cname = rb_class_path ( rb_obj_class ( self ) ) ; //<S2SV> rb_warn ( "arguments<S2SV_blank>for<S2SV_blank>%" PRIsVALUE "#encrypt<S2SV_blank>and<S2SV_blank>%" PRIsVALUE "#decrypt<S2SV_blank>were<S2SV_blank>deprecated;<S2SV_blank>" //<S2SV> "use<S2SV_blank>%" PRIsVALUE "#pkcs5_keyivgen<S2SV_blank>to<S2SV_blank>derive<S2SV_blank>key<S2SV_blank>and<S2SV_blank>IV" , //<S2SV> cname , cname , cname ) ; //<S2SV> StringValue ( pass ) ; //<S2SV> GetCipher ( self , ctx ) ; //<S2SV> if ( NIL_P ( init_v ) ) memcpy ( iv , "OpenSSL<S2SV_blank>for<S2SV_blank>Ruby<S2SV_blank>rulez!" , sizeof ( iv ) ) ; //<S2SV> else { //<S2SV> StringValue ( init_v ) ; //<S2SV> if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) { //<S2SV> memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ; //<S2SV> memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ; //<S2SV> } //<S2SV> else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ; //<S2SV> } //<S2SV> EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , //<S2SV> ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ; //<S2SV> p_key = key ; //<S2SV> p_iv = iv ; //<S2SV> } //<S2SV> else { //<S2SV> GetCipher ( self , ctx ) ; //<S2SV> } //<S2SV> if ( EVP_CipherInit_ex ( ctx , NULL , NULL , p_key , p_iv , mode ) != 1 ) { //<S2SV> ossl_raise ( eCipherError , NULL ) ; //<S2SV> } //<S2SV> if ( p_key ) //<S2SV> rb_ivar_set ( self , id_key_set , Qtrue ) ; //<S2SV> return self ; //<S2SV> } //<S2SV> 