int bzrtp_packetParser ( bzrtpContext_t * zrtpContext , bzrtpChannelContext_t * zrtpChannelContext , const uint8_t * input , uint16_t inputLength , bzrtpPacket_t * zrtpPacket ) { //<S2SV> int i ; //<S2SV> uint8_t * messageContent = ( uint8_t * ) ( input + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH ) ; //<S2SV> switch ( zrtpPacket -> messageType ) { //<S2SV> case MSGTYPE_HELLO : //<S2SV> { //<S2SV> bzrtpHelloMessage_t * messageData ; //<S2SV> messageData = ( bzrtpHelloMessage_t * ) malloc ( sizeof ( bzrtpHelloMessage_t ) ) ; //<S2SV> memcpy ( messageData -> version , messageContent , 4 ) ; //<S2SV> messageContent += 4 ; //<S2SV> memcpy ( messageData -> clientIdentifier , messageContent , 16 ) ; //<S2SV> messageContent += 16 ; //<S2SV> memcpy ( messageData -> H3 , messageContent , 32 ) ; //<S2SV> messageContent += 32 ; //<S2SV> memcpy ( messageData -> ZID , messageContent , 12 ) ; //<S2SV> messageContent += 12 ; //<S2SV> messageData -> S = ( ( * messageContent ) >> 6 ) & 0x01 ; //<S2SV> messageData -> M = ( ( * messageContent ) >> 5 ) & 0x01 ; //<S2SV> messageData -> P = ( ( * messageContent ) >> 4 ) & 0x01 ; //<S2SV> messageContent += 1 ; //<S2SV> messageData -> hc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; //<S2SV> messageContent += 1 ; //<S2SV> messageData -> cc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; //<S2SV> messageData -> ac = MIN ( ( * messageContent ) & 0x0F , 7 ) ; //<S2SV> messageContent += 1 ; //<S2SV> messageData -> kc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; //<S2SV> messageData -> sc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; //<S2SV> messageContent += 1 ; //<S2SV> if ( zrtpPacket -> messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4 * ( ( uint16_t ) ( messageData -> hc ) + ( uint16_t ) ( messageData -> cc ) + ( uint16_t ) ( messageData -> ac ) + ( uint16_t ) ( messageData -> kc ) + ( uint16_t ) ( messageData -> sc ) ) ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; //<S2SV> } //<S2SV> for ( i = 0 ; i < messageData -> hc ; i ++ ) { //<S2SV> messageData -> supportedHash [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < messageData -> cc ; i ++ ) { //<S2SV> messageData -> supportedCipher [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < messageData -> ac ; i ++ ) { //<S2SV> messageData -> supportedAuthTag [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < messageData -> kc ; i ++ ) { //<S2SV> messageData -> supportedKeyAgreement [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < messageData -> sc ; i ++ ) { //<S2SV> messageData -> supportedSas [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> } //<S2SV> addMandatoryCryptoTypesIfNeeded ( ZRTP_HASH_TYPE , messageData -> supportedHash , & messageData -> hc ) ; //<S2SV> addMandatoryCryptoTypesIfNeeded ( ZRTP_CIPHERBLOCK_TYPE , messageData -> supportedCipher , & messageData -> cc ) ; //<S2SV> addMandatoryCryptoTypesIfNeeded ( ZRTP_AUTHTAG_TYPE , messageData -> supportedAuthTag , & messageData -> ac ) ; //<S2SV> addMandatoryCryptoTypesIfNeeded ( ZRTP_KEYAGREEMENT_TYPE , messageData -> supportedKeyAgreement , & messageData -> kc ) ; //<S2SV> addMandatoryCryptoTypesIfNeeded ( ZRTP_SAS_TYPE , messageData -> supportedSas , & messageData -> sc ) ; //<S2SV> memcpy ( messageData -> MAC , messageContent , 8 ) ; //<S2SV> zrtpPacket -> messageData = ( void * ) messageData ; //<S2SV> zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; //<S2SV> memcpy ( zrtpPacket -> packetString , input , inputLength ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case MSGTYPE_HELLOACK : //<S2SV> { //<S2SV> if ( zrtpPacket -> messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH ) { //<S2SV> return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case MSGTYPE_COMMIT : //<S2SV> { //<S2SV> uint8_t checkH3 [ 32 ] ; //<S2SV> uint8_t checkMAC [ 32 ] ; //<S2SV> bzrtpHelloMessage_t * peerHelloMessageData ; //<S2SV> uint16_t variableLength = 0 ; //<S2SV> bzrtpCommitMessage_t * messageData ; //<S2SV> messageData = ( bzrtpCommitMessage_t * ) malloc ( sizeof ( bzrtpCommitMessage_t ) ) ; //<S2SV> memcpy ( messageData -> H2 , messageContent , 32 ) ; //<S2SV> messageContent += 32 ; //<S2SV> if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; //<S2SV> } //<S2SV> peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; //<S2SV> bctoolbox_sha256 ( messageData -> H2 , 32 , 32 , checkH3 ) ; //<S2SV> if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; //<S2SV> } //<S2SV> bctoolbox_hmacSha256 ( messageData -> H2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; //<S2SV> if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; //<S2SV> } //<S2SV> memcpy ( messageData -> ZID , messageContent , 12 ) ; //<S2SV> messageContent += 12 ; //<S2SV> messageData -> hashAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> messageData -> cipherAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> messageData -> authTagAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> messageData -> keyAgreementAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> switch ( messageData -> keyAgreementAlgo ) { //<S2SV> case ZRTP_KEYAGREEMENT_DH2k : //<S2SV> case ZRTP_KEYAGREEMENT_EC25 : //<S2SV> case ZRTP_KEYAGREEMENT_DH3k : //<S2SV> case ZRTP_KEYAGREEMENT_EC38 : //<S2SV> case ZRTP_KEYAGREEMENT_EC52 : //<S2SV> variableLength = 32 ; //<S2SV> break ; //<S2SV> case ZRTP_KEYAGREEMENT_Prsh : //<S2SV> variableLength = 24 ; //<S2SV> break ; //<S2SV> case ZRTP_KEYAGREEMENT_Mult : //<S2SV> variableLength = 16 ; //<S2SV> break ; //<S2SV> default : //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; //<S2SV> } //<S2SV> if ( zrtpPacket -> messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; //<S2SV> } //<S2SV> messageData -> sasAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; //<S2SV> messageContent += 4 ; //<S2SV> if ( ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) || ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) ) { //<S2SV> memcpy ( messageData -> nonce , messageContent , 16 ) ; //<S2SV> messageContent += 16 ; //<S2SV> if ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) { //<S2SV> memcpy ( messageData -> keyID , messageContent , 8 ) ; //<S2SV> messageContent += 8 ; //<S2SV> } //<S2SV> } else { //<S2SV> memcpy ( messageData -> hvi , messageContent , 32 ) ; //<S2SV> messageContent += 32 ; //<S2SV> } //<S2SV> memcpy ( messageData -> MAC , messageContent , 8 ) ; //<S2SV> zrtpPacket -> messageData = ( void * ) messageData ; //<S2SV> zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; //<S2SV> memcpy ( zrtpPacket -> packetString , input , inputLength ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case MSGTYPE_DHPART1 : //<S2SV> case MSGTYPE_DHPART2 : //<S2SV> { //<S2SV> bzrtpDHPartMessage_t * messageData ; //<S2SV> uint16_t pvLength = computeKeyAgreementPrivateValueLength ( zrtpChannelContext -> keyAgreementAlgo ) ; //<S2SV> if ( pvLength == 0 ) { //<S2SV> return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; //<S2SV> } //<S2SV> if ( zrtpPacket -> messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH + pvLength ) { //<S2SV> return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; //<S2SV> } //<S2SV> messageData = ( bzrtpDHPartMessage_t * ) malloc ( sizeof ( bzrtpDHPartMessage_t ) ) ; //<S2SV> messageData -> pv = ( uint8_t * ) malloc ( pvLength * sizeof ( uint8_t ) ) ; //<S2SV> memcpy ( messageData -> H1 , messageContent , 32 ) ; //<S2SV> messageContent += 32 ; //<S2SV> if ( zrtpChannelContext -> role == RESPONDER ) { //<S2SV> uint8_t checkH2 [ 32 ] ; //<S2SV> uint8_t checkMAC [ 32 ] ; //<S2SV> bzrtpCommitMessage_t * peerCommitMessageData ; //<S2SV> if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; //<S2SV> } //<S2SV> peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; //<S2SV> bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; //<S2SV> if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; //<S2SV> } //<S2SV> bctoolbox_hmacSha256 ( messageData -> H1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; //<S2SV> if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; //<S2SV> } //<S2SV> { //<S2SV> uint8_t computedHvi [ 32 ] ; //<S2SV> uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; //<S2SV> uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; //<S2SV> uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; //<S2SV> memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; //<S2SV> memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; //<S2SV> zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; //<S2SV> free ( DHPartHelloMessageString ) ; //<S2SV> if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> uint8_t checkH2 [ 32 ] ; //<S2SV> uint8_t checkH3 [ 32 ] ; //<S2SV> uint8_t checkMAC [ 32 ] ; //<S2SV> bzrtpHelloMessage_t * peerHelloMessageData ; //<S2SV> if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; //<S2SV> } //<S2SV> peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; //<S2SV> bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; //<S2SV> bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; //<S2SV> if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; //<S2SV> } //<S2SV> bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; //<S2SV> if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; //<S2SV> } //<S2SV> } //<S2SV> memcpy ( messageData -> rs1ID , messageContent , 8 ) ; //<S2SV> messageContent += 8 ; //<S2SV> memcpy ( messageData -> rs2ID , messageContent , 8 ) ; //<S2SV> messageContent += 8 ; //<S2SV> memcpy ( messageData -> auxsecretID , messageContent , 8 ) ; //<S2SV> messageContent += 8 ; //<S2SV> memcpy ( messageData -> pbxsecretID , messageContent , 8 ) ; //<S2SV> messageContent += 8 ; //<S2SV> memcpy ( messageData -> pv , messageContent , pvLength ) ; //<S2SV> messageContent += pvLength ; //<S2SV> memcpy ( messageData -> MAC , messageContent , 8 ) ; //<S2SV> zrtpPacket -> messageData = ( void * ) messageData ; //<S2SV> zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; //<S2SV> memcpy ( zrtpPacket -> packetString , input , inputLength ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case MSGTYPE_CONFIRM1 : //<S2SV> case MSGTYPE_CONFIRM2 : //<S2SV> { //<S2SV> uint8_t * confirmMessageKey = NULL ; //<S2SV> uint8_t * confirmMessageMacKey = NULL ; //<S2SV> bzrtpConfirmMessage_t * messageData ; //<S2SV> uint16_t cipherTextLength ; //<S2SV> uint8_t computedHmac [ 8 ] ; //<S2SV> uint8_t * confirmPlainMessageBuffer ; //<S2SV> uint8_t * confirmPlainMessage ; //<S2SV> if ( zrtpChannelContext -> role == RESPONDER ) { //<S2SV> if ( ( zrtpChannelContext -> zrtpkeyi == NULL ) || ( zrtpChannelContext -> mackeyi == NULL ) ) { //<S2SV> return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; //<S2SV> } //<S2SV> confirmMessageKey = zrtpChannelContext -> zrtpkeyi ; //<S2SV> confirmMessageMacKey = zrtpChannelContext -> mackeyi ; //<S2SV> } //<S2SV> if ( zrtpChannelContext -> role == INITIATOR ) { //<S2SV> if ( ( zrtpChannelContext -> zrtpkeyr == NULL ) || ( zrtpChannelContext -> mackeyr == NULL ) ) { //<S2SV> return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; //<S2SV> } //<S2SV> confirmMessageKey = zrtpChannelContext -> zrtpkeyr ; //<S2SV> confirmMessageMacKey = zrtpChannelContext -> mackeyr ; //<S2SV> } //<S2SV> messageData = ( bzrtpConfirmMessage_t * ) malloc ( sizeof ( bzrtpConfirmMessage_t ) ) ; //<S2SV> memcpy ( messageData -> confirm_mac , messageContent , 8 ) ; //<S2SV> messageContent += 8 ; //<S2SV> memcpy ( messageData -> CFBIV , messageContent , 16 ) ; //<S2SV> messageContent += 16 ; //<S2SV> cipherTextLength = zrtpPacket -> messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24 ; //<S2SV> zrtpChannelContext -> hmacFunction ( confirmMessageMacKey , zrtpChannelContext -> hashLength , messageContent , cipherTextLength , 8 , computedHmac ) ; //<S2SV> if ( memcmp ( computedHmac , messageData -> confirm_mac , 8 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC ; //<S2SV> } //<S2SV> confirmPlainMessageBuffer = ( uint8_t * ) malloc ( cipherTextLength * sizeof ( uint8_t ) ) ; //<S2SV> zrtpChannelContext -> cipherDecryptionFunction ( confirmMessageKey , messageData -> CFBIV , messageContent , cipherTextLength , confirmPlainMessageBuffer ) ; //<S2SV> confirmPlainMessage = confirmPlainMessageBuffer ; //<S2SV> memcpy ( messageData -> H0 , confirmPlainMessage , 32 ) ; //<S2SV> confirmPlainMessage += 33 ; //<S2SV> if ( zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) { //<S2SV> uint8_t checkH1 [ 32 ] ; //<S2SV> bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; //<S2SV> if ( zrtpChannelContext -> role == RESPONDER ) { //<S2SV> uint8_t checkH2 [ 32 ] ; //<S2SV> uint8_t checkMAC [ 32 ] ; //<S2SV> bzrtpCommitMessage_t * peerCommitMessageData ; //<S2SV> if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; //<S2SV> } //<S2SV> peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; //<S2SV> bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; //<S2SV> if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; //<S2SV> } //<S2SV> bctoolbox_hmacSha256 ( checkH1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; //<S2SV> if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; //<S2SV> } //<S2SV> } else { //<S2SV> uint8_t checkH2 [ 32 ] ; //<S2SV> uint8_t checkH3 [ 32 ] ; //<S2SV> uint8_t checkMAC [ 32 ] ; //<S2SV> bzrtpHelloMessage_t * peerHelloMessageData ; //<S2SV> if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; //<S2SV> } //<S2SV> peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; //<S2SV> bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; //<S2SV> bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; //<S2SV> if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; //<S2SV> } //<S2SV> bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; //<S2SV> if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> uint8_t checkH1 [ 32 ] ; //<S2SV> uint8_t checkMAC [ 32 ] ; //<S2SV> bzrtpDHPartMessage_t * peerDHPartMessageData ; //<S2SV> if ( zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] == NULL ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; //<S2SV> } //<S2SV> peerDHPartMessageData = ( bzrtpDHPartMessage_t * ) zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageData ; //<S2SV> bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; //<S2SV> if ( memcmp ( checkH1 , peerDHPartMessageData -> H1 , 32 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; //<S2SV> } //<S2SV> bctoolbox_hmacSha256 ( messageData -> H0 , 32 , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; //<S2SV> if ( memcmp ( checkMAC , peerDHPartMessageData -> MAC , 8 ) != 0 ) { //<S2SV> free ( messageData ) ; //<S2SV> return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; //<S2SV> } //<S2SV> } //<S2SV> messageData -> sig_len = ( ( uint16_t ) ( confirmPlainMessage [ 0 ] & 0x01 ) ) << 8 | ( ( ( uint16_t ) confirmPlainMessage [ 1 ] ) & 0x00FF ) ; //<S2SV> confirmPlainMessage += 2 ; //<S2SV> messageData -> E = ( ( * confirmPlainMessage ) & 0x08 ) >> 3 ; //<S2SV> messageData -> V = ( ( * confirmPlainMessage ) & 0x04 ) >> 2 ; //<S2SV> messageData -> A = ( ( * confirmPlainMessage ) & 0x02 ) >> 1 ; //<S2SV> messageData -> D = ( * confirmPlainMessage ) & 0x01 ; //<S2SV> confirmPlainMessage += 1 ; //<S2SV> messageData -> cacheExpirationInterval = ( ( ( uint32_t ) confirmPlainMessage [ 0 ] ) << 24 ) | ( ( ( uint32_t ) confirmPlainMessage [ 1 ] ) << 16 ) | ( ( ( uint32_t ) confirmPlainMessage [ 2 ] ) << 8 ) | ( ( uint32_t ) confirmPlainMessage [ 3 ] ) ; //<S2SV> confirmPlainMessage += 4 ; //<S2SV> if ( messageData -> sig_len > 0 ) { //<S2SV> memcpy ( messageData -> signatureBlockType , confirmPlainMessage , 4 ) ; //<S2SV> confirmPlainMessage += 4 ; //<S2SV> messageData -> signatureBlock = ( uint8_t * ) malloc ( 4 * ( messageData -> sig_len - 1 ) * sizeof ( uint8_t ) ) ; //<S2SV> memcpy ( messageData -> signatureBlock , confirmPlainMessage , 4 * ( messageData -> sig_len - 1 ) ) ; //<S2SV> } else { //<S2SV> messageData -> signatureBlock = NULL ; //<S2SV> } //<S2SV> free ( confirmPlainMessageBuffer ) ; //<S2SV> zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; //<S2SV> memcpy ( zrtpPacket -> packetString , input , inputLength ) ; //<S2SV> zrtpPacket -> messageData = ( void * ) messageData ; //<S2SV> } //<S2SV> break ; //<S2SV> case MSGTYPE_CONF2ACK : //<S2SV> break ; //<S2SV> case MSGTYPE_PING : //<S2SV> { //<S2SV> bzrtpPingMessage_t * messageData ; //<S2SV> messageData = ( bzrtpPingMessage_t * ) malloc ( sizeof ( bzrtpPingMessage_t ) ) ; //<S2SV> memcpy ( messageData -> version , messageContent , 4 ) ; //<S2SV> messageContent += 4 ; //<S2SV> memcpy ( messageData -> endpointHash , messageContent , 8 ) ; //<S2SV> zrtpPacket -> messageData = ( void * ) messageData ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 