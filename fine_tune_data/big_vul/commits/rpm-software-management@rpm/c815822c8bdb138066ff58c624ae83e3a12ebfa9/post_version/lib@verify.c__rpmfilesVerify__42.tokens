rpmVerifyAttrs rpmfilesVerify ( rpmfiles fi , int ix , rpmVerifyAttrs omitMask ) //<S2SV> { //<S2SV> rpm_mode_t fmode = rpmfilesFMode ( fi , ix ) ; //<S2SV> rpmfileAttrs fileAttrs = rpmfilesFFlags ( fi , ix ) ; //<S2SV> rpmVerifyAttrs flags = rpmfilesVFlags ( fi , ix ) ; //<S2SV> const char * fn = rpmfilesFN ( fi , ix ) ; //<S2SV> struct stat sb ; //<S2SV> rpmVerifyAttrs vfy = RPMVERIFY_NONE ; //<S2SV> switch ( rpmfilesFState ( fi , ix ) ) { //<S2SV> case RPMFILE_STATE_NETSHARED : //<S2SV> case RPMFILE_STATE_NOTINSTALLED : //<S2SV> goto exit ; //<S2SV> break ; //<S2SV> case RPMFILE_STATE_REPLACED : //<S2SV> flags = RPMVERIFY_LSTATFAIL ; //<S2SV> break ; //<S2SV> case RPMFILE_STATE_WRONGCOLOR : //<S2SV> flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | //<S2SV> RPMVERIFY_MTIME | RPMVERIFY_RDEV ) ; //<S2SV> break ; //<S2SV> case RPMFILE_STATE_NORMAL : //<S2SV> case RPMFILE_STATE_MISSING : //<S2SV> break ; //<S2SV> } //<S2SV> if ( fn == NULL || lstat ( fn , & sb ) != 0 ) { //<S2SV> vfy |= RPMVERIFY_LSTATFAIL ; //<S2SV> goto exit ; //<S2SV> } //<S2SV> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) ) { //<S2SV> struct stat dsb ; //<S2SV> if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { //<S2SV> uid_t fuid ; //<S2SV> if ( sb . st_uid == 0 || //<S2SV> ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && //<S2SV> sb . st_uid == fuid ) ) { //<S2SV> sb = dsb ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( S_ISLNK ( sb . st_mode ) ) //<S2SV> flags &= ~ ( RPMVERIFY_MODE ) ; //<S2SV> else //<S2SV> flags &= ~ ( RPMVERIFY_LINKTO ) ; //<S2SV> if ( ! S_ISREG ( sb . st_mode ) ) //<S2SV> flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | //<S2SV> RPMVERIFY_MTIME | RPMVERIFY_CAPS ) ; //<S2SV> if ( fileAttrs & RPMFILE_GHOST ) //<S2SV> flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | //<S2SV> RPMVERIFY_MTIME | RPMVERIFY_LINKTO ) ; //<S2SV> flags &= ~ ( omitMask | RPMVERIFY_FAILURES ) ; //<S2SV> if ( flags & RPMVERIFY_FILEDIGEST ) { //<S2SV> const unsigned char * digest ; //<S2SV> int algo ; //<S2SV> size_t diglen ; //<S2SV> if ( ( digest = rpmfilesFDigest ( fi , ix , & algo , & diglen ) ) ) { //<S2SV> unsigned char fdigest [ diglen ] ; //<S2SV> rpm_loff_t fsize ; //<S2SV> if ( rpmDoDigest ( algo , fn , 0 , fdigest , & fsize ) ) { //<S2SV> vfy |= ( RPMVERIFY_READFAIL | RPMVERIFY_FILEDIGEST ) ; //<S2SV> } else { //<S2SV> sb . st_size = fsize ; //<S2SV> if ( memcmp ( fdigest , digest , diglen ) ) //<S2SV> vfy |= RPMVERIFY_FILEDIGEST ; //<S2SV> } //<S2SV> } else { //<S2SV> vfy |= RPMVERIFY_FILEDIGEST ; //<S2SV> } //<S2SV> } //<S2SV> if ( flags & RPMVERIFY_LINKTO ) { //<S2SV> char linkto [ 1024 + 1 ] ; //<S2SV> int size = 0 ; //<S2SV> if ( ( size = readlink ( fn , linkto , sizeof ( linkto ) - 1 ) ) == - 1 ) //<S2SV> vfy |= ( RPMVERIFY_READLINKFAIL | RPMVERIFY_LINKTO ) ; //<S2SV> else { //<S2SV> const char * flink = rpmfilesFLink ( fi , ix ) ; //<S2SV> linkto [ size ] = '\\0' ; //<S2SV> if ( flink == NULL || ! rstreq ( linkto , flink ) ) //<S2SV> vfy |= RPMVERIFY_LINKTO ; //<S2SV> } //<S2SV> } //<S2SV> if ( flags & RPMVERIFY_FILESIZE ) { //<S2SV> if ( sb . st_size != rpmfilesFSize ( fi , ix ) ) //<S2SV> vfy |= RPMVERIFY_FILESIZE ; //<S2SV> } //<S2SV> if ( flags & RPMVERIFY_MODE ) { //<S2SV> rpm_mode_t metamode = fmode ; //<S2SV> rpm_mode_t filemode ; //<S2SV> filemode = ( rpm_mode_t ) sb . st_mode ; //<S2SV> if ( fileAttrs & RPMFILE_GHOST ) { //<S2SV> metamode &= ~ 0xf000 ; //<S2SV> filemode &= ~ 0xf000 ; //<S2SV> } //<S2SV> if ( metamode != filemode ) //<S2SV> vfy |= RPMVERIFY_MODE ; //<S2SV> # if WITH_ACL //<S2SV> acl_t facl = acl_get_file ( fn , ACL_TYPE_ACCESS ) ; //<S2SV> if ( facl ) { //<S2SV> if ( acl_equiv_mode ( facl , NULL ) == 1 ) { //<S2SV> vfy |= RPMVERIFY_MODE ; //<S2SV> } //<S2SV> acl_free ( facl ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> if ( flags & RPMVERIFY_RDEV ) { //<S2SV> if ( S_ISCHR ( fmode ) != S_ISCHR ( sb . st_mode ) //<S2SV> || S_ISBLK ( fmode ) != S_ISBLK ( sb . st_mode ) ) //<S2SV> { //<S2SV> vfy |= RPMVERIFY_RDEV ; //<S2SV> } else if ( S_ISDEV ( fmode ) && S_ISDEV ( sb . st_mode ) ) { //<S2SV> rpm_rdev_t st_rdev = ( sb . st_rdev & 0xffff ) ; //<S2SV> rpm_rdev_t frdev = ( rpmfilesFRdev ( fi , ix ) & 0xffff ) ; //<S2SV> if ( st_rdev != frdev ) //<S2SV> vfy |= RPMVERIFY_RDEV ; //<S2SV> } //<S2SV> } //<S2SV> # if WITH_CAP //<S2SV> if ( flags & RPMVERIFY_CAPS ) { //<S2SV> cap_t cap , fcap ; //<S2SV> cap = cap_from_text ( rpmfilesFCaps ( fi , ix ) ) ; //<S2SV> if ( ! cap ) { //<S2SV> cap = cap_from_text ( "=" ) ; //<S2SV> } //<S2SV> fcap = cap_get_file ( fn ) ; //<S2SV> if ( ! fcap ) { //<S2SV> fcap = cap_from_text ( "=" ) ; //<S2SV> } //<S2SV> if ( cap_compare ( cap , fcap ) != 0 ) //<S2SV> vfy |= RPMVERIFY_CAPS ; //<S2SV> cap_free ( fcap ) ; //<S2SV> cap_free ( cap ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ( flags & RPMVERIFY_MTIME ) && ( sb . st_mtime != rpmfilesFMtime ( fi , ix ) ) ) { //<S2SV> vfy |= RPMVERIFY_MTIME ; //<S2SV> } //<S2SV> if ( flags & RPMVERIFY_USER ) { //<S2SV> const char * name = rpmugUname ( sb . st_uid ) ; //<S2SV> const char * fuser = rpmfilesFUser ( fi , ix ) ; //<S2SV> uid_t uid ; //<S2SV> int namematch = 0 ; //<S2SV> int idmatch = 0 ; //<S2SV> if ( name && fuser ) //<S2SV> namematch = rstreq ( name , fuser ) ; //<S2SV> if ( fuser && rpmugUid ( fuser , & uid ) == 0 ) //<S2SV> idmatch = ( uid == sb . st_uid ) ; //<S2SV> if ( namematch != idmatch ) { //<S2SV> rpmlog ( RPMLOG_WARNING , //<S2SV> _ ( "Duplicate<S2SV_blank>username<S2SV_blank>or<S2SV_blank>UID<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s\\n" ) , fuser ) ; //<S2SV> } //<S2SV> if ( ! ( namematch || idmatch ) ) //<S2SV> vfy |= RPMVERIFY_USER ; //<S2SV> } //<S2SV> if ( flags & RPMVERIFY_GROUP ) { //<S2SV> const char * name = rpmugGname ( sb . st_gid ) ; //<S2SV> const char * fgroup = rpmfilesFGroup ( fi , ix ) ; //<S2SV> gid_t gid ; //<S2SV> int namematch = 0 ; //<S2SV> int idmatch = 0 ; //<S2SV> if ( name && fgroup ) //<S2SV> namematch = rstreq ( name , fgroup ) ; //<S2SV> if ( fgroup && rpmugGid ( fgroup , & gid ) == 0 ) //<S2SV> idmatch = ( gid == sb . st_gid ) ; //<S2SV> if ( namematch != idmatch ) { //<S2SV> rpmlog ( RPMLOG_WARNING , //<S2SV> _ ( "Duplicate<S2SV_blank>groupname<S2SV_blank>or<S2SV_blank>GID<S2SV_blank>for<S2SV_blank>group<S2SV_blank>%s\\n" ) , fgroup ) ; //<S2SV> } //<S2SV> if ( ! ( namematch || idmatch ) ) //<S2SV> vfy |= RPMVERIFY_GROUP ; //<S2SV> } //<S2SV> exit : //<S2SV> return vfy ; //<S2SV> } //<S2SV> 