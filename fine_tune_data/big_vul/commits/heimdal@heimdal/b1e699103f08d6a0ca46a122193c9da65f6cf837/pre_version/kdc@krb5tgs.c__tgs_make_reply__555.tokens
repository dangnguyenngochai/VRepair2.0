static krb5_error_code //<S2SV> tgs_make_reply ( krb5_context context , //<S2SV> krb5_kdc_configuration * config , //<S2SV> KDC_REQ_BODY * b , //<S2SV> krb5_const_principal tgt_name , //<S2SV> const EncTicketPart * tgt , //<S2SV> const krb5_keyblock * replykey , //<S2SV> int rk_is_subkey , //<S2SV> const EncryptionKey * serverkey , //<S2SV> const krb5_keyblock * sessionkey , //<S2SV> krb5_kvno kvno , //<S2SV> AuthorizationData * auth_data , //<S2SV> hdb_entry_ex * server , //<S2SV> krb5_principal server_principal , //<S2SV> const char * server_name , //<S2SV> hdb_entry_ex * client , //<S2SV> krb5_principal client_principal , //<S2SV> hdb_entry_ex * krbtgt , //<S2SV> krb5_enctype krbtgt_etype , //<S2SV> krb5_principals spp , //<S2SV> const krb5_data * rspac , //<S2SV> const METHOD_DATA * enc_pa_data , //<S2SV> const char * * e_text , //<S2SV> krb5_data * reply ) //<S2SV> { //<S2SV> KDC_REP rep ; //<S2SV> EncKDCRepPart ek ; //<S2SV> EncTicketPart et ; //<S2SV> KDCOptions f = b -> kdc_options ; //<S2SV> krb5_error_code ret ; //<S2SV> int is_weak = 0 ; //<S2SV> memset ( & rep , 0 , sizeof ( rep ) ) ; //<S2SV> memset ( & et , 0 , sizeof ( et ) ) ; //<S2SV> memset ( & ek , 0 , sizeof ( ek ) ) ; //<S2SV> rep . pvno = 5 ; //<S2SV> rep . msg_type = krb_tgs_rep ; //<S2SV> et . authtime = tgt -> authtime ; //<S2SV> _kdc_fix_time ( & b -> till ) ; //<S2SV> et . endtime = min ( tgt -> endtime , * b -> till ) ; //<S2SV> ALLOC ( et . starttime ) ; //<S2SV> * et . starttime = kdc_time ; //<S2SV> ret = check_tgs_flags ( context , config , b , tgt , & et ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> # define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) //<S2SV> # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) //<S2SV> # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) //<S2SV> # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 //<S2SV> # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 //<S2SV> ret = fix_transited_encoding ( context , config , //<S2SV> ! f . disable_transited_check || //<S2SV> GLOBAL_FORCE_TRANSITED_CHECK || //<S2SV> PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || //<S2SV> ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && //<S2SV> PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || //<S2SV> GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , //<S2SV> & tgt -> transited , & et , //<S2SV> krb5_principal_get_realm ( context , client_principal ) , //<S2SV> krb5_principal_get_realm ( context , server -> entry . principal ) , //<S2SV> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> copy_Realm ( & server_principal -> realm , & rep . ticket . realm ) ; //<S2SV> _krb5_principal2principalname ( & rep . ticket . sname , server_principal ) ; //<S2SV> copy_Realm ( & tgt_name -> realm , & rep . crealm ) ; //<S2SV> copy_PrincipalName ( & tgt_name -> name , & rep . cname ) ; //<S2SV> rep . ticket . tkt_vno = 5 ; //<S2SV> ek . caddr = et . caddr ; //<S2SV> { //<S2SV> time_t life ; //<S2SV> life = et . endtime - * et . starttime ; //<S2SV> if ( client && client -> entry . max_life ) //<S2SV> life = min ( life , * client -> entry . max_life ) ; //<S2SV> if ( server -> entry . max_life ) //<S2SV> life = min ( life , * server -> entry . max_life ) ; //<S2SV> et . endtime = * et . starttime + life ; //<S2SV> } //<S2SV> if ( f . renewable_ok && tgt -> flags . renewable && //<S2SV> et . renew_till == NULL && et . endtime < * b -> till && //<S2SV> tgt -> renew_till != NULL ) //<S2SV> { //<S2SV> et . flags . renewable = 1 ; //<S2SV> ALLOC ( et . renew_till ) ; //<S2SV> * et . renew_till = * b -> till ; //<S2SV> } //<S2SV> if ( et . renew_till ) { //<S2SV> time_t renew ; //<S2SV> renew = * et . renew_till - * et . starttime ; //<S2SV> if ( client && client -> entry . max_renew ) //<S2SV> renew = min ( renew , * client -> entry . max_renew ) ; //<S2SV> if ( server -> entry . max_renew ) //<S2SV> renew = min ( renew , * server -> entry . max_renew ) ; //<S2SV> * et . renew_till = * et . starttime + renew ; //<S2SV> } //<S2SV> if ( et . renew_till ) { //<S2SV> * et . renew_till = min ( * et . renew_till , * tgt -> renew_till ) ; //<S2SV> * et . starttime = min ( * et . starttime , * et . renew_till ) ; //<S2SV> et . endtime = min ( et . endtime , * et . renew_till ) ; //<S2SV> } //<S2SV> * et . starttime = min ( * et . starttime , et . endtime ) ; //<S2SV> if ( * et . starttime == et . endtime ) { //<S2SV> ret = KRB5KDC_ERR_NEVER_VALID ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( et . renew_till && et . endtime == * et . renew_till ) { //<S2SV> free ( et . renew_till ) ; //<S2SV> et . renew_till = NULL ; //<S2SV> et . flags . renewable = 0 ; //<S2SV> } //<S2SV> et . flags . pre_authent = tgt -> flags . pre_authent ; //<S2SV> et . flags . hw_authent = tgt -> flags . hw_authent ; //<S2SV> et . flags . anonymous = tgt -> flags . anonymous ; //<S2SV> et . flags . ok_as_delegate = server -> entry . flags . ok_as_delegate ; //<S2SV> if ( rspac -> length ) { //<S2SV> ret = _kdc_tkt_add_if_relevant_ad ( context , & et , //<S2SV> KRB5_AUTHDATA_WIN2K_PAC , rspac ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( auth_data ) { //<S2SV> unsigned int i = 0 ; //<S2SV> if ( et . authorization_data == NULL ) { //<S2SV> et . authorization_data = calloc ( 1 , sizeof ( * et . authorization_data ) ) ; //<S2SV> if ( et . authorization_data == NULL ) { //<S2SV> ret = ENOMEM ; //<S2SV> krb5_set_error_message ( context , ret , "malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < auth_data -> len ; i ++ ) { //<S2SV> ret = add_AuthorizationData ( et . authorization_data , & auth_data -> val [ i ] ) ; //<S2SV> if ( ret ) { //<S2SV> krb5_set_error_message ( context , ret , "malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> ret = find_KRB5SignedPath ( context , et . authorization_data , NULL ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> if ( et . authorization_data -> len == 1 ) { //<S2SV> free_AuthorizationData ( et . authorization_data ) ; //<S2SV> free ( et . authorization_data ) ; //<S2SV> et . authorization_data = NULL ; //<S2SV> } else { //<S2SV> AuthorizationData * ad = et . authorization_data ; //<S2SV> free_AuthorizationDataElement ( & ad -> val [ ad -> len - 1 ] ) ; //<S2SV> ad -> len -- ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ret = krb5_copy_keyblock_contents ( context , sessionkey , & et . key ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> et . crealm = tgt_name -> realm ; //<S2SV> et . cname = tgt_name -> name ; //<S2SV> ek . key = et . key ; //<S2SV> ek . last_req . val = calloc ( 1 , sizeof ( * ek . last_req . val ) ) ; //<S2SV> if ( ek . last_req . val == NULL ) { //<S2SV> ret = ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ek . last_req . len = 1 ; //<S2SV> ek . nonce = b -> nonce ; //<S2SV> ek . flags = et . flags ; //<S2SV> ek . authtime = et . authtime ; //<S2SV> ek . starttime = et . starttime ; //<S2SV> ek . endtime = et . endtime ; //<S2SV> ek . renew_till = et . renew_till ; //<S2SV> ek . srealm = rep . ticket . realm ; //<S2SV> ek . sname = rep . ticket . sname ; //<S2SV> _kdc_log_timestamp ( context , config , "TGS-REQ" , et . authtime , et . starttime , //<S2SV> et . endtime , et . renew_till ) ; //<S2SV> { //<S2SV> char * r = get_krbtgt_realm ( & ek . sname ) ; //<S2SV> if ( r == NULL || strcmp ( r , ek . srealm ) == 0 ) { //<S2SV> ret = _kdc_add_KRB5SignedPath ( context , //<S2SV> config , //<S2SV> krbtgt , //<S2SV> krbtgt_etype , //<S2SV> client_principal , //<S2SV> NULL , //<S2SV> spp , //<S2SV> & et ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> if ( enc_pa_data -> len ) { //<S2SV> rep . padata = calloc ( 1 , sizeof ( * rep . padata ) ) ; //<S2SV> if ( rep . padata == NULL ) { //<S2SV> ret = ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = copy_METHOD_DATA ( enc_pa_data , rep . padata ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( krb5_enctype_valid ( context , serverkey -> keytype ) != 0 //<S2SV> && _kdc_is_weak_exception ( server -> entry . principal , serverkey -> keytype ) ) //<S2SV> { //<S2SV> krb5_enctype_enable ( context , serverkey -> keytype ) ; //<S2SV> is_weak = 1 ; //<S2SV> } //<S2SV> ret = _kdc_encode_reply ( context , config , NULL , 0 , //<S2SV> & rep , & et , & ek , serverkey -> keytype , //<S2SV> kvno , //<S2SV> serverkey , 0 , replykey , rk_is_subkey , //<S2SV> e_text , reply ) ; //<S2SV> if ( is_weak ) //<S2SV> krb5_enctype_disable ( context , serverkey -> keytype ) ; //<S2SV> out : //<S2SV> free_TGS_REP ( & rep ) ; //<S2SV> free_TransitedEncoding ( & et . transited ) ; //<S2SV> if ( et . starttime ) //<S2SV> free ( et . starttime ) ; //<S2SV> if ( et . renew_till ) //<S2SV> free ( et . renew_till ) ; //<S2SV> if ( et . authorization_data ) { //<S2SV> free_AuthorizationData ( et . authorization_data ) ; //<S2SV> free ( et . authorization_data ) ; //<S2SV> } //<S2SV> free_LastReq ( & ek . last_req ) ; //<S2SV> memset ( et . key . keyvalue . data , 0 , et . key . keyvalue . length ) ; //<S2SV> free_EncryptionKey ( & et . key ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 