static krb5_error_code //<S2SV> tgs_build_reply ( krb5_context context , //<S2SV> krb5_kdc_configuration * config , //<S2SV> KDC_REQ * req , //<S2SV> KDC_REQ_BODY * b , //<S2SV> hdb_entry_ex * krbtgt , //<S2SV> krb5_enctype krbtgt_etype , //<S2SV> const krb5_keyblock * replykey , //<S2SV> int rk_is_subkey , //<S2SV> krb5_ticket * ticket , //<S2SV> krb5_data * reply , //<S2SV> const char * from , //<S2SV> const char * * e_text , //<S2SV> AuthorizationData * * auth_data , //<S2SV> const struct sockaddr * from_addr ) //<S2SV> { //<S2SV> krb5_error_code ret ; //<S2SV> krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; //<S2SV> krb5_principal krbtgt_out_principal = NULL ; //<S2SV> char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; //<S2SV> hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; //<S2SV> HDB * clientdb , * s4u2self_impersonated_clientdb ; //<S2SV> krb5_realm ref_realm = NULL ; //<S2SV> EncTicketPart * tgt = & ticket -> ticket ; //<S2SV> krb5_principals spp = NULL ; //<S2SV> const EncryptionKey * ekey ; //<S2SV> krb5_keyblock sessionkey ; //<S2SV> krb5_kvno kvno ; //<S2SV> krb5_data rspac ; //<S2SV> const char * our_realm = //<S2SV> krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; //<S2SV> char * * capath = NULL ; //<S2SV> size_t num_capath = 0 ; //<S2SV> hdb_entry_ex * krbtgt_out = NULL ; //<S2SV> METHOD_DATA enc_pa_data ; //<S2SV> PrincipalName * s ; //<S2SV> Realm r ; //<S2SV> EncTicketPart adtkt ; //<S2SV> char opt_str [ 128 ] ; //<S2SV> int signedpath = 0 ; //<S2SV> Key * tkey_check ; //<S2SV> Key * tkey_sign ; //<S2SV> int flags = HDB_F_FOR_TGS_REQ ; //<S2SV> memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; //<S2SV> memset ( & adtkt , 0 , sizeof ( adtkt ) ) ; //<S2SV> krb5_data_zero ( & rspac ) ; //<S2SV> memset ( & enc_pa_data , 0 , sizeof ( enc_pa_data ) ) ; //<S2SV> s = b -> sname ; //<S2SV> r = b -> realm ; //<S2SV> flags |= HDB_F_CANON ; //<S2SV> if ( b -> kdc_options . enc_tkt_in_skey ) { //<S2SV> Ticket * t ; //<S2SV> hdb_entry_ex * uu ; //<S2SV> krb5_principal p ; //<S2SV> Key * uukey ; //<S2SV> krb5uint32 second_kvno = 0 ; //<S2SV> krb5uint32 * kvno_ptr = NULL ; //<S2SV> if ( b -> additional_tickets == NULL || //<S2SV> b -> additional_tickets -> len == 0 ) { //<S2SV> ret = KRB5KDC_ERR_BADOPTION ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "No<S2SV_blank>second<S2SV_blank>ticket<S2SV_blank>present<S2SV_blank>in<S2SV_blank>request" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> t = & b -> additional_tickets -> val [ 0 ] ; //<S2SV> if ( ! get_krbtgt_realm ( & t -> sname ) ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Additional<S2SV_blank>ticket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>ticket-granting<S2SV_blank>ticket" ) ; //<S2SV> ret = KRB5KDC_ERR_POLICY ; //<S2SV> goto out ; //<S2SV> } //<S2SV> _krb5_principalname2krb5_principal ( context , & p , t -> sname , t -> realm ) ; //<S2SV> if ( t -> enc_part . kvno ) { //<S2SV> second_kvno = * t -> enc_part . kvno ; //<S2SV> kvno_ptr = & second_kvno ; //<S2SV> } //<S2SV> ret = _kdc_db_fetch ( context , config , p , //<S2SV> HDB_F_GET_KRBTGT , kvno_ptr , //<S2SV> NULL , & uu ) ; //<S2SV> krb5_free_principal ( context , p ) ; //<S2SV> if ( ret ) { //<S2SV> if ( ret == HDB_ERR_NOENTRY ) //<S2SV> ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = hdb_enctype2key ( context , & uu -> entry , NULL , //<S2SV> t -> enc_part . etype , & uukey ) ; //<S2SV> if ( ret ) { //<S2SV> _kdc_free_ent ( context , uu ) ; //<S2SV> ret = KRB5KDC_ERR_ETYPE_NOSUPP ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = krb5_decrypt_ticket ( context , t , & uukey -> key , & adtkt , 0 ) ; //<S2SV> _kdc_free_ent ( context , uu ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = verify_flags ( context , config , & adtkt , spn ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> s = & adtkt . cname ; //<S2SV> r = adtkt . crealm ; //<S2SV> } //<S2SV> _krb5_principalname2krb5_principal ( context , & sp , * s , r ) ; //<S2SV> ret = krb5_unparse_name ( context , sp , & spn ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> _krb5_principalname2krb5_principal ( context , & cp , tgt -> cname , tgt -> crealm ) ; //<S2SV> ret = krb5_unparse_name ( context , cp , & cpn ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> unparse_flags ( KDCOptions2int ( b -> kdc_options ) , //<S2SV> asn1_KDCOptions_units ( ) , //<S2SV> opt_str , sizeof ( opt_str ) ) ; //<S2SV> if ( * opt_str ) //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>[%s]" , //<S2SV> cpn , from , spn , opt_str ) ; //<S2SV> else //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "TGS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s" , cpn , from , spn ) ; //<S2SV> server_lookup : //<S2SV> ret = _kdc_db_fetch ( context , config , sp , HDB_F_GET_SERVER | flags , //<S2SV> NULL , NULL , & server ) ; //<S2SV> if ( ret == HDB_ERR_NOT_FOUND_HERE ) { //<S2SV> kdc_log ( context , config , 5 , "target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy" , sp ) ; //<S2SV> goto out ; //<S2SV> } else if ( ret == HDB_ERR_WRONG_REALM ) { //<S2SV> free ( ref_realm ) ; //<S2SV> ref_realm = strdup ( server -> entry . principal -> realm ) ; //<S2SV> if ( ref_realm == NULL ) { //<S2SV> ret = krb5_enomem ( context ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> kdc_log ( context , config , 5 , //<S2SV> "Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>" //<S2SV> "server<S2SV_blank>%s." , //<S2SV> ref_realm , spn ) ; //<S2SV> krb5_free_principal ( context , sp ) ; //<S2SV> sp = NULL ; //<S2SV> ret = krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , //<S2SV> ref_realm , NULL ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> free ( spn ) ; //<S2SV> spn = NULL ; //<S2SV> ret = krb5_unparse_name ( context , sp , & spn ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> goto server_lookup ; //<S2SV> } else if ( ret ) { //<S2SV> const char * new_rlm , * msg ; //<S2SV> Realm req_rlm ; //<S2SV> krb5_realm * realms ; //<S2SV> if ( ( req_rlm = get_krbtgt_realm ( & sp -> name ) ) != NULL ) { //<S2SV> if ( capath == NULL ) { //<S2SV> ret = _krb5_find_capath ( context , tgt -> crealm , our_realm , //<S2SV> req_rlm , TRUE , & capath , & num_capath ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> new_rlm = num_capath > 0 ? capath [ -- num_capath ] : NULL ; //<S2SV> if ( new_rlm ) { //<S2SV> kdc_log ( context , config , 5 , "krbtgt<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>" //<S2SV> "realm<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found,<S2SV_blank>trying<S2SV_blank>%s" , tgt -> crealm , //<S2SV> our_realm , req_rlm , new_rlm ) ; //<S2SV> free ( ref_realm ) ; //<S2SV> ref_realm = strdup ( new_rlm ) ; //<S2SV> if ( ref_realm == NULL ) { //<S2SV> ret = krb5_enomem ( context ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> krb5_free_principal ( context , sp ) ; //<S2SV> sp = NULL ; //<S2SV> krb5_make_principal ( context , & sp , r , //<S2SV> KRB5_TGS_NAME , ref_realm , NULL ) ; //<S2SV> free ( spn ) ; //<S2SV> spn = NULL ; //<S2SV> ret = krb5_unparse_name ( context , sp , & spn ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> goto server_lookup ; //<S2SV> } //<S2SV> } else if ( need_referral ( context , config , & b -> kdc_options , sp , & realms ) ) { //<S2SV> if ( strcmp ( realms [ 0 ] , sp -> realm ) != 0 ) { //<S2SV> kdc_log ( context , config , 5 , //<S2SV> "Returning<S2SV_blank>a<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>realm<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>" //<S2SV> "server<S2SV_blank>%s<S2SV_blank>that<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found" , //<S2SV> realms [ 0 ] , spn ) ; //<S2SV> krb5_free_principal ( context , sp ) ; //<S2SV> sp = NULL ; //<S2SV> krb5_make_principal ( context , & sp , r , KRB5_TGS_NAME , //<S2SV> realms [ 0 ] , NULL ) ; //<S2SV> free ( spn ) ; //<S2SV> spn = NULL ; //<S2SV> ret = krb5_unparse_name ( context , sp , & spn ) ; //<S2SV> if ( ret ) { //<S2SV> krb5_free_host_realm ( context , realms ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> free ( ref_realm ) ; //<S2SV> ref_realm = strdup ( realms [ 0 ] ) ; //<S2SV> krb5_free_host_realm ( context , realms ) ; //<S2SV> goto server_lookup ; //<S2SV> } //<S2SV> krb5_free_host_realm ( context , realms ) ; //<S2SV> } //<S2SV> msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Server<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s:<S2SV_blank>%s" , spn , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> if ( ret == HDB_ERR_NOENTRY ) //<S2SV> ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( b -> kdc_options . canonicalize ) //<S2SV> rsp = server -> entry . principal ; //<S2SV> else //<S2SV> rsp = sp ; //<S2SV> { //<S2SV> krb5_enctype etype ; //<S2SV> if ( b -> kdc_options . enc_tkt_in_skey ) { //<S2SV> size_t i ; //<S2SV> ekey = & adtkt . key ; //<S2SV> for ( i = 0 ; i < b -> etype . len ; i ++ ) //<S2SV> if ( b -> etype . val [ i ] == adtkt . key . keytype ) //<S2SV> break ; //<S2SV> if ( i == b -> etype . len ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Addition<S2SV_blank>ticket<S2SV_blank>have<S2SV_blank>not<S2SV_blank>matching<S2SV_blank>etypes" ) ; //<S2SV> krb5_clear_error_message ( context ) ; //<S2SV> ret = KRB5KDC_ERR_ETYPE_NOSUPP ; //<S2SV> goto out ; //<S2SV> } //<S2SV> etype = b -> etype . val [ i ] ; //<S2SV> kvno = 0 ; //<S2SV> } else { //<S2SV> Key * skey ; //<S2SV> ret = _kdc_find_etype ( context , //<S2SV> krb5_principal_is_krbtgt ( context , sp ) ? //<S2SV> config -> tgt_use_strongest_session_key : //<S2SV> config -> svc_use_strongest_session_key , FALSE , //<S2SV> server , b -> etype . val , b -> etype . len , & etype , //<S2SV> NULL ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>support<S2SV_blank>for<S2SV_blank>etypes" , spn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_get_preferred_key ( context , config , server , spn , //<S2SV> NULL , & skey ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Server<S2SV_blank>(%s)<S2SV_blank>has<S2SV_blank>no<S2SV_blank>supported<S2SV_blank>etypes" , spn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ekey = & skey -> key ; //<S2SV> kvno = server -> entry . kvno ; //<S2SV> } //<S2SV> ret = krb5_generate_random_keyblock ( context , etype , & sessionkey ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = hdb_enctype2key ( context , & krbtgt -> entry , NULL , //<S2SV> krbtgt_etype , & tkey_check ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>check" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = krb5_make_principal ( context , //<S2SV> & krbtgt_out_principal , //<S2SV> our_realm , //<S2SV> KRB5_TGS_NAME , //<S2SV> our_realm , //<S2SV> NULL ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>" //<S2SV> "authz-data<S2SV_blank>signatures" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = krb5_unparse_name ( context , krbtgt_out_principal , & krbtgt_out_n ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>krbtgt<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>object<S2SV_blank>for<S2SV_blank>" //<S2SV> "authz-data<S2SV_blank>signatures" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_db_fetch ( context , config , krbtgt_out_principal , //<S2SV> HDB_F_GET_KRBTGT , NULL , NULL , & krbtgt_out ) ; //<S2SV> if ( ret ) { //<S2SV> char * ktpn = NULL ; //<S2SV> ret = krb5_unparse_name ( context , krbtgt -> entry . principal , & ktpn ) ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "No<S2SV_blank>such<S2SV_blank>principal<S2SV_blank>%s<S2SV_blank>(needed<S2SV_blank>for<S2SV_blank>authz-data<S2SV_blank>signature<S2SV_blank>keys)<S2SV_blank>" //<S2SV> "while<S2SV_blank>processing<S2SV_blank>TGS-REQ<S2SV_blank>for<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>krbtg<S2SV_blank>%s" , //<S2SV> krbtgt_out_n , spn , ( ret == 0 ) ? ktpn : "<unknown>" ) ; //<S2SV> free ( ktpn ) ; //<S2SV> ret = KRB5KRB_AP_ERR_NOT_US ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( strcmp ( krb5_principal_get_realm ( context , server -> entry . principal ) , //<S2SV> krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ) != 0 ) { //<S2SV> char * ktpn ; //<S2SV> ret = krb5_unparse_name ( context , krbtgt_out -> entry . principal , & ktpn ) ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Request<S2SV_blank>with<S2SV_blank>wrong<S2SV_blank>krbtgt:<S2SV_blank>%s" , //<S2SV> ( ret == 0 ) ? ktpn : "<unknown>" ) ; //<S2SV> if ( ret == 0 ) //<S2SV> free ( ktpn ) ; //<S2SV> ret = KRB5KRB_AP_ERR_NOT_US ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_get_preferred_key ( context , config , krbtgt_out , krbtgt_out_n , //<S2SV> NULL , & tkey_sign ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = hdb_enctype2key ( context , & krbtgt_out -> entry , NULL , //<S2SV> tkey_sign -> key . keytype , & tkey_sign ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>key<S2SV_blank>for<S2SV_blank>krbtgt<S2SV_blank>PAC<S2SV_blank>signature" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_db_fetch ( context , config , cp , HDB_F_GET_CLIENT | flags , //<S2SV> NULL , & clientdb , & client ) ; //<S2SV> if ( ret == HDB_ERR_NOT_FOUND_HERE ) { //<S2SV> } else if ( ret ) { //<S2SV> const char * krbtgt_realm , * msg ; //<S2SV> krbtgt_realm = krb5_principal_get_realm ( context , krbtgt_out -> entry . principal ) ; //<S2SV> if ( strcmp ( krb5_principal_get_realm ( context , cp ) , krbtgt_realm ) == 0 ) { //<S2SV> if ( ret == HDB_ERR_NOENTRY ) //<S2SV> ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; //<S2SV> kdc_log ( context , config , 1 , "Client<S2SV_blank>no<S2SV_blank>longer<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s" , //<S2SV> cpn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 1 , "Client<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s" , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> } //<S2SV> ret = check_PAC ( context , config , cp , NULL , //<S2SV> client , server , krbtgt , //<S2SV> & tkey_check -> key , //<S2SV> ekey , & tkey_sign -> key , //<S2SV> tgt , & rspac , & signedpath ) ; //<S2SV> if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Verify<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s" , //<S2SV> spn , cpn , from , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = check_KRB5SignedPath ( context , //<S2SV> config , //<S2SV> krbtgt , //<S2SV> cp , //<S2SV> tgt , //<S2SV> & spp , //<S2SV> & signedpath ) ; //<S2SV> if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "KRB5SignedPath<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s" , //<S2SV> spn , cpn , from , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> tp = cp ; //<S2SV> tpn = cpn ; //<S2SV> if ( client ) { //<S2SV> const PA_DATA * sdata ; //<S2SV> int i = 0 ; //<S2SV> sdata = _kdc_find_padata ( req , & i , KRB5_PADATA_FOR_USER ) ; //<S2SV> if ( sdata ) { //<S2SV> krb5_crypto crypto ; //<S2SV> krb5_data datack ; //<S2SV> PA_S4U2Self self ; //<S2SV> const char * str ; //<S2SV> ret = decode_PA_S4U2Self ( sdata -> padata_value . data , //<S2SV> sdata -> padata_value . length , //<S2SV> & self , NULL ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>PA-S4U2Self" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _krb5_s4u2self_to_checksumdata ( context , & self , & datack ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = krb5_crypto_init ( context , & tgt -> key , 0 , & crypto ) ; //<S2SV> if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( context , ret ) ; //<S2SV> free_PA_S4U2Self ( & self ) ; //<S2SV> krb5_data_free ( & datack ) ; //<S2SV> kdc_log ( context , config , 0 , "krb5_crypto_init<S2SV_blank>failed:<S2SV_blank>%s" , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = krb5_verify_checksum ( context , //<S2SV> crypto , //<S2SV> KRB5_KU_OTHER_CKSUM , //<S2SV> datack . data , //<S2SV> datack . length , //<S2SV> & self . cksum ) ; //<S2SV> krb5_data_free ( & datack ) ; //<S2SV> krb5_crypto_destroy ( context , crypto ) ; //<S2SV> if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( context , ret ) ; //<S2SV> free_PA_S4U2Self ( & self ) ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "krb5_verify_checksum<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>S4U2Self:<S2SV_blank>%s" , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _krb5_principalname2krb5_principal ( context , //<S2SV> & tp , //<S2SV> self . name , //<S2SV> self . realm ) ; //<S2SV> free_PA_S4U2Self ( & self ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = krb5_unparse_name ( context , tp , & tpn ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> if ( rspac . data ) { //<S2SV> krb5_pac p = NULL ; //<S2SV> krb5_data_free ( & rspac ) ; //<S2SV> ret = _kdc_db_fetch ( context , config , tp , HDB_F_GET_CLIENT | flags , //<S2SV> NULL , & s4u2self_impersonated_clientdb , & s4u2self_impersonated_client ) ; //<S2SV> if ( ret ) { //<S2SV> const char * msg ; //<S2SV> if ( ret == HDB_ERR_NOENTRY ) //<S2SV> ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; //<S2SV> msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 1 , //<S2SV> "S2U4Self<S2SV_blank>principal<S2SV_blank>to<S2SV_blank>impersonate<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>database:<S2SV_blank>%s" , //<S2SV> tpn , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_pac_generate ( context , s4u2self_impersonated_client , & p ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , "PAC<S2SV_blank>generation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s" , //<S2SV> tpn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( p != NULL ) { //<S2SV> ret = _krb5_pac_sign ( context , p , ticket -> ticket . authtime , //<S2SV> s4u2self_impersonated_client -> entry . principal , //<S2SV> ekey , & tkey_sign -> key , //<S2SV> & rspac ) ; //<S2SV> krb5_pac_free ( context , p ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , "PAC<S2SV_blank>signing<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>--<S2SV_blank>%s" , //<S2SV> tpn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ret = check_s4u2self ( context , config , clientdb , client , sp ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , "S4U2Self:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>" //<S2SV> "to<S2SV_blank>impersonate<S2SV_blank>to<S2SV_blank>service<S2SV_blank>" //<S2SV> "(tried<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>service<S2SV_blank>%s)" , //<S2SV> cpn , tpn , spn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( client -> entry . flags . trusted_for_delegation ) { //<S2SV> str = "[forwardable]" ; //<S2SV> } else { //<S2SV> b -> kdc_options . forwardable = 0 ; //<S2SV> str = "" ; //<S2SV> } //<S2SV> kdc_log ( context , config , 0 , "s4u2self<S2SV_blank>%s<S2SV_blank>impersonating<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>" //<S2SV> "service<S2SV_blank>%s<S2SV_blank>%s" , cpn , tpn , spn , str ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( client != NULL //<S2SV> && b -> additional_tickets != NULL //<S2SV> && b -> additional_tickets -> len != 0 //<S2SV> && b -> kdc_options . enc_tkt_in_skey == 0 ) //<S2SV> { //<S2SV> int ad_signedpath = 0 ; //<S2SV> Key * clientkey ; //<S2SV> Ticket * t ; //<S2SV> if ( ! signedpath ) { //<S2SV> ret = KRB5KDC_ERR_BADOPTION ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Constrained<S2SV_blank>delegation<S2SV_blank>done<S2SV_blank>on<S2SV_blank>service<S2SV_blank>ticket<S2SV_blank>%s/%s" , //<S2SV> cpn , spn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> t = & b -> additional_tickets -> val [ 0 ] ; //<S2SV> ret = hdb_enctype2key ( context , & client -> entry , //<S2SV> hdb_kvno2keys ( context , & client -> entry , //<S2SV> t -> enc_part . kvno ? * t -> enc_part . kvno : 0 ) , //<S2SV> t -> enc_part . etype , & clientkey ) ; //<S2SV> if ( ret ) { //<S2SV> ret = KRB5KDC_ERR_ETYPE_NOSUPP ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = krb5_decrypt_ticket ( context , t , & clientkey -> key , & adtkt , 0 ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "failed<S2SV_blank>to<S2SV_blank>decrypt<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>" //<S2SV> "constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>" , cpn , spn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _krb5_principalname2krb5_principal ( context , //<S2SV> & tp , //<S2SV> adtkt . cname , //<S2SV> adtkt . crealm ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = krb5_unparse_name ( context , tp , & tpn ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = _krb5_principalname2krb5_principal ( context , //<S2SV> & dp , //<S2SV> t -> sname , //<S2SV> t -> realm ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = krb5_unparse_name ( context , dp , & dpn ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> if ( adtkt . flags . forwardable == 0 ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Missing<S2SV_blank>forwardable<S2SV_blank>flag<S2SV_blank>on<S2SV_blank>ticket<S2SV_blank>for<S2SV_blank>" //<S2SV> "constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>" , //<S2SV> cpn , dpn , tpn , spn ) ; //<S2SV> ret = KRB5KDC_ERR_BADOPTION ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = check_constrained_delegation ( context , config , clientdb , //<S2SV> client , server , sp ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "constrained<S2SV_blank>delegation<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>allowed" , //<S2SV> cpn , dpn , tpn , spn ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = verify_flags ( context , config , & adtkt , tpn ) ; //<S2SV> if ( ret ) { //<S2SV> goto out ; //<S2SV> } //<S2SV> krb5_data_free ( & rspac ) ; //<S2SV> ret = check_PAC ( context , config , tp , dp , //<S2SV> client , server , krbtgt , //<S2SV> & clientkey -> key , //<S2SV> ekey , & tkey_sign -> key , //<S2SV> & adtkt , & rspac , & ad_signedpath ) ; //<S2SV> if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Verify<S2SV_blank>delegated<S2SV_blank>PAC<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client" //<S2SV> "%s<S2SV_blank>(%s)<S2SV_blank>as<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%s" , //<S2SV> spn , cpn , dpn , tpn , from , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = check_KRB5SignedPath ( context , //<S2SV> config , //<S2SV> krbtgt , //<S2SV> cp , //<S2SV> & adtkt , //<S2SV> NULL , //<S2SV> & ad_signedpath ) ; //<S2SV> if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "KRB5SignedPath<S2SV_blank>check<S2SV_blank>from<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>" //<S2SV> "for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)" //<S2SV> "from<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%s" , //<S2SV> spn , tpn , dpn , cpn , from , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! ad_signedpath ) { //<S2SV> ret = KRB5KDC_ERR_BADOPTION ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Ticket<S2SV_blank>not<S2SV_blank>signed<S2SV_blank>with<S2SV_blank>PAC<S2SV_blank>nor<S2SV_blank>SignedPath<S2SV_blank>service<S2SV_blank>%s<S2SV_blank>failed<S2SV_blank>" //<S2SV> "for<S2SV_blank>delegation<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s<S2SV_blank>(%s)" //<S2SV> "from<S2SV_blank>%s" , //<S2SV> spn , tpn , dpn , cpn , from ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> kdc_log ( context , config , 0 , "constrained<S2SV_blank>delegation<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>" //<S2SV> "from<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s" , tpn , cpn , dpn , spn ) ; //<S2SV> } //<S2SV> ret = kdc_check_flags ( context , config , //<S2SV> client , cpn , //<S2SV> server , spn , //<S2SV> FALSE ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> if ( ( b -> kdc_options . validate || b -> kdc_options . renew ) && //<S2SV> ! krb5_principal_compare ( context , //<S2SV> krbtgt -> entry . principal , //<S2SV> server -> entry . principal ) ) { //<S2SV> kdc_log ( context , config , 0 , "Inconsistent<S2SV_blank>request." ) ; //<S2SV> ret = KRB5KDC_ERR_SERVER_NOMATCH ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! _kdc_check_addresses ( context , config , tgt -> caddr , from_addr ) ) { //<S2SV> ret = KRB5KRB_AP_ERR_BADADDR ; //<S2SV> kdc_log ( context , config , 0 , "Request<S2SV_blank>from<S2SV_blank>wrong<S2SV_blank>address" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ref_realm ) { //<S2SV> PA_DATA pa ; //<S2SV> krb5_crypto crypto ; //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Adding<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>to<S2SV_blank>%s" , ref_realm ) ; //<S2SV> ret = krb5_crypto_init ( context , & sessionkey , 0 , & crypto ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = build_server_referral ( context , config , crypto , ref_realm , //<S2SV> NULL , s , & pa . padata_value ) ; //<S2SV> krb5_crypto_destroy ( context , crypto ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Failed<S2SV_blank>building<S2SV_blank>server<S2SV_blank>referral" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> pa . padata_type = KRB5_PADATA_SERVER_REFERRAL ; //<S2SV> ret = add_METHOD_DATA ( & enc_pa_data , & pa ) ; //<S2SV> krb5_data_free ( & pa . padata_value ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Add<S2SV_blank>server<S2SV_blank>referral<S2SV_blank>METHOD-DATA<S2SV_blank>failed" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> ret = tgs_make_reply ( context , //<S2SV> config , //<S2SV> b , //<S2SV> tp , //<S2SV> tgt , //<S2SV> replykey , //<S2SV> rk_is_subkey , //<S2SV> ekey , //<S2SV> & sessionkey , //<S2SV> kvno , //<S2SV> * auth_data , //<S2SV> server , //<S2SV> rsp , //<S2SV> spn , //<S2SV> client , //<S2SV> cp , //<S2SV> krbtgt_out , //<S2SV> tkey_sign -> key . keytype , //<S2SV> spp , //<S2SV> & rspac , //<S2SV> & enc_pa_data , //<S2SV> e_text , //<S2SV> reply ) ; //<S2SV> out : //<S2SV> if ( tpn != cpn ) //<S2SV> free ( tpn ) ; //<S2SV> free ( spn ) ; //<S2SV> free ( cpn ) ; //<S2SV> free ( dpn ) ; //<S2SV> free ( krbtgt_out_n ) ; //<S2SV> _krb5_free_capath ( context , capath ) ; //<S2SV> krb5_data_free ( & rspac ) ; //<S2SV> krb5_free_keyblock_contents ( context , & sessionkey ) ; //<S2SV> if ( krbtgt_out ) //<S2SV> _kdc_free_ent ( context , krbtgt_out ) ; //<S2SV> if ( server ) //<S2SV> _kdc_free_ent ( context , server ) ; //<S2SV> if ( client ) //<S2SV> _kdc_free_ent ( context , client ) ; //<S2SV> if ( s4u2self_impersonated_client ) //<S2SV> _kdc_free_ent ( context , s4u2self_impersonated_client ) ; //<S2SV> if ( tp && tp != cp ) //<S2SV> krb5_free_principal ( context , tp ) ; //<S2SV> krb5_free_principal ( context , cp ) ; //<S2SV> krb5_free_principal ( context , dp ) ; //<S2SV> krb5_free_principal ( context , sp ) ; //<S2SV> krb5_free_principal ( context , krbtgt_out_principal ) ; //<S2SV> free ( ref_realm ) ; //<S2SV> free_METHOD_DATA ( & enc_pa_data ) ; //<S2SV> free_EncTicketPart ( & adtkt ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 