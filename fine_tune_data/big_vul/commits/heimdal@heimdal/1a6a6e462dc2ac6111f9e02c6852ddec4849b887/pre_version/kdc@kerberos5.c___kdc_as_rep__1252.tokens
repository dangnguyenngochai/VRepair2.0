krb5_error_code //<S2SV> _kdc_as_rep ( kdc_request_t r , //<S2SV> krb5_data * reply , //<S2SV> const char * from , //<S2SV> struct sockaddr * from_addr , //<S2SV> int datagram_reply ) //<S2SV> { //<S2SV> krb5_context context = r -> context ; //<S2SV> krb5_kdc_configuration * config = r -> config ; //<S2SV> KDC_REQ * req = & r -> req ; //<S2SV> KDC_REQ_BODY * b = NULL ; //<S2SV> AS_REP rep ; //<S2SV> KDCOptions f ; //<S2SV> krb5_enctype setype ; //<S2SV> krb5_error_code ret = 0 ; //<S2SV> Key * skey ; //<S2SV> int found_pa = 0 ; //<S2SV> int i , flags = HDB_F_FOR_AS_REQ ; //<S2SV> METHOD_DATA error_method ; //<S2SV> const PA_DATA * pa ; //<S2SV> memset ( & rep , 0 , sizeof ( rep ) ) ; //<S2SV> error_method . len = 0 ; //<S2SV> error_method . val = NULL ; //<S2SV> ret = _kdc_fast_unwrap_request ( r ) ; //<S2SV> if ( ret ) { //<S2SV> _kdc_r_log ( r , 0 , "FAST<S2SV_blank>unwrap<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%d" , from , ret ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> b = & req -> req_body ; //<S2SV> f = b -> kdc_options ; //<S2SV> if ( f . canonicalize ) //<S2SV> flags |= HDB_F_CANON ; //<S2SV> if ( b -> sname == NULL ) { //<S2SV> ret = KRB5KRB_ERR_GENERIC ; //<S2SV> _kdc_set_e_text ( r , "No<S2SV_blank>server<S2SV_blank>in<S2SV_blank>request" ) ; //<S2SV> } else { //<S2SV> ret = _krb5_principalname2krb5_principal ( context , //<S2SV> & r -> server_princ , //<S2SV> * ( b -> sname ) , //<S2SV> b -> realm ) ; //<S2SV> if ( ret == 0 ) //<S2SV> ret = krb5_unparse_name ( context , r -> server_princ , & r -> server_name ) ; //<S2SV> } //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "AS-REQ<S2SV_blank>malformed<S2SV_blank>server<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s" , from ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( b -> cname == NULL ) { //<S2SV> ret = KRB5KRB_ERR_GENERIC ; //<S2SV> _kdc_set_e_text ( r , "No<S2SV_blank>client<S2SV_blank>in<S2SV_blank>request" ) ; //<S2SV> } else { //<S2SV> ret = _krb5_principalname2krb5_principal ( context , //<S2SV> & r -> client_princ , //<S2SV> * ( b -> cname ) , //<S2SV> b -> realm ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = krb5_unparse_name ( context , r -> client_princ , & r -> client_name ) ; //<S2SV> } //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "AS-REQ<S2SV_blank>malformed<S2SV_blank>client<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s" , from ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> kdc_log ( context , config , 0 , "AS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s" , //<S2SV> r -> client_name , from , r -> server_name ) ; //<S2SV> if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { //<S2SV> if ( ! _kdc_is_anon_request ( b ) ) { //<S2SV> kdc_log ( context , config , 0 , "Anonymous<S2SV_blank>ticket<S2SV_blank>w/o<S2SV_blank>anonymous<S2SV_blank>flag" ) ; //<S2SV> ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } else if ( _kdc_is_anon_request ( b ) ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Request<S2SV_blank>for<S2SV_blank>a<S2SV_blank>anonymous<S2SV_blank>ticket<S2SV_blank>with<S2SV_blank>non<S2SV_blank>" //<S2SV> "anonymous<S2SV_blank>client<S2SV_blank>name:<S2SV_blank>%s" , r -> client_name ) ; //<S2SV> ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_db_fetch ( context , config , r -> client_princ , //<S2SV> HDB_F_GET_CLIENT | flags , NULL , //<S2SV> & r -> clientdb , & r -> client ) ; //<S2SV> if ( ret == HDB_ERR_NOT_FOUND_HERE ) { //<S2SV> kdc_log ( context , config , 5 , "client<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy" , //<S2SV> r -> client_name ) ; //<S2SV> goto out ; //<S2SV> } else if ( ret == HDB_ERR_WRONG_REALM ) { //<S2SV> char * fixed_client_name = NULL ; //<S2SV> ret = krb5_unparse_name ( context , r -> client -> entry . principal , //<S2SV> & fixed_client_name ) ; //<S2SV> if ( ret ) { //<S2SV> goto out ; //<S2SV> } //<S2SV> kdc_log ( context , config , 0 , "WRONG_REALM<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s" , //<S2SV> r -> client_name , fixed_client_name ) ; //<S2SV> free ( fixed_client_name ) ; //<S2SV> ret = _kdc_fast_mk_error ( context , r , //<S2SV> & error_method , //<S2SV> r -> armor_crypto , //<S2SV> & req -> req_body , //<S2SV> KRB5_KDC_ERR_WRONG_REALM , //<S2SV> NULL , //<S2SV> r -> server_princ , //<S2SV> NULL , //<S2SV> & r -> client -> entry . principal -> realm , //<S2SV> NULL , NULL , //<S2SV> reply ) ; //<S2SV> goto out ; //<S2SV> } else if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 0 , "UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s" , r -> client_name , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_db_fetch ( context , config , r -> server_princ , //<S2SV> HDB_F_GET_SERVER | HDB_F_GET_KRBTGT | flags , //<S2SV> NULL , NULL , & r -> server ) ; //<S2SV> if ( ret == HDB_ERR_NOT_FOUND_HERE ) { //<S2SV> kdc_log ( context , config , 5 , "target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy" , //<S2SV> r -> server_name ) ; //<S2SV> goto out ; //<S2SV> } else if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( context , ret ) ; //<S2SV> kdc_log ( context , config , 0 , "UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s" , r -> server_name , msg ) ; //<S2SV> krb5_free_error_message ( context , msg ) ; //<S2SV> ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_find_etype ( context , //<S2SV> krb5_principal_is_krbtgt ( context , r -> server_princ ) ? //<S2SV> config -> tgt_use_strongest_session_key : //<S2SV> config -> svc_use_strongest_session_key , FALSE , //<S2SV> r -> client , b -> etype . val , b -> etype . len , & r -> sessionetype , //<S2SV> NULL ) ; //<S2SV> if ( ret ) { //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "Client<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>common<S2SV_blank>enctypes<S2SV_blank>with<S2SV_blank>KDC<S2SV_blank>" //<S2SV> "to<S2SV_blank>use<S2SV_blank>for<S2SV_blank>the<S2SV_blank>session<S2SV_blank>key" , //<S2SV> r -> client_name , from ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( req -> padata ) { //<S2SV> unsigned int n ; //<S2SV> log_patypes ( context , config , req -> padata ) ; //<S2SV> for ( n = 0 ; ! found_pa && n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { //<S2SV> if ( pat [ n ] . validate == NULL ) //<S2SV> continue ; //<S2SV> if ( r -> armor_crypto == NULL && ( pat [ n ] . flags & PA_REQ_FAST ) ) //<S2SV> continue ; //<S2SV> kdc_log ( context , config , 5 , //<S2SV> "Looking<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>pa-data<S2SV_blank>--<S2SV_blank>%s" , pat [ n ] . name , r -> client_name ) ; //<S2SV> i = 0 ; //<S2SV> pa = _kdc_find_padata ( req , & i , pat [ n ] . type ) ; //<S2SV> if ( pa ) { //<S2SV> ret = pat [ n ] . validate ( r , pa ) ; //<S2SV> if ( ret != 0 ) { //<S2SV> goto out ; //<S2SV> } //<S2SV> kdc_log ( context , config , 0 , //<S2SV> "%s<S2SV_blank>pre-authentication<S2SV_blank>succeeded<S2SV_blank>--<S2SV_blank>%s" , //<S2SV> pat [ n ] . name , r -> client_name ) ; //<S2SV> found_pa = 1 ; //<S2SV> r -> et . flags . pre_authent = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( found_pa == 0 ) { //<S2SV> Key * ckey = NULL ; //<S2SV> size_t n ; //<S2SV> for ( n = 0 ; n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { //<S2SV> if ( ( pat [ n ] . flags & PA_ANNOUNCE ) == 0 ) //<S2SV> continue ; //<S2SV> ret = krb5_padata_add ( context , & error_method , //<S2SV> pat [ n ] . type , NULL , 0 ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = _kdc_find_etype ( context , //<S2SV> config -> preauth_use_strongest_session_key , TRUE , //<S2SV> r -> client , b -> etype . val , b -> etype . len , NULL , & ckey ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> if ( older_enctype ( ckey -> key . keytype ) ) { //<S2SV> ret = get_pa_etype_info ( context , config , //<S2SV> & error_method , ckey ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = get_pa_etype_info2 ( context , config , //<S2SV> & error_method , ckey ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( require_preauth_p ( r ) || _kdc_is_anon_request ( b ) ) { //<S2SV> ret = KRB5KDC_ERR_PREAUTH_REQUIRED ; //<S2SV> _kdc_set_e_text ( r , "Need<S2SV_blank>to<S2SV_blank>use<S2SV_blank>PA-ENC-TIMESTAMP/PA-PK-AS-REQ" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ckey == NULL ) { //<S2SV> ret = KRB5KDC_ERR_CLIENT_NOTYET ; //<S2SV> _kdc_set_e_text ( r , "Doesn\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>client<S2SV_blank>key<S2SV_blank>available" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; //<S2SV> ret = krb5_copy_keyblock_contents ( r -> context , & ckey -> key , & r -> reply_key ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( r -> clientdb -> hdb_auth_status ) { //<S2SV> r -> clientdb -> hdb_auth_status ( context , r -> clientdb , r -> client , //<S2SV> HDB_AUTH_SUCCESS ) ; //<S2SV> } //<S2SV> ret = _kdc_check_access ( context , config , r -> client , r -> client_name , //<S2SV> r -> server , r -> server_name , //<S2SV> req , & error_method ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = _kdc_get_preferred_key ( context , config , //<S2SV> r -> server , r -> server_name , //<S2SV> & setype , & skey ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> if ( f . renew || f . validate || f . proxy || f . forwarded || f . enc_tkt_in_skey //<S2SV> || ( _kdc_is_anon_request ( b ) && ! config -> allow_anonymous ) ) { //<S2SV> ret = KRB5KDC_ERR_BADOPTION ; //<S2SV> _kdc_set_e_text ( r , "Bad<S2SV_blank>KDC<S2SV_blank>options" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> rep . pvno = 5 ; //<S2SV> rep . msg_type = krb_as_rep ; //<S2SV> if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { //<S2SV> Realm anon_realm = KRB5_ANON_REALM ; //<S2SV> ret = copy_Realm ( & anon_realm , & rep . crealm ) ; //<S2SV> } else //<S2SV> ret = copy_Realm ( & r -> client -> entry . principal -> realm , & rep . crealm ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = _krb5_principal2principalname ( & rep . cname , r -> client -> entry . principal ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> rep . ticket . tkt_vno = 5 ; //<S2SV> ret = copy_Realm ( & r -> server -> entry . principal -> realm , & rep . ticket . realm ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> _krb5_principal2principalname ( & rep . ticket . sname , //<S2SV> r -> server -> entry . principal ) ; //<S2SV> # define CNT ( sp , t ) ( ( ( sp ) -> sname -> name_type ) == KRB5_NT_ ## t ) //<S2SV> if ( CNT ( b , UNKNOWN ) || CNT ( b , PRINCIPAL ) || CNT ( b , SRV_INST ) || CNT ( b , SRV_HST ) || CNT ( b , SRV_XHST ) ) //<S2SV> rep . ticket . sname . name_type = b -> sname -> name_type ; //<S2SV> # undef CNT //<S2SV> r -> et . flags . initial = 1 ; //<S2SV> if ( r -> client -> entry . flags . forwardable && r -> server -> entry . flags . forwardable ) //<S2SV> r -> et . flags . forwardable = f . forwardable ; //<S2SV> else if ( f . forwardable ) { //<S2SV> _kdc_set_e_text ( r , "Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>forwardable" ) ; //<S2SV> ret = KRB5KDC_ERR_POLICY ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( r -> client -> entry . flags . proxiable && r -> server -> entry . flags . proxiable ) //<S2SV> r -> et . flags . proxiable = f . proxiable ; //<S2SV> else if ( f . proxiable ) { //<S2SV> _kdc_set_e_text ( r , "Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>proxiable" ) ; //<S2SV> ret = KRB5KDC_ERR_POLICY ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( r -> client -> entry . flags . postdate && r -> server -> entry . flags . postdate ) //<S2SV> r -> et . flags . may_postdate = f . allow_postdate ; //<S2SV> else if ( f . allow_postdate ) { //<S2SV> _kdc_set_e_text ( r , "Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>postdate" ) ; //<S2SV> ret = KRB5KDC_ERR_POLICY ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! _kdc_check_addresses ( context , config , b -> addresses , from_addr ) ) { //<S2SV> _kdc_set_e_text ( r , "Bad<S2SV_blank>address<S2SV_blank>list<S2SV_blank>in<S2SV_blank>requested" ) ; //<S2SV> ret = KRB5KRB_AP_ERR_BADADDR ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = copy_PrincipalName ( & rep . cname , & r -> et . cname ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = copy_Realm ( & rep . crealm , & r -> et . crealm ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> { //<S2SV> time_t start ; //<S2SV> time_t t ; //<S2SV> start = r -> et . authtime = kdc_time ; //<S2SV> if ( f . postdated && req -> req_body . from ) { //<S2SV> ALLOC ( r -> et . starttime ) ; //<S2SV> start = * r -> et . starttime = * req -> req_body . from ; //<S2SV> r -> et . flags . invalid = 1 ; //<S2SV> r -> et . flags . postdated = 1 ; //<S2SV> } //<S2SV> _kdc_fix_time ( & b -> till ) ; //<S2SV> t = * b -> till ; //<S2SV> if ( r -> client -> entry . max_life ) //<S2SV> t = start + min ( t - start , * r -> client -> entry . max_life ) ; //<S2SV> if ( r -> server -> entry . max_life ) //<S2SV> t = start + min ( t - start , * r -> server -> entry . max_life ) ; //<S2SV> # if 0 //<S2SV> t = min ( t , start + realm -> max_life ) ; //<S2SV> # endif //<S2SV> r -> et . endtime = t ; //<S2SV> if ( f . renewable_ok && r -> et . endtime < * b -> till ) { //<S2SV> f . renewable = 1 ; //<S2SV> if ( b -> rtime == NULL ) { //<S2SV> ALLOC ( b -> rtime ) ; //<S2SV> * b -> rtime = 0 ; //<S2SV> } //<S2SV> if ( * b -> rtime < * b -> till ) //<S2SV> * b -> rtime = * b -> till ; //<S2SV> } //<S2SV> if ( f . renewable && b -> rtime ) { //<S2SV> t = * b -> rtime ; //<S2SV> if ( t == 0 ) //<S2SV> t = MAX_TIME ; //<S2SV> if ( r -> client -> entry . max_renew ) //<S2SV> t = start + min ( t - start , * r -> client -> entry . max_renew ) ; //<S2SV> if ( r -> server -> entry . max_renew ) //<S2SV> t = start + min ( t - start , * r -> server -> entry . max_renew ) ; //<S2SV> # if 0 //<S2SV> t = min ( t , start + realm -> max_renew ) ; //<S2SV> # endif //<S2SV> ALLOC ( r -> et . renew_till ) ; //<S2SV> * r -> et . renew_till = t ; //<S2SV> r -> et . flags . renewable = 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( _kdc_is_anon_request ( b ) ) //<S2SV> r -> et . flags . anonymous = 1 ; //<S2SV> if ( b -> addresses ) { //<S2SV> ALLOC ( r -> et . caddr ) ; //<S2SV> copy_HostAddresses ( b -> addresses , r -> et . caddr ) ; //<S2SV> } //<S2SV> r -> et . transited . tr_type = DOMAIN_X500_COMPRESS ; //<S2SV> krb5_data_zero ( & r -> et . transited . contents ) ; //<S2SV> r -> ek . last_req . val = malloc ( 2 * sizeof ( * r -> ek . last_req . val ) ) ; //<S2SV> if ( r -> ek . last_req . val == NULL ) { //<S2SV> ret = ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> r -> ek . last_req . len = 0 ; //<S2SV> if ( r -> client -> entry . pw_end //<S2SV> && ( config -> kdc_warn_pwexpire == 0 //<S2SV> || kdc_time + config -> kdc_warn_pwexpire >= * r -> client -> entry . pw_end ) ) { //<S2SV> r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_PW_EXPTIME ; //<S2SV> r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . pw_end ; //<S2SV> ++ r -> ek . last_req . len ; //<S2SV> } //<S2SV> if ( r -> client -> entry . valid_end ) { //<S2SV> r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_ACCT_EXPTIME ; //<S2SV> r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . valid_end ; //<S2SV> ++ r -> ek . last_req . len ; //<S2SV> } //<S2SV> if ( r -> ek . last_req . len == 0 ) { //<S2SV> r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_NONE ; //<S2SV> r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = 0 ; //<S2SV> ++ r -> ek . last_req . len ; //<S2SV> } //<S2SV> r -> ek . nonce = b -> nonce ; //<S2SV> if ( r -> client -> entry . valid_end || r -> client -> entry . pw_end ) { //<S2SV> ALLOC ( r -> ek . key_expiration ) ; //<S2SV> if ( r -> client -> entry . valid_end ) { //<S2SV> if ( r -> client -> entry . pw_end ) //<S2SV> * r -> ek . key_expiration = min ( * r -> client -> entry . valid_end , //<S2SV> * r -> client -> entry . pw_end ) ; //<S2SV> else //<S2SV> * r -> ek . key_expiration = * r -> client -> entry . valid_end ; //<S2SV> } else //<S2SV> * r -> ek . key_expiration = * r -> client -> entry . pw_end ; //<S2SV> } else //<S2SV> r -> ek . key_expiration = NULL ; //<S2SV> r -> ek . flags = r -> et . flags ; //<S2SV> r -> ek . authtime = r -> et . authtime ; //<S2SV> if ( r -> et . starttime ) { //<S2SV> ALLOC ( r -> ek . starttime ) ; //<S2SV> * r -> ek . starttime = * r -> et . starttime ; //<S2SV> } //<S2SV> r -> ek . endtime = r -> et . endtime ; //<S2SV> if ( r -> et . renew_till ) { //<S2SV> ALLOC ( r -> ek . renew_till ) ; //<S2SV> * r -> ek . renew_till = * r -> et . renew_till ; //<S2SV> } //<S2SV> ret = copy_Realm ( & rep . ticket . realm , & r -> ek . srealm ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = copy_PrincipalName ( & rep . ticket . sname , & r -> ek . sname ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> if ( r -> et . caddr ) { //<S2SV> ALLOC ( r -> ek . caddr ) ; //<S2SV> copy_HostAddresses ( r -> et . caddr , r -> ek . caddr ) ; //<S2SV> } //<S2SV> if ( r -> session_key . keytype == ETYPE_NULL ) { //<S2SV> ret = krb5_generate_random_keyblock ( context , r -> sessionetype , & r -> session_key ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( r -> reply_key . keytype == ETYPE_NULL ) { //<S2SV> _kdc_set_e_text ( r , "Client<S2SV_blank>have<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>key" ) ; //<S2SV> ret = KRB5KDC_ERR_CLIENT_NOTYET ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = copy_EncryptionKey ( & r -> session_key , & r -> et . key ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> ret = copy_EncryptionKey ( & r -> session_key , & r -> ek . key ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> if ( r -> outpadata . len ) { //<S2SV> ALLOC ( rep . padata ) ; //<S2SV> if ( rep . padata == NULL ) { //<S2SV> ret = ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = copy_METHOD_DATA ( & r -> outpadata , rep . padata ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( send_pac_p ( context , req ) ) { //<S2SV> generate_pac ( r , skey ) ; //<S2SV> } //<S2SV> _kdc_log_timestamp ( context , config , "AS-REQ" , r -> et . authtime , r -> et . starttime , //<S2SV> r -> et . endtime , r -> et . renew_till ) ; //<S2SV> ret = _kdc_add_KRB5SignedPath ( context , //<S2SV> config , //<S2SV> r -> server , //<S2SV> setype , //<S2SV> r -> client -> entry . principal , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> & r -> et ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> log_as_req ( context , config , r -> reply_key . keytype , setype , b ) ; //<S2SV> r -> et . flags . enc_pa_rep = r -> ek . flags . enc_pa_rep = 1 ; //<S2SV> i = 0 ; //<S2SV> pa = _kdc_find_padata ( req , & i , KRB5_PADATA_REQ_ENC_PA_REP ) ; //<S2SV> if ( pa ) { //<S2SV> ret = add_enc_pa_rep ( r ) ; //<S2SV> if ( ret ) { //<S2SV> const char * msg = krb5_get_error_message ( r -> context , ret ) ; //<S2SV> _kdc_r_log ( r , 0 , "add_enc_pa_rep<S2SV_blank>failed:<S2SV_blank>%s:<S2SV_blank>%d" , msg , ret ) ; //<S2SV> krb5_free_error_message ( r -> context , msg ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> ret = _kdc_encode_reply ( context , config , //<S2SV> r -> armor_crypto , req -> req_body . nonce , //<S2SV> & rep , & r -> et , & r -> ek , setype , r -> server -> entry . kvno , //<S2SV> & skey -> key , r -> client -> entry . kvno , //<S2SV> & r -> reply_key , 0 , & r -> e_text , reply ) ; //<S2SV> if ( ret ) //<S2SV> goto out ; //<S2SV> if ( datagram_reply && reply -> length > config -> max_datagram_reply_length ) { //<S2SV> krb5_data_free ( reply ) ; //<S2SV> ret = KRB5KRB_ERR_RESPONSE_TOO_BIG ; //<S2SV> _kdc_set_e_text ( r , "Reply<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large" ) ; //<S2SV> } //<S2SV> out : //<S2SV> free_AS_REP ( & rep ) ; //<S2SV> if ( ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply -> length == 0 ) { //<S2SV> ret = _kdc_fast_mk_error ( context , r , //<S2SV> & error_method , //<S2SV> r -> armor_crypto , //<S2SV> & req -> req_body , //<S2SV> ret , r -> e_text , //<S2SV> r -> server_princ , //<S2SV> & r -> client_princ -> name , //<S2SV> & r -> client_princ -> realm , //<S2SV> NULL , NULL , //<S2SV> reply ) ; //<S2SV> if ( ret ) //<S2SV> goto out2 ; //<S2SV> } //<S2SV> out2 : //<S2SV> free_EncTicketPart ( & r -> et ) ; //<S2SV> free_EncKDCRepPart ( & r -> ek ) ; //<S2SV> free_KDCFastState ( & r -> fast ) ; //<S2SV> if ( error_method . len ) //<S2SV> free_METHOD_DATA ( & error_method ) ; //<S2SV> if ( r -> outpadata . len ) //<S2SV> free_METHOD_DATA ( & r -> outpadata ) ; //<S2SV> if ( r -> client_princ ) { //<S2SV> krb5_free_principal ( context , r -> client_princ ) ; //<S2SV> r -> client_princ = NULL ; //<S2SV> } //<S2SV> if ( r -> client_name ) { //<S2SV> free ( r -> client_name ) ; //<S2SV> r -> client_name = NULL ; //<S2SV> } //<S2SV> if ( r -> server_princ ) { //<S2SV> krb5_free_principal ( context , r -> server_princ ) ; //<S2SV> r -> server_princ = NULL ; //<S2SV> } //<S2SV> if ( r -> server_name ) { //<S2SV> free ( r -> server_name ) ; //<S2SV> r -> server_name = NULL ; //<S2SV> } //<S2SV> if ( r -> client ) //<S2SV> _kdc_free_ent ( context , r -> client ) ; //<S2SV> if ( r -> server ) //<S2SV> _kdc_free_ent ( context , r -> server ) ; //<S2SV> if ( r -> armor_crypto ) { //<S2SV> krb5_crypto_destroy ( r -> context , r -> armor_crypto ) ; //<S2SV> r -> armor_crypto = NULL ; //<S2SV> } //<S2SV> krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; //<S2SV> krb5_free_keyblock_contents ( r -> context , & r -> session_key ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 