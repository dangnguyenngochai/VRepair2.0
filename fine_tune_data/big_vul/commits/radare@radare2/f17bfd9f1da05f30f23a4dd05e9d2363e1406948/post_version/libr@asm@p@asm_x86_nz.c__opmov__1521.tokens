static int opmov ( RAsm * a , ut8 * data , const Opcode * op ) { //<S2SV> int l = 0 ; //<S2SV> st64 offset = 0 ; //<S2SV> int mod = 0 ; //<S2SV> int base = 0 ; //<S2SV> int rex = 0 ; //<S2SV> ut64 immediate = 0 ; //<S2SV> if ( op -> operands [ 1 ] . type & OT_CONSTANT ) { //<S2SV> if ( ! op -> operands [ 1 ] . is_good_flag ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . immediate == - 1 ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> immediate = op -> operands [ 1 ] . immediate * op -> operands [ 1 ] . sign ; //<S2SV> if ( op -> operands [ 0 ] . type & OT_GPREG && ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) { //<S2SV> if ( a -> bits == 64 && ( ( op -> operands [ 0 ] . type & OT_QWORD ) | ( op -> operands [ 1 ] . type & OT_QWORD ) ) ) { //<S2SV> if ( ! ( op -> operands [ 1 ] . type & OT_CONSTANT ) && op -> operands [ 1 ] . extended ) { //<S2SV> data [ l ++ ] = 0x49 ; //<S2SV> } else { //<S2SV> data [ l ++ ] = 0x48 ; //<S2SV> } //<S2SV> } else if ( op -> operands [ 0 ] . extended ) { //<S2SV> data [ l ++ ] = 0x41 ; //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . type & OT_WORD ) { //<S2SV> if ( a -> bits > 16 ) { //<S2SV> data [ l ++ ] = 0x66 ; //<S2SV> } //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . type & OT_BYTE ) { //<S2SV> data [ l ++ ] = 0xb0 | op -> operands [ 0 ] . reg ; //<S2SV> data [ l ++ ] = immediate ; //<S2SV> } else { //<S2SV> if ( a -> bits == 64 && //<S2SV> ( ( op -> operands [ 0 ] . type & OT_QWORD ) | //<S2SV> ( op -> operands [ 1 ] . type & OT_QWORD ) ) && //<S2SV> immediate < UT32_MAX ) { //<S2SV> data [ l ++ ] = 0xc7 ; //<S2SV> data [ l ++ ] = 0xc0 | op -> operands [ 0 ] . reg ; //<S2SV> } else { //<S2SV> data [ l ++ ] = 0xb8 | op -> operands [ 0 ] . reg ; //<S2SV> } //<S2SV> data [ l ++ ] = immediate ; //<S2SV> data [ l ++ ] = immediate >> 8 ; //<S2SV> if ( ! ( op -> operands [ 0 ] . type & OT_WORD ) ) { //<S2SV> data [ l ++ ] = immediate >> 16 ; //<S2SV> data [ l ++ ] = immediate >> 24 ; //<S2SV> } //<S2SV> if ( a -> bits == 64 && immediate > UT32_MAX ) { //<S2SV> data [ l ++ ] = immediate >> 32 ; //<S2SV> data [ l ++ ] = immediate >> 40 ; //<S2SV> data [ l ++ ] = immediate >> 48 ; //<S2SV> data [ l ++ ] = immediate >> 56 ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( op -> operands [ 0 ] . type & OT_MEMORY ) { //<S2SV> if ( ! op -> operands [ 0 ] . explicit_size ) { //<S2SV> if ( op -> operands [ 0 ] . type & OT_GPREG ) { //<S2SV> ( ( Opcode * ) op ) -> operands [ 0 ] . dest_size = op -> operands [ 0 ] . reg_size ; //<S2SV> } else { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> int dest_bits = 8 * ( ( op -> operands [ 0 ] . dest_size & ALL_SIZE ) >> OPSIZE_SHIFT ) ; //<S2SV> int reg_bits = 8 * ( ( op -> operands [ 0 ] . reg_size & ALL_SIZE ) >> OPSIZE_SHIFT ) ; //<S2SV> int offset = op -> operands [ 0 ] . offset * op -> operands [ 0 ] . offset_sign ; //<S2SV> bool use_aso = false ; //<S2SV> if ( reg_bits < a -> bits ) { //<S2SV> use_aso = true ; //<S2SV> } //<S2SV> bool use_oso = false ; //<S2SV> if ( dest_bits == 16 ) { //<S2SV> use_oso = true ; //<S2SV> } //<S2SV> bool rip_rel = op -> operands [ 0 ] . regs [ 0 ] == X86R_RIP ; //<S2SV> int rex = 1 << 6 ; //<S2SV> bool use_rex = false ; //<S2SV> if ( dest_bits == 64 ) { //<S2SV> use_rex = true ; //<S2SV> rex |= 1 << 3 ; //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . extended ) { //<S2SV> use_rex = true ; //<S2SV> rex |= 1 ; //<S2SV> } //<S2SV> int opcode ; //<S2SV> if ( dest_bits == 8 ) { //<S2SV> opcode = 0xc6 ; //<S2SV> } else { //<S2SV> opcode = 0xc7 ; //<S2SV> } //<S2SV> int modrm = 0 ; //<S2SV> int mod ; //<S2SV> int reg = 0 ; //<S2SV> int rm ; //<S2SV> bool use_sib = false ; //<S2SV> int sib ; //<S2SV> if ( offset == 0 ) { //<S2SV> mod = 0 ; //<S2SV> } else if ( offset < 128 && offset > - 129 ) { //<S2SV> mod = 1 ; //<S2SV> } else { //<S2SV> mod = 2 ; //<S2SV> } //<S2SV> if ( reg_bits == 16 ) { //<S2SV> if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == X86R_SI ) { //<S2SV> rm = B0000 ; //<S2SV> } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == X86R_DI ) { //<S2SV> rm = B0001 ; //<S2SV> } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BP && op -> operands [ 0 ] . regs [ 1 ] == X86R_SI ) { //<S2SV> rm = B0010 ; //<S2SV> } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BP && op -> operands [ 0 ] . regs [ 1 ] == X86R_DI ) { //<S2SV> rm = B0011 ; //<S2SV> } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_SI && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { //<S2SV> rm = B0100 ; //<S2SV> } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_DI && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { //<S2SV> rm = B0101 ; //<S2SV> } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_BX && op -> operands [ 0 ] . regs [ 1 ] == - 1 ) { //<S2SV> rm = B0111 ; //<S2SV> } else { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> modrm = ( mod << 6 ) | ( reg << 3 ) | rm ; //<S2SV> } else { //<S2SV> if ( op -> operands [ 0 ] . extended ) { //<S2SV> rm = op -> operands [ 0 ] . reg ; //<S2SV> } else { //<S2SV> rm = op -> operands [ 0 ] . regs [ 0 ] ; //<S2SV> } //<S2SV> if ( rm == 5 && mod == 0 ) { //<S2SV> mod = 1 ; //<S2SV> } //<S2SV> int index = op -> operands [ 0 ] . regs [ 1 ] ; //<S2SV> int scale = getsib ( op -> operands [ 0 ] . scale [ 1 ] ) ; //<S2SV> if ( index != - 1 ) { //<S2SV> use_sib = true ; //<S2SV> sib = ( scale << 6 ) | ( index << 3 ) | rm ; //<S2SV> } else if ( rm == 4 ) { //<S2SV> use_sib = true ; //<S2SV> sib = 0x24 ; //<S2SV> } //<S2SV> if ( use_sib ) { //<S2SV> rm = B0100 ; //<S2SV> } //<S2SV> if ( rip_rel ) { //<S2SV> modrm = ( B0000 << 6 ) | ( reg << 3 ) | B0101 ; //<S2SV> sib = ( scale << 6 ) | ( B0100 << 3 ) | B0101 ; //<S2SV> } else { //<S2SV> modrm = ( mod << 6 ) | ( reg << 3 ) | rm ; //<S2SV> } //<S2SV> } //<S2SV> if ( use_aso ) { //<S2SV> data [ l ++ ] = 0x67 ; //<S2SV> } //<S2SV> if ( use_oso ) { //<S2SV> data [ l ++ ] = 0x66 ; //<S2SV> } //<S2SV> if ( use_rex ) { //<S2SV> data [ l ++ ] = rex ; //<S2SV> } //<S2SV> data [ l ++ ] = opcode ; //<S2SV> data [ l ++ ] = modrm ; //<S2SV> if ( use_sib ) { //<S2SV> data [ l ++ ] = sib ; //<S2SV> } //<S2SV> if ( mod == 1 ) { //<S2SV> data [ l ++ ] = offset ; //<S2SV> } else if ( reg_bits == 16 && mod == 2 ) { //<S2SV> data [ l ++ ] = offset ; //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> } else if ( mod == 2 || rip_rel ) { //<S2SV> data [ l ++ ] = offset ; //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> } //<S2SV> int byte ; //<S2SV> for ( byte = 0 ; byte < dest_bits && byte < 32 ; byte += 8 ) { //<S2SV> data [ l ++ ] = ( immediate >> byte ) ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( op -> operands [ 1 ] . type & OT_REGALL && //<S2SV> ! ( op -> operands [ 1 ] . type & OT_MEMORY ) ) { //<S2SV> if ( op -> operands [ 0 ] . type & OT_CONSTANT ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . type & OT_REGTYPE & OT_SEGMENTREG && //<S2SV> op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . type & OT_REGTYPE && op -> operands [ 1 ] . type & OT_REGTYPE ) { //<S2SV> if ( ! ( ( op -> operands [ 0 ] . type & ALL_SIZE ) & //<S2SV> ( op -> operands [ 1 ] . type & ALL_SIZE ) ) ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( a -> bits == 64 ) { //<S2SV> if ( op -> operands [ 0 ] . extended ) { //<S2SV> rex = 1 ; //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . extended ) { //<S2SV> rex += 4 ; //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . type & OT_QWORD ) { //<S2SV> if ( ! ( op -> operands [ 0 ] . type & OT_QWORD ) ) { //<S2SV> data [ l ++ ] = 0x67 ; //<S2SV> data [ l ++ ] = 0x48 ; //<S2SV> } //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . type & OT_QWORD && //<S2SV> op -> operands [ 0 ] . type & OT_QWORD ) { //<S2SV> data [ l ++ ] = 0x48 | rex ; //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . type & OT_DWORD && //<S2SV> op -> operands [ 0 ] . type & OT_DWORD ) { //<S2SV> data [ l ++ ] = 0x40 | rex ; //<S2SV> } //<S2SV> } else if ( op -> operands [ 0 ] . extended && op -> operands [ 1 ] . extended ) { //<S2SV> data [ l ++ ] = 0x45 ; //<S2SV> } //<S2SV> offset = op -> operands [ 0 ] . offset * op -> operands [ 0 ] . offset_sign ; //<S2SV> if ( op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { //<S2SV> data [ l ++ ] = 0x8c ; //<S2SV> } else { //<S2SV> if ( op -> operands [ 0 ] . type & OT_WORD ) { //<S2SV> data [ l ++ ] = 0x66 ; //<S2SV> } //<S2SV> data [ l ++ ] = ( op -> operands [ 0 ] . type & OT_BYTE ) ? 0x88 : 0x89 ; //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . scale [ 0 ] > 1 ) { //<S2SV> data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 4 ; //<S2SV> data [ l ++ ] = getsib ( op -> operands [ 0 ] . scale [ 0 ] ) << 6 | //<S2SV> op -> operands [ 0 ] . regs [ 0 ] << 3 | 5 ; //<S2SV> data [ l ++ ] = offset ; //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> return l ; //<S2SV> } //<S2SV> if ( ! ( op -> operands [ 0 ] . type & OT_MEMORY ) ) { //<S2SV> if ( op -> operands [ 0 ] . reg == X86R_UNDEFINED || //<S2SV> op -> operands [ 1 ] . reg == X86R_UNDEFINED ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> mod = 0x3 ; //<S2SV> data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . reg ; //<S2SV> } else if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_UNDEFINED ) { //<S2SV> data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 0x5 ; //<S2SV> data [ l ++ ] = offset ; //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> } else { //<S2SV> if ( op -> operands [ 0 ] . type & OT_MEMORY ) { //<S2SV> if ( op -> operands [ 0 ] . regs [ 1 ] != X86R_UNDEFINED ) { //<S2SV> data [ l ++ ] = op -> operands [ 1 ] . reg << 3 | 0x4 ; //<S2SV> data [ l ++ ] = op -> operands [ 0 ] . regs [ 1 ] << 3 | op -> operands [ 0 ] . regs [ 0 ] ; //<S2SV> return l ; //<S2SV> } //<S2SV> if ( offset ) { //<S2SV> mod = ( offset > 128 || offset < - 129 ) ? 0x2 : 0x1 ; //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_EBP ) { //<S2SV> mod = 0x2 ; //<S2SV> } //<S2SV> data [ l ++ ] = mod << 6 | op -> operands [ 1 ] . reg << 3 | op -> operands [ 0 ] . regs [ 0 ] ; //<S2SV> if ( op -> operands [ 0 ] . regs [ 0 ] == X86R_ESP ) { //<S2SV> data [ l ++ ] = 0x24 ; //<S2SV> } //<S2SV> if ( offset ) { //<S2SV> data [ l ++ ] = offset ; //<S2SV> } //<S2SV> if ( mod == 2 ) { //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else if ( op -> operands [ 1 ] . type & OT_MEMORY ) { //<S2SV> if ( op -> operands [ 0 ] . type & OT_MEMORY ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> offset = op -> operands [ 1 ] . offset * op -> operands [ 1 ] . offset_sign ; //<S2SV> if ( op -> operands [ 0 ] . reg == X86R_EAX && op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { //<S2SV> if ( a -> bits == 64 ) { //<S2SV> data [ l ++ ] = 0x48 ; //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . type & OT_BYTE ) { //<S2SV> data [ l ++ ] = 0xa0 ; //<S2SV> } else { //<S2SV> data [ l ++ ] = 0xa1 ; //<S2SV> } //<S2SV> data [ l ++ ] = offset ; //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> if ( a -> bits == 64 ) { //<S2SV> data [ l ++ ] = offset >> 32 ; //<S2SV> data [ l ++ ] = offset >> 40 ; //<S2SV> data [ l ++ ] = offset >> 48 ; //<S2SV> data [ l ++ ] = offset >> 54 ; //<S2SV> } //<S2SV> return l ; //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . type & OT_BYTE && a -> bits == 64 && op -> operands [ 1 ] . regs [ 0 ] ) { //<S2SV> if ( op -> operands [ 1 ] . regs [ 0 ] >= X86R_R8 && //<S2SV> op -> operands [ 0 ] . reg < 4 ) { //<S2SV> data [ l ++ ] = 0x41 ; //<S2SV> data [ l ++ ] = 0x8a ; //<S2SV> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | ( op -> operands [ 1 ] . regs [ 0 ] - 8 ) ; //<S2SV> return l ; //<S2SV> } //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . type & OT_REGTYPE & OT_SEGMENTREG ) { //<S2SV> if ( op -> operands [ 1 ] . scale [ 0 ] == 0 ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> data [ l ++ ] = SEG_REG_PREFIXES [ op -> operands [ 1 ] . regs [ 0 ] % 6 ] ; //<S2SV> data [ l ++ ] = 0x8b ; //<S2SV> data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; //<S2SV> data [ l ++ ] = offset ; //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> return l ; //<S2SV> } //<S2SV> if ( a -> bits == 64 ) { //<S2SV> if ( op -> operands [ 0 ] . type & OT_QWORD ) { //<S2SV> if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { //<S2SV> if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { //<S2SV> data [ l ++ ] = 0x67 ; //<S2SV> } //<S2SV> data [ l ++ ] = 0x48 ; //<S2SV> } //<S2SV> } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { //<S2SV> data [ l ++ ] = 0x44 ; //<S2SV> } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { //<S2SV> data [ l ++ ] = 0x67 ; //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . type & OT_QWORD && //<S2SV> op -> operands [ 0 ] . type & OT_QWORD ) { //<S2SV> data [ l ++ ] = 0x48 ; //<S2SV> } //<S2SV> } //<S2SV> if ( op -> operands [ 0 ] . type & OT_WORD ) { //<S2SV> data [ l ++ ] = 0x66 ; //<S2SV> data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; //<S2SV> } else { //<S2SV> data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || //<S2SV> op -> operands [ 0 ] . type & OT_BYTE ) ? //<S2SV> 0x8a : 0x8b ; //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { //<S2SV> if ( a -> bits == 64 ) { //<S2SV> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; //<S2SV> data [ l ++ ] = 0x25 ; //<S2SV> } else { //<S2SV> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x5 ; //<S2SV> } //<S2SV> data [ l ++ ] = offset ; //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> } else { //<S2SV> if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { //<S2SV> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; //<S2SV> if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { //<S2SV> base = 5 ; //<S2SV> } //<S2SV> if ( base ) { //<S2SV> data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; //<S2SV> } else { //<S2SV> data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; //<S2SV> } //<S2SV> if ( offset || base ) { //<S2SV> data [ l ++ ] = offset ; //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> } //<S2SV> return l ; //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED ) { //<S2SV> data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; //<S2SV> data [ l ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; //<S2SV> return l ; //<S2SV> } //<S2SV> if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { //<S2SV> mod = 0x2 ; //<S2SV> if ( op -> operands [ 1 ] . offset > 127 ) { //<S2SV> mod = 0x4 ; //<S2SV> } //<S2SV> } //<S2SV> if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { //<S2SV> if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { //<S2SV> data [ l ++ ] = 0x5 ; //<S2SV> } else { //<S2SV> if ( op -> operands [ 1 ] . offset > 127 ) { //<S2SV> data [ l ++ ] = 0x80 | op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ; //<S2SV> } else { //<S2SV> data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; //<S2SV> } //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . offset > 127 ) { //<S2SV> mod = 0x1 ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { //<S2SV> data [ l ++ ] = 0x0d ; //<S2SV> } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { //<S2SV> data [ l ++ ] = 0x05 ; //<S2SV> } else { //<S2SV> data [ l ++ ] = mod << 5 | op -> operands [ 0 ] . reg << 3 | op -> operands [ 1 ] . regs [ 0 ] ; //<S2SV> } //<S2SV> } //<S2SV> if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_ESP ) { //<S2SV> data [ l ++ ] = 0x24 ; //<S2SV> } //<S2SV> if ( mod >= 0x2 ) { //<S2SV> data [ l ++ ] = offset ; //<S2SV> if ( op -> operands [ 1 ] . offset > 128 || op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP ) { //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> } //<S2SV> } else if ( a -> bits == 64 && ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) ) { //<S2SV> data [ l ++ ] = offset ; //<S2SV> if ( op -> operands [ 1 ] . offset > 127 || op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { //<S2SV> data [ l ++ ] = offset >> 8 ; //<S2SV> data [ l ++ ] = offset >> 16 ; //<S2SV> data [ l ++ ] = offset >> 24 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return l ; //<S2SV> } //<S2SV> 