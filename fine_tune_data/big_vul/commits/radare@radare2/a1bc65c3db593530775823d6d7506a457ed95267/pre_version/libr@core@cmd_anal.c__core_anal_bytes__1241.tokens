static void core_anal_bytes ( RCore * core , const ut8 * buf , int len , int nops , int fmt ) { //<S2SV> int stacksize = r_config_get_i ( core -> config , "esil.stack.depth" ) ; //<S2SV> bool iotrap = r_config_get_i ( core -> config , "esil.iotrap" ) ; //<S2SV> bool romem = r_config_get_i ( core -> config , "esil.romem" ) ; //<S2SV> bool stats = r_config_get_i ( core -> config , "esil.stats" ) ; //<S2SV> bool be = core -> print -> big_endian ; //<S2SV> bool use_color = core -> print -> flags & R_PRINT_FLAGS_COLOR ; //<S2SV> core -> parser -> relsub = r_config_get_i ( core -> config , "asm.relsub" ) ; //<S2SV> int ret , i , j , idx , size ; //<S2SV> const char * color = "" ; //<S2SV> const char * esilstr ; //<S2SV> const char * opexstr ; //<S2SV> RAnalHint * hint ; //<S2SV> RAnalEsil * esil = NULL ; //<S2SV> RAsmOp asmop ; //<S2SV> RAnalOp op = { 0 } ; //<S2SV> ut64 addr ; //<S2SV> bool isFirst = true ; //<S2SV> unsigned int addrsize = r_config_get_i ( core -> config , "esil.addr.size" ) ; //<S2SV> int totalsize = 0 ; //<S2SV> if ( use_color ) { //<S2SV> color = core -> cons -> pal . label ; //<S2SV> } //<S2SV> switch ( fmt ) { //<S2SV> case 'j' : //<S2SV> r_cons_printf ( "[" ) ; //<S2SV> break ; //<S2SV> case 'r' : //<S2SV> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; //<S2SV> if ( ! esil ) { //<S2SV> return ; //<S2SV> } //<S2SV> r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; //<S2SV> r_anal_esil_set_pc ( esil , core -> offset ) ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( i = idx = ret = 0 ; idx < len && ( ! nops || ( nops && i < nops ) ) ; i ++ , idx += ret ) { //<S2SV> addr = core -> offset + idx ; //<S2SV> hint = r_anal_hint_get ( core -> anal , addr ) ; //<S2SV> r_asm_set_pc ( core -> assembler , addr ) ; //<S2SV> ( void ) r_asm_disassemble ( core -> assembler , & asmop , buf + idx , len - idx ) ; //<S2SV> ret = r_anal_op ( core -> anal , & op , core -> offset + idx , buf + idx , len - idx , R_ANAL_OP_MASK_ESIL ) ; //<S2SV> esilstr = R_STRBUF_SAFEGET ( & op . esil ) ; //<S2SV> opexstr = R_STRBUF_SAFEGET ( & op . opex ) ; //<S2SV> char * mnem = strdup ( r_asm_op_get_asm ( & asmop ) ) ; //<S2SV> char * sp = strchr ( mnem , '<S2SV_blank>' ) ; //<S2SV> if ( sp ) { //<S2SV> * sp = 0 ; //<S2SV> if ( op . prefix ) { //<S2SV> char * arg = strdup ( sp + 1 ) ; //<S2SV> char * sp = strchr ( arg , '<S2SV_blank>' ) ; //<S2SV> if ( sp ) { //<S2SV> * sp = 0 ; //<S2SV> } //<S2SV> free ( mnem ) ; //<S2SV> mnem = arg ; //<S2SV> } //<S2SV> } //<S2SV> if ( ret < 1 && fmt != 'd' ) { //<S2SV> eprintf ( "Oops<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "<S2SV_blank>(" , core -> offset + idx ) ; //<S2SV> for ( i = idx , j = 0 ; i < core -> blocksize && j < 3 ; ++ i , ++ j ) { //<S2SV> eprintf ( "%02x<S2SV_blank>" , buf [ i ] ) ; //<S2SV> } //<S2SV> eprintf ( "...)\\n" ) ; //<S2SV> free ( mnem ) ; //<S2SV> break ; //<S2SV> } //<S2SV> size = ( hint && hint -> size ) ? hint -> size : op . size ; //<S2SV> if ( fmt == 'd' ) { //<S2SV> char * opname = strdup ( r_asm_op_get_asm ( & asmop ) ) ; //<S2SV> if ( opname ) { //<S2SV> r_str_split ( opname , '<S2SV_blank>' ) ; //<S2SV> char * d = r_asm_describe ( core -> assembler , opname ) ; //<S2SV> if ( d && * d ) { //<S2SV> r_cons_printf ( "%s:<S2SV_blank>%s\\n" , opname , d ) ; //<S2SV> free ( d ) ; //<S2SV> } else { //<S2SV> eprintf ( "Unknown<S2SV_blank>opcode\\n" ) ; //<S2SV> } //<S2SV> free ( opname ) ; //<S2SV> } //<S2SV> } else if ( fmt == 'e' ) { //<S2SV> if ( * esilstr ) { //<S2SV> if ( use_color ) { //<S2SV> r_cons_printf ( "%s0x%" PFMT64x Color_RESET "<S2SV_blank>%s\\n" , color , core -> offset + idx , esilstr ) ; //<S2SV> } else { //<S2SV> r_cons_printf ( "0x%" PFMT64x "<S2SV_blank>%s\\n" , core -> offset + idx , esilstr ) ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( fmt == 's' ) { //<S2SV> totalsize += op . size ; //<S2SV> } else if ( fmt == 'r' ) { //<S2SV> if ( * esilstr ) { //<S2SV> if ( use_color ) { //<S2SV> r_cons_printf ( "%s0x%" PFMT64x Color_RESET "\\n" , color , core -> offset + idx ) ; //<S2SV> } else { //<S2SV> r_cons_printf ( "0x%" PFMT64x "\\n" , core -> offset + idx ) ; //<S2SV> } //<S2SV> r_anal_esil_parse ( esil , esilstr ) ; //<S2SV> r_anal_esil_dumpstack ( esil ) ; //<S2SV> r_anal_esil_stack_free ( esil ) ; //<S2SV> } //<S2SV> } else if ( fmt == 'j' ) { //<S2SV> if ( isFirst ) { //<S2SV> isFirst = false ; //<S2SV> } else { //<S2SV> r_cons_print ( "," ) ; //<S2SV> } //<S2SV> r_cons_printf ( "{\\"opcode\\":\\"%s\\"," , r_asm_op_get_asm ( & asmop ) ) ; //<S2SV> { //<S2SV> char strsub [ 128 ] = { 0 } ; //<S2SV> r_parse_varsub ( core -> parser , NULL , //<S2SV> core -> offset + idx , //<S2SV> asmop . size , r_asm_op_get_asm ( & asmop ) , //<S2SV> strsub , sizeof ( strsub ) ) ; //<S2SV> { //<S2SV> ut64 killme = UT64_MAX ; //<S2SV> if ( r_io_read_i ( core -> io , op . ptr , & killme , op . refptr , be ) ) { //<S2SV> core -> parser -> relsub_addr = killme ; //<S2SV> } //<S2SV> } //<S2SV> char * p = strdup ( strsub ) ; //<S2SV> if ( p ) { //<S2SV> r_parse_filter ( core -> parser , addr , core -> flags , p , //<S2SV> strsub , sizeof ( strsub ) , be ) ; //<S2SV> free ( p ) ; //<S2SV> } //<S2SV> r_cons_printf ( "\\"disasm\\":\\"%s\\"," , strsub ) ; //<S2SV> } //<S2SV> r_cons_printf ( "\\"mnemonic\\":\\"%s\\"," , mnem ) ; //<S2SV> if ( hint && hint -> opcode ) { //<S2SV> r_cons_printf ( "\\"ophint\\":\\"%s\\"," , hint -> opcode ) ; //<S2SV> } //<S2SV> r_cons_printf ( "\\"sign\\":%s," , r_str_bool ( op . sign ) ) ; //<S2SV> r_cons_printf ( "\\"prefix\\":%" PFMT64u "," , op . prefix ) ; //<S2SV> r_cons_printf ( "\\"id\\":%d," , op . id ) ; //<S2SV> if ( opexstr && * opexstr ) { //<S2SV> r_cons_printf ( "\\"opex\\":%s," , opexstr ) ; //<S2SV> } //<S2SV> r_cons_printf ( "\\"addr\\":%" PFMT64u "," , core -> offset + idx ) ; //<S2SV> r_cons_printf ( "\\"bytes\\":\\"" ) ; //<S2SV> for ( j = 0 ; j < size ; j ++ ) { //<S2SV> r_cons_printf ( "%02x" , buf [ j + idx ] ) ; //<S2SV> } //<S2SV> r_cons_printf ( "\\"," ) ; //<S2SV> if ( op . val != UT64_MAX ) { //<S2SV> r_cons_printf ( "\\"val\\":<S2SV_blank>%" PFMT64u "," , op . val ) ; //<S2SV> } //<S2SV> if ( op . ptr != UT64_MAX ) { //<S2SV> r_cons_printf ( "\\"ptr\\":<S2SV_blank>%" PFMT64u "," , op . ptr ) ; //<S2SV> } //<S2SV> r_cons_printf ( "\\"size\\":<S2SV_blank>%d," , size ) ; //<S2SV> r_cons_printf ( "\\"type\\":<S2SV_blank>\\"%s\\"," , //<S2SV> r_anal_optype_to_string ( op . type ) ) ; //<S2SV> if ( op . reg ) { //<S2SV> r_cons_printf ( "\\"reg\\":<S2SV_blank>\\"%s\\"," , op . reg ) ; //<S2SV> } //<S2SV> if ( op . ireg ) { //<S2SV> r_cons_printf ( "\\"ireg\\":<S2SV_blank>\\"%s\\"," , op . ireg ) ; //<S2SV> } //<S2SV> if ( op . scale ) { //<S2SV> r_cons_printf ( "\\"scale\\":%d," , op . scale ) ; //<S2SV> } //<S2SV> if ( hint && hint -> esil ) { //<S2SV> r_cons_printf ( "\\"esil\\":<S2SV_blank>\\"%s\\"," , hint -> esil ) ; //<S2SV> } else if ( * esilstr ) { //<S2SV> r_cons_printf ( "\\"esil\\":<S2SV_blank>\\"%s\\"," , esilstr ) ; //<S2SV> } //<S2SV> if ( hint && hint -> jump != UT64_MAX ) { //<S2SV> op . jump = hint -> jump ; //<S2SV> } //<S2SV> if ( op . jump != UT64_MAX ) { //<S2SV> r_cons_printf ( "\\"jump\\":%" PFMT64u "," , op . jump ) ; //<S2SV> } //<S2SV> if ( hint && hint -> fail != UT64_MAX ) { //<S2SV> op . fail = hint -> fail ; //<S2SV> } //<S2SV> if ( op . refptr != - 1 ) { //<S2SV> r_cons_printf ( "\\"refptr\\":%d," , op . refptr ) ; //<S2SV> } //<S2SV> if ( op . fail != UT64_MAX ) { //<S2SV> r_cons_printf ( "\\"fail\\":%" PFMT64u "," , op . fail ) ; //<S2SV> } //<S2SV> r_cons_printf ( "\\"cycles\\":%d," , op . cycles ) ; //<S2SV> if ( op . failcycles ) { //<S2SV> r_cons_printf ( "\\"failcycles\\":%d," , op . failcycles ) ; //<S2SV> } //<S2SV> r_cons_printf ( "\\"delay\\":%d," , op . delay ) ; //<S2SV> { //<S2SV> const char * p = r_anal_stackop_tostring ( op . stackop ) ; //<S2SV> if ( p && * p && strcmp ( p , "null" ) ) //<S2SV> r_cons_printf ( "\\"stack\\":\\"%s\\"," , p ) ; //<S2SV> } //<S2SV> if ( op . stackptr ) { //<S2SV> r_cons_printf ( "\\"stackptr\\":%d," , op . stackptr ) ; //<S2SV> } //<S2SV> { //<S2SV> const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) //<S2SV> ? r_anal_cond_tostring ( op . cond ) : NULL ; //<S2SV> if ( arg ) { //<S2SV> r_cons_printf ( "\\"cond\\":\\"%s\\"," , arg ) ; //<S2SV> } //<S2SV> } //<S2SV> r_cons_printf ( "\\"family\\":\\"%s\\"}" , r_anal_op_family_to_string ( op . family ) ) ; //<S2SV> } else { //<S2SV> # define printline ( k , fmt , arg ) { if ( use_color ) r_cons_printf ( "%s%s:<S2SV_blank>" Color_RESET , color , k ) ; else r_cons_printf ( "%s:<S2SV_blank>" , k ) ; if ( fmt ) r_cons_printf ( fmt , arg ) ; } //<S2SV> printline ( "address" , "0x%" PFMT64x "\\n" , core -> offset + idx ) ; //<S2SV> printline ( "opcode" , "%s\\n" , r_asm_op_get_asm ( & asmop ) ) ; //<S2SV> printline ( "mnemonic" , "%s\\n" , mnem ) ; //<S2SV> if ( hint ) { //<S2SV> if ( hint -> opcode ) { //<S2SV> printline ( "ophint" , "%s\\n" , hint -> opcode ) ; //<S2SV> } //<S2SV> # if 0 //<S2SV> if ( hint -> addr != UT64_MAX ) { //<S2SV> printline ( "addr" , "0x%08" PFMT64x "\\n" , ( hint -> addr + idx ) ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> printline ( "prefix" , "%" PFMT64u "\\n" , op . prefix ) ; //<S2SV> printline ( "id" , "%d\\n" , op . id ) ; //<S2SV> # if 0 //<S2SV> if ( opexstr && * opexstr ) { //<S2SV> printline ( "opex" , "%s\\n" , opexstr ) ; //<S2SV> } //<S2SV> # endif //<S2SV> printline ( "bytes" , NULL , 0 ) ; //<S2SV> for ( j = 0 ; j < size ; j ++ ) { //<S2SV> r_cons_printf ( "%02x" , buf [ j + idx ] ) ; //<S2SV> } //<S2SV> r_cons_newline ( ) ; //<S2SV> if ( op . val != UT64_MAX ) //<S2SV> printline ( "val" , "0x%08" PFMT64x "\\n" , op . val ) ; //<S2SV> if ( op . ptr != UT64_MAX ) //<S2SV> printline ( "ptr" , "0x%08" PFMT64x "\\n" , op . ptr ) ; //<S2SV> if ( op . refptr != - 1 ) //<S2SV> printline ( "refptr" , "%d\\n" , op . refptr ) ; //<S2SV> printline ( "size" , "%d\\n" , size ) ; //<S2SV> printline ( "sign" , "%s\\n" , r_str_bool ( op . sign ) ) ; //<S2SV> printline ( "type" , "%s\\n" , r_anal_optype_to_string ( op . type ) ) ; //<S2SV> printline ( "cycles" , "%d\\n" , op . cycles ) ; //<S2SV> if ( op . failcycles ) { //<S2SV> printline ( "failcycles" , "%d\\n" , op . failcycles ) ; //<S2SV> } //<S2SV> { //<S2SV> const char * t2 = r_anal_optype_to_string ( op . type2 ) ; //<S2SV> if ( t2 && strcmp ( t2 , "null" ) ) { //<S2SV> printline ( "type2" , "%s\\n" , t2 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( op . reg ) { //<S2SV> printline ( "reg" , "%s\\n" , op . reg ) ; //<S2SV> } //<S2SV> if ( op . ireg ) { //<S2SV> printline ( "ireg" , "%s\\n" , op . ireg ) ; //<S2SV> } //<S2SV> if ( op . scale ) { //<S2SV> printline ( "scale" , "%d\\n" , op . scale ) ; //<S2SV> } //<S2SV> if ( hint && hint -> esil ) { //<S2SV> printline ( "esil" , "%s\\n" , hint -> esil ) ; //<S2SV> } else if ( * esilstr ) { //<S2SV> printline ( "esil" , "%s\\n" , esilstr ) ; //<S2SV> } //<S2SV> if ( hint && hint -> jump != UT64_MAX ) { //<S2SV> op . jump = hint -> jump ; //<S2SV> } //<S2SV> if ( op . jump != UT64_MAX ) { //<S2SV> printline ( "jump" , "0x%08" PFMT64x "\\n" , op . jump ) ; //<S2SV> } //<S2SV> if ( op . direction != 0 ) { //<S2SV> const char * dir = op . direction == 1 ? "read" //<S2SV> : op . direction == 2 ? "write" //<S2SV> : op . direction == 4 ? "exec" //<S2SV> : op . direction == 8 ? "ref" : "none" ; //<S2SV> printline ( "direction" , "%s\\n" , dir ) ; //<S2SV> } //<S2SV> if ( hint && hint -> fail != UT64_MAX ) { //<S2SV> op . fail = hint -> fail ; //<S2SV> } //<S2SV> if ( op . fail != UT64_MAX ) { //<S2SV> printline ( "fail" , "0x%08" PFMT64x "\\n" , op . fail ) ; //<S2SV> } //<S2SV> if ( op . delay ) { //<S2SV> printline ( "delay" , "%d\\n" , op . delay ) ; //<S2SV> } //<S2SV> printline ( "stack" , "%s\\n" , r_anal_stackop_tostring ( op . stackop ) ) ; //<S2SV> { //<S2SV> const char * arg = ( op . type & R_ANAL_OP_TYPE_COND ) ? r_anal_cond_tostring ( op . cond ) : NULL ; //<S2SV> if ( arg ) { //<S2SV> printline ( "cond" , "%s\\n" , arg ) ; //<S2SV> } //<S2SV> } //<S2SV> printline ( "family" , "%s\\n" , r_anal_op_family_to_string ( op . family ) ) ; //<S2SV> printline ( "stackop" , "%s\\n" , r_anal_stackop_tostring ( op . stackop ) ) ; //<S2SV> if ( op . stackptr ) { //<S2SV> printline ( "stackptr" , "%" PFMT64u "\\n" , op . stackptr ) ; //<S2SV> } //<S2SV> } //<S2SV> free ( mnem ) ; //<S2SV> r_anal_hint_free ( hint ) ; //<S2SV> r_anal_op_fini ( & op ) ; //<S2SV> } //<S2SV> r_anal_op_fini ( & op ) ; //<S2SV> if ( fmt == 'j' ) { //<S2SV> r_cons_printf ( "]" ) ; //<S2SV> r_cons_newline ( ) ; //<S2SV> } else if ( fmt == 's' ) { //<S2SV> r_cons_printf ( "%d\\n" , totalsize ) ; //<S2SV> } //<S2SV> r_anal_esil_free ( esil ) ; //<S2SV> } //<S2SV> 