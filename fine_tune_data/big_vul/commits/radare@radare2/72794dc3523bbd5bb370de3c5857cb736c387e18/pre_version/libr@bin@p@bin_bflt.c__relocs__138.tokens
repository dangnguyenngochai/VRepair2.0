static RList * relocs ( RBinFile * arch ) { //<S2SV> struct r_bin_bflt_obj * obj = ( struct r_bin_bflt_obj * ) arch -> o -> bin_obj ; //<S2SV> RList * list = r_list_newf ( ( RListFree ) free ) ; //<S2SV> int i , len , n_got , amount ; //<S2SV> if ( ! list || ! obj ) { //<S2SV> r_list_free ( list ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( obj -> hdr -> flags & FLAT_FLAG_GOTPIC ) { //<S2SV> n_got = get_ngot_entries ( obj ) ; //<S2SV> if ( n_got ) { //<S2SV> amount = n_got * sizeof ( ut32 ) ; //<S2SV> if ( amount < n_got || amount > UT32_MAX ) { //<S2SV> goto out_error ; //<S2SV> } //<S2SV> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; //<S2SV> if ( got_table ) { //<S2SV> ut32 offset = 0 ; //<S2SV> for ( i = 0 ; i < n_got ; offset += 4 , i ++ ) { //<S2SV> ut32 got_entry ; //<S2SV> if ( obj -> hdr -> data_start + offset + 4 > obj -> size || //<S2SV> obj -> hdr -> data_start + offset + 4 < offset ) { //<S2SV> break ; //<S2SV> } //<S2SV> len = r_buf_read_at ( obj -> b , obj -> hdr -> data_start + offset , //<S2SV> ( ut8 * ) & got_entry , sizeof ( ut32 ) ) ; //<S2SV> if ( ! VALID_GOT_ENTRY ( got_entry ) || len != sizeof ( ut32 ) ) { //<S2SV> break ; //<S2SV> } //<S2SV> got_table [ i ] . addr_to_patch = got_entry ; //<S2SV> got_table [ i ] . data_offset = got_entry + BFLT_HDR_SIZE ; //<S2SV> } //<S2SV> obj -> n_got = n_got ; //<S2SV> obj -> got_table = got_table ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( obj -> hdr -> reloc_count > 0 ) { //<S2SV> int n_reloc = obj -> hdr -> reloc_count ; //<S2SV> amount = n_reloc * sizeof ( struct reloc_struct_t ) ; //<S2SV> if ( amount < n_reloc || amount > UT32_MAX ) { //<S2SV> goto out_error ; //<S2SV> } //<S2SV> struct reloc_struct_t * reloc_table = calloc ( 1 , amount + 1 ) ; //<S2SV> if ( ! reloc_table ) { //<S2SV> goto out_error ; //<S2SV> } //<S2SV> amount = n_reloc * sizeof ( ut32 ) ; //<S2SV> if ( amount < n_reloc || amount > UT32_MAX ) { //<S2SV> free ( reloc_table ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> ut32 * reloc_pointer_table = calloc ( 1 , amount + 1 ) ; //<S2SV> if ( ! reloc_pointer_table ) { //<S2SV> free ( reloc_table ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> if ( obj -> hdr -> reloc_start + amount > obj -> size || //<S2SV> obj -> hdr -> reloc_start + amount < amount ) { //<S2SV> free ( reloc_table ) ; //<S2SV> free ( reloc_pointer_table ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> len = r_buf_read_at ( obj -> b , obj -> hdr -> reloc_start , //<S2SV> ( ut8 * ) reloc_pointer_table , amount ) ; //<S2SV> if ( len != amount ) { //<S2SV> free ( reloc_table ) ; //<S2SV> free ( reloc_pointer_table ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> for ( i = 0 ; i < obj -> hdr -> reloc_count ; i ++ ) { //<S2SV> ut32 reloc_offset = //<S2SV> r_swap_ut32 ( reloc_pointer_table [ i ] ) + //<S2SV> BFLT_HDR_SIZE ; //<S2SV> if ( reloc_offset < obj -> hdr -> bss_end && reloc_offset < obj -> size ) { //<S2SV> ut32 reloc_fixed , reloc_data_offset ; //<S2SV> if ( reloc_offset + sizeof ( ut32 ) > obj -> size || //<S2SV> reloc_offset + sizeof ( ut32 ) < reloc_offset ) { //<S2SV> free ( reloc_table ) ; //<S2SV> free ( reloc_pointer_table ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> len = r_buf_read_at ( obj -> b , reloc_offset , //<S2SV> ( ut8 * ) & reloc_fixed , //<S2SV> sizeof ( ut32 ) ) ; //<S2SV> if ( len != sizeof ( ut32 ) ) { //<S2SV> eprintf ( "problem<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>relocation<S2SV_blank>entries\\n" ) ; //<S2SV> free ( reloc_table ) ; //<S2SV> free ( reloc_pointer_table ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> reloc_data_offset = r_swap_ut32 ( reloc_fixed ) + BFLT_HDR_SIZE ; //<S2SV> reloc_table [ i ] . addr_to_patch = reloc_offset ; //<S2SV> reloc_table [ i ] . data_offset = reloc_data_offset ; //<S2SV> RBinReloc * reloc = R_NEW0 ( RBinReloc ) ; //<S2SV> if ( reloc ) { //<S2SV> reloc -> type = R_BIN_RELOC_32 ; //<S2SV> reloc -> paddr = reloc_table [ i ] . addr_to_patch ; //<S2SV> reloc -> vaddr = reloc -> paddr ; //<S2SV> r_list_append ( list , reloc ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> free ( reloc_pointer_table ) ; //<S2SV> obj -> reloc_table = reloc_table ; //<S2SV> } //<S2SV> return list ; //<S2SV> out_error : //<S2SV> r_list_free ( list ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 