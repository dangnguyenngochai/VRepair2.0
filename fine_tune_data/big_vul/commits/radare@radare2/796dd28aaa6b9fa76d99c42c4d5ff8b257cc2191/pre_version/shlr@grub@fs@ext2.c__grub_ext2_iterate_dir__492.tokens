static int //<S2SV> grub_ext2_iterate_dir ( grub_fshelp_node_t dir , //<S2SV> int ( * hook ) ( const char * filename , //<S2SV> enum grub_fshelp_filetype filetype , //<S2SV> grub_fshelp_node_t node , //<S2SV> void * closure ) , //<S2SV> void * closure ) //<S2SV> { //<S2SV> unsigned int fpos = 0 ; //<S2SV> struct grub_fshelp_node * diro = ( struct grub_fshelp_node * ) dir ; //<S2SV> if ( ! diro -> inode_read ) //<S2SV> { //<S2SV> grub_ext2_read_inode ( diro -> data , diro -> ino , & diro -> inode ) ; //<S2SV> if ( grub_errno ) //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( hook ) //<S2SV> while ( fpos < grub_le_to_cpu32 ( diro -> inode . size ) ) //<S2SV> { //<S2SV> struct ext2_dirent dirent ; //<S2SV> grub_ext2_read_file ( diro , NULL , NULL , 0 , fpos , sizeof ( dirent ) , //<S2SV> ( char * ) & dirent ) ; //<S2SV> if ( grub_errno ) //<S2SV> return 0 ; //<S2SV> if ( dirent . direntlen == 0 ) //<S2SV> return 0 ; //<S2SV> if ( dirent . namelen != 0 ) //<S2SV> { //<S2SV> # ifndef _MSC_VER //<S2SV> char filename [ dirent . namelen + 1 ] ; //<S2SV> # else //<S2SV> char * filename = grub_malloc ( dirent . namelen + 1 ) ; //<S2SV> # endif //<S2SV> struct grub_fshelp_node * fdiro ; //<S2SV> enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ; //<S2SV> grub_ext2_read_file ( diro , 0 , 0 , 0 , //<S2SV> fpos + sizeof ( struct ext2_dirent ) , //<S2SV> dirent . namelen , filename ) ; //<S2SV> if ( grub_errno ) //<S2SV> return 0 ; //<S2SV> fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) ) ; //<S2SV> if ( ! fdiro ) //<S2SV> return 0 ; //<S2SV> fdiro -> data = diro -> data ; //<S2SV> fdiro -> ino = grub_le_to_cpu32 ( dirent . inode ) ; //<S2SV> filename [ dirent . namelen ] = '\\0' ; //<S2SV> if ( dirent . filetype != FILETYPE_UNKNOWN ) //<S2SV> { //<S2SV> fdiro -> inode_read = 0 ; //<S2SV> if ( dirent . filetype == FILETYPE_DIRECTORY ) //<S2SV> type = GRUB_FSHELP_DIR ; //<S2SV> else if ( dirent . filetype == FILETYPE_SYMLINK ) //<S2SV> type = GRUB_FSHELP_SYMLINK ; //<S2SV> else if ( dirent . filetype == FILETYPE_REG ) //<S2SV> type = GRUB_FSHELP_REG ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> grub_ext2_read_inode ( diro -> data , //<S2SV> grub_le_to_cpu32 ( dirent . inode ) , //<S2SV> & fdiro -> inode ) ; //<S2SV> if ( grub_errno ) //<S2SV> { //<S2SV> grub_free ( fdiro ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> fdiro -> inode_read = 1 ; //<S2SV> if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) //<S2SV> & FILETYPE_INO_MASK ) == FILETYPE_INO_DIRECTORY ) //<S2SV> type = GRUB_FSHELP_DIR ; //<S2SV> else if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) //<S2SV> & FILETYPE_INO_MASK ) == FILETYPE_INO_SYMLINK ) //<S2SV> type = GRUB_FSHELP_SYMLINK ; //<S2SV> else if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) //<S2SV> & FILETYPE_INO_MASK ) == FILETYPE_INO_REG ) //<S2SV> type = GRUB_FSHELP_REG ; //<S2SV> } //<S2SV> if ( hook ( filename , type , fdiro , closure ) ) //<S2SV> return 1 ; //<S2SV> } //<S2SV> fpos += grub_le_to_cpu16 ( dirent . direntlen ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 