static void cmd_anal_esil ( RCore * core , const char * input ) { //<S2SV> RAnalEsil * esil = core -> anal -> esil ; //<S2SV> ut64 addr = core -> offset ; //<S2SV> ut64 adr ; //<S2SV> char * n , * n1 ; //<S2SV> int off ; //<S2SV> int stacksize = r_config_get_i ( core -> config , "esil.stack.depth" ) ; //<S2SV> int iotrap = r_config_get_i ( core -> config , "esil.iotrap" ) ; //<S2SV> int romem = r_config_get_i ( core -> config , "esil.romem" ) ; //<S2SV> int stats = r_config_get_i ( core -> config , "esil.stats" ) ; //<S2SV> int noNULL = r_config_get_i ( core -> config , "esil.noNULL" ) ; //<S2SV> ut64 until_addr = UT64_MAX ; //<S2SV> unsigned int addrsize = r_config_get_i ( core -> config , "esil.addr.size" ) ; //<S2SV> const char * until_expr = NULL ; //<S2SV> RAnalOp * op ; //<S2SV> switch ( input [ 0 ] ) { //<S2SV> case 'p' : //<S2SV> switch ( input [ 1 ] ) { //<S2SV> case 'c' : //<S2SV> if ( input [ 2 ] == '<S2SV_blank>' ) { //<S2SV> r_core_cmdf ( core , "ar<S2SV_blank>PC=%s" , input + 3 ) ; //<S2SV> r_core_cmd0 ( core , ".ar*" ) ; //<S2SV> } else { //<S2SV> eprintf ( "Missing<S2SV_blank>argument\\n" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0 : //<S2SV> r_anal_pin_list ( core -> anal ) ; //<S2SV> break ; //<S2SV> case '-' : //<S2SV> if ( input [ 2 ] ) //<S2SV> addr = r_num_math ( core -> num , input + 2 ) ; //<S2SV> r_anal_pin_unset ( core -> anal , addr ) ; //<S2SV> break ; //<S2SV> case '<S2SV_blank>' : //<S2SV> r_anal_pin ( core -> anal , addr , input + 2 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> r_core_cmd_help ( core , help_msg_aep ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'r' : //<S2SV> cmd_anal_reg ( core , input + 1 ) ; //<S2SV> break ; //<S2SV> case '*' : //<S2SV> if ( core -> anal -> esil ) { //<S2SV> r_cons_printf ( "trap:<S2SV_blank>%d\\n" , core -> anal -> esil -> trap ) ; //<S2SV> r_cons_printf ( "trap-code:<S2SV_blank>%d\\n" , core -> anal -> esil -> trap_code ) ; //<S2SV> } else { //<S2SV> eprintf ( "esil<S2SV_blank>vm<S2SV_blank>not<S2SV_blank>initialized.<S2SV_blank>run<S2SV_blank>`aei`\\n" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case '<S2SV_blank>' : //<S2SV> if ( ! esil ) { //<S2SV> if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) //<S2SV> return ; //<S2SV> } //<S2SV> r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; //<S2SV> r_anal_esil_set_pc ( esil , core -> offset ) ; //<S2SV> r_anal_esil_parse ( esil , input + 1 ) ; //<S2SV> r_anal_esil_dumpstack ( esil ) ; //<S2SV> r_anal_esil_stack_free ( esil ) ; //<S2SV> break ; //<S2SV> case 's' : //<S2SV> switch ( input [ 1 ] ) { //<S2SV> case '?' : //<S2SV> eprintf ( "See:<S2SV_blank>ae?~aes\\n" ) ; //<S2SV> break ; //<S2SV> case 'l' : //<S2SV> { //<S2SV> ut64 pc = r_debug_reg_get ( core -> dbg , "PC" ) ; //<S2SV> RAnalOp * op = r_core_anal_op ( core , pc ) ; //<S2SV> if ( ! op ) { //<S2SV> break ; //<S2SV> } //<S2SV> r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; //<S2SV> r_debug_reg_set ( core -> dbg , "PC" , pc + op -> size ) ; //<S2SV> r_anal_esil_set_pc ( esil , pc + op -> size ) ; //<S2SV> r_core_cmd0 ( core , ".ar*" ) ; //<S2SV> } break ; //<S2SV> case 'b' : //<S2SV> if ( ! r_core_esil_step_back ( core ) ) { //<S2SV> eprintf ( "cannnot<S2SV_blank>step<S2SV_blank>back\\n" ) ; //<S2SV> } //<S2SV> r_core_cmd0 ( core , ".ar*" ) ; //<S2SV> break ; //<S2SV> case 'u' : //<S2SV> if ( input [ 2 ] == 'e' ) { //<S2SV> until_expr = input + 3 ; //<S2SV> } else { //<S2SV> until_addr = r_num_math ( core -> num , input + 2 ) ; //<S2SV> } //<S2SV> r_core_esil_step ( core , until_addr , until_expr , NULL ) ; //<S2SV> r_core_cmd0 ( core , ".ar*" ) ; //<S2SV> break ; //<S2SV> case 'o' : //<S2SV> op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , //<S2SV> r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ; //<S2SV> if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) { //<S2SV> until_addr = op -> addr + op -> size ; //<S2SV> } //<S2SV> r_core_esil_step ( core , until_addr , until_expr , NULL ) ; //<S2SV> r_anal_op_free ( op ) ; //<S2SV> r_core_cmd0 ( core , ".ar*" ) ; //<S2SV> break ; //<S2SV> case 'p' : //<S2SV> n = strchr ( input , '<S2SV_blank>' ) ; //<S2SV> n1 = n ? strchr ( n + 1 , '<S2SV_blank>' ) : NULL ; //<S2SV> if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) { //<S2SV> eprintf ( "aesp<S2SV_blank>[offset]<S2SV_blank>[num]\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> adr = r_num_math ( core -> num , n + 1 ) ; //<S2SV> off = r_num_math ( core -> num , n1 + 1 ) ; //<S2SV> cmd_aespc ( core , adr , off ) ; //<S2SV> break ; //<S2SV> case '<S2SV_blank>' : //<S2SV> n = strchr ( input , '<S2SV_blank>' ) ; //<S2SV> if ( ! ( n + 1 ) ) { //<S2SV> r_core_esil_step ( core , until_addr , until_expr , NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> off = r_num_math ( core -> num , n + 1 ) ; //<S2SV> cmd_aespc ( core , - 1 , off ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> r_core_esil_step ( core , until_addr , until_expr , NULL ) ; //<S2SV> r_core_cmd0 ( core , ".ar*" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'c' : //<S2SV> if ( input [ 1 ] == '?' ) { //<S2SV> r_core_cmd_help ( core , help_msg_aec ) ; //<S2SV> } else if ( input [ 1 ] == 's' ) { //<S2SV> const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; //<S2SV> ut64 newaddr ; //<S2SV> int ret ; //<S2SV> for ( ; ; ) { //<S2SV> op = r_core_anal_op ( core , addr ) ; //<S2SV> if ( ! op ) { //<S2SV> break ; //<S2SV> } //<S2SV> if ( op -> type == R_ANAL_OP_TYPE_SWI ) { //<S2SV> eprintf ( "syscall<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , addr ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( op -> type == R_ANAL_OP_TYPE_TRAP ) { //<S2SV> eprintf ( "trap<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , addr ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; //<S2SV> r_anal_op_free ( op ) ; //<S2SV> op = NULL ; //<S2SV> if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) { //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! ret ) //<S2SV> break ; //<S2SV> r_core_cmd0 ( core , ".ar*" ) ; //<S2SV> newaddr = r_num_get ( core -> num , pc ) ; //<S2SV> if ( addr == newaddr ) { //<S2SV> addr ++ ; //<S2SV> break ; //<S2SV> } else { //<S2SV> addr = newaddr ; //<S2SV> } //<S2SV> } //<S2SV> if ( op ) { //<S2SV> r_anal_op_free ( op ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( input [ 1 ] == 'u' && input [ 2 ] == 'e' ) //<S2SV> until_expr = input + 3 ; //<S2SV> else if ( input [ 1 ] == 'u' ) //<S2SV> until_addr = r_num_math ( core -> num , input + 2 ) ; //<S2SV> else until_expr = "0" ; //<S2SV> r_core_esil_step ( core , until_addr , until_expr , NULL ) ; //<S2SV> r_core_cmd0 ( core , ".ar*" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'i' : //<S2SV> switch ( input [ 1 ] ) { //<S2SV> case 's' : //<S2SV> case 'm' : //<S2SV> cmd_esil_mem ( core , input + 2 ) ; //<S2SV> break ; //<S2SV> case 'p' : //<S2SV> r_core_cmd0 ( core , "ar<S2SV_blank>PC=$$" ) ; //<S2SV> break ; //<S2SV> case '?' : //<S2SV> cmd_esil_mem ( core , "?" ) ; //<S2SV> break ; //<S2SV> case '-' : //<S2SV> if ( esil ) { //<S2SV> sdb_reset ( esil -> stats ) ; //<S2SV> } //<S2SV> r_anal_esil_free ( esil ) ; //<S2SV> core -> anal -> esil = NULL ; //<S2SV> break ; //<S2SV> case 0 : //<S2SV> r_anal_esil_free ( esil ) ; //<S2SV> { //<S2SV> const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; //<S2SV> if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) { //<S2SV> r_core_cmd0 ( core , "ar<S2SV_blank>PC=$$" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) { //<S2SV> return ; //<S2SV> } //<S2SV> r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; //<S2SV> esil -> verbose = ( int ) r_config_get_i ( core -> config , "esil.verbose" ) ; //<S2SV> { //<S2SV> const char * s = r_config_get ( core -> config , "cmd.esil.intr" ) ; //<S2SV> if ( s ) { //<S2SV> char * my = strdup ( s ) ; //<S2SV> if ( my ) { //<S2SV> r_config_set ( core -> config , "cmd.esil.intr" , my ) ; //<S2SV> free ( my ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'k' : //<S2SV> switch ( input [ 1 ] ) { //<S2SV> case '\\0' : //<S2SV> input = "123*" ; //<S2SV> case '<S2SV_blank>' : //<S2SV> if ( esil && esil -> stats ) { //<S2SV> char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ; //<S2SV> if ( out ) { //<S2SV> r_cons_println ( out ) ; //<S2SV> free ( out ) ; //<S2SV> } //<S2SV> } else { //<S2SV> eprintf ( "esil.stats<S2SV_blank>is<S2SV_blank>empty.<S2SV_blank>Run<S2SV_blank>\'aei\'\\n" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case '-' : //<S2SV> if ( esil ) { //<S2SV> sdb_reset ( esil -> stats ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'f' : //<S2SV> { //<S2SV> RListIter * iter ; //<S2SV> RAnalBlock * bb ; //<S2SV> RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , //<S2SV> core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ; //<S2SV> if ( fcn ) { //<S2SV> r_list_foreach ( fcn -> bbs , iter , bb ) { //<S2SV> ut64 pc = bb -> addr ; //<S2SV> ut64 end = bb -> addr + bb -> size ; //<S2SV> RAnalOp op ; //<S2SV> ut8 * buf ; //<S2SV> int ret , bbs = end - pc ; //<S2SV> if ( bbs < 1 || bbs > 0xfffff ) { //<S2SV> eprintf ( "Invalid<S2SV_blank>block<S2SV_blank>size\\n" ) ; //<S2SV> } //<S2SV> buf = calloc ( 1 , bbs + 1 ) ; //<S2SV> r_io_read_at ( core -> io , pc , buf , bbs ) ; //<S2SV> int left ; //<S2SV> while ( pc < end ) { //<S2SV> left = R_MIN ( end - pc , 32 ) ; //<S2SV> r_asm_set_pc ( core -> assembler , pc ) ; //<S2SV> ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ; //<S2SV> if ( ret ) { //<S2SV> r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ; //<S2SV> r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ; //<S2SV> r_anal_esil_dumpstack ( esil ) ; //<S2SV> r_anal_esil_stack_free ( esil ) ; //<S2SV> pc += op . size ; //<S2SV> } else { //<S2SV> pc += 4 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> eprintf ( "Cannot<S2SV_blank>find<S2SV_blank>function<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , core -> offset ) ; //<S2SV> } //<S2SV> } break ; //<S2SV> case 't' : //<S2SV> switch ( input [ 1 ] ) { //<S2SV> case 'r' : //<S2SV> { //<S2SV> RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; //<S2SV> if ( ! esil ) { //<S2SV> return ; //<S2SV> } //<S2SV> r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; //<S2SV> r_anal_esil_set_pc ( esil , core -> offset ) ; //<S2SV> r_anal_esil_parse ( esil , input + 2 ) ; //<S2SV> r_anal_esil_dumpstack ( esil ) ; //<S2SV> r_anal_esil_free ( esil ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 's' : //<S2SV> switch ( input [ 2 ] ) { //<S2SV> case 0 : //<S2SV> r_anal_esil_session_list ( esil ) ; //<S2SV> break ; //<S2SV> case '+' : //<S2SV> r_anal_esil_session_add ( esil ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> r_core_cmd_help ( core , help_msg_aets ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> eprintf ( "Unknown<S2SV_blank>command.<S2SV_blank>Use<S2SV_blank>`aetr`.\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'A' : //<S2SV> if ( input [ 1 ] == '?' ) { //<S2SV> r_core_cmd_help ( core , help_msg_aea ) ; //<S2SV> } else if ( input [ 1 ] == 'r' ) { //<S2SV> cmd_aea ( core , 1 + ( 1 << 1 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == 'w' ) { //<S2SV> cmd_aea ( core , 1 + ( 1 << 2 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == 'n' ) { //<S2SV> cmd_aea ( core , 1 + ( 1 << 3 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == 'j' ) { //<S2SV> cmd_aea ( core , 1 + ( 1 << 4 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == '*' ) { //<S2SV> cmd_aea ( core , 1 + ( 1 << 5 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == 'f' ) { //<S2SV> RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; //<S2SV> if ( fcn ) { //<S2SV> cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; //<S2SV> } //<S2SV> } else { //<S2SV> cmd_aea ( core , 1 , core -> offset , ( int ) r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'a' : //<S2SV> if ( input [ 1 ] == '?' ) { //<S2SV> r_core_cmd_help ( core , help_msg_aea ) ; //<S2SV> } else if ( input [ 1 ] == 'r' ) { //<S2SV> cmd_aea ( core , 1 << 1 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == 'w' ) { //<S2SV> cmd_aea ( core , 1 << 2 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == 'n' ) { //<S2SV> cmd_aea ( core , 1 << 3 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == 'j' ) { //<S2SV> cmd_aea ( core , 1 << 4 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == '*' ) { //<S2SV> cmd_aea ( core , 1 << 5 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; //<S2SV> } else if ( input [ 1 ] == 'f' ) { //<S2SV> RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; //<S2SV> if ( fcn ) { //<S2SV> switch ( input [ 2 ] ) { //<S2SV> case 'j' : //<S2SV> cmd_aea ( core , 1 << 4 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } else { //<S2SV> const char * arg = input [ 1 ] ? input + 2 : "" ; //<S2SV> ut64 len = r_num_math ( core -> num , arg ) ; //<S2SV> cmd_aea ( core , 0 , core -> offset , len ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'x' : { //<S2SV> char * hex ; //<S2SV> int ret , bufsz ; //<S2SV> input = r_str_trim_ro ( input + 1 ) ; //<S2SV> hex = strdup ( input ) ; //<S2SV> if ( ! hex ) { //<S2SV> break ; //<S2SV> } //<S2SV> RAnalOp aop = R_EMPTY ; //<S2SV> bufsz = r_hex_str2bin ( hex , ( ut8 * ) hex ) ; //<S2SV> ret = r_anal_op ( core -> anal , & aop , core -> offset , //<S2SV> ( const ut8 * ) hex , bufsz , R_ANAL_OP_MASK_ALL ) ; //<S2SV> if ( ret > 0 ) { //<S2SV> const char * str = R_STRBUF_SAFEGET ( & aop . esil ) ; //<S2SV> char * str2 = r_str_newf ( "<S2SV_blank>%s" , str ) ; //<S2SV> cmd_anal_esil ( core , str2 ) ; //<S2SV> free ( str2 ) ; //<S2SV> } //<S2SV> r_anal_op_fini ( & aop ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case '?' : //<S2SV> if ( input [ 1 ] == '?' ) { //<S2SV> r_core_cmd_help ( core , help_detail_ae ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> r_core_cmd_help ( core , help_msg_ae ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> 