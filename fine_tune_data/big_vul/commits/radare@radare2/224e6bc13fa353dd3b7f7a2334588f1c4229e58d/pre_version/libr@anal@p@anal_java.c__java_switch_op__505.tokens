static int java_switch_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { //<S2SV> ut8 op_byte = data [ 0 ] ; //<S2SV> ut64 offset = addr - java_get_method_start ( ) ; //<S2SV> ut8 pos = ( offset + 1 ) % 4 ? 1 + 4 - ( offset + 1 ) % 4 : 1 ; //<S2SV> if ( op_byte == 0xaa ) { //<S2SV> if ( pos + 8 > len ) { //<S2SV> return op -> size ; //<S2SV> } //<S2SV> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , //<S2SV> max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ; //<S2SV> ut32 default_loc = ( ut32 ) ( UINT ( data , pos ) ) , cur_case = 0 ; //<S2SV> op -> switch_op = r_anal_switch_op_new ( addr , min_val , default_loc ) ; //<S2SV> RAnalCaseOp * caseop = NULL ; //<S2SV> pos += 12 ; //<S2SV> if ( max_val > min_val && ( ( max_val - min_val ) < ( UT16_MAX / 4 ) ) ) { //<S2SV> for ( cur_case = 0 ; cur_case <= max_val - min_val ; pos += 4 , cur_case ++ ) { //<S2SV> if ( pos + 4 >= len ) { //<S2SV> break ; //<S2SV> } //<S2SV> int offset = ( int ) ( ut32 ) ( R_BIN_JAVA_UINT ( data , pos ) ) ; //<S2SV> caseop = r_anal_switch_op_add_case ( op -> switch_op , //<S2SV> addr + pos , cur_case + min_val , addr + offset ) ; //<S2SV> if ( caseop ) { //<S2SV> caseop -> bb_ref_to = addr + offset ; //<S2SV> caseop -> bb_ref_from = addr ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> eprintf ( "Invalid<S2SV_blank>switch<S2SV_blank>boundaries<S2SV_blank>at<S2SV_blank>0x%" PFMT64x "\\n" , addr ) ; //<S2SV> } //<S2SV> } //<S2SV> op -> size = pos ; //<S2SV> return op -> size ; //<S2SV> } //<S2SV> 