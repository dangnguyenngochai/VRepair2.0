static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { //<S2SV> ut8 * end , * need = NULL ; //<S2SV> const char * section_name = "" ; //<S2SV> Elf_ ( Shdr ) * link_shdr = NULL ; //<S2SV> const char * link_section_name = "" ; //<S2SV> Sdb * sdb_vernaux = NULL ; //<S2SV> Sdb * sdb_version = NULL ; //<S2SV> Sdb * sdb = NULL ; //<S2SV> int i , cnt ; //<S2SV> if ( ! bin || ! bin -> dynstr ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( shdr -> sh_size < 1 ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> sdb = sdb_new0 ( ) ; //<S2SV> if ( ! sdb ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> link_shdr = & bin -> shdr [ shdr -> sh_link ] ; //<S2SV> if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { //<S2SV> section_name = & bin -> shstrtab [ shdr -> sh_name ] ; //<S2SV> } //<S2SV> if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { //<S2SV> link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; //<S2SV> } //<S2SV> if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { //<S2SV> bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Elf_(Verneed)\\n" ) ; //<S2SV> goto beach ; //<S2SV> } //<S2SV> end = need + shdr -> sh_size ; //<S2SV> sdb_set ( sdb , "section_name" , section_name , 0 ) ; //<S2SV> sdb_num_set ( sdb , "num_entries" , shdr -> sh_info , 0 ) ; //<S2SV> sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; //<S2SV> sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; //<S2SV> sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; //<S2SV> sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; //<S2SV> if ( shdr -> sh_offset > bin -> size || shdr -> sh_offset + shdr -> sh_size > bin -> size ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> if ( shdr -> sh_offset + shdr -> sh_size < shdr -> sh_size ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> i = r_buf_read_at ( bin -> b , shdr -> sh_offset , need , shdr -> sh_size ) ; //<S2SV> if ( i < 0 ) //<S2SV> goto beach ; //<S2SV> for ( i = 0 , cnt = 0 ; cnt < shdr -> sh_info ; ++ cnt ) { //<S2SV> int j , isum ; //<S2SV> ut8 * vstart = need + i ; //<S2SV> Elf_ ( Verneed ) vvn = { 0 } ; //<S2SV> if ( vstart + sizeof ( Elf_ ( Verneed ) ) > end ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> Elf_ ( Verneed ) * entry = & vvn ; //<S2SV> char key [ 32 ] = { 0 } ; //<S2SV> sdb_version = sdb_new0 ( ) ; //<S2SV> if ( ! sdb_version ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> j = 0 ; //<S2SV> vvn . vn_version = READ16 ( vstart , j ) //<S2SV> vvn . vn_cnt = READ16 ( vstart , j ) //<S2SV> vvn . vn_file = READ32 ( vstart , j ) //<S2SV> vvn . vn_aux = READ32 ( vstart , j ) //<S2SV> vvn . vn_next = READ32 ( vstart , j ) //<S2SV> sdb_num_set ( sdb_version , "vn_version" , entry -> vn_version , 0 ) ; //<S2SV> sdb_num_set ( sdb_version , "idx" , i , 0 ) ; //<S2SV> if ( entry -> vn_file > bin -> dynstr_size ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> { //<S2SV> char * s = r_str_ndup ( & bin -> dynstr [ entry -> vn_file ] , 16 ) ; //<S2SV> sdb_set ( sdb_version , "file_name" , s , 0 ) ; //<S2SV> free ( s ) ; //<S2SV> } //<S2SV> sdb_num_set ( sdb_version , "cnt" , entry -> vn_cnt , 0 ) ; //<S2SV> st32 vnaux = entry -> vn_aux ; //<S2SV> if ( vnaux < 1 ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> vstart += vnaux ; //<S2SV> for ( j = 0 , isum = i + entry -> vn_aux ; j < entry -> vn_cnt && vstart + sizeof ( Elf_ ( Vernaux ) ) <= end ; ++ j ) { //<S2SV> int k ; //<S2SV> Elf_ ( Vernaux ) * aux = NULL ; //<S2SV> Elf_ ( Vernaux ) vaux = { 0 } ; //<S2SV> sdb_vernaux = sdb_new0 ( ) ; //<S2SV> if ( ! sdb_vernaux ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> aux = ( Elf_ ( Vernaux ) * ) & vaux ; //<S2SV> k = 0 ; //<S2SV> vaux . vna_hash = READ32 ( vstart , k ) //<S2SV> vaux . vna_flags = READ16 ( vstart , k ) //<S2SV> vaux . vna_other = READ16 ( vstart , k ) //<S2SV> vaux . vna_name = READ32 ( vstart , k ) //<S2SV> vaux . vna_next = READ32 ( vstart , k ) //<S2SV> if ( aux -> vna_name > bin -> dynstr_size ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> sdb_num_set ( sdb_vernaux , "idx" , isum , 0 ) ; //<S2SV> if ( aux -> vna_name > 0 && aux -> vna_name + 8 < bin -> dynstr_size ) { //<S2SV> char name [ 16 ] ; //<S2SV> strncpy ( name , & bin -> dynstr [ aux -> vna_name ] , sizeof ( name ) - 1 ) ; //<S2SV> name [ sizeof ( name ) - 1 ] = 0 ; //<S2SV> sdb_set ( sdb_vernaux , "name" , name , 0 ) ; //<S2SV> } //<S2SV> sdb_set ( sdb_vernaux , "flags" , get_ver_flags ( aux -> vna_flags ) , 0 ) ; //<S2SV> sdb_num_set ( sdb_vernaux , "version" , aux -> vna_other , 0 ) ; //<S2SV> isum += aux -> vna_next ; //<S2SV> vstart += aux -> vna_next ; //<S2SV> snprintf ( key , sizeof ( key ) , "vernaux%d" , j ) ; //<S2SV> sdb_ns_set ( sdb_version , key , sdb_vernaux ) ; //<S2SV> } //<S2SV> if ( ( int ) entry -> vn_next < 0 ) { //<S2SV> bprintf ( "Invalid<S2SV_blank>vn_next\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> i += entry -> vn_next ; //<S2SV> snprintf ( key , sizeof ( key ) , "version%d" , cnt ) ; //<S2SV> sdb_ns_set ( sdb , key , sdb_version ) ; //<S2SV> if ( ! entry -> vn_next ) { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> free ( need ) ; //<S2SV> return sdb ; //<S2SV> beach : //<S2SV> free ( need ) ; //<S2SV> sdb_free ( sdb_vernaux ) ; //<S2SV> sdb_free ( sdb_version ) ; //<S2SV> sdb_free ( sdb ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 