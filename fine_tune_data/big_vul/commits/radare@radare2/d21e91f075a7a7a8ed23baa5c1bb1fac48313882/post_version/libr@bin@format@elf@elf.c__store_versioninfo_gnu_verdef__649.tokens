static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { //<S2SV> const char * section_name = "" ; //<S2SV> const char * link_section_name = "" ; //<S2SV> char * end = NULL ; //<S2SV> Elf_ ( Shdr ) * link_shdr = NULL ; //<S2SV> ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; //<S2SV> Sdb * sdb ; //<S2SV> int cnt , i ; //<S2SV> if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { //<S2SV> return false ; //<S2SV> } //<S2SV> link_shdr = & bin -> shdr [ shdr -> sh_link ] ; //<S2SV> if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { //<S2SV> return false ; //<S2SV> } //<S2SV> Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; //<S2SV> if ( ! defs ) { //<S2SV> return false ; //<S2SV> } //<S2SV> if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { //<S2SV> section_name = & bin -> shstrtab [ shdr -> sh_name ] ; //<S2SV> } //<S2SV> if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { //<S2SV> link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; //<S2SV> } //<S2SV> if ( ! defs ) { //<S2SV> bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n" ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> sdb = sdb_new0 ( ) ; //<S2SV> end = ( char * ) defs + shdr -> sh_size ; //<S2SV> sdb_set ( sdb , "section_name" , section_name , 0 ) ; //<S2SV> sdb_num_set ( sdb , "entries" , shdr -> sh_info , 0 ) ; //<S2SV> sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; //<S2SV> sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; //<S2SV> sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; //<S2SV> sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; //<S2SV> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ; ++ cnt ) { //<S2SV> Sdb * sdb_verdef = sdb_new0 ( ) ; //<S2SV> char * vstart = ( ( char * ) defs ) + i ; //<S2SV> char key [ 32 ] = { 0 } ; //<S2SV> Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; //<S2SV> Elf_ ( Verdaux ) aux = { 0 } ; //<S2SV> int j = 0 ; //<S2SV> int isum = 0 ; //<S2SV> r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; //<S2SV> verdef -> vd_version = READ16 ( dfs , j ) //<S2SV> verdef -> vd_flags = READ16 ( dfs , j ) //<S2SV> verdef -> vd_ndx = READ16 ( dfs , j ) //<S2SV> verdef -> vd_cnt = READ16 ( dfs , j ) //<S2SV> verdef -> vd_hash = READ32 ( dfs , j ) //<S2SV> verdef -> vd_aux = READ32 ( dfs , j ) //<S2SV> verdef -> vd_next = READ32 ( dfs , j ) //<S2SV> int vdaux = verdef -> vd_aux ; //<S2SV> if ( vdaux < 1 || vstart + vdaux < vstart ) { //<S2SV> sdb_free ( sdb_verdef ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> vstart += vdaux ; //<S2SV> if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { //<S2SV> sdb_free ( sdb_verdef ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> j = 0 ; //<S2SV> aux . vda_name = READ32 ( vstart , j ) //<S2SV> aux . vda_next = READ32 ( vstart , j ) //<S2SV> isum = i + verdef -> vd_aux ; //<S2SV> if ( aux . vda_name > bin -> dynstr_size ) { //<S2SV> sdb_free ( sdb_verdef ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> sdb_num_set ( sdb_verdef , "idx" , i , 0 ) ; //<S2SV> sdb_num_set ( sdb_verdef , "vd_version" , verdef -> vd_version , 0 ) ; //<S2SV> sdb_num_set ( sdb_verdef , "vd_ndx" , verdef -> vd_ndx , 0 ) ; //<S2SV> sdb_num_set ( sdb_verdef , "vd_cnt" , verdef -> vd_cnt , 0 ) ; //<S2SV> sdb_set ( sdb_verdef , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; //<S2SV> sdb_set ( sdb_verdef , "flags" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; //<S2SV> for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { //<S2SV> int k ; //<S2SV> Sdb * sdb_parent = sdb_new0 ( ) ; //<S2SV> isum += aux . vda_next ; //<S2SV> vstart += aux . vda_next ; //<S2SV> if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { //<S2SV> sdb_free ( sdb_verdef ) ; //<S2SV> sdb_free ( sdb_parent ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> k = 0 ; //<S2SV> aux . vda_name = READ32 ( vstart , k ) //<S2SV> aux . vda_next = READ32 ( vstart , k ) //<S2SV> if ( aux . vda_name > bin -> dynstr_size ) { //<S2SV> sdb_free ( sdb_verdef ) ; //<S2SV> sdb_free ( sdb_parent ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> sdb_num_set ( sdb_parent , "idx" , isum , 0 ) ; //<S2SV> sdb_num_set ( sdb_parent , "parent" , j , 0 ) ; //<S2SV> sdb_set ( sdb_parent , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; //<S2SV> snprintf ( key , sizeof ( key ) , "parent%d" , j - 1 ) ; //<S2SV> sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; //<S2SV> } //<S2SV> snprintf ( key , sizeof ( key ) , "verdef%d" , cnt ) ; //<S2SV> sdb_ns_set ( sdb , key , sdb_verdef ) ; //<S2SV> if ( ! verdef -> vd_next ) { //<S2SV> sdb_free ( sdb_verdef ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> if ( ( st32 ) verdef -> vd_next < 1 ) { //<S2SV> eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> i += verdef -> vd_next ; //<S2SV> } //<S2SV> free ( defs ) ; //<S2SV> return sdb ; //<S2SV> out_error : //<S2SV> free ( defs ) ; //<S2SV> sdb_free ( sdb ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 