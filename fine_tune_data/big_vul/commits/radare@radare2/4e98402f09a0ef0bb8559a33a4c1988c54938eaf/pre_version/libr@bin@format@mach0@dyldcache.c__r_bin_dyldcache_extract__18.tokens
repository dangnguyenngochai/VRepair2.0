struct r_bin_dyldcache_lib_t * r_bin_dyldcache_extract ( struct r_bin_dyldcache_obj_t * bin , int idx , int * nlib ) { //<S2SV> ut64 liboff , linkedit_offset ; //<S2SV> ut64 dyld_vmbase ; //<S2SV> ut32 addend = 0 ; //<S2SV> struct r_bin_dyldcache_lib_t * ret = NULL ; //<S2SV> struct dyld_cache_image_info * image_infos = NULL ; //<S2SV> struct mach_header * mh ; //<S2SV> ut8 * data , * cmdptr ; //<S2SV> int cmd , libsz = 0 ; //<S2SV> RBuffer * dbuf ; //<S2SV> char * libname ; //<S2SV> if ( ! bin ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( bin -> size < 1 ) { //<S2SV> eprintf ( "Empty<S2SV_blank>file?<S2SV_blank>(%s)\\n" , bin -> file ? bin -> file : "(null)" ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( bin -> nlibs < 0 || idx < 0 || idx >= bin -> nlibs ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> * nlib = bin -> nlibs ; //<S2SV> ret = R_NEW0 ( struct r_bin_dyldcache_lib_t ) ; //<S2SV> if ( ! ret ) { //<S2SV> perror ( "malloc<S2SV_blank>(ret)" ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( bin -> hdr . startaddr > bin -> size ) { //<S2SV> eprintf ( "corrupted<S2SV_blank>dyldcache" ) ; //<S2SV> free ( ret ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) { //<S2SV> eprintf ( "corrupted<S2SV_blank>dyldcache" ) ; //<S2SV> free ( ret ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ; //<S2SV> dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ; //<S2SV> liboff = image_infos [ idx ] . address - dyld_vmbase ; //<S2SV> if ( liboff > bin -> size ) { //<S2SV> eprintf ( "Corrupted<S2SV_blank>file\\n" ) ; //<S2SV> free ( ret ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> ret -> offset = liboff ; //<S2SV> if ( image_infos [ idx ] . pathFileOffset > bin -> size ) { //<S2SV> eprintf ( "corrupted<S2SV_blank>file\\n" ) ; //<S2SV> free ( ret ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ; //<S2SV> data = bin -> b -> buf + liboff ; //<S2SV> mh = ( struct mach_header * ) data ; //<S2SV> if ( mh -> magic != MH_MAGIC && mh -> magic != MH_MAGIC_64 ) { //<S2SV> if ( mh -> magic == 0xbebafeca ) { //<S2SV> eprintf ( "FAT<S2SV_blank>Binary\\n" ) ; //<S2SV> } //<S2SV> eprintf ( "Not<S2SV_blank>mach-o\\n" ) ; //<S2SV> free ( ret ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! ( dbuf = r_buf_new ( ) ) ) { //<S2SV> eprintf ( "new<S2SV_blank>(dbuf)\\n" ) ; //<S2SV> free ( ret ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> addend = mh -> magic == MH_MAGIC ? sizeof ( struct mach_header ) : sizeof ( struct mach_header_64 ) ; //<S2SV> r_buf_set_bytes ( dbuf , data , addend ) ; //<S2SV> cmdptr = data + addend ; //<S2SV> for ( cmd = 0 ; cmd < mh -> ncmds ; cmd ++ ) { //<S2SV> struct load_command * lc = ( struct load_command * ) cmdptr ; //<S2SV> r_buf_append_bytes ( dbuf , ( ut8 * ) lc , lc -> cmdsize ) ; //<S2SV> cmdptr += lc -> cmdsize ; //<S2SV> } //<S2SV> cmdptr = data + addend ; //<S2SV> for ( cmd = linkedit_offset = 0 ; cmd < mh -> ncmds ; cmd ++ ) { //<S2SV> struct load_command * lc = ( struct load_command * ) cmdptr ; //<S2SV> cmdptr += lc -> cmdsize ; //<S2SV> switch ( lc -> cmd ) { //<S2SV> case LC_SEGMENT : //<S2SV> { //<S2SV> struct segment_command * seg = ( struct segment_command * ) lc ; //<S2SV> int t = seg -> filesize ; //<S2SV> if ( seg -> fileoff + seg -> filesize > bin -> size || seg -> fileoff > bin -> size ) { //<S2SV> eprintf ( "malformed<S2SV_blank>dyldcache\\n" ) ; //<S2SV> free ( ret ) ; //<S2SV> r_buf_free ( dbuf ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> r_buf_append_bytes ( dbuf , bin -> b -> buf + seg -> fileoff , t ) ; //<S2SV> r_bin_dyldcache_apply_patch ( dbuf , dbuf -> length , ( ut64 ) ( ( size_t ) & seg -> fileoff - ( size_t ) data ) ) ; //<S2SV> int sect_offset = seg -> fileoff - libsz ; //<S2SV> libsz = dbuf -> length ; //<S2SV> if ( ! strcmp ( seg -> segname , "__LINKEDIT" ) ) { //<S2SV> linkedit_offset = sect_offset ; //<S2SV> } //<S2SV> if ( seg -> nsects > 0 ) { //<S2SV> struct section * sects = ( struct section * ) ( ( ut8 * ) seg + sizeof ( struct segment_command ) ) ; //<S2SV> int nsect ; //<S2SV> for ( nsect = 0 ; nsect < seg -> nsects ; nsect ++ ) { //<S2SV> if ( sects [ nsect ] . offset > libsz ) { //<S2SV> r_bin_dyldcache_apply_patch ( dbuf , sects [ nsect ] . offset - sect_offset , //<S2SV> ( ut64 ) ( ( size_t ) & sects [ nsect ] . offset - ( size_t ) data ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case LC_SYMTAB : //<S2SV> { //<S2SV> struct symtab_command * st = ( struct symtab_command * ) lc ; //<S2SV> NZ_OFFSET ( st -> symoff ) ; //<S2SV> NZ_OFFSET ( st -> stroff ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case LC_DYSYMTAB : //<S2SV> { //<S2SV> struct dysymtab_command * st = ( struct dysymtab_command * ) lc ; //<S2SV> NZ_OFFSET ( st -> tocoff ) ; //<S2SV> NZ_OFFSET ( st -> modtaboff ) ; //<S2SV> NZ_OFFSET ( st -> extrefsymoff ) ; //<S2SV> NZ_OFFSET ( st -> indirectsymoff ) ; //<S2SV> NZ_OFFSET ( st -> extreloff ) ; //<S2SV> NZ_OFFSET ( st -> locreloff ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case LC_DYLD_INFO : //<S2SV> case LC_DYLD_INFO_ONLY : //<S2SV> { //<S2SV> struct dyld_info_command * st = ( struct dyld_info_command * ) lc ; //<S2SV> NZ_OFFSET ( st -> rebase_off ) ; //<S2SV> NZ_OFFSET ( st -> bind_off ) ; //<S2SV> NZ_OFFSET ( st -> weak_bind_off ) ; //<S2SV> NZ_OFFSET ( st -> lazy_bind_off ) ; //<S2SV> NZ_OFFSET ( st -> export_off ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ret -> b = dbuf ; //<S2SV> strncpy ( ret -> path , libname , sizeof ( ret -> path ) - 1 ) ; //<S2SV> ret -> size = libsz ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 