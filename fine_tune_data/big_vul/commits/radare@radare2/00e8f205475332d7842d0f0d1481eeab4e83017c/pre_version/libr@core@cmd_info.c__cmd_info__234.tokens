static int cmd_info ( void * data , const char * input ) { //<S2SV> RCore * core = ( RCore * ) data ; //<S2SV> bool newline = r_config_get_i ( core -> config , "scr.interactive" ) ; //<S2SV> RBinObject * o = r_bin_cur_object ( core -> bin ) ; //<S2SV> RCoreFile * cf = core -> file ; //<S2SV> int i , va = core -> io -> va || core -> io -> debug ; //<S2SV> int mode = 0 ; //<S2SV> int is_array = 0 ; //<S2SV> Sdb * db ; //<S2SV> for ( i = 0 ; input [ i ] && input [ i ] != '<S2SV_blank>' ; i ++ ) //<S2SV> ; //<S2SV> if ( i > 0 ) { //<S2SV> switch ( input [ i - 1 ] ) { //<S2SV> case '*' : mode = R_CORE_BIN_RADARE ; break ; //<S2SV> case 'j' : mode = R_CORE_BIN_JSON ; break ; //<S2SV> case 'q' : mode = R_CORE_BIN_SIMPLE ; break ; //<S2SV> } //<S2SV> } //<S2SV> if ( mode == R_CORE_BIN_JSON ) { //<S2SV> if ( strlen ( input + 1 ) > 1 ) { //<S2SV> is_array = 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( is_array ) { //<S2SV> r_cons_printf ( "{" ) ; //<S2SV> } //<S2SV> if ( ! * input ) { //<S2SV> cmd_info_bin ( core , va , mode ) ; //<S2SV> } //<S2SV> if ( ! strcmp ( input , "*" ) ) { //<S2SV> input = "I*" ; //<S2SV> } //<S2SV> RBinObject * obj = r_bin_cur_object ( core -> bin ) ; //<S2SV> while ( * input ) { //<S2SV> switch ( * input ) { //<S2SV> case 'b' : //<S2SV> { //<S2SV> ut64 baddr = r_config_get_i ( core -> config , "bin.baddr" ) ; //<S2SV> if ( input [ 1 ] == '<S2SV_blank>' ) { //<S2SV> baddr = r_num_math ( core -> num , input + 1 ) ; //<S2SV> } //<S2SV> r_core_bin_reload ( core , NULL , baddr ) ; //<S2SV> r_core_block_read ( core ) ; //<S2SV> newline = false ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'k' : //<S2SV> db = o ? o -> kv : NULL ; //<S2SV> switch ( input [ 1 ] ) { //<S2SV> case 'v' : //<S2SV> if ( db ) { //<S2SV> char * o = sdb_querys ( db , NULL , 0 , input + 3 ) ; //<S2SV> if ( o && * o ) { //<S2SV> r_cons_print ( o ) ; //<S2SV> } //<S2SV> free ( o ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case '*' : //<S2SV> r_core_bin_export_info_rad ( core ) ; //<S2SV> break ; //<S2SV> case '.' : //<S2SV> case '<S2SV_blank>' : //<S2SV> if ( db ) { //<S2SV> char * o = sdb_querys ( db , NULL , 0 , input + 2 ) ; //<S2SV> if ( o && * o ) { //<S2SV> r_cons_print ( o ) ; //<S2SV> } //<S2SV> free ( o ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case '\\0' : //<S2SV> if ( db ) { //<S2SV> char * o = sdb_querys ( db , NULL , 0 , "*" ) ; //<S2SV> if ( o && * o ) { //<S2SV> r_cons_print ( o ) ; //<S2SV> } //<S2SV> free ( o ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case '?' : //<S2SV> default : //<S2SV> eprintf ( "Usage:<S2SV_blank>ik<S2SV_blank>[sdb-query]\\n" ) ; //<S2SV> eprintf ( "Usage:<S2SV_blank>ik*<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#<S2SV_blank>load<S2SV_blank>all<S2SV_blank>header<S2SV_blank>information\\n" ) ; //<S2SV> } //<S2SV> goto done ; //<S2SV> break ; //<S2SV> case 'o' : //<S2SV> { //<S2SV> if ( ! cf ) { //<S2SV> eprintf ( "Core<S2SV_blank>file<S2SV_blank>not<S2SV_blank>open\\n" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> const char * fn = input [ 1 ] == '<S2SV_blank>' ? input + 2 : cf -> desc -> name ; //<S2SV> ut64 baddr = r_config_get_i ( core -> config , "bin.baddr" ) ; //<S2SV> r_core_bin_load ( core , fn , baddr ) ; //<S2SV> } //<S2SV> break ; //<S2SV> # define RBININFO ( n , x , y , z ) if ( is_array ) { if ( is_array == 1 ) { is_array ++ ; } else { r_cons_printf ( "," ) ; } r_cons_printf ( "\\"%s\\":" , n ) ; } if ( z ) { playMsg ( core , n , z ) ; } r_core_bin_info ( core , x , mode , va , NULL , y ) ; //<S2SV> case 'A' : //<S2SV> newline = false ; //<S2SV> if ( input [ 1 ] == 'j' ) { //<S2SV> r_cons_printf ( "{" ) ; //<S2SV> r_bin_list_archs ( core -> bin , 'j' ) ; //<S2SV> r_cons_printf ( "}\\n" ) ; //<S2SV> } else { //<S2SV> r_bin_list_archs ( core -> bin , 1 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'E' : RBININFO ( "exports" , R_CORE_BIN_ACC_EXPORTS , NULL , 0 ) ; break ; //<S2SV> case 'Z' : RBININFO ( "size" , R_CORE_BIN_ACC_SIZE , NULL , 0 ) ; break ; //<S2SV> case 'S' : //<S2SV> if ( ( input [ 1 ] == 'm' && input [ 2 ] == 'z' ) || ! input [ 1 ] ) { //<S2SV> RBININFO ( "sections" , R_CORE_BIN_ACC_SECTIONS , NULL , 0 ) ; //<S2SV> } else { //<S2SV> RBinObject * obj = r_bin_cur_object ( core -> bin ) ; //<S2SV> if ( mode == R_CORE_BIN_RADARE || mode == R_CORE_BIN_JSON || mode == R_CORE_BIN_SIMPLE ) { //<S2SV> RBININFO ( "sections" , R_CORE_BIN_ACC_SECTIONS , input + 2 , //<S2SV> obj ? r_list_length ( obj -> sections ) : 0 ) ; //<S2SV> } else { //<S2SV> RBININFO ( "sections" , R_CORE_BIN_ACC_SECTIONS , input + 1 , //<S2SV> obj ? r_list_length ( obj -> sections ) : 0 ) ; //<S2SV> } //<S2SV> while ( * ( ++ input ) ) ; //<S2SV> input -- ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'H' : //<S2SV> if ( input [ 1 ] == 'H' ) { //<S2SV> RBININFO ( "header" , R_CORE_BIN_ACC_HEADER , NULL , - 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'h' : RBININFO ( "fields" , R_CORE_BIN_ACC_FIELDS , NULL , 0 ) ; break ; //<S2SV> case 'l' : RBININFO ( "libs" , R_CORE_BIN_ACC_LIBS , NULL , obj ? r_list_length ( obj -> libs ) : 0 ) ; break ; //<S2SV> case 'L' : //<S2SV> { //<S2SV> char * ptr = strchr ( input , '<S2SV_blank>' ) ; //<S2SV> int json = input [ 1 ] == 'j' ? 'j' : 0 ; //<S2SV> if ( ptr && ptr [ 1 ] ) { //<S2SV> const char * plugin_name = ptr + 1 ; //<S2SV> if ( is_array ) { //<S2SV> r_cons_printf ( "\\"plugin\\":<S2SV_blank>" ) ; //<S2SV> } //<S2SV> r_bin_list_plugin ( core -> bin , plugin_name , json ) ; //<S2SV> } else { //<S2SV> r_bin_list ( core -> bin , json ) ; //<S2SV> } //<S2SV> newline = false ; //<S2SV> goto done ; //<S2SV> } //<S2SV> break ; //<S2SV> case 's' : //<S2SV> if ( input [ 1 ] == '.' ) { //<S2SV> ut64 addr = core -> offset + ( core -> print -> cur_enabled ? core -> print -> cur : 0 ) ; //<S2SV> RFlagItem * f = r_flag_get_at ( core -> flags , addr , false ) ; //<S2SV> if ( f ) { //<S2SV> if ( f -> offset == addr || ! f -> offset ) { //<S2SV> r_cons_printf ( "%s" , f -> name ) ; //<S2SV> } else { //<S2SV> r_cons_printf ( "%s+%d" , f -> name , ( int ) ( addr - f -> offset ) ) ; //<S2SV> } //<S2SV> } //<S2SV> input ++ ; //<S2SV> break ; //<S2SV> } else { //<S2SV> RBinObject * obj = r_bin_cur_object ( core -> bin ) ; //<S2SV> RBININFO ( "symbols" , R_CORE_BIN_ACC_SYMBOLS , NULL , obj ? r_list_length ( obj -> symbols ) : 0 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'R' : //<S2SV> if ( input [ 1 ] == '*' ) { //<S2SV> mode = R_CORE_BIN_RADARE ; //<S2SV> } else if ( input [ 1 ] == 'j' ) { //<S2SV> mode = R_CORE_BIN_JSON ; //<S2SV> } //<S2SV> RBININFO ( "resources" , R_CORE_BIN_ACC_RESOURCES , NULL , 0 ) ; //<S2SV> break ; //<S2SV> case 'r' : RBININFO ( "relocs" , R_CORE_BIN_ACC_RELOCS , NULL , 0 ) ; break ; //<S2SV> case 'd' : RBININFO ( "dwarf" , R_CORE_BIN_ACC_DWARF , NULL , - 1 ) ; break ; //<S2SV> case 'i' : RBININFO ( "imports" , R_CORE_BIN_ACC_IMPORTS , NULL , obj ? r_list_length ( obj -> imports ) : 0 ) ; break ; //<S2SV> case 'I' : RBININFO ( "info" , R_CORE_BIN_ACC_INFO , NULL , 0 ) ; break ; //<S2SV> case 'e' : RBININFO ( "entries" , R_CORE_BIN_ACC_ENTRIES , NULL , 0 ) ; break ; //<S2SV> case 'M' : RBININFO ( "main" , R_CORE_BIN_ACC_MAIN , NULL , 0 ) ; break ; //<S2SV> case 'm' : RBININFO ( "memory" , R_CORE_BIN_ACC_MEM , NULL , 0 ) ; break ; //<S2SV> case 'V' : RBININFO ( "versioninfo" , R_CORE_BIN_ACC_VERSIONINFO , NULL , 0 ) ; break ; //<S2SV> case 'C' : RBININFO ( "signature" , R_CORE_BIN_ACC_SIGNATURE , NULL , 0 ) ; break ; //<S2SV> case 'z' : //<S2SV> if ( input [ 1 ] == 'z' ) { //<S2SV> switch ( input [ 2 ] ) { //<S2SV> case '*' : //<S2SV> mode = R_CORE_BIN_RADARE ; //<S2SV> break ; //<S2SV> case 'j' : //<S2SV> mode = R_CORE_BIN_JSON ; //<S2SV> break ; //<S2SV> case 'q' : //<S2SV> if ( input [ 3 ] == 'q' ) { //<S2SV> mode = R_CORE_BIN_SIMPLEST ; //<S2SV> input ++ ; //<S2SV> } else { //<S2SV> mode = R_CORE_BIN_SIMPLE ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> mode = R_CORE_BIN_PRINT ; //<S2SV> break ; //<S2SV> } //<S2SV> input ++ ; //<S2SV> RBININFO ( "strings" , R_CORE_BIN_ACC_RAW_STRINGS , NULL , 0 ) ; //<S2SV> } else { //<S2SV> RBinObject * obj = r_bin_cur_object ( core -> bin ) ; //<S2SV> if ( input [ 1 ] == 'q' ) { //<S2SV> mode = ( input [ 2 ] == 'q' ) //<S2SV> ? R_CORE_BIN_SIMPLEST //<S2SV> : R_CORE_BIN_SIMPLE ; //<S2SV> input ++ ; //<S2SV> } //<S2SV> if ( obj ) { //<S2SV> RBININFO ( "strings" , R_CORE_BIN_ACC_STRINGS , NULL , //<S2SV> obj ? r_list_length ( obj -> strings ) : 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 'c' : //<S2SV> if ( input [ 1 ] == '?' ) { //<S2SV> eprintf ( "Usage:<S2SV_blank>ic[ljq*]<S2SV_blank>[class-index<S2SV_blank>or<S2SV_blank>name]\\n" ) ; //<S2SV> } else if ( input [ 1 ] == '<S2SV_blank>' || input [ 1 ] == 'q' || input [ 1 ] == 'j' || input [ 1 ] == 'l' ) { //<S2SV> RBinClass * cls ; //<S2SV> RBinSymbol * sym ; //<S2SV> RListIter * iter , * iter2 ; //<S2SV> RBinObject * obj = r_bin_cur_object ( core -> bin ) ; //<S2SV> if ( obj ) { //<S2SV> if ( input [ 2 ] ) { //<S2SV> int idx = - 1 ; //<S2SV> const char * cls_name = NULL ; //<S2SV> if ( r_num_is_valid_input ( core -> num , input + 2 ) ) { //<S2SV> idx = r_num_math ( core -> num , input + 2 ) ; //<S2SV> } else { //<S2SV> const char * first_char = input + ( ( input [ 1 ] == '<S2SV_blank>' ) ? 1 : 2 ) ; //<S2SV> int not_space = strspn ( first_char , "<S2SV_blank>" ) ; //<S2SV> if ( first_char [ not_space ] ) { //<S2SV> cls_name = first_char + not_space ; //<S2SV> } //<S2SV> } //<S2SV> int count = 0 ; //<S2SV> r_list_foreach ( obj -> classes , iter , cls ) { //<S2SV> if ( ( idx >= 0 && idx != count ++ ) || //<S2SV> ( cls_name && strcmp ( cls_name , cls -> name ) != 0 ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> switch ( input [ 1 ] ) { //<S2SV> case '*' : //<S2SV> r_list_foreach ( cls -> methods , iter2 , sym ) { //<S2SV> r_cons_printf ( "f<S2SV_blank>sym.%s<S2SV_blank>@<S2SV_blank>0x%" PFMT64x "\\n" , //<S2SV> sym -> name , sym -> vaddr ) ; //<S2SV> } //<S2SV> input ++ ; //<S2SV> break ; //<S2SV> case 'l' : //<S2SV> r_list_foreach ( cls -> methods , iter2 , sym ) { //<S2SV> const char * comma = iter2 -> p ? "<S2SV_blank>" : "" ; //<S2SV> r_cons_printf ( "%s0x%" PFMT64d , comma , sym -> vaddr ) ; //<S2SV> } //<S2SV> r_cons_newline ( ) ; //<S2SV> input ++ ; //<S2SV> break ; //<S2SV> case 'j' : //<S2SV> input ++ ; //<S2SV> r_cons_printf ( "\\"class\\":\\"%s\\"" , cls -> name ) ; //<S2SV> r_cons_printf ( ",\\"methods\\":[" ) ; //<S2SV> r_list_foreach ( cls -> methods , iter2 , sym ) { //<S2SV> const char * comma = iter2 -> p ? "," : "" ; //<S2SV> if ( sym -> method_flags ) { //<S2SV> char * flags = r_core_bin_method_flags_str ( sym , R_CORE_BIN_JSON ) ; //<S2SV> r_cons_printf ( "%s{\\"name\\":\\"%s\\",\\"flags\\":%s,\\"vaddr\\":%" PFMT64d "}" , //<S2SV> comma , sym -> name , flags , sym -> vaddr ) ; //<S2SV> R_FREE ( flags ) ; //<S2SV> } else { //<S2SV> r_cons_printf ( "%s{\\"name\\":\\"%s\\",\\"vaddr\\":%" PFMT64d "}" , //<S2SV> comma , sym -> name , sym -> vaddr ) ; //<S2SV> } //<S2SV> } //<S2SV> r_cons_printf ( "]" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> r_cons_printf ( "class<S2SV_blank>%s\\n" , cls -> name ) ; //<S2SV> r_list_foreach ( cls -> methods , iter2 , sym ) { //<S2SV> char * flags = r_core_bin_method_flags_str ( sym , 0 ) ; //<S2SV> r_cons_printf ( "0x%08" PFMT64x "<S2SV_blank>method<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n" , //<S2SV> sym -> vaddr , cls -> name , flags , sym -> name ) ; //<S2SV> R_FREE ( flags ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> goto done ; //<S2SV> } //<S2SV> goto done ; //<S2SV> } else { //<S2SV> playMsg ( core , "classes" , r_list_length ( obj -> classes ) ) ; //<S2SV> if ( input [ 1 ] == 'l' && obj ) { //<S2SV> r_list_foreach ( obj -> classes , iter , cls ) { //<S2SV> r_list_foreach ( cls -> methods , iter2 , sym ) { //<S2SV> const char * comma = iter2 -> p ? "<S2SV_blank>" : "" ; //<S2SV> r_cons_printf ( "%s0x%" PFMT64d , comma , sym -> vaddr ) ; //<S2SV> } //<S2SV> if ( ! r_list_empty ( cls -> methods ) ) { //<S2SV> r_cons_newline ( ) ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> RBININFO ( "classes" , R_CORE_BIN_ACC_CLASSES , NULL , r_list_length ( obj -> classes ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> RBinObject * obj = r_bin_cur_object ( core -> bin ) ; //<S2SV> int len = obj ? r_list_length ( obj -> classes ) : 0 ; //<S2SV> RBININFO ( "classes" , R_CORE_BIN_ACC_CLASSES , NULL , len ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'D' : //<S2SV> if ( input [ 1 ] != '<S2SV_blank>' || ! demangle ( core , input + 2 ) ) { //<S2SV> eprintf ( "|Usage:<S2SV_blank>iD<S2SV_blank>lang<S2SV_blank>symbolname\\n" ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case 'a' : //<S2SV> switch ( mode ) { //<S2SV> case R_CORE_BIN_RADARE : cmd_info ( core , "iIiecsSmz*" ) ; break ; //<S2SV> case R_CORE_BIN_JSON : cmd_info ( core , "iIiecsSmzj" ) ; break ; //<S2SV> case R_CORE_BIN_SIMPLE : cmd_info ( core , "iIiecsSmzq" ) ; break ; //<S2SV> default : cmd_info ( core , "IiEecsSmz" ) ; break ; //<S2SV> } //<S2SV> break ; //<S2SV> case '?' : { //<S2SV> const char * help_message [ ] = { //<S2SV> "Usage:<S2SV_blank>i" , "" , "Get<S2SV_blank>info<S2SV_blank>from<S2SV_blank>opened<S2SV_blank>file<S2SV_blank>(see<S2SV_blank>rabin2\'s<S2SV_blank>manpage)" , //<S2SV> "Output<S2SV_blank>mode:" , "" , "" , //<S2SV> "\'*\'" , "" , "Output<S2SV_blank>in<S2SV_blank>radare<S2SV_blank>commands" , //<S2SV> "\'j\'" , "" , "Output<S2SV_blank>in<S2SV_blank>json" , //<S2SV> "\'q\'" , "" , "Simple<S2SV_blank>quiet<S2SV_blank>output" , //<S2SV> "Actions:" , "" , "" , //<S2SV> "i|ij" , "" , "Show<S2SV_blank>info<S2SV_blank>of<S2SV_blank>current<S2SV_blank>file<S2SV_blank>(in<S2SV_blank>JSON)" , //<S2SV> "iA" , "" , "List<S2SV_blank>archs" , //<S2SV> "ia" , "" , "Show<S2SV_blank>all<S2SV_blank>info<S2SV_blank>(imports,<S2SV_blank>exports,<S2SV_blank>sections..)" , //<S2SV> "ib" , "" , "Reload<S2SV_blank>the<S2SV_blank>current<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>setting<S2SV_blank>of<S2SV_blank>the<S2SV_blank>bin<S2SV_blank>(use<S2SV_blank>once<S2SV_blank>only)" , //<S2SV> "ic" , "" , "List<S2SV_blank>classes,<S2SV_blank>methods<S2SV_blank>and<S2SV_blank>fields" , //<S2SV> "iC" , "" , "Show<S2SV_blank>signature<S2SV_blank>info<S2SV_blank>(entitlements,<S2SV_blank>...)" , //<S2SV> "id" , "" , "Debug<S2SV_blank>information<S2SV_blank>(source<S2SV_blank>lines)" , //<S2SV> "iD" , "<S2SV_blank>lang<S2SV_blank>sym" , "demangle<S2SV_blank>symbolname<S2SV_blank>for<S2SV_blank>given<S2SV_blank>language" , //<S2SV> "ie" , "" , "Entrypoint" , //<S2SV> "iE" , "" , "Exports<S2SV_blank>(global<S2SV_blank>symbols)" , //<S2SV> "ih" , "" , "Headers<S2SV_blank>(alias<S2SV_blank>for<S2SV_blank>iH)" , //<S2SV> "iHH" , "" , "Verbose<S2SV_blank>Headers<S2SV_blank>in<S2SV_blank>raw<S2SV_blank>text" , //<S2SV> "ii" , "" , "Imports" , //<S2SV> "iI" , "" , "Binary<S2SV_blank>info" , //<S2SV> "ik" , "<S2SV_blank>[query]" , "Key-value<S2SV_blank>database<S2SV_blank>from<S2SV_blank>RBinObject" , //<S2SV> "il" , "" , "Libraries" , //<S2SV> "iL<S2SV_blank>" , "[plugin]" , "List<S2SV_blank>all<S2SV_blank>RBin<S2SV_blank>plugins<S2SV_blank>loaded<S2SV_blank>or<S2SV_blank>plugin<S2SV_blank>details" , //<S2SV> "im" , "" , "Show<S2SV_blank>info<S2SV_blank>about<S2SV_blank>predefined<S2SV_blank>memory<S2SV_blank>allocation" , //<S2SV> "iM" , "" , "Show<S2SV_blank>main<S2SV_blank>address" , //<S2SV> "io" , "<S2SV_blank>[file]" , "Load<S2SV_blank>info<S2SV_blank>from<S2SV_blank>file<S2SV_blank>(or<S2SV_blank>last<S2SV_blank>opened)<S2SV_blank>use<S2SV_blank>bin.baddr" , //<S2SV> "ir" , "" , "Relocs" , //<S2SV> "iR" , "" , "Resources" , //<S2SV> "is" , "" , "Symbols" , //<S2SV> "iS<S2SV_blank>" , "[entropy,sha1]" , "Sections<S2SV_blank>(choose<S2SV_blank>which<S2SV_blank>hash<S2SV_blank>algorithm<S2SV_blank>to<S2SV_blank>use)" , //<S2SV> "iV" , "" , "Display<S2SV_blank>file<S2SV_blank>version<S2SV_blank>info" , //<S2SV> "iz|izj" , "" , "Strings<S2SV_blank>in<S2SV_blank>data<S2SV_blank>sections<S2SV_blank>(in<S2SV_blank>JSON/Base64)" , //<S2SV> "izz" , "" , "Search<S2SV_blank>for<S2SV_blank>Strings<S2SV_blank>in<S2SV_blank>the<S2SV_blank>whole<S2SV_blank>binary" , //<S2SV> "iZ" , "" , "Guess<S2SV_blank>size<S2SV_blank>of<S2SV_blank>binary<S2SV_blank>program" , //<S2SV> NULL //<S2SV> } ; //<S2SV> r_core_cmd_help ( core , help_message ) ; //<S2SV> } //<S2SV> goto done ; //<S2SV> case '*' : //<S2SV> mode = R_CORE_BIN_RADARE ; //<S2SV> goto done ; //<S2SV> case 'q' : //<S2SV> mode = R_CORE_BIN_SIMPLE ; //<S2SV> cmd_info_bin ( core , va , mode ) ; //<S2SV> goto done ; //<S2SV> case 'j' : //<S2SV> mode = R_CORE_BIN_JSON ; //<S2SV> if ( is_array > 1 ) { //<S2SV> mode |= R_CORE_BIN_ARRAY ; //<S2SV> } //<S2SV> cmd_info_bin ( core , va , mode ) ; //<S2SV> goto done ; //<S2SV> default : //<S2SV> cmd_info_bin ( core , va , mode ) ; //<S2SV> break ; //<S2SV> } //<S2SV> input ++ ; //<S2SV> if ( ( * input == 'j' || * input == 'q' ) && ! input [ 1 ] ) { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> done : //<S2SV> if ( is_array ) { //<S2SV> r_cons_printf ( "}\\n" ) ; //<S2SV> } //<S2SV> if ( newline ) { //<S2SV> r_cons_newline ( ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 