static int init_items ( struct MACH0_ ( obj_t ) * bin ) { //<S2SV> struct load_command lc = { 0 , 0 } ; //<S2SV> ut8 loadc [ sizeof ( struct load_command ) ] = { 0 } ; //<S2SV> bool is_first_thread = true ; //<S2SV> ut64 off = 0LL ; //<S2SV> int i , len ; //<S2SV> bin -> uuidn = 0 ; //<S2SV> bin -> os = 0 ; //<S2SV> bin -> has_crypto = 0 ; //<S2SV> if ( bin -> hdr . sizeofcmds > bin -> size ) { //<S2SV> bprintf ( "Warning:<S2SV_blank>chopping<S2SV_blank>hdr.sizeofcmds\\n" ) ; //<S2SV> bin -> hdr . sizeofcmds = bin -> size - 128 ; //<S2SV> } //<S2SV> for ( i = 0 , off = sizeof ( struct MACH0_ ( mach_header ) ) ; i < bin -> hdr . ncmds ; i ++ , off += lc . cmdsize ) { //<S2SV> if ( off > bin -> size || off + sizeof ( struct load_command ) > bin -> size ) { //<S2SV> bprintf ( "mach0:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>command\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> len = r_buf_read_at ( bin -> b , off , loadc , sizeof ( struct load_command ) ) ; //<S2SV> if ( len < 1 ) { //<S2SV> bprintf ( "Error:<S2SV_blank>read<S2SV_blank>(lc)<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , off ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> lc . cmd = r_read_ble32 ( & loadc [ 0 ] , bin -> big_endian ) ; //<S2SV> lc . cmdsize = r_read_ble32 ( & loadc [ 4 ] , bin -> big_endian ) ; //<S2SV> if ( lc . cmdsize < 1 || off + lc . cmdsize > bin -> size ) { //<S2SV> bprintf ( "Warning:<S2SV_blank>mach0_header<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>cmdsize<1.\\n" , i ) ; //<S2SV> break ; //<S2SV> } //<S2SV> sdb_num_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.offset" , i ) , off , 0 ) ; //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.format" , i ) , "xd<S2SV_blank>cmd<S2SV_blank>size" , 0 ) ; //<S2SV> switch ( lc . cmd ) { //<S2SV> case LC_DATA_IN_CODE : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "data_in_code" , 0 ) ; //<S2SV> break ; //<S2SV> case LC_RPATH : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "rpath" , 0 ) ; //<S2SV> break ; //<S2SV> case LC_SEGMENT_64 : //<S2SV> case LC_SEGMENT : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "segment" , 0 ) ; //<S2SV> bin -> nsegs ++ ; //<S2SV> if ( ! parse_segments ( bin , off ) ) { //<S2SV> bprintf ( "error<S2SV_blank>parsing<S2SV_blank>segment\\n" ) ; //<S2SV> bin -> nsegs -- ; //<S2SV> return false ; //<S2SV> } //<S2SV> break ; //<S2SV> case LC_SYMTAB : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "symtab" , 0 ) ; //<S2SV> if ( ! parse_symtab ( bin , off ) ) { //<S2SV> bprintf ( "error<S2SV_blank>parsing<S2SV_blank>symtab\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> break ; //<S2SV> case LC_DYSYMTAB : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "dysymtab" , 0 ) ; //<S2SV> if ( ! parse_dysymtab ( bin , off ) ) { //<S2SV> bprintf ( "error<S2SV_blank>parsing<S2SV_blank>dysymtab\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> break ; //<S2SV> case LC_DYLIB_CODE_SIGN_DRS : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "dylib_code_sign_drs" , 0 ) ; //<S2SV> break ; //<S2SV> case LC_VERSION_MIN_MACOSX : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "version_min_macosx" , 0 ) ; //<S2SV> bin -> os = 1 ; //<S2SV> break ; //<S2SV> case LC_VERSION_MIN_IPHONEOS : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "version_min_iphoneos" , 0 ) ; //<S2SV> bin -> os = 2 ; //<S2SV> break ; //<S2SV> case LC_VERSION_MIN_TVOS : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "version_min_tvos" , 0 ) ; //<S2SV> bin -> os = 4 ; //<S2SV> break ; //<S2SV> case LC_VERSION_MIN_WATCHOS : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "version_min_watchos" , 0 ) ; //<S2SV> bin -> os = 3 ; //<S2SV> break ; //<S2SV> case LC_UUID : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "uuid" , 0 ) ; //<S2SV> { //<S2SV> struct uuid_command uc = { 0 } ; //<S2SV> if ( off + sizeof ( struct uuid_command ) > bin -> size ) { //<S2SV> bprintf ( "UUID<S2SV_blank>out<S2SV_blank>of<S2SV_blank>obunds\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( r_buf_fread_at ( bin -> b , off , ( ut8 * ) & uc , "24c" , 1 ) != - 1 ) { //<S2SV> char key [ 128 ] ; //<S2SV> char val [ 128 ] ; //<S2SV> snprintf ( key , sizeof ( key ) - 1 , "uuid.%d" , bin -> uuidn ++ ) ; //<S2SV> r_hex_bin2str ( ( ut8 * ) & uc . uuid , 16 , val ) ; //<S2SV> sdb_set ( bin -> kv , key , val , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case LC_ENCRYPTION_INFO_64 : //<S2SV> case LC_ENCRYPTION_INFO : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "encryption_info" , 0 ) ; //<S2SV> { //<S2SV> struct MACH0_ ( encryption_info_command ) eic = { 0 } ; //<S2SV> ut8 seic [ sizeof ( struct MACH0_ ( encryption_info_command ) ) ] = { 0 } ; //<S2SV> if ( off + sizeof ( struct MACH0_ ( encryption_info_command ) ) > bin -> size ) { //<S2SV> bprintf ( "encryption<S2SV_blank>info<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( r_buf_read_at ( bin -> b , off , seic , sizeof ( struct MACH0_ ( encryption_info_command ) ) ) != - 1 ) { //<S2SV> eic . cmd = r_read_ble32 ( & seic [ 0 ] , bin -> big_endian ) ; //<S2SV> eic . cmdsize = r_read_ble32 ( & seic [ 4 ] , bin -> big_endian ) ; //<S2SV> eic . cryptoff = r_read_ble32 ( & seic [ 8 ] , bin -> big_endian ) ; //<S2SV> eic . cryptsize = r_read_ble32 ( & seic [ 12 ] , bin -> big_endian ) ; //<S2SV> eic . cryptid = r_read_ble32 ( & seic [ 16 ] , bin -> big_endian ) ; //<S2SV> bin -> has_crypto = eic . cryptid ; //<S2SV> sdb_set ( bin -> kv , "crypto" , "true" , 0 ) ; //<S2SV> sdb_num_set ( bin -> kv , "cryptid" , eic . cryptid , 0 ) ; //<S2SV> sdb_num_set ( bin -> kv , "cryptoff" , eic . cryptoff , 0 ) ; //<S2SV> sdb_num_set ( bin -> kv , "cryptsize" , eic . cryptsize , 0 ) ; //<S2SV> sdb_num_set ( bin -> kv , "cryptheader" , off , 0 ) ; //<S2SV> } } //<S2SV> break ; //<S2SV> case LC_LOAD_DYLINKER : //<S2SV> { //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "dylinker" , 0 ) ; //<S2SV> free ( bin -> intrp ) ; //<S2SV> bin -> intrp = NULL ; //<S2SV> struct dylinker_command dy = { 0 } ; //<S2SV> ut8 sdy [ sizeof ( struct dylinker_command ) ] = { 0 } ; //<S2SV> if ( off + sizeof ( struct dylinker_command ) > bin -> size ) { //<S2SV> bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>parse<S2SV_blank>dylinker<S2SV_blank>command\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( r_buf_read_at ( bin -> b , off , sdy , sizeof ( struct dylinker_command ) ) == - 1 ) { //<S2SV> bprintf ( "Warning:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , off ) ; //<S2SV> } else { //<S2SV> dy . cmd = r_read_ble32 ( & sdy [ 0 ] , bin -> big_endian ) ; //<S2SV> dy . cmdsize = r_read_ble32 ( & sdy [ 4 ] , bin -> big_endian ) ; //<S2SV> dy . name = r_read_ble32 ( & sdy [ 8 ] , bin -> big_endian ) ; //<S2SV> int len = dy . cmdsize ; //<S2SV> char * buf = malloc ( len + 1 ) ; //<S2SV> if ( buf ) { //<S2SV> r_buf_read_at ( bin -> b , off + 0xc , ( ut8 * ) buf , len ) ; //<S2SV> buf [ len ] = 0 ; //<S2SV> free ( bin -> intrp ) ; //<S2SV> bin -> intrp = buf ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case LC_MAIN : //<S2SV> { //<S2SV> struct { //<S2SV> ut64 eo ; //<S2SV> ut64 ss ; //<S2SV> } ep = { 0 } ; //<S2SV> ut8 sep [ 2 * sizeof ( ut64 ) ] = { 0 } ; //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "main" , 0 ) ; //<S2SV> if ( ! is_first_thread ) { //<S2SV> bprintf ( "Error:<S2SV_blank>LC_MAIN<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( off + 8 > bin -> size || off + sizeof ( ep ) > bin -> size ) { //<S2SV> bprintf ( "invalid<S2SV_blank>command<S2SV_blank>size<S2SV_blank>for<S2SV_blank>main\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> r_buf_read_at ( bin -> b , off + 8 , sep , 2 * sizeof ( ut64 ) ) ; //<S2SV> ep . eo = r_read_ble64 ( & sep [ 0 ] , bin -> big_endian ) ; //<S2SV> ep . ss = r_read_ble64 ( & sep [ 8 ] , bin -> big_endian ) ; //<S2SV> bin -> entry = ep . eo ; //<S2SV> bin -> main_cmd = lc ; //<S2SV> sdb_num_set ( bin -> kv , "mach0.entry.offset" , off + 8 , 0 ) ; //<S2SV> sdb_num_set ( bin -> kv , "stacksize" , ep . ss , 0 ) ; //<S2SV> is_first_thread = false ; //<S2SV> } //<S2SV> break ; //<S2SV> case LC_UNIXTHREAD : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "unixthread" , 0 ) ; //<S2SV> if ( ! is_first_thread ) { //<S2SV> bprintf ( "Error:<S2SV_blank>LC_UNIXTHREAD<S2SV_blank>with<S2SV_blank>other<S2SV_blank>threads\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> case LC_THREAD : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "thread" , 0 ) ; //<S2SV> if ( ! parse_thread ( bin , & lc , off , is_first_thread ) ) { //<S2SV> bprintf ( "Cannot<S2SV_blank>parse<S2SV_blank>thread\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> is_first_thread = false ; //<S2SV> break ; //<S2SV> case LC_LOAD_DYLIB : //<S2SV> case LC_LOAD_WEAK_DYLIB : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "load_dylib" , 0 ) ; //<S2SV> bin -> nlibs ++ ; //<S2SV> if ( ! parse_dylib ( bin , off ) ) { //<S2SV> bprintf ( "Cannot<S2SV_blank>parse<S2SV_blank>dylib\\n" ) ; //<S2SV> bin -> nlibs -- ; //<S2SV> return false ; //<S2SV> } //<S2SV> break ; //<S2SV> case LC_DYLD_INFO : //<S2SV> case LC_DYLD_INFO_ONLY : //<S2SV> { //<S2SV> ut8 dyldi [ sizeof ( struct dyld_info_command ) ] = { 0 } ; //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "dyld_info" , 0 ) ; //<S2SV> bin -> dyld_info = malloc ( sizeof ( struct dyld_info_command ) ) ; //<S2SV> if ( off + sizeof ( struct dyld_info_command ) > bin -> size ) { //<S2SV> bprintf ( "Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n" ) ; //<S2SV> free ( bin -> dyld_info ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( r_buf_read_at ( bin -> b , off , dyldi , sizeof ( struct dyld_info_command ) ) == - 1 ) { //<S2SV> free ( bin -> dyld_info ) ; //<S2SV> bin -> dyld_info = NULL ; //<S2SV> bprintf ( "Error:<S2SV_blank>read<S2SV_blank>(LC_DYLD_INFO)<S2SV_blank>at<S2SV_blank>0x%08" PFMT64x "\\n" , off ) ; //<S2SV> } else { //<S2SV> bin -> dyld_info -> cmd = r_read_ble32 ( & dyldi [ 0 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> cmdsize = r_read_ble32 ( & dyldi [ 4 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> rebase_off = r_read_ble32 ( & dyldi [ 8 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> rebase_size = r_read_ble32 ( & dyldi [ 12 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> bind_off = r_read_ble32 ( & dyldi [ 16 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> bind_size = r_read_ble32 ( & dyldi [ 20 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> weak_bind_off = r_read_ble32 ( & dyldi [ 24 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> weak_bind_size = r_read_ble32 ( & dyldi [ 28 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> lazy_bind_off = r_read_ble32 ( & dyldi [ 32 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> lazy_bind_size = r_read_ble32 ( & dyldi [ 36 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> export_off = r_read_ble32 ( & dyldi [ 40 ] , bin -> big_endian ) ; //<S2SV> bin -> dyld_info -> export_size = r_read_ble32 ( & dyldi [ 44 ] , bin -> big_endian ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case LC_CODE_SIGNATURE : //<S2SV> parse_signature ( bin , off ) ; //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "signature" , 0 ) ; //<S2SV> break ; //<S2SV> case LC_SOURCE_VERSION : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "version" , 0 ) ; //<S2SV> break ; //<S2SV> case LC_SEGMENT_SPLIT_INFO : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "split_info" , 0 ) ; //<S2SV> break ; //<S2SV> case LC_FUNCTION_STARTS : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "function_starts" , 0 ) ; //<S2SV> if ( ! parse_function_starts ( bin , off ) ) { //<S2SV> bprintf ( "Cannot<S2SV_blank>parse<S2SV_blank>LC_FUNCTION_STARTS\\n" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case LC_REEXPORT_DYLIB : //<S2SV> sdb_set ( bin -> kv , sdb_fmt ( 0 , "mach0_cmd_%d.cmd" , i ) , "dylib" , 0 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return true ; //<S2SV> } //<S2SV> 