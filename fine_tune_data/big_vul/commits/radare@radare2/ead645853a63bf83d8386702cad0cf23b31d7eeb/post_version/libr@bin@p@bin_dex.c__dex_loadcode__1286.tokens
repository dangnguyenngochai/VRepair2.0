static int dex_loadcode ( RBinFile * arch , RBinDexObj * bin ) { //<S2SV> struct r_bin_t * rbin = arch -> rbin ; //<S2SV> int i ; //<S2SV> int * methods = NULL ; //<S2SV> int sym_count = 0 ; //<S2SV> if ( ! bin || bin -> methods_list ) { //<S2SV> return false ; //<S2SV> } //<S2SV> bin -> code_from = UT64_MAX ; //<S2SV> bin -> code_to = 0 ; //<S2SV> bin -> methods_list = r_list_newf ( ( RListFree ) free ) ; //<S2SV> if ( ! bin -> methods_list ) { //<S2SV> return false ; //<S2SV> } //<S2SV> bin -> imports_list = r_list_newf ( ( RListFree ) free ) ; //<S2SV> if ( ! bin -> imports_list ) { //<S2SV> r_list_free ( bin -> methods_list ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> bin -> classes_list = r_list_newf ( ( RListFree ) __r_bin_class_free ) ; //<S2SV> if ( ! bin -> classes_list ) { //<S2SV> r_list_free ( bin -> methods_list ) ; //<S2SV> r_list_free ( bin -> imports_list ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( bin -> header . method_size > bin -> size ) { //<S2SV> bin -> header . method_size = 0 ; //<S2SV> return false ; //<S2SV> } //<S2SV> bin -> header . method_size = R_MIN ( bin -> header . method_size , bin -> size ) ; //<S2SV> bin -> header . class_size = R_MIN ( bin -> header . class_size , bin -> size ) ; //<S2SV> bin -> header . strings_size = R_MIN ( bin -> header . strings_size , bin -> size ) ; //<S2SV> if ( bin -> header . strings_size > bin -> size ) { //<S2SV> eprintf ( "Invalid<S2SV_blank>strings<S2SV_blank>size\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( bin -> classes ) { //<S2SV> ut64 amount = sizeof ( int ) * bin -> header . method_size ; //<S2SV> if ( amount > UT32_MAX || amount < bin -> header . method_size ) { //<S2SV> return false ; //<S2SV> } //<S2SV> methods = calloc ( 1 , amount + 1 ) ; //<S2SV> for ( i = 0 ; i < bin -> header . class_size ; i ++ ) { //<S2SV> char * super_name , * class_name ; //<S2SV> struct dex_class_t * c = & bin -> classes [ i ] ; //<S2SV> class_name = dex_class_name ( bin , c ) ; //<S2SV> super_name = dex_class_super_name ( bin , c ) ; //<S2SV> if ( dexdump ) { //<S2SV> rbin -> cb_printf ( "Class<S2SV_blank>#%d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-\\n" , i ) ; //<S2SV> } //<S2SV> parse_class ( arch , bin , c , i , methods , & sym_count ) ; //<S2SV> free ( class_name ) ; //<S2SV> free ( super_name ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( methods ) { //<S2SV> int import_count = 0 ; //<S2SV> int sym_count = bin -> methods_list -> length ; //<S2SV> for ( i = 0 ; i < bin -> header . method_size ; i ++ ) { //<S2SV> int len = 0 ; //<S2SV> if ( methods [ i ] ) { //<S2SV> continue ; //<S2SV> } //<S2SV> if ( bin -> methods [ i ] . class_id > bin -> header . types_size ) { //<S2SV> continue ; //<S2SV> } //<S2SV> if ( is_class_idx_in_code_classes ( bin , bin -> methods [ i ] . class_id ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> char * class_name = getstr ( //<S2SV> bin , bin -> types [ bin -> methods [ i ] . class_id ] //<S2SV> . descriptor_id ) ; //<S2SV> if ( ! class_name ) { //<S2SV> free ( class_name ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> len = strlen ( class_name ) ; //<S2SV> if ( len < 1 ) { //<S2SV> continue ; //<S2SV> } //<S2SV> class_name [ len - 1 ] = 0 ; //<S2SV> char * method_name = dex_method_name ( bin , i ) ; //<S2SV> char * signature = dex_method_signature ( bin , i ) ; //<S2SV> if ( method_name && * method_name ) { //<S2SV> RBinImport * imp = R_NEW0 ( RBinImport ) ; //<S2SV> imp -> name = r_str_newf ( "%s.method.%s%s" , class_name , method_name , signature ) ; //<S2SV> imp -> type = r_str_const ( "FUNC" ) ; //<S2SV> imp -> bind = r_str_const ( "NONE" ) ; //<S2SV> imp -> ordinal = import_count ++ ; //<S2SV> r_list_append ( bin -> imports_list , imp ) ; //<S2SV> RBinSymbol * sym = R_NEW0 ( RBinSymbol ) ; //<S2SV> sym -> name = r_str_newf ( "imp.%s" , imp -> name ) ; //<S2SV> sym -> type = r_str_const ( "FUNC" ) ; //<S2SV> sym -> bind = r_str_const ( "NONE" ) ; //<S2SV> sym -> paddr = sym -> vaddr = bin -> b -> base + bin -> header . method_offset + ( sizeof ( struct dex_method_t ) * i ) ; //<S2SV> sym -> ordinal = sym_count ++ ; //<S2SV> r_list_append ( bin -> methods_list , sym ) ; //<S2SV> sdb_num_set ( mdb , sdb_fmt ( 0 , "method.%d" , i ) , sym -> paddr , 0 ) ; //<S2SV> } //<S2SV> free ( method_name ) ; //<S2SV> free ( signature ) ; //<S2SV> free ( class_name ) ; //<S2SV> } //<S2SV> free ( methods ) ; //<S2SV> } //<S2SV> return true ; //<S2SV> } //<S2SV> 