int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { //<S2SV> op -> len = 1 ; //<S2SV> op -> op = buf [ 0 ] ; //<S2SV> if ( op -> op > 0xbf ) { //<S2SV> return 1 ; //<S2SV> } //<S2SV> WasmOpDef * opdef = & opcodes [ op -> op ] ; //<S2SV> switch ( op -> op ) { //<S2SV> case WASM_OP_TRAP : //<S2SV> case WASM_OP_NOP : //<S2SV> case WASM_OP_ELSE : //<S2SV> case WASM_OP_RETURN : //<S2SV> case WASM_OP_DROP : //<S2SV> case WASM_OP_SELECT : //<S2SV> case WASM_OP_I32EQZ : //<S2SV> case WASM_OP_I32EQ : //<S2SV> case WASM_OP_I32NE : //<S2SV> case WASM_OP_I32LTS : //<S2SV> case WASM_OP_I32LTU : //<S2SV> case WASM_OP_I32GTS : //<S2SV> case WASM_OP_I32GTU : //<S2SV> case WASM_OP_I32LES : //<S2SV> case WASM_OP_I32LEU : //<S2SV> case WASM_OP_I32GES : //<S2SV> case WASM_OP_I32GEU : //<S2SV> case WASM_OP_I64EQZ : //<S2SV> case WASM_OP_I64EQ : //<S2SV> case WASM_OP_I64NE : //<S2SV> case WASM_OP_I64LTS : //<S2SV> case WASM_OP_I64LTU : //<S2SV> case WASM_OP_I64GTS : //<S2SV> case WASM_OP_I64GTU : //<S2SV> case WASM_OP_I64LES : //<S2SV> case WASM_OP_I64LEU : //<S2SV> case WASM_OP_I64GES : //<S2SV> case WASM_OP_I64GEU : //<S2SV> case WASM_OP_F32EQ : //<S2SV> case WASM_OP_F32NE : //<S2SV> case WASM_OP_F32LT : //<S2SV> case WASM_OP_F32GT : //<S2SV> case WASM_OP_F32LE : //<S2SV> case WASM_OP_F32GE : //<S2SV> case WASM_OP_F64EQ : //<S2SV> case WASM_OP_F64NE : //<S2SV> case WASM_OP_F64LT : //<S2SV> case WASM_OP_F64GT : //<S2SV> case WASM_OP_F64LE : //<S2SV> case WASM_OP_F64GE : //<S2SV> case WASM_OP_I32CLZ : //<S2SV> case WASM_OP_I32CTZ : //<S2SV> case WASM_OP_I32POPCNT : //<S2SV> case WASM_OP_I32ADD : //<S2SV> case WASM_OP_I32SUB : //<S2SV> case WASM_OP_I32MUL : //<S2SV> case WASM_OP_I32DIVS : //<S2SV> case WASM_OP_I32DIVU : //<S2SV> case WASM_OP_I32REMS : //<S2SV> case WASM_OP_I32REMU : //<S2SV> case WASM_OP_I32AND : //<S2SV> case WASM_OP_I32OR : //<S2SV> case WASM_OP_I32XOR : //<S2SV> case WASM_OP_I32SHL : //<S2SV> case WASM_OP_I32SHRS : //<S2SV> case WASM_OP_I32SHRU : //<S2SV> case WASM_OP_I32ROTL : //<S2SV> case WASM_OP_I32ROTR : //<S2SV> case WASM_OP_I64CLZ : //<S2SV> case WASM_OP_I64CTZ : //<S2SV> case WASM_OP_I64POPCNT : //<S2SV> case WASM_OP_I64ADD : //<S2SV> case WASM_OP_I64SUB : //<S2SV> case WASM_OP_I64MUL : //<S2SV> case WASM_OP_I64DIVS : //<S2SV> case WASM_OP_I64DIVU : //<S2SV> case WASM_OP_I64REMS : //<S2SV> case WASM_OP_I64REMU : //<S2SV> case WASM_OP_I64AND : //<S2SV> case WASM_OP_I64OR : //<S2SV> case WASM_OP_I64XOR : //<S2SV> case WASM_OP_I64SHL : //<S2SV> case WASM_OP_I64SHRS : //<S2SV> case WASM_OP_I64SHRU : //<S2SV> case WASM_OP_I64ROTL : //<S2SV> case WASM_OP_I64ROTR : //<S2SV> case WASM_OP_F32ABS : //<S2SV> case WASM_OP_F32NEG : //<S2SV> case WASM_OP_F32CEIL : //<S2SV> case WASM_OP_F32FLOOR : //<S2SV> case WASM_OP_F32TRUNC : //<S2SV> case WASM_OP_F32NEAREST : //<S2SV> case WASM_OP_F32SQRT : //<S2SV> case WASM_OP_F32ADD : //<S2SV> case WASM_OP_F32SUB : //<S2SV> case WASM_OP_F32MUL : //<S2SV> case WASM_OP_F32DIV : //<S2SV> case WASM_OP_F32MIN : //<S2SV> case WASM_OP_F32MAX : //<S2SV> case WASM_OP_F32COPYSIGN : //<S2SV> case WASM_OP_F64ABS : //<S2SV> case WASM_OP_F64NEG : //<S2SV> case WASM_OP_F64CEIL : //<S2SV> case WASM_OP_F64FLOOR : //<S2SV> case WASM_OP_F64TRUNC : //<S2SV> case WASM_OP_F64NEAREST : //<S2SV> case WASM_OP_F64SQRT : //<S2SV> case WASM_OP_F64ADD : //<S2SV> case WASM_OP_F64SUB : //<S2SV> case WASM_OP_F64MUL : //<S2SV> case WASM_OP_F64DIV : //<S2SV> case WASM_OP_F64MIN : //<S2SV> case WASM_OP_F64MAX : //<S2SV> case WASM_OP_F64COPYSIGN : //<S2SV> case WASM_OP_I32WRAPI64 : //<S2SV> case WASM_OP_I32TRUNCSF32 : //<S2SV> case WASM_OP_I32TRUNCUF32 : //<S2SV> case WASM_OP_I32TRUNCSF64 : //<S2SV> case WASM_OP_I32TRUNCUF64 : //<S2SV> case WASM_OP_I64EXTENDSI32 : //<S2SV> case WASM_OP_I64EXTENDUI32 : //<S2SV> case WASM_OP_I64TRUNCSF32 : //<S2SV> case WASM_OP_I64TRUNCUF32 : //<S2SV> case WASM_OP_I64TRUNCSF64 : //<S2SV> case WASM_OP_I64TRUNCUF64 : //<S2SV> case WASM_OP_F32CONVERTSI32 : //<S2SV> case WASM_OP_F32CONVERTUI32 : //<S2SV> case WASM_OP_F32CONVERTSI64 : //<S2SV> case WASM_OP_F32CONVERTUI64 : //<S2SV> case WASM_OP_F32DEMOTEF64 : //<S2SV> case WASM_OP_F64CONVERTSI32 : //<S2SV> case WASM_OP_F64CONVERTUI32 : //<S2SV> case WASM_OP_F64CONVERTSI64 : //<S2SV> case WASM_OP_F64CONVERTUI64 : //<S2SV> case WASM_OP_F64PROMOTEF32 : //<S2SV> case WASM_OP_I32REINTERPRETF32 : //<S2SV> case WASM_OP_I64REINTERPRETF64 : //<S2SV> case WASM_OP_F32REINTERPRETI32 : //<S2SV> case WASM_OP_F64REINTERPRETI64 : //<S2SV> case WASM_OP_END : //<S2SV> { //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s" , opdef -> txt ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_BLOCK : //<S2SV> case WASM_OP_LOOP : //<S2SV> case WASM_OP_IF : //<S2SV> { //<S2SV> st32 val = 0 ; //<S2SV> size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> switch ( 0x80 - val ) { //<S2SV> case R_BIN_WASM_VALUETYPE_EMPTY : //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s" , opdef -> txt ) ; //<S2SV> break ; //<S2SV> case R_BIN_WASM_VALUETYPE_i32 : //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>i32)" , opdef -> txt ) ; //<S2SV> break ; //<S2SV> case R_BIN_WASM_VALUETYPE_i64 : //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>i64)" , opdef -> txt ) ; //<S2SV> break ; //<S2SV> case R_BIN_WASM_VALUETYPE_f32 : //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>f32)" , opdef -> txt ) ; //<S2SV> break ; //<S2SV> case R_BIN_WASM_VALUETYPE_f64 : //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>f64)" , opdef -> txt ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>(result<S2SV_blank>?)" , opdef -> txt ) ; //<S2SV> break ; //<S2SV> } //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_BR : //<S2SV> case WASM_OP_BRIF : //<S2SV> case WASM_OP_CALL : //<S2SV> { //<S2SV> ut32 val = 0 ; //<S2SV> size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d" , opdef -> txt , val ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_BRTABLE : //<S2SV> { //<S2SV> ut32 count = 0 , * table = NULL , def = 0 ; //<S2SV> size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) { //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) { //<S2SV> goto err ; //<S2SV> } //<S2SV> int i = 0 ; //<S2SV> op -> len += n ; //<S2SV> for ( i = 0 ; i < count ; i ++ ) { //<S2SV> n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; //<S2SV> if ( ! ( op -> len + n <= buf_len ) ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; //<S2SV> if ( ! ( n > 0 && n + op -> len < buf_len ) ) { //<S2SV> goto beach ; //<S2SV> } //<S2SV> op -> len += n ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d<S2SV_blank>" , opdef -> txt , count ) ; //<S2SV> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { //<S2SV> int optxtlen = strlen ( op -> txt ) ; //<S2SV> snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , "%d<S2SV_blank>" , table [ i ] ) ; //<S2SV> } //<S2SV> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , "%d" , def ) ; //<S2SV> free ( table ) ; //<S2SV> break ; //<S2SV> beach : //<S2SV> free ( table ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_CALLINDIRECT : //<S2SV> { //<S2SV> ut32 val = 0 , reserved = 0 ; //<S2SV> size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> op -> len += n ; //<S2SV> n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; //<S2SV> if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; //<S2SV> reserved &= 0x1 ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d<S2SV_blank>%d" , opdef -> txt , val , reserved ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_GETLOCAL : //<S2SV> case WASM_OP_SETLOCAL : //<S2SV> case WASM_OP_TEELOCAL : //<S2SV> case WASM_OP_GETGLOBAL : //<S2SV> case WASM_OP_SETGLOBAL : //<S2SV> { //<S2SV> ut32 val = 0 ; //<S2SV> size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d" , opdef -> txt , val ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_I32LOAD : //<S2SV> case WASM_OP_I64LOAD : //<S2SV> case WASM_OP_F32LOAD : //<S2SV> case WASM_OP_F64LOAD : //<S2SV> case WASM_OP_I32LOAD8S : //<S2SV> case WASM_OP_I32LOAD8U : //<S2SV> case WASM_OP_I32LOAD16S : //<S2SV> case WASM_OP_I32LOAD16U : //<S2SV> case WASM_OP_I64LOAD8S : //<S2SV> case WASM_OP_I64LOAD8U : //<S2SV> case WASM_OP_I64LOAD16S : //<S2SV> case WASM_OP_I64LOAD16U : //<S2SV> case WASM_OP_I64LOAD32S : //<S2SV> case WASM_OP_I64LOAD32U : //<S2SV> case WASM_OP_I32STORE : //<S2SV> case WASM_OP_I64STORE : //<S2SV> case WASM_OP_F32STORE : //<S2SV> case WASM_OP_F64STORE : //<S2SV> case WASM_OP_I32STORE8 : //<S2SV> case WASM_OP_I32STORE16 : //<S2SV> case WASM_OP_I64STORE8 : //<S2SV> case WASM_OP_I64STORE16 : //<S2SV> case WASM_OP_I64STORE32 : //<S2SV> { //<S2SV> ut32 flag = 0 , offset = 0 ; //<S2SV> size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> op -> len += n ; //<S2SV> n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; //<S2SV> if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d<S2SV_blank>%d" , opdef -> txt , flag , offset ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_CURRENTMEMORY : //<S2SV> case WASM_OP_GROWMEMORY : //<S2SV> { //<S2SV> ut32 reserved = 0 ; //<S2SV> size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; //<S2SV> if ( ! ( n == 1 && n < buf_len ) ) goto err ; //<S2SV> reserved &= 0x1 ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%d" , opdef -> txt , reserved ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_I32CONST : //<S2SV> { //<S2SV> st32 val = 0 ; //<S2SV> size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%" PFMT32d , opdef -> txt , val ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_I64CONST : //<S2SV> { //<S2SV> st64 val = 0 ; //<S2SV> size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%" PFMT64d , opdef -> txt , val ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_F32CONST : //<S2SV> { //<S2SV> ut32 val = 0 ; //<S2SV> size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> long double d = ( long double ) val ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%" LDBLFMT , opdef -> txt , d ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> case WASM_OP_F64CONST : //<S2SV> { //<S2SV> ut64 val = 0 ; //<S2SV> size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; //<S2SV> if ( ! ( n > 0 && n < buf_len ) ) goto err ; //<S2SV> long double d = ( long double ) val ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "%s<S2SV_blank>%" LDBLFMT , opdef -> txt , d ) ; //<S2SV> op -> len += n ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> goto err ; //<S2SV> } //<S2SV> return op -> len ; //<S2SV> err : //<S2SV> op -> len = 1 ; //<S2SV> snprintf ( op -> txt , R_ASM_BUFSIZE , "invalid" ) ; //<S2SV> return op -> len ; //<S2SV> } //<S2SV> 