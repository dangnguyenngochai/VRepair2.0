static //<S2SV> void * Type_MLU_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) //<S2SV> { //<S2SV> cmsMLU * mlu ; //<S2SV> cmsUInt32Number Count , RecLen , NumOfWchar ; //<S2SV> cmsUInt32Number SizeOfHeader ; //<S2SV> cmsUInt32Number Len , Offset ; //<S2SV> cmsUInt32Number i ; //<S2SV> wchar_t * Block ; //<S2SV> cmsUInt32Number BeginOfThisString , EndOfThisString , LargestPosition ; //<S2SV> * nItems = 0 ; //<S2SV> if ( ! _cmsReadUInt32Number ( io , & Count ) ) return NULL ; //<S2SV> if ( ! _cmsReadUInt32Number ( io , & RecLen ) ) return NULL ; //<S2SV> if ( RecLen != 12 ) { //<S2SV> cmsSignalError ( self -> ContextID , cmsERROR_UNKNOWN_EXTENSION , "multiLocalizedUnicodeType<S2SV_blank>of<S2SV_blank>len<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported." ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> mlu = cmsMLUalloc ( self -> ContextID , Count ) ; //<S2SV> if ( mlu == NULL ) return NULL ; //<S2SV> mlu -> UsedEntries = Count ; //<S2SV> SizeOfHeader = 12 * Count + sizeof ( _cmsTagBase ) ; //<S2SV> LargestPosition = 0 ; //<S2SV> for ( i = 0 ; i < Count ; i ++ ) { //<S2SV> if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Language ) ) goto Error ; //<S2SV> if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Country ) ) goto Error ; //<S2SV> if ( ! _cmsReadUInt32Number ( io , & Len ) ) goto Error ; //<S2SV> if ( ! _cmsReadUInt32Number ( io , & Offset ) ) goto Error ; //<S2SV> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; //<S2SV> BeginOfThisString = Offset - SizeOfHeader - 8 ; //<S2SV> mlu -> Entries [ i ] . Len = ( Len * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; //<S2SV> mlu -> Entries [ i ] . StrW = ( BeginOfThisString * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; //<S2SV> EndOfThisString = BeginOfThisString + Len ; //<S2SV> if ( EndOfThisString > LargestPosition ) //<S2SV> LargestPosition = EndOfThisString ; //<S2SV> } //<S2SV> SizeOfTag = ( LargestPosition * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; //<S2SV> if ( SizeOfTag == 0 ) //<S2SV> { //<S2SV> Block = NULL ; //<S2SV> NumOfWchar = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Block = ( wchar_t * ) _cmsMalloc ( self -> ContextID , SizeOfTag ) ; //<S2SV> if ( Block == NULL ) goto Error ; //<S2SV> NumOfWchar = SizeOfTag / sizeof ( wchar_t ) ; //<S2SV> if ( ! _cmsReadWCharArray ( io , NumOfWchar , Block ) ) goto Error ; //<S2SV> } //<S2SV> mlu -> MemPool = Block ; //<S2SV> mlu -> PoolSize = SizeOfTag ; //<S2SV> mlu -> PoolUsed = SizeOfTag ; //<S2SV> * nItems = 1 ; //<S2SV> return ( void * ) mlu ; //<S2SV> Error : //<S2SV> if ( mlu ) cmsMLUfree ( mlu ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 