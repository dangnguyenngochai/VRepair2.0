int main ( int argc , char * * argv ) { //<S2SV> int result ; //<S2SV> int error = FALSE ; //<S2SV> int display_license = FALSE ; //<S2SV> int display_help = FALSE ; //<S2SV> int c = 0 ; //<S2SV> struct tm * tm , tm_s ; //<S2SV> time_t now ; //<S2SV> char datestring [ 256 ] ; //<S2SV> nagios_macros * mac ; //<S2SV> const char * worker_socket = NULL ; //<S2SV> int i ; //<S2SV> # ifdef HAVE_SIGACTION //<S2SV> struct sigaction sig_action ; //<S2SV> # endif //<S2SV> # ifdef HAVE_GETOPT_H //<S2SV> int option_index = 0 ; //<S2SV> static struct option long_options [ ] = { //<S2SV> { "help" , no_argument , 0 , 'h' } , //<S2SV> { "version" , no_argument , 0 , 'V' } , //<S2SV> { "license" , no_argument , 0 , 'V' } , //<S2SV> { "verify-config" , no_argument , 0 , 'v' } , //<S2SV> { "daemon" , no_argument , 0 , 'd' } , //<S2SV> { "test-scheduling" , no_argument , 0 , 's' } , //<S2SV> { "precache-objects" , no_argument , 0 , 'p' } , //<S2SV> { "use-precached-objects" , no_argument , 0 , 'u' } , //<S2SV> { "enable-timing-point" , no_argument , 0 , 'T' } , //<S2SV> { "worker" , required_argument , 0 , 'W' } , //<S2SV> { 0 , 0 , 0 , 0 } //<S2SV> } ; //<S2SV> # define getopt ( argc , argv , o ) getopt_long ( argc , argv , o , long_options , & option_index ) //<S2SV> # endif //<S2SV> memset ( & loadctl , 0 , sizeof ( loadctl ) ) ; //<S2SV> mac = get_global_macros ( ) ; //<S2SV> if ( argc < 2 ) //<S2SV> error = TRUE ; //<S2SV> while ( 1 ) { //<S2SV> c = getopt ( argc , argv , "+hVvdspuxTW" ) ; //<S2SV> if ( c == - 1 || c == EOF ) //<S2SV> break ; //<S2SV> switch ( c ) { //<S2SV> case '?' : //<S2SV> case 'h' : //<S2SV> display_help = TRUE ; //<S2SV> break ; //<S2SV> case 'V' : //<S2SV> display_license = TRUE ; //<S2SV> break ; //<S2SV> case 'v' : //<S2SV> verify_config ++ ; //<S2SV> break ; //<S2SV> case 's' : //<S2SV> test_scheduling = TRUE ; //<S2SV> break ; //<S2SV> case 'd' : //<S2SV> daemon_mode = TRUE ; //<S2SV> break ; //<S2SV> case 'p' : //<S2SV> precache_objects = TRUE ; //<S2SV> break ; //<S2SV> case 'u' : //<S2SV> use_precached_objects = TRUE ; //<S2SV> break ; //<S2SV> case 'T' : //<S2SV> enable_timing_point = TRUE ; //<S2SV> break ; //<S2SV> case 'W' : //<S2SV> worker_socket = optarg ; //<S2SV> break ; //<S2SV> case 'x' : //<S2SV> printf ( "Warning:<S2SV_blank>-x<S2SV_blank>is<S2SV_blank>deprecated<S2SV_blank>and<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed\\n" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> # ifdef DEBUG_MEMORY //<S2SV> mtrace ( ) ; //<S2SV> # endif //<S2SV> if ( worker_socket ) { //<S2SV> exit ( nagios_core_worker ( worker_socket ) ) ; //<S2SV> } //<S2SV> init_main_cfg_vars ( 1 ) ; //<S2SV> init_shared_cfg_vars ( 1 ) ; //<S2SV> if ( daemon_mode == FALSE ) { //<S2SV> printf ( "\\nNagios<S2SV_blank>Core<S2SV_blank>%s\\n" , PROGRAM_VERSION ) ; //<S2SV> printf ( "Copyright<S2SV_blank>(c)<S2SV_blank>2009-present<S2SV_blank>Nagios<S2SV_blank>Core<S2SV_blank>Development<S2SV_blank>Team<S2SV_blank>and<S2SV_blank>Community<S2SV_blank>Contributors\\n" ) ; //<S2SV> printf ( "Copyright<S2SV_blank>(c)<S2SV_blank>1999-2009<S2SV_blank>Ethan<S2SV_blank>Galstad\\n" ) ; //<S2SV> printf ( "Last<S2SV_blank>Modified:<S2SV_blank>%s\\n" , PROGRAM_MODIFICATION_DATE ) ; //<S2SV> printf ( "License:<S2SV_blank>GPL\\n\\n" ) ; //<S2SV> printf ( "Website:<S2SV_blank>https://www.nagios.org\\n" ) ; //<S2SV> } //<S2SV> if ( display_license == TRUE ) { //<S2SV> printf ( "This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>you<S2SV_blank>can<S2SV_blank>redistribute<S2SV_blank>it<S2SV_blank>and/or<S2SV_blank>modify\\n" ) ; //<S2SV> printf ( "it<S2SV_blank>under<S2SV_blank>the<S2SV_blank>terms<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>version<S2SV_blank>2<S2SV_blank>as\\n" ) ; //<S2SV> printf ( "published<S2SV_blank>by<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software<S2SV_blank>Foundation.\\n\\n" ) ; //<S2SV> printf ( "This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>distributed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hope<S2SV_blank>that<S2SV_blank>it<S2SV_blank>will<S2SV_blank>be<S2SV_blank>useful,\\n" ) ; //<S2SV> printf ( "but<S2SV_blank>WITHOUT<S2SV_blank>ANY<S2SV_blank>WARRANTY;<S2SV_blank>without<S2SV_blank>even<S2SV_blank>the<S2SV_blank>implied<S2SV_blank>warranty<S2SV_blank>of\\n" ) ; //<S2SV> printf ( "MERCHANTABILITY<S2SV_blank>or<S2SV_blank>FITNESS<S2SV_blank>FOR<S2SV_blank>A<S2SV_blank>PARTICULAR<S2SV_blank>PURPOSE.<S2SV_blank><S2SV_blank>See<S2SV_blank>the\\n" ) ; //<S2SV> printf ( "GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>for<S2SV_blank>more<S2SV_blank>details.\\n\\n" ) ; //<S2SV> printf ( "You<S2SV_blank>should<S2SV_blank>have<S2SV_blank>received<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License\\n" ) ; //<S2SV> printf ( "along<S2SV_blank>with<S2SV_blank>this<S2SV_blank>program;<S2SV_blank>if<S2SV_blank>not,<S2SV_blank>write<S2SV_blank>to<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software\\n" ) ; //<S2SV> printf ( "Foundation,<S2SV_blank>Inc.,<S2SV_blank>675<S2SV_blank>Mass<S2SV_blank>Ave,<S2SV_blank>Cambridge,<S2SV_blank>MA<S2SV_blank>02139,<S2SV_blank>USA.\\n\\n" ) ; //<S2SV> exit ( OK ) ; //<S2SV> } //<S2SV> if ( optind >= argc ) //<S2SV> error = TRUE ; //<S2SV> if ( error == TRUE || display_help == TRUE ) { //<S2SV> printf ( "Usage:<S2SV_blank>%s<S2SV_blank>[options]<S2SV_blank><main_config_file>\\n" , argv [ 0 ] ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "Options:\\n" ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--verify-config<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>all<S2SV_blank>configuration<S2SV_blank>data<S2SV_blank>(-v<S2SV_blank>-v<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info)\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--test-scheduling<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Shows<S2SV_blank>projected/recommended<S2SV_blank>check<S2SV_blank>scheduling<S2SV_blank>and<S2SV_blank>other\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>diagnostic<S2SV_blank>info<S2SV_blank>based<S2SV_blank>on<S2SV_blank>the<S2SV_blank>current<S2SV_blank>configuration<S2SV_blank>files.\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>-T,<S2SV_blank>--enable-timing-point<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>timed<S2SV_blank>commentary<S2SV_blank>on<S2SV_blank>initialization\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--dont-verify-paths<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Deprecated<S2SV_blank>(Don\'t<S2SV_blank>check<S2SV_blank>for<S2SV_blank>circular<S2SV_blank>object<S2SV_blank>paths)\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--precache-objects<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Precache<S2SV_blank>object<S2SV_blank>configuration\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--use-precached-objects<S2SV_blank><S2SV_blank>Use<S2SV_blank>precached<S2SV_blank>object<S2SV_blank>config<S2SV_blank>file\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--daemon<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Starts<S2SV_blank>Nagios<S2SV_blank>in<S2SV_blank>daemon<S2SV_blank>mode,<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>as<S2SV_blank>a<S2SV_blank>foreground<S2SV_blank>process\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>-W,<S2SV_blank>--worker<S2SV_blank>/path/to/socket<S2SV_blank>Act<S2SV_blank>as<S2SV_blank>a<S2SV_blank>worker<S2SV_blank>for<S2SV_blank>an<S2SV_blank>already<S2SV_blank>running<S2SV_blank>daemon\\n" ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "Visit<S2SV_blank>the<S2SV_blank>Nagios<S2SV_blank>website<S2SV_blank>at<S2SV_blank>https://www.nagios.org/<S2SV_blank>for<S2SV_blank>bug<S2SV_blank>fixes,<S2SV_blank>new\\n" ) ; //<S2SV> printf ( "releases,<S2SV_blank>online<S2SV_blank>documentation,<S2SV_blank>FAQs,<S2SV_blank>information<S2SV_blank>on<S2SV_blank>subscribing<S2SV_blank>to\\n" ) ; //<S2SV> printf ( "the<S2SV_blank>mailing<S2SV_blank>lists,<S2SV_blank>and<S2SV_blank>commercial<S2SV_blank>support<S2SV_blank>options<S2SV_blank>for<S2SV_blank>Nagios.\\n" ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> exit ( ERROR ) ; //<S2SV> } //<S2SV> config_file = nspath_absolute ( argv [ optind ] , NULL ) ; //<S2SV> if ( config_file == NULL ) { //<S2SV> printf ( "Error<S2SV_blank>allocating<S2SV_blank>memory.\\n" ) ; //<S2SV> exit ( ERROR ) ; //<S2SV> } //<S2SV> config_file_dir = nspath_absolute_dirname ( config_file , NULL ) ; //<S2SV> # ifdef HAVE_SIGACTION //<S2SV> sig_action . sa_sigaction = NULL ; //<S2SV> sig_action . sa_handler = handle_sigxfsz ; //<S2SV> sigfillset ( & sig_action . sa_mask ) ; //<S2SV> sig_action . sa_flags = SA_NODEFER | SA_RESTART ; //<S2SV> sigaction ( SIGXFSZ , & sig_action , NULL ) ; //<S2SV> # else //<S2SV> signal ( SIGXFSZ , handle_sigxfsz ) ; //<S2SV> # endif //<S2SV> if ( verify_config || test_scheduling || precache_objects ) { //<S2SV> reset_variables ( ) ; //<S2SV> set_loadctl_defaults ( ) ; //<S2SV> if ( verify_config ) //<S2SV> printf ( "Reading<S2SV_blank>configuration<S2SV_blank>data...\\n" ) ; //<S2SV> result = read_main_config_file ( config_file ) ; //<S2SV> if ( result != OK ) { //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file!\\n\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( verify_config ) //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>okay...\\n" ) ; //<S2SV> if ( ( result = drop_privileges ( nagios_user , nagios_group ) ) == ERROR ) { //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting." ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( ! verify_config && test_configured_paths ( ) == ERROR ) { //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>path<S2SV_blank>problems<S2SV_blank>detected.<S2SV_blank>Aborting.\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> result = read_all_object_data ( config_file ) ; //<S2SV> if ( result != OK ) { //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files!\\n\\n" ) ; //<S2SV> if ( ! strstr ( config_file , "nagios.cfg" ) ) { //<S2SV> printf ( "\\n***><S2SV_blank>The<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>looks<S2SV_blank>suspicious...\\n" ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>are<S2SV_blank>specifying<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>MAIN<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>on\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>and<S2SV_blank>not<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>another<S2SV_blank>configuration<S2SV_blank>file.<S2SV_blank><S2SV_blank>The\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>typically<S2SV_blank>\'%s\'\\n" , DEFAULT_CONFIG_FILE ) ; //<S2SV> } //<S2SV> printf ( "\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>processing<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files...\\n" ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\'Whats<S2SV_blank>New\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\n\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( verify_config ) { //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files<S2SV_blank>okay...\\n\\n" ) ; //<S2SV> printf ( "Running<S2SV_blank>pre-flight<S2SV_blank>check<S2SV_blank>on<S2SV_blank>configuration<S2SV_blank>data...\\n\\n" ) ; //<S2SV> } //<S2SV> result = pre_flight_check ( ) ; //<S2SV> if ( result != OK ) { //<S2SV> printf ( "\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check...\\n" ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\n" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\'Whats<S2SV_blank>New\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\n\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( verify_config ) { //<S2SV> printf ( "\\nThings<S2SV_blank>look<S2SV_blank>okay<S2SV_blank>-<S2SV_blank>No<S2SV_blank>serious<S2SV_blank>problems<S2SV_blank>were<S2SV_blank>detected<S2SV_blank>during<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check\\n" ) ; //<S2SV> } //<S2SV> if ( test_scheduling == TRUE ) { //<S2SV> init_event_queue ( ) ; //<S2SV> timing_point ( "Done<S2SV_blank>initializing<S2SV_blank>event<S2SV_blank>queue\\n" ) ; //<S2SV> initialize_retention_data ( config_file ) ; //<S2SV> read_initial_state_information ( ) ; //<S2SV> timing_point ( "Retention<S2SV_blank>data<S2SV_blank>and<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>parsed\\n" ) ; //<S2SV> init_timing_loop ( ) ; //<S2SV> timing_point ( "Timing<S2SV_blank>loop<S2SV_blank>initialized\\n" ) ; //<S2SV> display_scheduling_info ( ) ; //<S2SV> } //<S2SV> if ( precache_objects ) { //<S2SV> result = fcache_objects ( object_precache_file ) ; //<S2SV> timing_point ( "Done<S2SV_blank>precaching<S2SV_blank>objects\\n" ) ; //<S2SV> if ( result == OK ) { //<S2SV> printf ( "Object<S2SV_blank>precache<S2SV_blank>file<S2SV_blank>created:\\n%s\\n" , object_precache_file ) ; //<S2SV> } //<S2SV> else { //<S2SV> printf ( "Failed<S2SV_blank>to<S2SV_blank>precache<S2SV_blank>objects<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s\\n" , object_precache_file , strerror ( errno ) ) ; //<S2SV> } //<S2SV> } //<S2SV> cleanup ( ) ; //<S2SV> timing_point ( "Exiting\\n" ) ; //<S2SV> neb_free_module_list ( ) ; //<S2SV> free ( config_file_dir ) ; //<S2SV> free ( config_file ) ; //<S2SV> exit ( result ) ; //<S2SV> } //<S2SV> else { //<S2SV> if ( strchr ( argv [ 0 ] , '/' ) ) //<S2SV> nagios_binary_path = nspath_absolute ( argv [ 0 ] , NULL ) ; //<S2SV> else //<S2SV> nagios_binary_path = strdup ( argv [ 0 ] ) ; //<S2SV> if ( ! nagios_binary_path ) { //<S2SV> logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>nagios_binary_path\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( ! ( nagios_iobs = iobroker_create ( ) ) ) { //<S2SV> logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>IO<S2SV_blank>broker<S2SV_blank>set:<S2SV_blank>%s\\n" , //<S2SV> strerror ( errno ) ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> do { //<S2SV> wproc_num_workers_spawned = wproc_num_workers_online = 0 ; //<S2SV> caught_signal = sigshutdown = FALSE ; //<S2SV> sig_id = 0 ; //<S2SV> reset_variables ( ) ; //<S2SV> timing_point ( "Variables<S2SV_blank>reset\\n" ) ; //<S2SV> nagios_pid = ( int ) getpid ( ) ; //<S2SV> result = read_main_config_file ( config_file ) ; //<S2SV> if ( result != OK ) { //<S2SV> logit ( NSLOG_CONFIG_ERROR , TRUE , "Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>process<S2SV_blank>config<S2SV_blank>file<S2SV_blank>\'%s\'.<S2SV_blank>Aborting\\n" , config_file ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> timing_point ( "Main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>read\\n" ) ; //<S2SV> program_start = time ( NULL ) ; //<S2SV> my_free ( mac -> x [ MACRO_PROCESSSTARTTIME ] ) ; //<S2SV> asprintf ( & mac -> x [ MACRO_PROCESSSTARTTIME ] , "%llu" , ( unsigned long long ) program_start ) ; //<S2SV> if ( daemon_mode == TRUE && sigrestart == FALSE ) { //<S2SV> result = daemon_init ( ) ; //<S2SV> if ( result == ERROR ) { //<S2SV> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; //<S2SV> cleanup ( ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> nagios_pid = ( int ) getpid ( ) ; //<S2SV> } //<S2SV> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { //<S2SV> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , "Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting." ) ; //<S2SV> cleanup ( ) ; //<S2SV> exit ( ERROR ) ; //<S2SV> } //<S2SV> if ( test_path_access ( nagios_binary_path , X_OK ) ) { //<S2SV> logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>access()<S2SV_blank>%s:<S2SV_blank>%s\\n" , nagios_binary_path , strerror ( errno ) ) ; //<S2SV> logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>Spawning<S2SV_blank>workers<S2SV_blank>will<S2SV_blank>be<S2SV_blank>impossible.<S2SV_blank>Aborting.\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( test_configured_paths ( ) == ERROR ) { //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> logit ( NSLOG_PROCESS_INFO , TRUE , "Nagios<S2SV_blank>%s<S2SV_blank>starting...<S2SV_blank>(PID=%d)\\n" , PROGRAM_VERSION , ( int ) getpid ( ) ) ; //<S2SV> now = time ( NULL ) ; //<S2SV> tm = localtime_r ( & now , & tm_s ) ; //<S2SV> strftime ( datestring , sizeof ( datestring ) , "%a<S2SV_blank>%b<S2SV_blank>%d<S2SV_blank>%H:%M:%S<S2SV_blank>%Z<S2SV_blank>%Y" , tm ) ; //<S2SV> logit ( NSLOG_PROCESS_INFO , TRUE , "Local<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s" , datestring ) ; //<S2SV> write_log_file_info ( NULL ) ; //<S2SV> open_debug_log ( ) ; //<S2SV> # ifdef USE_EVENT_BROKER //<S2SV> neb_init_modules ( ) ; //<S2SV> neb_init_callback_list ( ) ; //<S2SV> # endif //<S2SV> timing_point ( "NEB<S2SV_blank>module<S2SV_blank>API<S2SV_blank>initialized\\n" ) ; //<S2SV> setup_sighandler ( ) ; //<S2SV> if ( qh_init ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) != OK ) { //<S2SV> logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>query<S2SV_blank>handler.<S2SV_blank>Aborting\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> timing_point ( "Query<S2SV_blank>handler<S2SV_blank>initialized\\n" ) ; //<S2SV> nerd_init ( ) ; //<S2SV> timing_point ( "NERD<S2SV_blank>initialized\\n" ) ; //<S2SV> if ( init_workers ( num_check_workers ) < 0 ) { //<S2SV> logit ( NSLOG_RUNTIME_ERROR , TRUE , "Failed<S2SV_blank>to<S2SV_blank>spawn<S2SV_blank>workers.<S2SV_blank>Aborting\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> timing_point ( "%u<S2SV_blank>workers<S2SV_blank>spawned\\n" , wproc_num_workers_spawned ) ; //<S2SV> i = 0 ; //<S2SV> while ( i < 50 && wproc_num_workers_online < wproc_num_workers_spawned ) { //<S2SV> iobroker_poll ( nagios_iobs , 50 ) ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> timing_point ( "%u<S2SV_blank>workers<S2SV_blank>connected\\n" , wproc_num_workers_online ) ; //<S2SV> set_loadctl_defaults ( ) ; //<S2SV> # ifdef USE_EVENT_BROKER //<S2SV> if ( neb_load_all_modules ( ) != OK ) { //<S2SV> logit ( NSLOG_CONFIG_ERROR , ERROR , "Error:<S2SV_blank>Module<S2SV_blank>loading<S2SV_blank>failed.<S2SV_blank>Aborting.\\n" ) ; //<S2SV> if ( daemon_dumps_core ) //<S2SV> neb_unload_all_modules ( NEBMODULE_FORCE_UNLOAD , NEBMODULE_NEB_SHUTDOWN ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> timing_point ( "Modules<S2SV_blank>loaded\\n" ) ; //<S2SV> broker_program_state ( NEBTYPE_PROCESS_PRELAUNCH , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; //<S2SV> timing_point ( "First<S2SV_blank>callback<S2SV_blank>made\\n" ) ; //<S2SV> # endif //<S2SV> if ( result == OK ) //<S2SV> result = read_all_object_data ( config_file ) ; //<S2SV> if ( result != OK ) //<S2SV> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>one<S2SV_blank>or<S2SV_blank>more<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>in<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>files.<S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; //<S2SV> else { //<S2SV> if ( ( result = pre_flight_check ( ) ) != OK ) //<S2SV> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check.<S2SV_blank><S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)\\n" , ( int ) getpid ( ) ) ; //<S2SV> } //<S2SV> if ( result != OK ) { //<S2SV> if ( sigrestart == TRUE ) { //<S2SV> cleanup_status_data ( TRUE ) ; //<S2SV> } //<S2SV> # ifdef USE_EVENT_BROKER //<S2SV> broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_PROCESS_INITIATED , NEBATTR_SHUTDOWN_ABNORMAL , NULL ) ; //<S2SV> # endif //<S2SV> cleanup ( ) ; //<S2SV> exit ( ERROR ) ; //<S2SV> } //<S2SV> timing_point ( "Object<S2SV_blank>configuration<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>understood\\n" ) ; //<S2SV> fcache_objects ( object_cache_file ) ; //<S2SV> timing_point ( "Objects<S2SV_blank>cached\\n" ) ; //<S2SV> init_event_queue ( ) ; //<S2SV> timing_point ( "Event<S2SV_blank>queue<S2SV_blank>initialized\\n" ) ; //<S2SV> # ifdef USE_EVENT_BROKER //<S2SV> broker_program_state ( NEBTYPE_PROCESS_START , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; //<S2SV> # endif //<S2SV> if ( sigrestart == FALSE ) { //<S2SV> initialize_status_data ( config_file ) ; //<S2SV> timing_point ( "Status<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; //<S2SV> } //<S2SV> initialize_downtime_data ( ) ; //<S2SV> timing_point ( "Downtime<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; //<S2SV> initialize_retention_data ( config_file ) ; //<S2SV> timing_point ( "Retention<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; //<S2SV> read_initial_state_information ( ) ; //<S2SV> timing_point ( "Initial<S2SV_blank>state<S2SV_blank>information<S2SV_blank>read\\n" ) ; //<S2SV> initialize_comment_data ( ) ; //<S2SV> timing_point ( "Comment<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; //<S2SV> initialize_performance_data ( config_file ) ; //<S2SV> timing_point ( "Performance<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; //<S2SV> init_timing_loop ( ) ; //<S2SV> timing_point ( "Event<S2SV_blank>timing<S2SV_blank>loop<S2SV_blank>initialized\\n" ) ; //<S2SV> init_check_stats ( ) ; //<S2SV> timing_point ( "check<S2SV_blank>stats<S2SV_blank>initialized\\n" ) ; //<S2SV> check_for_nagios_updates ( FALSE , TRUE ) ; //<S2SV> timing_point ( "Update<S2SV_blank>check<S2SV_blank>concluded\\n" ) ; //<S2SV> update_all_status_data ( ) ; //<S2SV> timing_point ( "Status<S2SV_blank>data<S2SV_blank>updated\\n" ) ; //<S2SV> log_host_states ( INITIAL_STATES , NULL ) ; //<S2SV> log_service_states ( INITIAL_STATES , NULL ) ; //<S2SV> timing_point ( "Initial<S2SV_blank>states<S2SV_blank>logged\\n" ) ; //<S2SV> sigrestart = FALSE ; //<S2SV> launch_command_file_worker ( ) ; //<S2SV> timing_point ( "Command<S2SV_blank>file<S2SV_blank>worker<S2SV_blank>launched\\n" ) ; //<S2SV> # ifdef USE_EVENT_BROKER //<S2SV> broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPSTART , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; //<S2SV> # endif //<S2SV> event_start = time ( NULL ) ; //<S2SV> my_free ( mac -> x [ MACRO_EVENTSTARTTIME ] ) ; //<S2SV> asprintf ( & mac -> x [ MACRO_EVENTSTARTTIME ] , "%llu" , ( unsigned long long ) event_start ) ; //<S2SV> timing_point ( "Entering<S2SV_blank>event<S2SV_blank>execution<S2SV_blank>loop\\n" ) ; //<S2SV> event_execution_loop ( ) ; //<S2SV> qh_deinit ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) ; //<S2SV> if ( caught_signal == TRUE ) { //<S2SV> if ( sig_id == SIGHUP ) //<S2SV> logit ( NSLOG_PROCESS_INFO , TRUE , "Caught<S2SV_blank>SIGHUP,<S2SV_blank>restarting...\\n" ) ; //<S2SV> } //<S2SV> # ifdef USE_EVENT_BROKER //<S2SV> broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPEND , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; //<S2SV> if ( sigshutdown == TRUE ) //<S2SV> broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_USER_INITIATED , NEBATTR_SHUTDOWN_NORMAL , NULL ) ; //<S2SV> else if ( sigrestart == TRUE ) //<S2SV> broker_program_state ( NEBTYPE_PROCESS_RESTART , NEBFLAG_USER_INITIATED , NEBATTR_RESTART_NORMAL , NULL ) ; //<S2SV> # endif //<S2SV> save_state_information ( FALSE ) ; //<S2SV> cleanup_retention_data ( ) ; //<S2SV> cleanup_performance_data ( ) ; //<S2SV> cleanup_downtime_data ( ) ; //<S2SV> if ( sigrestart == FALSE ) { //<S2SV> cleanup_status_data ( TRUE ) ; //<S2SV> } //<S2SV> free_worker_memory ( WPROC_FORCE ) ; //<S2SV> if ( sigshutdown == TRUE ) { //<S2SV> iobroker_destroy ( nagios_iobs , IOBROKER_CLOSE_SOCKETS ) ; //<S2SV> nagios_iobs = NULL ; //<S2SV> logit ( NSLOG_PROCESS_INFO , TRUE , "Successfully<S2SV_blank>shutdown...<S2SV_blank>(PID=%d)\\n" , ( int ) getpid ( ) ) ; //<S2SV> } //<S2SV> cleanup ( ) ; //<S2SV> close_debug_log ( ) ; //<S2SV> } //<S2SV> while ( sigrestart == TRUE && sigshutdown == FALSE ) ; //<S2SV> if ( daemon_mode == TRUE ) //<S2SV> unlink ( lock_file ) ; //<S2SV> my_free ( lock_file ) ; //<S2SV> my_free ( config_file ) ; //<S2SV> my_free ( config_file_dir ) ; //<S2SV> my_free ( nagios_binary_path ) ; //<S2SV> } //<S2SV> return OK ; //<S2SV> } //<S2SV> 