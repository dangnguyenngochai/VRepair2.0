u32 h264bsdInitDpb ( //<S2SV> dpbStorage_t * dpb , //<S2SV> u32 picSizeInMbs , //<S2SV> u32 dpbSize , //<S2SV> u32 maxRefFrames , //<S2SV> u32 maxFrameNum , //<S2SV> u32 noReordering ) //<S2SV> { //<S2SV> u32 i ; //<S2SV> ASSERT ( picSizeInMbs ) ; //<S2SV> ASSERT ( maxRefFrames <= MAX_NUM_REF_PICS ) ; //<S2SV> ASSERT ( maxRefFrames <= dpbSize ) ; //<S2SV> ASSERT ( maxFrameNum ) ; //<S2SV> ASSERT ( dpbSize ) ; //<S2SV> dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ; //<S2SV> dpb -> maxRefFrames = MAX ( maxRefFrames , 1 ) ; //<S2SV> if ( noReordering ) //<S2SV> dpb -> dpbSize = dpb -> maxRefFrames ; //<S2SV> else //<S2SV> dpb -> dpbSize = dpbSize ; //<S2SV> dpb -> maxFrameNum = maxFrameNum ; //<S2SV> dpb -> noReordering = noReordering ; //<S2SV> dpb -> fullness = 0 ; //<S2SV> dpb -> numRefFrames = 0 ; //<S2SV> dpb -> prevRefFrameNum = 0 ; //<S2SV> ALLOCATE ( dpb -> buffer , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t ) ; //<S2SV> if ( dpb -> buffer == NULL ) //<S2SV> return ( MEMORY_ALLOCATION_ERROR ) ; //<S2SV> H264SwDecMemset ( dpb -> buffer , 0 , //<S2SV> ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t ) ) ; //<S2SV> for ( i = 0 ; i < dpb -> dpbSize + 1 ; i ++ ) //<S2SV> { //<S2SV> ALLOCATE ( dpb -> buffer [ i ] . pAllocatedData , ( picSizeInMbs * 384 + 32 + 15 ) , u8 ) ; //<S2SV> if ( dpb -> buffer [ i ] . pAllocatedData == NULL ) //<S2SV> return ( MEMORY_ALLOCATION_ERROR ) ; //<S2SV> dpb -> buffer [ i ] . data = ALIGN ( dpb -> buffer [ i ] . pAllocatedData , 16 ) ; //<S2SV> } //<S2SV> ALLOCATE ( dpb -> list , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t * ) ; //<S2SV> ALLOCATE ( dpb -> outBuf , dpb -> dpbSize + 1 , dpbOutPicture_t ) ; //<S2SV> if ( dpb -> list == NULL || dpb -> outBuf == NULL ) //<S2SV> return ( MEMORY_ALLOCATION_ERROR ) ; //<S2SV> H264SwDecMemset ( dpb -> list , 0 , //<S2SV> ( ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t * ) ) ) ; //<S2SV> dpb -> numOut = dpb -> outIndex = 0 ; //<S2SV> return ( HANTRO_OK ) ; //<S2SV> } //<S2SV> 