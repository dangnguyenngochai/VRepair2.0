int main ( int argc , char * * argv ) //<S2SV> { //<S2SV> u8 * byteStrmStart ; //<S2SV> u8 * byteStrm ; //<S2SV> u32 strmLen ; //<S2SV> u32 picSize ; //<S2SV> H264SwDecInst decInst ; //<S2SV> H264SwDecRet ret ; //<S2SV> H264SwDecInput decInput ; //<S2SV> H264SwDecOutput decOutput ; //<S2SV> H264SwDecPicture decPicture ; //<S2SV> H264SwDecInfo decInfo ; //<S2SV> u32 picNumber ; //<S2SV> FILE * finput ; //<S2SV> FILE * foutput ; //<S2SV> if ( argc < 2 ) //<S2SV> { //<S2SV> printf ( "Usage:<S2SV_blank>%s<S2SV_blank>file.h264\\n" , argv [ 0 ] ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> foutput = fopen ( "out.yuv" , "wb" ) ; //<S2SV> if ( foutput == NULL ) //<S2SV> { //<S2SV> printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>OUTPUT<S2SV_blank>FILE\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> finput = fopen ( argv [ argc - 1 ] , "rb" ) ; //<S2SV> if ( finput == NULL ) //<S2SV> { //<S2SV> printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>INPUT<S2SV_blank>FILE\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> fseek ( finput , 0L , SEEK_END ) ; //<S2SV> strmLen = ( u32 ) ftell ( finput ) ; //<S2SV> rewind ( finput ) ; //<S2SV> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; //<S2SV> if ( byteStrm == NULL ) //<S2SV> { //<S2SV> printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>ALLOCATE<S2SV_blank>MEMORY\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> fread ( byteStrm , sizeof ( u8 ) , strmLen , finput ) ; //<S2SV> fclose ( finput ) ; //<S2SV> ret = H264SwDecInit ( & decInst , 0 ) ; //<S2SV> if ( ret != H264SWDEC_OK ) //<S2SV> { //<S2SV> printf ( "DECODER<S2SV_blank>INITIALIZATION<S2SV_blank>FAILED\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> decInput . pStream = byteStrmStart ; //<S2SV> decInput . dataLen = strmLen ; //<S2SV> decInput . intraConcealmentMethod = 0 ; //<S2SV> picNumber = 0 ; //<S2SV> do //<S2SV> { //<S2SV> ret = H264SwDecDecode ( decInst , & decInput , & decOutput ) ; //<S2SV> switch ( ret ) //<S2SV> { //<S2SV> case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY : //<S2SV> ret = H264SwDecGetInfo ( decInst , & decInfo ) ; //<S2SV> if ( ret != H264SWDEC_OK ) //<S2SV> return - 1 ; //<S2SV> picSize = decInfo . picWidth * decInfo . picHeight ; //<S2SV> picSize = ( 3 * picSize ) / 2 ; //<S2SV> printf ( "Width<S2SV_blank>%d<S2SV_blank>Height<S2SV_blank>%d\\n" , //<S2SV> decInfo . picWidth , decInfo . picHeight ) ; //<S2SV> decInput . dataLen -= //<S2SV> ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; //<S2SV> decInput . pStream = decOutput . pStrmCurrPos ; //<S2SV> break ; //<S2SV> case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY : //<S2SV> case H264SWDEC_PIC_RDY : //<S2SV> decInput . dataLen -= //<S2SV> ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; //<S2SV> decInput . pStream = decOutput . pStrmCurrPos ; //<S2SV> while ( H264SwDecNextPicture ( decInst , & decPicture , 0 ) == //<S2SV> H264SWDEC_PIC_RDY ) { picNumber ++ ; //<S2SV> printf ( "PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n" , picNumber , //<S2SV> decPicture . isIdrPicture ? "IDR" : "NON-IDR" , //<S2SV> decPicture . nbrOfErrMBs ) ; //<S2SV> fflush ( stdout ) ; //<S2SV> WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , //<S2SV> picSize ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case H264SWDEC_EVALUATION_LIMIT_EXCEEDED : //<S2SV> printf ( "EVALUATION<S2SV_blank>LIMIT<S2SV_blank>REACHED\\n" ) ; //<S2SV> goto end ; //<S2SV> default : //<S2SV> printf ( "UNRECOVERABLE<S2SV_blank>ERROR\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } while ( decInput . dataLen > 0 ) ; //<S2SV> end : //<S2SV> while ( H264SwDecNextPicture ( decInst , & decPicture , 1 ) == //<S2SV> H264SWDEC_PIC_RDY ) { //<S2SV> picNumber ++ ; //<S2SV> printf ( "PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n" , picNumber , //<S2SV> decPicture . isIdrPicture ? "IDR" : "NON-IDR" , //<S2SV> decPicture . nbrOfErrMBs ) ; //<S2SV> fflush ( stdout ) ; //<S2SV> WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; //<S2SV> } //<S2SV> H264SwDecRelease ( decInst ) ; //<S2SV> fclose ( foutput ) ; //<S2SV> free ( byteStrmStart ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 