u32 h264bsdActivateParamSets ( storage_t * pStorage , u32 ppsId , u32 isIdr ) //<S2SV> { //<S2SV> u32 tmp ; //<S2SV> u32 flag ; //<S2SV> ASSERT ( pStorage ) ; //<S2SV> ASSERT ( ppsId < MAX_NUM_PIC_PARAM_SETS ) ; //<S2SV> if ( ( pStorage -> pps [ ppsId ] == NULL ) || //<S2SV> ( pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] == NULL ) ) //<S2SV> { //<S2SV> return ( HANTRO_NOK ) ; //<S2SV> } //<S2SV> tmp = CheckPps ( pStorage -> pps [ ppsId ] , //<S2SV> pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] ) ; //<S2SV> if ( tmp != HANTRO_OK ) //<S2SV> return ( tmp ) ; //<S2SV> if ( pStorage -> activePpsId == MAX_NUM_PIC_PARAM_SETS ) //<S2SV> { //<S2SV> pStorage -> activePpsId = ppsId ; //<S2SV> pStorage -> activePps = pStorage -> pps [ ppsId ] ; //<S2SV> pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; //<S2SV> pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; //<S2SV> pStorage -> picSizeInMbs = //<S2SV> pStorage -> activeSps -> picWidthInMbs * //<S2SV> pStorage -> activeSps -> picHeightInMbs ; //<S2SV> pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; //<S2SV> pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; //<S2SV> pStorage -> pendingActivation = HANTRO_TRUE ; //<S2SV> } //<S2SV> else if ( pStorage -> pendingActivation ) //<S2SV> { //<S2SV> pStorage -> pendingActivation = HANTRO_FALSE ; //<S2SV> FREE ( pStorage -> mb ) ; //<S2SV> FREE ( pStorage -> sliceGroupMap ) ; //<S2SV> ALLOCATE ( pStorage -> mb , pStorage -> picSizeInMbs , mbStorage_t ) ; //<S2SV> ALLOCATE ( pStorage -> sliceGroupMap , pStorage -> picSizeInMbs , u32 ) ; //<S2SV> if ( pStorage -> mb == NULL || pStorage -> sliceGroupMap == NULL ) //<S2SV> return ( MEMORY_ALLOCATION_ERROR ) ; //<S2SV> H264SwDecMemset ( pStorage -> mb , 0 , //<S2SV> pStorage -> picSizeInMbs * sizeof ( mbStorage_t ) ) ; //<S2SV> h264bsdInitMbNeighbours ( pStorage -> mb , //<S2SV> pStorage -> activeSps -> picWidthInMbs , //<S2SV> pStorage -> picSizeInMbs ) ; //<S2SV> if ( pStorage -> noReordering || //<S2SV> pStorage -> activeSps -> picOrderCntType == 2 || //<S2SV> ( pStorage -> activeSps -> vuiParametersPresentFlag && //<S2SV> pStorage -> activeSps -> vuiParameters -> bitstreamRestrictionFlag && //<S2SV> ! pStorage -> activeSps -> vuiParameters -> numReorderFrames ) ) //<S2SV> flag = HANTRO_TRUE ; //<S2SV> else //<S2SV> flag = HANTRO_FALSE ; //<S2SV> tmp = h264bsdResetDpb ( pStorage -> dpb , //<S2SV> pStorage -> activeSps -> picWidthInMbs * //<S2SV> pStorage -> activeSps -> picHeightInMbs , //<S2SV> pStorage -> activeSps -> maxDpbSize , //<S2SV> pStorage -> activeSps -> numRefFrames , //<S2SV> pStorage -> activeSps -> maxFrameNum , //<S2SV> flag ) ; //<S2SV> if ( tmp != HANTRO_OK ) //<S2SV> return ( tmp ) ; //<S2SV> } //<S2SV> else if ( ppsId != pStorage -> activePpsId ) //<S2SV> { //<S2SV> if ( pStorage -> pps [ ppsId ] -> seqParameterSetId != pStorage -> activeSpsId ) //<S2SV> { //<S2SV> DEBUG ( ( "SEQ<S2SV_blank>PARAM<S2SV_blank>SET<S2SV_blank>CHANGING...\\n" ) ) ; //<S2SV> if ( isIdr ) //<S2SV> { //<S2SV> pStorage -> activePpsId = ppsId ; //<S2SV> pStorage -> activePps = pStorage -> pps [ ppsId ] ; //<S2SV> pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; //<S2SV> pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; //<S2SV> pStorage -> picSizeInMbs = //<S2SV> pStorage -> activeSps -> picWidthInMbs * //<S2SV> pStorage -> activeSps -> picHeightInMbs ; //<S2SV> pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; //<S2SV> pStorage -> currImage -> height = //<S2SV> pStorage -> activeSps -> picHeightInMbs ; //<S2SV> pStorage -> pendingActivation = HANTRO_TRUE ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> DEBUG ( ( "TRYING<S2SV_blank>TO<S2SV_blank>CHANGE<S2SV_blank>SPS<S2SV_blank>IN<S2SV_blank>NON-IDR<S2SV_blank>SLICE\\n" ) ) ; //<S2SV> return ( HANTRO_NOK ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pStorage -> activePpsId = ppsId ; //<S2SV> pStorage -> activePps = pStorage -> pps [ ppsId ] ; //<S2SV> } //<S2SV> } //<S2SV> return ( HANTRO_OK ) ; //<S2SV> } //<S2SV> 