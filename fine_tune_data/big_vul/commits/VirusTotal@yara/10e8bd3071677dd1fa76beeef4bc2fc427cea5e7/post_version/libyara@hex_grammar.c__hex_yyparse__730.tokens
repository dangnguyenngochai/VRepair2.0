int //<S2SV> yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) //<S2SV> { //<S2SV> int yychar ; //<S2SV> YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) //<S2SV> YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; //<S2SV> int yynerrs ; //<S2SV> int yystate ; //<S2SV> int yyerrstatus ; //<S2SV> yytype_int16 yyssa [ YYINITDEPTH ] ; //<S2SV> yytype_int16 * yyss ; //<S2SV> yytype_int16 * yyssp ; //<S2SV> YYSTYPE yyvsa [ YYINITDEPTH ] ; //<S2SV> YYSTYPE * yyvs ; //<S2SV> YYSTYPE * yyvsp ; //<S2SV> YYSIZE_T yystacksize ; //<S2SV> int yyn ; //<S2SV> int yyresult ; //<S2SV> int yytoken = 0 ; //<S2SV> YYSTYPE yyval ; //<S2SV> # if YYERROR_VERBOSE //<S2SV> char yymsgbuf [ 128 ] ; //<S2SV> char * yymsg = yymsgbuf ; //<S2SV> YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; //<S2SV> # endif //<S2SV> # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) //<S2SV> int yylen = 0 ; //<S2SV> yyssp = yyss = yyssa ; //<S2SV> yyvsp = yyvs = yyvsa ; //<S2SV> yystacksize = YYINITDEPTH ; //<S2SV> YYDPRINTF ( ( stderr , "Starting<S2SV_blank>parse\\n" ) ) ; //<S2SV> yystate = 0 ; //<S2SV> yyerrstatus = 0 ; //<S2SV> yynerrs = 0 ; //<S2SV> yychar = YYEMPTY ; //<S2SV> goto yysetstate ; //<S2SV> yynewstate : //<S2SV> yyssp ++ ; //<S2SV> yysetstate : //<S2SV> * yyssp = yystate ; //<S2SV> if ( yyss + yystacksize - 1 <= yyssp ) //<S2SV> { //<S2SV> YYSIZE_T yysize = yyssp - yyss + 1 ; //<S2SV> # ifdef yyoverflow //<S2SV> { //<S2SV> YYSTYPE * yyvs1 = yyvs ; //<S2SV> yytype_int16 * yyss1 = yyss ; //<S2SV> yyoverflow ( YY_ ( "memory<S2SV_blank>exhausted" ) , //<S2SV> & yyss1 , yysize * sizeof ( * yyssp ) , //<S2SV> & yyvs1 , yysize * sizeof ( * yyvsp ) , //<S2SV> & yystacksize ) ; //<S2SV> yyss = yyss1 ; //<S2SV> yyvs = yyvs1 ; //<S2SV> } //<S2SV> # else //<S2SV> # ifndef YYSTACK_RELOCATE //<S2SV> goto yyexhaustedlab ; //<S2SV> # else //<S2SV> if ( YYMAXDEPTH <= yystacksize ) //<S2SV> goto yyexhaustedlab ; //<S2SV> yystacksize *= 2 ; //<S2SV> if ( YYMAXDEPTH < yystacksize ) //<S2SV> yystacksize = YYMAXDEPTH ; //<S2SV> { //<S2SV> yytype_int16 * yyss1 = yyss ; //<S2SV> union yyalloc * yyptr = //<S2SV> ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; //<S2SV> if ( ! yyptr ) //<S2SV> goto yyexhaustedlab ; //<S2SV> YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; //<S2SV> YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; //<S2SV> # undef YYSTACK_RELOCATE //<S2SV> if ( yyss1 != yyssa ) //<S2SV> YYSTACK_FREE ( yyss1 ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # endif //<S2SV> yyssp = yyss + yysize - 1 ; //<S2SV> yyvsp = yyvs + yysize - 1 ; //<S2SV> YYDPRINTF ( ( stderr , "Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n" , //<S2SV> ( unsigned long int ) yystacksize ) ) ; //<S2SV> if ( yyss + yystacksize - 1 <= yyssp ) //<S2SV> YYABORT ; //<S2SV> } //<S2SV> YYDPRINTF ( ( stderr , "Entering<S2SV_blank>state<S2SV_blank>%d\\n" , yystate ) ) ; //<S2SV> if ( yystate == YYFINAL ) //<S2SV> YYACCEPT ; //<S2SV> goto yybackup ; //<S2SV> yybackup : //<S2SV> yyn = yypact [ yystate ] ; //<S2SV> if ( yypact_value_is_default ( yyn ) ) //<S2SV> goto yydefault ; //<S2SV> if ( yychar == YYEMPTY ) //<S2SV> { //<S2SV> YYDPRINTF ( ( stderr , "Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>" ) ) ; //<S2SV> yychar = yylex ( & yylval , yyscanner , lex_env ) ; //<S2SV> } //<S2SV> if ( yychar <= YYEOF ) //<S2SV> { //<S2SV> yychar = yytoken = YYEOF ; //<S2SV> YYDPRINTF ( ( stderr , "Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n" ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> yytoken = YYTRANSLATE ( yychar ) ; //<S2SV> YY_SYMBOL_PRINT ( "Next<S2SV_blank>token<S2SV_blank>is" , yytoken , & yylval , & yylloc ) ; //<S2SV> } //<S2SV> yyn += yytoken ; //<S2SV> if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) //<S2SV> goto yydefault ; //<S2SV> yyn = yytable [ yyn ] ; //<S2SV> if ( yyn <= 0 ) //<S2SV> { //<S2SV> if ( yytable_value_is_error ( yyn ) ) //<S2SV> goto yyerrlab ; //<S2SV> yyn = - yyn ; //<S2SV> goto yyreduce ; //<S2SV> } //<S2SV> if ( yyerrstatus ) //<S2SV> yyerrstatus -- ; //<S2SV> YY_SYMBOL_PRINT ( "Shifting" , yytoken , & yylval , & yylloc ) ; //<S2SV> yychar = YYEMPTY ; //<S2SV> yystate = yyn ; //<S2SV> YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN //<S2SV> * ++ yyvsp = yylval ; //<S2SV> YY_IGNORE_MAYBE_UNINITIALIZED_END //<S2SV> goto yynewstate ; //<S2SV> yydefault : //<S2SV> yyn = yydefact [ yystate ] ; //<S2SV> if ( yyn == 0 ) //<S2SV> goto yyerrlab ; //<S2SV> goto yyreduce ; //<S2SV> yyreduce : //<S2SV> yylen = yyr2 [ yyn ] ; //<S2SV> yyval = yyvsp [ 1 - yylen ] ; //<S2SV> YY_REDUCE_PRINT ( yyn ) ; //<S2SV> switch ( yyn ) //<S2SV> { //<S2SV> case 2 : //<S2SV> # line 113 "hex_grammar.y" //<S2SV> { //<S2SV> RE_AST * re_ast = yyget_extra ( yyscanner ) ; //<S2SV> re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; //<S2SV> } //<S2SV> # line 1337 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 3 : //<S2SV> # line 122 "hex_grammar.y" //<S2SV> { //<S2SV> ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; //<S2SV> } //<S2SV> # line 1345 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 4 : //<S2SV> # line 126 "hex_grammar.y" //<S2SV> { //<S2SV> incr_ast_levels ( ) ; //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> } //<S2SV> # line 1360 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 5 : //<S2SV> # line 137 "hex_grammar.y" //<S2SV> { //<S2SV> RE_NODE * new_concat ; //<S2SV> RE_NODE * leftmost_concat = NULL ; //<S2SV> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; //<S2SV> incr_ast_levels ( ) ; //<S2SV> ( yyval . re_node ) = NULL ; //<S2SV> while ( leftmost_node -> type == RE_NODE_CONCAT ) //<S2SV> { //<S2SV> leftmost_concat = leftmost_node ; //<S2SV> leftmost_node = leftmost_node -> left ; //<S2SV> } //<S2SV> new_concat = yr_re_node_create ( //<S2SV> RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; //<S2SV> if ( new_concat != NULL ) //<S2SV> { //<S2SV> if ( leftmost_concat != NULL ) //<S2SV> { //<S2SV> leftmost_concat -> left = new_concat ; //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> } //<S2SV> } //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> } //<S2SV> # line 1424 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 6 : //<S2SV> # line 201 "hex_grammar.y" //<S2SV> { //<S2SV> ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; //<S2SV> } //<S2SV> # line 1432 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 7 : //<S2SV> # line 205 "hex_grammar.y" //<S2SV> { //<S2SV> incr_ast_levels ( ) ; //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> } //<S2SV> # line 1447 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 8 : //<S2SV> # line 220 "hex_grammar.y" //<S2SV> { //<S2SV> ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; //<S2SV> } //<S2SV> # line 1455 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 9 : //<S2SV> # line 224 "hex_grammar.y" //<S2SV> { //<S2SV> ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; //<S2SV> ( yyval . re_node ) -> greedy = FALSE ; //<S2SV> } //<S2SV> # line 1464 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 10 : //<S2SV> # line 233 "hex_grammar.y" //<S2SV> { //<S2SV> lex_env -> token_count ++ ; //<S2SV> if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) //<S2SV> { //<S2SV> yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> yyerror ( yyscanner , lex_env , "string<S2SV_blank>too<S2SV_blank>long" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; //<S2SV> } //<S2SV> # line 1481 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 11 : //<S2SV> # line 246 "hex_grammar.y" //<S2SV> { //<S2SV> lex_env -> inside_or ++ ; //<S2SV> } //<S2SV> # line 1489 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 12 : //<S2SV> # line 250 "hex_grammar.y" //<S2SV> { //<S2SV> ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; //<S2SV> lex_env -> inside_or -- ; //<S2SV> } //<S2SV> # line 1498 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 13 : //<S2SV> # line 259 "hex_grammar.y" //<S2SV> { //<S2SV> if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "invalid<S2SV_blank>jump<S2SV_blank>length" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "jumps<S2SV_blank>over<S2SV_blank>" //<S2SV> STR ( STRING_CHAINING_THRESHOLD ) //<S2SV> "<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; //<S2SV> ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; //<S2SV> } //<S2SV> # line 1525 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 14 : //<S2SV> # line 282 "hex_grammar.y" //<S2SV> { //<S2SV> if ( lex_env -> inside_or && //<S2SV> ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || //<S2SV> ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "jumps<S2SV_blank>over<S2SV_blank>" //<S2SV> STR ( STRING_CHAINING_THRESHOLD ) //<S2SV> "<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "invalid<S2SV_blank>jump<S2SV_blank>range" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; //<S2SV> ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; //<S2SV> } //<S2SV> # line 1561 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 15 : //<S2SV> # line 314 "hex_grammar.y" //<S2SV> { //<S2SV> if ( lex_env -> inside_or ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , //<S2SV> "unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> if ( ( yyvsp [ - 2 ] . integer ) < 0 ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; //<S2SV> ( yyval . re_node ) -> end = INT_MAX ; //<S2SV> } //<S2SV> # line 1587 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 16 : //<S2SV> # line 336 "hex_grammar.y" //<S2SV> { //<S2SV> if ( lex_env -> inside_or ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , //<S2SV> "unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)" ) ; //<S2SV> YYABORT ; //<S2SV> } //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> ( yyval . re_node ) -> start = 0 ; //<S2SV> ( yyval . re_node ) -> end = INT_MAX ; //<S2SV> } //<S2SV> # line 1607 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 17 : //<S2SV> # line 356 "hex_grammar.y" //<S2SV> { //<S2SV> ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; //<S2SV> } //<S2SV> # line 1615 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 18 : //<S2SV> # line 360 "hex_grammar.y" //<S2SV> { //<S2SV> mark_as_not_fast_regexp ( ) ; //<S2SV> incr_ast_levels ( ) ; //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; //<S2SV> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> } //<S2SV> # line 1631 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 19 : //<S2SV> # line 375 "hex_grammar.y" //<S2SV> { //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; //<S2SV> } //<S2SV> # line 1643 "hex_grammar.c" //<S2SV> break ; //<S2SV> case 20 : //<S2SV> # line 383 "hex_grammar.y" //<S2SV> { //<S2SV> uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; //<S2SV> if ( mask == 0x00 ) //<S2SV> { //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; //<S2SV> ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; //<S2SV> ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; //<S2SV> ( yyval . re_node ) -> mask = mask ; //<S2SV> } //<S2SV> } //<S2SV> # line 1667 "hex_grammar.c" //<S2SV> break ; //<S2SV> # line 1671 "hex_grammar.c" //<S2SV> default : break ; //<S2SV> } //<S2SV> YY_SYMBOL_PRINT ( "-><S2SV_blank>$$<S2SV_blank>=" , yyr1 [ yyn ] , & yyval , & yyloc ) ; //<S2SV> YYPOPSTACK ( yylen ) ; //<S2SV> yylen = 0 ; //<S2SV> YY_STACK_PRINT ( yyss , yyssp ) ; //<S2SV> * ++ yyvsp = yyval ; //<S2SV> yyn = yyr1 [ yyn ] ; //<S2SV> yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; //<S2SV> if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) //<S2SV> yystate = yytable [ yystate ] ; //<S2SV> else //<S2SV> yystate = yydefgoto [ yyn - YYNTOKENS ] ; //<S2SV> goto yynewstate ; //<S2SV> yyerrlab : //<S2SV> yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; //<S2SV> if ( ! yyerrstatus ) //<S2SV> { //<S2SV> ++ yynerrs ; //<S2SV> # if ! YYERROR_VERBOSE //<S2SV> yyerror ( yyscanner , lex_env , YY_ ( "syntax<S2SV_blank>error" ) ) ; //<S2SV> # else //<S2SV> # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) //<S2SV> { //<S2SV> char const * yymsgp = YY_ ( "syntax<S2SV_blank>error" ) ; //<S2SV> int yysyntax_error_status ; //<S2SV> yysyntax_error_status = YYSYNTAX_ERROR ; //<S2SV> if ( yysyntax_error_status == 0 ) //<S2SV> yymsgp = yymsg ; //<S2SV> else if ( yysyntax_error_status == 1 ) //<S2SV> { //<S2SV> if ( yymsg != yymsgbuf ) //<S2SV> YYSTACK_FREE ( yymsg ) ; //<S2SV> yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; //<S2SV> if ( ! yymsg ) //<S2SV> { //<S2SV> yymsg = yymsgbuf ; //<S2SV> yymsg_alloc = sizeof yymsgbuf ; //<S2SV> yysyntax_error_status = 2 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> yysyntax_error_status = YYSYNTAX_ERROR ; //<S2SV> yymsgp = yymsg ; //<S2SV> } //<S2SV> } //<S2SV> yyerror ( yyscanner , lex_env , yymsgp ) ; //<S2SV> if ( yysyntax_error_status == 2 ) //<S2SV> goto yyexhaustedlab ; //<S2SV> } //<S2SV> # undef YYSYNTAX_ERROR //<S2SV> # endif //<S2SV> } //<S2SV> if ( yyerrstatus == 3 ) //<S2SV> { //<S2SV> if ( yychar <= YYEOF ) //<S2SV> { //<S2SV> if ( yychar == YYEOF ) //<S2SV> YYABORT ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> yydestruct ( "Error:<S2SV_blank>discarding" , //<S2SV> yytoken , & yylval , yyscanner , lex_env ) ; //<S2SV> yychar = YYEMPTY ; //<S2SV> } //<S2SV> } //<S2SV> goto yyerrlab1 ; //<S2SV> yyerrorlab : //<S2SV> if ( 0 ) //<S2SV> goto yyerrorlab ; //<S2SV> YYPOPSTACK ( yylen ) ; //<S2SV> yylen = 0 ; //<S2SV> YY_STACK_PRINT ( yyss , yyssp ) ; //<S2SV> yystate = * yyssp ; //<S2SV> goto yyerrlab1 ; //<S2SV> yyerrlab1 : //<S2SV> yyerrstatus = 3 ; //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> yyn = yypact [ yystate ] ; //<S2SV> if ( ! yypact_value_is_default ( yyn ) ) //<S2SV> { //<S2SV> yyn += YYTERROR ; //<S2SV> if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) //<S2SV> { //<S2SV> yyn = yytable [ yyn ] ; //<S2SV> if ( 0 < yyn ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( yyssp == yyss ) //<S2SV> YYABORT ; //<S2SV> yydestruct ( "Error:<S2SV_blank>popping" , //<S2SV> yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; //<S2SV> YYPOPSTACK ( 1 ) ; //<S2SV> yystate = * yyssp ; //<S2SV> YY_STACK_PRINT ( yyss , yyssp ) ; //<S2SV> } //<S2SV> YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN //<S2SV> * ++ yyvsp = yylval ; //<S2SV> YY_IGNORE_MAYBE_UNINITIALIZED_END //<S2SV> YY_SYMBOL_PRINT ( "Shifting" , yystos [ yyn ] , yyvsp , yylsp ) ; //<S2SV> yystate = yyn ; //<S2SV> goto yynewstate ; //<S2SV> yyacceptlab : //<S2SV> yyresult = 0 ; //<S2SV> goto yyreturn ; //<S2SV> yyabortlab : //<S2SV> yyresult = 1 ; //<S2SV> goto yyreturn ; //<S2SV> # if ! defined yyoverflow || YYERROR_VERBOSE //<S2SV> yyexhaustedlab : //<S2SV> yyerror ( yyscanner , lex_env , YY_ ( "memory<S2SV_blank>exhausted" ) ) ; //<S2SV> yyresult = 2 ; //<S2SV> # endif //<S2SV> yyreturn : //<S2SV> if ( yychar != YYEMPTY ) //<S2SV> { //<S2SV> yytoken = YYTRANSLATE ( yychar ) ; //<S2SV> yydestruct ( "Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead" , //<S2SV> yytoken , & yylval , yyscanner , lex_env ) ; //<S2SV> } //<S2SV> YYPOPSTACK ( yylen ) ; //<S2SV> YY_STACK_PRINT ( yyss , yyssp ) ; //<S2SV> while ( yyssp != yyss ) //<S2SV> { //<S2SV> yydestruct ( "Cleanup:<S2SV_blank>popping" , //<S2SV> yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; //<S2SV> YYPOPSTACK ( 1 ) ; //<S2SV> } //<S2SV> # ifndef yyoverflow //<S2SV> if ( yyss != yyssa ) //<S2SV> YYSTACK_FREE ( yyss ) ; //<S2SV> # endif //<S2SV> # if YYERROR_VERBOSE //<S2SV> if ( yymsg != yymsgbuf ) //<S2SV> YYSTACK_FREE ( yymsg ) ; //<S2SV> # endif //<S2SV> return yyresult ; //<S2SV> } //<S2SV> 