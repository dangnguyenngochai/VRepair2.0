int yr_execute_code ( //<S2SV> YR_RULES * rules , //<S2SV> YR_SCAN_CONTEXT * context , //<S2SV> int timeout , //<S2SV> time_t start_time ) //<S2SV> { //<S2SV> int64_t mem [ MEM_SIZE ] ; //<S2SV> int32_t sp = 0 ; //<S2SV> uint8_t * ip = rules -> code_start ; //<S2SV> YR_VALUE args [ MAX_FUNCTION_ARGS ] ; //<S2SV> YR_VALUE * stack ; //<S2SV> YR_VALUE r1 ; //<S2SV> YR_VALUE r2 ; //<S2SV> YR_VALUE r3 ; //<S2SV> # ifdef PROFILING_ENABLED //<S2SV> YR_RULE * current_rule = NULL ; //<S2SV> # endif //<S2SV> YR_RULE * rule ; //<S2SV> YR_MATCH * match ; //<S2SV> YR_OBJECT_FUNCTION * function ; //<S2SV> char * identifier ; //<S2SV> char * args_fmt ; //<S2SV> int i ; //<S2SV> int found ; //<S2SV> int count ; //<S2SV> int result = ERROR_SUCCESS ; //<S2SV> int stop = FALSE ; //<S2SV> int cycle = 0 ; //<S2SV> int tidx = context -> tidx ; //<S2SV> int stack_size ; //<S2SV> # ifdef PROFILING_ENABLED //<S2SV> clock_t start = clock ( ) ; //<S2SV> # endif //<S2SV> yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; //<S2SV> stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; //<S2SV> if ( stack == NULL ) //<S2SV> return ERROR_INSUFFICIENT_MEMORY ; //<S2SV> while ( ! stop ) //<S2SV> { //<S2SV> switch ( * ip ) //<S2SV> { //<S2SV> case OP_NOP : //<S2SV> break ; //<S2SV> case OP_HALT : //<S2SV> assert ( sp == 0 ) ; //<S2SV> stop = TRUE ; //<S2SV> break ; //<S2SV> case OP_PUSH : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_POP : //<S2SV> pop ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_CLEAR_M : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> mem [ r1 . i ] = 0 ; //<S2SV> break ; //<S2SV> case OP_ADD_M : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> pop ( r2 ) ; //<S2SV> if ( ! is_undef ( r2 ) ) //<S2SV> mem [ r1 . i ] += r2 . i ; //<S2SV> break ; //<S2SV> case OP_INCR_M : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> mem [ r1 . i ] ++ ; //<S2SV> break ; //<S2SV> case OP_PUSH_M : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> r1 . i = mem [ r1 . i ] ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_POP_M : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> pop ( r2 ) ; //<S2SV> mem [ r1 . i ] = r2 . i ; //<S2SV> break ; //<S2SV> case OP_SWAPUNDEF : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> pop ( r2 ) ; //<S2SV> if ( is_undef ( r2 ) ) //<S2SV> { //<S2SV> r1 . i = mem [ r1 . i ] ; //<S2SV> push ( r1 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> push ( r2 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case OP_JNUNDEF : //<S2SV> pop ( r1 ) ; //<S2SV> push ( r1 ) ; //<S2SV> ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; //<S2SV> break ; //<S2SV> case OP_JLE : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> push ( r1 ) ; //<S2SV> push ( r2 ) ; //<S2SV> ip = jmp_if ( r1 . i <= r2 . i , ip ) ; //<S2SV> break ; //<S2SV> case OP_JTRUE : //<S2SV> pop ( r1 ) ; //<S2SV> push ( r1 ) ; //<S2SV> ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; //<S2SV> break ; //<S2SV> case OP_JFALSE : //<S2SV> pop ( r1 ) ; //<S2SV> push ( r1 ) ; //<S2SV> ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; //<S2SV> break ; //<S2SV> case OP_AND : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> if ( is_undef ( r1 ) || is_undef ( r2 ) ) //<S2SV> r1 . i = 0 ; //<S2SV> else //<S2SV> r1 . i = r1 . i && r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_OR : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> if ( is_undef ( r1 ) ) //<S2SV> { //<S2SV> push ( r2 ) ; //<S2SV> } //<S2SV> else if ( is_undef ( r2 ) ) //<S2SV> { //<S2SV> push ( r1 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> r1 . i = r1 . i || r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case OP_NOT : //<S2SV> pop ( r1 ) ; //<S2SV> if ( is_undef ( r1 ) ) //<S2SV> r1 . i = UNDEFINED ; //<S2SV> else //<S2SV> r1 . i = ! r1 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_MOD : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> if ( r2 . i != 0 ) //<S2SV> r1 . i = r1 . i % r2 . i ; //<S2SV> else //<S2SV> r1 . i = UNDEFINED ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_SHR : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i >> r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_SHL : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i << r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_BITWISE_NOT : //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = ~ r1 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_BITWISE_AND : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i & r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_BITWISE_OR : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i | r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_BITWISE_XOR : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i ^ r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_PUSH_RULE : //<S2SV> rule = * ( YR_RULE * * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INIT_RULE : //<S2SV> # ifdef PROFILING_ENABLED //<S2SV> current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; //<S2SV> # endif //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> break ; //<S2SV> case OP_MATCH_RULE : //<S2SV> pop ( r1 ) ; //<S2SV> rule = * ( YR_RULE * * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> if ( ! is_undef ( r1 ) && r1 . i ) //<S2SV> rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; //<S2SV> else if ( RULE_IS_GLOBAL ( rule ) ) //<S2SV> rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; //<S2SV> # ifdef PROFILING_ENABLED //<S2SV> rule -> clock_ticks += clock ( ) - start ; //<S2SV> start = clock ( ) ; //<S2SV> # endif //<S2SV> break ; //<S2SV> case OP_OBJ_LOAD : //<S2SV> identifier = * ( char * * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( //<S2SV> context -> objects_table , //<S2SV> identifier , //<S2SV> NULL ) ; //<S2SV> assert ( r1 . o != NULL ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_OBJ_FIELD : //<S2SV> identifier = * ( char * * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; //<S2SV> assert ( r1 . o != NULL ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_OBJ_VALUE : //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> switch ( r1 . o -> type ) //<S2SV> { //<S2SV> case OBJECT_TYPE_INTEGER : //<S2SV> r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; //<S2SV> break ; //<S2SV> case OBJECT_TYPE_FLOAT : //<S2SV> if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) //<S2SV> r1 . i = UNDEFINED ; //<S2SV> else //<S2SV> r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; //<S2SV> break ; //<S2SV> case OBJECT_TYPE_STRING : //<S2SV> if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) //<S2SV> r1 . i = UNDEFINED ; //<S2SV> else //<S2SV> r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( FALSE ) ; //<S2SV> } //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INDEX_ARRAY : //<S2SV> pop ( r1 ) ; //<S2SV> pop ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; //<S2SV> r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; //<S2SV> if ( r1 . o == NULL ) //<S2SV> r1 . i = UNDEFINED ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_LOOKUP_DICT : //<S2SV> pop ( r1 ) ; //<S2SV> pop ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; //<S2SV> r1 . o = yr_object_dict_get_item ( //<S2SV> r2 . o , 0 , r1 . ss -> c_string ) ; //<S2SV> if ( r1 . o == NULL ) //<S2SV> r1 . i = UNDEFINED ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_CALL : //<S2SV> args_fmt = * ( char * * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> i = ( int ) strlen ( args_fmt ) ; //<S2SV> count = 0 ; //<S2SV> while ( i > 0 ) //<S2SV> { //<S2SV> pop ( r1 ) ; //<S2SV> if ( is_undef ( r1 ) ) //<S2SV> count ++ ; //<S2SV> args [ i - 1 ] = r1 ; //<S2SV> i -- ; //<S2SV> } //<S2SV> pop ( r2 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> if ( count > 0 ) //<S2SV> { //<S2SV> r1 . i = UNDEFINED ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> function = ( YR_OBJECT_FUNCTION * ) r2 . o ; //<S2SV> result = ERROR_INTERNAL_FATAL_ERROR ; //<S2SV> for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) //<S2SV> { //<S2SV> if ( function -> prototypes [ i ] . arguments_fmt == NULL ) //<S2SV> break ; //<S2SV> if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) //<S2SV> { //<S2SV> result = function -> prototypes [ i ] . code ( args , context , function ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; //<S2SV> if ( result == ERROR_SUCCESS ) //<S2SV> { //<S2SV> r1 . o = function -> return_obj ; //<S2SV> push ( r1 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> stop = TRUE ; //<S2SV> } //<S2SV> break ; //<S2SV> case OP_FOUND : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_FOUND_AT : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> if ( is_undef ( r1 ) ) //<S2SV> { //<S2SV> r1 . i = 0 ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> match = r2 . s -> matches [ tidx ] . head ; //<S2SV> r3 . i = FALSE ; //<S2SV> while ( match != NULL ) //<S2SV> { //<S2SV> if ( r1 . i == match -> base + match -> offset ) //<S2SV> { //<S2SV> r3 . i = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( r1 . i < match -> base + match -> offset ) //<S2SV> break ; //<S2SV> match = match -> next ; //<S2SV> } //<S2SV> push ( r3 ) ; //<S2SV> break ; //<S2SV> case OP_FOUND_IN : //<S2SV> pop ( r3 ) ; //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> match = r3 . s -> matches [ tidx ] . head ; //<S2SV> r3 . i = FALSE ; //<S2SV> while ( match != NULL && ! r3 . i ) //<S2SV> { //<S2SV> if ( match -> base + match -> offset >= r1 . i && //<S2SV> match -> base + match -> offset <= r2 . i ) //<S2SV> { //<S2SV> r3 . i = TRUE ; //<S2SV> } //<S2SV> if ( match -> base + match -> offset > r2 . i ) //<S2SV> break ; //<S2SV> match = match -> next ; //<S2SV> } //<S2SV> push ( r3 ) ; //<S2SV> break ; //<S2SV> case OP_COUNT : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = r1 . s -> matches [ tidx ] . count ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_OFFSET : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> match = r2 . s -> matches [ tidx ] . head ; //<S2SV> i = 1 ; //<S2SV> r3 . i = UNDEFINED ; //<S2SV> while ( match != NULL && r3 . i == UNDEFINED ) //<S2SV> { //<S2SV> if ( r1 . i == i ) //<S2SV> r3 . i = match -> base + match -> offset ; //<S2SV> i ++ ; //<S2SV> match = match -> next ; //<S2SV> } //<S2SV> push ( r3 ) ; //<S2SV> break ; //<S2SV> case OP_LENGTH : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> match = r2 . s -> matches [ tidx ] . head ; //<S2SV> i = 1 ; //<S2SV> r3 . i = UNDEFINED ; //<S2SV> while ( match != NULL && r3 . i == UNDEFINED ) //<S2SV> { //<S2SV> if ( r1 . i == i ) //<S2SV> r3 . i = match -> match_length ; //<S2SV> i ++ ; //<S2SV> match = match -> next ; //<S2SV> } //<S2SV> push ( r3 ) ; //<S2SV> break ; //<S2SV> case OP_OF : //<S2SV> found = 0 ; //<S2SV> count = 0 ; //<S2SV> pop ( r1 ) ; //<S2SV> while ( ! is_undef ( r1 ) ) //<S2SV> { //<S2SV> if ( r1 . s -> matches [ tidx ] . tail != NULL ) //<S2SV> found ++ ; //<S2SV> count ++ ; //<S2SV> pop ( r1 ) ; //<S2SV> } //<S2SV> pop ( r2 ) ; //<S2SV> if ( is_undef ( r2 ) ) //<S2SV> r1 . i = found >= count ? 1 : 0 ; //<S2SV> else //<S2SV> r1 . i = found >= r2 . i ? 1 : 0 ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_FILESIZE : //<S2SV> r1 . i = context -> file_size ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_ENTRYPOINT : //<S2SV> r1 . i = context -> entry_point ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT8 : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT16 : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT32 : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_UINT8 : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_UINT16 : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_UINT32 : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT8BE : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT16BE : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT32BE : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_UINT8BE : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_UINT16BE : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_UINT32BE : //<S2SV> pop ( r1 ) ; //<S2SV> r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_CONTAINS : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , //<S2SV> r2 . ss -> c_string , r2 . ss -> length ) != NULL ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_IMPORT : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> result = yr_modules_load ( ( char * ) r1 . p , context ) ; //<S2SV> if ( result != ERROR_SUCCESS ) //<S2SV> stop = TRUE ; //<S2SV> break ; //<S2SV> case OP_MATCHES : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> if ( r1 . ss -> length == 0 ) //<S2SV> { //<S2SV> r1 . i = FALSE ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> result = yr_re_exec ( //<S2SV> ( uint8_t * ) r2 . re -> code , //<S2SV> ( uint8_t * ) r1 . ss -> c_string , //<S2SV> r1 . ss -> length , //<S2SV> 0 , //<S2SV> r2 . re -> flags | RE_FLAGS_SCAN , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> & found ) ; //<S2SV> if ( result != ERROR_SUCCESS ) //<S2SV> stop = TRUE ; //<S2SV> r1 . i = found >= 0 ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_TO_DBL : //<S2SV> r1 . i = * ( uint64_t * ) ( ip + 1 ) ; //<S2SV> ip += sizeof ( uint64_t ) ; //<S2SV> r2 = stack [ sp - r1 . i ] ; //<S2SV> if ( is_undef ( r2 ) ) //<S2SV> stack [ sp - r1 . i ] . i = UNDEFINED ; //<S2SV> else //<S2SV> stack [ sp - r1 . i ] . d = ( double ) r2 . i ; //<S2SV> break ; //<S2SV> case OP_STR_TO_BOOL : //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . ss -> length > 0 ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_EQ : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i == r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_NEQ : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i != r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_LT : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i < r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_GT : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i > r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_LE : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i <= r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_GE : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i >= r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_ADD : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i + r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_SUB : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i - r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_MUL : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . i * r2 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_DIV : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> if ( r2 . i != 0 ) //<S2SV> r1 . i = r1 . i / r2 . i ; //<S2SV> else //<S2SV> r1 . i = UNDEFINED ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_INT_MINUS : //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = - r1 . i ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_LT : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . d < r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_GT : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . d > r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_LE : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . d <= r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_GE : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . d >= r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_EQ : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . d == r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_NEQ : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . i = r1 . d != r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_ADD : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . d = r1 . d + r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_SUB : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . d = r1 . d - r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_MUL : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . d = r1 . d * r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_DIV : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . d = r1 . d / r2 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_DBL_MINUS : //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> r1 . d = - r1 . d ; //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> case OP_STR_EQ : //<S2SV> case OP_STR_NEQ : //<S2SV> case OP_STR_LT : //<S2SV> case OP_STR_LE : //<S2SV> case OP_STR_GT : //<S2SV> case OP_STR_GE : //<S2SV> pop ( r2 ) ; //<S2SV> pop ( r1 ) ; //<S2SV> ensure_defined ( r1 ) ; //<S2SV> ensure_defined ( r2 ) ; //<S2SV> switch ( * ip ) //<S2SV> { //<S2SV> case OP_STR_EQ : //<S2SV> r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; //<S2SV> break ; //<S2SV> case OP_STR_NEQ : //<S2SV> r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; //<S2SV> break ; //<S2SV> case OP_STR_LT : //<S2SV> r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; //<S2SV> break ; //<S2SV> case OP_STR_LE : //<S2SV> r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; //<S2SV> break ; //<S2SV> case OP_STR_GT : //<S2SV> r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; //<S2SV> break ; //<S2SV> case OP_STR_GE : //<S2SV> r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> push ( r1 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( FALSE ) ; //<S2SV> } //<S2SV> if ( timeout > 0 ) //<S2SV> { //<S2SV> if ( ++ cycle == 10 ) //<S2SV> { //<S2SV> if ( difftime ( time ( NULL ) , start_time ) > timeout ) //<S2SV> { //<S2SV> # ifdef PROFILING_ENABLED //<S2SV> assert ( current_rule != NULL ) ; //<S2SV> current_rule -> clock_ticks += clock ( ) - start ; //<S2SV> # endif //<S2SV> result = ERROR_SCAN_TIMEOUT ; //<S2SV> stop = TRUE ; //<S2SV> } //<S2SV> cycle = 0 ; //<S2SV> } //<S2SV> } //<S2SV> ip ++ ; //<S2SV> } //<S2SV> yr_modules_unload_all ( context ) ; //<S2SV> yr_free ( stack ) ; //<S2SV> return result ; //<S2SV> } //<S2SV> 