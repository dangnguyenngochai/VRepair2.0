int _yr_scan_verify_re_match ( //<S2SV> YR_SCAN_CONTEXT * context , //<S2SV> YR_AC_MATCH * ac_match , //<S2SV> uint8_t * data , //<S2SV> size_t data_size , //<S2SV> size_t data_base , //<S2SV> size_t offset ) //<S2SV> { //<S2SV> CALLBACK_ARGS callback_args ; //<S2SV> RE_EXEC_FUNC exec ; //<S2SV> int forward_matches = - 1 ; //<S2SV> int backward_matches = - 1 ; //<S2SV> int flags = 0 ; //<S2SV> if ( STRING_IS_GREEDY_REGEXP ( ac_match -> string ) ) //<S2SV> flags |= RE_FLAGS_GREEDY ; //<S2SV> if ( STRING_IS_NO_CASE ( ac_match -> string ) ) //<S2SV> flags |= RE_FLAGS_NO_CASE ; //<S2SV> if ( STRING_IS_DOT_ALL ( ac_match -> string ) ) //<S2SV> flags |= RE_FLAGS_DOT_ALL ; //<S2SV> if ( STRING_IS_FAST_REGEXP ( ac_match -> string ) ) //<S2SV> exec = yr_re_fast_exec ; //<S2SV> else //<S2SV> exec = yr_re_exec ; //<S2SV> if ( STRING_IS_ASCII ( ac_match -> string ) ) //<S2SV> { //<S2SV> forward_matches = exec ( //<S2SV> ac_match -> forward_code , //<S2SV> data + offset , //<S2SV> data_size - offset , //<S2SV> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , //<S2SV> NULL , //<S2SV> NULL ) ; //<S2SV> } //<S2SV> if ( STRING_IS_WIDE ( ac_match -> string ) && forward_matches == - 1 ) //<S2SV> { //<S2SV> flags |= RE_FLAGS_WIDE ; //<S2SV> forward_matches = exec ( //<S2SV> ac_match -> forward_code , //<S2SV> data + offset , //<S2SV> data_size - offset , //<S2SV> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , //<S2SV> NULL , //<S2SV> NULL ) ; //<S2SV> } //<S2SV> switch ( forward_matches ) //<S2SV> { //<S2SV> case - 1 : //<S2SV> return ERROR_SUCCESS ; //<S2SV> case - 2 : //<S2SV> return ERROR_INSUFFICIENT_MEMORY ; //<S2SV> case - 3 : //<S2SV> return ERROR_TOO_MANY_MATCHES ; //<S2SV> case - 4 : //<S2SV> return ERROR_TOO_MANY_RE_FIBERS ; //<S2SV> case - 5 : //<S2SV> return ERROR_INTERNAL_FATAL_ERROR ; //<S2SV> } //<S2SV> if ( forward_matches == 0 && ac_match -> backward_code == NULL ) //<S2SV> return ERROR_SUCCESS ; //<S2SV> callback_args . string = ac_match -> string ; //<S2SV> callback_args . context = context ; //<S2SV> callback_args . data = data ; //<S2SV> callback_args . data_size = data_size ; //<S2SV> callback_args . data_base = data_base ; //<S2SV> callback_args . forward_matches = forward_matches ; //<S2SV> callback_args . full_word = STRING_IS_FULL_WORD ( ac_match -> string ) ; //<S2SV> if ( ac_match -> backward_code != NULL ) //<S2SV> { //<S2SV> backward_matches = exec ( //<S2SV> ac_match -> backward_code , //<S2SV> data + offset , //<S2SV> offset , //<S2SV> flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , //<S2SV> _yr_scan_match_callback , //<S2SV> ( void * ) & callback_args ) ; //<S2SV> switch ( backward_matches ) //<S2SV> { //<S2SV> case - 2 : //<S2SV> return ERROR_INSUFFICIENT_MEMORY ; //<S2SV> case - 3 : //<S2SV> return ERROR_TOO_MANY_MATCHES ; //<S2SV> case - 4 : //<S2SV> return ERROR_TOO_MANY_RE_FIBERS ; //<S2SV> case - 5 : //<S2SV> return ERROR_INTERNAL_FATAL_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> FAIL_ON_ERROR ( _yr_scan_match_callback ( //<S2SV> data + offset , 0 , flags , & callback_args ) ) ; //<S2SV> } //<S2SV> return ERROR_SUCCESS ; //<S2SV> } //<S2SV> 