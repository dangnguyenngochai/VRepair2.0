int yr_re_exec ( //<S2SV> uint8_t * re_code , //<S2SV> uint8_t * input_data , //<S2SV> size_t input_size , //<S2SV> int flags , //<S2SV> RE_MATCH_CALLBACK_FUNC callback , //<S2SV> void * callback_args ) //<S2SV> { //<S2SV> uint8_t * ip ; //<S2SV> uint8_t * input ; //<S2SV> uint8_t mask ; //<S2SV> uint8_t value ; //<S2SV> RE_FIBER_LIST fibers ; //<S2SV> RE_THREAD_STORAGE * storage ; //<S2SV> RE_FIBER * fiber ; //<S2SV> RE_FIBER * next_fiber ; //<S2SV> int error ; //<S2SV> int bytes_matched ; //<S2SV> int max_bytes_matched ; //<S2SV> int match ; //<S2SV> int character_size ; //<S2SV> int input_incr ; //<S2SV> int kill ; //<S2SV> int action ; //<S2SV> int result = - 1 ; //<S2SV> # define ACTION_NONE 0 //<S2SV> # define ACTION_CONTINUE 1 //<S2SV> # define ACTION_KILL 2 //<S2SV> # define ACTION_KILL_TAIL 3 //<S2SV> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } //<S2SV> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } //<S2SV> if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) //<S2SV> return - 2 ; //<S2SV> if ( flags & RE_FLAGS_WIDE ) //<S2SV> character_size = 2 ; //<S2SV> else //<S2SV> character_size = 1 ; //<S2SV> input = input_data ; //<S2SV> input_incr = character_size ; //<S2SV> if ( flags & RE_FLAGS_BACKWARDS ) //<S2SV> { //<S2SV> input -= character_size ; //<S2SV> input_incr = - input_incr ; //<S2SV> } //<S2SV> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; //<S2SV> max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ; //<S2SV> bytes_matched = 0 ; //<S2SV> error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; //<S2SV> fail_if_error ( error ) ; //<S2SV> fiber -> ip = re_code ; //<S2SV> fibers . head = fiber ; //<S2SV> fibers . tail = fiber ; //<S2SV> error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; //<S2SV> fail_if_error ( error ) ; //<S2SV> while ( fibers . head != NULL ) //<S2SV> { //<S2SV> fiber = fibers . head ; //<S2SV> while ( fiber != NULL ) //<S2SV> { //<S2SV> ip = fiber -> ip ; //<S2SV> action = ACTION_NONE ; //<S2SV> switch ( * ip ) //<S2SV> { //<S2SV> case RE_OPCODE_ANY : //<S2SV> prolog ; //<S2SV> match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_REPEAT_ANY_GREEDY : //<S2SV> case RE_OPCODE_REPEAT_ANY_UNGREEDY : //<S2SV> prolog ; //<S2SV> match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> break ; //<S2SV> case RE_OPCODE_LITERAL : //<S2SV> prolog ; //<S2SV> if ( flags & RE_FLAGS_NO_CASE ) //<S2SV> match = yr_lowercase [ * input ] == yr_lowercase [ * ( ip + 1 ) ] ; //<S2SV> else //<S2SV> match = ( * input == * ( ip + 1 ) ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 2 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_MASKED_LITERAL : //<S2SV> prolog ; //<S2SV> value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; //<S2SV> mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; //<S2SV> match = ( ( * input & mask ) == value ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 3 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_CLASS : //<S2SV> prolog ; //<S2SV> match = CHAR_IN_CLASS ( * input , ip + 1 ) ; //<S2SV> if ( ! match && ( flags & RE_FLAGS_NO_CASE ) ) //<S2SV> match = CHAR_IN_CLASS ( yr_altercase [ * input ] , ip + 1 ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 33 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_WORD_CHAR : //<S2SV> prolog ; //<S2SV> match = IS_WORD_CHAR ( * input ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_NON_WORD_CHAR : //<S2SV> prolog ; //<S2SV> match = ! IS_WORD_CHAR ( * input ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_SPACE : //<S2SV> case RE_OPCODE_NON_SPACE : //<S2SV> prolog ; //<S2SV> switch ( * input ) //<S2SV> { //<S2SV> case '<S2SV_blank>' : //<S2SV> case '\\t' : //<S2SV> case '\\r' : //<S2SV> case '\\n' : //<S2SV> case '\\v' : //<S2SV> case '\\f' : //<S2SV> match = TRUE ; //<S2SV> break ; //<S2SV> default : //<S2SV> match = FALSE ; //<S2SV> } //<S2SV> if ( * ip == RE_OPCODE_NON_SPACE ) //<S2SV> match = ! match ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_DIGIT : //<S2SV> prolog ; //<S2SV> match = isdigit ( * input ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_NON_DIGIT : //<S2SV> prolog ; //<S2SV> match = ! isdigit ( * input ) ; //<S2SV> action = match ? ACTION_NONE : ACTION_KILL ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_WORD_BOUNDARY : //<S2SV> case RE_OPCODE_NON_WORD_BOUNDARY : //<S2SV> if ( bytes_matched == 0 && //<S2SV> ! ( flags & RE_FLAGS_NOT_AT_START ) && //<S2SV> ! ( flags & RE_FLAGS_BACKWARDS ) ) //<S2SV> match = TRUE ; //<S2SV> else if ( bytes_matched >= max_bytes_matched ) //<S2SV> match = TRUE ; //<S2SV> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) //<S2SV> match = TRUE ; //<S2SV> else //<S2SV> match = FALSE ; //<S2SV> if ( * ip == RE_OPCODE_NON_WORD_BOUNDARY ) //<S2SV> match = ! match ; //<S2SV> action = match ? ACTION_CONTINUE : ACTION_KILL ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_MATCH_AT_START : //<S2SV> if ( flags & RE_FLAGS_BACKWARDS ) //<S2SV> kill = input_size > ( size_t ) bytes_matched ; //<S2SV> else //<S2SV> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; //<S2SV> action = kill ? ACTION_KILL : ACTION_CONTINUE ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_MATCH_AT_END : //<S2SV> kill = flags & RE_FLAGS_BACKWARDS || //<S2SV> input_size > ( size_t ) bytes_matched ; //<S2SV> action = kill ? ACTION_KILL : ACTION_CONTINUE ; //<S2SV> fiber -> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_MATCH : //<S2SV> result = bytes_matched ; //<S2SV> if ( flags & RE_FLAGS_EXHAUSTIVE ) //<S2SV> { //<S2SV> if ( callback != NULL ) //<S2SV> { //<S2SV> int cb_result ; //<S2SV> if ( flags & RE_FLAGS_BACKWARDS ) //<S2SV> cb_result = callback ( //<S2SV> input + character_size , //<S2SV> bytes_matched , //<S2SV> flags , //<S2SV> callback_args ) ; //<S2SV> else //<S2SV> cb_result = callback ( //<S2SV> input_data , //<S2SV> bytes_matched , //<S2SV> flags , //<S2SV> callback_args ) ; //<S2SV> switch ( cb_result ) //<S2SV> { //<S2SV> case ERROR_INSUFFICIENT_MEMORY : //<S2SV> return - 2 ; //<S2SV> case ERROR_TOO_MANY_MATCHES : //<S2SV> return - 3 ; //<S2SV> default : //<S2SV> if ( cb_result != ERROR_SUCCESS ) //<S2SV> return - 4 ; //<S2SV> } //<S2SV> } //<S2SV> action = ACTION_KILL ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> action = ACTION_KILL_TAIL ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( FALSE ) ; //<S2SV> } //<S2SV> switch ( action ) //<S2SV> { //<S2SV> case ACTION_KILL : //<S2SV> fiber = _yr_re_fiber_kill ( & fibers , & storage -> fiber_pool , fiber ) ; //<S2SV> break ; //<S2SV> case ACTION_KILL_TAIL : //<S2SV> _yr_re_fiber_kill_tail ( & fibers , & storage -> fiber_pool , fiber ) ; //<S2SV> fiber = NULL ; //<S2SV> break ; //<S2SV> case ACTION_CONTINUE : //<S2SV> error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; //<S2SV> fail_if_error ( error ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> next_fiber = fiber -> next ; //<S2SV> error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; //<S2SV> fail_if_error ( error ) ; //<S2SV> fiber = next_fiber ; //<S2SV> } //<S2SV> } //<S2SV> if ( flags & RE_FLAGS_WIDE && //<S2SV> bytes_matched < max_bytes_matched && //<S2SV> * ( input + 1 ) != 0 ) //<S2SV> { //<S2SV> _yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ; //<S2SV> } //<S2SV> input += input_incr ; //<S2SV> bytes_matched += character_size ; //<S2SV> if ( flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched ) //<S2SV> { //<S2SV> error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; //<S2SV> fail_if_error ( error ) ; //<S2SV> fiber -> ip = re_code ; //<S2SV> _yr_re_fiber_append ( & fibers , fiber ) ; //<S2SV> error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; //<S2SV> fail_if_error ( error ) ; //<S2SV> } //<S2SV> } //<S2SV> return result ; //<S2SV> } //<S2SV> 