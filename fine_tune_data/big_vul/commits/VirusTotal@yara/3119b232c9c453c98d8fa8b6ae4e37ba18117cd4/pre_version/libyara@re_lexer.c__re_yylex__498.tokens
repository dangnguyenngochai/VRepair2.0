YY_DECL //<S2SV> { //<S2SV> yy_state_type yy_current_state ; //<S2SV> char * yy_cp , * yy_bp ; //<S2SV> int yy_act ; //<S2SV> struct yyguts_t * yyg = ( struct yyguts_t * ) yyscanner ; //<S2SV> yylval = yylval_param ; //<S2SV> if ( ! yyg -> yy_init ) //<S2SV> { //<S2SV> yyg -> yy_init = 1 ; //<S2SV> # ifdef YY_USER_INIT //<S2SV> YY_USER_INIT ; //<S2SV> # endif //<S2SV> if ( ! yyg -> yy_start ) //<S2SV> yyg -> yy_start = 1 ; //<S2SV> if ( ! yyin ) //<S2SV> yyin = stdin ; //<S2SV> if ( ! yyout ) //<S2SV> yyout = stdout ; //<S2SV> if ( ! YY_CURRENT_BUFFER ) { //<S2SV> re_yyensure_buffer_stack ( yyscanner ) ; //<S2SV> YY_CURRENT_BUFFER_LVALUE = //<S2SV> re_yy_create_buffer ( yyin , YY_BUF_SIZE , yyscanner ) ; //<S2SV> } //<S2SV> re_yy_load_buffer_state ( yyscanner ) ; //<S2SV> } //<S2SV> { //<S2SV> # line 99 "re_lexer.l" //<S2SV> # line 863 "re_lexer.c" //<S2SV> while ( 1 ) //<S2SV> { //<S2SV> yy_cp = yyg -> yy_c_buf_p ; //<S2SV> * yy_cp = yyg -> yy_hold_char ; //<S2SV> yy_bp = yy_cp ; //<S2SV> yy_current_state = yyg -> yy_start ; //<S2SV> yy_match : //<S2SV> do //<S2SV> { //<S2SV> YY_CHAR yy_c = yy_ec [ YY_SC_TO_UI ( * yy_cp ) ] ; //<S2SV> if ( yy_accept [ yy_current_state ] ) //<S2SV> { //<S2SV> yyg -> yy_last_accepting_state = yy_current_state ; //<S2SV> yyg -> yy_last_accepting_cpos = yy_cp ; //<S2SV> } //<S2SV> while ( yy_chk [ yy_base [ yy_current_state ] + yy_c ] != yy_current_state ) //<S2SV> { //<S2SV> yy_current_state = ( int ) yy_def [ yy_current_state ] ; //<S2SV> if ( yy_current_state >= 45 ) //<S2SV> yy_c = yy_meta [ ( unsigned int ) yy_c ] ; //<S2SV> } //<S2SV> yy_current_state = yy_nxt [ yy_base [ yy_current_state ] + ( unsigned int ) yy_c ] ; //<S2SV> ++ yy_cp ; //<S2SV> } //<S2SV> while ( yy_current_state != 44 ) ; //<S2SV> yy_cp = yyg -> yy_last_accepting_cpos ; //<S2SV> yy_current_state = yyg -> yy_last_accepting_state ; //<S2SV> yy_find_action : //<S2SV> yy_act = yy_accept [ yy_current_state ] ; //<S2SV> YY_DO_BEFORE_ACTION ; //<S2SV> if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol [ yy_act ] ) //<S2SV> { //<S2SV> yy_size_t yyl ; //<S2SV> for ( yyl = 0 ; yyl < yyleng ; ++ yyl ) //<S2SV> if ( yytext [ yyl ] == '\\n' ) //<S2SV> do { yylineno ++ ; //<S2SV> yycolumn = 0 ; //<S2SV> } while ( 0 ) //<S2SV> ; //<S2SV> } //<S2SV> do_action : //<S2SV> switch ( yy_act ) //<S2SV> { //<S2SV> case 0 : //<S2SV> * yy_cp = yyg -> yy_hold_char ; //<S2SV> yy_cp = yyg -> yy_last_accepting_cpos ; //<S2SV> yy_current_state = yyg -> yy_last_accepting_state ; //<S2SV> goto yy_find_action ; //<S2SV> case 1 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 101 "re_lexer.l" //<S2SV> { //<S2SV> int hi_bound ; //<S2SV> int lo_bound = atoi ( yytext + 1 ) ; //<S2SV> char * comma = strchr ( yytext , ',' ) ; //<S2SV> if ( comma - yytext == strlen ( yytext ) - 2 ) //<S2SV> hi_bound = INT16_MAX ; //<S2SV> else //<S2SV> hi_bound = atoi ( comma + 1 ) ; //<S2SV> if ( hi_bound > INT16_MAX ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> if ( hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0 ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "bad<S2SV_blank>repeat<S2SV_blank>interval" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> yylval -> range = ( hi_bound << 16 ) | lo_bound ; //<S2SV> return _RANGE_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 2 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 135 "re_lexer.l" //<S2SV> { //<S2SV> int value = atoi ( yytext + 1 ) ; //<S2SV> if ( value > INT16_MAX ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> yylval -> range = ( value << 16 ) | value ; //<S2SV> return _RANGE_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 3 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 153 "re_lexer.l" //<S2SV> { //<S2SV> BEGIN ( char_class ) ; //<S2SV> memset ( LEX_ENV -> class_vector , 0 , 32 ) ; //<S2SV> LEX_ENV -> negated_class = TRUE ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 4 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 162 "re_lexer.l" //<S2SV> { //<S2SV> BEGIN ( char_class ) ; //<S2SV> memset ( LEX_ENV -> class_vector , 0 , 32 ) ; //<S2SV> LEX_ENV -> negated_class = TRUE ; //<S2SV> LEX_ENV -> class_vector [ ']' / 8 ] |= 1 << ']' % 8 ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 5 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 175 "re_lexer.l" //<S2SV> { //<S2SV> BEGIN ( char_class ) ; //<S2SV> memset ( LEX_ENV -> class_vector , 0 , 32 ) ; //<S2SV> LEX_ENV -> negated_class = FALSE ; //<S2SV> LEX_ENV -> class_vector [ ']' / 8 ] |= 1 << ']' % 8 ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 6 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 188 "re_lexer.l" //<S2SV> { //<S2SV> BEGIN ( char_class ) ; //<S2SV> memset ( LEX_ENV -> class_vector , 0 , 32 ) ; //<S2SV> LEX_ENV -> negated_class = FALSE ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 7 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 198 "re_lexer.l" //<S2SV> { //<S2SV> yylval -> integer = yytext [ 0 ] ; //<S2SV> return _CHAR_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 8 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 207 "re_lexer.l" //<S2SV> { //<S2SV> return _WORD_CHAR_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 9 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 212 "re_lexer.l" //<S2SV> { //<S2SV> return _NON_WORD_CHAR_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 10 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 217 "re_lexer.l" //<S2SV> { //<S2SV> return _SPACE_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 11 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 222 "re_lexer.l" //<S2SV> { //<S2SV> return _NON_SPACE_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 12 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 227 "re_lexer.l" //<S2SV> { //<S2SV> return _DIGIT_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 13 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 232 "re_lexer.l" //<S2SV> { //<S2SV> return _NON_DIGIT_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 14 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 237 "re_lexer.l" //<S2SV> { //<S2SV> return _WORD_BOUNDARY_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 15 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 241 "re_lexer.l" //<S2SV> { //<S2SV> return _NON_WORD_BOUNDARY_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 16 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 246 "re_lexer.l" //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "backreferences<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 17 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 253 "re_lexer.l" //<S2SV> { //<S2SV> uint8_t c ; //<S2SV> if ( read_escaped_char ( yyscanner , & c ) ) //<S2SV> { //<S2SV> yylval -> integer = c ; //<S2SV> return _CHAR_ ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 18 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 270 "re_lexer.l" //<S2SV> { //<S2SV> int i ; //<S2SV> yylval -> class_vector = ( uint8_t * ) yr_malloc ( 32 ) ; //<S2SV> memcpy ( yylval -> class_vector , LEX_ENV -> class_vector , 32 ) ; //<S2SV> if ( LEX_ENV -> negated_class ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 32 ; i ++ ) //<S2SV> yylval -> class_vector [ i ] = ~ yylval -> class_vector [ i ] ; //<S2SV> } //<S2SV> BEGIN ( INITIAL ) ; //<S2SV> return _CLASS_ ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 19 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 291 "re_lexer.l" //<S2SV> { //<S2SV> uint16_t c ; //<S2SV> uint8_t start = yytext [ 0 ] ; //<S2SV> uint8_t end = yytext [ 2 ] ; //<S2SV> if ( start == '\\\\' ) //<S2SV> { //<S2SV> start = escaped_char_value ( yytext ) ; //<S2SV> if ( yytext [ 1 ] == 'x' ) //<S2SV> end = yytext [ 5 ] ; //<S2SV> else //<S2SV> end = yytext [ 3 ] ; //<S2SV> } //<S2SV> if ( end == '\\\\' ) //<S2SV> { //<S2SV> if ( ! read_escaped_char ( yyscanner , & end ) ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( end < start ) //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "bad<S2SV_blank>character<S2SV_blank>range" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> for ( c = start ; c <= end ; c ++ ) //<S2SV> { //<S2SV> LEX_ENV -> class_vector [ c / 8 ] |= 1 << c % 8 ; //<S2SV> } //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 20 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 333 "re_lexer.l" //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < 32 ; i ++ ) //<S2SV> LEX_ENV -> class_vector [ i ] |= word_chars [ i ] ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 21 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 342 "re_lexer.l" //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < 32 ; i ++ ) //<S2SV> LEX_ENV -> class_vector [ i ] |= ~ word_chars [ i ] ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 22 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 351 "re_lexer.l" //<S2SV> { //<S2SV> LEX_ENV -> class_vector [ '<S2SV_blank>' / 8 ] |= 1 << '<S2SV_blank>' % 8 ; //<S2SV> LEX_ENV -> class_vector [ '\\t' / 8 ] |= 1 << '\\t' % 8 ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 23 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 358 "re_lexer.l" //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < 32 ; i ++ ) //<S2SV> { //<S2SV> if ( i == '<S2SV_blank>' / 8 ) //<S2SV> LEX_ENV -> class_vector [ i ] |= ~ ( 1 << '<S2SV_blank>' % 8 ) ; //<S2SV> else if ( i == '\\t' / 8 ) //<S2SV> LEX_ENV -> class_vector [ i ] |= ~ ( 1 << '\\t' % 8 ) ; //<S2SV> else //<S2SV> LEX_ENV -> class_vector [ i ] = 0xFF ; //<S2SV> } //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 24 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 374 "re_lexer.l" //<S2SV> { //<S2SV> char c ; //<S2SV> for ( c = '0' ; c <= '9' ; c ++ ) //<S2SV> LEX_ENV -> class_vector [ c / 8 ] |= 1 << c % 8 ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 25 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 383 "re_lexer.l" //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < 32 ; i ++ ) //<S2SV> { //<S2SV> if ( i == 6 ) //<S2SV> continue ; //<S2SV> if ( i == 7 ) //<S2SV> LEX_ENV -> class_vector [ i ] |= 0xFC ; //<S2SV> else //<S2SV> LEX_ENV -> class_vector [ i ] = 0xFF ; //<S2SV> } //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 26 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 403 "re_lexer.l" //<S2SV> { //<S2SV> uint8_t c ; //<S2SV> if ( read_escaped_char ( yyscanner , & c ) ) //<S2SV> { //<S2SV> LEX_ENV -> class_vector [ c / 8 ] |= 1 << c % 8 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 27 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 419 "re_lexer.l" //<S2SV> { //<S2SV> if ( yytext [ 0 ] >= 32 && yytext [ 0 ] < 127 ) //<S2SV> { //<S2SV> LEX_ENV -> class_vector [ yytext [ 0 ] / 8 ] |= 1 << yytext [ 0 ] % 8 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "non-ascii<S2SV_blank>character" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case YY_STATE_EOF ( char_class ) : //<S2SV> # line 436 "re_lexer.l" //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "missing<S2SV_blank>terminating<S2SV_blank>]<S2SV_blank>for<S2SV_blank>character<S2SV_blank>class" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 28 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 445 "re_lexer.l" //<S2SV> { //<S2SV> if ( yytext [ 0 ] >= 32 && yytext [ 0 ] < 127 ) //<S2SV> { //<S2SV> return yytext [ 0 ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> yyerror ( yyscanner , lex_env , "non-ascii<S2SV_blank>character" ) ; //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case YY_STATE_EOF ( INITIAL ) : //<S2SV> # line 459 "re_lexer.l" //<S2SV> { //<S2SV> yyterminate ( ) ; //<S2SV> } //<S2SV> YY_BREAK //<S2SV> case 29 : //<S2SV> YY_RULE_SETUP //<S2SV> # line 464 "re_lexer.l" //<S2SV> ECHO ; //<S2SV> YY_BREAK //<S2SV> # line 1358 "re_lexer.c" //<S2SV> case YY_END_OF_BUFFER : //<S2SV> { //<S2SV> int yy_amount_of_matched_text = ( int ) ( yy_cp - yyg -> yytext_ptr ) - 1 ; //<S2SV> * yy_cp = yyg -> yy_hold_char ; //<S2SV> YY_RESTORE_YY_MORE_OFFSET //<S2SV> if ( YY_CURRENT_BUFFER_LVALUE -> yy_buffer_status == YY_BUFFER_NEW ) //<S2SV> { //<S2SV> yyg -> yy_n_chars = YY_CURRENT_BUFFER_LVALUE -> yy_n_chars ; //<S2SV> YY_CURRENT_BUFFER_LVALUE -> yy_input_file = yyin ; //<S2SV> YY_CURRENT_BUFFER_LVALUE -> yy_buffer_status = YY_BUFFER_NORMAL ; //<S2SV> } //<S2SV> if ( yyg -> yy_c_buf_p <= & YY_CURRENT_BUFFER_LVALUE -> yy_ch_buf [ yyg -> yy_n_chars ] ) //<S2SV> { //<S2SV> yy_state_type yy_next_state ; //<S2SV> yyg -> yy_c_buf_p = yyg -> yytext_ptr + yy_amount_of_matched_text ; //<S2SV> yy_current_state = yy_get_previous_state ( yyscanner ) ; //<S2SV> yy_next_state = yy_try_NUL_trans ( yy_current_state , yyscanner ) ; //<S2SV> yy_bp = yyg -> yytext_ptr + YY_MORE_ADJ ; //<S2SV> if ( yy_next_state ) //<S2SV> { //<S2SV> yy_cp = ++ yyg -> yy_c_buf_p ; //<S2SV> yy_current_state = yy_next_state ; //<S2SV> goto yy_match ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> yy_cp = yyg -> yy_last_accepting_cpos ; //<S2SV> yy_current_state = yyg -> yy_last_accepting_state ; //<S2SV> goto yy_find_action ; //<S2SV> } //<S2SV> } //<S2SV> else switch ( yy_get_next_buffer ( yyscanner ) ) //<S2SV> { //<S2SV> case EOB_ACT_END_OF_FILE : //<S2SV> { //<S2SV> yyg -> yy_did_buffer_switch_on_eof = 0 ; //<S2SV> if ( re_yywrap ( yyscanner ) ) //<S2SV> { //<S2SV> yyg -> yy_c_buf_p = yyg -> yytext_ptr + YY_MORE_ADJ ; //<S2SV> yy_act = YY_STATE_EOF ( YY_START ) ; //<S2SV> goto do_action ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ! yyg -> yy_did_buffer_switch_on_eof ) //<S2SV> YY_NEW_FILE ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case EOB_ACT_CONTINUE_SCAN : //<S2SV> yyg -> yy_c_buf_p = //<S2SV> yyg -> yytext_ptr + yy_amount_of_matched_text ; //<S2SV> yy_current_state = yy_get_previous_state ( yyscanner ) ; //<S2SV> yy_cp = yyg -> yy_c_buf_p ; //<S2SV> yy_bp = yyg -> yytext_ptr + YY_MORE_ADJ ; //<S2SV> goto yy_match ; //<S2SV> case EOB_ACT_LAST_MATCH : //<S2SV> yyg -> yy_c_buf_p = //<S2SV> & YY_CURRENT_BUFFER_LVALUE -> yy_ch_buf [ yyg -> yy_n_chars ] ; //<S2SV> yy_current_state = yy_get_previous_state ( yyscanner ) ; //<S2SV> yy_cp = yyg -> yy_c_buf_p ; //<S2SV> yy_bp = yyg -> yytext_ptr + YY_MORE_ADJ ; //<S2SV> goto yy_find_action ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> YY_FATAL_ERROR ( //<S2SV> "fatal<S2SV_blank>flex<S2SV_blank>scanner<S2SV_blank>internal<S2SV_blank>error--no<S2SV_blank>action<S2SV_blank>found" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 