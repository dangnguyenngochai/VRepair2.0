int yr_re_fast_exec ( //<S2SV> uint8_t * code , //<S2SV> uint8_t * input_data , //<S2SV> size_t input_forwards_size , //<S2SV> size_t input_backwards_size , //<S2SV> int flags , //<S2SV> RE_MATCH_CALLBACK_FUNC callback , //<S2SV> void * callback_args , //<S2SV> int * matches ) //<S2SV> { //<S2SV> RE_REPEAT_ANY_ARGS * repeat_any_args ; //<S2SV> uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; //<S2SV> uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; //<S2SV> int matches_stack [ MAX_FAST_RE_STACK ] ; //<S2SV> uint8_t * ip = code ; //<S2SV> uint8_t * input = input_data ; //<S2SV> uint8_t * next_input ; //<S2SV> uint8_t * next_opcode ; //<S2SV> uint8_t mask ; //<S2SV> uint8_t value ; //<S2SV> int i ; //<S2SV> int stop ; //<S2SV> int input_incr ; //<S2SV> int sp = 0 ; //<S2SV> int bytes_matched ; //<S2SV> int max_bytes_matched ; //<S2SV> max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? //<S2SV> ( int ) input_backwards_size : //<S2SV> ( int ) input_forwards_size ; //<S2SV> input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; //<S2SV> if ( flags & RE_FLAGS_BACKWARDS ) //<S2SV> input -- ; //<S2SV> code_stack [ sp ] = code ; //<S2SV> input_stack [ sp ] = input ; //<S2SV> matches_stack [ sp ] = 0 ; //<S2SV> sp ++ ; //<S2SV> while ( sp > 0 ) //<S2SV> { //<S2SV> sp -- ; //<S2SV> ip = code_stack [ sp ] ; //<S2SV> input = input_stack [ sp ] ; //<S2SV> bytes_matched = matches_stack [ sp ] ; //<S2SV> stop = FALSE ; //<S2SV> while ( ! stop ) //<S2SV> { //<S2SV> if ( * ip == RE_OPCODE_MATCH ) //<S2SV> { //<S2SV> if ( flags & RE_FLAGS_EXHAUSTIVE ) //<S2SV> { //<S2SV> FAIL_ON_ERROR ( callback ( //<S2SV> flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , //<S2SV> bytes_matched , //<S2SV> flags , //<S2SV> callback_args ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( matches != NULL ) //<S2SV> * matches = bytes_matched ; //<S2SV> return ERROR_SUCCESS ; //<S2SV> } //<S2SV> } //<S2SV> if ( bytes_matched >= max_bytes_matched ) //<S2SV> break ; //<S2SV> switch ( * ip ) //<S2SV> { //<S2SV> case RE_OPCODE_LITERAL : //<S2SV> if ( * input == * ( ip + 1 ) ) //<S2SV> { //<S2SV> bytes_matched ++ ; //<S2SV> input += input_incr ; //<S2SV> ip += 2 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> stop = TRUE ; //<S2SV> } //<S2SV> break ; //<S2SV> case RE_OPCODE_MASKED_LITERAL : //<S2SV> value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; //<S2SV> mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; //<S2SV> if ( ( * input & mask ) == value ) //<S2SV> { //<S2SV> bytes_matched ++ ; //<S2SV> input += input_incr ; //<S2SV> ip += 3 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> stop = TRUE ; //<S2SV> } //<S2SV> break ; //<S2SV> case RE_OPCODE_ANY : //<S2SV> bytes_matched ++ ; //<S2SV> input += input_incr ; //<S2SV> ip += 1 ; //<S2SV> break ; //<S2SV> case RE_OPCODE_REPEAT_ANY_UNGREEDY : //<S2SV> repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; //<S2SV> next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; //<S2SV> for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) //<S2SV> { //<S2SV> next_input = input + i * input_incr ; //<S2SV> if ( bytes_matched + i >= max_bytes_matched ) //<S2SV> break ; //<S2SV> if ( * ( next_opcode ) != RE_OPCODE_LITERAL || //<S2SV> ( * ( next_opcode ) == RE_OPCODE_LITERAL && //<S2SV> * ( next_opcode + 1 ) == * next_input ) ) //<S2SV> { //<S2SV> if ( sp >= MAX_FAST_RE_STACK ) //<S2SV> return - 4 ; //<S2SV> code_stack [ sp ] = next_opcode ; //<S2SV> input_stack [ sp ] = next_input ; //<S2SV> matches_stack [ sp ] = bytes_matched + i ; //<S2SV> sp ++ ; //<S2SV> } //<S2SV> } //<S2SV> input += input_incr * repeat_any_args -> min ; //<S2SV> bytes_matched += repeat_any_args -> min ; //<S2SV> ip = next_opcode ; //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( FALSE ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( matches != NULL ) //<S2SV> * matches = - 1 ; //<S2SV> return ERROR_SUCCESS ; //<S2SV> } //<S2SV> 