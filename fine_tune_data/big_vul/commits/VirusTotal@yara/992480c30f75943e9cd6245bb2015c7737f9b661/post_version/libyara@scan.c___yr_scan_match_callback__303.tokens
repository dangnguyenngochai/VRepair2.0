int _yr_scan_match_callback ( //<S2SV> uint8_t * match_data , //<S2SV> int32_t match_length , //<S2SV> int flags , //<S2SV> void * args ) //<S2SV> { //<S2SV> CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; //<S2SV> YR_STRING * string = callback_args -> string ; //<S2SV> YR_MATCH * new_match ; //<S2SV> int result = ERROR_SUCCESS ; //<S2SV> int tidx = callback_args -> context -> tidx ; //<S2SV> size_t match_offset = match_data - callback_args -> data ; //<S2SV> match_length += callback_args -> forward_matches ; //<S2SV> assert ( match_offset + match_length <= callback_args -> data_size ) ; //<S2SV> if ( callback_args -> full_word ) //<S2SV> { //<S2SV> if ( flags & RE_FLAGS_WIDE ) //<S2SV> { //<S2SV> if ( match_offset >= 2 && //<S2SV> * ( match_data - 1 ) == 0 && //<S2SV> isalnum ( * ( match_data - 2 ) ) ) //<S2SV> return ERROR_SUCCESS ; //<S2SV> if ( match_offset + match_length + 1 < callback_args -> data_size && //<S2SV> * ( match_data + match_length + 1 ) == 0 && //<S2SV> isalnum ( * ( match_data + match_length ) ) ) //<S2SV> return ERROR_SUCCESS ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( match_offset >= 1 && //<S2SV> isalnum ( * ( match_data - 1 ) ) ) //<S2SV> return ERROR_SUCCESS ; //<S2SV> if ( match_offset + match_length < callback_args -> data_size && //<S2SV> isalnum ( * ( match_data + match_length ) ) ) //<S2SV> return ERROR_SUCCESS ; //<S2SV> } //<S2SV> } //<S2SV> if ( STRING_IS_CHAIN_PART ( string ) ) //<S2SV> { //<S2SV> result = _yr_scan_verify_chained_string_match ( //<S2SV> string , //<S2SV> callback_args -> context , //<S2SV> match_data , //<S2SV> callback_args -> data_base , //<S2SV> match_offset , //<S2SV> match_length ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( string -> matches [ tidx ] . count == 0 ) //<S2SV> { //<S2SV> FAIL_ON_ERROR ( yr_arena_write_data ( //<S2SV> callback_args -> context -> matching_strings_arena , //<S2SV> & string , //<S2SV> sizeof ( string ) , //<S2SV> NULL ) ) ; //<S2SV> } //<S2SV> FAIL_ON_ERROR ( yr_arena_allocate_memory ( //<S2SV> callback_args -> context -> matches_arena , //<S2SV> sizeof ( YR_MATCH ) , //<S2SV> ( void * * ) & new_match ) ) ; //<S2SV> new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; //<S2SV> FAIL_ON_ERROR ( yr_arena_write_data ( //<S2SV> callback_args -> context -> matches_arena , //<S2SV> match_data , //<S2SV> new_match -> data_length , //<S2SV> ( void * * ) & new_match -> data ) ) ; //<S2SV> if ( result == ERROR_SUCCESS ) //<S2SV> { //<S2SV> new_match -> base = callback_args -> data_base ; //<S2SV> new_match -> offset = match_offset ; //<S2SV> new_match -> match_length = match_length ; //<S2SV> new_match -> prev = NULL ; //<S2SV> new_match -> next = NULL ; //<S2SV> FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( //<S2SV> new_match , //<S2SV> & string -> matches [ tidx ] , //<S2SV> STRING_IS_GREEDY_REGEXP ( string ) ) ) ; //<S2SV> } //<S2SV> } //<S2SV> return result ; //<S2SV> } //<S2SV> 