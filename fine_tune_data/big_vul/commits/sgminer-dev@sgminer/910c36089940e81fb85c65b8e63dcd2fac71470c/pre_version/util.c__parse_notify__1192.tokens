static bool parse_notify ( struct pool * pool , json_t * val ) //<S2SV> { //<S2SV> char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , //<S2SV> * ntime , * header ; //<S2SV> size_t cb1_len , cb2_len , alloc_len ; //<S2SV> unsigned char * cb1 , * cb2 ; //<S2SV> bool clean , ret = false ; //<S2SV> int merkles , i ; //<S2SV> json_t * arr ; //<S2SV> arr = json_array_get ( val , 4 ) ; //<S2SV> if ( ! arr || ! json_is_array ( arr ) ) //<S2SV> goto out ; //<S2SV> merkles = json_array_size ( arr ) ; //<S2SV> job_id = json_array_string ( val , 0 ) ; //<S2SV> prev_hash = json_array_string ( val , 1 ) ; //<S2SV> coinbase1 = json_array_string ( val , 2 ) ; //<S2SV> coinbase2 = json_array_string ( val , 3 ) ; //<S2SV> bbversion = json_array_string ( val , 5 ) ; //<S2SV> nbit = json_array_string ( val , 6 ) ; //<S2SV> ntime = json_array_string ( val , 7 ) ; //<S2SV> clean = json_is_true ( json_array_get ( val , 8 ) ) ; //<S2SV> if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { //<S2SV> if ( job_id ) //<S2SV> free ( job_id ) ; //<S2SV> if ( prev_hash ) //<S2SV> free ( prev_hash ) ; //<S2SV> if ( coinbase1 ) //<S2SV> free ( coinbase1 ) ; //<S2SV> if ( coinbase2 ) //<S2SV> free ( coinbase2 ) ; //<S2SV> if ( bbversion ) //<S2SV> free ( bbversion ) ; //<S2SV> if ( nbit ) //<S2SV> free ( nbit ) ; //<S2SV> if ( ntime ) //<S2SV> free ( ntime ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> cg_wlock ( & pool -> data_lock ) ; //<S2SV> free ( pool -> swork . job_id ) ; //<S2SV> free ( pool -> swork . prev_hash ) ; //<S2SV> free ( pool -> swork . bbversion ) ; //<S2SV> free ( pool -> swork . nbit ) ; //<S2SV> free ( pool -> swork . ntime ) ; //<S2SV> pool -> swork . job_id = job_id ; //<S2SV> pool -> swork . prev_hash = prev_hash ; //<S2SV> cb1_len = strlen ( coinbase1 ) / 2 ; //<S2SV> cb2_len = strlen ( coinbase2 ) / 2 ; //<S2SV> pool -> swork . bbversion = bbversion ; //<S2SV> pool -> swork . nbit = nbit ; //<S2SV> pool -> swork . ntime = ntime ; //<S2SV> pool -> swork . clean = clean ; //<S2SV> alloc_len = pool -> swork . cb_len = cb1_len + pool -> n1_len + pool -> n2size + cb2_len ; //<S2SV> pool -> nonce2_offset = cb1_len + pool -> n1_len ; //<S2SV> for ( i = 0 ; i < pool -> swork . merkles ; i ++ ) //<S2SV> free ( pool -> swork . merkle_bin [ i ] ) ; //<S2SV> if ( merkles ) { //<S2SV> pool -> swork . merkle_bin = ( unsigned char * * ) realloc ( pool -> swork . merkle_bin , //<S2SV> sizeof ( char * ) * merkles + 1 ) ; //<S2SV> for ( i = 0 ; i < merkles ; i ++ ) { //<S2SV> char * merkle = json_array_string ( arr , i ) ; //<S2SV> pool -> swork . merkle_bin [ i ] = ( unsigned char * ) malloc ( 32 ) ; //<S2SV> if ( unlikely ( ! pool -> swork . merkle_bin [ i ] ) ) //<S2SV> quit ( 1 , "Failed<S2SV_blank>to<S2SV_blank>malloc<S2SV_blank>pool<S2SV_blank>swork<S2SV_blank>merkle_bin" ) ; //<S2SV> hex2bin ( pool -> swork . merkle_bin [ i ] , merkle , 32 ) ; //<S2SV> free ( merkle ) ; //<S2SV> } //<S2SV> } //<S2SV> pool -> swork . merkles = merkles ; //<S2SV> if ( clean ) //<S2SV> pool -> nonce2 = 0 ; //<S2SV> pool -> merkle_offset = strlen ( pool -> swork . bbversion ) + //<S2SV> strlen ( pool -> swork . prev_hash ) ; //<S2SV> pool -> swork . header_len = pool -> merkle_offset + //<S2SV> 32 + //<S2SV> strlen ( pool -> swork . ntime ) + //<S2SV> strlen ( pool -> swork . nbit ) + //<S2SV> 8 + //<S2SV> 96 ; //<S2SV> pool -> merkle_offset /= 2 ; //<S2SV> pool -> swork . header_len = pool -> swork . header_len * 2 + 1 ; //<S2SV> align_len ( & pool -> swork . header_len ) ; //<S2SV> header = ( char * ) alloca ( pool -> swork . header_len ) ; //<S2SV> snprintf ( header , pool -> swork . header_len , //<S2SV> "%s%s%s%s%s%s%s" , //<S2SV> pool -> swork . bbversion , //<S2SV> pool -> swork . prev_hash , //<S2SV> blank_merkel , //<S2SV> pool -> swork . ntime , //<S2SV> pool -> swork . nbit , //<S2SV> "00000000" , //<S2SV> workpadding ) ; //<S2SV> if ( unlikely ( ! hex2bin ( pool -> header_bin , header , 128 ) ) ) //<S2SV> quit ( 1 , "Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> cb1 = ( unsigned char * ) calloc ( cb1_len , 1 ) ; //<S2SV> if ( unlikely ( ! cb1 ) ) //<S2SV> quithere ( 1 , "Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>cb1<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> hex2bin ( cb1 , coinbase1 , cb1_len ) ; //<S2SV> cb2 = ( unsigned char * ) calloc ( cb2_len , 1 ) ; //<S2SV> if ( unlikely ( ! cb2 ) ) //<S2SV> quithere ( 1 , "Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>cb2<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> hex2bin ( cb2 , coinbase2 , cb2_len ) ; //<S2SV> free ( pool -> coinbase ) ; //<S2SV> align_len ( & alloc_len ) ; //<S2SV> pool -> coinbase = ( unsigned char * ) calloc ( alloc_len , 1 ) ; //<S2SV> if ( unlikely ( ! pool -> coinbase ) ) //<S2SV> quit ( 1 , "Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool<S2SV_blank>coinbase<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> memcpy ( pool -> coinbase , cb1 , cb1_len ) ; //<S2SV> memcpy ( pool -> coinbase + cb1_len , pool -> nonce1bin , pool -> n1_len ) ; //<S2SV> memcpy ( pool -> coinbase + cb1_len + pool -> n1_len + pool -> n2size , cb2 , cb2_len ) ; //<S2SV> cg_wunlock ( & pool -> data_lock ) ; //<S2SV> if ( opt_protocol ) { //<S2SV> applog ( LOG_DEBUG , "job_id:<S2SV_blank>%s" , job_id ) ; //<S2SV> applog ( LOG_DEBUG , "prev_hash:<S2SV_blank>%s" , prev_hash ) ; //<S2SV> applog ( LOG_DEBUG , "coinbase1:<S2SV_blank>%s" , coinbase1 ) ; //<S2SV> applog ( LOG_DEBUG , "coinbase2:<S2SV_blank>%s" , coinbase2 ) ; //<S2SV> applog ( LOG_DEBUG , "bbversion:<S2SV_blank>%s" , bbversion ) ; //<S2SV> applog ( LOG_DEBUG , "nbit:<S2SV_blank>%s" , nbit ) ; //<S2SV> applog ( LOG_DEBUG , "ntime:<S2SV_blank>%s" , ntime ) ; //<S2SV> applog ( LOG_DEBUG , "clean:<S2SV_blank>%s" , clean ? "yes" : "no" ) ; //<S2SV> } //<S2SV> free ( coinbase1 ) ; //<S2SV> free ( coinbase2 ) ; //<S2SV> free ( cb1 ) ; //<S2SV> free ( cb2 ) ; //<S2SV> pool -> getwork_requested ++ ; //<S2SV> total_getworks ++ ; //<S2SV> ret = true ; //<S2SV> if ( pool == current_pool ( ) ) //<S2SV> opt_work_update = true ; //<S2SV> out : //<S2SV> return ret ; //<S2SV> } //<S2SV> 