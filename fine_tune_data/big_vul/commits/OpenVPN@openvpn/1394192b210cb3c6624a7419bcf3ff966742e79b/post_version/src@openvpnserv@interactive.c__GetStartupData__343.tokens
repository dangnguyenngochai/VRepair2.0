static BOOL //<S2SV> GetStartupData ( HANDLE pipe , STARTUP_DATA * sud ) //<S2SV> { //<S2SV> size_t size , len ; //<S2SV> WCHAR * data = NULL ; //<S2SV> DWORD bytes , read ; //<S2SV> bytes = PeekNamedPipeAsync ( pipe , 1 , & exit_event ) ; //<S2SV> if ( bytes == 0 ) //<S2SV> { //<S2SV> MsgToEventLog ( M_SYSERR , TEXT ( "PeekNamedPipeAsync<S2SV_blank>failed" ) ) ; //<S2SV> ReturnLastError ( pipe , L"PeekNamedPipeAsync" ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> size = bytes / sizeof ( * data ) ; //<S2SV> if ( size == 0 ) //<S2SV> { //<S2SV> MsgToEventLog ( M_SYSERR , TEXT ( "malformed<S2SV_blank>startup<S2SV_blank>data:<S2SV_blank>1<S2SV_blank>byte<S2SV_blank>received" ) ) ; //<S2SV> ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> data = malloc ( bytes ) ; //<S2SV> if ( data == NULL ) //<S2SV> { //<S2SV> MsgToEventLog ( M_SYSERR , TEXT ( "malloc<S2SV_blank>failed" ) ) ; //<S2SV> ReturnLastError ( pipe , L"malloc" ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ; //<S2SV> if ( bytes != read ) //<S2SV> { //<S2SV> MsgToEventLog ( M_SYSERR , TEXT ( "ReadPipeAsync<S2SV_blank>failed" ) ) ; //<S2SV> ReturnLastError ( pipe , L"ReadPipeAsync" ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( data [ size - 1 ] != 0 ) //<S2SV> { //<S2SV> MsgToEventLog ( M_ERR , TEXT ( "Startup<S2SV_blank>data<S2SV_blank>is<S2SV_blank>not<S2SV_blank>NULL<S2SV_blank>terminated" ) ) ; //<S2SV> ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> sud -> directory = data ; //<S2SV> len = wcslen ( sud -> directory ) + 1 ; //<S2SV> size -= len ; //<S2SV> if ( size <= 0 ) //<S2SV> { //<S2SV> MsgToEventLog ( M_ERR , TEXT ( "Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>working<S2SV_blank>directory" ) ) ; //<S2SV> ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> sud -> options = sud -> directory + len ; //<S2SV> len = wcslen ( sud -> options ) + 1 ; //<S2SV> size -= len ; //<S2SV> if ( size <= 0 ) //<S2SV> { //<S2SV> MsgToEventLog ( M_ERR , TEXT ( "Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>command<S2SV_blank>line<S2SV_blank>options" ) ) ; //<S2SV> ReturnError ( pipe , ERROR_STARTUP_DATA , L"GetStartupData" , 1 , & exit_event ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> sud -> std_input = sud -> options + len ; //<S2SV> return TRUE ; //<S2SV> err : //<S2SV> sud -> directory = NULL ; //<S2SV> free ( data ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> 