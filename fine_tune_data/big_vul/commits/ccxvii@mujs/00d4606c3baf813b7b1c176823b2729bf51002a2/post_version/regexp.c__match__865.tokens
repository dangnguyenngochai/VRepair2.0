static int match ( Reinst * pc , const char * sp , const char * bol , int flags , Resub * out , int depth ) //<S2SV> { //<S2SV> Resub scratch ; //<S2SV> int result ; //<S2SV> int i ; //<S2SV> Rune c ; //<S2SV> if ( depth > MAXREC ) //<S2SV> return - 1 ; //<S2SV> for ( ; ; ) { //<S2SV> switch ( pc -> opcode ) { //<S2SV> case I_END : //<S2SV> return 0 ; //<S2SV> case I_JUMP : //<S2SV> pc = pc -> x ; //<S2SV> break ; //<S2SV> case I_SPLIT : //<S2SV> scratch = * out ; //<S2SV> result = match ( pc -> x , sp , bol , flags , & scratch , depth + 1 ) ; //<S2SV> if ( result == - 1 ) //<S2SV> return - 1 ; //<S2SV> if ( result == 0 ) { //<S2SV> * out = scratch ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> pc = pc -> y ; //<S2SV> break ; //<S2SV> case I_PLA : //<S2SV> result = match ( pc -> x , sp , bol , flags , out , depth + 1 ) ; //<S2SV> if ( result == - 1 ) //<S2SV> return - 1 ; //<S2SV> if ( result == 1 ) //<S2SV> return 1 ; //<S2SV> pc = pc -> y ; //<S2SV> break ; //<S2SV> case I_NLA : //<S2SV> scratch = * out ; //<S2SV> result = match ( pc -> x , sp , bol , flags , & scratch , depth + 1 ) ; //<S2SV> if ( result == - 1 ) //<S2SV> return - 1 ; //<S2SV> if ( result == 0 ) //<S2SV> return 1 ; //<S2SV> pc = pc -> y ; //<S2SV> break ; //<S2SV> case I_ANYNL : //<S2SV> sp += chartorune ( & c , sp ) ; //<S2SV> if ( c == 0 ) //<S2SV> return 1 ; //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_ANY : //<S2SV> sp += chartorune ( & c , sp ) ; //<S2SV> if ( c == 0 ) //<S2SV> return 1 ; //<S2SV> if ( isnewline ( c ) ) //<S2SV> return 1 ; //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_CHAR : //<S2SV> sp += chartorune ( & c , sp ) ; //<S2SV> if ( c == 0 ) //<S2SV> return 1 ; //<S2SV> if ( flags & REG_ICASE ) //<S2SV> c = canon ( c ) ; //<S2SV> if ( c != pc -> c ) //<S2SV> return 1 ; //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_CCLASS : //<S2SV> sp += chartorune ( & c , sp ) ; //<S2SV> if ( c == 0 ) //<S2SV> return 1 ; //<S2SV> if ( flags & REG_ICASE ) { //<S2SV> if ( ! incclasscanon ( pc -> cc , canon ( c ) ) ) //<S2SV> return 1 ; //<S2SV> } else { //<S2SV> if ( ! incclass ( pc -> cc , c ) ) //<S2SV> return 1 ; //<S2SV> } //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_NCCLASS : //<S2SV> sp += chartorune ( & c , sp ) ; //<S2SV> if ( c == 0 ) //<S2SV> return 1 ; //<S2SV> if ( flags & REG_ICASE ) { //<S2SV> if ( incclasscanon ( pc -> cc , canon ( c ) ) ) //<S2SV> return 1 ; //<S2SV> } else { //<S2SV> if ( incclass ( pc -> cc , c ) ) //<S2SV> return 1 ; //<S2SV> } //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_REF : //<S2SV> i = out -> sub [ pc -> n ] . ep - out -> sub [ pc -> n ] . sp ; //<S2SV> if ( flags & REG_ICASE ) { //<S2SV> if ( strncmpcanon ( sp , out -> sub [ pc -> n ] . sp , i ) ) //<S2SV> return 1 ; //<S2SV> } else { //<S2SV> if ( strncmp ( sp , out -> sub [ pc -> n ] . sp , i ) ) //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( i > 0 ) //<S2SV> sp += i ; //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_BOL : //<S2SV> if ( sp == bol && ! ( flags & REG_NOTBOL ) ) { //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( flags & REG_NEWLINE ) { //<S2SV> if ( sp > bol && isnewline ( sp [ - 1 ] ) ) { //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> case I_EOL : //<S2SV> if ( * sp == 0 ) { //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( flags & REG_NEWLINE ) { //<S2SV> if ( isnewline ( * sp ) ) { //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> case I_WORD : //<S2SV> i = sp > bol && iswordchar ( sp [ - 1 ] ) ; //<S2SV> i ^= iswordchar ( sp [ 0 ] ) ; //<S2SV> if ( ! i ) //<S2SV> return 1 ; //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_NWORD : //<S2SV> i = sp > bol && iswordchar ( sp [ - 1 ] ) ; //<S2SV> i ^= iswordchar ( sp [ 0 ] ) ; //<S2SV> if ( i ) //<S2SV> return 1 ; //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_LPAR : //<S2SV> out -> sub [ pc -> n ] . sp = sp ; //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> case I_RPAR : //<S2SV> out -> sub [ pc -> n ] . ep = sp ; //<S2SV> pc = pc + 1 ; //<S2SV> break ; //<S2SV> default : //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 