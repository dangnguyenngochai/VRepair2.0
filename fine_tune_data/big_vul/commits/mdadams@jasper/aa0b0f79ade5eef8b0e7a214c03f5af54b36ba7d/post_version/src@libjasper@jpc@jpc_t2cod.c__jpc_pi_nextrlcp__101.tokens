static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) //<S2SV> { //<S2SV> jpc_pchg_t * pchg ; //<S2SV> int * prclyrno ; //<S2SV> pchg = pi -> pchg ; //<S2SV> if ( ! pi -> prgvolfirst ) { //<S2SV> assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; //<S2SV> prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; //<S2SV> goto skip ; //<S2SV> } else { //<S2SV> pi -> prgvolfirst = 0 ; //<S2SV> } //<S2SV> for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && //<S2SV> pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { //<S2SV> for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < //<S2SV> JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { //<S2SV> for ( pi -> compno = pchg -> compnostart , pi -> picomp = //<S2SV> & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && //<S2SV> pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , //<S2SV> ++ pi -> picomp ) { //<S2SV> if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { //<S2SV> continue ; //<S2SV> } //<S2SV> pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; //<S2SV> for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; //<S2SV> pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { //<S2SV> if ( pi -> lyrno >= * prclyrno ) { //<S2SV> * prclyrno = pi -> lyrno ; //<S2SV> ++ ( * prclyrno ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> skip : //<S2SV> ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> } //<S2SV> 