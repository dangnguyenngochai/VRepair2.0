TPM_RC tpm_kdfa ( TPMI_ALG_HASH hashAlg , //<S2SV> TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , //<S2SV> TPM2B_MAX_BUFFER * resultKey ) //<S2SV> { //<S2SV> TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; //<S2SV> UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; //<S2SV> UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; //<S2SV> TPM2B_DIGEST * bufferList [ 8 ] ; //<S2SV> UINT32 bitsSwizzled , i_Swizzled ; //<S2SV> TPM_RC rval = TPM_RC_SUCCESS ; //<S2SV> int i , j ; //<S2SV> UINT16 bytes = bits / 8 ; //<S2SV> resultKey -> t . size = 0 ; //<S2SV> tpm2b_i_2 . t . size = 4 ; //<S2SV> tpm2bBits . t . size = 4 ; //<S2SV> bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; //<S2SV> * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; //<S2SV> for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; //<S2SV> tpm2bLabel . t . size = i + 1 ; //<S2SV> for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) //<S2SV> { //<S2SV> tpm2bLabel . t . buffer [ i ] = label [ i ] ; //<S2SV> } //<S2SV> resultKey -> t . size = 0 ; //<S2SV> i = 1 ; //<S2SV> const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; //<S2SV> if ( ! md ) { //<S2SV> LOG_ERR ( "Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x" , hashAlg ) ; //<S2SV> return TPM_RC_HASH ; //<S2SV> } //<S2SV> HMAC_CTX ctx ; //<S2SV> HMAC_CTX_init ( & ctx ) ; //<S2SV> int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; //<S2SV> if ( ! rc ) { //<S2SV> LOG_ERR ( "HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; //<S2SV> return TPM_RC_MEMORY ; //<S2SV> } //<S2SV> while ( resultKey -> t . size < bytes ) //<S2SV> { //<S2SV> TPM2B_DIGEST tmpResult ; //<S2SV> i_Swizzled = string_bytes_endian_convert_32 ( i ) ; //<S2SV> * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; //<S2SV> j = 0 ; //<S2SV> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; //<S2SV> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; //<S2SV> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; //<S2SV> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; //<S2SV> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; //<S2SV> bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ; //<S2SV> int c ; //<S2SV> for ( c = 0 ; c < j ; c ++ ) { //<S2SV> TPM2B_DIGEST * digest = bufferList [ c ] ; //<S2SV> int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; //<S2SV> if ( ! rc ) { //<S2SV> LOG_ERR ( "HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; //<S2SV> rval = TPM_RC_MEMORY ; //<S2SV> goto err ; //<S2SV> } //<S2SV> } //<S2SV> unsigned size = sizeof ( tmpResult . t . buffer ) ; //<S2SV> int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size ) ; //<S2SV> if ( ! rc ) { //<S2SV> LOG_ERR ( "HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; //<S2SV> rval = TPM_RC_MEMORY ; //<S2SV> goto err ; //<S2SV> } //<S2SV> tmpResult . t . size = size ; //<S2SV> bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; //<S2SV> if ( ! res ) { //<S2SV> rval = TSS2_SYS_RC_BAD_VALUE ; //<S2SV> goto err ; //<S2SV> } //<S2SV> } //<S2SV> resultKey -> t . size = bytes ; //<S2SV> err : //<S2SV> HMAC_CTX_cleanup ( & ctx ) ; //<S2SV> return rval ; //<S2SV> } //<S2SV> 