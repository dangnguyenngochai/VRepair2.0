static enum ofperr //<S2SV> parse_group_prop_ntr_selection_method ( struct ofpbuf * payload , //<S2SV> enum ofp11_group_type group_type , //<S2SV> enum ofp15_group_mod_command group_cmd , //<S2SV> struct ofputil_group_props * gp ) //<S2SV> { //<S2SV> struct ntr_group_prop_selection_method * prop = payload -> data ; //<S2SV> size_t fields_len , method_len ; //<S2SV> enum ofperr error ; //<S2SV> switch ( group_type ) { //<S2SV> case OFPGT11_SELECT : //<S2SV> break ; //<S2SV> case OFPGT11_ALL : //<S2SV> case OFPGT11_INDIRECT : //<S2SV> case OFPGT11_FF : //<S2SV> OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>is<S2SV_blank>" //<S2SV> "only<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>select<S2SV_blank>groups" ) ; //<S2SV> return OFPERR_OFPBPC_BAD_VALUE ; //<S2SV> default : //<S2SV> return OFPERR_OFPGMFC_BAD_TYPE ; //<S2SV> } //<S2SV> switch ( group_cmd ) { //<S2SV> case OFPGC15_ADD : //<S2SV> case OFPGC15_MODIFY : //<S2SV> case OFPGC15_ADD_OR_MOD : //<S2SV> break ; //<S2SV> case OFPGC15_DELETE : //<S2SV> case OFPGC15_INSERT_BUCKET : //<S2SV> case OFPGC15_REMOVE_BUCKET : //<S2SV> OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>is<S2SV_blank>" //<S2SV> "only<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>add<S2SV_blank>and<S2SV_blank>delete<S2SV_blank>group<S2SV_blank>modifications" ) ; //<S2SV> return OFPERR_OFPBPC_BAD_VALUE ; //<S2SV> default : //<S2SV> return OFPERR_OFPGMFC_BAD_COMMAND ; //<S2SV> } //<S2SV> if ( payload -> size < sizeof * prop ) { //<S2SV> OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>property<S2SV_blank>" //<S2SV> "length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>not<S2SV_blank>valid" , payload -> size ) ; //<S2SV> return OFPERR_OFPBPC_BAD_LEN ; //<S2SV> } //<S2SV> method_len = strnlen ( prop -> selection_method , NTR_MAX_SELECTION_METHOD_LEN ) ; //<S2SV> if ( method_len == NTR_MAX_SELECTION_METHOD_LEN ) { //<S2SV> OFPPROP_LOG ( & bad_ofmsg_rl , false , //<S2SV> "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>is<S2SV_blank>not<S2SV_blank>null<S2SV_blank>terminated" ) ; //<S2SV> return OFPERR_OFPBPC_BAD_VALUE ; //<S2SV> } //<S2SV> if ( strcmp ( "hash" , prop -> selection_method ) //<S2SV> && strcmp ( "dp_hash" , prop -> selection_method ) ) { //<S2SV> OFPPROP_LOG ( & bad_ofmsg_rl , false , //<S2SV> "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported" , //<S2SV> prop -> selection_method ) ; //<S2SV> return OFPERR_OFPBPC_BAD_VALUE ; //<S2SV> } //<S2SV> strcpy ( gp -> selection_method , prop -> selection_method ) ; //<S2SV> gp -> selection_method_param = ntohll ( prop -> selection_method_param ) ; //<S2SV> ofpbuf_pull ( payload , sizeof * prop ) ; //<S2SV> fields_len = ntohs ( prop -> length ) - sizeof * prop ; //<S2SV> if ( fields_len && strcmp ( "hash" , gp -> selection_method ) ) { //<S2SV> OFPPROP_LOG ( & bad_ofmsg_rl , false , "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>%s<S2SV_blank>" //<S2SV> "does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>fields" , gp -> selection_method ) ; //<S2SV> return OFPERR_OFPBPC_BAD_VALUE ; //<S2SV> } //<S2SV> error = oxm_pull_field_array ( payload -> data , fields_len , //<S2SV> & gp -> fields ) ; //<S2SV> if ( error ) { //<S2SV> OFPPROP_LOG ( & bad_ofmsg_rl , false , //<S2SV> "ntr<S2SV_blank>selection<S2SV_blank>method<S2SV_blank>fields<S2SV_blank>are<S2SV_blank>invalid" ) ; //<S2SV> return error ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 