static enum ofperr //<S2SV> decode_bundle ( bool load , const struct nx_action_bundle * nab , //<S2SV> const struct vl_mff_map * vl_mff_map , uint64_t * tlv_bitmap , //<S2SV> struct ofpbuf * ofpacts ) //<S2SV> { //<S2SV> static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT ( 1 , 5 ) ; //<S2SV> struct ofpact_bundle * bundle ; //<S2SV> uint32_t slave_type ; //<S2SV> size_t slaves_size , i ; //<S2SV> enum ofperr error ; //<S2SV> bundle = ofpact_put_BUNDLE ( ofpacts ) ; //<S2SV> bundle -> n_slaves = ntohs ( nab -> n_slaves ) ; //<S2SV> bundle -> basis = ntohs ( nab -> basis ) ; //<S2SV> bundle -> fields = ntohs ( nab -> fields ) ; //<S2SV> bundle -> algorithm = ntohs ( nab -> algorithm ) ; //<S2SV> slave_type = ntohl ( nab -> slave_type ) ; //<S2SV> slaves_size = ntohs ( nab -> len ) - sizeof * nab ; //<S2SV> error = OFPERR_OFPBAC_BAD_ARGUMENT ; //<S2SV> if ( ! flow_hash_fields_valid ( bundle -> fields ) ) { //<S2SV> VLOG_WARN_RL ( & rl , "unsupported<S2SV_blank>fields<S2SV_blank>%d" , ( int ) bundle -> fields ) ; //<S2SV> } else if ( bundle -> n_slaves > BUNDLE_MAX_SLAVES ) { //<S2SV> VLOG_WARN_RL ( & rl , "too<S2SV_blank>many<S2SV_blank>slaves" ) ; //<S2SV> } else if ( bundle -> algorithm != NX_BD_ALG_HRW //<S2SV> && bundle -> algorithm != NX_BD_ALG_ACTIVE_BACKUP ) { //<S2SV> VLOG_WARN_RL ( & rl , "unsupported<S2SV_blank>algorithm<S2SV_blank>%d" , ( int ) bundle -> algorithm ) ; //<S2SV> } else if ( slave_type != mf_nxm_header ( MFF_IN_PORT ) ) { //<S2SV> VLOG_WARN_RL ( & rl , "unsupported<S2SV_blank>slave<S2SV_blank>type<S2SV_blank>%" PRIu16 , slave_type ) ; //<S2SV> } else { //<S2SV> error = 0 ; //<S2SV> } //<S2SV> if ( ! is_all_zeros ( nab -> zero , sizeof nab -> zero ) ) { //<S2SV> VLOG_WARN_RL ( & rl , "reserved<S2SV_blank>field<S2SV_blank>is<S2SV_blank>nonzero" ) ; //<S2SV> error = OFPERR_OFPBAC_BAD_ARGUMENT ; //<S2SV> } //<S2SV> if ( load ) { //<S2SV> bundle -> dst . ofs = nxm_decode_ofs ( nab -> ofs_nbits ) ; //<S2SV> bundle -> dst . n_bits = nxm_decode_n_bits ( nab -> ofs_nbits ) ; //<S2SV> error = mf_vl_mff_mf_from_nxm_header ( ntohl ( nab -> dst ) , vl_mff_map , //<S2SV> & bundle -> dst . field , tlv_bitmap ) ; //<S2SV> if ( error ) { //<S2SV> return error ; //<S2SV> } //<S2SV> if ( bundle -> dst . n_bits < 16 ) { //<S2SV> VLOG_WARN_RL ( & rl , "bundle_load<S2SV_blank>action<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>16<S2SV_blank>bit<S2SV_blank>" //<S2SV> "destination." ) ; //<S2SV> error = OFPERR_OFPBAC_BAD_ARGUMENT ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( nab -> ofs_nbits || nab -> dst ) { //<S2SV> VLOG_WARN_RL ( & rl , "bundle<S2SV_blank>action<S2SV_blank>has<S2SV_blank>nonzero<S2SV_blank>reserved<S2SV_blank>fields" ) ; //<S2SV> error = OFPERR_OFPBAC_BAD_ARGUMENT ; //<S2SV> } //<S2SV> } //<S2SV> if ( slaves_size < bundle -> n_slaves * sizeof ( ovs_be16 ) ) { //<S2SV> VLOG_WARN_RL ( & rl , "Nicira<S2SV_blank>action<S2SV_blank>%s<S2SV_blank>only<S2SV_blank>has<S2SV_blank>%" PRIuSIZE "<S2SV_blank>bytes<S2SV_blank>" //<S2SV> "allocated<S2SV_blank>for<S2SV_blank>slaves.<S2SV_blank><S2SV_blank>%" PRIuSIZE "<S2SV_blank>bytes<S2SV_blank>are<S2SV_blank>required<S2SV_blank>" //<S2SV> "for<S2SV_blank>%" PRIu16 "<S2SV_blank>slaves." , //<S2SV> load ? "bundle_load" : "bundle" , slaves_size , //<S2SV> bundle -> n_slaves * sizeof ( ovs_be16 ) , bundle -> n_slaves ) ; //<S2SV> error = OFPERR_OFPBAC_BAD_LEN ; //<S2SV> } else { //<S2SV> for ( i = 0 ; i < bundle -> n_slaves ; i ++ ) { //<S2SV> ofp_port_t ofp_port //<S2SV> = u16_to_ofp ( ntohs ( ( ( ovs_be16 * ) ( nab + 1 ) ) [ i ] ) ) ; //<S2SV> ofpbuf_put ( ofpacts , & ofp_port , sizeof ofp_port ) ; //<S2SV> bundle = ofpacts -> header ; //<S2SV> } //<S2SV> } //<S2SV> ofpact_finish_BUNDLE ( ofpacts , & bundle ) ; //<S2SV> if ( ! error ) { //<S2SV> error = bundle_check ( bundle , OFPP_MAX , NULL ) ; //<S2SV> } //<S2SV> return error ; //<S2SV> } //<S2SV> 