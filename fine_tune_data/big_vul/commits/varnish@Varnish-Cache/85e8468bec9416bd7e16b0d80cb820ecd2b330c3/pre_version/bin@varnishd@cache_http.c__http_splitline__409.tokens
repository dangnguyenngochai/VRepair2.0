static uint16_t //<S2SV> http_splitline ( struct worker * w , int fd , struct http * hp , //<S2SV> const struct http_conn * htc , int h1 , int h2 , int h3 ) //<S2SV> { //<S2SV> char * p , * q ; //<S2SV> CHECK_OBJ_NOTNULL ( htc , HTTP_CONN_MAGIC ) ; //<S2SV> CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; //<S2SV> Tcheck ( htc -> rxbuf ) ; //<S2SV> for ( p = htc -> rxbuf . b ; vct_islws ( * p ) ; p ++ ) //<S2SV> continue ; //<S2SV> q = p ; //<S2SV> for ( ; ! vct_issp ( * p ) ; p ++ ) { //<S2SV> if ( vct_isctl ( * p ) ) //<S2SV> return ( 400 ) ; //<S2SV> } //<S2SV> hp -> hd [ h1 ] . b = q ; //<S2SV> hp -> hd [ h1 ] . e = p ; //<S2SV> for ( ; vct_issp ( * p ) ; p ++ ) { //<S2SV> if ( vct_isctl ( * p ) ) //<S2SV> return ( 400 ) ; //<S2SV> } //<S2SV> q = p ; //<S2SV> for ( ; ! vct_islws ( * p ) ; p ++ ) { //<S2SV> if ( vct_isctl ( * p ) ) //<S2SV> return ( 400 ) ; //<S2SV> } //<S2SV> hp -> hd [ h2 ] . b = q ; //<S2SV> hp -> hd [ h2 ] . e = p ; //<S2SV> if ( ! Tlen ( hp -> hd [ h2 ] ) ) //<S2SV> return ( 400 ) ; //<S2SV> for ( ; vct_issp ( * p ) ; p ++ ) { //<S2SV> if ( vct_isctl ( * p ) ) //<S2SV> return ( 400 ) ; //<S2SV> } //<S2SV> q = p ; //<S2SV> if ( ! vct_iscrlf ( * p ) ) { //<S2SV> for ( ; ! vct_iscrlf ( * p ) ; p ++ ) //<S2SV> if ( ! vct_issep ( * p ) && vct_isctl ( * p ) ) //<S2SV> return ( 400 ) ; //<S2SV> } //<S2SV> hp -> hd [ h3 ] . b = q ; //<S2SV> hp -> hd [ h3 ] . e = p ; //<S2SV> p += vct_skipcrlf ( p ) ; //<S2SV> * hp -> hd [ h1 ] . e = '\\0' ; //<S2SV> WSLH ( w , fd , hp , h1 ) ; //<S2SV> * hp -> hd [ h2 ] . e = '\\0' ; //<S2SV> WSLH ( w , fd , hp , h2 ) ; //<S2SV> if ( hp -> hd [ h3 ] . e != NULL ) { //<S2SV> * hp -> hd [ h3 ] . e = '\\0' ; //<S2SV> WSLH ( w , fd , hp , h3 ) ; //<S2SV> } //<S2SV> return ( http_dissect_hdrs ( w , hp , fd , p , htc ) ) ; //<S2SV> } //<S2SV> 