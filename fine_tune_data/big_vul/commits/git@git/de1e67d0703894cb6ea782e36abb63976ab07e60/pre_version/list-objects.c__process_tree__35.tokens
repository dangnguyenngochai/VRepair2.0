static void process_tree ( struct rev_info * revs , //<S2SV> struct tree * tree , //<S2SV> show_object_fn show , //<S2SV> struct strbuf * base , //<S2SV> const char * name , //<S2SV> void * cb_data ) //<S2SV> { //<S2SV> struct object * obj = & tree -> object ; //<S2SV> struct tree_desc desc ; //<S2SV> struct name_entry entry ; //<S2SV> enum interesting match = revs -> diffopt . pathspec . nr == 0 ? //<S2SV> all_entries_interesting : entry_not_interesting ; //<S2SV> int baselen = base -> len ; //<S2SV> if ( ! revs -> tree_objects ) //<S2SV> return ; //<S2SV> if ( ! obj ) //<S2SV> die ( "bad<S2SV_blank>tree<S2SV_blank>object" ) ; //<S2SV> if ( obj -> flags & ( UNINTERESTING | SEEN ) ) //<S2SV> return ; //<S2SV> if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) { //<S2SV> if ( revs -> ignore_missing_links ) //<S2SV> return ; //<S2SV> die ( "bad<S2SV_blank>tree<S2SV_blank>object<S2SV_blank>%s" , oid_to_hex ( & obj -> oid ) ) ; //<S2SV> } //<S2SV> obj -> flags |= SEEN ; //<S2SV> show ( obj , base , name , cb_data ) ; //<S2SV> strbuf_addstr ( base , name ) ; //<S2SV> if ( base -> len ) //<S2SV> strbuf_addch ( base , '/' ) ; //<S2SV> init_tree_desc ( & desc , tree -> buffer , tree -> size ) ; //<S2SV> while ( tree_entry ( & desc , & entry ) ) { //<S2SV> if ( match != all_entries_interesting ) { //<S2SV> match = tree_entry_interesting ( & entry , base , 0 , //<S2SV> & revs -> diffopt . pathspec ) ; //<S2SV> if ( match == all_entries_not_interesting ) //<S2SV> break ; //<S2SV> if ( match == entry_not_interesting ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( S_ISDIR ( entry . mode ) ) //<S2SV> process_tree ( revs , //<S2SV> lookup_tree ( entry . sha1 ) , //<S2SV> show , base , entry . path , //<S2SV> cb_data ) ; //<S2SV> else if ( S_ISGITLINK ( entry . mode ) ) //<S2SV> process_gitlink ( revs , entry . sha1 , //<S2SV> show , base , entry . path , //<S2SV> cb_data ) ; //<S2SV> else //<S2SV> process_blob ( revs , //<S2SV> lookup_blob ( entry . sha1 ) , //<S2SV> show , base , entry . path , //<S2SV> cb_data ) ; //<S2SV> } //<S2SV> strbuf_setlen ( base , baselen ) ; //<S2SV> free_tree_buffer ( tree ) ; //<S2SV> } //<S2SV> 