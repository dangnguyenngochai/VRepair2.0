hsm_com_errno_t //<S2SV> unix_client_connect ( hsm_com_client_hdl_t * hdl ) //<S2SV> { //<S2SV> int fd , len ; //<S2SV> struct sockaddr_un unix_addr ; //<S2SV> hsm_com_errno_t res = HSM_COM_OK ; //<S2SV> if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) //<S2SV> { //<S2SV> return HSM_COM_ERROR ; //<S2SV> } //<S2SV> memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; //<S2SV> unix_addr . sun_family = AF_UNIX ; //<S2SV> if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) //<S2SV> { //<S2SV> res = HSM_COM_PATH_ERR ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , "%s" , hdl -> c_path ) ; //<S2SV> len = SUN_LEN ( & unix_addr ) ; //<S2SV> unlink ( unix_addr . sun_path ) ; //<S2SV> if ( bind ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) //<S2SV> { //<S2SV> res = HSM_COM_BIND_ERR ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( chmod ( unix_addr . sun_path , S_IRWXU ) < 0 ) //<S2SV> { //<S2SV> res = HSM_COM_CHMOD_ERR ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; //<S2SV> unix_addr . sun_family = AF_UNIX ; //<S2SV> strncpy ( unix_addr . sun_path , hdl -> s_path , sizeof ( unix_addr . sun_path ) ) ; //<S2SV> unix_addr . sun_path [ sizeof ( unix_addr . sun_path ) - 1 ] = 0 ; //<S2SV> len = SUN_LEN ( & unix_addr ) ; //<S2SV> if ( connect ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) //<S2SV> { //<S2SV> res = HSM_COM_CONX_ERR ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> hdl -> client_fd = fd ; //<S2SV> hdl -> client_state = HSM_COM_C_STATE_CT ; //<S2SV> if ( unix_sck_send_conn ( hdl , 2 ) != HSM_COM_OK ) //<S2SV> { //<S2SV> hdl -> client_state = HSM_COM_C_STATE_IN ; //<S2SV> res = HSM_COM_SEND_ERR ; //<S2SV> } //<S2SV> return res ; //<S2SV> cleanup : //<S2SV> close ( fd ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> 