static enum fetch_step //<S2SV> vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) //<S2SV> { //<S2SV> ssize_t l , ll , o ; //<S2SV> double now ; //<S2SV> uint8_t * ptr ; //<S2SV> struct vsb * synth_body ; //<S2SV> CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; //<S2SV> CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; //<S2SV> CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; //<S2SV> AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; //<S2SV> assert ( bo -> director_state == DIR_S_NULL ) ; //<S2SV> wrk -> stats -> fetch_failed ++ ; //<S2SV> now = W_TIM_real ( wrk ) ; //<S2SV> VSLb_ts_busyobj ( bo , "Error" , now ) ; //<S2SV> if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) //<S2SV> ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; //<S2SV> HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; //<S2SV> http_PutResponse ( bo -> beresp , "HTTP/1.1" , 503 , "Backend<S2SV_blank>fetch<S2SV_blank>failed" ) ; //<S2SV> http_TimeHeader ( bo -> beresp , "Date:<S2SV_blank>" , now ) ; //<S2SV> http_SetHeader ( bo -> beresp , "Server:<S2SV_blank>Varnish" ) ; //<S2SV> bo -> fetch_objcore -> t_origin = now ; //<S2SV> if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { //<S2SV> bo -> fetch_objcore -> ttl = 1 ; //<S2SV> bo -> fetch_objcore -> grace = 5 ; //<S2SV> bo -> fetch_objcore -> keep = 5 ; //<S2SV> } else { //<S2SV> bo -> fetch_objcore -> ttl = 0 ; //<S2SV> bo -> fetch_objcore -> grace = 0 ; //<S2SV> bo -> fetch_objcore -> keep = 0 ; //<S2SV> } //<S2SV> synth_body = VSB_new_auto ( ) ; //<S2SV> AN ( synth_body ) ; //<S2SV> VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; //<S2SV> AZ ( VSB_finish ( synth_body ) ) ; //<S2SV> if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) { //<S2SV> VSB_destroy ( & synth_body ) ; //<S2SV> return ( F_STP_FAIL ) ; //<S2SV> } //<S2SV> if ( wrk -> handling == VCL_RET_RETRY ) { //<S2SV> VSB_destroy ( & synth_body ) ; //<S2SV> if ( bo -> retries ++ < cache_param -> max_retries ) //<S2SV> return ( F_STP_RETRY ) ; //<S2SV> VSLb ( bo -> vsl , SLT_VCL_Error , "Too<S2SV_blank>many<S2SV_blank>retries,<S2SV_blank>failing" ) ; //<S2SV> return ( F_STP_FAIL ) ; //<S2SV> } //<S2SV> assert ( wrk -> handling == VCL_RET_DELIVER ) ; //<S2SV> bo -> vfc -> bo = bo ; //<S2SV> bo -> vfc -> wrk = bo -> wrk ; //<S2SV> bo -> vfc -> oc = bo -> fetch_objcore ; //<S2SV> bo -> vfc -> http = bo -> beresp ; //<S2SV> bo -> vfc -> esi_req = bo -> bereq ; //<S2SV> if ( vbf_beresp2obj ( bo ) ) { //<S2SV> ( void ) VFP_Error ( bo -> vfc , "Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>storage" ) ; //<S2SV> VSB_destroy ( & synth_body ) ; //<S2SV> return ( F_STP_FAIL ) ; //<S2SV> } //<S2SV> ll = VSB_len ( synth_body ) ; //<S2SV> o = 0 ; //<S2SV> while ( ll > 0 ) { //<S2SV> l = ll ; //<S2SV> if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) //<S2SV> break ; //<S2SV> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; //<S2SV> VFP_Extend ( bo -> vfc , l ) ; //<S2SV> ll -= l ; //<S2SV> o += l ; //<S2SV> } //<S2SV> AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ; //<S2SV> VSB_destroy ( & synth_body ) ; //<S2SV> HSH_Unbusy ( wrk , bo -> fetch_objcore ) ; //<S2SV> ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ; //<S2SV> return ( F_STP_DONE ) ; //<S2SV> } //<S2SV> 