static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , //<S2SV> struct mschmd_header * chm , int entire ) //<S2SV> { //<S2SV> unsigned int section , name_len , x , errors , num_chunks ; //<S2SV> unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; //<S2SV> struct mschmd_file * fi , * link = NULL ; //<S2SV> off_t offset , length ; //<S2SV> int num_entries ; //<S2SV> chm -> files = NULL ; //<S2SV> chm -> sysfiles = NULL ; //<S2SV> chm -> chunk_cache = NULL ; //<S2SV> chm -> sec0 . base . chm = chm ; //<S2SV> chm -> sec0 . base . id = 0 ; //<S2SV> chm -> sec1 . base . chm = chm ; //<S2SV> chm -> sec1 . base . id = 1 ; //<S2SV> chm -> sec1 . content = NULL ; //<S2SV> chm -> sec1 . control = NULL ; //<S2SV> chm -> sec1 . spaninfo = NULL ; //<S2SV> chm -> sec1 . rtable = NULL ; //<S2SV> if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { //<S2SV> return MSPACK_ERR_READ ; //<S2SV> } //<S2SV> if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { //<S2SV> return MSPACK_ERR_SIGNATURE ; //<S2SV> } //<S2SV> if ( mspack_memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { //<S2SV> D ( ( "incorrect<S2SV_blank>GUIDs" ) ) //<S2SV> return MSPACK_ERR_SIGNATURE ; //<S2SV> } //<S2SV> chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; //<S2SV> chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; //<S2SV> chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; //<S2SV> if ( chm -> version > 3 ) { //<S2SV> sys -> message ( fh , "WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3" ) ; //<S2SV> } //<S2SV> if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { //<S2SV> return MSPACK_ERR_READ ; //<S2SV> } //<S2SV> if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || //<S2SV> read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || //<S2SV> read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) //<S2SV> { //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { //<S2SV> return MSPACK_ERR_SEEK ; //<S2SV> } //<S2SV> if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { //<S2SV> return MSPACK_ERR_READ ; //<S2SV> } //<S2SV> if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { //<S2SV> return MSPACK_ERR_SEEK ; //<S2SV> } //<S2SV> if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { //<S2SV> return MSPACK_ERR_READ ; //<S2SV> } //<S2SV> chm -> dir_offset = sys -> tell ( fh ) ; //<S2SV> chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; //<S2SV> chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; //<S2SV> chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; //<S2SV> chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; //<S2SV> chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; //<S2SV> chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; //<S2SV> chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; //<S2SV> if ( chm -> version < 3 ) { //<S2SV> chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; //<S2SV> } //<S2SV> if ( chm -> sec0 . offset > chm -> length ) { //<S2SV> D ( ( "content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended" ) ) //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { //<S2SV> D ( ( "chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough" ) ) //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( chm -> num_chunks == 0 ) { //<S2SV> D ( ( "no<S2SV_blank>chunks" ) ) //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( chm -> num_chunks > 100000 ) { //<S2SV> D ( ( "more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks" ) ) //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { //<S2SV> D ( ( "chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file" ) ) //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { //<S2SV> sys -> message ( fh , "WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two" ) ; //<S2SV> } //<S2SV> if ( chm -> first_pmgl != 0 ) { //<S2SV> sys -> message ( fh , "WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero" ) ; //<S2SV> } //<S2SV> if ( chm -> first_pmgl > chm -> last_pmgl ) { //<S2SV> D ( ( "first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk" ) ) //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root >= chm -> num_chunks ) { //<S2SV> D ( ( "index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range" ) ) //<S2SV> return MSPACK_ERR_DATAFORMAT ; //<S2SV> } //<S2SV> if ( ! entire ) { //<S2SV> return MSPACK_ERR_OK ; //<S2SV> } //<S2SV> if ( ( x = chm -> first_pmgl ) != 0 ) { //<S2SV> if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { //<S2SV> return MSPACK_ERR_SEEK ; //<S2SV> } //<S2SV> } //<S2SV> num_chunks = chm -> last_pmgl - x + 1 ; //<S2SV> if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { //<S2SV> return MSPACK_ERR_NOMEMORY ; //<S2SV> } //<S2SV> errors = 0 ; //<S2SV> while ( num_chunks -- ) { //<S2SV> if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { //<S2SV> sys -> free ( chunk ) ; //<S2SV> return MSPACK_ERR_READ ; //<S2SV> } //<S2SV> if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; //<S2SV> if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { //<S2SV> sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small" ) ; //<S2SV> } //<S2SV> if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > //<S2SV> ( ( int ) chm -> chunk_size - pmgl_Entries ) ) //<S2SV> { //<S2SV> sys -> message ( fh , "WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ; //<S2SV> } //<S2SV> p = & chunk [ pmgl_Entries ] ; //<S2SV> end = & chunk [ chm -> chunk_size - 2 ] ; //<S2SV> num_entries = EndGetI16 ( end ) ; //<S2SV> while ( num_entries -- ) { //<S2SV> READ_ENCINT ( name_len ) ; //<S2SV> if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; //<S2SV> if ( name_len == 0 ) goto chunk_end ; //<S2SV> name = p ; p += name_len ; //<S2SV> READ_ENCINT ( section ) ; //<S2SV> READ_ENCINT ( offset ) ; //<S2SV> READ_ENCINT ( length ) ; //<S2SV> if ( ( offset == 0 ) && ( length == 0 ) ) { //<S2SV> if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; //<S2SV> } //<S2SV> if ( section > 1 ) { //<S2SV> sys -> message ( fh , "invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\'%u\'." , section ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { //<S2SV> sys -> free ( chunk ) ; //<S2SV> return MSPACK_ERR_NOMEMORY ; //<S2SV> } //<S2SV> fi -> next = NULL ; //<S2SV> fi -> filename = ( char * ) & fi [ 1 ] ; //<S2SV> fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) //<S2SV> : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; //<S2SV> fi -> offset = offset ; //<S2SV> fi -> length = length ; //<S2SV> sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; //<S2SV> fi -> filename [ name_len ] = '\\0' ; //<S2SV> if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { //<S2SV> if ( mspack_memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { //<S2SV> if ( mspack_memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { //<S2SV> chm -> sec1 . content = fi ; //<S2SV> } //<S2SV> else if ( mspack_memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { //<S2SV> chm -> sec1 . control = fi ; //<S2SV> } //<S2SV> else if ( mspack_memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { //<S2SV> chm -> sec1 . spaninfo = fi ; //<S2SV> } //<S2SV> else if ( mspack_memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { //<S2SV> chm -> sec1 . rtable = fi ; //<S2SV> } //<S2SV> } //<S2SV> fi -> next = chm -> sysfiles ; //<S2SV> chm -> sysfiles = fi ; //<S2SV> } //<S2SV> else { //<S2SV> if ( link ) link -> next = fi ; else chm -> files = fi ; //<S2SV> link = fi ; //<S2SV> } //<S2SV> } //<S2SV> chunk_end : //<S2SV> if ( num_entries >= 0 ) { //<S2SV> D ( ( "chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read" ) ) //<S2SV> errors ++ ; //<S2SV> } //<S2SV> } //<S2SV> sys -> free ( chunk ) ; //<S2SV> return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; //<S2SV> } //<S2SV> 