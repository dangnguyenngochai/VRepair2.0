int lzxd_decompress ( struct lzxd_stream * lzx , off_t out_bytes ) { //<S2SV> register unsigned int bit_buffer ; //<S2SV> register int bits_left , i = 0 ; //<S2SV> unsigned char * i_ptr , * i_end ; //<S2SV> register unsigned short sym ; //<S2SV> int match_length , length_footer , extra , verbatim_bits , bytes_todo ; //<S2SV> int this_run , main_element , aligned_bits , j ; //<S2SV> unsigned char * window , * runsrc , * rundest , buf [ 12 ] ; //<S2SV> unsigned int frame_size = 0 , end_frame , match_offset , window_posn ; //<S2SV> unsigned int R0 , R1 , R2 ; //<S2SV> if ( ! lzx || ( out_bytes < 0 ) ) return MSPACK_ERR_ARGS ; //<S2SV> if ( lzx -> error ) return lzx -> error ; //<S2SV> i = lzx -> o_end - lzx -> o_ptr ; //<S2SV> if ( ( off_t ) i > out_bytes ) i = ( int ) out_bytes ; //<S2SV> if ( i ) { //<S2SV> if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { //<S2SV> return lzx -> error = MSPACK_ERR_WRITE ; //<S2SV> } //<S2SV> lzx -> o_ptr += i ; //<S2SV> lzx -> offset += i ; //<S2SV> out_bytes -= i ; //<S2SV> } //<S2SV> if ( out_bytes == 0 ) return MSPACK_ERR_OK ; //<S2SV> RESTORE_BITS ; //<S2SV> window = lzx -> window ; //<S2SV> window_posn = lzx -> window_posn ; //<S2SV> R0 = lzx -> R0 ; //<S2SV> R1 = lzx -> R1 ; //<S2SV> R2 = lzx -> R2 ; //<S2SV> end_frame = ( unsigned int ) ( ( lzx -> offset + out_bytes ) / LZX_FRAME_SIZE ) + 1 ; //<S2SV> while ( lzx -> frame < end_frame ) { //<S2SV> if ( lzx -> reset_interval && ( ( lzx -> frame % lzx -> reset_interval ) == 0 ) ) { //<S2SV> if ( lzx -> block_remaining ) { //<S2SV> D ( ( "%d<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>at<S2SV_blank>reset<S2SV_blank>interval" , lzx -> block_remaining ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> lzxd_reset_state ( lzx ) ; //<S2SV> R0 = lzx -> R0 ; //<S2SV> R1 = lzx -> R1 ; //<S2SV> R2 = lzx -> R2 ; //<S2SV> } //<S2SV> if ( lzx -> is_delta ) { //<S2SV> ENSURE_BITS ( 16 ) ; //<S2SV> REMOVE_BITS ( 16 ) ; //<S2SV> } //<S2SV> if ( ! lzx -> header_read ) { //<S2SV> j = 0 ; READ_BITS ( i , 1 ) ; if ( i ) { READ_BITS ( i , 16 ) ; READ_BITS ( j , 16 ) ; } //<S2SV> lzx -> intel_filesize = ( i << 16 ) | j ; //<S2SV> lzx -> header_read = 1 ; //<S2SV> } //<S2SV> frame_size = LZX_FRAME_SIZE ; //<S2SV> if ( lzx -> length && ( lzx -> length - lzx -> offset ) < ( off_t ) frame_size ) { //<S2SV> frame_size = lzx -> length - lzx -> offset ; //<S2SV> } //<S2SV> bytes_todo = lzx -> frame_posn + frame_size - window_posn ; //<S2SV> while ( bytes_todo > 0 ) { //<S2SV> if ( lzx -> block_remaining == 0 ) { //<S2SV> if ( ( lzx -> block_type == LZX_BLOCKTYPE_UNCOMPRESSED ) && //<S2SV> ( lzx -> block_length & 1 ) ) //<S2SV> { //<S2SV> READ_IF_NEEDED ; //<S2SV> i_ptr ++ ; //<S2SV> } //<S2SV> READ_BITS ( lzx -> block_type , 3 ) ; //<S2SV> READ_BITS ( i , 16 ) ; READ_BITS ( j , 8 ) ; //<S2SV> lzx -> block_remaining = lzx -> block_length = ( i << 8 ) | j ; //<S2SV> switch ( lzx -> block_type ) { //<S2SV> case LZX_BLOCKTYPE_ALIGNED : //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) { READ_BITS ( j , 3 ) ; lzx -> ALIGNED_len [ i ] = j ; } //<S2SV> BUILD_TABLE ( ALIGNED ) ; //<S2SV> case LZX_BLOCKTYPE_VERBATIM : //<S2SV> READ_LENGTHS ( MAINTREE , 0 , 256 ) ; //<S2SV> READ_LENGTHS ( MAINTREE , 256 , LZX_NUM_CHARS + lzx -> num_offsets ) ; //<S2SV> BUILD_TABLE ( MAINTREE ) ; //<S2SV> if ( lzx -> MAINTREE_len [ 0xE8 ] != 0 ) lzx -> intel_started = 1 ; //<S2SV> READ_LENGTHS ( LENGTH , 0 , LZX_NUM_SECONDARY_LENGTHS ) ; //<S2SV> BUILD_TABLE_MAYBE_EMPTY ( LENGTH ) ; //<S2SV> break ; //<S2SV> case LZX_BLOCKTYPE_UNCOMPRESSED : //<S2SV> lzx -> intel_started = 1 ; //<S2SV> ENSURE_BITS ( 16 ) ; //<S2SV> if ( bits_left > 16 ) i_ptr -= 2 ; //<S2SV> bits_left = 0 ; bit_buffer = 0 ; //<S2SV> for ( rundest = & buf [ 0 ] , i = 0 ; i < 12 ; i ++ ) { //<S2SV> READ_IF_NEEDED ; //<S2SV> * rundest ++ = * i_ptr ++ ; //<S2SV> } //<S2SV> R0 = buf [ 0 ] | ( buf [ 1 ] << 8 ) | ( buf [ 2 ] << 16 ) | ( buf [ 3 ] << 24 ) ; //<S2SV> R1 = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; //<S2SV> R2 = buf [ 8 ] | ( buf [ 9 ] << 8 ) | ( buf [ 10 ] << 16 ) | ( buf [ 11 ] << 24 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> D ( ( "bad<S2SV_blank>block<S2SV_blank>type" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> } //<S2SV> this_run = lzx -> block_remaining ; //<S2SV> if ( this_run > bytes_todo ) this_run = bytes_todo ; //<S2SV> bytes_todo -= this_run ; //<S2SV> lzx -> block_remaining -= this_run ; //<S2SV> switch ( lzx -> block_type ) { //<S2SV> case LZX_BLOCKTYPE_VERBATIM : //<S2SV> while ( this_run > 0 ) { //<S2SV> READ_HUFFSYM ( MAINTREE , main_element ) ; //<S2SV> if ( main_element < LZX_NUM_CHARS ) { //<S2SV> window [ window_posn ++ ] = main_element ; //<S2SV> this_run -- ; //<S2SV> } //<S2SV> else { //<S2SV> main_element -= LZX_NUM_CHARS ; //<S2SV> match_length = main_element & LZX_NUM_PRIMARY_LENGTHS ; //<S2SV> if ( match_length == LZX_NUM_PRIMARY_LENGTHS ) { //<S2SV> if ( lzx -> LENGTH_empty ) { //<S2SV> D ( ( "LENGTH<S2SV_blank>symbol<S2SV_blank>needed<S2SV_blank>but<S2SV_blank>tree<S2SV_blank>is<S2SV_blank>empty" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> READ_HUFFSYM ( LENGTH , length_footer ) ; //<S2SV> match_length += length_footer ; //<S2SV> } //<S2SV> match_length += LZX_MIN_MATCH ; //<S2SV> switch ( ( match_offset = ( main_element >> 3 ) ) ) { //<S2SV> case 0 : match_offset = R0 ; break ; //<S2SV> case 1 : match_offset = R1 ; R1 = R0 ; R0 = match_offset ; break ; //<S2SV> case 2 : match_offset = R2 ; R2 = R0 ; R0 = match_offset ; break ; //<S2SV> case 3 : match_offset = 1 ; R2 = R1 ; R1 = R0 ; R0 = match_offset ; break ; //<S2SV> default : //<S2SV> extra = ( match_offset >= 36 ) ? 17 : extra_bits [ match_offset ] ; //<S2SV> READ_BITS ( verbatim_bits , extra ) ; //<S2SV> match_offset = position_base [ match_offset ] - 2 + verbatim_bits ; //<S2SV> R2 = R1 ; R1 = R0 ; R0 = match_offset ; //<S2SV> } //<S2SV> if ( match_length == LZX_MAX_MATCH && lzx -> is_delta ) { //<S2SV> int extra_len = 0 ; //<S2SV> ENSURE_BITS ( 3 ) ; //<S2SV> if ( PEEK_BITS ( 1 ) == 0 ) { //<S2SV> REMOVE_BITS ( 1 ) ; //<S2SV> READ_BITS ( extra_len , 8 ) ; //<S2SV> } //<S2SV> else if ( PEEK_BITS ( 2 ) == 2 ) { //<S2SV> REMOVE_BITS ( 2 ) ; //<S2SV> READ_BITS ( extra_len , 10 ) ; //<S2SV> extra_len += 0x100 ; //<S2SV> } //<S2SV> else if ( PEEK_BITS ( 3 ) == 6 ) { //<S2SV> REMOVE_BITS ( 3 ) ; //<S2SV> READ_BITS ( extra_len , 12 ) ; //<S2SV> extra_len += 0x500 ; //<S2SV> } //<S2SV> else { //<S2SV> REMOVE_BITS ( 3 ) ; //<S2SV> READ_BITS ( extra_len , 15 ) ; //<S2SV> } //<S2SV> match_length += extra_len ; //<S2SV> } //<S2SV> if ( ( window_posn + match_length ) > lzx -> window_size ) { //<S2SV> D ( ( "match<S2SV_blank>ran<S2SV_blank>over<S2SV_blank>window<S2SV_blank>wrap" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> rundest = & window [ window_posn ] ; //<S2SV> i = match_length ; //<S2SV> if ( match_offset > window_posn ) { //<S2SV> if ( match_offset > lzx -> offset && //<S2SV> ( match_offset - window_posn ) > lzx -> ref_data_size ) //<S2SV> { //<S2SV> D ( ( "match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>LZX<S2SV_blank>stream" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> j = match_offset - window_posn ; //<S2SV> if ( j > ( int ) lzx -> window_size ) { //<S2SV> D ( ( "match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>window<S2SV_blank>boundaries" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> runsrc = & window [ lzx -> window_size - j ] ; //<S2SV> if ( j < i ) { //<S2SV> i -= j ; while ( j -- > 0 ) * rundest ++ = * runsrc ++ ; //<S2SV> runsrc = window ; //<S2SV> } //<S2SV> while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; //<S2SV> } //<S2SV> else { //<S2SV> runsrc = rundest - match_offset ; //<S2SV> while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; //<S2SV> } //<S2SV> this_run -= match_length ; //<S2SV> window_posn += match_length ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case LZX_BLOCKTYPE_ALIGNED : //<S2SV> while ( this_run > 0 ) { //<S2SV> READ_HUFFSYM ( MAINTREE , main_element ) ; //<S2SV> if ( main_element < LZX_NUM_CHARS ) { //<S2SV> window [ window_posn ++ ] = main_element ; //<S2SV> this_run -- ; //<S2SV> } //<S2SV> else { //<S2SV> main_element -= LZX_NUM_CHARS ; //<S2SV> match_length = main_element & LZX_NUM_PRIMARY_LENGTHS ; //<S2SV> if ( match_length == LZX_NUM_PRIMARY_LENGTHS ) { //<S2SV> if ( lzx -> LENGTH_empty ) { //<S2SV> D ( ( "LENGTH<S2SV_blank>symbol<S2SV_blank>needed<S2SV_blank>but<S2SV_blank>tree<S2SV_blank>is<S2SV_blank>empty" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> READ_HUFFSYM ( LENGTH , length_footer ) ; //<S2SV> match_length += length_footer ; //<S2SV> } //<S2SV> match_length += LZX_MIN_MATCH ; //<S2SV> switch ( ( match_offset = ( main_element >> 3 ) ) ) { //<S2SV> case 0 : match_offset = R0 ; break ; //<S2SV> case 1 : match_offset = R1 ; R1 = R0 ; R0 = match_offset ; break ; //<S2SV> case 2 : match_offset = R2 ; R2 = R0 ; R0 = match_offset ; break ; //<S2SV> default : //<S2SV> extra = ( match_offset >= 36 ) ? 17 : extra_bits [ match_offset ] ; //<S2SV> match_offset = position_base [ match_offset ] - 2 ; //<S2SV> if ( extra > 3 ) { //<S2SV> extra -= 3 ; //<S2SV> READ_BITS ( verbatim_bits , extra ) ; //<S2SV> match_offset += ( verbatim_bits << 3 ) ; //<S2SV> READ_HUFFSYM ( ALIGNED , aligned_bits ) ; //<S2SV> match_offset += aligned_bits ; //<S2SV> } //<S2SV> else if ( extra == 3 ) { //<S2SV> READ_HUFFSYM ( ALIGNED , aligned_bits ) ; //<S2SV> match_offset += aligned_bits ; //<S2SV> } //<S2SV> else if ( extra > 0 ) { //<S2SV> READ_BITS ( verbatim_bits , extra ) ; //<S2SV> match_offset += verbatim_bits ; //<S2SV> } //<S2SV> else { //<S2SV> match_offset = 1 ; //<S2SV> } //<S2SV> R2 = R1 ; R1 = R0 ; R0 = match_offset ; //<S2SV> } //<S2SV> if ( match_length == LZX_MAX_MATCH && lzx -> is_delta ) { //<S2SV> int extra_len = 0 ; //<S2SV> ENSURE_BITS ( 3 ) ; //<S2SV> if ( PEEK_BITS ( 1 ) == 0 ) { //<S2SV> REMOVE_BITS ( 1 ) ; //<S2SV> READ_BITS ( extra_len , 8 ) ; //<S2SV> } //<S2SV> else if ( PEEK_BITS ( 2 ) == 2 ) { //<S2SV> REMOVE_BITS ( 2 ) ; //<S2SV> READ_BITS ( extra_len , 10 ) ; //<S2SV> extra_len += 0x100 ; //<S2SV> } //<S2SV> else if ( PEEK_BITS ( 3 ) == 6 ) { //<S2SV> REMOVE_BITS ( 3 ) ; //<S2SV> READ_BITS ( extra_len , 12 ) ; //<S2SV> extra_len += 0x500 ; //<S2SV> } //<S2SV> else { //<S2SV> REMOVE_BITS ( 3 ) ; //<S2SV> READ_BITS ( extra_len , 15 ) ; //<S2SV> } //<S2SV> match_length += extra_len ; //<S2SV> } //<S2SV> if ( ( window_posn + match_length ) > lzx -> window_size ) { //<S2SV> D ( ( "match<S2SV_blank>ran<S2SV_blank>over<S2SV_blank>window<S2SV_blank>wrap" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> rundest = & window [ window_posn ] ; //<S2SV> i = match_length ; //<S2SV> if ( match_offset > window_posn ) { //<S2SV> if ( match_offset > lzx -> offset && //<S2SV> ( match_offset - window_posn ) > lzx -> ref_data_size ) //<S2SV> { //<S2SV> D ( ( "match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>LZX<S2SV_blank>stream" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> j = match_offset - window_posn ; //<S2SV> if ( j > ( int ) lzx -> window_size ) { //<S2SV> D ( ( "match<S2SV_blank>offset<S2SV_blank>beyond<S2SV_blank>window<S2SV_blank>boundaries" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> runsrc = & window [ lzx -> window_size - j ] ; //<S2SV> if ( j < i ) { //<S2SV> i -= j ; while ( j -- > 0 ) * rundest ++ = * runsrc ++ ; //<S2SV> runsrc = window ; //<S2SV> } //<S2SV> while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; //<S2SV> } //<S2SV> else { //<S2SV> runsrc = rundest - match_offset ; //<S2SV> while ( i -- > 0 ) * rundest ++ = * runsrc ++ ; //<S2SV> } //<S2SV> this_run -= match_length ; //<S2SV> window_posn += match_length ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case LZX_BLOCKTYPE_UNCOMPRESSED : //<S2SV> rundest = & window [ window_posn ] ; //<S2SV> window_posn += this_run ; //<S2SV> while ( this_run > 0 ) { //<S2SV> if ( ( i = i_end - i_ptr ) == 0 ) { //<S2SV> READ_IF_NEEDED ; //<S2SV> } //<S2SV> else { //<S2SV> if ( i > this_run ) i = this_run ; //<S2SV> lzx -> sys -> copy ( i_ptr , rundest , ( size_t ) i ) ; //<S2SV> rundest += i ; //<S2SV> i_ptr += i ; //<S2SV> this_run -= i ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> if ( this_run < 0 ) { //<S2SV> if ( ( unsigned int ) ( - this_run ) > lzx -> block_remaining ) { //<S2SV> D ( ( "overrun<S2SV_blank>went<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>block<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>(%d<S2SV_blank>remaining)" , //<S2SV> - this_run , lzx -> block_remaining ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> lzx -> block_remaining -= - this_run ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( window_posn - lzx -> frame_posn ) != frame_size ) { //<S2SV> D ( ( "decode<S2SV_blank>beyond<S2SV_blank>output<S2SV_blank>frame<S2SV_blank>limits!<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d" , //<S2SV> window_posn - lzx -> frame_posn , frame_size ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> if ( bits_left > 0 ) ENSURE_BITS ( 16 ) ; //<S2SV> if ( bits_left & 15 ) REMOVE_BITS ( bits_left & 15 ) ; //<S2SV> if ( lzx -> o_ptr != lzx -> o_end ) { //<S2SV> D ( ( "%ld<S2SV_blank>avail<S2SV_blank>bytes,<S2SV_blank>new<S2SV_blank>%d<S2SV_blank>frame" , //<S2SV> ( long ) ( lzx -> o_end - lzx -> o_ptr ) , frame_size ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> if ( lzx -> intel_started && lzx -> intel_filesize && //<S2SV> ( lzx -> frame <= 32768 ) && ( frame_size > 10 ) ) //<S2SV> { //<S2SV> unsigned char * data = & lzx -> e8_buf [ 0 ] ; //<S2SV> unsigned char * dataend = & lzx -> e8_buf [ frame_size - 10 ] ; //<S2SV> signed int curpos = lzx -> intel_curpos ; //<S2SV> signed int filesize = lzx -> intel_filesize ; //<S2SV> signed int abs_off , rel_off ; //<S2SV> lzx -> o_ptr = data ; //<S2SV> lzx -> sys -> copy ( & lzx -> window [ lzx -> frame_posn ] , data , frame_size ) ; //<S2SV> while ( data < dataend ) { //<S2SV> if ( * data ++ != 0xE8 ) { curpos ++ ; continue ; } //<S2SV> abs_off = data [ 0 ] | ( data [ 1 ] << 8 ) | ( data [ 2 ] << 16 ) | ( data [ 3 ] << 24 ) ; //<S2SV> if ( ( abs_off >= - curpos ) && ( abs_off < filesize ) ) { //<S2SV> rel_off = ( abs_off >= 0 ) ? abs_off - curpos : abs_off + filesize ; //<S2SV> data [ 0 ] = ( unsigned char ) rel_off ; //<S2SV> data [ 1 ] = ( unsigned char ) ( rel_off >> 8 ) ; //<S2SV> data [ 2 ] = ( unsigned char ) ( rel_off >> 16 ) ; //<S2SV> data [ 3 ] = ( unsigned char ) ( rel_off >> 24 ) ; //<S2SV> } //<S2SV> data += 4 ; //<S2SV> curpos += 5 ; //<S2SV> } //<S2SV> lzx -> intel_curpos += frame_size ; //<S2SV> } //<S2SV> else { //<S2SV> lzx -> o_ptr = & lzx -> window [ lzx -> frame_posn ] ; //<S2SV> if ( lzx -> intel_filesize ) lzx -> intel_curpos += frame_size ; //<S2SV> } //<S2SV> lzx -> o_end = & lzx -> o_ptr [ frame_size ] ; //<S2SV> i = ( out_bytes < ( off_t ) frame_size ) ? ( unsigned int ) out_bytes : frame_size ; //<S2SV> if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { //<S2SV> return lzx -> error = MSPACK_ERR_WRITE ; //<S2SV> } //<S2SV> lzx -> o_ptr += i ; //<S2SV> lzx -> offset += i ; //<S2SV> out_bytes -= i ; //<S2SV> lzx -> frame_posn += frame_size ; //<S2SV> lzx -> frame ++ ; //<S2SV> if ( window_posn == lzx -> window_size ) window_posn = 0 ; //<S2SV> if ( lzx -> frame_posn == lzx -> window_size ) lzx -> frame_posn = 0 ; //<S2SV> } //<S2SV> if ( out_bytes ) { //<S2SV> D ( ( "bytes<S2SV_blank>left<S2SV_blank>to<S2SV_blank>output" ) ) //<S2SV> return lzx -> error = MSPACK_ERR_DECRUNCH ; //<S2SV> } //<S2SV> STORE_BITS ; //<S2SV> lzx -> window_posn = window_posn ; //<S2SV> lzx -> R0 = R0 ; //<S2SV> lzx -> R1 = R1 ; //<S2SV> lzx -> R2 = R2 ; //<S2SV> return MSPACK_ERR_OK ; //<S2SV> } //<S2SV> 