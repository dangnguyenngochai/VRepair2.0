static void //<S2SV> dispatch_cmd ( conn c ) //<S2SV> { //<S2SV> int r , i , timeout = - 1 ; //<S2SV> size_t z ; //<S2SV> unsigned int count ; //<S2SV> job j ; //<S2SV> unsigned char type ; //<S2SV> char * size_buf , * delay_buf , * ttr_buf , * pri_buf , * end_buf , * name ; //<S2SV> unsigned int pri , body_size ; //<S2SV> usec delay , ttr ; //<S2SV> uint64_t id ; //<S2SV> tube t = NULL ; //<S2SV> c -> cmd [ c -> cmd_len - 2 ] = '\\0' ; //<S2SV> if ( strlen ( c -> cmd ) != c -> cmd_len - 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> type = which_cmd ( c ) ; //<S2SV> dprintf ( "got<S2SV_blank>%s<S2SV_blank>command:<S2SV_blank>\\"%s\\"\\n" , op_names [ ( int ) type ] , c -> cmd ) ; //<S2SV> switch ( type ) { //<S2SV> case OP_PUT : //<S2SV> r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ; //<S2SV> if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> r = read_delay ( & delay , delay_buf , & ttr_buf ) ; //<S2SV> if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> r = read_ttr ( & ttr , ttr_buf , & size_buf ) ; //<S2SV> if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> errno = 0 ; //<S2SV> body_size = strtoul ( size_buf , & end_buf , 10 ) ; //<S2SV> if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> if ( body_size > job_data_size_limit ) { //<S2SV> return reply_msg ( c , MSG_JOB_TOO_BIG ) ; //<S2SV> } //<S2SV> if ( end_buf [ 0 ] != '\\0' ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> conn_set_producer ( c ) ; //<S2SV> c -> in_job = make_job ( pri , delay , ttr ? : 1 , body_size + 2 , c -> use ) ; //<S2SV> if ( ! c -> in_job ) { //<S2SV> twarnx ( "server<S2SV_blank>error:<S2SV_blank>" MSG_OUT_OF_MEMORY ) ; //<S2SV> return skip ( c , body_size + 2 , MSG_OUT_OF_MEMORY ) ; //<S2SV> } //<S2SV> fill_extra_data ( c ) ; //<S2SV> maybe_enqueue_incoming_job ( c ) ; //<S2SV> break ; //<S2SV> case OP_PEEK_READY : //<S2SV> if ( c -> cmd_len != CMD_PEEK_READY_LEN + 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = job_copy ( pq_peek ( & c -> use -> ready ) ) ; //<S2SV> if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> reply_job ( c , j , MSG_FOUND ) ; //<S2SV> break ; //<S2SV> case OP_PEEK_DELAYED : //<S2SV> if ( c -> cmd_len != CMD_PEEK_DELAYED_LEN + 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = job_copy ( pq_peek ( & c -> use -> delay ) ) ; //<S2SV> if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> reply_job ( c , j , MSG_FOUND ) ; //<S2SV> break ; //<S2SV> case OP_PEEK_BURIED : //<S2SV> if ( c -> cmd_len != CMD_PEEK_BURIED_LEN + 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = job_copy ( buried_job_p ( c -> use ) ? j = c -> use -> buried . next : NULL ) ; //<S2SV> if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> reply_job ( c , j , MSG_FOUND ) ; //<S2SV> break ; //<S2SV> case OP_PEEKJOB : //<S2SV> errno = 0 ; //<S2SV> id = strtoull ( c -> cmd + CMD_PEEKJOB_LEN , & end_buf , 10 ) ; //<S2SV> if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = job_copy ( peek_job ( id ) ) ; //<S2SV> if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> reply_job ( c , j , MSG_FOUND ) ; //<S2SV> break ; //<S2SV> case OP_RESERVE_TIMEOUT : //<S2SV> errno = 0 ; //<S2SV> timeout = strtol ( c -> cmd + CMD_RESERVE_TIMEOUT_LEN , & end_buf , 10 ) ; //<S2SV> if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> case OP_RESERVE : //<S2SV> if ( type == OP_RESERVE && c -> cmd_len != CMD_RESERVE_LEN + 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> op_ct [ type ] ++ ; //<S2SV> conn_set_worker ( c ) ; //<S2SV> if ( conn_has_close_deadline ( c ) && ! conn_ready ( c ) ) { //<S2SV> return reply_msg ( c , MSG_DEADLINE_SOON ) ; //<S2SV> } //<S2SV> wait_for_job ( c , timeout ) ; //<S2SV> process_queue ( ) ; //<S2SV> break ; //<S2SV> case OP_DELETE : //<S2SV> errno = 0 ; //<S2SV> id = strtoull ( c -> cmd + CMD_DELETE_LEN , & end_buf , 10 ) ; //<S2SV> if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = job_find ( id ) ; //<S2SV> j = remove_reserved_job ( c , j ) ? : //<S2SV> remove_ready_job ( j ) ? : //<S2SV> remove_buried_job ( j ) ; //<S2SV> if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> j -> state = JOB_STATE_INVALID ; //<S2SV> r = binlog_write_job ( j ) ; //<S2SV> job_free ( j ) ; //<S2SV> if ( ! r ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; //<S2SV> reply ( c , MSG_DELETED , MSG_DELETED_LEN , STATE_SENDWORD ) ; //<S2SV> break ; //<S2SV> case OP_RELEASE : //<S2SV> errno = 0 ; //<S2SV> id = strtoull ( c -> cmd + CMD_RELEASE_LEN , & pri_buf , 10 ) ; //<S2SV> if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> r = read_pri ( & pri , pri_buf , & delay_buf ) ; //<S2SV> if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> r = read_delay ( & delay , delay_buf , NULL ) ; //<S2SV> if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = remove_reserved_job ( c , job_find ( id ) ) ; //<S2SV> if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> if ( delay ) { //<S2SV> z = binlog_reserve_space_update ( j ) ; //<S2SV> if ( ! z ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; //<S2SV> j -> reserved_binlog_space += z ; //<S2SV> } //<S2SV> j -> pri = pri ; //<S2SV> j -> delay = delay ; //<S2SV> j -> release_ct ++ ; //<S2SV> r = enqueue_job ( j , delay , ! ! delay ) ; //<S2SV> if ( r < 0 ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; //<S2SV> if ( r == 1 ) { //<S2SV> return reply ( c , MSG_RELEASED , MSG_RELEASED_LEN , STATE_SENDWORD ) ; //<S2SV> } //<S2SV> bury_job ( j , 0 ) ; //<S2SV> reply ( c , MSG_BURIED , MSG_BURIED_LEN , STATE_SENDWORD ) ; //<S2SV> break ; //<S2SV> case OP_BURY : //<S2SV> errno = 0 ; //<S2SV> id = strtoull ( c -> cmd + CMD_BURY_LEN , & pri_buf , 10 ) ; //<S2SV> if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> r = read_pri ( & pri , pri_buf , NULL ) ; //<S2SV> if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = remove_reserved_job ( c , job_find ( id ) ) ; //<S2SV> if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> j -> pri = pri ; //<S2SV> r = bury_job ( j , 1 ) ; //<S2SV> if ( ! r ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; //<S2SV> reply ( c , MSG_BURIED , MSG_BURIED_LEN , STATE_SENDWORD ) ; //<S2SV> break ; //<S2SV> case OP_KICK : //<S2SV> errno = 0 ; //<S2SV> count = strtoul ( c -> cmd + CMD_KICK_LEN , & end_buf , 10 ) ; //<S2SV> if ( end_buf == c -> cmd + CMD_KICK_LEN ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> i = kick_jobs ( c -> use , count ) ; //<S2SV> return reply_line ( c , STATE_SENDWORD , "KICKED<S2SV_blank>%u\\r\\n" , i ) ; //<S2SV> case OP_TOUCH : //<S2SV> errno = 0 ; //<S2SV> id = strtoull ( c -> cmd + CMD_TOUCH_LEN , & end_buf , 10 ) ; //<S2SV> if ( errno ) return twarn ( "strtoull" ) , reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = touch_job ( c , job_find ( id ) ) ; //<S2SV> if ( j ) { //<S2SV> reply ( c , MSG_TOUCHED , MSG_TOUCHED_LEN , STATE_SENDWORD ) ; //<S2SV> } else { //<S2SV> return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case OP_STATS : //<S2SV> if ( c -> cmd_len != CMD_STATS_LEN + 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> op_ct [ type ] ++ ; //<S2SV> do_stats ( c , fmt_stats , NULL ) ; //<S2SV> break ; //<S2SV> case OP_JOBSTATS : //<S2SV> errno = 0 ; //<S2SV> id = strtoull ( c -> cmd + CMD_JOBSTATS_LEN , & end_buf , 10 ) ; //<S2SV> if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> j = peek_job ( id ) ; //<S2SV> if ( ! j ) return reply ( c , MSG_NOTFOUND , MSG_NOTFOUND_LEN , STATE_SENDWORD ) ; //<S2SV> if ( ! j -> tube ) return reply_serr ( c , MSG_INTERNAL_ERROR ) ; //<S2SV> do_stats ( c , ( fmt_fn ) fmt_job_stats , j ) ; //<S2SV> break ; //<S2SV> case OP_STATS_TUBE : //<S2SV> name = c -> cmd + CMD_STATS_TUBE_LEN ; //<S2SV> if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> t = tube_find ( name ) ; //<S2SV> if ( ! t ) return reply_msg ( c , MSG_NOTFOUND ) ; //<S2SV> do_stats ( c , ( fmt_fn ) fmt_stats_tube , t ) ; //<S2SV> t = NULL ; //<S2SV> break ; //<S2SV> case OP_LIST_TUBES : //<S2SV> if ( c -> cmd_len != CMD_LIST_TUBES_LEN + 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> op_ct [ type ] ++ ; //<S2SV> do_list_tubes ( c , & tubes ) ; //<S2SV> break ; //<S2SV> case OP_LIST_TUBE_USED : //<S2SV> if ( c -> cmd_len != CMD_LIST_TUBE_USED_LEN + 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> op_ct [ type ] ++ ; //<S2SV> reply_line ( c , STATE_SENDWORD , "USING<S2SV_blank>%s\\r\\n" , c -> use -> name ) ; //<S2SV> break ; //<S2SV> case OP_LIST_TUBES_WATCHED : //<S2SV> if ( c -> cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2 ) { //<S2SV> return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> } //<S2SV> op_ct [ type ] ++ ; //<S2SV> do_list_tubes ( c , & c -> watch ) ; //<S2SV> break ; //<S2SV> case OP_USE : //<S2SV> name = c -> cmd + CMD_USE_LEN ; //<S2SV> if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> TUBE_ASSIGN ( t , tube_find_or_make ( name ) ) ; //<S2SV> if ( ! t ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; //<S2SV> c -> use -> using_ct -- ; //<S2SV> TUBE_ASSIGN ( c -> use , t ) ; //<S2SV> TUBE_ASSIGN ( t , NULL ) ; //<S2SV> c -> use -> using_ct ++ ; //<S2SV> reply_line ( c , STATE_SENDWORD , "USING<S2SV_blank>%s\\r\\n" , c -> use -> name ) ; //<S2SV> break ; //<S2SV> case OP_WATCH : //<S2SV> name = c -> cmd + CMD_WATCH_LEN ; //<S2SV> if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> TUBE_ASSIGN ( t , tube_find_or_make ( name ) ) ; //<S2SV> if ( ! t ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; //<S2SV> r = 1 ; //<S2SV> if ( ! ms_contains ( & c -> watch , t ) ) r = ms_append ( & c -> watch , t ) ; //<S2SV> TUBE_ASSIGN ( t , NULL ) ; //<S2SV> if ( ! r ) return reply_serr ( c , MSG_OUT_OF_MEMORY ) ; //<S2SV> reply_line ( c , STATE_SENDWORD , "WATCHING<S2SV_blank>%d\\r\\n" , c -> watch . used ) ; //<S2SV> break ; //<S2SV> case OP_IGNORE : //<S2SV> name = c -> cmd + CMD_IGNORE_LEN ; //<S2SV> if ( ! name_is_ok ( name , 200 ) ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> op_ct [ type ] ++ ; //<S2SV> t = NULL ; //<S2SV> for ( i = 0 ; i < c -> watch . used ; i ++ ) { //<S2SV> t = c -> watch . items [ i ] ; //<S2SV> if ( strncmp ( t -> name , name , MAX_TUBE_NAME_LEN ) == 0 ) break ; //<S2SV> t = NULL ; //<S2SV> } //<S2SV> if ( t && c -> watch . used < 2 ) return reply_msg ( c , MSG_NOT_IGNORED ) ; //<S2SV> if ( t ) ms_remove ( & c -> watch , t ) ; //<S2SV> t = NULL ; //<S2SV> reply_line ( c , STATE_SENDWORD , "WATCHING<S2SV_blank>%d\\r\\n" , c -> watch . used ) ; //<S2SV> break ; //<S2SV> case OP_QUIT : //<S2SV> conn_close ( c ) ; //<S2SV> break ; //<S2SV> case OP_PAUSE_TUBE : //<S2SV> op_ct [ type ] ++ ; //<S2SV> r = read_tube_name ( & name , c -> cmd + CMD_PAUSE_TUBE_LEN , & delay_buf ) ; //<S2SV> if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> r = read_delay ( & delay , delay_buf , NULL ) ; //<S2SV> if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; //<S2SV> * delay_buf = '\\0' ; //<S2SV> t = tube_find ( name ) ; //<S2SV> if ( ! t ) return reply_msg ( c , MSG_NOTFOUND ) ; //<S2SV> t -> deadline_at = now_usec ( ) + delay ; //<S2SV> t -> pause = delay ; //<S2SV> t -> stat . pause_ct ++ ; //<S2SV> set_main_delay_timeout ( ) ; //<S2SV> reply_line ( c , STATE_SENDWORD , "PAUSED\\r\\n" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> return reply_msg ( c , MSG_UNKNOWN_COMMAND ) ; //<S2SV> } //<S2SV> } //<S2SV> 