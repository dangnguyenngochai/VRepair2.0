NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) //<S2SV> { //<S2SV> PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; //<S2SV> NTSTATUS ntStatus ; //<S2SV> switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) //<S2SV> { //<S2SV> case TC_IOCTL_GET_DRIVER_VERSION : //<S2SV> case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) //<S2SV> { //<S2SV> LONG tmp = VERSION_NUM ; //<S2SV> memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; //<S2SV> Irp -> IoStatus . Information = sizeof ( LONG ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_DEVICE_REFCOUNT : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) //<S2SV> { //<S2SV> * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; //<S2SV> Irp -> IoStatus . Information = sizeof ( int ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) //<S2SV> { //<S2SV> LONG deviceObjectCount = 0 ; //<S2SV> * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; //<S2SV> if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) //<S2SV> * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; //<S2SV> Irp -> IoStatus . Information = sizeof ( int ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) //<S2SV> { //<S2SV> int drive ; //<S2SV> * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; //<S2SV> for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) //<S2SV> { //<S2SV> if ( GetVirtualVolumeDeviceObject ( drive ) ) //<S2SV> { //<S2SV> * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( IsBootDriveMounted ( ) ) //<S2SV> * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 1 ; //<S2SV> Irp -> IoStatus . Information = sizeof ( int ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_OPEN_TEST : //<S2SV> { //<S2SV> OPEN_TEST_STRUCT * opentest = ( OPEN_TEST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> OBJECT_ATTRIBUTES ObjectAttributes ; //<S2SV> HANDLE NtFileHandle ; //<S2SV> UNICODE_STRING FullFileName ; //<S2SV> IO_STATUS_BLOCK IoStatus ; //<S2SV> LARGE_INTEGER offset ; //<S2SV> ACCESS_MASK access = FILE_READ_ATTRIBUTES ; //<S2SV> if ( ! ValidateIOBufferSize ( Irp , sizeof ( OPEN_TEST_STRUCT ) , ValidateInputOutput ) ) //<S2SV> break ; //<S2SV> EnsureNullTerminatedString ( opentest -> wszFileName , sizeof ( opentest -> wszFileName ) ) ; //<S2SV> RtlInitUnicodeString ( & FullFileName , opentest -> wszFileName ) ; //<S2SV> InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; //<S2SV> if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) //<S2SV> access |= FILE_READ_DATA ; //<S2SV> ntStatus = ZwCreateFile ( & NtFileHandle , //<S2SV> SYNCHRONIZE | access , & ObjectAttributes , & IoStatus , NULL , //<S2SV> 0 , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT , NULL , 0 ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> opentest -> TCBootLoaderDetected = FALSE ; //<S2SV> opentest -> FilesystemDetected = FALSE ; //<S2SV> memset ( opentest -> VolumeIDComputed , 0 , sizeof ( opentest -> VolumeIDComputed ) ) ; //<S2SV> memset ( opentest -> volumeIDs , 0 , sizeof ( opentest -> volumeIDs ) ) ; //<S2SV> if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem || opentest -> bComputeVolumeIDs ) //<S2SV> { //<S2SV> byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; //<S2SV> if ( ! readBuffer ) //<S2SV> { //<S2SV> ntStatus = STATUS_INSUFFICIENT_RESOURCES ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( opentest -> bDetectTCBootLoader || opentest -> DetectFilesystem ) //<S2SV> { //<S2SV> offset . QuadPart = 0 ; //<S2SV> ntStatus = ZwReadFile ( NtFileHandle , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> & IoStatus , //<S2SV> readBuffer , //<S2SV> TC_MAX_VOLUME_SECTOR_SIZE , //<S2SV> & offset , //<S2SV> NULL ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> size_t i ; //<S2SV> if ( opentest -> bDetectTCBootLoader && IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) //<S2SV> { //<S2SV> for ( i = 0 ; i < TC_SECTOR_SIZE_BIOS - strlen ( TC_APP_NAME ) ; ++ i ) //<S2SV> { //<S2SV> if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) //<S2SV> { //<S2SV> opentest -> TCBootLoaderDetected = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( opentest -> DetectFilesystem && IoStatus . Information >= sizeof ( int64 ) ) //<S2SV> { //<S2SV> switch ( BE64 ( * ( uint64 * ) readBuffer ) ) //<S2SV> { //<S2SV> case 0xEB52904E54465320ULL : //<S2SV> case 0xEB3C904D53444F53ULL : //<S2SV> case 0xEB58904D53444F53ULL : //<S2SV> case 0xEB76904558464154ULL : //<S2SV> case 0x0000005265465300ULL : //<S2SV> case 0xEB58906D6B66732EULL : //<S2SV> case 0xEB58906D6B646F73ULL : //<S2SV> case 0xEB3C906D6B66732EULL : //<S2SV> case 0xEB3C906D6B646F73ULL : //<S2SV> opentest -> FilesystemDetected = TRUE ; //<S2SV> break ; //<S2SV> case 0x0000000000000000ULL : //<S2SV> if ( IsAllZeroes ( readBuffer + 8 , TC_VOLUME_HEADER_EFFECTIVE_SIZE - 8 ) ) //<S2SV> opentest -> FilesystemDetected = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( opentest -> bComputeVolumeIDs && ( ! opentest -> DetectFilesystem || ! opentest -> FilesystemDetected ) ) //<S2SV> { //<S2SV> int volumeType ; //<S2SV> for ( volumeType = TC_VOLUME_TYPE_NORMAL ; //<S2SV> volumeType < TC_VOLUME_TYPE_COUNT ; //<S2SV> volumeType ++ ) //<S2SV> { //<S2SV> switch ( volumeType ) //<S2SV> { //<S2SV> case TC_VOLUME_TYPE_NORMAL : //<S2SV> offset . QuadPart = TC_VOLUME_HEADER_OFFSET ; //<S2SV> break ; //<S2SV> case TC_VOLUME_TYPE_HIDDEN : //<S2SV> offset . QuadPart = TC_HIDDEN_VOLUME_HEADER_OFFSET ; //<S2SV> break ; //<S2SV> } //<S2SV> ntStatus = ZwReadFile ( NtFileHandle , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> & IoStatus , //<S2SV> readBuffer , //<S2SV> TC_MAX_VOLUME_SECTOR_SIZE , //<S2SV> & offset , //<S2SV> NULL ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> sha256 ( opentest -> volumeIDs [ volumeType ] , readBuffer , TC_VOLUME_HEADER_EFFECTIVE_SIZE ) ; //<S2SV> opentest -> VolumeIDComputed [ volumeType ] = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> TCfree ( readBuffer ) ; //<S2SV> } //<S2SV> } //<S2SV> ZwClose ( NtFileHandle ) ; //<S2SV> Dump ( "Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>success.\\n" , opentest -> wszFileName ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> # if 0 //<S2SV> Dump ( "Open<S2SV_blank>test<S2SV_blank>on<S2SV_blank>file<S2SV_blank>%ls<S2SV_blank>failed<S2SV_blank>NTSTATUS<S2SV_blank>0x%08x\\n" , opentest -> wszFileName , ntStatus ) ; //<S2SV> # endif //<S2SV> } //<S2SV> Irp -> IoStatus . Information = NT_SUCCESS ( ntStatus ) ? sizeof ( OPEN_TEST_STRUCT ) : 0 ; //<S2SV> Irp -> IoStatus . Status = ntStatus ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_SYSTEM_DRIVE_CONFIG : //<S2SV> { //<S2SV> GetSystemDriveConfigurationRequest * request = ( GetSystemDriveConfigurationRequest * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> OBJECT_ATTRIBUTES ObjectAttributes ; //<S2SV> HANDLE NtFileHandle ; //<S2SV> UNICODE_STRING FullFileName ; //<S2SV> IO_STATUS_BLOCK IoStatus ; //<S2SV> LARGE_INTEGER offset ; //<S2SV> size_t devicePathLen = 0 ; //<S2SV> if ( ! ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveConfigurationRequest ) , ValidateInputOutput ) ) //<S2SV> break ; //<S2SV> if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) //<S2SV> || ( devicePathLen < 28 ) //<S2SV> || ( devicePathLen > 30 ) //<S2SV> || ( memcmp ( request -> DevicePath , L"\\\\Device\\\\Harddisk" , 16 * sizeof ( WCHAR ) ) ) //<S2SV> || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L"\\\\Partition0" , 11 * sizeof ( WCHAR ) ) ) //<S2SV> ) //<S2SV> { //<S2SV> Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> EnsureNullTerminatedString ( request -> DevicePath , sizeof ( request -> DevicePath ) ) ; //<S2SV> RtlInitUnicodeString ( & FullFileName , request -> DevicePath ) ; //<S2SV> InitializeObjectAttributes ( & ObjectAttributes , & FullFileName , OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE , NULL , NULL ) ; //<S2SV> ntStatus = ZwCreateFile ( & NtFileHandle , //<S2SV> SYNCHRONIZE | GENERIC_READ , & ObjectAttributes , & IoStatus , NULL , //<S2SV> FILE_ATTRIBUTE_NORMAL , FILE_SHARE_READ | FILE_SHARE_WRITE , FILE_OPEN , FILE_SYNCHRONOUS_IO_NONALERT | FILE_RANDOM_ACCESS , NULL , 0 ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; //<S2SV> if ( ! readBuffer ) //<S2SV> { //<S2SV> Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> offset . QuadPart = 0 ; //<S2SV> ntStatus = ZwReadFile ( NtFileHandle , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> & IoStatus , //<S2SV> readBuffer , //<S2SV> TC_MAX_VOLUME_SECTOR_SIZE , //<S2SV> & offset , //<S2SV> NULL ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS ) //<S2SV> { //<S2SV> size_t i ; //<S2SV> request -> DriveIsDynamic = FALSE ; //<S2SV> if ( readBuffer [ 510 ] == 0x55 && readBuffer [ 511 ] == 0xaa ) //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < 4 ; ++ i ) //<S2SV> { //<S2SV> if ( readBuffer [ 446 + i * 16 + 4 ] == PARTITION_LDM ) //<S2SV> { //<S2SV> request -> DriveIsDynamic = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> request -> BootLoaderVersion = 0 ; //<S2SV> request -> Configuration = 0 ; //<S2SV> request -> UserConfiguration = 0 ; //<S2SV> request -> CustomUserMessage [ 0 ] = 0 ; //<S2SV> for ( i = 0 ; i < sizeof ( readBuffer ) - strlen ( TC_APP_NAME ) ; ++ i ) //<S2SV> { //<S2SV> if ( memcmp ( readBuffer + i , TC_APP_NAME , strlen ( TC_APP_NAME ) ) == 0 ) //<S2SV> { //<S2SV> request -> BootLoaderVersion = BE16 ( * ( uint16 * ) ( readBuffer + TC_BOOT_SECTOR_VERSION_OFFSET ) ) ; //<S2SV> request -> Configuration = readBuffer [ TC_BOOT_SECTOR_CONFIG_OFFSET ] ; //<S2SV> if ( request -> BootLoaderVersion != 0 && request -> BootLoaderVersion <= VERSION_NUM ) //<S2SV> { //<S2SV> request -> UserConfiguration = readBuffer [ TC_BOOT_SECTOR_USER_CONFIG_OFFSET ] ; //<S2SV> memcpy ( request -> CustomUserMessage , readBuffer + TC_BOOT_SECTOR_USER_MESSAGE_OFFSET , TC_BOOT_SECTOR_USER_MESSAGE_MAX_LENGTH ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> Irp -> IoStatus . Information = sizeof ( * request ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Irp -> IoStatus . Status = ntStatus ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> } //<S2SV> TCfree ( readBuffer ) ; //<S2SV> } //<S2SV> ZwClose ( NtFileHandle ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Irp -> IoStatus . Status = ntStatus ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_WIPE_PASSWORD_CACHE : //<S2SV> WipeCache ( ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : //<S2SV> Irp -> IoStatus . Status = cacheEmpty ? STATUS_PIPE_EMPTY : STATUS_SUCCESS ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_SET_PORTABLE_MODE_STATUS : //<S2SV> if ( ! UserCanAccessDriveDevice ( ) ) //<S2SV> { //<S2SV> Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> PortableMode = TRUE ; //<S2SV> Dump ( "Setting<S2SV_blank>portable<S2SV_blank>mode\\n" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_PORTABLE_MODE_STATUS : //<S2SV> Irp -> IoStatus . Status = PortableMode ? STATUS_SUCCESS : STATUS_PIPE_EMPTY ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_MOUNTED_VOLUMES : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_LIST_STRUCT ) , ValidateOutput ) ) //<S2SV> { //<S2SV> MOUNT_LIST_STRUCT * list = ( MOUNT_LIST_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> PDEVICE_OBJECT ListDevice ; //<S2SV> int drive ; //<S2SV> list -> ulMountedDrives = 0 ; //<S2SV> for ( drive = MIN_MOUNTED_VOLUME_DRIVE_NUMBER ; drive <= MAX_MOUNTED_VOLUME_DRIVE_NUMBER ; ++ drive ) //<S2SV> { //<S2SV> PEXTENSION ListExtension ; //<S2SV> ListDevice = GetVirtualVolumeDeviceObject ( drive ) ; //<S2SV> if ( ! ListDevice ) //<S2SV> continue ; //<S2SV> ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; //<S2SV> if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) //<S2SV> { //<S2SV> list -> ulMountedDrives |= ( 1 << ListExtension -> nDosDriveNo ) ; //<S2SV> RtlStringCbCopyW ( list -> wszVolume [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszVolume [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszVolume ) ; //<S2SV> RtlStringCbCopyW ( list -> wszLabel [ ListExtension -> nDosDriveNo ] , sizeof ( list -> wszLabel [ ListExtension -> nDosDriveNo ] ) , ListExtension -> wszLabel ) ; //<S2SV> memcpy ( list -> volumeID [ ListExtension -> nDosDriveNo ] , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; //<S2SV> list -> diskLength [ ListExtension -> nDosDriveNo ] = ListExtension -> DiskLength ; //<S2SV> list -> ea [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> ea ; //<S2SV> if ( ListExtension -> cryptoInfo -> hiddenVolume ) //<S2SV> list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_HIDDEN ; //<S2SV> else if ( ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ) //<S2SV> list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER_VOL_WRITE_PREVENTED ; //<S2SV> else if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) //<S2SV> list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_OUTER ; //<S2SV> else //<S2SV> list -> volumeType [ ListExtension -> nDosDriveNo ] = PROP_VOL_TYPE_NORMAL ; //<S2SV> list -> truecryptMode [ ListExtension -> nDosDriveNo ] = ListExtension -> cryptoInfo -> bTrueCryptMode ; //<S2SV> } //<S2SV> } //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> Irp -> IoStatus . Information = sizeof ( MOUNT_LIST_STRUCT ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_LEGACY_GET_MOUNTED_VOLUMES : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( uint32 ) , ValidateOutput ) ) //<S2SV> { //<S2SV> memset ( Irp -> AssociatedIrp . SystemBuffer , 0 , irpSp -> Parameters . DeviceIoControl . OutputBufferLength ) ; //<S2SV> * ( uint32 * ) Irp -> AssociatedIrp . SystemBuffer = 0xffffFFFF ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> Irp -> IoStatus . Information = irpSp -> Parameters . DeviceIoControl . OutputBufferLength ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_VOLUME_PROPERTIES : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( VOLUME_PROPERTIES_STRUCT ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> VOLUME_PROPERTIES_STRUCT * prop = ( VOLUME_PROPERTIES_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( prop -> driveNo ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> if ( ListDevice ) //<S2SV> { //<S2SV> PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; //<S2SV> if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) //<S2SV> { //<S2SV> prop -> uniqueId = ListExtension -> UniqueVolumeId ; //<S2SV> RtlStringCbCopyW ( prop -> wszVolume , sizeof ( prop -> wszVolume ) , ListExtension -> wszVolume ) ; //<S2SV> RtlStringCbCopyW ( prop -> wszLabel , sizeof ( prop -> wszLabel ) , ListExtension -> wszLabel ) ; //<S2SV> memcpy ( prop -> volumeID , ListExtension -> volumeID , VOLUME_ID_SIZE ) ; //<S2SV> prop -> bDriverSetLabel = ListExtension -> bDriverSetLabel ; //<S2SV> prop -> diskLength = ListExtension -> DiskLength ; //<S2SV> prop -> ea = ListExtension -> cryptoInfo -> ea ; //<S2SV> prop -> mode = ListExtension -> cryptoInfo -> mode ; //<S2SV> prop -> pkcs5 = ListExtension -> cryptoInfo -> pkcs5 ; //<S2SV> prop -> pkcs5Iterations = ListExtension -> cryptoInfo -> noIterations ; //<S2SV> prop -> volumePim = ListExtension -> cryptoInfo -> volumePim ; //<S2SV> # if 0 //<S2SV> prop -> volumeCreationTime = ListExtension -> cryptoInfo -> volume_creation_time ; //<S2SV> prop -> headerCreationTime = ListExtension -> cryptoInfo -> header_creation_time ; //<S2SV> # endif //<S2SV> prop -> volumeHeaderFlags = ListExtension -> cryptoInfo -> HeaderFlags ; //<S2SV> prop -> readOnly = ListExtension -> bReadOnly ; //<S2SV> prop -> removable = ListExtension -> bRemovable ; //<S2SV> prop -> partitionInInactiveSysEncScope = ListExtension -> PartitionInInactiveSysEncScope ; //<S2SV> prop -> hiddenVolume = ListExtension -> cryptoInfo -> hiddenVolume ; //<S2SV> if ( ListExtension -> cryptoInfo -> bProtectHiddenVolume ) //<S2SV> prop -> hiddenVolProtection = ListExtension -> cryptoInfo -> bHiddenVolProtectionAction ? HIDVOL_PROT_STATUS_ACTION_TAKEN : HIDVOL_PROT_STATUS_ACTIVE ; //<S2SV> else //<S2SV> prop -> hiddenVolProtection = HIDVOL_PROT_STATUS_NONE ; //<S2SV> prop -> totalBytesRead = ListExtension -> Queue . TotalBytesRead ; //<S2SV> prop -> totalBytesWritten = ListExtension -> Queue . TotalBytesWritten ; //<S2SV> prop -> volFormatVersion = ListExtension -> cryptoInfo -> LegacyVolume ? TC_VOLUME_FORMAT_VERSION_PRE_6_0 : TC_VOLUME_FORMAT_VERSION ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> Irp -> IoStatus . Information = sizeof ( VOLUME_PROPERTIES_STRUCT ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_RESOLVED_SYMLINK : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( RESOLVE_SYMLINK_STRUCT ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> RESOLVE_SYMLINK_STRUCT * resolve = ( RESOLVE_SYMLINK_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> { //<S2SV> NTSTATUS ntStatus ; //<S2SV> EnsureNullTerminatedString ( resolve -> symLinkName , sizeof ( resolve -> symLinkName ) ) ; //<S2SV> ntStatus = SymbolicLinkToTarget ( resolve -> symLinkName , //<S2SV> resolve -> targetName , //<S2SV> sizeof ( resolve -> targetName ) ) ; //<S2SV> Irp -> IoStatus . Information = sizeof ( RESOLVE_SYMLINK_STRUCT ) ; //<S2SV> Irp -> IoStatus . Status = ntStatus ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_DRIVE_PARTITION_INFO : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_PARTITION_INFO_STRUCT ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> DISK_PARTITION_INFO_STRUCT * info = ( DISK_PARTITION_INFO_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> { //<S2SV> PARTITION_INFORMATION_EX pi ; //<S2SV> NTSTATUS ntStatus ; //<S2SV> EnsureNullTerminatedString ( info -> deviceName , sizeof ( info -> deviceName ) ) ; //<S2SV> ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO_EX , NULL , 0 , & pi , sizeof ( pi ) ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; //<S2SV> info -> partInfo . PartitionLength = pi . PartitionLength ; //<S2SV> info -> partInfo . PartitionNumber = pi . PartitionNumber ; //<S2SV> info -> partInfo . StartingOffset = pi . StartingOffset ; //<S2SV> if ( pi . PartitionStyle == PARTITION_STYLE_MBR ) //<S2SV> { //<S2SV> info -> partInfo . PartitionType = pi . Mbr . PartitionType ; //<S2SV> info -> partInfo . BootIndicator = pi . Mbr . BootIndicator ; //<S2SV> } //<S2SV> info -> IsGPT = pi . PartitionStyle == PARTITION_STYLE_GPT ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_PARTITION_INFO , NULL , 0 , & info -> partInfo , sizeof ( info -> partInfo ) ) ; //<S2SV> info -> IsGPT = FALSE ; //<S2SV> } //<S2SV> if ( ! NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> GET_LENGTH_INFORMATION lengthInfo ; //<S2SV> ntStatus = TCDeviceIoControl ( info -> deviceName , IOCTL_DISK_GET_LENGTH_INFO , NULL , 0 , & lengthInfo , sizeof ( lengthInfo ) ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> memset ( & info -> partInfo , 0 , sizeof ( info -> partInfo ) ) ; //<S2SV> info -> partInfo . PartitionLength = lengthInfo . Length ; //<S2SV> } //<S2SV> } //<S2SV> info -> IsDynamic = FALSE ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) && OsMajorVersion >= 6 ) //<S2SV> { //<S2SV> # define IOCTL_VOLUME_IS_DYNAMIC CTL_CODE ( IOCTL_VOLUME_BASE , 18 , METHOD_BUFFERED , FILE_ANY_ACCESS ) //<S2SV> if ( ! NT_SUCCESS ( TCDeviceIoControl ( info -> deviceName , IOCTL_VOLUME_IS_DYNAMIC , NULL , 0 , & info -> IsDynamic , sizeof ( info -> IsDynamic ) ) ) ) //<S2SV> info -> IsDynamic = FALSE ; //<S2SV> } //<S2SV> Irp -> IoStatus . Information = sizeof ( DISK_PARTITION_INFO_STRUCT ) ; //<S2SV> Irp -> IoStatus . Status = ntStatus ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_DRIVE_GEOMETRY : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_STRUCT ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> DISK_GEOMETRY_STRUCT * g = ( DISK_GEOMETRY_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> { //<S2SV> NTSTATUS ntStatus ; //<S2SV> EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; //<S2SV> Dump ( "Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; //<S2SV> ntStatus = TCDeviceIoControl ( g -> deviceName , //<S2SV> IOCTL_DISK_GET_DRIVE_GEOMETRY , //<S2SV> NULL , 0 , & g -> diskGeometry , sizeof ( g -> diskGeometry ) ) ; //<S2SV> Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_STRUCT ) ; //<S2SV> Irp -> IoStatus . Status = ntStatus ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case VC_IOCTL_GET_DRIVE_GEOMETRY_EX : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( DISK_GEOMETRY_EX_STRUCT ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> DISK_GEOMETRY_EX_STRUCT * g = ( DISK_GEOMETRY_EX_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> { //<S2SV> NTSTATUS ntStatus ; //<S2SV> PVOID buffer = TCalloc ( 256 ) ; //<S2SV> if ( buffer ) //<S2SV> { //<S2SV> EnsureNullTerminatedString ( g -> deviceName , sizeof ( g -> deviceName ) ) ; //<S2SV> Dump ( "Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; //<S2SV> ntStatus = TCDeviceIoControl ( g -> deviceName , //<S2SV> IOCTL_DISK_GET_DRIVE_GEOMETRY_EX , //<S2SV> NULL , 0 , buffer , 256 ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> PDISK_GEOMETRY_EX pGeo = ( PDISK_GEOMETRY_EX ) buffer ; //<S2SV> memcpy ( & g -> diskGeometry , & pGeo -> Geometry , sizeof ( DISK_GEOMETRY ) ) ; //<S2SV> g -> DiskSize . QuadPart = pGeo -> DiskSize . QuadPart ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> DISK_GEOMETRY dg = { 0 } ; //<S2SV> Dump ( "Failed.<S2SV_blank>Calling<S2SV_blank>IOCTL_DISK_GET_DRIVE_GEOMETRY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; //<S2SV> ntStatus = TCDeviceIoControl ( g -> deviceName , //<S2SV> IOCTL_DISK_GET_DRIVE_GEOMETRY , //<S2SV> NULL , 0 , & dg , sizeof ( dg ) ) ; //<S2SV> if ( NT_SUCCESS ( ntStatus ) ) //<S2SV> { //<S2SV> memcpy ( & g -> diskGeometry , & dg , sizeof ( DISK_GEOMETRY ) ) ; //<S2SV> g -> DiskSize . QuadPart = dg . Cylinders . QuadPart * dg . SectorsPerTrack * dg . TracksPerCylinder * dg . BytesPerSector ; //<S2SV> if ( OsMajorVersion >= 6 ) //<S2SV> { //<S2SV> STORAGE_READ_CAPACITY storage = { 0 } ; //<S2SV> NTSTATUS lStatus ; //<S2SV> storage . Version = sizeof ( STORAGE_READ_CAPACITY ) ; //<S2SV> Dump ( "Calling<S2SV_blank>IOCTL_STORAGE_READ_CAPACITY<S2SV_blank>on<S2SV_blank>%ls\\n" , g -> deviceName ) ; //<S2SV> lStatus = TCDeviceIoControl ( g -> deviceName , //<S2SV> IOCTL_STORAGE_READ_CAPACITY , //<S2SV> NULL , 0 , & storage , sizeof ( STORAGE_READ_CAPACITY ) ) ; //<S2SV> if ( NT_SUCCESS ( lStatus ) //<S2SV> && ( storage . Size == sizeof ( STORAGE_READ_CAPACITY ) ) //<S2SV> ) //<S2SV> { //<S2SV> g -> DiskSize . QuadPart = storage . DiskLength . QuadPart ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> TCfree ( buffer ) ; //<S2SV> Irp -> IoStatus . Information = sizeof ( DISK_GEOMETRY_EX_STRUCT ) ; //<S2SV> Irp -> IoStatus . Status = ntStatus ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_PROBE_REAL_DRIVE_SIZE : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( ProbeRealDriveSizeRequest ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> ProbeRealDriveSizeRequest * request = ( ProbeRealDriveSizeRequest * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> NTSTATUS status ; //<S2SV> UNICODE_STRING name ; //<S2SV> PFILE_OBJECT fileObject ; //<S2SV> PDEVICE_OBJECT deviceObject ; //<S2SV> EnsureNullTerminatedString ( request -> DeviceName , sizeof ( request -> DeviceName ) ) ; //<S2SV> RtlInitUnicodeString ( & name , request -> DeviceName ) ; //<S2SV> status = IoGetDeviceObjectPointer ( & name , FILE_READ_ATTRIBUTES , & fileObject , & deviceObject ) ; //<S2SV> if ( ! NT_SUCCESS ( status ) ) //<S2SV> { //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> Irp -> IoStatus . Status = status ; //<S2SV> break ; //<S2SV> } //<S2SV> status = ProbeRealDriveSize ( deviceObject , & request -> RealDriveSize ) ; //<S2SV> ObDereferenceObject ( fileObject ) ; //<S2SV> if ( status == STATUS_TIMEOUT ) //<S2SV> { //<S2SV> request -> TimeOut = TRUE ; //<S2SV> Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> else if ( ! NT_SUCCESS ( status ) ) //<S2SV> { //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> Irp -> IoStatus . Status = status ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> request -> TimeOut = FALSE ; //<S2SV> Irp -> IoStatus . Information = sizeof ( ProbeRealDriveSizeRequest ) ; //<S2SV> Irp -> IoStatus . Status = status ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_MOUNT_VOLUME : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( MOUNT_STRUCT ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> MOUNT_STRUCT * mount = ( MOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> if ( mount -> VolumePassword . Length > MAX_PASSWORD || mount -> ProtectedHidVolPassword . Length > MAX_PASSWORD //<S2SV> || mount -> pkcs5_prf < 0 || mount -> pkcs5_prf > LAST_PRF_ID //<S2SV> || mount -> VolumePim < - 1 || mount -> VolumePim == INT_MAX //<S2SV> || mount -> ProtectedHidVolPkcs5Prf < 0 || mount -> ProtectedHidVolPkcs5Prf > LAST_PRF_ID //<S2SV> || ( mount -> bTrueCryptMode != FALSE && mount -> bTrueCryptMode != TRUE ) //<S2SV> ) //<S2SV> { //<S2SV> Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> EnsureNullTerminatedString ( mount -> wszVolume , sizeof ( mount -> wszVolume ) ) ; //<S2SV> EnsureNullTerminatedString ( mount -> wszLabel , sizeof ( mount -> wszLabel ) ) ; //<S2SV> Irp -> IoStatus . Information = sizeof ( MOUNT_STRUCT ) ; //<S2SV> Irp -> IoStatus . Status = MountDevice ( DeviceObject , mount ) ; //<S2SV> burn ( & mount -> VolumePassword , sizeof ( mount -> VolumePassword ) ) ; //<S2SV> burn ( & mount -> ProtectedHidVolPassword , sizeof ( mount -> ProtectedHidVolPassword ) ) ; //<S2SV> burn ( & mount -> pkcs5_prf , sizeof ( mount -> pkcs5_prf ) ) ; //<S2SV> burn ( & mount -> VolumePim , sizeof ( mount -> VolumePim ) ) ; //<S2SV> burn ( & mount -> bTrueCryptMode , sizeof ( mount -> bTrueCryptMode ) ) ; //<S2SV> burn ( & mount -> ProtectedHidVolPkcs5Prf , sizeof ( mount -> ProtectedHidVolPkcs5Prf ) ) ; //<S2SV> burn ( & mount -> ProtectedHidVolPim , sizeof ( mount -> ProtectedHidVolPim ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_DISMOUNT_VOLUME : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> PDEVICE_OBJECT ListDevice = GetVirtualVolumeDeviceObject ( unmount -> nDosDriveNo ) ; //<S2SV> unmount -> nReturnCode = ERR_DRIVE_NOT_FOUND ; //<S2SV> if ( ListDevice ) //<S2SV> { //<S2SV> PEXTENSION ListExtension = ( PEXTENSION ) ListDevice -> DeviceExtension ; //<S2SV> if ( IsVolumeAccessibleByCurrentUser ( ListExtension ) ) //<S2SV> unmount -> nReturnCode = UnmountDevice ( unmount , ListDevice , unmount -> ignoreOpenFiles ) ; //<S2SV> } //<S2SV> Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_DISMOUNT_ALL_VOLUMES : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( UNMOUNT_STRUCT ) , ValidateInputOutput ) ) //<S2SV> { //<S2SV> UNMOUNT_STRUCT * unmount = ( UNMOUNT_STRUCT * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> unmount -> nReturnCode = UnmountAllDevices ( unmount , unmount -> ignoreOpenFiles ) ; //<S2SV> Irp -> IoStatus . Information = sizeof ( UNMOUNT_STRUCT ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_BOOT_ENCRYPTION_SETUP : //<S2SV> Irp -> IoStatus . Status = StartBootEncryptionSetup ( DeviceObject , Irp , irpSp ) ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_ABORT_BOOT_ENCRYPTION_SETUP : //<S2SV> Irp -> IoStatus . Status = AbortBootEncryptionSetup ( ) ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : //<S2SV> GetBootEncryptionStatus ( Irp , irpSp ) ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_BOOT_ENCRYPTION_SETUP_RESULT : //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> Irp -> IoStatus . Status = GetSetupResult ( ) ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : //<S2SV> GetBootDriveVolumeProperties ( Irp , irpSp ) ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_BOOT_LOADER_VERSION : //<S2SV> GetBootLoaderVersion ( Irp , irpSp ) ; //<S2SV> break ; //<S2SV> case TC_IOCTL_REOPEN_BOOT_VOLUME_HEADER : //<S2SV> ReopenBootVolumeHeader ( Irp , irpSp ) ; //<S2SV> break ; //<S2SV> case VC_IOCTL_GET_BOOT_LOADER_FINGERPRINT : //<S2SV> GetBootLoaderFingerprint ( Irp , irpSp ) ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_BOOT_ENCRYPTION_ALGORITHM_NAME : //<S2SV> GetBootEncryptionAlgorithmName ( Irp , irpSp ) ; //<S2SV> break ; //<S2SV> case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) //<S2SV> { //<S2SV> * ( int * ) Irp -> AssociatedIrp . SystemBuffer = IsHiddenSystemRunning ( ) ? 1 : 0 ; //<S2SV> Irp -> IoStatus . Information = sizeof ( int ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_START_DECOY_SYSTEM_WIPE : //<S2SV> Irp -> IoStatus . Status = StartDecoySystemWipe ( DeviceObject , Irp , irpSp ) ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_ABORT_DECOY_SYSTEM_WIPE : //<S2SV> Irp -> IoStatus . Status = AbortDecoySystemWipe ( ) ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_RESULT : //<S2SV> Irp -> IoStatus . Status = GetDecoySystemWipeResult ( ) ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_DECOY_SYSTEM_WIPE_STATUS : //<S2SV> GetDecoySystemWipeStatus ( Irp , irpSp ) ; //<S2SV> break ; //<S2SV> case TC_IOCTL_WRITE_BOOT_DRIVE_SECTOR : //<S2SV> Irp -> IoStatus . Status = WriteBootDriveSector ( Irp , irpSp ) ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_WARNING_FLAGS : //<S2SV> if ( ValidateIOBufferSize ( Irp , sizeof ( GetWarningFlagsRequest ) , ValidateOutput ) ) //<S2SV> { //<S2SV> GetWarningFlagsRequest * flags = ( GetWarningFlagsRequest * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> flags -> PagingFileCreationPrevented = PagingFileCreationPrevented ; //<S2SV> PagingFileCreationPrevented = FALSE ; //<S2SV> flags -> SystemFavoriteVolumeDirty = SystemFavoriteVolumeDirty ; //<S2SV> SystemFavoriteVolumeDirty = FALSE ; //<S2SV> Irp -> IoStatus . Information = sizeof ( GetWarningFlagsRequest ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> break ; //<S2SV> case TC_IOCTL_SET_SYSTEM_FAVORITE_VOLUME_DIRTY : //<S2SV> if ( UserCanAccessDriveDevice ( ) ) //<S2SV> { //<S2SV> SystemFavoriteVolumeDirty = TRUE ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> } //<S2SV> else //<S2SV> Irp -> IoStatus . Status = STATUS_ACCESS_DENIED ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_REREAD_DRIVER_CONFIG : //<S2SV> Irp -> IoStatus . Status = ReadRegistryConfigFlags ( FALSE ) ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> break ; //<S2SV> case TC_IOCTL_GET_SYSTEM_DRIVE_DUMP_CONFIG : //<S2SV> if ( ( ValidateIOBufferSize ( Irp , sizeof ( GetSystemDriveDumpConfigRequest ) , ValidateOutput ) ) //<S2SV> && ( Irp -> RequestorMode == KernelMode ) //<S2SV> ) //<S2SV> { //<S2SV> GetSystemDriveDumpConfigRequest * request = ( GetSystemDriveDumpConfigRequest * ) Irp -> AssociatedIrp . SystemBuffer ; //<S2SV> request -> BootDriveFilterExtension = GetBootDriveFilterExtension ( ) ; //<S2SV> if ( IsBootDriveMounted ( ) && request -> BootDriveFilterExtension ) //<S2SV> { //<S2SV> request -> HwEncryptionEnabled = IsHwEncryptionEnabled ( ) ; //<S2SV> Irp -> IoStatus . Status = STATUS_SUCCESS ; //<S2SV> Irp -> IoStatus . Information = sizeof ( * request ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; //<S2SV> Irp -> IoStatus . Information = 0 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> return TCCompleteIrp ( Irp , STATUS_INVALID_DEVICE_REQUEST , 0 ) ; //<S2SV> } //<S2SV> # if defined ( DEBUG ) || defined ( DEBUG_TRACE ) //<S2SV> if ( ! NT_SUCCESS ( Irp -> IoStatus . Status ) ) //<S2SV> { //<S2SV> switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) //<S2SV> { //<S2SV> case TC_IOCTL_GET_MOUNTED_VOLUMES : //<S2SV> case TC_IOCTL_GET_PASSWORD_CACHE_STATUS : //<S2SV> case TC_IOCTL_GET_PORTABLE_MODE_STATUS : //<S2SV> case TC_IOCTL_SET_PORTABLE_MODE_STATUS : //<S2SV> case TC_IOCTL_OPEN_TEST : //<S2SV> case TC_IOCTL_GET_RESOLVED_SYMLINK : //<S2SV> case TC_IOCTL_GET_DRIVE_PARTITION_INFO : //<S2SV> case TC_IOCTL_GET_BOOT_DRIVE_VOLUME_PROPERTIES : //<S2SV> case TC_IOCTL_GET_BOOT_ENCRYPTION_STATUS : //<S2SV> case TC_IOCTL_IS_HIDDEN_SYSTEM_RUNNING : //<S2SV> break ; //<S2SV> default : //<S2SV> Dump ( "IOCTL<S2SV_blank>error<S2SV_blank>0x%08x\\n" , Irp -> IoStatus . Status ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> return TCCompleteIrp ( Irp , Irp -> IoStatus . Status , Irp -> IoStatus . Information ) ; //<S2SV> } //<S2SV> 