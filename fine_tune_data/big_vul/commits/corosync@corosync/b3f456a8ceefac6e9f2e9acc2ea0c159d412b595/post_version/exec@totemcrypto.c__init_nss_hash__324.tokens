static int init_nss_hash ( struct crypto_instance * instance ) //<S2SV> { //<S2SV> PK11SlotInfo * hash_slot = NULL ; //<S2SV> SECItem hash_param ; //<S2SV> if ( ! hash_to_nss [ instance -> crypto_hash_type ] ) { //<S2SV> return 0 ; //<S2SV> } //<S2SV> hash_param . type = siBuffer ; //<S2SV> hash_param . data = instance -> private_key ; //<S2SV> hash_param . len = instance -> private_key_len ; //<S2SV> hash_slot = PK11_GetBestSlot ( hash_to_nss [ instance -> crypto_hash_type ] , NULL ) ; //<S2SV> if ( hash_slot == NULL ) { //<S2SV> log_printf ( instance -> log_level_security , "Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>security<S2SV_blank>slot<S2SV_blank>(err<S2SV_blank>%d)" , //<S2SV> PR_GetError ( ) ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> instance -> nss_sym_key_sign = PK11_ImportSymKey ( hash_slot , //<S2SV> hash_to_nss [ instance -> crypto_hash_type ] , //<S2SV> PK11_OriginUnwrap , CKA_SIGN , //<S2SV> & hash_param , NULL ) ; //<S2SV> if ( instance -> nss_sym_key_sign == NULL ) { //<S2SV> log_printf ( instance -> log_level_security , "Failure<S2SV_blank>to<S2SV_blank>import<S2SV_blank>key<S2SV_blank>into<S2SV_blank>NSS<S2SV_blank>(err<S2SV_blank>%d)" , //<S2SV> PR_GetError ( ) ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> PK11_FreeSlot ( hash_slot ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 