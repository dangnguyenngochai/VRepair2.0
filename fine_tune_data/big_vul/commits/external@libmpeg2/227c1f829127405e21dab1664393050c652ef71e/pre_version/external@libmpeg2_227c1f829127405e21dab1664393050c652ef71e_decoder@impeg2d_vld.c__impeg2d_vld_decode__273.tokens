IMPEG2D_ERROR_CODES_T impeg2d_vld_decode ( //<S2SV> dec_state_t * ps_dec , //<S2SV> WORD16 * pi2_outAddr , //<S2SV> const UWORD8 * pu1_scan , //<S2SV> UWORD8 * pu1_pos , //<S2SV> UWORD16 u2_intra_flag , //<S2SV> UWORD16 u2_chroma_flag , //<S2SV> UWORD16 u2_d_picture , //<S2SV> UWORD16 u2_intra_vlc_format , //<S2SV> UWORD16 u2_mpeg2 , //<S2SV> WORD32 * pi4_num_coeffs //<S2SV> ) //<S2SV> { //<S2SV> UWORD32 u4_sym_len ; //<S2SV> UWORD32 u4_decoded_value ; //<S2SV> UWORD32 u4_level_first_byte ; //<S2SV> WORD32 u4_level ; //<S2SV> UWORD32 u4_run , u4_numCoeffs ; //<S2SV> UWORD32 u4_buf ; //<S2SV> UWORD32 u4_buf_nxt ; //<S2SV> UWORD32 u4_offset ; //<S2SV> UWORD32 * pu4_buf_aligned ; //<S2SV> UWORD32 u4_bits ; //<S2SV> stream_t * ps_stream = & ps_dec -> s_bit_stream ; //<S2SV> WORD32 u4_pos ; //<S2SV> UWORD32 u4_nz_cols ; //<S2SV> UWORD32 u4_nz_rows ; //<S2SV> * pi4_num_coeffs = 0 ; //<S2SV> ps_dec -> u4_non_zero_cols = 0 ; //<S2SV> ps_dec -> u4_non_zero_rows = 0 ; //<S2SV> u4_nz_cols = ps_dec -> u4_non_zero_cols ; //<S2SV> u4_nz_rows = ps_dec -> u4_non_zero_rows ; //<S2SV> GET_TEMP_STREAM_DATA ( u4_buf , u4_buf_nxt , u4_offset , pu4_buf_aligned , ps_stream ) //<S2SV> if ( u2_intra_flag ) //<S2SV> { //<S2SV> WORD32 dc_size ; //<S2SV> WORD32 dc_diff ; //<S2SV> WORD32 maxLen ; //<S2SV> WORD32 idx ; //<S2SV> maxLen = MPEG2_DCT_DC_SIZE_LEN ; //<S2SV> idx = 0 ; //<S2SV> if ( u2_chroma_flag != 0 ) //<S2SV> { //<S2SV> maxLen += 1 ; //<S2SV> idx ++ ; //<S2SV> } //<S2SV> { //<S2SV> WORD16 end = 0 ; //<S2SV> UWORD32 maxLen_tmp = maxLen ; //<S2SV> UWORD16 m_iBit ; //<S2SV> IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , maxLen ) //<S2SV> do //<S2SV> { //<S2SV> maxLen_tmp -- ; //<S2SV> m_iBit = ( UWORD8 ) ( ( u4_bits >> maxLen_tmp ) & 0x1 ) ; //<S2SV> end = gai2_impeg2d_dct_dc_size [ idx ] [ end ] [ m_iBit ] ; //<S2SV> } while ( end > 0 ) ; //<S2SV> dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET ; //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , ( maxLen - maxLen_tmp ) , pu4_buf_aligned ) //<S2SV> } //<S2SV> if ( dc_size != 0 ) //<S2SV> { //<S2SV> UWORD32 u4_bits ; //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , dc_size ) //<S2SV> dc_diff = u4_bits ; //<S2SV> if ( ( dc_diff & ( 1 << ( dc_size - 1 ) ) ) == 0 ) //<S2SV> dc_diff -= ( 1 << dc_size ) - 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> dc_diff = 0 ; //<S2SV> } //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = dc_diff ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = pu1_scan [ 0 ] ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> if ( 0 != dc_diff ) //<S2SV> { //<S2SV> u4_nz_cols |= 0x01 ; //<S2SV> u4_nz_rows |= 0x01 ; //<S2SV> } //<S2SV> u4_numCoeffs = 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> UWORD32 u4_bits ; //<S2SV> IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , 1 ) //<S2SV> if ( u4_bits == 1 ) //<S2SV> { //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , 1 , pu4_buf_aligned ) //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 1 ) //<S2SV> if ( u4_bits == 1 ) //<S2SV> { //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = - 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = 1 ; //<S2SV> } //<S2SV> pu1_pos [ * pi4_num_coeffs ] = pu1_scan [ 0 ] ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> u4_numCoeffs = 1 ; //<S2SV> u4_nz_cols |= 0x01 ; //<S2SV> u4_nz_rows |= 0x01 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> u4_numCoeffs = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( 1 == u2_d_picture ) //<S2SV> { //<S2SV> PUT_TEMP_STREAM_DATA ( u4_buf , u4_buf_nxt , u4_offset , pu4_buf_aligned , ps_stream ) //<S2SV> ps_dec -> u4_non_zero_cols = u4_nz_cols ; //<S2SV> ps_dec -> u4_non_zero_rows = u4_nz_rows ; //<S2SV> return ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ) ; //<S2SV> } //<S2SV> if ( 1 == u2_intra_vlc_format && u2_intra_flag ) //<S2SV> { //<S2SV> while ( 1 ) //<S2SV> { //<S2SV> UWORD32 lead_zeros ; //<S2SV> WORD16 DecodedValue ; //<S2SV> u4_sym_len = 17 ; //<S2SV> IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) //<S2SV> DecodedValue = gau2_impeg2d_tab_one_1_9 [ u4_bits >> 8 ] ; //<S2SV> u4_sym_len = ( DecodedValue & 0xf ) ; //<S2SV> u4_level = DecodedValue >> 9 ; //<S2SV> if ( 0 != u4_level ) //<S2SV> { //<S2SV> u4_run = ( ( DecodedValue >> 4 ) & 0x1f ) ; //<S2SV> u4_numCoeffs += u4_run ; //<S2SV> u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = u4_pos ; //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( DecodedValue == END_OF_BLOCK_ONE ) //<S2SV> { //<S2SV> u4_sym_len = 4 ; //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> lead_zeros = CLZ ( u4_bits ) - 20 ; //<S2SV> if ( 0 != lead_zeros ) //<S2SV> { //<S2SV> u4_bits = ( u4_bits >> ( 6 - lead_zeros ) ) & 0x001F ; //<S2SV> if ( 1 == lead_zeros ) //<S2SV> { //<S2SV> u4_sym_len = ( ( u4_bits & 0x18 ) >> 3 ) == 2 ? 11 : 10 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> u4_sym_len = 11 + lead_zeros ; //<S2SV> } //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) //<S2SV> u4_bits = ( ( lead_zeros - 1 ) << 5 ) + u4_bits ; //<S2SV> DecodedValue = gau2_impeg2d_tab_one_10_16 [ u4_bits ] ; //<S2SV> u4_run = BITS ( DecodedValue , 8 , 4 ) ; //<S2SV> u4_level = ( ( WORD16 ) DecodedValue ) >> 9 ; //<S2SV> u4_numCoeffs += u4_run ; //<S2SV> u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = u4_pos ; //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> } //<S2SV> else if ( u2_mpeg2 == 1 ) //<S2SV> { //<S2SV> u4_sym_len = 6 ; //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 18 ) //<S2SV> u4_decoded_value = u4_bits ; //<S2SV> u4_run = ( u4_decoded_value >> 12 ) ; //<S2SV> u4_level = ( u4_decoded_value & 0x0FFF ) ; //<S2SV> if ( u4_level ) //<S2SV> u4_level = ( u4_level - ( ( u4_level & 0x0800 ) << 1 ) ) ; //<S2SV> u4_numCoeffs += u4_run ; //<S2SV> u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = u4_pos ; //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> u4_sym_len = 6 ; //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 14 ) //<S2SV> u4_decoded_value = u4_bits ; //<S2SV> u4_run = ( u4_decoded_value >> 8 ) ; //<S2SV> u4_level_first_byte = ( u4_decoded_value & 0x0FF ) ; //<S2SV> if ( u4_level_first_byte & 0x7F ) //<S2SV> { //<S2SV> u4_level = ( u4_level_first_byte - //<S2SV> ( ( u4_level_first_byte & 0x80 ) << 1 ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 8 ) //<S2SV> u4_level = u4_bits ; //<S2SV> u4_level = ( u4_level - ( u4_level_first_byte << 1 ) ) ; //<S2SV> } //<S2SV> u4_numCoeffs += u4_run ; //<S2SV> u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = u4_pos ; //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> u4_nz_cols |= 1 << ( u4_pos & 0x7 ) ; //<S2SV> u4_nz_rows |= 1 << ( u4_pos >> 0x3 ) ; //<S2SV> if ( u4_numCoeffs > 64 ) //<S2SV> { //<S2SV> return IMPEG2D_MB_TEX_DECODE_ERR ; //<S2SV> } //<S2SV> } //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> while ( 1 ) //<S2SV> { //<S2SV> UWORD32 lead_zeros ; //<S2SV> UWORD16 DecodedValue ; //<S2SV> u4_sym_len = 17 ; //<S2SV> IBITS_NXT ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , u4_sym_len ) //<S2SV> DecodedValue = gau2_impeg2d_tab_zero_1_9 [ u4_bits >> 8 ] ; //<S2SV> u4_sym_len = BITS ( DecodedValue , 3 , 0 ) ; //<S2SV> u4_level = ( ( WORD16 ) DecodedValue ) >> 9 ; //<S2SV> if ( 0 != u4_level ) //<S2SV> { //<S2SV> u4_run = BITS ( DecodedValue , 8 , 4 ) ; //<S2SV> u4_numCoeffs += u4_run ; //<S2SV> u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = u4_pos ; //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( DecodedValue == END_OF_BLOCK_ZERO ) //<S2SV> { //<S2SV> u4_sym_len = 2 ; //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> lead_zeros = CLZ ( u4_bits ) - 20 ; //<S2SV> if ( 0 != lead_zeros ) //<S2SV> { //<S2SV> u4_bits = ( u4_bits >> ( 6 - lead_zeros ) ) & 0x001F ; //<S2SV> u4_sym_len = 11 + lead_zeros ; //<S2SV> u4_bits = ( ( lead_zeros - 1 ) << 5 ) + u4_bits ; //<S2SV> DecodedValue = gau2_impeg2d_tab_zero_10_16 [ u4_bits ] ; //<S2SV> u4_run = BITS ( DecodedValue , 8 , 4 ) ; //<S2SV> u4_level = ( ( WORD16 ) DecodedValue ) >> 9 ; //<S2SV> u4_numCoeffs += u4_run ; //<S2SV> u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = u4_pos ; //<S2SV> if ( 1 == lead_zeros ) //<S2SV> u4_sym_len -- ; //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> } //<S2SV> else if ( u2_mpeg2 == 1 ) //<S2SV> { //<S2SV> u4_sym_len = 6 ; //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 18 ) //<S2SV> u4_decoded_value = u4_bits ; //<S2SV> u4_run = ( u4_decoded_value >> 12 ) ; //<S2SV> u4_level = ( u4_decoded_value & 0x0FFF ) ; //<S2SV> if ( u4_level ) //<S2SV> u4_level = ( u4_level - ( ( u4_level & 0x0800 ) << 1 ) ) ; //<S2SV> u4_numCoeffs += u4_run ; //<S2SV> u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = u4_pos ; //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> u4_sym_len = 6 ; //<S2SV> FLUSH_BITS ( u4_offset , u4_buf , u4_buf_nxt , u4_sym_len , pu4_buf_aligned ) //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 14 ) //<S2SV> u4_decoded_value = u4_bits ; //<S2SV> u4_run = ( u4_decoded_value >> 8 ) ; //<S2SV> u4_level_first_byte = ( u4_decoded_value & 0x0FF ) ; //<S2SV> if ( u4_level_first_byte & 0x7F ) //<S2SV> { //<S2SV> u4_level = ( u4_level_first_byte - //<S2SV> ( ( u4_level_first_byte & 0x80 ) << 1 ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , 8 ) //<S2SV> u4_level = u4_bits ; //<S2SV> u4_level = ( u4_level - ( u4_level_first_byte << 1 ) ) ; //<S2SV> } //<S2SV> u4_numCoeffs += u4_run ; //<S2SV> u4_pos = pu1_scan [ u4_numCoeffs ++ & 63 ] ; //<S2SV> pu1_pos [ * pi4_num_coeffs ] = u4_pos ; //<S2SV> pi2_outAddr [ * pi4_num_coeffs ] = u4_level ; //<S2SV> ( * pi4_num_coeffs ) ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> u4_nz_cols |= 1 << ( u4_pos & 0x7 ) ; //<S2SV> u4_nz_rows |= 1 << ( u4_pos >> 0x3 ) ; //<S2SV> if ( u4_numCoeffs > 64 ) //<S2SV> { //<S2SV> return IMPEG2D_MB_TEX_DECODE_ERR ; //<S2SV> } //<S2SV> } //<S2SV> IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) //<S2SV> } //<S2SV> PUT_TEMP_STREAM_DATA ( u4_buf , u4_buf_nxt , u4_offset , pu4_buf_aligned , ps_stream ) //<S2SV> ps_dec -> u4_non_zero_cols = u4_nz_cols ; //<S2SV> ps_dec -> u4_non_zero_rows = u4_nz_rows ; //<S2SV> return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; //<S2SV> } //<S2SV> 