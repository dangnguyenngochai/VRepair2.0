IMPEG2D_ERROR_CODES_T impeg2d_dec_slice ( dec_state_t * ps_dec ) //<S2SV> { //<S2SV> stream_t * ps_stream ; //<S2SV> UWORD32 u4_slice_vertical_position ; //<S2SV> UWORD32 u4_slice_vertical_position_extension ; //<S2SV> IMPEG2D_ERROR_CODES_T e_error ; //<S2SV> ps_stream = & ps_dec -> s_bit_stream ; //<S2SV> impeg2d_bit_stream_flush ( ps_stream , START_CODE_PREFIX_LEN ) ; //<S2SV> u4_slice_vertical_position = impeg2d_bit_stream_get ( ps_stream , 8 ) ; //<S2SV> if ( u4_slice_vertical_position > 2800 ) //<S2SV> { //<S2SV> u4_slice_vertical_position_extension = impeg2d_bit_stream_get ( ps_stream , 3 ) ; //<S2SV> u4_slice_vertical_position += ( u4_slice_vertical_position_extension << 7 ) ; //<S2SV> } //<S2SV> if ( ( u4_slice_vertical_position > ps_dec -> u2_num_vert_mb ) || //<S2SV> ( u4_slice_vertical_position == 0 ) ) //<S2SV> { //<S2SV> return IMPEG2D_INVALID_VERT_SIZE ; //<S2SV> } //<S2SV> u4_slice_vertical_position -- ; //<S2SV> if ( ps_dec -> u2_mb_y != u4_slice_vertical_position ) //<S2SV> { //<S2SV> ps_dec -> u2_mb_y = u4_slice_vertical_position ; //<S2SV> ps_dec -> u2_mb_x = 0 ; //<S2SV> } //<S2SV> ps_dec -> u2_first_mb = 1 ; //<S2SV> { //<S2SV> UWORD16 u2_quant_scale_code ; //<S2SV> u2_quant_scale_code = impeg2d_bit_stream_get ( ps_stream , 5 ) ; //<S2SV> ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? //<S2SV> gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; //<S2SV> } //<S2SV> if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) //<S2SV> { //<S2SV> impeg2d_bit_stream_flush ( ps_stream , 9 ) ; //<S2SV> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) //<S2SV> { //<S2SV> impeg2d_bit_stream_flush ( ps_stream , 9 ) ; //<S2SV> } //<S2SV> } //<S2SV> impeg2d_bit_stream_get_bit ( ps_stream ) ; //<S2SV> ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; //<S2SV> ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; //<S2SV> ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; //<S2SV> e_error = ps_dec -> pf_decode_slice ( ps_dec ) ; //<S2SV> if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) //<S2SV> { //<S2SV> return e_error ; //<S2SV> } //<S2SV> if ( ps_dec -> u2_mb_y < ps_dec -> u2_num_vert_mb ) //<S2SV> impeg2d_next_start_code ( ps_dec ) ; //<S2SV> return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; //<S2SV> } //<S2SV> 