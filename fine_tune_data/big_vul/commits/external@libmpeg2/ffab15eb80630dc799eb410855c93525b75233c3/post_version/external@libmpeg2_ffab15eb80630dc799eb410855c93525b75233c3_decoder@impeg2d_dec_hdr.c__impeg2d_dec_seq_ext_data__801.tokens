IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data ( dec_state_t * ps_dec ) //<S2SV> { //<S2SV> stream_t * ps_stream ; //<S2SV> UWORD32 u4_start_code ; //<S2SV> IMPEG2D_ERROR_CODES_T e_error ; //<S2SV> e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; //<S2SV> ps_stream = & ps_dec -> s_bit_stream ; //<S2SV> u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; //<S2SV> while ( ( u4_start_code == EXTENSION_START_CODE || //<S2SV> u4_start_code == USER_DATA_START_CODE ) && //<S2SV> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error && //<S2SV> ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) ) //<S2SV> { //<S2SV> if ( u4_start_code == USER_DATA_START_CODE ) //<S2SV> { //<S2SV> impeg2d_dec_user_data ( ps_dec ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; //<S2SV> u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; //<S2SV> switch ( u4_start_code ) //<S2SV> { //<S2SV> case SEQ_DISPLAY_EXT_ID : //<S2SV> impeg2d_dec_seq_disp_ext ( ps_dec ) ; //<S2SV> break ; //<S2SV> case SEQ_SCALABLE_EXT_ID : //<S2SV> e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED ; //<S2SV> break ; //<S2SV> default : //<S2SV> impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; //<S2SV> impeg2d_peek_next_start_code ( ps_dec ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; //<S2SV> } //<S2SV> return e_error ; //<S2SV> } //<S2SV> 