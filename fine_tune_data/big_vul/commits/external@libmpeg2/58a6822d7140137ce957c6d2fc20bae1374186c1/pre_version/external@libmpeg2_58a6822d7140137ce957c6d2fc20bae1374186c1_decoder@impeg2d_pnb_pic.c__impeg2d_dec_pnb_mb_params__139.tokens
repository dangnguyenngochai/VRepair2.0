void impeg2d_dec_pnb_mb_params ( dec_state_t * ps_dec ) //<S2SV> { //<S2SV> stream_t * ps_stream = & ps_dec -> s_bit_stream ; //<S2SV> UWORD16 u2_mb_addr_incr ; //<S2SV> UWORD16 u2_total_len ; //<S2SV> UWORD16 u2_len ; //<S2SV> UWORD16 u2_mb_type ; //<S2SV> UWORD32 u4_next_word ; //<S2SV> const dec_mb_params_t * ps_dec_mb_params ; //<S2SV> if ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) //<S2SV> { //<S2SV> impeg2d_bit_stream_flush ( ps_stream , 1 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> u2_mb_addr_incr = impeg2d_get_mb_addr_incr ( ps_stream ) ; //<S2SV> if ( ps_dec -> u2_first_mb ) //<S2SV> { //<S2SV> ps_dec -> u2_mb_x = u2_mb_addr_incr - 1 ; //<S2SV> ps_dec -> u2_mb_x = MIN ( ps_dec -> u2_mb_x , ( ps_dec -> u2_num_horiz_mb - 1 ) ) ; //<S2SV> u2_mb_addr_incr = 1 ; //<S2SV> ps_dec -> u2_first_mb = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ps_dec -> u2_is_mpeg2 && //<S2SV> ( ( ps_dec -> u2_mb_x + u2_mb_addr_incr ) > ps_dec -> u2_num_horiz_mb ) ) //<S2SV> { //<S2SV> u2_mb_addr_incr = ps_dec -> u2_num_horiz_mb - ps_dec -> u2_mb_x ; //<S2SV> } //<S2SV> impeg2d_dec_skip_mbs ( ps_dec , ( UWORD16 ) ( u2_mb_addr_incr - 1 ) ) ; //<S2SV> } //<S2SV> } //<S2SV> u4_next_word = ( UWORD16 ) impeg2d_bit_stream_nxt ( ps_stream , 16 ) ; //<S2SV> { //<S2SV> u2_mb_type = ps_dec -> pu2_mb_type [ BITS ( ( UWORD16 ) u4_next_word , 15 , 10 ) ] ; //<S2SV> u2_len = BITS ( u2_mb_type , 15 , 8 ) ; //<S2SV> u2_total_len = u2_len ; //<S2SV> u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << u2_len ) ; //<S2SV> } //<S2SV> { //<S2SV> WORD32 i4_motion_type = ps_dec -> u2_motion_type ; //<S2SV> if ( ( u2_mb_type & MB_FORW_OR_BACK ) && ps_dec -> u2_read_motion_type ) //<S2SV> { //<S2SV> ps_dec -> u2_motion_type = BITS ( ( UWORD16 ) u4_next_word , 15 , 14 ) ; //<S2SV> u2_total_len += MB_MOTION_TYPE_LEN ; //<S2SV> u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_MOTION_TYPE_LEN ) ; //<S2SV> i4_motion_type = ps_dec -> u2_motion_type ; //<S2SV> } //<S2SV> if ( ( u2_mb_type & MB_FORW_OR_BACK ) && //<S2SV> ( ( i4_motion_type == 0 ) || //<S2SV> ( i4_motion_type == 3 ) || //<S2SV> ( i4_motion_type == 4 ) || //<S2SV> ( i4_motion_type >= 7 ) ) ) //<S2SV> { //<S2SV> i4_motion_type = 1 ; //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> if ( ( u2_mb_type & MB_CODED ) && ps_dec -> u2_read_dct_type ) //<S2SV> { //<S2SV> ps_dec -> u2_field_dct = BIT ( ( UWORD16 ) u4_next_word , 15 ) ; //<S2SV> u2_total_len += MB_DCT_TYPE_LEN ; //<S2SV> u4_next_word = ( UWORD16 ) LSW ( ( UWORD16 ) u4_next_word << MB_DCT_TYPE_LEN ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( u2_mb_type & MB_QUANT ) //<S2SV> { //<S2SV> UWORD16 u2_quant_scale_code ; //<S2SV> u2_quant_scale_code = BITS ( ( UWORD16 ) u4_next_word , 15 , 11 ) ; //<S2SV> ps_dec -> u1_quant_scale = ( ps_dec -> u2_q_scale_type ) ? //<S2SV> gau1_impeg2_non_linear_quant_scale [ u2_quant_scale_code ] : ( u2_quant_scale_code << 1 ) ; //<S2SV> u2_total_len += MB_QUANT_SCALE_CODE_LEN ; //<S2SV> } //<S2SV> impeg2d_bit_stream_flush ( ps_stream , u2_total_len ) ; //<S2SV> ps_dec -> u2_coded_mb = ( UWORD16 ) ( u2_mb_type & MB_CODED ) ; //<S2SV> if ( u2_mb_type & MB_BIDRECT ) //<S2SV> { //<S2SV> UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; //<S2SV> ps_dec -> u2_prev_intra_mb = 0 ; //<S2SV> ps_dec -> e_mb_pred = BIDIRECT ; //<S2SV> ps_dec_mb_params = & ps_dec -> ps_func_bi_direct [ u2_index ] ; //<S2SV> ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; //<S2SV> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; //<S2SV> } //<S2SV> else if ( u2_mb_type & MB_FORW_OR_BACK ) //<S2SV> { //<S2SV> UWORD16 u2_refPic = ! ( u2_mb_type & MB_MV_FORW ) ; //<S2SV> UWORD16 u2_index = ( ps_dec -> u2_motion_type ) ; //<S2SV> ps_dec -> u2_prev_intra_mb = 0 ; //<S2SV> ps_dec -> e_mb_pred = ( e_pred_direction_t ) u2_refPic ; //<S2SV> ps_dec_mb_params = & ps_dec -> ps_func_forw_or_back [ u2_index ] ; //<S2SV> ps_dec -> s_mb_type = ps_dec_mb_params -> s_mb_type ; //<S2SV> ps_dec_mb_params -> pf_func_mb_params ( ps_dec ) ; //<S2SV> } //<S2SV> else if ( u2_mb_type & MB_TYPE_INTRA ) //<S2SV> { //<S2SV> ps_dec -> u2_prev_intra_mb = 1 ; //<S2SV> impeg2d_dec_intra_mb ( ps_dec ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_dec -> u2_prev_intra_mb = 0 ; //<S2SV> ps_dec -> e_mb_pred = FORW ; //<S2SV> ps_dec -> u2_motion_type = 0 ; //<S2SV> impeg2d_dec_0mv_coded_mb ( ps_dec ) ; //<S2SV> } //<S2SV> if ( ( u2_mb_type & MB_TYPE_INTRA ) ) //<S2SV> { //<S2SV> ps_dec -> u2_cbp = 0x3f ; //<S2SV> ps_dec -> u2_prev_intra_mb = 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_dec -> u2_prev_intra_mb = 0 ; //<S2SV> ps_dec -> u2_def_dc_pred [ Y_LUMA ] = 128 << ps_dec -> u2_intra_dc_precision ; //<S2SV> ps_dec -> u2_def_dc_pred [ U_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; //<S2SV> ps_dec -> u2_def_dc_pred [ V_CHROMA ] = 128 << ps_dec -> u2_intra_dc_precision ; //<S2SV> if ( ( ps_dec -> u2_coded_mb ) ) //<S2SV> { //<S2SV> UWORD16 cbpValue ; //<S2SV> cbpValue = gau2_impeg2d_cbp_code [ impeg2d_bit_stream_nxt ( ps_stream , MB_CBP_LEN ) ] ; //<S2SV> ps_dec -> u2_cbp = cbpValue & 0xFF ; //<S2SV> impeg2d_bit_stream_flush ( ps_stream , ( cbpValue >> 8 ) & 0x0FF ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_dec -> u2_cbp = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 