local void process ( char * path ) //<S2SV> { //<S2SV> int method = - 1 ; //<S2SV> size_t len ; //<S2SV> struct stat st ; //<S2SV> static char * sufs [ ] = { ".z" , "-z" , "_z" , ".Z" , ".gz" , "-gz" , ".zz" , "-zz" , //<S2SV> ".zip" , ".ZIP" , ".tgz" , NULL } ; //<S2SV> if ( path == NULL ) { //<S2SV> strcpy ( g . inf , "<stdin>" ) ; //<S2SV> g . ind = 0 ; //<S2SV> g . name = NULL ; //<S2SV> g . mtime = g . headis & 2 ? //<S2SV> ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; //<S2SV> len = 0 ; //<S2SV> } //<S2SV> else { //<S2SV> if ( path != g . inf ) { //<S2SV> strncpy ( g . inf , path , sizeof ( g . inf ) ) ; //<S2SV> if ( g . inf [ sizeof ( g . inf ) - 1 ] ) //<S2SV> bail ( "name<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>" , path ) ; //<S2SV> } //<S2SV> len = strlen ( g . inf ) ; //<S2SV> if ( lstat ( g . inf , & st ) ) { //<S2SV> if ( errno == ENOENT && ( g . list || g . decode ) ) { //<S2SV> char * * try = sufs ; //<S2SV> do { //<S2SV> if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) //<S2SV> break ; //<S2SV> strcpy ( g . inf + len , * try ++ ) ; //<S2SV> errno = 0 ; //<S2SV> } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; //<S2SV> } //<S2SV> # ifdef EOVERFLOW //<S2SV> if ( errno == EOVERFLOW || errno == EFBIG ) //<S2SV> bail ( g . inf , //<S2SV> "<S2SV_blank>too<S2SV_blank>large<S2SV_blank>--<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>large<S2SV_blank>file<S2SV_blank>support" ) ; //<S2SV> # endif //<S2SV> if ( errno ) { //<S2SV> g . inf [ len ] = 0 ; //<S2SV> complain ( "%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>--<S2SV_blank>skipping" , g . inf ) ; //<S2SV> return ; //<S2SV> } //<S2SV> len = strlen ( g . inf ) ; //<S2SV> } //<S2SV> if ( ( st . st_mode & S_IFMT ) != S_IFREG && //<S2SV> ( st . st_mode & S_IFMT ) != S_IFLNK && //<S2SV> ( st . st_mode & S_IFMT ) != S_IFDIR ) { //<S2SV> complain ( "%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>special<S2SV_blank>file<S2SV_blank>or<S2SV_blank>device<S2SV_blank>--<S2SV_blank>skipping" , g . inf ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ( st . st_mode & S_IFMT ) == S_IFLNK && ! g . force && ! g . pipeout ) { //<S2SV> complain ( "%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>--<S2SV_blank>skipping" , g . inf ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ( st . st_mode & S_IFMT ) == S_IFDIR && ! g . recurse ) { //<S2SV> complain ( "%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>directory<S2SV_blank>--<S2SV_blank>skipping" , g . inf ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ( st . st_mode & S_IFMT ) == S_IFDIR ) { //<S2SV> char * roll , * item , * cut , * base , * bigger ; //<S2SV> size_t len , hold ; //<S2SV> DIR * here ; //<S2SV> struct dirent * next ; //<S2SV> here = opendir ( g . inf ) ; //<S2SV> if ( here == NULL ) //<S2SV> return ; //<S2SV> hold = 512 ; //<S2SV> roll = MALLOC ( hold ) ; //<S2SV> if ( roll == NULL ) //<S2SV> bail ( "not<S2SV_blank>enough<S2SV_blank>memory" , "" ) ; //<S2SV> * roll = 0 ; //<S2SV> item = roll ; //<S2SV> while ( ( next = readdir ( here ) ) != NULL ) { //<S2SV> if ( next -> d_name [ 0 ] == 0 || //<S2SV> ( next -> d_name [ 0 ] == '.' && ( next -> d_name [ 1 ] == 0 || //<S2SV> ( next -> d_name [ 1 ] == '.' && next -> d_name [ 2 ] == 0 ) ) ) ) //<S2SV> continue ; //<S2SV> len = strlen ( next -> d_name ) + 1 ; //<S2SV> if ( item + len + 1 > roll + hold ) { //<S2SV> do { //<S2SV> hold <<= 1 ; //<S2SV> } while ( item + len + 1 > roll + hold ) ; //<S2SV> bigger = REALLOC ( roll , hold ) ; //<S2SV> if ( bigger == NULL ) { //<S2SV> FREE ( roll ) ; //<S2SV> bail ( "not<S2SV_blank>enough<S2SV_blank>memory" , "" ) ; //<S2SV> } //<S2SV> item = bigger + ( item - roll ) ; //<S2SV> roll = bigger ; //<S2SV> } //<S2SV> strcpy ( item , next -> d_name ) ; //<S2SV> item += len ; //<S2SV> * item = 0 ; //<S2SV> } //<S2SV> closedir ( here ) ; //<S2SV> cut = base = g . inf + strlen ( g . inf ) ; //<S2SV> if ( base > g . inf && base [ - 1 ] != ( unsigned char ) '/' ) { //<S2SV> if ( ( size_t ) ( base - g . inf ) >= sizeof ( g . inf ) ) //<S2SV> bail ( "path<S2SV_blank>too<S2SV_blank>long" , g . inf ) ; //<S2SV> * base ++ = '/' ; //<S2SV> } //<S2SV> item = roll ; //<S2SV> while ( * item ) { //<S2SV> strncpy ( base , item , sizeof ( g . inf ) - ( base - g . inf ) ) ; //<S2SV> if ( g . inf [ sizeof ( g . inf ) - 1 ] ) { //<S2SV> strcpy ( g . inf + ( sizeof ( g . inf ) - 4 ) , "..." ) ; //<S2SV> bail ( "path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>" , g . inf ) ; //<S2SV> } //<S2SV> process ( g . inf ) ; //<S2SV> item += strlen ( item ) + 1 ; //<S2SV> } //<S2SV> * cut = 0 ; //<S2SV> FREE ( roll ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! ( g . force || g . list || g . decode ) && len >= strlen ( g . sufx ) && //<S2SV> strcmp ( g . inf + len - strlen ( g . sufx ) , g . sufx ) == 0 ) { //<S2SV> complain ( "%s<S2SV_blank>ends<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>skipping" , g . inf , g . sufx ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( g . decode == 1 && ! g . pipeout && ! g . list ) { //<S2SV> int suf = compressed_suffix ( g . inf ) ; //<S2SV> if ( suf == 0 ) { //<S2SV> complain ( "%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>compressed<S2SV_blank>suffix<S2SV_blank>--<S2SV_blank>skipping" , //<S2SV> g . inf ) ; //<S2SV> return ; //<S2SV> } //<S2SV> len -= suf ; //<S2SV> } //<S2SV> g . ind = open ( g . inf , O_RDONLY , 0 ) ; //<S2SV> if ( g . ind < 0 ) //<S2SV> bail ( "read<S2SV_blank>error<S2SV_blank>on<S2SV_blank>" , g . inf ) ; //<S2SV> g . name = g . headis & 1 ? justname ( g . inf ) : NULL ; //<S2SV> g . mtime = g . headis & 2 ? st . st_mtime : 0 ; //<S2SV> } //<S2SV> SET_BINARY_MODE ( g . ind ) ; //<S2SV> g . hname = NULL ; //<S2SV> if ( g . decode ) { //<S2SV> in_init ( ) ; //<S2SV> method = get_header ( 1 ) ; //<S2SV> if ( method != 8 && method != 257 && //<S2SV> ! ( method == - 2 && g . force && g . pipeout && g . decode != 2 && //<S2SV> ! g . list ) ) { //<S2SV> RELEASE ( g . hname ) ; //<S2SV> if ( g . ind != 0 ) //<S2SV> close ( g . ind ) ; //<S2SV> if ( method != - 1 ) //<S2SV> complain ( method < 0 ? "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>compressed<S2SV_blank>--<S2SV_blank>skipping" : //<S2SV> "%s<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>--<S2SV_blank>skipping" , //<S2SV> g . inf ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( g . decode == 2 ) { //<S2SV> if ( method == 8 ) //<S2SV> infchk ( ) ; //<S2SV> else { //<S2SV> unlzw ( ) ; //<S2SV> if ( g . list ) { //<S2SV> g . in_tot -= 3 ; //<S2SV> show_info ( method , 0 , g . out_tot , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> RELEASE ( g . hname ) ; //<S2SV> if ( g . ind != 0 ) //<S2SV> close ( g . ind ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> if ( g . list ) { //<S2SV> list_info ( ) ; //<S2SV> RELEASE ( g . hname ) ; //<S2SV> if ( g . ind != 0 ) //<S2SV> close ( g . ind ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( path == NULL || g . pipeout ) { //<S2SV> g . outf = MALLOC ( strlen ( "<stdout>" ) + 1 ) ; //<S2SV> if ( g . outf == NULL ) //<S2SV> bail ( "not<S2SV_blank>enough<S2SV_blank>memory" , "" ) ; //<S2SV> strcpy ( g . outf , "<stdout>" ) ; //<S2SV> g . outd = 1 ; //<S2SV> if ( ! g . decode && ! g . force && isatty ( g . outd ) ) //<S2SV> bail ( "trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>data<S2SV_blank>to<S2SV_blank>a<S2SV_blank>terminal" , //<S2SV> "<S2SV_blank>(use<S2SV_blank>-f<S2SV_blank>to<S2SV_blank>force)" ) ; //<S2SV> } //<S2SV> else { //<S2SV> char * to , * repl ; //<S2SV> to = g . inf ; //<S2SV> if ( g . decode && ( g . headis & 1 ) != 0 && g . hname != NULL ) { //<S2SV> to = g . hname ; //<S2SV> len = strlen ( g . hname ) ; //<S2SV> } //<S2SV> repl = g . decode && strcmp ( to + len , ".tgz" ) ? "" : ".tar" ; //<S2SV> g . outf = MALLOC ( len + ( g . decode ? strlen ( repl ) : strlen ( g . sufx ) ) + 1 ) ; //<S2SV> if ( g . outf == NULL ) //<S2SV> bail ( "not<S2SV_blank>enough<S2SV_blank>memory" , "" ) ; //<S2SV> memcpy ( g . outf , to , len ) ; //<S2SV> strcpy ( g . outf + len , g . decode ? repl : g . sufx ) ; //<S2SV> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY | //<S2SV> ( g . force ? 0 : O_EXCL ) , 0600 ) ; //<S2SV> if ( g . outd < 0 && errno == EEXIST && isatty ( 0 ) && g . verbosity ) { //<S2SV> int ch , reply ; //<S2SV> fprintf ( stderr , "%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>overwrite<S2SV_blank>(y/n)?<S2SV_blank>" , g . outf ) ; //<S2SV> fflush ( stderr ) ; //<S2SV> reply = - 1 ; //<S2SV> do { //<S2SV> ch = getchar ( ) ; //<S2SV> if ( reply < 0 && ch != '<S2SV_blank>' && ch != '\\t' ) //<S2SV> reply = ch == 'y' || ch == 'Y' ? 1 : 0 ; //<S2SV> } while ( ch != EOF && ch != '\\n' && ch != '\\r' ) ; //<S2SV> if ( reply == 1 ) //<S2SV> g . outd = open ( g . outf , O_CREAT | O_TRUNC | O_WRONLY , //<S2SV> 0600 ) ; //<S2SV> } //<S2SV> if ( g . outd < 0 && errno == EEXIST ) { //<S2SV> complain ( "%s<S2SV_blank>exists<S2SV_blank>--<S2SV_blank>skipping" , g . outf ) ; //<S2SV> RELEASE ( g . outf ) ; //<S2SV> RELEASE ( g . hname ) ; //<S2SV> if ( g . ind != 0 ) //<S2SV> close ( g . ind ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( g . outd < 0 ) //<S2SV> bail ( "write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>" , g . outf ) ; //<S2SV> } //<S2SV> SET_BINARY_MODE ( g . outd ) ; //<S2SV> RELEASE ( g . hname ) ; //<S2SV> if ( g . verbosity > 1 ) //<S2SV> fprintf ( stderr , "%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>" , g . inf , g . outf ) ; //<S2SV> if ( g . decode ) { //<S2SV> if ( method == 8 ) //<S2SV> infchk ( ) ; //<S2SV> else if ( method == 257 ) //<S2SV> unlzw ( ) ; //<S2SV> else //<S2SV> cat ( ) ; //<S2SV> } //<S2SV> # ifndef NOTHREAD //<S2SV> else if ( g . procs > 1 ) //<S2SV> parallel_compress ( ) ; //<S2SV> # endif //<S2SV> else //<S2SV> single_compress ( 0 ) ; //<S2SV> if ( g . verbosity > 1 ) { //<S2SV> putc ( '\\n' , stderr ) ; //<S2SV> fflush ( stderr ) ; //<S2SV> } //<S2SV> if ( g . ind != 0 ) //<S2SV> close ( g . ind ) ; //<S2SV> if ( g . outd != 1 ) { //<S2SV> if ( close ( g . outd ) ) //<S2SV> bail ( "write<S2SV_blank>error<S2SV_blank>on<S2SV_blank>" , g . outf ) ; //<S2SV> g . outd = - 1 ; //<S2SV> if ( g . ind != 0 ) { //<S2SV> copymeta ( g . inf , g . outf ) ; //<S2SV> if ( ! g . keep ) //<S2SV> unlink ( g . inf ) ; //<S2SV> } //<S2SV> if ( g . decode && ( g . headis & 2 ) != 0 && g . stamp ) //<S2SV> touch ( g . outf , g . stamp ) ; //<S2SV> } //<S2SV> RELEASE ( g . outf ) ; //<S2SV> } //<S2SV> 