static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * images ) //<S2SV> { //<S2SV> const Image //<S2SV> * next ; //<S2SV> MagickPixelPacket //<S2SV> * * pixels ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> j ; //<S2SV> size_t //<S2SV> columns , //<S2SV> number_threads ; //<S2SV> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; //<S2SV> pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , //<S2SV> sizeof ( * pixels ) ) ; //<S2SV> if ( pixels == ( MagickPixelPacket * * ) NULL ) //<S2SV> return ( ( MagickPixelPacket * * ) NULL ) ; //<S2SV> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; //<S2SV> columns = images -> columns ; //<S2SV> for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) //<S2SV> columns = MagickMax ( next -> columns , columns ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) //<S2SV> { //<S2SV> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( columns , //<S2SV> sizeof ( * * pixels ) ) ; //<S2SV> if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) //<S2SV> return ( DestroyPixelThreadSet ( pixels ) ) ; //<S2SV> for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) //<S2SV> GetMagickPixelPacket ( images , & pixels [ i ] [ j ] ) ; //<S2SV> } //<S2SV> return ( pixels ) ; //<S2SV> } //<S2SV> 