static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define BoundingBox "BoundingBox:" //<S2SV> # define BeginDocument "BeginDocument:" //<S2SV> # define BeginXMPPacket "<?xpacket<S2SV_blank>begin=" //<S2SV> # define EndXMPPacket "<?xpacket<S2SV_blank>end=" //<S2SV> # define ICCProfile "BeginICCProfile:" //<S2SV> # define CMYKCustomColor "CMYKCustomColor:" //<S2SV> # define CMYKProcessColor "CMYKProcessColor:" //<S2SV> # define DocumentMedia "DocumentMedia:" //<S2SV> # define DocumentCustomColors "DocumentCustomColors:" //<S2SV> # define DocumentProcessColors "DocumentProcessColors:" //<S2SV> # define EndDocument "EndDocument:" //<S2SV> # define HiResBoundingBox "HiResBoundingBox:" //<S2SV> # define ImageData "ImageData:" //<S2SV> # define PageBoundingBox "PageBoundingBox:" //<S2SV> # define LanguageLevel "LanguageLevel:" //<S2SV> # define PageMedia "PageMedia:" //<S2SV> # define Pages "Pages:" //<S2SV> # define PhotoshopProfile "BeginPhotoshop:" //<S2SV> # define PostscriptLevel "!PS-" //<S2SV> # define RenderPostscriptText "<S2SV_blank><S2SV_blank>Rendering<S2SV_blank>Postscript...<S2SV_blank><S2SV_blank>" //<S2SV> # define SpotColor "+<S2SV_blank>" //<S2SV> char //<S2SV> command [ MaxTextExtent ] , //<S2SV> * density , //<S2SV> filename [ MaxTextExtent ] , //<S2SV> geometry [ MaxTextExtent ] , //<S2SV> input_filename [ MaxTextExtent ] , //<S2SV> message [ MaxTextExtent ] , //<S2SV> * options , //<S2SV> postscript_filename [ MaxTextExtent ] ; //<S2SV> const char //<S2SV> * option ; //<S2SV> const DelegateInfo //<S2SV> * delegate_info ; //<S2SV> GeometryInfo //<S2SV> geometry_info ; //<S2SV> Image //<S2SV> * image , //<S2SV> * next , //<S2SV> * postscript_image ; //<S2SV> ImageInfo //<S2SV> * read_info ; //<S2SV> int //<S2SV> c , //<S2SV> file ; //<S2SV> MagickBooleanType //<S2SV> cmyk , //<S2SV> fitPage , //<S2SV> skip , //<S2SV> status ; //<S2SV> MagickStatusType //<S2SV> flags ; //<S2SV> PointInfo //<S2SV> delta , //<S2SV> resolution ; //<S2SV> RectangleInfo //<S2SV> page ; //<S2SV> register char //<S2SV> * p ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> SegmentInfo //<S2SV> bounds , //<S2SV> hires_bounds ; //<S2SV> short int //<S2SV> hex_digits [ 256 ] ; //<S2SV> size_t //<S2SV> length , //<S2SV> priority ; //<S2SV> ssize_t //<S2SV> count ; //<S2SV> StringInfo //<S2SV> * profile ; //<S2SV> unsigned long //<S2SV> columns , //<S2SV> extent , //<S2SV> language_level , //<S2SV> pages , //<S2SV> rows , //<S2SV> scene , //<S2SV> spotcolor ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> status = AcquireUniqueSymbolicLink ( image_info -> filename , input_filename ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , FileOpenError , "UnableToCreateTemporaryFile" , //<S2SV> image_info -> filename ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) memset ( hex_digits , 0 , sizeof ( hex_digits ) ) ; //<S2SV> hex_digits [ ( int ) '0' ] = 0 ; //<S2SV> hex_digits [ ( int ) '1' ] = 1 ; //<S2SV> hex_digits [ ( int ) '2' ] = 2 ; //<S2SV> hex_digits [ ( int ) '3' ] = 3 ; //<S2SV> hex_digits [ ( int ) '4' ] = 4 ; //<S2SV> hex_digits [ ( int ) '5' ] = 5 ; //<S2SV> hex_digits [ ( int ) '6' ] = 6 ; //<S2SV> hex_digits [ ( int ) '7' ] = 7 ; //<S2SV> hex_digits [ ( int ) '8' ] = 8 ; //<S2SV> hex_digits [ ( int ) '9' ] = 9 ; //<S2SV> hex_digits [ ( int ) 'a' ] = 10 ; //<S2SV> hex_digits [ ( int ) 'b' ] = 11 ; //<S2SV> hex_digits [ ( int ) 'c' ] = 12 ; //<S2SV> hex_digits [ ( int ) 'd' ] = 13 ; //<S2SV> hex_digits [ ( int ) 'e' ] = 14 ; //<S2SV> hex_digits [ ( int ) 'f' ] = 15 ; //<S2SV> hex_digits [ ( int ) 'A' ] = 10 ; //<S2SV> hex_digits [ ( int ) 'B' ] = 11 ; //<S2SV> hex_digits [ ( int ) 'C' ] = 12 ; //<S2SV> hex_digits [ ( int ) 'D' ] = 13 ; //<S2SV> hex_digits [ ( int ) 'E' ] = 14 ; //<S2SV> hex_digits [ ( int ) 'F' ] = 15 ; //<S2SV> delta . x = DefaultResolution ; //<S2SV> delta . y = DefaultResolution ; //<S2SV> if ( ( image -> x_resolution == 0.0 ) || ( image -> y_resolution == 0.0 ) ) //<S2SV> { //<S2SV> flags = ParseGeometry ( PSDensityGeometry , & geometry_info ) ; //<S2SV> image -> x_resolution = geometry_info . rho ; //<S2SV> image -> y_resolution = geometry_info . sigma ; //<S2SV> if ( ( flags & SigmaValue ) == 0 ) //<S2SV> image -> y_resolution = image -> x_resolution ; //<S2SV> } //<S2SV> if ( image_info -> density != ( char * ) NULL ) //<S2SV> { //<S2SV> flags = ParseGeometry ( image_info -> density , & geometry_info ) ; //<S2SV> image -> x_resolution = geometry_info . rho ; //<S2SV> image -> y_resolution = geometry_info . sigma ; //<S2SV> if ( ( flags & SigmaValue ) == 0 ) //<S2SV> image -> y_resolution = image -> x_resolution ; //<S2SV> } //<S2SV> ( void ) ParseAbsoluteGeometry ( PSPageGeometry , & page ) ; //<S2SV> if ( image_info -> page != ( char * ) NULL ) //<S2SV> ( void ) ParseAbsoluteGeometry ( image_info -> page , & page ) ; //<S2SV> resolution . x = image -> x_resolution ; //<S2SV> resolution . y = image -> y_resolution ; //<S2SV> page . width = ( size_t ) ceil ( ( double ) ( page . width * resolution . x / delta . x ) - 0.5 ) ; //<S2SV> page . height = ( size_t ) ceil ( ( double ) ( page . height * resolution . y / delta . y ) - 0.5 ) ; //<S2SV> ( void ) memset ( & bounds , 0 , sizeof ( bounds ) ) ; //<S2SV> ( void ) memset ( command , 0 , sizeof ( command ) ) ; //<S2SV> cmyk = image_info -> colorspace == CMYKColorspace ? MagickTrue : MagickFalse ; //<S2SV> ( void ) memset ( & hires_bounds , 0 , sizeof ( hires_bounds ) ) ; //<S2SV> priority = 0 ; //<S2SV> columns = 0 ; //<S2SV> rows = 0 ; //<S2SV> extent = 0 ; //<S2SV> spotcolor = 0 ; //<S2SV> language_level = 1 ; //<S2SV> skip = MagickFalse ; //<S2SV> pages = ( ~ 0UL ) ; //<S2SV> p = command ; //<S2SV> for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) //<S2SV> { //<S2SV> * p ++ = ( char ) c ; //<S2SV> if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && //<S2SV> ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) //<S2SV> continue ; //<S2SV> * p = '\\0' ; //<S2SV> p = command ; //<S2SV> if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) //<S2SV> skip = MagickTrue ; //<S2SV> if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) //<S2SV> skip = MagickFalse ; //<S2SV> if ( skip != MagickFalse ) //<S2SV> continue ; //<S2SV> if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) //<S2SV> { //<S2SV> ( void ) SetImageProperty ( image , "ps:Level" , command + 4 ) ; //<S2SV> if ( GlobExpression ( command , "*EPSF-*" , MagickTrue ) != MagickFalse ) //<S2SV> pages = 1 ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) //<S2SV> ( void ) sscanf ( command , LanguageLevel "<S2SV_blank>%lu" , & language_level ) ; //<S2SV> if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) //<S2SV> ( void ) sscanf ( command , Pages "<S2SV_blank>%lu" , & pages ) ; //<S2SV> if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) //<S2SV> ( void ) sscanf ( command , ImageData "<S2SV_blank>%lu<S2SV_blank>%lu" , & columns , & rows ) ; //<S2SV> length = strlen ( DocumentProcessColors ) ; //<S2SV> if ( LocaleNCompare ( DocumentProcessColors , command , length ) == 0 ) //<S2SV> { //<S2SV> if ( ( GlobExpression ( command , "*Cyan*" , MagickTrue ) != MagickFalse ) || //<S2SV> ( GlobExpression ( command , "*Magenta*" , MagickTrue ) != MagickFalse ) || //<S2SV> ( GlobExpression ( command , "*Yellow*" , MagickTrue ) != MagickFalse ) ) //<S2SV> cmyk = MagickTrue ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) //<S2SV> cmyk = MagickTrue ; //<S2SV> if ( LocaleNCompare ( CMYKProcessColor , command , strlen ( CMYKProcessColor ) ) == 0 ) //<S2SV> cmyk = MagickTrue ; //<S2SV> length = strlen ( DocumentCustomColors ) ; //<S2SV> if ( ( LocaleNCompare ( DocumentCustomColors , command , length ) == 0 ) || //<S2SV> ( LocaleNCompare ( CMYKCustomColor , command , strlen ( CMYKCustomColor ) ) == 0 ) || //<S2SV> ( LocaleNCompare ( SpotColor , command , strlen ( SpotColor ) ) == 0 ) ) //<S2SV> { //<S2SV> char //<S2SV> property [ MaxTextExtent ] , //<S2SV> * value ; //<S2SV> register char //<S2SV> * p ; //<S2SV> ( void ) FormatLocaleString ( property , MaxTextExtent , "ps:SpotColor-%.20g" , //<S2SV> ( double ) ( spotcolor ++ ) ) ; //<S2SV> for ( p = command ; * p != '\\0' ; p ++ ) //<S2SV> if ( isspace ( ( int ) ( unsigned char ) * p ) != 0 ) //<S2SV> break ; //<S2SV> value = ConstantString ( p ) ; //<S2SV> ( void ) SubstituteString ( & value , "(" , "" ) ; //<S2SV> ( void ) SubstituteString ( & value , ")" , "" ) ; //<S2SV> ( void ) StripString ( value ) ; //<S2SV> if ( * value != '\\0' ) //<S2SV> ( void ) SetImageProperty ( image , property , value ) ; //<S2SV> value = DestroyString ( value ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( image_info -> page != ( char * ) NULL ) //<S2SV> continue ; //<S2SV> count = 0 ; //<S2SV> i = 0 ; //<S2SV> if ( LocaleNCompare ( BoundingBox , command , strlen ( BoundingBox ) ) == 0 ) //<S2SV> { //<S2SV> count = ( ssize_t ) sscanf ( command , BoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , //<S2SV> & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; //<S2SV> i = 2 ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( DocumentMedia , command , strlen ( DocumentMedia ) ) == 0 ) //<S2SV> { //<S2SV> count = ( ssize_t ) sscanf ( command , DocumentMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , //<S2SV> & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; //<S2SV> i = 1 ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( HiResBoundingBox , command , strlen ( HiResBoundingBox ) ) == 0 ) //<S2SV> { //<S2SV> count = ( ssize_t ) sscanf ( command , HiResBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , //<S2SV> & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; //<S2SV> i = 3 ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( PageBoundingBox , command , strlen ( PageBoundingBox ) ) == 0 ) //<S2SV> { //<S2SV> count = ( ssize_t ) sscanf ( command , PageBoundingBox "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , //<S2SV> & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; //<S2SV> i = 1 ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( PageMedia , command , strlen ( PageMedia ) ) == 0 ) //<S2SV> { //<S2SV> count = ( ssize_t ) sscanf ( command , PageMedia "<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf<S2SV_blank>%lf" , //<S2SV> & bounds . x1 , & bounds . y1 , & bounds . x2 , & bounds . y2 ) ; //<S2SV> i = 1 ; //<S2SV> } //<S2SV> if ( ( count != 4 ) || ( i < ( ssize_t ) priority ) ) //<S2SV> continue ; //<S2SV> if ( ( fabs ( bounds . x2 - bounds . x1 ) <= fabs ( hires_bounds . x2 - hires_bounds . x1 ) ) || //<S2SV> ( fabs ( bounds . y2 - bounds . y1 ) <= fabs ( hires_bounds . y2 - hires_bounds . y1 ) ) ) //<S2SV> if ( i == ( ssize_t ) priority ) //<S2SV> continue ; //<S2SV> hires_bounds = bounds ; //<S2SV> priority = ( size_t ) i ; //<S2SV> } //<S2SV> if ( ( fabs ( hires_bounds . x2 - hires_bounds . x1 ) >= MagickEpsilon ) && //<S2SV> ( fabs ( hires_bounds . y2 - hires_bounds . y1 ) >= MagickEpsilon ) ) //<S2SV> { //<S2SV> ( void ) FormatLocaleString ( geometry , MaxTextExtent , "%gx%g%+.15g%+.15g" , //<S2SV> hires_bounds . x2 - hires_bounds . x1 , hires_bounds . y2 - hires_bounds . y1 , //<S2SV> hires_bounds . x1 , hires_bounds . y1 ) ; //<S2SV> ( void ) SetImageProperty ( image , "ps:HiResBoundingBox" , geometry ) ; //<S2SV> page . width = ( size_t ) ceil ( ( double ) ( ( hires_bounds . x2 - hires_bounds . x1 ) * //<S2SV> resolution . x / delta . x ) - 0.5 ) ; //<S2SV> page . height = ( size_t ) ceil ( ( double ) ( ( hires_bounds . y2 - hires_bounds . y1 ) * //<S2SV> resolution . y / delta . y ) - 0.5 ) ; //<S2SV> } //<S2SV> fitPage = MagickFalse ; //<S2SV> option = GetImageOption ( image_info , "eps:fit-page" ) ; //<S2SV> if ( option != ( char * ) NULL ) //<S2SV> { //<S2SV> char //<S2SV> * geometry ; //<S2SV> MagickStatusType //<S2SV> flags ; //<S2SV> geometry = GetPageGeometry ( option ) ; //<S2SV> flags = ParseMetaGeometry ( geometry , & page . x , & page . y , & page . width , //<S2SV> & page . height ) ; //<S2SV> if ( flags == NoValue ) //<S2SV> { //<S2SV> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , OptionError , //<S2SV> "InvalidGeometry" , "`%s\'" , option ) ; //<S2SV> image = DestroyImage ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> page . width = ( size_t ) ceil ( ( double ) ( page . width * image -> x_resolution / delta . x ) //<S2SV> - 0.5 ) ; //<S2SV> page . height = ( size_t ) ceil ( ( double ) ( page . height * image -> y_resolution / //<S2SV> delta . y ) - 0.5 ) ; //<S2SV> geometry = DestroyString ( geometry ) ; //<S2SV> fitPage = MagickTrue ; //<S2SV> } //<S2SV> if ( IssRGBCompatibleColorspace ( image_info -> colorspace ) != MagickFalse ) //<S2SV> cmyk = MagickFalse ; //<S2SV> file = AcquireUniqueFileResource ( postscript_filename ) ; //<S2SV> if ( file == - 1 ) //<S2SV> { //<S2SV> ThrowFileException ( & image -> exception , FileOpenError , "UnableToOpenFile" , //<S2SV> image_info -> filename ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) CopyMagickString ( command , "/setpagedevice<S2SV_blank>{pop}<S2SV_blank>bind<S2SV_blank>1<S2SV_blank>index<S2SV_blank>where<S2SV_blank>{" //<S2SV> "dup<S2SV_blank>wcheck<S2SV_blank>{3<S2SV_blank>1<S2SV_blank>roll<S2SV_blank>put}<S2SV_blank>{pop<S2SV_blank>def}<S2SV_blank>ifelse}<S2SV_blank>{def}<S2SV_blank>ifelse\\n" //<S2SV> "<</UseCIEColor<S2SV_blank>true>>setpagedevice\\n" , MaxTextExtent ) ; //<S2SV> count = write ( file , command , ( unsigned int ) strlen ( command ) ) ; //<S2SV> if ( image_info -> page == ( char * ) NULL ) //<S2SV> { //<S2SV> char //<S2SV> translate_geometry [ MaxTextExtent ] ; //<S2SV> ( void ) FormatLocaleString ( translate_geometry , MaxTextExtent , //<S2SV> "%g<S2SV_blank>%g<S2SV_blank>translate\\n" , - hires_bounds . x1 , - hires_bounds . y1 ) ; //<S2SV> count = write ( file , translate_geometry , ( unsigned int ) //<S2SV> strlen ( translate_geometry ) ) ; //<S2SV> } //<S2SV> file = close ( file ) - 1 ; //<S2SV> if ( image_info -> monochrome != MagickFalse ) //<S2SV> delegate_info = GetDelegateInfo ( "ps:mono" , ( char * ) NULL , exception ) ; //<S2SV> else //<S2SV> if ( cmyk != MagickFalse ) //<S2SV> delegate_info = GetDelegateInfo ( "ps:cmyk" , ( char * ) NULL , exception ) ; //<S2SV> else //<S2SV> delegate_info = GetDelegateInfo ( "ps:alpha" , ( char * ) NULL , exception ) ; //<S2SV> if ( delegate_info == ( const DelegateInfo * ) NULL ) //<S2SV> { //<S2SV> ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> density = AcquireString ( "" ) ; //<S2SV> options = AcquireString ( "" ) ; //<S2SV> ( void ) FormatLocaleString ( density , MaxTextExtent , "%gx%g" , resolution . x , //<S2SV> resolution . y ) ; //<S2SV> ( void ) FormatLocaleString ( options , MaxTextExtent , "-g%.20gx%.20g<S2SV_blank>" , ( double ) //<S2SV> page . width , ( double ) page . height ) ; //<S2SV> read_info = CloneImageInfo ( image_info ) ; //<S2SV> * read_info -> magick = '\\0' ; //<S2SV> if ( read_info -> number_scenes != 0 ) //<S2SV> { //<S2SV> char //<S2SV> pages [ MaxTextExtent ] ; //<S2SV> ( void ) FormatLocaleString ( pages , MaxTextExtent , "-dFirstPage=%.20g<S2SV_blank>" //<S2SV> "-dLastPage=%.20g<S2SV_blank>" , ( double ) read_info -> scene + 1 , ( double ) //<S2SV> ( read_info -> scene + read_info -> number_scenes ) ) ; //<S2SV> ( void ) ConcatenateMagickString ( options , pages , MaxTextExtent ) ; //<S2SV> read_info -> number_scenes = 0 ; //<S2SV> if ( read_info -> scenes != ( char * ) NULL ) //<S2SV> * read_info -> scenes = '\\0' ; //<S2SV> } //<S2SV> if ( * image_info -> magick == 'E' ) //<S2SV> { //<S2SV> option = GetImageOption ( image_info , "eps:use-cropbox" ) ; //<S2SV> if ( ( option == ( const char * ) NULL ) || //<S2SV> ( IsStringTrue ( option ) != MagickFalse ) ) //<S2SV> ( void ) ConcatenateMagickString ( options , "-dEPSCrop<S2SV_blank>" , MaxTextExtent ) ; //<S2SV> if ( fitPage != MagickFalse ) //<S2SV> ( void ) ConcatenateMagickString ( options , "-dEPSFitPage<S2SV_blank>" , MaxTextExtent ) ; //<S2SV> } //<S2SV> ( void ) CopyMagickString ( filename , read_info -> filename , MaxTextExtent ) ; //<S2SV> ( void ) AcquireUniqueFilename ( filename ) ; //<S2SV> ( void ) RelinquishUniqueFileResource ( filename ) ; //<S2SV> ( void ) ConcatenateMagickString ( filename , "%d" , MaxTextExtent ) ; //<S2SV> ( void ) FormatLocaleString ( command , MaxTextExtent , //<S2SV> GetDelegateCommands ( delegate_info ) , //<S2SV> read_info -> antialias != MagickFalse ? 4 : 1 , //<S2SV> read_info -> antialias != MagickFalse ? 4 : 1 , density , options , filename , //<S2SV> postscript_filename , input_filename ) ; //<S2SV> options = DestroyString ( options ) ; //<S2SV> density = DestroyString ( density ) ; //<S2SV> * message = '\\0' ; //<S2SV> status = InvokePostscriptDelegate ( read_info -> verbose , command , message , exception ) ; //<S2SV> ( void ) InterpretImageFilename ( image_info , image , filename , 1 , //<S2SV> read_info -> filename ) ; //<S2SV> if ( ( status == MagickFalse ) || //<S2SV> ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) ) //<S2SV> { //<S2SV> ( void ) ConcatenateMagickString ( command , "<S2SV_blank>-c<S2SV_blank>showpage" , MaxTextExtent ) ; //<S2SV> status = InvokePostscriptDelegate ( read_info -> verbose , command , message , //<S2SV> exception ) ; //<S2SV> } //<S2SV> ( void ) RelinquishUniqueFileResource ( postscript_filename ) ; //<S2SV> ( void ) RelinquishUniqueFileResource ( input_filename ) ; //<S2SV> postscript_image = ( Image * ) NULL ; //<S2SV> if ( status == MagickFalse ) //<S2SV> for ( i = 1 ; ; i ++ ) //<S2SV> { //<S2SV> ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , //<S2SV> read_info -> filename ) ; //<S2SV> if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) //<S2SV> break ; //<S2SV> ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; //<S2SV> } //<S2SV> else //<S2SV> for ( i = 1 ; ; i ++ ) //<S2SV> { //<S2SV> ( void ) InterpretImageFilename ( image_info , image , filename , ( int ) i , //<S2SV> read_info -> filename ) ; //<S2SV> if ( IsPostscriptRendered ( read_info -> filename ) == MagickFalse ) //<S2SV> break ; //<S2SV> read_info -> blob = NULL ; //<S2SV> read_info -> length = 0 ; //<S2SV> next = ReadImage ( read_info , exception ) ; //<S2SV> ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; //<S2SV> if ( next == ( Image * ) NULL ) //<S2SV> break ; //<S2SV> AppendImageToList ( & postscript_image , next ) ; //<S2SV> } //<S2SV> ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; //<S2SV> read_info = DestroyImageInfo ( read_info ) ; //<S2SV> if ( postscript_image == ( Image * ) NULL ) //<S2SV> { //<S2SV> if ( * message != '\\0' ) //<S2SV> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , DelegateError , //<S2SV> "PostscriptDelegateFailed" , "`%s\'" , message ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> if ( LocaleCompare ( postscript_image -> magick , "BMP" ) == 0 ) //<S2SV> { //<S2SV> Image //<S2SV> * cmyk_image ; //<S2SV> cmyk_image = ConsolidateCMYKImages ( postscript_image , exception ) ; //<S2SV> if ( cmyk_image != ( Image * ) NULL ) //<S2SV> { //<S2SV> postscript_image = DestroyImageList ( postscript_image ) ; //<S2SV> postscript_image = cmyk_image ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; //<S2SV> for ( c = ReadBlobByte ( image ) ; c != EOF ; c = ReadBlobByte ( image ) ) //<S2SV> { //<S2SV> * p ++ = ( char ) c ; //<S2SV> if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && //<S2SV> ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) //<S2SV> continue ; //<S2SV> * p = '\\0' ; //<S2SV> p = command ; //<S2SV> if ( LocaleNCompare ( BeginDocument , command , strlen ( BeginDocument ) ) == 0 ) //<S2SV> skip = MagickTrue ; //<S2SV> if ( LocaleNCompare ( EndDocument , command , strlen ( EndDocument ) ) == 0 ) //<S2SV> skip = MagickFalse ; //<S2SV> if ( skip != MagickFalse ) //<S2SV> continue ; //<S2SV> if ( LocaleNCompare ( PostscriptLevel , command , strlen ( PostscriptLevel ) ) == 0 ) //<S2SV> { //<S2SV> ( void ) SetImageProperty ( image , "ps:Level" , command + 4 ) ; //<S2SV> if ( GlobExpression ( command , "*EPSF-*" , MagickTrue ) != MagickFalse ) //<S2SV> pages = 1 ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( LanguageLevel , command , strlen ( LanguageLevel ) ) == 0 ) //<S2SV> ( void ) sscanf ( command , LanguageLevel "<S2SV_blank>%lu" , & language_level ) ; //<S2SV> if ( LocaleNCompare ( Pages , command , strlen ( Pages ) ) == 0 ) //<S2SV> ( void ) sscanf ( command , Pages "<S2SV_blank>%lu" , & pages ) ; //<S2SV> if ( LocaleNCompare ( ImageData , command , strlen ( ImageData ) ) == 0 ) //<S2SV> ( void ) sscanf ( command , ImageData "<S2SV_blank>%lu<S2SV_blank>%lu" , & columns , & rows ) ; //<S2SV> if ( LocaleNCompare ( ICCProfile , command , strlen ( ICCProfile ) ) == 0 ) //<S2SV> { //<S2SV> unsigned char //<S2SV> * datum ; //<S2SV> profile = AcquireStringInfo ( MaxTextExtent ) ; //<S2SV> datum = GetStringInfoDatum ( profile ) ; //<S2SV> for ( i = 0 ; ( c = ProfileInteger ( image , hex_digits ) ) != EOF ; i ++ ) //<S2SV> { //<S2SV> if ( i >= ( ssize_t ) GetStringInfoLength ( profile ) ) //<S2SV> { //<S2SV> SetStringInfoLength ( profile , ( size_t ) i << 1 ) ; //<S2SV> datum = GetStringInfoDatum ( profile ) ; //<S2SV> } //<S2SV> datum [ i ] = ( unsigned char ) c ; //<S2SV> } //<S2SV> SetStringInfoLength ( profile , ( size_t ) i + 1 ) ; //<S2SV> ( void ) SetImageProfile ( image , "icc" , profile ) ; //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( PhotoshopProfile , command , strlen ( PhotoshopProfile ) ) == 0 ) //<S2SV> { //<S2SV> unsigned char //<S2SV> * p ; //<S2SV> count = ( ssize_t ) sscanf ( command , PhotoshopProfile "<S2SV_blank>%lu" , & extent ) ; //<S2SV> if ( count != 1 ) //<S2SV> continue ; //<S2SV> length = extent ; //<S2SV> if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; //<S2SV> if ( profile != ( StringInfo * ) NULL ) //<S2SV> { //<S2SV> p = GetStringInfoDatum ( profile ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) //<S2SV> * p ++ = ( unsigned char ) ProfileInteger ( image , hex_digits ) ; //<S2SV> ( void ) SetImageProfile ( image , "8bim" , profile ) ; //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( BeginXMPPacket , command , strlen ( BeginXMPPacket ) ) == 0 ) //<S2SV> { //<S2SV> register size_t //<S2SV> i ; //<S2SV> p = command ; //<S2SV> profile = StringToStringInfo ( command ) ; //<S2SV> for ( i = GetStringInfoLength ( profile ) - 1 ; c != EOF ; i ++ ) //<S2SV> { //<S2SV> SetStringInfoLength ( profile , ( size_t ) ( i + 1 ) ) ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> GetStringInfoDatum ( profile ) [ i ] = ( unsigned char ) c ; //<S2SV> * p ++ = ( char ) c ; //<S2SV> if ( ( strchr ( "\\n\\r%" , c ) == ( char * ) NULL ) && //<S2SV> ( ( size_t ) ( p - command ) < ( MaxTextExtent - 1 ) ) ) //<S2SV> continue ; //<S2SV> * p = '\\0' ; //<S2SV> p = command ; //<S2SV> if ( LocaleNCompare ( EndXMPPacket , command , strlen ( EndXMPPacket ) ) == 0 ) //<S2SV> break ; //<S2SV> } //<S2SV> SetStringInfoLength ( profile , ( size_t ) i ) ; //<S2SV> ( void ) SetImageProfile ( image , "xmp" , profile ) ; //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> { //<S2SV> Image //<S2SV> * clone_image ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image_info -> scene ; i ++ ) //<S2SV> { //<S2SV> clone_image = CloneImage ( postscript_image , 1 , 1 , MagickTrue , exception ) ; //<S2SV> if ( clone_image != ( Image * ) NULL ) //<S2SV> PrependImageToList ( & postscript_image , clone_image ) ; //<S2SV> } //<S2SV> } //<S2SV> do //<S2SV> { //<S2SV> ( void ) CopyMagickString ( postscript_image -> filename , filename , MaxTextExtent ) ; //<S2SV> ( void ) CopyMagickString ( postscript_image -> magick , image -> magick , //<S2SV> MaxTextExtent ) ; //<S2SV> if ( columns != 0 ) //<S2SV> postscript_image -> magick_columns = columns ; //<S2SV> if ( rows != 0 ) //<S2SV> postscript_image -> magick_rows = rows ; //<S2SV> postscript_image -> page = page ; //<S2SV> ( void ) CloneImageProfiles ( postscript_image , image ) ; //<S2SV> ( void ) CloneImageProperties ( postscript_image , image ) ; //<S2SV> next = SyncNextImageInList ( postscript_image ) ; //<S2SV> if ( next != ( Image * ) NULL ) //<S2SV> postscript_image = next ; //<S2SV> } while ( next != ( Image * ) NULL ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> scene = 0 ; //<S2SV> for ( next = GetFirstImageInList ( postscript_image ) ; next != ( Image * ) NULL ; ) //<S2SV> { //<S2SV> next -> scene = scene ++ ; //<S2SV> next = GetNextImageInList ( next ) ; //<S2SV> } //<S2SV> return ( GetFirstImageInList ( postscript_image ) ) ; //<S2SV> } //<S2SV> 