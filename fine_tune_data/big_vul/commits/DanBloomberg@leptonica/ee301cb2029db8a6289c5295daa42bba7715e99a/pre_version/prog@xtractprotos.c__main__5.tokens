int main ( int argc , //<S2SV> char * * argv ) //<S2SV> { //<S2SV> char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; //<S2SV> const char * spacestr = "<S2SV_blank>" ; //<S2SV> char buf [ L_BUF_SIZE ] ; //<S2SV> l_uint8 * allheaders ; //<S2SV> l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; //<S2SV> size_t nbytes ; //<S2SV> L_BYTEA * ba , * ba2 ; //<S2SV> SARRAY * sa , * safirst ; //<S2SV> static char mainName [ ] = "xtractprotos" ; //<S2SV> if ( argc == 1 ) { //<S2SV> fprintf ( stderr , //<S2SV> "xtractprotos<S2SV_blank>[-prestring=<string>]<S2SV_blank>[-protos=<where>]<S2SV_blank>" //<S2SV> "[list<S2SV_blank>of<S2SV_blank>C<S2SV_blank>files]\\n" //<S2SV> "where<S2SV_blank>the<S2SV_blank>prestring<S2SV_blank>is<S2SV_blank>prepended<S2SV_blank>to<S2SV_blank>each<S2SV_blank>prototype,<S2SV_blank>and<S2SV_blank>\\n" //<S2SV> "protos<S2SV_blank>can<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'inline\'<S2SV_blank>or<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>an<S2SV_blank>output<S2SV_blank>" //<S2SV> "prototype<S2SV_blank>file\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> prestring = outprotos = NULL ; //<S2SV> in_line = FALSE ; //<S2SV> nflags = 0 ; //<S2SV> maxindex = L_MIN ( 3 , argc ) ; //<S2SV> for ( i = 1 ; i < maxindex ; i ++ ) { //<S2SV> if ( argv [ i ] [ 0 ] == '-' ) { //<S2SV> if ( ! strncmp ( argv [ i ] , "-prestring" , 10 ) ) { //<S2SV> nflags ++ ; //<S2SV> ret = sscanf ( argv [ i ] + 1 , "prestring=%s" , buf ) ; //<S2SV> if ( ret != 1 ) { //<S2SV> fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>prestring\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3 ) { //<S2SV> L_WARNING ( "prestring<S2SV_blank>too<S2SV_blank>large;<S2SV_blank>omitting!\\n" , mainName ) ; //<S2SV> } else { //<S2SV> buf [ len ] = '<S2SV_blank>' ; //<S2SV> buf [ len + 1 ] = '\\0' ; //<S2SV> prestring = stringNew ( buf ) ; //<S2SV> } //<S2SV> } else if ( ! strncmp ( argv [ i ] , "-protos" , 7 ) ) { //<S2SV> nflags ++ ; //<S2SV> ret = sscanf ( argv [ i ] + 1 , "protos=%s" , buf ) ; //<S2SV> if ( ret != 1 ) { //<S2SV> fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>protos\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> outprotos = stringNew ( buf ) ; //<S2SV> if ( ! strncmp ( outprotos , "inline" , 7 ) ) //<S2SV> in_line = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( argc - nflags < 2 ) { //<S2SV> fprintf ( stderr , "no<S2SV_blank>files<S2SV_blank>specified!\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> ba = l_byteaCreate ( 500 ) ; //<S2SV> sa = sarrayCreate ( 0 ) ; //<S2SV> sarrayAddString ( sa , ( char * ) "/*" , L_COPY ) ; //<S2SV> snprintf ( buf , L_BUF_SIZE , //<S2SV> "<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s" , //<S2SV> version ) ; //<S2SV> sarrayAddString ( sa , buf , L_COPY ) ; //<S2SV> sarrayAddString ( sa , ( char * ) "<S2SV_blank>*/" , L_COPY ) ; //<S2SV> sarrayAddString ( sa , ( char * ) "#ifdef<S2SV_blank>__cplusplus" , L_COPY ) ; //<S2SV> sarrayAddString ( sa , ( char * ) "extern<S2SV_blank>\\"C\\"<S2SV_blank>{" , L_COPY ) ; //<S2SV> sarrayAddString ( sa , ( char * ) "#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/\\n" , L_COPY ) ; //<S2SV> str = sarrayToString ( sa , 1 ) ; //<S2SV> l_byteaAppendString ( ba , str ) ; //<S2SV> lept_free ( str ) ; //<S2SV> sarrayDestroy ( & sa ) ; //<S2SV> firstfile = 1 + nflags ; //<S2SV> protos_added = FALSE ; //<S2SV> if ( ( tempfile = l_makeTempFilename ( ) ) == NULL ) { //<S2SV> fprintf ( stderr , "failure<S2SV_blank>to<S2SV_blank>make<S2SV_blank>a<S2SV_blank>writeable<S2SV_blank>temp<S2SV_blank>file\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> for ( i = firstfile ; i < argc ; i ++ ) { //<S2SV> filein = argv [ i ] ; //<S2SV> len = strlen ( filein ) ; //<S2SV> if ( filein [ len - 1 ] == 'h' ) //<S2SV> continue ; //<S2SV> snprintf ( buf , L_BUF_SIZE , "cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s" , //<S2SV> filein , tempfile ) ; //<S2SV> ret = system ( buf ) ; //<S2SV> if ( ret ) { //<S2SV> fprintf ( stderr , "cpp<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n" , filein ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( str = parseForProtos ( tempfile , prestring ) ) == NULL ) { //<S2SV> fprintf ( stderr , "parse<S2SV_blank>failure<S2SV_blank>for<S2SV_blank>%s;<S2SV_blank>continuing\\n" , filein ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( strlen ( str ) > 1 ) { //<S2SV> l_byteaAppendString ( ba , str ) ; //<S2SV> protos_added = TRUE ; //<S2SV> } //<S2SV> lept_free ( str ) ; //<S2SV> } //<S2SV> lept_rmfile ( tempfile ) ; //<S2SV> lept_free ( tempfile ) ; //<S2SV> sa = sarrayCreate ( 0 ) ; //<S2SV> sarrayAddString ( sa , ( char * ) "\\n#ifdef<S2SV_blank>__cplusplus" , L_COPY ) ; //<S2SV> sarrayAddString ( sa , ( char * ) "}" , L_COPY ) ; //<S2SV> sarrayAddString ( sa , ( char * ) "#endif<S2SV_blank><S2SV_blank>/*<S2SV_blank>__cplusplus<S2SV_blank>*/" , L_COPY ) ; //<S2SV> str = sarrayToString ( sa , 1 ) ; //<S2SV> l_byteaAppendString ( ba , str ) ; //<S2SV> lept_free ( str ) ; //<S2SV> sarrayDestroy ( & sa ) ; //<S2SV> protostr = ( char * ) l_byteaCopyData ( ba , & nbytes ) ; //<S2SV> l_byteaDestroy ( & ba ) ; //<S2SV> if ( ! outprotos ) { //<S2SV> fprintf ( stderr , "%s\\n" , protostr ) ; //<S2SV> lept_free ( protostr ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! protos_added ) { //<S2SV> fprintf ( stderr , "No<S2SV_blank>protos<S2SV_blank>found\\n" ) ; //<S2SV> lept_free ( protostr ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> ba = l_byteaInitFromFile ( "allheaders_top.txt" ) ; //<S2SV> if ( ! in_line ) { //<S2SV> snprintf ( buf , sizeof ( buf ) , "#include<S2SV_blank>\\"%s\\"\\n" , outprotos ) ; //<S2SV> l_byteaAppendString ( ba , buf ) ; //<S2SV> l_binaryWrite ( outprotos , "w" , protostr , nbytes ) ; //<S2SV> } else { //<S2SV> l_byteaAppendString ( ba , protostr ) ; //<S2SV> } //<S2SV> ba2 = l_byteaInitFromFile ( "allheaders_bot.txt" ) ; //<S2SV> l_byteaJoin ( ba , & ba2 ) ; //<S2SV> l_byteaWrite ( "allheaders.h" , ba , 0 , 0 ) ; //<S2SV> l_byteaDestroy ( & ba ) ; //<S2SV> lept_free ( protostr ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 