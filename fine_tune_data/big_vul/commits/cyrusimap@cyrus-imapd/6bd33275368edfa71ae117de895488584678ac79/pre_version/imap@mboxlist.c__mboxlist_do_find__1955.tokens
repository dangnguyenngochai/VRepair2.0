static int mboxlist_do_find ( struct find_rock * rock , const strarray_t * patterns ) //<S2SV> { //<S2SV> const char * userid = rock -> userid ; //<S2SV> int isadmin = rock -> isadmin ; //<S2SV> int crossdomains = config_getswitch ( IMAPOPT_CROSSDOMAINS ) ; //<S2SV> char inbox [ MAX_MAILBOX_BUFFER ] ; //<S2SV> size_t inboxlen = 0 ; //<S2SV> size_t prefixlen , len ; //<S2SV> size_t domainlen = 0 ; //<S2SV> size_t userlen = userid ? strlen ( userid ) : 0 ; //<S2SV> char domainpat [ MAX_MAILBOX_BUFFER ] ; //<S2SV> char commonpat [ MAX_MAILBOX_BUFFER ] ; //<S2SV> int r = 0 ; //<S2SV> int i ; //<S2SV> const char * p ; //<S2SV> if ( patterns -> count < 1 ) return 0 ; //<S2SV> for ( i = 0 ; i < patterns -> count ; i ++ ) { //<S2SV> glob * g = glob_init ( strarray_nth ( patterns , i ) , rock -> namespace -> hier_sep ) ; //<S2SV> ptrarray_append ( & rock -> globs , g ) ; //<S2SV> } //<S2SV> if ( config_virtdomains && userid && ( p = strchr ( userid , '@' ) ) ) { //<S2SV> userlen = p - userid ; //<S2SV> domainlen = strlen ( p ) ; //<S2SV> snprintf ( domainpat , sizeof ( domainpat ) , "%s!" , p + 1 ) ; //<S2SV> } //<S2SV> else //<S2SV> domainpat [ 0 ] = '\\0' ; //<S2SV> if ( userid && ( ! ( p = strchr ( userid , rock -> namespace -> hier_sep ) ) || //<S2SV> ( ( p - userid ) > ( int ) userlen ) ) && //<S2SV> strlen ( userid ) + 7 < MAX_MAILBOX_BUFFER ) { //<S2SV> char * t , * tmpuser = NULL ; //<S2SV> const char * inboxuser ; //<S2SV> if ( domainlen ) //<S2SV> snprintf ( inbox , sizeof ( inbox ) , "%s!" , userid + userlen + 1 ) ; //<S2SV> if ( rock -> namespace -> hier_sep == '/' && ( p = strchr ( userid , '.' ) ) ) { //<S2SV> tmpuser = xmalloc ( userlen ) ; //<S2SV> memcpy ( tmpuser , userid , userlen ) ; //<S2SV> t = tmpuser + ( p - userid ) ; //<S2SV> while ( t < ( tmpuser + userlen ) ) { //<S2SV> if ( * t == '.' ) //<S2SV> * t = '^' ; //<S2SV> t ++ ; //<S2SV> } //<S2SV> inboxuser = tmpuser ; //<S2SV> } else //<S2SV> inboxuser = userid ; //<S2SV> snprintf ( inbox + domainlen , sizeof ( inbox ) - domainlen , //<S2SV> "user.%.*s.INBOX." , ( int ) userlen , inboxuser ) ; //<S2SV> free ( tmpuser ) ; //<S2SV> inboxlen = strlen ( inbox ) - 7 ; //<S2SV> } //<S2SV> else { //<S2SV> userid = 0 ; //<S2SV> } //<S2SV> const char * firstpat = strarray_nth ( patterns , 0 ) ; //<S2SV> for ( prefixlen = 0 ; firstpat [ prefixlen ] ; prefixlen ++ ) { //<S2SV> if ( prefixlen >= MAX_MAILBOX_NAME ) { //<S2SV> r = IMAP_MAILBOX_BADNAME ; //<S2SV> goto done ; //<S2SV> } //<S2SV> char c = firstpat [ prefixlen ] ; //<S2SV> for ( i = 1 ; i < patterns -> count ; i ++ ) { //<S2SV> const char * pat = strarray_nth ( patterns , i ) ; //<S2SV> if ( pat [ prefixlen ] != c ) break ; //<S2SV> } //<S2SV> if ( i < patterns -> count ) break ; //<S2SV> if ( c == '*' || c == '%' || c == '?' ) break ; //<S2SV> commonpat [ prefixlen ] = c ; //<S2SV> } //<S2SV> commonpat [ prefixlen ] = '\\0' ; //<S2SV> if ( patterns -> count == 1 ) { //<S2SV> if ( ! strcmp ( firstpat + prefixlen , "%" ) ) //<S2SV> rock -> singlepercent = 2 ; //<S2SV> if ( ! strcmp ( firstpat + prefixlen , "*%" ) ) //<S2SV> rock -> singlepercent = 1 ; //<S2SV> } //<S2SV> if ( userid && ! isadmin ) { //<S2SV> rock -> mb_category = MBNAME_INBOX ; //<S2SV> r = cyrusdb_forone ( rock -> db , inbox , inboxlen , & find_p , & find_cb , rock , NULL ) ; //<S2SV> if ( r == CYRUSDB_DONE ) r = 0 ; //<S2SV> if ( r ) goto done ; //<S2SV> if ( rock -> namespace -> isalt ) { //<S2SV> rock -> mb_category = MBNAME_INBOXSUB ; //<S2SV> r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 7 , & find_p , & find_cb , rock , NULL ) ; //<S2SV> if ( r == CYRUSDB_DONE ) r = 0 ; //<S2SV> if ( r ) goto done ; //<S2SV> r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; //<S2SV> if ( r ) goto done ; //<S2SV> } //<S2SV> rock -> mb_category = MBNAME_OWNER ; //<S2SV> r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 1 , & find_p , & find_cb , rock , NULL ) ; //<S2SV> if ( r == CYRUSDB_DONE ) r = 0 ; //<S2SV> if ( r ) goto done ; //<S2SV> if ( rock -> namespace -> isalt ) { //<S2SV> r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; //<S2SV> if ( r ) goto done ; //<S2SV> rock -> mb_category = MBNAME_ALTINBOX ; //<S2SV> r = cyrusdb_forone ( rock -> db , inbox , inboxlen + 6 , & find_p , & find_cb , rock , NULL ) ; //<S2SV> if ( r == CYRUSDB_DONE ) goto skipalt ; //<S2SV> if ( r ) goto done ; //<S2SV> rock -> mb_category = MBNAME_ALTPREFIX ; //<S2SV> r = cyrusdb_foreach ( rock -> db , inbox , inboxlen + 1 , & find_p , & find_cb , rock , NULL ) ; //<S2SV> skipalt : //<S2SV> if ( r == CYRUSDB_DONE ) r = 0 ; //<S2SV> if ( r ) goto done ; //<S2SV> } //<S2SV> } //<S2SV> if ( isadmin || rock -> namespace -> accessible [ NAMESPACE_USER ] ) { //<S2SV> len = strlen ( rock -> namespace -> prefix [ NAMESPACE_USER ] ) ; //<S2SV> if ( len ) len -- ; //<S2SV> if ( ! strncmp ( rock -> namespace -> prefix [ NAMESPACE_USER ] , commonpat , MIN ( len , prefixlen ) ) ) { //<S2SV> if ( prefixlen < len ) { //<S2SV> strlcpy ( domainpat + domainlen , "user." , sizeof ( domainpat ) - domainlen ) ; //<S2SV> } //<S2SV> else { //<S2SV> strlcpy ( domainpat + domainlen , "user." , sizeof ( domainpat ) - domainlen ) ; //<S2SV> strlcpy ( domainpat + domainlen + 5 , commonpat + len + 1 , sizeof ( domainpat ) - domainlen - 5 ) ; //<S2SV> } //<S2SV> rock -> mb_category = MBNAME_OTHERUSER ; //<S2SV> size_t thislen = ( isadmin || crossdomains ) ? 0 : strlen ( domainpat ) ; //<S2SV> r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; //<S2SV> if ( r ) goto done ; //<S2SV> r = mboxlist_find_category ( rock , domainpat , thislen ) ; //<S2SV> if ( r ) goto done ; //<S2SV> } //<S2SV> } //<S2SV> if ( isadmin || rock -> namespace -> accessible [ NAMESPACE_SHARED ] ) { //<S2SV> len = strlen ( rock -> namespace -> prefix [ NAMESPACE_SHARED ] ) ; //<S2SV> if ( len ) len -- ; //<S2SV> if ( ! strncmp ( rock -> namespace -> prefix [ NAMESPACE_SHARED ] , commonpat , MIN ( len , prefixlen ) ) ) { //<S2SV> rock -> mb_category = MBNAME_SHARED ; //<S2SV> r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; //<S2SV> if ( r ) goto done ; //<S2SV> r = mboxlist_find_category ( rock , domainpat , domainlen ) ; //<S2SV> if ( r ) goto done ; //<S2SV> } //<S2SV> } //<S2SV> r = ( * rock -> proc ) ( NULL , rock -> procrock ) ; //<S2SV> done : //<S2SV> for ( i = 0 ; i < rock -> globs . count ; i ++ ) { //<S2SV> glob * g = ptrarray_nth ( & rock -> globs , i ) ; //<S2SV> glob_free ( & g ) ; //<S2SV> } //<S2SV> ptrarray_fini ( & rock -> globs ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> 