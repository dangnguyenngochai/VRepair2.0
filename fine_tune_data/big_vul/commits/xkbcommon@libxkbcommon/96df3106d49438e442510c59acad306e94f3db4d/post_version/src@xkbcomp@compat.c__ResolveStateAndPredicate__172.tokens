static bool //<S2SV> ResolveStateAndPredicate ( ExprDef * expr , enum xkb_match_operation * pred_rtrn , //<S2SV> xkb_mod_mask_t * mods_rtrn , CompatInfo * info ) //<S2SV> { //<S2SV> if ( expr == NULL ) { //<S2SV> * pred_rtrn = MATCH_ANY_OR_NONE ; //<S2SV> * mods_rtrn = MOD_REAL_MASK_ALL ; //<S2SV> return true ; //<S2SV> } //<S2SV> * pred_rtrn = MATCH_EXACTLY ; //<S2SV> if ( expr -> expr . op == EXPR_ACTION_DECL ) { //<S2SV> const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> action . name ) ; //<S2SV> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) || //<S2SV> ! expr -> action . args ) { //<S2SV> log_err ( info -> ctx , //<S2SV> "Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\"%s\\";<S2SV_blank>Ignored\\n" , pred_txt ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> expr = expr -> action . args ; //<S2SV> } //<S2SV> else if ( expr -> expr . op == EXPR_IDENT ) { //<S2SV> const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> ident . ident ) ; //<S2SV> if ( pred_txt && istreq ( pred_txt , "any" ) ) { //<S2SV> * pred_rtrn = MATCH_ANY ; //<S2SV> * mods_rtrn = MOD_REAL_MASK_ALL ; //<S2SV> return true ; //<S2SV> } //<S2SV> } //<S2SV> return ExprResolveModMask ( info -> ctx , expr , MOD_REAL , & info -> mods , //<S2SV> mods_rtrn ) ; //<S2SV> } //<S2SV> 