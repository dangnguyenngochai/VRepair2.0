int mk_request_error ( int http_status , struct client_session * cs , //<S2SV> struct session_request * sr ) { //<S2SV> int ret , fd ; //<S2SV> mk_ptr_t message , * page = 0 ; //<S2SV> struct error_page * entry ; //<S2SV> struct mk_list * head ; //<S2SV> struct file_info finfo ; //<S2SV> mk_header_set_http_status ( sr , http_status ) ; //<S2SV> if ( http_status != MK_CLIENT_LENGTH_REQUIRED && //<S2SV> http_status != MK_CLIENT_BAD_REQUEST && //<S2SV> http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE ) { //<S2SV> mk_list_foreach ( head , & sr -> host_conf -> error_pages ) { //<S2SV> entry = mk_list_entry ( head , struct error_page , _head ) ; //<S2SV> if ( entry -> status != http_status ) { //<S2SV> continue ; //<S2SV> } //<S2SV> ret = mk_file_get_info ( entry -> real_path , & finfo ) ; //<S2SV> if ( ret == - 1 ) { //<S2SV> break ; //<S2SV> } //<S2SV> fd = open ( entry -> real_path , config -> open_flags ) ; //<S2SV> if ( fd == - 1 ) { //<S2SV> break ; //<S2SV> } //<S2SV> sr -> fd_file = fd ; //<S2SV> sr -> fd_is_fdt = MK_FALSE ; //<S2SV> sr -> bytes_to_send = finfo . size ; //<S2SV> sr -> headers . content_length = finfo . size ; //<S2SV> sr -> headers . real_length = finfo . size ; //<S2SV> memcpy ( & sr -> file_info , & finfo , sizeof ( struct file_info ) ) ; //<S2SV> mk_header_send ( cs -> socket , cs , sr ) ; //<S2SV> return mk_http_send_file ( cs , sr ) ; //<S2SV> } //<S2SV> } //<S2SV> mk_ptr_reset ( & message ) ; //<S2SV> switch ( http_status ) { //<S2SV> case MK_CLIENT_BAD_REQUEST : //<S2SV> page = mk_request_set_default_page ( "Bad<S2SV_blank>Request" , //<S2SV> sr -> uri , //<S2SV> sr -> host_conf -> host_signature ) ; //<S2SV> break ; //<S2SV> case MK_CLIENT_FORBIDDEN : //<S2SV> page = mk_request_set_default_page ( "Forbidden" , //<S2SV> sr -> uri , //<S2SV> sr -> host_conf -> host_signature ) ; //<S2SV> break ; //<S2SV> case MK_CLIENT_NOT_FOUND : //<S2SV> mk_string_build ( & message . data , & message . len , //<S2SV> "The<S2SV_blank>requested<S2SV_blank>URL<S2SV_blank>was<S2SV_blank>not<S2SV_blank>found<S2SV_blank>on<S2SV_blank>this<S2SV_blank>server." ) ; //<S2SV> page = mk_request_set_default_page ( "Not<S2SV_blank>Found" , //<S2SV> message , //<S2SV> sr -> host_conf -> host_signature ) ; //<S2SV> mk_ptr_free ( & message ) ; //<S2SV> break ; //<S2SV> case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE : //<S2SV> mk_string_build ( & message . data , & message . len , //<S2SV> "The<S2SV_blank>request<S2SV_blank>entity<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large." ) ; //<S2SV> page = mk_request_set_default_page ( "Entity<S2SV_blank>too<S2SV_blank>large" , //<S2SV> message , //<S2SV> sr -> host_conf -> host_signature ) ; //<S2SV> mk_ptr_free ( & message ) ; //<S2SV> break ; //<S2SV> case MK_CLIENT_METHOD_NOT_ALLOWED : //<S2SV> page = mk_request_set_default_page ( "Method<S2SV_blank>Not<S2SV_blank>Allowed" , //<S2SV> sr -> uri , //<S2SV> sr -> host_conf -> host_signature ) ; //<S2SV> break ; //<S2SV> case MK_CLIENT_REQUEST_TIMEOUT : //<S2SV> case MK_CLIENT_LENGTH_REQUIRED : //<S2SV> break ; //<S2SV> case MK_SERVER_NOT_IMPLEMENTED : //<S2SV> page = mk_request_set_default_page ( "Method<S2SV_blank>Not<S2SV_blank>Implemented" , //<S2SV> sr -> uri , //<S2SV> sr -> host_conf -> host_signature ) ; //<S2SV> break ; //<S2SV> case MK_SERVER_INTERNAL_ERROR : //<S2SV> page = mk_request_set_default_page ( "Internal<S2SV_blank>Server<S2SV_blank>Error" , //<S2SV> sr -> uri , //<S2SV> sr -> host_conf -> host_signature ) ; //<S2SV> break ; //<S2SV> case MK_SERVER_HTTP_VERSION_UNSUP : //<S2SV> mk_ptr_reset ( & message ) ; //<S2SV> page = mk_request_set_default_page ( "HTTP<S2SV_blank>Version<S2SV_blank>Not<S2SV_blank>Supported" , //<S2SV> message , //<S2SV> sr -> host_conf -> host_signature ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( page ) { //<S2SV> sr -> headers . content_length = page -> len ; //<S2SV> } //<S2SV> sr -> headers . location = NULL ; //<S2SV> sr -> headers . cgi = SH_NOCGI ; //<S2SV> sr -> headers . pconnections_left = 0 ; //<S2SV> sr -> headers . last_modified = - 1 ; //<S2SV> if ( ! page ) { //<S2SV> mk_ptr_reset ( & sr -> headers . content_type ) ; //<S2SV> } //<S2SV> else { //<S2SV> mk_ptr_set ( & sr -> headers . content_type , "text/html\\r\\n" ) ; //<S2SV> } //<S2SV> mk_header_send ( cs -> socket , cs , sr ) ; //<S2SV> if ( page ) { //<S2SV> if ( sr -> method != MK_HTTP_METHOD_HEAD ) //<S2SV> mk_socket_send ( cs -> socket , page -> data , page -> len ) ; //<S2SV> mk_ptr_free ( page ) ; //<S2SV> mk_mem_free ( page ) ; //<S2SV> } //<S2SV> mk_server_cork_flag ( cs -> socket , TCP_CORK_OFF ) ; //<S2SV> return EXIT_ERROR ; //<S2SV> } //<S2SV> 