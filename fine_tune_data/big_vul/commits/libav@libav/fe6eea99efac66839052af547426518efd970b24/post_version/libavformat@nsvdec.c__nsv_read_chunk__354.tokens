static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) //<S2SV> { //<S2SV> NSVContext * nsv = s -> priv_data ; //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> AVStream * st [ 2 ] = { NULL , NULL } ; //<S2SV> NSVStream * nst ; //<S2SV> AVPacket * pkt ; //<S2SV> int i , err = 0 ; //<S2SV> uint8_t auxcount ; //<S2SV> uint32_t vsize ; //<S2SV> uint16_t asize ; //<S2SV> uint16_t auxsize ; //<S2SV> int ret ; //<S2SV> if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) //<S2SV> return 0 ; //<S2SV> null_chunk_retry : //<S2SV> if ( pb -> eof_reached ) //<S2SV> return - 1 ; //<S2SV> for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) //<S2SV> err = nsv_resync ( s ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( nsv -> state == NSV_FOUND_NSVS ) //<S2SV> err = nsv_parse_NSVs_header ( s ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) //<S2SV> return - 1 ; //<S2SV> auxcount = avio_r8 ( pb ) ; //<S2SV> vsize = avio_rl16 ( pb ) ; //<S2SV> asize = avio_rl16 ( pb ) ; //<S2SV> vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; //<S2SV> auxcount &= 0x0f ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>CHUNK<S2SV_blank>%" PRIu8 "<S2SV_blank>aux,<S2SV_blank>%" PRIu32 "<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%" PRIu16 "<S2SV_blank>bytes<S2SV_blank>audio\\n" , //<S2SV> auxcount , vsize , asize ) ; //<S2SV> for ( i = 0 ; i < auxcount ; i ++ ) { //<S2SV> uint32_t av_unused auxtag ; //<S2SV> auxsize = avio_rl16 ( pb ) ; //<S2SV> auxtag = avio_rl32 ( pb ) ; //<S2SV> avio_skip ( pb , auxsize ) ; //<S2SV> vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; //<S2SV> } //<S2SV> if ( pb -> eof_reached ) //<S2SV> return - 1 ; //<S2SV> if ( ! vsize && ! asize ) { //<S2SV> nsv -> state = NSV_UNSYNC ; //<S2SV> goto null_chunk_retry ; //<S2SV> } //<S2SV> if ( s -> nb_streams > 0 ) //<S2SV> st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; //<S2SV> if ( s -> nb_streams > 1 ) //<S2SV> st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; //<S2SV> if ( vsize && st [ NSV_ST_VIDEO ] ) { //<S2SV> nst = st [ NSV_ST_VIDEO ] -> priv_data ; //<S2SV> pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ; //<S2SV> if ( ( ret = av_get_packet ( pb , pkt , vsize ) ) < 0 ) //<S2SV> return ret ; //<S2SV> pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; //<S2SV> pkt -> dts = nst -> frame_offset ; //<S2SV> pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; //<S2SV> for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02" PRIx8 "\\n" , //<S2SV> i , pkt -> data [ i ] ) ; //<S2SV> } //<S2SV> if ( st [ NSV_ST_VIDEO ] ) //<S2SV> ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; //<S2SV> if ( asize && st [ NSV_ST_AUDIO ] ) { //<S2SV> nst = st [ NSV_ST_AUDIO ] -> priv_data ; //<S2SV> pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; //<S2SV> if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { //<S2SV> uint8_t bps ; //<S2SV> uint8_t channels ; //<S2SV> uint16_t samplerate ; //<S2SV> bps = avio_r8 ( pb ) ; //<S2SV> channels = avio_r8 ( pb ) ; //<S2SV> samplerate = avio_rl16 ( pb ) ; //<S2SV> if ( ! channels || ! samplerate ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> asize -= 4 ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%" PRIu8 ",<S2SV_blank>nchan<S2SV_blank>%" PRIu8 ",<S2SV_blank>srate<S2SV_blank>%" PRIu16 "\\n" , //<S2SV> bps , channels , samplerate ) ; //<S2SV> if ( fill_header ) { //<S2SV> st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; //<S2SV> if ( bps != 16 ) { //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%" PRIu8 ")!!!\\n" , bps ) ; //<S2SV> } //<S2SV> bps /= channels ; //<S2SV> if ( bps == 8 ) //<S2SV> st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; //<S2SV> samplerate /= 4 ; //<S2SV> channels = 1 ; //<S2SV> st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; //<S2SV> st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%" PRIu8 ",<S2SV_blank>nchan<S2SV_blank>%" PRIu8 ",<S2SV_blank>srate<S2SV_blank>%" PRIu16 "\\n" , //<S2SV> bps , channels , samplerate ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ret = av_get_packet ( pb , pkt , asize ) ) < 0 ) //<S2SV> return ret ; //<S2SV> pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; //<S2SV> pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; //<S2SV> if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { //<S2SV> pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; //<S2SV> pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; //<S2SV> pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%" PRId16 ",<S2SV_blank>dts:%" PRId64 , //<S2SV> nsv -> avsync , pkt -> dts ) ; //<S2SV> } //<S2SV> nst -> frame_offset ++ ; //<S2SV> } //<S2SV> nsv -> state = NSV_UNSYNC ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 