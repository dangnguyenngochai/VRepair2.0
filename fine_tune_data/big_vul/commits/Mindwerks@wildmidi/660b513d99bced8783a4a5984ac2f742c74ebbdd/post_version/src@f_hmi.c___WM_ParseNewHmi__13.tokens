struct _mdi * //<S2SV> _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { //<S2SV> uint32_t hmi_tmp = 0 ; //<S2SV> uint8_t * hmi_base = hmi_data ; //<S2SV> uint32_t data_siz ; //<S2SV> uint16_t hmi_bpm = 0 ; //<S2SV> uint16_t hmi_division = 0 ; //<S2SV> uint32_t hmi_track_cnt = 0 ; //<S2SV> uint32_t * hmi_track_offset = NULL ; //<S2SV> uint32_t i = 0 ; //<S2SV> uint32_t j = 0 ; //<S2SV> uint8_t * hmi_addr = NULL ; //<S2SV> uint32_t * hmi_track_header_length = NULL ; //<S2SV> struct _mdi * hmi_mdi = NULL ; //<S2SV> uint32_t tempo_f = 5000000.0 ; //<S2SV> uint32_t * hmi_track_end = NULL ; //<S2SV> uint8_t hmi_tracks_ended = 0 ; //<S2SV> uint8_t * hmi_running_event = NULL ; //<S2SV> uint32_t setup_ret = 0 ; //<S2SV> uint32_t * hmi_delta = NULL ; //<S2SV> uint32_t smallest_delta = 0 ; //<S2SV> uint32_t subtract_delta = 0 ; //<S2SV> uint32_t sample_count = 0 ; //<S2SV> float sample_count_f = 0 ; //<S2SV> float sample_remainder = 0 ; //<S2SV> float samples_per_delta_f = 0.0 ; //<S2SV> struct _note { //<S2SV> uint32_t length ; //<S2SV> uint8_t channel ; //<S2SV> } * note ; //<S2SV> if ( memcmp ( hmi_data , "HMI-MIDISONG061595" , 18 ) ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> hmi_bpm = hmi_data [ 212 ] ; //<S2SV> hmi_division = 60 ; //<S2SV> hmi_track_cnt = hmi_data [ 228 ] ; //<S2SV> hmi_mdi = _WM_initMDI ( ) ; //<S2SV> _WM_midi_setup_divisions ( hmi_mdi , hmi_division ) ; //<S2SV> if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { //<S2SV> tempo_f = ( float ) ( 60000000 / hmi_bpm ) + 0.5f ; //<S2SV> } else { //<S2SV> tempo_f = ( float ) ( 60000000 / hmi_bpm ) ; //<S2SV> } //<S2SV> samples_per_delta_f = _WM_GetSamplesPerTick ( hmi_division , ( uint32_t ) tempo_f ) ; //<S2SV> _WM_midi_setup_tempo ( hmi_mdi , ( uint32_t ) tempo_f ) ; //<S2SV> hmi_track_offset = ( uint32_t * ) malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; //<S2SV> hmi_track_header_length = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; //<S2SV> hmi_track_end = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; //<S2SV> hmi_delta = malloc ( sizeof ( uint32_t ) * hmi_track_cnt ) ; //<S2SV> note = malloc ( sizeof ( struct _note ) * 128 * hmi_track_cnt ) ; //<S2SV> hmi_running_event = malloc ( sizeof ( uint8_t ) * 128 * hmi_track_cnt ) ; //<S2SV> hmi_data += 370 ; //<S2SV> smallest_delta = 0xffffffff ; //<S2SV> if ( hmi_size < ( 370 + ( hmi_track_cnt * 17 ) ) ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> hmi_track_offset [ 0 ] = * hmi_data ; //<S2SV> for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { //<S2SV> hmi_track_offset [ i ] = * hmi_data ++ ; //<S2SV> hmi_track_offset [ i ] += ( * hmi_data ++ << 8 ) ; //<S2SV> hmi_track_offset [ i ] += ( * hmi_data ++ << 16 ) ; //<S2SV> hmi_track_offset [ i ] += ( * hmi_data ++ << 24 ) ; //<S2SV> if ( hmi_size < ( hmi_track_offset [ i ] + 0x5a + 4 ) ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> hmi_addr = hmi_base + hmi_track_offset [ i ] ; //<S2SV> if ( memcmp ( hmi_addr , "HMI-MIDITRACK" , 13 ) ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> hmi_track_header_length [ i ] = hmi_addr [ 0x57 ] ; //<S2SV> hmi_track_header_length [ i ] += ( hmi_addr [ 0x58 ] << 8 ) ; //<S2SV> hmi_track_header_length [ i ] += ( hmi_addr [ 0x59 ] << 16 ) ; //<S2SV> hmi_track_header_length [ i ] += ( hmi_addr [ 0x5a ] << 24 ) ; //<S2SV> hmi_addr += hmi_track_header_length [ i ] ; //<S2SV> hmi_track_offset [ i ] += hmi_track_header_length [ i ] ; //<S2SV> hmi_delta [ i ] = 0 ; //<S2SV> if ( * hmi_addr > 0x7f ) { //<S2SV> do { //<S2SV> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; //<S2SV> hmi_addr ++ ; //<S2SV> hmi_track_offset [ i ] ++ ; //<S2SV> } while ( * hmi_addr > 0x7f ) ; //<S2SV> } //<S2SV> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) + ( * hmi_addr & 0x7f ) ; //<S2SV> hmi_track_offset [ i ] ++ ; //<S2SV> hmi_addr ++ ; //<S2SV> if ( hmi_delta [ i ] < smallest_delta ) { //<S2SV> smallest_delta = hmi_delta [ i ] ; //<S2SV> } //<S2SV> hmi_track_end [ i ] = 0 ; //<S2SV> hmi_running_event [ i ] = 0 ; //<S2SV> for ( j = 0 ; j < 128 ; j ++ ) { //<S2SV> hmi_tmp = ( 128 * i ) + j ; //<S2SV> note [ hmi_tmp ] . length = 0 ; //<S2SV> note [ hmi_tmp ] . channel = 0 ; //<S2SV> } //<S2SV> } //<S2SV> subtract_delta = smallest_delta ; //<S2SV> sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; //<S2SV> sample_count = ( uint32_t ) sample_count_f ; //<S2SV> sample_remainder = sample_count_f - ( float ) sample_count ; //<S2SV> hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; //<S2SV> hmi_mdi -> extra_info . approx_total_samples += sample_count ; //<S2SV> while ( hmi_tracks_ended < hmi_track_cnt ) { //<S2SV> smallest_delta = 0 ; //<S2SV> for ( i = 0 ; i < hmi_track_cnt ; i ++ ) { //<S2SV> if ( hmi_track_end [ i ] ) continue ; //<S2SV> for ( j = 0 ; j < 128 ; j ++ ) { //<S2SV> hmi_tmp = ( 128 * i ) + j ; //<S2SV> if ( note [ hmi_tmp ] . length ) { //<S2SV> note [ hmi_tmp ] . length -= subtract_delta ; //<S2SV> if ( note [ hmi_tmp ] . length ) { //<S2SV> if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { //<S2SV> smallest_delta = note [ hmi_tmp ] . length ; //<S2SV> } //<S2SV> } else { //<S2SV> _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( hmi_delta [ i ] ) { //<S2SV> hmi_delta [ i ] -= subtract_delta ; //<S2SV> if ( hmi_delta [ i ] ) { //<S2SV> if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { //<S2SV> smallest_delta = hmi_delta [ i ] ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> do { //<S2SV> hmi_data = hmi_base + hmi_track_offset [ i ] ; //<S2SV> hmi_delta [ i ] = 0 ; //<S2SV> if ( hmi_track_offset [ i ] >= hmi_size ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> data_siz = hmi_size - hmi_track_offset [ i ] ; //<S2SV> if ( hmi_data [ 0 ] == 0xfe ) { //<S2SV> if ( hmi_data [ 1 ] == 0x10 ) { //<S2SV> hmi_tmp = ( hmi_data [ 4 ] + 5 ) ; //<S2SV> hmi_data += hmi_tmp ; //<S2SV> hmi_track_offset [ i ] += hmi_tmp ; //<S2SV> hmi_tmp += 4 ; //<S2SV> } else if ( hmi_data [ 1 ] == 0x15 ) { //<S2SV> hmi_data += 4 ; //<S2SV> hmi_track_offset [ i ] += 4 ; //<S2SV> hmi_tmp = 8 ; //<S2SV> } else { //<S2SV> hmi_tmp = 4 ; //<S2SV> } //<S2SV> hmi_data += 4 ; //<S2SV> hmi_track_offset [ i ] += 4 ; //<S2SV> if ( hmi_tmp > data_siz ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> data_siz -= hmi_tmp ; //<S2SV> } else { //<S2SV> if ( ( setup_ret = _WM_SetupMidiEvent ( hmi_mdi , hmi_data , data_siz , hmi_running_event [ i ] ) ) == 0 ) { //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> if ( ( hmi_data [ 0 ] == 0xff ) && ( hmi_data [ 1 ] == 0x2f ) && ( hmi_data [ 2 ] == 0x00 ) ) { //<S2SV> hmi_track_end [ i ] = 1 ; //<S2SV> hmi_tracks_ended ++ ; //<S2SV> for ( j = 0 ; j < 128 ; j ++ ) { //<S2SV> hmi_tmp = ( 128 * i ) + j ; //<S2SV> if ( note [ hmi_tmp ] . length ) { //<S2SV> _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; //<S2SV> note [ hmi_tmp ] . length = 0 ; //<S2SV> } //<S2SV> } //<S2SV> goto _hmi_next_track ; //<S2SV> } //<S2SV> if ( ( * hmi_data == 0xF0 ) || ( * hmi_data == 0xF7 ) ) { //<S2SV> hmi_running_event [ i ] = 0 ; //<S2SV> } else if ( * hmi_data < 0xF0 ) { //<S2SV> if ( * hmi_data >= 0x80 ) { //<S2SV> hmi_running_event [ i ] = * hmi_data ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( hmi_running_event [ i ] & 0xf0 ) == 0x90 ) { //<S2SV> if ( * hmi_data > 127 ) { //<S2SV> hmi_tmp = hmi_data [ 1 ] ; //<S2SV> } else { //<S2SV> hmi_tmp = * hmi_data ; //<S2SV> } //<S2SV> hmi_tmp += ( i * 128 ) ; //<S2SV> note [ hmi_tmp ] . channel = hmi_running_event [ i ] & 0xf ; //<S2SV> hmi_data += setup_ret ; //<S2SV> hmi_track_offset [ i ] += setup_ret ; //<S2SV> data_siz -= setup_ret ; //<S2SV> note [ hmi_tmp ] . length = 0 ; //<S2SV> if ( data_siz && * hmi_data > 0x7f ) { //<S2SV> do { //<S2SV> if ( ! data_siz ) break ; //<S2SV> note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; //<S2SV> hmi_data ++ ; //<S2SV> data_siz -- ; //<S2SV> hmi_track_offset [ i ] ++ ; //<S2SV> } while ( * hmi_data > 0x7F ) ; //<S2SV> } //<S2SV> if ( ! data_siz ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> note [ hmi_tmp ] . length = ( note [ hmi_tmp ] . length << 7 ) | ( * hmi_data & 0x7F ) ; //<S2SV> hmi_data ++ ; //<S2SV> data_siz -- ; //<S2SV> hmi_track_offset [ i ] ++ ; //<S2SV> if ( note [ hmi_tmp ] . length ) { //<S2SV> if ( ( ! smallest_delta ) || ( smallest_delta > note [ hmi_tmp ] . length ) ) { //<S2SV> smallest_delta = note [ hmi_tmp ] . length ; //<S2SV> } //<S2SV> } else { //<S2SV> _WM_midi_setup_noteoff ( hmi_mdi , note [ hmi_tmp ] . channel , j , 0 ) ; //<S2SV> } //<S2SV> } else { //<S2SV> hmi_data += setup_ret ; //<S2SV> hmi_track_offset [ i ] += setup_ret ; //<S2SV> data_siz -= setup_ret ; //<S2SV> } //<S2SV> } //<S2SV> if ( data_siz && * hmi_data > 0x7f ) { //<S2SV> do { //<S2SV> if ( ! data_siz ) break ; //<S2SV> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; //<S2SV> hmi_data ++ ; //<S2SV> data_siz -- ; //<S2SV> hmi_track_offset [ i ] ++ ; //<S2SV> } while ( * hmi_data > 0x7F ) ; //<S2SV> } //<S2SV> if ( ! data_siz ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> hmi_delta [ i ] = ( hmi_delta [ i ] << 7 ) | ( * hmi_data & 0x7F ) ; //<S2SV> hmi_data ++ ; //<S2SV> data_siz -- ; //<S2SV> hmi_track_offset [ i ] ++ ; //<S2SV> } while ( ! hmi_delta [ i ] ) ; //<S2SV> if ( ( ! smallest_delta ) || ( smallest_delta > hmi_delta [ i ] ) ) { //<S2SV> smallest_delta = hmi_delta [ i ] ; //<S2SV> } //<S2SV> _hmi_next_track : //<S2SV> hmi_tmp = 0 ; //<S2SV> UNUSED ( hmi_tmp ) ; //<S2SV> } //<S2SV> subtract_delta = smallest_delta ; //<S2SV> sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; //<S2SV> sample_count = ( uint32_t ) sample_count_f ; //<S2SV> sample_remainder = sample_count_f - ( float ) sample_count ; //<S2SV> hmi_mdi -> events [ hmi_mdi -> event_count - 1 ] . samples_to_next += sample_count ; //<S2SV> hmi_mdi -> extra_info . approx_total_samples += sample_count ; //<S2SV> } //<S2SV> if ( ( hmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , "to<S2SV_blank>init<S2SV_blank>reverb" , 0 ) ; //<S2SV> goto _hmi_end ; //<S2SV> } //<S2SV> hmi_mdi -> extra_info . current_sample = 0 ; //<S2SV> hmi_mdi -> current_event = & hmi_mdi -> events [ 0 ] ; //<S2SV> hmi_mdi -> samples_to_mix = 0 ; //<S2SV> hmi_mdi -> note = NULL ; //<S2SV> _WM_ResetToStart ( hmi_mdi ) ; //<S2SV> _hmi_end : //<S2SV> free ( hmi_track_offset ) ; //<S2SV> free ( hmi_track_header_length ) ; //<S2SV> free ( hmi_track_end ) ; //<S2SV> free ( hmi_delta ) ; //<S2SV> free ( note ) ; //<S2SV> free ( hmi_running_event ) ; //<S2SV> if ( hmi_mdi -> reverb ) return ( hmi_mdi ) ; //<S2SV> _WM_freeMDI ( hmi_mdi ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 