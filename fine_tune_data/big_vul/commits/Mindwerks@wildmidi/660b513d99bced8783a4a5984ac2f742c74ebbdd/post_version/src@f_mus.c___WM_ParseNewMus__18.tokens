struct _mdi * //<S2SV> _WM_ParseNewMus ( uint8_t * mus_data , uint32_t mus_size ) { //<S2SV> uint8_t mus_hdr [ ] = { 'M' , 'U' , 'S' , 0x1A } ; //<S2SV> uint32_t mus_song_ofs = 0 ; //<S2SV> uint32_t mus_song_len = 0 ; //<S2SV> uint16_t mus_ch_cnt1 = 0 ; //<S2SV> uint16_t mus_ch_cnt2 = 0 ; //<S2SV> uint16_t mus_no_instr = 0 ; //<S2SV> uint32_t mus_data_ofs = 0 ; //<S2SV> uint16_t * mus_mid_instr = NULL ; //<S2SV> uint16_t mus_instr_cnt = 0 ; //<S2SV> struct _mdi * mus_mdi ; //<S2SV> uint32_t mus_divisions = 60 ; //<S2SV> float tempo_f = 0.0 ; //<S2SV> uint16_t mus_freq = 0 ; //<S2SV> float samples_per_tick_f = 0.0 ; //<S2SV> # define MUS_SZ 4 //<S2SV> uint8_t mus_event [ MUS_SZ ] = { 0 , 0 , 0 , 0 } ; //<S2SV> uint8_t mus_event_size = 0 ; //<S2SV> uint8_t mus_prev_vol [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; //<S2SV> uint32_t setup_ret = 0 ; //<S2SV> uint32_t mus_ticks = 0 ; //<S2SV> uint32_t sample_count = 0 ; //<S2SV> float sample_count_f = 0.0 ; //<S2SV> float sample_remainder = 0.0 ; //<S2SV> uint16_t pitchbend_tmp = 0 ; //<S2SV> if ( mus_size < 17 ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , "File<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( memcmp ( mus_data , mus_hdr , 4 ) ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , NULL , 0 ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> mus_song_len = ( mus_data [ 5 ] << 8 ) | mus_data [ 4 ] ; //<S2SV> mus_song_ofs = ( mus_data [ 7 ] << 8 ) | mus_data [ 6 ] ; //<S2SV> mus_ch_cnt1 = ( mus_data [ 9 ] << 8 ) | mus_data [ 8 ] ; //<S2SV> mus_ch_cnt2 = ( mus_data [ 11 ] << 8 ) | mus_data [ 10 ] ; //<S2SV> UNUSED ( mus_ch_cnt1 ) ; //<S2SV> UNUSED ( mus_ch_cnt2 ) ; //<S2SV> mus_no_instr = ( mus_data [ 13 ] << 8 ) | mus_data [ 12 ] ; //<S2SV> mus_data_ofs = 16 ; //<S2SV> if ( mus_size < ( mus_data_ofs + ( mus_no_instr << 1 ) + mus_song_len ) ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , "File<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> mus_mid_instr = malloc ( mus_no_instr * sizeof ( uint16_t ) ) ; //<S2SV> for ( mus_instr_cnt = 0 ; mus_instr_cnt < mus_no_instr ; mus_instr_cnt ++ ) { //<S2SV> mus_mid_instr [ mus_instr_cnt ] = ( mus_data [ mus_data_ofs + 1 ] << 8 ) | mus_data [ mus_data_ofs ] ; //<S2SV> mus_data_ofs += 2 ; //<S2SV> } //<S2SV> mus_data_ofs = mus_song_ofs ; //<S2SV> mus_freq = _cvt_get_option ( WM_CO_FREQUENCY ) ; //<S2SV> if ( mus_freq == 0 ) mus_freq = 140 ; //<S2SV> if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { //<S2SV> tempo_f = ( float ) ( 60000000 / mus_freq ) + 0.5f ; //<S2SV> } else { //<S2SV> tempo_f = ( float ) ( 60000000 / mus_freq ) ; //<S2SV> } //<S2SV> samples_per_tick_f = _WM_GetSamplesPerTick ( mus_divisions , ( uint32_t ) tempo_f ) ; //<S2SV> mus_mdi = _WM_initMDI ( ) ; //<S2SV> _WM_midi_setup_divisions ( mus_mdi , mus_divisions ) ; //<S2SV> _WM_midi_setup_tempo ( mus_mdi , ( uint32_t ) tempo_f ) ; //<S2SV> do { //<S2SV> _mus_build_event : //<S2SV> # if 1 //<S2SV> MUS_EVENT_DEBUG ( "Before" , mus_data [ mus_data_ofs ] , 0 ) ; //<S2SV> if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x0f ) { //<S2SV> mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x09 ; //<S2SV> } else if ( ( mus_data [ mus_data_ofs ] & 0x0f ) == 0x09 ) { //<S2SV> mus_data [ mus_data_ofs ] = ( mus_data [ mus_data_ofs ] & 0xf0 ) | 0x0f ; //<S2SV> } //<S2SV> MUS_EVENT_DEBUG ( "After" , mus_data [ mus_data_ofs ] , 0 ) ; //<S2SV> # endif //<S2SV> switch ( ( mus_data [ mus_data_ofs ] >> 4 ) & 0x07 ) { //<S2SV> case 0 : //<S2SV> mus_event_size = 2 ; //<S2SV> mus_event [ 0 ] = 0x80 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; //<S2SV> mus_event [ 2 ] = 0 ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> if ( mus_data [ mus_data_ofs + 1 ] & 0x80 ) { //<S2SV> mus_event_size = 3 ; //<S2SV> mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] & 0x7f ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] = mus_event [ 2 ] ; //<S2SV> } else { //<S2SV> mus_event_size = 2 ; //<S2SV> mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = mus_data [ mus_data_ofs + 1 ] ; //<S2SV> mus_event [ 2 ] = mus_prev_vol [ mus_data [ mus_data_ofs ] & 0x0f ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> case 2 : //<S2SV> mus_event_size = 2 ; //<S2SV> mus_event [ 0 ] = 0xe0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> pitchbend_tmp = mus_data [ mus_data_ofs + 1 ] << 6 ; //<S2SV> mus_event [ 1 ] = pitchbend_tmp & 0x7f ; //<S2SV> mus_event [ 2 ] = ( pitchbend_tmp >> 7 ) & 0x7f ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> mus_event_size = 2 ; //<S2SV> switch ( mus_data [ mus_data_ofs + 1 ] ) { //<S2SV> case 10 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 120 ; //<S2SV> mus_event [ 2 ] = 0 ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 11 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 123 ; //<S2SV> mus_event [ 2 ] = 0 ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 12 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 126 ; //<S2SV> mus_event [ 2 ] = 0 ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 13 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 127 ; //<S2SV> mus_event [ 2 ] = 0 ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 14 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 121 ; //<S2SV> mus_event [ 2 ] = 0 ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto _mus_next_data ; //<S2SV> } //<S2SV> break ; //<S2SV> case 4 : //<S2SV> mus_event_size = 3 ; //<S2SV> switch ( mus_data [ mus_data_ofs + 1 ] ) { //<S2SV> case 0 : //<S2SV> mus_event [ 0 ] = 0xc0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 2 ] = 0 ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 0 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 1 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 7 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 4 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 10 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 5 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 11 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 6 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 91 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 7 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 93 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 8 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 64 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> case 9 : //<S2SV> mus_event [ 0 ] = 0xb0 | ( mus_data [ mus_data_ofs ] & 0x0f ) ; //<S2SV> mus_event [ 1 ] = 67 ; //<S2SV> mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; //<S2SV> mus_event [ 3 ] = 0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto _mus_next_data ; //<S2SV> } //<S2SV> break ; //<S2SV> case 5 : //<S2SV> mus_event_size = 1 ; //<S2SV> goto _mus_next_data ; //<S2SV> break ; //<S2SV> case 6 : //<S2SV> goto _mus_end_of_song ; //<S2SV> break ; //<S2SV> case 7 : //<S2SV> mus_event_size = 1 ; //<S2SV> goto _mus_next_data ; //<S2SV> break ; //<S2SV> } //<S2SV> setup_ret = _WM_SetupMidiEvent ( mus_mdi , ( uint8_t * ) mus_event , MUS_SZ , 0 ) ; //<S2SV> if ( setup_ret == 0 ) { //<S2SV> goto _mus_end ; //<S2SV> } //<S2SV> _mus_next_data : //<S2SV> if ( ! ( mus_data [ mus_data_ofs ] & 0x80 ) ) { //<S2SV> mus_data_ofs += mus_event_size ; //<S2SV> goto _mus_build_event ; //<S2SV> } //<S2SV> mus_data_ofs += mus_event_size ; //<S2SV> mus_ticks = 0 ; //<S2SV> do { //<S2SV> mus_ticks = ( mus_ticks << 7 ) | ( mus_data [ mus_data_ofs ++ ] & 0x7f ) ; //<S2SV> } while ( mus_data [ mus_data_ofs - 1 ] & 0x80 ) ; //<S2SV> sample_count_f = ( ( float ) mus_ticks * samples_per_tick_f ) + sample_remainder ; //<S2SV> sample_count = ( uint32_t ) sample_count_f ; //<S2SV> sample_remainder = sample_count_f - ( float ) sample_count ; //<S2SV> mus_mdi -> events [ mus_mdi -> event_count - 1 ] . samples_to_next = sample_count ; //<S2SV> mus_mdi -> extra_info . approx_total_samples += sample_count ; //<S2SV> } while ( mus_data_ofs < mus_size ) ; //<S2SV> _mus_end_of_song : //<S2SV> if ( ( mus_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , "to<S2SV_blank>init<S2SV_blank>reverb" , 0 ) ; //<S2SV> goto _mus_end ; //<S2SV> } //<S2SV> _WM_midi_setup_endoftrack ( mus_mdi ) ; //<S2SV> mus_mdi -> extra_info . current_sample = 0 ; //<S2SV> mus_mdi -> current_event = & mus_mdi -> events [ 0 ] ; //<S2SV> mus_mdi -> samples_to_mix = 0 ; //<S2SV> mus_mdi -> note = NULL ; //<S2SV> _WM_ResetToStart ( mus_mdi ) ; //<S2SV> _mus_end : //<S2SV> free ( mus_mid_instr ) ; //<S2SV> if ( mus_mdi -> reverb ) return ( mus_mdi ) ; //<S2SV> _WM_freeMDI ( mus_mdi ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 