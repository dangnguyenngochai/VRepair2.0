struct _mdi * //<S2SV> _WM_ParseNewHmp ( uint8_t * hmp_data , uint32_t hmp_size ) { //<S2SV> uint8_t is_hmp2 = 0 ; //<S2SV> uint32_t zero_cnt = 0 ; //<S2SV> uint32_t i = 0 ; //<S2SV> uint32_t hmp_file_length = 0 ; //<S2SV> uint32_t hmp_chunks = 0 ; //<S2SV> uint32_t hmp_divisions = 0 ; //<S2SV> uint32_t hmp_unknown = 0 ; //<S2SV> uint32_t hmp_bpm = 0 ; //<S2SV> uint32_t hmp_song_time = 0 ; //<S2SV> struct _mdi * hmp_mdi ; //<S2SV> uint8_t * * hmp_chunk ; //<S2SV> uint32_t * chunk_length ; //<S2SV> uint32_t * chunk_ofs ; //<S2SV> uint32_t * chunk_delta ; //<S2SV> uint8_t * chunk_end ; //<S2SV> uint32_t chunk_num = 0 ; //<S2SV> uint32_t hmp_track = 0 ; //<S2SV> uint32_t smallest_delta = 0 ; //<S2SV> uint32_t subtract_delta = 0 ; //<S2SV> uint32_t end_of_chunks = 0 ; //<S2SV> uint32_t var_len_shift = 0 ; //<S2SV> float tempo_f = 500000.0 ; //<S2SV> float samples_per_delta_f = 0.0 ; //<S2SV> uint32_t sample_count = 0 ; //<S2SV> float sample_count_f = 0 ; //<S2SV> float sample_remainder = 0 ; //<S2SV> if ( memcmp ( hmp_data , "HMIMIDIP" , 8 ) ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , NULL , 0 ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> hmp_data += 8 ; //<S2SV> hmp_size -= 8 ; //<S2SV> if ( ! memcmp ( hmp_data , "013195" , 6 ) ) { //<S2SV> hmp_data += 6 ; //<S2SV> hmp_size -= 6 ; //<S2SV> is_hmp2 = 1 ; //<S2SV> } //<S2SV> if ( is_hmp2 ) { //<S2SV> zero_cnt = 18 ; //<S2SV> } else { //<S2SV> zero_cnt = 24 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < zero_cnt ; i ++ ) { //<S2SV> if ( hmp_data [ i ] != 0 ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , NULL , 0 ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> } //<S2SV> hmp_data += zero_cnt ; //<S2SV> hmp_size -= zero_cnt ; //<S2SV> hmp_file_length = * hmp_data ++ ; //<S2SV> hmp_file_length += ( * hmp_data ++ << 8 ) ; //<S2SV> hmp_file_length += ( * hmp_data ++ << 16 ) ; //<S2SV> hmp_file_length += ( * hmp_data ++ << 24 ) ; //<S2SV> hmp_size -= 4 ; //<S2SV> UNUSED ( hmp_file_length ) ; //<S2SV> hmp_data += 12 ; //<S2SV> hmp_size -= 12 ; //<S2SV> hmp_chunks = * hmp_data ++ ; //<S2SV> hmp_chunks += ( * hmp_data ++ << 8 ) ; //<S2SV> hmp_chunks += ( * hmp_data ++ << 16 ) ; //<S2SV> hmp_chunks += ( * hmp_data ++ << 24 ) ; //<S2SV> hmp_size -= 4 ; //<S2SV> hmp_unknown = * hmp_data ++ ; //<S2SV> hmp_unknown += ( * hmp_data ++ << 8 ) ; //<S2SV> hmp_unknown += ( * hmp_data ++ << 16 ) ; //<S2SV> hmp_unknown += ( * hmp_data ++ << 24 ) ; //<S2SV> hmp_size -= 4 ; //<S2SV> UNUSED ( hmp_unknown ) ; //<S2SV> hmp_divisions = 60 ; //<S2SV> hmp_bpm = * hmp_data ++ ; //<S2SV> hmp_bpm += ( * hmp_data ++ << 8 ) ; //<S2SV> hmp_bpm += ( * hmp_data ++ << 16 ) ; //<S2SV> hmp_bpm += ( * hmp_data ++ << 24 ) ; //<S2SV> hmp_size -= 4 ; //<S2SV> if ( ( _WM_MixerOptions & WM_MO_ROUNDTEMPO ) ) { //<S2SV> tempo_f = ( float ) ( 60000000 / hmp_bpm ) + 0.5f ; //<S2SV> } else { //<S2SV> tempo_f = ( float ) ( 60000000 / hmp_bpm ) ; //<S2SV> } //<S2SV> samples_per_delta_f = _WM_GetSamplesPerTick ( hmp_divisions , tempo_f ) ; //<S2SV> hmp_song_time = * hmp_data ++ ; //<S2SV> hmp_song_time += ( * hmp_data ++ << 8 ) ; //<S2SV> hmp_song_time += ( * hmp_data ++ << 16 ) ; //<S2SV> hmp_song_time += ( * hmp_data ++ << 24 ) ; //<S2SV> hmp_size -= 4 ; //<S2SV> UNUSED ( hmp_song_time ) ; //<S2SV> if ( is_hmp2 ) { //<S2SV> hmp_data += 840 ; //<S2SV> hmp_size -= 840 ; //<S2SV> } else { //<S2SV> hmp_data += 712 ; //<S2SV> hmp_size -= 712 ; //<S2SV> } //<S2SV> hmp_mdi = _WM_initMDI ( ) ; //<S2SV> _WM_midi_setup_divisions ( hmp_mdi , hmp_divisions ) ; //<S2SV> _WM_midi_setup_tempo ( hmp_mdi , ( uint32_t ) tempo_f ) ; //<S2SV> hmp_chunk = malloc ( sizeof ( uint8_t * ) * hmp_chunks ) ; //<S2SV> chunk_length = malloc ( sizeof ( uint32_t ) * hmp_chunks ) ; //<S2SV> chunk_delta = malloc ( sizeof ( uint32_t ) * hmp_chunks ) ; //<S2SV> chunk_ofs = malloc ( sizeof ( uint32_t ) * hmp_chunks ) ; //<S2SV> chunk_end = malloc ( sizeof ( uint8_t ) * hmp_chunks ) ; //<S2SV> smallest_delta = 0xffffffff ; //<S2SV> for ( i = 0 ; i < hmp_chunks ; i ++ ) { //<S2SV> hmp_chunk [ i ] = hmp_data ; //<S2SV> chunk_ofs [ i ] = 0 ; //<S2SV> chunk_num = * hmp_data ++ ; //<S2SV> chunk_num += ( * hmp_data ++ << 8 ) ; //<S2SV> chunk_num += ( * hmp_data ++ << 16 ) ; //<S2SV> chunk_num += ( * hmp_data ++ << 24 ) ; //<S2SV> chunk_ofs [ i ] += 4 ; //<S2SV> UNUSED ( chunk_num ) ; //<S2SV> chunk_length [ i ] = * hmp_data ++ ; //<S2SV> chunk_length [ i ] += ( * hmp_data ++ << 8 ) ; //<S2SV> chunk_length [ i ] += ( * hmp_data ++ << 16 ) ; //<S2SV> chunk_length [ i ] += ( * hmp_data ++ << 24 ) ; //<S2SV> chunk_ofs [ i ] += 4 ; //<S2SV> if ( chunk_length [ i ] > hmp_size ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> goto _hmp_end ; //<S2SV> } //<S2SV> hmp_size -= chunk_length [ i ] ; //<S2SV> hmp_track = * hmp_data ++ ; //<S2SV> hmp_track += ( * hmp_data ++ << 8 ) ; //<S2SV> hmp_track += ( * hmp_data ++ << 16 ) ; //<S2SV> hmp_track += ( * hmp_data ++ << 24 ) ; //<S2SV> chunk_ofs [ i ] += 4 ; //<S2SV> UNUSED ( hmp_track ) ; //<S2SV> chunk_delta [ i ] = 0 ; //<S2SV> var_len_shift = 0 ; //<S2SV> if ( * hmp_data < 0x80 ) { //<S2SV> do { //<S2SV> chunk_delta [ i ] = chunk_delta [ i ] | ( ( * hmp_data ++ & 0x7F ) << var_len_shift ) ; //<S2SV> var_len_shift += 7 ; //<S2SV> chunk_ofs [ i ] ++ ; //<S2SV> } while ( * hmp_data < 0x80 ) ; //<S2SV> } //<S2SV> chunk_delta [ i ] = chunk_delta [ i ] | ( ( * hmp_data ++ & 0x7F ) << var_len_shift ) ; //<S2SV> chunk_ofs [ i ] ++ ; //<S2SV> if ( chunk_delta [ i ] < smallest_delta ) { //<S2SV> smallest_delta = chunk_delta [ i ] ; //<S2SV> } //<S2SV> hmp_data = hmp_chunk [ i ] + chunk_length [ i ] ; //<S2SV> chunk_length [ i ] -= chunk_ofs [ i ] ; //<S2SV> hmp_chunk [ i ] += chunk_ofs [ i ] ++ ; //<S2SV> chunk_end [ i ] = 0 ; //<S2SV> } //<S2SV> subtract_delta = smallest_delta ; //<S2SV> sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; //<S2SV> sample_count = ( uint32_t ) sample_count_f ; //<S2SV> sample_remainder = sample_count_f - ( float ) sample_count ; //<S2SV> hmp_mdi -> events [ hmp_mdi -> event_count - 1 ] . samples_to_next += sample_count ; //<S2SV> hmp_mdi -> extra_info . approx_total_samples += sample_count ; //<S2SV> while ( end_of_chunks < hmp_chunks ) { //<S2SV> smallest_delta = 0 ; //<S2SV> for ( i = 0 ; i < hmp_chunks ; i ++ ) { //<S2SV> if ( chunk_end [ i ] ) //<S2SV> continue ; //<S2SV> if ( chunk_delta [ i ] ) { //<S2SV> chunk_delta [ i ] -= subtract_delta ; //<S2SV> if ( chunk_delta [ i ] ) { //<S2SV> if ( ( ! smallest_delta ) //<S2SV> || ( smallest_delta > chunk_delta [ i ] ) ) { //<S2SV> smallest_delta = chunk_delta [ i ] ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> do { //<S2SV> if ( ( ( hmp_chunk [ i ] [ 0 ] & 0xf0 ) == 0xb0 ) && ( ( hmp_chunk [ i ] [ 1 ] == 110 ) || ( hmp_chunk [ i ] [ 1 ] == 111 ) ) && ( hmp_chunk [ i ] [ 2 ] > 0x7f ) ) { //<S2SV> hmp_chunk [ i ] += 3 ; //<S2SV> chunk_length [ i ] -= 3 ; //<S2SV> } else { //<S2SV> uint32_t setup_ret = 0 ; //<S2SV> if ( ( setup_ret = _WM_SetupMidiEvent ( hmp_mdi , hmp_chunk [ i ] , chunk_length [ i ] , 0 ) ) == 0 ) { //<S2SV> goto _hmp_end ; //<S2SV> } //<S2SV> if ( ( hmp_chunk [ i ] [ 0 ] == 0xff ) && ( hmp_chunk [ i ] [ 1 ] == 0x2f ) && ( hmp_chunk [ i ] [ 2 ] == 0x00 ) ) { //<S2SV> end_of_chunks ++ ; //<S2SV> chunk_end [ i ] = 1 ; //<S2SV> chunk_length [ i ] -= 3 ; //<S2SV> hmp_chunk [ i ] += 3 ; //<S2SV> goto NEXT_CHUNK ; //<S2SV> } else if ( ( hmp_chunk [ i ] [ 0 ] == 0xff ) && ( hmp_chunk [ i ] [ 1 ] == 0x51 ) && ( hmp_chunk [ i ] [ 2 ] == 0x03 ) ) { //<S2SV> tempo_f = ( float ) ( ( hmp_chunk [ i ] [ 3 ] << 16 ) + ( hmp_chunk [ i ] [ 4 ] << 8 ) + hmp_chunk [ i ] [ 5 ] ) ; //<S2SV> if ( tempo_f == 0.0 ) //<S2SV> tempo_f = 500000.0 ; //<S2SV> fprintf ( stderr , "DEBUG:<S2SV_blank>Tempo<S2SV_blank>change<S2SV_blank>%f\\r\\n" , tempo_f ) ; //<S2SV> } //<S2SV> hmp_chunk [ i ] += setup_ret ; //<S2SV> chunk_length [ i ] -= setup_ret ; //<S2SV> } //<S2SV> var_len_shift = 0 ; //<S2SV> chunk_delta [ i ] = 0 ; //<S2SV> if ( chunk_length [ i ] && * hmp_chunk [ i ] < 0x80 ) { //<S2SV> do { //<S2SV> if ( ! chunk_length [ i ] ) break ; //<S2SV> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; //<S2SV> var_len_shift += 7 ; //<S2SV> hmp_chunk [ i ] ++ ; //<S2SV> chunk_length [ i ] -- ; //<S2SV> } while ( * hmp_chunk [ i ] < 0x80 ) ; //<S2SV> } //<S2SV> if ( ! chunk_length [ i ] ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; //<S2SV> goto _hmp_end ; //<S2SV> } //<S2SV> chunk_delta [ i ] = chunk_delta [ i ] + ( ( * hmp_chunk [ i ] & 0x7F ) << var_len_shift ) ; //<S2SV> hmp_chunk [ i ] ++ ; //<S2SV> chunk_length [ i ] -- ; //<S2SV> } while ( ! chunk_delta [ i ] ) ; //<S2SV> if ( ( ! smallest_delta ) || ( smallest_delta > chunk_delta [ i ] ) ) { //<S2SV> smallest_delta = chunk_delta [ i ] ; //<S2SV> } //<S2SV> NEXT_CHUNK : continue ; //<S2SV> } //<S2SV> subtract_delta = smallest_delta ; //<S2SV> sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; //<S2SV> sample_count = ( uint32_t ) sample_count_f ; //<S2SV> sample_remainder = sample_count_f - ( float ) sample_count ; //<S2SV> hmp_mdi -> events [ hmp_mdi -> event_count - 1 ] . samples_to_next += sample_count ; //<S2SV> hmp_mdi -> extra_info . approx_total_samples += sample_count ; //<S2SV> } //<S2SV> if ( ( hmp_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { //<S2SV> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , "to<S2SV_blank>init<S2SV_blank>reverb" , 0 ) ; //<S2SV> goto _hmp_end ; //<S2SV> } //<S2SV> hmp_mdi -> extra_info . current_sample = 0 ; //<S2SV> hmp_mdi -> current_event = & hmp_mdi -> events [ 0 ] ; //<S2SV> hmp_mdi -> samples_to_mix = 0 ; //<S2SV> hmp_mdi -> note = NULL ; //<S2SV> _WM_ResetToStart ( hmp_mdi ) ; //<S2SV> _hmp_end : //<S2SV> free ( hmp_chunk ) ; //<S2SV> free ( chunk_length ) ; //<S2SV> free ( chunk_delta ) ; //<S2SV> free ( chunk_ofs ) ; //<S2SV> free ( chunk_end ) ; //<S2SV> if ( hmp_mdi -> reverb ) return ( hmp_mdi ) ; //<S2SV> _WM_freeMDI ( hmp_mdi ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 