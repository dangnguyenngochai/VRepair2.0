static int mpeg4_decode_studio_block ( MpegEncContext * s , int32_t block [ 64 ] , int n ) //<S2SV> { //<S2SV> Mpeg4DecContext * ctx = s -> avctx -> priv_data ; //<S2SV> int cc , dct_dc_size , dct_diff , code , j , idx = 1 , group = 0 , run = 0 , //<S2SV> additional_code_len , sign , mismatch ; //<S2SV> VLC * cur_vlc = & ctx -> studio_intra_tab [ 0 ] ; //<S2SV> uint8_t * const scantable = s -> intra_scantable . permutated ; //<S2SV> const uint16_t * quant_matrix ; //<S2SV> uint32_t flc ; //<S2SV> const int min = - 1 * ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) ; //<S2SV> const int max = ( ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) - 1 ) ; //<S2SV> mismatch = 1 ; //<S2SV> memset ( block , 0 , 64 * sizeof ( int32_t ) ) ; //<S2SV> if ( n < 4 ) { //<S2SV> cc = 0 ; //<S2SV> dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; //<S2SV> quant_matrix = s -> intra_matrix ; //<S2SV> } else { //<S2SV> cc = ( n & 1 ) + 1 ; //<S2SV> if ( ctx -> rgb ) //<S2SV> dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; //<S2SV> else //<S2SV> dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_chroma_dc . table , STUDIO_INTRA_BITS , 2 ) ; //<S2SV> quant_matrix = s -> chroma_intra_matrix ; //<S2SV> } //<S2SV> if ( dct_dc_size < 0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "illegal<S2SV_blank>dct_dc_size<S2SV_blank>vlc\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } else if ( dct_dc_size == 0 ) { //<S2SV> dct_diff = 0 ; //<S2SV> } else { //<S2SV> dct_diff = get_xbits ( & s -> gb , dct_dc_size ) ; //<S2SV> if ( dct_dc_size > 8 ) { //<S2SV> if ( ! check_marker ( s -> avctx , & s -> gb , "dct_dc_size<S2SV_blank>><S2SV_blank>8" ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> s -> last_dc [ cc ] += dct_diff ; //<S2SV> if ( s -> mpeg_quant ) //<S2SV> block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) ; //<S2SV> else //<S2SV> block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) * ( 8 >> s -> dct_precision ) ; //<S2SV> block [ 0 ] = av_clip ( block [ 0 ] , min , max ) ; //<S2SV> mismatch ^= block [ 0 ] ; //<S2SV> while ( 1 ) { //<S2SV> group = get_vlc2 ( & s -> gb , cur_vlc -> table , STUDIO_INTRA_BITS , 2 ) ; //<S2SV> if ( group < 0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "illegal<S2SV_blank>ac<S2SV_blank>coefficient<S2SV_blank>group<S2SV_blank>vlc\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> additional_code_len = ac_state_tab [ group ] [ 0 ] ; //<S2SV> cur_vlc = & ctx -> studio_intra_tab [ ac_state_tab [ group ] [ 1 ] ] ; //<S2SV> if ( group == 0 ) { //<S2SV> break ; //<S2SV> } else if ( group >= 1 && group <= 6 ) { //<S2SV> run = 1 << additional_code_len ; //<S2SV> if ( additional_code_len ) //<S2SV> run += get_bits ( & s -> gb , additional_code_len ) ; //<S2SV> idx += run ; //<S2SV> continue ; //<S2SV> } else if ( group >= 7 && group <= 12 ) { //<S2SV> code = get_bits ( & s -> gb , additional_code_len ) ; //<S2SV> sign = code & 1 ; //<S2SV> code >>= 1 ; //<S2SV> run = ( 1 << ( additional_code_len - 1 ) ) + code ; //<S2SV> idx += run ; //<S2SV> j = scantable [ idx ++ ] ; //<S2SV> block [ j ] = sign ? 1 : - 1 ; //<S2SV> } else if ( group >= 13 && group <= 20 ) { //<S2SV> j = scantable [ idx ++ ] ; //<S2SV> block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ; //<S2SV> } else if ( group == 21 ) { //<S2SV> j = scantable [ idx ++ ] ; //<S2SV> additional_code_len = s -> avctx -> bits_per_raw_sample + s -> dct_precision + 4 ; //<S2SV> flc = get_bits ( & s -> gb , additional_code_len ) ; //<S2SV> if ( flc >> ( additional_code_len - 1 ) ) //<S2SV> block [ j ] = - 1 * ( ( flc ^ ( ( 1 << additional_code_len ) - 1 ) ) + 1 ) ; //<S2SV> else //<S2SV> block [ j ] = flc ; //<S2SV> } //<S2SV> block [ j ] = ( ( 8 * 2 * block [ j ] * quant_matrix [ j ] * s -> qscale ) >> s -> dct_precision ) / 32 ; //<S2SV> block [ j ] = av_clip ( block [ j ] , min , max ) ; //<S2SV> mismatch ^= block [ j ] ; //<S2SV> } //<S2SV> block [ 63 ] ^= mismatch & 1 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 