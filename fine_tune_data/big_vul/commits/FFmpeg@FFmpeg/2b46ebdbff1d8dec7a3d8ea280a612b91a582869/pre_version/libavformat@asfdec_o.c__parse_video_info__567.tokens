static int parse_video_info ( AVIOContext * pb , AVStream * st ) //<S2SV> { //<S2SV> uint16_t size_asf ; //<S2SV> uint32_t size_bmp ; //<S2SV> unsigned int tag ; //<S2SV> st -> codecpar -> width = avio_rl32 ( pb ) ; //<S2SV> st -> codecpar -> height = avio_rl32 ( pb ) ; //<S2SV> avio_skip ( pb , 1 ) ; //<S2SV> size_asf = avio_rl16 ( pb ) ; //<S2SV> tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; //<S2SV> st -> codecpar -> codec_tag = tag ; //<S2SV> st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; //<S2SV> size_bmp = FFMAX ( size_asf , size_bmp ) ; //<S2SV> if ( size_bmp > BMP_HEADER_SIZE ) { //<S2SV> int ret ; //<S2SV> st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; //<S2SV> if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + //<S2SV> AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { //<S2SV> st -> codecpar -> extradata_size = 0 ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , //<S2SV> AV_INPUT_BUFFER_PADDING_SIZE ) ; //<S2SV> if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , //<S2SV> st -> codecpar -> extradata_size ) ) < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 