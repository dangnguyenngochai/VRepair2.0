static int ape_decode_frame ( AVCodecContext * avctx , void * data , //<S2SV> int * got_frame_ptr , AVPacket * avpkt ) //<S2SV> { //<S2SV> AVFrame * frame = data ; //<S2SV> const uint8_t * buf = avpkt -> data ; //<S2SV> APEContext * s = avctx -> priv_data ; //<S2SV> uint8_t * sample8 ; //<S2SV> int16_t * sample16 ; //<S2SV> int32_t * sample24 ; //<S2SV> int i , ch , ret ; //<S2SV> int blockstodecode ; //<S2SV> uint64_t decoded_buffer_size ; //<S2SV> av_assert0 ( s -> samples >= 0 ) ; //<S2SV> if ( ! s -> samples ) { //<S2SV> uint32_t nblocks , offset ; //<S2SV> int buf_size ; //<S2SV> if ( ! avpkt -> size ) { //<S2SV> * got_frame_ptr = 0 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( avpkt -> size < 8 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> buf_size = avpkt -> size & ~ 3 ; //<S2SV> if ( buf_size != avpkt -> size ) { //<S2SV> av_log ( avctx , AV_LOG_WARNING , "packet<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4.<S2SV_blank>" //<S2SV> "extra<S2SV_blank>bytes<S2SV_blank>at<S2SV_blank>the<S2SV_blank>end<S2SV_blank>will<S2SV_blank>be<S2SV_blank>skipped.\\n" ) ; //<S2SV> } //<S2SV> if ( s -> fileversion < 3950 ) //<S2SV> buf_size += 2 ; //<S2SV> av_fast_padded_malloc ( & s -> data , & s -> data_size , buf_size ) ; //<S2SV> if ( ! s -> data ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> s -> bdsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , //<S2SV> buf_size >> 2 ) ; //<S2SV> memset ( s -> data + ( buf_size & ~ 3 ) , 0 , buf_size & 3 ) ; //<S2SV> s -> ptr = s -> data ; //<S2SV> s -> data_end = s -> data + buf_size ; //<S2SV> nblocks = bytestream_get_be32 ( & s -> ptr ) ; //<S2SV> offset = bytestream_get_be32 ( & s -> ptr ) ; //<S2SV> if ( s -> fileversion >= 3900 ) { //<S2SV> if ( offset > 3 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Incorrect<S2SV_blank>offset<S2SV_blank>passed\\n" ) ; //<S2SV> s -> data = NULL ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( s -> data_end - s -> ptr < offset ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> s -> ptr += offset ; //<S2SV> } else { //<S2SV> if ( ( ret = init_get_bits8 ( & s -> gb , s -> ptr , s -> data_end - s -> ptr ) ) < 0 ) //<S2SV> return ret ; //<S2SV> if ( s -> fileversion > 3800 ) //<S2SV> skip_bits_long ( & s -> gb , offset * 8 ) ; //<S2SV> else //<S2SV> skip_bits_long ( & s -> gb , offset ) ; //<S2SV> } //<S2SV> if ( ! nblocks || nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>count:<S2SV_blank>%" PRIu32 ".\\n" , //<S2SV> nblocks ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( init_frame_decoder ( s ) < 0 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Error<S2SV_blank>reading<S2SV_blank>frame<S2SV_blank>header\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> s -> samples = nblocks ; //<S2SV> } //<S2SV> if ( ! s -> data ) { //<S2SV> * got_frame_ptr = 0 ; //<S2SV> return avpkt -> size ; //<S2SV> } //<S2SV> blockstodecode = FFMIN ( s -> blocks_per_loop , s -> samples ) ; //<S2SV> if ( s -> fileversion < 3930 ) //<S2SV> blockstodecode = s -> samples ; //<S2SV> decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; //<S2SV> av_assert0 ( decoded_buffer_size <= INT_MAX ) ; //<S2SV> av_fast_malloc ( & s -> decoded_buffer , & s -> decoded_size , decoded_buffer_size ) ; //<S2SV> if ( ! s -> decoded_buffer ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> memset ( s -> decoded_buffer , 0 , s -> decoded_size ) ; //<S2SV> s -> decoded [ 0 ] = s -> decoded_buffer ; //<S2SV> s -> decoded [ 1 ] = s -> decoded_buffer + FFALIGN ( blockstodecode , 8 ) ; //<S2SV> frame -> nb_samples = blockstodecode ; //<S2SV> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) //<S2SV> return ret ; //<S2SV> s -> error = 0 ; //<S2SV> if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) //<S2SV> ape_unpack_mono ( s , blockstodecode ) ; //<S2SV> else //<S2SV> ape_unpack_stereo ( s , blockstodecode ) ; //<S2SV> emms_c ( ) ; //<S2SV> if ( s -> error ) { //<S2SV> s -> samples = 0 ; //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Error<S2SV_blank>decoding<S2SV_blank>frame\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> switch ( s -> bps ) { //<S2SV> case 8 : //<S2SV> for ( ch = 0 ; ch < s -> channels ; ch ++ ) { //<S2SV> sample8 = ( uint8_t * ) frame -> data [ ch ] ; //<S2SV> for ( i = 0 ; i < blockstodecode ; i ++ ) //<S2SV> * sample8 ++ = ( s -> decoded [ ch ] [ i ] + 0x80 ) & 0xff ; //<S2SV> } //<S2SV> break ; //<S2SV> case 16 : //<S2SV> for ( ch = 0 ; ch < s -> channels ; ch ++ ) { //<S2SV> sample16 = ( int16_t * ) frame -> data [ ch ] ; //<S2SV> for ( i = 0 ; i < blockstodecode ; i ++ ) //<S2SV> * sample16 ++ = s -> decoded [ ch ] [ i ] ; //<S2SV> } //<S2SV> break ; //<S2SV> case 24 : //<S2SV> for ( ch = 0 ; ch < s -> channels ; ch ++ ) { //<S2SV> sample24 = ( int32_t * ) frame -> data [ ch ] ; //<S2SV> for ( i = 0 ; i < blockstodecode ; i ++ ) //<S2SV> * sample24 ++ = s -> decoded [ ch ] [ i ] << 8 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> s -> samples -= blockstodecode ; //<S2SV> * got_frame_ptr = 1 ; //<S2SV> return ! s -> samples ? avpkt -> size : 0 ; //<S2SV> } //<S2SV> 