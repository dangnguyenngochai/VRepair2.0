static int get_siz ( Jpeg2000DecoderContext * s ) //<S2SV> { //<S2SV> int i ; //<S2SV> int ncomponents ; //<S2SV> uint32_t log2_chroma_wh = 0 ; //<S2SV> const enum AVPixelFormat * possible_fmts = NULL ; //<S2SV> int possible_fmts_nb = 0 ; //<S2SV> if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; //<S2SV> s -> width = bytestream2_get_be32u ( & s -> g ) ; //<S2SV> s -> height = bytestream2_get_be32u ( & s -> g ) ; //<S2SV> s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; //<S2SV> s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; //<S2SV> s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; //<S2SV> s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; //<S2SV> s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; //<S2SV> s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; //<S2SV> ncomponents = bytestream2_get_be16u ( & s -> g ) ; //<S2SV> if ( ncomponents <= 0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n" , //<S2SV> s -> ncomponents ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ncomponents > 4 ) { //<S2SV> avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components" , //<S2SV> s -> ncomponents ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> s -> ncomponents = ncomponents ; //<S2SV> if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n" , //<S2SV> s -> tile_width , s -> tile_height ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> for ( i = 0 ; i < s -> ncomponents ; i ++ ) { //<S2SV> uint8_t x = bytestream2_get_byteu ( & s -> g ) ; //<S2SV> s -> cbps [ i ] = ( x & 0x7f ) + 1 ; //<S2SV> s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; //<S2SV> s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; //<S2SV> s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; //<S2SV> s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; //<S2SV> if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 //<S2SV> || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>seperation\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; //<S2SV> } //<S2SV> s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; //<S2SV> s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; //<S2SV> if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { //<S2SV> s -> numXtiles = s -> numYtiles = 0 ; //<S2SV> return AVERROR ( EINVAL ) ; //<S2SV> } //<S2SV> s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; //<S2SV> if ( ! s -> tile ) { //<S2SV> s -> numXtiles = s -> numYtiles = 0 ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { //<S2SV> Jpeg2000Tile * tile = s -> tile + i ; //<S2SV> tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; //<S2SV> if ( ! tile -> comp ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , //<S2SV> s -> reduction_factor ) ; //<S2SV> s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , //<S2SV> s -> reduction_factor ) ; //<S2SV> if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || //<S2SV> s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { //<S2SV> possible_fmts = xyz_pix_fmts ; //<S2SV> possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; //<S2SV> } else { //<S2SV> switch ( s -> colour_space ) { //<S2SV> case 16 : //<S2SV> possible_fmts = rgb_pix_fmts ; //<S2SV> possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; //<S2SV> break ; //<S2SV> case 17 : //<S2SV> possible_fmts = gray_pix_fmts ; //<S2SV> possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; //<S2SV> break ; //<S2SV> case 18 : //<S2SV> possible_fmts = yuv_pix_fmts ; //<S2SV> possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> possible_fmts = all_pix_fmts ; //<S2SV> possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { //<S2SV> if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { //<S2SV> s -> avctx -> pix_fmt = possible_fmts [ i ] ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>" //<S2SV> "components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>" //<S2SV> "cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n" , //<S2SV> s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , //<S2SV> ncomponents > 2 ? s -> cdx [ 1 ] : 0 , //<S2SV> ncomponents > 2 ? s -> cdy [ 1 ] : 0 , //<S2SV> ncomponents > 2 ? s -> cdx [ 2 ] : 0 , //<S2SV> ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 