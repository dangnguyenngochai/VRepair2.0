static int ape_read_header ( AVFormatContext * s , AVFormatParameters * ap ) //<S2SV> { //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> APEContext * ape = s -> priv_data ; //<S2SV> AVStream * st ; //<S2SV> uint32_t tag ; //<S2SV> int i ; //<S2SV> int total_blocks ; //<S2SV> int64_t pts ; //<S2SV> ape -> junklength = 0 ; //<S2SV> tag = avio_rl32 ( pb ) ; //<S2SV> if ( tag != MKTAG ( 'M' , 'A' , 'C' , '<S2SV_blank>' ) ) //<S2SV> return - 1 ; //<S2SV> ape -> fileversion = avio_rl16 ( pb ) ; //<S2SV> if ( ape -> fileversion < APE_MIN_VERSION || ape -> fileversion > APE_MAX_VERSION ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "Unsupported<S2SV_blank>file<S2SV_blank>version<S2SV_blank>-<S2SV_blank>%d.%02d\\n" , ape -> fileversion / 1000 , ( ape -> fileversion % 1000 ) / 10 ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( ape -> fileversion >= 3980 ) { //<S2SV> ape -> padding1 = avio_rl16 ( pb ) ; //<S2SV> ape -> descriptorlength = avio_rl32 ( pb ) ; //<S2SV> ape -> headerlength = avio_rl32 ( pb ) ; //<S2SV> ape -> seektablelength = avio_rl32 ( pb ) ; //<S2SV> ape -> wavheaderlength = avio_rl32 ( pb ) ; //<S2SV> ape -> audiodatalength = avio_rl32 ( pb ) ; //<S2SV> ape -> audiodatalength_high = avio_rl32 ( pb ) ; //<S2SV> ape -> wavtaillength = avio_rl32 ( pb ) ; //<S2SV> avio_read ( pb , ape -> md5 , 16 ) ; //<S2SV> if ( ape -> descriptorlength > 52 ) //<S2SV> avio_seek ( pb , ape -> descriptorlength - 52 , SEEK_CUR ) ; //<S2SV> ape -> compressiontype = avio_rl16 ( pb ) ; //<S2SV> ape -> formatflags = avio_rl16 ( pb ) ; //<S2SV> ape -> blocksperframe = avio_rl32 ( pb ) ; //<S2SV> ape -> finalframeblocks = avio_rl32 ( pb ) ; //<S2SV> ape -> totalframes = avio_rl32 ( pb ) ; //<S2SV> ape -> bps = avio_rl16 ( pb ) ; //<S2SV> ape -> channels = avio_rl16 ( pb ) ; //<S2SV> ape -> samplerate = avio_rl32 ( pb ) ; //<S2SV> } else { //<S2SV> ape -> descriptorlength = 0 ; //<S2SV> ape -> headerlength = 32 ; //<S2SV> ape -> compressiontype = avio_rl16 ( pb ) ; //<S2SV> ape -> formatflags = avio_rl16 ( pb ) ; //<S2SV> ape -> channels = avio_rl16 ( pb ) ; //<S2SV> ape -> samplerate = avio_rl32 ( pb ) ; //<S2SV> ape -> wavheaderlength = avio_rl32 ( pb ) ; //<S2SV> ape -> wavtaillength = avio_rl32 ( pb ) ; //<S2SV> ape -> totalframes = avio_rl32 ( pb ) ; //<S2SV> ape -> finalframeblocks = avio_rl32 ( pb ) ; //<S2SV> if ( ape -> formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL ) { //<S2SV> avio_seek ( pb , 4 , SEEK_CUR ) ; //<S2SV> ape -> headerlength += 4 ; //<S2SV> } //<S2SV> if ( ape -> formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS ) { //<S2SV> ape -> seektablelength = avio_rl32 ( pb ) ; //<S2SV> ape -> headerlength += 4 ; //<S2SV> ape -> seektablelength *= sizeof ( int32_t ) ; //<S2SV> } else //<S2SV> ape -> seektablelength = ape -> totalframes * sizeof ( int32_t ) ; //<S2SV> if ( ape -> formatflags & MAC_FORMAT_FLAG_8_BIT ) //<S2SV> ape -> bps = 8 ; //<S2SV> else if ( ape -> formatflags & MAC_FORMAT_FLAG_24_BIT ) //<S2SV> ape -> bps = 24 ; //<S2SV> else //<S2SV> ape -> bps = 16 ; //<S2SV> if ( ape -> fileversion >= 3950 ) //<S2SV> ape -> blocksperframe = 73728 * 4 ; //<S2SV> else if ( ape -> fileversion >= 3900 || ( ape -> fileversion >= 3800 && ape -> compressiontype >= 4000 ) ) //<S2SV> ape -> blocksperframe = 73728 ; //<S2SV> else //<S2SV> ape -> blocksperframe = 9216 ; //<S2SV> if ( ! ( ape -> formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER ) ) //<S2SV> avio_seek ( pb , ape -> wavheaderlength , SEEK_CUR ) ; //<S2SV> } //<S2SV> if ( ! ape -> totalframes ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\n" ) ; //<S2SV> return AVERROR ( EINVAL ) ; //<S2SV> } //<S2SV> if ( ape -> totalframes > UINT_MAX / sizeof ( APEFrame ) ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "Too<S2SV_blank>many<S2SV_blank>frames:<S2SV_blank>%d\\n" , ape -> totalframes ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> ape -> frames = av_malloc ( ape -> totalframes * sizeof ( APEFrame ) ) ; //<S2SV> if ( ! ape -> frames ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> ape -> firstframe = ape -> junklength + ape -> descriptorlength + ape -> headerlength + ape -> seektablelength + ape -> wavheaderlength ; //<S2SV> ape -> currentframe = 0 ; //<S2SV> ape -> totalsamples = ape -> finalframeblocks ; //<S2SV> if ( ape -> totalframes > 1 ) //<S2SV> ape -> totalsamples += ape -> blocksperframe * ( ape -> totalframes - 1 ) ; //<S2SV> if ( ape -> seektablelength > 0 ) { //<S2SV> ape -> seektable = av_malloc ( ape -> seektablelength ) ; //<S2SV> for ( i = 0 ; i < ape -> seektablelength / sizeof ( uint32_t ) ; i ++ ) //<S2SV> ape -> seektable [ i ] = avio_rl32 ( pb ) ; //<S2SV> } //<S2SV> ape -> frames [ 0 ] . pos = ape -> firstframe ; //<S2SV> ape -> frames [ 0 ] . nblocks = ape -> blocksperframe ; //<S2SV> ape -> frames [ 0 ] . skip = 0 ; //<S2SV> for ( i = 1 ; i < ape -> totalframes ; i ++ ) { //<S2SV> ape -> frames [ i ] . pos = ape -> seektable [ i ] ; //<S2SV> ape -> frames [ i ] . nblocks = ape -> blocksperframe ; //<S2SV> ape -> frames [ i - 1 ] . size = ape -> frames [ i ] . pos - ape -> frames [ i - 1 ] . pos ; //<S2SV> ape -> frames [ i ] . skip = ( ape -> frames [ i ] . pos - ape -> frames [ 0 ] . pos ) & 3 ; //<S2SV> } //<S2SV> ape -> frames [ ape -> totalframes - 1 ] . size = ape -> finalframeblocks * 4 ; //<S2SV> ape -> frames [ ape -> totalframes - 1 ] . nblocks = ape -> finalframeblocks ; //<S2SV> for ( i = 0 ; i < ape -> totalframes ; i ++ ) { //<S2SV> if ( ape -> frames [ i ] . skip ) { //<S2SV> ape -> frames [ i ] . pos -= ape -> frames [ i ] . skip ; //<S2SV> ape -> frames [ i ] . size += ape -> frames [ i ] . skip ; //<S2SV> } //<S2SV> ape -> frames [ i ] . size = ( ape -> frames [ i ] . size + 3 ) & ~ 3 ; //<S2SV> } //<S2SV> ape_dumpinfo ( s , ape ) ; //<S2SV> if ( ! url_is_streamed ( pb ) ) { //<S2SV> ff_ape_parse_tag ( s ) ; //<S2SV> avio_seek ( pb , 0 , SEEK_SET ) ; //<S2SV> } //<S2SV> av_log ( s , AV_LOG_DEBUG , "Decoding<S2SV_blank>file<S2SV_blank>-<S2SV_blank>v%d.%02d,<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d\\n" , ape -> fileversion / 1000 , ( ape -> fileversion % 1000 ) / 10 , ape -> compressiontype ) ; //<S2SV> st = av_new_stream ( s , 0 ) ; //<S2SV> if ( ! st ) //<S2SV> return - 1 ; //<S2SV> total_blocks = ( ape -> totalframes == 0 ) ? 0 : ( ( ape -> totalframes - 1 ) * ape -> blocksperframe ) + ape -> finalframeblocks ; //<S2SV> st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; //<S2SV> st -> codec -> codec_id = CODEC_ID_APE ; //<S2SV> st -> codec -> codec_tag = MKTAG ( 'A' , 'P' , 'E' , '<S2SV_blank>' ) ; //<S2SV> st -> codec -> channels = ape -> channels ; //<S2SV> st -> codec -> sample_rate = ape -> samplerate ; //<S2SV> st -> codec -> bits_per_coded_sample = ape -> bps ; //<S2SV> st -> codec -> frame_size = MAC_SUBFRAME_SIZE ; //<S2SV> st -> nb_frames = ape -> totalframes ; //<S2SV> st -> start_time = 0 ; //<S2SV> st -> duration = total_blocks / MAC_SUBFRAME_SIZE ; //<S2SV> av_set_pts_info ( st , 64 , MAC_SUBFRAME_SIZE , ape -> samplerate ) ; //<S2SV> st -> codec -> extradata = av_malloc ( APE_EXTRADATA_SIZE ) ; //<S2SV> st -> codec -> extradata_size = APE_EXTRADATA_SIZE ; //<S2SV> AV_WL16 ( st -> codec -> extradata + 0 , ape -> fileversion ) ; //<S2SV> AV_WL16 ( st -> codec -> extradata + 2 , ape -> compressiontype ) ; //<S2SV> AV_WL16 ( st -> codec -> extradata + 4 , ape -> formatflags ) ; //<S2SV> pts = 0 ; //<S2SV> for ( i = 0 ; i < ape -> totalframes ; i ++ ) { //<S2SV> ape -> frames [ i ] . pts = pts ; //<S2SV> av_add_index_entry ( st , ape -> frames [ i ] . pos , ape -> frames [ i ] . pts , 0 , 0 , AVINDEX_KEYFRAME ) ; //<S2SV> pts += ape -> blocksperframe / MAC_SUBFRAME_SIZE ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 