static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) //<S2SV> { //<S2SV> AVFilterContext * ctx = inlink -> dst ; //<S2SV> FPSContext * s = ctx -> priv ; //<S2SV> AVFilterLink * outlink = ctx -> outputs [ 0 ] ; //<S2SV> int64_t delta ; //<S2SV> int i , ret ; //<S2SV> s -> frames_in ++ ; //<S2SV> if ( s -> pts == AV_NOPTS_VALUE ) { //<S2SV> if ( buf -> pts != AV_NOPTS_VALUE ) { //<S2SV> ret = write_to_fifo ( s -> fifo , buf ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { //<S2SV> double first_pts = s -> start_time * AV_TIME_BASE ; //<S2SV> first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; //<S2SV> s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , //<S2SV> inlink -> time_base ) ; //<S2SV> av_log ( ctx , AV_LOG_VERBOSE , "Set<S2SV_blank>first<S2SV_blank>pts<S2SV_blank>to<S2SV_blank>(in:%" PRId64 "<S2SV_blank>out:%" PRId64 ")\\n" , //<S2SV> s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , //<S2SV> outlink -> time_base ) ) ; //<S2SV> } else { //<S2SV> s -> first_pts = s -> pts = buf -> pts ; //<S2SV> } //<S2SV> } else { //<S2SV> av_log ( ctx , AV_LOG_WARNING , "Discarding<S2SV_blank>initial<S2SV_blank>frame(s)<S2SV_blank>with<S2SV_blank>no<S2SV_blank>" //<S2SV> "timestamp.\\n" ) ; //<S2SV> av_frame_free ( & buf ) ; //<S2SV> s -> drop ++ ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( buf -> pts == AV_NOPTS_VALUE ) { //<S2SV> return write_to_fifo ( s -> fifo , buf ) ; //<S2SV> } //<S2SV> delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , //<S2SV> outlink -> time_base , s -> rounding ) ; //<S2SV> if ( delta < 1 ) { //<S2SV> AVFrame * tmp ; //<S2SV> int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; //<S2SV> av_log ( ctx , AV_LOG_DEBUG , "Dropping<S2SV_blank>%d<S2SV_blank>frame(s).\\n" , drop ) ; //<S2SV> s -> drop += drop ; //<S2SV> av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; //<S2SV> flush_fifo ( s -> fifo ) ; //<S2SV> ret = write_to_fifo ( s -> fifo , tmp ) ; //<S2SV> av_frame_free ( & buf ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> for ( i = 0 ; i < delta ; i ++ ) { //<S2SV> AVFrame * buf_out ; //<S2SV> av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; //<S2SV> if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { //<S2SV> AVFrame * dup = av_frame_clone ( buf_out ) ; //<S2SV> av_log ( ctx , AV_LOG_DEBUG , "Duplicating<S2SV_blank>frame.\\n" ) ; //<S2SV> if ( dup ) //<S2SV> ret = write_to_fifo ( s -> fifo , dup ) ; //<S2SV> else //<S2SV> ret = AVERROR ( ENOMEM ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> av_frame_free ( & buf_out ) ; //<S2SV> av_frame_free ( & buf ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> s -> dup ++ ; //<S2SV> } //<S2SV> buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , //<S2SV> outlink -> time_base ) + s -> frames_out ; //<S2SV> if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { //<S2SV> av_frame_free ( & buf ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> s -> frames_out ++ ; //<S2SV> } //<S2SV> flush_fifo ( s -> fifo ) ; //<S2SV> ret = write_to_fifo ( s -> fifo , buf ) ; //<S2SV> s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 