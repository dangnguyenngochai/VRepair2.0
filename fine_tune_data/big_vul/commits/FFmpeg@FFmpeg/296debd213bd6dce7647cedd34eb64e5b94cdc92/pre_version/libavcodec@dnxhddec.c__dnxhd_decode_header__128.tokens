static int dnxhd_decode_header ( DNXHDContext * ctx , AVFrame * frame , //<S2SV> const uint8_t * buf , int buf_size , //<S2SV> int first_field ) //<S2SV> { //<S2SV> int i , cid , ret ; //<S2SV> int old_bit_depth = ctx -> bit_depth , bitdepth ; //<S2SV> uint64_t header_prefix ; //<S2SV> if ( buf_size < 0x280 ) { //<S2SV> av_log ( ctx -> avctx , AV_LOG_ERROR , //<S2SV> "buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>640).\\n" , buf_size ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> header_prefix = ff_dnxhd_parse_header_prefix ( buf ) ; //<S2SV> if ( header_prefix == 0 ) { //<S2SV> av_log ( ctx -> avctx , AV_LOG_ERROR , //<S2SV> "unknown<S2SV_blank>header<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X\\n" , //<S2SV> buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] , buf [ 4 ] ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( buf [ 5 ] & 2 ) { //<S2SV> ctx -> cur_field = buf [ 5 ] & 1 ; //<S2SV> frame -> interlaced_frame = 1 ; //<S2SV> frame -> top_field_first = first_field ^ ctx -> cur_field ; //<S2SV> av_log ( ctx -> avctx , AV_LOG_DEBUG , //<S2SV> "interlaced<S2SV_blank>%d,<S2SV_blank>cur<S2SV_blank>field<S2SV_blank>%d\\n" , buf [ 5 ] & 3 , ctx -> cur_field ) ; //<S2SV> } else { //<S2SV> ctx -> cur_field = 0 ; //<S2SV> } //<S2SV> ctx -> mbaff = ( buf [ 0x6 ] >> 5 ) & 1 ; //<S2SV> ctx -> height = AV_RB16 ( buf + 0x18 ) ; //<S2SV> ctx -> width = AV_RB16 ( buf + 0x1a ) ; //<S2SV> switch ( buf [ 0x21 ] >> 5 ) { //<S2SV> case 1 : bitdepth = 8 ; break ; //<S2SV> case 2 : bitdepth = 10 ; break ; //<S2SV> case 3 : bitdepth = 12 ; break ; //<S2SV> default : //<S2SV> av_log ( ctx -> avctx , AV_LOG_ERROR , //<S2SV> "Unknown<S2SV_blank>bitdepth<S2SV_blank>indicator<S2SV_blank>(%d)\\n" , buf [ 0x21 ] >> 5 ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> cid = AV_RB32 ( buf + 0x28 ) ; //<S2SV> ctx -> avctx -> profile = dnxhd_get_profile ( cid ) ; //<S2SV> if ( ( ret = dnxhd_init_vlc ( ctx , cid , bitdepth ) ) < 0 ) //<S2SV> return ret ; //<S2SV> if ( ctx -> mbaff && ctx -> cid_table -> cid != 1260 ) //<S2SV> av_log ( ctx -> avctx , AV_LOG_WARNING , //<S2SV> "Adaptive<S2SV_blank>MB<S2SV_blank>interlace<S2SV_blank>flag<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n" ) ; //<S2SV> ctx -> act = buf [ 0x2C ] & 7 ; //<S2SV> if ( ctx -> act && ctx -> cid_table -> cid != 1256 && ctx -> cid_table -> cid != 1270 ) //<S2SV> av_log ( ctx -> avctx , AV_LOG_WARNING , //<S2SV> "Adaptive<S2SV_blank>color<S2SV_blank>transform<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n" ) ; //<S2SV> ctx -> is_444 = ( buf [ 0x2C ] >> 6 ) & 1 ; //<S2SV> if ( ctx -> is_444 ) { //<S2SV> if ( bitdepth == 8 ) { //<S2SV> avpriv_request_sample ( ctx -> avctx , "4:4:4<S2SV_blank>8<S2SV_blank>bits" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } else if ( bitdepth == 10 ) { //<S2SV> ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; //<S2SV> ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P10 //<S2SV> : AV_PIX_FMT_GBRP10 ; //<S2SV> } else { //<S2SV> ctx -> decode_dct_block = dnxhd_decode_dct_block_12_444 ; //<S2SV> ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P12 //<S2SV> : AV_PIX_FMT_GBRP12 ; //<S2SV> } //<S2SV> } else if ( bitdepth == 12 ) { //<S2SV> ctx -> decode_dct_block = dnxhd_decode_dct_block_12 ; //<S2SV> ctx -> pix_fmt = AV_PIX_FMT_YUV422P12 ; //<S2SV> } else if ( bitdepth == 10 ) { //<S2SV> if ( ctx -> avctx -> profile == FF_PROFILE_DNXHR_HQX ) //<S2SV> ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; //<S2SV> else //<S2SV> ctx -> decode_dct_block = dnxhd_decode_dct_block_10 ; //<S2SV> ctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; //<S2SV> } else { //<S2SV> ctx -> decode_dct_block = dnxhd_decode_dct_block_8 ; //<S2SV> ctx -> pix_fmt = AV_PIX_FMT_YUV422P ; //<S2SV> } //<S2SV> ctx -> avctx -> bits_per_raw_sample = ctx -> bit_depth = bitdepth ; //<S2SV> if ( ctx -> bit_depth != old_bit_depth ) { //<S2SV> ff_blockdsp_init ( & ctx -> bdsp , ctx -> avctx ) ; //<S2SV> ff_idctdsp_init ( & ctx -> idsp , ctx -> avctx ) ; //<S2SV> ff_init_scantable ( ctx -> idsp . idct_permutation , & ctx -> scantable , //<S2SV> ff_zigzag_direct ) ; //<S2SV> } //<S2SV> if ( ctx -> width != ctx -> cid_table -> width && //<S2SV> ctx -> cid_table -> width != DNXHD_VARIABLE ) { //<S2SV> av_reduce ( & ctx -> avctx -> sample_aspect_ratio . num , //<S2SV> & ctx -> avctx -> sample_aspect_ratio . den , //<S2SV> ctx -> width , ctx -> cid_table -> width , 255 ) ; //<S2SV> ctx -> width = ctx -> cid_table -> width ; //<S2SV> } //<S2SV> if ( buf_size < ctx -> cid_table -> coding_unit_size ) { //<S2SV> av_log ( ctx -> avctx , AV_LOG_ERROR , "incorrect<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%u).\\n" , //<S2SV> buf_size , ctx -> cid_table -> coding_unit_size ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> ctx -> mb_width = ( ctx -> width + 15 ) >> 4 ; //<S2SV> ctx -> mb_height = AV_RB16 ( buf + 0x16c ) ; //<S2SV> if ( ( ctx -> height + 15 ) >> 4 == ctx -> mb_height && frame -> interlaced_frame ) //<S2SV> ctx -> height <<= 1 ; //<S2SV> av_log ( ctx -> avctx , AV_LOG_VERBOSE , "%dx%d,<S2SV_blank>4:%s<S2SV_blank>%d<S2SV_blank>bits,<S2SV_blank>MBAFF=%d<S2SV_blank>ACT=%d\\n" , //<S2SV> ctx -> width , ctx -> height , ctx -> is_444 ? "4:4" : "2:2" , //<S2SV> ctx -> bit_depth , ctx -> mbaff , ctx -> act ) ; //<S2SV> if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) { //<S2SV> ctx -> data_offset = 0x170 + ( ctx -> mb_height << 2 ) ; //<S2SV> } else { //<S2SV> if ( ctx -> mb_height > 68 || //<S2SV> ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4 ) { //<S2SV> av_log ( ctx -> avctx , AV_LOG_ERROR , //<S2SV> "mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n" , ctx -> mb_height ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> ctx -> data_offset = 0x280 ; //<S2SV> } //<S2SV> if ( buf_size < ctx -> data_offset ) { //<S2SV> av_log ( ctx -> avctx , AV_LOG_ERROR , //<S2SV> "buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%d).\\n" , buf_size , ctx -> data_offset ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ctx -> mb_height > FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) { //<S2SV> av_log ( ctx -> avctx , AV_LOG_ERROR , //<S2SV> "mb_height<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%" SIZE_SPECIFIER ").\\n" , ctx -> mb_height , FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ctx -> mb_height ; i ++ ) { //<S2SV> ctx -> mb_scan_index [ i ] = AV_RB32 ( buf + 0x170 + ( i << 2 ) ) ; //<S2SV> ff_dlog ( ctx -> avctx , "mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>%d,<S2SV_blank>pos<S2SV_blank>%d:<S2SV_blank>%" PRIu32 "\\n" , //<S2SV> i , 0x170 + ( i << 2 ) , ctx -> mb_scan_index [ i ] ) ; //<S2SV> if ( buf_size - ctx -> data_offset < ctx -> mb_scan_index [ i ] ) { //<S2SV> av_log ( ctx -> avctx , AV_LOG_ERROR , //<S2SV> "invalid<S2SV_blank>mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>(%" PRIu32 "<S2SV_blank>vs<S2SV_blank>%u).\\n" , //<S2SV> ctx -> mb_scan_index [ i ] , buf_size - ctx -> data_offset ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 