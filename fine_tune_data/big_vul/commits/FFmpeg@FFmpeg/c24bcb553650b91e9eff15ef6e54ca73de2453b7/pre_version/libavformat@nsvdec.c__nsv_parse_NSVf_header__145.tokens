static int nsv_parse_NSVf_header ( AVFormatContext * s ) //<S2SV> { //<S2SV> NSVContext * nsv = s -> priv_data ; //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> unsigned int av_unused file_size ; //<S2SV> unsigned int size ; //<S2SV> int64_t duration ; //<S2SV> int strings_size ; //<S2SV> int table_entries ; //<S2SV> int table_entries_used ; //<S2SV> nsv -> state = NSV_UNSYNC ; //<S2SV> size = avio_rl32 ( pb ) ; //<S2SV> if ( size < 28 ) //<S2SV> return - 1 ; //<S2SV> nsv -> NSVf_end = size ; //<S2SV> file_size = ( uint32_t ) avio_rl32 ( pb ) ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n" , size ) ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n" , file_size ) ; //<S2SV> nsv -> duration = duration = avio_rl32 ( pb ) ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%" PRId64 "<S2SV_blank>ms\\n" , duration ) ; //<S2SV> strings_size = avio_rl32 ( pb ) ; //<S2SV> table_entries = avio_rl32 ( pb ) ; //<S2SV> table_entries_used = avio_rl32 ( pb ) ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n" , //<S2SV> strings_size , table_entries , table_entries_used ) ; //<S2SV> if ( avio_feof ( pb ) ) //<S2SV> return - 1 ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; //<S2SV> if ( strings_size > 0 ) { //<S2SV> char * strings ; //<S2SV> char * p , * endp ; //<S2SV> char * token , * value ; //<S2SV> char quote ; //<S2SV> p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ; //<S2SV> if ( ! p ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> endp = strings + strings_size ; //<S2SV> avio_read ( pb , strings , strings_size ) ; //<S2SV> while ( p < endp ) { //<S2SV> while ( * p == '<S2SV_blank>' ) //<S2SV> p ++ ; //<S2SV> if ( p >= endp - 2 ) //<S2SV> break ; //<S2SV> token = p ; //<S2SV> p = strchr ( p , '=' ) ; //<S2SV> if ( ! p || p >= endp - 2 ) //<S2SV> break ; //<S2SV> * p ++ = '\\0' ; //<S2SV> quote = * p ++ ; //<S2SV> value = p ; //<S2SV> p = strchr ( p , quote ) ; //<S2SV> if ( ! p || p >= endp ) //<S2SV> break ; //<S2SV> * p ++ = '\\0' ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n" , token , value ) ; //<S2SV> av_dict_set ( & s -> metadata , token , value , 0 ) ; //<S2SV> } //<S2SV> av_free ( strings ) ; //<S2SV> } //<S2SV> if ( avio_feof ( pb ) ) //<S2SV> return - 1 ; //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; //<S2SV> if ( table_entries_used > 0 ) { //<S2SV> int i ; //<S2SV> nsv -> index_entries = table_entries_used ; //<S2SV> if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) //<S2SV> return - 1 ; //<S2SV> nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; //<S2SV> if ( ! nsv -> nsvs_file_offset ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> for ( i = 0 ; i < table_entries_used ; i ++ ) //<S2SV> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; //<S2SV> if ( table_entries > table_entries_used && //<S2SV> avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { //<S2SV> nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; //<S2SV> if ( ! nsv -> nsvs_timestamps ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> for ( i = 0 ; i < table_entries_used ; i ++ ) { //<S2SV> nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; //<S2SV> avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; //<S2SV> if ( avio_feof ( pb ) ) //<S2SV> return - 1 ; //<S2SV> nsv -> state = NSV_HAS_READ_NSVF ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 