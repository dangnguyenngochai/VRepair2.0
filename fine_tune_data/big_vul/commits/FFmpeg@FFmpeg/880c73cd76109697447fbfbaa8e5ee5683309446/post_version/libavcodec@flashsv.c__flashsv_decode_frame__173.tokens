static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , //<S2SV> int * got_frame , AVPacket * avpkt ) //<S2SV> { //<S2SV> int buf_size = avpkt -> size ; //<S2SV> FlashSVContext * s = avctx -> priv_data ; //<S2SV> int h_blocks , v_blocks , h_part , v_part , i , j , ret ; //<S2SV> GetBitContext gb ; //<S2SV> int last_blockwidth = s -> block_width ; //<S2SV> int last_blockheight = s -> block_height ; //<S2SV> if ( buf_size == 0 ) //<S2SV> return 0 ; //<S2SV> if ( buf_size < 4 ) //<S2SV> return - 1 ; //<S2SV> init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; //<S2SV> s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; //<S2SV> s -> image_width = get_bits ( & gb , 12 ) ; //<S2SV> s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; //<S2SV> s -> image_height = get_bits ( & gb , 12 ) ; //<S2SV> if ( last_blockwidth != s -> block_width //<S2SV> || last_blockheight != s -> block_height ) //<S2SV> av_freep ( & s -> blocks ) ; //<S2SV> if ( s -> ver == 2 ) { //<S2SV> skip_bits ( & gb , 6 ) ; //<S2SV> if ( get_bits1 ( & gb ) ) { //<S2SV> avpriv_request_sample ( avctx , "iframe" ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> if ( get_bits1 ( & gb ) ) { //<S2SV> avpriv_request_sample ( avctx , "Custom<S2SV_blank>palette" ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> } //<S2SV> h_blocks = s -> image_width / s -> block_width ; //<S2SV> h_part = s -> image_width % s -> block_width ; //<S2SV> v_blocks = s -> image_height / s -> block_height ; //<S2SV> v_part = s -> image_height % s -> block_height ; //<S2SV> if ( s -> block_size < s -> block_width * s -> block_height ) { //<S2SV> int tmpblock_size = 3 * s -> block_width * s -> block_height ; //<S2SV> s -> tmpblock = av_realloc ( s -> tmpblock , tmpblock_size ) ; //<S2SV> if ( ! s -> tmpblock ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Can\'t<S2SV_blank>allocate<S2SV_blank>decompression<S2SV_blank>buffer.\\n" ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> if ( s -> ver == 2 ) { //<S2SV> s -> deflate_block_size = calc_deflate_block_size ( tmpblock_size ) ; //<S2SV> if ( s -> deflate_block_size <= 0 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Can\'t<S2SV_blank>determine<S2SV_blank>deflate<S2SV_blank>buffer<S2SV_blank>size.\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> s -> deflate_block = av_realloc ( s -> deflate_block , s -> deflate_block_size ) ; //<S2SV> if ( ! s -> deflate_block ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Can\'t<S2SV_blank>allocate<S2SV_blank>deflate<S2SV_blank>buffer.\\n" ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> s -> block_size = s -> block_width * s -> block_height ; //<S2SV> if ( avctx -> width == 0 && avctx -> height == 0 ) { //<S2SV> avcodec_set_dimensions ( avctx , s -> image_width , s -> image_height ) ; //<S2SV> } //<S2SV> if ( avctx -> width != s -> image_width || avctx -> height != s -> image_height ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , //<S2SV> "Frame<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>differs<S2SV_blank>from<S2SV_blank>first<S2SV_blank>frame!\\n" ) ; //<S2SV> av_log ( avctx , AV_LOG_ERROR , "fh<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>fv<S2SV_blank>%d<S2SV_blank><S2SV_blank>vs<S2SV_blank><S2SV_blank>ch<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cv<S2SV_blank>=<S2SV_blank>%d\\n" , //<S2SV> avctx -> height , avctx -> width , s -> image_height , s -> image_width ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> s -> is_keyframe = ( avpkt -> flags & AV_PKT_FLAG_KEY ) && ( s -> ver == 2 ) ; //<S2SV> if ( s -> is_keyframe ) { //<S2SV> s -> keyframedata = av_realloc ( s -> keyframedata , avpkt -> size ) ; //<S2SV> memcpy ( s -> keyframedata , avpkt -> data , avpkt -> size ) ; //<S2SV> } //<S2SV> if ( s -> ver == 2 && ! s -> blocks ) //<S2SV> s -> blocks = av_mallocz ( ( v_blocks + ! ! v_part ) * ( h_blocks + ! ! h_part ) //<S2SV> * sizeof ( s -> blocks [ 0 ] ) ) ; //<S2SV> av_dlog ( avctx , "image:<S2SV_blank>%dx%d<S2SV_blank>block:<S2SV_blank>%dx%d<S2SV_blank>num:<S2SV_blank>%dx%d<S2SV_blank>part:<S2SV_blank>%dx%d\\n" , //<S2SV> s -> image_width , s -> image_height , s -> block_width , s -> block_height , //<S2SV> h_blocks , v_blocks , h_part , v_part ) ; //<S2SV> if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) //<S2SV> return ret ; //<S2SV> for ( j = 0 ; j < v_blocks + ( v_part ? 1 : 0 ) ; j ++ ) { //<S2SV> int y_pos = j * s -> block_height ; //<S2SV> int cur_blk_height = ( j < v_blocks ) ? s -> block_height : v_part ; //<S2SV> for ( i = 0 ; i < h_blocks + ( h_part ? 1 : 0 ) ; i ++ ) { //<S2SV> int x_pos = i * s -> block_width ; //<S2SV> int cur_blk_width = ( i < h_blocks ) ? s -> block_width : h_part ; //<S2SV> int has_diff = 0 ; //<S2SV> int size = get_bits ( & gb , 16 ) ; //<S2SV> s -> color_depth = 0 ; //<S2SV> s -> zlibprime_curr = 0 ; //<S2SV> s -> zlibprime_prev = 0 ; //<S2SV> s -> diff_start = 0 ; //<S2SV> s -> diff_height = cur_blk_height ; //<S2SV> if ( 8 * size > get_bits_left ( & gb ) ) { //<S2SV> av_frame_unref ( & s -> frame ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( s -> ver == 2 && size ) { //<S2SV> skip_bits ( & gb , 3 ) ; //<S2SV> s -> color_depth = get_bits ( & gb , 2 ) ; //<S2SV> has_diff = get_bits1 ( & gb ) ; //<S2SV> s -> zlibprime_curr = get_bits1 ( & gb ) ; //<S2SV> s -> zlibprime_prev = get_bits1 ( & gb ) ; //<S2SV> if ( s -> color_depth != 0 && s -> color_depth != 2 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , //<S2SV> "%dx%d<S2SV_blank>invalid<S2SV_blank>color<S2SV_blank>depth<S2SV_blank>%d\\n" , i , j , s -> color_depth ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( has_diff ) { //<S2SV> if ( ! s -> keyframe ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , //<S2SV> "inter<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>keyframe\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> s -> diff_start = get_bits ( & gb , 8 ) ; //<S2SV> s -> diff_height = get_bits ( & gb , 8 ) ; //<S2SV> if ( s -> diff_start + s -> diff_height > cur_blk_height ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Block<S2SV_blank>parameters<S2SV_blank>invalid\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> av_log ( avctx , AV_LOG_DEBUG , //<S2SV> "%dx%d<S2SV_blank>diff<S2SV_blank>start<S2SV_blank>%d<S2SV_blank>height<S2SV_blank>%d\\n" , //<S2SV> i , j , s -> diff_start , s -> diff_height ) ; //<S2SV> size -= 2 ; //<S2SV> } //<S2SV> if ( s -> zlibprime_prev ) //<S2SV> av_log ( avctx , AV_LOG_DEBUG , "%dx%d<S2SV_blank>zlibprime_prev\\n" , i , j ) ; //<S2SV> if ( s -> zlibprime_curr ) { //<S2SV> int col = get_bits ( & gb , 8 ) ; //<S2SV> int row = get_bits ( & gb , 8 ) ; //<S2SV> av_log ( avctx , AV_LOG_DEBUG , "%dx%d<S2SV_blank>zlibprime_curr<S2SV_blank>%dx%d\\n" , i , j , col , row ) ; //<S2SV> size -= 2 ; //<S2SV> avpriv_request_sample ( avctx , "zlibprime_curr" ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> if ( ! s -> blocks && ( s -> zlibprime_curr || s -> zlibprime_prev ) ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "no<S2SV_blank>data<S2SV_blank>available<S2SV_blank>for<S2SV_blank>zlib<S2SV_blank>" //<S2SV> "priming\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> size -- ; //<S2SV> } //<S2SV> if ( has_diff ) { //<S2SV> int k ; //<S2SV> int off = ( s -> image_height - y_pos - 1 ) * s -> frame . linesize [ 0 ] ; //<S2SV> for ( k = 0 ; k < cur_blk_height ; k ++ ) //<S2SV> memcpy ( s -> frame . data [ 0 ] + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , //<S2SV> s -> keyframe + off - k * s -> frame . linesize [ 0 ] + x_pos * 3 , //<S2SV> cur_blk_width * 3 ) ; //<S2SV> } //<S2SV> if ( size ) { //<S2SV> if ( flashsv_decode_block ( avctx , avpkt , & gb , size , //<S2SV> cur_blk_width , cur_blk_height , //<S2SV> x_pos , y_pos , //<S2SV> i + j * ( h_blocks + ! ! h_part ) ) ) //<S2SV> av_log ( avctx , AV_LOG_ERROR , //<S2SV> "error<S2SV_blank>in<S2SV_blank>decompression<S2SV_blank>of<S2SV_blank>block<S2SV_blank>%dx%d\\n" , i , j ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( s -> is_keyframe && s -> ver == 2 ) { //<S2SV> if ( ! s -> keyframe ) { //<S2SV> s -> keyframe = av_malloc ( s -> frame . linesize [ 0 ] * avctx -> height ) ; //<S2SV> if ( ! s -> keyframe ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Cannot<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\n" ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> } //<S2SV> memcpy ( s -> keyframe , s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] * avctx -> height ) ; //<S2SV> } //<S2SV> if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) //<S2SV> return ret ; //<S2SV> * got_frame = 1 ; //<S2SV> if ( ( get_bits_count ( & gb ) / 8 ) != buf_size ) //<S2SV> av_log ( avctx , AV_LOG_ERROR , "buffer<S2SV_blank>not<S2SV_blank>fully<S2SV_blank>consumed<S2SV_blank>(%d<S2SV_blank>!=<S2SV_blank>%d)\\n" , //<S2SV> buf_size , ( get_bits_count ( & gb ) / 8 ) ) ; //<S2SV> return buf_size ; //<S2SV> } //<S2SV> 