static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , //<S2SV> uint32_t length ) //<S2SV> { //<S2SV> int v , i ; //<S2SV> if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { //<S2SV> if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> for ( i = 0 ; i < length ; i ++ ) { //<S2SV> v = bytestream2_get_byte ( & s -> gb ) ; //<S2SV> s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; //<S2SV> } //<S2SV> } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { //<S2SV> if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || //<S2SV> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> for ( i = 0 ; i < length / 2 ; i ++ ) { //<S2SV> v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; //<S2SV> if ( s -> bit_depth > 8 ) //<S2SV> AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; //<S2SV> else //<S2SV> s -> transparent_color_be [ i ] = v ; //<S2SV> } //<S2SV> } else { //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> bytestream2_skip ( & s -> gb , 4 ) ; //<S2SV> s -> has_trns = 1 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 