static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , //<S2SV> AVFrame * p , AVPacket * avpkt ) //<S2SV> { //<S2SV> AVDictionary * metadata = NULL ; //<S2SV> uint32_t tag , length ; //<S2SV> int decode_next_dat = 0 ; //<S2SV> int ret ; //<S2SV> for ( ; ; ) { //<S2SV> length = bytestream2_get_bytes_left ( & s -> gb ) ; //<S2SV> if ( length <= 0 ) { //<S2SV> if ( avctx -> codec_id == AV_CODEC_ID_PNG && //<S2SV> avctx -> skip_frame == AVDISCARD_ALL ) { //<S2SV> av_frame_set_metadata ( p , metadata ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { //<S2SV> if ( ! ( s -> state & PNG_IDAT ) ) //<S2SV> return 0 ; //<S2SV> else //<S2SV> goto exit_loop ; //<S2SV> } //<S2SV> av_log ( avctx , AV_LOG_ERROR , "%d<S2SV_blank>bytes<S2SV_blank>left\\n" , length ) ; //<S2SV> if ( s -> state & PNG_ALLIMAGE //<S2SV> && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) //<S2SV> goto exit_loop ; //<S2SV> ret = AVERROR_INVALIDDATA ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> length = bytestream2_get_be32 ( & s -> gb ) ; //<S2SV> if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "chunk<S2SV_blank>too<S2SV_blank>big\\n" ) ; //<S2SV> ret = AVERROR_INVALIDDATA ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> tag = bytestream2_get_le32 ( & s -> gb ) ; //<S2SV> if ( avctx -> debug & FF_DEBUG_STARTCODE ) //<S2SV> av_log ( avctx , AV_LOG_DEBUG , "png:<S2SV_blank>tag=%c%c%c%c<S2SV_blank>length=%u\\n" , //<S2SV> ( tag & 0xff ) , //<S2SV> ( ( tag >> 8 ) & 0xff ) , //<S2SV> ( ( tag >> 16 ) & 0xff ) , //<S2SV> ( ( tag >> 24 ) & 0xff ) , length ) ; //<S2SV> if ( avctx -> codec_id == AV_CODEC_ID_PNG && //<S2SV> avctx -> skip_frame == AVDISCARD_ALL ) { //<S2SV> switch ( tag ) { //<S2SV> case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : //<S2SV> case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : //<S2SV> case MKTAG ( 't' , 'E' , 'X' , 't' ) : //<S2SV> case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : //<S2SV> case MKTAG ( 't' , 'R' , 'N' , 'S' ) : //<S2SV> break ; //<S2SV> default : //<S2SV> goto skip_tag ; //<S2SV> } //<S2SV> } //<S2SV> switch ( tag ) { //<S2SV> case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : //<S2SV> if ( ( ret = decode_ihdr_chunk ( avctx , s , length ) ) < 0 ) //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : //<S2SV> if ( ( ret = decode_phys_chunk ( avctx , s ) ) < 0 ) //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case MKTAG ( 'f' , 'c' , 'T' , 'L' ) : //<S2SV> if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) //<S2SV> goto skip_tag ; //<S2SV> if ( ( ret = decode_fctl_chunk ( avctx , s , length ) ) < 0 ) //<S2SV> goto fail ; //<S2SV> decode_next_dat = 1 ; //<S2SV> break ; //<S2SV> case MKTAG ( 'f' , 'd' , 'A' , 'T' ) : //<S2SV> if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) //<S2SV> goto skip_tag ; //<S2SV> if ( ! decode_next_dat ) { //<S2SV> ret = AVERROR_INVALIDDATA ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> bytestream2_get_be32 ( & s -> gb ) ; //<S2SV> length -= 4 ; //<S2SV> case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : //<S2SV> if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ! decode_next_dat ) //<S2SV> goto skip_tag ; //<S2SV> if ( ( ret = decode_idat_chunk ( avctx , s , length , p ) ) < 0 ) //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case MKTAG ( 'P' , 'L' , 'T' , 'E' ) : //<S2SV> if ( decode_plte_chunk ( avctx , s , length ) < 0 ) //<S2SV> goto skip_tag ; //<S2SV> break ; //<S2SV> case MKTAG ( 't' , 'R' , 'N' , 'S' ) : //<S2SV> if ( decode_trns_chunk ( avctx , s , length ) < 0 ) //<S2SV> goto skip_tag ; //<S2SV> break ; //<S2SV> case MKTAG ( 't' , 'E' , 'X' , 't' ) : //<S2SV> if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 ) //<S2SV> av_log ( avctx , AV_LOG_WARNING , "Broken<S2SV_blank>tEXt<S2SV_blank>chunk\\n" ) ; //<S2SV> bytestream2_skip ( & s -> gb , length + 4 ) ; //<S2SV> break ; //<S2SV> case MKTAG ( 'z' , 'T' , 'X' , 't' ) : //<S2SV> if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 ) //<S2SV> av_log ( avctx , AV_LOG_WARNING , "Broken<S2SV_blank>zTXt<S2SV_blank>chunk\\n" ) ; //<S2SV> bytestream2_skip ( & s -> gb , length + 4 ) ; //<S2SV> break ; //<S2SV> case MKTAG ( 's' , 'T' , 'E' , 'R' ) : { //<S2SV> int mode = bytestream2_get_byte ( & s -> gb ) ; //<S2SV> AVStereo3D * stereo3d = av_stereo3d_create_side_data ( p ) ; //<S2SV> if ( ! stereo3d ) //<S2SV> goto fail ; //<S2SV> if ( mode == 0 || mode == 1 ) { //<S2SV> stereo3d -> type = AV_STEREO3D_SIDEBYSIDE ; //<S2SV> stereo3d -> flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT ; //<S2SV> } else { //<S2SV> av_log ( avctx , AV_LOG_WARNING , //<S2SV> "Unknown<S2SV_blank>value<S2SV_blank>in<S2SV_blank>sTER<S2SV_blank>chunk<S2SV_blank>(%d)\\n" , mode ) ; //<S2SV> } //<S2SV> bytestream2_skip ( & s -> gb , 4 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case MKTAG ( 'I' , 'E' , 'N' , 'D' ) : //<S2SV> if ( ! ( s -> state & PNG_ALLIMAGE ) ) //<S2SV> av_log ( avctx , AV_LOG_ERROR , "IEND<S2SV_blank>without<S2SV_blank>all<S2SV_blank>image\\n" ) ; //<S2SV> if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) ) { //<S2SV> ret = AVERROR_INVALIDDATA ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> bytestream2_skip ( & s -> gb , 4 ) ; //<S2SV> goto exit_loop ; //<S2SV> default : //<S2SV> skip_tag : //<S2SV> bytestream2_skip ( & s -> gb , length + 4 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> exit_loop : //<S2SV> if ( avctx -> codec_id == AV_CODEC_ID_PNG && //<S2SV> avctx -> skip_frame == AVDISCARD_ALL ) { //<S2SV> av_frame_set_metadata ( p , metadata ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( s -> bits_per_pixel <= 4 ) //<S2SV> handle_small_bpp ( s , p ) ; //<S2SV> if ( s -> has_trns && s -> color_type != PNG_COLOR_TYPE_PALETTE ) { //<S2SV> size_t byte_depth = s -> bit_depth > 8 ? 2 : 1 ; //<S2SV> size_t raw_bpp = s -> bpp - byte_depth ; //<S2SV> unsigned x , y ; //<S2SV> for ( y = 0 ; y < s -> height ; ++ y ) { //<S2SV> uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ; //<S2SV> for ( x = s -> width ; x > 0 ; -- x ) { //<S2SV> uint8_t * pixel = & row [ s -> bpp * ( x - 1 ) ] ; //<S2SV> memmove ( pixel , & row [ raw_bpp * ( x - 1 ) ] , raw_bpp ) ; //<S2SV> if ( ! memcmp ( pixel , s -> transparent_color_be , raw_bpp ) ) { //<S2SV> memset ( & pixel [ raw_bpp ] , 0 , byte_depth ) ; //<S2SV> } else { //<S2SV> memset ( & pixel [ raw_bpp ] , 0xff , byte_depth ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( s -> last_picture . f -> data [ 0 ] ) { //<S2SV> if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( "MPNG" ) //<S2SV> && s -> last_picture . f -> width == p -> width //<S2SV> && s -> last_picture . f -> height == p -> height //<S2SV> && s -> last_picture . f -> format == p -> format //<S2SV> ) { //<S2SV> if ( CONFIG_PNG_DECODER && avctx -> codec_id != AV_CODEC_ID_APNG ) //<S2SV> handle_p_frame_png ( s , p ) ; //<S2SV> else if ( CONFIG_APNG_DECODER && //<S2SV> avctx -> codec_id == AV_CODEC_ID_APNG && //<S2SV> ( ret = handle_p_frame_apng ( avctx , s , p ) ) < 0 ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; //<S2SV> ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; //<S2SV> av_frame_set_metadata ( p , metadata ) ; //<S2SV> metadata = NULL ; //<S2SV> return 0 ; //<S2SV> fail : //<S2SV> av_dict_free ( & metadata ) ; //<S2SV> ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; //<S2SV> ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 