int ff_jpeg2000_init_component ( Jpeg2000Component * comp , //<S2SV> Jpeg2000CodingStyle * codsty , //<S2SV> Jpeg2000QuantStyle * qntsty , //<S2SV> int cbps , int dx , int dy , //<S2SV> AVCodecContext * avctx ) //<S2SV> { //<S2SV> uint8_t log2_band_prec_width , log2_band_prec_height ; //<S2SV> int reslevelno , bandno , gbandno = 0 , ret , i , j ; //<S2SV> uint32_t csize ; //<S2SV> if ( codsty -> nreslevels2decode <= 0 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n" , codsty -> nreslevels2decode ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , //<S2SV> codsty -> nreslevels2decode - 1 , //<S2SV> codsty -> transform ) ) //<S2SV> return ret ; //<S2SV> csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * //<S2SV> ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; //<S2SV> if ( codsty -> transform == FF_DWT97 ) { //<S2SV> comp -> i_data = NULL ; //<S2SV> comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; //<S2SV> if ( ! comp -> f_data ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } else { //<S2SV> comp -> f_data = NULL ; //<S2SV> comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; //<S2SV> if ( ! comp -> i_data ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; //<S2SV> if ( ! comp -> reslevel ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { //<S2SV> int declvl = codsty -> nreslevels - reslevelno ; //<S2SV> Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; //<S2SV> for ( i = 0 ; i < 2 ; i ++ ) //<S2SV> for ( j = 0 ; j < 2 ; j ++ ) //<S2SV> reslevel -> coord [ i ] [ j ] = //<S2SV> ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ) ; //<S2SV> reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ] ; //<S2SV> reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ] ; //<S2SV> if ( reslevelno == 0 ) //<S2SV> reslevel -> nbands = 1 ; //<S2SV> else //<S2SV> reslevel -> nbands = 3 ; //<S2SV> if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] ) //<S2SV> reslevel -> num_precincts_x = 0 ; //<S2SV> else //<S2SV> reslevel -> num_precincts_x = //<S2SV> ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , //<S2SV> reslevel -> log2_prec_width ) - //<S2SV> ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ) ; //<S2SV> if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] ) //<S2SV> reslevel -> num_precincts_y = 0 ; //<S2SV> else //<S2SV> reslevel -> num_precincts_y = //<S2SV> ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , //<S2SV> reslevel -> log2_prec_height ) - //<S2SV> ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ; //<S2SV> reslevel -> band = av_calloc ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; //<S2SV> if ( ! reslevel -> band ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ , gbandno ++ ) { //<S2SV> Jpeg2000Band * band = reslevel -> band + bandno ; //<S2SV> int cblkno , precno ; //<S2SV> int nb_precincts ; //<S2SV> switch ( qntsty -> quantsty ) { //<S2SV> uint8_t gain ; //<S2SV> int numbps ; //<S2SV> case JPEG2000_QSTY_NONE : //<S2SV> band -> f_stepsize = 1 ; //<S2SV> break ; //<S2SV> case JPEG2000_QSTY_SI : //<S2SV> numbps = cbps + //<S2SV> lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] ; //<S2SV> band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , //<S2SV> 2 + numbps - qntsty -> expn [ gbandno ] ) ; //<S2SV> break ; //<S2SV> case JPEG2000_QSTY_SE : //<S2SV> gain = cbps ; //<S2SV> band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; //<S2SV> band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> band -> f_stepsize = 0 ; //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>quantization<S2SV_blank>format\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! av_codec_is_encoder ( avctx -> codec ) ) //<S2SV> band -> f_stepsize *= 0.5 ; //<S2SV> band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; //<S2SV> if ( reslevelno == 0 ) { //<S2SV> for ( i = 0 ; i < 2 ; i ++ ) //<S2SV> for ( j = 0 ; j < 2 ; j ++ ) //<S2SV> band -> coord [ i ] [ j ] = //<S2SV> ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , //<S2SV> declvl - 1 ) ; //<S2SV> log2_band_prec_width = reslevel -> log2_prec_width ; //<S2SV> log2_band_prec_height = reslevel -> log2_prec_height ; //<S2SV> band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , //<S2SV> reslevel -> log2_prec_width ) ; //<S2SV> band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , //<S2SV> reslevel -> log2_prec_height ) ; //<S2SV> } else { //<S2SV> for ( i = 0 ; i < 2 ; i ++ ) //<S2SV> for ( j = 0 ; j < 2 ; j ++ ) //<S2SV> band -> coord [ i ] [ j ] = //<S2SV> ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - //<S2SV> ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , //<S2SV> declvl ) ; //<S2SV> band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , //<S2SV> reslevel -> log2_prec_width - 1 ) ; //<S2SV> band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , //<S2SV> reslevel -> log2_prec_height - 1 ) ; //<S2SV> log2_band_prec_width = reslevel -> log2_prec_width - 1 ; //<S2SV> log2_band_prec_height = reslevel -> log2_prec_height - 1 ; //<S2SV> } //<S2SV> for ( j = 0 ; j < 2 ; j ++ ) //<S2SV> band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ) ; //<S2SV> for ( j = 0 ; j < 2 ; j ++ ) //<S2SV> band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ; //<S2SV> band -> prec = av_calloc ( reslevel -> num_precincts_x * //<S2SV> ( uint64_t ) reslevel -> num_precincts_y , //<S2SV> sizeof ( * band -> prec ) ) ; //<S2SV> if ( ! band -> prec ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y ; //<S2SV> for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { //<S2SV> Jpeg2000Prec * prec = band -> prec + precno ; //<S2SV> prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * //<S2SV> ( 1 << log2_band_prec_width ) ; //<S2SV> prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ) ; //<S2SV> prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * //<S2SV> ( 1 << log2_band_prec_height ) ; //<S2SV> prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ) ; //<S2SV> prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + //<S2SV> ( 1 << log2_band_prec_width ) ; //<S2SV> prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ) ; //<S2SV> prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + //<S2SV> ( 1 << log2_band_prec_height ) ; //<S2SV> prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ) ; //<S2SV> prec -> nb_codeblocks_width = //<S2SV> ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - //<S2SV> prec -> coord [ 0 ] [ 0 ] , //<S2SV> band -> log2_cblk_width ) ; //<S2SV> prec -> nb_codeblocks_height = //<S2SV> ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - //<S2SV> prec -> coord [ 1 ] [ 0 ] , //<S2SV> band -> log2_cblk_height ) ; //<S2SV> prec -> cblkincl = //<S2SV> ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , //<S2SV> prec -> nb_codeblocks_height ) ; //<S2SV> if ( ! prec -> cblkincl ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> prec -> zerobits = //<S2SV> ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , //<S2SV> prec -> nb_codeblocks_height ) ; //<S2SV> if ( ! prec -> zerobits ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * //<S2SV> ( uint64_t ) prec -> nb_codeblocks_height , //<S2SV> sizeof ( * prec -> cblk ) ) ; //<S2SV> if ( ! prec -> cblk ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { //<S2SV> Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; //<S2SV> uint16_t Cx0 , Cy0 ; //<S2SV> Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width ; //<S2SV> Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ) ; //<S2SV> cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ) ; //<S2SV> Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height ; //<S2SV> Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) ; //<S2SV> cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ) ; //<S2SV> cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , //<S2SV> prec -> coord [ 0 ] [ 1 ] ) ; //<S2SV> cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , //<S2SV> prec -> coord [ 1 ] [ 1 ] ) ; //<S2SV> if ( ( bandno + ! ! reslevelno ) & 1 ) { //<S2SV> cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - //<S2SV> comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; //<S2SV> cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - //<S2SV> comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; //<S2SV> } //<S2SV> if ( ( bandno + ! ! reslevelno ) & 2 ) { //<S2SV> cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - //<S2SV> comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; //<S2SV> cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - //<S2SV> comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; //<S2SV> } //<S2SV> cblk -> zero = 0 ; //<S2SV> cblk -> lblock = 3 ; //<S2SV> cblk -> length = 0 ; //<S2SV> cblk -> lengthinc = 0 ; //<S2SV> cblk -> npasses = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 