static int mxf_parse_structural_metadata ( MXFContext * mxf ) //<S2SV> { //<S2SV> MXFPackage * material_package = NULL ; //<S2SV> int i , j , k , ret ; //<S2SV> av_log ( mxf -> fc , AV_LOG_TRACE , "metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n" , mxf -> metadata_sets_count ) ; //<S2SV> for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { //<S2SV> material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; //<S2SV> if ( material_package ) break ; //<S2SV> } //<S2SV> if ( ! material_package ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_ERROR , "no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> mxf_add_umid_metadata ( & mxf -> fc -> metadata , "material_package_umid" , material_package ) ; //<S2SV> if ( material_package -> name && material_package -> name [ 0 ] ) //<S2SV> av_dict_set ( & mxf -> fc -> metadata , "material_package_name" , material_package -> name , 0 ) ; //<S2SV> mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; //<S2SV> for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { //<S2SV> MXFPackage * source_package = NULL ; //<S2SV> MXFTrack * material_track = NULL ; //<S2SV> MXFTrack * source_track = NULL ; //<S2SV> MXFTrack * temp_track = NULL ; //<S2SV> MXFDescriptor * descriptor = NULL ; //<S2SV> MXFStructuralComponent * component = NULL ; //<S2SV> MXFTimecodeComponent * mxf_tc = NULL ; //<S2SV> UID * essence_container_ul = NULL ; //<S2SV> const MXFCodecUL * codec_ul = NULL ; //<S2SV> const MXFCodecUL * container_ul = NULL ; //<S2SV> const MXFCodecUL * pix_fmt_ul = NULL ; //<S2SV> AVStream * st ; //<S2SV> AVTimecode tc ; //<S2SV> int flags ; //<S2SV> if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { //<S2SV> mxf_tc = ( MXFTimecodeComponent * ) component ; //<S2SV> flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; //<S2SV> if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { //<S2SV> mxf_add_timecode_metadata ( & mxf -> fc -> metadata , "timecode" , & tc ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { //<S2SV> component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; //<S2SV> if ( ! component ) //<S2SV> continue ; //<S2SV> mxf_tc = ( MXFTimecodeComponent * ) component ; //<S2SV> flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; //<S2SV> if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { //<S2SV> mxf_add_timecode_metadata ( & mxf -> fc -> metadata , "timecode" , & tc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( material_track -> sequence -> structural_components_count > 1 ) //<S2SV> av_log ( mxf -> fc , AV_LOG_WARNING , "material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n" , //<S2SV> material_track -> track_id , material_track -> sequence -> structural_components_count ) ; //<S2SV> for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { //<S2SV> component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; //<S2SV> if ( ! component ) //<S2SV> continue ; //<S2SV> source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; //<S2SV> if ( ! source_package ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_TRACE , "material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n" , material_track -> track_id ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { //<S2SV> if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; //<S2SV> ret = AVERROR_INVALIDDATA ; //<S2SV> goto fail_and_free ; //<S2SV> } //<S2SV> if ( temp_track -> track_id == component -> source_track_id ) { //<S2SV> source_track = temp_track ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! source_track ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_ERROR , "material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n" , material_track -> track_id ) ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { //<S2SV> MXFEssenceContainerData * essence_data ; //<S2SV> if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { //<S2SV> av_log ( mxf , AV_LOG_TRACE , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { //<S2SV> source_track -> body_sid = essence_data -> body_sid ; //<S2SV> source_track -> index_sid = essence_data -> index_sid ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( source_track && component ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! source_track || ! component || ! source_package ) { //<S2SV> if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) //<S2SV> goto fail_and_free ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n" ) ; //<S2SV> ret = AVERROR_INVALIDDATA ; //<S2SV> goto fail_and_free ; //<S2SV> } //<S2SV> if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_ERROR , "material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n" , material_track -> track_id ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> st = avformat_new_stream ( mxf -> fc , NULL ) ; //<S2SV> if ( ! st ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_ERROR , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n" ) ; //<S2SV> ret = AVERROR ( ENOMEM ) ; //<S2SV> goto fail_and_free ; //<S2SV> } //<S2SV> st -> id = material_track -> track_id ; //<S2SV> st -> priv_data = source_track ; //<S2SV> source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; //<S2SV> descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; //<S2SV> if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) //<S2SV> source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; //<S2SV> else //<S2SV> source_track -> original_duration = st -> duration = component -> duration ; //<S2SV> if ( st -> duration == - 1 ) //<S2SV> st -> duration = AV_NOPTS_VALUE ; //<S2SV> st -> start_time = component -> start_position ; //<S2SV> if ( material_track -> edit_rate . num <= 0 || //<S2SV> material_track -> edit_rate . den <= 0 ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_WARNING , //<S2SV> "Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>" //<S2SV> "defaulting<S2SV_blank>to<S2SV_blank>25/1\\n" , //<S2SV> material_track -> edit_rate . num , //<S2SV> material_track -> edit_rate . den , st -> index ) ; //<S2SV> material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; //<S2SV> } //<S2SV> avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; //<S2SV> source_track -> edit_rate = material_track -> edit_rate ; //<S2SV> PRINT_KEY ( mxf -> fc , "data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul" , source_track -> sequence -> data_definition_ul ) ; //<S2SV> codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; //<S2SV> st -> codecpar -> codec_type = codec_ul -> id ; //<S2SV> if ( ! descriptor ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_INFO , "source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n" , source_track -> track_id , st -> index ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> PRINT_KEY ( mxf -> fc , "essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul" , descriptor -> essence_codec_ul ) ; //<S2SV> PRINT_KEY ( mxf -> fc , "essence<S2SV_blank>container<S2SV_blank>ul" , descriptor -> essence_container_ul ) ; //<S2SV> essence_container_ul = & descriptor -> essence_container_ul ; //<S2SV> source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; //<S2SV> if ( source_track -> wrapping == UnknownWrapped ) //<S2SV> av_log ( mxf -> fc , AV_LOG_INFO , "wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n" , st -> index ) ; //<S2SV> if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_INFO , "broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n" ) ; //<S2SV> for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { //<S2SV> MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; //<S2SV> if ( metadata -> type == CryptoContext ) { //<S2SV> essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; //<S2SV> st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; //<S2SV> if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { //<S2SV> codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; //<S2SV> st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; //<S2SV> } //<S2SV> av_log ( mxf -> fc , AV_LOG_VERBOSE , "%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>" , //<S2SV> avcodec_get_name ( st -> codecpar -> codec_id ) ) ; //<S2SV> for ( k = 0 ; k < 16 ; k ++ ) { //<S2SV> av_log ( mxf -> fc , AV_LOG_VERBOSE , "%.2x" , //<S2SV> descriptor -> essence_codec_ul [ k ] ) ; //<S2SV> if ( ! ( k + 1 & 19 ) || k == 5 ) //<S2SV> av_log ( mxf -> fc , AV_LOG_VERBOSE , "." ) ; //<S2SV> } //<S2SV> av_log ( mxf -> fc , AV_LOG_VERBOSE , "\\n" ) ; //<S2SV> mxf_add_umid_metadata ( & st -> metadata , "file_package_umid" , source_package ) ; //<S2SV> if ( source_package -> name && source_package -> name [ 0 ] ) //<S2SV> av_dict_set ( & st -> metadata , "file_package_name" , source_package -> name , 0 ) ; //<S2SV> if ( material_track -> name && material_track -> name [ 0 ] ) //<S2SV> av_dict_set ( & st -> metadata , "track_name" , material_track -> name , 0 ) ; //<S2SV> mxf_parse_physical_source_package ( mxf , source_track , st ) ; //<S2SV> if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { //<S2SV> source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; //<S2SV> container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; //<S2SV> if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) //<S2SV> st -> codecpar -> codec_id = container_ul -> id ; //<S2SV> st -> codecpar -> width = descriptor -> width ; //<S2SV> st -> codecpar -> height = descriptor -> height ; //<S2SV> switch ( descriptor -> frame_layout ) { //<S2SV> case FullFrame : //<S2SV> st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; //<S2SV> break ; //<S2SV> case OneField : //<S2SV> av_log ( mxf -> fc , AV_LOG_INFO , "OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n" ) ; //<S2SV> break ; //<S2SV> case MixedFields : //<S2SV> break ; //<S2SV> case SegmentedFrame : //<S2SV> st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; //<S2SV> case SeparateFields : //<S2SV> av_log ( mxf -> fc , AV_LOG_DEBUG , "video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n" , //<S2SV> descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , //<S2SV> descriptor -> field_dominance ) ; //<S2SV> if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { //<S2SV> if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { //<S2SV> switch ( descriptor -> field_dominance ) { //<S2SV> case MXF_FIELD_DOMINANCE_DEFAULT : //<S2SV> case MXF_FIELD_DOMINANCE_FF : //<S2SV> st -> codecpar -> field_order = AV_FIELD_TT ; //<S2SV> break ; //<S2SV> case MXF_FIELD_DOMINANCE_FL : //<S2SV> st -> codecpar -> field_order = AV_FIELD_TB ; //<S2SV> break ; //<S2SV> default : //<S2SV> avpriv_request_sample ( mxf -> fc , //<S2SV> "Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support" , //<S2SV> descriptor -> field_dominance ) ; //<S2SV> } //<S2SV> } else { //<S2SV> switch ( descriptor -> field_dominance ) { //<S2SV> case MXF_FIELD_DOMINANCE_DEFAULT : //<S2SV> case MXF_FIELD_DOMINANCE_FF : //<S2SV> st -> codecpar -> field_order = AV_FIELD_BB ; //<S2SV> break ; //<S2SV> case MXF_FIELD_DOMINANCE_FL : //<S2SV> st -> codecpar -> field_order = AV_FIELD_BT ; //<S2SV> break ; //<S2SV> default : //<S2SV> avpriv_request_sample ( mxf -> fc , //<S2SV> "Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support" , //<S2SV> descriptor -> field_dominance ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> st -> codecpar -> height *= 2 ; //<S2SV> break ; //<S2SV> default : //<S2SV> av_log ( mxf -> fc , AV_LOG_INFO , "Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n" , descriptor -> frame_layout ) ; //<S2SV> } //<S2SV> if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { //<S2SV> st -> codecpar -> format = descriptor -> pix_fmt ; //<S2SV> if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { //<S2SV> pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , //<S2SV> & descriptor -> essence_codec_ul ) ; //<S2SV> st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; //<S2SV> if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { //<S2SV> st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , //<S2SV> & descriptor -> essence_codec_ul ) -> id ; //<S2SV> if ( ! st -> codecpar -> codec_tag ) { //<S2SV> if ( descriptor -> horiz_subsampling == 2 && //<S2SV> descriptor -> vert_subsampling == 1 && //<S2SV> descriptor -> component_depth == 8 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> st -> need_parsing = AVSTREAM_PARSE_HEADERS ; //<S2SV> if ( material_track -> sequence -> origin ) { //<S2SV> av_dict_set_int ( & st -> metadata , "material_track_origin" , material_track -> sequence -> origin , 0 ) ; //<S2SV> } //<S2SV> if ( source_track -> sequence -> origin ) { //<S2SV> av_dict_set_int ( & st -> metadata , "source_track_origin" , source_track -> sequence -> origin , 0 ) ; //<S2SV> } //<S2SV> if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) //<S2SV> st -> display_aspect_ratio = descriptor -> aspect_ratio ; //<S2SV> } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { //<S2SV> container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; //<S2SV> if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) //<S2SV> st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; //<S2SV> st -> codecpar -> channels = descriptor -> channels ; //<S2SV> st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; //<S2SV> if ( descriptor -> sample_rate . den > 0 ) { //<S2SV> st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; //<S2SV> avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; //<S2SV> } else { //<S2SV> av_log ( mxf -> fc , AV_LOG_WARNING , "invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>" //<S2SV> "found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n" , //<S2SV> descriptor -> sample_rate . num , descriptor -> sample_rate . den , //<S2SV> st -> index ) ; //<S2SV> avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; //<S2SV> } //<S2SV> if ( st -> duration != AV_NOPTS_VALUE ) //<S2SV> st -> duration = av_rescale_q ( st -> duration , //<S2SV> av_inv_q ( material_track -> edit_rate ) , //<S2SV> st -> time_base ) ; //<S2SV> if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { //<S2SV> if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; //<S2SV> else if ( descriptor -> bits_per_sample == 32 ) //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; //<S2SV> } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { //<S2SV> if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; //<S2SV> else if ( descriptor -> bits_per_sample == 32 ) //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; //<S2SV> } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { //<S2SV> st -> need_parsing = AVSTREAM_PARSE_FULL ; //<S2SV> } //<S2SV> } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { //<S2SV> enum AVMediaType type ; //<S2SV> container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; //<S2SV> if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) //<S2SV> st -> codecpar -> codec_id = container_ul -> id ; //<S2SV> type = avcodec_get_type ( st -> codecpar -> codec_id ) ; //<S2SV> if ( type == AVMEDIA_TYPE_SUBTITLE ) //<S2SV> st -> codecpar -> codec_type = type ; //<S2SV> if ( container_ul -> desc ) //<S2SV> av_dict_set ( & st -> metadata , "data_type" , container_ul -> desc , 0 ) ; //<S2SV> } //<S2SV> if ( descriptor -> extradata ) { //<S2SV> if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { //<S2SV> memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; //<S2SV> } //<S2SV> } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { //<S2SV> int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , //<S2SV> & descriptor -> essence_codec_ul ) -> id ; //<S2SV> if ( coded_width ) //<S2SV> st -> codecpar -> width = coded_width ; //<S2SV> ret = ff_generate_avci_extradata ( st ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { //<S2SV> st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; //<S2SV> } //<S2SV> } //<S2SV> ret = 0 ; //<S2SV> fail_and_free : //<S2SV> return ret ; //<S2SV> } //<S2SV> 