static int xwd_decode_frame ( AVCodecContext * avctx , void * data , //<S2SV> int * got_frame , AVPacket * avpkt ) //<S2SV> { //<S2SV> AVFrame * p = data ; //<S2SV> const uint8_t * buf = avpkt -> data ; //<S2SV> int i , ret , buf_size = avpkt -> size ; //<S2SV> uint32_t version , header_size , vclass , ncolors ; //<S2SV> uint32_t xoffset , be , bpp , lsize , rsize ; //<S2SV> uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; //<S2SV> uint32_t rgb [ 3 ] ; //<S2SV> uint8_t * ptr ; //<S2SV> GetByteContext gb ; //<S2SV> if ( buf_size < XWD_HEADER_SIZE ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> bytestream2_init ( & gb , buf , buf_size ) ; //<S2SV> header_size = bytestream2_get_be32u ( & gb ) ; //<S2SV> version = bytestream2_get_be32u ( & gb ) ; //<S2SV> if ( version != XWD_VERSION ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "unsupported<S2SV_blank>version\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>header<S2SV_blank>size\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> pixformat = bytestream2_get_be32u ( & gb ) ; //<S2SV> pixdepth = bytestream2_get_be32u ( & gb ) ; //<S2SV> avctx -> width = bytestream2_get_be32u ( & gb ) ; //<S2SV> avctx -> height = bytestream2_get_be32u ( & gb ) ; //<S2SV> xoffset = bytestream2_get_be32u ( & gb ) ; //<S2SV> be = bytestream2_get_be32u ( & gb ) ; //<S2SV> bunit = bytestream2_get_be32u ( & gb ) ; //<S2SV> bitorder = bytestream2_get_be32u ( & gb ) ; //<S2SV> bpad = bytestream2_get_be32u ( & gb ) ; //<S2SV> bpp = bytestream2_get_be32u ( & gb ) ; //<S2SV> lsize = bytestream2_get_be32u ( & gb ) ; //<S2SV> vclass = bytestream2_get_be32u ( & gb ) ; //<S2SV> rgb [ 0 ] = bytestream2_get_be32u ( & gb ) ; //<S2SV> rgb [ 1 ] = bytestream2_get_be32u ( & gb ) ; //<S2SV> rgb [ 2 ] = bytestream2_get_be32u ( & gb ) ; //<S2SV> bytestream2_skipu ( & gb , 8 ) ; //<S2SV> ncolors = bytestream2_get_be32u ( & gb ) ; //<S2SV> bytestream2_skipu ( & gb , header_size - ( XWD_HEADER_SIZE - 20 ) ) ; //<S2SV> av_log ( avctx , AV_LOG_DEBUG , //<S2SV> "pixformat<S2SV_blank>%" PRIu32 ",<S2SV_blank>pixdepth<S2SV_blank>%" PRIu32 ",<S2SV_blank>bunit<S2SV_blank>%" PRIu32 ",<S2SV_blank>bitorder<S2SV_blank>%" PRIu32 ",<S2SV_blank>bpad<S2SV_blank>%" PRIu32 "\\n" , //<S2SV> pixformat , pixdepth , bunit , bitorder , bpad ) ; //<S2SV> av_log ( avctx , AV_LOG_DEBUG , //<S2SV> "vclass<S2SV_blank>%" PRIu32 ",<S2SV_blank>ncolors<S2SV_blank>%" PRIu32 ",<S2SV_blank>bpp<S2SV_blank>%" PRIu32 ",<S2SV_blank>be<S2SV_blank>%" PRIu32 ",<S2SV_blank>lsize<S2SV_blank>%" PRIu32 ",<S2SV_blank>xoffset<S2SV_blank>%" PRIu32 "\\n" , //<S2SV> vclass , ncolors , bpp , be , lsize , xoffset ) ; //<S2SV> av_log ( avctx , AV_LOG_DEBUG , //<S2SV> "red<S2SV_blank>%0" PRIx32 ",<S2SV_blank>green<S2SV_blank>%0" PRIx32 ",<S2SV_blank>blue<S2SV_blank>%0" PRIx32 "\\n" , //<S2SV> rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; //<S2SV> if ( pixformat > XWD_Z_PIXMAP ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>pixmap<S2SV_blank>format\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( pixdepth == 0 || pixdepth > 32 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( xoffset ) { //<S2SV> avpriv_request_sample ( avctx , "xoffset<S2SV_blank>%" PRIu32 "" , xoffset ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> if ( be > 1 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>byte<S2SV_blank>order\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( bitorder > 1 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( bunit != 8 && bunit != 16 && bunit != 32 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( bpad != 8 && bpad != 16 && bpad != 32 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( bpp == 0 || bpp > 32 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ncolors > 256 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , NULL ) ) < 0 ) //<S2SV> return ret ; //<S2SV> rsize = FFALIGN ( avctx -> width * bpp , bpad ) / 8 ; //<S2SV> if ( lsize < rsize ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( bytestream2_get_bytes_left ( & gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( pixformat != XWD_Z_PIXMAP ) { //<S2SV> avpriv_report_missing_feature ( avctx , "Pixmap<S2SV_blank>format<S2SV_blank>%" PRIu32 , pixformat ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> avctx -> pix_fmt = AV_PIX_FMT_NONE ; //<S2SV> switch ( vclass ) { //<S2SV> case XWD_STATIC_GRAY : //<S2SV> case XWD_GRAY_SCALE : //<S2SV> if ( bpp != 1 && bpp != 8 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> if ( pixdepth == 1 ) { //<S2SV> avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; //<S2SV> } else if ( pixdepth == 8 ) { //<S2SV> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; //<S2SV> } //<S2SV> break ; //<S2SV> case XWD_STATIC_COLOR : //<S2SV> case XWD_PSEUDO_COLOR : //<S2SV> if ( bpp == 8 ) //<S2SV> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; //<S2SV> break ; //<S2SV> case XWD_TRUE_COLOR : //<S2SV> case XWD_DIRECT_COLOR : //<S2SV> if ( bpp != 16 && bpp != 24 && bpp != 32 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> if ( bpp == 16 && pixdepth == 15 ) { //<S2SV> if ( rgb [ 0 ] == 0x7C00 && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x1F ) //<S2SV> avctx -> pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE ; //<S2SV> else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x7C00 ) //<S2SV> avctx -> pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE ; //<S2SV> } else if ( bpp == 16 && pixdepth == 16 ) { //<S2SV> if ( rgb [ 0 ] == 0xF800 && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0x1F ) //<S2SV> avctx -> pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE ; //<S2SV> else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0xF800 ) //<S2SV> avctx -> pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE ; //<S2SV> } else if ( bpp == 24 ) { //<S2SV> if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) //<S2SV> avctx -> pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ; //<S2SV> else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) //<S2SV> avctx -> pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24 ; //<S2SV> } else if ( bpp == 32 ) { //<S2SV> if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) //<S2SV> avctx -> pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA ; //<S2SV> else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) //<S2SV> avctx -> pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA ; //<S2SV> } //<S2SV> bytestream2_skipu ( & gb , ncolors * XWD_CMAP_SIZE ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>visual<S2SV_blank>class\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( avctx -> pix_fmt == AV_PIX_FMT_NONE ) { //<S2SV> avpriv_request_sample ( avctx , //<S2SV> "Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%" PRIu32 ",<S2SV_blank>pixdepth<S2SV_blank>%" PRIu32 ",<S2SV_blank>vclass<S2SV_blank>%" PRIu32 "" , //<S2SV> bpp , pixdepth , vclass ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) //<S2SV> return ret ; //<S2SV> p -> key_frame = 1 ; //<S2SV> p -> pict_type = AV_PICTURE_TYPE_I ; //<S2SV> if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { //<S2SV> uint32_t * dst = ( uint32_t * ) p -> data [ 1 ] ; //<S2SV> uint8_t red , green , blue ; //<S2SV> for ( i = 0 ; i < ncolors ; i ++ ) { //<S2SV> bytestream2_skipu ( & gb , 4 ) ; //<S2SV> red = bytestream2_get_byteu ( & gb ) ; //<S2SV> bytestream2_skipu ( & gb , 1 ) ; //<S2SV> green = bytestream2_get_byteu ( & gb ) ; //<S2SV> bytestream2_skipu ( & gb , 1 ) ; //<S2SV> blue = bytestream2_get_byteu ( & gb ) ; //<S2SV> bytestream2_skipu ( & gb , 3 ) ; //<S2SV> dst [ i ] = red << 16 | green << 8 | blue ; //<S2SV> } //<S2SV> } //<S2SV> ptr = p -> data [ 0 ] ; //<S2SV> for ( i = 0 ; i < avctx -> height ; i ++ ) { //<S2SV> bytestream2_get_bufferu ( & gb , ptr , rsize ) ; //<S2SV> bytestream2_skipu ( & gb , lsize - rsize ) ; //<S2SV> ptr += p -> linesize [ 0 ] ; //<S2SV> } //<S2SV> * got_frame = 1 ; //<S2SV> return buf_size ; //<S2SV> } //<S2SV> 