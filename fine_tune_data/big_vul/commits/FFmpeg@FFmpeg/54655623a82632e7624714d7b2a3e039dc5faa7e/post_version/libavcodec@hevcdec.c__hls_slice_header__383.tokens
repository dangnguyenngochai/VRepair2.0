static int hls_slice_header ( HEVCContext * s ) //<S2SV> { //<S2SV> GetBitContext * gb = & s -> HEVClc -> gb ; //<S2SV> SliceHeader * sh = & s -> sh ; //<S2SV> int i , ret ; //<S2SV> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; //<S2SV> if ( s -> ref && sh -> first_slice_in_pic_flag ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { //<S2SV> s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; //<S2SV> s -> max_ra = INT_MAX ; //<S2SV> if ( IS_IDR ( s ) ) //<S2SV> ff_hevc_clear_refs ( s ) ; //<S2SV> } //<S2SV> sh -> no_output_of_prior_pics_flag = 0 ; //<S2SV> if ( IS_IRAP ( s ) ) //<S2SV> sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; //<S2SV> sh -> pps_id = get_ue_golomb_long ( gb ) ; //<S2SV> if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "PPS<S2SV_blank>id<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>%d\\n" , sh -> pps_id ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ! sh -> first_slice_in_pic_flag && //<S2SV> s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "PPS<S2SV_blank>changed<S2SV_blank>between<S2SV_blank>slices.\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; //<S2SV> if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) //<S2SV> sh -> no_output_of_prior_pics_flag = 1 ; //<S2SV> if ( s -> ps . sps != ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ) { //<S2SV> const HEVCSPS * sps = ( HEVCSPS * ) s -> ps . sps_list [ s -> ps . pps -> sps_id ] -> data ; //<S2SV> const HEVCSPS * last_sps = s -> ps . sps ; //<S2SV> enum AVPixelFormat pix_fmt ; //<S2SV> if ( last_sps && IS_IRAP ( s ) && s -> nal_unit_type != HEVC_NAL_CRA_NUT ) { //<S2SV> if ( sps -> width != last_sps -> width || sps -> height != last_sps -> height || //<S2SV> sps -> temporal_layer [ sps -> max_sub_layers - 1 ] . max_dec_pic_buffering != //<S2SV> last_sps -> temporal_layer [ last_sps -> max_sub_layers - 1 ] . max_dec_pic_buffering ) //<S2SV> sh -> no_output_of_prior_pics_flag = 0 ; //<S2SV> } //<S2SV> ff_hevc_clear_refs ( s ) ; //<S2SV> ret = set_sps ( s , sps , sps -> pix_fmt ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> pix_fmt = get_format ( s , sps ) ; //<S2SV> if ( pix_fmt < 0 ) //<S2SV> return pix_fmt ; //<S2SV> s -> avctx -> pix_fmt = pix_fmt ; //<S2SV> s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; //<S2SV> s -> max_ra = INT_MAX ; //<S2SV> } //<S2SV> sh -> dependent_slice_segment_flag = 0 ; //<S2SV> if ( ! sh -> first_slice_in_pic_flag ) { //<S2SV> int slice_address_length ; //<S2SV> if ( s -> ps . pps -> dependent_slice_segments_enabled_flag ) //<S2SV> sh -> dependent_slice_segment_flag = get_bits1 ( gb ) ; //<S2SV> slice_address_length = av_ceil_log2 ( s -> ps . sps -> ctb_width * //<S2SV> s -> ps . sps -> ctb_height ) ; //<S2SV> sh -> slice_segment_addr = get_bitsz ( gb , slice_address_length ) ; //<S2SV> if ( sh -> slice_segment_addr >= s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "Invalid<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>address:<S2SV_blank>%u.\\n" , //<S2SV> sh -> slice_segment_addr ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ! sh -> dependent_slice_segment_flag ) { //<S2SV> sh -> slice_addr = sh -> slice_segment_addr ; //<S2SV> s -> slice_idx ++ ; //<S2SV> } //<S2SV> } else { //<S2SV> sh -> slice_segment_addr = sh -> slice_addr = 0 ; //<S2SV> s -> slice_idx = 0 ; //<S2SV> s -> slice_initialized = 0 ; //<S2SV> } //<S2SV> if ( ! sh -> dependent_slice_segment_flag ) { //<S2SV> s -> slice_initialized = 0 ; //<S2SV> for ( i = 0 ; i < s -> ps . pps -> num_extra_slice_header_bits ; i ++ ) //<S2SV> skip_bits ( gb , 1 ) ; //<S2SV> sh -> slice_type = get_ue_golomb_long ( gb ) ; //<S2SV> if ( ! ( sh -> slice_type == HEVC_SLICE_I || //<S2SV> sh -> slice_type == HEVC_SLICE_P || //<S2SV> sh -> slice_type == HEVC_SLICE_B ) ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>slice<S2SV_blank>type:<S2SV_blank>%d.\\n" , //<S2SV> sh -> slice_type ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( IS_IRAP ( s ) && sh -> slice_type != HEVC_SLICE_I ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Inter<S2SV_blank>slices<S2SV_blank>in<S2SV_blank>an<S2SV_blank>IRAP<S2SV_blank>frame.\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> sh -> pic_output_flag = 1 ; //<S2SV> if ( s -> ps . pps -> output_flag_present_flag ) //<S2SV> sh -> pic_output_flag = get_bits1 ( gb ) ; //<S2SV> if ( s -> ps . sps -> separate_colour_plane_flag ) //<S2SV> sh -> colour_plane_id = get_bits ( gb , 2 ) ; //<S2SV> if ( ! IS_IDR ( s ) ) { //<S2SV> int poc , pos ; //<S2SV> sh -> pic_order_cnt_lsb = get_bits ( gb , s -> ps . sps -> log2_max_poc_lsb ) ; //<S2SV> poc = ff_hevc_compute_poc ( s -> ps . sps , s -> pocTid0 , sh -> pic_order_cnt_lsb , s -> nal_unit_type ) ; //<S2SV> if ( ! sh -> first_slice_in_pic_flag && poc != s -> poc ) { //<S2SV> av_log ( s -> avctx , AV_LOG_WARNING , //<S2SV> "Ignoring<S2SV_blank>POC<S2SV_blank>change<S2SV_blank>between<S2SV_blank>slices:<S2SV_blank>%d<S2SV_blank>-><S2SV_blank>%d\\n" , s -> poc , poc ) ; //<S2SV> if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> poc = s -> poc ; //<S2SV> } //<S2SV> s -> poc = poc ; //<S2SV> sh -> short_term_ref_pic_set_sps_flag = get_bits1 ( gb ) ; //<S2SV> pos = get_bits_left ( gb ) ; //<S2SV> if ( ! sh -> short_term_ref_pic_set_sps_flag ) { //<S2SV> ret = ff_hevc_decode_short_term_rps ( gb , s -> avctx , & sh -> slice_rps , s -> ps . sps , 1 ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> sh -> short_term_rps = & sh -> slice_rps ; //<S2SV> } else { //<S2SV> int numbits , rps_idx ; //<S2SV> if ( ! s -> ps . sps -> nb_st_rps ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "No<S2SV_blank>ref<S2SV_blank>lists<S2SV_blank>in<S2SV_blank>the<S2SV_blank>SPS.\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> numbits = av_ceil_log2 ( s -> ps . sps -> nb_st_rps ) ; //<S2SV> rps_idx = numbits > 0 ? get_bits ( gb , numbits ) : 0 ; //<S2SV> sh -> short_term_rps = & s -> ps . sps -> st_rps [ rps_idx ] ; //<S2SV> } //<S2SV> sh -> short_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; //<S2SV> pos = get_bits_left ( gb ) ; //<S2SV> ret = decode_lt_rps ( s , & sh -> long_term_rps , gb ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_WARNING , "Invalid<S2SV_blank>long<S2SV_blank>term<S2SV_blank>RPS.\\n" ) ; //<S2SV> if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> sh -> long_term_ref_pic_set_size = pos - get_bits_left ( gb ) ; //<S2SV> if ( s -> ps . sps -> sps_temporal_mvp_enabled_flag ) //<S2SV> sh -> slice_temporal_mvp_enabled_flag = get_bits1 ( gb ) ; //<S2SV> else //<S2SV> sh -> slice_temporal_mvp_enabled_flag = 0 ; //<S2SV> } else { //<S2SV> s -> sh . short_term_rps = NULL ; //<S2SV> s -> poc = 0 ; //<S2SV> } //<S2SV> if ( sh -> first_slice_in_pic_flag && s -> temporal_id == 0 && //<S2SV> s -> nal_unit_type != HEVC_NAL_TRAIL_N && //<S2SV> s -> nal_unit_type != HEVC_NAL_TSA_N && //<S2SV> s -> nal_unit_type != HEVC_NAL_STSA_N && //<S2SV> s -> nal_unit_type != HEVC_NAL_RADL_N && //<S2SV> s -> nal_unit_type != HEVC_NAL_RADL_R && //<S2SV> s -> nal_unit_type != HEVC_NAL_RASL_N && //<S2SV> s -> nal_unit_type != HEVC_NAL_RASL_R ) //<S2SV> s -> pocTid0 = s -> poc ; //<S2SV> if ( s -> ps . sps -> sao_enabled ) { //<S2SV> sh -> slice_sample_adaptive_offset_flag [ 0 ] = get_bits1 ( gb ) ; //<S2SV> if ( s -> ps . sps -> chroma_format_idc ) { //<S2SV> sh -> slice_sample_adaptive_offset_flag [ 1 ] = //<S2SV> sh -> slice_sample_adaptive_offset_flag [ 2 ] = get_bits1 ( gb ) ; //<S2SV> } //<S2SV> } else { //<S2SV> sh -> slice_sample_adaptive_offset_flag [ 0 ] = 0 ; //<S2SV> sh -> slice_sample_adaptive_offset_flag [ 1 ] = 0 ; //<S2SV> sh -> slice_sample_adaptive_offset_flag [ 2 ] = 0 ; //<S2SV> } //<S2SV> sh -> nb_refs [ L0 ] = sh -> nb_refs [ L1 ] = 0 ; //<S2SV> if ( sh -> slice_type == HEVC_SLICE_P || sh -> slice_type == HEVC_SLICE_B ) { //<S2SV> int nb_refs ; //<S2SV> sh -> nb_refs [ L0 ] = s -> ps . pps -> num_ref_idx_l0_default_active ; //<S2SV> if ( sh -> slice_type == HEVC_SLICE_B ) //<S2SV> sh -> nb_refs [ L1 ] = s -> ps . pps -> num_ref_idx_l1_default_active ; //<S2SV> if ( get_bits1 ( gb ) ) { //<S2SV> sh -> nb_refs [ L0 ] = get_ue_golomb_long ( gb ) + 1 ; //<S2SV> if ( sh -> slice_type == HEVC_SLICE_B ) //<S2SV> sh -> nb_refs [ L1 ] = get_ue_golomb_long ( gb ) + 1 ; //<S2SV> } //<S2SV> if ( sh -> nb_refs [ L0 ] > HEVC_MAX_REFS || sh -> nb_refs [ L1 ] > HEVC_MAX_REFS ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Too<S2SV_blank>many<S2SV_blank>refs:<S2SV_blank>%d/%d.\\n" , //<S2SV> sh -> nb_refs [ L0 ] , sh -> nb_refs [ L1 ] ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> sh -> rpl_modification_flag [ 0 ] = 0 ; //<S2SV> sh -> rpl_modification_flag [ 1 ] = 0 ; //<S2SV> nb_refs = ff_hevc_frame_nb_refs ( s ) ; //<S2SV> if ( ! nb_refs ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Zero<S2SV_blank>refs<S2SV_blank>for<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>with<S2SV_blank>P<S2SV_blank>or<S2SV_blank>B<S2SV_blank>slices.\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( s -> ps . pps -> lists_modification_present_flag && nb_refs > 1 ) { //<S2SV> sh -> rpl_modification_flag [ 0 ] = get_bits1 ( gb ) ; //<S2SV> if ( sh -> rpl_modification_flag [ 0 ] ) { //<S2SV> for ( i = 0 ; i < sh -> nb_refs [ L0 ] ; i ++ ) //<S2SV> sh -> list_entry_lx [ 0 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; //<S2SV> } //<S2SV> if ( sh -> slice_type == HEVC_SLICE_B ) { //<S2SV> sh -> rpl_modification_flag [ 1 ] = get_bits1 ( gb ) ; //<S2SV> if ( sh -> rpl_modification_flag [ 1 ] == 1 ) //<S2SV> for ( i = 0 ; i < sh -> nb_refs [ L1 ] ; i ++ ) //<S2SV> sh -> list_entry_lx [ 1 ] [ i ] = get_bits ( gb , av_ceil_log2 ( nb_refs ) ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sh -> slice_type == HEVC_SLICE_B ) //<S2SV> sh -> mvd_l1_zero_flag = get_bits1 ( gb ) ; //<S2SV> if ( s -> ps . pps -> cabac_init_present_flag ) //<S2SV> sh -> cabac_init_flag = get_bits1 ( gb ) ; //<S2SV> else //<S2SV> sh -> cabac_init_flag = 0 ; //<S2SV> sh -> collocated_ref_idx = 0 ; //<S2SV> if ( sh -> slice_temporal_mvp_enabled_flag ) { //<S2SV> sh -> collocated_list = L0 ; //<S2SV> if ( sh -> slice_type == HEVC_SLICE_B ) //<S2SV> sh -> collocated_list = ! get_bits1 ( gb ) ; //<S2SV> if ( sh -> nb_refs [ sh -> collocated_list ] > 1 ) { //<S2SV> sh -> collocated_ref_idx = get_ue_golomb_long ( gb ) ; //<S2SV> if ( sh -> collocated_ref_idx >= sh -> nb_refs [ sh -> collocated_list ] ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "Invalid<S2SV_blank>collocated_ref_idx:<S2SV_blank>%d.\\n" , //<S2SV> sh -> collocated_ref_idx ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( s -> ps . pps -> weighted_pred_flag && sh -> slice_type == HEVC_SLICE_P ) || //<S2SV> ( s -> ps . pps -> weighted_bipred_flag && sh -> slice_type == HEVC_SLICE_B ) ) { //<S2SV> int ret = pred_weight_table ( s , gb ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> sh -> max_num_merge_cand = 5 - get_ue_golomb_long ( gb ) ; //<S2SV> if ( sh -> max_num_merge_cand < 1 || sh -> max_num_merge_cand > 5 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>merging<S2SV_blank>MVP<S2SV_blank>candidates:<S2SV_blank>%d.\\n" , //<S2SV> sh -> max_num_merge_cand ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> sh -> slice_qp_delta = get_se_golomb ( gb ) ; //<S2SV> if ( s -> ps . pps -> pic_slice_level_chroma_qp_offsets_present_flag ) { //<S2SV> sh -> slice_cb_qp_offset = get_se_golomb ( gb ) ; //<S2SV> sh -> slice_cr_qp_offset = get_se_golomb ( gb ) ; //<S2SV> } else { //<S2SV> sh -> slice_cb_qp_offset = 0 ; //<S2SV> sh -> slice_cr_qp_offset = 0 ; //<S2SV> } //<S2SV> if ( s -> ps . pps -> chroma_qp_offset_list_enabled_flag ) //<S2SV> sh -> cu_chroma_qp_offset_enabled_flag = get_bits1 ( gb ) ; //<S2SV> else //<S2SV> sh -> cu_chroma_qp_offset_enabled_flag = 0 ; //<S2SV> if ( s -> ps . pps -> deblocking_filter_control_present_flag ) { //<S2SV> int deblocking_filter_override_flag = 0 ; //<S2SV> if ( s -> ps . pps -> deblocking_filter_override_enabled_flag ) //<S2SV> deblocking_filter_override_flag = get_bits1 ( gb ) ; //<S2SV> if ( deblocking_filter_override_flag ) { //<S2SV> sh -> disable_deblocking_filter_flag = get_bits1 ( gb ) ; //<S2SV> if ( ! sh -> disable_deblocking_filter_flag ) { //<S2SV> int beta_offset_div2 = get_se_golomb ( gb ) ; //<S2SV> int tc_offset_div2 = get_se_golomb ( gb ) ; //<S2SV> if ( beta_offset_div2 < - 6 || beta_offset_div2 > 6 || //<S2SV> tc_offset_div2 < - 6 || tc_offset_div2 > 6 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "Invalid<S2SV_blank>deblock<S2SV_blank>filter<S2SV_blank>offsets:<S2SV_blank>%d,<S2SV_blank>%d\\n" , //<S2SV> beta_offset_div2 , tc_offset_div2 ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> sh -> beta_offset = beta_offset_div2 * 2 ; //<S2SV> sh -> tc_offset = tc_offset_div2 * 2 ; //<S2SV> } //<S2SV> } else { //<S2SV> sh -> disable_deblocking_filter_flag = s -> ps . pps -> disable_dbf ; //<S2SV> sh -> beta_offset = s -> ps . pps -> beta_offset ; //<S2SV> sh -> tc_offset = s -> ps . pps -> tc_offset ; //<S2SV> } //<S2SV> } else { //<S2SV> sh -> disable_deblocking_filter_flag = 0 ; //<S2SV> sh -> beta_offset = 0 ; //<S2SV> sh -> tc_offset = 0 ; //<S2SV> } //<S2SV> if ( s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag && //<S2SV> ( sh -> slice_sample_adaptive_offset_flag [ 0 ] || //<S2SV> sh -> slice_sample_adaptive_offset_flag [ 1 ] || //<S2SV> ! sh -> disable_deblocking_filter_flag ) ) { //<S2SV> sh -> slice_loop_filter_across_slices_enabled_flag = get_bits1 ( gb ) ; //<S2SV> } else { //<S2SV> sh -> slice_loop_filter_across_slices_enabled_flag = s -> ps . pps -> seq_loop_filter_across_slices_enabled_flag ; //<S2SV> } //<S2SV> } else if ( ! s -> slice_initialized ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Independent<S2SV_blank>slice<S2SV_blank>segment<S2SV_blank>missing.\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> sh -> num_entry_point_offsets = 0 ; //<S2SV> if ( s -> ps . pps -> tiles_enabled_flag || s -> ps . pps -> entropy_coding_sync_enabled_flag ) { //<S2SV> unsigned num_entry_point_offsets = get_ue_golomb_long ( gb ) ; //<S2SV> if ( num_entry_point_offsets > get_bits_left ( gb ) ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "num_entry_point_offsets<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , num_entry_point_offsets ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> sh -> num_entry_point_offsets = num_entry_point_offsets ; //<S2SV> if ( sh -> num_entry_point_offsets > 0 ) { //<S2SV> int offset_len = get_ue_golomb_long ( gb ) + 1 ; //<S2SV> if ( offset_len < 1 || offset_len > 32 ) { //<S2SV> sh -> num_entry_point_offsets = 0 ; //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "offset_len<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , offset_len ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> av_freep ( & sh -> entry_point_offset ) ; //<S2SV> av_freep ( & sh -> offset ) ; //<S2SV> av_freep ( & sh -> size ) ; //<S2SV> sh -> entry_point_offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( unsigned ) ) ; //<S2SV> sh -> offset = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; //<S2SV> sh -> size = av_malloc_array ( sh -> num_entry_point_offsets , sizeof ( int ) ) ; //<S2SV> if ( ! sh -> entry_point_offset || ! sh -> offset || ! sh -> size ) { //<S2SV> sh -> num_entry_point_offsets = 0 ; //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n" ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < sh -> num_entry_point_offsets ; i ++ ) { //<S2SV> unsigned val = get_bits_long ( gb , offset_len ) ; //<S2SV> sh -> entry_point_offset [ i ] = val + 1 ; //<S2SV> } //<S2SV> if ( s -> threads_number > 1 && ( s -> ps . pps -> num_tile_rows > 1 || s -> ps . pps -> num_tile_columns > 1 ) ) { //<S2SV> s -> enable_parallel_tiles = 0 ; //<S2SV> s -> threads_number = 1 ; //<S2SV> } else //<S2SV> s -> enable_parallel_tiles = 0 ; //<S2SV> } else //<S2SV> s -> enable_parallel_tiles = 0 ; //<S2SV> } //<S2SV> if ( s -> ps . pps -> slice_header_extension_present_flag ) { //<S2SV> unsigned int length = get_ue_golomb_long ( gb ) ; //<S2SV> if ( length * 8LL > get_bits_left ( gb ) ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "too<S2SV_blank>many<S2SV_blank>slice_header_extension_data_bytes\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> for ( i = 0 ; i < length ; i ++ ) //<S2SV> skip_bits ( gb , 8 ) ; //<S2SV> } //<S2SV> sh -> slice_qp = 26U + s -> ps . pps -> pic_init_qp_minus26 + sh -> slice_qp_delta ; //<S2SV> if ( sh -> slice_qp > 51 || //<S2SV> sh -> slice_qp < - s -> ps . sps -> qp_bd_offset ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "The<S2SV_blank>slice_qp<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>valid<S2SV_blank>range<S2SV_blank>" //<S2SV> "[%d,<S2SV_blank>51].\\n" , //<S2SV> sh -> slice_qp , //<S2SV> - s -> ps . sps -> qp_bd_offset ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> sh -> slice_ctb_addr_rs = sh -> slice_segment_addr ; //<S2SV> if ( ! s -> sh . slice_ctb_addr_rs && s -> sh . dependent_slice_segment_flag ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Impossible<S2SV_blank>slice<S2SV_blank>segment.\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( get_bits_left ( gb ) < 0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "Overread<S2SV_blank>slice<S2SV_blank>header<S2SV_blank>by<S2SV_blank>%d<S2SV_blank>bits\\n" , - get_bits_left ( gb ) ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> s -> HEVClc -> first_qp_group = ! s -> sh . dependent_slice_segment_flag ; //<S2SV> if ( ! s -> ps . pps -> cu_qp_delta_enabled_flag ) //<S2SV> s -> HEVClc -> qp_y = s -> sh . slice_qp ; //<S2SV> s -> slice_initialized = 1 ; //<S2SV> s -> HEVClc -> tu . cu_qp_offset_cb = 0 ; //<S2SV> s -> HEVClc -> tu . cu_qp_offset_cr = 0 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 