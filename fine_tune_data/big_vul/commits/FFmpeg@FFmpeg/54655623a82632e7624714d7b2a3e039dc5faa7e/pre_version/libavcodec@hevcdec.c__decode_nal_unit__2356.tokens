static int decode_nal_unit ( HEVCContext * s , const H2645NAL * nal ) //<S2SV> { //<S2SV> HEVCLocalContext * lc = s -> HEVClc ; //<S2SV> GetBitContext * gb = & lc -> gb ; //<S2SV> int ctb_addr_ts , ret ; //<S2SV> * gb = nal -> gb ; //<S2SV> s -> nal_unit_type = nal -> type ; //<S2SV> s -> temporal_id = nal -> temporal_id ; //<S2SV> switch ( s -> nal_unit_type ) { //<S2SV> case HEVC_NAL_VPS : //<S2SV> if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { //<S2SV> ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , //<S2SV> nal -> type , //<S2SV> nal -> raw_data , //<S2SV> nal -> raw_size ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> ret = ff_hevc_decode_nal_vps ( gb , s -> avctx , & s -> ps ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case HEVC_NAL_SPS : //<S2SV> if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { //<S2SV> ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , //<S2SV> nal -> type , //<S2SV> nal -> raw_data , //<S2SV> nal -> raw_size ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> ret = ff_hevc_decode_nal_sps ( gb , s -> avctx , & s -> ps , //<S2SV> s -> apply_defdispwin ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case HEVC_NAL_PPS : //<S2SV> if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { //<S2SV> ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , //<S2SV> nal -> type , //<S2SV> nal -> raw_data , //<S2SV> nal -> raw_size ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> ret = ff_hevc_decode_nal_pps ( gb , s -> avctx , & s -> ps ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case HEVC_NAL_SEI_PREFIX : //<S2SV> case HEVC_NAL_SEI_SUFFIX : //<S2SV> if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { //<S2SV> ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , //<S2SV> nal -> type , //<S2SV> nal -> raw_data , //<S2SV> nal -> raw_size ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> ret = ff_hevc_decode_nal_sei ( gb , s -> avctx , & s -> sei , & s -> ps , s -> nal_unit_type ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case HEVC_NAL_TRAIL_R : //<S2SV> case HEVC_NAL_TRAIL_N : //<S2SV> case HEVC_NAL_TSA_N : //<S2SV> case HEVC_NAL_TSA_R : //<S2SV> case HEVC_NAL_STSA_N : //<S2SV> case HEVC_NAL_STSA_R : //<S2SV> case HEVC_NAL_BLA_W_LP : //<S2SV> case HEVC_NAL_BLA_W_RADL : //<S2SV> case HEVC_NAL_BLA_N_LP : //<S2SV> case HEVC_NAL_IDR_W_RADL : //<S2SV> case HEVC_NAL_IDR_N_LP : //<S2SV> case HEVC_NAL_CRA_NUT : //<S2SV> case HEVC_NAL_RADL_N : //<S2SV> case HEVC_NAL_RADL_R : //<S2SV> case HEVC_NAL_RASL_N : //<S2SV> case HEVC_NAL_RASL_R : //<S2SV> ret = hls_slice_header ( s ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( //<S2SV> ( s -> avctx -> skip_frame >= AVDISCARD_BIDIR && s -> sh . slice_type == HEVC_SLICE_B ) || //<S2SV> ( s -> avctx -> skip_frame >= AVDISCARD_NONINTRA && s -> sh . slice_type != HEVC_SLICE_I ) || //<S2SV> ( s -> avctx -> skip_frame >= AVDISCARD_NONKEY && ! IS_IRAP ( s ) ) ) { //<S2SV> break ; //<S2SV> } //<S2SV> if ( s -> sh . first_slice_in_pic_flag ) { //<S2SV> if ( s -> ref ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( s -> max_ra == INT_MAX ) { //<S2SV> if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA ( s ) ) { //<S2SV> s -> max_ra = s -> poc ; //<S2SV> } else { //<S2SV> if ( IS_IDR ( s ) ) //<S2SV> s -> max_ra = INT_MIN ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( s -> nal_unit_type == HEVC_NAL_RASL_R || s -> nal_unit_type == HEVC_NAL_RASL_N ) && //<S2SV> s -> poc <= s -> max_ra ) { //<S2SV> s -> is_decoded = 0 ; //<S2SV> break ; //<S2SV> } else { //<S2SV> if ( s -> nal_unit_type == HEVC_NAL_RASL_R && s -> poc > s -> max_ra ) //<S2SV> s -> max_ra = INT_MIN ; //<S2SV> } //<S2SV> s -> overlap ++ ; //<S2SV> ret = hevc_frame_start ( s ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } else if ( ! s -> ref ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "First<S2SV_blank>slice<S2SV_blank>in<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>missing.\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( s -> nal_unit_type != s -> first_nal_type ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "Non-matching<S2SV_blank>NAL<S2SV_blank>types<S2SV_blank>of<S2SV_blank>the<S2SV_blank>VCL<S2SV_blank>NALUs:<S2SV_blank>%d<S2SV_blank>%d\\n" , //<S2SV> s -> first_nal_type , s -> nal_unit_type ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ! s -> sh . dependent_slice_segment_flag && //<S2SV> s -> sh . slice_type != HEVC_SLICE_I ) { //<S2SV> ret = ff_hevc_slice_rpl ( s ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_WARNING , //<S2SV> "Error<S2SV_blank>constructing<S2SV_blank>the<S2SV_blank>reference<S2SV_blank>lists<S2SV_blank>for<S2SV_blank>the<S2SV_blank>current<S2SV_blank>slice.\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> if ( s -> sh . first_slice_in_pic_flag && s -> avctx -> hwaccel ) { //<S2SV> ret = s -> avctx -> hwaccel -> start_frame ( s -> avctx , NULL , 0 ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( s -> avctx -> hwaccel ) { //<S2SV> ret = s -> avctx -> hwaccel -> decode_slice ( s -> avctx , nal -> raw_data , nal -> raw_size ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto fail ; //<S2SV> } else { //<S2SV> if ( s -> threads_number > 1 && s -> sh . num_entry_point_offsets > 0 ) //<S2SV> ctb_addr_ts = hls_slice_data_wpp ( s , nal ) ; //<S2SV> else //<S2SV> ctb_addr_ts = hls_slice_data ( s ) ; //<S2SV> if ( ctb_addr_ts >= ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ) { //<S2SV> s -> is_decoded = 1 ; //<S2SV> } //<S2SV> if ( ctb_addr_ts < 0 ) { //<S2SV> ret = ctb_addr_ts ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case HEVC_NAL_EOS_NUT : //<S2SV> case HEVC_NAL_EOB_NUT : //<S2SV> s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; //<S2SV> s -> max_ra = INT_MAX ; //<S2SV> break ; //<S2SV> case HEVC_NAL_AUD : //<S2SV> case HEVC_NAL_FD_NUT : //<S2SV> break ; //<S2SV> default : //<S2SV> av_log ( s -> avctx , AV_LOG_INFO , //<S2SV> "Skipping<S2SV_blank>NAL<S2SV_blank>unit<S2SV_blank>%d\\n" , s -> nal_unit_type ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> fail : //<S2SV> if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) //<S2SV> return ret ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 