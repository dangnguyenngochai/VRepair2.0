static av_cold int rl2_read_header ( AVFormatContext * s ) //<S2SV> { //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> AVStream * st ; //<S2SV> unsigned int frame_count ; //<S2SV> unsigned int audio_frame_counter = 0 ; //<S2SV> unsigned int video_frame_counter = 0 ; //<S2SV> unsigned int back_size ; //<S2SV> unsigned short sound_rate ; //<S2SV> unsigned short rate ; //<S2SV> unsigned short channels ; //<S2SV> unsigned short def_sound_size ; //<S2SV> unsigned int signature ; //<S2SV> unsigned int pts_den = 11025 ; //<S2SV> unsigned int pts_num = 1103 ; //<S2SV> unsigned int * chunk_offset = NULL ; //<S2SV> int * chunk_size = NULL ; //<S2SV> int * audio_size = NULL ; //<S2SV> int i ; //<S2SV> int ret = 0 ; //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> back_size = avio_rl32 ( pb ) ; //<S2SV> signature = avio_rb32 ( pb ) ; //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> frame_count = avio_rl32 ( pb ) ; //<S2SV> if ( back_size > INT_MAX / 2 || frame_count > INT_MAX / sizeof ( uint32_t ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> avio_skip ( pb , 2 ) ; //<S2SV> sound_rate = avio_rl16 ( pb ) ; //<S2SV> rate = avio_rl16 ( pb ) ; //<S2SV> channels = avio_rl16 ( pb ) ; //<S2SV> def_sound_size = avio_rl16 ( pb ) ; //<S2SV> st = avformat_new_stream ( s , NULL ) ; //<S2SV> if ( ! st ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_RL2 ; //<S2SV> st -> codecpar -> codec_tag = 0 ; //<S2SV> st -> codecpar -> width = 320 ; //<S2SV> st -> codecpar -> height = 200 ; //<S2SV> st -> codecpar -> extradata_size = EXTRADATA1_SIZE ; //<S2SV> if ( signature == RLV3_TAG && back_size > 0 ) //<S2SV> st -> codecpar -> extradata_size += back_size ; //<S2SV> if ( ff_get_extradata ( s , st -> codecpar , pb , st -> codecpar -> extradata_size ) < 0 ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> if ( sound_rate ) { //<S2SV> if ( ! channels || channels > 42 ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>channels:<S2SV_blank>%d\\n" , channels ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> pts_num = def_sound_size ; //<S2SV> pts_den = rate ; //<S2SV> st = avformat_new_stream ( s , NULL ) ; //<S2SV> if ( ! st ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; //<S2SV> st -> codecpar -> codec_tag = 1 ; //<S2SV> st -> codecpar -> channels = channels ; //<S2SV> st -> codecpar -> bits_per_coded_sample = 8 ; //<S2SV> st -> codecpar -> sample_rate = rate ; //<S2SV> st -> codecpar -> bit_rate = st -> codecpar -> channels * st -> codecpar -> sample_rate * //<S2SV> st -> codecpar -> bits_per_coded_sample ; //<S2SV> st -> codecpar -> block_align = st -> codecpar -> channels * //<S2SV> st -> codecpar -> bits_per_coded_sample / 8 ; //<S2SV> avpriv_set_pts_info ( st , 32 , 1 , rate ) ; //<S2SV> } //<S2SV> avpriv_set_pts_info ( s -> streams [ 0 ] , 32 , pts_num , pts_den ) ; //<S2SV> chunk_size = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; //<S2SV> audio_size = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; //<S2SV> chunk_offset = av_malloc ( frame_count * sizeof ( uint32_t ) ) ; //<S2SV> if ( ! chunk_size || ! audio_size || ! chunk_offset ) { //<S2SV> av_free ( chunk_size ) ; //<S2SV> av_free ( audio_size ) ; //<S2SV> av_free ( chunk_offset ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < frame_count ; i ++ ) //<S2SV> chunk_size [ i ] = avio_rl32 ( pb ) ; //<S2SV> for ( i = 0 ; i < frame_count ; i ++ ) //<S2SV> chunk_offset [ i ] = avio_rl32 ( pb ) ; //<S2SV> for ( i = 0 ; i < frame_count ; i ++ ) //<S2SV> audio_size [ i ] = avio_rl32 ( pb ) & 0xFFFF ; //<S2SV> for ( i = 0 ; i < frame_count ; i ++ ) { //<S2SV> if ( chunk_size [ i ] < 0 || audio_size [ i ] > chunk_size [ i ] ) { //<S2SV> ret = AVERROR_INVALIDDATA ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( sound_rate && audio_size [ i ] ) { //<S2SV> av_add_index_entry ( s -> streams [ 1 ] , chunk_offset [ i ] , //<S2SV> audio_frame_counter , audio_size [ i ] , 0 , AVINDEX_KEYFRAME ) ; //<S2SV> audio_frame_counter += audio_size [ i ] / channels ; //<S2SV> } //<S2SV> av_add_index_entry ( s -> streams [ 0 ] , chunk_offset [ i ] + audio_size [ i ] , //<S2SV> video_frame_counter , chunk_size [ i ] - audio_size [ i ] , 0 , AVINDEX_KEYFRAME ) ; //<S2SV> ++ video_frame_counter ; //<S2SV> } //<S2SV> av_free ( chunk_size ) ; //<S2SV> av_free ( audio_size ) ; //<S2SV> av_free ( chunk_offset ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 