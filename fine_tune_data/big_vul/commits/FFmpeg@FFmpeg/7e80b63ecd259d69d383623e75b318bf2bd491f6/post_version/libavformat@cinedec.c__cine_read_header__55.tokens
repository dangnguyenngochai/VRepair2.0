static int cine_read_header ( AVFormatContext * avctx ) //<S2SV> { //<S2SV> AVIOContext * pb = avctx -> pb ; //<S2SV> AVStream * st ; //<S2SV> unsigned int version , compression , offImageHeader , offSetup , offImageOffsets , biBitCount , length , CFA ; //<S2SV> int vflip ; //<S2SV> char * description ; //<S2SV> uint64_t i ; //<S2SV> st = avformat_new_stream ( avctx , NULL ) ; //<S2SV> if ( ! st ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; //<S2SV> st -> codecpar -> codec_tag = 0 ; //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> compression = avio_rl16 ( pb ) ; //<S2SV> version = avio_rl16 ( pb ) ; //<S2SV> if ( version != 1 ) { //<S2SV> avpriv_request_sample ( avctx , "unknown<S2SV_blank>version<S2SV_blank>%i" , version ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> avio_skip ( pb , 12 ) ; //<S2SV> st -> duration = avio_rl32 ( pb ) ; //<S2SV> offImageHeader = avio_rl32 ( pb ) ; //<S2SV> offSetup = avio_rl32 ( pb ) ; //<S2SV> offImageOffsets = avio_rl32 ( pb ) ; //<S2SV> avio_skip ( pb , 8 ) ; //<S2SV> avio_seek ( pb , offImageHeader , SEEK_SET ) ; //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> st -> codecpar -> width = avio_rl32 ( pb ) ; //<S2SV> st -> codecpar -> height = avio_rl32 ( pb ) ; //<S2SV> if ( avio_rl16 ( pb ) != 1 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> biBitCount = avio_rl16 ( pb ) ; //<S2SV> if ( biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48 ) { //<S2SV> avpriv_request_sample ( avctx , "unsupported<S2SV_blank>biBitCount<S2SV_blank>%i" , biBitCount ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> switch ( avio_rl32 ( pb ) ) { //<S2SV> case BMP_RGB : //<S2SV> vflip = 0 ; //<S2SV> break ; //<S2SV> case 0x100 : //<S2SV> st -> codecpar -> codec_tag = MKTAG ( 'B' , 'I' , 'T' , 0 ) ; //<S2SV> vflip = 1 ; //<S2SV> break ; //<S2SV> default : //<S2SV> avpriv_request_sample ( avctx , "unknown<S2SV_blank>bitmap<S2SV_blank>compression" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> avio_seek ( pb , offSetup , SEEK_SET ) ; //<S2SV> avio_skip ( pb , 140 ) ; //<S2SV> if ( avio_rl16 ( pb ) != 0x5453 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> length = avio_rl16 ( pb ) ; //<S2SV> if ( length < 0x163C ) { //<S2SV> avpriv_request_sample ( avctx , "short<S2SV_blank>SETUP<S2SV_blank>header" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> avio_skip ( pb , 616 ) ; //<S2SV> if ( ! avio_rl32 ( pb ) ^ vflip ) { //<S2SV> st -> codecpar -> extradata = av_strdup ( "BottomUp" ) ; //<S2SV> st -> codecpar -> extradata_size = 9 ; //<S2SV> } //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> avpriv_set_pts_info ( st , 64 , 1 , avio_rl32 ( pb ) ) ; //<S2SV> avio_skip ( pb , 20 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "camera_version" , avio_rl32 ( pb ) , 0 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "firmware_version" , avio_rl32 ( pb ) , 0 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "software_version" , avio_rl32 ( pb ) , 0 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "recording_timezone" , avio_rl32 ( pb ) , 0 ) ; //<S2SV> CFA = avio_rl32 ( pb ) ; //<S2SV> set_metadata_int ( & st -> metadata , "brightness" , avio_rl32 ( pb ) , 1 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "contrast" , avio_rl32 ( pb ) , 1 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "gamma" , avio_rl32 ( pb ) , 1 ) ; //<S2SV> avio_skip ( pb , 12 + 16 ) ; //<S2SV> set_metadata_float ( & st -> metadata , "wbgain[0].r" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; //<S2SV> set_metadata_float ( & st -> metadata , "wbgain[0].b" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; //<S2SV> avio_skip ( pb , 36 ) ; //<S2SV> st -> codecpar -> bits_per_coded_sample = avio_rl32 ( pb ) ; //<S2SV> if ( compression == CC_RGB ) { //<S2SV> if ( biBitCount == 8 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_GRAY8 ; //<S2SV> } else if ( biBitCount == 16 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_GRAY16LE ; //<S2SV> } else if ( biBitCount == 24 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_BGR24 ; //<S2SV> } else if ( biBitCount == 48 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_BGR48LE ; //<S2SV> } else { //<S2SV> avpriv_request_sample ( avctx , "unsupported<S2SV_blank>biBitCount<S2SV_blank>%i" , biBitCount ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } else if ( compression == CC_UNINT ) { //<S2SV> switch ( CFA & 0xFFFFFF ) { //<S2SV> case CFA_BAYER : //<S2SV> if ( biBitCount == 8 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG8 ; //<S2SV> } else if ( biBitCount == 16 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG16LE ; //<S2SV> } else { //<S2SV> avpriv_request_sample ( avctx , "unsupported<S2SV_blank>biBitCount<S2SV_blank>%i" , biBitCount ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> break ; //<S2SV> case CFA_BAYERFLIP : //<S2SV> if ( biBitCount == 8 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB8 ; //<S2SV> } else if ( biBitCount == 16 ) { //<S2SV> st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB16LE ; //<S2SV> } else { //<S2SV> avpriv_request_sample ( avctx , "unsupported<S2SV_blank>biBitCount<S2SV_blank>%i" , biBitCount ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> avpriv_request_sample ( avctx , "unsupported<S2SV_blank>Color<S2SV_blank>Field<S2SV_blank>Array<S2SV_blank>(CFA)<S2SV_blank>%i" , CFA & 0xFFFFFF ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } else { //<S2SV> avpriv_request_sample ( avctx , "unsupported<S2SV_blank>compression<S2SV_blank>%i" , compression ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> avio_skip ( pb , 668 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "shutter_ns" , avio_rl32 ( pb ) , 0 ) ; //<S2SV> avio_skip ( pb , 24 ) ; //<S2SV> # define DESCRIPTION_SIZE 4096 //<S2SV> description = av_malloc ( DESCRIPTION_SIZE + 1 ) ; //<S2SV> if ( ! description ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> i = avio_get_str ( pb , DESCRIPTION_SIZE , description , DESCRIPTION_SIZE + 1 ) ; //<S2SV> if ( i < DESCRIPTION_SIZE ) //<S2SV> avio_skip ( pb , DESCRIPTION_SIZE - i ) ; //<S2SV> if ( description [ 0 ] ) //<S2SV> av_dict_set ( & st -> metadata , "description" , description , AV_DICT_DONT_STRDUP_VAL ) ; //<S2SV> else //<S2SV> av_free ( description ) ; //<S2SV> avio_skip ( pb , 1176 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "enable_crop" , avio_rl32 ( pb ) , 1 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "crop_left" , avio_rl32 ( pb ) , 1 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "crop_top" , avio_rl32 ( pb ) , 1 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "crop_right" , avio_rl32 ( pb ) , 1 ) ; //<S2SV> set_metadata_int ( & st -> metadata , "crop_bottom" , avio_rl32 ( pb ) , 1 ) ; //<S2SV> avio_seek ( pb , offImageOffsets , SEEK_SET ) ; //<S2SV> for ( i = 0 ; i < st -> duration ; i ++ ) { //<S2SV> if ( avio_feof ( pb ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 