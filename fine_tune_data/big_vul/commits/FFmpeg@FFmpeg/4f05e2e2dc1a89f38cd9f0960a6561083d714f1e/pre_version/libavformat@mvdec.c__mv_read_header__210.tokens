static int mv_read_header ( AVFormatContext * avctx ) //<S2SV> { //<S2SV> MvContext * mv = avctx -> priv_data ; //<S2SV> AVIOContext * pb = avctx -> pb ; //<S2SV> AVStream * ast = NULL , * vst = NULL ; //<S2SV> int version , i ; //<S2SV> int ret ; //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> version = avio_rb16 ( pb ) ; //<S2SV> if ( version == 2 ) { //<S2SV> uint64_t timestamp ; //<S2SV> int v ; //<S2SV> avio_skip ( pb , 22 ) ; //<S2SV> ast = avformat_new_stream ( avctx , NULL ) ; //<S2SV> if ( ! ast ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> vst = avformat_new_stream ( avctx , NULL ) ; //<S2SV> if ( ! vst ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; //<S2SV> vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; //<S2SV> vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; //<S2SV> vst -> nb_frames = avio_rb32 ( pb ) ; //<S2SV> v = avio_rb32 ( pb ) ; //<S2SV> switch ( v ) { //<S2SV> case 1 : //<S2SV> vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> vst -> codecpar -> format = AV_PIX_FMT_ARGB ; //<S2SV> vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; //<S2SV> break ; //<S2SV> default : //<S2SV> avpriv_request_sample ( avctx , "Video<S2SV_blank>compression<S2SV_blank>%i" , v ) ; //<S2SV> break ; //<S2SV> } //<S2SV> vst -> codecpar -> codec_tag = 0 ; //<S2SV> vst -> codecpar -> width = avio_rb32 ( pb ) ; //<S2SV> vst -> codecpar -> height = avio_rb32 ( pb ) ; //<S2SV> avio_skip ( pb , 12 ) ; //<S2SV> ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; //<S2SV> ast -> nb_frames = vst -> nb_frames ; //<S2SV> ast -> codecpar -> sample_rate = avio_rb32 ( pb ) ; //<S2SV> if ( ast -> codecpar -> sample_rate <= 0 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>%d\\n" , ast -> codecpar -> sample_rate ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> avpriv_set_pts_info ( ast , 33 , 1 , ast -> codecpar -> sample_rate ) ; //<S2SV> if ( set_channels ( avctx , ast , avio_rb32 ( pb ) ) < 0 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> v = avio_rb32 ( pb ) ; //<S2SV> if ( v == AUDIO_FORMAT_SIGNED ) { //<S2SV> ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; //<S2SV> } else { //<S2SV> avpriv_request_sample ( avctx , "Audio<S2SV_blank>compression<S2SV_blank>(format<S2SV_blank>%i)" , v ) ; //<S2SV> } //<S2SV> avio_skip ( pb , 12 ) ; //<S2SV> var_read_metadata ( avctx , "title" , 0x80 ) ; //<S2SV> var_read_metadata ( avctx , "comment" , 0x100 ) ; //<S2SV> avio_skip ( pb , 0x80 ) ; //<S2SV> timestamp = 0 ; //<S2SV> for ( i = 0 ; i < vst -> nb_frames ; i ++ ) { //<S2SV> uint32_t pos = avio_rb32 ( pb ) ; //<S2SV> uint32_t asize = avio_rb32 ( pb ) ; //<S2SV> uint32_t vsize = avio_rb32 ( pb ) ; //<S2SV> avio_skip ( pb , 8 ) ; //<S2SV> av_add_index_entry ( ast , pos , timestamp , asize , 0 , AVINDEX_KEYFRAME ) ; //<S2SV> av_add_index_entry ( vst , pos + asize , i , vsize , 0 , AVINDEX_KEYFRAME ) ; //<S2SV> timestamp += asize / ( ast -> codecpar -> channels * 2 ) ; //<S2SV> } //<S2SV> } else if ( ! version && avio_rb16 ( pb ) == 3 ) { //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> if ( ( ret = read_table ( avctx , NULL , parse_global_var ) ) < 0 ) //<S2SV> return ret ; //<S2SV> if ( mv -> nb_audio_tracks > 1 ) { //<S2SV> avpriv_request_sample ( avctx , "Multiple<S2SV_blank>audio<S2SV_blank>streams<S2SV_blank>support" ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } else if ( mv -> nb_audio_tracks ) { //<S2SV> ast = avformat_new_stream ( avctx , NULL ) ; //<S2SV> if ( ! ast ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; //<S2SV> if ( ( read_table ( avctx , ast , parse_audio_var ) ) < 0 ) //<S2SV> return ret ; //<S2SV> if ( mv -> acompression == 100 && //<S2SV> mv -> aformat == AUDIO_FORMAT_SIGNED && //<S2SV> ast -> codecpar -> bits_per_coded_sample == 16 ) { //<S2SV> ast -> codecpar -> codec_id = AV_CODEC_ID_PCM_S16BE ; //<S2SV> } else { //<S2SV> avpriv_request_sample ( avctx , //<S2SV> "Audio<S2SV_blank>compression<S2SV_blank>%i<S2SV_blank>(format<S2SV_blank>%i,<S2SV_blank>sr<S2SV_blank>%i)" , //<S2SV> mv -> acompression , mv -> aformat , //<S2SV> ast -> codecpar -> bits_per_coded_sample ) ; //<S2SV> ast -> codecpar -> codec_id = AV_CODEC_ID_NONE ; //<S2SV> } //<S2SV> if ( ast -> codecpar -> channels <= 0 ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "No<S2SV_blank>valid<S2SV_blank>channel<S2SV_blank>count<S2SV_blank>found.\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> if ( mv -> nb_video_tracks > 1 ) { //<S2SV> avpriv_request_sample ( avctx , "Multiple<S2SV_blank>video<S2SV_blank>streams<S2SV_blank>support" ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } else if ( mv -> nb_video_tracks ) { //<S2SV> vst = avformat_new_stream ( avctx , NULL ) ; //<S2SV> if ( ! vst ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; //<S2SV> if ( ( ret = read_table ( avctx , vst , parse_video_var ) ) < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( mv -> nb_audio_tracks ) //<S2SV> read_index ( pb , ast ) ; //<S2SV> if ( mv -> nb_video_tracks ) //<S2SV> read_index ( pb , vst ) ; //<S2SV> } else { //<S2SV> avpriv_request_sample ( avctx , "Version<S2SV_blank>%i" , version ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 