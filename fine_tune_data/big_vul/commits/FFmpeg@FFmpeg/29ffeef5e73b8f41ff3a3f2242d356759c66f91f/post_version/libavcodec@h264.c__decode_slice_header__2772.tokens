static int decode_slice_header ( H264Context * h , H264Context * h0 ) //<S2SV> { //<S2SV> unsigned int first_mb_in_slice ; //<S2SV> unsigned int pps_id ; //<S2SV> int ret ; //<S2SV> unsigned int slice_type , tmp , i , j ; //<S2SV> int last_pic_structure , last_pic_droppable ; //<S2SV> int must_reinit ; //<S2SV> int needs_reinit = 0 ; //<S2SV> int field_pic_flag , bottom_field_flag ; //<S2SV> h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab ; //<S2SV> h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab ; //<S2SV> first_mb_in_slice = get_ue_golomb_long ( & h -> gb ) ; //<S2SV> if ( first_mb_in_slice == 0 ) { //<S2SV> if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) { //<S2SV> field_end ( h , 1 ) ; //<S2SV> } //<S2SV> h0 -> current_slice = 0 ; //<S2SV> if ( ! h0 -> first_field ) { //<S2SV> if ( h -> cur_pic_ptr && ! h -> droppable ) { //<S2SV> ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , //<S2SV> h -> picture_structure == PICT_BOTTOM_FIELD ) ; //<S2SV> } //<S2SV> h -> cur_pic_ptr = NULL ; //<S2SV> } //<S2SV> } //<S2SV> slice_type = get_ue_golomb_31 ( & h -> gb ) ; //<S2SV> if ( slice_type > 9 ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\n" , //<S2SV> slice_type , h -> mb_x , h -> mb_y ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( slice_type > 4 ) { //<S2SV> slice_type -= 5 ; //<S2SV> h -> slice_type_fixed = 1 ; //<S2SV> } else //<S2SV> h -> slice_type_fixed = 0 ; //<S2SV> slice_type = golomb_to_pict_type [ slice_type ] ; //<S2SV> h -> slice_type = slice_type ; //<S2SV> h -> slice_type_nos = slice_type & 3 ; //<S2SV> h -> pict_type = h -> slice_type ; //<S2SV> pps_id = get_ue_golomb ( & h -> gb ) ; //<S2SV> if ( pps_id >= MAX_PPS_COUNT ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , "pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n" , pps_id ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ! h0 -> pps_buffers [ pps_id ] ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\n" , //<S2SV> pps_id ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> h -> pps = * h0 -> pps_buffers [ pps_id ] ; //<S2SV> if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\n" , //<S2SV> h -> pps . sps_id ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( h -> pps . sps_id != h -> current_sps_id || //<S2SV> h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) { //<S2SV> h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ; //<S2SV> h -> current_sps_id = h -> pps . sps_id ; //<S2SV> h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ; //<S2SV> if ( h -> mb_width != h -> sps . mb_width || //<S2SV> h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || //<S2SV> h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || //<S2SV> h -> cur_chroma_format_idc != h -> sps . chroma_format_idc //<S2SV> ) //<S2SV> needs_reinit = 1 ; //<S2SV> if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || //<S2SV> h -> chroma_format_idc != h -> sps . chroma_format_idc ) { //<S2SV> h -> bit_depth_luma = h -> sps . bit_depth_luma ; //<S2SV> h -> chroma_format_idc = h -> sps . chroma_format_idc ; //<S2SV> needs_reinit = 1 ; //<S2SV> } //<S2SV> if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ; //<S2SV> h -> avctx -> level = h -> sps . level_idc ; //<S2SV> h -> avctx -> refs = h -> sps . ref_frame_count ; //<S2SV> must_reinit = ( h -> context_initialized && //<S2SV> ( 16 * h -> sps . mb_width != h -> avctx -> coded_width //<S2SV> || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height //<S2SV> || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma //<S2SV> || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc //<S2SV> || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) //<S2SV> || h -> mb_width != h -> sps . mb_width //<S2SV> || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) //<S2SV> ) ) ; //<S2SV> if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) //<S2SV> must_reinit = 1 ; //<S2SV> h -> mb_width = h -> sps . mb_width ; //<S2SV> h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ; //<S2SV> h -> mb_num = h -> mb_width * h -> mb_height ; //<S2SV> h -> mb_stride = h -> mb_width + 1 ; //<S2SV> h -> b_stride = h -> mb_width * 4 ; //<S2SV> h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ; //<S2SV> h -> width = 16 * h -> mb_width ; //<S2SV> h -> height = 16 * h -> mb_height ; //<S2SV> ret = init_dimensions ( h ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( h -> sps . video_signal_type_present_flag ) { //<S2SV> h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG //<S2SV> : AVCOL_RANGE_MPEG ; //<S2SV> if ( h -> sps . colour_description_present_flag ) { //<S2SV> if ( h -> avctx -> colorspace != h -> sps . colorspace ) //<S2SV> needs_reinit = 1 ; //<S2SV> h -> avctx -> color_primaries = h -> sps . color_primaries ; //<S2SV> h -> avctx -> color_trc = h -> sps . color_trc ; //<S2SV> h -> avctx -> colorspace = h -> sps . colorspace ; //<S2SV> } //<S2SV> } //<S2SV> if ( h -> context_initialized && //<S2SV> ( h -> width != h -> avctx -> coded_width || //<S2SV> h -> height != h -> avctx -> coded_height || //<S2SV> must_reinit || //<S2SV> needs_reinit ) ) { //<S2SV> if ( h != h0 ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , "changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>" //<S2SV> "slice<S2SV_blank>%d\\n" , h0 -> current_slice + 1 ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> flush_change ( h ) ; //<S2SV> if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) //<S2SV> return ret ; //<S2SV> h -> avctx -> pix_fmt = ret ; //<S2SV> av_log ( h -> avctx , AV_LOG_INFO , "Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>" //<S2SV> "pix_fmt:<S2SV_blank>%s\\n" , h -> width , h -> height , av_get_pix_fmt_name ( h -> avctx -> pix_fmt ) ) ; //<S2SV> if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "h264_slice_header_init()<S2SV_blank>failed\\n" ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! h -> context_initialized ) { //<S2SV> if ( h != h0 ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\n" ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) //<S2SV> return ret ; //<S2SV> h -> avctx -> pix_fmt = ret ; //<S2SV> if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "h264_slice_header_init()<S2SV_blank>failed\\n" ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> if ( h == h0 && h -> dequant_coeff_pps != pps_id ) { //<S2SV> h -> dequant_coeff_pps = pps_id ; //<S2SV> init_dequant_tables ( h ) ; //<S2SV> } //<S2SV> h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ; //<S2SV> h -> mb_mbaff = 0 ; //<S2SV> h -> mb_aff_frame = 0 ; //<S2SV> last_pic_structure = h0 -> picture_structure ; //<S2SV> last_pic_droppable = h0 -> droppable ; //<S2SV> h -> droppable = h -> nal_ref_idc == 0 ; //<S2SV> if ( h -> sps . frame_mbs_only_flag ) { //<S2SV> h -> picture_structure = PICT_FRAME ; //<S2SV> } else { //<S2SV> if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , "This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> field_pic_flag = get_bits1 ( & h -> gb ) ; //<S2SV> if ( field_pic_flag ) { //<S2SV> bottom_field_flag = get_bits1 ( & h -> gb ) ; //<S2SV> h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ; //<S2SV> } else { //<S2SV> h -> picture_structure = PICT_FRAME ; //<S2SV> h -> mb_aff_frame = h -> sps . mb_aff ; //<S2SV> } //<S2SV> } //<S2SV> h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ; //<S2SV> if ( h0 -> current_slice != 0 ) { //<S2SV> if ( last_pic_structure != h -> picture_structure || //<S2SV> last_pic_droppable != h -> droppable ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n" , //<S2SV> last_pic_structure , h -> picture_structure ) ; //<S2SV> h -> picture_structure = last_pic_structure ; //<S2SV> h -> droppable = last_pic_droppable ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } else if ( ! h0 -> cur_pic_ptr ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "unset<S2SV_blank>cur_pic_ptr<S2SV_blank>on<S2SV_blank>%d.<S2SV_blank>slice\\n" , //<S2SV> h0 -> current_slice + 1 ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 ) { //<S2SV> int unwrap_prev_frame_num = h -> prev_frame_num ; //<S2SV> int max_frame_num = 1 << h -> sps . log2_max_frame_num ; //<S2SV> if ( unwrap_prev_frame_num > h -> frame_num ) //<S2SV> unwrap_prev_frame_num -= max_frame_num ; //<S2SV> if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count ) { //<S2SV> unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 ; //<S2SV> if ( unwrap_prev_frame_num < 0 ) //<S2SV> unwrap_prev_frame_num += max_frame_num ; //<S2SV> h -> prev_frame_num = unwrap_prev_frame_num ; //<S2SV> } //<S2SV> } //<S2SV> if ( h0 -> first_field ) { //<S2SV> assert ( h0 -> cur_pic_ptr ) ; //<S2SV> assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; //<S2SV> assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; //<S2SV> if ( h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { //<S2SV> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , //<S2SV> last_pic_structure == PICT_BOTTOM_FIELD ) ; //<S2SV> } //<S2SV> if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { //<S2SV> if ( last_pic_structure != PICT_FRAME ) { //<S2SV> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , //<S2SV> last_pic_structure == PICT_TOP_FIELD ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { //<S2SV> if ( last_pic_structure != PICT_FRAME ) { //<S2SV> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , //<S2SV> last_pic_structure == PICT_TOP_FIELD ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && //<S2SV> h -> picture_structure == PICT_BOTTOM_FIELD ) || //<S2SV> ( last_pic_structure == PICT_BOTTOM_FIELD && //<S2SV> h -> picture_structure == PICT_TOP_FIELD ) ) ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "Invalid<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>combination<S2SV_blank>%d/%d\\n" , //<S2SV> last_pic_structure , h -> picture_structure ) ; //<S2SV> h -> picture_structure = last_pic_structure ; //<S2SV> h -> droppable = last_pic_droppable ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } else if ( last_pic_droppable != h -> droppable ) { //<S2SV> avpriv_request_sample ( h -> avctx , //<S2SV> "Found<S2SV_blank>reference<S2SV_blank>and<S2SV_blank>non-reference<S2SV_blank>fields<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame,<S2SV_blank>which" ) ; //<S2SV> h -> picture_structure = last_pic_structure ; //<S2SV> h -> droppable = last_pic_droppable ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && //<S2SV> h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) ) { //<S2SV> Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; //<S2SV> av_log ( h -> avctx , AV_LOG_DEBUG , "Frame<S2SV_blank>num<S2SV_blank>gap<S2SV_blank>%d<S2SV_blank>%d\\n" , //<S2SV> h -> frame_num , h -> prev_frame_num ) ; //<S2SV> if ( ! h -> sps . gaps_in_frame_num_allowed_flag ) //<S2SV> for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> last_pocs ) ; i ++ ) //<S2SV> h -> last_pocs [ i ] = INT_MIN ; //<S2SV> ret = h264_frame_start ( h ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> h -> prev_frame_num ++ ; //<S2SV> h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num ; //<S2SV> h -> cur_pic_ptr -> frame_num = h -> prev_frame_num ; //<S2SV> ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 0 ) ; //<S2SV> ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 1 ) ; //<S2SV> ret = ff_generate_sliding_window_mmcos ( h , 1 ) ; //<S2SV> if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) //<S2SV> return ret ; //<S2SV> ret = ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) ; //<S2SV> if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) //<S2SV> return ret ; //<S2SV> if ( h -> short_ref_count ) { //<S2SV> if ( prev ) { //<S2SV> av_image_copy ( h -> short_ref [ 0 ] -> f . data , //<S2SV> h -> short_ref [ 0 ] -> f . linesize , //<S2SV> ( const uint8_t * * ) prev -> f . data , //<S2SV> prev -> f . linesize , //<S2SV> h -> avctx -> pix_fmt , //<S2SV> h -> mb_width * 16 , //<S2SV> h -> mb_height * 16 ) ; //<S2SV> h -> short_ref [ 0 ] -> poc = prev -> poc + 2 ; //<S2SV> } //<S2SV> h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num ; //<S2SV> } //<S2SV> } //<S2SV> if ( h0 -> first_field ) { //<S2SV> assert ( h0 -> cur_pic_ptr ) ; //<S2SV> assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; //<S2SV> assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; //<S2SV> if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { //<S2SV> h0 -> cur_pic_ptr = NULL ; //<S2SV> h0 -> first_field = FIELD_PICTURE ( h ) ; //<S2SV> } else { //<S2SV> if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { //<S2SV> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , //<S2SV> h0 -> picture_structure == PICT_BOTTOM_FIELD ) ; //<S2SV> h0 -> first_field = 1 ; //<S2SV> h0 -> cur_pic_ptr = NULL ; //<S2SV> } else { //<S2SV> h0 -> first_field = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> h0 -> first_field = FIELD_PICTURE ( h ) ; //<S2SV> } //<S2SV> if ( ! FIELD_PICTURE ( h ) || h0 -> first_field ) { //<S2SV> if ( h264_frame_start ( h ) < 0 ) { //<S2SV> h0 -> first_field = 0 ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } else { //<S2SV> release_unused_pictures ( h , 0 ) ; //<S2SV> } //<S2SV> if ( FIELD_PICTURE ( h ) ) { //<S2SV> for ( i = ( h -> picture_structure == PICT_BOTTOM_FIELD ) ; i < h -> mb_height ; i ++ ) //<S2SV> memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ) ; //<S2SV> } else { //<S2SV> memset ( h -> slice_table , - 1 , //<S2SV> ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ) ; //<S2SV> } //<S2SV> h0 -> last_slice_type = - 1 ; //<S2SV> } //<S2SV> if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 ) //<S2SV> return ret ; //<S2SV> for ( i = 0 ; i < h -> slice_context_count ; i ++ ) //<S2SV> if ( h -> thread_context [ i ] ) { //<S2SV> ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> h -> cur_pic_ptr -> frame_num = h -> frame_num ; //<S2SV> av_assert1 ( h -> mb_num == h -> mb_width * h -> mb_height ) ; //<S2SV> if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || //<S2SV> first_mb_in_slice >= h -> mb_num ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , "first_mb_in_slice<S2SV_blank>overflow\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width ; //<S2SV> h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << //<S2SV> FIELD_OR_MBAFF_PICTURE ( h ) ; //<S2SV> if ( h -> picture_structure == PICT_BOTTOM_FIELD ) //<S2SV> h -> resync_mb_y = h -> mb_y = h -> mb_y + 1 ; //<S2SV> av_assert1 ( h -> mb_y < h -> mb_height ) ; //<S2SV> if ( h -> picture_structure == PICT_FRAME ) { //<S2SV> h -> curr_pic_num = h -> frame_num ; //<S2SV> h -> max_pic_num = 1 << h -> sps . log2_max_frame_num ; //<S2SV> } else { //<S2SV> h -> curr_pic_num = 2 * h -> frame_num + 1 ; //<S2SV> h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ) ; //<S2SV> } //<S2SV> if ( h -> nal_unit_type == NAL_IDR_SLICE ) //<S2SV> get_ue_golomb ( & h -> gb ) ; //<S2SV> if ( h -> sps . poc_type == 0 ) { //<S2SV> h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ) ; //<S2SV> if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) //<S2SV> h -> delta_poc_bottom = get_se_golomb ( & h -> gb ) ; //<S2SV> } //<S2SV> if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag ) { //<S2SV> h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ) ; //<S2SV> if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) //<S2SV> h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ) ; //<S2SV> } //<S2SV> ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ) ; //<S2SV> if ( h -> pps . redundant_pic_cnt_present ) //<S2SV> h -> redundant_pic_count = get_ue_golomb ( & h -> gb ) ; //<S2SV> ret = ff_set_ref_count ( h ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( slice_type != AV_PICTURE_TYPE_I && //<S2SV> ( h0 -> current_slice == 0 || //<S2SV> slice_type != h0 -> last_slice_type || //<S2SV> memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) ) { //<S2SV> ff_h264_fill_default_ref_list ( h ) ; //<S2SV> } //<S2SV> if ( h -> slice_type_nos != AV_PICTURE_TYPE_I ) { //<S2SV> ret = ff_h264_decode_ref_pic_list_reordering ( h ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0 ; //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || //<S2SV> ( h -> pps . weighted_bipred_idc == 1 && //<S2SV> h -> slice_type_nos == AV_PICTURE_TYPE_B ) ) //<S2SV> ff_pred_weight_table ( h ) ; //<S2SV> else if ( h -> pps . weighted_bipred_idc == 2 && //<S2SV> h -> slice_type_nos == AV_PICTURE_TYPE_B ) { //<S2SV> implicit_weight_table ( h , - 1 ) ; //<S2SV> } else { //<S2SV> h -> use_weight = 0 ; //<S2SV> for ( i = 0 ; i < 2 ; i ++ ) { //<S2SV> h -> luma_weight_flag [ i ] = 0 ; //<S2SV> h -> chroma_weight_flag [ i ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( h -> nal_ref_idc ) { //<S2SV> ret = ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , //<S2SV> ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || //<S2SV> h0 -> current_slice == 0 ) ; //<S2SV> if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( FRAME_MBAFF ( h ) ) { //<S2SV> ff_h264_fill_mbaff_ref_list ( h ) ; //<S2SV> if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { //<S2SV> implicit_weight_table ( h , 0 ) ; //<S2SV> implicit_weight_table ( h , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred ) //<S2SV> ff_h264_direct_dist_scale_factor ( h ) ; //<S2SV> ff_h264_direct_ref_list_init ( h ) ; //<S2SV> if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac ) { //<S2SV> tmp = get_ue_golomb_31 ( & h -> gb ) ; //<S2SV> if ( tmp > 2 ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , "cabac_init_idc<S2SV_blank>overflow\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> h -> cabac_init_idc = tmp ; //<S2SV> } //<S2SV> h -> last_qscale_diff = 0 ; //<S2SV> tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ) ; //<S2SV> if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , "QP<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n" , tmp ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> h -> qscale = tmp ; //<S2SV> h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ; //<S2SV> h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ; //<S2SV> if ( h -> slice_type == AV_PICTURE_TYPE_SP ) //<S2SV> get_bits1 ( & h -> gb ) ; //<S2SV> if ( h -> slice_type == AV_PICTURE_TYPE_SP || //<S2SV> h -> slice_type == AV_PICTURE_TYPE_SI ) //<S2SV> get_se_golomb ( & h -> gb ) ; //<S2SV> h -> deblocking_filter = 1 ; //<S2SV> h -> slice_alpha_c0_offset = 52 ; //<S2SV> h -> slice_beta_offset = 52 ; //<S2SV> if ( h -> pps . deblocking_filter_parameters_present ) { //<S2SV> tmp = get_ue_golomb_31 ( & h -> gb ) ; //<S2SV> if ( tmp > 2 ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "deblocking_filter_idc<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n" , tmp ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> h -> deblocking_filter = tmp ; //<S2SV> if ( h -> deblocking_filter < 2 ) //<S2SV> h -> deblocking_filter ^= 1 ; //<S2SV> if ( h -> deblocking_filter ) { //<S2SV> h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1 ; //<S2SV> h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1 ; //<S2SV> if ( h -> slice_alpha_c0_offset > 104U || //<S2SV> h -> slice_beta_offset > 104U ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "deblocking<S2SV_blank>filter<S2SV_blank>parameters<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n" , //<S2SV> h -> slice_alpha_c0_offset , h -> slice_beta_offset ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || //<S2SV> ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && //<S2SV> h -> slice_type_nos != AV_PICTURE_TYPE_I ) || //<S2SV> ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && //<S2SV> h -> slice_type_nos == AV_PICTURE_TYPE_B ) || //<S2SV> ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && //<S2SV> h -> nal_ref_idc == 0 ) ) //<S2SV> h -> deblocking_filter = 0 ; //<S2SV> if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 ) { //<S2SV> if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST ) { //<S2SV> h -> deblocking_filter = 2 ; //<S2SV> } else { //<S2SV> h0 -> max_contexts = 1 ; //<S2SV> if ( ! h0 -> single_decode_warning ) { //<S2SV> av_log ( h -> avctx , AV_LOG_INFO , //<S2SV> "Cannot<S2SV_blank>parallelize<S2SV_blank>deblocking<S2SV_blank>type<S2SV_blank>1,<S2SV_blank>decoding<S2SV_blank>such<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>sequential<S2SV_blank>order\\n" ) ; //<S2SV> h0 -> single_decode_warning = 1 ; //<S2SV> } //<S2SV> if ( h != h0 ) { //<S2SV> av_log ( h -> avctx , AV_LOG_ERROR , //<S2SV> "Deblocking<S2SV_blank>switched<S2SV_blank>inside<S2SV_blank>frame.\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> h -> qp_thresh = 15 + 52 - //<S2SV> FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - //<S2SV> FFMAX3 ( 0 , //<S2SV> h -> pps . chroma_qp_index_offset [ 0 ] , //<S2SV> h -> pps . chroma_qp_index_offset [ 1 ] ) + //<S2SV> 6 * ( h -> sps . bit_depth_luma - 8 ) ; //<S2SV> h0 -> last_slice_type = slice_type ; //<S2SV> memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ) ; //<S2SV> h -> slice_num = ++ h0 -> current_slice ; //<S2SV> if ( h -> slice_num ) //<S2SV> h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y ; //<S2SV> if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y //<S2SV> && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y //<S2SV> && h -> slice_num >= MAX_SLICES ) { //<S2SV> av_log ( h -> avctx , AV_LOG_WARNING , "Possibly<S2SV_blank>too<S2SV_blank>many<S2SV_blank>slices<S2SV_blank>(%d<S2SV_blank>>=<S2SV_blank>%d),<S2SV_blank>increase<S2SV_blank>MAX_SLICES<S2SV_blank>and<S2SV_blank>recompile<S2SV_blank>if<S2SV_blank>there<S2SV_blank>are<S2SV_blank>artifacts\\n" , h -> slice_num , MAX_SLICES ) ; //<S2SV> } //<S2SV> for ( j = 0 ; j < 2 ; j ++ ) { //<S2SV> int id_list [ 16 ] ; //<S2SV> int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) { //<S2SV> id_list [ i ] = 60 ; //<S2SV> if ( j < h -> list_count && i < h -> ref_count [ j ] && //<S2SV> h -> ref_list [ j ] [ i ] . f . buf [ 0 ] ) { //<S2SV> int k ; //<S2SV> AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; //<S2SV> for ( k = 0 ; k < h -> short_ref_count ; k ++ ) //<S2SV> if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { //<S2SV> id_list [ i ] = k ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( k = 0 ; k < h -> long_ref_count ; k ++ ) //<S2SV> if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { //<S2SV> id_list [ i ] = h -> short_ref_count + k ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ref2frm [ 0 ] = //<S2SV> ref2frm [ 1 ] = - 1 ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; //<S2SV> ref2frm [ 18 + 0 ] = //<S2SV> ref2frm [ 18 + 1 ] = - 1 ; //<S2SV> for ( i = 16 ; i < 48 ; i ++ ) //<S2SV> ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + //<S2SV> ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; //<S2SV> } //<S2SV> if ( h -> ref_count [ 0 ] ) h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ] ; //<S2SV> if ( h -> ref_count [ 1 ] ) h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ] ; //<S2SV> h -> er . ref_count = h -> ref_count [ 0 ] ; //<S2SV> if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO ) { //<S2SV> av_log ( h -> avctx , AV_LOG_DEBUG , //<S2SV> "slice:%d<S2SV_blank>%s<S2SV_blank>mb:%d<S2SV_blank>%c%s%s<S2SV_blank>pps:%u<S2SV_blank>frame:%d<S2SV_blank>poc:%d/%d<S2SV_blank>ref:%d/%d<S2SV_blank>qp:%d<S2SV_blank>loop:%d:%d:%d<S2SV_blank>weight:%d%s<S2SV_blank>%s\\n" , //<S2SV> h -> slice_num , //<S2SV> ( h -> picture_structure == PICT_FRAME ? "F" : h -> picture_structure == PICT_TOP_FIELD ? "T" : "B" ) , //<S2SV> first_mb_in_slice , //<S2SV> av_get_picture_type_char ( h -> slice_type ) , //<S2SV> h -> slice_type_fixed ? "<S2SV_blank>fix" : "" , //<S2SV> h -> nal_unit_type == NAL_IDR_SLICE ? "<S2SV_blank>IDR" : "" , //<S2SV> pps_id , h -> frame_num , //<S2SV> h -> cur_pic_ptr -> field_poc [ 0 ] , //<S2SV> h -> cur_pic_ptr -> field_poc [ 1 ] , //<S2SV> h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , //<S2SV> h -> qscale , //<S2SV> h -> deblocking_filter , //<S2SV> h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , //<S2SV> h -> use_weight , //<S2SV> h -> use_weight == 1 && h -> use_weight_chroma ? "c" : "" , //<S2SV> h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? "SPAT" : "TEMP" ) : "" ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 