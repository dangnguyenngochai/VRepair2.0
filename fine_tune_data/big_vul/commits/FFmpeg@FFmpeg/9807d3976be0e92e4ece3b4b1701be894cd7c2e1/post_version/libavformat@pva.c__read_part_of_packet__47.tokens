static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , //<S2SV> int * len , int * strid , int read_packet ) { //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> PVAContext * pvactx = s -> priv_data ; //<S2SV> int syncword , streamid , reserved , flags , length , pts_flag ; //<S2SV> int64_t pva_pts = AV_NOPTS_VALUE , startpos ; //<S2SV> int ret ; //<S2SV> recover : //<S2SV> startpos = avio_tell ( pb ) ; //<S2SV> syncword = avio_rb16 ( pb ) ; //<S2SV> streamid = avio_r8 ( pb ) ; //<S2SV> avio_r8 ( pb ) ; //<S2SV> reserved = avio_r8 ( pb ) ; //<S2SV> flags = avio_r8 ( pb ) ; //<S2SV> length = avio_rb16 ( pb ) ; //<S2SV> pts_flag = flags & 0x10 ; //<S2SV> if ( syncword != PVA_MAGIC ) { //<S2SV> pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>syncword\\n" ) ; //<S2SV> return AVERROR ( EIO ) ; //<S2SV> } //<S2SV> if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { //<S2SV> pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>streamid\\n" ) ; //<S2SV> return AVERROR ( EIO ) ; //<S2SV> } //<S2SV> if ( reserved != 0x55 ) { //<S2SV> pva_log ( s , AV_LOG_WARNING , "expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n" ) ; //<S2SV> } //<S2SV> if ( length > PVA_MAX_PAYLOAD_LENGTH ) { //<S2SV> pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n" , length ) ; //<S2SV> return AVERROR ( EIO ) ; //<S2SV> } //<S2SV> if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { //<S2SV> pva_pts = avio_rb32 ( pb ) ; //<S2SV> length -= 4 ; //<S2SV> } else if ( streamid == PVA_AUDIO_PAYLOAD ) { //<S2SV> if ( ! pvactx -> continue_pes ) { //<S2SV> int pes_signal , pes_header_data_length , pes_packet_length , //<S2SV> pes_flags ; //<S2SV> unsigned char pes_header_data [ 256 ] ; //<S2SV> pes_signal = avio_rb24 ( pb ) ; //<S2SV> avio_r8 ( pb ) ; //<S2SV> pes_packet_length = avio_rb16 ( pb ) ; //<S2SV> pes_flags = avio_rb16 ( pb ) ; //<S2SV> pes_header_data_length = avio_r8 ( pb ) ; //<S2SV> if ( avio_feof ( pb ) ) { //<S2SV> return AVERROR_EOF ; //<S2SV> } //<S2SV> if ( pes_signal != 1 || pes_header_data_length == 0 ) { //<S2SV> pva_log ( s , AV_LOG_WARNING , "expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>" //<S2SV> "trying<S2SV_blank>to<S2SV_blank>recover\\n" ) ; //<S2SV> avio_skip ( pb , length - 9 ) ; //<S2SV> if ( ! read_packet ) //<S2SV> return AVERROR ( EIO ) ; //<S2SV> goto recover ; //<S2SV> } //<S2SV> ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; //<S2SV> if ( ret != pes_header_data_length ) //<S2SV> return ret < 0 ? ret : AVERROR_INVALIDDATA ; //<S2SV> length -= 9 + pes_header_data_length ; //<S2SV> pes_packet_length -= 3 + pes_header_data_length ; //<S2SV> pvactx -> continue_pes = pes_packet_length ; //<S2SV> if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { //<S2SV> if ( pes_header_data_length < 5 ) { //<S2SV> pva_log ( s , AV_LOG_ERROR , "header<S2SV_blank>too<S2SV_blank>short\\n" ) ; //<S2SV> avio_skip ( pb , length ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> pva_pts = ff_parse_pes_pts ( pes_header_data ) ; //<S2SV> } //<S2SV> } //<S2SV> pvactx -> continue_pes -= length ; //<S2SV> if ( pvactx -> continue_pes < 0 ) { //<S2SV> pva_log ( s , AV_LOG_WARNING , "audio<S2SV_blank>data<S2SV_blank>corruption\\n" ) ; //<S2SV> pvactx -> continue_pes = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( pva_pts != AV_NOPTS_VALUE ) //<S2SV> av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; //<S2SV> * pts = pva_pts ; //<S2SV> * len = length ; //<S2SV> * strid = streamid ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 