static int http_read_header ( URLContext * h , int * new_location ) //<S2SV> { //<S2SV> HTTPContext * s = h -> priv_data ; //<S2SV> char line [ MAX_URL_SIZE ] ; //<S2SV> int err = 0 ; //<S2SV> s -> chunksize = UINT64_MAX ; //<S2SV> for ( ; ; ) { //<S2SV> if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) //<S2SV> return err ; //<S2SV> av_log ( h , AV_LOG_TRACE , "header=\'%s\'\\n" , line ) ; //<S2SV> err = process_line ( h , line , s -> line_count , new_location ) ; //<S2SV> if ( err < 0 ) //<S2SV> return err ; //<S2SV> if ( err == 0 ) //<S2SV> break ; //<S2SV> s -> line_count ++ ; //<S2SV> } //<S2SV> if ( s -> seekable == - 1 && s -> is_mediagateway && s -> filesize == 2000000000 ) //<S2SV> h -> is_streamed = 1 ; //<S2SV> cookie_string ( s -> cookie_dict , & s -> cookies ) ; //<S2SV> av_dict_free ( & s -> cookie_dict ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 