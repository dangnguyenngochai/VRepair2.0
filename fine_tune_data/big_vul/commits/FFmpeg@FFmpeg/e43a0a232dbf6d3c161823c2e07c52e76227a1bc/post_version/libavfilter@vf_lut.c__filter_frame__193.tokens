static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) //<S2SV> { //<S2SV> AVFilterContext * ctx = inlink -> dst ; //<S2SV> LutContext * s = ctx -> priv ; //<S2SV> AVFilterLink * outlink = ctx -> outputs [ 0 ] ; //<S2SV> AVFrame * out ; //<S2SV> uint8_t * inrow , * outrow , * inrow0 , * outrow0 ; //<S2SV> int i , j , plane , direct = 0 ; //<S2SV> if ( av_frame_is_writable ( in ) ) { //<S2SV> direct = 1 ; //<S2SV> out = in ; //<S2SV> } else { //<S2SV> out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; //<S2SV> if ( ! out ) { //<S2SV> av_frame_free ( & in ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> av_frame_copy_props ( out , in ) ; //<S2SV> } //<S2SV> if ( s -> is_rgb ) { //<S2SV> inrow0 = in -> data [ 0 ] ; //<S2SV> outrow0 = out -> data [ 0 ] ; //<S2SV> for ( i = 0 ; i < in -> height ; i ++ ) { //<S2SV> int w = inlink -> w ; //<S2SV> const uint8_t ( * tab ) [ 256 ] = ( const uint8_t ( * ) [ 256 ] ) s -> lut ; //<S2SV> inrow = inrow0 ; //<S2SV> outrow = outrow0 ; //<S2SV> for ( j = 0 ; j < w ; j ++ ) { //<S2SV> switch ( s -> step ) { //<S2SV> case 4 : outrow [ 3 ] = tab [ 3 ] [ inrow [ 3 ] ] ; //<S2SV> case 3 : outrow [ 2 ] = tab [ 2 ] [ inrow [ 2 ] ] ; //<S2SV> case 2 : outrow [ 1 ] = tab [ 1 ] [ inrow [ 1 ] ] ; //<S2SV> default : outrow [ 0 ] = tab [ 0 ] [ inrow [ 0 ] ] ; //<S2SV> } //<S2SV> outrow += s -> step ; //<S2SV> inrow += s -> step ; //<S2SV> } //<S2SV> inrow0 += in -> linesize [ 0 ] ; //<S2SV> outrow0 += out -> linesize [ 0 ] ; //<S2SV> } //<S2SV> } else { //<S2SV> for ( plane = 0 ; plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ; plane ++ ) { //<S2SV> int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ; //<S2SV> int hsub = plane == 1 || plane == 2 ? s -> hsub : 0 ; //<S2SV> int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; //<S2SV> int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; //<S2SV> inrow = in -> data [ plane ] ; //<S2SV> outrow = out -> data [ plane ] ; //<S2SV> for ( i = 0 ; i < h ; i ++ ) { //<S2SV> const uint8_t * tab = s -> lut [ plane ] ; //<S2SV> for ( j = 0 ; j < w ; j ++ ) //<S2SV> outrow [ j ] = tab [ inrow [ j ] ] ; //<S2SV> inrow += in -> linesize [ plane ] ; //<S2SV> outrow += out -> linesize [ plane ] ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! direct ) //<S2SV> av_frame_free ( & in ) ; //<S2SV> return ff_filter_frame ( outlink , out ) ; //<S2SV> } //<S2SV> 