static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) //<S2SV> { //<S2SV> DelogoContext * s = inlink -> dst -> priv ; //<S2SV> AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; //<S2SV> const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; //<S2SV> AVFrame * out ; //<S2SV> int hsub0 = desc -> log2_chroma_w ; //<S2SV> int vsub0 = desc -> log2_chroma_h ; //<S2SV> int direct = 0 ; //<S2SV> int plane ; //<S2SV> AVRational sar ; //<S2SV> if ( av_frame_is_writable ( in ) ) { //<S2SV> direct = 1 ; //<S2SV> out = in ; //<S2SV> } else { //<S2SV> out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; //<S2SV> if ( ! out ) { //<S2SV> av_frame_free ( & in ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> av_frame_copy_props ( out , in ) ; //<S2SV> } //<S2SV> sar = in -> sample_aspect_ratio ; //<S2SV> if ( ! sar . num ) //<S2SV> sar . num = sar . den = 1 ; //<S2SV> for ( plane = 0 ; plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ; plane ++ ) { //<S2SV> int hsub = plane == 1 || plane == 2 ? hsub0 : 0 ; //<S2SV> int vsub = plane == 1 || plane == 2 ? vsub0 : 0 ; //<S2SV> apply_delogo ( out -> data [ plane ] , out -> linesize [ plane ] , //<S2SV> in -> data [ plane ] , in -> linesize [ plane ] , //<S2SV> FF_CEIL_RSHIFT ( inlink -> w , hsub ) , //<S2SV> FF_CEIL_RSHIFT ( inlink -> h , vsub ) , //<S2SV> sar , s -> x >> hsub , s -> y >> vsub , //<S2SV> FF_CEIL_RSHIFT ( s -> w + ( s -> x & ( ( 1 << hsub ) - 1 ) ) , hsub ) , //<S2SV> FF_CEIL_RSHIFT ( s -> h + ( s -> y & ( ( 1 << vsub ) - 1 ) ) , vsub ) , //<S2SV> s -> band >> FFMIN ( hsub , vsub ) , //<S2SV> s -> show , direct ) ; //<S2SV> } //<S2SV> if ( ! direct ) //<S2SV> av_frame_free ( & in ) ; //<S2SV> return ff_filter_frame ( outlink , out ) ; //<S2SV> } //<S2SV> 