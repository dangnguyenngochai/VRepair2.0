static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) //<S2SV> { //<S2SV> KerndeintContext * kerndeint = inlink -> dst -> priv ; //<S2SV> AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; //<S2SV> AVFrame * outpic ; //<S2SV> const uint8_t * prvp ; //<S2SV> const uint8_t * prvpp ; //<S2SV> const uint8_t * prvpn ; //<S2SV> const uint8_t * prvppp ; //<S2SV> const uint8_t * prvpnn ; //<S2SV> const uint8_t * prvp4p ; //<S2SV> const uint8_t * prvp4n ; //<S2SV> const uint8_t * srcp ; //<S2SV> const uint8_t * srcpp ; //<S2SV> const uint8_t * srcpn ; //<S2SV> const uint8_t * srcppp ; //<S2SV> const uint8_t * srcpnn ; //<S2SV> const uint8_t * srcp3p ; //<S2SV> const uint8_t * srcp3n ; //<S2SV> const uint8_t * srcp4p ; //<S2SV> const uint8_t * srcp4n ; //<S2SV> uint8_t * dstp , * dstp_saved ; //<S2SV> const uint8_t * srcp_saved ; //<S2SV> int src_linesize , psrc_linesize , dst_linesize , bwidth ; //<S2SV> int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; //<S2SV> double valf ; //<S2SV> const int thresh = kerndeint -> thresh ; //<S2SV> const int order = kerndeint -> order ; //<S2SV> const int map = kerndeint -> map ; //<S2SV> const int sharp = kerndeint -> sharp ; //<S2SV> const int twoway = kerndeint -> twoway ; //<S2SV> const int is_packed_rgb = kerndeint -> is_packed_rgb ; //<S2SV> outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; //<S2SV> if ( ! outpic ) { //<S2SV> av_frame_free ( & inpic ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> av_frame_copy_props ( outpic , inpic ) ; //<S2SV> outpic -> interlaced_frame = 0 ; //<S2SV> for ( plane = 0 ; plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ] ; plane ++ ) { //<S2SV> h = plane == 0 ? inlink -> h : FF_CEIL_RSHIFT ( inlink -> h , kerndeint -> vsub ) ; //<S2SV> bwidth = kerndeint -> tmp_bwidth [ plane ] ; //<S2SV> srcp = srcp_saved = inpic -> data [ plane ] ; //<S2SV> src_linesize = inpic -> linesize [ plane ] ; //<S2SV> psrc_linesize = kerndeint -> tmp_linesize [ plane ] ; //<S2SV> dstp = dstp_saved = outpic -> data [ plane ] ; //<S2SV> dst_linesize = outpic -> linesize [ plane ] ; //<S2SV> srcp = srcp_saved + ( 1 - order ) * src_linesize ; //<S2SV> dstp = dstp_saved + ( 1 - order ) * dst_linesize ; //<S2SV> for ( y = 0 ; y < h ; y += 2 ) { //<S2SV> memcpy ( dstp , srcp , bwidth ) ; //<S2SV> srcp += 2 * src_linesize ; //<S2SV> dstp += 2 * dst_linesize ; //<S2SV> } //<S2SV> memcpy ( dstp_saved + order * dst_linesize , srcp_saved + ( 1 - order ) * src_linesize , bwidth ) ; //<S2SV> memcpy ( dstp_saved + ( 2 + order ) * dst_linesize , srcp_saved + ( 3 - order ) * src_linesize , bwidth ) ; //<S2SV> memcpy ( dstp_saved + ( h - 2 + order ) * dst_linesize , srcp_saved + ( h - 1 - order ) * src_linesize , bwidth ) ; //<S2SV> memcpy ( dstp_saved + ( h - 4 + order ) * dst_linesize , srcp_saved + ( h - 3 - order ) * src_linesize , bwidth ) ; //<S2SV> prvp = kerndeint -> tmp_data [ plane ] + 5 * psrc_linesize - ( 1 - order ) * psrc_linesize ; //<S2SV> prvpp = prvp - psrc_linesize ; //<S2SV> prvppp = prvp - 2 * psrc_linesize ; //<S2SV> prvp4p = prvp - 4 * psrc_linesize ; //<S2SV> prvpn = prvp + psrc_linesize ; //<S2SV> prvpnn = prvp + 2 * psrc_linesize ; //<S2SV> prvp4n = prvp + 4 * psrc_linesize ; //<S2SV> srcp = srcp_saved + 5 * src_linesize - ( 1 - order ) * src_linesize ; //<S2SV> srcpp = srcp - src_linesize ; //<S2SV> srcppp = srcp - 2 * src_linesize ; //<S2SV> srcp3p = srcp - 3 * src_linesize ; //<S2SV> srcp4p = srcp - 4 * src_linesize ; //<S2SV> srcpn = srcp + src_linesize ; //<S2SV> srcpnn = srcp + 2 * src_linesize ; //<S2SV> srcp3n = srcp + 3 * src_linesize ; //<S2SV> srcp4n = srcp + 4 * src_linesize ; //<S2SV> dstp = dstp_saved + 5 * dst_linesize - ( 1 - order ) * dst_linesize ; //<S2SV> for ( y = 5 - ( 1 - order ) ; y <= h - 5 - ( 1 - order ) ; y += 2 ) { //<S2SV> for ( x = 0 ; x < bwidth ; x ++ ) { //<S2SV> if ( thresh == 0 || n == 0 || //<S2SV> ( abs ( ( int ) prvp [ x ] - ( int ) srcp [ x ] ) > thresh ) || //<S2SV> ( abs ( ( int ) prvpp [ x ] - ( int ) srcpp [ x ] ) > thresh ) || //<S2SV> ( abs ( ( int ) prvpn [ x ] - ( int ) srcpn [ x ] ) > thresh ) ) { //<S2SV> if ( map ) { //<S2SV> g = x & ~ 3 ; //<S2SV> if ( is_packed_rgb ) { //<S2SV> AV_WB32 ( dstp + g , 0xffffffff ) ; //<S2SV> x = g + 3 ; //<S2SV> } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { //<S2SV> AV_WB32 ( dstp + g , 0xeb80eb80 ) ; //<S2SV> x = g + 3 ; //<S2SV> } else { //<S2SV> dstp [ x ] = plane == 0 ? 235 : 128 ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( is_packed_rgb ) { //<S2SV> hi = 255 ; //<S2SV> lo = 0 ; //<S2SV> } else if ( inlink -> format == AV_PIX_FMT_YUYV422 ) { //<S2SV> hi = x & 1 ? 240 : 235 ; //<S2SV> lo = 16 ; //<S2SV> } else { //<S2SV> hi = plane == 0 ? 235 : 240 ; //<S2SV> lo = 16 ; //<S2SV> } //<S2SV> if ( sharp ) { //<S2SV> if ( twoway ) { //<S2SV> valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) //<S2SV> + 0.170 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) //<S2SV> - 0.116 * ( ( int ) srcppp [ x ] + ( int ) srcpnn [ x ] + ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) //<S2SV> - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) //<S2SV> + 0.031 * ( ( int ) srcp4p [ x ] + ( int ) srcp4n [ x ] + ( int ) prvp4p [ x ] + ( int ) prvp4n [ x ] ) ; //<S2SV> } else { //<S2SV> valf = + 0.526 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) //<S2SV> + 0.170 * ( ( int ) prvp [ x ] ) //<S2SV> - 0.116 * ( ( int ) prvppp [ x ] + ( int ) prvpnn [ x ] ) //<S2SV> - 0.026 * ( ( int ) srcp3p [ x ] + ( int ) srcp3n [ x ] ) //<S2SV> + 0.031 * ( ( int ) prvp4p [ x ] + ( int ) prvp4p [ x ] ) ; //<S2SV> } //<S2SV> dstp [ x ] = av_clip ( valf , lo , hi ) ; //<S2SV> } else { //<S2SV> if ( twoway ) { //<S2SV> val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) srcp [ x ] + ( int ) prvp [ x ] ) //<S2SV> - ( int ) ( srcppp [ x ] ) - ( int ) ( srcpnn [ x ] ) //<S2SV> - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; //<S2SV> } else { //<S2SV> val = ( 8 * ( ( int ) srcpp [ x ] + ( int ) srcpn [ x ] ) + 2 * ( ( int ) prvp [ x ] ) //<S2SV> - ( int ) ( prvppp [ x ] ) - ( int ) ( prvpnn [ x ] ) ) >> 4 ; //<S2SV> } //<S2SV> dstp [ x ] = av_clip ( val , lo , hi ) ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> dstp [ x ] = srcp [ x ] ; //<S2SV> } //<S2SV> } //<S2SV> prvp += 2 * psrc_linesize ; //<S2SV> prvpp += 2 * psrc_linesize ; //<S2SV> prvppp += 2 * psrc_linesize ; //<S2SV> prvpn += 2 * psrc_linesize ; //<S2SV> prvpnn += 2 * psrc_linesize ; //<S2SV> prvp4p += 2 * psrc_linesize ; //<S2SV> prvp4n += 2 * psrc_linesize ; //<S2SV> srcp += 2 * src_linesize ; //<S2SV> srcpp += 2 * src_linesize ; //<S2SV> srcppp += 2 * src_linesize ; //<S2SV> srcp3p += 2 * src_linesize ; //<S2SV> srcp4p += 2 * src_linesize ; //<S2SV> srcpn += 2 * src_linesize ; //<S2SV> srcpnn += 2 * src_linesize ; //<S2SV> srcp3n += 2 * src_linesize ; //<S2SV> srcp4n += 2 * src_linesize ; //<S2SV> dstp += 2 * dst_linesize ; //<S2SV> } //<S2SV> srcp = inpic -> data [ plane ] ; //<S2SV> dstp = kerndeint -> tmp_data [ plane ] ; //<S2SV> av_image_copy_plane ( dstp , psrc_linesize , srcp , src_linesize , bwidth , h ) ; //<S2SV> } //<S2SV> av_frame_free ( & inpic ) ; //<S2SV> return ff_filter_frame ( outlink , outpic ) ; //<S2SV> } //<S2SV> 