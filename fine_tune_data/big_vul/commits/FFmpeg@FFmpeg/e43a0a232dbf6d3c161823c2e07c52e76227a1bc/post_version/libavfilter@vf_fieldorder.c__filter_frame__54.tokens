static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) //<S2SV> { //<S2SV> AVFilterContext * ctx = inlink -> dst ; //<S2SV> FieldOrderContext * s = ctx -> priv ; //<S2SV> AVFilterLink * outlink = ctx -> outputs [ 0 ] ; //<S2SV> int h , plane , line_step , line_size , line ; //<S2SV> uint8_t * data ; //<S2SV> if ( ! frame -> interlaced_frame || //<S2SV> frame -> top_field_first == s -> dst_tff ) //<S2SV> return ff_filter_frame ( outlink , frame ) ; //<S2SV> av_dlog ( ctx , //<S2SV> "picture<S2SV_blank>will<S2SV_blank>move<S2SV_blank>%s<S2SV_blank>one<S2SV_blank>line\\n" , //<S2SV> s -> dst_tff ? "up" : "down" ) ; //<S2SV> h = frame -> height ; //<S2SV> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ; plane ++ ) { //<S2SV> line_step = frame -> linesize [ plane ] ; //<S2SV> line_size = s -> line_size [ plane ] ; //<S2SV> data = frame -> data [ plane ] ; //<S2SV> if ( s -> dst_tff ) { //<S2SV> for ( line = 0 ; line < h ; line ++ ) { //<S2SV> if ( 1 + line < frame -> height ) { //<S2SV> memcpy ( data , data + line_step , line_size ) ; //<S2SV> } else { //<S2SV> memcpy ( data , data - line_step - line_step , line_size ) ; //<S2SV> } //<S2SV> data += line_step ; //<S2SV> } //<S2SV> } else { //<S2SV> data += ( h - 1 ) * line_step ; //<S2SV> for ( line = h - 1 ; line >= 0 ; line -- ) { //<S2SV> if ( line > 0 ) { //<S2SV> memcpy ( data , data - line_step , line_size ) ; //<S2SV> } else { //<S2SV> memcpy ( data , data + line_step + line_step , line_size ) ; //<S2SV> } //<S2SV> data -= line_step ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> frame -> top_field_first = s -> dst_tff ; //<S2SV> return ff_filter_frame ( outlink , frame ) ; //<S2SV> } //<S2SV> 