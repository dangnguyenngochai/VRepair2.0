static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) //<S2SV> { //<S2SV> GradFunContext * s = inlink -> dst -> priv ; //<S2SV> AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; //<S2SV> AVFrame * out ; //<S2SV> int p , direct ; //<S2SV> if ( av_frame_is_writable ( in ) ) { //<S2SV> direct = 1 ; //<S2SV> out = in ; //<S2SV> } else { //<S2SV> direct = 0 ; //<S2SV> out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; //<S2SV> if ( ! out ) { //<S2SV> av_frame_free ( & in ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> av_frame_copy_props ( out , in ) ; //<S2SV> } //<S2SV> for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) { //<S2SV> int w = inlink -> w ; //<S2SV> int h = inlink -> h ; //<S2SV> int r = s -> radius ; //<S2SV> if ( p ) { //<S2SV> w = s -> chroma_w ; //<S2SV> h = s -> chroma_h ; //<S2SV> r = s -> chroma_r ; //<S2SV> } //<S2SV> if ( FFMIN ( w , h ) > 2 * r ) //<S2SV> filter ( s , out -> data [ p ] , in -> data [ p ] , w , h , out -> linesize [ p ] , in -> linesize [ p ] , r ) ; //<S2SV> else if ( out -> data [ p ] != in -> data [ p ] ) //<S2SV> av_image_copy_plane ( out -> data [ p ] , out -> linesize [ p ] , in -> data [ p ] , in -> linesize [ p ] , w , h ) ; //<S2SV> } //<S2SV> if ( ! direct ) //<S2SV> av_frame_free ( & in ) ; //<S2SV> return ff_filter_frame ( outlink , out ) ; //<S2SV> } //<S2SV> 