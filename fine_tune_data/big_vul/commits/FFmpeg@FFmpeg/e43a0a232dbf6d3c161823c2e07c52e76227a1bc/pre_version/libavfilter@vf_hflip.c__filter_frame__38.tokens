static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) //<S2SV> { //<S2SV> AVFilterContext * ctx = inlink -> dst ; //<S2SV> FlipContext * s = ctx -> priv ; //<S2SV> AVFilterLink * outlink = ctx -> outputs [ 0 ] ; //<S2SV> AVFrame * out ; //<S2SV> uint8_t * inrow , * outrow ; //<S2SV> int i , j , plane , step ; //<S2SV> out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; //<S2SV> if ( ! out ) { //<S2SV> av_frame_free ( & in ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> av_frame_copy_props ( out , in ) ; //<S2SV> if ( av_pix_fmt_desc_get ( inlink -> format ) -> flags & AV_PIX_FMT_FLAG_PAL ) //<S2SV> memcpy ( out -> data [ 1 ] , in -> data [ 1 ] , AVPALETTE_SIZE ) ; //<S2SV> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { //<S2SV> const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ; //<S2SV> const int height = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> h , s -> vsub ) : inlink -> h ; //<S2SV> step = s -> max_step [ plane ] ; //<S2SV> outrow = out -> data [ plane ] ; //<S2SV> inrow = in -> data [ plane ] + ( width - 1 ) * step ; //<S2SV> for ( i = 0 ; i < height ; i ++ ) { //<S2SV> switch ( step ) { //<S2SV> case 1 : //<S2SV> for ( j = 0 ; j < width ; j ++ ) //<S2SV> outrow [ j ] = inrow [ - j ] ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> { //<S2SV> uint16_t * outrow16 = ( uint16_t * ) outrow ; //<S2SV> uint16_t * inrow16 = ( uint16_t * ) inrow ; //<S2SV> for ( j = 0 ; j < width ; j ++ ) //<S2SV> outrow16 [ j ] = inrow16 [ - j ] ; //<S2SV> } //<S2SV> break ; //<S2SV> case 3 : //<S2SV> { //<S2SV> uint8_t * in = inrow ; //<S2SV> uint8_t * out = outrow ; //<S2SV> for ( j = 0 ; j < width ; j ++ , out += 3 , in -= 3 ) { //<S2SV> int32_t v = AV_RB24 ( in ) ; //<S2SV> AV_WB24 ( out , v ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 4 : //<S2SV> { //<S2SV> uint32_t * outrow32 = ( uint32_t * ) outrow ; //<S2SV> uint32_t * inrow32 = ( uint32_t * ) inrow ; //<S2SV> for ( j = 0 ; j < width ; j ++ ) //<S2SV> outrow32 [ j ] = inrow32 [ - j ] ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> for ( j = 0 ; j < width ; j ++ ) //<S2SV> memcpy ( outrow + j * step , inrow - j * step , step ) ; //<S2SV> } //<S2SV> inrow += in -> linesize [ plane ] ; //<S2SV> outrow += out -> linesize [ plane ] ; //<S2SV> } //<S2SV> } //<S2SV> av_frame_free ( & in ) ; //<S2SV> return ff_filter_frame ( outlink , out ) ; //<S2SV> } //<S2SV> 