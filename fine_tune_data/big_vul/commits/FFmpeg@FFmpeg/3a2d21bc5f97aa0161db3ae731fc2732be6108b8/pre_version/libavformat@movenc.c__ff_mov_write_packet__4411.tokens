int ff_mov_write_packet ( AVFormatContext * s , AVPacket * pkt ) //<S2SV> { //<S2SV> MOVMuxContext * mov = s -> priv_data ; //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> MOVTrack * trk = & mov -> tracks [ pkt -> stream_index ] ; //<S2SV> AVCodecParameters * par = trk -> par ; //<S2SV> unsigned int samples_in_chunk = 0 ; //<S2SV> int size = pkt -> size , ret = 0 ; //<S2SV> uint8_t * reformatted_data = NULL ; //<S2SV> ret = check_pkt ( s , pkt ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( mov -> flags & FF_MOV_FLAG_FRAGMENT ) { //<S2SV> int ret ; //<S2SV> if ( mov -> moov_written || mov -> flags & FF_MOV_FLAG_EMPTY_MOOV ) { //<S2SV> if ( mov -> frag_interleave && mov -> fragments > 0 ) { //<S2SV> if ( trk -> entry - trk -> entries_flushed >= mov -> frag_interleave ) { //<S2SV> if ( ( ret = mov_flush_fragment_interleaving ( s , trk ) ) < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! trk -> mdat_buf ) { //<S2SV> if ( ( ret = avio_open_dyn_buf ( & trk -> mdat_buf ) ) < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> pb = trk -> mdat_buf ; //<S2SV> } else { //<S2SV> if ( ! mov -> mdat_buf ) { //<S2SV> if ( ( ret = avio_open_dyn_buf ( & mov -> mdat_buf ) ) < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> pb = mov -> mdat_buf ; //<S2SV> } //<S2SV> } //<S2SV> if ( par -> codec_id == AV_CODEC_ID_AMR_NB ) { //<S2SV> static const uint16_t packed_size [ 16 ] = //<S2SV> { 13 , 14 , 16 , 18 , 20 , 21 , 27 , 32 , 6 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ; //<S2SV> int len = 0 ; //<S2SV> while ( len < size && samples_in_chunk < 100 ) { //<S2SV> len += packed_size [ ( pkt -> data [ len ] >> 3 ) & 0x0F ] ; //<S2SV> samples_in_chunk ++ ; //<S2SV> } //<S2SV> if ( samples_in_chunk > 1 ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>single<S2SV_blank>packet,<S2SV_blank>implement<S2SV_blank>a<S2SV_blank>AVParser<S2SV_blank>for<S2SV_blank>it\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } else if ( par -> codec_id == AV_CODEC_ID_ADPCM_MS || //<S2SV> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ) { //<S2SV> samples_in_chunk = trk -> par -> frame_size ; //<S2SV> } else if ( trk -> sample_size ) //<S2SV> samples_in_chunk = size / trk -> sample_size ; //<S2SV> else //<S2SV> samples_in_chunk = 1 ; //<S2SV> if ( trk -> vos_len == 0 && par -> extradata_size > 0 && //<S2SV> ! TAG_IS_AVCI ( trk -> tag ) && //<S2SV> ( par -> codec_id != AV_CODEC_ID_DNXHD ) ) { //<S2SV> trk -> vos_len = par -> extradata_size ; //<S2SV> trk -> vos_data = av_malloc ( trk -> vos_len ) ; //<S2SV> if ( ! trk -> vos_data ) { //<S2SV> ret = AVERROR ( ENOMEM ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> memcpy ( trk -> vos_data , par -> extradata , trk -> vos_len ) ; //<S2SV> } //<S2SV> if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && //<S2SV> ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { //<S2SV> if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>" //<S2SV> "use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>" //<S2SV> "(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> av_log ( s , AV_LOG_WARNING , "aac<S2SV_blank>bitstream<S2SV_blank>error\\n" ) ; //<S2SV> } //<S2SV> if ( par -> codec_id == AV_CODEC_ID_H264 && trk -> vos_len > 0 && * ( uint8_t * ) trk -> vos_data != 1 && ! TAG_IS_AVCI ( trk -> tag ) ) { //<S2SV> if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) { //<S2SV> ff_avc_parse_nal_units_buf ( pkt -> data , & reformatted_data , //<S2SV> & size ) ; //<S2SV> avio_write ( pb , reformatted_data , size ) ; //<S2SV> } else { //<S2SV> if ( trk -> cenc . aes_ctr ) { //<S2SV> size = ff_mov_cenc_avc_parse_nal_units ( & trk -> cenc , pb , pkt -> data , size ) ; //<S2SV> if ( size < 0 ) { //<S2SV> ret = size ; //<S2SV> goto err ; //<S2SV> } //<S2SV> } else { //<S2SV> size = ff_avc_parse_nal_units ( pb , pkt -> data , pkt -> size ) ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( par -> codec_id == AV_CODEC_ID_HEVC && trk -> vos_len > 6 && //<S2SV> ( AV_RB24 ( trk -> vos_data ) == 1 || AV_RB32 ( trk -> vos_data ) == 1 ) ) { //<S2SV> if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) { //<S2SV> ff_hevc_annexb2mp4_buf ( pkt -> data , & reformatted_data , & size , 0 , NULL ) ; //<S2SV> avio_write ( pb , reformatted_data , size ) ; //<S2SV> } else { //<S2SV> size = ff_hevc_annexb2mp4 ( pb , pkt -> data , pkt -> size , 0 , NULL ) ; //<S2SV> } //<S2SV> # if CONFIG_AC3_PARSER //<S2SV> } else if ( par -> codec_id == AV_CODEC_ID_EAC3 ) { //<S2SV> size = handle_eac3 ( mov , pkt , trk ) ; //<S2SV> if ( size < 0 ) //<S2SV> return size ; //<S2SV> else if ( ! size ) //<S2SV> goto end ; //<S2SV> avio_write ( pb , pkt -> data , size ) ; //<S2SV> # endif //<S2SV> } else { //<S2SV> if ( trk -> cenc . aes_ctr ) { //<S2SV> if ( par -> codec_id == AV_CODEC_ID_H264 && par -> extradata_size > 4 ) { //<S2SV> int nal_size_length = ( par -> extradata [ 4 ] & 0x3 ) + 1 ; //<S2SV> ret = ff_mov_cenc_avc_write_nal_units ( s , & trk -> cenc , nal_size_length , pb , pkt -> data , size ) ; //<S2SV> } else { //<S2SV> ret = ff_mov_cenc_write_packet ( & trk -> cenc , pb , pkt -> data , size ) ; //<S2SV> } //<S2SV> if ( ret ) { //<S2SV> goto err ; //<S2SV> } //<S2SV> } else { //<S2SV> avio_write ( pb , pkt -> data , size ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( par -> codec_id == AV_CODEC_ID_DNXHD || //<S2SV> par -> codec_id == AV_CODEC_ID_AC3 ) && ! trk -> vos_len ) { //<S2SV> trk -> vos_len = size ; //<S2SV> trk -> vos_data = av_malloc ( size ) ; //<S2SV> if ( ! trk -> vos_data ) { //<S2SV> ret = AVERROR ( ENOMEM ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> memcpy ( trk -> vos_data , pkt -> data , size ) ; //<S2SV> } //<S2SV> if ( trk -> entry >= trk -> cluster_capacity ) { //<S2SV> unsigned new_capacity = 2 * ( trk -> entry + MOV_INDEX_CLUSTER_SIZE ) ; //<S2SV> if ( av_reallocp_array ( & trk -> cluster , new_capacity , //<S2SV> sizeof ( * trk -> cluster ) ) ) { //<S2SV> ret = AVERROR ( ENOMEM ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> trk -> cluster_capacity = new_capacity ; //<S2SV> } //<S2SV> trk -> cluster [ trk -> entry ] . pos = avio_tell ( pb ) - size ; //<S2SV> trk -> cluster [ trk -> entry ] . samples_in_chunk = samples_in_chunk ; //<S2SV> trk -> cluster [ trk -> entry ] . chunkNum = 0 ; //<S2SV> trk -> cluster [ trk -> entry ] . size = size ; //<S2SV> trk -> cluster [ trk -> entry ] . entries = samples_in_chunk ; //<S2SV> trk -> cluster [ trk -> entry ] . dts = pkt -> dts ; //<S2SV> trk -> cluster [ trk -> entry ] . pts = pkt -> pts ; //<S2SV> if ( ! trk -> entry && trk -> start_dts != AV_NOPTS_VALUE ) { //<S2SV> if ( ! trk -> frag_discont ) { //<S2SV> trk -> cluster [ trk -> entry ] . dts = trk -> start_dts + trk -> track_duration ; //<S2SV> if ( ( mov -> flags & FF_MOV_FLAG_DASH && ! ( mov -> flags & FF_MOV_FLAG_GLOBAL_SIDX ) ) || //<S2SV> mov -> mode == MODE_ISM ) //<S2SV> pkt -> pts = pkt -> dts + trk -> end_pts - trk -> cluster [ trk -> entry ] . dts ; //<S2SV> } else { //<S2SV> trk -> frag_start = pkt -> dts - trk -> start_dts ; //<S2SV> trk -> end_pts = AV_NOPTS_VALUE ; //<S2SV> trk -> frag_discont = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! trk -> entry && trk -> start_dts == AV_NOPTS_VALUE && ! mov -> use_editlist && //<S2SV> s -> avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO ) { //<S2SV> trk -> cluster [ trk -> entry ] . dts = trk -> start_dts = 0 ; //<S2SV> } //<S2SV> if ( trk -> start_dts == AV_NOPTS_VALUE ) { //<S2SV> trk -> start_dts = pkt -> dts ; //<S2SV> if ( trk -> frag_discont ) { //<S2SV> if ( mov -> use_editlist ) { //<S2SV> trk -> frag_start = pkt -> pts ; //<S2SV> trk -> start_dts = pkt -> dts - pkt -> pts ; //<S2SV> } else { //<S2SV> trk -> frag_start = pkt -> dts ; //<S2SV> trk -> start_dts = 0 ; //<S2SV> } //<S2SV> trk -> frag_discont = 0 ; //<S2SV> } else if ( pkt -> dts && mov -> moov_written ) //<S2SV> av_log ( s , AV_LOG_WARNING , //<S2SV> "Track<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>with<S2SV_blank>a<S2SV_blank>nonzero<S2SV_blank>dts<S2SV_blank>%" PRId64 ",<S2SV_blank>while<S2SV_blank>the<S2SV_blank>moov<S2SV_blank>" //<S2SV> "already<S2SV_blank>has<S2SV_blank>been<S2SV_blank>written.<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>delay_moov<S2SV_blank>flag<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>" //<S2SV> "this<S2SV_blank>case.\\n" , //<S2SV> pkt -> stream_index , pkt -> dts ) ; //<S2SV> } //<S2SV> trk -> track_duration = pkt -> dts - trk -> start_dts + pkt -> duration ; //<S2SV> trk -> last_sample_is_subtitle_end = 0 ; //<S2SV> if ( pkt -> pts == AV_NOPTS_VALUE ) { //<S2SV> av_log ( s , AV_LOG_WARNING , "pts<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value\\n" ) ; //<S2SV> pkt -> pts = pkt -> dts ; //<S2SV> } //<S2SV> if ( pkt -> dts != pkt -> pts ) //<S2SV> trk -> flags |= MOV_TRACK_CTTS ; //<S2SV> trk -> cluster [ trk -> entry ] . cts = pkt -> pts - pkt -> dts ; //<S2SV> trk -> cluster [ trk -> entry ] . flags = 0 ; //<S2SV> if ( trk -> start_cts == AV_NOPTS_VALUE ) //<S2SV> trk -> start_cts = pkt -> pts - pkt -> dts ; //<S2SV> if ( trk -> end_pts == AV_NOPTS_VALUE ) //<S2SV> trk -> end_pts = trk -> cluster [ trk -> entry ] . dts + //<S2SV> trk -> cluster [ trk -> entry ] . cts + pkt -> duration ; //<S2SV> else //<S2SV> trk -> end_pts = FFMAX ( trk -> end_pts , trk -> cluster [ trk -> entry ] . dts + //<S2SV> trk -> cluster [ trk -> entry ] . cts + //<S2SV> pkt -> duration ) ; //<S2SV> if ( par -> codec_id == AV_CODEC_ID_VC1 ) { //<S2SV> mov_parse_vc1_frame ( pkt , trk ) ; //<S2SV> } else if ( pkt -> flags & AV_PKT_FLAG_KEY ) { //<S2SV> if ( mov -> mode == MODE_MOV && par -> codec_id == AV_CODEC_ID_MPEG2VIDEO && //<S2SV> trk -> entry > 0 ) { //<S2SV> mov_parse_mpeg2_frame ( pkt , & trk -> cluster [ trk -> entry ] . flags ) ; //<S2SV> if ( trk -> cluster [ trk -> entry ] . flags & MOV_PARTIAL_SYNC_SAMPLE ) //<S2SV> trk -> flags |= MOV_TRACK_STPS ; //<S2SV> } else { //<S2SV> trk -> cluster [ trk -> entry ] . flags = MOV_SYNC_SAMPLE ; //<S2SV> } //<S2SV> if ( trk -> cluster [ trk -> entry ] . flags & MOV_SYNC_SAMPLE ) //<S2SV> trk -> has_keyframes ++ ; //<S2SV> } //<S2SV> if ( pkt -> flags & AV_PKT_FLAG_DISPOSABLE ) { //<S2SV> trk -> cluster [ trk -> entry ] . flags |= MOV_DISPOSABLE_SAMPLE ; //<S2SV> trk -> has_disposable ++ ; //<S2SV> } //<S2SV> trk -> entry ++ ; //<S2SV> trk -> sample_count += samples_in_chunk ; //<S2SV> mov -> mdat_size += size ; //<S2SV> if ( trk -> hint_track >= 0 && trk -> hint_track < mov -> nb_streams ) //<S2SV> ff_mov_add_hinted_packet ( s , pkt , trk -> hint_track , trk -> entry , //<S2SV> reformatted_data , size ) ; //<S2SV> end : //<S2SV> err : //<S2SV> av_free ( reformatted_data ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 