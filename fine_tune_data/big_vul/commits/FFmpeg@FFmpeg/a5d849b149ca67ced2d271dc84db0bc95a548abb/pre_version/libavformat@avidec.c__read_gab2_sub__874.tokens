static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) //<S2SV> { //<S2SV> if ( pkt -> size >= 7 && //<S2SV> pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && //<S2SV> ! strcmp ( pkt -> data , "GAB2" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) { //<S2SV> uint8_t desc [ 256 ] ; //<S2SV> int score = AVPROBE_SCORE_EXTENSION , ret ; //<S2SV> AVIStream * ast = st -> priv_data ; //<S2SV> AVInputFormat * sub_demuxer ; //<S2SV> AVRational time_base ; //<S2SV> int size ; //<S2SV> AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , //<S2SV> pkt -> size - 7 , //<S2SV> 0 , NULL , NULL , NULL , NULL ) ; //<S2SV> AVProbeData pd ; //<S2SV> unsigned int desc_len = avio_rl32 ( pb ) ; //<S2SV> if ( desc_len > pb -> buf_end - pb -> buf_ptr ) //<S2SV> goto error ; //<S2SV> ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ; //<S2SV> avio_skip ( pb , desc_len - ret ) ; //<S2SV> if ( * desc ) //<S2SV> av_dict_set ( & st -> metadata , "title" , desc , 0 ) ; //<S2SV> avio_rl16 ( pb ) ; //<S2SV> avio_rl32 ( pb ) ; //<S2SV> size = pb -> buf_end - pb -> buf_ptr ; //<S2SV> pd = ( AVProbeData ) { . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , //<S2SV> . buf_size = size } ; //<S2SV> if ( ! pd . buf ) //<S2SV> goto error ; //<S2SV> memcpy ( pd . buf , pb -> buf_ptr , size ) ; //<S2SV> sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ; //<S2SV> av_freep ( & pd . buf ) ; //<S2SV> if ( ! sub_demuxer ) //<S2SV> goto error ; //<S2SV> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) //<S2SV> goto error ; //<S2SV> ast -> sub_ctx -> pb = pb ; //<S2SV> if ( ff_copy_whiteblacklists ( ast -> sub_ctx , s ) < 0 ) //<S2SV> goto error ; //<S2SV> if ( ! avformat_open_input ( & ast -> sub_ctx , "" , sub_demuxer , NULL ) ) { //<S2SV> if ( ast -> sub_ctx -> nb_streams != 1 ) //<S2SV> goto error ; //<S2SV> ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) ; //<S2SV> avcodec_parameters_copy ( st -> codecpar , ast -> sub_ctx -> streams [ 0 ] -> codecpar ) ; //<S2SV> time_base = ast -> sub_ctx -> streams [ 0 ] -> time_base ; //<S2SV> avpriv_set_pts_info ( st , 64 , time_base . num , time_base . den ) ; //<S2SV> } //<S2SV> ast -> sub_buffer = pkt -> data ; //<S2SV> memset ( pkt , 0 , sizeof ( * pkt ) ) ; //<S2SV> return 1 ; //<S2SV> error : //<S2SV> av_freep ( & ast -> sub_ctx ) ; //<S2SV> av_freep ( & pb ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 