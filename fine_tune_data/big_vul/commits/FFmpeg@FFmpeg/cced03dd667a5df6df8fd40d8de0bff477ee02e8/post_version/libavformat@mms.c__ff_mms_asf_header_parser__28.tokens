int ff_mms_asf_header_parser ( MMSContext * mms ) //<S2SV> { //<S2SV> uint8_t * p = mms -> asf_header ; //<S2SV> uint8_t * end ; //<S2SV> int flags , stream_id ; //<S2SV> mms -> stream_num = 0 ; //<S2SV> if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || //<S2SV> memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { //<S2SV> av_log ( NULL , AV_LOG_ERROR , //<S2SV> "Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\n" , //<S2SV> mms -> asf_header_size ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> end = mms -> asf_header + mms -> asf_header_size ; //<S2SV> p += sizeof ( ff_asf_guid ) + 14 ; //<S2SV> while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { //<S2SV> uint64_t chunksize ; //<S2SV> if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { //<S2SV> chunksize = 50 ; //<S2SV> } else { //<S2SV> chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; //<S2SV> } //<S2SV> if ( ! chunksize || chunksize > end - p ) { //<S2SV> av_log ( NULL , AV_LOG_ERROR , //<S2SV> "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , //<S2SV> chunksize ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { //<S2SV> if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { //<S2SV> mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; //<S2SV> if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { //<S2SV> av_log ( NULL , AV_LOG_ERROR , //<S2SV> "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\n" , //<S2SV> mms -> asf_packet_len ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { //<S2SV> if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { //<S2SV> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; //<S2SV> stream_id = flags & 0x7F ; //<S2SV> if ( mms -> stream_num < MMS_MAX_STREAMS && //<S2SV> 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { //<S2SV> mms -> streams = av_fast_realloc ( mms -> streams , //<S2SV> & mms -> nb_streams_allocated , //<S2SV> ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; //<S2SV> if ( ! mms -> streams ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> mms -> streams [ mms -> stream_num ] . id = stream_id ; //<S2SV> mms -> stream_num ++ ; //<S2SV> } else { //<S2SV> av_log ( NULL , AV_LOG_ERROR , //<S2SV> "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { //<S2SV> if ( end - p >= 88 ) { //<S2SV> int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; //<S2SV> uint64_t skip_bytes = 88 ; //<S2SV> while ( stream_count -- ) { //<S2SV> if ( end - p < skip_bytes + 4 ) { //<S2SV> av_log ( NULL , AV_LOG_ERROR , //<S2SV> "Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; //<S2SV> } //<S2SV> while ( ext_len_count -- ) { //<S2SV> if ( end - p < skip_bytes + 22 ) { //<S2SV> av_log ( NULL , AV_LOG_ERROR , //<S2SV> "Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; //<S2SV> } //<S2SV> if ( end - p < skip_bytes ) { //<S2SV> av_log ( NULL , AV_LOG_ERROR , //<S2SV> "Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( chunksize - skip_bytes > 24 ) //<S2SV> chunksize = skip_bytes ; //<S2SV> } //<S2SV> } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { //<S2SV> chunksize = 46 ; //<S2SV> if ( chunksize > end - p ) { //<S2SV> av_log ( NULL , AV_LOG_ERROR , //<S2SV> "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , //<S2SV> chunksize ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> p += chunksize ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 