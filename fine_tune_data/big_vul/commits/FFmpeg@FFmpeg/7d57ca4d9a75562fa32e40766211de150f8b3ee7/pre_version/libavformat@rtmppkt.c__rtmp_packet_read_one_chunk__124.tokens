static int rtmp_packet_read_one_chunk ( URLContext * h , RTMPPacket * p , //<S2SV> int chunk_size , RTMPPacket * * prev_pkt_ptr , //<S2SV> int * nb_prev_pkt , uint8_t hdr ) //<S2SV> { //<S2SV> uint8_t buf [ 16 ] ; //<S2SV> int channel_id , timestamp , size ; //<S2SV> uint32_t ts_field ; //<S2SV> uint32_t extra = 0 ; //<S2SV> enum RTMPPacketType type ; //<S2SV> int written = 0 ; //<S2SV> int ret , toread ; //<S2SV> RTMPPacket * prev_pkt ; //<S2SV> written ++ ; //<S2SV> channel_id = hdr & 0x3F ; //<S2SV> if ( channel_id < 2 ) { //<S2SV> buf [ 1 ] = 0 ; //<S2SV> if ( ffurl_read_complete ( h , buf , channel_id + 1 ) != channel_id + 1 ) //<S2SV> return AVERROR ( EIO ) ; //<S2SV> written += channel_id + 1 ; //<S2SV> channel_id = AV_RL16 ( buf ) + 64 ; //<S2SV> } //<S2SV> if ( ( ret = ff_rtmp_check_alloc_array ( prev_pkt_ptr , nb_prev_pkt , //<S2SV> channel_id ) ) < 0 ) //<S2SV> return ret ; //<S2SV> prev_pkt = * prev_pkt_ptr ; //<S2SV> size = prev_pkt [ channel_id ] . size ; //<S2SV> type = prev_pkt [ channel_id ] . type ; //<S2SV> extra = prev_pkt [ channel_id ] . extra ; //<S2SV> hdr >>= 6 ; //<S2SV> if ( hdr == RTMP_PS_ONEBYTE ) { //<S2SV> ts_field = prev_pkt [ channel_id ] . ts_field ; //<S2SV> } else { //<S2SV> if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) //<S2SV> return AVERROR ( EIO ) ; //<S2SV> written += 3 ; //<S2SV> ts_field = AV_RB24 ( buf ) ; //<S2SV> if ( hdr != RTMP_PS_FOURBYTES ) { //<S2SV> if ( ffurl_read_complete ( h , buf , 3 ) != 3 ) //<S2SV> return AVERROR ( EIO ) ; //<S2SV> written += 3 ; //<S2SV> size = AV_RB24 ( buf ) ; //<S2SV> if ( ffurl_read_complete ( h , buf , 1 ) != 1 ) //<S2SV> return AVERROR ( EIO ) ; //<S2SV> written ++ ; //<S2SV> type = buf [ 0 ] ; //<S2SV> if ( hdr == RTMP_PS_TWELVEBYTES ) { //<S2SV> if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) //<S2SV> return AVERROR ( EIO ) ; //<S2SV> written += 4 ; //<S2SV> extra = AV_RL32 ( buf ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ts_field == 0xFFFFFF ) { //<S2SV> if ( ffurl_read_complete ( h , buf , 4 ) != 4 ) //<S2SV> return AVERROR ( EIO ) ; //<S2SV> timestamp = AV_RB32 ( buf ) ; //<S2SV> } else { //<S2SV> timestamp = ts_field ; //<S2SV> } //<S2SV> if ( hdr != RTMP_PS_TWELVEBYTES ) //<S2SV> timestamp += prev_pkt [ channel_id ] . timestamp ; //<S2SV> if ( ! prev_pkt [ channel_id ] . read ) { //<S2SV> if ( ( ret = ff_rtmp_packet_create ( p , channel_id , type , timestamp , //<S2SV> size ) ) < 0 ) //<S2SV> return ret ; //<S2SV> p -> read = written ; //<S2SV> p -> offset = 0 ; //<S2SV> prev_pkt [ channel_id ] . ts_field = ts_field ; //<S2SV> prev_pkt [ channel_id ] . timestamp = timestamp ; //<S2SV> } else { //<S2SV> RTMPPacket * prev = & prev_pkt [ channel_id ] ; //<S2SV> p -> data = prev -> data ; //<S2SV> p -> size = prev -> size ; //<S2SV> p -> channel_id = prev -> channel_id ; //<S2SV> p -> type = prev -> type ; //<S2SV> p -> ts_field = prev -> ts_field ; //<S2SV> p -> extra = prev -> extra ; //<S2SV> p -> offset = prev -> offset ; //<S2SV> p -> read = prev -> read + written ; //<S2SV> p -> timestamp = prev -> timestamp ; //<S2SV> prev -> data = NULL ; //<S2SV> } //<S2SV> p -> extra = extra ; //<S2SV> prev_pkt [ channel_id ] . channel_id = channel_id ; //<S2SV> prev_pkt [ channel_id ] . type = type ; //<S2SV> prev_pkt [ channel_id ] . size = size ; //<S2SV> prev_pkt [ channel_id ] . extra = extra ; //<S2SV> size = size - p -> offset ; //<S2SV> toread = FFMIN ( size , chunk_size ) ; //<S2SV> if ( ffurl_read_complete ( h , p -> data + p -> offset , toread ) != toread ) { //<S2SV> ff_rtmp_packet_destroy ( p ) ; //<S2SV> return AVERROR ( EIO ) ; //<S2SV> } //<S2SV> size -= toread ; //<S2SV> p -> read += toread ; //<S2SV> p -> offset += toread ; //<S2SV> if ( size > 0 ) { //<S2SV> RTMPPacket * prev = & prev_pkt [ channel_id ] ; //<S2SV> prev -> data = p -> data ; //<S2SV> prev -> read = p -> read ; //<S2SV> prev -> offset = p -> offset ; //<S2SV> p -> data = NULL ; //<S2SV> return AVERROR ( EAGAIN ) ; //<S2SV> } //<S2SV> prev_pkt [ channel_id ] . read = 0 ; //<S2SV> return p -> read ; //<S2SV> } //<S2SV> 