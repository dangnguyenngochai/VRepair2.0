static void rpza_decode_stream ( RpzaContext * s ) //<S2SV> { //<S2SV> int width = s -> avctx -> width ; //<S2SV> int stride = s -> frame . linesize [ 0 ] / 2 ; //<S2SV> int row_inc = stride - 4 ; //<S2SV> int stream_ptr = 0 ; //<S2SV> int chunk_size ; //<S2SV> unsigned char opcode ; //<S2SV> int n_blocks ; //<S2SV> unsigned short colorA = 0 , colorB ; //<S2SV> unsigned short color4 [ 4 ] ; //<S2SV> unsigned char index , idx ; //<S2SV> unsigned short ta , tb ; //<S2SV> unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; //<S2SV> int row_ptr = 0 ; //<S2SV> int pixel_ptr = 0 ; //<S2SV> int block_ptr ; //<S2SV> int pixel_x , pixel_y ; //<S2SV> int total_blocks ; //<S2SV> if ( s -> buf [ stream_ptr ] != 0xe1 ) //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "First<S2SV_blank>chunk<S2SV_blank>byte<S2SV_blank>is<S2SV_blank>0x%02x<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>0xe1\\n" , //<S2SV> s -> buf [ stream_ptr ] ) ; //<S2SV> chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; //<S2SV> stream_ptr += 4 ; //<S2SV> if ( chunk_size != s -> size ) //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "MOV<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>!=<S2SV_blank>encoded<S2SV_blank>chunk<S2SV_blank>size;<S2SV_blank>using<S2SV_blank>MOV<S2SV_blank>chunk<S2SV_blank>size\\n" ) ; //<S2SV> chunk_size = s -> size ; //<S2SV> total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; //<S2SV> while ( stream_ptr < chunk_size ) { //<S2SV> opcode = s -> buf [ stream_ptr ++ ] ; //<S2SV> n_blocks = ( opcode & 0x1f ) + 1 ; //<S2SV> if ( ( opcode & 0x80 ) == 0 ) { //<S2SV> colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] ) ; //<S2SV> opcode = 0 ; //<S2SV> if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 ) { //<S2SV> opcode = 0x20 ; //<S2SV> n_blocks = 1 ; //<S2SV> } //<S2SV> } //<S2SV> switch ( opcode & 0xe0 ) { //<S2SV> case 0x80 : //<S2SV> while ( n_blocks -- ) { //<S2SV> ADVANCE_BLOCK ( ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0xa0 : //<S2SV> colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; //<S2SV> stream_ptr += 2 ; //<S2SV> while ( n_blocks -- ) { //<S2SV> block_ptr = row_ptr + pixel_ptr ; //<S2SV> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { //<S2SV> for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { //<S2SV> pixels [ block_ptr ] = colorA ; //<S2SV> block_ptr ++ ; //<S2SV> } //<S2SV> block_ptr += row_inc ; //<S2SV> } //<S2SV> ADVANCE_BLOCK ( ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0xc0 : //<S2SV> colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; //<S2SV> stream_ptr += 2 ; //<S2SV> case 0x20 : //<S2SV> colorB = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; //<S2SV> stream_ptr += 2 ; //<S2SV> color4 [ 0 ] = colorB ; //<S2SV> color4 [ 1 ] = 0 ; //<S2SV> color4 [ 2 ] = 0 ; //<S2SV> color4 [ 3 ] = colorA ; //<S2SV> ta = ( colorA >> 10 ) & 0x1F ; //<S2SV> tb = ( colorB >> 10 ) & 0x1F ; //<S2SV> color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 10 ; //<S2SV> color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 10 ; //<S2SV> ta = ( colorA >> 5 ) & 0x1F ; //<S2SV> tb = ( colorB >> 5 ) & 0x1F ; //<S2SV> color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) << 5 ; //<S2SV> color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) << 5 ; //<S2SV> ta = colorA & 0x1F ; //<S2SV> tb = colorB & 0x1F ; //<S2SV> color4 [ 1 ] |= ( ( 11 * ta + 21 * tb ) >> 5 ) ; //<S2SV> color4 [ 2 ] |= ( ( 21 * ta + 11 * tb ) >> 5 ) ; //<S2SV> if ( s -> size - stream_ptr < n_blocks * 4 ) //<S2SV> return ; //<S2SV> while ( n_blocks -- ) { //<S2SV> block_ptr = row_ptr + pixel_ptr ; //<S2SV> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { //<S2SV> index = s -> buf [ stream_ptr ++ ] ; //<S2SV> for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { //<S2SV> idx = ( index >> ( 2 * ( 3 - pixel_x ) ) ) & 0x03 ; //<S2SV> pixels [ block_ptr ] = color4 [ idx ] ; //<S2SV> block_ptr ++ ; //<S2SV> } //<S2SV> block_ptr += row_inc ; //<S2SV> } //<S2SV> ADVANCE_BLOCK ( ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0x00 : //<S2SV> if ( s -> size - stream_ptr < 16 ) //<S2SV> return ; //<S2SV> block_ptr = row_ptr + pixel_ptr ; //<S2SV> for ( pixel_y = 0 ; pixel_y < 4 ; pixel_y ++ ) { //<S2SV> for ( pixel_x = 0 ; pixel_x < 4 ; pixel_x ++ ) { //<S2SV> if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) ) { //<S2SV> colorA = AV_RB16 ( & s -> buf [ stream_ptr ] ) ; //<S2SV> stream_ptr += 2 ; //<S2SV> } //<S2SV> pixels [ block_ptr ] = colorA ; //<S2SV> block_ptr ++ ; //<S2SV> } //<S2SV> block_ptr += row_inc ; //<S2SV> } //<S2SV> ADVANCE_BLOCK ( ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>opcode<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>rpza<S2SV_blank>chunk." //<S2SV> "<S2SV_blank>Skip<S2SV_blank>remaining<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>chunk<S2SV_blank>data.\\n" , opcode , //<S2SV> chunk_size - stream_ptr ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 