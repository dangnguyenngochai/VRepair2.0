static int flv_write_packet ( AVFormatContext * s , AVPacket * pkt ) //<S2SV> { //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> AVCodecParameters * par = s -> streams [ pkt -> stream_index ] -> codecpar ; //<S2SV> FLVContext * flv = s -> priv_data ; //<S2SV> FLVStreamContext * sc = s -> streams [ pkt -> stream_index ] -> priv_data ; //<S2SV> unsigned ts ; //<S2SV> int size = pkt -> size ; //<S2SV> uint8_t * data = NULL ; //<S2SV> int flags = - 1 , flags_size , ret ; //<S2SV> int64_t cur_offset = avio_tell ( pb ) ; //<S2SV> if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A || //<S2SV> par -> codec_id == AV_CODEC_ID_VP6 || par -> codec_id == AV_CODEC_ID_AAC ) //<S2SV> flags_size = 2 ; //<S2SV> else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) //<S2SV> flags_size = 5 ; //<S2SV> else //<S2SV> flags_size = 1 ; //<S2SV> if ( par -> codec_id == AV_CODEC_ID_AAC || par -> codec_id == AV_CODEC_ID_H264 //<S2SV> || par -> codec_id == AV_CODEC_ID_MPEG4 ) { //<S2SV> int side_size = 0 ; //<S2SV> uint8_t * side = av_packet_get_side_data ( pkt , AV_PKT_DATA_NEW_EXTRADATA , & side_size ) ; //<S2SV> if ( side && side_size > 0 && ( side_size != par -> extradata_size || memcmp ( side , par -> extradata , side_size ) ) ) { //<S2SV> av_free ( par -> extradata ) ; //<S2SV> par -> extradata = av_mallocz ( side_size + AV_INPUT_BUFFER_PADDING_SIZE ) ; //<S2SV> if ( ! par -> extradata ) { //<S2SV> par -> extradata_size = 0 ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> memcpy ( par -> extradata , side , side_size ) ; //<S2SV> par -> extradata_size = side_size ; //<S2SV> flv_write_codec_header ( s , par , pkt -> dts ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( flv -> delay == AV_NOPTS_VALUE ) //<S2SV> flv -> delay = - pkt -> dts ; //<S2SV> if ( pkt -> dts < - flv -> delay ) { //<S2SV> av_log ( s , AV_LOG_WARNING , //<S2SV> "Packets<S2SV_blank>are<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>proper<S2SV_blank>order<S2SV_blank>with<S2SV_blank>respect<S2SV_blank>to<S2SV_blank>DTS\\n" ) ; //<S2SV> return AVERROR ( EINVAL ) ; //<S2SV> } //<S2SV> ts = pkt -> dts ; //<S2SV> if ( s -> event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED ) { //<S2SV> write_metadata ( s , ts ) ; //<S2SV> s -> event_flags &= ~ AVSTREAM_EVENT_FLAG_METADATA_UPDATED ; //<S2SV> } //<S2SV> avio_write_marker ( pb , av_rescale ( ts , AV_TIME_BASE , 1000 ) , //<S2SV> pkt -> flags & AV_PKT_FLAG_KEY && ( flv -> video_par ? par -> codec_type == AVMEDIA_TYPE_VIDEO : 1 ) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT ) ; //<S2SV> switch ( par -> codec_type ) { //<S2SV> case AVMEDIA_TYPE_VIDEO : //<S2SV> avio_w8 ( pb , FLV_TAG_TYPE_VIDEO ) ; //<S2SV> flags = ff_codec_get_tag ( flv_video_codec_ids , par -> codec_id ) ; //<S2SV> flags |= pkt -> flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER ; //<S2SV> break ; //<S2SV> case AVMEDIA_TYPE_AUDIO : //<S2SV> flags = get_audio_flags ( s , par ) ; //<S2SV> av_assert0 ( size ) ; //<S2SV> avio_w8 ( pb , FLV_TAG_TYPE_AUDIO ) ; //<S2SV> break ; //<S2SV> case AVMEDIA_TYPE_SUBTITLE : //<S2SV> case AVMEDIA_TYPE_DATA : //<S2SV> avio_w8 ( pb , FLV_TAG_TYPE_META ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> return AVERROR ( EINVAL ) ; //<S2SV> } //<S2SV> if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { //<S2SV> if ( par -> extradata_size > 0 && * ( uint8_t * ) par -> extradata != 1 ) //<S2SV> if ( ( ret = ff_avc_parse_nal_units_buf ( pkt -> data , & data , & size ) ) < 0 ) //<S2SV> return ret ; //<S2SV> } else if ( par -> codec_id == AV_CODEC_ID_AAC && pkt -> size > 2 && //<S2SV> ( AV_RB16 ( pkt -> data ) & 0xfff0 ) == 0xfff0 ) { //<S2SV> if ( ! s -> streams [ pkt -> stream_index ] -> nb_frames ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "Malformed<S2SV_blank>AAC<S2SV_blank>bitstream<S2SV_blank>detected:<S2SV_blank>" //<S2SV> "use<S2SV_blank>the<S2SV_blank>audio<S2SV_blank>bitstream<S2SV_blank>filter<S2SV_blank>\'aac_adtstoasc\'<S2SV_blank>to<S2SV_blank>fix<S2SV_blank>it<S2SV_blank>" //<S2SV> "(\'-bsf:a<S2SV_blank>aac_adtstoasc\'<S2SV_blank>option<S2SV_blank>with<S2SV_blank>ffmpeg)\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> av_log ( s , AV_LOG_WARNING , "aac<S2SV_blank>bitstream<S2SV_blank>error\\n" ) ; //<S2SV> } //<S2SV> if ( par -> codec_id == AV_CODEC_ID_SPEEX && ts - sc -> last_ts > 160 ) //<S2SV> av_log ( s , AV_LOG_WARNING , "Warning:<S2SV_blank>Speex<S2SV_blank>stream<S2SV_blank>has<S2SV_blank>more<S2SV_blank>than<S2SV_blank>" //<S2SV> "8<S2SV_blank>frames<S2SV_blank>per<S2SV_blank>packet.<S2SV_blank>Adobe<S2SV_blank>Flash<S2SV_blank>" //<S2SV> "Player<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>this!\\n" ) ; //<S2SV> if ( sc -> last_ts < ts ) //<S2SV> sc -> last_ts = ts ; //<S2SV> if ( size + flags_size >= 1 << 24 ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "Too<S2SV_blank>large<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>>=<S2SV_blank>%u\\n" , //<S2SV> size + flags_size , 1 << 24 ) ; //<S2SV> return AVERROR ( EINVAL ) ; //<S2SV> } //<S2SV> avio_wb24 ( pb , size + flags_size ) ; //<S2SV> put_timestamp ( pb , ts ) ; //<S2SV> avio_wb24 ( pb , flv -> reserved ) ; //<S2SV> if ( par -> codec_type == AVMEDIA_TYPE_DATA || //<S2SV> par -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { //<S2SV> int data_size ; //<S2SV> int64_t metadata_size_pos = avio_tell ( pb ) ; //<S2SV> if ( par -> codec_id == AV_CODEC_ID_TEXT ) { //<S2SV> avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; //<S2SV> put_amf_string ( pb , "onTextData" ) ; //<S2SV> avio_w8 ( pb , AMF_DATA_TYPE_MIXEDARRAY ) ; //<S2SV> avio_wb32 ( pb , 2 ) ; //<S2SV> put_amf_string ( pb , "type" ) ; //<S2SV> avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; //<S2SV> put_amf_string ( pb , "Text" ) ; //<S2SV> put_amf_string ( pb , "text" ) ; //<S2SV> avio_w8 ( pb , AMF_DATA_TYPE_STRING ) ; //<S2SV> put_amf_string ( pb , pkt -> data ) ; //<S2SV> put_amf_string ( pb , "" ) ; //<S2SV> avio_w8 ( pb , AMF_END_OF_OBJECT ) ; //<S2SV> } else { //<S2SV> avio_write ( pb , data ? data : pkt -> data , size ) ; //<S2SV> } //<S2SV> data_size = avio_tell ( pb ) - metadata_size_pos ; //<S2SV> avio_seek ( pb , metadata_size_pos - 10 , SEEK_SET ) ; //<S2SV> avio_wb24 ( pb , data_size ) ; //<S2SV> avio_seek ( pb , data_size + 10 - 3 , SEEK_CUR ) ; //<S2SV> avio_wb32 ( pb , data_size + 11 ) ; //<S2SV> } else { //<S2SV> av_assert1 ( flags >= 0 ) ; //<S2SV> avio_w8 ( pb , flags ) ; //<S2SV> if ( par -> codec_id == AV_CODEC_ID_VP6 ) //<S2SV> avio_w8 ( pb , 0 ) ; //<S2SV> if ( par -> codec_id == AV_CODEC_ID_VP6F || par -> codec_id == AV_CODEC_ID_VP6A ) { //<S2SV> if ( par -> extradata_size ) //<S2SV> avio_w8 ( pb , par -> extradata [ 0 ] ) ; //<S2SV> else //<S2SV> avio_w8 ( pb , ( ( FFALIGN ( par -> width , 16 ) - par -> width ) << 4 ) | //<S2SV> ( FFALIGN ( par -> height , 16 ) - par -> height ) ) ; //<S2SV> } else if ( par -> codec_id == AV_CODEC_ID_AAC ) //<S2SV> avio_w8 ( pb , 1 ) ; //<S2SV> else if ( par -> codec_id == AV_CODEC_ID_H264 || par -> codec_id == AV_CODEC_ID_MPEG4 ) { //<S2SV> avio_w8 ( pb , 1 ) ; //<S2SV> avio_wb24 ( pb , pkt -> pts - pkt -> dts ) ; //<S2SV> } //<S2SV> avio_write ( pb , data ? data : pkt -> data , size ) ; //<S2SV> avio_wb32 ( pb , size + flags_size + 11 ) ; //<S2SV> flv -> duration = FFMAX ( flv -> duration , //<S2SV> pkt -> pts + flv -> delay + pkt -> duration ) ; //<S2SV> } //<S2SV> if ( flv -> flags & FLV_ADD_KEYFRAME_INDEX ) { //<S2SV> switch ( par -> codec_type ) { //<S2SV> case AVMEDIA_TYPE_VIDEO : //<S2SV> flv -> videosize += ( avio_tell ( pb ) - cur_offset ) ; //<S2SV> flv -> lasttimestamp = flv -> acurframeindex / flv -> framerate ; //<S2SV> if ( pkt -> flags & AV_PKT_FLAG_KEY ) { //<S2SV> double ts = flv -> acurframeindex / flv -> framerate ; //<S2SV> int64_t pos = cur_offset ; //<S2SV> flv -> lastkeyframetimestamp = flv -> acurframeindex / flv -> framerate ; //<S2SV> flv -> lastkeyframelocation = pos ; //<S2SV> flv_append_keyframe_info ( s , flv , ts , pos ) ; //<S2SV> } //<S2SV> flv -> acurframeindex ++ ; //<S2SV> break ; //<S2SV> case AVMEDIA_TYPE_AUDIO : //<S2SV> flv -> audiosize += ( avio_tell ( pb ) - cur_offset ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> av_log ( s , AV_LOG_WARNING , "par->codec_type<S2SV_blank>is<S2SV_blank>type<S2SV_blank>=<S2SV_blank>[%d]\\n" , par -> codec_type ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> av_free ( data ) ; //<S2SV> return pb -> error ; //<S2SV> } //<S2SV> 