static int aa_read_header ( AVFormatContext * s ) //<S2SV> { //<S2SV> int i , j , idx , largest_idx = - 1 ; //<S2SV> uint32_t nkey , nval , toc_size , npairs , header_seed = 0 , start ; //<S2SV> char key [ 128 ] , val [ 128 ] , codec_name [ 64 ] = { 0 } ; //<S2SV> uint8_t output [ 24 ] , dst [ 8 ] , src [ 8 ] ; //<S2SV> int64_t largest_size = - 1 , current_size = - 1 , chapter_pos ; //<S2SV> struct toc_entry { //<S2SV> uint32_t offset ; //<S2SV> uint32_t size ; //<S2SV> } TOC [ MAX_TOC_ENTRIES ] ; //<S2SV> uint32_t header_key_part [ 4 ] ; //<S2SV> uint8_t header_key [ 16 ] = { 0 } ; //<S2SV> AADemuxContext * c = s -> priv_data ; //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> AVStream * st ; //<S2SV> int ret ; //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> toc_size = avio_rb32 ( pb ) ; //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> if ( toc_size > MAX_TOC_ENTRIES ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> for ( i = 0 ; i < toc_size ; i ++ ) { //<S2SV> avio_skip ( pb , 4 ) ; //<S2SV> TOC [ i ] . offset = avio_rb32 ( pb ) ; //<S2SV> TOC [ i ] . size = avio_rb32 ( pb ) ; //<S2SV> } //<S2SV> avio_skip ( pb , 24 ) ; //<S2SV> npairs = avio_rb32 ( pb ) ; //<S2SV> if ( npairs > MAX_DICTIONARY_ENTRIES ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> for ( i = 0 ; i < npairs ; i ++ ) { //<S2SV> memset ( val , 0 , sizeof ( val ) ) ; //<S2SV> memset ( key , 0 , sizeof ( key ) ) ; //<S2SV> avio_skip ( pb , 1 ) ; //<S2SV> nkey = avio_rb32 ( pb ) ; //<S2SV> nval = avio_rb32 ( pb ) ; //<S2SV> avio_get_str ( pb , nkey , key , sizeof ( key ) ) ; //<S2SV> avio_get_str ( pb , nval , val , sizeof ( val ) ) ; //<S2SV> if ( ! strcmp ( key , "codec" ) ) { //<S2SV> av_log ( s , AV_LOG_DEBUG , "Codec<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; //<S2SV> strncpy ( codec_name , val , sizeof ( codec_name ) - 1 ) ; //<S2SV> } else if ( ! strcmp ( key , "HeaderSeed" ) ) { //<S2SV> av_log ( s , AV_LOG_DEBUG , "HeaderSeed<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; //<S2SV> header_seed = atoi ( val ) ; //<S2SV> } else if ( ! strcmp ( key , "HeaderKey" ) ) { //<S2SV> av_log ( s , AV_LOG_DEBUG , "HeaderKey<S2SV_blank>is<S2SV_blank><%s>\\n" , val ) ; //<S2SV> ret = sscanf ( val , "%" SCNu32 "%" SCNu32 "%" SCNu32 "%" SCNu32 , //<S2SV> & header_key_part [ 0 ] , & header_key_part [ 1 ] , & header_key_part [ 2 ] , & header_key_part [ 3 ] ) ; //<S2SV> if ( ret != 4 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> for ( idx = 0 ; idx < 4 ; idx ++ ) { //<S2SV> AV_WB32 ( & header_key [ idx * 4 ] , header_key_part [ idx ] ) ; //<S2SV> } //<S2SV> av_log ( s , AV_LOG_DEBUG , "Processed<S2SV_blank>HeaderKey<S2SV_blank>is<S2SV_blank>" ) ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> av_log ( s , AV_LOG_DEBUG , "%02x" , header_key [ i ] ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "\\n" ) ; //<S2SV> } else { //<S2SV> av_dict_set ( & s -> metadata , key , val , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( c -> aa_fixed_key_len != 16 ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "aa_fixed_key<S2SV_blank>value<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>16<S2SV_blank>bytes!\\n" ) ; //<S2SV> return AVERROR ( EINVAL ) ; //<S2SV> } //<S2SV> if ( ( c -> codec_second_size = get_second_size ( codec_name ) ) == - 1 ) { //<S2SV> av_log ( s , AV_LOG_ERROR , "unknown<S2SV_blank>codec<S2SV_blank><%s>!\\n" , codec_name ) ; //<S2SV> return AVERROR ( EINVAL ) ; //<S2SV> } //<S2SV> c -> tea_ctx = av_tea_alloc ( ) ; //<S2SV> if ( ! c -> tea_ctx ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> av_tea_init ( c -> tea_ctx , c -> aa_fixed_key , 16 ) ; //<S2SV> output [ 0 ] = output [ 1 ] = 0 ; //<S2SV> memcpy ( output + 2 , header_key , 16 ) ; //<S2SV> idx = 0 ; //<S2SV> for ( i = 0 ; i < 3 ; i ++ ) { //<S2SV> AV_WB32 ( src , header_seed ) ; //<S2SV> AV_WB32 ( src + 4 , header_seed + 1 ) ; //<S2SV> header_seed += 2 ; //<S2SV> av_tea_crypt ( c -> tea_ctx , dst , src , 1 , NULL , 0 ) ; //<S2SV> for ( j = 0 ; j < TEA_BLOCK_SIZE && idx < 18 ; j += 1 , idx += 1 ) { //<S2SV> output [ idx ] = output [ idx ] ^ dst [ j ] ; //<S2SV> } //<S2SV> } //<S2SV> memcpy ( c -> file_key , output + 2 , 16 ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "File<S2SV_blank>key<S2SV_blank>is<S2SV_blank>" ) ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> av_log ( s , AV_LOG_DEBUG , "%02x" , c -> file_key [ i ] ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "\\n" ) ; //<S2SV> st = avformat_new_stream ( s , NULL ) ; //<S2SV> if ( ! st ) { //<S2SV> av_freep ( & c -> tea_ctx ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; //<S2SV> if ( ! strcmp ( codec_name , "mp332" ) ) { //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_MP3 ; //<S2SV> st -> codecpar -> sample_rate = 22050 ; //<S2SV> st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; //<S2SV> avpriv_set_pts_info ( st , 64 , 8 , 32000 * TIMEPREC ) ; //<S2SV> } else if ( ! strcmp ( codec_name , "acelp85" ) ) { //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_SIPR ; //<S2SV> st -> codecpar -> block_align = 19 ; //<S2SV> st -> codecpar -> channels = 1 ; //<S2SV> st -> codecpar -> sample_rate = 8500 ; //<S2SV> st -> codecpar -> bit_rate = 8500 ; //<S2SV> st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; //<S2SV> avpriv_set_pts_info ( st , 64 , 8 , 8500 * TIMEPREC ) ; //<S2SV> } else if ( ! strcmp ( codec_name , "acelp16" ) ) { //<S2SV> st -> codecpar -> codec_id = AV_CODEC_ID_SIPR ; //<S2SV> st -> codecpar -> block_align = 20 ; //<S2SV> st -> codecpar -> channels = 1 ; //<S2SV> st -> codecpar -> sample_rate = 16000 ; //<S2SV> st -> codecpar -> bit_rate = 16000 ; //<S2SV> st -> need_parsing = AVSTREAM_PARSE_FULL_RAW ; //<S2SV> avpriv_set_pts_info ( st , 64 , 8 , 16000 * TIMEPREC ) ; //<S2SV> } //<S2SV> for ( i = 1 ; i < toc_size ; i ++ ) { //<S2SV> current_size = TOC [ i ] . size ; //<S2SV> if ( current_size > largest_size ) { //<S2SV> largest_idx = i ; //<S2SV> largest_size = current_size ; //<S2SV> } //<S2SV> } //<S2SV> start = TOC [ largest_idx ] . offset ; //<S2SV> avio_seek ( pb , start , SEEK_SET ) ; //<S2SV> st -> start_time = 0 ; //<S2SV> c -> content_start = start ; //<S2SV> c -> content_end = start + largest_size ; //<S2SV> while ( ( chapter_pos = avio_tell ( pb ) ) >= 0 && chapter_pos < c -> content_end ) { //<S2SV> int chapter_idx = s -> nb_chapters ; //<S2SV> uint32_t chapter_size = avio_rb32 ( pb ) ; //<S2SV> if ( chapter_size == 0 ) break ; //<S2SV> chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx ; //<S2SV> avio_skip ( pb , 4 + chapter_size ) ; //<S2SV> if ( ! avpriv_new_chapter ( s , chapter_idx , st -> time_base , //<S2SV> chapter_pos * TIMEPREC , ( chapter_pos + chapter_size ) * TIMEPREC , NULL ) ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> st -> duration = ( largest_size - CHAPTER_HEADER_SIZE * s -> nb_chapters ) * TIMEPREC ; //<S2SV> ff_update_cur_dts ( s , st , 0 ) ; //<S2SV> avio_seek ( pb , start , SEEK_SET ) ; //<S2SV> c -> current_chapter_size = 0 ; //<S2SV> c -> seek_offset = 0 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 