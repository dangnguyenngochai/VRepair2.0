static int http_receive_data ( HTTPContext * c ) //<S2SV> { //<S2SV> HTTPContext * c1 ; //<S2SV> int len , loop_run = 0 ; //<S2SV> while ( c -> chunked_encoding && ! c -> chunk_size && //<S2SV> c -> buffer_end > c -> buffer_ptr ) { //<S2SV> len = recv ( c -> fd , c -> buffer_ptr , 1 , 0 ) ; //<S2SV> if ( len < 0 ) { //<S2SV> if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && //<S2SV> ff_neterrno ( ) != AVERROR ( EINTR ) ) //<S2SV> goto fail ; //<S2SV> return 0 ; //<S2SV> } else if ( len == 0 ) { //<S2SV> goto fail ; //<S2SV> } else if ( c -> buffer_ptr - c -> buffer >= 2 && //<S2SV> ! memcmp ( c -> buffer_ptr - 1 , "\\r\\n" , 2 ) ) { //<S2SV> c -> chunk_size = strtol ( c -> buffer , 0 , 16 ) ; //<S2SV> if ( c -> chunk_size == 0 ) //<S2SV> goto fail ; //<S2SV> c -> buffer_ptr = c -> buffer ; //<S2SV> break ; //<S2SV> } else if ( ++ loop_run > 10 ) //<S2SV> goto fail ; //<S2SV> else //<S2SV> c -> buffer_ptr ++ ; //<S2SV> } //<S2SV> if ( c -> buffer_end > c -> buffer_ptr ) { //<S2SV> len = recv ( c -> fd , c -> buffer_ptr , //<S2SV> FFMIN ( c -> chunk_size , c -> buffer_end - c -> buffer_ptr ) , 0 ) ; //<S2SV> if ( len < 0 ) { //<S2SV> if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && //<S2SV> ff_neterrno ( ) != AVERROR ( EINTR ) ) //<S2SV> goto fail ; //<S2SV> } else if ( len == 0 ) //<S2SV> goto fail ; //<S2SV> else { //<S2SV> c -> chunk_size -= len ; //<S2SV> c -> buffer_ptr += len ; //<S2SV> c -> data_count += len ; //<S2SV> update_datarate ( & c -> datarate , c -> data_count ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( c -> buffer_ptr - c -> buffer >= 2 && c -> data_count > FFM_PACKET_SIZE ) { //<S2SV> if ( c -> buffer [ 0 ] != 'f' || //<S2SV> c -> buffer [ 1 ] != 'm' ) { //<S2SV> http_log ( "Feed<S2SV_blank>stream<S2SV_blank>has<S2SV_blank>become<S2SV_blank>desynchronized<S2SV_blank>--<S2SV_blank>disconnecting\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> if ( c -> buffer_ptr >= c -> buffer_end ) { //<S2SV> FFServerStream * feed = c -> stream ; //<S2SV> if ( c -> data_count > FFM_PACKET_SIZE ) { //<S2SV> if ( lseek ( c -> feed_fd , feed -> feed_write_index , SEEK_SET ) == - 1 ) //<S2SV> http_log ( "Seek<S2SV_blank>to<S2SV_blank>%" PRId64 "<S2SV_blank>failed\\n" , feed -> feed_write_index ) ; //<S2SV> if ( write ( c -> feed_fd , c -> buffer , FFM_PACKET_SIZE ) < 0 ) { //<S2SV> http_log ( "Error<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>feed<S2SV_blank>file:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> feed -> feed_write_index += FFM_PACKET_SIZE ; //<S2SV> if ( feed -> feed_write_index > c -> stream -> feed_size ) //<S2SV> feed -> feed_size = feed -> feed_write_index ; //<S2SV> if ( c -> stream -> feed_max_size && //<S2SV> feed -> feed_write_index >= c -> stream -> feed_max_size ) //<S2SV> feed -> feed_write_index = FFM_PACKET_SIZE ; //<S2SV> if ( ffm_write_write_index ( c -> feed_fd , feed -> feed_write_index ) < 0 ) { //<S2SV> http_log ( "Error<S2SV_blank>writing<S2SV_blank>index<S2SV_blank>to<S2SV_blank>feed<S2SV_blank>file:<S2SV_blank>%s\\n" , //<S2SV> strerror ( errno ) ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> for ( c1 = first_http_ctx ; c1 ; c1 = c1 -> next ) { //<S2SV> if ( c1 -> state == HTTPSTATE_WAIT_FEED && //<S2SV> c1 -> stream -> feed == c -> stream -> feed ) //<S2SV> c1 -> state = HTTPSTATE_SEND_DATA ; //<S2SV> } //<S2SV> } else { //<S2SV> AVFormatContext * s = avformat_alloc_context ( ) ; //<S2SV> AVIOContext * pb ; //<S2SV> AVInputFormat * fmt_in ; //<S2SV> int i ; //<S2SV> if ( ! s ) //<S2SV> goto fail ; //<S2SV> fmt_in = av_find_input_format ( feed -> fmt -> name ) ; //<S2SV> if ( ! fmt_in ) //<S2SV> goto fail ; //<S2SV> pb = avio_alloc_context ( c -> buffer , c -> buffer_end - c -> buffer , //<S2SV> 0 , NULL , NULL , NULL , NULL ) ; //<S2SV> if ( ! pb ) //<S2SV> goto fail ; //<S2SV> pb -> seekable = 0 ; //<S2SV> s -> pb = pb ; //<S2SV> if ( avformat_open_input ( & s , c -> stream -> feed_filename , fmt_in , NULL ) < 0 ) { //<S2SV> av_freep ( & pb ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( s -> nb_streams != feed -> nb_streams ) { //<S2SV> avformat_close_input ( & s ) ; //<S2SV> av_freep ( & pb ) ; //<S2SV> http_log ( "Feed<S2SV_blank>\'%s\'<S2SV_blank>stream<S2SV_blank>number<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>registered<S2SV_blank>feed\\n" , //<S2SV> c -> stream -> feed_filename ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> for ( i = 0 ; i < s -> nb_streams ; i ++ ) { //<S2SV> LayeredAVStream * fst = feed -> streams [ i ] ; //<S2SV> AVStream * st = s -> streams [ i ] ; //<S2SV> avcodec_parameters_to_context ( fst -> codec , st -> codecpar ) ; //<S2SV> avcodec_parameters_from_context ( fst -> codecpar , fst -> codec ) ; //<S2SV> } //<S2SV> avformat_close_input ( & s ) ; //<S2SV> av_freep ( & pb ) ; //<S2SV> } //<S2SV> c -> buffer_ptr = c -> buffer ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> fail : //<S2SV> c -> stream -> feed_opened = 0 ; //<S2SV> close ( c -> feed_fd ) ; //<S2SV> for ( c1 = first_http_ctx ; c1 ; c1 = c1 -> next ) { //<S2SV> if ( c1 -> state == HTTPSTATE_WAIT_FEED && //<S2SV> c1 -> stream -> feed == c -> stream -> feed ) //<S2SV> c1 -> state = HTTPSTATE_SEND_DATA_TRAILER ; //<S2SV> } //<S2SV> return - 1 ; //<S2SV> } //<S2SV> 