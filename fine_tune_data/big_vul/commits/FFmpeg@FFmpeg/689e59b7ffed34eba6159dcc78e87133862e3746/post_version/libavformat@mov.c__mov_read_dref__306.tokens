static int mov_read_dref ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) //<S2SV> { //<S2SV> AVStream * st ; //<S2SV> MOVStreamContext * sc ; //<S2SV> int entries , i , j ; //<S2SV> if ( c -> fc -> nb_streams < 1 ) //<S2SV> return 0 ; //<S2SV> st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; //<S2SV> sc = st -> priv_data ; //<S2SV> avio_rb32 ( pb ) ; //<S2SV> entries = avio_rb32 ( pb ) ; //<S2SV> if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> av_free ( sc -> drefs ) ; //<S2SV> sc -> drefs_count = 0 ; //<S2SV> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; //<S2SV> if ( ! sc -> drefs ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> sc -> drefs_count = entries ; //<S2SV> for ( i = 0 ; i < sc -> drefs_count ; i ++ ) { //<S2SV> MOVDref * dref = & sc -> drefs [ i ] ; //<S2SV> uint32_t size = avio_rb32 ( pb ) ; //<S2SV> int64_t next = avio_tell ( pb ) + size - 4 ; //<S2SV> if ( size < 12 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> dref -> type = avio_rl32 ( pb ) ; //<S2SV> avio_rb32 ( pb ) ; //<S2SV> av_dlog ( c -> fc , "type<S2SV_blank>%.4s<S2SV_blank>size<S2SV_blank>%d\\n" , ( char * ) & dref -> type , size ) ; //<S2SV> if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 ) { //<S2SV> uint16_t volume_len , len ; //<S2SV> int16_t type ; //<S2SV> avio_skip ( pb , 10 ) ; //<S2SV> volume_len = avio_r8 ( pb ) ; //<S2SV> volume_len = FFMIN ( volume_len , 27 ) ; //<S2SV> avio_read ( pb , dref -> volume , 27 ) ; //<S2SV> dref -> volume [ volume_len ] = 0 ; //<S2SV> av_log ( c -> fc , AV_LOG_DEBUG , "volume<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%d\\n" , dref -> volume , volume_len ) ; //<S2SV> avio_skip ( pb , 12 ) ; //<S2SV> len = avio_r8 ( pb ) ; //<S2SV> len = FFMIN ( len , 63 ) ; //<S2SV> avio_read ( pb , dref -> filename , 63 ) ; //<S2SV> dref -> filename [ len ] = 0 ; //<S2SV> av_log ( c -> fc , AV_LOG_DEBUG , "filename<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%d\\n" , dref -> filename , len ) ; //<S2SV> avio_skip ( pb , 16 ) ; //<S2SV> dref -> nlvl_from = avio_rb16 ( pb ) ; //<S2SV> dref -> nlvl_to = avio_rb16 ( pb ) ; //<S2SV> av_log ( c -> fc , AV_LOG_DEBUG , "nlvl<S2SV_blank>from<S2SV_blank>%d,<S2SV_blank>nlvl<S2SV_blank>to<S2SV_blank>%d\\n" , //<S2SV> dref -> nlvl_from , dref -> nlvl_to ) ; //<S2SV> avio_skip ( pb , 16 ) ; //<S2SV> for ( type = 0 ; type != - 1 && avio_tell ( pb ) < next ; ) { //<S2SV> if ( url_feof ( pb ) ) //<S2SV> return AVERROR_EOF ; //<S2SV> type = avio_rb16 ( pb ) ; //<S2SV> len = avio_rb16 ( pb ) ; //<S2SV> av_log ( c -> fc , AV_LOG_DEBUG , "type<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%d\\n" , type , len ) ; //<S2SV> if ( len & 1 ) //<S2SV> len += 1 ; //<S2SV> if ( type == 2 ) { //<S2SV> av_free ( dref -> path ) ; //<S2SV> dref -> path = av_mallocz ( len + 1 ) ; //<S2SV> if ( ! dref -> path ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> avio_read ( pb , dref -> path , len ) ; //<S2SV> if ( len > volume_len && ! strncmp ( dref -> path , dref -> volume , volume_len ) ) { //<S2SV> len -= volume_len ; //<S2SV> memmove ( dref -> path , dref -> path + volume_len , len ) ; //<S2SV> dref -> path [ len ] = 0 ; //<S2SV> } //<S2SV> for ( j = 0 ; j < len ; j ++ ) //<S2SV> if ( dref -> path [ j ] == ':' ) //<S2SV> dref -> path [ j ] = '/' ; //<S2SV> av_log ( c -> fc , AV_LOG_DEBUG , "path<S2SV_blank>%s\\n" , dref -> path ) ; //<S2SV> } else if ( type == 0 ) { //<S2SV> av_free ( dref -> dir ) ; //<S2SV> dref -> dir = av_malloc ( len + 1 ) ; //<S2SV> if ( ! dref -> dir ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> avio_read ( pb , dref -> dir , len ) ; //<S2SV> dref -> dir [ len ] = 0 ; //<S2SV> for ( j = 0 ; j < len ; j ++ ) //<S2SV> if ( dref -> dir [ j ] == ':' ) //<S2SV> dref -> dir [ j ] = '/' ; //<S2SV> av_log ( c -> fc , AV_LOG_DEBUG , "dir<S2SV_blank>%s\\n" , dref -> dir ) ; //<S2SV> } else //<S2SV> avio_skip ( pb , len ) ; //<S2SV> } //<S2SV> } //<S2SV> avio_seek ( pb , next , SEEK_SET ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 