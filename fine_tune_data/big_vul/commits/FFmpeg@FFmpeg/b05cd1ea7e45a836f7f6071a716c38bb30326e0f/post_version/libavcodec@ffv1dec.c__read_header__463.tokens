static int read_header ( FFV1Context * f ) //<S2SV> { //<S2SV> uint8_t state [ CONTEXT_SIZE ] ; //<S2SV> int i , j , context_count = - 1 ; //<S2SV> RangeCoder * const c = & f -> slice_context [ 0 ] -> c ; //<S2SV> memset ( state , 128 , sizeof ( state ) ) ; //<S2SV> if ( f -> version < 2 ) { //<S2SV> int chroma_planes , chroma_h_shift , chroma_v_shift , transparency , colorspace , bits_per_raw_sample ; //<S2SV> unsigned v = get_symbol ( c , state , 0 ) ; //<S2SV> if ( v >= 2 ) { //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "invalid<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ver01<S2SV_blank>header\\n" , v ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> f -> version = v ; //<S2SV> f -> ac = f -> avctx -> coder_type = get_symbol ( c , state , 0 ) ; //<S2SV> if ( f -> ac > 1 ) { //<S2SV> for ( i = 1 ; i < 256 ; i ++ ) //<S2SV> f -> state_transition [ i ] = get_symbol ( c , state , 1 ) + c -> one_state [ i ] ; //<S2SV> } //<S2SV> colorspace = get_symbol ( c , state , 0 ) ; //<S2SV> bits_per_raw_sample = f -> version > 0 ? get_symbol ( c , state , 0 ) : f -> avctx -> bits_per_raw_sample ; //<S2SV> chroma_planes = get_rac ( c , state ) ; //<S2SV> chroma_h_shift = get_symbol ( c , state , 0 ) ; //<S2SV> chroma_v_shift = get_symbol ( c , state , 0 ) ; //<S2SV> transparency = get_rac ( c , state ) ; //<S2SV> if ( f -> plane_count ) { //<S2SV> if ( colorspace != f -> colorspace //<S2SV> || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample //<S2SV> || chroma_planes != f -> chroma_planes //<S2SV> || chroma_h_shift != f -> chroma_h_shift //<S2SV> || chroma_v_shift != f -> chroma_v_shift //<S2SV> || transparency != f -> transparency ) { //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } //<S2SV> f -> colorspace = colorspace ; //<S2SV> f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ; //<S2SV> f -> chroma_planes = chroma_planes ; //<S2SV> f -> chroma_h_shift = chroma_h_shift ; //<S2SV> f -> chroma_v_shift = chroma_v_shift ; //<S2SV> f -> transparency = transparency ; //<S2SV> f -> plane_count = 2 + f -> transparency ; //<S2SV> } //<S2SV> if ( f -> colorspace == 0 ) { //<S2SV> if ( ! f -> transparency && ! f -> chroma_planes ) { //<S2SV> if ( f -> avctx -> bits_per_raw_sample <= 8 ) //<S2SV> f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; //<S2SV> else //<S2SV> f -> avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; //<S2SV> } else if ( f -> avctx -> bits_per_raw_sample <= 8 && ! f -> transparency ) { //<S2SV> switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { //<S2SV> case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P ; break ; //<S2SV> case 0x01 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV440P ; break ; //<S2SV> case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P ; break ; //<S2SV> case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P ; break ; //<S2SV> case 0x20 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV411P ; break ; //<S2SV> case 0x22 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV410P ; break ; //<S2SV> default : //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "format<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> return AVERROR ( ENOSYS ) ; //<S2SV> } //<S2SV> } else if ( f -> avctx -> bits_per_raw_sample <= 8 && f -> transparency ) { //<S2SV> switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { //<S2SV> case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA444P ; break ; //<S2SV> case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA422P ; break ; //<S2SV> case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUVA420P ; break ; //<S2SV> default : //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "format<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> return AVERROR ( ENOSYS ) ; //<S2SV> } //<S2SV> } else if ( f -> avctx -> bits_per_raw_sample == 9 ) { //<S2SV> f -> packed_at_lsb = 1 ; //<S2SV> switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { //<S2SV> case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P9 ; break ; //<S2SV> case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P9 ; break ; //<S2SV> case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P9 ; break ; //<S2SV> default : //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "format<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> return AVERROR ( ENOSYS ) ; //<S2SV> } //<S2SV> } else if ( f -> avctx -> bits_per_raw_sample == 10 ) { //<S2SV> f -> packed_at_lsb = 1 ; //<S2SV> switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { //<S2SV> case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P10 ; break ; //<S2SV> case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; break ; //<S2SV> case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P10 ; break ; //<S2SV> default : //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "format<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> return AVERROR ( ENOSYS ) ; //<S2SV> } //<S2SV> } else { //<S2SV> switch ( 16 * f -> chroma_h_shift + f -> chroma_v_shift ) { //<S2SV> case 0x00 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV444P16 ; break ; //<S2SV> case 0x10 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV422P16 ; break ; //<S2SV> case 0x11 : f -> avctx -> pix_fmt = AV_PIX_FMT_YUV420P16 ; break ; //<S2SV> default : //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "format<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> return AVERROR ( ENOSYS ) ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( f -> colorspace == 1 ) { //<S2SV> if ( f -> chroma_h_shift || f -> chroma_v_shift ) { //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , //<S2SV> "chroma<S2SV_blank>subsampling<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>colorspace\\n" ) ; //<S2SV> return AVERROR ( ENOSYS ) ; //<S2SV> } //<S2SV> if ( f -> avctx -> bits_per_raw_sample == 9 ) //<S2SV> f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP9 ; //<S2SV> else if ( f -> avctx -> bits_per_raw_sample == 10 ) //<S2SV> f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP10 ; //<S2SV> else if ( f -> avctx -> bits_per_raw_sample == 12 ) //<S2SV> f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP12 ; //<S2SV> else if ( f -> avctx -> bits_per_raw_sample == 14 ) //<S2SV> f -> avctx -> pix_fmt = AV_PIX_FMT_GBRP14 ; //<S2SV> else //<S2SV> if ( f -> transparency ) f -> avctx -> pix_fmt = AV_PIX_FMT_RGB32 ; //<S2SV> else f -> avctx -> pix_fmt = AV_PIX_FMT_0RGB32 ; //<S2SV> } else { //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "colorspace<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> return AVERROR ( ENOSYS ) ; //<S2SV> } //<S2SV> av_dlog ( f -> avctx , "%d<S2SV_blank>%d<S2SV_blank>%d\\n" , //<S2SV> f -> chroma_h_shift , f -> chroma_v_shift , f -> avctx -> pix_fmt ) ; //<S2SV> if ( f -> version < 2 ) { //<S2SV> context_count = read_quant_tables ( c , f -> quant_table ) ; //<S2SV> if ( context_count < 0 ) { //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "read_quant_table<S2SV_blank>error\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> } else if ( f -> version < 3 ) { //<S2SV> f -> slice_count = get_symbol ( c , state , 0 ) ; //<S2SV> } else { //<S2SV> const uint8_t * p = c -> bytestream_end ; //<S2SV> for ( f -> slice_count = 0 ; //<S2SV> f -> slice_count < MAX_SLICES && 3 < p - c -> bytestream_start ; //<S2SV> f -> slice_count ++ ) { //<S2SV> int trailer = 3 + 5 * ! ! f -> ec ; //<S2SV> int size = AV_RB24 ( p - trailer ) ; //<S2SV> if ( size + trailer > p - c -> bytestream_start ) //<S2SV> break ; //<S2SV> p -= size + trailer ; //<S2SV> } //<S2SV> } //<S2SV> if ( f -> slice_count > ( unsigned ) MAX_SLICES || f -> slice_count <= 0 ) { //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , "slice<S2SV_blank>count<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid\\n" , f -> slice_count ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> for ( j = 0 ; j < f -> slice_count ; j ++ ) { //<S2SV> FFV1Context * fs = f -> slice_context [ j ] ; //<S2SV> fs -> ac = f -> ac ; //<S2SV> fs -> packed_at_lsb = f -> packed_at_lsb ; //<S2SV> fs -> slice_damaged = 0 ; //<S2SV> if ( f -> version == 2 ) { //<S2SV> fs -> slice_x = get_symbol ( c , state , 0 ) * f -> width ; //<S2SV> fs -> slice_y = get_symbol ( c , state , 0 ) * f -> height ; //<S2SV> fs -> slice_width = ( get_symbol ( c , state , 0 ) + 1 ) * f -> width + fs -> slice_x ; //<S2SV> fs -> slice_height = ( get_symbol ( c , state , 0 ) + 1 ) * f -> height + fs -> slice_y ; //<S2SV> fs -> slice_x /= f -> num_h_slices ; //<S2SV> fs -> slice_y /= f -> num_v_slices ; //<S2SV> fs -> slice_width = fs -> slice_width / f -> num_h_slices - fs -> slice_x ; //<S2SV> fs -> slice_height = fs -> slice_height / f -> num_v_slices - fs -> slice_y ; //<S2SV> if ( ( unsigned ) fs -> slice_width > f -> width || //<S2SV> ( unsigned ) fs -> slice_height > f -> height ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> if ( ( unsigned ) fs -> slice_x + ( uint64_t ) fs -> slice_width > f -> width //<S2SV> || ( unsigned ) fs -> slice_y + ( uint64_t ) fs -> slice_height > f -> height ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> for ( i = 0 ; i < f -> plane_count ; i ++ ) { //<S2SV> PlaneContext * const p = & fs -> plane [ i ] ; //<S2SV> if ( f -> version == 2 ) { //<S2SV> int idx = get_symbol ( c , state , 0 ) ; //<S2SV> if ( idx > ( unsigned ) f -> quant_table_count ) { //<S2SV> av_log ( f -> avctx , AV_LOG_ERROR , //<S2SV> "quant_table_index<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> p -> quant_table_index = idx ; //<S2SV> memcpy ( p -> quant_table , f -> quant_tables [ idx ] , //<S2SV> sizeof ( p -> quant_table ) ) ; //<S2SV> context_count = f -> context_count [ idx ] ; //<S2SV> } else { //<S2SV> memcpy ( p -> quant_table , f -> quant_table , sizeof ( p -> quant_table ) ) ; //<S2SV> } //<S2SV> if ( f -> version <= 2 ) { //<S2SV> av_assert0 ( context_count >= 0 ) ; //<S2SV> if ( p -> context_count < context_count ) { //<S2SV> av_freep ( & p -> state ) ; //<S2SV> av_freep ( & p -> vlc_state ) ; //<S2SV> } //<S2SV> p -> context_count = context_count ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 