static int ivr_read_header ( AVFormatContext * s ) //<S2SV> { //<S2SV> unsigned tag , type , len , tlen , value ; //<S2SV> int i , j , n , count , nb_streams = 0 , ret ; //<S2SV> uint8_t key [ 256 ] , val [ 256 ] ; //<S2SV> AVIOContext * pb = s -> pb ; //<S2SV> AVStream * st ; //<S2SV> int64_t pos , offset , temp ; //<S2SV> pos = avio_tell ( pb ) ; //<S2SV> tag = avio_rl32 ( pb ) ; //<S2SV> if ( tag == MKTAG ( '.' , 'R' , '1' , 'M' ) ) { //<S2SV> if ( avio_rb16 ( pb ) != 1 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> if ( avio_r8 ( pb ) != 1 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> len = avio_rb32 ( pb ) ; //<S2SV> avio_skip ( pb , len ) ; //<S2SV> avio_skip ( pb , 5 ) ; //<S2SV> temp = avio_rb64 ( pb ) ; //<S2SV> while ( ! avio_feof ( pb ) && temp ) { //<S2SV> offset = temp ; //<S2SV> temp = avio_rb64 ( pb ) ; //<S2SV> } //<S2SV> avio_skip ( pb , offset - avio_tell ( pb ) ) ; //<S2SV> if ( avio_r8 ( pb ) != 1 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> len = avio_rb32 ( pb ) ; //<S2SV> avio_skip ( pb , len ) ; //<S2SV> if ( avio_r8 ( pb ) != 2 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> avio_skip ( pb , 16 ) ; //<S2SV> pos = avio_tell ( pb ) ; //<S2SV> tag = avio_rl32 ( pb ) ; //<S2SV> } //<S2SV> if ( tag != MKTAG ( '.' , 'R' , 'E' , 'C' ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> if ( avio_r8 ( pb ) != 0 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> count = avio_rb32 ( pb ) ; //<S2SV> for ( i = 0 ; i < count ; i ++ ) { //<S2SV> if ( avio_feof ( pb ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> type = avio_r8 ( pb ) ; //<S2SV> tlen = avio_rb32 ( pb ) ; //<S2SV> avio_get_str ( pb , tlen , key , sizeof ( key ) ) ; //<S2SV> len = avio_rb32 ( pb ) ; //<S2SV> if ( type == 5 ) { //<S2SV> avio_get_str ( pb , len , val , sizeof ( val ) ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "%s<S2SV_blank>=<S2SV_blank>\'%s\'\\n" , key , val ) ; //<S2SV> } else if ( type == 4 ) { //<S2SV> av_log ( s , AV_LOG_DEBUG , "%s<S2SV_blank>=<S2SV_blank>\'0x" , key ) ; //<S2SV> for ( j = 0 ; j < len ; j ++ ) //<S2SV> av_log ( s , AV_LOG_DEBUG , "%X" , avio_r8 ( pb ) ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "\'\\n" ) ; //<S2SV> } else if ( len == 4 && type == 3 && ! strncmp ( key , "StreamCount" , tlen ) ) { //<S2SV> nb_streams = value = avio_rb32 ( pb ) ; //<S2SV> } else if ( len == 4 && type == 3 ) { //<S2SV> value = avio_rb32 ( pb ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "%s<S2SV_blank>=<S2SV_blank>%d\\n" , key , value ) ; //<S2SV> } else { //<S2SV> av_log ( s , AV_LOG_DEBUG , "Skipping<S2SV_blank>unsupported<S2SV_blank>key:<S2SV_blank>%s\\n" , key ) ; //<S2SV> avio_skip ( pb , len ) ; //<S2SV> } //<S2SV> } //<S2SV> for ( n = 0 ; n < nb_streams ; n ++ ) { //<S2SV> st = avformat_new_stream ( s , NULL ) ; //<S2SV> if ( ! st ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> st -> priv_data = ff_rm_alloc_rmstream ( ) ; //<S2SV> if ( ! st -> priv_data ) //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> if ( avio_r8 ( pb ) != 1 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> count = avio_rb32 ( pb ) ; //<S2SV> for ( i = 0 ; i < count ; i ++ ) { //<S2SV> if ( avio_feof ( pb ) ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> type = avio_r8 ( pb ) ; //<S2SV> tlen = avio_rb32 ( pb ) ; //<S2SV> avio_get_str ( pb , tlen , key , sizeof ( key ) ) ; //<S2SV> len = avio_rb32 ( pb ) ; //<S2SV> if ( type == 5 ) { //<S2SV> avio_get_str ( pb , len , val , sizeof ( val ) ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "%s<S2SV_blank>=<S2SV_blank>\'%s\'\\n" , key , val ) ; //<S2SV> } else if ( type == 4 && ! strncmp ( key , "OpaqueData" , tlen ) ) { //<S2SV> ret = ffio_ensure_seekback ( pb , 4 ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( avio_rb32 ( pb ) == MKBETAG ( 'M' , 'L' , 'T' , 'I' ) ) { //<S2SV> ret = rm_read_multi ( s , pb , st , NULL ) ; //<S2SV> } else { //<S2SV> avio_seek ( pb , - 4 , SEEK_CUR ) ; //<S2SV> ret = ff_rm_read_mdpr_codecdata ( s , pb , st , st -> priv_data , len , NULL ) ; //<S2SV> } //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } else if ( type == 4 ) { //<S2SV> int j ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "%s<S2SV_blank>=<S2SV_blank>\'0x" , key ) ; //<S2SV> for ( j = 0 ; j < len ; j ++ ) //<S2SV> av_log ( s , AV_LOG_DEBUG , "%X" , avio_r8 ( pb ) ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "\'\\n" ) ; //<S2SV> } else if ( len == 4 && type == 3 && ! strncmp ( key , "Duration" , tlen ) ) { //<S2SV> st -> duration = avio_rb32 ( pb ) ; //<S2SV> } else if ( len == 4 && type == 3 ) { //<S2SV> value = avio_rb32 ( pb ) ; //<S2SV> av_log ( s , AV_LOG_DEBUG , "%s<S2SV_blank>=<S2SV_blank>%d\\n" , key , value ) ; //<S2SV> } else { //<S2SV> av_log ( s , AV_LOG_DEBUG , "Skipping<S2SV_blank>unsupported<S2SV_blank>key:<S2SV_blank>%s\\n" , key ) ; //<S2SV> avio_skip ( pb , len ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( avio_r8 ( pb ) != 6 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> avio_skip ( pb , 12 ) ; //<S2SV> avio_skip ( pb , avio_rb64 ( pb ) + pos - avio_tell ( s -> pb ) ) ; //<S2SV> if ( avio_r8 ( pb ) != 8 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> avio_skip ( pb , 8 ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 