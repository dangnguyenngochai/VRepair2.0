void ff_h264_free_tables ( H264Context * h , int free_rbsp ) //<S2SV> { //<S2SV> int i ; //<S2SV> H264Context * hx ; //<S2SV> av_freep ( & h -> intra4x4_pred_mode ) ; //<S2SV> av_freep ( & h -> chroma_pred_mode_table ) ; //<S2SV> av_freep ( & h -> cbp_table ) ; //<S2SV> av_freep ( & h -> mvd_table [ 0 ] ) ; //<S2SV> av_freep ( & h -> mvd_table [ 1 ] ) ; //<S2SV> av_freep ( & h -> direct_table ) ; //<S2SV> av_freep ( & h -> non_zero_count ) ; //<S2SV> av_freep ( & h -> slice_table_base ) ; //<S2SV> h -> slice_table = NULL ; //<S2SV> av_freep ( & h -> list_counts ) ; //<S2SV> av_freep ( & h -> mb2b_xy ) ; //<S2SV> av_freep ( & h -> mb2br_xy ) ; //<S2SV> av_buffer_pool_uninit ( & h -> qscale_table_pool ) ; //<S2SV> av_buffer_pool_uninit ( & h -> mb_type_pool ) ; //<S2SV> av_buffer_pool_uninit ( & h -> motion_val_pool ) ; //<S2SV> av_buffer_pool_uninit ( & h -> ref_index_pool ) ; //<S2SV> if ( free_rbsp && h -> DPB ) { //<S2SV> for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) //<S2SV> ff_h264_unref_picture ( h , & h -> DPB [ i ] ) ; //<S2SV> memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ; //<S2SV> av_freep ( & h -> DPB ) ; //<S2SV> } else if ( h -> DPB ) { //<S2SV> for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) //<S2SV> h -> DPB [ i ] . needs_realloc = 1 ; //<S2SV> } //<S2SV> h -> cur_pic_ptr = NULL ; //<S2SV> for ( i = 0 ; i < H264_MAX_THREADS ; i ++ ) { //<S2SV> hx = h -> thread_context [ i ] ; //<S2SV> if ( ! hx ) //<S2SV> continue ; //<S2SV> av_freep ( & hx -> top_borders [ 1 ] ) ; //<S2SV> av_freep ( & hx -> top_borders [ 0 ] ) ; //<S2SV> av_freep ( & hx -> bipred_scratchpad ) ; //<S2SV> av_freep ( & hx -> edge_emu_buffer ) ; //<S2SV> av_freep ( & hx -> dc_val_base ) ; //<S2SV> av_freep ( & hx -> er . mb_index2xy ) ; //<S2SV> av_freep ( & hx -> er . error_status_table ) ; //<S2SV> av_freep ( & hx -> er . er_temp_buffer ) ; //<S2SV> av_freep ( & hx -> er . mbintra_table ) ; //<S2SV> av_freep ( & hx -> er . mbskip_table ) ; //<S2SV> if ( free_rbsp ) { //<S2SV> av_freep ( & hx -> rbsp_buffer [ 1 ] ) ; //<S2SV> av_freep ( & hx -> rbsp_buffer [ 0 ] ) ; //<S2SV> hx -> rbsp_buffer_size [ 0 ] = 0 ; //<S2SV> hx -> rbsp_buffer_size [ 1 ] = 0 ; //<S2SV> } //<S2SV> if ( i ) //<S2SV> av_freep ( & h -> thread_context [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> 