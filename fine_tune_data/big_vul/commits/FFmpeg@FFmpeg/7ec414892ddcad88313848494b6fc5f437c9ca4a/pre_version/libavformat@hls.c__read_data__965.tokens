static int read_data ( void * opaque , uint8_t * buf , int buf_size ) //<S2SV> { //<S2SV> struct playlist * v = opaque ; //<S2SV> HLSContext * c = v -> parent -> priv_data ; //<S2SV> int ret , i ; //<S2SV> int just_opened = 0 ; //<S2SV> restart : //<S2SV> if ( ! v -> needed ) //<S2SV> return AVERROR_EOF ; //<S2SV> if ( ! v -> input ) { //<S2SV> int64_t reload_interval ; //<S2SV> struct segment * seg ; //<S2SV> if ( v -> ctx && v -> ctx -> nb_streams ) { //<S2SV> v -> needed = 0 ; //<S2SV> for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { //<S2SV> if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { //<S2SV> v -> needed = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! v -> needed ) { //<S2SV> av_log ( v -> parent , AV_LOG_INFO , "No<S2SV_blank>longer<S2SV_blank>receiving<S2SV_blank>playlist<S2SV_blank>%d\\n" , //<S2SV> v -> index ) ; //<S2SV> return AVERROR_EOF ; //<S2SV> } //<S2SV> reload_interval = default_reload_interval ( v ) ; //<S2SV> reload : //<S2SV> if ( ! v -> finished && //<S2SV> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { //<S2SV> if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { //<S2SV> av_log ( v -> parent , AV_LOG_WARNING , "Failed<S2SV_blank>to<S2SV_blank>reload<S2SV_blank>playlist<S2SV_blank>%d\\n" , //<S2SV> v -> index ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> reload_interval = v -> target_duration / 2 ; //<S2SV> } //<S2SV> if ( v -> cur_seq_no < v -> start_seq_no ) { //<S2SV> av_log ( NULL , AV_LOG_WARNING , //<S2SV> "skipping<S2SV_blank>%d<S2SV_blank>segments<S2SV_blank>ahead,<S2SV_blank>expired<S2SV_blank>from<S2SV_blank>playlists\\n" , //<S2SV> v -> start_seq_no - v -> cur_seq_no ) ; //<S2SV> v -> cur_seq_no = v -> start_seq_no ; //<S2SV> } //<S2SV> if ( v -> cur_seq_no >= v -> start_seq_no + v -> n_segments ) { //<S2SV> if ( v -> finished ) //<S2SV> return AVERROR_EOF ; //<S2SV> while ( av_gettime_relative ( ) - v -> last_load_time < reload_interval ) { //<S2SV> if ( ff_check_interrupt ( c -> interrupt_callback ) ) //<S2SV> return AVERROR_EXIT ; //<S2SV> av_usleep ( 100 * 1000 ) ; //<S2SV> } //<S2SV> goto reload ; //<S2SV> } //<S2SV> seg = current_segment ( v ) ; //<S2SV> ret = update_init_section ( v , seg ) ; //<S2SV> if ( ret ) //<S2SV> return ret ; //<S2SV> ret = open_input ( c , v , seg ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> if ( ff_check_interrupt ( c -> interrupt_callback ) ) //<S2SV> return AVERROR_EXIT ; //<S2SV> av_log ( v -> parent , AV_LOG_WARNING , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>segment<S2SV_blank>of<S2SV_blank>playlist<S2SV_blank>%d\\n" , //<S2SV> v -> index ) ; //<S2SV> v -> cur_seq_no += 1 ; //<S2SV> goto reload ; //<S2SV> } //<S2SV> just_opened = 1 ; //<S2SV> } //<S2SV> if ( v -> init_sec_buf_read_offset < v -> init_sec_data_len ) { //<S2SV> int copy_size = FFMIN ( v -> init_sec_data_len - v -> init_sec_buf_read_offset , buf_size ) ; //<S2SV> memcpy ( buf , v -> init_sec_buf , copy_size ) ; //<S2SV> v -> init_sec_buf_read_offset += copy_size ; //<S2SV> return copy_size ; //<S2SV> } //<S2SV> ret = read_from_url ( v , current_segment ( v ) , buf , buf_size , READ_NORMAL ) ; //<S2SV> if ( ret > 0 ) { //<S2SV> if ( just_opened && v -> is_id3_timestamped != 0 ) { //<S2SV> intercept_id3 ( v , buf , buf_size , & ret ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> ff_format_io_close ( v -> parent , & v -> input ) ; //<S2SV> v -> cur_seq_no ++ ; //<S2SV> c -> cur_seq_no = v -> cur_seq_no ; //<S2SV> goto restart ; //<S2SV> } //<S2SV> 