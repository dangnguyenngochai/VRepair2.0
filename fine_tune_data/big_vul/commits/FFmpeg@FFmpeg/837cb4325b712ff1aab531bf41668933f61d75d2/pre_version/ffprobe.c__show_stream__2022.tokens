static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) //<S2SV> { //<S2SV> AVStream * stream = ist -> st ; //<S2SV> AVCodecParameters * par ; //<S2SV> AVCodecContext * dec_ctx ; //<S2SV> char val_str [ 128 ] ; //<S2SV> const char * s ; //<S2SV> AVRational sar , dar ; //<S2SV> AVBPrint pbuf ; //<S2SV> const AVCodecDescriptor * cd ; //<S2SV> int ret = 0 ; //<S2SV> const char * profile = NULL ; //<S2SV> av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; //<S2SV> writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; //<S2SV> print_int ( "index" , stream -> index ) ; //<S2SV> par = stream -> codecpar ; //<S2SV> dec_ctx = ist -> dec_ctx ; //<S2SV> if ( cd = avcodec_descriptor_get ( par -> codec_id ) ) { //<S2SV> print_str ( "codec_name" , cd -> name ) ; //<S2SV> if ( ! do_bitexact ) { //<S2SV> print_str ( "codec_long_name" , //<S2SV> cd -> long_name ? cd -> long_name : "unknown" ) ; //<S2SV> } //<S2SV> } else { //<S2SV> print_str_opt ( "codec_name" , "unknown" ) ; //<S2SV> if ( ! do_bitexact ) { //<S2SV> print_str_opt ( "codec_long_name" , "unknown" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) //<S2SV> print_str ( "profile" , profile ) ; //<S2SV> else { //<S2SV> if ( par -> profile != FF_PROFILE_UNKNOWN ) { //<S2SV> char profile_num [ 12 ] ; //<S2SV> snprintf ( profile_num , sizeof ( profile_num ) , "%d" , par -> profile ) ; //<S2SV> print_str ( "profile" , profile_num ) ; //<S2SV> } else //<S2SV> print_str_opt ( "profile" , "unknown" ) ; //<S2SV> } //<S2SV> s = av_get_media_type_string ( par -> codec_type ) ; //<S2SV> if ( s ) print_str ( "codec_type" , s ) ; //<S2SV> else print_str_opt ( "codec_type" , "unknown" ) ; //<S2SV> # if FF_API_LAVF_AVCTX //<S2SV> if ( dec_ctx ) //<S2SV> print_q ( "codec_time_base" , dec_ctx -> time_base , '/' ) ; //<S2SV> # endif //<S2SV> print_str ( "codec_tag_string" , av_fourcc2str ( par -> codec_tag ) ) ; //<S2SV> print_fmt ( "codec_tag" , "0x%04" PRIx32 , par -> codec_tag ) ; //<S2SV> switch ( par -> codec_type ) { //<S2SV> case AVMEDIA_TYPE_VIDEO : //<S2SV> print_int ( "width" , par -> width ) ; //<S2SV> print_int ( "height" , par -> height ) ; //<S2SV> if ( dec_ctx ) { //<S2SV> print_int ( "coded_width" , dec_ctx -> coded_width ) ; //<S2SV> print_int ( "coded_height" , dec_ctx -> coded_height ) ; //<S2SV> } //<S2SV> print_int ( "has_b_frames" , par -> video_delay ) ; //<S2SV> sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ; //<S2SV> if ( sar . den ) { //<S2SV> print_q ( "sample_aspect_ratio" , sar , ':' ) ; //<S2SV> av_reduce ( & dar . num , & dar . den , //<S2SV> par -> width * sar . num , //<S2SV> par -> height * sar . den , //<S2SV> 1024 * 1024 ) ; //<S2SV> print_q ( "display_aspect_ratio" , dar , ':' ) ; //<S2SV> } else { //<S2SV> print_str_opt ( "sample_aspect_ratio" , "N/A" ) ; //<S2SV> print_str_opt ( "display_aspect_ratio" , "N/A" ) ; //<S2SV> } //<S2SV> s = av_get_pix_fmt_name ( par -> format ) ; //<S2SV> if ( s ) print_str ( "pix_fmt" , s ) ; //<S2SV> else print_str_opt ( "pix_fmt" , "unknown" ) ; //<S2SV> print_int ( "level" , par -> level ) ; //<S2SV> if ( par -> color_range != AVCOL_RANGE_UNSPECIFIED ) //<S2SV> print_str ( "color_range" , av_color_range_name ( par -> color_range ) ) ; //<S2SV> else //<S2SV> print_str_opt ( "color_range" , "N/A" ) ; //<S2SV> if ( par -> color_space != AVCOL_SPC_UNSPECIFIED ) //<S2SV> print_str ( "color_space" , av_color_space_name ( par -> color_space ) ) ; //<S2SV> else //<S2SV> print_str_opt ( "color_space" , av_color_space_name ( par -> color_space ) ) ; //<S2SV> if ( par -> color_trc != AVCOL_TRC_UNSPECIFIED ) //<S2SV> print_str ( "color_transfer" , av_color_transfer_name ( par -> color_trc ) ) ; //<S2SV> else //<S2SV> print_str_opt ( "color_transfer" , av_color_transfer_name ( par -> color_trc ) ) ; //<S2SV> if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) //<S2SV> print_str ( "color_primaries" , av_color_primaries_name ( par -> color_primaries ) ) ; //<S2SV> else //<S2SV> print_str_opt ( "color_primaries" , av_color_primaries_name ( par -> color_primaries ) ) ; //<S2SV> if ( par -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) //<S2SV> print_str ( "chroma_location" , av_chroma_location_name ( par -> chroma_location ) ) ; //<S2SV> else //<S2SV> print_str_opt ( "chroma_location" , av_chroma_location_name ( par -> chroma_location ) ) ; //<S2SV> if ( par -> field_order == AV_FIELD_PROGRESSIVE ) //<S2SV> print_str ( "field_order" , "progressive" ) ; //<S2SV> else if ( par -> field_order == AV_FIELD_TT ) //<S2SV> print_str ( "field_order" , "tt" ) ; //<S2SV> else if ( par -> field_order == AV_FIELD_BB ) //<S2SV> print_str ( "field_order" , "bb" ) ; //<S2SV> else if ( par -> field_order == AV_FIELD_TB ) //<S2SV> print_str ( "field_order" , "tb" ) ; //<S2SV> else if ( par -> field_order == AV_FIELD_BT ) //<S2SV> print_str ( "field_order" , "bt" ) ; //<S2SV> else //<S2SV> print_str_opt ( "field_order" , "unknown" ) ; //<S2SV> # if FF_API_PRIVATE_OPT //<S2SV> if ( dec_ctx && dec_ctx -> timecode_frame_start >= 0 ) { //<S2SV> char tcbuf [ AV_TIMECODE_STR_SIZE ] ; //<S2SV> av_timecode_make_mpeg_tc_string ( tcbuf , dec_ctx -> timecode_frame_start ) ; //<S2SV> print_str ( "timecode" , tcbuf ) ; //<S2SV> } else { //<S2SV> print_str_opt ( "timecode" , "N/A" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( dec_ctx ) //<S2SV> print_int ( "refs" , dec_ctx -> refs ) ; //<S2SV> break ; //<S2SV> case AVMEDIA_TYPE_AUDIO : //<S2SV> s = av_get_sample_fmt_name ( par -> format ) ; //<S2SV> if ( s ) print_str ( "sample_fmt" , s ) ; //<S2SV> else print_str_opt ( "sample_fmt" , "unknown" ) ; //<S2SV> print_val ( "sample_rate" , par -> sample_rate , unit_hertz_str ) ; //<S2SV> print_int ( "channels" , par -> channels ) ; //<S2SV> if ( par -> channel_layout ) { //<S2SV> av_bprint_clear ( & pbuf ) ; //<S2SV> av_bprint_channel_layout ( & pbuf , par -> channels , par -> channel_layout ) ; //<S2SV> print_str ( "channel_layout" , pbuf . str ) ; //<S2SV> } else { //<S2SV> print_str_opt ( "channel_layout" , "unknown" ) ; //<S2SV> } //<S2SV> print_int ( "bits_per_sample" , av_get_bits_per_sample ( par -> codec_id ) ) ; //<S2SV> break ; //<S2SV> case AVMEDIA_TYPE_SUBTITLE : //<S2SV> if ( par -> width ) //<S2SV> print_int ( "width" , par -> width ) ; //<S2SV> else //<S2SV> print_str_opt ( "width" , "N/A" ) ; //<S2SV> if ( par -> height ) //<S2SV> print_int ( "height" , par -> height ) ; //<S2SV> else //<S2SV> print_str_opt ( "height" , "N/A" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( dec_ctx && dec_ctx -> codec && dec_ctx -> codec -> priv_class && show_private_data ) { //<S2SV> const AVOption * opt = NULL ; //<S2SV> while ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) { //<S2SV> uint8_t * str ; //<S2SV> if ( opt -> flags ) continue ; //<S2SV> if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) { //<S2SV> print_str ( opt -> name , str ) ; //<S2SV> av_free ( str ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( "id" , "0x%x" , stream -> id ) ; //<S2SV> else print_str_opt ( "id" , "N/A" ) ; //<S2SV> print_q ( "r_frame_rate" , stream -> r_frame_rate , '/' ) ; //<S2SV> print_q ( "avg_frame_rate" , stream -> avg_frame_rate , '/' ) ; //<S2SV> print_q ( "time_base" , stream -> time_base , '/' ) ; //<S2SV> print_ts ( "start_pts" , stream -> start_time ) ; //<S2SV> print_time ( "start_time" , stream -> start_time , & stream -> time_base ) ; //<S2SV> print_ts ( "duration_ts" , stream -> duration ) ; //<S2SV> print_time ( "duration" , stream -> duration , & stream -> time_base ) ; //<S2SV> if ( par -> bit_rate > 0 ) print_val ( "bit_rate" , par -> bit_rate , unit_bit_per_second_str ) ; //<S2SV> else print_str_opt ( "bit_rate" , "N/A" ) ; //<S2SV> # if FF_API_LAVF_AVCTX //<S2SV> if ( stream -> codec -> rc_max_rate > 0 ) print_val ( "max_bit_rate" , stream -> codec -> rc_max_rate , unit_bit_per_second_str ) ; //<S2SV> else print_str_opt ( "max_bit_rate" , "N/A" ) ; //<S2SV> # endif //<S2SV> if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( "bits_per_raw_sample" , "%d" , dec_ctx -> bits_per_raw_sample ) ; //<S2SV> else print_str_opt ( "bits_per_raw_sample" , "N/A" ) ; //<S2SV> if ( stream -> nb_frames ) print_fmt ( "nb_frames" , "%" PRId64 , stream -> nb_frames ) ; //<S2SV> else print_str_opt ( "nb_frames" , "N/A" ) ; //<S2SV> if ( nb_streams_frames [ stream_idx ] ) print_fmt ( "nb_read_frames" , "%" PRIu64 , nb_streams_frames [ stream_idx ] ) ; //<S2SV> else print_str_opt ( "nb_read_frames" , "N/A" ) ; //<S2SV> if ( nb_streams_packets [ stream_idx ] ) print_fmt ( "nb_read_packets" , "%" PRIu64 , nb_streams_packets [ stream_idx ] ) ; //<S2SV> else print_str_opt ( "nb_read_packets" , "N/A" ) ; //<S2SV> if ( do_show_data ) //<S2SV> writer_print_data ( w , "extradata" , par -> extradata , //<S2SV> par -> extradata_size ) ; //<S2SV> writer_print_data_hash ( w , "extradata_hash" , par -> extradata , //<S2SV> par -> extradata_size ) ; //<S2SV> # define PRINT_DISPOSITION ( flagname , name ) do { print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ; } while ( 0 ) //<S2SV> if ( do_show_stream_disposition ) { //<S2SV> writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ; //<S2SV> PRINT_DISPOSITION ( DEFAULT , "default" ) ; //<S2SV> PRINT_DISPOSITION ( DUB , "dub" ) ; //<S2SV> PRINT_DISPOSITION ( ORIGINAL , "original" ) ; //<S2SV> PRINT_DISPOSITION ( COMMENT , "comment" ) ; //<S2SV> PRINT_DISPOSITION ( LYRICS , "lyrics" ) ; //<S2SV> PRINT_DISPOSITION ( KARAOKE , "karaoke" ) ; //<S2SV> PRINT_DISPOSITION ( FORCED , "forced" ) ; //<S2SV> PRINT_DISPOSITION ( HEARING_IMPAIRED , "hearing_impaired" ) ; //<S2SV> PRINT_DISPOSITION ( VISUAL_IMPAIRED , "visual_impaired" ) ; //<S2SV> PRINT_DISPOSITION ( CLEAN_EFFECTS , "clean_effects" ) ; //<S2SV> PRINT_DISPOSITION ( ATTACHED_PIC , "attached_pic" ) ; //<S2SV> PRINT_DISPOSITION ( TIMED_THUMBNAILS , "timed_thumbnails" ) ; //<S2SV> writer_print_section_footer ( w ) ; //<S2SV> } //<S2SV> if ( do_show_stream_tags ) //<S2SV> ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ; //<S2SV> if ( stream -> nb_side_data ) { //<S2SV> print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , //<S2SV> SECTION_ID_STREAM_SIDE_DATA_LIST , //<S2SV> SECTION_ID_STREAM_SIDE_DATA ) ; //<S2SV> } //<S2SV> writer_print_section_footer ( w ) ; //<S2SV> av_bprint_finalize ( & pbuf , NULL ) ; //<S2SV> fflush ( stdout ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 