static av_cold int vqa_decode_init ( AVCodecContext * avctx ) //<S2SV> { //<S2SV> VqaContext * s = avctx -> priv_data ; //<S2SV> int i , j , codebook_index , ret ; //<S2SV> s -> avctx = avctx ; //<S2SV> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; //<S2SV> if ( s -> avctx -> extradata_size != VQA_HEADER_SIZE ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "expected<S2SV_blank>extradata<S2SV_blank>size<S2SV_blank>of<S2SV_blank>%d\\n" , VQA_HEADER_SIZE ) ; //<S2SV> return AVERROR ( EINVAL ) ; //<S2SV> } //<S2SV> s -> vqa_version = s -> avctx -> extradata [ 0 ] ; //<S2SV> switch ( s -> vqa_version ) { //<S2SV> case 1 : //<S2SV> case 2 : //<S2SV> break ; //<S2SV> case 3 : //<S2SV> avpriv_report_missing_feature ( avctx , "VQA<S2SV_blank>Version<S2SV_blank>%d" , s -> vqa_version ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> default : //<S2SV> avpriv_request_sample ( avctx , "VQA<S2SV_blank>Version<S2SV_blank>%i" , s -> vqa_version ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> s -> width = AV_RL16 ( & s -> avctx -> extradata [ 6 ] ) ; //<S2SV> s -> height = AV_RL16 ( & s -> avctx -> extradata [ 8 ] ) ; //<S2SV> if ( ( ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ) < 0 ) { //<S2SV> s -> width = s -> height = 0 ; //<S2SV> return ret ; //<S2SV> } //<S2SV> s -> vector_width = s -> avctx -> extradata [ 10 ] ; //<S2SV> s -> vector_height = s -> avctx -> extradata [ 11 ] ; //<S2SV> s -> partial_count = s -> partial_countdown = s -> avctx -> extradata [ 13 ] ; //<S2SV> if ( ( s -> vector_width != 4 ) || //<S2SV> ( ( s -> vector_height != 2 ) && ( s -> vector_height != 4 ) ) ) { //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( s -> width % s -> vector_width || s -> height % s -> vector_height ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "Image<S2SV_blank>size<S2SV_blank>not<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>block<S2SV_blank>size\\n" ) ; //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> s -> codebook_size = MAX_CODEBOOK_SIZE ; //<S2SV> s -> codebook = av_malloc ( s -> codebook_size ) ; //<S2SV> if ( ! s -> codebook ) //<S2SV> goto fail ; //<S2SV> s -> next_codebook_buffer = av_malloc ( s -> codebook_size ) ; //<S2SV> if ( ! s -> next_codebook_buffer ) //<S2SV> goto fail ; //<S2SV> s -> decode_buffer_size = ( s -> width / s -> vector_width ) * //<S2SV> ( s -> height / s -> vector_height ) * 2 ; //<S2SV> s -> decode_buffer = av_mallocz ( s -> decode_buffer_size ) ; //<S2SV> if ( ! s -> decode_buffer ) //<S2SV> goto fail ; //<S2SV> if ( s -> vector_height == 4 ) { //<S2SV> codebook_index = 0xFF00 * 16 ; //<S2SV> for ( i = 0 ; i < 256 ; i ++ ) //<S2SV> for ( j = 0 ; j < 16 ; j ++ ) //<S2SV> s -> codebook [ codebook_index ++ ] = i ; //<S2SV> } else { //<S2SV> codebook_index = 0xF00 * 8 ; //<S2SV> for ( i = 0 ; i < 256 ; i ++ ) //<S2SV> for ( j = 0 ; j < 8 ; j ++ ) //<S2SV> s -> codebook [ codebook_index ++ ] = i ; //<S2SV> } //<S2SV> s -> next_codebook_buffer_index = 0 ; //<S2SV> return 0 ; //<S2SV> fail : //<S2SV> av_freep ( & s -> codebook ) ; //<S2SV> av_freep ( & s -> next_codebook_buffer ) ; //<S2SV> av_freep ( & s -> decode_buffer ) ; //<S2SV> return AVERROR ( ENOMEM ) ; //<S2SV> } //<S2SV> 