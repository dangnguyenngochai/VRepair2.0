static av_always_inline //<S2SV> int vp78_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , //<S2SV> AVPacket * avpkt , int is_vp7 ) //<S2SV> { //<S2SV> VP8Context * s = avctx -> priv_data ; //<S2SV> int ret , i , referenced , num_jobs ; //<S2SV> enum AVDiscard skip_thresh ; //<S2SV> VP8Frame * av_uninit ( curframe ) , * prev_frame ; //<S2SV> if ( is_vp7 ) //<S2SV> ret = vp7_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ; //<S2SV> else //<S2SV> ret = vp8_decode_frame_header ( s , avpkt -> data , avpkt -> size ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto err ; //<S2SV> prev_frame = s -> framep [ VP56_FRAME_CURRENT ] ; //<S2SV> referenced = s -> update_last || s -> update_golden == VP56_FRAME_CURRENT || //<S2SV> s -> update_altref == VP56_FRAME_CURRENT ; //<S2SV> skip_thresh = ! referenced ? AVDISCARD_NONREF //<S2SV> : ! s -> keyframe ? AVDISCARD_NONKEY //<S2SV> : AVDISCARD_ALL ; //<S2SV> if ( avctx -> skip_frame >= skip_thresh ) { //<S2SV> s -> invisible = 1 ; //<S2SV> memcpy ( & s -> next_framep [ 0 ] , & s -> framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; //<S2SV> goto skip_decode ; //<S2SV> } //<S2SV> s -> deblock_filter = s -> filter . level && avctx -> skip_loop_filter < skip_thresh ; //<S2SV> for ( i = 0 ; i < 5 ; i ++ ) //<S2SV> if ( s -> frames [ i ] . tf . f -> data [ 0 ] && //<S2SV> & s -> frames [ i ] != prev_frame && //<S2SV> & s -> frames [ i ] != s -> framep [ VP56_FRAME_PREVIOUS ] && //<S2SV> & s -> frames [ i ] != s -> framep [ VP56_FRAME_GOLDEN ] && //<S2SV> & s -> frames [ i ] != s -> framep [ VP56_FRAME_GOLDEN2 ] ) //<S2SV> vp8_release_frame ( s , & s -> frames [ i ] ) ; //<S2SV> curframe = s -> framep [ VP56_FRAME_CURRENT ] = vp8_find_free_buffer ( s ) ; //<S2SV> if ( ! s -> colorspace ) //<S2SV> avctx -> colorspace = AVCOL_SPC_BT470BG ; //<S2SV> if ( s -> fullrange ) //<S2SV> avctx -> color_range = AVCOL_RANGE_JPEG ; //<S2SV> else //<S2SV> avctx -> color_range = AVCOL_RANGE_MPEG ; //<S2SV> if ( ! s -> keyframe && ( ! s -> framep [ VP56_FRAME_PREVIOUS ] || //<S2SV> ! s -> framep [ VP56_FRAME_GOLDEN ] || //<S2SV> ! s -> framep [ VP56_FRAME_GOLDEN2 ] ) ) { //<S2SV> av_log ( avctx , AV_LOG_WARNING , //<S2SV> "Discarding<S2SV_blank>interframe<S2SV_blank>without<S2SV_blank>a<S2SV_blank>prior<S2SV_blank>keyframe!\\n" ) ; //<S2SV> ret = AVERROR_INVALIDDATA ; //<S2SV> goto err ; //<S2SV> } //<S2SV> curframe -> tf . f -> key_frame = s -> keyframe ; //<S2SV> curframe -> tf . f -> pict_type = s -> keyframe ? AV_PICTURE_TYPE_I //<S2SV> : AV_PICTURE_TYPE_P ; //<S2SV> if ( ( ret = vp8_alloc_frame ( s , curframe , referenced ) ) < 0 ) //<S2SV> goto err ; //<S2SV> if ( s -> update_altref != VP56_FRAME_NONE ) //<S2SV> s -> next_framep [ VP56_FRAME_GOLDEN2 ] = s -> framep [ s -> update_altref ] ; //<S2SV> else //<S2SV> s -> next_framep [ VP56_FRAME_GOLDEN2 ] = s -> framep [ VP56_FRAME_GOLDEN2 ] ; //<S2SV> if ( s -> update_golden != VP56_FRAME_NONE ) //<S2SV> s -> next_framep [ VP56_FRAME_GOLDEN ] = s -> framep [ s -> update_golden ] ; //<S2SV> else //<S2SV> s -> next_framep [ VP56_FRAME_GOLDEN ] = s -> framep [ VP56_FRAME_GOLDEN ] ; //<S2SV> if ( s -> update_last ) //<S2SV> s -> next_framep [ VP56_FRAME_PREVIOUS ] = curframe ; //<S2SV> else //<S2SV> s -> next_framep [ VP56_FRAME_PREVIOUS ] = s -> framep [ VP56_FRAME_PREVIOUS ] ; //<S2SV> s -> next_framep [ VP56_FRAME_CURRENT ] = curframe ; //<S2SV> if ( avctx -> codec -> update_thread_context ) //<S2SV> ff_thread_finish_setup ( avctx ) ; //<S2SV> s -> linesize = curframe -> tf . f -> linesize [ 0 ] ; //<S2SV> s -> uvlinesize = curframe -> tf . f -> linesize [ 1 ] ; //<S2SV> memset ( s -> top_nnz , 0 , s -> mb_width * sizeof ( * s -> top_nnz ) ) ; //<S2SV> if ( ! s -> mb_layout ) //<S2SV> memset ( s -> macroblocks + s -> mb_height * 2 - 1 , 0 , //<S2SV> ( s -> mb_width + 1 ) * sizeof ( * s -> macroblocks ) ) ; //<S2SV> if ( ! s -> mb_layout && s -> keyframe ) //<S2SV> memset ( s -> intra4x4_pred_mode_top , DC_PRED , s -> mb_width * 4 ) ; //<S2SV> memset ( s -> ref_count , 0 , sizeof ( s -> ref_count ) ) ; //<S2SV> if ( s -> mb_layout == 1 ) { //<S2SV> if ( prev_frame && s -> segmentation . enabled && //<S2SV> ! s -> segmentation . update_map ) //<S2SV> ff_thread_await_progress ( & prev_frame -> tf , 1 , 0 ) ; //<S2SV> if ( is_vp7 ) //<S2SV> vp7_decode_mv_mb_modes ( avctx , curframe , prev_frame ) ; //<S2SV> else //<S2SV> vp8_decode_mv_mb_modes ( avctx , curframe , prev_frame ) ; //<S2SV> } //<S2SV> if ( avctx -> active_thread_type == FF_THREAD_FRAME ) //<S2SV> num_jobs = 1 ; //<S2SV> else //<S2SV> num_jobs = FFMIN ( s -> num_coeff_partitions , avctx -> thread_count ) ; //<S2SV> s -> num_jobs = num_jobs ; //<S2SV> s -> curframe = curframe ; //<S2SV> s -> prev_frame = prev_frame ; //<S2SV> s -> mv_bounds . mv_min . y = - MARGIN ; //<S2SV> s -> mv_bounds . mv_max . y = ( ( s -> mb_height - 1 ) << 6 ) + MARGIN ; //<S2SV> for ( i = 0 ; i < MAX_THREADS ; i ++ ) { //<S2SV> VP8ThreadData * td = & s -> thread_data [ i ] ; //<S2SV> atomic_init ( & td -> thread_mb_pos , 0 ) ; //<S2SV> atomic_init ( & td -> wait_mb_pos , INT_MAX ) ; //<S2SV> } //<S2SV> if ( is_vp7 ) //<S2SV> avctx -> execute2 ( avctx , vp7_decode_mb_row_sliced , s -> thread_data , NULL , //<S2SV> num_jobs ) ; //<S2SV> else //<S2SV> avctx -> execute2 ( avctx , vp8_decode_mb_row_sliced , s -> thread_data , NULL , //<S2SV> num_jobs ) ; //<S2SV> ff_thread_report_progress ( & curframe -> tf , INT_MAX , 0 ) ; //<S2SV> memcpy ( & s -> framep [ 0 ] , & s -> next_framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; //<S2SV> skip_decode : //<S2SV> if ( ! s -> update_probabilities ) //<S2SV> s -> prob [ 0 ] = s -> prob [ 1 ] ; //<S2SV> if ( ! s -> invisible ) { //<S2SV> if ( ( ret = av_frame_ref ( data , curframe -> tf . f ) ) < 0 ) //<S2SV> return ret ; //<S2SV> * got_frame = 1 ; //<S2SV> } //<S2SV> return avpkt -> size ; //<S2SV> err : //<S2SV> memcpy ( & s -> next_framep [ 0 ] , & s -> framep [ 0 ] , sizeof ( s -> framep [ 0 ] ) * 4 ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 