int ff_h263_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , //<S2SV> AVPacket * avpkt ) //<S2SV> { //<S2SV> const uint8_t * buf = avpkt -> data ; //<S2SV> int buf_size = avpkt -> size ; //<S2SV> MpegEncContext * s = avctx -> priv_data ; //<S2SV> int ret ; //<S2SV> int slice_ret = 0 ; //<S2SV> AVFrame * pict = data ; //<S2SV> if ( buf_size == 0 ) { //<S2SV> if ( s -> low_delay == 0 && s -> next_picture_ptr ) { //<S2SV> if ( ( ret = av_frame_ref ( pict , s -> next_picture_ptr -> f ) ) < 0 ) //<S2SV> return ret ; //<S2SV> s -> next_picture_ptr = NULL ; //<S2SV> * got_frame = 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( s -> avctx -> flags & AV_CODEC_FLAG_TRUNCATED ) { //<S2SV> int next ; //<S2SV> if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) { //<S2SV> next = ff_mpeg4_find_frame_end ( & s -> parse_context , buf , buf_size ) ; //<S2SV> } else if ( CONFIG_H263_DECODER && s -> codec_id == AV_CODEC_ID_H263 ) { //<S2SV> next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; //<S2SV> } else if ( CONFIG_H263P_DECODER && s -> codec_id == AV_CODEC_ID_H263P ) { //<S2SV> next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; //<S2SV> } else { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , //<S2SV> "this<S2SV_blank>codec<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>truncated<S2SV_blank>bitstreams\\n" ) ; //<S2SV> return AVERROR ( ENOSYS ) ; //<S2SV> } //<S2SV> if ( ff_combine_frame ( & s -> parse_context , next , ( const uint8_t * * ) & buf , //<S2SV> & buf_size ) < 0 ) //<S2SV> return buf_size ; //<S2SV> } //<S2SV> retry : //<S2SV> if ( s -> divx_packed && s -> bitstream_buffer_size ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < buf_size - 3 ; i ++ ) { //<S2SV> if ( buf [ i ] == 0 && buf [ i + 1 ] == 0 && buf [ i + 2 ] == 1 ) { //<S2SV> if ( buf [ i + 3 ] == 0xB0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_WARNING , "Discarding<S2SV_blank>excessive<S2SV_blank>bitstream<S2SV_blank>in<S2SV_blank>packed<S2SV_blank>xvid\\n" ) ; //<S2SV> s -> bitstream_buffer_size = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( s -> bitstream_buffer_size && ( s -> divx_packed || buf_size <= MAX_NVOP_SIZE ) ) //<S2SV> ret = init_get_bits8 ( & s -> gb , s -> bitstream_buffer , //<S2SV> s -> bitstream_buffer_size ) ; //<S2SV> else //<S2SV> ret = init_get_bits8 ( & s -> gb , buf , buf_size ) ; //<S2SV> s -> bitstream_buffer_size = 0 ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( ! s -> context_initialized ) //<S2SV> ff_mpv_idct_init ( s ) ; //<S2SV> if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { //<S2SV> ret = ff_wmv2_decode_picture_header ( s ) ; //<S2SV> } else if ( CONFIG_MSMPEG4_DECODER && s -> msmpeg4_version ) { //<S2SV> ret = ff_msmpeg4_decode_picture_header ( s ) ; //<S2SV> } else if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { //<S2SV> if ( s -> avctx -> extradata_size && s -> picture_number == 0 ) { //<S2SV> GetBitContext gb ; //<S2SV> if ( init_get_bits8 ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size ) >= 0 ) //<S2SV> ff_mpeg4_decode_picture_header ( avctx -> priv_data , & gb ) ; //<S2SV> } //<S2SV> ret = ff_mpeg4_decode_picture_header ( avctx -> priv_data , & s -> gb ) ; //<S2SV> } else if ( CONFIG_H263I_DECODER && s -> codec_id == AV_CODEC_ID_H263I ) { //<S2SV> ret = ff_intel_h263_decode_picture_header ( s ) ; //<S2SV> } else if ( CONFIG_FLV_DECODER && s -> h263_flv ) { //<S2SV> ret = ff_flv_decode_picture_header ( s ) ; //<S2SV> } else { //<S2SV> ret = ff_h263_decode_picture_header ( s ) ; //<S2SV> } //<S2SV> if ( ret < 0 || ret == FRAME_SKIPPED ) { //<S2SV> if ( s -> width != avctx -> coded_width //<S2SV> || s -> height != avctx -> coded_height ) { //<S2SV> av_log ( s -> avctx , AV_LOG_WARNING , "Reverting<S2SV_blank>picture<S2SV_blank>dimensions<S2SV_blank>change<S2SV_blank>due<S2SV_blank>to<S2SV_blank>header<S2SV_blank>decoding<S2SV_blank>failure\\n" ) ; //<S2SV> s -> width = avctx -> coded_width ; //<S2SV> s -> height = avctx -> coded_height ; //<S2SV> } //<S2SV> } //<S2SV> if ( ret == FRAME_SKIPPED ) //<S2SV> return get_consumed_bytes ( s , buf_size ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> av_log ( s -> avctx , AV_LOG_ERROR , "header<S2SV_blank>damaged\\n" ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( ! s -> context_initialized ) { //<S2SV> avctx -> pix_fmt = h263_get_format ( avctx ) ; //<S2SV> if ( ( ret = ff_mpv_common_init ( s ) ) < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( ! s -> current_picture_ptr || s -> current_picture_ptr -> f -> data [ 0 ] ) { //<S2SV> int i = ff_find_unused_picture ( s -> avctx , s -> picture , 0 ) ; //<S2SV> if ( i < 0 ) //<S2SV> return i ; //<S2SV> s -> current_picture_ptr = & s -> picture [ i ] ; //<S2SV> } //<S2SV> avctx -> has_b_frames = ! s -> low_delay ; //<S2SV> if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { //<S2SV> if ( ff_mpeg4_workaround_bugs ( avctx ) == 1 ) //<S2SV> goto retry ; //<S2SV> if ( s -> studio_profile != ( s -> idsp . idct == NULL ) ) //<S2SV> ff_mpv_idct_init ( s ) ; //<S2SV> } //<S2SV> if ( s -> width != avctx -> coded_width || //<S2SV> s -> height != avctx -> coded_height || //<S2SV> s -> context_reinit ) { //<S2SV> s -> context_reinit = 0 ; //<S2SV> ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> ff_set_sar ( avctx , avctx -> sample_aspect_ratio ) ; //<S2SV> if ( ( ret = ff_mpv_common_frame_size_change ( s ) ) ) //<S2SV> return ret ; //<S2SV> if ( avctx -> pix_fmt != h263_get_format ( avctx ) ) { //<S2SV> av_log ( avctx , AV_LOG_ERROR , "format<S2SV_blank>change<S2SV_blank>not<S2SV_blank>supported\\n" ) ; //<S2SV> avctx -> pix_fmt = AV_PIX_FMT_NONE ; //<S2SV> return AVERROR_UNKNOWN ; //<S2SV> } //<S2SV> } //<S2SV> if ( s -> codec_id == AV_CODEC_ID_H263 || //<S2SV> s -> codec_id == AV_CODEC_ID_H263P || //<S2SV> s -> codec_id == AV_CODEC_ID_H263I ) //<S2SV> s -> gob_index = H263_GOB_HEIGHT ( s -> height ) ; //<S2SV> s -> current_picture . f -> pict_type = s -> pict_type ; //<S2SV> s -> current_picture . f -> key_frame = s -> pict_type == AV_PICTURE_TYPE_I ; //<S2SV> if ( ! s -> last_picture_ptr && //<S2SV> ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) //<S2SV> return get_consumed_bytes ( s , buf_size ) ; //<S2SV> if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && //<S2SV> s -> pict_type == AV_PICTURE_TYPE_B ) || //<S2SV> ( avctx -> skip_frame >= AVDISCARD_NONKEY && //<S2SV> s -> pict_type != AV_PICTURE_TYPE_I ) || //<S2SV> avctx -> skip_frame >= AVDISCARD_ALL ) //<S2SV> return get_consumed_bytes ( s , buf_size ) ; //<S2SV> if ( s -> next_p_frame_damaged ) { //<S2SV> if ( s -> pict_type == AV_PICTURE_TYPE_B ) //<S2SV> return get_consumed_bytes ( s , buf_size ) ; //<S2SV> else //<S2SV> s -> next_p_frame_damaged = 0 ; //<S2SV> } //<S2SV> if ( ( ! s -> no_rounding ) || s -> pict_type == AV_PICTURE_TYPE_B ) { //<S2SV> s -> me . qpel_put = s -> qdsp . put_qpel_pixels_tab ; //<S2SV> s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; //<S2SV> } else { //<S2SV> s -> me . qpel_put = s -> qdsp . put_no_rnd_qpel_pixels_tab ; //<S2SV> s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; //<S2SV> } //<S2SV> if ( ( ret = ff_mpv_frame_start ( s , avctx ) ) < 0 ) //<S2SV> return ret ; //<S2SV> if ( ! s -> divx_packed ) //<S2SV> ff_thread_finish_setup ( avctx ) ; //<S2SV> if ( avctx -> hwaccel ) { //<S2SV> ret = avctx -> hwaccel -> start_frame ( avctx , s -> gb . buffer , //<S2SV> s -> gb . buffer_end - s -> gb . buffer ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> ff_mpeg_er_frame_start ( s ) ; //<S2SV> if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { //<S2SV> ret = ff_wmv2_decode_secondary_picture_header ( s ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> if ( ret == 1 ) //<S2SV> goto frame_end ; //<S2SV> } //<S2SV> s -> mb_x = 0 ; //<S2SV> s -> mb_y = 0 ; //<S2SV> slice_ret = decode_slice ( s ) ; //<S2SV> while ( s -> mb_y < s -> mb_height ) { //<S2SV> if ( s -> msmpeg4_version ) { //<S2SV> if ( s -> slice_height == 0 || s -> mb_x != 0 || slice_ret < 0 || //<S2SV> ( s -> mb_y % s -> slice_height ) != 0 || get_bits_left ( & s -> gb ) < 0 ) //<S2SV> break ; //<S2SV> } else { //<S2SV> int prev_x = s -> mb_x , prev_y = s -> mb_y ; //<S2SV> if ( ff_h263_resync ( s ) < 0 ) //<S2SV> break ; //<S2SV> if ( prev_y * s -> mb_width + prev_x < s -> mb_y * s -> mb_width + s -> mb_x ) //<S2SV> s -> er . error_occurred = 1 ; //<S2SV> } //<S2SV> if ( s -> msmpeg4_version < 4 && s -> h263_pred ) //<S2SV> ff_mpeg4_clean_buffers ( s ) ; //<S2SV> if ( decode_slice ( s ) < 0 ) //<S2SV> slice_ret = AVERROR_INVALIDDATA ; //<S2SV> } //<S2SV> if ( s -> msmpeg4_version && s -> msmpeg4_version < 4 && //<S2SV> s -> pict_type == AV_PICTURE_TYPE_I ) //<S2SV> if ( ! CONFIG_MSMPEG4_DECODER || //<S2SV> ff_msmpeg4_decode_ext_header ( s , buf_size ) < 0 ) //<S2SV> s -> er . error_status_table [ s -> mb_num - 1 ] = ER_MB_ERROR ; //<S2SV> av_assert1 ( s -> bitstream_buffer_size == 0 ) ; //<S2SV> frame_end : //<S2SV> if ( ! s -> studio_profile ) //<S2SV> ff_er_frame_end ( & s -> er ) ; //<S2SV> if ( avctx -> hwaccel ) { //<S2SV> ret = avctx -> hwaccel -> end_frame ( avctx ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> ff_mpv_frame_end ( s ) ; //<S2SV> if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) //<S2SV> ff_mpeg4_frame_end ( avctx , buf , buf_size ) ; //<S2SV> if ( ! s -> divx_packed && avctx -> hwaccel ) //<S2SV> ff_thread_finish_setup ( avctx ) ; //<S2SV> av_assert1 ( s -> current_picture . f -> pict_type == s -> current_picture_ptr -> f -> pict_type ) ; //<S2SV> av_assert1 ( s -> current_picture . f -> pict_type == s -> pict_type ) ; //<S2SV> if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { //<S2SV> if ( ( ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ) < 0 ) //<S2SV> return ret ; //<S2SV> ff_print_debug_info ( s , s -> current_picture_ptr , pict ) ; //<S2SV> ff_mpv_export_qp_table ( s , pict , s -> current_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; //<S2SV> } else if ( s -> last_picture_ptr ) { //<S2SV> if ( ( ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ) < 0 ) //<S2SV> return ret ; //<S2SV> ff_print_debug_info ( s , s -> last_picture_ptr , pict ) ; //<S2SV> ff_mpv_export_qp_table ( s , pict , s -> last_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; //<S2SV> } //<S2SV> if ( s -> last_picture_ptr || s -> low_delay ) { //<S2SV> if ( pict -> format == AV_PIX_FMT_YUV420P //<S2SV> && ( s -> codec_tag == AV_RL32 ( "GEOV" ) || s -> codec_tag == AV_RL32 ( "GEOX" ) ) ) { //<S2SV> int x , y , p ; //<S2SV> av_frame_make_writable ( pict ) ; //<S2SV> for ( p = 0 ; p < 3 ; p ++ ) { //<S2SV> int w = AV_CEIL_RSHIFT ( pict -> width , ! ! p ) ; //<S2SV> int h = AV_CEIL_RSHIFT ( pict -> height , ! ! p ) ; //<S2SV> int linesize = pict -> linesize [ p ] ; //<S2SV> for ( y = 0 ; y < ( h >> 1 ) ; y ++ ) //<S2SV> for ( x = 0 ; x < w ; x ++ ) //<S2SV> FFSWAP ( int , //<S2SV> pict -> data [ p ] [ x + y * linesize ] , //<S2SV> pict -> data [ p ] [ x + ( h - 1 - y ) * linesize ] ) ; //<S2SV> } //<S2SV> } //<S2SV> * got_frame = 1 ; //<S2SV> } //<S2SV> if ( slice_ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) //<S2SV> return slice_ret ; //<S2SV> else //<S2SV> return get_consumed_bytes ( s , buf_size ) ; //<S2SV> } //<S2SV> 