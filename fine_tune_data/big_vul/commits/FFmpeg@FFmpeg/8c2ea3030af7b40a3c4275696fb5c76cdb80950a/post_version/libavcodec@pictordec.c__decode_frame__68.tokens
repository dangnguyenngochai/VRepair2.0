static int decode_frame ( AVCodecContext * avctx , //<S2SV> void * data , int * got_frame , //<S2SV> AVPacket * avpkt ) //<S2SV> { //<S2SV> PicContext * s = avctx -> priv_data ; //<S2SV> AVFrame * frame = data ; //<S2SV> uint32_t * palette ; //<S2SV> int bits_per_plane , bpp , etype , esize , npal , pos_after_pal ; //<S2SV> int i , x , y , plane , tmp , ret , val ; //<S2SV> bytestream2_init ( & s -> g , avpkt -> data , avpkt -> size ) ; //<S2SV> if ( bytestream2_get_bytes_left ( & s -> g ) < 11 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> if ( bytestream2_get_le16u ( & s -> g ) != 0x1234 ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> s -> width = bytestream2_get_le16u ( & s -> g ) ; //<S2SV> s -> height = bytestream2_get_le16u ( & s -> g ) ; //<S2SV> bytestream2_skip ( & s -> g , 4 ) ; //<S2SV> tmp = bytestream2_get_byteu ( & s -> g ) ; //<S2SV> bits_per_plane = tmp & 0xF ; //<S2SV> s -> nb_planes = ( tmp >> 4 ) + 1 ; //<S2SV> bpp = bits_per_plane * s -> nb_planes ; //<S2SV> if ( bits_per_plane > 8 || bpp < 1 || bpp > 32 ) { //<S2SV> avpriv_request_sample ( avctx , "Unsupported<S2SV_blank>bit<S2SV_blank>depth" ) ; //<S2SV> return AVERROR_PATCHWELCOME ; //<S2SV> } //<S2SV> if ( bytestream2_peek_byte ( & s -> g ) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8 ) { //<S2SV> bytestream2_skip ( & s -> g , 2 ) ; //<S2SV> etype = bytestream2_get_le16 ( & s -> g ) ; //<S2SV> esize = bytestream2_get_le16 ( & s -> g ) ; //<S2SV> if ( bytestream2_get_bytes_left ( & s -> g ) < esize ) //<S2SV> return AVERROR_INVALIDDATA ; //<S2SV> } else { //<S2SV> etype = - 1 ; //<S2SV> esize = 0 ; //<S2SV> } //<S2SV> avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; //<S2SV> if ( av_image_check_size ( s -> width , s -> height , 0 , avctx ) < 0 ) //<S2SV> return - 1 ; //<S2SV> if ( s -> width != avctx -> width || s -> height != avctx -> height ) { //<S2SV> ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; //<S2SV> if ( ret < 0 ) //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) //<S2SV> return ret ; //<S2SV> memset ( frame -> data [ 0 ] , 0 , s -> height * frame -> linesize [ 0 ] ) ; //<S2SV> frame -> pict_type = AV_PICTURE_TYPE_I ; //<S2SV> frame -> palette_has_changed = 1 ; //<S2SV> pos_after_pal = bytestream2_tell ( & s -> g ) + esize ; //<S2SV> palette = ( uint32_t * ) frame -> data [ 1 ] ; //<S2SV> if ( etype == 1 && esize > 1 && bytestream2_peek_byte ( & s -> g ) < 6 ) { //<S2SV> int idx = bytestream2_get_byte ( & s -> g ) ; //<S2SV> npal = 4 ; //<S2SV> for ( i = 0 ; i < npal ; i ++ ) //<S2SV> palette [ i ] = ff_cga_palette [ cga_mode45_index [ idx ] [ i ] ] ; //<S2SV> } else if ( etype == 2 ) { //<S2SV> npal = FFMIN ( esize , 16 ) ; //<S2SV> for ( i = 0 ; i < npal ; i ++ ) { //<S2SV> int pal_idx = bytestream2_get_byte ( & s -> g ) ; //<S2SV> palette [ i ] = ff_cga_palette [ FFMIN ( pal_idx , 15 ) ] ; //<S2SV> } //<S2SV> } else if ( etype == 3 ) { //<S2SV> npal = FFMIN ( esize , 16 ) ; //<S2SV> for ( i = 0 ; i < npal ; i ++ ) { //<S2SV> int pal_idx = bytestream2_get_byte ( & s -> g ) ; //<S2SV> palette [ i ] = ff_ega_palette [ FFMIN ( pal_idx , 63 ) ] ; //<S2SV> } //<S2SV> } else if ( etype == 4 || etype == 5 ) { //<S2SV> npal = FFMIN ( esize / 3 , 256 ) ; //<S2SV> for ( i = 0 ; i < npal ; i ++ ) { //<S2SV> palette [ i ] = bytestream2_get_be24 ( & s -> g ) << 2 ; //<S2SV> palette [ i ] |= 0xFFU << 24 | palette [ i ] >> 6 & 0x30303 ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( bpp == 1 ) { //<S2SV> npal = 2 ; //<S2SV> palette [ 0 ] = 0xFF000000 ; //<S2SV> palette [ 1 ] = 0xFFFFFFFF ; //<S2SV> } else if ( bpp == 2 ) { //<S2SV> npal = 4 ; //<S2SV> for ( i = 0 ; i < npal ; i ++ ) //<S2SV> palette [ i ] = ff_cga_palette [ cga_mode45_index [ 0 ] [ i ] ] ; //<S2SV> } else { //<S2SV> npal = 16 ; //<S2SV> memcpy ( palette , ff_cga_palette , npal * 4 ) ; //<S2SV> } //<S2SV> } //<S2SV> memset ( palette + npal , 0 , AVPALETTE_SIZE - npal * 4 ) ; //<S2SV> bytestream2_seek ( & s -> g , pos_after_pal , SEEK_SET ) ; //<S2SV> val = 0 ; //<S2SV> y = s -> height - 1 ; //<S2SV> if ( bytestream2_get_le16 ( & s -> g ) ) { //<S2SV> x = 0 ; //<S2SV> plane = 0 ; //<S2SV> while ( bytestream2_get_bytes_left ( & s -> g ) >= 6 ) { //<S2SV> int stop_size , marker , t1 , t2 ; //<S2SV> t1 = bytestream2_get_bytes_left ( & s -> g ) ; //<S2SV> t2 = bytestream2_get_le16 ( & s -> g ) ; //<S2SV> stop_size = t1 - FFMIN ( t1 , t2 ) ; //<S2SV> bytestream2_skip ( & s -> g , 2 ) ; //<S2SV> marker = bytestream2_get_byte ( & s -> g ) ; //<S2SV> while ( plane < s -> nb_planes && //<S2SV> bytestream2_get_bytes_left ( & s -> g ) > stop_size ) { //<S2SV> int run = 1 ; //<S2SV> val = bytestream2_get_byte ( & s -> g ) ; //<S2SV> if ( val == marker ) { //<S2SV> run = bytestream2_get_byte ( & s -> g ) ; //<S2SV> if ( run == 0 ) //<S2SV> run = bytestream2_get_le16 ( & s -> g ) ; //<S2SV> val = bytestream2_get_byte ( & s -> g ) ; //<S2SV> } //<S2SV> if ( ! bytestream2_get_bytes_left ( & s -> g ) ) //<S2SV> break ; //<S2SV> if ( bits_per_plane == 8 ) { //<S2SV> picmemset_8bpp ( s , frame , val , run , & x , & y ) ; //<S2SV> if ( y < 0 ) //<S2SV> goto finish ; //<S2SV> } else { //<S2SV> picmemset ( s , frame , val , run , & x , & y , & plane , bits_per_plane ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( x < avctx -> width ) { //<S2SV> int run = ( y + 1 ) * avctx -> width - x ; //<S2SV> if ( bits_per_plane == 8 ) //<S2SV> picmemset_8bpp ( s , frame , val , run , & x , & y ) ; //<S2SV> else //<S2SV> picmemset ( s , frame , val , run / ( 8 / bits_per_plane ) , & x , & y , & plane , bits_per_plane ) ; //<S2SV> } //<S2SV> } else { //<S2SV> while ( y >= 0 && bytestream2_get_bytes_left ( & s -> g ) > 0 ) { //<S2SV> memcpy ( frame -> data [ 0 ] + y * frame -> linesize [ 0 ] , s -> g . buffer , FFMIN ( avctx -> width , bytestream2_get_bytes_left ( & s -> g ) ) ) ; //<S2SV> bytestream2_skip ( & s -> g , avctx -> width ) ; //<S2SV> y -- ; //<S2SV> } //<S2SV> } //<S2SV> finish : //<S2SV> * got_frame = 1 ; //<S2SV> return avpkt -> size ; //<S2SV> } //<S2SV> 