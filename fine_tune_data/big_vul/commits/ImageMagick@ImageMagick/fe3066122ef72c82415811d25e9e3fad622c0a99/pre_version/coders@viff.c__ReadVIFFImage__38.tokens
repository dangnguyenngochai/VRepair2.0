static Image * ReadVIFFImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define VFF_CM_genericRGB 15 //<S2SV> # define VFF_CM_ntscRGB 1 //<S2SV> # define VFF_CM_NONE 0 //<S2SV> # define VFF_DEP_DECORDER 0x4 //<S2SV> # define VFF_DEP_NSORDER 0x8 //<S2SV> # define VFF_DES_RAW 0 //<S2SV> # define VFF_LOC_IMPLICIT 1 //<S2SV> # define VFF_MAPTYP_NONE 0 //<S2SV> # define VFF_MAPTYP_1_BYTE 1 //<S2SV> # define VFF_MAPTYP_2_BYTE 2 //<S2SV> # define VFF_MAPTYP_4_BYTE 4 //<S2SV> # define VFF_MAPTYP_FLOAT 5 //<S2SV> # define VFF_MAPTYP_DOUBLE 7 //<S2SV> # define VFF_MS_NONE 0 //<S2SV> # define VFF_MS_ONEPERBAND 1 //<S2SV> # define VFF_MS_SHARED 3 //<S2SV> # define VFF_TYP_BIT 0 //<S2SV> # define VFF_TYP_1_BYTE 1 //<S2SV> # define VFF_TYP_2_BYTE 2 //<S2SV> # define VFF_TYP_4_BYTE 4 //<S2SV> # define VFF_TYP_FLOAT 5 //<S2SV> # define VFF_TYP_DOUBLE 9 //<S2SV> typedef struct _ViffInfo //<S2SV> { //<S2SV> unsigned char //<S2SV> identifier , //<S2SV> file_type , //<S2SV> release , //<S2SV> version , //<S2SV> machine_dependency , //<S2SV> reserve [ 3 ] ; //<S2SV> char //<S2SV> comment [ 512 ] ; //<S2SV> unsigned int //<S2SV> rows , //<S2SV> columns , //<S2SV> subrows ; //<S2SV> int //<S2SV> x_offset , //<S2SV> y_offset ; //<S2SV> float //<S2SV> x_bits_per_pixel , //<S2SV> y_bits_per_pixel ; //<S2SV> unsigned int //<S2SV> location_type , //<S2SV> location_dimension , //<S2SV> number_of_images , //<S2SV> number_data_bands , //<S2SV> data_storage_type , //<S2SV> data_encode_scheme , //<S2SV> map_scheme , //<S2SV> map_storage_type , //<S2SV> map_rows , //<S2SV> map_columns , //<S2SV> map_subrows , //<S2SV> map_enable , //<S2SV> maps_per_cycle , //<S2SV> color_space_model ; //<S2SV> } ViffInfo ; //<S2SV> double //<S2SV> min_value , //<S2SV> scale_factor , //<S2SV> value ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> bit ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickSizeType //<S2SV> number_pixels ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bytes_per_pixel , //<S2SV> max_packets , //<S2SV> quantum ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * pixels ; //<S2SV> unsigned long //<S2SV> lsb_first ; //<S2SV> ViffInfo //<S2SV> viff_info ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , 1 , & viff_info . identifier ) ; //<S2SV> do //<S2SV> { //<S2SV> if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "NotAVIFFImage" ) ; //<S2SV> ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; //<S2SV> ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; //<S2SV> ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; //<S2SV> ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , //<S2SV> & viff_info . machine_dependency ) ; //<S2SV> ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; //<S2SV> count = ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; //<S2SV> if ( count != 512 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> viff_info . comment [ 511 ] = '\\0' ; //<S2SV> if ( strlen ( viff_info . comment ) > 4 ) //<S2SV> ( void ) SetImageProperty ( image , "comment" , viff_info . comment , exception ) ; //<S2SV> if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || //<S2SV> ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) //<S2SV> image -> endian = LSBEndian ; //<S2SV> else //<S2SV> image -> endian = MSBEndian ; //<S2SV> viff_info . rows = ReadBlobLong ( image ) ; //<S2SV> viff_info . columns = ReadBlobLong ( image ) ; //<S2SV> viff_info . subrows = ReadBlobLong ( image ) ; //<S2SV> viff_info . x_offset = ReadBlobSignedLong ( image ) ; //<S2SV> viff_info . y_offset = ReadBlobSignedLong ( image ) ; //<S2SV> viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; //<S2SV> viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; //<S2SV> viff_info . location_type = ReadBlobLong ( image ) ; //<S2SV> viff_info . location_dimension = ReadBlobLong ( image ) ; //<S2SV> viff_info . number_of_images = ReadBlobLong ( image ) ; //<S2SV> viff_info . number_data_bands = ReadBlobLong ( image ) ; //<S2SV> viff_info . data_storage_type = ReadBlobLong ( image ) ; //<S2SV> viff_info . data_encode_scheme = ReadBlobLong ( image ) ; //<S2SV> viff_info . map_scheme = ReadBlobLong ( image ) ; //<S2SV> viff_info . map_storage_type = ReadBlobLong ( image ) ; //<S2SV> viff_info . map_rows = ReadBlobLong ( image ) ; //<S2SV> viff_info . map_columns = ReadBlobLong ( image ) ; //<S2SV> viff_info . map_subrows = ReadBlobLong ( image ) ; //<S2SV> viff_info . map_enable = ReadBlobLong ( image ) ; //<S2SV> viff_info . maps_per_cycle = ReadBlobLong ( image ) ; //<S2SV> viff_info . color_space_model = ReadBlobLong ( image ) ; //<S2SV> for ( i = 0 ; i < 420 ; i ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; //<S2SV> if ( number_pixels > GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> if ( number_pixels != ( size_t ) number_pixels ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> if ( number_pixels == 0 ) //<S2SV> ThrowReaderException ( CoderError , "ImageColumnOrRowSizeIsNotSupported" ) ; //<S2SV> image -> columns = viff_info . rows ; //<S2SV> image -> rows = viff_info . columns ; //<S2SV> image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : //<S2SV> MAGICKCORE_QUANTUM_DEPTH ; //<S2SV> image -> alpha_trait = viff_info . number_data_bands == 4 ? BlendPixelTrait : //<S2SV> UndefinedPixelTrait ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> ( void ) SetImageBackgroundColor ( image , exception ) ; //<S2SV> if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && //<S2SV> ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && //<S2SV> ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && //<S2SV> ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && //<S2SV> ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && //<S2SV> ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) //<S2SV> ThrowReaderException ( CoderError , "DataStorageTypeIsNotSupported" ) ; //<S2SV> if ( viff_info . data_encode_scheme != VFF_DES_RAW ) //<S2SV> ThrowReaderException ( CoderError , "DataEncodingSchemeIsNotSupported" ) ; //<S2SV> if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && //<S2SV> ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && //<S2SV> ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && //<S2SV> ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && //<S2SV> ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && //<S2SV> ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) //<S2SV> ThrowReaderException ( CoderError , "MapStorageTypeIsNotSupported" ) ; //<S2SV> if ( ( viff_info . color_space_model != VFF_CM_NONE ) && //<S2SV> ( viff_info . color_space_model != VFF_CM_ntscRGB ) && //<S2SV> ( viff_info . color_space_model != VFF_CM_genericRGB ) ) //<S2SV> ThrowReaderException ( CoderError , "ColorspaceModelIsNotSupported" ) ; //<S2SV> if ( viff_info . location_type != VFF_LOC_IMPLICIT ) //<S2SV> ThrowReaderException ( CoderError , "LocationTypeIsNotSupported" ) ; //<S2SV> if ( viff_info . number_of_images != 1 ) //<S2SV> ThrowReaderException ( CoderError , "NumberOfImagesIsNotSupported" ) ; //<S2SV> if ( viff_info . map_rows == 0 ) //<S2SV> viff_info . map_scheme = VFF_MS_NONE ; //<S2SV> switch ( ( int ) viff_info . map_scheme ) //<S2SV> { //<S2SV> case VFF_MS_NONE : //<S2SV> { //<S2SV> if ( viff_info . number_data_bands < 3 ) //<S2SV> { //<S2SV> if ( viff_info . data_storage_type == VFF_TYP_BIT ) //<S2SV> image -> colors = 2 ; //<S2SV> else //<S2SV> if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) //<S2SV> image -> colors = 256UL ; //<S2SV> else //<S2SV> image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; //<S2SV> status = AcquireImageColormap ( image , image -> colors , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case VFF_MS_ONEPERBAND : //<S2SV> case VFF_MS_SHARED : //<S2SV> { //<S2SV> unsigned char //<S2SV> * viff_colormap ; //<S2SV> switch ( ( int ) viff_info . map_storage_type ) //<S2SV> { //<S2SV> case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; //<S2SV> case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; //<S2SV> case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; //<S2SV> case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; //<S2SV> case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; //<S2SV> default : bytes_per_pixel = 1 ; break ; //<S2SV> } //<S2SV> image -> colors = viff_info . map_columns ; //<S2SV> if ( ( MagickSizeType ) ( viff_info . map_rows * image -> colors ) > GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> if ( ( MagickSizeType ) viff_info . map_rows > GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> if ( ( MagickSizeType ) viff_info . map_rows > //<S2SV> ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , //<S2SV> viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; //<S2SV> if ( viff_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , //<S2SV> viff_colormap ) ; //<S2SV> lsb_first = 1 ; //<S2SV> if ( * ( char * ) & lsb_first && //<S2SV> ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && //<S2SV> ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) //<S2SV> switch ( ( int ) viff_info . map_storage_type ) //<S2SV> { //<S2SV> case VFF_MAPTYP_2_BYTE : //<S2SV> { //<S2SV> MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * //<S2SV> viff_info . map_rows ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case VFF_MAPTYP_4_BYTE : //<S2SV> case VFF_MAPTYP_FLOAT : //<S2SV> { //<S2SV> MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * //<S2SV> viff_info . map_rows ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : break ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) //<S2SV> { //<S2SV> switch ( ( int ) viff_info . map_storage_type ) //<S2SV> { //<S2SV> case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; //<S2SV> case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; //<S2SV> case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; //<S2SV> case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; //<S2SV> default : value = 1.0 * viff_colormap [ i ] ; break ; //<S2SV> } //<S2SV> if ( i < ( ssize_t ) image -> colors ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ( MagickRealType ) //<S2SV> ScaleCharToQuantum ( ( unsigned char ) value ) ; //<S2SV> image -> colormap [ i ] . green = ( MagickRealType ) //<S2SV> ScaleCharToQuantum ( ( unsigned char ) value ) ; //<S2SV> image -> colormap [ i ] . blue = ( MagickRealType ) //<S2SV> ScaleCharToQuantum ( ( unsigned char ) value ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( i < ( ssize_t ) ( 2 * image -> colors ) ) //<S2SV> image -> colormap [ i % image -> colors ] . green = ( MagickRealType ) //<S2SV> ScaleCharToQuantum ( ( unsigned char ) value ) ; //<S2SV> else //<S2SV> if ( i < ( ssize_t ) ( 3 * image -> colors ) ) //<S2SV> image -> colormap [ i % image -> colors ] . blue = ( MagickRealType ) //<S2SV> ScaleCharToQuantum ( ( unsigned char ) value ) ; //<S2SV> } //<S2SV> viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; //<S2SV> } //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( viff_info . data_storage_type == VFF_TYP_BIT ) //<S2SV> { //<S2SV> image -> colors = 2 ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> image -> colorspace = GRAYColorspace ; //<S2SV> } //<S2SV> switch ( ( int ) viff_info . data_storage_type ) //<S2SV> { //<S2SV> case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; //<S2SV> case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; //<S2SV> case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; //<S2SV> case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; //<S2SV> default : bytes_per_pixel = 1 ; break ; //<S2SV> } //<S2SV> if ( viff_info . data_storage_type == VFF_TYP_BIT ) //<S2SV> { //<S2SV> if ( HeapOverflowSanityCheck ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( HeapOverflowSanityCheck ( ( size_t ) number_pixels , viff_info . number_data_bands ) != MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; //<S2SV> } //<S2SV> if ( ( MagickSizeType ) ( bytes_per_pixel * max_packets ) > GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> pixels = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( //<S2SV> number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; //<S2SV> if ( pixels == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) memset ( pixels , 0 , MagickMax ( number_pixels , max_packets ) * //<S2SV> bytes_per_pixel * sizeof ( * pixels ) ) ; //<S2SV> count = ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; //<S2SV> lsb_first = 1 ; //<S2SV> if ( * ( char * ) & lsb_first && //<S2SV> ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && //<S2SV> ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) //<S2SV> switch ( ( int ) viff_info . data_storage_type ) //<S2SV> { //<S2SV> case VFF_TYP_2_BYTE : //<S2SV> { //<S2SV> MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case VFF_TYP_4_BYTE : //<S2SV> case VFF_TYP_FLOAT : //<S2SV> { //<S2SV> MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : break ; //<S2SV> } //<S2SV> min_value = 0.0 ; //<S2SV> scale_factor = 1.0 ; //<S2SV> if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && //<S2SV> ( viff_info . map_scheme == VFF_MS_NONE ) ) //<S2SV> { //<S2SV> double //<S2SV> max_value ; //<S2SV> switch ( ( int ) viff_info . data_storage_type ) //<S2SV> { //<S2SV> case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; //<S2SV> case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; //<S2SV> case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; //<S2SV> case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; //<S2SV> default : value = 1.0 * pixels [ 0 ] ; break ; //<S2SV> } //<S2SV> max_value = value ; //<S2SV> min_value = value ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) //<S2SV> { //<S2SV> switch ( ( int ) viff_info . data_storage_type ) //<S2SV> { //<S2SV> case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; //<S2SV> case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; //<S2SV> case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; //<S2SV> case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; //<S2SV> default : value = 1.0 * pixels [ i ] ; break ; //<S2SV> } //<S2SV> if ( value > max_value ) //<S2SV> max_value = value ; //<S2SV> else //<S2SV> if ( value < min_value ) //<S2SV> min_value = value ; //<S2SV> } //<S2SV> if ( ( min_value == 0 ) && ( max_value == 0 ) ) //<S2SV> scale_factor = 0 ; //<S2SV> else //<S2SV> if ( min_value == max_value ) //<S2SV> { //<S2SV> scale_factor = ( double ) QuantumRange / min_value ; //<S2SV> min_value = 0 ; //<S2SV> } //<S2SV> else //<S2SV> scale_factor = ( double ) QuantumRange / ( max_value - min_value ) ; //<S2SV> } //<S2SV> p = ( unsigned char * ) pixels ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) //<S2SV> { //<S2SV> switch ( ( int ) viff_info . data_storage_type ) //<S2SV> { //<S2SV> case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; //<S2SV> case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; //<S2SV> case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; //<S2SV> case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; //<S2SV> default : value = 1.0 * pixels [ i ] ; break ; //<S2SV> } //<S2SV> if ( viff_info . map_scheme == VFF_MS_NONE ) //<S2SV> { //<S2SV> value = ( value - min_value ) * scale_factor ; //<S2SV> if ( value > QuantumRange ) //<S2SV> value = QuantumRange ; //<S2SV> else //<S2SV> if ( value < 0 ) //<S2SV> value = 0 ; //<S2SV> } //<S2SV> * p = ( unsigned char ) ( ( Quantum ) value ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> p = ( unsigned char * ) pixels ; //<S2SV> if ( viff_info . data_storage_type == VFF_TYP_BIT ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; //<S2SV> SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; //<S2SV> SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; //<S2SV> SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> SetPixelIndex ( image , ( Quantum ) quantum , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) //<S2SV> { //<S2SV> quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; //<S2SV> SetPixelRed ( image , quantum == 0 ? 0 : QuantumRange , q ) ; //<S2SV> SetPixelGreen ( image , quantum == 0 ? 0 : QuantumRange , q ) ; //<S2SV> SetPixelBlue ( image , quantum == 0 ? 0 : QuantumRange , q ) ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> SetPixelIndex ( image , ( Quantum ) quantum , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( image , * p ++ , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + number_pixels ) ) , q ) ; //<S2SV> SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) , q ) ; //<S2SV> if ( image -> colors != 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> index ; //<S2SV> index = ( ssize_t ) GetPixelRed ( image , q ) ; //<S2SV> SetPixelRed ( image , ClampToQuantum ( image -> colormap [ //<S2SV> ConstrainColormapIndex ( image , index , exception ) ] . red ) , q ) ; //<S2SV> index = ( ssize_t ) GetPixelGreen ( image , q ) ; //<S2SV> SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ //<S2SV> ConstrainColormapIndex ( image , index , exception ) ] . green ) , q ) ; //<S2SV> index = ( ssize_t ) GetPixelBlue ( image , q ) ; //<S2SV> SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ //<S2SV> ConstrainColormapIndex ( image , index , exception ) ] . blue ) , q ) ; //<S2SV> } //<S2SV> SetPixelAlpha ( image , image -> alpha_trait != UndefinedPixelTrait ? //<S2SV> ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueAlpha , q ) ; //<S2SV> p ++ ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> ( void ) SyncImage ( image , exception ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> count = ReadBlob ( image , 1 , & viff_info . identifier ) ; //<S2SV> if ( ( count == 1 ) && ( viff_info . identifier == 0xab ) ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 