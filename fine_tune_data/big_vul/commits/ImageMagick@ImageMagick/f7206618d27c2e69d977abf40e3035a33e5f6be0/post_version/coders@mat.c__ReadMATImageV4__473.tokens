static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> typedef struct { //<S2SV> unsigned char Type [ 4 ] ; //<S2SV> unsigned int nRows ; //<S2SV> unsigned int nCols ; //<S2SV> unsigned int imagf ; //<S2SV> unsigned int nameLen ; //<S2SV> } MAT4_HDR ; //<S2SV> long //<S2SV> ldblk ; //<S2SV> EndianType //<S2SV> endian ; //<S2SV> Image //<S2SV> * rotated_image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MAT4_HDR //<S2SV> HDR ; //<S2SV> QuantumInfo //<S2SV> * quantum_info ; //<S2SV> QuantumFormatType //<S2SV> format_type ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * pixels ; //<S2SV> unsigned int //<S2SV> depth ; //<S2SV> quantum_info = ( QuantumInfo * ) NULL ; //<S2SV> ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; //<S2SV> status = MagickTrue ; //<S2SV> while ( EOFBlob ( image ) == MagickFalse ) //<S2SV> { //<S2SV> ldblk = ReadBlobLSBLong ( image ) ; //<S2SV> if ( EOFBlob ( image ) ) break ; //<S2SV> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) //<S2SV> break ; //<S2SV> HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; //<S2SV> HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; //<S2SV> HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; //<S2SV> HDR . Type [ 0 ] = ldblk ; //<S2SV> if ( HDR . Type [ 3 ] != 0 ) //<S2SV> break ; //<S2SV> if ( HDR . Type [ 2 ] != 0 ) //<S2SV> break ; //<S2SV> if ( HDR . Type [ 0 ] == 0 ) //<S2SV> { //<S2SV> HDR . nRows = ReadBlobLSBLong ( image ) ; //<S2SV> HDR . nCols = ReadBlobLSBLong ( image ) ; //<S2SV> HDR . imagf = ReadBlobLSBLong ( image ) ; //<S2SV> HDR . nameLen = ReadBlobLSBLong ( image ) ; //<S2SV> endian = LSBEndian ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> HDR . nRows = ReadBlobMSBLong ( image ) ; //<S2SV> HDR . nCols = ReadBlobMSBLong ( image ) ; //<S2SV> HDR . imagf = ReadBlobMSBLong ( image ) ; //<S2SV> HDR . nameLen = ReadBlobMSBLong ( image ) ; //<S2SV> endian = MSBEndian ; //<S2SV> } //<S2SV> if ( ( HDR . imagf != 0 ) && ( HDR . imagf != 1 ) ) //<S2SV> break ; //<S2SV> if ( HDR . nameLen > 0xFFFF ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) HDR . nameLen ; i ++ ) //<S2SV> { //<S2SV> int //<S2SV> byte ; //<S2SV> byte = ReadBlobByte ( image ) ; //<S2SV> if ( byte == EOF ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> image -> columns = ( size_t ) HDR . nRows ; //<S2SV> image -> rows = ( size_t ) HDR . nCols ; //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> Swap ( image -> columns , image -> rows ) ; //<S2SV> if ( HDR . imagf == 1 ) ldblk *= 2 ; //<S2SV> SeekBlob ( image , HDR . nCols * ldblk , SEEK_CUR ) ; //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) //<S2SV> return ( image -> previous == ( Image * ) NULL ? DestroyImageList ( image ) //<S2SV> : image ) ; //<S2SV> goto skip_reading_current ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> ( void ) SetImageBackgroundColor ( image , exception ) ; //<S2SV> ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; //<S2SV> quantum_info = AcquireQuantumInfo ( image_info , image ) ; //<S2SV> if ( quantum_info == ( QuantumInfo * ) NULL ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> switch ( HDR . Type [ 1 ] ) //<S2SV> { //<S2SV> case 0 : //<S2SV> format_type = FloatingPointQuantumFormat ; //<S2SV> depth = 64 ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> format_type = FloatingPointQuantumFormat ; //<S2SV> depth = 32 ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> format_type = UnsignedQuantumFormat ; //<S2SV> depth = 16 ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> format_type = SignedQuantumFormat ; //<S2SV> depth = 16 ; //<S2SV> break ; //<S2SV> case 4 : //<S2SV> format_type = UnsignedQuantumFormat ; //<S2SV> depth = 8 ; //<S2SV> break ; //<S2SV> default : //<S2SV> format_type = UnsignedQuantumFormat ; //<S2SV> depth = 8 ; //<S2SV> break ; //<S2SV> } //<S2SV> image -> depth = depth ; //<S2SV> if ( HDR . Type [ 0 ] != 0 ) //<S2SV> SetQuantumEndian ( image , quantum_info , MSBEndian ) ; //<S2SV> status = SetQuantumFormat ( image , quantum_info , format_type ) ; //<S2SV> status = SetQuantumDepth ( image , quantum_info , depth ) ; //<S2SV> status = SetQuantumEndian ( image , quantum_info , endian ) ; //<S2SV> SetQuantumScale ( quantum_info , 1.0 ) ; //<S2SV> pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> register Quantum //<S2SV> * magick_restrict q ; //<S2SV> count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; //<S2SV> if ( count == - 1 ) //<S2SV> break ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , image -> rows - y - 1 , image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , //<S2SV> GrayQuantum , pixels , exception ) ; //<S2SV> if ( ( HDR . Type [ 1 ] == 2 ) || ( HDR . Type [ 1 ] == 3 ) ) //<S2SV> FixSignedValues ( image , q , ( int ) image -> columns ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( HDR . imagf == 1 ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; //<S2SV> if ( count == - 1 ) //<S2SV> break ; //<S2SV> if ( HDR . Type [ 1 ] == 0 ) //<S2SV> InsertComplexDoubleRow ( image , ( double * ) pixels , y , 0 , 0 , exception ) ; //<S2SV> else //<S2SV> InsertComplexFloatRow ( image , ( float * ) pixels , y , 0 , 0 , exception ) ; //<S2SV> } //<S2SV> if ( quantum_info != ( QuantumInfo * ) NULL ) //<S2SV> quantum_info = DestroyQuantumInfo ( quantum_info ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> rotated_image = RotateImage ( image , 90.0 , exception ) ; //<S2SV> if ( rotated_image != ( Image * ) NULL ) //<S2SV> { //<S2SV> rotated_image -> page . x = 0 ; //<S2SV> rotated_image -> page . y = 0 ; //<S2SV> rotated_image -> colors = image -> colors ; //<S2SV> DestroyBlob ( rotated_image ) ; //<S2SV> rotated_image -> blob = ReferenceBlob ( image -> blob ) ; //<S2SV> AppendImageToList ( & image , rotated_image ) ; //<S2SV> DeleteImageFromList ( & image ) ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> skip_reading_current : //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> break ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 