static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> Image //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickSizeType //<S2SV> number_pixels ; //<S2SV> MemoryInfo //<S2SV> * pixel_info ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> SGIInfo //<S2SV> iris_info ; //<S2SV> size_t //<S2SV> bytes_per_pixel , //<S2SV> quantum ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y , //<S2SV> z ; //<S2SV> unsigned char //<S2SV> * pixels ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> iris_info . magic = ReadBlobMSBShort ( image ) ; //<S2SV> do //<S2SV> { //<S2SV> if ( iris_info . magic != 0x01DA ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> switch ( iris_info . storage ) //<S2SV> { //<S2SV> case 0x00 : image -> compression = NoCompression ; break ; //<S2SV> case 0x01 : image -> compression = RLECompression ; break ; //<S2SV> default : //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> iris_info . dimension = ReadBlobMSBShort ( image ) ; //<S2SV> iris_info . columns = ReadBlobMSBShort ( image ) ; //<S2SV> iris_info . rows = ReadBlobMSBShort ( image ) ; //<S2SV> iris_info . depth = ReadBlobMSBShort ( image ) ; //<S2SV> if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> iris_info . minimum_value = ReadBlobMSBLong ( image ) ; //<S2SV> iris_info . maximum_value = ReadBlobMSBLong ( image ) ; //<S2SV> iris_info . sans = ReadBlobMSBLong ( image ) ; //<S2SV> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) //<S2SV> iris_info . name ) ; //<S2SV> iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; //<S2SV> if ( * iris_info . name != '\\0' ) //<S2SV> ( void ) SetImageProperty ( image , "label" , iris_info . name , exception ) ; //<S2SV> iris_info . pixel_format = ReadBlobMSBLong ( image ) ; //<S2SV> if ( iris_info . pixel_format != 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; //<S2SV> ( void ) count ; //<S2SV> image -> columns = iris_info . columns ; //<S2SV> image -> rows = iris_info . rows ; //<S2SV> image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; //<S2SV> if ( iris_info . pixel_format == 0 ) //<S2SV> image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * //<S2SV> iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; //<S2SV> if ( iris_info . depth < 3 ) //<S2SV> { //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; //<S2SV> } //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; //<S2SV> number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; //<S2SV> if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) //<S2SV> ( 4 * bytes_per_pixel * number_pixels ) ) ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * //<S2SV> bytes_per_pixel * sizeof ( * pixels ) ) ; //<S2SV> if ( pixel_info == ( MemoryInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; //<S2SV> if ( ( int ) iris_info . storage != 0x01 ) //<S2SV> { //<S2SV> unsigned char //<S2SV> * scanline ; //<S2SV> scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , //<S2SV> bytes_per_pixel * sizeof ( * scanline ) ) ; //<S2SV> if ( scanline == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) //<S2SV> { //<S2SV> p = pixels + bytes_per_pixel * z ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) //<S2SV> { //<S2SV> count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> break ; //<S2SV> if ( bytes_per_pixel == 2 ) //<S2SV> for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) //<S2SV> { //<S2SV> * p = scanline [ 2 * x ] ; //<S2SV> * ( p + 1 ) = scanline [ 2 * x + 1 ] ; //<S2SV> p += 8 ; //<S2SV> } //<S2SV> else //<S2SV> for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) //<S2SV> { //<S2SV> * p = scanline [ x ] ; //<S2SV> p += 4 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> MemoryInfo //<S2SV> * packet_info ; //<S2SV> size_t //<S2SV> * runlength ; //<S2SV> ssize_t //<S2SV> offset , //<S2SV> * offsets ; //<S2SV> unsigned char //<S2SV> * packets ; //<S2SV> unsigned int //<S2SV> data_order ; //<S2SV> offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , //<S2SV> iris_info . depth * sizeof ( * offsets ) ) ; //<S2SV> runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , //<S2SV> iris_info . depth * sizeof ( * runlength ) ) ; //<S2SV> packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * //<S2SV> sizeof ( * packets ) ) ; //<S2SV> if ( ( offsets == ( ssize_t * ) NULL ) || //<S2SV> ( runlength == ( size_t * ) NULL ) || //<S2SV> ( packet_info == ( MemoryInfo * ) NULL ) ) //<S2SV> { //<S2SV> if ( offsets == ( ssize_t * ) NULL ) //<S2SV> offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; //<S2SV> if ( runlength == ( size_t * ) NULL ) //<S2SV> runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; //<S2SV> if ( packet_info == ( MemoryInfo * ) NULL ) //<S2SV> packet_info = RelinquishVirtualMemory ( packet_info ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) //<S2SV> offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) //<S2SV> { //<S2SV> runlength [ i ] = ReadBlobMSBLong ( image ) ; //<S2SV> if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> offset = 0 ; //<S2SV> data_order = 0 ; //<S2SV> for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) //<S2SV> for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) //<S2SV> { //<S2SV> if ( offsets [ y + z * iris_info . rows ] < offset ) //<S2SV> data_order = 1 ; //<S2SV> offset = offsets [ y + z * iris_info . rows ] ; //<S2SV> } //<S2SV> offset = ( ssize_t ) TellBlob ( image ) ; //<S2SV> if ( data_order == 1 ) //<S2SV> { //<S2SV> for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) //<S2SV> { //<S2SV> p = pixels ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) //<S2SV> { //<S2SV> if ( offset != offsets [ y + z * iris_info . rows ] ) //<S2SV> { //<S2SV> offset = offsets [ y + z * iris_info . rows ] ; //<S2SV> offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , //<S2SV> packets ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> break ; //<S2SV> offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; //<S2SV> status = SGIDecode ( bytes_per_pixel , ( ssize_t ) //<S2SV> ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , //<S2SV> 1L * iris_info . columns , p + bytes_per_pixel * z ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> p += ( iris_info . columns * 4 * bytes_per_pixel ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> MagickOffsetType //<S2SV> position ; //<S2SV> position = TellBlob ( image ) ; //<S2SV> p = pixels ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) //<S2SV> { //<S2SV> for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) //<S2SV> { //<S2SV> if ( offset != offsets [ y + z * iris_info . rows ] ) //<S2SV> { //<S2SV> offset = offsets [ y + z * iris_info . rows ] ; //<S2SV> offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , //<S2SV> packets ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> break ; //<S2SV> offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; //<S2SV> status = SGIDecode ( bytes_per_pixel , ( ssize_t ) //<S2SV> ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , //<S2SV> 1L * iris_info . columns , p + bytes_per_pixel * z ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> p += ( iris_info . columns * 4 * bytes_per_pixel ) ; //<S2SV> } //<S2SV> offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; //<S2SV> } //<S2SV> packet_info = RelinquishVirtualMemory ( packet_info ) ; //<S2SV> runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; //<S2SV> offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; //<S2SV> } //<S2SV> image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : //<S2SV> UndefinedPixelTrait ; //<S2SV> image -> columns = iris_info . columns ; //<S2SV> image -> rows = iris_info . rows ; //<S2SV> if ( image -> storage_class == DirectClass ) //<S2SV> { //<S2SV> if ( bytes_per_pixel == 2 ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) //<S2SV> ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) //<S2SV> ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; //<S2SV> SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) //<S2SV> ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; //<S2SV> SetPixelAlpha ( image , OpaqueAlpha , q ) ; //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) //<S2SV> ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; //<S2SV> p += 8 ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> y , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; //<S2SV> SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; //<S2SV> SetPixelAlpha ( image , OpaqueAlpha , q ) ; //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; //<S2SV> p += 4 ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> if ( bytes_per_pixel == 2 ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> quantum = ( * p << 8 ) ; //<S2SV> quantum |= ( * ( p + 1 ) ) ; //<S2SV> SetPixelIndex ( image , ( Quantum ) quantum , q ) ; //<S2SV> p += 8 ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> y , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( image , * p , q ) ; //<S2SV> p += 4 ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SyncImage ( image , exception ) ; //<S2SV> } //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> iris_info . magic = ReadBlobMSBShort ( image ) ; //<S2SV> if ( iris_info . magic == 0x01DA ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( iris_info . magic == 0x01DA ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 