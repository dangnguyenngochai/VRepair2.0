static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> Image * image , * palette ; //<S2SV> ImageInfo * clone_info ; //<S2SV> MagickBooleanType status ; //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> size_t EncodedByte ; //<S2SV> unsigned char RunCount , RunValue , RunCountMasked ; //<S2SV> CUTHeader Header ; //<S2SV> CUTPalHeader PalHeader ; //<S2SV> ssize_t depth ; //<S2SV> ssize_t i , j ; //<S2SV> ssize_t ldblk ; //<S2SV> unsigned char * BImgBuff = NULL , * ptrB ; //<S2SV> PixelPacket * q ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> palette = NULL ; //<S2SV> clone_info = NULL ; //<S2SV> Header . Width = ReadBlobLSBShort ( image ) ; //<S2SV> Header . Height = ReadBlobLSBShort ( image ) ; //<S2SV> Header . Reserved = ReadBlobLSBShort ( image ) ; //<S2SV> if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) //<S2SV> CUT_KO : ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> EncodedByte = ReadBlobLSBShort ( image ) ; //<S2SV> RunCount = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> RunCountMasked = RunCount & 0x7F ; //<S2SV> ldblk = 0 ; //<S2SV> while ( ( int ) RunCountMasked != 0 ) //<S2SV> { //<S2SV> i = 1 ; //<S2SV> if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; //<S2SV> offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; //<S2SV> EncodedByte -= i + 1 ; //<S2SV> ldblk += ( ssize_t ) RunCountMasked ; //<S2SV> RunCount = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; //<S2SV> RunCountMasked = RunCount & 0x7F ; //<S2SV> } //<S2SV> if ( EncodedByte != 1 ) goto CUT_KO ; //<S2SV> i = 0 ; //<S2SV> if ( ldblk == ( int ) Header . Width ) i = 8 ; //<S2SV> if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; //<S2SV> if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; //<S2SV> if ( i == 0 ) goto CUT_KO ; //<S2SV> depth = i ; //<S2SV> image -> columns = Header . Width ; //<S2SV> image -> rows = Header . Height ; //<S2SV> image -> depth = 8 ; //<S2SV> image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; //<S2SV> if ( image_info -> ping != MagickFalse ) goto Finish ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; //<S2SV> i = ( ssize_t ) strlen ( clone_info -> filename ) ; //<S2SV> j = i ; //<S2SV> while ( -- i > 0 ) //<S2SV> { //<S2SV> if ( clone_info -> filename [ i ] == '.' ) //<S2SV> { //<S2SV> break ; //<S2SV> } //<S2SV> if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || //<S2SV> clone_info -> filename [ i ] == ':' ) //<S2SV> { //<S2SV> i = j ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) CopyMagickString ( clone_info -> filename + i , ".PAL" , ( size_t ) //<S2SV> ( MaxTextExtent - i ) ) ; //<S2SV> if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) //<S2SV> { //<S2SV> ( void ) CopyMagickString ( clone_info -> filename + i , ".pal" , ( size_t ) //<S2SV> ( MaxTextExtent - i ) ) ; //<S2SV> if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) //<S2SV> { //<S2SV> clone_info -> filename [ i ] = '\\0' ; //<S2SV> if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , "rb" ) ) == NULL ) //<S2SV> { //<S2SV> clone_info = DestroyImageInfo ( clone_info ) ; //<S2SV> clone_info = NULL ; //<S2SV> goto NoPalette ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( palette = AcquireImage ( clone_info ) ) == NULL ) goto NoPalette ; //<S2SV> status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> ErasePalette : //<S2SV> palette = DestroyImage ( palette ) ; //<S2SV> palette = NULL ; //<S2SV> goto NoPalette ; //<S2SV> } //<S2SV> if ( palette != NULL ) //<S2SV> { //<S2SV> ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; //<S2SV> if ( strncmp ( PalHeader . FileId , "AH" , 2 ) != 0 ) goto ErasePalette ; //<S2SV> PalHeader . Version = ReadBlobLSBShort ( palette ) ; //<S2SV> PalHeader . Size = ReadBlobLSBShort ( palette ) ; //<S2SV> PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; //<S2SV> PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; //<S2SV> PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; //<S2SV> PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; //<S2SV> PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; //<S2SV> PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; //<S2SV> PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; //<S2SV> PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; //<S2SV> ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; //<S2SV> if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; //<S2SV> image -> colors = PalHeader . MaxIndex + 1 ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) goto NoMemory ; //<S2SV> if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; //<S2SV> if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; //<S2SV> if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; //<S2SV> for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) //<S2SV> { //<S2SV> j = ( ssize_t ) TellBlob ( palette ) ; //<S2SV> if ( ( j % 512 ) > 512 - 6 ) //<S2SV> { //<S2SV> j = ( ( j / 512 ) + 1 ) * 512 ; //<S2SV> offset = SeekBlob ( palette , j , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; //<S2SV> if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) //<S2SV> image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / //<S2SV> PalHeader . MaxRed ) ; //<S2SV> } //<S2SV> image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; //<S2SV> if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) //<S2SV> { //<S2SV> image -> colormap [ i ] . green = ClampToQuantum //<S2SV> ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; //<S2SV> } //<S2SV> image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; //<S2SV> if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) //<S2SV> { //<S2SV> image -> colormap [ i ] . blue = ClampToQuantum //<S2SV> ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> NoPalette : //<S2SV> if ( palette == NULL ) //<S2SV> { //<S2SV> image -> colors = 256 ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) //<S2SV> { //<S2SV> NoMemory : //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; //<S2SV> } //<S2SV> } //<S2SV> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , //<S2SV> sizeof ( * BImgBuff ) ) ; //<S2SV> if ( BImgBuff == NULL ) goto NoMemory ; //<S2SV> offset = SeekBlob ( image , 6 , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) //<S2SV> { //<S2SV> EncodedByte = ReadBlobLSBShort ( image ) ; //<S2SV> ptrB = BImgBuff ; //<S2SV> j = ldblk ; //<S2SV> RunCount = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> RunCountMasked = RunCount & 0x7F ; //<S2SV> while ( ( int ) RunCountMasked != 0 ) //<S2SV> { //<S2SV> if ( ( ssize_t ) RunCountMasked > j ) //<S2SV> { //<S2SV> RunCountMasked = ( unsigned char ) j ; //<S2SV> if ( j == 0 ) //<S2SV> { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( int ) RunCount > 0x80 ) //<S2SV> { //<S2SV> RunValue = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> ( void ) ResetMagickMemory ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; //<S2SV> } //<S2SV> else { //<S2SV> ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; //<S2SV> } //<S2SV> ptrB += ( int ) RunCountMasked ; //<S2SV> j -= ( int ) RunCountMasked ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; //<S2SV> RunCount = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> RunCountMasked = RunCount & 0x7F ; //<S2SV> } //<S2SV> InsertRow ( depth , BImgBuff , i , image ) ; //<S2SV> } //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> if ( palette == NULL ) //<S2SV> { //<S2SV> if ( ( image -> storage_class == PseudoClass ) && //<S2SV> ( IsGrayImage ( image , & image -> exception ) != MagickFalse ) ) //<S2SV> { //<S2SV> if ( GetCutColors ( image ) == 2 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> register Quantum //<S2SV> sample ; //<S2SV> sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; //<S2SV> if ( image -> colormap [ i ] . red != sample ) goto Finish ; //<S2SV> if ( image -> colormap [ i ] . green != sample ) goto Finish ; //<S2SV> if ( image -> colormap [ i ] . blue != sample ) goto Finish ; //<S2SV> } //<S2SV> image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = //<S2SV> image -> colormap [ 1 ] . blue = QuantumRange ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; //<S2SV> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) //<S2SV> { //<S2SV> if ( GetPixelRed ( q ) == ScaleCharToQuantum ( 1 ) ) //<S2SV> { //<S2SV> SetPixelRed ( q , QuantumRange ) ; //<S2SV> SetPixelGreen ( q , QuantumRange ) ; //<S2SV> SetPixelBlue ( q , QuantumRange ) ; //<S2SV> } //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> Finish : //<S2SV> if ( BImgBuff != NULL ) //<S2SV> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; //<S2SV> if ( palette != NULL ) //<S2SV> palette = DestroyImage ( palette ) ; //<S2SV> if ( clone_info != NULL ) //<S2SV> clone_info = DestroyImageInfo ( clone_info ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 