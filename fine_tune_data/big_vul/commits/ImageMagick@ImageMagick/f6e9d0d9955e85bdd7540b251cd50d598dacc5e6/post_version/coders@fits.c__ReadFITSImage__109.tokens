static Image * ReadFITSImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> typedef struct _FITSInfo //<S2SV> { //<S2SV> MagickBooleanType //<S2SV> extend , //<S2SV> simple ; //<S2SV> int //<S2SV> bits_per_pixel , //<S2SV> columns , //<S2SV> rows , //<S2SV> number_axes , //<S2SV> number_planes ; //<S2SV> double //<S2SV> min_data , //<S2SV> max_data , //<S2SV> zero , //<S2SV> scale ; //<S2SV> EndianType //<S2SV> endian ; //<S2SV> } FITSInfo ; //<S2SV> char //<S2SV> * comment , //<S2SV> keyword [ 9 ] , //<S2SV> property [ MaxTextExtent ] , //<S2SV> value [ 73 ] ; //<S2SV> double //<S2SV> pixel , //<S2SV> scale ; //<S2SV> FITSInfo //<S2SV> fits_info ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> c ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickSizeType //<S2SV> number_pixels ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> scene , //<S2SV> y ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) ResetMagickMemory ( & fits_info , 0 , sizeof ( fits_info ) ) ; //<S2SV> fits_info . extend = MagickFalse ; //<S2SV> fits_info . simple = MagickFalse ; //<S2SV> fits_info . bits_per_pixel = 8 ; //<S2SV> fits_info . columns = 1 ; //<S2SV> fits_info . rows = 1 ; //<S2SV> fits_info . rows = 1 ; //<S2SV> fits_info . number_planes = 1 ; //<S2SV> fits_info . min_data = 0.0 ; //<S2SV> fits_info . max_data = 0.0 ; //<S2SV> fits_info . zero = 0.0 ; //<S2SV> fits_info . scale = 1.0 ; //<S2SV> fits_info . endian = MSBEndian ; //<S2SV> for ( comment = ( char * ) NULL ; EOFBlob ( image ) == MagickFalse ; ) //<S2SV> { //<S2SV> for ( ; EOFBlob ( image ) == MagickFalse ; ) //<S2SV> { //<S2SV> register char //<S2SV> * p ; //<S2SV> count = ReadBlob ( image , 8 , ( unsigned char * ) keyword ) ; //<S2SV> if ( count != 8 ) //<S2SV> break ; //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> if ( isspace ( ( int ) ( ( unsigned char ) keyword [ i ] ) ) != 0 ) //<S2SV> break ; //<S2SV> keyword [ i ] = tolower ( ( int ) ( ( unsigned char ) keyword [ i ] ) ) ; //<S2SV> } //<S2SV> keyword [ i ] = '\\0' ; //<S2SV> count = ReadBlob ( image , 72 , ( unsigned char * ) value ) ; //<S2SV> value [ 72 ] = '\\0' ; //<S2SV> if ( count != 72 ) //<S2SV> break ; //<S2SV> p = value ; //<S2SV> if ( * p == '=' ) //<S2SV> { //<S2SV> p += 2 ; //<S2SV> while ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "end" ) == 0 ) //<S2SV> break ; //<S2SV> if ( LocaleCompare ( keyword , "extend" ) == 0 ) //<S2SV> fits_info . extend = ( * p == 'T' ) || ( * p == 't' ) ? MagickTrue : MagickFalse ; //<S2SV> if ( LocaleCompare ( keyword , "simple" ) == 0 ) //<S2SV> fits_info . simple = ( * p == 'T' ) || ( * p == 't' ) ? MagickTrue : MagickFalse ; //<S2SV> if ( LocaleCompare ( keyword , "bitpix" ) == 0 ) //<S2SV> fits_info . bits_per_pixel = StringToLong ( p ) ; //<S2SV> if ( LocaleCompare ( keyword , "naxis" ) == 0 ) //<S2SV> fits_info . number_axes = StringToLong ( p ) ; //<S2SV> if ( LocaleCompare ( keyword , "naxis1" ) == 0 ) //<S2SV> fits_info . columns = StringToLong ( p ) ; //<S2SV> if ( LocaleCompare ( keyword , "naxis2" ) == 0 ) //<S2SV> fits_info . rows = StringToLong ( p ) ; //<S2SV> if ( LocaleCompare ( keyword , "naxis3" ) == 0 ) //<S2SV> fits_info . number_planes = StringToLong ( p ) ; //<S2SV> if ( LocaleCompare ( keyword , "datamax" ) == 0 ) //<S2SV> fits_info . max_data = StringToDouble ( p , ( char * * ) NULL ) ; //<S2SV> if ( LocaleCompare ( keyword , "datamin" ) == 0 ) //<S2SV> fits_info . min_data = StringToDouble ( p , ( char * * ) NULL ) ; //<S2SV> if ( LocaleCompare ( keyword , "bzero" ) == 0 ) //<S2SV> fits_info . zero = StringToDouble ( p , ( char * * ) NULL ) ; //<S2SV> if ( LocaleCompare ( keyword , "bscale" ) == 0 ) //<S2SV> fits_info . scale = StringToDouble ( p , ( char * * ) NULL ) ; //<S2SV> if ( LocaleCompare ( keyword , "comment" ) == 0 ) //<S2SV> { //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> comment = ConstantString ( p ) ; //<S2SV> else //<S2SV> ( void ) ConcatenateString ( & comment , p ) ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "xendian" ) == 0 ) //<S2SV> { //<S2SV> if ( LocaleNCompare ( p , "big" , 3 ) == 0 ) //<S2SV> fits_info . endian = MSBEndian ; //<S2SV> else //<S2SV> fits_info . endian = LSBEndian ; //<S2SV> } //<S2SV> ( void ) FormatLocaleString ( property , MaxTextExtent , "fits:%s" , keyword ) ; //<S2SV> ( void ) SetImageProperty ( image , property , p ) ; //<S2SV> } //<S2SV> c = 0 ; //<S2SV> while ( ( ( TellBlob ( image ) % FITSBlocksize ) != 0 ) && ( c != EOF ) ) //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( fits_info . extend == MagickFalse ) //<S2SV> break ; //<S2SV> number_pixels = ( MagickSizeType ) fits_info . columns * fits_info . rows ; //<S2SV> if ( ( fits_info . simple != MagickFalse ) && ( fits_info . number_axes >= 1 ) && //<S2SV> ( fits_info . number_axes <= 4 ) && ( number_pixels != 0 ) ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( comment != ( char * ) NULL ) //<S2SV> { //<S2SV> ( void ) SetImageProperty ( image , "comment" , comment ) ; //<S2SV> comment = DestroyString ( comment ) ; //<S2SV> } //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> number_pixels = ( MagickSizeType ) fits_info . columns * fits_info . rows ; //<S2SV> if ( ( fits_info . simple == MagickFalse ) || ( fits_info . number_axes < 1 ) || //<S2SV> ( fits_info . number_axes > 4 ) || ( number_pixels == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; //<S2SV> for ( scene = 0 ; scene < ( ssize_t ) fits_info . number_planes ; scene ++ ) //<S2SV> { //<S2SV> image -> columns = ( size_t ) fits_info . columns ; //<S2SV> image -> rows = ( size_t ) fits_info . rows ; //<S2SV> image -> depth = ( size_t ) ( fits_info . bits_per_pixel < 0 ? - 1 : 1 ) * //<S2SV> fits_info . bits_per_pixel ; //<S2SV> image -> endian = fits_info . endian ; //<S2SV> image -> scene = ( size_t ) scene ; //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> ( void ) SetImageColorspace ( image , GRAYColorspace ) ; //<S2SV> if ( ( fits_info . min_data == 0.0 ) && ( fits_info . max_data == 0.0 ) ) //<S2SV> { //<S2SV> if ( fits_info . zero == 0.0 ) //<S2SV> ( void ) GetFITSPixelExtrema ( image , fits_info . bits_per_pixel , //<S2SV> & fits_info . min_data , & fits_info . max_data ) ; //<S2SV> else //<S2SV> fits_info . max_data = GetFITSPixelRange ( ( size_t ) //<S2SV> fits_info . bits_per_pixel ) ; //<S2SV> } //<S2SV> else //<S2SV> fits_info . max_data = GetFITSPixelRange ( ( size_t ) fits_info . bits_per_pixel ) ; //<S2SV> scale = QuantumRange / ( fits_info . max_data - fits_info . min_data ) ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> pixel = GetFITSPixel ( image , fits_info . bits_per_pixel ) ; //<S2SV> if ( ( image -> depth == 16 ) || ( image -> depth == 32 ) || //<S2SV> ( image -> depth == 64 ) ) //<S2SV> SetFITSUnsignedPixels ( 1 , image -> depth , image -> endian , ( unsigned char * ) //<S2SV> & pixel ) ; //<S2SV> SetPixelRed ( q , ClampToQuantum ( scale * ( fits_info . scale * ( pixel - //<S2SV> fits_info . min_data ) + fits_info . zero ) ) ) ; //<S2SV> SetPixelGreen ( q , GetPixelRed ( q ) ) ; //<S2SV> SetPixelBlue ( q , GetPixelRed ( q ) ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( scene < ( ssize_t ) ( fits_info . number_planes - 1 ) ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 