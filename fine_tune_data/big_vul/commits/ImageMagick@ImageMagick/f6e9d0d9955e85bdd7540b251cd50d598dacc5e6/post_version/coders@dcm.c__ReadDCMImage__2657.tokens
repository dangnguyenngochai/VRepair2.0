static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> explicit_vr [ MaxTextExtent ] , //<S2SV> implicit_vr [ MaxTextExtent ] , //<S2SV> magick [ MaxTextExtent ] , //<S2SV> photometric [ MaxTextExtent ] ; //<S2SV> DCMStreamInfo //<S2SV> * stream_info ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> * bluemap , //<S2SV> datum , //<S2SV> * greenmap , //<S2SV> * graymap , //<S2SV> index , //<S2SV> * redmap ; //<S2SV> MagickBooleanType //<S2SV> explicit_file , //<S2SV> explicit_retry , //<S2SV> polarity , //<S2SV> sequence , //<S2SV> use_explicit ; //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> Quantum //<S2SV> * scale ; //<S2SV> register IndexPacket //<S2SV> * indexes ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bits_allocated , //<S2SV> bytes_per_pixel , //<S2SV> colors , //<S2SV> depth , //<S2SV> height , //<S2SV> length , //<S2SV> mask , //<S2SV> max_value , //<S2SV> number_scenes , //<S2SV> quantum , //<S2SV> samples_per_pixel , //<S2SV> signed_data , //<S2SV> significant_bits , //<S2SV> status , //<S2SV> width , //<S2SV> window_width ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> scene , //<S2SV> window_center , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * data ; //<S2SV> unsigned short //<S2SV> group , //<S2SV> element ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image -> depth = 8UL ; //<S2SV> image -> endian = LSBEndian ; //<S2SV> stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; //<S2SV> if ( stream_info == ( DCMStreamInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; //<S2SV> count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; //<S2SV> if ( count != 128 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; //<S2SV> if ( ( count != 4 ) || ( LocaleNCompare ( magick , "DICM" , 4 ) != 0 ) ) //<S2SV> { //<S2SV> offset = SeekBlob ( image , 0L , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> ( void ) CopyMagickString ( photometric , "MONOCHROME1<S2SV_blank>" , MaxTextExtent ) ; //<S2SV> bits_allocated = 8 ; //<S2SV> bytes_per_pixel = 1 ; //<S2SV> polarity = MagickFalse ; //<S2SV> data = ( unsigned char * ) NULL ; //<S2SV> depth = 8 ; //<S2SV> element = 0 ; //<S2SV> explicit_vr [ 2 ] = '\\0' ; //<S2SV> explicit_file = MagickFalse ; //<S2SV> colors = 0 ; //<S2SV> redmap = ( int * ) NULL ; //<S2SV> greenmap = ( int * ) NULL ; //<S2SV> bluemap = ( int * ) NULL ; //<S2SV> graymap = ( int * ) NULL ; //<S2SV> height = 0 ; //<S2SV> max_value = 255UL ; //<S2SV> mask = 0xffff ; //<S2SV> number_scenes = 1 ; //<S2SV> samples_per_pixel = 1 ; //<S2SV> scale = ( Quantum * ) NULL ; //<S2SV> sequence = MagickFalse ; //<S2SV> signed_data = ( ~ 0UL ) ; //<S2SV> significant_bits = 0 ; //<S2SV> use_explicit = MagickFalse ; //<S2SV> explicit_retry = MagickFalse ; //<S2SV> width = 0 ; //<S2SV> window_center = 0 ; //<S2SV> window_width = 0 ; //<S2SV> for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || //<S2SV> ( sequence != MagickFalse ) ; ) //<S2SV> { //<S2SV> image -> offset = ( ssize_t ) TellBlob ( image ) ; //<S2SV> group = ReadBlobLSBShort ( image ) ; //<S2SV> element = ReadBlobLSBShort ( image ) ; //<S2SV> if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) //<S2SV> { //<S2SV> group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; //<S2SV> element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; //<S2SV> } //<S2SV> quantum = 0 ; //<S2SV> for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) //<S2SV> if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) //<S2SV> break ; //<S2SV> ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MaxTextExtent ) ; //<S2SV> count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; //<S2SV> if ( count != 2 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) //<S2SV> explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && //<S2SV> ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || //<S2SV> ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; //<S2SV> if ( ( use_explicit != MagickFalse ) && ( strcmp ( implicit_vr , "xs" ) == 0 ) ) //<S2SV> ( void ) CopyMagickString ( implicit_vr , explicit_vr , MaxTextExtent ) ; //<S2SV> if ( ( use_explicit == MagickFalse ) || ( strcmp ( implicit_vr , "!!" ) == 0 ) ) //<S2SV> { //<S2SV> offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> quantum = 4 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> quantum = 2 ; //<S2SV> if ( ( strcmp ( explicit_vr , "OB" ) == 0 ) || //<S2SV> ( strcmp ( explicit_vr , "UN" ) == 0 ) || //<S2SV> ( strcmp ( explicit_vr , "OW" ) == 0 ) || ( strcmp ( explicit_vr , "SQ" ) == 0 ) ) //<S2SV> { //<S2SV> ( void ) ReadBlobLSBShort ( image ) ; //<S2SV> quantum = 4 ; //<S2SV> } //<S2SV> } //<S2SV> datum = 0 ; //<S2SV> if ( quantum == 4 ) //<S2SV> { //<S2SV> if ( group == 0x0002 ) //<S2SV> datum = ( int ) ReadBlobLSBLong ( image ) ; //<S2SV> else //<S2SV> datum = ( int ) ReadBlobLong ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( quantum == 2 ) //<S2SV> { //<S2SV> if ( group == 0x0002 ) //<S2SV> datum = ( int ) ReadBlobLSBShort ( image ) ; //<S2SV> else //<S2SV> datum = ( int ) ReadBlobShort ( image ) ; //<S2SV> } //<S2SV> quantum = 0 ; //<S2SV> length = 1 ; //<S2SV> if ( datum != 0 ) //<S2SV> { //<S2SV> if ( ( strcmp ( implicit_vr , "SS" ) == 0 ) || //<S2SV> ( strcmp ( implicit_vr , "US" ) == 0 ) ) //<S2SV> quantum = 2 ; //<S2SV> else //<S2SV> if ( ( strcmp ( implicit_vr , "UL" ) == 0 ) || //<S2SV> ( strcmp ( implicit_vr , "SL" ) == 0 ) || //<S2SV> ( strcmp ( implicit_vr , "FL" ) == 0 ) ) //<S2SV> quantum = 4 ; //<S2SV> else //<S2SV> if ( strcmp ( implicit_vr , "FD" ) != 0 ) //<S2SV> quantum = 1 ; //<S2SV> else //<S2SV> quantum = 8 ; //<S2SV> if ( datum != ~ 0 ) //<S2SV> length = ( size_t ) datum / quantum ; //<S2SV> else //<S2SV> { //<S2SV> quantum = 0 ; //<S2SV> length = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> { //<S2SV> if ( use_explicit == MagickFalse ) //<S2SV> explicit_vr [ 0 ] = '\\0' ; //<S2SV> for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) //<S2SV> if ( ( group == dicom_info [ i ] . group ) && //<S2SV> ( element == dicom_info [ i ] . element ) ) //<S2SV> break ; //<S2SV> ( void ) FormatLocaleFile ( stdout , "0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)" , //<S2SV> ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , //<S2SV> ( unsigned long ) group , ( unsigned long ) element ) ; //<S2SV> if ( dicom_info [ i ] . description != ( char * ) NULL ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "<S2SV_blank>%s" , dicom_info [ i ] . description ) ; //<S2SV> ( void ) FormatLocaleFile ( stdout , ":<S2SV_blank>" ) ; //<S2SV> } //<S2SV> if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) //<S2SV> { //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> data = ( unsigned char * ) NULL ; //<S2SV> if ( ( length == 1 ) && ( quantum == 1 ) ) //<S2SV> datum = ( int ) ReadBlobByte ( image ) ; //<S2SV> else //<S2SV> if ( ( length == 1 ) && ( quantum == 2 ) ) //<S2SV> { //<S2SV> if ( group == 0x0002 ) //<S2SV> datum = ( int ) ReadBlobLSBShort ( image ) ; //<S2SV> else //<S2SV> datum = ( int ) ReadBlobShort ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( ( length == 1 ) && ( quantum == 4 ) ) //<S2SV> { //<S2SV> if ( group == 0x0002 ) //<S2SV> datum = ( int ) ReadBlobLSBLong ( image ) ; //<S2SV> else //<S2SV> datum = ( int ) ReadBlobLong ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( ( quantum != 0 ) && ( length != 0 ) ) //<S2SV> { //<S2SV> if ( ~ length >= 1 ) //<S2SV> data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * //<S2SV> sizeof ( * data ) ) ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; //<S2SV> if ( count != ( ssize_t ) ( quantum * length ) ) //<S2SV> { //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "count=%d<S2SV_blank>quantum=%d<S2SV_blank>" //<S2SV> "length=%d<S2SV_blank>group=%d\\n" , ( int ) count , ( int ) quantum , ( int ) //<S2SV> length , ( int ) group ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> } //<S2SV> data [ length * quantum ] = '\\0' ; //<S2SV> } //<S2SV> else //<S2SV> if ( ( unsigned int ) datum == 0xFFFFFFFFU ) //<S2SV> { //<S2SV> sequence = MagickTrue ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; //<S2SV> sequence = MagickFalse ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( sequence != MagickFalse ) //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> switch ( group ) //<S2SV> { //<S2SV> case 0x0002 : //<S2SV> { //<S2SV> switch ( element ) //<S2SV> { //<S2SV> case 0x0010 : //<S2SV> { //<S2SV> char //<S2SV> transfer_syntax [ MaxTextExtent ] ; //<S2SV> if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) //<S2SV> { //<S2SV> explicit_retry = MagickTrue ; //<S2SV> ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; //<S2SV> group = 0 ; //<S2SV> element = 0 ; //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , //<S2SV> "Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> * transfer_syntax = '\\0' ; //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , //<S2SV> MaxTextExtent ) ; //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "transfer_syntax=%s\\n" , //<S2SV> ( const char * ) transfer_syntax ) ; //<S2SV> if ( strncmp ( transfer_syntax , "1.2.840.10008.1.2" , 17 ) == 0 ) //<S2SV> { //<S2SV> int //<S2SV> subtype , //<S2SV> type ; //<S2SV> type = 0 ; //<S2SV> subtype = 0 ; //<S2SV> ( void ) sscanf ( transfer_syntax + 17 , ".%d.%d" , & type , & subtype ) ; //<S2SV> switch ( type ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> image -> endian = LSBEndian ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> image -> endian = MSBEndian ; //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) //<S2SV> image -> compression = JPEGCompression ; //<S2SV> else //<S2SV> if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) //<S2SV> image -> compression = JPEG2000Compression ; //<S2SV> else //<S2SV> image -> compression = JPEGCompression ; //<S2SV> break ; //<S2SV> } //<S2SV> case 5 : //<S2SV> { //<S2SV> image -> compression = RLECompression ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0028 : //<S2SV> { //<S2SV> switch ( element ) //<S2SV> { //<S2SV> case 0x0002 : //<S2SV> { //<S2SV> samples_per_pixel = ( size_t ) datum ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0004 : //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MaxTextExtent - 1 ) ; i ++ ) //<S2SV> photometric [ i ] = ( char ) data [ i ] ; //<S2SV> photometric [ i ] = '\\0' ; //<S2SV> polarity = LocaleCompare ( photometric , "MONOCHROME1<S2SV_blank>" ) == 0 ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0006 : //<S2SV> { //<S2SV> if ( datum == 1 ) //<S2SV> image -> interlace = PlaneInterlace ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0008 : //<S2SV> { //<S2SV> number_scenes = StringToUnsignedLong ( ( char * ) data ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0010 : //<S2SV> { //<S2SV> height = ( size_t ) datum ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0011 : //<S2SV> { //<S2SV> width = ( size_t ) datum ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0100 : //<S2SV> { //<S2SV> bits_allocated = ( size_t ) datum ; //<S2SV> bytes_per_pixel = 1 ; //<S2SV> if ( datum > 8 ) //<S2SV> bytes_per_pixel = 2 ; //<S2SV> depth = bits_allocated ; //<S2SV> if ( depth > 32 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> max_value = ( 1UL << bits_allocated ) - 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0101 : //<S2SV> { //<S2SV> significant_bits = ( size_t ) datum ; //<S2SV> bytes_per_pixel = 1 ; //<S2SV> if ( significant_bits > 8 ) //<S2SV> bytes_per_pixel = 2 ; //<S2SV> depth = significant_bits ; //<S2SV> if ( depth > 32 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> max_value = ( 1UL << significant_bits ) - 1 ; //<S2SV> mask = ( size_t ) GetQuantumRange ( significant_bits ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0102 : //<S2SV> { //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0103 : //<S2SV> { //<S2SV> signed_data = ( size_t ) datum ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1050 : //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1051 : //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> window_width = StringToUnsignedLong ( ( char * ) data ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1200 : //<S2SV> case 0x3006 : //<S2SV> { //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> colors = ( size_t ) ( length / bytes_per_pixel ) ; //<S2SV> datum = ( int ) colors ; //<S2SV> graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , //<S2SV> sizeof ( * graymap ) ) ; //<S2SV> if ( graymap == ( int * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> if ( bytes_per_pixel == 1 ) //<S2SV> graymap [ i ] = ( int ) data [ i ] ; //<S2SV> else //<S2SV> graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1201 : //<S2SV> { //<S2SV> unsigned short //<S2SV> index ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> colors = ( size_t ) ( length / 2 ) ; //<S2SV> datum = ( int ) colors ; //<S2SV> redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , //<S2SV> sizeof ( * redmap ) ) ; //<S2SV> if ( redmap == ( int * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> p = data ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> if ( image -> endian == MSBEndian ) //<S2SV> index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; //<S2SV> else //<S2SV> index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; //<S2SV> redmap [ i ] = ( int ) index ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1202 : //<S2SV> { //<S2SV> unsigned short //<S2SV> index ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> colors = ( size_t ) ( length / 2 ) ; //<S2SV> datum = ( int ) colors ; //<S2SV> greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , //<S2SV> sizeof ( * greenmap ) ) ; //<S2SV> if ( greenmap == ( int * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> p = data ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> if ( image -> endian == MSBEndian ) //<S2SV> index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; //<S2SV> else //<S2SV> index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; //<S2SV> greenmap [ i ] = ( int ) index ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1203 : //<S2SV> { //<S2SV> unsigned short //<S2SV> index ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> colors = ( size_t ) ( length / 2 ) ; //<S2SV> datum = ( int ) colors ; //<S2SV> bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , //<S2SV> sizeof ( * bluemap ) ) ; //<S2SV> if ( bluemap == ( int * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> p = data ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> if ( image -> endian == MSBEndian ) //<S2SV> index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; //<S2SV> else //<S2SV> index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; //<S2SV> bluemap [ i ] = ( int ) index ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x2050 : //<S2SV> { //<S2SV> switch ( element ) //<S2SV> { //<S2SV> case 0x0020 : //<S2SV> { //<S2SV> if ( ( data != ( unsigned char * ) NULL ) && //<S2SV> ( strncmp ( ( char * ) data , "INVERSE" , 7 ) == 0 ) ) //<S2SV> polarity = MagickTrue ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> { //<S2SV> char //<S2SV> * attribute ; //<S2SV> for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) //<S2SV> if ( ( group == dicom_info [ i ] . group ) && //<S2SV> ( element == dicom_info [ i ] . element ) ) //<S2SV> break ; //<S2SV> if ( dicom_info [ i ] . description != ( char * ) NULL ) //<S2SV> { //<S2SV> attribute = AcquireString ( "dcm:" ) ; //<S2SV> ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) //<S2SV> if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) //<S2SV> { //<S2SV> ( void ) SubstituteString ( & attribute , "<S2SV_blank>" , "" ) ; //<S2SV> ( void ) SetImageProperty ( image , attribute , ( char * ) data ) ; //<S2SV> } //<S2SV> attribute = DestroyString ( attribute ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> { //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "%d\\n" , datum ) ; //<S2SV> else //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) //<S2SV> if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) //<S2SV> { //<S2SV> ssize_t //<S2SV> j ; //<S2SV> datum = 0 ; //<S2SV> for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) //<S2SV> datum = ( 256 * datum + data [ j ] ) ; //<S2SV> ( void ) FormatLocaleFile ( stdout , "%d" , datum ) ; //<S2SV> } //<S2SV> else //<S2SV> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) //<S2SV> if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "%c" , data [ i ] ) ; //<S2SV> else //<S2SV> ( void ) FormatLocaleFile ( stdout , "%c" , '.' ) ; //<S2SV> ( void ) FormatLocaleFile ( stdout , "\\n" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( width == 0 ) || ( height == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> image -> columns = ( size_t ) width ; //<S2SV> image -> rows = ( size_t ) height ; //<S2SV> if ( signed_data == 0xffff ) //<S2SV> signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; //<S2SV> if ( ( image -> compression == JPEGCompression ) || //<S2SV> ( image -> compression == JPEG2000Compression ) ) //<S2SV> { //<S2SV> Image //<S2SV> * images ; //<S2SV> ImageInfo //<S2SV> * read_info ; //<S2SV> int //<S2SV> c ; //<S2SV> size_t //<S2SV> length ; //<S2SV> unsigned int //<S2SV> tag ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; //<S2SV> ( void ) tag ; //<S2SV> length = ( size_t ) ReadBlobLSBLong ( image ) ; //<S2SV> stream_info -> offset_count = length >> 2 ; //<S2SV> if ( stream_info -> offset_count != 0 ) //<S2SV> { //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( //<S2SV> stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; //<S2SV> if ( stream_info -> offsets == ( ssize_t * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) //<S2SV> stream_info -> offsets [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; //<S2SV> offset = TellBlob ( image ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) //<S2SV> stream_info -> offsets [ i ] += offset ; //<S2SV> } //<S2SV> read_info = CloneImageInfo ( image_info ) ; //<S2SV> SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; //<S2SV> images = NewImageList ( ) ; //<S2SV> for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) //<S2SV> { //<S2SV> char //<S2SV> filename [ MaxTextExtent ] ; //<S2SV> const char //<S2SV> * property ; //<S2SV> FILE //<S2SV> * file ; //<S2SV> Image //<S2SV> * jpeg_image ; //<S2SV> int //<S2SV> unique_file ; //<S2SV> unsigned int //<S2SV> tag ; //<S2SV> tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; //<S2SV> length = ( size_t ) ReadBlobLSBLong ( image ) ; //<S2SV> if ( tag == 0xFFFEE0DD ) //<S2SV> break ; //<S2SV> if ( tag != 0xFFFEE000 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> file = ( FILE * ) NULL ; //<S2SV> unique_file = AcquireUniqueFileResource ( filename ) ; //<S2SV> if ( unique_file != - 1 ) //<S2SV> file = fdopen ( unique_file , "wb" ) ; //<S2SV> if ( file == ( FILE * ) NULL ) //<S2SV> { //<S2SV> ( void ) RelinquishUniqueFileResource ( filename ) ; //<S2SV> ThrowFileException ( exception , FileOpenError , //<S2SV> "UnableToCreateTemporaryFile" , filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( ; length != 0 ; length -- ) //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) fputc ( c , file ) ; //<S2SV> } //<S2SV> ( void ) fclose ( file ) ; //<S2SV> ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , "jpeg:%s" , //<S2SV> filename ) ; //<S2SV> if ( image -> compression == JPEG2000Compression ) //<S2SV> ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , "j2k:%s" , //<S2SV> filename ) ; //<S2SV> jpeg_image = ReadImage ( read_info , exception ) ; //<S2SV> if ( jpeg_image != ( Image * ) NULL ) //<S2SV> { //<S2SV> ResetImagePropertyIterator ( image ) ; //<S2SV> property = GetNextImageProperty ( image ) ; //<S2SV> while ( property != ( const char * ) NULL ) //<S2SV> { //<S2SV> ( void ) SetImageProperty ( jpeg_image , property , //<S2SV> GetImageProperty ( image , property ) ) ; //<S2SV> property = GetNextImageProperty ( image ) ; //<S2SV> } //<S2SV> AppendImageToList ( & images , jpeg_image ) ; //<S2SV> } //<S2SV> ( void ) RelinquishUniqueFileResource ( filename ) ; //<S2SV> } //<S2SV> read_info = DestroyImageInfo ( read_info ) ; //<S2SV> image = DestroyImage ( image ) ; //<S2SV> return ( GetFirstImageInList ( images ) ) ; //<S2SV> } //<S2SV> if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) //<S2SV> { //<S2SV> QuantumAny //<S2SV> range ; //<S2SV> size_t //<S2SV> length ; //<S2SV> length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; //<S2SV> scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; //<S2SV> if ( scale == ( Quantum * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> range = GetQuantumRange ( depth ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) //<S2SV> scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; //<S2SV> } //<S2SV> if ( image -> compression == RLECompression ) //<S2SV> { //<S2SV> size_t //<S2SV> length ; //<S2SV> unsigned int //<S2SV> tag ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; //<S2SV> ( void ) tag ; //<S2SV> length = ( size_t ) ReadBlobLSBLong ( image ) ; //<S2SV> stream_info -> offset_count = length >> 2 ; //<S2SV> if ( stream_info -> offset_count != 0 ) //<S2SV> { //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( //<S2SV> stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; //<S2SV> if ( stream_info -> offsets == ( ssize_t * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) //<S2SV> stream_info -> offsets [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; //<S2SV> offset = TellBlob ( image ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) //<S2SV> stream_info -> offsets [ i ] += offset ; //<S2SV> } //<S2SV> } //<S2SV> for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) //<S2SV> { //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> break ; //<S2SV> image -> columns = ( size_t ) width ; //<S2SV> image -> rows = ( size_t ) height ; //<S2SV> image -> depth = depth ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> image -> colorspace = RGBColorspace ; //<S2SV> if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( samples_per_pixel == 1 ) ) //<S2SV> { //<S2SV> size_t //<S2SV> one ; //<S2SV> one = 1 ; //<S2SV> if ( colors == 0 ) //<S2SV> colors = one << depth ; //<S2SV> if ( AcquireImageColormap ( image , one << depth ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> if ( redmap != ( int * ) NULL ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> index = redmap [ i ] ; //<S2SV> if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) //<S2SV> index = ( int ) scale [ index ] ; //<S2SV> image -> colormap [ i ] . red = ( Quantum ) index ; //<S2SV> } //<S2SV> if ( greenmap != ( int * ) NULL ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> index = greenmap [ i ] ; //<S2SV> if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) //<S2SV> index = ( int ) scale [ index ] ; //<S2SV> image -> colormap [ i ] . green = ( Quantum ) index ; //<S2SV> } //<S2SV> if ( bluemap != ( int * ) NULL ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> index = bluemap [ i ] ; //<S2SV> if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) //<S2SV> index = ( int ) scale [ index ] ; //<S2SV> image -> colormap [ i ] . blue = ( Quantum ) index ; //<S2SV> } //<S2SV> if ( graymap != ( int * ) NULL ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> index = graymap [ i ] ; //<S2SV> if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) //<S2SV> index = ( int ) scale [ index ] ; //<S2SV> image -> colormap [ i ] . red = ( Quantum ) index ; //<S2SV> image -> colormap [ i ] . green = ( Quantum ) index ; //<S2SV> image -> colormap [ i ] . blue = ( Quantum ) index ; //<S2SV> } //<S2SV> } //<S2SV> if ( image -> compression == RLECompression ) //<S2SV> { //<S2SV> unsigned int //<S2SV> tag ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; //<S2SV> stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; //<S2SV> if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || //<S2SV> ( EOFBlob ( image ) != MagickFalse ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> stream_info -> count = 0 ; //<S2SV> stream_info -> segment_count = ReadBlobLSBLong ( image ) ; //<S2SV> if ( stream_info -> segment_count > 1 ) //<S2SV> { //<S2SV> bytes_per_pixel = 1 ; //<S2SV> depth = 8 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < 15 ; i ++ ) //<S2SV> stream_info -> segments [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; //<S2SV> stream_info -> remaining -= 64 ; //<S2SV> } //<S2SV> if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> switch ( ( int ) i ) //<S2SV> { //<S2SV> case 0 : //<S2SV> { //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadDCMByte ( stream_info , image ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 1 : //<S2SV> { //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadDCMByte ( stream_info , image ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadDCMByte ( stream_info , image ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 3 : //<S2SV> { //<S2SV> SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadDCMByte ( stream_info , image ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> const char //<S2SV> * option ; //<S2SV> int //<S2SV> byte ; //<S2SV> LongPixelPacket //<S2SV> pixel ; //<S2SV> byte = 0 ; //<S2SV> i = 0 ; //<S2SV> if ( ( window_center != 0 ) && ( window_width == 0 ) ) //<S2SV> window_width = ( size_t ) window_center ; //<S2SV> option = GetImageOption ( image_info , "dcm:display-range" ) ; //<S2SV> if ( option != ( const char * ) NULL ) //<S2SV> { //<S2SV> if ( LocaleCompare ( option , "reset" ) == 0 ) //<S2SV> window_width = 0 ; //<S2SV> } //<S2SV> ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( samples_per_pixel == 1 ) //<S2SV> { //<S2SV> int //<S2SV> pixel_value ; //<S2SV> if ( bytes_per_pixel == 1 ) //<S2SV> pixel_value = polarity != MagickFalse ? ( ( int ) max_value - //<S2SV> ReadDCMByte ( stream_info , image ) ) : //<S2SV> ReadDCMByte ( stream_info , image ) ; //<S2SV> else //<S2SV> if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) //<S2SV> pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - //<S2SV> ReadDCMShort ( stream_info , image ) ) : //<S2SV> ReadDCMShort ( stream_info , image ) ) ; //<S2SV> else //<S2SV> { //<S2SV> if ( ( i & 0x01 ) != 0 ) //<S2SV> pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | //<S2SV> byte ; //<S2SV> else //<S2SV> { //<S2SV> pixel_value = ( int ) ReadDCMShort ( stream_info , image ) ; //<S2SV> byte = ( int ) ( pixel_value & 0x0f ) ; //<S2SV> pixel_value >>= 4 ; //<S2SV> } //<S2SV> i ++ ; //<S2SV> } //<S2SV> index = pixel_value ; //<S2SV> if ( window_width == 0 ) //<S2SV> { //<S2SV> if ( signed_data == 1 ) //<S2SV> index = pixel_value - 32767 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ssize_t //<S2SV> window_max , //<S2SV> window_min ; //<S2SV> window_min = ( ssize_t ) ceil ( ( double ) window_center - //<S2SV> ( window_width - 1.0 ) / 2.0 - 0.5 ) ; //<S2SV> window_max = ( ssize_t ) floor ( ( double ) window_center + //<S2SV> ( window_width - 1.0 ) / 2.0 + 0.5 ) ; //<S2SV> if ( ( ssize_t ) pixel_value <= window_min ) //<S2SV> index = 0 ; //<S2SV> else //<S2SV> if ( ( ssize_t ) pixel_value > window_max ) //<S2SV> index = ( int ) max_value ; //<S2SV> else //<S2SV> index = ( int ) ( max_value * ( ( ( pixel_value - window_center - //<S2SV> 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; //<S2SV> } //<S2SV> index &= mask ; //<S2SV> index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> pixel . red = 1U * image -> colormap [ index ] . red ; //<S2SV> pixel . green = 1U * image -> colormap [ index ] . green ; //<S2SV> pixel . blue = 1U * image -> colormap [ index ] . blue ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( bytes_per_pixel == 1 ) //<S2SV> { //<S2SV> pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; //<S2SV> pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; //<S2SV> pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pixel . red = ReadDCMShort ( stream_info , image ) ; //<S2SV> pixel . green = ReadDCMShort ( stream_info , image ) ; //<S2SV> pixel . blue = ReadDCMShort ( stream_info , image ) ; //<S2SV> } //<S2SV> pixel . red &= mask ; //<S2SV> pixel . green &= mask ; //<S2SV> pixel . blue &= mask ; //<S2SV> if ( scale != ( Quantum * ) NULL ) //<S2SV> { //<S2SV> pixel . red = scale [ pixel . red ] ; //<S2SV> pixel . green = scale [ pixel . green ] ; //<S2SV> pixel . blue = scale [ pixel . blue ] ; //<S2SV> } //<S2SV> } //<S2SV> SetPixelRed ( q , pixel . red ) ; //<S2SV> SetPixelGreen ( q , pixel . green ) ; //<S2SV> SetPixelBlue ( q , pixel . blue ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( stream_info -> segment_count > 1 ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( samples_per_pixel == 1 ) //<S2SV> { //<S2SV> int //<S2SV> pixel_value ; //<S2SV> if ( bytes_per_pixel == 1 ) //<S2SV> pixel_value = polarity != MagickFalse ? ( ( int ) max_value - //<S2SV> ReadDCMByte ( stream_info , image ) ) : //<S2SV> ReadDCMByte ( stream_info , image ) ; //<S2SV> else //<S2SV> if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) //<S2SV> { //<S2SV> pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - //<S2SV> ReadDCMShort ( stream_info , image ) ) : //<S2SV> ReadDCMShort ( stream_info , image ) ) ; //<S2SV> if ( signed_data == 1 ) //<S2SV> pixel_value = ( ( signed short ) pixel_value ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ( i & 0x01 ) != 0 ) //<S2SV> pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | //<S2SV> byte ; //<S2SV> else //<S2SV> { //<S2SV> pixel_value = ( int ) ReadDCMShort ( stream_info , image ) ; //<S2SV> byte = ( int ) ( pixel_value & 0x0f ) ; //<S2SV> pixel_value >>= 4 ; //<S2SV> } //<S2SV> i ++ ; //<S2SV> } //<S2SV> index = pixel_value ; //<S2SV> if ( window_width == 0 ) //<S2SV> { //<S2SV> if ( signed_data == 1 ) //<S2SV> index = pixel_value - 32767 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ssize_t //<S2SV> window_max , //<S2SV> window_min ; //<S2SV> window_min = ( ssize_t ) ceil ( ( double ) window_center - //<S2SV> ( window_width - 1.0 ) / 2.0 - 0.5 ) ; //<S2SV> window_max = ( ssize_t ) floor ( ( double ) window_center + //<S2SV> ( window_width - 1.0 ) / 2.0 + 0.5 ) ; //<S2SV> if ( ( ssize_t ) pixel_value <= window_min ) //<S2SV> index = 0 ; //<S2SV> else //<S2SV> if ( ( ssize_t ) pixel_value > window_max ) //<S2SV> index = ( int ) max_value ; //<S2SV> else //<S2SV> index = ( int ) ( max_value * ( ( ( pixel_value - window_center - //<S2SV> 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; //<S2SV> } //<S2SV> index &= mask ; //<S2SV> index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index ) ; //<S2SV> SetPixelIndex ( indexes + x , ( ( ( size_t ) GetPixelIndex ( indexes + x ) ) | //<S2SV> ( ( ( size_t ) index ) << 8 ) ) ) ; //<S2SV> pixel . red = 1U * image -> colormap [ index ] . red ; //<S2SV> pixel . green = 1U * image -> colormap [ index ] . green ; //<S2SV> pixel . blue = 1U * image -> colormap [ index ] . blue ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( bytes_per_pixel == 1 ) //<S2SV> { //<S2SV> pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; //<S2SV> pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; //<S2SV> pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pixel . red = ReadDCMShort ( stream_info , image ) ; //<S2SV> pixel . green = ReadDCMShort ( stream_info , image ) ; //<S2SV> pixel . blue = ReadDCMShort ( stream_info , image ) ; //<S2SV> } //<S2SV> pixel . red &= mask ; //<S2SV> pixel . green &= mask ; //<S2SV> pixel . blue &= mask ; //<S2SV> if ( scale != ( Quantum * ) NULL ) //<S2SV> { //<S2SV> pixel . red = scale [ pixel . red ] ; //<S2SV> pixel . green = scale [ pixel . green ] ; //<S2SV> pixel . blue = scale [ pixel . blue ] ; //<S2SV> } //<S2SV> } //<S2SV> SetPixelRed ( q , ( ( ( size_t ) GetPixelRed ( q ) ) | //<S2SV> ( ( ( size_t ) pixel . red ) << 8 ) ) ) ; //<S2SV> SetPixelGreen ( q , ( ( ( size_t ) GetPixelGreen ( q ) ) | //<S2SV> ( ( ( size_t ) pixel . green ) << 8 ) ) ) ; //<S2SV> SetPixelBlue ( q , ( ( ( size_t ) GetPixelBlue ( q ) ) | //<S2SV> ( ( ( size_t ) pixel . blue ) << 8 ) ) ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( IsGrayImage ( image , exception ) != MagickFalse ) //<S2SV> ( void ) SetImageColorspace ( image , GRAYColorspace ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( stream_info -> offsets != ( ssize_t * ) NULL ) //<S2SV> stream_info -> offsets = ( ssize_t * ) //<S2SV> RelinquishMagickMemory ( stream_info -> offsets ) ; //<S2SV> stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; //<S2SV> if ( scale != ( Quantum * ) NULL ) //<S2SV> scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; //<S2SV> if ( graymap != ( int * ) NULL ) //<S2SV> graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; //<S2SV> if ( bluemap != ( int * ) NULL ) //<S2SV> bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; //<S2SV> if ( greenmap != ( int * ) NULL ) //<S2SV> greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; //<S2SV> if ( redmap != ( int * ) NULL ) //<S2SV> redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 