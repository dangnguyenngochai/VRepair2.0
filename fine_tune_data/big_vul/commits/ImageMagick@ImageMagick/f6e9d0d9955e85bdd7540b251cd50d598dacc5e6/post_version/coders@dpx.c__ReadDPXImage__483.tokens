static Image * ReadDPXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> magick [ 4 ] , //<S2SV> value [ MaxTextExtent ] ; //<S2SV> DPXInfo //<S2SV> dpx ; //<S2SV> Image //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> QuantumInfo //<S2SV> * quantum_info ; //<S2SV> QuantumType //<S2SV> quantum_type ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> extent , //<S2SV> samples_per_pixel ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> n , //<S2SV> row , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> component_type ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> offset = 0 ; //<S2SV> count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; //<S2SV> offset += count ; //<S2SV> if ( ( count != 4 ) || ( ( LocaleNCompare ( magick , "SDPX" , 4 ) != 0 ) && //<S2SV> ( LocaleNCompare ( ( char * ) magick , "XPDS" , 4 ) != 0 ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> image -> endian = LSBEndian ; //<S2SV> if ( LocaleNCompare ( magick , "SDPX" , 4 ) == 0 ) //<S2SV> image -> endian = MSBEndian ; //<S2SV> ( void ) ResetMagickMemory ( & dpx , 0 , sizeof ( dpx ) ) ; //<S2SV> dpx . file . image_offset = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . file . version ) , ( unsigned char * ) //<S2SV> dpx . file . version ) ; //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.version" , "%.8s" , dpx . file . version ) ; //<S2SV> dpx . file . file_size = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . file . ditto_key = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . file . ditto_key != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.ditto.key" , "%u" , //<S2SV> dpx . file . ditto_key ) ; //<S2SV> dpx . file . generic_size = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . file . industry_size = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . file . user_size = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . file . filename ) , ( unsigned char * ) //<S2SV> dpx . file . filename ) ; //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.filename" , "%.100s" , //<S2SV> dpx . file . filename ) ; //<S2SV> ( void ) FormatImageProperty ( image , "document" , "%.100s" , dpx . file . filename ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . file . timestamp ) , ( unsigned char * ) //<S2SV> dpx . file . timestamp ) ; //<S2SV> if ( * dpx . file . timestamp != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.timestamp" , "%.24s" , //<S2SV> dpx . file . timestamp ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . file . creator ) , ( unsigned char * ) //<S2SV> dpx . file . creator ) ; //<S2SV> if ( * dpx . file . creator == '\\0' ) //<S2SV> { //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.creator" , "%.100s" , //<S2SV> GetMagickVersion ( ( size_t * ) NULL ) ) ; //<S2SV> ( void ) FormatImageProperty ( image , "software" , "%.100s" , //<S2SV> GetMagickVersion ( ( size_t * ) NULL ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.creator" , "%.100s" , //<S2SV> dpx . file . creator ) ; //<S2SV> ( void ) FormatImageProperty ( image , "software" , "%.100s" , dpx . file . creator ) ; //<S2SV> } //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . file . project ) , ( unsigned char * ) //<S2SV> dpx . file . project ) ; //<S2SV> if ( * dpx . file . project != '\\0' ) //<S2SV> { //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.project" , "%.200s" , //<S2SV> dpx . file . project ) ; //<S2SV> ( void ) FormatImageProperty ( image , "comment" , "%.100s" , dpx . file . project ) ; //<S2SV> } //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . file . copyright ) , ( unsigned char * ) //<S2SV> dpx . file . copyright ) ; //<S2SV> if ( * dpx . file . copyright != '\\0' ) //<S2SV> { //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.copyright" , "%.200s" , //<S2SV> dpx . file . copyright ) ; //<S2SV> ( void ) FormatImageProperty ( image , "copyright" , "%.100s" , //<S2SV> dpx . file . copyright ) ; //<S2SV> } //<S2SV> dpx . file . encrypt_key = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . file . encrypt_key != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:file.encrypt_key" , "%u" , //<S2SV> dpx . file . encrypt_key ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . file . reserve ) , ( unsigned char * ) //<S2SV> dpx . file . reserve ) ; //<S2SV> dpx . image . orientation = ReadBlobShort ( image ) ; //<S2SV> if ( dpx . image . orientation > 7 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> offset += 2 ; //<S2SV> if ( dpx . image . orientation != ( unsigned short ) ~ 0 ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:image.orientation" , "%d" , //<S2SV> dpx . image . orientation ) ; //<S2SV> switch ( dpx . image . orientation ) //<S2SV> { //<S2SV> default : //<S2SV> case 0 : image -> orientation = TopLeftOrientation ; break ; //<S2SV> case 1 : image -> orientation = TopRightOrientation ; break ; //<S2SV> case 2 : image -> orientation = BottomLeftOrientation ; break ; //<S2SV> case 3 : image -> orientation = BottomRightOrientation ; break ; //<S2SV> case 4 : image -> orientation = LeftTopOrientation ; break ; //<S2SV> case 5 : image -> orientation = RightTopOrientation ; break ; //<S2SV> case 6 : image -> orientation = LeftBottomOrientation ; break ; //<S2SV> case 7 : image -> orientation = RightBottomOrientation ; break ; //<S2SV> } //<S2SV> dpx . image . number_elements = ReadBlobShort ( image ) ; //<S2SV> if ( dpx . image . number_elements > MaxNumberImageElements ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> offset += 2 ; //<S2SV> dpx . image . pixels_per_line = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> image -> columns = dpx . image . pixels_per_line ; //<S2SV> dpx . image . lines_per_element = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> image -> rows = dpx . image . lines_per_element ; //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> char //<S2SV> property [ MaxTextExtent ] ; //<S2SV> dpx . image . image_element [ i ] . data_sign = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . image . image_element [ i ] . low_data = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . image . image_element [ i ] . low_quantity = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . image . image_element [ i ] . high_data = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . image . image_element [ i ] . high_quantity = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . image . image_element [ i ] . descriptor = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> dpx . image . image_element [ i ] . transfer_characteristic = ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ; //<S2SV> ( void ) FormatLocaleString ( property , MaxTextExtent , //<S2SV> "dpx:image.element[%lu].transfer-characteristic" , ( long ) i ) ; //<S2SV> ( void ) FormatImageProperty ( image , property , "%s" , //<S2SV> GetImageTransferCharacteristic ( ( DPXTransferCharacteristic ) //<S2SV> dpx . image . image_element [ i ] . transfer_characteristic ) ) ; //<S2SV> offset ++ ; //<S2SV> dpx . image . image_element [ i ] . colorimetric = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> dpx . image . image_element [ i ] . bit_size = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> dpx . image . image_element [ i ] . packing = ReadBlobShort ( image ) ; //<S2SV> offset += 2 ; //<S2SV> dpx . image . image_element [ i ] . encoding = ReadBlobShort ( image ) ; //<S2SV> offset += 2 ; //<S2SV> dpx . image . image_element [ i ] . data_offset = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . image . image_element [ i ] . end_of_line_padding = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> dpx . image . image_element [ i ] . end_of_image_padding = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . image . image_element [ i ] . description ) , //<S2SV> ( unsigned char * ) dpx . image . image_element [ i ] . description ) ; //<S2SV> } //<S2SV> ( void ) SetImageColorspace ( image , RGBColorspace ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . image . reserve ) , ( unsigned char * ) //<S2SV> dpx . image . reserve ) ; //<S2SV> if ( dpx . file . image_offset >= 1664U ) //<S2SV> { //<S2SV> dpx . orientation . x_offset = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . orientation . x_offset != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.x_offset" , "%u" , //<S2SV> dpx . orientation . x_offset ) ; //<S2SV> dpx . orientation . y_offset = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . orientation . y_offset != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.y_offset" , "%u" , //<S2SV> dpx . orientation . y_offset ) ; //<S2SV> dpx . orientation . x_center = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . orientation . x_center ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.x_center" , "%g" , //<S2SV> dpx . orientation . x_center ) ; //<S2SV> dpx . orientation . y_center = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . orientation . y_center ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.y_center" , "%g" , //<S2SV> dpx . orientation . y_center ) ; //<S2SV> dpx . orientation . x_size = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . orientation . x_size != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.x_size" , "%u" , //<S2SV> dpx . orientation . x_size ) ; //<S2SV> dpx . orientation . y_size = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . orientation . y_size != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.y_size" , "%u" , //<S2SV> dpx . orientation . y_size ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . orientation . filename ) , ( unsigned char * ) //<S2SV> dpx . orientation . filename ) ; //<S2SV> if ( * dpx . orientation . filename != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.filename" , "%.100s" , //<S2SV> dpx . orientation . filename ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . orientation . timestamp ) , ( unsigned char * ) //<S2SV> dpx . orientation . timestamp ) ; //<S2SV> if ( * dpx . orientation . timestamp != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.timestamp" , "%.24s" , //<S2SV> dpx . orientation . timestamp ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . orientation . device ) , ( unsigned char * ) //<S2SV> dpx . orientation . device ) ; //<S2SV> if ( * dpx . orientation . device != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.device" , "%.32s" , //<S2SV> dpx . orientation . device ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . orientation . serial ) , ( unsigned char * ) //<S2SV> dpx . orientation . serial ) ; //<S2SV> if ( * dpx . orientation . serial != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.serial" , "%.32s" , //<S2SV> dpx . orientation . serial ) ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> { //<S2SV> dpx . orientation . border [ i ] = ReadBlobShort ( image ) ; //<S2SV> offset += 2 ; //<S2SV> } //<S2SV> if ( ( dpx . orientation . border [ 0 ] != ( unsigned short ) ( ~ 0 ) ) && //<S2SV> ( dpx . orientation . border [ 1 ] != ( unsigned short ) ( ~ 0 ) ) ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.border" , "%dx%d%+d%+d" , dpx . orientation . border [ 0 ] , dpx . orientation . border [ 1 ] , //<S2SV> dpx . orientation . border [ 2 ] , dpx . orientation . border [ 3 ] ) ; //<S2SV> for ( i = 0 ; i < 2 ; i ++ ) //<S2SV> { //<S2SV> dpx . orientation . aspect_ratio [ i ] = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> } //<S2SV> if ( ( dpx . orientation . aspect_ratio [ 0 ] != ~ 0U ) && //<S2SV> ( dpx . orientation . aspect_ratio [ 1 ] != ~ 0U ) ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:orientation.aspect_ratio" , //<S2SV> "%ux%u" , dpx . orientation . aspect_ratio [ 0 ] , //<S2SV> dpx . orientation . aspect_ratio [ 1 ] ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . orientation . reserve ) , ( unsigned char * ) //<S2SV> dpx . orientation . reserve ) ; //<S2SV> } //<S2SV> if ( dpx . file . image_offset >= 1920U ) //<S2SV> { //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . id ) , ( unsigned char * ) dpx . film . id ) ; //<S2SV> if ( * dpx . film . id != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.id" , "%.2s" , dpx . film . id ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . type ) , ( unsigned char * ) //<S2SV> dpx . film . type ) ; //<S2SV> if ( * dpx . film . type != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.type" , "%.2s" , dpx . film . type ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . offset ) , ( unsigned char * ) //<S2SV> dpx . film . offset ) ; //<S2SV> if ( * dpx . film . offset != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.offset" , "%.2s" , //<S2SV> dpx . film . offset ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . prefix ) , ( unsigned char * ) //<S2SV> dpx . film . prefix ) ; //<S2SV> if ( * dpx . film . prefix != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.prefix" , "%.6s" , //<S2SV> dpx . film . prefix ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . count ) , ( unsigned char * ) //<S2SV> dpx . film . count ) ; //<S2SV> if ( * dpx . film . count != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.count" , "%.4s" , //<S2SV> dpx . film . count ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . format ) , ( unsigned char * ) //<S2SV> dpx . film . format ) ; //<S2SV> if ( * dpx . film . format != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.format" , "%.4s" , //<S2SV> dpx . film . format ) ; //<S2SV> dpx . film . frame_position = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . film . frame_position != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.frame_position" , "%u" , //<S2SV> dpx . film . frame_position ) ; //<S2SV> dpx . film . sequence_extent = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . film . sequence_extent != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.sequence_extent" , "%u" , //<S2SV> dpx . film . sequence_extent ) ; //<S2SV> dpx . film . held_count = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( dpx . film . held_count != ~ 0U ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.held_count" , "%u" , //<S2SV> dpx . film . held_count ) ; //<S2SV> dpx . film . frame_rate = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . film . frame_rate ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.frame_rate" , "%g" , //<S2SV> dpx . film . frame_rate ) ; //<S2SV> dpx . film . shutter_angle = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . film . shutter_angle ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.shutter_angle" , "%g" , //<S2SV> dpx . film . shutter_angle ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . frame_id ) , ( unsigned char * ) //<S2SV> dpx . film . frame_id ) ; //<S2SV> if ( * dpx . film . frame_id != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.frame_id" , "%.32s" , //<S2SV> dpx . film . frame_id ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . slate ) , ( unsigned char * ) //<S2SV> dpx . film . slate ) ; //<S2SV> if ( * dpx . film . slate != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.slate" , "%.100s" , //<S2SV> dpx . film . slate ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . film . reserve ) , ( unsigned char * ) //<S2SV> dpx . film . reserve ) ; //<S2SV> } //<S2SV> if ( dpx . file . image_offset >= 2048U ) //<S2SV> { //<S2SV> dpx . television . time_code = ( unsigned int ) ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> TimeCodeToString ( dpx . television . time_code , value ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:television.time.code" , value ) ; //<S2SV> dpx . television . user_bits = ( unsigned int ) ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> TimeCodeToString ( dpx . television . user_bits , value ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:television.user.bits" , value ) ; //<S2SV> dpx . television . interlace = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> if ( dpx . television . interlace != 0 ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.interlace" , "%.20g" , //<S2SV> ( double ) dpx . television . interlace ) ; //<S2SV> dpx . television . field_number = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> if ( dpx . television . field_number != 0 ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.field_number" , "%.20g" , //<S2SV> ( double ) dpx . television . field_number ) ; //<S2SV> dpx . television . video_signal = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> if ( dpx . television . video_signal != 0 ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.video_signal" , "%.20g" , //<S2SV> ( double ) dpx . television . video_signal ) ; //<S2SV> dpx . television . padding = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> if ( dpx . television . padding != 0 ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.padding" , "%d" , //<S2SV> dpx . television . padding ) ; //<S2SV> dpx . television . horizontal_sample_rate = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . horizontal_sample_rate ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , //<S2SV> "dpx:television.horizontal_sample_rate" , "%g" , //<S2SV> dpx . television . horizontal_sample_rate ) ; //<S2SV> dpx . television . vertical_sample_rate = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . vertical_sample_rate ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.vertical_sample_rate" , //<S2SV> "%g" , dpx . television . vertical_sample_rate ) ; //<S2SV> dpx . television . frame_rate = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . frame_rate ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.frame_rate" , "%g" , //<S2SV> dpx . television . frame_rate ) ; //<S2SV> dpx . television . time_offset = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . time_offset ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.time_offset" , "%g" , //<S2SV> dpx . television . time_offset ) ; //<S2SV> dpx . television . gamma = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . gamma ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.gamma" , "%g" , //<S2SV> dpx . television . gamma ) ; //<S2SV> dpx . television . black_level = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . black_level ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.black_level" , "%g" , //<S2SV> dpx . television . black_level ) ; //<S2SV> dpx . television . black_gain = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . black_gain ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.black_gain" , "%g" , //<S2SV> dpx . television . black_gain ) ; //<S2SV> dpx . television . break_point = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . break_point ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.break_point" , "%g" , //<S2SV> dpx . television . break_point ) ; //<S2SV> dpx . television . white_level = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . white_level ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.white_level" , "%g" , //<S2SV> dpx . television . white_level ) ; //<S2SV> dpx . television . integration_times = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( dpx . television . integration_times ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:television.integration_times" , //<S2SV> "%g" , dpx . television . integration_times ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . television . reserve ) , ( unsigned char * ) //<S2SV> dpx . television . reserve ) ; //<S2SV> } //<S2SV> if ( dpx . file . image_offset > 2080U ) //<S2SV> { //<S2SV> offset += ReadBlob ( image , sizeof ( dpx . user . id ) , ( unsigned char * ) dpx . user . id ) ; //<S2SV> if ( * dpx . user . id != '\\0' ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:user.id" , "%.32s" , dpx . user . id ) ; //<S2SV> if ( ( dpx . file . user_size != ~ 0U ) && //<S2SV> ( ( size_t ) dpx . file . user_size > sizeof ( dpx . user . id ) ) ) //<S2SV> { //<S2SV> StringInfo //<S2SV> * profile ; //<S2SV> profile = BlobToStringInfo ( ( const void * ) NULL , //<S2SV> dpx . file . user_size - sizeof ( dpx . user . id ) ) ; //<S2SV> if ( profile == ( StringInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> offset += ReadBlob ( image , GetStringInfoLength ( profile ) , //<S2SV> GetStringInfoDatum ( profile ) ) ; //<S2SV> ( void ) SetImageProfile ( image , "dpx:user-data" , profile ) ; //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> } //<S2SV> } //<S2SV> for ( ; offset < ( MagickOffsetType ) dpx . file . image_offset ; offset ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> for ( n = 0 ; n < ( ssize_t ) dpx . image . number_elements ; n ++ ) //<S2SV> { //<S2SV> if ( ( dpx . image . image_element [ n ] . data_offset != ~ 0U ) && //<S2SV> ( dpx . image . image_element [ n ] . data_offset != 0U ) ) //<S2SV> { //<S2SV> MagickOffsetType //<S2SV> data_offset ; //<S2SV> data_offset = ( MagickOffsetType ) dpx . image . image_element [ n ] . data_offset ; //<S2SV> if ( data_offset < offset ) //<S2SV> offset = SeekBlob ( image , data_offset , SEEK_SET ) ; //<S2SV> else //<S2SV> for ( ; offset < data_offset ; offset ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( offset != data_offset ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> } //<S2SV> SetPrimaryChromaticity ( ( DPXColorimetric ) //<S2SV> dpx . image . image_element [ n ] . colorimetric , & image -> chromaticity ) ; //<S2SV> image -> depth = dpx . image . image_element [ n ] . bit_size ; //<S2SV> samples_per_pixel = 1 ; //<S2SV> quantum_type = GrayQuantum ; //<S2SV> component_type = dpx . image . image_element [ n ] . descriptor ; //<S2SV> switch ( component_type ) //<S2SV> { //<S2SV> case CbYCrY422ComponentType : //<S2SV> { //<S2SV> samples_per_pixel = 2 ; //<S2SV> quantum_type = CbYCrYQuantum ; //<S2SV> break ; //<S2SV> } //<S2SV> case CbYACrYA4224ComponentType : //<S2SV> case CbYCr444ComponentType : //<S2SV> { //<S2SV> samples_per_pixel = 3 ; //<S2SV> quantum_type = CbYCrQuantum ; //<S2SV> break ; //<S2SV> } //<S2SV> case RGBComponentType : //<S2SV> { //<S2SV> samples_per_pixel = 3 ; //<S2SV> quantum_type = RGBQuantum ; //<S2SV> break ; //<S2SV> } //<S2SV> case ABGRComponentType : //<S2SV> case RGBAComponentType : //<S2SV> { //<S2SV> image -> matte = MagickTrue ; //<S2SV> samples_per_pixel = 4 ; //<S2SV> quantum_type = RGBAQuantum ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> switch ( component_type ) //<S2SV> { //<S2SV> case CbYCrY422ComponentType : //<S2SV> case CbYACrYA4224ComponentType : //<S2SV> case CbYCr444ComponentType : //<S2SV> { //<S2SV> ( void ) SetImageColorspace ( image , Rec709YCbCrColorspace ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case LumaComponentType : //<S2SV> { //<S2SV> ( void ) SetImageColorspace ( image , GRAYColorspace ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> ( void ) SetImageColorspace ( image , RGBColorspace ) ; //<S2SV> if ( dpx . image . image_element [ n ] . transfer_characteristic == LogarithmicColorimetric ) //<S2SV> ( void ) SetImageColorspace ( image , LogColorspace ) ; //<S2SV> if ( dpx . image . image_element [ n ] . transfer_characteristic == PrintingDensityColorimetric ) //<S2SV> ( void ) SetImageColorspace ( image , LogColorspace ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> extent = GetBytesPerRow ( image -> columns , samples_per_pixel , image -> depth , //<S2SV> dpx . image . image_element [ n ] . packing == 0 ? MagickFalse : MagickTrue ) ; //<S2SV> status = MagickTrue ; //<S2SV> row = 0 ; //<S2SV> quantum_info = AcquireQuantumInfo ( image_info , image ) ; //<S2SV> if ( quantum_info == ( QuantumInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> SetQuantumQuantum ( quantum_info , 32 ) ; //<S2SV> SetQuantumPack ( quantum_info , dpx . image . image_element [ n ] . packing == 0 ? //<S2SV> MagickTrue : MagickFalse ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> MagickBooleanType //<S2SV> sync ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> size_t //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> offset ; //<S2SV> unsigned char //<S2SV> * pixels ; //<S2SV> if ( status == MagickFalse ) //<S2SV> continue ; //<S2SV> pixels = GetQuantumPixels ( quantum_info ) ; //<S2SV> { //<S2SV> count = ReadBlob ( image , extent , pixels ) ; //<S2SV> if ( ( image -> progress_monitor != ( MagickProgressMonitor ) NULL ) && //<S2SV> ( image -> previous == ( Image * ) NULL ) ) //<S2SV> { //<S2SV> MagickBooleanType //<S2SV> proceed ; //<S2SV> proceed = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) row , //<S2SV> image -> rows ) ; //<S2SV> if ( proceed == MagickFalse ) //<S2SV> status = MagickFalse ; //<S2SV> } //<S2SV> offset = row ++ ; //<S2SV> } //<S2SV> if ( count != ( ssize_t ) extent ) //<S2SV> status = MagickFalse ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> continue ; //<S2SV> } //<S2SV> length = ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , //<S2SV> quantum_type , pixels , exception ) ; //<S2SV> ( void ) length ; //<S2SV> sync = SyncAuthenticPixels ( image , exception ) ; //<S2SV> if ( sync == MagickFalse ) //<S2SV> status = MagickFalse ; //<S2SV> } //<S2SV> quantum_info = DestroyQuantumInfo ( quantum_info ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> SetQuantumImageType ( image , quantum_type ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 