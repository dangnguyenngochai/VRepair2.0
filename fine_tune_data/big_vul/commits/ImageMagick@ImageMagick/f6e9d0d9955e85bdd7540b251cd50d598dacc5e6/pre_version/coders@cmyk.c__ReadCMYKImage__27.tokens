static Image * ReadCMYKImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> Image //<S2SV> * canvas_image , //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickOffsetType //<S2SV> scene ; //<S2SV> QuantumInfo //<S2SV> * quantum_info ; //<S2SV> QuantumType //<S2SV> quantum_type ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * pixels ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) //<S2SV> ThrowReaderException ( OptionError , "MustSpecifyImageSize" ) ; //<S2SV> SetImageColorspace ( image , CMYKColorspace ) ; //<S2SV> if ( image_info -> interlace != PartitionInterlace ) //<S2SV> { //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> } //<S2SV> canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , //<S2SV> exception ) ; //<S2SV> ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; //<S2SV> quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; //<S2SV> if ( quantum_info == ( QuantumInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> pixels = GetQuantumPixels ( quantum_info ) ; //<S2SV> quantum_type = CMYKQuantum ; //<S2SV> if ( LocaleCompare ( image_info -> magick , "CMYKA" ) == 0 ) //<S2SV> { //<S2SV> quantum_type = CMYKAQuantum ; //<S2SV> image -> matte = MagickTrue ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> while ( image -> scene < image_info -> scene ) //<S2SV> { //<S2SV> image -> scene ++ ; //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> count = 0 ; //<S2SV> length = 0 ; //<S2SV> scene = 0 ; //<S2SV> do //<S2SV> { //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> SetImageColorspace ( image , CMYKColorspace ) ; //<S2SV> switch ( image_info -> interlace ) //<S2SV> { //<S2SV> case NoInterlace : //<S2SV> default : //<S2SV> { //<S2SV> if ( scene == 0 ) //<S2SV> { //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const IndexPacket //<S2SV> * restrict canvas_indexes ; //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register IndexPacket //<S2SV> * restrict indexes ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , quantum_type , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( q , GetPixelRed ( p ) ) ; //<S2SV> SetPixelGreen ( q , GetPixelGreen ( p ) ) ; //<S2SV> SetPixelBlue ( q , GetPixelBlue ( p ) ) ; //<S2SV> SetPixelBlack ( indexes + x , GetPixelBlack ( //<S2SV> canvas_indexes + image -> extract_info . x + x ) ) ; //<S2SV> SetPixelOpacity ( q , OpaqueOpacity ) ; //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case LineInterlace : //<S2SV> { //<S2SV> static QuantumType //<S2SV> quantum_types [ 5 ] = //<S2SV> { //<S2SV> CyanQuantum , //<S2SV> MagentaQuantum , //<S2SV> YellowQuantum , //<S2SV> BlackQuantum , //<S2SV> OpacityQuantum //<S2SV> } ; //<S2SV> if ( scene == 0 ) //<S2SV> { //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const IndexPacket //<S2SV> * restrict canvas_indexes ; //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register IndexPacket //<S2SV> * restrict indexes ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ( image -> matte != MagickFalse ? 5 : 4 ) ; i ++ ) //<S2SV> { //<S2SV> quantum_type = quantum_types [ i ] ; //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , quantum_type , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , //<S2SV> 0 , canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> switch ( quantum_type ) //<S2SV> { //<S2SV> case CyanQuantum : //<S2SV> { //<S2SV> SetPixelCyan ( q , GetPixelCyan ( p ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case MagentaQuantum : //<S2SV> { //<S2SV> SetPixelMagenta ( q , GetPixelMagenta ( p ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case YellowQuantum : //<S2SV> { //<S2SV> SetPixelYellow ( q , GetPixelYellow ( p ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case BlackQuantum : //<S2SV> { //<S2SV> SetPixelIndex ( indexes + x , GetPixelIndex ( //<S2SV> canvas_indexes + image -> extract_info . x + x ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case OpacityQuantum : //<S2SV> { //<S2SV> SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case PlaneInterlace : //<S2SV> { //<S2SV> if ( scene == 0 ) //<S2SV> { //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , CyanQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( q , GetPixelRed ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 1 , 6 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , MagentaQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelGreen ( q , GetPixelGreen ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 2 , 6 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , YellowQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelBlue ( q , GetPixelBlue ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 3 , 6 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const IndexPacket //<S2SV> * restrict canvas_indexes ; //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register IndexPacket //<S2SV> * restrict indexes ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , BlackQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( indexes + x , GetPixelIndex ( //<S2SV> canvas_indexes + image -> extract_info . x + x ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 4 , 6 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , AlphaQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , //<S2SV> canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 5 , 6 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 6 , 6 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case PartitionInterlace : //<S2SV> { //<S2SV> AppendImageFormat ( "C" , image -> filename ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> canvas_image = DestroyImageList ( canvas_image ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , CyanQuantum ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , CyanQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( q , GetPixelRed ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> AppendImageFormat ( "M" , image -> filename ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> canvas_image = DestroyImageList ( canvas_image ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , MagentaQuantum ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , MagentaQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelGreen ( q , GetPixelGreen ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> AppendImageFormat ( "Y" , image -> filename ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> canvas_image = DestroyImageList ( canvas_image ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , YellowQuantum ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , YellowQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelBlue ( q , GetPixelBlue ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> AppendImageFormat ( "K" , image -> filename ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> canvas_image = DestroyImageList ( canvas_image ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , BlackQuantum ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const IndexPacket //<S2SV> * restrict canvas_indexes ; //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register IndexPacket //<S2SV> * restrict indexes ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , BlackQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , //<S2SV> canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> canvas_indexes = GetVirtualIndexQueue ( canvas_image ) ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( indexes + x , GetPixelIndex ( //<S2SV> canvas_indexes + image -> extract_info . x + x ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> AppendImageFormat ( "A" , image -> filename ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> canvas_image = DestroyImageList ( canvas_image ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> length = GetQuantumExtent ( canvas_image , quantum_info , AlphaQuantum ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> if ( ReadBlob ( image , length , pixels ) != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) //<S2SV> { //<S2SV> register const PixelPacket //<S2SV> * restrict p ; //<S2SV> register PixelPacket //<S2SV> * restrict q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , //<S2SV> quantum_info , YellowQuantum , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( ( y - image -> extract_info . y ) >= 0 ) && //<S2SV> ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) //<S2SV> { //<S2SV> p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , //<S2SV> 0 , canvas_image -> columns , 1 , exception ) ; //<S2SV> q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , //<S2SV> image -> columns , 1 , exception ) ; //<S2SV> if ( ( p == ( const PixelPacket * ) NULL ) || //<S2SV> ( q == ( PixelPacket * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelOpacity ( q , GetPixelOpacity ( p ) ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> SetQuantumImageType ( image , quantum_type ) ; //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( count == ( ssize_t ) length ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> scene ++ ; //<S2SV> } while ( count == ( ssize_t ) length ) ; //<S2SV> quantum_info = DestroyQuantumInfo ( quantum_info ) ; //<S2SV> InheritException ( & image -> exception , & canvas_image -> exception ) ; //<S2SV> canvas_image = DestroyImage ( canvas_image ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 