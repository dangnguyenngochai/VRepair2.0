static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> format [ MaxTextExtent ] , //<S2SV> keyword [ MaxTextExtent ] , //<S2SV> tag [ MaxTextExtent ] , //<S2SV> value [ MaxTextExtent ] ; //<S2SV> double //<S2SV> gamma ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> c ; //<S2SV> MagickBooleanType //<S2SV> status , //<S2SV> value_expected ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * end , //<S2SV> pixel [ 4 ] , //<S2SV> * pixels ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image -> columns = 0 ; //<S2SV> image -> rows = 0 ; //<S2SV> * format = '\\0' ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> { //<S2SV> image = DestroyImage ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) //<S2SV> { //<S2SV> if ( c == ( int ) '#' ) //<S2SV> { //<S2SV> char //<S2SV> * comment ; //<S2SV> register char //<S2SV> * p ; //<S2SV> size_t //<S2SV> length ; //<S2SV> length = MaxTextExtent ; //<S2SV> comment = AcquireString ( ( char * ) NULL ) ; //<S2SV> for ( p = comment ; comment != ( char * ) NULL ; p ++ ) //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) //<S2SV> break ; //<S2SV> if ( ( size_t ) ( p - comment + 1 ) >= length ) //<S2SV> { //<S2SV> * p = '\\0' ; //<S2SV> length <<= 1 ; //<S2SV> comment = ( char * ) ResizeQuantumMemory ( comment , length + //<S2SV> MaxTextExtent , sizeof ( * comment ) ) ; //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> break ; //<S2SV> p = comment + strlen ( comment ) ; //<S2SV> } //<S2SV> * p = ( char ) c ; //<S2SV> } //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> * p = '\\0' ; //<S2SV> ( void ) SetImageProperty ( image , "comment" , comment ) ; //<S2SV> comment = DestroyString ( comment ) ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( isalnum ( c ) == MagickFalse ) //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> else //<S2SV> { //<S2SV> register char //<S2SV> * p ; //<S2SV> p = keyword ; //<S2SV> do //<S2SV> { //<S2SV> if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) //<S2SV> * p ++ = c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } while ( isalnum ( c ) || ( c == '_' ) ) ; //<S2SV> * p = '\\0' ; //<S2SV> value_expected = MagickFalse ; //<S2SV> while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) //<S2SV> { //<S2SV> if ( c == '=' ) //<S2SV> value_expected = MagickTrue ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "Y" ) == 0 ) //<S2SV> value_expected = MagickTrue ; //<S2SV> if ( value_expected == MagickFalse ) //<S2SV> continue ; //<S2SV> p = value ; //<S2SV> while ( ( c != '\\n' ) && ( c != '\\0' ) ) //<S2SV> { //<S2SV> if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) //<S2SV> * p ++ = c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> * p = '\\0' ; //<S2SV> switch ( * keyword ) //<S2SV> { //<S2SV> case 'F' : //<S2SV> case 'f' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "format" ) == 0 ) //<S2SV> { //<S2SV> ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) FormatLocaleString ( tag , MaxTextExtent , "hdr:%s" , keyword ) ; //<S2SV> ( void ) SetImageProperty ( image , tag , value ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'G' : //<S2SV> case 'g' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "gamma" ) == 0 ) //<S2SV> { //<S2SV> image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) FormatLocaleString ( tag , MaxTextExtent , "hdr:%s" , keyword ) ; //<S2SV> ( void ) SetImageProperty ( image , tag , value ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'P' : //<S2SV> case 'p' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "primaries" ) == 0 ) //<S2SV> { //<S2SV> float //<S2SV> chromaticity [ 6 ] , //<S2SV> white_point [ 2 ] ; //<S2SV> ( void ) sscanf ( value , "%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g" , //<S2SV> & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , //<S2SV> & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , //<S2SV> & white_point [ 0 ] , & white_point [ 1 ] ) ; //<S2SV> image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; //<S2SV> image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; //<S2SV> image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; //<S2SV> image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; //<S2SV> image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; //<S2SV> image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; //<S2SV> image -> chromaticity . white_point . x = white_point [ 0 ] , //<S2SV> image -> chromaticity . white_point . y = white_point [ 1 ] ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) FormatLocaleString ( tag , MaxTextExtent , "hdr:%s" , keyword ) ; //<S2SV> ( void ) SetImageProperty ( image , tag , value ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'Y' : //<S2SV> case 'y' : //<S2SV> { //<S2SV> if ( strcmp ( keyword , "Y" ) == 0 ) //<S2SV> { //<S2SV> int //<S2SV> height , //<S2SV> width ; //<S2SV> ( void ) sscanf ( value , "%d<S2SV_blank>+X<S2SV_blank>%d" , & height , & width ) ; //<S2SV> image -> columns = ( size_t ) width ; //<S2SV> image -> rows = ( size_t ) height ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) FormatLocaleString ( tag , MaxTextExtent , "hdr:%s" , keyword ) ; //<S2SV> ( void ) SetImageProperty ( image , tag , value ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> ( void ) FormatLocaleString ( tag , MaxTextExtent , "hdr:%s" , keyword ) ; //<S2SV> ( void ) SetImageProperty ( image , tag , value ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) //<S2SV> while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> if ( ( LocaleCompare ( format , "32-bit_rle_rgbe" ) != 0 ) && //<S2SV> ( LocaleCompare ( format , "32-bit_rle_xyze" ) != 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; //<S2SV> ( void ) SetImageColorspace ( image , RGBColorspace ) ; //<S2SV> if ( LocaleCompare ( format , "32-bit_rle_xyze" ) == 0 ) //<S2SV> ( void ) SetImageColorspace ( image , XYZColorspace ) ; //<S2SV> image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? //<S2SV> NoCompression : RLECompression ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * //<S2SV> sizeof ( * pixels ) ) ; //<S2SV> if ( pixels == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> if ( image -> compression != RLECompression ) //<S2SV> { //<S2SV> count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; //<S2SV> if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; //<S2SV> if ( count != 4 ) //<S2SV> break ; //<S2SV> if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) //<S2SV> { //<S2SV> ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; //<S2SV> count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; //<S2SV> image -> compression = NoCompression ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> p = pixels ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> { //<S2SV> end = & pixels [ ( i + 1 ) * image -> columns ] ; //<S2SV> while ( p < end ) //<S2SV> { //<S2SV> count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; //<S2SV> if ( count < 1 ) //<S2SV> break ; //<S2SV> if ( pixel [ 0 ] > 128 ) //<S2SV> { //<S2SV> count = ( ssize_t ) pixel [ 0 ] - 128 ; //<S2SV> if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) //<S2SV> break ; //<S2SV> while ( count -- > 0 ) //<S2SV> * p ++ = pixel [ 1 ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> count = ( ssize_t ) pixel [ 0 ] ; //<S2SV> if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) //<S2SV> break ; //<S2SV> * p ++ = pixel [ 1 ] ; //<S2SV> if ( -- count > 0 ) //<S2SV> { //<S2SV> count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; //<S2SV> if ( count < 1 ) //<S2SV> break ; //<S2SV> p += count ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> i = 0 ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( image -> compression == RLECompression ) //<S2SV> { //<S2SV> pixel [ 0 ] = pixels [ x ] ; //<S2SV> pixel [ 1 ] = pixels [ x + image -> columns ] ; //<S2SV> pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; //<S2SV> pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pixel [ 0 ] = pixels [ i ++ ] ; //<S2SV> pixel [ 1 ] = pixels [ i ++ ] ; //<S2SV> pixel [ 2 ] = pixels [ i ++ ] ; //<S2SV> pixel [ 3 ] = pixels [ i ++ ] ; //<S2SV> } //<S2SV> SetPixelRed ( q , 0 ) ; //<S2SV> SetPixelGreen ( q , 0 ) ; //<S2SV> SetPixelBlue ( q , 0 ) ; //<S2SV> if ( pixel [ 3 ] != 0 ) //<S2SV> { //<S2SV> gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; //<S2SV> SetPixelRed ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) ) ; //<S2SV> SetPixelGreen ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) ) ; //<S2SV> SetPixelBlue ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) ) ; //<S2SV> } //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 