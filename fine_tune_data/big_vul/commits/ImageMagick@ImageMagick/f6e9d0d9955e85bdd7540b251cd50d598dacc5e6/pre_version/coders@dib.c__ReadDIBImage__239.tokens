static Image * ReadDIBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> DIBInfo //<S2SV> dib_info ; //<S2SV> Image //<S2SV> * image ; //<S2SV> IndexPacket //<S2SV> index ; //<S2SV> ssize_t //<S2SV> bit , //<S2SV> y ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MemoryInfo //<S2SV> * pixel_info ; //<S2SV> register IndexPacket //<S2SV> * indexes ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bytes_per_line , //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count ; //<S2SV> unsigned char //<S2SV> * pixels ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; //<S2SV> dib_info . size = ReadBlobLSBLong ( image ) ; //<S2SV> if ( dib_info . size != 40 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> dib_info . width = ( short ) ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . height = ( short ) ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . planes = ReadBlobLSBShort ( image ) ; //<S2SV> dib_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; //<S2SV> dib_info . compression = ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . image_size = ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . x_pixels = ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . y_pixels = ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . number_colors = ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . colors_important = ReadBlobLSBLong ( image ) ; //<S2SV> if ( ( dib_info . compression == BI_BITFIELDS ) && //<S2SV> ( ( dib_info . bits_per_pixel == 16 ) || ( dib_info . bits_per_pixel == 32 ) ) ) //<S2SV> { //<S2SV> dib_info . red_mask = ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . green_mask = ReadBlobLSBLong ( image ) ; //<S2SV> dib_info . blue_mask = ReadBlobLSBLong ( image ) ; //<S2SV> } //<S2SV> image -> matte = dib_info . bits_per_pixel == 32 ? MagickTrue : MagickFalse ; //<S2SV> image -> columns = ( size_t ) MagickAbsoluteValue ( dib_info . width ) ; //<S2SV> image -> rows = ( size_t ) MagickAbsoluteValue ( dib_info . height ) ; //<S2SV> image -> depth = 8 ; //<S2SV> if ( ( dib_info . number_colors != 0 ) || ( dib_info . bits_per_pixel < 16 ) ) //<S2SV> { //<S2SV> size_t //<S2SV> one ; //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> colors = dib_info . number_colors ; //<S2SV> one = 1 ; //<S2SV> if ( image -> colors == 0 ) //<S2SV> image -> colors = one << dib_info . bits_per_pixel ; //<S2SV> } //<S2SV> if ( image_info -> size ) //<S2SV> { //<S2SV> RectangleInfo //<S2SV> geometry ; //<S2SV> MagickStatusType //<S2SV> flags ; //<S2SV> flags = ParseAbsoluteGeometry ( image_info -> size , & geometry ) ; //<S2SV> if ( flags & WidthValue ) //<S2SV> if ( ( geometry . width != 0 ) && ( geometry . width < image -> columns ) ) //<S2SV> image -> columns = geometry . width ; //<S2SV> if ( flags & HeightValue ) //<S2SV> if ( ( geometry . height != 0 ) && ( geometry . height < image -> rows ) ) //<S2SV> image -> rows = geometry . height ; //<S2SV> } //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> size_t //<S2SV> length , //<S2SV> packet_size ; //<S2SV> unsigned char //<S2SV> * dib_colormap ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> length = ( size_t ) image -> colors ; //<S2SV> dib_colormap = ( unsigned char * ) AcquireQuantumMemory ( length , //<S2SV> 4 * sizeof ( * dib_colormap ) ) ; //<S2SV> if ( dib_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> packet_size = 4 ; //<S2SV> count = ReadBlob ( image , packet_size * image -> colors , dib_colormap ) ; //<S2SV> if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> p = dib_colormap ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; //<S2SV> if ( packet_size == 4 ) //<S2SV> p ++ ; //<S2SV> } //<S2SV> dib_colormap = ( unsigned char * ) RelinquishMagickMemory ( dib_colormap ) ; //<S2SV> } //<S2SV> if ( dib_info . compression == BI_RLE4 ) //<S2SV> dib_info . bits_per_pixel <<= 1 ; //<S2SV> bytes_per_line = 4 * ( ( image -> columns * dib_info . bits_per_pixel + 31 ) / 32 ) ; //<S2SV> length = bytes_per_line * image -> rows ; //<S2SV> pixel_info = AcquireVirtualMemory ( ( size_t ) image -> rows , MagickMax ( //<S2SV> bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; //<S2SV> if ( pixel_info == ( MemoryInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; //<S2SV> if ( ( dib_info . compression == BI_RGB ) || //<S2SV> ( dib_info . compression == BI_BITFIELDS ) ) //<S2SV> { //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> if ( count != ( ssize_t ) ( length ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> status = DecodeImage ( image , dib_info . compression ? MagickTrue : MagickFalse , //<S2SV> pixels ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToRunlengthDecodeImage" ) ; //<S2SV> } //<S2SV> image -> units = PixelsPerCentimeterResolution ; //<S2SV> image -> x_resolution = ( double ) dib_info . x_pixels / 100.0 ; //<S2SV> image -> y_resolution = ( double ) dib_info . y_pixels / 100.0 ; //<S2SV> switch ( dib_info . bits_per_pixel ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; //<S2SV> SetPixelIndex ( indexes + x + bit , index ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) //<S2SV> { //<S2SV> index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; //<S2SV> SetPixelIndex ( indexes + x + bit , index ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> index = ConstrainColormapIndex ( image , * p & 0xf ) ; //<S2SV> SetPixelIndex ( indexes + x + 1 , index ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 2 ) != 0 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 8 : //<S2SV> { //<S2SV> if ( ( dib_info . compression == BI_RLE8 ) || //<S2SV> ( dib_info . compression == BI_RLE4 ) ) //<S2SV> bytes_per_line = image -> columns ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , * p ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 16 : //<S2SV> { //<S2SV> unsigned short //<S2SV> word ; //<S2SV> image -> storage_class = DirectClass ; //<S2SV> if ( dib_info . compression == BI_RLE8 ) //<S2SV> bytes_per_line = 2 * image -> columns ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> word = ( * p ++ ) ; //<S2SV> word |= ( * p ++ << 8 ) ; //<S2SV> if ( dib_info . red_mask == 0 ) //<S2SV> { //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( //<S2SV> ( unsigned char ) ( ( word >> 10 ) & 0x1f ) ) ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor5to8 ( //<S2SV> ( unsigned char ) ( ( word >> 5 ) & 0x1f ) ) ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( //<S2SV> ( unsigned char ) ( word & 0x1f ) ) ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( //<S2SV> ( unsigned char ) ( ( word >> 11 ) & 0x1f ) ) ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor6to8 ( //<S2SV> ( unsigned char ) ( ( word >> 5 ) & 0x3f ) ) ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( //<S2SV> ( unsigned char ) ( word & 0x1f ) ) ) ) ; //<S2SV> } //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 24 : //<S2SV> case 32 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> SetPixelOpacity ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> if ( dib_info . height < 0 ) //<S2SV> { //<S2SV> Image //<S2SV> * flipped_image ; //<S2SV> flipped_image = FlipImage ( image , exception ) ; //<S2SV> if ( flipped_image != ( Image * ) NULL ) //<S2SV> { //<S2SV> DuplicateBlob ( flipped_image , image ) ; //<S2SV> image = DestroyImage ( image ) ; //<S2SV> image = flipped_image ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 