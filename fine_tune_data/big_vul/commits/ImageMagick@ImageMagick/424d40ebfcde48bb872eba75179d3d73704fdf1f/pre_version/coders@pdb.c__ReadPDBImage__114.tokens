static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> unsigned char //<S2SV> attributes , //<S2SV> tag [ 3 ] ; //<S2SV> Image //<S2SV> * image ; //<S2SV> IndexPacket //<S2SV> index ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> PDBImage //<S2SV> pdb_image ; //<S2SV> PDBInfo //<S2SV> pdb_info ; //<S2SV> register IndexPacket //<S2SV> * indexes ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bits_per_pixel , //<S2SV> num_pad_bytes , //<S2SV> one , //<S2SV> packets ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> img_offset , //<S2SV> comment_offset = 0 , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * pixels ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; //<S2SV> if ( count != sizeof ( pdb_info . name ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; //<S2SV> pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; //<S2SV> pdb_info . create_time = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_info . modify_time = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_info . archive_time = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_info . modify_number = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_info . application_info = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_info . sort_info = ReadBlobMSBLong ( image ) ; //<S2SV> ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; //<S2SV> ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; //<S2SV> pdb_info . seed = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_info . next_record = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_info . number_records = ( short ) ReadBlobMSBShort ( image ) ; //<S2SV> if ( ( memcmp ( pdb_info . type , "vIMG" , 4 ) != 0 ) || //<S2SV> ( memcmp ( pdb_info . id , "View" , 4 ) != 0 ) ) //<S2SV> if ( pdb_info . next_record != 0 ) //<S2SV> ThrowReaderException ( CoderError , "MultipleRecordListNotSupported" ) ; //<S2SV> img_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; //<S2SV> attributes = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; //<S2SV> ( void ) attributes ; //<S2SV> count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; //<S2SV> if ( count != 3 || memcmp ( tag , "\\x6f\\x80\\x00" , 3 ) != 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; //<S2SV> if ( pdb_info . number_records > 1 ) //<S2SV> { //<S2SV> comment_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; //<S2SV> attributes = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; //<S2SV> count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; //<S2SV> if ( count != 3 || memcmp ( tag , "\\x6f\\x80\\x01" , 3 ) != 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; //<S2SV> } //<S2SV> num_pad_bytes = ( size_t ) ( img_offset - TellBlob ( image ) ) ; //<S2SV> while ( num_pad_bytes -- != 0 ) //<S2SV> { //<S2SV> int //<S2SV> c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> count = ReadBlob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; //<S2SV> if ( count != sizeof ( pdb_image . name ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> pdb_image . version = ReadBlobByte ( image ) ; //<S2SV> pdb_image . type = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> pdb_image . reserved_1 = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_image . note = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_image . x_last = ( short ) ReadBlobMSBShort ( image ) ; //<S2SV> pdb_image . y_last = ( short ) ReadBlobMSBShort ( image ) ; //<S2SV> pdb_image . reserved_2 = ReadBlobMSBLong ( image ) ; //<S2SV> pdb_image . x_anchor = ReadBlobMSBShort ( image ) ; //<S2SV> pdb_image . y_anchor = ReadBlobMSBShort ( image ) ; //<S2SV> pdb_image . width = ( short ) ReadBlobMSBShort ( image ) ; //<S2SV> pdb_image . height = ( short ) ReadBlobMSBShort ( image ) ; //<S2SV> image -> columns = ( size_t ) pdb_image . width ; //<S2SV> image -> rows = ( size_t ) pdb_image . height ; //<S2SV> image -> depth = 8 ; //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> bits_per_pixel = pdb_image . type == 0 ? 2UL : pdb_image . type == 2 ? 4UL : 1UL ; //<S2SV> one = 1 ; //<S2SV> if ( AcquireImageColormap ( image , one << bits_per_pixel ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; //<S2SV> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * //<S2SV> sizeof ( * pixels ) ) ; //<S2SV> if ( pixels == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> switch ( pdb_image . version & 0x07 ) //<S2SV> { //<S2SV> case 0 : //<S2SV> { //<S2SV> image -> compression = NoCompression ; //<S2SV> count = ( ssize_t ) ReadBlob ( image , packets * image -> rows , pixels ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 1 : //<S2SV> { //<S2SV> image -> compression = RLECompression ; //<S2SV> if ( ! DecodeImage ( image , pixels , packets * image -> rows ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "RLEDecoderError" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "UnrecognizedImageCompressionType" ) ; //<S2SV> } //<S2SV> p = pixels ; //<S2SV> switch ( bits_per_pixel ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> int //<S2SV> bit ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> index = ( IndexPacket ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; //<S2SV> SetPixelIndex ( indexes + x + bit , index ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 6 ) & 0x03 ) ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 4 ) & 0x03 ) ) ; //<S2SV> SetPixelIndex ( indexes + x + 1 , index ) ; //<S2SV> index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 2 ) & 0x03 ) ) ; //<S2SV> SetPixelIndex ( indexes + x + 2 , index ) ; //<S2SV> index = ConstrainColormapIndex ( image , 3UL - ( ( * p ) & 0x03 ) ) ; //<S2SV> SetPixelIndex ( indexes + x + 3 , index ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , 15UL - ( ( * p >> 4 ) & 0x0f ) ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> index = ConstrainColormapIndex ( image , 15UL - ( ( * p ) & 0x0f ) ) ; //<S2SV> SetPixelIndex ( indexes + x + 1 , index ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> if ( pdb_info . number_records > 1 ) //<S2SV> { //<S2SV> char //<S2SV> * comment ; //<S2SV> int //<S2SV> c ; //<S2SV> register char //<S2SV> * p ; //<S2SV> size_t //<S2SV> length ; //<S2SV> num_pad_bytes = ( size_t ) ( comment_offset - TellBlob ( image ) ) ; //<S2SV> while ( num_pad_bytes -- ) ReadBlobByte ( image ) ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> length = MaxTextExtent ; //<S2SV> comment = AcquireString ( ( char * ) NULL ) ; //<S2SV> for ( p = comment ; c != EOF ; p ++ ) //<S2SV> { //<S2SV> if ( ( size_t ) ( p - comment + MaxTextExtent ) >= length ) //<S2SV> { //<S2SV> * p = '\\0' ; //<S2SV> length <<= 1 ; //<S2SV> length += MaxTextExtent ; //<S2SV> comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , //<S2SV> sizeof ( * comment ) ) ; //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> break ; //<S2SV> p = comment + strlen ( comment ) ; //<S2SV> } //<S2SV> * p = c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> * p = '\\0' ; //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) SetImageProperty ( image , "comment" , comment ) ; //<S2SV> comment = DestroyString ( comment ) ; //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 