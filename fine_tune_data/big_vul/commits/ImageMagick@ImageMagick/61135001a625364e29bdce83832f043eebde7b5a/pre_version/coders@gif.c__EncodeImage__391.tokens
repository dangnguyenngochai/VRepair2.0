static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , //<S2SV> const size_t data_size , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) //<S2SV> # define MaxHashTable 5003 //<S2SV> # define MaxGIFBits 12UL //<S2SV> # define MaxGIFTable ( 1UL << MaxGIFBits ) //<S2SV> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } //<S2SV> Quantum //<S2SV> index ; //<S2SV> short //<S2SV> * hash_code , //<S2SV> * hash_prefix , //<S2SV> waiting_code ; //<S2SV> size_t //<S2SV> bits , //<S2SV> clear_code , //<S2SV> datum , //<S2SV> end_of_information_code , //<S2SV> free_code , //<S2SV> length , //<S2SV> max_code , //<S2SV> next_pixel , //<S2SV> number_bits , //<S2SV> one , //<S2SV> pass ; //<S2SV> ssize_t //<S2SV> displacement , //<S2SV> offset , //<S2SV> k , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * packet , //<S2SV> * hash_suffix ; //<S2SV> assert ( image != ( Image * ) NULL ) ; //<S2SV> one = 1 ; //<S2SV> packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; //<S2SV> hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; //<S2SV> hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; //<S2SV> hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , //<S2SV> sizeof ( * hash_suffix ) ) ; //<S2SV> if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || //<S2SV> ( hash_prefix == ( short * ) NULL ) || //<S2SV> ( hash_suffix == ( unsigned char * ) NULL ) ) //<S2SV> { //<S2SV> if ( packet != ( unsigned char * ) NULL ) //<S2SV> packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; //<S2SV> if ( hash_code != ( short * ) NULL ) //<S2SV> hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; //<S2SV> if ( hash_prefix != ( short * ) NULL ) //<S2SV> hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; //<S2SV> if ( hash_suffix != ( unsigned char * ) NULL ) //<S2SV> hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; //<S2SV> return ( MagickFalse ) ; //<S2SV> } //<S2SV> ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; //<S2SV> ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; //<S2SV> ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; //<S2SV> ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; //<S2SV> number_bits = data_size ; //<S2SV> max_code = MaxCode ( number_bits ) ; //<S2SV> clear_code = ( ( short ) one << ( data_size - 1 ) ) ; //<S2SV> end_of_information_code = clear_code + 1 ; //<S2SV> free_code = clear_code + 2 ; //<S2SV> length = 0 ; //<S2SV> datum = 0 ; //<S2SV> bits = 0 ; //<S2SV> GIFOutputCode ( clear_code ) ; //<S2SV> offset = 0 ; //<S2SV> pass = 0 ; //<S2SV> waiting_code = 0 ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> register const Quantum //<S2SV> * magick_restrict p ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; //<S2SV> if ( p == ( const Quantum * ) NULL ) //<S2SV> break ; //<S2SV> if ( y == 0 ) //<S2SV> { //<S2SV> waiting_code = ( short ) GetPixelIndex ( image , p ) ; //<S2SV> p += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; //<S2SV> p += GetPixelChannels ( image ) ; //<S2SV> k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; //<S2SV> if ( k >= MaxHashTable ) //<S2SV> k -= MaxHashTable ; //<S2SV> next_pixel = MagickFalse ; //<S2SV> displacement = 1 ; //<S2SV> if ( hash_code [ k ] > 0 ) //<S2SV> { //<S2SV> if ( ( hash_prefix [ k ] == waiting_code ) && //<S2SV> ( hash_suffix [ k ] == ( unsigned char ) index ) ) //<S2SV> { //<S2SV> waiting_code = hash_code [ k ] ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( k != 0 ) //<S2SV> displacement = MaxHashTable - k ; //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> k -= displacement ; //<S2SV> if ( k < 0 ) //<S2SV> k += MaxHashTable ; //<S2SV> if ( hash_code [ k ] == 0 ) //<S2SV> break ; //<S2SV> if ( ( hash_prefix [ k ] == waiting_code ) && //<S2SV> ( hash_suffix [ k ] == ( unsigned char ) index ) ) //<S2SV> { //<S2SV> waiting_code = hash_code [ k ] ; //<S2SV> next_pixel = MagickTrue ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( next_pixel != MagickFalse ) //<S2SV> continue ; //<S2SV> } //<S2SV> GIFOutputCode ( waiting_code ) ; //<S2SV> if ( free_code < MaxGIFTable ) //<S2SV> { //<S2SV> hash_code [ k ] = ( short ) free_code ++ ; //<S2SV> hash_prefix [ k ] = waiting_code ; //<S2SV> hash_suffix [ k ] = ( unsigned char ) index ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> for ( k = 0 ; k < MaxHashTable ; k ++ ) //<S2SV> hash_code [ k ] = 0 ; //<S2SV> free_code = clear_code + 2 ; //<S2SV> GIFOutputCode ( clear_code ) ; //<S2SV> number_bits = data_size ; //<S2SV> max_code = MaxCode ( number_bits ) ; //<S2SV> } //<S2SV> waiting_code = ( short ) index ; //<S2SV> } //<S2SV> if ( image_info -> interlace == NoInterlace ) //<S2SV> offset ++ ; //<S2SV> else //<S2SV> switch ( pass ) //<S2SV> { //<S2SV> case 0 : //<S2SV> default : //<S2SV> { //<S2SV> offset += 8 ; //<S2SV> if ( offset >= ( ssize_t ) image -> rows ) //<S2SV> { //<S2SV> pass ++ ; //<S2SV> offset = 4 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 1 : //<S2SV> { //<S2SV> offset += 8 ; //<S2SV> if ( offset >= ( ssize_t ) image -> rows ) //<S2SV> { //<S2SV> pass ++ ; //<S2SV> offset = 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> offset += 4 ; //<S2SV> if ( offset >= ( ssize_t ) image -> rows ) //<S2SV> { //<S2SV> pass ++ ; //<S2SV> offset = 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 3 : //<S2SV> { //<S2SV> offset += 2 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> GIFOutputCode ( waiting_code ) ; //<S2SV> GIFOutputCode ( end_of_information_code ) ; //<S2SV> if ( bits > 0 ) //<S2SV> { //<S2SV> packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; //<S2SV> if ( length >= 254 ) //<S2SV> { //<S2SV> ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; //<S2SV> ( void ) WriteBlob ( image , length , packet ) ; //<S2SV> length = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( length > 0 ) //<S2SV> { //<S2SV> ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; //<S2SV> ( void ) WriteBlob ( image , length , packet ) ; //<S2SV> } //<S2SV> hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; //<S2SV> hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; //<S2SV> hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; //<S2SV> packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; //<S2SV> return ( MagickTrue ) ; //<S2SV> } //<S2SV> 