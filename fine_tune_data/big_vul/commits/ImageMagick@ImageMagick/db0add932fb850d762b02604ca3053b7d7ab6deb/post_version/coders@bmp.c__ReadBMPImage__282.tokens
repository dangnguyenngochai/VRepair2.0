static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> BMPInfo //<S2SV> bmp_info ; //<S2SV> Image //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickOffsetType //<S2SV> offset , //<S2SV> start_position ; //<S2SV> MemoryInfo //<S2SV> * pixel_info ; //<S2SV> Quantum //<S2SV> index ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bit , //<S2SV> bytes_per_line , //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> magick [ 12 ] , //<S2SV> * pixels ; //<S2SV> unsigned int //<S2SV> blue , //<S2SV> green , //<S2SV> offset_bits , //<S2SV> red ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; //<S2SV> bmp_info . ba_offset = 0 ; //<S2SV> start_position = 0 ; //<S2SV> offset_bits = 0 ; //<S2SV> count = ReadBlob ( image , 2 , magick ) ; //<S2SV> if ( count != 2 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> do //<S2SV> { //<S2SV> PixelInfo //<S2SV> quantum_bits ; //<S2SV> PixelPacket //<S2SV> shift ; //<S2SV> start_position = TellBlob ( image ) - 2 ; //<S2SV> bmp_info . ba_offset = 0 ; //<S2SV> while ( LocaleNCompare ( ( char * ) magick , "BA" , 2 ) == 0 ) //<S2SV> { //<S2SV> bmp_info . file_size = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; //<S2SV> count = ReadBlob ( image , 2 , magick ) ; //<S2SV> if ( count != 2 ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c" , //<S2SV> magick [ 0 ] , magick [ 1 ] ) ; //<S2SV> if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , "BM" , 2 ) != 0 ) && //<S2SV> ( LocaleNCompare ( ( char * ) magick , "CI" , 2 ) != 0 ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> bmp_info . file_size = ReadBlobLSBLong ( image ) ; //<S2SV> ( void ) ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . size = ReadBlobLSBLong ( image ) ; //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u" , //<S2SV> bmp_info . size ) ; //<S2SV> if ( bmp_info . size == 12 ) //<S2SV> { //<S2SV> ( void ) CopyMagickString ( image -> magick , "BMP2" , MagickPathExtent ) ; //<S2SV> bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; //<S2SV> bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; //<S2SV> bmp_info . planes = ReadBlobLSBShort ( image ) ; //<S2SV> bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; //<S2SV> bmp_info . x_pixels = 0 ; //<S2SV> bmp_info . y_pixels = 0 ; //<S2SV> bmp_info . number_colors = 0 ; //<S2SV> bmp_info . compression = BI_RGB ; //<S2SV> bmp_info . image_size = 0 ; //<S2SV> bmp_info . alpha_mask = 0 ; //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap" ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) //<S2SV> bmp_info . height ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( bmp_info . size < 40 ) //<S2SV> ThrowReaderException ( CorruptImageError , "NonOS2HeaderSizeError" ) ; //<S2SV> bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; //<S2SV> bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; //<S2SV> bmp_info . planes = ReadBlobLSBShort ( image ) ; //<S2SV> bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; //<S2SV> bmp_info . compression = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . image_size = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . number_colors = ReadBlobLSBLong ( image ) ; //<S2SV> if ( ( MagickSizeType ) bmp_info . number_colors > GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> bmp_info . colors_important = ReadBlobLSBLong ( image ) ; //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap" ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g" , ( double ) bmp_info . width , ( double ) //<S2SV> bmp_info . height ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g" , ( double ) bmp_info . bits_per_pixel ) ; //<S2SV> switch ( bmp_info . compression ) //<S2SV> { //<S2SV> case BI_RGB : //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case BI_RLE4 : //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case BI_RLE8 : //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case BI_BITFIELDS : //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case BI_PNG : //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case BI_JPEG : //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)" , bmp_info . compression ) ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u" , bmp_info . number_colors ) ; //<S2SV> } //<S2SV> bmp_info . red_mask = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . green_mask = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; //<S2SV> if ( bmp_info . size > 40 ) //<S2SV> { //<S2SV> double //<S2SV> gamma ; //<S2SV> bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; //<S2SV> bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; //<S2SV> # define BMP_DENOM ( ( double ) 0x40000000 ) //<S2SV> bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; //<S2SV> gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + //<S2SV> bmp_info . red_primary . z ; //<S2SV> gamma = PerceptibleReciprocal ( gamma ) ; //<S2SV> bmp_info . red_primary . x *= gamma ; //<S2SV> bmp_info . red_primary . y *= gamma ; //<S2SV> image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; //<S2SV> image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; //<S2SV> gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + //<S2SV> bmp_info . green_primary . z ; //<S2SV> gamma = PerceptibleReciprocal ( gamma ) ; //<S2SV> bmp_info . green_primary . x *= gamma ; //<S2SV> bmp_info . green_primary . y *= gamma ; //<S2SV> image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; //<S2SV> image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; //<S2SV> gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + //<S2SV> bmp_info . blue_primary . z ; //<S2SV> gamma = PerceptibleReciprocal ( gamma ) ; //<S2SV> bmp_info . blue_primary . x *= gamma ; //<S2SV> bmp_info . blue_primary . y *= gamma ; //<S2SV> image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; //<S2SV> image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; //<S2SV> bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; //<S2SV> bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; //<S2SV> bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; //<S2SV> image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + //<S2SV> bmp_info . gamma_scale . z ) / 3.0 ; //<S2SV> } //<S2SV> else //<S2SV> ( void ) CopyMagickString ( image -> magick , "BMP3" , MagickPathExtent ) ; //<S2SV> if ( bmp_info . size > 108 ) //<S2SV> { //<S2SV> size_t //<S2SV> intent ; //<S2SV> intent = ReadBlobLSBLong ( image ) ; //<S2SV> switch ( ( int ) intent ) //<S2SV> { //<S2SV> case LCS_GM_BUSINESS : //<S2SV> { //<S2SV> image -> rendering_intent = SaturationIntent ; //<S2SV> break ; //<S2SV> } //<S2SV> case LCS_GM_GRAPHICS : //<S2SV> { //<S2SV> image -> rendering_intent = RelativeIntent ; //<S2SV> break ; //<S2SV> } //<S2SV> case LCS_GM_IMAGES : //<S2SV> { //<S2SV> image -> rendering_intent = PerceptualIntent ; //<S2SV> break ; //<S2SV> } //<S2SV> case LCS_GM_ABS_COLORIMETRIC : //<S2SV> { //<S2SV> image -> rendering_intent = AbsoluteIntent ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) ReadBlobLSBLong ( image ) ; //<S2SV> ( void ) ReadBlobLSBLong ( image ) ; //<S2SV> ( void ) ReadBlobLSBLong ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) //<S2SV> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , //<S2SV> "LengthAndFilesizeDoNotMatch" , "`%s\'" , image -> filename ) ; //<S2SV> else //<S2SV> if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) //<S2SV> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , //<S2SV> CorruptImageWarning , "LengthAndFilesizeDoNotMatch" , "`%s\'" , //<S2SV> image -> filename ) ; //<S2SV> if ( bmp_info . width <= 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; //<S2SV> if ( bmp_info . height == 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; //<S2SV> if ( bmp_info . planes != 1 ) //<S2SV> ThrowReaderException ( CorruptImageError , "StaticPlanesValueNotEqualToOne" ) ; //<S2SV> if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && //<S2SV> ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && //<S2SV> ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; //<S2SV> if ( bmp_info . bits_per_pixel < 16 && //<S2SV> bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedNumberOfColors" ) ; //<S2SV> if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; //<S2SV> if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; //<S2SV> if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; //<S2SV> switch ( bmp_info . compression ) //<S2SV> { //<S2SV> case BI_RGB : //<S2SV> image -> compression = NoCompression ; //<S2SV> break ; //<S2SV> case BI_RLE8 : //<S2SV> case BI_RLE4 : //<S2SV> image -> compression = RLECompression ; //<S2SV> break ; //<S2SV> case BI_BITFIELDS : //<S2SV> break ; //<S2SV> case BI_JPEG : //<S2SV> ThrowReaderException ( CoderError , "JPEGCompressNotSupported" ) ; //<S2SV> case BI_PNG : //<S2SV> ThrowReaderException ( CoderError , "PNGCompressNotSupported" ) ; //<S2SV> default : //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; //<S2SV> } //<S2SV> image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; //<S2SV> image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; //<S2SV> image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; //<S2SV> image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && //<S2SV> ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : //<S2SV> UndefinedPixelTrait ; //<S2SV> if ( bmp_info . bits_per_pixel < 16 ) //<S2SV> { //<S2SV> size_t //<S2SV> one ; //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> colors = bmp_info . number_colors ; //<S2SV> one = 1 ; //<S2SV> if ( image -> colors == 0 ) //<S2SV> image -> colors = one << bmp_info . bits_per_pixel ; //<S2SV> } //<S2SV> image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; //<S2SV> image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; //<S2SV> image -> units = PixelsPerCentimeterResolution ; //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> unsigned char //<S2SV> * bmp_colormap ; //<S2SV> size_t //<S2SV> packet_size ; //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors" , ( double ) image -> colors ) ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) //<S2SV> image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; //<S2SV> if ( bmp_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) //<S2SV> packet_size = 3 ; //<S2SV> else //<S2SV> packet_size = 4 ; //<S2SV> offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> { //<S2SV> bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; //<S2SV> if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) //<S2SV> { //<S2SV> bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> } //<S2SV> p = bmp_colormap ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> if ( packet_size == 4 ) //<S2SV> p ++ ; //<S2SV> } //<S2SV> bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; //<S2SV> } //<S2SV> if ( bmp_info . offset_bits == offset_bits ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> offset_bits = bmp_info . offset_bits ; //<S2SV> offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( bmp_info . compression == BI_RLE4 ) //<S2SV> bmp_info . bits_per_pixel <<= 1 ; //<S2SV> bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; //<S2SV> length = ( size_t ) bytes_per_line * image -> rows ; //<S2SV> if ( ( bmp_info . compression == BI_RGB ) || //<S2SV> ( bmp_info . compression == BI_BITFIELDS ) ) //<S2SV> { //<S2SV> if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> pixel_info = AcquireVirtualMemory ( image -> rows , //<S2SV> MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; //<S2SV> if ( pixel_info == ( MemoryInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)" , ( double ) length ) ; //<S2SV> count = ReadBlob ( image , length , pixels ) ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pixel_info = AcquireVirtualMemory ( image -> rows , //<S2SV> MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; //<S2SV> if ( pixel_info == ( MemoryInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; //<S2SV> status = DecodeImage ( image , bmp_info . compression , pixels , //<S2SV> image -> columns * image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "UnableToRunlengthDecodeImage" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( bmp_info . compression == BI_RGB ) //<S2SV> { //<S2SV> if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && //<S2SV> ( bmp_info . bits_per_pixel == 32 ) ) //<S2SV> { //<S2SV> bytes_per_line = 4 * ( image -> columns ) ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( * ( p + 3 ) != 0 ) //<S2SV> { //<S2SV> image -> alpha_trait = BlendPixelTrait ; //<S2SV> y = - 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> p += 4 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? //<S2SV> 0xff000000U : 0U ; //<S2SV> bmp_info . red_mask = 0x00ff0000U ; //<S2SV> bmp_info . green_mask = 0x0000ff00U ; //<S2SV> bmp_info . blue_mask = 0x000000ffU ; //<S2SV> if ( bmp_info . bits_per_pixel == 16 ) //<S2SV> { //<S2SV> bmp_info . red_mask = 0x00007c00U ; //<S2SV> bmp_info . green_mask = 0x000003e0U ; //<S2SV> bmp_info . blue_mask = 0x0000001fU ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; //<S2SV> ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; //<S2SV> if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) //<S2SV> { //<S2SV> register unsigned int //<S2SV> sample ; //<S2SV> if ( bmp_info . red_mask != 0 ) //<S2SV> while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) //<S2SV> { //<S2SV> shift . red ++ ; //<S2SV> if ( shift . red >= 32U ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( bmp_info . green_mask != 0 ) //<S2SV> while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) //<S2SV> { //<S2SV> shift . green ++ ; //<S2SV> if ( shift . green >= 32U ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( bmp_info . blue_mask != 0 ) //<S2SV> while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) //<S2SV> { //<S2SV> shift . blue ++ ; //<S2SV> if ( shift . blue >= 32U ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( bmp_info . alpha_mask != 0 ) //<S2SV> while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) //<S2SV> { //<S2SV> shift . alpha ++ ; //<S2SV> if ( shift . alpha >= 32U ) //<S2SV> break ; //<S2SV> } //<S2SV> sample = shift . red ; //<S2SV> while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) //<S2SV> { //<S2SV> sample ++ ; //<S2SV> if ( sample >= 32U ) //<S2SV> break ; //<S2SV> } //<S2SV> quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; //<S2SV> sample = shift . green ; //<S2SV> while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) //<S2SV> { //<S2SV> sample ++ ; //<S2SV> if ( sample >= 32U ) //<S2SV> break ; //<S2SV> } //<S2SV> quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; //<S2SV> sample = shift . blue ; //<S2SV> while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) //<S2SV> { //<S2SV> sample ++ ; //<S2SV> if ( sample >= 32U ) //<S2SV> break ; //<S2SV> } //<S2SV> quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; //<S2SV> sample = shift . alpha ; //<S2SV> while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) //<S2SV> { //<S2SV> sample ++ ; //<S2SV> if ( sample >= 32U ) //<S2SV> break ; //<S2SV> } //<S2SV> quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; //<S2SV> } //<S2SV> switch ( bmp_info . bits_per_pixel ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) //<S2SV> { //<S2SV> index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> ( image -> rows - y ) , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SyncImage ( image , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) //<S2SV> { //<S2SV> ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , //<S2SV> exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 2 ) != 0 ) //<S2SV> { //<S2SV> ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , //<S2SV> exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> p ++ ; //<S2SV> x ++ ; //<S2SV> } //<S2SV> if ( x < ( ssize_t ) image -> columns ) //<S2SV> break ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> ( image -> rows - y ) , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SyncImage ( image , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 8 : //<S2SV> { //<S2SV> if ( ( bmp_info . compression == BI_RLE8 ) || //<S2SV> ( bmp_info . compression == BI_RLE4 ) ) //<S2SV> bytes_per_line = image -> columns ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) //<S2SV> { //<S2SV> ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> ( image -> rows - y ) , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SyncImage ( image , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 16 : //<S2SV> { //<S2SV> unsigned int //<S2SV> alpha , //<S2SV> pixel ; //<S2SV> if ( ( bmp_info . compression != BI_RGB ) && //<S2SV> ( bmp_info . compression != BI_BITFIELDS ) ) //<S2SV> { //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "UnrecognizedImageCompression" ) ; //<S2SV> } //<S2SV> bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; //<S2SV> image -> storage_class = DirectClass ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> pixel = ( unsigned int ) ( * p ++ ) ; //<S2SV> pixel |= ( * p ++ ) << 8 ; //<S2SV> red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; //<S2SV> if ( quantum_bits . red == 5 ) //<S2SV> red |= ( ( red & 0xe000 ) >> 5 ) ; //<S2SV> if ( quantum_bits . red <= 8 ) //<S2SV> red |= ( ( red & 0xff00 ) >> 8 ) ; //<S2SV> green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; //<S2SV> if ( quantum_bits . green == 5 ) //<S2SV> green |= ( ( green & 0xe000 ) >> 5 ) ; //<S2SV> if ( quantum_bits . green == 6 ) //<S2SV> green |= ( ( green & 0xc000 ) >> 6 ) ; //<S2SV> if ( quantum_bits . green <= 8 ) //<S2SV> green |= ( ( green & 0xff00 ) >> 8 ) ; //<S2SV> blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; //<S2SV> if ( quantum_bits . blue == 5 ) //<S2SV> blue |= ( ( blue & 0xe000 ) >> 5 ) ; //<S2SV> if ( quantum_bits . blue <= 8 ) //<S2SV> blue |= ( ( blue & 0xff00 ) >> 8 ) ; //<S2SV> SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; //<S2SV> SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; //<S2SV> SetPixelAlpha ( image , OpaqueAlpha , q ) ; //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> { //<S2SV> alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; //<S2SV> if ( quantum_bits . alpha <= 8 ) //<S2SV> alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; //<S2SV> SetPixelAlpha ( image , ScaleShortToQuantum ( //<S2SV> ( unsigned short ) alpha ) , q ) ; //<S2SV> } //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> ( image -> rows - y ) , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 24 : //<S2SV> { //<S2SV> bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelAlpha ( image , OpaqueAlpha , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> ( image -> rows - y ) , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 32 : //<S2SV> { //<S2SV> if ( ( bmp_info . compression != BI_RGB ) && //<S2SV> ( bmp_info . compression != BI_BITFIELDS ) ) //<S2SV> { //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "UnrecognizedImageCompression" ) ; //<S2SV> } //<S2SV> bytes_per_line = 4 * ( image -> columns ) ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> unsigned int //<S2SV> alpha , //<S2SV> pixel ; //<S2SV> p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> pixel = ( unsigned int ) ( * p ++ ) ; //<S2SV> pixel |= ( ( unsigned int ) * p ++ << 8 ) ; //<S2SV> pixel |= ( ( unsigned int ) * p ++ << 16 ) ; //<S2SV> pixel |= ( ( unsigned int ) * p ++ << 24 ) ; //<S2SV> red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; //<S2SV> if ( quantum_bits . red == 8 ) //<S2SV> red |= ( red >> 8 ) ; //<S2SV> green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; //<S2SV> if ( quantum_bits . green == 8 ) //<S2SV> green |= ( green >> 8 ) ; //<S2SV> blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; //<S2SV> if ( quantum_bits . blue == 8 ) //<S2SV> blue |= ( blue >> 8 ) ; //<S2SV> SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; //<S2SV> SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; //<S2SV> SetPixelAlpha ( image , OpaqueAlpha , q ) ; //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> { //<S2SV> alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; //<S2SV> if ( quantum_bits . alpha == 8 ) //<S2SV> alpha |= ( alpha >> 8 ) ; //<S2SV> SetPixelAlpha ( image , ScaleShortToQuantum ( //<S2SV> ( unsigned short ) alpha ) , q ) ; //<S2SV> } //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> ( image -> rows - y ) , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> } //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> if ( y > 0 ) //<S2SV> break ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( bmp_info . height < 0 ) //<S2SV> { //<S2SV> Image //<S2SV> * flipped_image ; //<S2SV> flipped_image = FlipImage ( image , exception ) ; //<S2SV> if ( flipped_image != ( Image * ) NULL ) //<S2SV> { //<S2SV> DuplicateBlob ( flipped_image , image ) ; //<S2SV> ReplaceImageInList ( & image , flipped_image ) ; //<S2SV> image = flipped_image ; //<S2SV> } //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> offset = ( MagickOffsetType ) bmp_info . ba_offset ; //<S2SV> if ( offset != 0 ) //<S2SV> if ( ( offset < TellBlob ( image ) ) || //<S2SV> ( SeekBlob ( image , offset , SEEK_SET ) != offset ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> * magick = '\\0' ; //<S2SV> count = ReadBlob ( image , 2 , magick ) ; //<S2SV> if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 