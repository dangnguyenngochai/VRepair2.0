static MagickBooleanType ReadDXT3 ( Image * image , DDSInfo * dds_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> DDSColors //<S2SV> colors ; //<S2SV> ssize_t //<S2SV> j , //<S2SV> y ; //<S2SV> PixelPacket //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> unsigned char //<S2SV> alpha ; //<S2SV> size_t //<S2SV> a0 , //<S2SV> a1 , //<S2SV> bits , //<S2SV> code ; //<S2SV> unsigned short //<S2SV> c0 , //<S2SV> c1 ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , //<S2SV> Min ( 4 , dds_info -> height - y ) , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> return MagickFalse ; //<S2SV> a0 = ReadBlobLSBLong ( image ) ; //<S2SV> a1 = ReadBlobLSBLong ( image ) ; //<S2SV> c0 = ReadBlobLSBShort ( image ) ; //<S2SV> c1 = ReadBlobLSBShort ( image ) ; //<S2SV> bits = ReadBlobLSBLong ( image ) ; //<S2SV> CalculateColors ( c0 , c1 , & colors , MagickTrue ) ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> { //<S2SV> if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) //<S2SV> { //<S2SV> code = ( bits >> ( ( 4 * j + i ) * 2 ) ) & 0x3 ; //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; //<S2SV> if ( j < 2 ) //<S2SV> alpha = 17U * ( unsigned char ) ( ( a0 >> ( 4 * ( 4 * j + i ) ) ) & 0xf ) ; //<S2SV> else //<S2SV> alpha = 17U * ( unsigned char ) ( ( a1 >> ( 4 * ( 4 * ( j - 2 ) + i ) ) ) & 0xf ) ; //<S2SV> SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> alpha ) ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> return MagickFalse ; //<S2SV> } //<S2SV> } //<S2SV> SkipDXTMipmaps ( image , dds_info , 16 ) ; //<S2SV> return MagickTrue ; //<S2SV> } //<S2SV> 