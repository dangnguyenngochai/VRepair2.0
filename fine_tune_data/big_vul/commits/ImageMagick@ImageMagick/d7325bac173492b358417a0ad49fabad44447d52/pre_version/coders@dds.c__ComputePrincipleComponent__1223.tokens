static void ComputePrincipleComponent ( const float * covariance , //<S2SV> DDSVector3 * principle ) //<S2SV> { //<S2SV> DDSVector4 //<S2SV> row0 , //<S2SV> row1 , //<S2SV> row2 , //<S2SV> v ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> row0 . x = covariance [ 0 ] ; //<S2SV> row0 . y = covariance [ 1 ] ; //<S2SV> row0 . z = covariance [ 2 ] ; //<S2SV> row0 . w = 0.0f ; //<S2SV> row1 . x = covariance [ 1 ] ; //<S2SV> row1 . y = covariance [ 3 ] ; //<S2SV> row1 . z = covariance [ 4 ] ; //<S2SV> row1 . w = 0.0f ; //<S2SV> row2 . x = covariance [ 2 ] ; //<S2SV> row2 . y = covariance [ 4 ] ; //<S2SV> row2 . z = covariance [ 5 ] ; //<S2SV> row2 . w = 0.0f ; //<S2SV> VectorInit ( v , 1.0f ) ; //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> DDSVector4 //<S2SV> w ; //<S2SV> float //<S2SV> a ; //<S2SV> w . x = row0 . x * v . x ; //<S2SV> w . y = row0 . y * v . x ; //<S2SV> w . z = row0 . z * v . x ; //<S2SV> w . w = row0 . w * v . x ; //<S2SV> w . x = ( row1 . x * v . y ) + w . x ; //<S2SV> w . y = ( row1 . y * v . y ) + w . y ; //<S2SV> w . z = ( row1 . z * v . y ) + w . z ; //<S2SV> w . w = ( row1 . w * v . y ) + w . w ; //<S2SV> w . x = ( row2 . x * v . z ) + w . x ; //<S2SV> w . y = ( row2 . y * v . z ) + w . y ; //<S2SV> w . z = ( row2 . z * v . z ) + w . z ; //<S2SV> w . w = ( row2 . w * v . z ) + w . w ; //<S2SV> a = 1.0f / MaxF ( w . x , MaxF ( w . y , w . z ) ) ; //<S2SV> v . x = w . x * a ; //<S2SV> v . y = w . y * a ; //<S2SV> v . z = w . z * a ; //<S2SV> v . w = w . w * a ; //<S2SV> } //<S2SV> VectorCopy43 ( v , principle ) ; //<S2SV> } //<S2SV> 