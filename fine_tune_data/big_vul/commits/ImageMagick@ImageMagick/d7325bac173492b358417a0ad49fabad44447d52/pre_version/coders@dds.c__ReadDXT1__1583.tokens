static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> DDSColors //<S2SV> colors ; //<S2SV> PixelPacket //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> size_t //<S2SV> bits ; //<S2SV> ssize_t //<S2SV> j , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> code ; //<S2SV> unsigned short //<S2SV> c0 , //<S2SV> c1 ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , //<S2SV> Min ( 4 , dds_info -> height - y ) , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> return MagickFalse ; //<S2SV> c0 = ReadBlobLSBShort ( image ) ; //<S2SV> c1 = ReadBlobLSBShort ( image ) ; //<S2SV> bits = ReadBlobLSBLong ( image ) ; //<S2SV> CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> { //<S2SV> if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) //<S2SV> { //<S2SV> code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; //<S2SV> SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; //<S2SV> if ( colors . a [ code ] && image -> matte == MagickFalse ) //<S2SV> image -> matte = MagickTrue ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> return MagickFalse ; //<S2SV> } //<S2SV> } //<S2SV> SkipDXTMipmaps ( image , dds_info , 8 ) ; //<S2SV> return MagickTrue ; //<S2SV> } //<S2SV> 