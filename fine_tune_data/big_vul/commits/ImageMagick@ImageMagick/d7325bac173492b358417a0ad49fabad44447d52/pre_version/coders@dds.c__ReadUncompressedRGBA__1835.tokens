static MagickBooleanType ReadUncompressedRGBA ( Image * image , DDSInfo * dds_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> PixelPacket //<S2SV> * q ; //<S2SV> ssize_t //<S2SV> alphaBits , //<S2SV> x , //<S2SV> y ; //<S2SV> unsigned short //<S2SV> color ; //<S2SV> alphaBits = 0 ; //<S2SV> if ( dds_info -> pixelformat . rgb_bitcount == 16 ) //<S2SV> { //<S2SV> if ( IsBitMask ( dds_info -> pixelformat , 0x7c00 , 0x03e0 , 0x001f , 0x8000 ) ) //<S2SV> alphaBits = 1 ; //<S2SV> else if ( IsBitMask ( dds_info -> pixelformat , 0x00ff , 0x00ff , 0x00ff , 0xff00 ) ) //<S2SV> { //<S2SV> alphaBits = 2 ; //<S2SV> ( void ) SetImageType ( image , GrayscaleMatteType ) ; //<S2SV> } //<S2SV> else if ( IsBitMask ( dds_info -> pixelformat , 0x0f00 , 0x00f0 , 0x000f , 0xf000 ) ) //<S2SV> alphaBits = 4 ; //<S2SV> else //<S2SV> ThrowBinaryException ( CorruptImageError , "ImageTypeNotSupported" , //<S2SV> image -> filename ) ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , dds_info -> width , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> return MagickFalse ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x ++ ) //<S2SV> { //<S2SV> if ( dds_info -> pixelformat . rgb_bitcount == 16 ) //<S2SV> { //<S2SV> color = ReadBlobShort ( image ) ; //<S2SV> if ( alphaBits == 1 ) //<S2SV> { //<S2SV> SetPixelAlpha ( q , ( color & ( 1 << 15 ) ) ? QuantumRange : 0 ) ; //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ( ( ( ( unsigned short ) ( color << 1 ) >> 11 ) / 31.0 ) * 255 ) ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ( ( ( ( unsigned short ) ( color << 6 ) >> 11 ) / 31.0 ) * 255 ) ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ( ( ( ( unsigned short ) ( color << 11 ) >> 11 ) / 31.0 ) * 255 ) ) ) ; //<S2SV> } //<S2SV> else if ( alphaBits == 2 ) //<S2SV> { //<S2SV> SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ( color >> 8 ) ) ) ; //<S2SV> SetPixelGray ( q , ScaleCharToQuantum ( ( unsigned char ) color ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ( ( ( color >> 12 ) / 15.0 ) * 255 ) ) ) ; //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ( ( ( ( unsigned short ) ( color << 4 ) >> 12 ) / 15.0 ) * 255 ) ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ( ( ( ( unsigned short ) ( color << 8 ) >> 12 ) / 15.0 ) * 255 ) ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ( ( ( ( unsigned short ) ( color << 12 ) >> 12 ) / 15.0 ) * 255 ) ) ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ) ; //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ) ; //<S2SV> SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ) ; //<S2SV> } //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> return MagickFalse ; //<S2SV> } //<S2SV> SkipRGBMipmaps ( image , dds_info , 4 ) ; //<S2SV> return MagickTrue ; //<S2SV> } //<S2SV> 