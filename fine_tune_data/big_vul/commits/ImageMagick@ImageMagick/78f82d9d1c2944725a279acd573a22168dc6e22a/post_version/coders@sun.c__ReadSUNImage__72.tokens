static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define RMT_EQUAL_RGB 1 //<S2SV> # define RMT_NONE 0 //<S2SV> # define RMT_RAW 2 //<S2SV> # define RT_STANDARD 1 //<S2SV> # define RT_ENCODED 2 //<S2SV> # define RT_FORMAT_RGB 3 //<S2SV> typedef struct _SUNInfo //<S2SV> { //<S2SV> unsigned int //<S2SV> magic , //<S2SV> width , //<S2SV> height , //<S2SV> depth , //<S2SV> length , //<S2SV> type , //<S2SV> maptype , //<S2SV> maplength ; //<S2SV> } SUNInfo ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> bit ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickSizeType //<S2SV> number_pixels ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bytes_per_line , //<S2SV> extent , //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> SUNInfo //<S2SV> sun_info ; //<S2SV> unsigned char //<S2SV> * sun_data , //<S2SV> * sun_pixels ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; //<S2SV> sun_info . magic = ReadBlobMSBLong ( image ) ; //<S2SV> do //<S2SV> { //<S2SV> if ( sun_info . magic != 0x59a66a95 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> sun_info . width = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . height = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . depth = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . length = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . type = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . maptype = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . maplength = ReadBlobMSBLong ( image ) ; //<S2SV> extent = sun_info . height * sun_info . width ; //<S2SV> if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && //<S2SV> ( sun_info . type != RT_FORMAT_RGB ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && //<S2SV> ( sun_info . maptype != RMT_RAW ) ) //<S2SV> ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; //<S2SV> image -> columns = sun_info . width ; //<S2SV> image -> rows = sun_info . height ; //<S2SV> image -> depth = sun_info . depth <= 8 ? sun_info . depth : //<S2SV> MAGICKCORE_QUANTUM_DEPTH ; //<S2SV> if ( sun_info . depth < 24 ) //<S2SV> { //<S2SV> size_t //<S2SV> one ; //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> colors = sun_info . maplength ; //<S2SV> one = 1 ; //<S2SV> if ( sun_info . maptype == RMT_NONE ) //<S2SV> image -> colors = one << sun_info . depth ; //<S2SV> if ( sun_info . maptype == RMT_EQUAL_RGB ) //<S2SV> image -> colors = sun_info . maplength / 3 ; //<S2SV> } //<S2SV> switch ( sun_info . maptype ) //<S2SV> { //<S2SV> case RMT_NONE : //<S2SV> { //<S2SV> if ( sun_info . depth < 24 ) //<S2SV> { //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case RMT_EQUAL_RGB : //<S2SV> { //<S2SV> unsigned char //<S2SV> * sun_colormap ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , //<S2SV> sizeof ( * sun_colormap ) ) ; //<S2SV> if ( sun_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , image -> colors , sun_colormap ) ; //<S2SV> if ( count != ( ssize_t ) image -> colors ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( //<S2SV> sun_colormap [ i ] ) ; //<S2SV> count = ReadBlob ( image , image -> colors , sun_colormap ) ; //<S2SV> if ( count != ( ssize_t ) image -> colors ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( //<S2SV> sun_colormap [ i ] ) ; //<S2SV> count = ReadBlob ( image , image -> colors , sun_colormap ) ; //<S2SV> if ( count != ( ssize_t ) image -> colors ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( //<S2SV> sun_colormap [ i ] ) ; //<S2SV> sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case RMT_RAW : //<S2SV> { //<S2SV> unsigned char //<S2SV> * sun_colormap ; //<S2SV> sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , //<S2SV> sizeof ( * sun_colormap ) ) ; //<S2SV> if ( sun_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; //<S2SV> if ( count != ( ssize_t ) sun_info . maplength ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; //<S2SV> } //<S2SV> image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : //<S2SV> UndefinedPixelTrait ; //<S2SV> image -> columns = sun_info . width ; //<S2SV> image -> rows = sun_info . height ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != //<S2SV> sun_info . length || ! sun_info . length ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; //<S2SV> if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && //<S2SV> ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> bytes_per_line = sun_info . width * sun_info . depth ; //<S2SV> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( //<S2SV> sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; //<S2SV> if ( sun_data == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; //<S2SV> if ( count != ( ssize_t ) sun_info . length ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> sun_pixels = sun_data ; //<S2SV> bytes_per_line = 0 ; //<S2SV> if ( sun_info . type == RT_ENCODED ) //<S2SV> { //<S2SV> size_t //<S2SV> height ; //<S2SV> height = sun_info . height ; //<S2SV> if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || //<S2SV> ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> bytes_per_line += 15 ; //<S2SV> bytes_per_line <<= 1 ; //<S2SV> if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> bytes_per_line >>= 4 ; //<S2SV> sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , //<S2SV> bytes_per_line * sizeof ( * sun_pixels ) ) ; //<S2SV> if ( sun_pixels == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * //<S2SV> height ) ; //<S2SV> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; //<S2SV> } //<S2SV> p = sun_pixels ; //<S2SV> if ( sun_info . depth == 1 ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 7 ; bit >= 0 ; bit -- ) //<S2SV> { //<S2SV> SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , //<S2SV> q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) //<S2SV> { //<S2SV> SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : //<S2SV> 0x01 ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) //<S2SV> p ++ ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> if ( bytes_per_line == 0 ) //<S2SV> bytes_per_line = image -> columns ; //<S2SV> length = image -> rows * ( image -> columns + image -> columns % 2 ) ; //<S2SV> if ( ( ( sun_info . type == RT_ENCODED ) && //<S2SV> ( length > ( bytes_per_line * image -> rows ) ) ) || //<S2SV> ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( image , * p ++ , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( ( image -> columns % 2 ) != 0 ) //<S2SV> p ++ ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> size_t //<S2SV> bytes_per_pixel ; //<S2SV> bytes_per_pixel = 3 ; //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> bytes_per_pixel ++ ; //<S2SV> if ( bytes_per_line == 0 ) //<S2SV> bytes_per_line = bytes_per_pixel * image -> columns ; //<S2SV> length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; //<S2SV> if ( ( ( sun_info . type == RT_ENCODED ) && //<S2SV> ( length > ( bytes_per_line * image -> rows ) ) ) || //<S2SV> ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> if ( sun_info . type == RT_STANDARD ) //<S2SV> { //<S2SV> SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> } //<S2SV> if ( image -> colors != 0 ) //<S2SV> { //<S2SV> SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) //<S2SV> GetPixelRed ( image , q ) ] . red ) , q ) ; //<S2SV> SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) //<S2SV> GetPixelGreen ( image , q ) ] . green ) , q ) ; //<S2SV> SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) //<S2SV> GetPixelBlue ( image , q ) ] . blue ) , q ) ; //<S2SV> } //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) //<S2SV> p ++ ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> ( void ) SyncImage ( image , exception ) ; //<S2SV> sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> sun_info . magic = ReadBlobMSBLong ( image ) ; //<S2SV> if ( sun_info . magic == 0x59a66a95 ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( sun_info . magic == 0x59a66a95 ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 