static Image * ReadICONImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> IconFile //<S2SV> icon_file ; //<S2SV> IconInfo //<S2SV> icon_info ; //<S2SV> Image //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bit , //<S2SV> byte , //<S2SV> bytes_per_line , //<S2SV> one , //<S2SV> scanline_pad ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> offset , //<S2SV> y ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; //<S2SV> icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; //<S2SV> icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; //<S2SV> if ( ( icon_file . reserved != 0 ) || //<S2SV> ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || //<S2SV> ( icon_file . count > MaxIcons ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> for ( i = 0 ; i < icon_file . count ; i ++ ) //<S2SV> { //<S2SV> icon_file . directory [ i ] . width = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> icon_file . directory [ i ] . height = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> icon_file . directory [ i ] . colors = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> icon_file . directory [ i ] . reserved = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> icon_file . directory [ i ] . planes = ( unsigned short ) ReadBlobLSBShort ( image ) ; //<S2SV> icon_file . directory [ i ] . bits_per_pixel = ( unsigned short ) //<S2SV> ReadBlobLSBShort ( image ) ; //<S2SV> icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ; //<S2SV> icon_file . directory [ i ] . offset = ReadBlobLSBLong ( image ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> one = 1 ; //<S2SV> for ( i = 0 ; i < icon_file . count ; i ++ ) //<S2SV> { //<S2SV> offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) //<S2SV> icon_file . directory [ i ] . offset , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> icon_info . size = ReadBlobLSBLong ( image ) ; //<S2SV> icon_info . width = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) ) ; //<S2SV> icon_info . height = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) / 2 ) ; //<S2SV> icon_info . planes = ReadBlobLSBShort ( image ) ; //<S2SV> icon_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( ( icon_info . planes == 18505 ) && ( icon_info . bits_per_pixel == 21060 ) ) || //<S2SV> ( icon_info . size == 0x474e5089 ) ) //<S2SV> { //<S2SV> Image //<S2SV> * icon_image ; //<S2SV> ImageInfo //<S2SV> * read_info ; //<S2SV> size_t //<S2SV> length ; //<S2SV> unsigned char //<S2SV> * png ; //<S2SV> length = icon_file . directory [ i ] . size ; //<S2SV> if ( ~ length < 16 ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ; //<S2SV> if ( png == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) CopyMagickMemory ( png , "\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015" , 12 ) ; //<S2SV> png [ 12 ] = ( unsigned char ) icon_info . planes ; //<S2SV> png [ 13 ] = ( unsigned char ) ( icon_info . planes >> 8 ) ; //<S2SV> png [ 14 ] = ( unsigned char ) icon_info . bits_per_pixel ; //<S2SV> png [ 15 ] = ( unsigned char ) ( icon_info . bits_per_pixel >> 8 ) ; //<S2SV> count = ReadBlob ( image , length - 16 , png + 16 ) ; //<S2SV> icon_image = ( Image * ) NULL ; //<S2SV> if ( count > 0 ) //<S2SV> { //<S2SV> read_info = CloneImageInfo ( image_info ) ; //<S2SV> ( void ) CopyMagickString ( read_info -> magick , "PNG" , MagickPathExtent ) ; //<S2SV> icon_image = BlobToImage ( read_info , png , length + 16 , exception ) ; //<S2SV> read_info = DestroyImageInfo ( read_info ) ; //<S2SV> } //<S2SV> png = ( unsigned char * ) RelinquishMagickMemory ( png ) ; //<S2SV> if ( icon_image == ( Image * ) NULL ) //<S2SV> { //<S2SV> if ( count != ( ssize_t ) ( length - 16 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> DestroyBlob ( icon_image ) ; //<S2SV> icon_image -> blob = ReferenceBlob ( image -> blob ) ; //<S2SV> ReplaceImageInList ( & image , icon_image ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( icon_info . bits_per_pixel > 32 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> icon_info . compression = ReadBlobLSBLong ( image ) ; //<S2SV> icon_info . image_size = ReadBlobLSBLong ( image ) ; //<S2SV> icon_info . x_pixels = ReadBlobLSBLong ( image ) ; //<S2SV> icon_info . y_pixels = ReadBlobLSBLong ( image ) ; //<S2SV> icon_info . number_colors = ReadBlobLSBLong ( image ) ; //<S2SV> icon_info . colors_important = ReadBlobLSBLong ( image ) ; //<S2SV> image -> alpha_trait = BlendPixelTrait ; //<S2SV> image -> columns = ( size_t ) icon_file . directory [ i ] . width ; //<S2SV> if ( ( ssize_t ) image -> columns > icon_info . width ) //<S2SV> image -> columns = ( size_t ) icon_info . width ; //<S2SV> if ( image -> columns == 0 ) //<S2SV> image -> columns = 256 ; //<S2SV> image -> rows = ( size_t ) icon_file . directory [ i ] . height ; //<S2SV> if ( ( ssize_t ) image -> rows > icon_info . height ) //<S2SV> image -> rows = ( size_t ) icon_info . height ; //<S2SV> if ( image -> rows == 0 ) //<S2SV> image -> rows = 256 ; //<S2SV> image -> depth = icon_info . bits_per_pixel ; //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> { //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank>scene<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g" , ( double ) i ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank><S2SV_blank>size<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g" , ( double ) icon_info . size ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank><S2SV_blank>width<S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g" , ( double ) icon_file . directory [ i ] . width ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank><S2SV_blank>height<S2SV_blank>=<S2SV_blank>%.20g" , ( double ) icon_file . directory [ i ] . height ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank><S2SV_blank>colors<S2SV_blank>=<S2SV_blank>%.20g" , ( double ) icon_info . number_colors ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank><S2SV_blank>planes<S2SV_blank>=<S2SV_blank>%.20g" , ( double ) icon_info . planes ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank><S2SV_blank>bpp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g" , ( double ) icon_info . bits_per_pixel ) ; //<S2SV> } //<S2SV> if ( ( icon_info . number_colors != 0 ) || ( icon_info . bits_per_pixel <= 16U ) ) //<S2SV> { //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> colors = icon_info . number_colors ; //<S2SV> if ( image -> colors == 0 ) //<S2SV> image -> colors = one << icon_info . bits_per_pixel ; //<S2SV> } //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> unsigned char //<S2SV> * icon_colormap ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == //<S2SV> MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> icon_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) //<S2SV> image -> colors , 4UL * sizeof ( * icon_colormap ) ) ; //<S2SV> if ( icon_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , ( size_t ) ( 4 * image -> colors ) , icon_colormap ) ; //<S2SV> if ( count != ( ssize_t ) ( 4 * image -> colors ) ) //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> p = icon_colormap ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . blue = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . green = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . red = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> icon_colormap = ( unsigned char * ) RelinquishMagickMemory ( icon_colormap ) ; //<S2SV> } //<S2SV> if ( ( image_info -> ping != MagickFalse ) && //<S2SV> ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> bytes_per_line = ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & //<S2SV> ~ 31 ) >> 3 ; //<S2SV> ( void ) bytes_per_line ; //<S2SV> scanline_pad = ( ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) - //<S2SV> ( image -> columns * icon_info . bits_per_pixel ) ) >> 3 ; //<S2SV> switch ( icon_info . bits_per_pixel ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : //<S2SV> 0x00 ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : //<S2SV> 0x00 ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) //<S2SV> { //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> SetPixelIndex ( image , ( ( byte ) & 0xf ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( ( image -> columns % 2 ) != 0 ) //<S2SV> { //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 8 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> SetPixelIndex ( image , byte , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 16 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> byte |= ( size_t ) ( ReadBlobByte ( image ) << 8 ) ; //<S2SV> SetPixelIndex ( image , byte , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 24 : //<S2SV> case 32 : //<S2SV> { //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) , q ) ; //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) , q ) ; //<S2SV> if ( icon_info . bits_per_pixel == 32 ) //<S2SV> SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( icon_info . bits_per_pixel == 24 ) //<S2SV> for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> if ( image_info -> ping == MagickFalse ) //<S2SV> ( void ) SyncImage ( image , exception ) ; //<S2SV> if ( icon_info . bits_per_pixel != 32 ) //<S2SV> { //<S2SV> image -> storage_class = DirectClass ; //<S2SV> for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) //<S2SV> { //<S2SV> q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? //<S2SV> TransparentAlpha : OpaqueAlpha ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) //<S2SV> { //<S2SV> SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? //<S2SV> TransparentAlpha : OpaqueAlpha ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( image -> columns % 32 ) != 0 ) //<S2SV> for ( x = 0 ; x < ( ssize_t ) ( ( 32 - ( image -> columns % 32 ) ) / 8 ) ; x ++ ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( i < ( ssize_t ) ( icon_file . count - 1 ) ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 