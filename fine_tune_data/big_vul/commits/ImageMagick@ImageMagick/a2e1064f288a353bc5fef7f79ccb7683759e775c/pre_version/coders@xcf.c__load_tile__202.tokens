static MagickBooleanType load_tile ( Image * image , Image * tile_image , //<S2SV> XCFDocInfo * inDocInfo , XCFLayerInfo * inLayerInfo , size_t data_length , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> ssize_t //<S2SV> y ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> ssize_t //<S2SV> count ; //<S2SV> unsigned char //<S2SV> * graydata ; //<S2SV> XCFPixelInfo //<S2SV> * xcfdata , //<S2SV> * xcfodata ; //<S2SV> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; //<S2SV> if ( xcfdata == ( XCFPixelInfo * ) NULL ) //<S2SV> ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , //<S2SV> image -> filename ) ; //<S2SV> xcfodata = xcfdata ; //<S2SV> graydata = ( unsigned char * ) xcfdata ; //<S2SV> count = ReadBlob ( image , data_length , ( unsigned char * ) xcfdata ) ; //<S2SV> if ( count != ( ssize_t ) data_length ) //<S2SV> ThrowBinaryException ( CorruptImageError , "NotEnoughPixelData" , //<S2SV> image -> filename ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = GetAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> if ( inDocInfo -> image_type == GIMP_GRAY ) //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelGray ( tile_image , ScaleCharToQuantum ( * graydata ) , q ) ; //<S2SV> SetPixelAlpha ( tile_image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> inLayerInfo -> alpha ) , q ) ; //<S2SV> graydata ++ ; //<S2SV> q += GetPixelChannels ( tile_image ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> if ( inDocInfo -> image_type == GIMP_RGB ) //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( tile_image , ScaleCharToQuantum ( xcfdata -> red ) , q ) ; //<S2SV> SetPixelGreen ( tile_image , ScaleCharToQuantum ( xcfdata -> green ) , q ) ; //<S2SV> SetPixelBlue ( tile_image , ScaleCharToQuantum ( xcfdata -> blue ) , q ) ; //<S2SV> SetPixelAlpha ( tile_image , xcfdata -> alpha == 255U ? TransparentAlpha : //<S2SV> ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; //<S2SV> xcfdata ++ ; //<S2SV> q += GetPixelChannels ( tile_image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> xcfodata = ( XCFPixelInfo * ) RelinquishMagickMemory ( xcfodata ) ; //<S2SV> return MagickTrue ; //<S2SV> } //<S2SV> 