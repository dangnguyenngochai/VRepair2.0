static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define MonoColorType 1 //<S2SV> # define RGBColorType 3 //<S2SV> char //<S2SV> property [ MagickPathExtent ] ; //<S2SV> CINInfo //<S2SV> cin ; //<S2SV> const unsigned char //<S2SV> * pixels ; //<S2SV> Image //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> QuantumInfo //<S2SV> * quantum_info ; //<S2SV> QuantumType //<S2SV> quantum_type ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> size_t //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> magick [ 4 ] ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> offset = 0 ; //<S2SV> count = ReadBlob ( image , 4 , magick ) ; //<S2SV> offset += count ; //<S2SV> if ( ( count != 4 ) || //<S2SV> ( ( LocaleNCompare ( ( char * ) magick , "\\200\\052\\137\\327" , 4 ) != 0 ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> memset ( & cin , 0 , sizeof ( cin ) ) ; //<S2SV> image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && //<S2SV> ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; //<S2SV> cin . file . image_offset = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . file . generic_length = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . file . industry_length = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . file . user_length = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . file . file_size = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) //<S2SV> cin . file . version ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:file.version" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) //<S2SV> cin . file . filename ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:file.filename" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) //<S2SV> cin . file . create_date ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . file . create_date , //<S2SV> sizeof ( cin . file . create_date ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:file.create_date" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) //<S2SV> cin . file . create_time ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . file . create_time , //<S2SV> sizeof ( cin . file . create_time ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:file.create_time" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) //<S2SV> cin . file . reserve ) ; //<S2SV> cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:image.orientation" , "%d" , //<S2SV> cin . image . orientation ) ; //<S2SV> switch ( cin . image . orientation ) //<S2SV> { //<S2SV> default : //<S2SV> case 0 : image -> orientation = TopLeftOrientation ; break ; //<S2SV> case 1 : image -> orientation = TopRightOrientation ; break ; //<S2SV> case 2 : image -> orientation = BottomLeftOrientation ; break ; //<S2SV> case 3 : image -> orientation = BottomRightOrientation ; break ; //<S2SV> case 4 : image -> orientation = LeftTopOrientation ; break ; //<S2SV> case 5 : image -> orientation = RightTopOrientation ; break ; //<S2SV> case 6 : image -> orientation = LeftBottomOrientation ; break ; //<S2SV> case 7 : image -> orientation = RightBottomOrientation ; break ; //<S2SV> } //<S2SV> cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) //<S2SV> cin . image . reserve1 ) ; //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> } //<S2SV> cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) //<S2SV> image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; //<S2SV> cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) //<S2SV> image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; //<S2SV> cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) //<S2SV> image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; //<S2SV> cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) //<S2SV> image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; //<S2SV> cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) //<S2SV> image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; //<S2SV> cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) //<S2SV> image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; //<S2SV> cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) //<S2SV> image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; //<S2SV> cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) //<S2SV> image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) //<S2SV> cin . image . label ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:image.label" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) //<S2SV> cin . image . reserve ) ; //<S2SV> cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . data_format . line_pad = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . data_format . channel_pad = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) //<S2SV> cin . data_format . reserve ) ; //<S2SV> cin . origination . x_offset = ReadBlobSignedLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:origination.x_offset" , "%.20g" , //<S2SV> ( double ) cin . origination . x_offset ) ; //<S2SV> cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:origination.y_offset" , "%.20g" , //<S2SV> ( double ) cin . origination . y_offset ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) //<S2SV> cin . origination . filename ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . origination . filename , //<S2SV> sizeof ( cin . origination . filename ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:origination.filename" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) //<S2SV> cin . origination . create_date ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . origination . create_date , //<S2SV> sizeof ( cin . origination . create_date ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:origination.create_date" , property , //<S2SV> exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) //<S2SV> cin . origination . create_time ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . origination . create_time , //<S2SV> sizeof ( cin . origination . create_time ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:origination.create_time" , property , //<S2SV> exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) //<S2SV> cin . origination . device ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . origination . device , //<S2SV> sizeof ( cin . origination . device ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:origination.device" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) //<S2SV> cin . origination . model ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . origination . model , //<S2SV> sizeof ( cin . origination . model ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:origination.model" , property , exception ) ; //<S2SV> ( void ) memset ( cin . origination . serial , 0 , //<S2SV> sizeof ( cin . origination . serial ) ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) //<S2SV> cin . origination . serial ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . origination . serial , //<S2SV> sizeof ( cin . origination . serial ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:origination.serial" , property , exception ) ; //<S2SV> cin . origination . x_pitch = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . origination . y_pitch = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> cin . origination . gamma = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) //<S2SV> image -> gamma = cin . origination . gamma ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) //<S2SV> cin . origination . reserve ) ; //<S2SV> if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) //<S2SV> { //<S2SV> int //<S2SV> c ; //<S2SV> cin . film . id = ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> c = cin . film . id ; //<S2SV> if ( c != ~ 0 ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.id" , "%d" , cin . film . id ) ; //<S2SV> cin . film . type = ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> c = cin . film . type ; //<S2SV> if ( c != ~ 0 ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.type" , "%d" , cin . film . type ) ; //<S2SV> cin . film . offset = ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> c = cin . film . offset ; //<S2SV> if ( c != ~ 0 ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.offset" , "%d" , //<S2SV> cin . film . offset ) ; //<S2SV> cin . film . reserve1 = ReadBlobByte ( image ) ; //<S2SV> offset ++ ; //<S2SV> cin . film . prefix = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( cin . film . prefix != ~ 0UL ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.prefix" , "%.20g" , ( double ) //<S2SV> cin . film . prefix ) ; //<S2SV> cin . film . count = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) //<S2SV> cin . film . format ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:film.format" , property , exception ) ; //<S2SV> cin . film . frame_position = ReadBlobLong ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( cin . film . frame_position != ~ 0UL ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.frame_position" , "%.20g" , //<S2SV> ( double ) cin . film . frame_position ) ; //<S2SV> cin . film . frame_rate = ReadBlobFloat ( image ) ; //<S2SV> offset += 4 ; //<S2SV> if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) //<S2SV> ( void ) FormatImageProperty ( image , "dpx:film.frame_rate" , "%g" , //<S2SV> cin . film . frame_rate ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) //<S2SV> cin . film . frame_id ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . film . frame_id , //<S2SV> sizeof ( cin . film . frame_id ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:film.frame_id" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) //<S2SV> cin . film . slate_info ) ; //<S2SV> ( void ) CopyMagickString ( property , cin . film . slate_info , //<S2SV> sizeof ( cin . film . slate_info ) ) ; //<S2SV> ( void ) SetImageProperty ( image , "dpx:film.slate_info" , property , exception ) ; //<S2SV> offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) //<S2SV> cin . film . reserve ) ; //<S2SV> } //<S2SV> if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) //<S2SV> { //<S2SV> StringInfo //<S2SV> * profile ; //<S2SV> if ( cin . file . user_length > GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> profile = BlobToStringInfo ( ( const unsigned char * ) NULL , //<S2SV> cin . file . user_length ) ; //<S2SV> if ( profile == ( StringInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> offset += ReadBlob ( image , GetStringInfoLength ( profile ) , //<S2SV> GetStringInfoDatum ( profile ) ) ; //<S2SV> ( void ) SetImageProfile ( image , "dpx:user.data" , profile , exception ) ; //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> } //<S2SV> image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; //<S2SV> image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; //<S2SV> image -> rows = cin . image . channel [ 0 ] . lines_per_image ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( image ) ; //<S2SV> } //<S2SV> for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) //<S2SV> { //<S2SV> int //<S2SV> c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( offset < ( MagickOffsetType ) cin . file . image_offset ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> ( void ) SetImageBackgroundColor ( image , exception ) ; //<S2SV> quantum_info = AcquireQuantumInfo ( image_info , image ) ; //<S2SV> if ( quantum_info == ( QuantumInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> quantum_info -> quantum = 32 ; //<S2SV> quantum_info -> pack = MagickFalse ; //<S2SV> quantum_type = RGBQuantum ; //<S2SV> length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; //<S2SV> length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; //<S2SV> if ( cin . image . number_channels == 1 ) //<S2SV> { //<S2SV> quantum_type = GrayQuantum ; //<S2SV> length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> pixels = ( const unsigned char * ) ReadBlobStream ( image , length , //<S2SV> GetQuantumPixels ( quantum_info ) , & count ) ; //<S2SV> if ( ( size_t ) count != length ) //<S2SV> break ; //<S2SV> ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , //<S2SV> quantum_type , pixels , exception ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> SetQuantumImageType ( image , quantum_type ) ; //<S2SV> quantum_info = DestroyQuantumInfo ( quantum_info ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> SetImageColorspace ( image , LogColorspace , exception ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 