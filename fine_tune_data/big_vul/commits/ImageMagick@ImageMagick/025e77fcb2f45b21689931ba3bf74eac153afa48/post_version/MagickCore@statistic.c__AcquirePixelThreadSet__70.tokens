static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) //<S2SV> { //<S2SV> const Image //<S2SV> * next ; //<S2SV> PixelChannels //<S2SV> * * pixels ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> columns , //<S2SV> rows ; //<S2SV> rows = MagickMax ( GetImageListLength ( images ) , //<S2SV> ( size_t ) GetMagickResourceLimit ( ThreadResource ) ) ; //<S2SV> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( rows , sizeof ( * pixels ) ) ; //<S2SV> if ( pixels == ( PixelChannels * * ) NULL ) //<S2SV> return ( ( PixelChannels * * ) NULL ) ; //<S2SV> columns = MaxPixelChannels ; //<S2SV> for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) //<S2SV> columns = MagickMax ( next -> columns , columns ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) rows ; i ++ ) //<S2SV> { //<S2SV> register ssize_t //<S2SV> j ; //<S2SV> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; //<S2SV> if ( pixels [ i ] == ( PixelChannels * ) NULL ) //<S2SV> return ( DestroyPixelThreadSet ( pixels ) ) ; //<S2SV> for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) //<S2SV> { //<S2SV> register ssize_t //<S2SV> k ; //<S2SV> for ( k = 0 ; k < MaxPixelChannels ; k ++ ) //<S2SV> pixels [ i ] [ j ] . channel [ k ] = 0.0 ; //<S2SV> } //<S2SV> } //<S2SV> return ( pixels ) ; //<S2SV> } //<S2SV> 