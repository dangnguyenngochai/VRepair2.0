static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) //<S2SV> { //<S2SV> ExceptionInfo //<S2SV> * exception ; //<S2SV> int //<S2SV> bit ; //<S2SV> ssize_t //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> IndexPacket //<S2SV> index ; //<S2SV> register IndexPacket //<S2SV> * indexes ; //<S2SV> exception = ( & image -> exception ) ; //<S2SV> switch ( bpp ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; //<S2SV> SetPixelIndex ( indexes + x + bit , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) //<S2SV> { //<S2SV> index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; //<S2SV> SetPixelIndex ( indexes + x + bit , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ! SyncAuthenticPixels ( image , exception ) ) //<S2SV> break ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> index = ConstrainColormapIndex ( image , ( * p ) & 0x3 ) ; //<S2SV> SetPixelIndex ( indexes + x + 1 , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 4 ) != 0 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> if ( ( image -> columns % 4 ) >= 1 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> if ( ( image -> columns % 4 ) >= 2 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> q ++ ; //<S2SV> index = ConstrainColormapIndex ( image , ( * p ) & 0x0f ) ; //<S2SV> SetPixelIndex ( indexes + x + 1 , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 2 ) != 0 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> break ; //<S2SV> } //<S2SV> case 8 : //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , * p ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 24 : //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( ! SyncAuthenticPixels ( image , exception ) ) //<S2SV> break ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> 