static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> colorspace [ MaxTextExtent ] , //<S2SV> text [ MaxTextExtent ] ; //<S2SV> Image //<S2SV> * image ; //<S2SV> IndexPacket //<S2SV> * indexes ; //<S2SV> long //<S2SV> x_offset , //<S2SV> y_offset ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickPixelPacket //<S2SV> pixel ; //<S2SV> QuantumAny //<S2SV> range ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> type , //<S2SV> y ; //<S2SV> unsigned long //<S2SV> depth , //<S2SV> height , //<S2SV> max_value , //<S2SV> width ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; //<S2SV> ( void ) ReadBlobString ( image , text ) ; //<S2SV> if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> do //<S2SV> { //<S2SV> width = 0 ; //<S2SV> height = 0 ; //<S2SV> max_value = 0 ; //<S2SV> * colorspace = '\\0' ; //<S2SV> count = ( ssize_t ) sscanf ( text + 32 , "%lu,%lu,%lu,%s" , & width , & height , & max_value , //<S2SV> colorspace ) ; //<S2SV> if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> image -> columns = width ; //<S2SV> image -> rows = height ; //<S2SV> if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; //<S2SV> image -> depth = depth ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> LocaleLower ( colorspace ) ; //<S2SV> i = ( ssize_t ) strlen ( colorspace ) - 1 ; //<S2SV> image -> matte = MagickFalse ; //<S2SV> if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) //<S2SV> { //<S2SV> colorspace [ i ] = '\\0' ; //<S2SV> image -> matte = MagickTrue ; //<S2SV> } //<S2SV> type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; //<S2SV> if ( type < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> image -> colorspace = ( ColorspaceType ) type ; //<S2SV> ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; //<S2SV> ( void ) SetImageBackgroundColor ( image ) ; //<S2SV> range = GetQuantumRange ( image -> depth ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> double //<S2SV> blue , //<S2SV> green , //<S2SV> index , //<S2SV> opacity , //<S2SV> red ; //<S2SV> red = 0.0 ; //<S2SV> green = 0.0 ; //<S2SV> blue = 0.0 ; //<S2SV> index = 0.0 ; //<S2SV> opacity = 0.0 ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( ReadBlobString ( image , text ) == ( char * ) NULL ) //<S2SV> break ; //<S2SV> switch ( image -> colorspace ) //<S2SV> { //<S2SV> case GRAYColorspace : //<S2SV> { //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> { //<S2SV> ( void ) sscanf ( text , "%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]" , & x_offset , //<S2SV> & y_offset , & red , & opacity ) ; //<S2SV> green = red ; //<S2SV> blue = red ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) sscanf ( text , "%ld,%ld:<S2SV_blank>(%lf%*[%,]" , & x_offset , & y_offset , & red ) ; //<S2SV> green = red ; //<S2SV> blue = red ; //<S2SV> break ; //<S2SV> } //<S2SV> case CMYKColorspace : //<S2SV> { //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> { //<S2SV> ( void ) sscanf ( text , //<S2SV> "%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]" , //<S2SV> & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) sscanf ( text , //<S2SV> "%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]" , & x_offset , //<S2SV> & y_offset , & red , & green , & blue , & index ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> { //<S2SV> ( void ) sscanf ( text , //<S2SV> "%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]" , //<S2SV> & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) sscanf ( text , "%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]" , //<S2SV> & x_offset , & y_offset , & red , & green , & blue ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( strchr ( text , '%' ) != ( char * ) NULL ) //<S2SV> { //<S2SV> red *= 0.01 * range ; //<S2SV> green *= 0.01 * range ; //<S2SV> blue *= 0.01 * range ; //<S2SV> index *= 0.01 * range ; //<S2SV> opacity *= 0.01 * range ; //<S2SV> } //<S2SV> if ( image -> colorspace == LabColorspace ) //<S2SV> { //<S2SV> green += ( range + 1 ) / 2.0 ; //<S2SV> blue += ( range + 1 ) / 2.0 ; //<S2SV> } //<S2SV> pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , //<S2SV> range ) ; //<S2SV> pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , //<S2SV> range ) ; //<S2SV> pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , //<S2SV> range ) ; //<S2SV> pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , //<S2SV> range ) ; //<S2SV> pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + //<S2SV> 0.5 ) , range ) ; //<S2SV> q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> continue ; //<S2SV> SetPixelRed ( q , pixel . red ) ; //<S2SV> SetPixelGreen ( q , pixel . green ) ; //<S2SV> SetPixelBlue ( q , pixel . blue ) ; //<S2SV> if ( image -> colorspace == CMYKColorspace ) //<S2SV> { //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> SetPixelIndex ( indexes , pixel . index ) ; //<S2SV> } //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> SetPixelAlpha ( q , pixel . opacity ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) ReadBlobString ( image , text ) ; //<S2SV> if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 