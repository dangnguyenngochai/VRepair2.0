static MagickBooleanType ReadPSDChannel ( Image * image , //<S2SV> const ImageInfo * image_info , const PSDInfo * psd_info , LayerInfo * layer_info , //<S2SV> const size_t channel , const PSDCompressionType compression , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> Image //<S2SV> * channel_image , //<S2SV> * mask ; //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> channel_image = image ; //<S2SV> mask = ( Image * ) NULL ; //<S2SV> if ( layer_info -> channel_info [ channel ] . type < - 1 ) //<S2SV> { //<S2SV> const char //<S2SV> * option ; //<S2SV> option = GetImageOption ( image_info , "psd:preserve-opacity-mask" ) ; //<S2SV> if ( ( layer_info -> channel_info [ channel ] . type != - 2 ) || //<S2SV> ( layer_info -> mask . flags > 2 ) || ( ( layer_info -> mask . flags & 0x02 ) && //<S2SV> ( IsStringTrue ( option ) == MagickFalse ) ) ) //<S2SV> { //<S2SV> SeekBlob ( image , layer_info -> channel_info [ channel ] . size - 2 , SEEK_CUR ) ; //<S2SV> return ( MagickTrue ) ; //<S2SV> } //<S2SV> mask = CloneImage ( image , layer_info -> mask . page . width , //<S2SV> layer_info -> mask . page . height , MagickFalse , exception ) ; //<S2SV> if ( mask != ( Image * ) NULL ) //<S2SV> { //<S2SV> mask -> matte = MagickFalse ; //<S2SV> channel_image = mask ; //<S2SV> } //<S2SV> } //<S2SV> offset = TellBlob ( image ) ; //<S2SV> status = MagickTrue ; //<S2SV> switch ( compression ) //<S2SV> { //<S2SV> case Raw : //<S2SV> status = ReadPSDChannelRaw ( channel_image , psd_info -> channels , //<S2SV> layer_info -> channel_info [ channel ] . type , exception ) ; //<S2SV> break ; //<S2SV> case RLE : //<S2SV> { //<S2SV> MagickOffsetType //<S2SV> * sizes ; //<S2SV> sizes = ReadPSDRLESizes ( channel_image , psd_info , channel_image -> rows ) ; //<S2SV> if ( sizes == ( MagickOffsetType * ) NULL ) //<S2SV> ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , //<S2SV> image -> filename ) ; //<S2SV> status = ReadPSDChannelRLE ( channel_image , psd_info , //<S2SV> layer_info -> channel_info [ channel ] . type , sizes , exception ) ; //<S2SV> sizes = ( MagickOffsetType * ) RelinquishMagickMemory ( sizes ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case ZipWithPrediction : //<S2SV> case ZipWithoutPrediction : //<S2SV> # ifdef MAGICKCORE_ZLIB_DELEGATE //<S2SV> status = ReadPSDChannelZip ( channel_image , layer_info -> channels , //<S2SV> layer_info -> channel_info [ channel ] . type , compression , //<S2SV> layer_info -> channel_info [ channel ] . size - 2 , exception ) ; //<S2SV> # else //<S2SV> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , //<S2SV> MissingDelegateWarning , "DelegateLibrarySupportNotBuiltIn" , //<S2SV> "\'%s\'<S2SV_blank>(ZLIB)" , image -> filename ) ; //<S2SV> # endif //<S2SV> break ; //<S2SV> default : //<S2SV> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , TypeWarning , //<S2SV> "CompressionNotSupported" , "\'%.20g\'" , ( double ) compression ) ; //<S2SV> break ; //<S2SV> } //<S2SV> SeekBlob ( image , offset + layer_info -> channel_info [ channel ] . size - 2 , SEEK_SET ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> if ( mask != ( Image * ) NULL ) //<S2SV> DestroyImage ( mask ) ; //<S2SV> ThrowBinaryException ( CoderError , "UnableToDecompressImage" , //<S2SV> image -> filename ) ; //<S2SV> } //<S2SV> layer_info -> mask . image = mask ; //<S2SV> return ( status ) ; //<S2SV> } //<S2SV> 