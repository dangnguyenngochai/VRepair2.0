static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , //<S2SV> unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) //<S2SV> # define PCDGetBits ( n ) \\\n{ sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } \\\n} //<S2SV> typedef struct PCDTable //<S2SV> { //<S2SV> unsigned int //<S2SV> length , //<S2SV> sequence ; //<S2SV> MagickStatusType //<S2SV> mask ; //<S2SV> unsigned char //<S2SV> key ; //<S2SV> } PCDTable ; //<S2SV> PCDTable //<S2SV> * pcd_table [ 3 ] ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> j ; //<S2SV> register PCDTable //<S2SV> * r ; //<S2SV> register unsigned char //<S2SV> * p , //<S2SV> * q ; //<S2SV> size_t //<S2SV> bits , //<S2SV> length , //<S2SV> plane , //<S2SV> pcd_length [ 3 ] , //<S2SV> row , //<S2SV> sum ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> quantum ; //<S2SV> unsigned char //<S2SV> * buffer ; //<S2SV> assert ( image != ( const Image * ) NULL ) ; //<S2SV> assert ( image -> signature == MagickCoreSignature ) ; //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image -> filename ) ; //<S2SV> assert ( luma != ( unsigned char * ) NULL ) ; //<S2SV> assert ( chroma1 != ( unsigned char * ) NULL ) ; //<S2SV> assert ( chroma2 != ( unsigned char * ) NULL ) ; //<S2SV> buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; //<S2SV> if ( buffer == ( unsigned char * ) NULL ) //<S2SV> ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , //<S2SV> image -> filename ) ; //<S2SV> sum = 0 ; //<S2SV> bits = 32 ; //<S2SV> p = buffer + 0x800 ; //<S2SV> for ( i = 0 ; i < 3 ; i ++ ) //<S2SV> { //<S2SV> pcd_table [ i ] = ( PCDTable * ) NULL ; //<S2SV> pcd_length [ i ] = 0 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) //<S2SV> { //<S2SV> PCDGetBits ( 8 ) ; //<S2SV> length = ( sum & 0xff ) + 1 ; //<S2SV> pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , //<S2SV> sizeof ( * pcd_table [ i ] ) ) ; //<S2SV> if ( pcd_table [ i ] == ( PCDTable * ) NULL ) //<S2SV> { //<S2SV> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; //<S2SV> for ( j = 0 ; j < i ; j ++ ) //<S2SV> pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; //<S2SV> ThrowBinaryException ( ResourceLimitError , "MemoryAllocationFailed" , //<S2SV> image -> filename ) ; //<S2SV> } //<S2SV> r = pcd_table [ i ] ; //<S2SV> for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) //<S2SV> { //<S2SV> PCDGetBits ( 8 ) ; //<S2SV> r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; //<S2SV> if ( r -> length > 16 ) //<S2SV> { //<S2SV> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; //<S2SV> for ( j = 0 ; j <= i ; j ++ ) //<S2SV> pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; //<S2SV> return ( MagickFalse ) ; //<S2SV> } //<S2SV> PCDGetBits ( 16 ) ; //<S2SV> r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; //<S2SV> PCDGetBits ( 8 ) ; //<S2SV> r -> key = ( unsigned char ) ( sum & 0xff ) ; //<S2SV> r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; //<S2SV> r ++ ; //<S2SV> } //<S2SV> pcd_length [ i ] = ( size_t ) length ; //<S2SV> } //<S2SV> for ( i = 0 ; i < 1 ; i ++ ) //<S2SV> PCDGetBits ( 16 ) ; //<S2SV> for ( i = 0 ; i < 1 ; i ++ ) //<S2SV> PCDGetBits ( 16 ) ; //<S2SV> while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) //<S2SV> PCDGetBits ( 8 ) ; //<S2SV> while ( IsSync ( sum ) == 0 ) //<S2SV> PCDGetBits ( 1 ) ; //<S2SV> count = 0 ; //<S2SV> length = 0 ; //<S2SV> plane = 0 ; //<S2SV> row = 0 ; //<S2SV> q = luma ; //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> if ( IsSync ( sum ) != 0 ) //<S2SV> { //<S2SV> PCDGetBits ( 16 ) ; //<S2SV> row = ( ( sum >> 9 ) & 0x1fff ) ; //<S2SV> if ( row == image -> rows ) //<S2SV> break ; //<S2SV> PCDGetBits ( 8 ) ; //<S2SV> plane = sum >> 30 ; //<S2SV> PCDGetBits ( 16 ) ; //<S2SV> switch ( plane ) //<S2SV> { //<S2SV> case 0 : //<S2SV> { //<S2SV> q = luma + row * image -> columns ; //<S2SV> count = ( ssize_t ) image -> columns ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> q = chroma1 + ( row >> 1 ) * image -> columns ; //<S2SV> count = ( ssize_t ) ( image -> columns >> 1 ) ; //<S2SV> plane -- ; //<S2SV> break ; //<S2SV> } //<S2SV> case 3 : //<S2SV> { //<S2SV> q = chroma2 + ( row >> 1 ) * image -> columns ; //<S2SV> count = ( ssize_t ) ( image -> columns >> 1 ) ; //<S2SV> plane -- ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) //<S2SV> pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; //<S2SV> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; //<S2SV> ThrowBinaryException ( CorruptImageError , "CorruptImage" , //<S2SV> image -> filename ) ; //<S2SV> } //<S2SV> } //<S2SV> length = pcd_length [ plane ] ; //<S2SV> continue ; //<S2SV> } //<S2SV> r = pcd_table [ plane ] ; //<S2SV> for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) //<S2SV> r ++ ; //<S2SV> if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) //<S2SV> { //<S2SV> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , //<S2SV> CorruptImageWarning , "SkipToSyncByte" , "`%s\'" , image -> filename ) ; //<S2SV> while ( ( sum & 0x00fff000 ) != 0x00fff000 ) //<S2SV> PCDGetBits ( 8 ) ; //<S2SV> while ( IsSync ( sum ) == 0 ) //<S2SV> PCDGetBits ( 1 ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( r -> key < 128 ) //<S2SV> quantum = ( ssize_t ) ( * q ) + r -> key ; //<S2SV> else //<S2SV> quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; //<S2SV> * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; //<S2SV> q ++ ; //<S2SV> PCDGetBits ( r -> length ) ; //<S2SV> count -- ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) //<S2SV> pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; //<S2SV> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; //<S2SV> return ( MagickTrue ) ; //<S2SV> } //<S2SV> 