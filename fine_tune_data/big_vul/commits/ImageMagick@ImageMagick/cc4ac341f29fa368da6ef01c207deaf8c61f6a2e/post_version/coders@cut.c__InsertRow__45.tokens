static MagickBooleanType InsertRow ( Image * image , ssize_t bpp , unsigned char * p , //<S2SV> ssize_t y , ExceptionInfo * exception ) //<S2SV> { //<S2SV> int //<S2SV> bit ; //<S2SV> Quantum //<S2SV> index ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> ssize_t //<S2SV> x ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> return ( MagickFalse ) ; //<S2SV> switch ( bpp ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) //<S2SV> { //<S2SV> index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 3 ) ; x += 4 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 4 ) != 0 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> if ( ( image -> columns % 4 ) > 1 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> if ( ( image -> columns % 4 ) > 2 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , //<S2SV> exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) //<S2SV> index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> p ++ ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( ( image -> columns % 2 ) != 0 ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> p ++ ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 8 : //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , * p , exception ) ; //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> if ( index < image -> colors ) //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; //<S2SV> p ++ ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 24 : //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! SyncAuthenticPixels ( image , exception ) ) //<S2SV> return ( MagickFalse ) ; //<S2SV> return ( MagickTrue ) ; //<S2SV> } //<S2SV> 