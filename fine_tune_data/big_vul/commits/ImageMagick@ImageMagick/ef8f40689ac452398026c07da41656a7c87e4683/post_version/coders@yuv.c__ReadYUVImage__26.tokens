static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> Image //<S2SV> * chroma_image , //<S2SV> * image , //<S2SV> * resize_image ; //<S2SV> InterlaceType //<S2SV> interlace ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> register const Quantum //<S2SV> * chroma_pixels ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> horizontal_factor , //<S2SV> vertical_factor , //<S2SV> y ; //<S2SV> size_t //<S2SV> length , //<S2SV> quantum ; //<S2SV> unsigned char //<S2SV> * scanline ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) //<S2SV> ThrowReaderException ( OptionError , "MustSpecifyImageSize" ) ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; //<S2SV> interlace = image_info -> interlace ; //<S2SV> horizontal_factor = 2 ; //<S2SV> vertical_factor = 2 ; //<S2SV> if ( image_info -> sampling_factor != ( char * ) NULL ) //<S2SV> { //<S2SV> GeometryInfo //<S2SV> geometry_info ; //<S2SV> MagickStatusType //<S2SV> flags ; //<S2SV> flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; //<S2SV> horizontal_factor = ( ssize_t ) geometry_info . rho ; //<S2SV> vertical_factor = ( ssize_t ) geometry_info . sigma ; //<S2SV> if ( ( flags & SigmaValue ) == 0 ) //<S2SV> vertical_factor = horizontal_factor ; //<S2SV> if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && //<S2SV> ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedSamplingFactor" ) ; //<S2SV> } //<S2SV> if ( ( interlace == UndefinedInterlace ) || //<S2SV> ( ( interlace == NoInterlace ) && ( vertical_factor == 2 ) ) ) //<S2SV> { //<S2SV> interlace = NoInterlace ; //<S2SV> if ( vertical_factor == 2 ) //<S2SV> interlace = PlaneInterlace ; //<S2SV> } //<S2SV> if ( interlace != PartitionInterlace ) //<S2SV> { //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> if ( DiscardBlobBytes ( image , ( MagickSizeType ) image -> offset ) == MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> } //<S2SV> if ( interlace == NoInterlace ) //<S2SV> scanline = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( 2UL * //<S2SV> image -> columns + 2UL ) , ( size_t ) quantum * sizeof ( * scanline ) ) ; //<S2SV> else //<S2SV> scanline = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , //<S2SV> ( size_t ) quantum * sizeof ( * scanline ) ) ; //<S2SV> if ( scanline == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> status = MagickTrue ; //<S2SV> do //<S2SV> { //<S2SV> chroma_image = CloneImage ( image , ( image -> columns + horizontal_factor - 1 ) / //<S2SV> horizontal_factor , ( image -> rows + vertical_factor - 1 ) / vertical_factor , //<S2SV> MagickTrue , exception ) ; //<S2SV> if ( chroma_image == ( Image * ) NULL ) //<S2SV> { //<S2SV> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> if ( interlace == PartitionInterlace ) //<S2SV> { //<S2SV> AppendImageFormat ( "Y" , image -> filename ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> register Quantum //<S2SV> * chroma_pixels ; //<S2SV> if ( interlace == NoInterlace ) //<S2SV> { //<S2SV> if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) //<S2SV> { //<S2SV> length = 2 * quantum * image -> columns ; //<S2SV> count = ReadBlob ( image , length , scanline ) ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> p = scanline ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> chroma_pixels = QueueAuthenticPixels ( chroma_image , 0 , y , //<S2SV> chroma_image -> columns , 1 , exception ) ; //<S2SV> if ( chroma_pixels == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x += 2 ) //<S2SV> { //<S2SV> SetPixelRed ( chroma_image , 0 , chroma_pixels ) ; //<S2SV> if ( quantum == 1 ) //<S2SV> SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , //<S2SV> chroma_pixels ) ; //<S2SV> else //<S2SV> { //<S2SV> SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | //<S2SV> * ( p + 1 ) ) , chroma_pixels ) ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> if ( quantum == 1 ) //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> else //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> SetPixelGreen ( image , 0 , q ) ; //<S2SV> SetPixelBlue ( image , 0 , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> SetPixelGreen ( image , 0 , q ) ; //<S2SV> SetPixelBlue ( image , 0 , q ) ; //<S2SV> if ( quantum == 1 ) //<S2SV> SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , chroma_pixels ) ; //<S2SV> else //<S2SV> { //<S2SV> SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | //<S2SV> * ( p + 1 ) ) , chroma_pixels ) ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> if ( quantum == 1 ) //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> else //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> chroma_pixels += GetPixelChannels ( chroma_image ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ( y > 0 ) || ( GetPreviousImageInList ( image ) == ( Image * ) NULL ) ) //<S2SV> { //<S2SV> length = quantum * image -> columns ; //<S2SV> count = ReadBlob ( image , length , scanline ) ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> p = scanline ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( quantum == 1 ) //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> else //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | * ( p + 1 ) ) , q ) ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> SetPixelGreen ( image , 0 , q ) ; //<S2SV> SetPixelBlue ( image , 0 , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( interlace == NoInterlace ) //<S2SV> if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( interlace == PartitionInterlace ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> AppendImageFormat ( "U" , image -> filename ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( interlace != NoInterlace ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) //<S2SV> { //<S2SV> length = quantum * chroma_image -> columns ; //<S2SV> count = ReadBlob ( image , length , scanline ) ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> p = scanline ; //<S2SV> q = QueueAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( chroma_image , 0 , q ) ; //<S2SV> if ( quantum == 1 ) //<S2SV> SetPixelGreen ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> else //<S2SV> { //<S2SV> SetPixelGreen ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | //<S2SV> * ( p + 1 ) ) , q ) ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> SetPixelBlue ( chroma_image , 0 , q ) ; //<S2SV> q += GetPixelChannels ( chroma_image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( interlace == PartitionInterlace ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> AppendImageFormat ( "V" , image -> filename ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) chroma_image -> rows ; y ++ ) //<S2SV> { //<S2SV> length = quantum * chroma_image -> columns ; //<S2SV> count = ReadBlob ( image , length , scanline ) ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> p = scanline ; //<S2SV> q = GetAuthenticPixels ( chroma_image , 0 , y , chroma_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) chroma_image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( quantum == 1 ) //<S2SV> SetPixelBlue ( chroma_image , ScaleCharToQuantum ( * p ++ ) , q ) ; //<S2SV> else //<S2SV> { //<S2SV> SetPixelBlue ( chroma_image , ScaleShortToQuantum ( ( ( * p ) << 8 ) | //<S2SV> * ( p + 1 ) ) , q ) ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> q += GetPixelChannels ( chroma_image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( chroma_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> resize_image = ResizeImage ( chroma_image , image -> columns , image -> rows , //<S2SV> TriangleFilter , exception ) ; //<S2SV> chroma_image = DestroyImage ( chroma_image ) ; //<S2SV> if ( resize_image == ( Image * ) NULL ) //<S2SV> { //<S2SV> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> chroma_pixels = GetVirtualPixels ( resize_image , 0 , y , resize_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( ( q == ( Quantum * ) NULL ) || //<S2SV> ( chroma_pixels == ( const Quantum * ) NULL ) ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelGreen ( image , GetPixelGreen ( resize_image , chroma_pixels ) , q ) ; //<S2SV> SetPixelBlue ( image , GetPixelBlue ( resize_image , chroma_pixels ) , q ) ; //<S2SV> chroma_pixels += GetPixelChannels ( resize_image ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> resize_image = DestroyImage ( resize_image ) ; //<S2SV> if ( SetImageColorspace ( image , YCbCrColorspace , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( interlace == PartitionInterlace ) //<S2SV> ( void ) CopyMagickString ( image -> filename , image_info -> filename , //<S2SV> MagickPathExtent ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( interlace == NoInterlace ) //<S2SV> count = ReadBlob ( image , ( size_t ) ( 2 * quantum * image -> columns ) , scanline ) ; //<S2SV> else //<S2SV> count = ReadBlob ( image , ( size_t ) quantum * image -> columns , scanline ) ; //<S2SV> if ( count != 0 ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( count != 0 ) ; //<S2SV> scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 