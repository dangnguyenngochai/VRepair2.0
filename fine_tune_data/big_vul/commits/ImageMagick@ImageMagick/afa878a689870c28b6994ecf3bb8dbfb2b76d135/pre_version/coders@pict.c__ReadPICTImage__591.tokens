static Image * ReadPICTImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } //<S2SV> char //<S2SV> geometry [ MagickPathExtent ] , //<S2SV> header_ole [ 4 ] ; //<S2SV> Image //<S2SV> * image , //<S2SV> * tile_image ; //<S2SV> ImageInfo //<S2SV> * read_info ; //<S2SV> int //<S2SV> c , //<S2SV> code ; //<S2SV> MagickBooleanType //<S2SV> jpeg , //<S2SV> status ; //<S2SV> PICTRectangle //<S2SV> frame ; //<S2SV> PICTPixmap //<S2SV> pixmap ; //<S2SV> Quantum //<S2SV> index ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> size_t //<S2SV> extent , //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> flags , //<S2SV> j , //<S2SV> version , //<S2SV> y ; //<S2SV> StringInfo //<S2SV> * profile ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> read_info = ( ImageInfo * ) NULL ; //<S2SV> tile_image = ( Image * ) NULL ; //<S2SV> pixmap . bits_per_pixel = 0 ; //<S2SV> pixmap . component_count = 0 ; //<S2SV> header_ole [ 0 ] = ReadBlobByte ( image ) ; //<S2SV> header_ole [ 1 ] = ReadBlobByte ( image ) ; //<S2SV> header_ole [ 2 ] = ReadBlobByte ( image ) ; //<S2SV> header_ole [ 3 ] = ReadBlobByte ( image ) ; //<S2SV> if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && //<S2SV> ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) //<S2SV> for ( i = 0 ; i < 508 ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> ( void ) ReadBlobMSBShort ( image ) ; //<S2SV> if ( ReadRectangle ( image , & frame ) == MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; //<S2SV> if ( c != 0x11 ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> version = ( ssize_t ) ReadBlobByte ( image ) ; //<S2SV> if ( version == 2 ) //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c != 0xff ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( version != 1 ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || //<S2SV> ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || //<S2SV> ( frame . top >= frame . bottom ) ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> flags = 0 ; //<S2SV> image -> depth = 8 ; //<S2SV> image -> columns = ( size_t ) ( frame . right - frame . left ) ; //<S2SV> image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; //<S2SV> image -> resolution . x = DefaultResolution ; //<S2SV> image -> resolution . y = DefaultResolution ; //<S2SV> image -> units = UndefinedResolution ; //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status != MagickFalse ) //<S2SV> status = ResetImagePixels ( image , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> jpeg = MagickFalse ; //<S2SV> for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) //<S2SV> { //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) //<S2SV> code = ReadBlobByte ( image ) ; //<S2SV> if ( version == 2 ) //<S2SV> code = ReadBlobMSBSignedShort ( image ) ; //<S2SV> if ( code < 0 ) //<S2SV> break ; //<S2SV> if ( code == 0 ) //<S2SV> continue ; //<S2SV> if ( code > 0xa1 ) //<S2SV> { //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "%04X:" , code ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( image -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s" , code , codes [ code ] . name , codes [ code ] . description ) ; //<S2SV> switch ( code ) //<S2SV> { //<S2SV> case 0x01 : //<S2SV> { //<S2SV> length = ReadBlobMSBShort ( image ) ; //<S2SV> if ( length != 0x000a ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ReadRectangle ( image , & frame ) == MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) //<S2SV> break ; //<S2SV> image -> columns = ( size_t ) ( frame . right - frame . left ) ; //<S2SV> image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status != MagickFalse ) //<S2SV> status = ResetImagePixels ( image , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x12 : //<S2SV> case 0x13 : //<S2SV> case 0x14 : //<S2SV> { //<S2SV> ssize_t //<S2SV> pattern ; //<S2SV> size_t //<S2SV> height , //<S2SV> width ; //<S2SV> pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> if ( pattern == 2 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 5 ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( pattern != 1 ) //<S2SV> ThrowPICTException ( CorruptImageError , "UnknownPatternType" ) ; //<S2SV> length = ReadBlobMSBShort ( image ) ; //<S2SV> if ( ReadRectangle ( image , & frame ) == MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> image -> depth = ( size_t ) pixmap . component_size ; //<S2SV> image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; //<S2SV> image -> resolution . y = 1.0 * pixmap . vertical_resolution ; //<S2SV> image -> units = PixelsPerInchResolution ; //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; //<S2SV> length = ReadBlobMSBShort ( image ) ; //<S2SV> for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> width = ( size_t ) ( frame . bottom - frame . top ) ; //<S2SV> height = ( size_t ) ( frame . right - frame . left ) ; //<S2SV> if ( pixmap . bits_per_pixel <= 8 ) //<S2SV> length &= 0x7fff ; //<S2SV> if ( pixmap . bits_per_pixel == 16 ) //<S2SV> width <<= 1 ; //<S2SV> if ( length == 0 ) //<S2SV> length = width ; //<S2SV> if ( length < 8 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) //<S2SV> { //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> break ; //<S2SV> if ( length > 200 ) //<S2SV> { //<S2SV> for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1b : //<S2SV> { //<S2SV> image -> background_color . red = ( Quantum ) //<S2SV> ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; //<S2SV> image -> background_color . green = ( Quantum ) //<S2SV> ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; //<S2SV> image -> background_color . blue = ( Quantum ) //<S2SV> ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x70 : //<S2SV> case 0x71 : //<S2SV> case 0x72 : //<S2SV> case 0x73 : //<S2SV> case 0x74 : //<S2SV> case 0x75 : //<S2SV> case 0x76 : //<S2SV> case 0x77 : //<S2SV> { //<S2SV> length = ReadBlobMSBShort ( image ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x90 : //<S2SV> case 0x91 : //<S2SV> case 0x98 : //<S2SV> case 0x99 : //<S2SV> case 0x9a : //<S2SV> case 0x9b : //<S2SV> { //<S2SV> PICTRectangle //<S2SV> source , //<S2SV> destination ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> j ; //<S2SV> ssize_t //<S2SV> bytes_per_line ; //<S2SV> unsigned char //<S2SV> * pixels ; //<S2SV> bytes_per_line = 0 ; //<S2SV> if ( ( code != 0x9a ) && ( code != 0x9b ) ) //<S2SV> bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; //<S2SV> else //<S2SV> { //<S2SV> ( void ) ReadBlobMSBShort ( image ) ; //<S2SV> ( void ) ReadBlobMSBShort ( image ) ; //<S2SV> ( void ) ReadBlobMSBShort ( image ) ; //<S2SV> } //<S2SV> if ( ReadRectangle ( image , & frame ) == MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , //<S2SV> ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; //<S2SV> if ( tile_image == ( Image * ) NULL ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( code == 0x9a ) || ( code == 0x9b ) || //<S2SV> ( ( bytes_per_line & 0x8000 ) != 0 ) ) //<S2SV> { //<S2SV> if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> tile_image -> depth = ( size_t ) pixmap . component_size ; //<S2SV> tile_image -> alpha_trait = pixmap . component_count == 4 ? //<S2SV> BlendPixelTrait : UndefinedPixelTrait ; //<S2SV> tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; //<S2SV> tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; //<S2SV> tile_image -> units = PixelsPerInchResolution ; //<S2SV> if ( tile_image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; //<S2SV> } //<S2SV> if ( ( code != 0x9a ) && ( code != 0x9b ) ) //<S2SV> { //<S2SV> tile_image -> colors = 2 ; //<S2SV> if ( ( bytes_per_line & 0x8000 ) != 0 ) //<S2SV> { //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; //<S2SV> tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; //<S2SV> } //<S2SV> status = AcquireImageColormap ( tile_image , tile_image -> colors , //<S2SV> exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowPICTException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> if ( ( bytes_per_line & 0x8000 ) != 0 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) //<S2SV> { //<S2SV> j = ReadBlobMSBShort ( image ) % tile_image -> colors ; //<S2SV> if ( ( flags & 0x8000 ) != 0 ) //<S2SV> j = ( size_t ) i ; //<S2SV> tile_image -> colormap [ j ] . red = ( Quantum ) //<S2SV> ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; //<S2SV> tile_image -> colormap [ j ] . green = ( Quantum ) //<S2SV> ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; //<S2SV> tile_image -> colormap [ j ] . blue = ( Quantum ) //<S2SV> ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) //<S2SV> { //<S2SV> tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - //<S2SV> tile_image -> colormap [ i ] . red ) ; //<S2SV> tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - //<S2SV> tile_image -> colormap [ i ] . green ) ; //<S2SV> tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - //<S2SV> tile_image -> colormap [ i ] . blue ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> if ( ReadRectangle ( image , & source ) == MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ReadRectangle ( image , & destination ) == MagickFalse ) //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> ( void ) ReadBlobMSBShort ( image ) ; //<S2SV> if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) //<S2SV> { //<S2SV> length = ReadBlobMSBShort ( image ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( code != 0x9a ) && ( code != 0x9b ) && //<S2SV> ( bytes_per_line & 0x8000 ) == 0 ) //<S2SV> pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , //<S2SV> & extent ) ; //<S2SV> else //<S2SV> pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , //<S2SV> ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; //<S2SV> if ( pixels == ( unsigned char * ) NULL ) //<S2SV> ThrowPICTException ( CorruptImageError , "UnableToUncompressImage" ) ; //<S2SV> p = pixels ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) //<S2SV> { //<S2SV> if ( p > ( pixels + extent + image -> columns ) ) //<S2SV> { //<S2SV> pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; //<S2SV> ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; //<S2SV> } //<S2SV> q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , //<S2SV> exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( tile_image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) //<S2SV> * p , exception ) ; //<S2SV> SetPixelIndex ( tile_image , index , q ) ; //<S2SV> SetPixelRed ( tile_image , //<S2SV> tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; //<S2SV> SetPixelGreen ( tile_image , //<S2SV> tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; //<S2SV> SetPixelBlue ( tile_image , //<S2SV> tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( pixmap . bits_per_pixel == 16 ) //<S2SV> { //<S2SV> i = ( ssize_t ) ( * p ++ ) ; //<S2SV> j = ( size_t ) ( * p ) ; //<S2SV> SetPixelRed ( tile_image , ScaleCharToQuantum ( //<S2SV> ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; //<S2SV> SetPixelGreen ( tile_image , ScaleCharToQuantum ( //<S2SV> ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | //<S2SV> ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; //<S2SV> SetPixelBlue ( tile_image , ScaleCharToQuantum ( //<S2SV> ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( tile_image -> alpha_trait == UndefinedPixelTrait ) //<S2SV> { //<S2SV> if ( p > ( pixels + extent + 2 * image -> columns ) ) //<S2SV> ThrowPICTException ( CorruptImageError , //<S2SV> "NotEnoughPixelData" ) ; //<S2SV> SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; //<S2SV> SetPixelGreen ( tile_image , ScaleCharToQuantum ( //<S2SV> * ( p + tile_image -> columns ) ) , q ) ; //<S2SV> SetPixelBlue ( tile_image , ScaleCharToQuantum ( //<S2SV> * ( p + 2 * tile_image -> columns ) ) , q ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( p > ( pixels + extent + 3 * image -> columns ) ) //<S2SV> ThrowPICTException ( CorruptImageError , //<S2SV> "NotEnoughPixelData" ) ; //<S2SV> SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; //<S2SV> SetPixelRed ( tile_image , ScaleCharToQuantum ( //<S2SV> * ( p + tile_image -> columns ) ) , q ) ; //<S2SV> SetPixelGreen ( tile_image , ScaleCharToQuantum ( //<S2SV> * ( p + 2 * tile_image -> columns ) ) , q ) ; //<S2SV> SetPixelBlue ( tile_image , ScaleCharToQuantum ( //<S2SV> * ( p + 3 * tile_image -> columns ) ) , q ) ; //<S2SV> } //<S2SV> } //<S2SV> p ++ ; //<S2SV> q += GetPixelChannels ( tile_image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( tile_image -> storage_class == DirectClass ) && //<S2SV> ( pixmap . bits_per_pixel != 16 ) ) //<S2SV> { //<S2SV> p += ( pixmap . component_count - 1 ) * tile_image -> columns ; //<S2SV> if ( p < pixels ) //<S2SV> break ; //<S2SV> } //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> tile_image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; //<S2SV> if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) //<S2SV> if ( ( code == 0x9a ) || ( code == 0x9b ) || //<S2SV> ( ( bytes_per_line & 0x8000 ) != 0 ) ) //<S2SV> ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , //<S2SV> MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) //<S2SV> destination . top , exception ) ; //<S2SV> tile_image = DestroyImage ( tile_image ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0xa1 : //<S2SV> { //<S2SV> unsigned char //<S2SV> * info ; //<S2SV> size_t //<S2SV> type ; //<S2SV> type = ReadBlobMSBShort ( image ) ; //<S2SV> length = ReadBlobMSBShort ( image ) ; //<S2SV> if ( length == 0 ) //<S2SV> break ; //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> length -= MagickMin ( length , 4 ) ; //<S2SV> if ( length == 0 ) //<S2SV> break ; //<S2SV> info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; //<S2SV> if ( info == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> count = ReadBlob ( image , length , info ) ; //<S2SV> if ( count != ( ssize_t ) length ) //<S2SV> { //<S2SV> info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; //<S2SV> ThrowPICTException ( ResourceLimitError , "UnableToReadImageData" ) ; //<S2SV> } //<S2SV> switch ( type ) //<S2SV> { //<S2SV> case 0xe0 : //<S2SV> { //<S2SV> profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; //<S2SV> SetStringInfoDatum ( profile , info ) ; //<S2SV> status = SetImageProfile ( image , "icc" , profile , exception ) ; //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; //<S2SV> ThrowPICTException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1f2 : //<S2SV> { //<S2SV> profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; //<S2SV> SetStringInfoDatum ( profile , info ) ; //<S2SV> status = SetImageProfile ( image , "iptc" , profile , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; //<S2SV> ThrowPICTException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> if ( codes [ code ] . length == - 1 ) //<S2SV> ( void ) ReadBlobMSBShort ( image ) ; //<S2SV> else //<S2SV> for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( code == 0xc00 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 24 ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || //<S2SV> ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) //<S2SV> continue ; //<S2SV> if ( code == 0x8200 ) //<S2SV> { //<S2SV> char //<S2SV> filename [ MaxTextExtent ] ; //<S2SV> FILE //<S2SV> * file ; //<S2SV> int //<S2SV> unique_file ; //<S2SV> jpeg = MagickTrue ; //<S2SV> read_info = CloneImageInfo ( image_info ) ; //<S2SV> SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; //<S2SV> file = ( FILE * ) NULL ; //<S2SV> unique_file = AcquireUniqueFileResource ( filename ) ; //<S2SV> ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , "jpeg:%s" , //<S2SV> filename ) ; //<S2SV> if ( unique_file != - 1 ) //<S2SV> file = fdopen ( unique_file , "wb" ) ; //<S2SV> if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) //<S2SV> { //<S2SV> ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; //<S2SV> ( void ) CopyMagickString ( image -> filename , read_info -> filename , //<S2SV> MagickPathExtent ) ; //<S2SV> ThrowPICTException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; //<S2SV> } //<S2SV> length = ReadBlobMSBLong ( image ) ; //<S2SV> if ( length > 154 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 6 ; i ++ ) //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> if ( ReadRectangle ( image , & frame ) == MagickFalse ) //<S2SV> { //<S2SV> ( void ) fclose ( file ) ; //<S2SV> ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; //<S2SV> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < 122 ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> break ; //<S2SV> if ( fputc ( c , file ) != c ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) fclose ( file ) ; //<S2SV> ( void ) close ( unique_file ) ; //<S2SV> tile_image = ReadImage ( read_info , exception ) ; //<S2SV> ( void ) RelinquishUniqueFileResource ( filename ) ; //<S2SV> read_info = DestroyImageInfo ( read_info ) ; //<S2SV> if ( tile_image == ( Image * ) NULL ) //<S2SV> continue ; //<S2SV> ( void ) FormatLocaleString ( geometry , MagickPathExtent , "%.20gx%.20g" , //<S2SV> ( double ) MagickMax ( image -> columns , tile_image -> columns ) , //<S2SV> ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; //<S2SV> ( void ) SetImageExtent ( image , //<S2SV> MagickMax ( image -> columns , tile_image -> columns ) , //<S2SV> MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; //<S2SV> ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; //<S2SV> ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , //<S2SV> ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; //<S2SV> image -> compression = tile_image -> compression ; //<S2SV> tile_image = DestroyImage ( tile_image ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( code == 0xff ) || ( code == 0xffff ) ) //<S2SV> break ; //<S2SV> if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || //<S2SV> ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) //<S2SV> { //<S2SV> length = ReadBlobMSBShort ( image ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) //<S2SV> { //<S2SV> length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 