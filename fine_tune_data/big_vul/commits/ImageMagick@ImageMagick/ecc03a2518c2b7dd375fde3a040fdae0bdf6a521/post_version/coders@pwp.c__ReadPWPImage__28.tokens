static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> FILE //<S2SV> * file ; //<S2SV> Image //<S2SV> * image , //<S2SV> * next_image , //<S2SV> * pwp_image ; //<S2SV> ImageInfo //<S2SV> * read_info ; //<S2SV> int //<S2SV> c , //<S2SV> unique_file ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> register Image //<S2SV> * p ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> filesize , //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count ; //<S2SV> unsigned char //<S2SV> magick [ MaxTextExtent ] ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> pwp_image = AcquireImage ( image_info ) ; //<S2SV> image = pwp_image ; //<S2SV> status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> count = ReadBlob ( pwp_image , 5 , magick ) ; //<S2SV> if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , "SFW95" , 5 ) != 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> read_info = CloneImageInfo ( image_info ) ; //<S2SV> ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , //<S2SV> ( void * ) NULL ) ; //<S2SV> SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; //<S2SV> unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 17 ; i ++ ) //<S2SV> magick [ i ] = magick [ i + 1 ] ; //<S2SV> magick [ 17 ] = ( unsigned char ) c ; //<S2SV> if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) == 0 ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( c == EOF ) //<S2SV> break ; //<S2SV> if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) != 0 ) //<S2SV> { //<S2SV> ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> file = ( FILE * ) NULL ; //<S2SV> if ( unique_file != - 1 ) //<S2SV> file = fdopen ( unique_file , "wb" ) ; //<S2SV> if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) //<S2SV> { //<S2SV> ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; //<S2SV> ThrowFileException ( exception , FileOpenError , "UnableToWriteFile" , //<S2SV> image -> filename ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> length = fwrite ( "SFW94A" , 1 , 6 , file ) ; //<S2SV> ( void ) length ; //<S2SV> filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) //<S2SV> { //<S2SV> c = ReadBlobByte ( pwp_image ) ; //<S2SV> ( void ) fputc ( c , file ) ; //<S2SV> } //<S2SV> ( void ) fclose ( file ) ; //<S2SV> next_image = ReadImage ( read_info , exception ) ; //<S2SV> if ( next_image == ( Image * ) NULL ) //<S2SV> break ; //<S2SV> ( void ) FormatLocaleString ( next_image -> filename , MaxTextExtent , //<S2SV> "slide_%02ld.sfw" , ( long ) next_image -> scene ) ; //<S2SV> if ( image == ( Image * ) NULL ) //<S2SV> image = next_image ; //<S2SV> else //<S2SV> { //<S2SV> for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; //<S2SV> next_image -> previous = p ; //<S2SV> next_image -> scene = p -> scene + 1 ; //<S2SV> p -> next = next_image ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , //<S2SV> GetBlobSize ( pwp_image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( unique_file != - 1 ) //<S2SV> ( void ) close ( unique_file ) ; //<S2SV> ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; //<S2SV> read_info = DestroyImageInfo ( read_info ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> char //<S2SV> * message ; //<S2SV> message = GetExceptionMessage ( errno ) ; //<S2SV> ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , "`%s\':<S2SV_blank>%s" , image -> filename , message ) ; //<S2SV> message = DestroyString ( message ) ; //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 