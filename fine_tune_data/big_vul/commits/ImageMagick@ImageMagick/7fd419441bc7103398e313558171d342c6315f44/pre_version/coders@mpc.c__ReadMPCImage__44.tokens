static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> cache_filename [ MagickPathExtent ] , //<S2SV> id [ MagickPathExtent ] , //<S2SV> keyword [ MagickPathExtent ] , //<S2SV> * options ; //<S2SV> const unsigned char //<S2SV> * p ; //<S2SV> GeometryInfo //<S2SV> geometry_info ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> c ; //<S2SV> LinkedListInfo //<S2SV> * profiles ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> MagickStatusType //<S2SV> flags ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> depth , //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count ; //<S2SV> StringInfo //<S2SV> * profile ; //<S2SV> unsigned int //<S2SV> signature ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) CopyMagickString ( cache_filename , image -> filename , MagickPathExtent ) ; //<S2SV> AppendImageFormat ( "cache" , cache_filename ) ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> { //<S2SV> image = DestroyImage ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> * id = '\\0' ; //<S2SV> ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; //<S2SV> offset = 0 ; //<S2SV> do //<S2SV> { //<S2SV> profiles = ( LinkedListInfo * ) NULL ; //<S2SV> length = MagickPathExtent ; //<S2SV> options = AcquireString ( ( char * ) NULL ) ; //<S2SV> signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; //<S2SV> image -> depth = 8 ; //<S2SV> image -> compression = NoCompression ; //<S2SV> while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) //<S2SV> { //<S2SV> register char //<S2SV> * p ; //<S2SV> if ( c == ( int ) '{' ) //<S2SV> { //<S2SV> char //<S2SV> * comment ; //<S2SV> length = MagickPathExtent ; //<S2SV> comment = AcquireString ( ( char * ) NULL ) ; //<S2SV> for ( p = comment ; comment != ( char * ) NULL ; p ++ ) //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == ( int ) '\\\\' ) //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> else //<S2SV> if ( ( c == EOF ) || ( c == ( int ) '}' ) ) //<S2SV> break ; //<S2SV> if ( ( size_t ) ( p - comment + 1 ) >= length ) //<S2SV> { //<S2SV> * p = '\\0' ; //<S2SV> length <<= 1 ; //<S2SV> comment = ( char * ) ResizeQuantumMemory ( comment , length + //<S2SV> MagickPathExtent , sizeof ( * comment ) ) ; //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> break ; //<S2SV> p = comment + strlen ( comment ) ; //<S2SV> } //<S2SV> * p = ( char ) c ; //<S2SV> } //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> * p = '\\0' ; //<S2SV> ( void ) SetImageProperty ( image , "comment" , comment , exception ) ; //<S2SV> comment = DestroyString ( comment ) ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( isalnum ( c ) != MagickFalse ) //<S2SV> { //<S2SV> length = MagickPathExtent ; //<S2SV> p = keyword ; //<S2SV> do //<S2SV> { //<S2SV> if ( c == ( int ) '=' ) //<S2SV> break ; //<S2SV> if ( ( size_t ) ( p - keyword ) < ( MagickPathExtent - 1 ) ) //<S2SV> * p ++ = ( char ) c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } while ( c != EOF ) ; //<S2SV> * p = '\\0' ; //<S2SV> p = options ; //<S2SV> while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == ( int ) '=' ) //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> while ( ( c != ( int ) '}' ) && ( c != EOF ) ) //<S2SV> { //<S2SV> if ( ( size_t ) ( p - options + 1 ) >= length ) //<S2SV> { //<S2SV> * p = '\\0' ; //<S2SV> length <<= 1 ; //<S2SV> options = ( char * ) ResizeQuantumMemory ( options , length + //<S2SV> MagickPathExtent , sizeof ( * options ) ) ; //<S2SV> if ( options == ( char * ) NULL ) //<S2SV> break ; //<S2SV> p = options + strlen ( options ) ; //<S2SV> } //<S2SV> * p ++ = ( char ) c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == '\\\\' ) //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == ( int ) '}' ) //<S2SV> { //<S2SV> * p ++ = ( char ) c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( * options != '{' ) //<S2SV> if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( options == ( char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> * p = '\\0' ; //<S2SV> if ( * options == '{' ) //<S2SV> ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; //<S2SV> switch ( * keyword ) //<S2SV> { //<S2SV> case 'a' : //<S2SV> case 'A' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "alpha-trait" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> alpha_trait ; //<S2SV> alpha_trait = ParseCommandOption ( MagickPixelTraitOptions , //<S2SV> MagickFalse , options ) ; //<S2SV> if ( alpha_trait < 0 ) //<S2SV> break ; //<S2SV> image -> alpha_trait = ( PixelTrait ) alpha_trait ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'b' : //<S2SV> case 'B' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "background-color" ) == 0 ) //<S2SV> { //<S2SV> ( void ) QueryColorCompliance ( options , AllCompliance , //<S2SV> & image -> background_color , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "blue-primary" ) == 0 ) //<S2SV> { //<S2SV> flags = ParseGeometry ( options , & geometry_info ) ; //<S2SV> image -> chromaticity . blue_primary . x = geometry_info . rho ; //<S2SV> image -> chromaticity . blue_primary . y = geometry_info . sigma ; //<S2SV> if ( ( flags & SigmaValue ) == 0 ) //<S2SV> image -> chromaticity . blue_primary . y = //<S2SV> image -> chromaticity . blue_primary . x ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "border-color" ) == 0 ) //<S2SV> { //<S2SV> ( void ) QueryColorCompliance ( options , AllCompliance , //<S2SV> & image -> border_color , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'c' : //<S2SV> case 'C' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "class" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> storage_class ; //<S2SV> storage_class = ParseCommandOption ( MagickClassOptions , //<S2SV> MagickFalse , options ) ; //<S2SV> if ( storage_class < 0 ) //<S2SV> break ; //<S2SV> image -> storage_class = ( ClassType ) storage_class ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "colors" ) == 0 ) //<S2SV> { //<S2SV> image -> colors = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "colorspace" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> colorspace ; //<S2SV> colorspace = ParseCommandOption ( MagickColorspaceOptions , //<S2SV> MagickFalse , options ) ; //<S2SV> if ( colorspace < 0 ) //<S2SV> break ; //<S2SV> image -> colorspace = ( ColorspaceType ) colorspace ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "compression" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> compression ; //<S2SV> compression = ParseCommandOption ( MagickCompressOptions , //<S2SV> MagickFalse , options ) ; //<S2SV> if ( compression < 0 ) //<S2SV> break ; //<S2SV> image -> compression = ( CompressionType ) compression ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "columns" ) == 0 ) //<S2SV> { //<S2SV> image -> columns = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'd' : //<S2SV> case 'D' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "delay" ) == 0 ) //<S2SV> { //<S2SV> image -> delay = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "depth" ) == 0 ) //<S2SV> { //<S2SV> image -> depth = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "dispose" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> dispose ; //<S2SV> dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , //<S2SV> options ) ; //<S2SV> if ( dispose < 0 ) //<S2SV> break ; //<S2SV> image -> dispose = ( DisposeType ) dispose ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'e' : //<S2SV> case 'E' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "endian" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> endian ; //<S2SV> endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , //<S2SV> options ) ; //<S2SV> if ( endian < 0 ) //<S2SV> break ; //<S2SV> image -> endian = ( EndianType ) endian ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "error" ) == 0 ) //<S2SV> { //<S2SV> image -> error . mean_error_per_pixel = StringToDouble ( options , //<S2SV> ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'g' : //<S2SV> case 'G' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "gamma" ) == 0 ) //<S2SV> { //<S2SV> image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "green-primary" ) == 0 ) //<S2SV> { //<S2SV> flags = ParseGeometry ( options , & geometry_info ) ; //<S2SV> image -> chromaticity . green_primary . x = geometry_info . rho ; //<S2SV> image -> chromaticity . green_primary . y = geometry_info . sigma ; //<S2SV> if ( ( flags & SigmaValue ) == 0 ) //<S2SV> image -> chromaticity . green_primary . y = //<S2SV> image -> chromaticity . green_primary . x ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'i' : //<S2SV> case 'I' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "id" ) == 0 ) //<S2SV> { //<S2SV> ( void ) CopyMagickString ( id , options , MagickPathExtent ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "iterations" ) == 0 ) //<S2SV> { //<S2SV> image -> iterations = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'm' : //<S2SV> case 'M' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "magick-signature" ) == 0 ) //<S2SV> { //<S2SV> signature = ( unsigned int ) StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "mattecolor" ) == 0 ) //<S2SV> { //<S2SV> ( void ) QueryColorCompliance ( options , AllCompliance , //<S2SV> & image -> matte_color , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "maximum-error" ) == 0 ) //<S2SV> { //<S2SV> image -> error . normalized_maximum_error = StringToDouble ( //<S2SV> options , ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "mean-error" ) == 0 ) //<S2SV> { //<S2SV> image -> error . normalized_mean_error = StringToDouble ( options , //<S2SV> ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "montage" ) == 0 ) //<S2SV> { //<S2SV> ( void ) CloneString ( & image -> montage , options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'n' : //<S2SV> case 'N' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "number-channels" ) == 0 ) //<S2SV> { //<S2SV> image -> number_channels = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "number-meta-channels" ) == 0 ) //<S2SV> { //<S2SV> image -> number_meta_channels = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 'o' : //<S2SV> case 'O' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "orientation" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> orientation ; //<S2SV> orientation = ParseCommandOption ( MagickOrientationOptions , //<S2SV> MagickFalse , options ) ; //<S2SV> if ( orientation < 0 ) //<S2SV> break ; //<S2SV> image -> orientation = ( OrientationType ) orientation ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'p' : //<S2SV> case 'P' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "page" ) == 0 ) //<S2SV> { //<S2SV> char //<S2SV> * geometry ; //<S2SV> geometry = GetPageGeometry ( options ) ; //<S2SV> ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; //<S2SV> geometry = DestroyString ( geometry ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "pixel-intensity" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> intensity ; //<S2SV> intensity = ParseCommandOption ( MagickPixelIntensityOptions , //<S2SV> MagickFalse , options ) ; //<S2SV> if ( intensity < 0 ) //<S2SV> break ; //<S2SV> image -> intensity = ( PixelIntensityMethod ) intensity ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( LocaleNCompare ( keyword , "profile:" , 8 ) == 0 ) || //<S2SV> ( LocaleNCompare ( keyword , "profile-" , 8 ) == 0 ) ) //<S2SV> { //<S2SV> if ( profiles == ( LinkedListInfo * ) NULL ) //<S2SV> profiles = NewLinkedList ( 0 ) ; //<S2SV> ( void ) AppendValueToLinkedList ( profiles , //<S2SV> AcquireString ( keyword + 8 ) ) ; //<S2SV> profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) //<S2SV> StringToLong ( options ) ) ; //<S2SV> if ( profile == ( StringInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> ( void ) SetImageProfile ( image , keyword + 8 , profile , exception ) ; //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'q' : //<S2SV> case 'Q' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "quality" ) == 0 ) //<S2SV> { //<S2SV> image -> quality = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'r' : //<S2SV> case 'R' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "red-primary" ) == 0 ) //<S2SV> { //<S2SV> flags = ParseGeometry ( options , & geometry_info ) ; //<S2SV> image -> chromaticity . red_primary . x = geometry_info . rho ; //<S2SV> if ( ( flags & SigmaValue ) != 0 ) //<S2SV> image -> chromaticity . red_primary . y = geometry_info . sigma ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "rendering-intent" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> rendering_intent ; //<S2SV> rendering_intent = ParseCommandOption ( MagickIntentOptions , //<S2SV> MagickFalse , options ) ; //<S2SV> if ( rendering_intent < 0 ) //<S2SV> break ; //<S2SV> image -> rendering_intent = ( RenderingIntent ) rendering_intent ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "resolution" ) == 0 ) //<S2SV> { //<S2SV> flags = ParseGeometry ( options , & geometry_info ) ; //<S2SV> image -> resolution . x = geometry_info . rho ; //<S2SV> image -> resolution . y = geometry_info . sigma ; //<S2SV> if ( ( flags & SigmaValue ) == 0 ) //<S2SV> image -> resolution . y = image -> resolution . x ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "rows" ) == 0 ) //<S2SV> { //<S2SV> image -> rows = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 's' : //<S2SV> case 'S' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "scene" ) == 0 ) //<S2SV> { //<S2SV> image -> scene = StringToUnsignedLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 't' : //<S2SV> case 'T' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "ticks-per-second" ) == 0 ) //<S2SV> { //<S2SV> image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "tile-offset" ) == 0 ) //<S2SV> { //<S2SV> char //<S2SV> * geometry ; //<S2SV> geometry = GetPageGeometry ( options ) ; //<S2SV> ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; //<S2SV> geometry = DestroyString ( geometry ) ; //<S2SV> } //<S2SV> if ( LocaleCompare ( keyword , "type" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> type ; //<S2SV> type = ParseCommandOption ( MagickTypeOptions , MagickFalse , //<S2SV> options ) ; //<S2SV> if ( type < 0 ) //<S2SV> break ; //<S2SV> image -> type = ( ImageType ) type ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'u' : //<S2SV> case 'U' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "units" ) == 0 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> units ; //<S2SV> units = ParseCommandOption ( MagickResolutionOptions , //<S2SV> MagickFalse , options ) ; //<S2SV> if ( units < 0 ) //<S2SV> break ; //<S2SV> image -> units = ( ResolutionType ) units ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'w' : //<S2SV> case 'W' : //<S2SV> { //<S2SV> if ( LocaleCompare ( keyword , "white-point" ) == 0 ) //<S2SV> { //<S2SV> flags = ParseGeometry ( options , & geometry_info ) ; //<S2SV> image -> chromaticity . white_point . x = geometry_info . rho ; //<S2SV> image -> chromaticity . white_point . y = geometry_info . sigma ; //<S2SV> if ( ( flags & SigmaValue ) == 0 ) //<S2SV> image -> chromaticity . white_point . y = //<S2SV> image -> chromaticity . white_point . x ; //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> ( void ) SetImageProperty ( image , keyword , options , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> options = DestroyString ( options ) ; //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( ( LocaleCompare ( id , "MagickCache" ) != 0 ) || //<S2SV> ( image -> storage_class == UndefinedClass ) || //<S2SV> ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || //<S2SV> ( image -> rows == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) //<S2SV> ThrowReaderException ( CacheError , "IncompatibleAPI" ) ; //<S2SV> if ( image -> montage != ( char * ) NULL ) //<S2SV> { //<S2SV> register char //<S2SV> * p ; //<S2SV> length = MagickPathExtent ; //<S2SV> image -> directory = AcquireString ( ( char * ) NULL ) ; //<S2SV> p = image -> directory ; //<S2SV> do //<S2SV> { //<S2SV> * p = '\\0' ; //<S2SV> if ( ( strlen ( image -> directory ) + MagickPathExtent ) >= length ) //<S2SV> { //<S2SV> length <<= 1 ; //<S2SV> image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , //<S2SV> length + MagickPathExtent , sizeof ( * image -> directory ) ) ; //<S2SV> if ( image -> directory == ( char * ) NULL ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> p = image -> directory + strlen ( image -> directory ) ; //<S2SV> } //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> * p ++ = ( char ) c ; //<S2SV> } while ( c != ( int ) '\\0' ) ; //<S2SV> } //<S2SV> if ( profiles != ( LinkedListInfo * ) NULL ) //<S2SV> { //<S2SV> const char //<S2SV> * name ; //<S2SV> const StringInfo //<S2SV> * profile ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> ResetLinkedListIterator ( profiles ) ; //<S2SV> name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; //<S2SV> while ( name != ( const char * ) NULL ) //<S2SV> { //<S2SV> profile = GetImageProfile ( image , name ) ; //<S2SV> if ( profile != ( StringInfo * ) NULL ) //<S2SV> { //<S2SV> p = GetStringInfoDatum ( profile ) ; //<S2SV> count = ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; //<S2SV> } //<S2SV> name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; //<S2SV> } //<S2SV> profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; //<S2SV> } //<S2SV> depth = GetImageQuantumDepth ( image , MagickFalse ) ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( image -> colors + 1 , //<S2SV> sizeof ( * image -> colormap ) ) ; //<S2SV> if ( image -> colormap == ( PixelInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> if ( image -> colors != 0 ) //<S2SV> { //<S2SV> size_t //<S2SV> packet_size ; //<S2SV> unsigned char //<S2SV> * colormap ; //<S2SV> packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; //<S2SV> colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , //<S2SV> packet_size * sizeof ( * colormap ) ) ; //<S2SV> if ( colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; //<S2SV> if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) //<S2SV> { //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> } //<S2SV> p = colormap ; //<S2SV> switch ( depth ) //<S2SV> { //<S2SV> default : //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "ImageDepthNotSupported" ) ; //<S2SV> case 8 : //<S2SV> { //<S2SV> unsigned char //<S2SV> pixel ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> p = PushCharPixel ( p , & pixel ) ; //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; //<S2SV> p = PushCharPixel ( p , & pixel ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; //<S2SV> p = PushCharPixel ( p , & pixel ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 16 : //<S2SV> { //<S2SV> unsigned short //<S2SV> pixel ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> p = PushShortPixel ( MSBEndian , p , & pixel ) ; //<S2SV> image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; //<S2SV> p = PushShortPixel ( MSBEndian , p , & pixel ) ; //<S2SV> image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; //<S2SV> p = PushShortPixel ( MSBEndian , p , & pixel ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 32 : //<S2SV> { //<S2SV> unsigned int //<S2SV> pixel ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> p = PushLongPixel ( MSBEndian , p , & pixel ) ; //<S2SV> image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; //<S2SV> p = PushLongPixel ( MSBEndian , p , & pixel ) ; //<S2SV> image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; //<S2SV> p = PushLongPixel ( MSBEndian , p , & pixel ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || //<S2SV> ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) ) //<S2SV> ThrowReaderException ( ImageError , "WidthOrHeightExceedsLimit" ) ; //<S2SV> status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowReaderException ( CacheError , "UnableToPersistPixelCache" ) ; //<S2SV> do //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; //<S2SV> if ( c != EOF ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( c != EOF ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 