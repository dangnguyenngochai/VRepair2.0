static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) //<S2SV> { //<S2SV> const Image //<S2SV> * next ; //<S2SV> PixelChannels //<S2SV> * * pixels ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> columns , //<S2SV> number_threads ; //<S2SV> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; //<S2SV> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , //<S2SV> sizeof ( * pixels ) ) ; //<S2SV> if ( pixels == ( PixelChannels * * ) NULL ) //<S2SV> return ( ( PixelChannels * * ) NULL ) ; //<S2SV> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; //<S2SV> columns = images -> columns ; //<S2SV> for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) //<S2SV> columns = MagickMax ( next -> columns , columns ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) //<S2SV> { //<S2SV> register ssize_t //<S2SV> j ; //<S2SV> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; //<S2SV> if ( pixels [ i ] == ( PixelChannels * ) NULL ) //<S2SV> return ( DestroyPixelThreadSet ( pixels ) ) ; //<S2SV> for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) //<S2SV> { //<S2SV> register ssize_t //<S2SV> k ; //<S2SV> for ( k = 0 ; k < MaxPixelChannels ; k ++ ) //<S2SV> pixels [ i ] [ j ] . channel [ k ] = 0.0 ; //<S2SV> } //<S2SV> } //<S2SV> return ( pixels ) ; //<S2SV> } //<S2SV> 