static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define RMT_EQUAL_RGB 1 //<S2SV> # define RMT_NONE 0 //<S2SV> # define RMT_RAW 2 //<S2SV> # define RT_STANDARD 1 //<S2SV> # define RT_ENCODED 2 //<S2SV> # define RT_FORMAT_RGB 3 //<S2SV> typedef struct _SUNInfo //<S2SV> { //<S2SV> unsigned int //<S2SV> magic , //<S2SV> width , //<S2SV> height , //<S2SV> depth , //<S2SV> length , //<S2SV> type , //<S2SV> maptype , //<S2SV> maplength ; //<S2SV> } SUNInfo ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> bit ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickSizeType //<S2SV> number_pixels ; //<S2SV> register IndexPacket //<S2SV> * indexes ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bytes_per_line , //<S2SV> extent , //<S2SV> height , //<S2SV> pixels_length , //<S2SV> quantum ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> SUNInfo //<S2SV> sun_info ; //<S2SV> unsigned char //<S2SV> * sun_data , //<S2SV> * sun_pixels ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; //<S2SV> sun_info . magic = ReadBlobMSBLong ( image ) ; //<S2SV> do //<S2SV> { //<S2SV> if ( sun_info . magic != 0x59a66a95 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> sun_info . width = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . height = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . depth = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . length = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . type = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . maptype = ReadBlobMSBLong ( image ) ; //<S2SV> sun_info . maplength = ReadBlobMSBLong ( image ) ; //<S2SV> extent = sun_info . height * sun_info . width ; //<S2SV> if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && //<S2SV> ( sun_info . type != RT_FORMAT_RGB ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( sun_info . depth != 1 ) && ( sun_info . depth != 8 ) && //<S2SV> ( sun_info . depth != 24 ) && ( sun_info . depth != 32 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && //<S2SV> ( sun_info . maptype != RMT_RAW ) ) //<S2SV> ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; //<S2SV> image -> columns = sun_info . width ; //<S2SV> image -> rows = sun_info . height ; //<S2SV> image -> depth = sun_info . depth <= 8 ? sun_info . depth : //<S2SV> MAGICKCORE_QUANTUM_DEPTH ; //<S2SV> if ( sun_info . depth < 24 ) //<S2SV> { //<S2SV> size_t //<S2SV> one ; //<S2SV> image -> colors = sun_info . maplength ; //<S2SV> one = 1 ; //<S2SV> if ( sun_info . maptype == RMT_NONE ) //<S2SV> image -> colors = one << sun_info . depth ; //<S2SV> if ( sun_info . maptype == RMT_EQUAL_RGB ) //<S2SV> image -> colors = sun_info . maplength / 3 ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> switch ( sun_info . maptype ) //<S2SV> { //<S2SV> case RMT_NONE : //<S2SV> break ; //<S2SV> case RMT_EQUAL_RGB : //<S2SV> { //<S2SV> unsigned char //<S2SV> * sun_colormap ; //<S2SV> sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , //<S2SV> sizeof ( * sun_colormap ) ) ; //<S2SV> if ( sun_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , image -> colors , sun_colormap ) ; //<S2SV> if ( count != ( ssize_t ) image -> colors ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( sun_colormap [ i ] ) ; //<S2SV> count = ReadBlob ( image , image -> colors , sun_colormap ) ; //<S2SV> if ( count != ( ssize_t ) image -> colors ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( sun_colormap [ i ] ) ; //<S2SV> count = ReadBlob ( image , image -> colors , sun_colormap ) ; //<S2SV> if ( count != ( ssize_t ) image -> colors ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( sun_colormap [ i ] ) ; //<S2SV> sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case RMT_RAW : //<S2SV> { //<S2SV> unsigned char //<S2SV> * sun_colormap ; //<S2SV> sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , //<S2SV> sizeof ( * sun_colormap ) ) ; //<S2SV> if ( sun_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; //<S2SV> if ( count != ( ssize_t ) sun_info . maplength ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; //<S2SV> sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> image -> matte = sun_info . depth == 32 ? MagickTrue : MagickFalse ; //<S2SV> image -> columns = sun_info . width ; //<S2SV> image -> rows = sun_info . height ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> if ( sun_info . length == 0 ) //<S2SV> ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; //<S2SV> number_pixels = ( MagickSizeType ) ( image -> columns * image -> rows ) ; //<S2SV> if ( ( sun_info . type != RT_ENCODED ) && //<S2SV> ( ( number_pixels * sun_info . depth ) > ( 8UL * sun_info . length ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( HeapOverflowSanityCheck ( sun_info . width , sun_info . depth ) != MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> bytes_per_line = sun_info . width * sun_info . depth ; //<S2SV> sun_data = ( unsigned char * ) AcquireQuantumMemory ( sun_info . length , //<S2SV> sizeof ( * sun_data ) ) ; //<S2SV> if ( sun_data == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; //<S2SV> if ( count != ( ssize_t ) sun_info . length ) //<S2SV> { //<S2SV> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> } //<S2SV> height = sun_info . height ; //<S2SV> if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || //<S2SV> ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) //<S2SV> { //<S2SV> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> quantum = sun_info . depth == 1 ? 15 : 7 ; //<S2SV> bytes_per_line += quantum ; //<S2SV> bytes_per_line <<= 1 ; //<S2SV> if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + quantum ) ) //<S2SV> { //<S2SV> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> bytes_per_line >>= 4 ; //<S2SV> if ( HeapOverflowSanityCheck ( height , bytes_per_line ) != MagickFalse ) //<S2SV> { //<S2SV> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> pixels_length = height * bytes_per_line ; //<S2SV> sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length , //<S2SV> sizeof ( * sun_pixels ) ) ; //<S2SV> if ( sun_pixels == ( unsigned char * ) NULL ) //<S2SV> { //<S2SV> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> ResetMagickMemory ( sun_pixels , 0 , pixels_length * sizeof ( * sun_pixels ) ) ; //<S2SV> if ( sun_info . type == RT_ENCODED ) //<S2SV> { //<S2SV> status = DecodeImage ( sun_data , sun_info . length , sun_pixels , pixels_length ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( sun_info . length > pixels_length ) //<S2SV> { //<S2SV> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; //<S2SV> sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; //<S2SV> } //<S2SV> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; //<S2SV> p = sun_pixels ; //<S2SV> if ( sun_info . depth == 1 ) //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 7 ; bit >= 0 ; bit -- ) //<S2SV> SetPixelIndex ( indexes + x + 7 - bit , ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 8 ) != 0 ) //<S2SV> { //<S2SV> for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) //<S2SV> SetPixelIndex ( indexes + x + 7 - bit , ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) //<S2SV> p ++ ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( indexes + x , ConstrainColormapIndex ( image , * p ) ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( image -> columns % 2 ) != 0 ) //<S2SV> p ++ ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> size_t //<S2SV> bytes_per_pixel ; //<S2SV> bytes_per_pixel = 3 ; //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> bytes_per_pixel ++ ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> if ( sun_info . type == RT_STANDARD ) //<S2SV> { //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> } //<S2SV> if ( image -> colors != 0 ) //<S2SV> { //<S2SV> SetPixelRed ( q , image -> colormap [ ( ssize_t ) //<S2SV> GetPixelRed ( q ) ] . red ) ; //<S2SV> SetPixelGreen ( q , image -> colormap [ ( ssize_t ) //<S2SV> GetPixelGreen ( q ) ] . green ) ; //<S2SV> SetPixelBlue ( q , image -> colormap [ ( ssize_t ) //<S2SV> GetPixelBlue ( q ) ] . blue ) ; //<S2SV> } //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) //<S2SV> p ++ ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> sun_info . magic = ReadBlobMSBLong ( image ) ; //<S2SV> if ( sun_info . magic == 0x59a66a95 ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( sun_info . magic == 0x59a66a95 ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 