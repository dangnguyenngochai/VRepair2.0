MagickExport void * AcquireAlignedMemory ( const size_t count , const size_t quantum ) //<S2SV> { //<S2SV> # define AlignedExtent ( size , alignment ) ( ( ( size ) + ( ( alignment ) - 1 ) ) & ~ ( ( alignment ) - 1 ) ) //<S2SV> size_t //<S2SV> alignment , //<S2SV> extent , //<S2SV> size ; //<S2SV> void //<S2SV> * memory ; //<S2SV> if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) //<S2SV> return ( ( void * ) NULL ) ; //<S2SV> memory = NULL ; //<S2SV> alignment = CACHE_LINE_SIZE ; //<S2SV> size = count * quantum ; //<S2SV> extent = AlignedExtent ( size , alignment ) ; //<S2SV> if ( ( size == 0 ) || ( alignment < sizeof ( void * ) ) || ( extent < size ) ) //<S2SV> return ( ( void * ) NULL ) ; //<S2SV> # if defined ( MAGICKCORE_HAVE_POSIX_MEMALIGN ) //<S2SV> if ( posix_memalign ( & memory , alignment , extent ) != 0 ) //<S2SV> memory = NULL ; //<S2SV> # elif defined ( MAGICKCORE_HAVE__ALIGNED_MALLOC ) //<S2SV> memory = _aligned_malloc ( extent , alignment ) ; //<S2SV> # else //<S2SV> { //<S2SV> void //<S2SV> * p ; //<S2SV> extent = ( size + alignment - 1 ) + sizeof ( void * ) ; //<S2SV> if ( extent > size ) //<S2SV> { //<S2SV> p = malloc ( extent ) ; //<S2SV> if ( p != NULL ) //<S2SV> { //<S2SV> memory = ( void * ) AlignedExtent ( ( size_t ) p + sizeof ( void * ) , alignment ) ; //<S2SV> * ( ( void * * ) memory - 1 ) = p ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> return ( memory ) ; //<S2SV> } //<S2SV> 