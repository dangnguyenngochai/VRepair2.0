static Image * ReadCALSImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> filename [ MagickPathExtent ] , //<S2SV> header [ MagickPathExtent ] , //<S2SV> message [ MagickPathExtent ] ; //<S2SV> FILE //<S2SV> * file ; //<S2SV> Image //<S2SV> * image ; //<S2SV> ImageInfo //<S2SV> * read_info ; //<S2SV> int //<S2SV> c , //<S2SV> unique_file ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> unsigned long //<S2SV> density , //<S2SV> direction , //<S2SV> height , //<S2SV> orientation , //<S2SV> pel_path , //<S2SV> type , //<S2SV> width ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> ( void ) memset ( header , 0 , sizeof ( header ) ) ; //<S2SV> density = 0 ; //<S2SV> direction = 0 ; //<S2SV> orientation = 1 ; //<S2SV> pel_path = 0 ; //<S2SV> type = 1 ; //<S2SV> width = 0 ; //<S2SV> height = 0 ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> { //<S2SV> if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) //<S2SV> break ; //<S2SV> switch ( * header ) //<S2SV> { //<S2SV> case 'R' : //<S2SV> case 'r' : //<S2SV> { //<S2SV> if ( LocaleNCompare ( header , "rdensty:" , 8 ) == 0 ) //<S2SV> { //<S2SV> ( void ) sscanf ( header + 8 , "%lu" , & density ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( header , "rpelcnt:" , 8 ) == 0 ) //<S2SV> { //<S2SV> ( void ) sscanf ( header + 8 , "%lu,%lu" , & width , & height ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( header , "rorient:" , 8 ) == 0 ) //<S2SV> { //<S2SV> ( void ) sscanf ( header + 8 , "%lu,%lu" , & pel_path , & direction ) ; //<S2SV> if ( pel_path == 90 ) //<S2SV> orientation = 5 ; //<S2SV> else //<S2SV> if ( pel_path == 180 ) //<S2SV> orientation = 3 ; //<S2SV> else //<S2SV> if ( pel_path == 270 ) //<S2SV> orientation = 7 ; //<S2SV> if ( direction == 90 ) //<S2SV> orientation ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( LocaleNCompare ( header , "rtype:" , 6 ) == 0 ) //<S2SV> { //<S2SV> ( void ) sscanf ( header + 6 , "%lu" , & type ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> file = ( FILE * ) NULL ; //<S2SV> unique_file = AcquireUniqueFileResource ( filename ) ; //<S2SV> if ( unique_file != - 1 ) //<S2SV> file = fdopen ( unique_file , "wb" ) ; //<S2SV> if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) //<S2SV> ThrowImageException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; //<S2SV> while ( ( c = ReadBlobByte ( image ) ) != EOF ) //<S2SV> if ( fputc ( c , file ) != c ) //<S2SV> break ; //<S2SV> ( void ) fclose ( file ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> image = DestroyImage ( image ) ; //<S2SV> read_info = CloneImageInfo ( image_info ) ; //<S2SV> SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; //<S2SV> ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "group4:%s" , //<S2SV> filename ) ; //<S2SV> ( void ) FormatLocaleString ( message , MagickPathExtent , "%lux%lu" , width , height ) ; //<S2SV> ( void ) CloneString ( & read_info -> size , message ) ; //<S2SV> ( void ) FormatLocaleString ( message , MagickPathExtent , "%lu" , density ) ; //<S2SV> ( void ) CloneString ( & read_info -> density , message ) ; //<S2SV> read_info -> orientation = ( OrientationType ) orientation ; //<S2SV> image = ReadImage ( read_info , exception ) ; //<S2SV> if ( image != ( Image * ) NULL ) //<S2SV> { //<S2SV> ( void ) CopyMagickString ( image -> filename , image_info -> filename , //<S2SV> MagickPathExtent ) ; //<S2SV> ( void ) CopyMagickString ( image -> magick_filename , image_info -> filename , //<S2SV> MagickPathExtent ) ; //<S2SV> ( void ) CopyMagickString ( image -> magick , "CALS" , MagickPathExtent ) ; //<S2SV> } //<S2SV> read_info = DestroyImageInfo ( read_info ) ; //<S2SV> ( void ) RelinquishUniqueFileResource ( filename ) ; //<S2SV> return ( image ) ; //<S2SV> } //<S2SV> 