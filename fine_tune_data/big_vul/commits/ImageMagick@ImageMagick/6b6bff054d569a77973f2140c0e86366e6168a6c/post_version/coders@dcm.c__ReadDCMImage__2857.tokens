static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define ThrowDCMException ( exception , message ) \\\n{ if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} //<S2SV> char //<S2SV> explicit_vr [ MagickPathExtent ] , //<S2SV> implicit_vr [ MagickPathExtent ] , //<S2SV> magick [ MagickPathExtent ] , //<S2SV> photometric [ MagickPathExtent ] ; //<S2SV> DCMInfo //<S2SV> info ; //<S2SV> DCMStreamInfo //<S2SV> * stream_info ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> * bluemap , //<S2SV> datum , //<S2SV> * greenmap , //<S2SV> * graymap , //<S2SV> * redmap ; //<S2SV> MagickBooleanType //<S2SV> explicit_file , //<S2SV> explicit_retry , //<S2SV> use_explicit ; //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> colors , //<S2SV> height , //<S2SV> length , //<S2SV> number_scenes , //<S2SV> quantum , //<S2SV> status , //<S2SV> width ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> scene ; //<S2SV> unsigned char //<S2SV> * data ; //<S2SV> unsigned short //<S2SV> group , //<S2SV> element ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image -> depth = 8UL ; //<S2SV> image -> endian = LSBEndian ; //<S2SV> ( void ) memset ( & info , 0 , sizeof ( info ) ) ; //<S2SV> data = ( unsigned char * ) NULL ; //<S2SV> graymap = ( int * ) NULL ; //<S2SV> redmap = ( int * ) NULL ; //<S2SV> greenmap = ( int * ) NULL ; //<S2SV> bluemap = ( int * ) NULL ; //<S2SV> stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; //<S2SV> if ( stream_info == ( DCMStreamInfo * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; //<S2SV> count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; //<S2SV> if ( count != 128 ) //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; //<S2SV> if ( ( count != 4 ) || ( LocaleNCompare ( magick , "DICM" , 4 ) != 0 ) ) //<S2SV> { //<S2SV> offset = SeekBlob ( image , 0L , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> ( void ) CopyMagickString ( photometric , "MONOCHROME1<S2SV_blank>" , MagickPathExtent ) ; //<S2SV> info . bits_allocated = 8 ; //<S2SV> info . bytes_per_pixel = 1 ; //<S2SV> info . depth = 8 ; //<S2SV> info . mask = 0xffff ; //<S2SV> info . max_value = 255UL ; //<S2SV> info . samples_per_pixel = 1 ; //<S2SV> info . signed_data = ( ~ 0UL ) ; //<S2SV> info . rescale_slope = 1.0 ; //<S2SV> data = ( unsigned char * ) NULL ; //<S2SV> element = 0 ; //<S2SV> explicit_vr [ 2 ] = '\\0' ; //<S2SV> explicit_file = MagickFalse ; //<S2SV> colors = 0 ; //<S2SV> redmap = ( int * ) NULL ; //<S2SV> greenmap = ( int * ) NULL ; //<S2SV> bluemap = ( int * ) NULL ; //<S2SV> graymap = ( int * ) NULL ; //<S2SV> height = 0 ; //<S2SV> number_scenes = 1 ; //<S2SV> use_explicit = MagickFalse ; //<S2SV> explicit_retry = MagickFalse ; //<S2SV> width = 0 ; //<S2SV> while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) //<S2SV> { //<S2SV> for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) //<S2SV> { //<S2SV> image -> offset = ( ssize_t ) TellBlob ( image ) ; //<S2SV> group = ReadBlobLSBShort ( image ) ; //<S2SV> element = ReadBlobLSBShort ( image ) ; //<S2SV> if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) //<S2SV> break ; //<S2SV> if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) //<S2SV> { //<S2SV> group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; //<S2SV> element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; //<S2SV> } //<S2SV> quantum = 0 ; //<S2SV> for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) //<S2SV> if ( ( group == dicom_info [ i ] . group ) && //<S2SV> ( element == dicom_info [ i ] . element ) ) //<S2SV> break ; //<S2SV> ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; //<S2SV> count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; //<S2SV> if ( count != 2 ) //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) //<S2SV> explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && //<S2SV> ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || //<S2SV> ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; //<S2SV> if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , "xs" , 2 ) == 0 ) ) //<S2SV> ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; //<S2SV> if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , "!!" , 2 ) == 0 ) ) //<S2SV> { //<S2SV> offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> quantum = 4 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> quantum = 2 ; //<S2SV> if ( ( strncmp ( explicit_vr , "OB" , 2 ) == 0 ) || //<S2SV> ( strncmp ( explicit_vr , "UN" , 2 ) == 0 ) || //<S2SV> ( strncmp ( explicit_vr , "OW" , 2 ) == 0 ) || //<S2SV> ( strncmp ( explicit_vr , "SQ" , 2 ) == 0 ) ) //<S2SV> { //<S2SV> ( void ) ReadBlobLSBShort ( image ) ; //<S2SV> quantum = 4 ; //<S2SV> } //<S2SV> } //<S2SV> datum = 0 ; //<S2SV> if ( quantum == 4 ) //<S2SV> { //<S2SV> if ( group == 0x0002 ) //<S2SV> datum = ReadBlobLSBSignedLong ( image ) ; //<S2SV> else //<S2SV> datum = ReadBlobSignedLong ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( quantum == 2 ) //<S2SV> { //<S2SV> if ( group == 0x0002 ) //<S2SV> datum = ReadBlobLSBSignedShort ( image ) ; //<S2SV> else //<S2SV> datum = ReadBlobSignedShort ( image ) ; //<S2SV> } //<S2SV> quantum = 0 ; //<S2SV> length = 1 ; //<S2SV> if ( datum != 0 ) //<S2SV> { //<S2SV> if ( ( strncmp ( implicit_vr , "OW" , 2 ) == 0 ) || //<S2SV> ( strncmp ( implicit_vr , "SS" , 2 ) == 0 ) || //<S2SV> ( strncmp ( implicit_vr , "US" , 2 ) == 0 ) ) //<S2SV> quantum = 2 ; //<S2SV> else //<S2SV> if ( ( strncmp ( implicit_vr , "FL" , 2 ) == 0 ) || //<S2SV> ( strncmp ( implicit_vr , "OF" , 2 ) == 0 ) || //<S2SV> ( strncmp ( implicit_vr , "SL" , 2 ) == 0 ) || //<S2SV> ( strncmp ( implicit_vr , "UL" , 2 ) == 0 ) ) //<S2SV> quantum = 4 ; //<S2SV> else //<S2SV> if ( strncmp ( implicit_vr , "FD" , 2 ) == 0 ) //<S2SV> quantum = 8 ; //<S2SV> else //<S2SV> quantum = 1 ; //<S2SV> if ( datum != ~ 0 ) //<S2SV> length = ( size_t ) datum / quantum ; //<S2SV> else //<S2SV> { //<S2SV> quantum = 0 ; //<S2SV> length = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> { //<S2SV> if ( use_explicit == MagickFalse ) //<S2SV> explicit_vr [ 0 ] = '\\0' ; //<S2SV> for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) //<S2SV> if ( ( group == dicom_info [ i ] . group ) && //<S2SV> ( element == dicom_info [ i ] . element ) ) //<S2SV> break ; //<S2SV> ( void ) FormatLocaleFile ( stdout , "0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)" , //<S2SV> ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , //<S2SV> ( unsigned long ) group , ( unsigned long ) element ) ; //<S2SV> if ( dicom_info [ i ] . description != ( char * ) NULL ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "<S2SV_blank>%s" , dicom_info [ i ] . description ) ; //<S2SV> ( void ) FormatLocaleFile ( stdout , ":<S2SV_blank>" ) ; //<S2SV> } //<S2SV> if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) //<S2SV> { //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> data = ( unsigned char * ) NULL ; //<S2SV> if ( ( length == 1 ) && ( quantum == 1 ) ) //<S2SV> datum = ReadBlobByte ( image ) ; //<S2SV> else //<S2SV> if ( ( length == 1 ) && ( quantum == 2 ) ) //<S2SV> { //<S2SV> if ( group == 0x0002 ) //<S2SV> datum = ReadBlobLSBSignedShort ( image ) ; //<S2SV> else //<S2SV> datum = ReadBlobSignedShort ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( ( length == 1 ) && ( quantum == 4 ) ) //<S2SV> { //<S2SV> if ( group == 0x0002 ) //<S2SV> datum = ReadBlobLSBSignedLong ( image ) ; //<S2SV> else //<S2SV> datum = ReadBlobSignedLong ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( ( quantum != 0 ) && ( length != 0 ) ) //<S2SV> { //<S2SV> if ( length > ( size_t ) GetBlobSize ( image ) ) //<S2SV> ThrowDCMException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> if ( ~ length >= 1 ) //<S2SV> data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * //<S2SV> sizeof ( * data ) ) ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; //<S2SV> if ( count != ( ssize_t ) ( quantum * length ) ) //<S2SV> { //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "count=%d<S2SV_blank>quantum=%d<S2SV_blank>" //<S2SV> "length=%d<S2SV_blank>group=%d\\n" , ( int ) count , ( int ) quantum , ( int ) //<S2SV> length , ( int ) group ) ; //<S2SV> ThrowDCMException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> } //<S2SV> data [ length * quantum ] = '\\0' ; //<S2SV> } //<S2SV> if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> switch ( group ) //<S2SV> { //<S2SV> case 0x0002 : //<S2SV> { //<S2SV> switch ( element ) //<S2SV> { //<S2SV> case 0x0010 : //<S2SV> { //<S2SV> char //<S2SV> transfer_syntax [ MagickPathExtent ] ; //<S2SV> if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) //<S2SV> { //<S2SV> explicit_retry = MagickTrue ; //<S2SV> ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; //<S2SV> group = 0 ; //<S2SV> element = 0 ; //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , //<S2SV> "Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> * transfer_syntax = '\\0' ; //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , //<S2SV> MagickPathExtent ) ; //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "transfer_syntax=%s\\n" , //<S2SV> ( const char * ) transfer_syntax ) ; //<S2SV> if ( strncmp ( transfer_syntax , "1.2.840.10008.1.2" , 17 ) == 0 ) //<S2SV> { //<S2SV> int //<S2SV> subtype , //<S2SV> type ; //<S2SV> type = 1 ; //<S2SV> subtype = 0 ; //<S2SV> if ( strlen ( transfer_syntax ) > 17 ) //<S2SV> { //<S2SV> count = ( ssize_t ) sscanf ( transfer_syntax + 17 , ".%d.%d" , & type , //<S2SV> & subtype ) ; //<S2SV> if ( count < 1 ) //<S2SV> ThrowDCMException ( CorruptImageError , //<S2SV> "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> switch ( type ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> image -> endian = LSBEndian ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> image -> endian = MSBEndian ; //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) //<S2SV> image -> compression = JPEGCompression ; //<S2SV> else //<S2SV> if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) //<S2SV> image -> compression = JPEG2000Compression ; //<S2SV> else //<S2SV> image -> compression = JPEGCompression ; //<S2SV> break ; //<S2SV> } //<S2SV> case 5 : //<S2SV> { //<S2SV> image -> compression = RLECompression ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0028 : //<S2SV> { //<S2SV> switch ( element ) //<S2SV> { //<S2SV> case 0x0002 : //<S2SV> { //<S2SV> info . samples_per_pixel = ( size_t ) datum ; //<S2SV> if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0004 : //<S2SV> { //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) //<S2SV> photometric [ i ] = ( char ) data [ i ] ; //<S2SV> photometric [ i ] = '\\0' ; //<S2SV> info . polarity = LocaleCompare ( photometric , "MONOCHROME1<S2SV_blank>" ) == 0 ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0006 : //<S2SV> { //<S2SV> if ( datum == 1 ) //<S2SV> image -> interlace = PlaneInterlace ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0008 : //<S2SV> { //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> number_scenes = StringToUnsignedLong ( ( char * ) data ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0010 : //<S2SV> { //<S2SV> height = ( size_t ) datum ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0011 : //<S2SV> { //<S2SV> width = ( size_t ) datum ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0100 : //<S2SV> { //<S2SV> info . bits_allocated = ( size_t ) datum ; //<S2SV> info . bytes_per_pixel = 1 ; //<S2SV> if ( datum > 8 ) //<S2SV> info . bytes_per_pixel = 2 ; //<S2SV> info . depth = info . bits_allocated ; //<S2SV> if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> info . max_value = ( 1UL << info . bits_allocated ) - 1 ; //<S2SV> image -> depth = info . depth ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0101 : //<S2SV> { //<S2SV> info . significant_bits = ( size_t ) datum ; //<S2SV> info . bytes_per_pixel = 1 ; //<S2SV> if ( info . significant_bits > 8 ) //<S2SV> info . bytes_per_pixel = 2 ; //<S2SV> info . depth = info . significant_bits ; //<S2SV> if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> info . max_value = ( 1UL << info . significant_bits ) - 1 ; //<S2SV> info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; //<S2SV> image -> depth = info . depth ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0102 : //<S2SV> { //<S2SV> break ; //<S2SV> } //<S2SV> case 0x0103 : //<S2SV> { //<S2SV> info . signed_data = ( size_t ) datum ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1050 : //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1051 : //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1052 : //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> info . rescale_intercept = StringToDouble ( ( char * ) data , //<S2SV> ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1053 : //<S2SV> { //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1200 : //<S2SV> case 0x3006 : //<S2SV> { //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> colors = ( size_t ) ( length / info . bytes_per_pixel ) ; //<S2SV> datum = ( int ) colors ; //<S2SV> if ( graymap != ( int * ) NULL ) //<S2SV> graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; //<S2SV> graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , //<S2SV> sizeof ( * graymap ) ) ; //<S2SV> if ( graymap == ( int * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * //<S2SV> sizeof ( * graymap ) ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> if ( info . bytes_per_pixel == 1 ) //<S2SV> graymap [ i ] = ( int ) data [ i ] ; //<S2SV> else //<S2SV> graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1201 : //<S2SV> { //<S2SV> unsigned short //<S2SV> index ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> colors = ( size_t ) ( length / 2 ) ; //<S2SV> datum = ( int ) colors ; //<S2SV> if ( redmap != ( int * ) NULL ) //<S2SV> redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; //<S2SV> redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , //<S2SV> sizeof ( * redmap ) ) ; //<S2SV> if ( redmap == ( int * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * //<S2SV> sizeof ( * redmap ) ) ; //<S2SV> p = data ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> if ( image -> endian == MSBEndian ) //<S2SV> index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; //<S2SV> else //<S2SV> index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; //<S2SV> redmap [ i ] = ( int ) index ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1202 : //<S2SV> { //<S2SV> unsigned short //<S2SV> index ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> colors = ( size_t ) ( length / 2 ) ; //<S2SV> datum = ( int ) colors ; //<S2SV> if ( greenmap != ( int * ) NULL ) //<S2SV> greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; //<S2SV> greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , //<S2SV> sizeof ( * greenmap ) ) ; //<S2SV> if ( greenmap == ( int * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * //<S2SV> sizeof ( * greenmap ) ) ; //<S2SV> p = data ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> if ( image -> endian == MSBEndian ) //<S2SV> index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; //<S2SV> else //<S2SV> index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; //<S2SV> greenmap [ i ] = ( int ) index ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x1203 : //<S2SV> { //<S2SV> unsigned short //<S2SV> index ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> break ; //<S2SV> colors = ( size_t ) ( length / 2 ) ; //<S2SV> datum = ( int ) colors ; //<S2SV> if ( bluemap != ( int * ) NULL ) //<S2SV> bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; //<S2SV> bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , //<S2SV> sizeof ( * bluemap ) ) ; //<S2SV> if ( bluemap == ( int * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * //<S2SV> sizeof ( * bluemap ) ) ; //<S2SV> p = data ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> if ( image -> endian == MSBEndian ) //<S2SV> index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; //<S2SV> else //<S2SV> index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; //<S2SV> bluemap [ i ] = ( int ) index ; //<S2SV> p += 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 0x2050 : //<S2SV> { //<S2SV> switch ( element ) //<S2SV> { //<S2SV> case 0x0020 : //<S2SV> { //<S2SV> if ( ( data != ( unsigned char * ) NULL ) && //<S2SV> ( strncmp ( ( char * ) data , "INVERSE" , 7 ) == 0 ) ) //<S2SV> info . polarity = MagickTrue ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> { //<S2SV> char //<S2SV> * attribute ; //<S2SV> for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) //<S2SV> if ( ( group == dicom_info [ i ] . group ) && //<S2SV> ( element == dicom_info [ i ] . element ) ) //<S2SV> break ; //<S2SV> if ( dicom_info [ i ] . description != ( char * ) NULL ) //<S2SV> { //<S2SV> attribute = AcquireString ( "dcm:" ) ; //<S2SV> ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) //<S2SV> if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) //<S2SV> { //<S2SV> ( void ) SubstituteString ( & attribute , "<S2SV_blank>" , "" ) ; //<S2SV> ( void ) SetImageProperty ( image , attribute , ( char * ) data , //<S2SV> exception ) ; //<S2SV> } //<S2SV> attribute = DestroyString ( attribute ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( image_info -> verbose != MagickFalse ) //<S2SV> { //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "%d\\n" , datum ) ; //<S2SV> else //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) //<S2SV> if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) //<S2SV> { //<S2SV> ssize_t //<S2SV> j ; //<S2SV> datum = 0 ; //<S2SV> for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) //<S2SV> datum = ( 256 * datum + data [ j ] ) ; //<S2SV> ( void ) FormatLocaleFile ( stdout , "%d" , datum ) ; //<S2SV> } //<S2SV> else //<S2SV> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) //<S2SV> if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) //<S2SV> ( void ) FormatLocaleFile ( stdout , "%c" , data [ i ] ) ; //<S2SV> else //<S2SV> ( void ) FormatLocaleFile ( stdout , "%c" , '.' ) ; //<S2SV> ( void ) FormatLocaleFile ( stdout , "\\n" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( data != ( unsigned char * ) NULL ) //<S2SV> data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) //<S2SV> { //<S2SV> Image //<S2SV> * last ; //<S2SV> last = RemoveLastImageFromList ( & image ) ; //<S2SV> if ( last != ( Image * ) NULL ) //<S2SV> last = DestroyImage ( last ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( width == 0 ) || ( height == 0 ) ) //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> image -> columns = ( size_t ) width ; //<S2SV> image -> rows = ( size_t ) height ; //<S2SV> if ( info . signed_data == 0xffff ) //<S2SV> info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; //<S2SV> if ( ( image -> compression == JPEGCompression ) || //<S2SV> ( image -> compression == JPEG2000Compression ) ) //<S2SV> { //<S2SV> Image //<S2SV> * images ; //<S2SV> ImageInfo //<S2SV> * read_info ; //<S2SV> int //<S2SV> c ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) //<S2SV> if ( ReadBlobByte ( image ) == EOF ) //<S2SV> break ; //<S2SV> ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | //<S2SV> ReadBlobLSBShort ( image ) ) ; //<S2SV> length = ( size_t ) ReadBlobLSBLong ( image ) ; //<S2SV> if ( length > ( size_t ) GetBlobSize ( image ) ) //<S2SV> ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> stream_info -> offset_count = length >> 2 ; //<S2SV> if ( stream_info -> offset_count != 0 ) //<S2SV> { //<S2SV> if ( stream_info -> offsets != ( ssize_t * ) NULL ) //<S2SV> stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( //<S2SV> stream_info -> offsets ) ; //<S2SV> stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( //<S2SV> stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; //<S2SV> if ( stream_info -> offsets == ( ssize_t * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) //<S2SV> stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; //<S2SV> offset = TellBlob ( image ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) //<S2SV> stream_info -> offsets [ i ] += offset ; //<S2SV> } //<S2SV> read_info = CloneImageInfo ( image_info ) ; //<S2SV> SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; //<S2SV> images = NewImageList ( ) ; //<S2SV> for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) //<S2SV> { //<S2SV> char //<S2SV> filename [ MagickPathExtent ] ; //<S2SV> const char //<S2SV> * property ; //<S2SV> FILE //<S2SV> * file ; //<S2SV> Image //<S2SV> * jpeg_image ; //<S2SV> int //<S2SV> unique_file ; //<S2SV> unsigned int //<S2SV> tag ; //<S2SV> tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | //<S2SV> ReadBlobLSBShort ( image ) ; //<S2SV> length = ( size_t ) ReadBlobLSBLong ( image ) ; //<S2SV> if ( tag == 0xFFFEE0DD ) //<S2SV> break ; //<S2SV> if ( tag != 0xFFFEE000 ) //<S2SV> { //<S2SV> read_info = DestroyImageInfo ( read_info ) ; //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> file = ( FILE * ) NULL ; //<S2SV> unique_file = AcquireUniqueFileResource ( filename ) ; //<S2SV> if ( unique_file != - 1 ) //<S2SV> file = fdopen ( unique_file , "wb" ) ; //<S2SV> if ( file == ( FILE * ) NULL ) //<S2SV> { //<S2SV> ( void ) RelinquishUniqueFileResource ( filename ) ; //<S2SV> ThrowFileException ( exception , FileOpenError , //<S2SV> "UnableToCreateTemporaryFile" , filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( c = EOF ; length != 0 ; length -- ) //<S2SV> { //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( fputc ( c , file ) != c ) //<S2SV> break ; //<S2SV> } //<S2SV> ( void ) fclose ( file ) ; //<S2SV> if ( c == EOF ) //<S2SV> break ; //<S2SV> ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , //<S2SV> "jpeg:%s" , filename ) ; //<S2SV> if ( image -> compression == JPEG2000Compression ) //<S2SV> ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , //<S2SV> "j2k:%s" , filename ) ; //<S2SV> jpeg_image = ReadImage ( read_info , exception ) ; //<S2SV> if ( jpeg_image != ( Image * ) NULL ) //<S2SV> { //<S2SV> ResetImagePropertyIterator ( image ) ; //<S2SV> property = GetNextImageProperty ( image ) ; //<S2SV> while ( property != ( const char * ) NULL ) //<S2SV> { //<S2SV> ( void ) SetImageProperty ( jpeg_image , property , //<S2SV> GetImageProperty ( image , property , exception ) , exception ) ; //<S2SV> property = GetNextImageProperty ( image ) ; //<S2SV> } //<S2SV> AppendImageToList ( & images , jpeg_image ) ; //<S2SV> } //<S2SV> ( void ) RelinquishUniqueFileResource ( filename ) ; //<S2SV> } //<S2SV> read_info = DestroyImageInfo ( read_info ) ; //<S2SV> if ( stream_info -> offsets != ( ssize_t * ) NULL ) //<S2SV> stream_info -> offsets = ( ssize_t * ) //<S2SV> RelinquishMagickMemory ( stream_info -> offsets ) ; //<S2SV> stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; //<S2SV> if ( info . scale != ( Quantum * ) NULL ) //<S2SV> info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; //<S2SV> if ( graymap != ( int * ) NULL ) //<S2SV> graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; //<S2SV> if ( bluemap != ( int * ) NULL ) //<S2SV> bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; //<S2SV> if ( greenmap != ( int * ) NULL ) //<S2SV> greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; //<S2SV> if ( redmap != ( int * ) NULL ) //<S2SV> redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( GetFirstImageInList ( images ) ) ; //<S2SV> } //<S2SV> if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) //<S2SV> { //<S2SV> QuantumAny //<S2SV> range ; //<S2SV> length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; //<S2SV> if ( length > ( size_t ) GetBlobSize ( image ) ) //<S2SV> ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> if ( info . scale != ( Quantum * ) NULL ) //<S2SV> info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; //<S2SV> info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , //<S2SV> sizeof ( * info . scale ) ) ; //<S2SV> if ( info . scale == ( Quantum * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * //<S2SV> sizeof ( * info . scale ) ) ; //<S2SV> range = GetQuantumRange ( info . depth ) ; //<S2SV> for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) //<S2SV> info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; //<S2SV> } //<S2SV> if ( image -> compression == RLECompression ) //<S2SV> { //<S2SV> unsigned int //<S2SV> tag ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) //<S2SV> { //<S2SV> int //<S2SV> c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | //<S2SV> ReadBlobLSBShort ( image ) ; //<S2SV> ( void ) tag ; //<S2SV> length = ( size_t ) ReadBlobLSBLong ( image ) ; //<S2SV> if ( length > ( size_t ) GetBlobSize ( image ) ) //<S2SV> ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> stream_info -> offset_count = length >> 2 ; //<S2SV> if ( stream_info -> offset_count != 0 ) //<S2SV> { //<S2SV> stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( //<S2SV> stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; //<S2SV> if ( stream_info -> offsets == ( ssize_t * ) NULL ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) //<S2SV> { //<S2SV> stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> offset = TellBlob ( image ) + 8 ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) //<S2SV> stream_info -> offsets [ i ] += offset ; //<S2SV> } //<S2SV> } //<S2SV> for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) //<S2SV> { //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> break ; //<S2SV> image -> columns = ( size_t ) width ; //<S2SV> image -> rows = ( size_t ) height ; //<S2SV> image -> depth = info . depth ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> image -> colorspace = RGBColorspace ; //<S2SV> ( void ) SetImageBackgroundColor ( image , exception ) ; //<S2SV> if ( ( image -> colormap == ( PixelInfo * ) NULL ) && //<S2SV> ( info . samples_per_pixel == 1 ) ) //<S2SV> { //<S2SV> int //<S2SV> index ; //<S2SV> size_t //<S2SV> one ; //<S2SV> one = 1 ; //<S2SV> if ( colors == 0 ) //<S2SV> colors = one << info . depth ; //<S2SV> if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) //<S2SV> ThrowDCMException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> if ( redmap != ( int * ) NULL ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> index = redmap [ i ] ; //<S2SV> if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && //<S2SV> ( index <= ( int ) info . max_value ) ) //<S2SV> index = ( int ) info . scale [ index ] ; //<S2SV> image -> colormap [ i ] . red = ( MagickRealType ) index ; //<S2SV> } //<S2SV> if ( greenmap != ( int * ) NULL ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> index = greenmap [ i ] ; //<S2SV> if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && //<S2SV> ( index <= ( int ) info . max_value ) ) //<S2SV> index = ( int ) info . scale [ index ] ; //<S2SV> image -> colormap [ i ] . green = ( MagickRealType ) index ; //<S2SV> } //<S2SV> if ( bluemap != ( int * ) NULL ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> index = bluemap [ i ] ; //<S2SV> if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && //<S2SV> ( index <= ( int ) info . max_value ) ) //<S2SV> index = ( int ) info . scale [ index ] ; //<S2SV> image -> colormap [ i ] . blue = ( MagickRealType ) index ; //<S2SV> } //<S2SV> if ( graymap != ( int * ) NULL ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) //<S2SV> { //<S2SV> index = graymap [ i ] ; //<S2SV> if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && //<S2SV> ( index <= ( int ) info . max_value ) ) //<S2SV> index = ( int ) info . scale [ index ] ; //<S2SV> image -> colormap [ i ] . red = ( MagickRealType ) index ; //<S2SV> image -> colormap [ i ] . green = ( MagickRealType ) index ; //<S2SV> image -> colormap [ i ] . blue = ( MagickRealType ) index ; //<S2SV> } //<S2SV> } //<S2SV> if ( image -> compression == RLECompression ) //<S2SV> { //<S2SV> unsigned int //<S2SV> tag ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) //<S2SV> { //<S2SV> int //<S2SV> c ; //<S2SV> c = ReadBlobByte ( image ) ; //<S2SV> if ( c == EOF ) //<S2SV> break ; //<S2SV> } //<S2SV> tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | //<S2SV> ReadBlobLSBShort ( image ) ; //<S2SV> stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; //<S2SV> if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || //<S2SV> ( EOFBlob ( image ) != MagickFalse ) ) //<S2SV> { //<S2SV> if ( stream_info -> offsets != ( ssize_t * ) NULL ) //<S2SV> stream_info -> offsets = ( ssize_t * ) //<S2SV> RelinquishMagickMemory ( stream_info -> offsets ) ; //<S2SV> ThrowDCMException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> } //<S2SV> stream_info -> count = 0 ; //<S2SV> stream_info -> segment_count = ReadBlobLSBLong ( image ) ; //<S2SV> for ( i = 0 ; i < 15 ; i ++ ) //<S2SV> stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; //<S2SV> stream_info -> remaining -= 64 ; //<S2SV> if ( stream_info -> segment_count > 1 ) //<S2SV> { //<S2SV> info . bytes_per_pixel = 1 ; //<S2SV> info . depth = 8 ; //<S2SV> if ( stream_info -> offset_count > 0 ) //<S2SV> ( void ) SeekBlob ( image , ( MagickOffsetType ) //<S2SV> stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) //<S2SV> { //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> ssize_t //<S2SV> y ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> switch ( ( int ) i ) //<S2SV> { //<S2SV> case 0 : //<S2SV> { //<S2SV> SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadDCMByte ( stream_info , image ) ) , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 1 : //<S2SV> { //<S2SV> SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadDCMByte ( stream_info , image ) ) , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadDCMByte ( stream_info , image ) ) , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 3 : //<S2SV> { //<S2SV> SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadDCMByte ( stream_info , image ) ) , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> y , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> const char //<S2SV> * option ; //<S2SV> option = GetImageOption ( image_info , "dcm:display-range" ) ; //<S2SV> if ( option != ( const char * ) NULL ) //<S2SV> { //<S2SV> if ( LocaleCompare ( option , "reset" ) == 0 ) //<S2SV> info . window_width = 0 ; //<S2SV> } //<S2SV> option = GetImageOption ( image_info , "dcm:window" ) ; //<S2SV> if ( option != ( char * ) NULL ) //<S2SV> { //<S2SV> GeometryInfo //<S2SV> geometry_info ; //<S2SV> MagickStatusType //<S2SV> flags ; //<S2SV> flags = ParseGeometry ( option , & geometry_info ) ; //<S2SV> if ( flags & RhoValue ) //<S2SV> info . window_center = geometry_info . rho ; //<S2SV> if ( flags & SigmaValue ) //<S2SV> info . window_width = geometry_info . sigma ; //<S2SV> info . rescale = MagickTrue ; //<S2SV> } //<S2SV> option = GetImageOption ( image_info , "dcm:rescale" ) ; //<S2SV> if ( option != ( char * ) NULL ) //<S2SV> info . rescale = IsStringTrue ( option ) ; //<S2SV> if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) //<S2SV> info . window_width = info . window_center ; //<S2SV> status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; //<S2SV> if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) //<S2SV> { //<S2SV> if ( stream_info -> offset_count > 0 ) //<S2SV> ( void ) SeekBlob ( image , ( MagickOffsetType ) //<S2SV> stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; //<S2SV> ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , //<S2SV> exception ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( SetImageGray ( image , exception ) != MagickFalse ) //<S2SV> ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> break ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = MagickFalse ; //<S2SV> break ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( stream_info -> offsets != ( ssize_t * ) NULL ) //<S2SV> stream_info -> offsets = ( ssize_t * ) //<S2SV> RelinquishMagickMemory ( stream_info -> offsets ) ; //<S2SV> stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; //<S2SV> if ( info . scale != ( Quantum * ) NULL ) //<S2SV> info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; //<S2SV> if ( graymap != ( int * ) NULL ) //<S2SV> graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; //<S2SV> if ( bluemap != ( int * ) NULL ) //<S2SV> bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; //<S2SV> if ( greenmap != ( int * ) NULL ) //<S2SV> greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; //<S2SV> if ( redmap != ( int * ) NULL ) //<S2SV> redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 