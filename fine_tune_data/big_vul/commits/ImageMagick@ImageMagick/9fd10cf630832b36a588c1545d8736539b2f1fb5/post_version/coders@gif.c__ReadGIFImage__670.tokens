static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) //<S2SV> # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) //<S2SV> Image //<S2SV> * image , //<S2SV> * meta_image ; //<S2SV> int //<S2SV> number_extensionss = 0 ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> RectangleInfo //<S2SV> page ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> delay , //<S2SV> dispose , //<S2SV> duration , //<S2SV> global_colors , //<S2SV> image_count , //<S2SV> iterations , //<S2SV> one ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> opacity ; //<S2SV> unsigned char //<S2SV> background , //<S2SV> c , //<S2SV> flag , //<S2SV> * global_colormap , //<S2SV> buffer [ 257 ] ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , 6 , buffer ) ; //<S2SV> if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) buffer , "GIF87" , 5 ) != 0 ) && //<S2SV> ( LocaleNCompare ( ( char * ) buffer , "GIF89" , 5 ) != 0 ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> page . width = ReadBlobLSBShort ( image ) ; //<S2SV> page . height = ReadBlobLSBShort ( image ) ; //<S2SV> flag = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> background = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> c = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> one = 1 ; //<S2SV> global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ; //<S2SV> global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) //<S2SV> MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ; //<S2SV> if ( global_colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * //<S2SV> sizeof ( * global_colormap ) ) ; //<S2SV> if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) //<S2SV> { //<S2SV> count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ; //<S2SV> if ( count != ( ssize_t ) ( 3 * global_colors ) ) //<S2SV> { //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( //<S2SV> global_colormap ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; //<S2SV> } //<S2SV> } //<S2SV> delay = 0 ; //<S2SV> dispose = 0 ; //<S2SV> duration = 0 ; //<S2SV> iterations = 1 ; //<S2SV> opacity = ( - 1 ) ; //<S2SV> image_count = 0 ; //<S2SV> meta_image = AcquireImage ( image_info , exception ) ; //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> count = ReadBlob ( image , 1 , & c ) ; //<S2SV> if ( count != 1 ) //<S2SV> break ; //<S2SV> if ( c == ( unsigned char ) ';' ) //<S2SV> break ; //<S2SV> if ( c == ( unsigned char ) '!' ) //<S2SV> { //<S2SV> count = ReadBlob ( image , 1 , & c ) ; //<S2SV> if ( count != 1 ) //<S2SV> { //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( //<S2SV> global_colormap ) ; //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "UnableToReadExtensionBlock" ) ; //<S2SV> } //<S2SV> switch ( c ) //<S2SV> { //<S2SV> case 0xf9 : //<S2SV> { //<S2SV> while ( ReadBlobBlock ( image , buffer ) != 0 ) ; //<S2SV> dispose = ( size_t ) ( buffer [ 0 ] >> 2 ) ; //<S2SV> delay = ( size_t ) ( ( buffer [ 2 ] << 8 ) | buffer [ 1 ] ) ; //<S2SV> if ( ( ssize_t ) ( buffer [ 0 ] & 0x01 ) == 0x01 ) //<S2SV> opacity = ( ssize_t ) buffer [ 3 ] ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0xfe : //<S2SV> { //<S2SV> char //<S2SV> * comments ; //<S2SV> size_t //<S2SV> length ; //<S2SV> comments = AcquireString ( ( char * ) NULL ) ; //<S2SV> for ( length = 0 ; ; length += count ) //<S2SV> { //<S2SV> count = ( ssize_t ) ReadBlobBlock ( image , buffer ) ; //<S2SV> if ( count == 0 ) //<S2SV> break ; //<S2SV> buffer [ count ] = '\\0' ; //<S2SV> ( void ) ConcatenateString ( & comments , ( const char * ) buffer ) ; //<S2SV> } //<S2SV> ( void ) SetImageProperty ( meta_image , "comment" , comments , exception ) ; //<S2SV> comments = DestroyString ( comments ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 0xff : //<S2SV> { //<S2SV> MagickBooleanType //<S2SV> loop ; //<S2SV> loop = MagickFalse ; //<S2SV> if ( ReadBlobBlock ( image , buffer ) != 0 ) //<S2SV> loop = LocaleNCompare ( ( char * ) buffer , "NETSCAPE2.0" , 11 ) == 0 ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> if ( loop != MagickFalse ) //<S2SV> { //<S2SV> while ( ReadBlobBlock ( image , buffer ) != 0 ) //<S2SV> iterations = ( size_t ) ( ( buffer [ 2 ] << 8 ) | buffer [ 1 ] ) ; //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> char //<S2SV> name [ MagickPathExtent ] ; //<S2SV> int //<S2SV> block_length , //<S2SV> info_length , //<S2SV> reserved_length ; //<S2SV> MagickBooleanType //<S2SV> i8bim , //<S2SV> icc , //<S2SV> iptc , //<S2SV> magick ; //<S2SV> StringInfo //<S2SV> * profile ; //<S2SV> unsigned char //<S2SV> * info ; //<S2SV> icc = LocaleNCompare ( ( char * ) buffer , "ICCRGBG1012" , 11 ) == 0 ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> magick = LocaleNCompare ( ( char * ) buffer , "ImageMagick" , 11 ) == 0 ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> i8bim = LocaleNCompare ( ( char * ) buffer , "MGK8BIM0000" , 11 ) == 0 ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> iptc = LocaleNCompare ( ( char * ) buffer , "MGKIPTC0000" , 11 ) == 0 ? //<S2SV> MagickTrue : MagickFalse ; //<S2SV> number_extensionss ++ ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Reading<S2SV_blank>GIF<S2SV_blank>application<S2SV_blank>extension" ) ; //<S2SV> info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , //<S2SV> sizeof ( * info ) ) ; //<S2SV> if ( info == ( unsigned char * ) NULL ) //<S2SV> { //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> reserved_length = 255 ; //<S2SV> for ( info_length = 0 ; ; ) //<S2SV> { //<S2SV> block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ; //<S2SV> if ( block_length == 0 ) //<S2SV> break ; //<S2SV> info_length += block_length ; //<S2SV> if ( info_length > ( reserved_length - 255 ) ) //<S2SV> { //<S2SV> reserved_length += 4096 ; //<S2SV> info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) //<S2SV> reserved_length , sizeof ( * info ) ) ; //<S2SV> if ( info == ( unsigned char * ) NULL ) //<S2SV> { //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> profile = BlobToStringInfo ( info , ( size_t ) info_length ) ; //<S2SV> if ( profile == ( StringInfo * ) NULL ) //<S2SV> { //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> if ( i8bim != MagickFalse ) //<S2SV> ( void ) CopyMagickString ( name , "8bim" , sizeof ( name ) ) ; //<S2SV> else if ( icc != MagickFalse ) //<S2SV> ( void ) CopyMagickString ( name , "icc" , sizeof ( name ) ) ; //<S2SV> else if ( iptc != MagickFalse ) //<S2SV> ( void ) CopyMagickString ( name , "iptc" , sizeof ( name ) ) ; //<S2SV> else if ( magick != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CopyMagickString ( name , "magick" , sizeof ( name ) ) ; //<S2SV> meta_image -> gamma = StringToDouble ( ( char * ) info + 6 , //<S2SV> ( char * * ) NULL ) ; //<S2SV> } //<S2SV> else //<S2SV> ( void ) FormatLocaleString ( name , sizeof ( name ) , "gif:%.11s" , //<S2SV> buffer ) ; //<S2SV> info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; //<S2SV> if ( magick == MagickFalse ) //<S2SV> ( void ) SetImageProfile ( meta_image , name , profile , exception ) ; //<S2SV> profile = DestroyStringInfo ( profile ) ; //<S2SV> ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , //<S2SV> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>profile<S2SV_blank>name=%s" , name ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> while ( ReadBlobBlock ( image , buffer ) != 0 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( c != ( unsigned char ) ',' ) //<S2SV> continue ; //<S2SV> if ( image_count != 0 ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image , exception ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( //<S2SV> global_colormap ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> } //<S2SV> image_count ++ ; //<S2SV> meta_image -> scene = image -> scene ; //<S2SV> ( void ) CloneImageProperties ( image , meta_image ) ; //<S2SV> DestroyImageProperties ( meta_image ) ; //<S2SV> ( void ) CloneImageProfiles ( image , meta_image ) ; //<S2SV> DestroyImageProfiles ( meta_image ) ; //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> compression = LZWCompression ; //<S2SV> page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ; //<S2SV> page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ; //<S2SV> image -> columns = ReadBlobLSBShort ( image ) ; //<S2SV> image -> rows = ReadBlobLSBShort ( image ) ; //<S2SV> image -> depth = 8 ; //<S2SV> flag = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ; //<S2SV> image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << //<S2SV> ( ( size_t ) ( flag & 0x07 ) + 1 ) ; //<S2SV> if ( opacity >= ( ssize_t ) image -> colors ) //<S2SV> opacity = ( - 1 ) ; //<S2SV> image -> page . width = page . width ; //<S2SV> image -> page . height = page . height ; //<S2SV> image -> page . y = page . y ; //<S2SV> image -> page . x = page . x ; //<S2SV> image -> delay = delay ; //<S2SV> image -> ticks_per_second = 100 ; //<S2SV> image -> dispose = ( DisposeType ) dispose ; //<S2SV> image -> iterations = iterations ; //<S2SV> image -> alpha_trait = opacity >= 0 ? BlendPixelTrait : UndefinedPixelTrait ; //<S2SV> delay = 0 ; //<S2SV> dispose = 0 ; //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) //<S2SV> { //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( //<S2SV> global_colormap ) ; //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; //<S2SV> } //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> { //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( //<S2SV> global_colormap ) ; //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) //<S2SV> { //<S2SV> p = global_colormap ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ( double ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . green = ( double ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . blue = ( double ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> if ( i == opacity ) //<S2SV> { //<S2SV> image -> colormap [ i ] . alpha = ( double ) TransparentAlpha ; //<S2SV> image -> transparent_color = image -> colormap [ opacity ] ; //<S2SV> } //<S2SV> } //<S2SV> image -> background_color = image -> colormap [ MagickMin ( ( ssize_t ) background , //<S2SV> ( ssize_t ) image -> colors - 1 ) ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> unsigned char //<S2SV> * colormap ; //<S2SV> colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * //<S2SV> sizeof ( * colormap ) ) ; //<S2SV> if ( colormap == ( unsigned char * ) NULL ) //<S2SV> { //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( //<S2SV> global_colormap ) ; //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ; //<S2SV> if ( count != ( ssize_t ) ( 3 * image -> colors ) ) //<S2SV> { //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( //<S2SV> global_colormap ) ; //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "InsufficientImageDataInFile" ) ; //<S2SV> } //<S2SV> p = colormap ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ( double ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . green = ( double ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> image -> colormap [ i ] . blue = ( double ) ScaleCharToQuantum ( * p ++ ) ; //<S2SV> if ( i == opacity ) //<S2SV> image -> colormap [ i ] . alpha = ( double ) TransparentAlpha ; //<S2SV> } //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> } //<S2SV> if ( image -> gamma == 1.0 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> if ( IsPixelInfoGray ( image -> colormap + i ) == MagickFalse ) //<S2SV> break ; //<S2SV> ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? //<S2SV> GRAYColorspace : RGBColorspace , exception ) ; //<S2SV> } //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> status = PingGIFImage ( image , exception ) ; //<S2SV> else //<S2SV> status = DecodeImage ( image , opacity , exception ) ; //<S2SV> if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) //<S2SV> { //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( //<S2SV> global_colormap ) ; //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; //<S2SV> } //<S2SV> duration += image -> delay * image -> iterations ; //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> opacity = ( - 1 ) ; //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - //<S2SV> 1 , image -> scene ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> image -> duration = duration ; //<S2SV> meta_image = DestroyImage ( meta_image ) ; //<S2SV> global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 