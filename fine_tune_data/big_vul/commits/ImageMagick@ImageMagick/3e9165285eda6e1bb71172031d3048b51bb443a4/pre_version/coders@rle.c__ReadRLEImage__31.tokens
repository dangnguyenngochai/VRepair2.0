static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> # define SkipLinesOp 0x01 //<S2SV> # define SetColorOp 0x02 //<S2SV> # define SkipPixelsOp 0x03 //<S2SV> # define ByteDataOp 0x05 //<S2SV> # define RunDataOp 0x06 //<S2SV> # define EOFOp 0x07 //<S2SV> char //<S2SV> magick [ 12 ] ; //<S2SV> Image //<S2SV> * image ; //<S2SV> IndexPacket //<S2SV> index ; //<S2SV> int //<S2SV> opcode , //<S2SV> operand , //<S2SV> status ; //<S2SV> MagickStatusType //<S2SV> flags ; //<S2SV> MagickSizeType //<S2SV> number_pixels ; //<S2SV> MemoryInfo //<S2SV> * pixel_info ; //<S2SV> register IndexPacket //<S2SV> * indexes ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> size_t //<S2SV> bits_per_pixel , //<S2SV> map_length , //<S2SV> number_colormaps , //<S2SV> number_planes , //<S2SV> number_planes_filled , //<S2SV> one , //<S2SV> offset , //<S2SV> pixel_info_length ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> background_color [ 256 ] , //<S2SV> * colormap , //<S2SV> pixel , //<S2SV> plane , //<S2SV> * pixels ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; //<S2SV> if ( ( count != 2 ) || ( memcmp ( magick , "\\122\\314" , 2 ) != 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> do //<S2SV> { //<S2SV> image -> page . x = ReadBlobLSBShort ( image ) ; //<S2SV> image -> page . y = ReadBlobLSBShort ( image ) ; //<S2SV> image -> columns = ReadBlobLSBShort ( image ) ; //<S2SV> image -> rows = ReadBlobLSBShort ( image ) ; //<S2SV> flags = ( MagickStatusType ) ReadBlobByte ( image ) ; //<S2SV> image -> matte = flags & 0x04 ? MagickTrue : MagickFalse ; //<S2SV> number_planes = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> number_colormaps = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> map_length = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> if ( map_length >= 32 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> one = 1 ; //<S2SV> map_length = one << map_length ; //<S2SV> if ( ( number_planes == 0 ) || ( number_planes == 2 ) || //<S2SV> ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || //<S2SV> ( image -> columns == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( flags & 0x02 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) //<S2SV> background_color [ i ] = 0 ; //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> p = background_color ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) //<S2SV> * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> if ( ( number_planes & 0x01 ) == 0 ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> colormap = ( unsigned char * ) NULL ; //<S2SV> if ( number_colormaps != 0 ) //<S2SV> { //<S2SV> colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , //<S2SV> 3 * map_length * sizeof ( * colormap ) ) ; //<S2SV> if ( colormap == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> p = colormap ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) //<S2SV> for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) //<S2SV> * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; //<S2SV> } //<S2SV> if ( ( flags & 0x08 ) != 0 ) //<S2SV> { //<S2SV> char //<S2SV> * comment ; //<S2SV> size_t //<S2SV> length ; //<S2SV> length = ReadBlobLSBShort ( image ) ; //<S2SV> if ( length != 0 ) //<S2SV> { //<S2SV> comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; //<S2SV> comment [ length - 1 ] = '\\0' ; //<S2SV> ( void ) SetImageProperty ( image , "comment" , comment ) ; //<S2SV> comment = DestroyString ( comment ) ; //<S2SV> if ( ( length & 0x01 ) == 0 ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> number_planes ++ ; //<S2SV> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; //<S2SV> number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : //<S2SV> number_planes + 1 ; //<S2SV> if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * //<S2SV> number_planes_filled ) ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * //<S2SV> number_planes_filled * sizeof ( * pixels ) ) ; //<S2SV> if ( pixel_info == ( MemoryInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> pixel_info_length = image -> columns * image -> rows * number_planes_filled ; //<S2SV> pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; //<S2SV> if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) //<S2SV> { //<S2SV> ssize_t //<S2SV> j ; //<S2SV> p = pixels ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) //<S2SV> { //<S2SV> if ( image -> matte == MagickFalse ) //<S2SV> for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) //<S2SV> * p ++ = background_color [ j ] ; //<S2SV> else //<S2SV> { //<S2SV> for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) //<S2SV> * p ++ = background_color [ j ] ; //<S2SV> * p ++ = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> plane = 0 ; //<S2SV> x = 0 ; //<S2SV> y = 0 ; //<S2SV> opcode = ReadBlobByte ( image ) ; //<S2SV> do //<S2SV> { //<S2SV> switch ( opcode & 0x3f ) //<S2SV> { //<S2SV> case SkipLinesOp : //<S2SV> { //<S2SV> operand = ReadBlobByte ( image ) ; //<S2SV> if ( opcode & 0x40 ) //<S2SV> operand = ReadBlobLSBSignedShort ( image ) ; //<S2SV> x = 0 ; //<S2SV> y += operand ; //<S2SV> break ; //<S2SV> } //<S2SV> case SetColorOp : //<S2SV> { //<S2SV> operand = ReadBlobByte ( image ) ; //<S2SV> plane = ( unsigned char ) operand ; //<S2SV> if ( plane == 255 ) //<S2SV> plane = ( unsigned char ) ( number_planes - 1 ) ; //<S2SV> x = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case SkipPixelsOp : //<S2SV> { //<S2SV> operand = ReadBlobByte ( image ) ; //<S2SV> if ( opcode & 0x40 ) //<S2SV> operand = ReadBlobLSBSignedShort ( image ) ; //<S2SV> x += operand ; //<S2SV> break ; //<S2SV> } //<S2SV> case ByteDataOp : //<S2SV> { //<S2SV> operand = ReadBlobByte ( image ) ; //<S2SV> if ( opcode & 0x40 ) //<S2SV> operand = ReadBlobLSBSignedShort ( image ) ; //<S2SV> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * //<S2SV> number_planes + plane ; //<S2SV> operand ++ ; //<S2SV> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) //<S2SV> { //<S2SV> if ( number_colormaps != 0 ) //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> } //<S2SV> p = pixels + offset ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) //<S2SV> { //<S2SV> pixel = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> if ( ( y < ( ssize_t ) image -> rows ) && //<S2SV> ( ( x + i ) < ( ssize_t ) image -> columns ) ) //<S2SV> * p = pixel ; //<S2SV> p += number_planes ; //<S2SV> } //<S2SV> if ( operand & 0x01 ) //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> x += operand ; //<S2SV> break ; //<S2SV> } //<S2SV> case RunDataOp : //<S2SV> { //<S2SV> operand = ReadBlobByte ( image ) ; //<S2SV> if ( opcode & 0x40 ) //<S2SV> operand = ReadBlobLSBSignedShort ( image ) ; //<S2SV> pixel = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> operand ++ ; //<S2SV> offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * //<S2SV> number_planes + plane ; //<S2SV> p = pixels + offset ; //<S2SV> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) //<S2SV> { //<S2SV> if ( number_colormaps != 0 ) //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) //<S2SV> { //<S2SV> if ( ( y < ( ssize_t ) image -> rows ) && //<S2SV> ( ( x + i ) < ( ssize_t ) image -> columns ) ) //<S2SV> * p = pixel ; //<S2SV> p += number_planes ; //<S2SV> } //<S2SV> x += operand ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> opcode = ReadBlobByte ( image ) ; //<S2SV> } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; //<S2SV> if ( number_colormaps != 0 ) //<S2SV> { //<S2SV> MagickStatusType //<S2SV> mask ; //<S2SV> mask = ( MagickStatusType ) ( map_length - 1 ) ; //<S2SV> p = pixels ; //<S2SV> x = ( ssize_t ) number_planes ; //<S2SV> if ( number_colormaps == 1 ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) //<S2SV> { //<S2SV> if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == //<S2SV> MagickFalse ) //<S2SV> break ; //<S2SV> * p = colormap [ ( ssize_t ) index ] ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> else //<S2SV> if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) //<S2SV> { //<S2SV> if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + //<S2SV> ( * p & mask ) ) , & index , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> * p = colormap [ ( ssize_t ) index ] ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) //<S2SV> { //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( number_planes >= 3 ) //<S2SV> { //<S2SV> p = pixels ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> if ( image -> matte != MagickFalse ) //<S2SV> SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( number_colormaps == 0 ) //<S2SV> map_length = 256 ; //<S2SV> if ( AcquireImageColormap ( image , map_length ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> p = colormap ; //<S2SV> if ( number_colormaps == 1 ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( number_colormaps > 1 ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( * ( p + map_length ) ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; //<S2SV> p ++ ; //<S2SV> } //<S2SV> p = pixels ; //<S2SV> if ( image -> matte == MagickFalse ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> SetPixelIndex ( indexes + x , * p ++ ) ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> y , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == //<S2SV> MagickFalse ) //<S2SV> break ; //<S2SV> SetPixelRed ( q , image -> colormap [ ( ssize_t ) index ] . red ) ; //<S2SV> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == //<S2SV> MagickFalse ) //<S2SV> break ; //<S2SV> SetPixelGreen ( q , image -> colormap [ ( ssize_t ) index ] . green ) ; //<S2SV> if ( IsValidColormapIndex ( image , * p ++ , & index , exception ) == //<S2SV> MagickFalse ) //<S2SV> break ; //<S2SV> SetPixelBlue ( q , image -> colormap [ ( ssize_t ) index ] . blue ) ; //<S2SV> SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( x < ( ssize_t ) image -> columns ) //<S2SV> break ; //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) //<S2SV> y , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> image -> colormap = ( PixelPacket * ) RelinquishMagickMemory ( //<S2SV> image -> colormap ) ; //<S2SV> image -> storage_class = DirectClass ; //<S2SV> image -> colors = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( number_colormaps != 0 ) //<S2SV> colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; //<S2SV> pixel_info = RelinquishVirtualMemory ( pixel_info ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; //<S2SV> if ( ( count != 0 ) && ( memcmp ( magick , "\\122\\314" , 2 ) == 0 ) ) //<S2SV> { //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( ( count != 0 ) && ( memcmp ( magick , "\\122\\314" , 2 ) == 0 ) ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 