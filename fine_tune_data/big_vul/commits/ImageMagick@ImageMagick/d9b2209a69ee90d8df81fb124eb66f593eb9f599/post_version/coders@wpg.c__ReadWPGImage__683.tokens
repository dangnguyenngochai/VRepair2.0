static Image * ReadWPGImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> typedef struct //<S2SV> { //<S2SV> size_t FileId ; //<S2SV> MagickOffsetType DataOffset ; //<S2SV> unsigned int ProductType ; //<S2SV> unsigned int FileType ; //<S2SV> unsigned char MajorVersion ; //<S2SV> unsigned char MinorVersion ; //<S2SV> unsigned int EncryptKey ; //<S2SV> unsigned int Reserved ; //<S2SV> } WPGHeader ; //<S2SV> typedef struct //<S2SV> { //<S2SV> unsigned char RecType ; //<S2SV> size_t RecordLength ; //<S2SV> } WPGRecord ; //<S2SV> typedef struct //<S2SV> { //<S2SV> unsigned char Class ; //<S2SV> unsigned char RecType ; //<S2SV> size_t Extension ; //<S2SV> size_t RecordLength ; //<S2SV> } WPG2Record ; //<S2SV> typedef struct //<S2SV> { //<S2SV> unsigned HorizontalUnits ; //<S2SV> unsigned VerticalUnits ; //<S2SV> unsigned char PosSizePrecision ; //<S2SV> } WPG2Start ; //<S2SV> typedef struct //<S2SV> { //<S2SV> unsigned int Width ; //<S2SV> unsigned int Height ; //<S2SV> unsigned int Depth ; //<S2SV> unsigned int HorzRes ; //<S2SV> unsigned int VertRes ; //<S2SV> } WPGBitmapType1 ; //<S2SV> typedef struct //<S2SV> { //<S2SV> unsigned int Width ; //<S2SV> unsigned int Height ; //<S2SV> unsigned char Depth ; //<S2SV> unsigned char Compression ; //<S2SV> } WPG2BitmapType1 ; //<S2SV> typedef struct //<S2SV> { //<S2SV> unsigned int RotAngle ; //<S2SV> unsigned int LowLeftX ; //<S2SV> unsigned int LowLeftY ; //<S2SV> unsigned int UpRightX ; //<S2SV> unsigned int UpRightY ; //<S2SV> unsigned int Width ; //<S2SV> unsigned int Height ; //<S2SV> unsigned int Depth ; //<S2SV> unsigned int HorzRes ; //<S2SV> unsigned int VertRes ; //<S2SV> } WPGBitmapType2 ; //<S2SV> typedef struct //<S2SV> { //<S2SV> unsigned int StartIndex ; //<S2SV> unsigned int NumOfEntries ; //<S2SV> } WPGColorMapRec ; //<S2SV> Image //<S2SV> * image ; //<S2SV> unsigned int //<S2SV> status ; //<S2SV> WPGHeader //<S2SV> Header ; //<S2SV> WPGRecord //<S2SV> Rec ; //<S2SV> WPG2Record //<S2SV> Rec2 ; //<S2SV> WPG2Start StartWPG ; //<S2SV> WPGBitmapType1 //<S2SV> BitmapHeader1 ; //<S2SV> WPG2BitmapType1 //<S2SV> Bitmap2Header1 ; //<S2SV> WPGBitmapType2 //<S2SV> BitmapHeader2 ; //<S2SV> WPGColorMapRec //<S2SV> WPG_Palette ; //<S2SV> int //<S2SV> i , //<S2SV> bpp , //<S2SV> WPG2Flags ; //<S2SV> ssize_t //<S2SV> ldblk ; //<S2SV> size_t //<S2SV> one ; //<S2SV> unsigned char //<S2SV> * BImgBuff ; //<S2SV> tCTM CTM ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> one = 1 ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> image -> depth = 8 ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> Header . FileId = ReadBlobLSBLong ( image ) ; //<S2SV> Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; //<S2SV> Header . ProductType = ReadBlobLSBShort ( image ) ; //<S2SV> Header . FileType = ReadBlobLSBShort ( image ) ; //<S2SV> Header . MajorVersion = ReadBlobByte ( image ) ; //<S2SV> Header . MinorVersion = ReadBlobByte ( image ) ; //<S2SV> Header . EncryptKey = ReadBlobLSBShort ( image ) ; //<S2SV> Header . Reserved = ReadBlobLSBShort ( image ) ; //<S2SV> if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( Header . EncryptKey != 0 ) //<S2SV> ThrowReaderException ( CoderError , "EncryptedWPGImageFileNotSupported" ) ; //<S2SV> image -> columns = 1 ; //<S2SV> image -> rows = 1 ; //<S2SV> image -> colors = 0 ; //<S2SV> bpp = 0 ; //<S2SV> BitmapHeader2 . RotAngle = 0 ; //<S2SV> switch ( Header . FileType ) //<S2SV> { //<S2SV> case 1 : //<S2SV> while ( ! EOFBlob ( image ) ) //<S2SV> { //<S2SV> ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; //<S2SV> if ( EOFBlob ( image ) ) //<S2SV> break ; //<S2SV> Rec . RecType = ( i = ReadBlobByte ( image ) ) ; //<S2SV> if ( i == EOF ) //<S2SV> break ; //<S2SV> Rd_WP_DWORD ( image , & Rec . RecordLength ) ; //<S2SV> if ( EOFBlob ( image ) ) //<S2SV> break ; //<S2SV> Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; //<S2SV> switch ( Rec . RecType ) //<S2SV> { //<S2SV> case 0x0B : //<S2SV> BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; //<S2SV> if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; //<S2SV> if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) //<S2SV> { //<S2SV> image -> units = PixelsPerCentimeterResolution ; //<S2SV> image -> x_resolution = BitmapHeader1 . HorzRes / 470.0 ; //<S2SV> image -> y_resolution = BitmapHeader1 . VertRes / 470.0 ; //<S2SV> } //<S2SV> image -> columns = BitmapHeader1 . Width ; //<S2SV> image -> rows = BitmapHeader1 . Height ; //<S2SV> bpp = BitmapHeader1 . Depth ; //<S2SV> goto UnpackRaster ; //<S2SV> case 0x0E : //<S2SV> WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; //<S2SV> WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; //<S2SV> image -> colors = WPG_Palette . NumOfEntries ; //<S2SV> if ( ! AcquireImageColormap ( image , image -> colors ) ) //<S2SV> goto NoMemory ; //<S2SV> for ( i = WPG_Palette . StartIndex ; //<S2SV> i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0x11 : //<S2SV> if ( Rec . RecordLength > 8 ) //<S2SV> image = ExtractPostscript ( image , image_info , //<S2SV> TellBlob ( image ) + 8 , //<S2SV> ( ssize_t ) Rec . RecordLength - 8 , exception ) ; //<S2SV> break ; //<S2SV> case 0x14 : //<S2SV> BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; //<S2SV> if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; //<S2SV> BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; //<S2SV> image -> units = PixelsPerCentimeterResolution ; //<S2SV> image -> page . width = ( unsigned int ) //<S2SV> ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; //<S2SV> image -> page . height = ( unsigned int ) //<S2SV> ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; //<S2SV> image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; //<S2SV> image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; //<S2SV> if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) //<S2SV> { //<S2SV> image -> x_resolution = BitmapHeader2 . HorzRes / 470.0 ; //<S2SV> image -> y_resolution = BitmapHeader2 . VertRes / 470.0 ; //<S2SV> } //<S2SV> image -> columns = BitmapHeader2 . Width ; //<S2SV> image -> rows = BitmapHeader2 . Height ; //<S2SV> bpp = BitmapHeader2 . Depth ; //<S2SV> UnpackRaster : //<S2SV> if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) //<S2SV> { //<S2SV> image -> colors = one << bpp ; //<S2SV> if ( ! AcquireImageColormap ( image , image -> colors ) ) //<S2SV> { //<S2SV> NoMemory : //<S2SV> ThrowReaderException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( bpp < 24 ) //<S2SV> if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) //<S2SV> image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( //<S2SV> image -> colormap , ( size_t ) ( one << bpp ) , //<S2SV> sizeof ( * image -> colormap ) ) ; //<S2SV> } //<S2SV> if ( bpp == 1 ) //<S2SV> { //<S2SV> if ( image -> colormap [ 0 ] . red == 0 && //<S2SV> image -> colormap [ 0 ] . green == 0 && //<S2SV> image -> colormap [ 0 ] . blue == 0 && //<S2SV> image -> colormap [ 1 ] . red == 0 && //<S2SV> image -> colormap [ 1 ] . green == 0 && //<S2SV> image -> colormap [ 1 ] . blue == 0 ) //<S2SV> { //<S2SV> image -> colormap [ 1 ] . red = //<S2SV> image -> colormap [ 1 ] . green = //<S2SV> image -> colormap [ 1 ] . blue = QuantumRange ; //<S2SV> } //<S2SV> } //<S2SV> if ( UnpackWPGRaster ( image , bpp ) < 0 ) //<S2SV> { //<S2SV> DecompressionFailed : //<S2SV> ThrowReaderException ( CoderError , "UnableToDecompressImage" ) ; //<S2SV> } //<S2SV> if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) //<S2SV> { //<S2SV> if ( BitmapHeader2 . RotAngle & 0x8000 ) //<S2SV> { //<S2SV> Image //<S2SV> * flop_image ; //<S2SV> flop_image = FlopImage ( image , exception ) ; //<S2SV> if ( flop_image != ( Image * ) NULL ) { //<S2SV> DuplicateBlob ( flop_image , image ) ; //<S2SV> ( void ) RemoveLastImageFromList ( & image ) ; //<S2SV> AppendImageToList ( & image , flop_image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( BitmapHeader2 . RotAngle & 0x2000 ) //<S2SV> { //<S2SV> Image //<S2SV> * flip_image ; //<S2SV> flip_image = FlipImage ( image , exception ) ; //<S2SV> if ( flip_image != ( Image * ) NULL ) { //<S2SV> DuplicateBlob ( flip_image , image ) ; //<S2SV> ( void ) RemoveLastImageFromList ( & image ) ; //<S2SV> AppendImageToList ( & image , flip_image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( BitmapHeader2 . RotAngle & 0x0FFF ) //<S2SV> { //<S2SV> Image //<S2SV> * rotate_image ; //<S2SV> rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & //<S2SV> 0x0FFF ) , exception ) ; //<S2SV> if ( rotate_image != ( Image * ) NULL ) { //<S2SV> DuplicateBlob ( rotate_image , image ) ; //<S2SV> ( void ) RemoveLastImageFromList ( & image ) ; //<S2SV> AppendImageToList ( & image , rotate_image ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> image -> depth = 8 ; //<S2SV> if ( image -> next == ( Image * ) NULL ) //<S2SV> goto Finish ; //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> image -> columns = image -> rows = 1 ; //<S2SV> image -> colors = 0 ; //<S2SV> break ; //<S2SV> case 0x1B : //<S2SV> if ( Rec . RecordLength > 0x3C ) //<S2SV> image = ExtractPostscript ( image , image_info , //<S2SV> TellBlob ( image ) + 0x3C , //<S2SV> ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 2 : //<S2SV> ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; //<S2SV> StartWPG . PosSizePrecision = 0 ; //<S2SV> while ( ! EOFBlob ( image ) ) //<S2SV> { //<S2SV> ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; //<S2SV> if ( EOFBlob ( image ) ) //<S2SV> break ; //<S2SV> Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; //<S2SV> if ( i == EOF ) //<S2SV> break ; //<S2SV> Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; //<S2SV> if ( i == EOF ) //<S2SV> break ; //<S2SV> Rd_WP_DWORD ( image , & Rec2 . Extension ) ; //<S2SV> Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; //<S2SV> if ( EOFBlob ( image ) ) //<S2SV> break ; //<S2SV> Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; //<S2SV> switch ( Rec2 . RecType ) //<S2SV> { //<S2SV> case 1 : //<S2SV> StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; //<S2SV> StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; //<S2SV> StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; //<S2SV> break ; //<S2SV> case 0x0C : //<S2SV> WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; //<S2SV> WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; //<S2SV> image -> colors = WPG_Palette . NumOfEntries ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , //<S2SV> "MemoryAllocationFailed" ) ; //<S2SV> for ( i = WPG_Palette . StartIndex ; //<S2SV> i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) //<S2SV> { //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> ( void ) ReadBlobByte ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 0x0E : //<S2SV> Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; //<S2SV> Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; //<S2SV> if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; //<S2SV> Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; //<S2SV> if ( Bitmap2Header1 . Compression > 1 ) //<S2SV> continue ; //<S2SV> switch ( Bitmap2Header1 . Depth ) //<S2SV> { //<S2SV> case 1 : //<S2SV> bpp = 1 ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> bpp = 2 ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> bpp = 4 ; //<S2SV> break ; //<S2SV> case 4 : //<S2SV> bpp = 8 ; //<S2SV> break ; //<S2SV> case 8 : //<S2SV> bpp = 24 ; //<S2SV> break ; //<S2SV> default : //<S2SV> continue ; //<S2SV> } //<S2SV> image -> columns = Bitmap2Header1 . Width ; //<S2SV> image -> rows = Bitmap2Header1 . Height ; //<S2SV> if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) //<S2SV> { //<S2SV> size_t //<S2SV> one ; //<S2SV> one = 1 ; //<S2SV> image -> colors = one << bpp ; //<S2SV> if ( ! AcquireImageColormap ( image , image -> colors ) ) //<S2SV> goto NoMemory ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( bpp < 24 ) //<S2SV> if ( image -> colors < ( one << bpp ) && bpp != 24 ) //<S2SV> image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( //<S2SV> image -> colormap , ( size_t ) ( one << bpp ) , //<S2SV> sizeof ( * image -> colormap ) ) ; //<S2SV> } //<S2SV> switch ( Bitmap2Header1 . Compression ) //<S2SV> { //<S2SV> case 0 : //<S2SV> { //<S2SV> ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; //<S2SV> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) //<S2SV> ldblk , sizeof ( * BImgBuff ) ) ; //<S2SV> if ( BImgBuff == ( unsigned char * ) NULL ) //<S2SV> goto NoMemory ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) //<S2SV> { //<S2SV> ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; //<S2SV> InsertRow ( BImgBuff , i , image , bpp ) ; //<S2SV> } //<S2SV> if ( BImgBuff ) //<S2SV> BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 1 : //<S2SV> { //<S2SV> if ( UnpackWPG2Raster ( image , bpp ) < 0 ) //<S2SV> goto DecompressionFailed ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) //<S2SV> { //<S2SV> Image //<S2SV> * flop_image ; //<S2SV> flop_image = FlopImage ( image , exception ) ; //<S2SV> if ( flop_image != ( Image * ) NULL ) { //<S2SV> DuplicateBlob ( flop_image , image ) ; //<S2SV> ( void ) RemoveLastImageFromList ( & image ) ; //<S2SV> AppendImageToList ( & image , flop_image ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) //<S2SV> { //<S2SV> Image //<S2SV> * flip_image ; //<S2SV> flip_image = FlipImage ( image , exception ) ; //<S2SV> if ( flip_image != ( Image * ) NULL ) { //<S2SV> DuplicateBlob ( flip_image , image ) ; //<S2SV> ( void ) RemoveLastImageFromList ( & image ) ; //<S2SV> AppendImageToList ( & image , flip_image ) ; //<S2SV> } //<S2SV> } //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> image -> depth = 8 ; //<S2SV> if ( image -> next == ( Image * ) NULL ) //<S2SV> goto Finish ; //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> image -> columns = image -> rows = 1 ; //<S2SV> image -> colors = 0 ; //<S2SV> break ; //<S2SV> case 0x12 : //<S2SV> i = ReadBlobLSBShort ( image ) ; //<S2SV> if ( Rec2 . RecordLength > ( unsigned int ) i ) //<S2SV> image = ExtractPostscript ( image , image_info , //<S2SV> TellBlob ( image ) + i , //<S2SV> ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; //<S2SV> break ; //<S2SV> case 0x1B : //<S2SV> WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; //<S2SV> ( void ) WPG2Flags ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> { //<S2SV> ThrowReaderException ( CoderError , "DataEncodingSchemeIsNotSupported" ) ; //<S2SV> } //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> Finish : //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> { //<S2SV> Image //<S2SV> * p ; //<S2SV> ssize_t //<S2SV> scene = 0 ; //<S2SV> p = image ; //<S2SV> image = NULL ; //<S2SV> while ( p != ( Image * ) NULL ) //<S2SV> { //<S2SV> Image * tmp = p ; //<S2SV> if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { //<S2SV> p = p -> previous ; //<S2SV> DeleteImageFromList ( & tmp ) ; //<S2SV> } else { //<S2SV> image = p ; //<S2SV> p = p -> previous ; //<S2SV> } //<S2SV> } //<S2SV> for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) //<S2SV> p -> scene = ( size_t ) scene ++ ; //<S2SV> } //<S2SV> if ( image == ( Image * ) NULL ) //<S2SV> ThrowReaderException ( CorruptImageError , //<S2SV> "ImageFileDoesNotContainAnyImageData" ) ; //<S2SV> return ( image ) ; //<S2SV> } //<S2SV> 