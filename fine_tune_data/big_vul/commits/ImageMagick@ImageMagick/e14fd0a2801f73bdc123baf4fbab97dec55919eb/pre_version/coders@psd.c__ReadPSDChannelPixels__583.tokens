static MagickBooleanType ReadPSDChannelPixels ( Image * image , //<S2SV> const size_t channels , const size_t row , const ssize_t type , //<S2SV> const unsigned char * pixels , ExceptionInfo * exception ) //<S2SV> { //<S2SV> Quantum //<S2SV> pixel ; //<S2SV> register const unsigned char //<S2SV> * p ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> size_t //<S2SV> packet_size ; //<S2SV> unsigned short //<S2SV> nibble ; //<S2SV> p = pixels ; //<S2SV> q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> return MagickFalse ; //<S2SV> packet_size = GetPSDPacketSize ( image ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( packet_size == 1 ) //<S2SV> pixel = ScaleCharToQuantum ( * p ++ ) ; //<S2SV> else //<S2SV> { //<S2SV> p = PushShortPixel ( MSBEndian , p , & nibble ) ; //<S2SV> pixel = ScaleShortToQuantum ( nibble ) ; //<S2SV> } //<S2SV> switch ( type ) //<S2SV> { //<S2SV> case - 1 : //<S2SV> { //<S2SV> SetPixelAlpha ( image , pixel , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case - 2 : //<S2SV> case 0 : //<S2SV> { //<S2SV> SetPixelRed ( image , pixel , q ) ; //<S2SV> if ( channels == 1 || type == - 2 ) //<S2SV> SetPixelGray ( image , pixel , q ) ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> if ( packet_size == 1 ) //<S2SV> SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ; //<S2SV> else //<S2SV> SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ; //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) //<S2SV> ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; //<S2SV> if ( image -> depth == 1 ) //<S2SV> { //<S2SV> ssize_t //<S2SV> bit , //<S2SV> number_bits ; //<S2SV> number_bits = image -> columns - x ; //<S2SV> if ( number_bits > 8 ) //<S2SV> number_bits = 8 ; //<S2SV> for ( bit = 0 ; bit < number_bits ; bit ++ ) //<S2SV> { //<S2SV> SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & //<S2SV> ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; //<S2SV> SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) //<S2SV> GetPixelIndex ( image , q ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> x ++ ; //<S2SV> } //<S2SV> x -- ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 1 : //<S2SV> { //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> SetPixelAlpha ( image , pixel , q ) ; //<S2SV> else //<S2SV> SetPixelGreen ( image , pixel , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> SetPixelAlpha ( image , pixel , q ) ; //<S2SV> else //<S2SV> SetPixelBlue ( image , pixel , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 3 : //<S2SV> { //<S2SV> if ( image -> colorspace == CMYKColorspace ) //<S2SV> SetPixelBlack ( image , pixel , q ) ; //<S2SV> else //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> SetPixelAlpha ( image , pixel , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && //<S2SV> ( channels > 3 ) ) //<S2SV> break ; //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> SetPixelAlpha ( image , pixel , q ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> return ( SyncAuthenticPixels ( image , exception ) ) ; //<S2SV> } //<S2SV> 