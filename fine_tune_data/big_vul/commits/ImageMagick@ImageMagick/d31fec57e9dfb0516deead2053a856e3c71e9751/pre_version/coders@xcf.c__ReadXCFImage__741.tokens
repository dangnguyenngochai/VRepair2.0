static Image * ReadXCFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> magick [ 14 ] ; //<S2SV> Image //<S2SV> * image ; //<S2SV> int //<S2SV> foundPropEnd = 0 ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickOffsetType //<S2SV> offset ; //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> image_type , //<S2SV> length ; //<S2SV> ssize_t //<S2SV> count ; //<S2SV> XCFDocInfo //<S2SV> doc_info ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , 14 , ( unsigned char * ) magick ) ; //<S2SV> if ( ( count != 14 ) || //<S2SV> ( LocaleNCompare ( ( char * ) magick , "gimp<S2SV_blank>xcf" , 8 ) != 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> ( void ) ResetMagickMemory ( & doc_info , 0 , sizeof ( XCFDocInfo ) ) ; //<S2SV> doc_info . exception = exception ; //<S2SV> doc_info . width = ReadBlobMSBLong ( image ) ; //<S2SV> doc_info . height = ReadBlobMSBLong ( image ) ; //<S2SV> if ( ( doc_info . width > 262144 ) || ( doc_info . height > 262144 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> doc_info . image_type = ReadBlobMSBLong ( image ) ; //<S2SV> image -> columns = doc_info . width ; //<S2SV> image -> rows = doc_info . height ; //<S2SV> image_type = doc_info . image_type ; //<S2SV> doc_info . file_size = GetBlobSize ( image ) ; //<S2SV> image -> compression = NoCompression ; //<S2SV> image -> depth = 8 ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> if ( image_type == GIMP_RGB ) //<S2SV> ; //<S2SV> else //<S2SV> if ( image_type == GIMP_GRAY ) //<S2SV> image -> colorspace = GRAYColorspace ; //<S2SV> else //<S2SV> if ( image_type == GIMP_INDEXED ) //<S2SV> ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; //<S2SV> ( void ) SetImageOpacity ( image , OpaqueOpacity ) ; //<S2SV> ( void ) SetImageBackgroundColor ( image ) ; //<S2SV> while ( ( foundPropEnd == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) //<S2SV> { //<S2SV> PropType prop_type = ( PropType ) ReadBlobMSBLong ( image ) ; //<S2SV> size_t prop_size = ReadBlobMSBLong ( image ) ; //<S2SV> switch ( prop_type ) //<S2SV> { //<S2SV> case PROP_END : //<S2SV> foundPropEnd = 1 ; //<S2SV> break ; //<S2SV> case PROP_COLORMAP : //<S2SV> { //<S2SV> size_t num_colours = ReadBlobMSBLong ( image ) ; //<S2SV> if ( DiscardBlobBytes ( image , 3 * num_colours ) == MagickFalse ) //<S2SV> ThrowFileException ( & image -> exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PROP_COMPRESSION : //<S2SV> { //<S2SV> doc_info . compression = ReadBlobByte ( image ) ; //<S2SV> if ( ( doc_info . compression != COMPRESS_NONE ) && //<S2SV> ( doc_info . compression != COMPRESS_RLE ) && //<S2SV> ( doc_info . compression != COMPRESS_ZLIB ) && //<S2SV> ( doc_info . compression != COMPRESS_FRACTAL ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PROP_GUIDES : //<S2SV> { //<S2SV> if ( DiscardBlobBytes ( image , prop_size ) == MagickFalse ) //<S2SV> ThrowFileException ( & image -> exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PROP_RESOLUTION : //<S2SV> { //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PROP_TATTOO : //<S2SV> { //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PROP_PARASITES : //<S2SV> { //<S2SV> if ( DiscardBlobBytes ( image , prop_size ) == MagickFalse ) //<S2SV> ThrowFileException ( & image -> exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PROP_UNIT : //<S2SV> { //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PROP_PATHS : //<S2SV> { //<S2SV> if ( DiscardBlobBytes ( image , prop_size ) == MagickFalse ) //<S2SV> ThrowFileException ( & image -> exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PROP_USER_UNIT : //<S2SV> { //<S2SV> char unit_string [ 1000 ] ; //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> ( void ) ReadBlobMSBLong ( image ) ; //<S2SV> for ( i = 0 ; i < 5 ; i ++ ) //<S2SV> ( void ) ReadBlobStringWithLongSize ( image , unit_string , //<S2SV> sizeof ( unit_string ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> { //<S2SV> int buf [ 16 ] ; //<S2SV> ssize_t amount ; //<S2SV> while ( ( prop_size > 0 ) && ( EOFBlob ( image ) == MagickFalse ) ) //<S2SV> { //<S2SV> amount = ( ssize_t ) MagickMin ( 16 , prop_size ) ; //<S2SV> amount = ( ssize_t ) ReadBlob ( image , ( size_t ) amount , ( unsigned char * ) & buf ) ; //<S2SV> if ( ! amount ) //<S2SV> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; //<S2SV> prop_size -= ( size_t ) MagickMin ( 16 , ( size_t ) amount ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( foundPropEnd == MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) //<S2SV> { //<S2SV> ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int //<S2SV> current_layer = 0 , //<S2SV> foundAllLayers = MagickFalse , //<S2SV> number_layers = 0 ; //<S2SV> MagickOffsetType //<S2SV> oldPos = TellBlob ( image ) ; //<S2SV> XCFLayerInfo //<S2SV> * layer_info ; //<S2SV> do //<S2SV> { //<S2SV> ssize_t offset = ReadBlobMSBSignedLong ( image ) ; //<S2SV> if ( offset == 0 ) //<S2SV> foundAllLayers = MagickTrue ; //<S2SV> else //<S2SV> number_layers ++ ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , //<S2SV> "UnexpectedEndOfFile" , image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } while ( foundAllLayers == MagickFalse ) ; //<S2SV> doc_info . number_layers = number_layers ; //<S2SV> offset = SeekBlob ( image , oldPos , SEEK_SET ) ; //<S2SV> if ( offset < 0 ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> length = ( size_t ) number_layers ; //<S2SV> layer_info = ( XCFLayerInfo * ) AcquireQuantumMemory ( length , //<S2SV> sizeof ( * layer_info ) ) ; //<S2SV> if ( layer_info == ( XCFLayerInfo * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> ( void ) ResetMagickMemory ( layer_info , 0 , number_layers * sizeof ( XCFLayerInfo ) ) ; //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> MagickBooleanType //<S2SV> layer_ok ; //<S2SV> MagickOffsetType //<S2SV> offset , //<S2SV> saved_pos ; //<S2SV> offset = ( MagickOffsetType ) ReadBlobMSBLong ( image ) ; //<S2SV> if ( offset == 0 ) //<S2SV> break ; //<S2SV> saved_pos = TellBlob ( image ) ; //<S2SV> if ( SeekBlob ( image , offset , SEEK_SET ) != offset ) //<S2SV> ThrowReaderException ( ResourceLimitError , "NotEnoughPixelData" ) ; //<S2SV> layer_ok = ReadOneLayer ( image_info , image , & doc_info , //<S2SV> & layer_info [ current_layer ] , current_layer ) ; //<S2SV> if ( layer_ok == MagickFalse ) //<S2SV> { //<S2SV> int j ; //<S2SV> for ( j = 0 ; j < current_layer ; j ++ ) //<S2SV> layer_info [ j ] . image = DestroyImage ( layer_info [ j ] . image ) ; //<S2SV> layer_info = ( XCFLayerInfo * ) RelinquishMagickMemory ( layer_info ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> offset = SeekBlob ( image , saved_pos , SEEK_SET ) ; //<S2SV> current_layer ++ ; //<S2SV> } //<S2SV> # if 0 //<S2SV> { //<S2SV> signed int j ; //<S2SV> for ( j = number_layers - 1 ; j >= 0 ; j -- ) { //<S2SV> if ( layer_info [ j ] . visible ) { //<S2SV> CompositeImage ( image , OverCompositeOp , layer_info [ j ] . image , //<S2SV> layer_info [ j ] . offset_x , layer_info [ j ] . offset_y ) ; //<S2SV> layer_info [ j ] . image = DestroyImage ( layer_info [ j ] . image ) ; //<S2SV> if ( image_type == GIMP_GRAY ) { //<S2SV> QuantizeInfo qi ; //<S2SV> GetQuantizeInfo ( & qi ) ; //<S2SV> qi . colorspace = GRAYColorspace ; //<S2SV> QuantizeImage ( & qi , layer_info [ j ] . image ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # else //<S2SV> { //<S2SV> ssize_t j ; //<S2SV> for ( j = ( long ) number_layers - 1 ; j >= 0 ; j -- ) //<S2SV> AppendImageToList ( & image , layer_info [ j ] . image ) ; //<S2SV> } //<S2SV> # endif //<S2SV> layer_info = ( XCFLayerInfo * ) RelinquishMagickMemory ( layer_info ) ; //<S2SV> # if 0 //<S2SV> while ( MagickTrue ) //<S2SV> { //<S2SV> info -> cp += xcf_read_int32 ( info -> fp , & offset , 1 ) ; //<S2SV> if ( offset == 0 ) //<S2SV> break ; //<S2SV> saved_pos = info -> cp ; //<S2SV> xcf_seek_pos ( info , offset ) ; //<S2SV> channel = xcf_load_channel ( info , gimage ) ; //<S2SV> if ( channel == 0 ) //<S2SV> goto error ; //<S2SV> num_successful_elements ++ ; //<S2SV> if ( channel != gimage -> selection_mask ) //<S2SV> gimp_image_add_channel ( gimage , channel , - 1 ) ; //<S2SV> xcf_seek_pos ( info , saved_pos ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> DestroyImage ( RemoveFirstImageFromList ( & image ) ) ; //<S2SV> if ( image_type == GIMP_GRAY ) //<S2SV> image -> type = GrayscaleType ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 