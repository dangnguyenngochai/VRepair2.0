static Image * ReadSCREENSHOTImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> Image //<S2SV> * image ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = ( Image * ) NULL ; //<S2SV> # if defined ( MAGICKCORE_WINGDI32_DELEGATE ) //<S2SV> { //<S2SV> BITMAPINFO //<S2SV> bmi ; //<S2SV> DISPLAY_DEVICE //<S2SV> device ; //<S2SV> HBITMAP //<S2SV> bitmap , //<S2SV> bitmapOld ; //<S2SV> HDC //<S2SV> bitmapDC , //<S2SV> hDC ; //<S2SV> Image //<S2SV> * screen ; //<S2SV> int //<S2SV> i ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> RGBTRIPLE //<S2SV> * p ; //<S2SV> ssize_t //<S2SV> y ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> i = 0 ; //<S2SV> device . cb = sizeof ( device ) ; //<S2SV> image = ( Image * ) NULL ; //<S2SV> while ( EnumDisplayDevices ( NULL , i , & device , 0 ) && ++ i ) //<S2SV> { //<S2SV> if ( ( device . StateFlags & DISPLAY_DEVICE_ACTIVE ) != DISPLAY_DEVICE_ACTIVE ) //<S2SV> continue ; //<S2SV> hDC = CreateDC ( device . DeviceName , device . DeviceName , NULL , NULL ) ; //<S2SV> if ( hDC == ( HDC ) NULL ) //<S2SV> ThrowReaderException ( CoderError , "UnableToCreateDC" ) ; //<S2SV> screen = AcquireImage ( image_info ) ; //<S2SV> screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; //<S2SV> screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; //<S2SV> screen -> storage_class = DirectClass ; //<S2SV> if ( image == ( Image * ) NULL ) //<S2SV> image = screen ; //<S2SV> else //<S2SV> AppendImageToList ( & image , screen ) ; //<S2SV> status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> bitmapDC = CreateCompatibleDC ( hDC ) ; //<S2SV> if ( bitmapDC == ( HDC ) NULL ) //<S2SV> { //<S2SV> DeleteDC ( hDC ) ; //<S2SV> ThrowReaderException ( CoderError , "UnableToCreateDC" ) ; //<S2SV> } //<S2SV> ( void ) ResetMagickMemory ( & bmi , 0 , sizeof ( BITMAPINFO ) ) ; //<S2SV> bmi . bmiHeader . biSize = sizeof ( BITMAPINFOHEADER ) ; //<S2SV> bmi . bmiHeader . biWidth = ( LONG ) screen -> columns ; //<S2SV> bmi . bmiHeader . biHeight = ( - 1 ) * ( LONG ) screen -> rows ; //<S2SV> bmi . bmiHeader . biPlanes = 1 ; //<S2SV> bmi . bmiHeader . biBitCount = 24 ; //<S2SV> bmi . bmiHeader . biCompression = BI_RGB ; //<S2SV> bitmap = CreateDIBSection ( hDC , & bmi , DIB_RGB_COLORS , ( void * * ) & p , NULL , 0 ) ; //<S2SV> if ( bitmap == ( HBITMAP ) NULL ) //<S2SV> { //<S2SV> DeleteDC ( hDC ) ; //<S2SV> DeleteDC ( bitmapDC ) ; //<S2SV> ThrowReaderException ( CoderError , "UnableToCreateBitmap" ) ; //<S2SV> } //<S2SV> bitmapOld = ( HBITMAP ) SelectObject ( bitmapDC , bitmap ) ; //<S2SV> if ( bitmapOld == ( HBITMAP ) NULL ) //<S2SV> { //<S2SV> DeleteDC ( hDC ) ; //<S2SV> DeleteDC ( bitmapDC ) ; //<S2SV> DeleteObject ( bitmap ) ; //<S2SV> ThrowReaderException ( CoderError , "UnableToCreateBitmap" ) ; //<S2SV> } //<S2SV> BitBlt ( bitmapDC , 0 , 0 , ( int ) screen -> columns , ( int ) screen -> rows , hDC , 0 , 0 , //<S2SV> SRCCOPY ) ; //<S2SV> ( void ) SelectObject ( bitmapDC , bitmapOld ) ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) screen -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( screen , 0 , y , screen -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) screen -> columns ; x ++ ) //<S2SV> { //<S2SV> SetPixelRed ( q , ScaleCharToQuantum ( p -> rgbtRed ) ) ; //<S2SV> SetPixelGreen ( q , ScaleCharToQuantum ( p -> rgbtGreen ) ) ; //<S2SV> SetPixelBlue ( q , ScaleCharToQuantum ( p -> rgbtBlue ) ) ; //<S2SV> SetPixelOpacity ( q , OpaqueOpacity ) ; //<S2SV> p ++ ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( screen , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> DeleteDC ( hDC ) ; //<S2SV> DeleteDC ( bitmapDC ) ; //<S2SV> DeleteObject ( bitmap ) ; //<S2SV> } //<S2SV> } //<S2SV> # elif defined ( MAGICKCORE_X11_DELEGATE ) //<S2SV> { //<S2SV> const char //<S2SV> * option ; //<S2SV> XImportInfo //<S2SV> ximage_info ; //<S2SV> ( void ) exception ; //<S2SV> XGetImportInfo ( & ximage_info ) ; //<S2SV> option = GetImageOption ( image_info , "x:screen" ) ; //<S2SV> if ( option != ( const char * ) NULL ) //<S2SV> ximage_info . screen = IsMagickTrue ( option ) ; //<S2SV> option = GetImageOption ( image_info , "x:silent" ) ; //<S2SV> if ( option != ( const char * ) NULL ) //<S2SV> ximage_info . silent = IsMagickTrue ( option ) ; //<S2SV> image = XImportImage ( image_info , & ximage_info ) ; //<S2SV> } //<S2SV> # endif //<S2SV> return ( image ) ; //<S2SV> } //<S2SV> 