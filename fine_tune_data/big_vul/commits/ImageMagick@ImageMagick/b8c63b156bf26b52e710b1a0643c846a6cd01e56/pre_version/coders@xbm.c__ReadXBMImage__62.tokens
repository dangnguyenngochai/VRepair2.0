static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> buffer [ MaxTextExtent ] , //<S2SV> name [ MaxTextExtent ] ; //<S2SV> Image //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> register IndexPacket //<S2SV> * indexes ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> register unsigned char //<S2SV> * p ; //<S2SV> short int //<S2SV> hex_digits [ 256 ] ; //<S2SV> ssize_t //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * data ; //<S2SV> unsigned int //<S2SV> bit , //<S2SV> byte , //<S2SV> bytes_per_line , //<S2SV> height , //<S2SV> length , //<S2SV> padding , //<S2SV> value , //<S2SV> version , //<S2SV> width ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> width = 0 ; //<S2SV> height = 0 ; //<S2SV> while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) //<S2SV> if ( sscanf ( buffer , "#define<S2SV_blank>%32s<S2SV_blank>%u" , name , & width ) == 2 ) //<S2SV> if ( ( strlen ( name ) >= 6 ) && //<S2SV> ( LocaleCompare ( name + strlen ( name ) - 6 , "_width" ) == 0 ) ) //<S2SV> break ; //<S2SV> while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) //<S2SV> if ( sscanf ( buffer , "#define<S2SV_blank>%32s<S2SV_blank>%u" , name , & height ) == 2 ) //<S2SV> if ( ( strlen ( name ) >= 7 ) && //<S2SV> ( LocaleCompare ( name + strlen ( name ) - 7 , "_height" ) == 0 ) ) //<S2SV> break ; //<S2SV> image -> columns = width ; //<S2SV> image -> rows = height ; //<S2SV> image -> depth = 8 ; //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> colors = 2 ; //<S2SV> version = 11 ; //<S2SV> while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) //<S2SV> { //<S2SV> if ( sscanf ( buffer , "static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{" , name ) == 1 ) //<S2SV> version = 10 ; //<S2SV> else //<S2SV> if ( sscanf ( buffer , "static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>{" , name ) == 1 ) //<S2SV> version = 11 ; //<S2SV> else //<S2SV> if ( sscanf ( buffer , "static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{" , name ) == 1 ) //<S2SV> version = 11 ; //<S2SV> else //<S2SV> continue ; //<S2SV> p = ( unsigned char * ) strrchr ( name , '_' ) ; //<S2SV> if ( p == ( unsigned char * ) NULL ) //<S2SV> p = ( unsigned char * ) name ; //<S2SV> else //<S2SV> p ++ ; //<S2SV> if ( LocaleCompare ( "bits[]" , ( char * ) p ) == 0 ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || //<S2SV> ( EOFBlob ( image ) != MagickFalse ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> image -> colormap [ 0 ] . red = QuantumRange ; //<S2SV> image -> colormap [ 0 ] . green = QuantumRange ; //<S2SV> image -> colormap [ 0 ] . blue = QuantumRange ; //<S2SV> image -> colormap [ 1 ] . red = ( Quantum ) 0 ; //<S2SV> image -> colormap [ 1 ] . green = ( Quantum ) 0 ; //<S2SV> image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> hex_digits [ ( int ) '0' ] = 0 ; //<S2SV> hex_digits [ ( int ) '1' ] = 1 ; //<S2SV> hex_digits [ ( int ) '2' ] = 2 ; //<S2SV> hex_digits [ ( int ) '3' ] = 3 ; //<S2SV> hex_digits [ ( int ) '4' ] = 4 ; //<S2SV> hex_digits [ ( int ) '5' ] = 5 ; //<S2SV> hex_digits [ ( int ) '6' ] = 6 ; //<S2SV> hex_digits [ ( int ) '7' ] = 7 ; //<S2SV> hex_digits [ ( int ) '8' ] = 8 ; //<S2SV> hex_digits [ ( int ) '9' ] = 9 ; //<S2SV> hex_digits [ ( int ) 'A' ] = 10 ; //<S2SV> hex_digits [ ( int ) 'B' ] = 11 ; //<S2SV> hex_digits [ ( int ) 'C' ] = 12 ; //<S2SV> hex_digits [ ( int ) 'D' ] = 13 ; //<S2SV> hex_digits [ ( int ) 'E' ] = 14 ; //<S2SV> hex_digits [ ( int ) 'F' ] = 15 ; //<S2SV> hex_digits [ ( int ) 'a' ] = 10 ; //<S2SV> hex_digits [ ( int ) 'b' ] = 11 ; //<S2SV> hex_digits [ ( int ) 'c' ] = 12 ; //<S2SV> hex_digits [ ( int ) 'd' ] = 13 ; //<S2SV> hex_digits [ ( int ) 'e' ] = 14 ; //<S2SV> hex_digits [ ( int ) 'f' ] = 15 ; //<S2SV> hex_digits [ ( int ) 'x' ] = 0 ; //<S2SV> hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; //<S2SV> hex_digits [ ( int ) ',' ] = ( - 1 ) ; //<S2SV> hex_digits [ ( int ) '}' ] = ( - 1 ) ; //<S2SV> hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; //<S2SV> hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; //<S2SV> padding = 0 ; //<S2SV> if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && //<S2SV> ( version == 10 ) ) //<S2SV> padding = 1 ; //<S2SV> bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; //<S2SV> length = ( unsigned int ) image -> rows ; //<S2SV> data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * //<S2SV> sizeof ( * data ) ) ; //<S2SV> if ( data == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> p = data ; //<S2SV> if ( version == 10 ) //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) //<S2SV> { //<S2SV> value = XBMInteger ( image , hex_digits ) ; //<S2SV> * p ++ = ( unsigned char ) value ; //<S2SV> if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) //<S2SV> * p ++ = ( unsigned char ) ( value >> 8 ) ; //<S2SV> } //<S2SV> else //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) //<S2SV> { //<S2SV> value = XBMInteger ( image , hex_digits ) ; //<S2SV> * p ++ = ( unsigned char ) value ; //<S2SV> } //<S2SV> p = data ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> bit = 0 ; //<S2SV> byte = 0 ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( bit == 0 ) //<S2SV> byte = ( size_t ) ( * p ++ ) ; //<S2SV> SetPixelIndex ( indexes + x , ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) ; //<S2SV> bit ++ ; //<S2SV> byte >>= 1 ; //<S2SV> if ( bit == 8 ) //<S2SV> bit = 0 ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; //<S2SV> ( void ) SyncImage ( image ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 