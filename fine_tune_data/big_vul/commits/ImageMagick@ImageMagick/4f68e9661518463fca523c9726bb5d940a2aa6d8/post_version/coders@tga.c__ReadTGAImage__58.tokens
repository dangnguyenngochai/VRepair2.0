static Image * ReadTGAImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> Image //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> PixelInfo //<S2SV> pixel ; //<S2SV> Quantum //<S2SV> index ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> size_t //<S2SV> base , //<S2SV> flag , //<S2SV> offset , //<S2SV> real , //<S2SV> skip ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> TGAInfo //<S2SV> tga_info ; //<S2SV> unsigned char //<S2SV> j , //<S2SV> k , //<S2SV> pixels [ 4 ] , //<S2SV> runlength ; //<S2SV> unsigned int //<S2SV> alpha_bits ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> count = ReadBlob ( image , 1 , & tga_info . id_length ) ; //<S2SV> tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ; //<S2SV> if ( ( count != 1 ) || //<S2SV> ( ( tga_info . image_type != TGAColormap ) && //<S2SV> ( tga_info . image_type != TGARGB ) && //<S2SV> ( tga_info . image_type != TGAMonochrome ) && //<S2SV> ( tga_info . image_type != TGARLEColormap ) && //<S2SV> ( tga_info . image_type != TGARLERGB ) && //<S2SV> ( tga_info . image_type != TGARLEMonochrome ) ) || //<S2SV> ( ( ( tga_info . image_type == TGAColormap ) || //<S2SV> ( tga_info . image_type == TGARLEColormap ) ) && //<S2SV> ( tga_info . colormap_type == 0 ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> tga_info . colormap_index = ReadBlobLSBShort ( image ) ; //<S2SV> tga_info . colormap_length = ReadBlobLSBShort ( image ) ; //<S2SV> tga_info . colormap_size = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> tga_info . x_origin = ReadBlobLSBShort ( image ) ; //<S2SV> tga_info . y_origin = ReadBlobLSBShort ( image ) ; //<S2SV> tga_info . width = ( unsigned short ) ReadBlobLSBShort ( image ) ; //<S2SV> tga_info . height = ( unsigned short ) ReadBlobLSBShort ( image ) ; //<S2SV> tga_info . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> tga_info . attributes = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> if ( ( ( ( tga_info . bits_per_pixel <= 1 ) || ( tga_info . bits_per_pixel >= 17 ) ) && //<S2SV> ( tga_info . bits_per_pixel != 24 ) && ( tga_info . bits_per_pixel != 32 ) ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> image -> columns = tga_info . width ; //<S2SV> image -> rows = tga_info . height ; //<S2SV> alpha_bits = ( tga_info . attributes & 0x0FU ) ; //<S2SV> image -> alpha_trait = ( alpha_bits > 0 ) || ( tga_info . bits_per_pixel == 32 ) || //<S2SV> ( tga_info . colormap_size == 32 ) ? BlendPixelTrait : UndefinedPixelTrait ; //<S2SV> if ( ( tga_info . image_type != TGAColormap ) && //<S2SV> ( tga_info . image_type != TGARLEColormap ) ) //<S2SV> image -> depth = ( size_t ) ( ( tga_info . bits_per_pixel <= 8 ) ? 8 : //<S2SV> ( tga_info . bits_per_pixel <= 16 ) ? 5 : //<S2SV> ( tga_info . bits_per_pixel == 24 ) ? 8 : //<S2SV> ( tga_info . bits_per_pixel == 32 ) ? 8 : 8 ) ; //<S2SV> else //<S2SV> image -> depth = ( size_t ) ( ( tga_info . colormap_size <= 8 ) ? 8 : //<S2SV> ( tga_info . colormap_size <= 16 ) ? 5 : //<S2SV> ( tga_info . colormap_size == 24 ) ? 8 : //<S2SV> ( tga_info . colormap_size == 32 ) ? 8 : 8 ) ; //<S2SV> if ( ( tga_info . image_type == TGAColormap ) || //<S2SV> ( tga_info . image_type == TGAMonochrome ) || //<S2SV> ( tga_info . image_type == TGARLEColormap ) || //<S2SV> ( tga_info . image_type == TGARLEMonochrome ) ) //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> compression = NoCompression ; //<S2SV> if ( ( tga_info . image_type == TGARLEColormap ) || //<S2SV> ( tga_info . image_type == TGARLEMonochrome ) || //<S2SV> ( tga_info . image_type == TGARLERGB ) ) //<S2SV> image -> compression = RLECompression ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> { //<S2SV> if ( tga_info . colormap_type != 0 ) //<S2SV> image -> colors = tga_info . colormap_index + tga_info . colormap_length ; //<S2SV> else //<S2SV> { //<S2SV> size_t //<S2SV> one ; //<S2SV> one = 1 ; //<S2SV> image -> colors = one << tga_info . bits_per_pixel ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( tga_info . id_length != 0 ) //<S2SV> { //<S2SV> char //<S2SV> * comment ; //<S2SV> size_t //<S2SV> length ; //<S2SV> length = ( size_t ) tga_info . id_length ; //<S2SV> comment = ( char * ) NULL ; //<S2SV> if ( ~ length >= ( MagickPathExtent - 1 ) ) //<S2SV> comment = ( char * ) AcquireQuantumMemory ( length + MagickPathExtent , //<S2SV> sizeof ( * comment ) ) ; //<S2SV> if ( comment == ( char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> count = ReadBlob ( image , tga_info . id_length , ( unsigned char * ) comment ) ; //<S2SV> comment [ tga_info . id_length ] = '\\0' ; //<S2SV> ( void ) SetImageProperty ( image , "comment" , comment , exception ) ; //<S2SV> comment = DestroyString ( comment ) ; //<S2SV> } //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( image ) ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; //<S2SV> pixel . alpha = ( MagickRealType ) OpaqueAlpha ; //<S2SV> if ( tga_info . colormap_type != 0 ) //<S2SV> { //<S2SV> if ( image -> colors < tga_info . colormap_index ) //<S2SV> image -> colors = tga_info . colormap_index ; //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) tga_info . colormap_index ; i ++ ) //<S2SV> image -> colormap [ i ] = pixel ; //<S2SV> for ( ; i < ( ssize_t ) image -> colors ; i ++ ) //<S2SV> { //<S2SV> switch ( tga_info . colormap_size ) //<S2SV> { //<S2SV> case 8 : //<S2SV> default : //<S2SV> { //<S2SV> pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> pixel . green = pixel . red ; //<S2SV> pixel . blue = pixel . red ; //<S2SV> break ; //<S2SV> } //<S2SV> case 15 : //<S2SV> case 16 : //<S2SV> { //<S2SV> QuantumAny //<S2SV> range ; //<S2SV> j = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> k = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> range = GetQuantumRange ( 5UL ) ; //<S2SV> pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , //<S2SV> range ) ; //<S2SV> pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * ( k & 0x03 ) //<S2SV> << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; //<S2SV> pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 24 : //<S2SV> { //<S2SV> pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 32 : //<S2SV> { //<S2SV> pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> ReadBlobByte ( image ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> image -> colormap [ i ] = pixel ; //<S2SV> } //<S2SV> } //<S2SV> base = 0 ; //<S2SV> flag = 0 ; //<S2SV> skip = MagickFalse ; //<S2SV> real = 0 ; //<S2SV> index = 0 ; //<S2SV> runlength = 0 ; //<S2SV> offset = 0 ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> real = offset ; //<S2SV> if ( ( ( unsigned char ) ( tga_info . attributes & 0x20 ) >> 5 ) == 0 ) //<S2SV> real = image -> rows - real - 1 ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , ( ssize_t ) real , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( ( tga_info . image_type == TGARLEColormap ) || //<S2SV> ( tga_info . image_type == TGARLERGB ) || //<S2SV> ( tga_info . image_type == TGARLEMonochrome ) ) //<S2SV> { //<S2SV> if ( runlength != 0 ) //<S2SV> { //<S2SV> runlength -- ; //<S2SV> skip = flag != 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> count = ReadBlob ( image , 1 , & runlength ) ; //<S2SV> if ( count != 1 ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> flag = runlength & 0x80 ; //<S2SV> if ( flag != 0 ) //<S2SV> runlength -= 128 ; //<S2SV> skip = MagickFalse ; //<S2SV> } //<S2SV> } //<S2SV> if ( skip == MagickFalse ) //<S2SV> switch ( tga_info . bits_per_pixel ) //<S2SV> { //<S2SV> case 8 : //<S2SV> default : //<S2SV> { //<S2SV> index = ( Quantum ) ReadBlobByte ( image ) ; //<S2SV> if ( tga_info . colormap_type != 0 ) //<S2SV> pixel = image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , //<S2SV> ( ssize_t ) index , exception ) ] ; //<S2SV> else //<S2SV> { //<S2SV> pixel . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> index ) ; //<S2SV> pixel . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> index ) ; //<S2SV> pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) //<S2SV> index ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 15 : //<S2SV> case 16 : //<S2SV> { //<S2SV> QuantumAny //<S2SV> range ; //<S2SV> if ( ReadBlob ( image , 2 , pixels ) != 2 ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> j = pixels [ 0 ] ; //<S2SV> k = pixels [ 1 ] ; //<S2SV> range = GetQuantumRange ( 5UL ) ; //<S2SV> pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( k & 0x7c ) >> 2 , //<S2SV> range ) ; //<S2SV> pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( 1UL * //<S2SV> ( k & 0x03 ) << 3 ) + ( 1UL * ( j & 0xe0 ) >> 5 ) , range ) ; //<S2SV> pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( 1UL * ( j & 0x1f ) , range ) ; //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> pixel . alpha = ( MagickRealType ) ( ( k & 0x80 ) == 0 ? ( Quantum ) //<S2SV> TransparentAlpha : ( Quantum ) OpaqueAlpha ) ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> index = ( Quantum ) ConstrainColormapIndex ( image , ( ( ssize_t ) ( k << 8 ) ) + //<S2SV> j , exception ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 24 : //<S2SV> { //<S2SV> if ( ReadBlob ( image , 3 , pixels ) != 3 ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; //<S2SV> pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; //<S2SV> pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 32 : //<S2SV> { //<S2SV> if ( ReadBlob ( image , 4 , pixels ) != 4 ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> pixel . blue = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 0 ] ) ; //<S2SV> pixel . green = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 1 ] ) ; //<S2SV> pixel . red = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 2 ] ) ; //<S2SV> pixel . alpha = ( MagickRealType ) ScaleCharToQuantum ( pixels [ 3 ] ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( status == MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; //<S2SV> if ( image -> storage_class == PseudoClass ) //<S2SV> SetPixelIndex ( image , index , q ) ; //<S2SV> SetPixelRed ( image , ClampToQuantum ( pixel . red ) , q ) ; //<S2SV> SetPixelGreen ( image , ClampToQuantum ( pixel . green ) , q ) ; //<S2SV> SetPixelBlue ( image , ClampToQuantum ( pixel . blue ) , q ) ; //<S2SV> if ( image -> alpha_trait != UndefinedPixelTrait ) //<S2SV> SetPixelAlpha ( image , ClampToQuantum ( pixel . alpha ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( ( ( unsigned char ) ( tga_info . attributes & 0xc0 ) >> 6 ) == 2 ) //<S2SV> offset += 2 ; //<S2SV> else //<S2SV> offset ++ ; //<S2SV> if ( offset >= image -> rows ) //<S2SV> { //<S2SV> base ++ ; //<S2SV> offset = base ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 