static Image * ReadPALMImage ( const ImageInfo * image_info , //<S2SV> ExceptionInfo * exception ) //<S2SV> { //<S2SV> Image //<S2SV> * image ; //<S2SV> IndexPacket //<S2SV> index ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> MagickOffsetType //<S2SV> totalOffset , //<S2SV> seekNextDepth ; //<S2SV> MagickPixelPacket //<S2SV> transpix ; //<S2SV> register IndexPacket //<S2SV> * indexes ; //<S2SV> register ssize_t //<S2SV> i , //<S2SV> x ; //<S2SV> register PixelPacket //<S2SV> * q ; //<S2SV> size_t //<S2SV> bytes_per_row , //<S2SV> flags , //<S2SV> bits_per_pixel , //<S2SV> version , //<S2SV> nextDepthOffset , //<S2SV> transparentIndex , //<S2SV> compressionType , //<S2SV> byte , //<S2SV> mask , //<S2SV> redbits , //<S2SV> greenbits , //<S2SV> bluebits , //<S2SV> one , //<S2SV> pad , //<S2SV> size , //<S2SV> bit ; //<S2SV> ssize_t //<S2SV> count , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * lastrow , //<S2SV> * one_row , //<S2SV> * ptr ; //<S2SV> unsigned short //<S2SV> color16 ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickSignature ) ; //<S2SV> image = AcquireImage ( image_info ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> ( void ) DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> totalOffset = 0 ; //<S2SV> do //<S2SV> { //<S2SV> image -> columns = ReadBlobMSBShort ( image ) ; //<S2SV> image -> rows = ReadBlobMSBShort ( image ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "NegativeOrZeroImageSize" ) ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> bytes_per_row = ReadBlobMSBShort ( image ) ; //<S2SV> flags = ReadBlobMSBShort ( image ) ; //<S2SV> bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && //<S2SV> ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && //<S2SV> ( bits_per_pixel != 16 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedBitsPerPixel" ) ; //<S2SV> version = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "FileFormatVersionMismatch" ) ; //<S2SV> nextDepthOffset = ( size_t ) ReadBlobMSBShort ( image ) ; //<S2SV> transparentIndex = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> compressionType = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> if ( ( compressionType != PALM_COMPRESSION_NONE ) && //<S2SV> ( compressionType != PALM_COMPRESSION_SCANLINE ) && //<S2SV> ( compressionType != PALM_COMPRESSION_RLE ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "UnrecognizedImageCompression" ) ; //<S2SV> pad = ReadBlobMSBShort ( image ) ; //<S2SV> ( void ) pad ; //<S2SV> one = 1 ; //<S2SV> if ( ( bits_per_pixel < 16 ) && //<S2SV> ( AcquireImageColormap ( image , one << bits_per_pixel ) == MagickFalse ) ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> GetMagickPixelPacket ( image , & transpix ) ; //<S2SV> if ( bits_per_pixel == 16 ) //<S2SV> { //<S2SV> redbits = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> ( void ) redbits ; //<S2SV> greenbits = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> ( void ) greenbits ; //<S2SV> bluebits = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> ( void ) bluebits ; //<S2SV> ReadBlobByte ( image ) ; //<S2SV> ReadBlobByte ( image ) ; //<S2SV> transpix . red = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; //<S2SV> transpix . green = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ; //<S2SV> transpix . blue = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; //<S2SV> } //<S2SV> if ( bits_per_pixel == 8 ) //<S2SV> { //<S2SV> IndexPacket //<S2SV> index ; //<S2SV> if ( flags & PALM_HAS_COLORMAP_FLAG ) //<S2SV> { //<S2SV> count = ( ssize_t ) ReadBlobMSBShort ( image ) ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) //<S2SV> { //<S2SV> ReadBlobByte ( image ) ; //<S2SV> index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ; //<S2SV> image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( //<S2SV> ( unsigned char ) ReadBlobByte ( image ) ) ; //<S2SV> image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( //<S2SV> ( unsigned char ) ReadBlobByte ( image ) ) ; //<S2SV> image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( //<S2SV> ( unsigned char ) ReadBlobByte ( image ) ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> for ( i = 0 ; i < ( ssize_t ) ( 1L << bits_per_pixel ) ; i ++ ) //<S2SV> { //<S2SV> index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ; //<S2SV> image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( //<S2SV> PalmPalette [ i ] [ 0 ] ) ; //<S2SV> image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( //<S2SV> PalmPalette [ i ] [ 1 ] ) ; //<S2SV> image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( //<S2SV> PalmPalette [ i ] [ 2 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( flags & PALM_IS_COMPRESSED_FLAG ) //<S2SV> size = ReadBlobMSBShort ( image ) ; //<S2SV> ( void ) size ; //<S2SV> image -> storage_class = DirectClass ; //<S2SV> if ( bits_per_pixel < 16 ) //<S2SV> { //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> image -> depth = 8 ; //<S2SV> } //<S2SV> if ( image_info -> ping != MagickFalse ) //<S2SV> { //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( image ) ; //<S2SV> } //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> InheritException ( exception , & image -> exception ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , //<S2SV> 2 * image -> columns ) , sizeof ( * one_row ) ) ; //<S2SV> if ( one_row == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> lastrow = ( unsigned char * ) NULL ; //<S2SV> if ( compressionType == PALM_COMPRESSION_SCANLINE ) //<S2SV> { //<S2SV> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , //<S2SV> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; //<S2SV> if ( lastrow == ( unsigned char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> mask = ( size_t ) ( 1U << bits_per_pixel ) - 1 ; //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> if ( ( flags & PALM_IS_COMPRESSED_FLAG ) == 0 ) //<S2SV> { //<S2SV> image -> compression = NoCompression ; //<S2SV> count = ReadBlob ( image , bytes_per_row , one_row ) ; //<S2SV> if ( count != ( ssize_t ) bytes_per_row ) //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( compressionType == PALM_COMPRESSION_RLE ) //<S2SV> { //<S2SV> image -> compression = RLECompression ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) //<S2SV> { //<S2SV> count = ( ssize_t ) ReadBlobByte ( image ) ; //<S2SV> if ( count < 0 ) //<S2SV> break ; //<S2SV> count = MagickMin ( count , ( ssize_t ) bytes_per_row - i ) ; //<S2SV> byte = ( size_t ) ReadBlobByte ( image ) ; //<S2SV> ( void ) ResetMagickMemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; //<S2SV> i += count ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> if ( compressionType == PALM_COMPRESSION_SCANLINE ) //<S2SV> { //<S2SV> size_t //<S2SV> one ; //<S2SV> one = 1 ; //<S2SV> image -> compression = FaxCompression ; //<S2SV> for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) //<S2SV> { //<S2SV> count = ( ssize_t ) ReadBlobByte ( image ) ; //<S2SV> if ( count < 0 ) //<S2SV> break ; //<S2SV> byte = ( size_t ) MagickMin ( ( ssize_t ) bytes_per_row - i , 8 ) ; //<S2SV> for ( bit = 0 ; bit < byte ; bit ++ ) //<S2SV> { //<S2SV> if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) //<S2SV> one_row [ i + bit ] = ( unsigned char ) ReadBlobByte ( image ) ; //<S2SV> else //<S2SV> one_row [ i + bit ] = lastrow [ i + bit ] ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; //<S2SV> } //<S2SV> } //<S2SV> ptr = one_row ; //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( PixelPacket * ) NULL ) //<S2SV> break ; //<S2SV> indexes = GetAuthenticIndexQueue ( image ) ; //<S2SV> if ( bits_per_pixel == 16 ) //<S2SV> { //<S2SV> if ( image -> columns > ( 2 * bytes_per_row ) ) //<S2SV> { //<S2SV> one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; //<S2SV> if ( compressionType == PALM_COMPRESSION_SCANLINE ) //<S2SV> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> color16 = ( * ptr ++ << 8 ) ; //<S2SV> color16 |= ( * ptr ++ ) ; //<S2SV> SetPixelRed ( q , ( QuantumRange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) ; //<S2SV> SetPixelGreen ( q , ( QuantumRange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) ; //<S2SV> SetPixelBlue ( q , ( QuantumRange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) ; //<S2SV> SetPixelOpacity ( q , OpaqueOpacity ) ; //<S2SV> q ++ ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> bit = 8 - bits_per_pixel ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) //<S2SV> { //<S2SV> one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; //<S2SV> if ( compressionType == PALM_COMPRESSION_SCANLINE ) //<S2SV> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; //<S2SV> } //<S2SV> index = ( IndexPacket ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; //<S2SV> SetPixelIndex ( indexes + x , index ) ; //<S2SV> SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; //<S2SV> if ( bit ) //<S2SV> bit -= bits_per_pixel ; //<S2SV> else //<S2SV> { //<S2SV> ptr ++ ; //<S2SV> bit = 8 - bits_per_pixel ; //<S2SV> } //<S2SV> q ++ ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( image -> previous == ( Image * ) NULL ) //<S2SV> { //<S2SV> status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , //<S2SV> image -> rows ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( flags & PALM_HAS_TRANSPARENCY_FLAG ) //<S2SV> { //<S2SV> IndexPacket index = ConstrainColormapIndex ( image , ( mask - transparentIndex ) ) ; //<S2SV> if ( bits_per_pixel != 16 ) //<S2SV> SetMagickPixelPacket ( image , image -> colormap + ( ssize_t ) index , //<S2SV> ( const IndexPacket * ) NULL , & transpix ) ; //<S2SV> ( void ) TransparentPaintImage ( image , & transpix , ( Quantum ) //<S2SV> TransparentOpacity , MagickFalse ) ; //<S2SV> } //<S2SV> one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; //<S2SV> if ( compressionType == PALM_COMPRESSION_SCANLINE ) //<S2SV> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; //<S2SV> if ( EOFBlob ( image ) != MagickFalse ) //<S2SV> { //<S2SV> ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , //<S2SV> image -> filename ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( image_info -> number_scenes != 0 ) //<S2SV> if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) //<S2SV> break ; //<S2SV> if ( nextDepthOffset != 0 ) //<S2SV> { //<S2SV> totalOffset += ( MagickOffsetType ) ( nextDepthOffset * 4 ) ; //<S2SV> if ( totalOffset >= ( MagickOffsetType ) GetBlobSize ( image ) ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) //<S2SV> else //<S2SV> seekNextDepth = SeekBlob ( image , totalOffset , SEEK_SET ) ; //<S2SV> if ( seekNextDepth != totalOffset ) //<S2SV> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; //<S2SV> AcquireNextImage ( image_info , image ) ; //<S2SV> if ( GetNextImageInList ( image ) == ( Image * ) NULL ) //<S2SV> { //<S2SV> ( void ) DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> image = SyncNextImageInList ( image ) ; //<S2SV> status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , //<S2SV> GetBlobSize ( image ) ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> } while ( nextDepthOffset != 0 ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 