static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) //<S2SV> { //<S2SV> char //<S2SV> * sixel_buffer ; //<S2SV> Image //<S2SV> * image ; //<S2SV> MagickBooleanType //<S2SV> status ; //<S2SV> register char //<S2SV> * p ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> register Quantum //<S2SV> * q ; //<S2SV> size_t //<S2SV> length ; //<S2SV> ssize_t //<S2SV> i , //<S2SV> j , //<S2SV> y ; //<S2SV> unsigned char //<S2SV> * sixel_pixels , //<S2SV> * sixel_palette ; //<S2SV> assert ( image_info != ( const ImageInfo * ) NULL ) ; //<S2SV> assert ( image_info -> signature == MagickCoreSignature ) ; //<S2SV> if ( image_info -> debug != MagickFalse ) //<S2SV> ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , //<S2SV> image_info -> filename ) ; //<S2SV> assert ( exception != ( ExceptionInfo * ) NULL ) ; //<S2SV> assert ( exception -> signature == MagickCoreSignature ) ; //<S2SV> image = AcquireImage ( image_info , exception ) ; //<S2SV> status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> image = DestroyImageList ( image ) ; //<S2SV> return ( ( Image * ) NULL ) ; //<S2SV> } //<S2SV> length = MagickPathExtent ; //<S2SV> sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , //<S2SV> sizeof ( * sixel_buffer ) ) ; //<S2SV> p = sixel_buffer ; //<S2SV> if ( sixel_buffer != ( char * ) NULL ) //<S2SV> while ( ReadBlobString ( image , p ) != ( char * ) NULL ) //<S2SV> { //<S2SV> if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) //<S2SV> continue ; //<S2SV> if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) //<S2SV> break ; //<S2SV> p += strlen ( p ) ; //<S2SV> if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) //<S2SV> continue ; //<S2SV> length <<= 1 ; //<S2SV> sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + //<S2SV> MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; //<S2SV> if ( sixel_buffer == ( char * ) NULL ) //<S2SV> break ; //<S2SV> p = sixel_buffer + strlen ( sixel_buffer ) ; //<S2SV> } //<S2SV> if ( sixel_buffer == ( char * ) NULL ) //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> sixel_buffer [ length ] = '\\0' ; //<S2SV> if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) //<S2SV> { //<S2SV> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; //<S2SV> } //<S2SV> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; //<S2SV> image -> depth = 24 ; //<S2SV> image -> storage_class = PseudoClass ; //<S2SV> status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; //<S2SV> if ( status == MagickFalse ) //<S2SV> { //<S2SV> sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; //<S2SV> sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; //<S2SV> return ( DestroyImageList ( image ) ) ; //<S2SV> } //<S2SV> if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) //<S2SV> { //<S2SV> sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; //<S2SV> sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; //<S2SV> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { //<S2SV> image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; //<S2SV> image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; //<S2SV> image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; //<S2SV> } //<S2SV> j = 0 ; //<S2SV> if ( image_info -> ping == MagickFalse ) //<S2SV> { //<S2SV> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) //<S2SV> { //<S2SV> q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; //<S2SV> if ( q == ( Quantum * ) NULL ) //<S2SV> break ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) //<S2SV> { //<S2SV> j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; //<S2SV> SetPixelIndex ( image , j , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( y < ( ssize_t ) image -> rows ) //<S2SV> { //<S2SV> sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; //<S2SV> sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; //<S2SV> ThrowReaderException ( CorruptImageError , "NotEnoughPixelData" ) ; //<S2SV> } //<S2SV> } //<S2SV> sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; //<S2SV> sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; //<S2SV> ( void ) CloseBlob ( image ) ; //<S2SV> return ( GetFirstImageInList ( image ) ) ; //<S2SV> } //<S2SV> 