static void ImportCbYCrYQuantum ( const Image * image , QuantumInfo * quantum_info , //<S2SV> const MagickSizeType number_pixels , const unsigned char * magick_restrict p , //<S2SV> Quantum * magick_restrict q , ExceptionInfo * exception ) //<S2SV> { //<S2SV> QuantumAny //<S2SV> range ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> unsigned int //<S2SV> pixel ; //<S2SV> assert ( image != ( Image * ) NULL ) ; //<S2SV> assert ( image -> signature == MagickCoreSignature ) ; //<S2SV> switch ( quantum_info -> depth ) //<S2SV> { //<S2SV> case 10 : //<S2SV> { //<S2SV> Quantum //<S2SV> cbcr [ 4 ] ; //<S2SV> pixel = 0 ; //<S2SV> if ( quantum_info -> pack == MagickFalse ) //<S2SV> { //<S2SV> register ssize_t //<S2SV> i ; //<S2SV> size_t //<S2SV> quantum ; //<S2SV> ssize_t //<S2SV> n ; //<S2SV> n = 0 ; //<S2SV> quantum = 0 ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x += 2 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> { //<S2SV> switch ( n % 3 ) //<S2SV> { //<S2SV> case 0 : //<S2SV> { //<S2SV> p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) //<S2SV> ( ( ( pixel >> 22 ) & 0x3ff ) << 6 ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 1 : //<S2SV> { //<S2SV> quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) //<S2SV> ( ( ( pixel >> 12 ) & 0x3ff ) << 6 ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case 2 : //<S2SV> { //<S2SV> quantum = ( size_t ) ( ScaleShortToQuantum ( ( unsigned short ) //<S2SV> ( ( ( pixel >> 2 ) & 0x3ff ) << 6 ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> cbcr [ i ] = ( Quantum ) ( quantum ) ; //<S2SV> n ++ ; //<S2SV> } //<S2SV> p += quantum_info -> pad ; //<S2SV> SetPixelRed ( image , cbcr [ 1 ] , q ) ; //<S2SV> SetPixelGreen ( image , cbcr [ 0 ] , q ) ; //<S2SV> SetPixelBlue ( image , cbcr [ 2 ] , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> SetPixelRed ( image , cbcr [ 3 ] , q ) ; //<S2SV> SetPixelGreen ( image , cbcr [ 0 ] , q ) ; //<S2SV> SetPixelBlue ( image , cbcr [ 2 ] , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> range = GetQuantumRange ( quantum_info -> depth ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushQuantumPixel ( quantum_info , p , & pixel ) ; //<S2SV> SetPixelRed ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; //<S2SV> p = PushQuantumPixel ( quantum_info , p , & pixel ) ; //<S2SV> SetPixelGreen ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 