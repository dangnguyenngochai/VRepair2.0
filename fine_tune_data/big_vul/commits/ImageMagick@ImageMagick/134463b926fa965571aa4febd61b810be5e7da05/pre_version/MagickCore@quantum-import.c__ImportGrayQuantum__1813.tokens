static void ImportGrayQuantum ( const Image * image , QuantumInfo * quantum_info , //<S2SV> const MagickSizeType number_pixels , const unsigned char * magick_restrict p , //<S2SV> Quantum * magick_restrict q , ExceptionInfo * exception ) //<S2SV> { //<S2SV> QuantumAny //<S2SV> range ; //<S2SV> register ssize_t //<S2SV> x ; //<S2SV> ssize_t //<S2SV> bit ; //<S2SV> unsigned int //<S2SV> pixel ; //<S2SV> assert ( image != ( Image * ) NULL ) ; //<S2SV> assert ( image -> signature == MagickCoreSignature ) ; //<S2SV> switch ( quantum_info -> depth ) //<S2SV> { //<S2SV> case 1 : //<S2SV> { //<S2SV> register Quantum //<S2SV> black , //<S2SV> white ; //<S2SV> black = 0 ; //<S2SV> white = QuantumRange ; //<S2SV> if ( quantum_info -> min_is_white != MagickFalse ) //<S2SV> { //<S2SV> black = QuantumRange ; //<S2SV> white = 0 ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 7 ) ; x += 8 ) //<S2SV> { //<S2SV> for ( bit = 0 ; bit < 8 ; bit ++ ) //<S2SV> { //<S2SV> SetPixelGray ( image , ( ( * p ) & ( 1 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> } //<S2SV> for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 8 ) ; bit ++ ) //<S2SV> { //<S2SV> SetPixelGray ( image , ( ( * p ) & ( 0x01 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( bit != 0 ) //<S2SV> p ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> case 4 : //<S2SV> { //<S2SV> register unsigned char //<S2SV> pixel ; //<S2SV> range = GetQuantumRange ( quantum_info -> depth ) ; //<S2SV> for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 1 ) ; x += 2 ) //<S2SV> { //<S2SV> pixel = ( unsigned char ) ( ( * p >> 4 ) & 0xf ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> pixel = ( unsigned char ) ( ( * p ) & 0xf ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; //<S2SV> p ++ ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 2 ) ; bit ++ ) //<S2SV> { //<S2SV> pixel = ( unsigned char ) ( * p ++ >> 4 ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 8 : //<S2SV> { //<S2SV> unsigned char //<S2SV> pixel ; //<S2SV> if ( quantum_info -> min_is_white != MagickFalse ) //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushCharPixel ( p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ; //<S2SV> SetPixelAlpha ( image , OpaqueAlpha , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushCharPixel ( p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleCharToQuantum ( pixel ) , q ) ; //<S2SV> SetPixelAlpha ( image , OpaqueAlpha , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 10 : //<S2SV> { //<S2SV> range = GetQuantumRange ( quantum_info -> depth ) ; //<S2SV> if ( quantum_info -> pack == MagickFalse ) //<S2SV> { //<S2SV> if ( image -> endian == LSBEndian ) //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 2 ) ; x += 3 ) //<S2SV> { //<S2SV> p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , //<S2SV> range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , //<S2SV> range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , //<S2SV> range ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) //<S2SV> { //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , //<S2SV> range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( x ++ < ( ssize_t ) number_pixels ) //<S2SV> { //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , //<S2SV> range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 2 ) ; x += 3 ) //<S2SV> { //<S2SV> p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , range ) , //<S2SV> q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , range ) , //<S2SV> q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 22 ) & 0x3ff , range ) , //<S2SV> q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> if ( x ++ < ( ssize_t ) ( number_pixels - 1 ) ) //<S2SV> { //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 2 ) & 0x3ff , //<S2SV> range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( x ++ < ( ssize_t ) number_pixels ) //<S2SV> { //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( pixel >> 12 ) & 0x3ff , //<S2SV> range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushQuantumPixel ( quantum_info , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 12 : //<S2SV> { //<S2SV> range = GetQuantumRange ( quantum_info -> depth ) ; //<S2SV> if ( quantum_info -> pack == MagickFalse ) //<S2SV> { //<S2SV> unsigned short //<S2SV> pixel ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) ( number_pixels - 1 ) ; x += 2 ) //<S2SV> { //<S2SV> p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , //<S2SV> range ) , q ) ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , //<S2SV> range ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 2 ) ; bit ++ ) //<S2SV> { //<S2SV> p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( ( QuantumAny ) ( pixel >> 4 ) , //<S2SV> range ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> if ( bit != 0 ) //<S2SV> p ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushQuantumPixel ( quantum_info , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 16 : //<S2SV> { //<S2SV> unsigned short //<S2SV> pixel ; //<S2SV> if ( quantum_info -> min_is_white != MagickFalse ) //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> if ( quantum_info -> format == FloatingPointQuantumFormat ) //<S2SV> { //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ClampToQuantum ( QuantumRange * //<S2SV> HalfToSinglePrecision ( pixel ) ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushShortPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleShortToQuantum ( pixel ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 32 : //<S2SV> { //<S2SV> unsigned int //<S2SV> pixel ; //<S2SV> if ( quantum_info -> format == FloatingPointQuantumFormat ) //<S2SV> { //<S2SV> float //<S2SV> pixel ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushFloatPixel ( quantum_info , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushLongPixel ( quantum_info -> endian , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleLongToQuantum ( pixel ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case 64 : //<S2SV> { //<S2SV> if ( quantum_info -> format == FloatingPointQuantumFormat ) //<S2SV> { //<S2SV> double //<S2SV> pixel ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushDoublePixel ( quantum_info , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ClampToQuantum ( pixel ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> default : //<S2SV> { //<S2SV> range = GetQuantumRange ( quantum_info -> depth ) ; //<S2SV> for ( x = 0 ; x < ( ssize_t ) number_pixels ; x ++ ) //<S2SV> { //<S2SV> p = PushQuantumPixel ( quantum_info , p , & pixel ) ; //<S2SV> SetPixelGray ( image , ScaleAnyToQuantum ( pixel , range ) , q ) ; //<S2SV> p += quantum_info -> pad ; //<S2SV> q += GetPixelChannels ( image ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 