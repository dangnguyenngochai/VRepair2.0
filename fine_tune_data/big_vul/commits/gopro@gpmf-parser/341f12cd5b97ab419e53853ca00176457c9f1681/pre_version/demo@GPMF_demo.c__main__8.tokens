int main ( int argc , char * argv [ ] ) //<S2SV> { //<S2SV> int32_t ret = GPMF_OK ; //<S2SV> GPMF_stream metadata_stream , * ms = & metadata_stream ; //<S2SV> double metadatalength ; //<S2SV> uint32_t * payload = NULL ; //<S2SV> if ( argc != 2 ) //<S2SV> { //<S2SV> printf ( "usage:<S2SV_blank>%s<S2SV_blank><file_with_GPMF>\\n" , argv [ 0 ] ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> size_t mp4 = OpenMP4Source ( argv [ 1 ] , MOV_GPMF_TRAK_TYPE , MOV_GPMF_TRAK_SUBTYPE ) ; //<S2SV> metadatalength = GetDuration ( mp4 ) ; //<S2SV> if ( metadatalength > 0.0 ) //<S2SV> { //<S2SV> uint32_t index , payloads = GetNumberPayloads ( mp4 ) ; //<S2SV> # if 1 //<S2SV> if ( payloads == 1 ) //<S2SV> { //<S2SV> uint32_t payloadsize = GetPayloadSize ( mp4 , 0 ) ; //<S2SV> payload = GetPayload ( mp4 , payload , 0 ) ; //<S2SV> if ( payload == NULL ) //<S2SV> goto cleanup ; //<S2SV> ret = GPMF_Init ( ms , payload , payloadsize ) ; //<S2SV> if ( ret != GPMF_OK ) //<S2SV> goto cleanup ; //<S2SV> ret = GPMF_Validate ( ms , GPMF_RECURSE_LEVELS ) ; //<S2SV> if ( GPMF_OK != ret ) //<S2SV> { //<S2SV> printf ( "Invalid<S2SV_blank>Structure\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> GPMF_ResetState ( ms ) ; //<S2SV> do //<S2SV> { //<S2SV> PrintGPMF ( ms ) ; //<S2SV> } while ( GPMF_OK == GPMF_Next ( ms , GPMF_RECURSE_LEVELS ) ) ; //<S2SV> GPMF_ResetState ( ms ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> for ( index = 0 ; index < payloads ; index ++ ) //<S2SV> { //<S2SV> uint32_t payloadsize = GetPayloadSize ( mp4 , index ) ; //<S2SV> float in = 0.0 , out = 0.0 ; //<S2SV> payload = GetPayload ( mp4 , payload , index ) ; //<S2SV> if ( payload == NULL ) //<S2SV> goto cleanup ; //<S2SV> ret = GetPayloadTime ( mp4 , index , & in , & out ) ; //<S2SV> if ( ret != GPMF_OK ) //<S2SV> goto cleanup ; //<S2SV> ret = GPMF_Init ( ms , payload , payloadsize ) ; //<S2SV> if ( ret != GPMF_OK ) //<S2SV> goto cleanup ; //<S2SV> # if 1 //<S2SV> if ( index == 0 ) //<S2SV> { //<S2SV> ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; //<S2SV> while ( GPMF_OK == ret ) //<S2SV> { //<S2SV> ret = GPMF_SeekToSamples ( ms ) ; //<S2SV> if ( GPMF_OK == ret ) //<S2SV> { //<S2SV> uint32_t key = GPMF_Key ( ms ) ; //<S2SV> GPMF_SampleType type = GPMF_Type ( ms ) ; //<S2SV> uint32_t elements = GPMF_ElementsInStruct ( ms ) ; //<S2SV> uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; //<S2SV> if ( samples ) //<S2SV> { //<S2SV> printf ( "<S2SV_blank><S2SV_blank>STRM<S2SV_blank>of<S2SV_blank>%c%c%c%c<S2SV_blank>" , PRINTF_4CC ( key ) ) ; //<S2SV> if ( type == GPMF_TYPE_COMPLEX ) //<S2SV> { //<S2SV> GPMF_stream find_stream ; //<S2SV> GPMF_CopyState ( ms , & find_stream ) ; //<S2SV> if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TYPE , GPMF_CURRENT_LEVEL ) ) //<S2SV> { //<S2SV> char tmp [ 64 ] ; //<S2SV> char * data = ( char * ) GPMF_RawData ( & find_stream ) ; //<S2SV> int size = GPMF_RawDataSize ( & find_stream ) ; //<S2SV> if ( size < sizeof ( tmp ) ) //<S2SV> { //<S2SV> memcpy ( tmp , data , size ) ; //<S2SV> tmp [ size ] = 0 ; //<S2SV> printf ( "of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>" , tmp ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> printf ( "of<S2SV_blank>type<S2SV_blank>%c<S2SV_blank>" , type ) ; //<S2SV> } //<S2SV> printf ( "with<S2SV_blank>%d<S2SV_blank>sample%s<S2SV_blank>" , samples , samples > 1 ? "s" : "" ) ; //<S2SV> if ( elements > 1 ) //<S2SV> printf ( "--<S2SV_blank>%d<S2SV_blank>elements<S2SV_blank>per<S2SV_blank>sample" , elements ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ret == GPMF_ERROR_BAD_STRUCTURE ) //<S2SV> { //<S2SV> ret = GPMF_Next ( ms , GPMF_CURRENT_LEVEL ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> GPMF_ResetState ( ms ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # if 1 //<S2SV> if ( index == 0 ) //<S2SV> { //<S2SV> if ( GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( "GPS5" ) , GPMF_RECURSE_LEVELS ) || //<S2SV> GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( "GPRI" ) , GPMF_RECURSE_LEVELS ) ) //<S2SV> { //<S2SV> uint32_t key = GPMF_Key ( ms ) ; //<S2SV> uint32_t samples = GPMF_Repeat ( ms ) ; //<S2SV> uint32_t elements = GPMF_ElementsInStruct ( ms ) ; //<S2SV> uint32_t buffersize = samples * elements * sizeof ( double ) ; //<S2SV> GPMF_stream find_stream ; //<S2SV> double * ptr , * tmpbuffer = malloc ( buffersize ) ; //<S2SV> char units [ 10 ] [ 6 ] = { "" } ; //<S2SV> uint32_t unit_samples = 1 ; //<S2SV> printf ( "MP4<S2SV_blank>Payload<S2SV_blank>time<S2SV_blank>%.3f<S2SV_blank>to<S2SV_blank>%.3f<S2SV_blank>seconds\\n" , in , out ) ; //<S2SV> if ( tmpbuffer && samples ) //<S2SV> { //<S2SV> uint32_t i , j ; //<S2SV> GPMF_CopyState ( ms , & find_stream ) ; //<S2SV> if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_SI_UNITS , GPMF_CURRENT_LEVEL ) || //<S2SV> GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_UNITS , GPMF_CURRENT_LEVEL ) ) //<S2SV> { //<S2SV> char * data = ( char * ) GPMF_RawData ( & find_stream ) ; //<S2SV> int ssize = GPMF_StructSize ( & find_stream ) ; //<S2SV> unit_samples = GPMF_Repeat ( & find_stream ) ; //<S2SV> for ( i = 0 ; i < unit_samples ; i ++ ) //<S2SV> { //<S2SV> memcpy ( units [ i ] , data , ssize ) ; //<S2SV> units [ i ] [ ssize ] = 0 ; //<S2SV> data += ssize ; //<S2SV> } //<S2SV> } //<S2SV> GPMF_ScaledData ( ms , tmpbuffer , buffersize , 0 , samples , GPMF_TYPE_DOUBLE ) ; //<S2SV> ptr = tmpbuffer ; //<S2SV> for ( i = 0 ; i < samples ; i ++ ) //<S2SV> { //<S2SV> printf ( "%c%c%c%c<S2SV_blank>" , PRINTF_4CC ( key ) ) ; //<S2SV> for ( j = 0 ; j < elements ; j ++ ) //<S2SV> printf ( "%.3f%s,<S2SV_blank>" , * ptr ++ , units [ j % unit_samples ] ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> free ( tmpbuffer ) ; //<S2SV> } //<S2SV> } //<S2SV> GPMF_ResetState ( ms ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> # if 1 //<S2SV> while ( GPMF_OK == GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ) //<S2SV> { //<S2SV> if ( GPMF_OK == GPMF_SeekToSamples ( ms ) ) //<S2SV> { //<S2SV> uint32_t fourcc = GPMF_Key ( ms ) ; //<S2SV> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; //<S2SV> printf ( "%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n" , PRINTF_4CC ( fourcc ) , rate ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> cleanup : //<S2SV> if ( payload ) FreePayload ( payload ) ; payload = NULL ; //<S2SV> CloseSource ( mp4 ) ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 