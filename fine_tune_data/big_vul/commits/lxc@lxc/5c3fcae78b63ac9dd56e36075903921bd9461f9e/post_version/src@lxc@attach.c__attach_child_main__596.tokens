static int attach_child_main ( void * data ) //<S2SV> { //<S2SV> struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; //<S2SV> int ipc_socket = payload -> ipc_socket ; //<S2SV> int procfd = payload -> procfd ; //<S2SV> lxc_attach_options_t * options = payload -> options ; //<S2SV> struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; //<S2SV> # if HAVE_SYS_PERSONALITY_H //<S2SV> long new_personality ; //<S2SV> # endif //<S2SV> int ret ; //<S2SV> int status ; //<S2SV> int expected ; //<S2SV> long flags ; //<S2SV> int fd ; //<S2SV> uid_t new_uid ; //<S2SV> gid_t new_gid ; //<S2SV> expected = 0 ; //<S2SV> status = - 1 ; //<S2SV> ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { //<S2SV> ret = lxc_attach_remount_sys_proc ( ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> # if HAVE_SYS_PERSONALITY_H //<S2SV> if ( options -> personality < 0 ) //<S2SV> new_personality = init_ctx -> personality ; //<S2SV> else //<S2SV> new_personality = options -> personality ; //<S2SV> if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { //<S2SV> ret = personality ( new_personality ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> SYSERROR ( "could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { //<S2SV> ret = lxc_attach_drop_privs ( init_ctx ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> ERROR ( "could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> ERROR ( "could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> new_uid = 0 ; //<S2SV> new_gid = 0 ; //<S2SV> if ( options -> namespaces & CLONE_NEWUSER ) //<S2SV> lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; //<S2SV> if ( options -> uid != ( uid_t ) - 1 ) //<S2SV> new_uid = options -> uid ; //<S2SV> if ( options -> gid != ( gid_t ) - 1 ) //<S2SV> new_gid = options -> gid ; //<S2SV> if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { //<S2SV> if ( setsid ( ) < 0 ) { //<S2SV> SYSERROR ( "unable<S2SV_blank>to<S2SV_blank>setsid" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { //<S2SV> SYSERROR ( "unable<S2SV_blank>to<S2SV_blank>TIOCSTTY" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { //<S2SV> if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { //<S2SV> SYSERROR ( "switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { //<S2SV> SYSERROR ( "switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> status = 1 ; //<S2SV> ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; //<S2SV> if ( ret != sizeof ( status ) ) { //<S2SV> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> expected = 2 ; //<S2SV> status = - 1 ; //<S2SV> ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)" ) ; //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> shutdown ( ipc_socket , SHUT_RDWR ) ; //<S2SV> close ( ipc_socket ) ; //<S2SV> if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { //<S2SV> int on_exec ; //<S2SV> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; //<S2SV> if ( lsm_set_label_at ( procfd , on_exec , init_ctx -> lsm_label ) < 0 ) { //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( init_ctx -> container && init_ctx -> container -> lxc_conf && //<S2SV> lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) { //<S2SV> ERROR ( "Loading<S2SV_blank>seccomp<S2SV_blank>policy" ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> lxc_proc_put_context_info ( init_ctx ) ; //<S2SV> if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) //<S2SV> dup2 ( options -> stdin_fd , 0 ) ; //<S2SV> if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) //<S2SV> dup2 ( options -> stdout_fd , 1 ) ; //<S2SV> if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) //<S2SV> dup2 ( options -> stderr_fd , 2 ) ; //<S2SV> if ( options -> stdin_fd > 2 ) //<S2SV> close ( options -> stdin_fd ) ; //<S2SV> if ( options -> stdout_fd > 2 ) //<S2SV> close ( options -> stdout_fd ) ; //<S2SV> if ( options -> stderr_fd > 2 ) //<S2SV> close ( options -> stderr_fd ) ; //<S2SV> for ( fd = 0 ; fd <= 2 ; fd ++ ) { //<S2SV> flags = fcntl ( fd , F_GETFL ) ; //<S2SV> if ( flags < 0 ) //<S2SV> continue ; //<S2SV> if ( flags & FD_CLOEXEC ) { //<S2SV> if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) { //<S2SV> SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> close ( procfd ) ; //<S2SV> rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; //<S2SV> } //<S2SV> 