int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) //<S2SV> { //<S2SV> int ret , status ; //<S2SV> pid_t init_pid , pid , attached_pid , expected ; //<S2SV> struct lxc_proc_context_info * init_ctx ; //<S2SV> char * cwd ; //<S2SV> char * new_cwd ; //<S2SV> int ipc_sockets [ 2 ] ; //<S2SV> signed long personality ; //<S2SV> if ( ! options ) //<S2SV> options = & attach_static_default_options ; //<S2SV> init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; //<S2SV> if ( init_pid < 0 ) { //<S2SV> ERROR ( "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> init_ctx = lxc_proc_get_context_info ( init_pid ) ; //<S2SV> if ( ! init_ctx ) { //<S2SV> ERROR ( "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld" , ( long ) init_pid ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> personality = get_personality ( name , lxcpath ) ; //<S2SV> if ( init_ctx -> personality < 0 ) { //<S2SV> ERROR ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container" ) ; //<S2SV> lxc_proc_put_context_info ( init_ctx ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> init_ctx -> personality = personality ; //<S2SV> init_ctx -> container = lxc_container_new ( name , lxcpath ) ; //<S2SV> if ( ! init_ctx -> container ) //<S2SV> return - 1 ; //<S2SV> if ( ! fetch_seccomp ( init_ctx -> container , options ) ) //<S2SV> WARN ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy" ) ; //<S2SV> if ( ! no_new_privs ( init_ctx -> container , options ) ) //<S2SV> WARN ( "Could<S2SV_blank>not<S2SV_blank>determine<S2SV_blank>whether<S2SV_blank>PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set." ) ; //<S2SV> cwd = getcwd ( NULL , 0 ) ; //<S2SV> if ( options -> namespaces == - 1 ) { //<S2SV> options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; //<S2SV> if ( options -> namespaces == - 1 ) { //<S2SV> ERROR ( "failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>" //<S2SV> "namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared" ) ; //<S2SV> free ( cwd ) ; //<S2SV> lxc_proc_put_context_info ( init_ctx ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> SYSERROR ( "could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching" ) ; //<S2SV> free ( cwd ) ; //<S2SV> lxc_proc_put_context_info ( init_ctx ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> pid = fork ( ) ; //<S2SV> if ( pid < 0 ) { //<S2SV> SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess" ) ; //<S2SV> free ( cwd ) ; //<S2SV> lxc_proc_put_context_info ( init_ctx ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( pid ) { //<S2SV> int procfd = - 1 ; //<S2SV> pid_t to_cleanup_pid = pid ; //<S2SV> close ( ipc_sockets [ 1 ] ) ; //<S2SV> free ( cwd ) ; //<S2SV> if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { //<S2SV> if ( ! cgroup_attach ( name , lxcpath , pid ) ) //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> procfd = open ( "/proc" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; //<S2SV> if ( procfd < 0 ) { //<S2SV> SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc." ) ; //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> status = 0 ; //<S2SV> ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" ) ; //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> if ( ret != 0 ) //<S2SV> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process" ) ; //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> if ( options -> stdin_fd == 0 ) { //<S2SV> signal ( SIGINT , SIG_IGN ) ; //<S2SV> signal ( SIGQUIT , SIG_IGN ) ; //<S2SV> } //<S2SV> ret = wait_for_pid ( pid ) ; //<S2SV> if ( ret < 0 ) //<S2SV> goto cleanup_error ; //<S2SV> to_cleanup_pid = attached_pid ; //<S2SV> status = 0 ; //<S2SV> ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" ) ; //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> expected = 1 ; //<S2SV> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> if ( ret != 0 ) //<S2SV> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>" //<S2SV> "from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)" ) ; //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> status = 2 ; //<S2SV> ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>" //<S2SV> "initialization<S2SV_blank>(2):<S2SV_blank>%s." , strerror ( errno ) ) ; //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> expected = 3 ; //<S2SV> ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s." , //<S2SV> strerror ( errno ) ) ; //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { //<S2SV> int on_exec , labelfd ; //<S2SV> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; //<S2SV> labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; //<S2SV> if ( labelfd < 0 ) //<S2SV> goto cleanup_error ; //<S2SV> ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , //<S2SV> strerror ( errno ) ) ; //<S2SV> goto cleanup_error ; //<S2SV> } //<S2SV> } //<S2SV> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; //<S2SV> close ( ipc_sockets [ 0 ] ) ; //<S2SV> lxc_proc_put_context_info ( init_ctx ) ; //<S2SV> * attached_process = attached_pid ; //<S2SV> return 0 ; //<S2SV> cleanup_error : //<S2SV> if ( procfd >= 0 ) //<S2SV> close ( procfd ) ; //<S2SV> shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; //<S2SV> close ( ipc_sockets [ 0 ] ) ; //<S2SV> if ( to_cleanup_pid ) //<S2SV> ( void ) wait_for_pid ( to_cleanup_pid ) ; //<S2SV> lxc_proc_put_context_info ( init_ctx ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> close ( ipc_sockets [ 0 ] ) ; //<S2SV> expected = 0 ; //<S2SV> status = - 1 ; //<S2SV> ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; //<S2SV> if ( ret <= 0 ) { //<S2SV> ERROR ( "error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process" ) ; //<S2SV> shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> if ( ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) && cgns_supported ( ) ) //<S2SV> options -> namespaces |= CLONE_NEWCGROUP ; //<S2SV> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; //<S2SV> if ( ret < 0 ) { //<S2SV> ERROR ( "failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace" ) ; //<S2SV> shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> if ( options -> initial_cwd ) //<S2SV> new_cwd = options -> initial_cwd ; //<S2SV> else //<S2SV> new_cwd = cwd ; //<S2SV> ret = chdir ( new_cwd ) ; //<S2SV> if ( ret < 0 ) //<S2SV> WARN ( "could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'" , new_cwd ) ; //<S2SV> free ( cwd ) ; //<S2SV> { //<S2SV> struct attach_clone_payload payload = { //<S2SV> . ipc_socket = ipc_sockets [ 1 ] , //<S2SV> . options = options , //<S2SV> . init_ctx = init_ctx , //<S2SV> . exec_function = exec_function , //<S2SV> . exec_payload = exec_payload , //<S2SV> } ; //<S2SV> pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; //<S2SV> } //<S2SV> if ( pid <= 0 ) { //<S2SV> SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess" ) ; //<S2SV> shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; //<S2SV> if ( ret != sizeof ( pid ) ) { //<S2SV> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process" ) ; //<S2SV> shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; //<S2SV> rexit ( - 1 ) ; //<S2SV> } //<S2SV> rexit ( 0 ) ; //<S2SV> } //<S2SV> 