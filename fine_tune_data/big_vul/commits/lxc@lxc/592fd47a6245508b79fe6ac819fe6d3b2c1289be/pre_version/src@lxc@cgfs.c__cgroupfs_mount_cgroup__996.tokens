static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) //<S2SV> { //<S2SV> size_t bufsz = strlen ( root ) + sizeof ( "/sys/fs/cgroup" ) ; //<S2SV> char * path = NULL ; //<S2SV> char * * parts = NULL ; //<S2SV> char * dirname = NULL ; //<S2SV> char * abs_path = NULL ; //<S2SV> char * abs_path2 = NULL ; //<S2SV> struct cgfs_data * cgfs_d ; //<S2SV> struct cgroup_process_info * info , * base_info ; //<S2SV> int r , saved_errno = 0 ; //<S2SV> cgfs_d = hdata ; //<S2SV> if ( ! cgfs_d ) //<S2SV> return false ; //<S2SV> base_info = cgfs_d -> info ; //<S2SV> if ( type == LXC_AUTO_CGROUP_FULL_NOSPEC ) //<S2SV> type = LXC_AUTO_CGROUP_FULL_MIXED ; //<S2SV> else if ( type == LXC_AUTO_CGROUP_NOSPEC ) //<S2SV> type = LXC_AUTO_CGROUP_MIXED ; //<S2SV> if ( type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED ) { //<S2SV> ERROR ( "could<S2SV_blank>not<S2SV_blank>mount<S2SV_blank>cgroups<S2SV_blank>into<S2SV_blank>container:<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>specified<S2SV_blank>internally" ) ; //<S2SV> errno = EINVAL ; //<S2SV> return false ; //<S2SV> } //<S2SV> path = calloc ( 1 , bufsz ) ; //<S2SV> if ( ! path ) //<S2SV> return false ; //<S2SV> snprintf ( path , bufsz , "%s/sys/fs/cgroup" , root ) ; //<S2SV> r = mount ( "cgroup_root" , path , "tmpfs" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , "size=10240k,mode=755" ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "could<S2SV_blank>not<S2SV_blank>mount<S2SV_blank>tmpfs<S2SV_blank>to<S2SV_blank>/sys/fs/cgroup<S2SV_blank>in<S2SV_blank>the<S2SV_blank>container" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> for ( info = base_info ; info ; info = info -> next ) { //<S2SV> size_t subsystem_count , i ; //<S2SV> struct cgroup_mount_point * mp = info -> designated_mount_point ; //<S2SV> if ( ! mp ) //<S2SV> mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ; //<S2SV> if ( ! mp ) { //<S2SV> SYSERROR ( "could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>original<S2SV_blank>mount<S2SV_blank>point<S2SV_blank>for<S2SV_blank>cgroup<S2SV_blank>hierarchy<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>cgroup<S2SV_blank>filesystem" ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> subsystem_count = lxc_array_len ( ( void * * ) info -> hierarchy -> subsystems ) ; //<S2SV> parts = calloc ( subsystem_count + 1 , sizeof ( char * ) ) ; //<S2SV> if ( ! parts ) //<S2SV> goto out_error ; //<S2SV> for ( i = 0 ; i < subsystem_count ; i ++ ) { //<S2SV> if ( ! strncmp ( info -> hierarchy -> subsystems [ i ] , "name=" , 5 ) ) //<S2SV> parts [ i ] = info -> hierarchy -> subsystems [ i ] + 5 ; //<S2SV> else //<S2SV> parts [ i ] = info -> hierarchy -> subsystems [ i ] ; //<S2SV> } //<S2SV> dirname = lxc_string_join ( "," , ( const char * * ) parts , false ) ; //<S2SV> if ( ! dirname ) //<S2SV> goto out_error ; //<S2SV> abs_path = lxc_append_paths ( path , dirname ) ; //<S2SV> if ( ! abs_path ) //<S2SV> goto out_error ; //<S2SV> r = mkdir_p ( abs_path , 0755 ) ; //<S2SV> if ( r < 0 && errno != EEXIST ) { //<S2SV> SYSERROR ( "could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>cgroup<S2SV_blank>subsystem<S2SV_blank>directory<S2SV_blank>/sys/fs/cgroup/%s" , dirname ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> abs_path2 = lxc_append_paths ( abs_path , info -> cgroup_path ) ; //<S2SV> if ( ! abs_path2 ) //<S2SV> goto out_error ; //<S2SV> if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED ) { //<S2SV> if ( strcmp ( mp -> mount_prefix , "/" ) != 0 ) { //<S2SV> ERROR ( "could<S2SV_blank>not<S2SV_blank>automatically<S2SV_blank>mount<S2SV_blank>cgroup-full<S2SV_blank>to<S2SV_blank>/sys/fs/cgroup/%s:<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>mount<S2SV_blank>point<S2SV_blank>for<S2SV_blank>this<S2SV_blank>cgroup<S2SV_blank>filesystem<S2SV_blank>that<S2SV_blank>has<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>root<S2SV_blank>cgroup" , dirname ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> r = mount ( mp -> mount_point , abs_path , "none" , MS_BIND , 0 ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s" , mp -> mount_point , abs_path ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED ) { //<S2SV> r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly" , abs_path ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> } //<S2SV> if ( type == LXC_AUTO_CGROUP_FULL_MIXED ) { //<S2SV> r = mount ( abs_path2 , abs_path2 , NULL , MS_BIND , NULL ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>onto<S2SV_blank>itself" , abs_path2 ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND , NULL ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readwrite" , abs_path2 ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> r = mkdir_p ( abs_path2 , 0755 ) ; //<S2SV> if ( r < 0 && errno != EEXIST ) { //<S2SV> SYSERROR ( "could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>cgroup<S2SV_blank>directory<S2SV_blank>/sys/fs/cgroup/%s%s" , dirname , info -> cgroup_path ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> if ( type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO ) { //<S2SV> r = mount ( abs_path , abs_path , NULL , MS_BIND , NULL ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>onto<S2SV_blank>itself" , abs_path ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly" , abs_path ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> } //<S2SV> free ( abs_path ) ; //<S2SV> abs_path = NULL ; //<S2SV> abs_path = cgroup_to_absolute_path ( mp , info -> cgroup_path , NULL ) ; //<S2SV> if ( ! abs_path ) //<S2SV> goto out_error ; //<S2SV> r = mount ( abs_path , abs_path2 , "none" , MS_BIND , 0 ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s" , abs_path , abs_path2 ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> if ( type == LXC_AUTO_CGROUP_RO ) { //<S2SV> r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; //<S2SV> if ( r < 0 ) { //<S2SV> SYSERROR ( "error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly" , abs_path2 ) ; //<S2SV> goto out_error ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> free ( abs_path ) ; //<S2SV> free ( abs_path2 ) ; //<S2SV> abs_path = NULL ; //<S2SV> abs_path2 = NULL ; //<S2SV> if ( subsystem_count > 1 ) { //<S2SV> for ( i = 0 ; i < subsystem_count ; i ++ ) { //<S2SV> abs_path = lxc_append_paths ( path , parts [ i ] ) ; //<S2SV> if ( ! abs_path ) //<S2SV> goto out_error ; //<S2SV> r = symlink ( dirname , abs_path ) ; //<S2SV> if ( r < 0 ) //<S2SV> WARN ( "could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s<S2SV_blank>in<S2SV_blank>/sys/fs/cgroup<S2SV_blank>of<S2SV_blank>container" , parts [ i ] , dirname ) ; //<S2SV> free ( abs_path ) ; //<S2SV> abs_path = NULL ; //<S2SV> } //<S2SV> } //<S2SV> free ( dirname ) ; //<S2SV> free ( parts ) ; //<S2SV> dirname = NULL ; //<S2SV> parts = NULL ; //<S2SV> } //<S2SV> free ( path ) ; //<S2SV> return true ; //<S2SV> out_error : //<S2SV> saved_errno = errno ; //<S2SV> free ( path ) ; //<S2SV> free ( dirname ) ; //<S2SV> free ( parts ) ; //<S2SV> free ( abs_path ) ; //<S2SV> free ( abs_path2 ) ; //<S2SV> errno = saved_errno ; //<S2SV> return false ; //<S2SV> } //<S2SV> 