int main ( int argc , char * * argv ) //<S2SV> { //<S2SV> int fd = xopen ( "/dev/null" , O_RDWR ) ; //<S2SV> while ( fd < 2 ) //<S2SV> fd = xdup ( fd ) ; //<S2SV> if ( fd > 2 ) //<S2SV> close ( fd ) ; //<S2SV> int err = 1 ; //<S2SV> logmode = LOGMODE_JOURNAL ; //<S2SV> load_abrt_conf ( ) ; //<S2SV> bool setting_MakeCompatCore ; //<S2SV> bool setting_SaveBinaryImage ; //<S2SV> bool setting_SaveFullCore ; //<S2SV> bool setting_CreateCoreBacktrace ; //<S2SV> bool setting_SaveContainerizedPackageData ; //<S2SV> bool setting_StandaloneHook ; //<S2SV> { //<S2SV> map_string_t * settings = new_map_string ( ) ; //<S2SV> load_abrt_plugin_conf_file ( "CCpp.conf" , settings ) ; //<S2SV> const char * value ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "MakeCompatCore" ) ; //<S2SV> setting_MakeCompatCore = value && string_to_bool ( value ) ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "SaveBinaryImage" ) ; //<S2SV> setting_SaveBinaryImage = value && string_to_bool ( value ) ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "SaveFullCore" ) ; //<S2SV> setting_SaveFullCore = value ? string_to_bool ( value ) : true ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "CreateCoreBacktrace" ) ; //<S2SV> setting_CreateCoreBacktrace = value ? string_to_bool ( value ) : true ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "SaveContainerizedPackageData" ) ; //<S2SV> setting_SaveContainerizedPackageData = value && string_to_bool ( value ) ; //<S2SV> if ( ! g_settings_explorechroots ) //<S2SV> { //<S2SV> if ( setting_SaveContainerizedPackageData ) //<S2SV> log_warning ( "Ignoring<S2SV_blank>SaveContainerizedPackageData<S2SV_blank>because<S2SV_blank>ExploreChroots<S2SV_blank>is<S2SV_blank>disabled" ) ; //<S2SV> setting_SaveContainerizedPackageData = false ; //<S2SV> } //<S2SV> value = get_map_string_item_or_NULL ( settings , "StandaloneHook" ) ; //<S2SV> setting_StandaloneHook = value && string_to_bool ( value ) ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "VerboseLog" ) ; //<S2SV> if ( value ) //<S2SV> g_verbose = xatoi_positive ( value ) ; //<S2SV> free_map_string ( settings ) ; //<S2SV> } //<S2SV> if ( argc == 2 && strcmp ( argv [ 1 ] , "--config-test" ) ) //<S2SV> return test_configuration ( setting_SaveFullCore , setting_CreateCoreBacktrace ) ; //<S2SV> if ( argc < 8 ) //<S2SV> { //<S2SV> error_msg_and_die ( "Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>GLOBAL_PID<S2SV_blank>[TID]" , argv [ 0 ] ) ; //<S2SV> } //<S2SV> if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 1 ; argv [ i ] ; i ++ ) //<S2SV> { //<S2SV> strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; //<S2SV> } //<S2SV> } //<S2SV> errno = 0 ; //<S2SV> const char * signal_str = argv [ 1 ] ; //<S2SV> int signal_no = xatoi_positive ( signal_str ) ; //<S2SV> off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; //<S2SV> if ( ulimit_c < 0 ) //<S2SV> { //<S2SV> ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; //<S2SV> } //<S2SV> const char * pid_str = argv [ 3 ] ; //<S2SV> pid_t local_pid = xatoi_positive ( argv [ 3 ] ) ; //<S2SV> uid_t uid = xatoi_positive ( argv [ 4 ] ) ; //<S2SV> if ( errno || local_pid <= 0 ) //<S2SV> { //<S2SV> perror_msg_and_die ( "PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus" , argv [ 3 ] , argv [ 2 ] ) ; //<S2SV> } //<S2SV> { //<S2SV> char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN "/abrt/saved_core_pattern" ) ; //<S2SV> if ( s && s [ 0 ] != '|' ) //<S2SV> core_basename = s ; //<S2SV> else //<S2SV> free ( s ) ; //<S2SV> } //<S2SV> const char * global_pid_str = argv [ 8 ] ; //<S2SV> pid_t pid = xatoi_positive ( argv [ 8 ] ) ; //<S2SV> pid_t tid = - 1 ; //<S2SV> const char * tid_str = argv [ 9 ] ; //<S2SV> if ( tid_str ) //<S2SV> { //<S2SV> tid = xatoi_positive ( tid_str ) ; //<S2SV> } //<S2SV> char path [ PATH_MAX ] ; //<S2SV> char * executable = get_executable ( pid ) ; //<S2SV> if ( executable && strstr ( executable , "/abrt-hook-ccpp" ) ) //<S2SV> { //<S2SV> error_msg_and_die ( "PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion" , //<S2SV> ( long ) pid , executable ) ; //<S2SV> } //<S2SV> user_pwd = get_cwd ( pid ) ; //<S2SV> log_notice ( "user_pwd:\'%s\'" , user_pwd ) ; //<S2SV> sprintf ( path , "/proc/%lu/status" , ( long ) pid ) ; //<S2SV> char * proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; //<S2SV> uid_t fsuid = uid ; //<S2SV> uid_t tmp_fsuid = get_fsuid ( proc_pid_status ) ; //<S2SV> if ( tmp_fsuid < 0 ) //<S2SV> perror_msg_and_die ( "Can\'t<S2SV_blank>parse<S2SV_blank>\'Uid:<S2SV_blank>line\'<S2SV_blank>in<S2SV_blank>/proc/%lu/status" , ( long ) pid ) ; //<S2SV> const int fsgid = get_fsgid ( proc_pid_status ) ; //<S2SV> if ( fsgid < 0 ) //<S2SV> error_msg_and_die ( "Can\'t<S2SV_blank>parse<S2SV_blank>\'Gid:<S2SV_blank>line\'<S2SV_blank>in<S2SV_blank>/proc/%lu/status" , ( long ) pid ) ; //<S2SV> int suid_policy = dump_suid_policy ( ) ; //<S2SV> if ( tmp_fsuid != uid ) //<S2SV> { //<S2SV> fsuid = 0 ; //<S2SV> if ( suid_policy == DUMP_SUID_UNSAFE ) //<S2SV> fsuid = tmp_fsuid ; //<S2SV> else //<S2SV> { //<S2SV> g_user_core_flags = O_EXCL ; //<S2SV> g_need_nonrelative = 1 ; //<S2SV> } //<S2SV> } //<S2SV> int user_core_fd = - 1 ; //<S2SV> if ( setting_MakeCompatCore && ulimit_c != 0 ) //<S2SV> user_core_fd = open_user_core ( uid , fsuid , fsgid , pid , & argv [ 1 ] ) ; //<S2SV> if ( executable == NULL ) //<S2SV> { //<S2SV> error_msg ( "Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link" , ( long ) pid ) ; //<S2SV> return create_user_core ( user_core_fd , pid , ulimit_c ) ; //<S2SV> } //<S2SV> const char * signame = NULL ; //<S2SV> if ( ! signal_is_fatal ( signal_no , & signame ) ) //<S2SV> return create_user_core ( user_core_fd , pid , ulimit_c ) ; //<S2SV> const int abrtd_running = daemon_is_ok ( ) ; //<S2SV> if ( ! setting_StandaloneHook && ! abrtd_running ) //<S2SV> { //<S2SV> log ( "abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>" //<S2SV> "/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>" //<S2SV> "consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'" //<S2SV> ) ; //<S2SV> return create_user_core ( user_core_fd , pid , ulimit_c ) ; //<S2SV> } //<S2SV> if ( setting_StandaloneHook ) //<S2SV> ensure_writable_dir ( g_settings_dump_location , DEFAULT_DUMP_LOCATION_MODE , "abrt" ) ; //<S2SV> if ( g_settings_nMaxCrashReportsSize > 0 ) //<S2SV> { //<S2SV> if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) //<S2SV> return create_user_core ( user_core_fd , pid , ulimit_c ) ; //<S2SV> } //<S2SV> snprintf ( path , sizeof ( path ) , "%s/last-ccpp" , g_settings_dump_location ) ; //<S2SV> if ( check_recent_crash_file ( path , executable ) ) //<S2SV> { //<S2SV> return create_user_core ( user_core_fd , pid , ulimit_c ) ; //<S2SV> } //<S2SV> const char * last_slash = strrchr ( executable , '/' ) ; //<S2SV> if ( last_slash && strncmp ( ++ last_slash , "abrt" , 4 ) == 0 ) //<S2SV> { //<S2SV> if ( g_settings_debug_level == 0 ) //<S2SV> { //<S2SV> log_warning ( "Ignoring<S2SV_blank>crash<S2SV_blank>of<S2SV_blank>%s<S2SV_blank>(SIG%s)." , //<S2SV> executable , signame ? signame : signal_str ) ; //<S2SV> goto cleanup_and_exit ; //<S2SV> } //<S2SV> if ( snprintf ( path , sizeof ( path ) , "%s/%s-coredump" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) //<S2SV> error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path" , path ) ; //<S2SV> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; //<S2SV> off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; //<S2SV> if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) //<S2SV> { //<S2SV> unlink ( path ) ; //<S2SV> error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; //<S2SV> } //<S2SV> log_notice ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , executable , path , ( long long ) core_size ) ; //<S2SV> err = 0 ; //<S2SV> goto cleanup_and_exit ; //<S2SV> } //<S2SV> unsigned path_len = snprintf ( path , sizeof ( path ) , "%s/ccpp-%s-%lu.new" , //<S2SV> g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; //<S2SV> if ( path_len >= ( sizeof ( path ) - sizeof ( "/" FILENAME_COREDUMP ) ) ) //<S2SV> { //<S2SV> return create_user_core ( user_core_fd , pid , ulimit_c ) ; //<S2SV> } //<S2SV> dd = dd_create ( path , 0 , DEFAULT_DUMP_DIR_MODE ) ; //<S2SV> if ( dd ) //<S2SV> { //<S2SV> char source_filename [ sizeof ( "/proc/%lu/somewhat_long_name" ) + sizeof ( long ) * 3 ] ; //<S2SV> int source_base_ofs = sprintf ( source_filename , "/proc/%lu/root" , ( long ) pid ) ; //<S2SV> source_base_ofs -= strlen ( "root" ) ; //<S2SV> char * rootdir = process_has_own_root ( pid ) ? get_rootdir ( pid ) : NULL ; //<S2SV> if ( g_settings_explorechroots ) //<S2SV> { //<S2SV> dd_create_basic_files ( dd , fsuid , ( rootdir != NULL ) ? source_filename : NULL ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> dd_create_basic_files ( dd , fsuid , NULL ) ; //<S2SV> } //<S2SV> char * dest_filename = concat_path_file ( dd -> dd_dirname , "also_somewhat_longish_name" ) ; //<S2SV> char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; //<S2SV> strcpy ( source_filename + source_base_ofs , "maps" ) ; //<S2SV> dd_copy_file ( dd , FILENAME_MAPS , source_filename ) ; //<S2SV> strcpy ( source_filename + source_base_ofs , "limits" ) ; //<S2SV> dd_copy_file ( dd , FILENAME_LIMITS , source_filename ) ; //<S2SV> strcpy ( source_filename + source_base_ofs , "cgroup" ) ; //<S2SV> dd_copy_file ( dd , FILENAME_CGROUP , source_filename ) ; //<S2SV> strcpy ( source_filename + source_base_ofs , "mountinfo" ) ; //<S2SV> dd_copy_file ( dd , FILENAME_MOUNTINFO , source_filename ) ; //<S2SV> strcpy ( dest_base , FILENAME_OPEN_FDS ) ; //<S2SV> strcpy ( source_filename + source_base_ofs , "fd" ) ; //<S2SV> dump_fd_info_ext ( dest_filename , source_filename , dd -> dd_uid , dd -> dd_gid ) ; //<S2SV> strcpy ( dest_base , FILENAME_NAMESPACES ) ; //<S2SV> dump_namespace_diff_ext ( dest_filename , 1 , pid , dd -> dd_uid , dd -> dd_gid ) ; //<S2SV> free ( dest_filename ) ; //<S2SV> char * tmp = NULL ; //<S2SV> get_env_variable ( pid , "container" , & tmp ) ; //<S2SV> if ( tmp != NULL ) //<S2SV> { //<S2SV> dd_save_text ( dd , FILENAME_CONTAINER , tmp ) ; //<S2SV> free ( tmp ) ; //<S2SV> tmp = NULL ; //<S2SV> } //<S2SV> get_env_variable ( pid , "container_uuid" , & tmp ) ; //<S2SV> if ( tmp != NULL ) //<S2SV> { //<S2SV> dd_save_text ( dd , FILENAME_CONTAINER_UUID , tmp ) ; //<S2SV> free ( tmp ) ; //<S2SV> } //<S2SV> const int containerized = ( rootdir != NULL && strcmp ( rootdir , "/" ) == 0 ) ; //<S2SV> if ( containerized ) //<S2SV> { //<S2SV> log_debug ( "Process<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>considered<S2SV_blank>to<S2SV_blank>be<S2SV_blank>containerized" , pid ) ; //<S2SV> pid_t container_pid ; //<S2SV> if ( get_pid_of_container ( pid , & container_pid ) == 0 ) //<S2SV> { //<S2SV> char * container_cmdline = get_cmdline ( container_pid ) ; //<S2SV> dd_save_text ( dd , FILENAME_CONTAINER_CMDLINE , container_cmdline ) ; //<S2SV> free ( container_cmdline ) ; //<S2SV> } //<S2SV> } //<S2SV> dd_save_text ( dd , FILENAME_ANALYZER , "abrt-ccpp" ) ; //<S2SV> dd_save_text ( dd , FILENAME_TYPE , "CCpp" ) ; //<S2SV> dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; //<S2SV> dd_save_text ( dd , FILENAME_PID , pid_str ) ; //<S2SV> dd_save_text ( dd , FILENAME_GLOBAL_PID , global_pid_str ) ; //<S2SV> dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; //<S2SV> if ( user_pwd ) //<S2SV> dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; //<S2SV> if ( tid_str ) //<S2SV> dd_save_text ( dd , FILENAME_TID , tid_str ) ; //<S2SV> if ( rootdir ) //<S2SV> { //<S2SV> if ( strcmp ( rootdir , "/" ) != 0 ) //<S2SV> dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; //<S2SV> } //<S2SV> free ( rootdir ) ; //<S2SV> char * reason = xasprintf ( "%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s" , //<S2SV> last_slash , signame ? signame : signal_str ) ; //<S2SV> dd_save_text ( dd , FILENAME_REASON , reason ) ; //<S2SV> free ( reason ) ; //<S2SV> char * cmdline = get_cmdline ( pid ) ; //<S2SV> dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : "" ) ; //<S2SV> free ( cmdline ) ; //<S2SV> char * environ = get_environ ( pid ) ; //<S2SV> dd_save_text ( dd , FILENAME_ENVIRON , environ ? : "" ) ; //<S2SV> free ( environ ) ; //<S2SV> char * fips_enabled = xmalloc_fopen_fgetline_fclose ( "/proc/sys/crypto/fips_enabled" ) ; //<S2SV> if ( fips_enabled ) //<S2SV> { //<S2SV> if ( strcmp ( fips_enabled , "0" ) != 0 ) //<S2SV> dd_save_text ( dd , "fips_enabled" , fips_enabled ) ; //<S2SV> free ( fips_enabled ) ; //<S2SV> } //<S2SV> dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; //<S2SV> long unsigned lck_bytes = ULONG_MAX ; //<S2SV> const char * vmlck = strstr ( proc_pid_status , "VmLck:" ) ; //<S2SV> if ( vmlck == NULL ) //<S2SV> error_msg ( "/proc/%s/status<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>\'VmLck:\'<S2SV_blank>line" , pid_str ) ; //<S2SV> else if ( 1 != sscanf ( vmlck + 6 , "%lu<S2SV_blank>kB\\n" , & lck_bytes ) ) //<S2SV> error_msg ( "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'VmLck:\'<S2SV_blank>line<S2SV_blank>in<S2SV_blank>/proc/%s/status" , pid_str ) ; //<S2SV> if ( lck_bytes ) //<S2SV> { //<S2SV> log_notice ( "Process<S2SV_blank>%s<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%lu<S2SV_blank>has<S2SV_blank>locked<S2SV_blank>memory" , //<S2SV> pid_str , ( long unsigned ) uid ) ; //<S2SV> dd_mark_as_notreportable ( dd , "The<S2SV_blank>process<S2SV_blank>had<S2SV_blank>locked<S2SV_blank>memory<S2SV_blank>" //<S2SV> "which<S2SV_blank>usually<S2SV_blank>indicates<S2SV_blank>efforts<S2SV_blank>to<S2SV_blank>protect<S2SV_blank>sensitive<S2SV_blank>" //<S2SV> "data<S2SV_blank>(passwords)<S2SV_blank>from<S2SV_blank>being<S2SV_blank>written<S2SV_blank>to<S2SV_blank>disk.\\n" //<S2SV> "In<S2SV_blank>order<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>sensitive<S2SV_blank>information<S2SV_blank>leakages,<S2SV_blank>" //<S2SV> "ABRT<S2SV_blank>will<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>you<S2SV_blank>to<S2SV_blank>report<S2SV_blank>this<S2SV_blank>problem<S2SV_blank>to<S2SV_blank>" //<S2SV> "bug<S2SV_blank>tracking<S2SV_blank>tools" ) ; //<S2SV> } //<S2SV> if ( setting_SaveBinaryImage ) //<S2SV> { //<S2SV> if ( save_crashing_binary ( pid , dd ) ) //<S2SV> { //<S2SV> error_msg ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; //<S2SV> goto cleanup_and_exit ; //<S2SV> } //<S2SV> } //<S2SV> off_t core_size = 0 ; //<S2SV> if ( setting_SaveFullCore ) //<S2SV> { //<S2SV> strcpy ( path + path_len , "/" FILENAME_COREDUMP ) ; //<S2SV> int abrt_core_fd = create_or_die ( path , user_core_fd ) ; //<S2SV> core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; //<S2SV> close_user_core ( user_core_fd , core_size ) ; //<S2SV> if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) //<S2SV> { //<S2SV> unlink ( path ) ; //<S2SV> error_msg ( "Error<S2SV_blank>writing<S2SV_blank>\'%s\'" , path ) ; //<S2SV> goto cleanup_and_exit ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> create_user_core ( user_core_fd , pid , ulimit_c ) ; //<S2SV> } //<S2SV> user_core_fd = - 1 ; //<S2SV> # if 0 //<S2SV> { //<S2SV> char * java_log = xasprintf ( "/tmp/jvm-%lu/hs_error.log" , ( long ) pid ) ; //<S2SV> int src_fd = open ( java_log , O_RDONLY ) ; //<S2SV> free ( java_log ) ; //<S2SV> if ( src_fd < 0 ) //<S2SV> { //<S2SV> java_log = xasprintf ( "%s/hs_err_pid%lu.log" , user_pwd , ( long ) pid ) ; //<S2SV> src_fd = open ( java_log , O_RDONLY ) ; //<S2SV> free ( java_log ) ; //<S2SV> } //<S2SV> if ( src_fd >= 0 ) //<S2SV> { //<S2SV> strcpy ( path + path_len , "/hs_err.log" ) ; //<S2SV> int dst_fd = create_or_die ( path , user_core_fd ) ; //<S2SV> off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; //<S2SV> if ( close ( dst_fd ) != 0 || sz < 0 ) //<S2SV> { //<S2SV> error_msg ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; //<S2SV> goto cleanup_and_exit ; //<S2SV> } //<S2SV> close ( src_fd ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( tid > 0 && setting_CreateCoreBacktrace ) //<S2SV> create_core_backtrace ( tid , executable , signal_no , dd ) ; //<S2SV> dd_close ( dd ) ; //<S2SV> dd = NULL ; //<S2SV> path [ path_len ] = '\\0' ; //<S2SV> if ( abrtd_running && setting_SaveContainerizedPackageData && containerized ) //<S2SV> { //<S2SV> sprintf ( source_filename , "/proc/%lu/root" , ( long ) pid ) ; //<S2SV> const char * cmd_args [ 6 ] ; //<S2SV> cmd_args [ 0 ] = BIN_DIR "/abrt-action-save-package-data" ; //<S2SV> cmd_args [ 1 ] = "-d" ; //<S2SV> cmd_args [ 2 ] = path ; //<S2SV> cmd_args [ 3 ] = "-r" ; //<S2SV> cmd_args [ 4 ] = source_filename ; //<S2SV> cmd_args [ 5 ] = NULL ; //<S2SV> pid_t pid = fork_execv_on_steroids ( 0 , ( char * * ) cmd_args , NULL , NULL , path , 0 ) ; //<S2SV> int stat ; //<S2SV> safe_waitpid ( pid , & stat , 0 ) ; //<S2SV> } //<S2SV> char * newpath = xstrndup ( path , path_len - ( sizeof ( ".new" ) - 1 ) ) ; //<S2SV> if ( rename ( path , newpath ) == 0 ) //<S2SV> strcpy ( path , newpath ) ; //<S2SV> free ( newpath ) ; //<S2SV> if ( core_size > 0 ) //<S2SV> log_notice ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , //<S2SV> ( long ) pid , executable , path , ( long long ) core_size ) ; //<S2SV> if ( abrtd_running ) //<S2SV> notify_new_path ( path ) ; //<S2SV> if ( g_settings_nMaxCrashReportsSize > 0 ) //<S2SV> { //<S2SV> unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; //<S2SV> maxsize |= 63 ; //<S2SV> trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; //<S2SV> } //<S2SV> err = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> return create_user_core ( user_core_fd , pid , ulimit_c ) ; //<S2SV> } //<S2SV> cleanup_and_exit : //<S2SV> if ( dd ) //<S2SV> dd_delete ( dd ) ; //<S2SV> if ( user_core_fd >= 0 ) //<S2SV> unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; //<S2SV> if ( proc_cwd != NULL ) //<S2SV> closedir ( proc_cwd ) ; //<S2SV> return err ; //<S2SV> } //<S2SV> 