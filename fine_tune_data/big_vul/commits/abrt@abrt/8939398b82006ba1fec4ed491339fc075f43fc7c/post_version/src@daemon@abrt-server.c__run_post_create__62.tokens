static int run_post_create ( const char * dirname ) //<S2SV> { //<S2SV> if ( ! dir_is_in_dump_location ( dirname ) ) //<S2SV> { //<S2SV> error_msg ( "Bad<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>name<S2SV_blank>\'%s\',<S2SV_blank>should<S2SV_blank>start<S2SV_blank>with:<S2SV_blank>\'%s\'" , dirname , g_settings_dump_location ) ; //<S2SV> return 400 ; //<S2SV> } //<S2SV> if ( g_settings_privatereports ) //<S2SV> { //<S2SV> struct stat statbuf ; //<S2SV> if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) //<S2SV> { //<S2SV> error_msg ( "Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory" , dirname ) ; //<S2SV> return 404 ; //<S2SV> } //<S2SV> struct group * gr = getgrnam ( "abrt" ) ; //<S2SV> if ( ! gr ) //<S2SV> { //<S2SV> error_msg ( "Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist" ) ; //<S2SV> return 500 ; //<S2SV> } //<S2SV> if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) //<S2SV> { //<S2SV> error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access" , dirname ) ; //<S2SV> return 403 ; //<S2SV> } //<S2SV> struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; //<S2SV> const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; //<S2SV> dd_close ( dd ) ; //<S2SV> if ( complete ) //<S2SV> { //<S2SV> error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed" , dirname ) ; //<S2SV> return 403 ; //<S2SV> } //<S2SV> } //<S2SV> else if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) ) //<S2SV> { //<S2SV> if ( errno == ENOTDIR ) //<S2SV> { //<S2SV> error_msg ( "Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>problem<S2SV_blank>directory" , dirname ) ; //<S2SV> return 404 ; //<S2SV> } //<S2SV> error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>accessed<S2SV_blank>by<S2SV_blank>user<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>%ld" , dirname , ( long ) client_uid ) ; //<S2SV> return 403 ; //<S2SV> } //<S2SV> int child_stdout_fd ; //<S2SV> int child_pid = spawn_event_handler_child ( dirname , "post-create" , & child_stdout_fd ) ; //<S2SV> char * dup_of_dir = NULL ; //<S2SV> struct strbuf * cmd_output = strbuf_new ( ) ; //<S2SV> bool child_is_post_create = 1 ; //<S2SV> read_child_output : //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> char buf [ 250 ] ; //<S2SV> errno = 0 ; //<S2SV> int r = safe_read ( child_stdout_fd , buf , sizeof ( buf ) - 1 ) ; //<S2SV> if ( r <= 0 ) //<S2SV> break ; //<S2SV> buf [ r ] = '\\0' ; //<S2SV> char * raw = buf ; //<S2SV> char * newline ; //<S2SV> while ( ( newline = strchr ( raw , '\\n' ) ) != NULL ) //<S2SV> { //<S2SV> * newline = '\\0' ; //<S2SV> strbuf_append_str ( cmd_output , raw ) ; //<S2SV> char * msg = cmd_output -> buf ; //<S2SV> log ( "%s" , msg ) ; //<S2SV> if ( child_is_post_create //<S2SV> && prefixcmp ( msg , "DUP_OF_DIR:<S2SV_blank>" ) == 0 //<S2SV> ) { //<S2SV> free ( dup_of_dir ) ; //<S2SV> dup_of_dir = xstrdup ( msg + strlen ( "DUP_OF_DIR:<S2SV_blank>" ) ) ; //<S2SV> } //<S2SV> strbuf_clear ( cmd_output ) ; //<S2SV> raw = newline + 1 ; //<S2SV> } //<S2SV> strbuf_append_str ( cmd_output , raw ) ; //<S2SV> } //<S2SV> int status = 0 ; //<S2SV> if ( safe_waitpid ( child_pid , & status , 0 ) <= 0 ) //<S2SV> perror_msg ( "waitpid(%d)" , child_pid ) ; //<S2SV> if ( ! child_is_post_create ) //<S2SV> goto ret ; //<S2SV> if ( status != 0 ) //<S2SV> { //<S2SV> if ( WIFSIGNALED ( status ) ) //<S2SV> { //<S2SV> log ( "\'post-create\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>signal<S2SV_blank>%d" , //<S2SV> dirname , WTERMSIG ( status ) ) ; //<S2SV> goto delete_bad_dir ; //<S2SV> } //<S2SV> if ( ! dup_of_dir ) //<S2SV> { //<S2SV> log ( "\'post-create\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>%d" , //<S2SV> dirname , WEXITSTATUS ( status ) ) ; //<S2SV> goto delete_bad_dir ; //<S2SV> } //<S2SV> } //<S2SV> const char * work_dir = ( dup_of_dir ? dup_of_dir : dirname ) ; //<S2SV> struct dump_dir * dd = dd_opendir ( work_dir , 0 ) ; //<S2SV> if ( ! dd ) //<S2SV> goto delete_bad_dir ; //<S2SV> char * count_str = dd_load_text_ext ( dd , FILENAME_COUNT , DD_FAIL_QUIETLY_ENOENT ) ; //<S2SV> unsigned long count = strtoul ( count_str , NULL , 10 ) ; //<S2SV> if ( ( status != 0 && dup_of_dir ) || count == 0 ) //<S2SV> { //<S2SV> count ++ ; //<S2SV> char new_count_str [ sizeof ( long ) * 3 + 2 ] ; //<S2SV> sprintf ( new_count_str , "%lu" , count ) ; //<S2SV> dd_save_text ( dd , FILENAME_COUNT , new_count_str ) ; //<S2SV> if ( strcmp ( dd -> dd_dirname , dirname ) != 0 ) //<S2SV> { //<S2SV> struct dump_dir * new_dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; //<S2SV> char * last_ocr = NULL ; //<S2SV> if ( new_dd ) //<S2SV> { //<S2SV> last_ocr = dd_load_text_ext ( new_dd , FILENAME_TIME , //<S2SV> DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT ) ; //<S2SV> dd_close ( new_dd ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> error_msg ( "Can\'t<S2SV_blank>read<S2SV_blank>the<S2SV_blank>last<S2SV_blank>occurrence<S2SV_blank>file<S2SV_blank>from<S2SV_blank>the<S2SV_blank>new<S2SV_blank>dump<S2SV_blank>directory." ) ; //<S2SV> } //<S2SV> if ( ! last_ocr ) //<S2SV> { //<S2SV> log ( "Using<S2SV_blank>current<S2SV_blank>time<S2SV_blank>for<S2SV_blank>the<S2SV_blank>last<S2SV_blank>occurrence<S2SV_blank>file<S2SV_blank>which<S2SV_blank>may<S2SV_blank>be<S2SV_blank>incorrect." ) ; //<S2SV> time_t t = time ( NULL ) ; //<S2SV> last_ocr = xasprintf ( "%lu" , ( long ) t ) ; //<S2SV> } //<S2SV> dd_save_text ( dd , FILENAME_LAST_OCCURRENCE , last_ocr ) ; //<S2SV> free ( last_ocr ) ; //<S2SV> } //<S2SV> } //<S2SV> dd_sanitize_mode_and_owner ( dd ) ; //<S2SV> dd_close ( dd ) ; //<S2SV> if ( ! dup_of_dir ) //<S2SV> log_notice ( "New<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>%s,<S2SV_blank>processing" , work_dir ) ; //<S2SV> else //<S2SV> { //<S2SV> log_warning ( "Deleting<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>(dup<S2SV_blank>of<S2SV_blank>%s)" , //<S2SV> strrchr ( dirname , '/' ) + 1 , //<S2SV> strrchr ( dup_of_dir , '/' ) + 1 ) ; //<S2SV> delete_dump_dir ( dirname ) ; //<S2SV> } //<S2SV> int fd ; //<S2SV> child_pid = spawn_event_handler_child ( //<S2SV> work_dir , //<S2SV> ( dup_of_dir ? "notify-dup" : "notify" ) , //<S2SV> & fd //<S2SV> ) ; //<S2SV> xmove_fd ( fd , child_stdout_fd ) ; //<S2SV> child_is_post_create = 0 ; //<S2SV> strbuf_clear ( cmd_output ) ; //<S2SV> free ( dup_of_dir ) ; //<S2SV> dup_of_dir = NULL ; //<S2SV> goto read_child_output ; //<S2SV> delete_bad_dir : //<S2SV> log_warning ( "Deleting<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>\'%s\'" , dirname ) ; //<S2SV> delete_dump_dir ( dirname ) ; //<S2SV> ret : //<S2SV> strbuf_free ( cmd_output ) ; //<S2SV> free ( dup_of_dir ) ; //<S2SV> close ( child_stdout_fd ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 