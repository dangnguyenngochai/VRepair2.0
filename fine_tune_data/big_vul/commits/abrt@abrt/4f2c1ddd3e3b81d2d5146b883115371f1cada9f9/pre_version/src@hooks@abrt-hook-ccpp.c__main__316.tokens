int main ( int argc , char * * argv ) //<S2SV> { //<S2SV> int fd = xopen ( "/dev/null" , O_RDWR ) ; //<S2SV> while ( fd < 2 ) //<S2SV> fd = xdup ( fd ) ; //<S2SV> if ( fd > 2 ) //<S2SV> close ( fd ) ; //<S2SV> if ( argc < 8 ) //<S2SV> { //<S2SV> error_msg_and_die ( "Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]" , argv [ 0 ] ) ; //<S2SV> } //<S2SV> if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 1 ; argv [ i ] ; i ++ ) //<S2SV> { //<S2SV> strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; //<S2SV> } //<S2SV> } //<S2SV> logmode = LOGMODE_JOURNAL ; //<S2SV> load_abrt_conf ( ) ; //<S2SV> bool setting_MakeCompatCore ; //<S2SV> bool setting_SaveBinaryImage ; //<S2SV> { //<S2SV> map_string_t * settings = new_map_string ( ) ; //<S2SV> load_abrt_plugin_conf_file ( "CCpp.conf" , settings ) ; //<S2SV> const char * value ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "MakeCompatCore" ) ; //<S2SV> setting_MakeCompatCore = value && string_to_bool ( value ) ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "SaveBinaryImage" ) ; //<S2SV> setting_SaveBinaryImage = value && string_to_bool ( value ) ; //<S2SV> value = get_map_string_item_or_NULL ( settings , "VerboseLog" ) ; //<S2SV> if ( value ) //<S2SV> g_verbose = xatoi_positive ( value ) ; //<S2SV> free_map_string ( settings ) ; //<S2SV> } //<S2SV> errno = 0 ; //<S2SV> const char * signal_str = argv [ 1 ] ; //<S2SV> int signal_no = xatoi_positive ( signal_str ) ; //<S2SV> off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; //<S2SV> if ( ulimit_c < 0 ) //<S2SV> { //<S2SV> ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; //<S2SV> } //<S2SV> const char * pid_str = argv [ 3 ] ; //<S2SV> pid_t pid = xatoi_positive ( argv [ 3 ] ) ; //<S2SV> uid_t uid = xatoi_positive ( argv [ 4 ] ) ; //<S2SV> if ( errno || pid <= 0 ) //<S2SV> { //<S2SV> perror_msg_and_die ( "PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus" , argv [ 3 ] , argv [ 2 ] ) ; //<S2SV> } //<S2SV> { //<S2SV> char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN "/abrt/saved_core_pattern" ) ; //<S2SV> if ( s && s [ 0 ] != '|' ) //<S2SV> core_basename = s ; //<S2SV> else //<S2SV> free ( s ) ; //<S2SV> } //<S2SV> struct utsname uts ; //<S2SV> if ( ! argv [ 8 ] ) //<S2SV> { //<S2SV> uname ( & uts ) ; //<S2SV> argv [ 8 ] = uts . nodename ; //<S2SV> } //<S2SV> char path [ PATH_MAX ] ; //<S2SV> int src_fd_binary = - 1 ; //<S2SV> char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; //<S2SV> if ( executable && strstr ( executable , "/abrt-hook-ccpp" ) ) //<S2SV> { //<S2SV> error_msg_and_die ( "PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion" , //<S2SV> ( long ) pid , executable ) ; //<S2SV> } //<S2SV> user_pwd = get_cwd ( pid ) ; //<S2SV> log_notice ( "user_pwd:\'%s\'" , user_pwd ) ; //<S2SV> sprintf ( path , "/proc/%lu/status" , ( long ) pid ) ; //<S2SV> proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; //<S2SV> uid_t fsuid = uid ; //<S2SV> uid_t tmp_fsuid = get_fsuid ( ) ; //<S2SV> int suid_policy = dump_suid_policy ( ) ; //<S2SV> if ( tmp_fsuid != uid ) //<S2SV> { //<S2SV> fsuid = 0 ; //<S2SV> if ( suid_policy == DUMP_SUID_UNSAFE ) //<S2SV> { //<S2SV> fsuid = tmp_fsuid ; //<S2SV> } //<S2SV> } //<S2SV> if ( setting_MakeCompatCore && ulimit_c != 0 ) //<S2SV> user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; //<S2SV> if ( executable == NULL ) //<S2SV> { //<S2SV> error_msg ( "Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link" , ( long ) pid ) ; //<S2SV> goto create_user_core ; //<S2SV> } //<S2SV> const char * signame = NULL ; //<S2SV> switch ( signal_no ) //<S2SV> { //<S2SV> case SIGILL : signame = "ILL" ; break ; //<S2SV> case SIGFPE : signame = "FPE" ; break ; //<S2SV> case SIGSEGV : signame = "SEGV" ; break ; //<S2SV> case SIGBUS : signame = "BUS" ; break ; //<S2SV> case SIGABRT : signame = "ABRT" ; break ; //<S2SV> case SIGTRAP : signame = "TRAP" ; break ; //<S2SV> default : goto create_user_core ; //<S2SV> } //<S2SV> if ( ! daemon_is_ok ( ) ) //<S2SV> { //<S2SV> log ( "abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>" //<S2SV> "/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>" //<S2SV> "consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'" //<S2SV> ) ; //<S2SV> goto create_user_core ; //<S2SV> } //<S2SV> if ( g_settings_nMaxCrashReportsSize > 0 ) //<S2SV> { //<S2SV> if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) //<S2SV> goto create_user_core ; //<S2SV> } //<S2SV> snprintf ( path , sizeof ( path ) , "%s/last-ccpp" , g_settings_dump_location ) ; //<S2SV> if ( check_recent_crash_file ( path , executable ) ) //<S2SV> { //<S2SV> goto create_user_core ; //<S2SV> } //<S2SV> const char * last_slash = strrchr ( executable , '/' ) ; //<S2SV> if ( last_slash && strncmp ( ++ last_slash , "abrt" , 4 ) == 0 ) //<S2SV> { //<S2SV> snprintf ( path , sizeof ( path ) , "%s/%s-coredump" , g_settings_dump_location , last_slash ) ; //<S2SV> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; //<S2SV> off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; //<S2SV> if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) //<S2SV> { //<S2SV> unlink ( path ) ; //<S2SV> error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; //<S2SV> } //<S2SV> log ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , executable , path , ( long long ) core_size ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> unsigned path_len = snprintf ( path , sizeof ( path ) , "%s/ccpp-%s-%lu.new" , //<S2SV> g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; //<S2SV> if ( path_len >= ( sizeof ( path ) - sizeof ( "/" FILENAME_COREDUMP ) ) ) //<S2SV> { //<S2SV> goto create_user_core ; //<S2SV> } //<S2SV> dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; //<S2SV> if ( dd ) //<S2SV> { //<S2SV> char * rootdir = get_rootdir ( pid ) ; //<S2SV> dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , "/" ) != 0 ) ? rootdir : NULL ) ; //<S2SV> char source_filename [ sizeof ( "/proc/%lu/somewhat_long_name" ) + sizeof ( long ) * 3 ] ; //<S2SV> int source_base_ofs = sprintf ( source_filename , "/proc/%lu/smaps" , ( long ) pid ) ; //<S2SV> source_base_ofs -= strlen ( "smaps" ) ; //<S2SV> char * dest_filename = concat_path_file ( dd -> dd_dirname , "also_somewhat_longish_name" ) ; //<S2SV> char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; //<S2SV> strcpy ( source_filename + source_base_ofs , "maps" ) ; //<S2SV> strcpy ( dest_base , FILENAME_MAPS ) ; //<S2SV> copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; //<S2SV> strcpy ( source_filename + source_base_ofs , "limits" ) ; //<S2SV> strcpy ( dest_base , FILENAME_LIMITS ) ; //<S2SV> copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; //<S2SV> strcpy ( source_filename + source_base_ofs , "cgroup" ) ; //<S2SV> strcpy ( dest_base , FILENAME_CGROUP ) ; //<S2SV> copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; //<S2SV> strcpy ( dest_base , FILENAME_OPEN_FDS ) ; //<S2SV> dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; //<S2SV> free ( dest_filename ) ; //<S2SV> dd_save_text ( dd , FILENAME_ANALYZER , "CCpp" ) ; //<S2SV> dd_save_text ( dd , FILENAME_TYPE , "CCpp" ) ; //<S2SV> dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; //<S2SV> dd_save_text ( dd , FILENAME_PID , pid_str ) ; //<S2SV> dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; //<S2SV> if ( user_pwd ) //<S2SV> dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; //<S2SV> if ( rootdir ) //<S2SV> { //<S2SV> if ( strcmp ( rootdir , "/" ) != 0 ) //<S2SV> dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; //<S2SV> } //<S2SV> char * reason = xasprintf ( "%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s" , //<S2SV> last_slash , signame ? signame : signal_str ) ; //<S2SV> dd_save_text ( dd , FILENAME_REASON , reason ) ; //<S2SV> free ( reason ) ; //<S2SV> char * cmdline = get_cmdline ( pid ) ; //<S2SV> dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : "" ) ; //<S2SV> free ( cmdline ) ; //<S2SV> char * environ = get_environ ( pid ) ; //<S2SV> dd_save_text ( dd , FILENAME_ENVIRON , environ ? : "" ) ; //<S2SV> free ( environ ) ; //<S2SV> char * fips_enabled = xmalloc_fopen_fgetline_fclose ( "/proc/sys/crypto/fips_enabled" ) ; //<S2SV> if ( fips_enabled ) //<S2SV> { //<S2SV> if ( strcmp ( fips_enabled , "0" ) != 0 ) //<S2SV> dd_save_text ( dd , "fips_enabled" , fips_enabled ) ; //<S2SV> free ( fips_enabled ) ; //<S2SV> } //<S2SV> dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; //<S2SV> if ( src_fd_binary > 0 ) //<S2SV> { //<S2SV> strcpy ( path + path_len , "/" FILENAME_BINARY ) ; //<S2SV> int dst_fd = create_or_die ( path ) ; //<S2SV> off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; //<S2SV> if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) //<S2SV> { //<S2SV> dd_delete ( dd ) ; //<S2SV> error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; //<S2SV> } //<S2SV> close ( src_fd_binary ) ; //<S2SV> } //<S2SV> strcpy ( path + path_len , "/" FILENAME_COREDUMP ) ; //<S2SV> int abrt_core_fd = create_or_die ( path ) ; //<S2SV> off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; //<S2SV> if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) //<S2SV> { //<S2SV> unlink ( path ) ; //<S2SV> dd_delete ( dd ) ; //<S2SV> if ( user_core_fd >= 0 ) //<S2SV> { //<S2SV> xchdir ( user_pwd ) ; //<S2SV> unlink ( core_basename ) ; //<S2SV> } //<S2SV> error_msg_and_die ( "Error<S2SV_blank>writing<S2SV_blank>\'%s\'" , path ) ; //<S2SV> } //<S2SV> if ( user_core_fd >= 0 //<S2SV> && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 //<S2SV> || ( ulimit_c == 0 || core_size > ulimit_c ) //<S2SV> ) //<S2SV> ) { //<S2SV> xchdir ( user_pwd ) ; //<S2SV> unlink ( core_basename ) ; //<S2SV> } //<S2SV> # if 0 //<S2SV> { //<S2SV> char * java_log = xasprintf ( "/tmp/jvm-%lu/hs_error.log" , ( long ) pid ) ; //<S2SV> int src_fd = open ( java_log , O_RDONLY ) ; //<S2SV> free ( java_log ) ; //<S2SV> if ( src_fd < 0 ) //<S2SV> { //<S2SV> java_log = xasprintf ( "%s/hs_err_pid%lu.log" , user_pwd , ( long ) pid ) ; //<S2SV> src_fd = open ( java_log , O_RDONLY ) ; //<S2SV> free ( java_log ) ; //<S2SV> } //<S2SV> if ( src_fd >= 0 ) //<S2SV> { //<S2SV> strcpy ( path + path_len , "/hs_err.log" ) ; //<S2SV> int dst_fd = create_or_die ( path ) ; //<S2SV> off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; //<S2SV> if ( close ( dst_fd ) != 0 || sz < 0 ) //<S2SV> { //<S2SV> dd_delete ( dd ) ; //<S2SV> error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; //<S2SV> } //<S2SV> close ( src_fd ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> dd_close ( dd ) ; //<S2SV> path [ path_len ] = '\\0' ; //<S2SV> char * newpath = xstrndup ( path , path_len - ( sizeof ( ".new" ) - 1 ) ) ; //<S2SV> if ( rename ( path , newpath ) == 0 ) //<S2SV> strcpy ( path , newpath ) ; //<S2SV> free ( newpath ) ; //<S2SV> log ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , executable , path , ( long long ) core_size ) ; //<S2SV> notify_new_path ( path ) ; //<S2SV> if ( g_settings_nMaxCrashReportsSize > 0 ) //<S2SV> { //<S2SV> unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; //<S2SV> maxsize |= 63 ; //<S2SV> trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; //<S2SV> } //<S2SV> free ( rootdir ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> create_user_core : //<S2SV> if ( user_core_fd >= 0 ) //<S2SV> { //<S2SV> off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; //<S2SV> if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) //<S2SV> { //<S2SV> perror_msg ( "Error<S2SV_blank>writing<S2SV_blank>\'%s\'" , full_core_basename ) ; //<S2SV> xchdir ( user_pwd ) ; //<S2SV> unlink ( core_basename ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ulimit_c == 0 || core_size > ulimit_c ) //<S2SV> { //<S2SV> xchdir ( user_pwd ) ; //<S2SV> unlink ( core_basename ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> log ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 