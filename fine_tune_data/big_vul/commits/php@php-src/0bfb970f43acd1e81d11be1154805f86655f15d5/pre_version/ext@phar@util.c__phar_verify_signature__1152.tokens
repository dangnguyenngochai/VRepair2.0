int phar_verify_signature ( php_stream * fp , size_t end_of_phar , php_uint32 sig_type , char * sig , int sig_len , char * fname , char * * signature , int * signature_len , char * * error ) //<S2SV> { //<S2SV> int read_size , len ; //<S2SV> zend_off_t read_len ; //<S2SV> unsigned char buf [ 1024 ] ; //<S2SV> php_stream_rewind ( fp ) ; //<S2SV> switch ( sig_type ) { //<S2SV> case PHAR_SIG_OPENSSL : { //<S2SV> # ifdef PHAR_HAVE_OPENSSL //<S2SV> BIO * in ; //<S2SV> EVP_PKEY * key ; //<S2SV> EVP_MD * mdtype = ( EVP_MD * ) EVP_sha1 ( ) ; //<S2SV> EVP_MD_CTX md_ctx ; //<S2SV> # else //<S2SV> int tempsig ; //<S2SV> # endif //<S2SV> zend_string * pubkey = NULL ; //<S2SV> char * pfile ; //<S2SV> php_stream * pfp ; //<S2SV> # ifndef PHAR_HAVE_OPENSSL //<S2SV> if ( ! zend_hash_str_exists ( & module_registry , "openssl" , sizeof ( "openssl" ) - 1 ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "openssl<S2SV_blank>not<S2SV_blank>loaded" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> # endif //<S2SV> spprintf ( & pfile , 0 , "%s.pubkey" , fname ) ; //<S2SV> pfp = php_stream_open_wrapper ( pfile , "rb" , 0 , NULL ) ; //<S2SV> efree ( pfile ) ; //<S2SV> if ( ! pfp || ! ( pubkey = php_stream_copy_to_mem ( pfp , PHP_STREAM_COPY_ALL , 0 ) ) || ! ZSTR_LEN ( pubkey ) ) { //<S2SV> if ( pfp ) { //<S2SV> php_stream_close ( pfp ) ; //<S2SV> } //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "openssl<S2SV_blank>public<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>read" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> php_stream_close ( pfp ) ; //<S2SV> # ifndef PHAR_HAVE_OPENSSL //<S2SV> tempsig = sig_len ; //<S2SV> if ( FAILURE == phar_call_openssl_signverify ( 0 , fp , end_of_phar , pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 , & sig , & tempsig ) ) { //<S2SV> if ( pubkey ) { //<S2SV> zend_string_release ( pubkey ) ; //<S2SV> } //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>verified" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> if ( pubkey ) { //<S2SV> zend_string_release ( pubkey ) ; //<S2SV> } //<S2SV> sig_len = tempsig ; //<S2SV> # else //<S2SV> in = BIO_new_mem_buf ( pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 ) ; //<S2SV> if ( NULL == in ) { //<S2SV> zend_string_release ( pubkey ) ; //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>processed" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> key = PEM_read_bio_PUBKEY ( in , NULL , NULL , NULL ) ; //<S2SV> BIO_free ( in ) ; //<S2SV> zend_string_release ( pubkey ) ; //<S2SV> if ( NULL == key ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>processed" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> EVP_VerifyInit ( & md_ctx , mdtype ) ; //<S2SV> read_len = end_of_phar ; //<S2SV> if ( read_len > sizeof ( buf ) ) { //<S2SV> read_size = sizeof ( buf ) ; //<S2SV> } else { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> php_stream_seek ( fp , 0 , SEEK_SET ) ; //<S2SV> while ( read_size && ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { //<S2SV> EVP_VerifyUpdate ( & md_ctx , buf , len ) ; //<S2SV> read_len -= ( zend_off_t ) len ; //<S2SV> if ( read_len < read_size ) { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> } //<S2SV> if ( EVP_VerifyFinal ( & md_ctx , ( unsigned char * ) sig , sig_len , key ) != 1 ) { //<S2SV> EVP_MD_CTX_cleanup ( & md_ctx ) ; //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "broken<S2SV_blank>openssl<S2SV_blank>signature" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> EVP_MD_CTX_cleanup ( & md_ctx ) ; //<S2SV> # endif //<S2SV> * signature_len = phar_hex_str ( ( const char * ) sig , sig_len , signature ) ; //<S2SV> } //<S2SV> break ; //<S2SV> # ifdef PHAR_HASH_OK //<S2SV> case PHAR_SIG_SHA512 : { //<S2SV> unsigned char digest [ 64 ] ; //<S2SV> PHP_SHA512_CTX context ; //<S2SV> PHP_SHA512Init ( & context ) ; //<S2SV> read_len = end_of_phar ; //<S2SV> if ( read_len > sizeof ( buf ) ) { //<S2SV> read_size = sizeof ( buf ) ; //<S2SV> } else { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { //<S2SV> PHP_SHA512Update ( & context , buf , len ) ; //<S2SV> read_len -= ( zend_off_t ) len ; //<S2SV> if ( read_len < read_size ) { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> } //<S2SV> PHP_SHA512Final ( digest , & context ) ; //<S2SV> if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PHAR_SIG_SHA256 : { //<S2SV> unsigned char digest [ 32 ] ; //<S2SV> PHP_SHA256_CTX context ; //<S2SV> PHP_SHA256Init ( & context ) ; //<S2SV> read_len = end_of_phar ; //<S2SV> if ( read_len > sizeof ( buf ) ) { //<S2SV> read_size = sizeof ( buf ) ; //<S2SV> } else { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { //<S2SV> PHP_SHA256Update ( & context , buf , len ) ; //<S2SV> read_len -= ( zend_off_t ) len ; //<S2SV> if ( read_len < read_size ) { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> } //<S2SV> PHP_SHA256Final ( digest , & context ) ; //<S2SV> if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; //<S2SV> break ; //<S2SV> } //<S2SV> # else //<S2SV> case PHAR_SIG_SHA512 : //<S2SV> case PHAR_SIG_SHA256 : //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "unsupported<S2SV_blank>signature" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> # endif //<S2SV> case PHAR_SIG_SHA1 : { //<S2SV> unsigned char digest [ 20 ] ; //<S2SV> PHP_SHA1_CTX context ; //<S2SV> PHP_SHA1Init ( & context ) ; //<S2SV> read_len = end_of_phar ; //<S2SV> if ( read_len > sizeof ( buf ) ) { //<S2SV> read_size = sizeof ( buf ) ; //<S2SV> } else { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { //<S2SV> PHP_SHA1Update ( & context , buf , len ) ; //<S2SV> read_len -= ( zend_off_t ) len ; //<S2SV> if ( read_len < read_size ) { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> } //<S2SV> PHP_SHA1Final ( digest , & context ) ; //<S2SV> if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PHAR_SIG_MD5 : { //<S2SV> unsigned char digest [ 16 ] ; //<S2SV> PHP_MD5_CTX context ; //<S2SV> PHP_MD5Init ( & context ) ; //<S2SV> read_len = end_of_phar ; //<S2SV> if ( read_len > sizeof ( buf ) ) { //<S2SV> read_size = sizeof ( buf ) ; //<S2SV> } else { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { //<S2SV> PHP_MD5Update ( & context , buf , len ) ; //<S2SV> read_len -= ( zend_off_t ) len ; //<S2SV> if ( read_len < read_size ) { //<S2SV> read_size = ( int ) read_len ; //<S2SV> } //<S2SV> } //<S2SV> PHP_MD5Final ( digest , & context ) ; //<S2SV> if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 0 , "broken<S2SV_blank>or<S2SV_blank>unsupported<S2SV_blank>signature" ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> return SUCCESS ; //<S2SV> } //<S2SV> 