int phar_parse_zipfile ( php_stream * fp , char * fname , int fname_len , char * alias , int alias_len , phar_archive_data * * pphar , char * * error ) //<S2SV> { //<S2SV> phar_zip_dir_end locator ; //<S2SV> char buf [ sizeof ( locator ) + 65536 ] ; //<S2SV> zend_long size ; //<S2SV> php_uint16 i ; //<S2SV> phar_archive_data * mydata = NULL ; //<S2SV> phar_entry_info entry = { 0 } ; //<S2SV> char * p = buf , * ext , * actual_alias = NULL ; //<S2SV> char * metadata = NULL ; //<S2SV> size = php_stream_tell ( fp ) ; //<S2SV> if ( size > sizeof ( locator ) + 65536 ) { //<S2SV> size = sizeof ( locator ) + 65536 ; //<S2SV> if ( FAILURE == php_stream_seek ( fp , - size , SEEK_END ) ) { //<S2SV> php_stream_close ( fp ) ; //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> } else { //<S2SV> php_stream_seek ( fp , 0 , SEEK_SET ) ; //<S2SV> } //<S2SV> if ( ! php_stream_read ( fp , buf , size ) ) { //<S2SV> php_stream_close ( fp ) ; //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>data<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> while ( ( p = ( char * ) memchr ( p + 1 , 'P' , ( size_t ) ( size - ( p + 1 - buf ) ) ) ) != NULL ) { //<S2SV> if ( ( p - buf ) + sizeof ( locator ) <= size && ! memcmp ( p + 1 , "K\\5\\6" , 3 ) ) { //<S2SV> memcpy ( ( void * ) & locator , ( void * ) p , sizeof ( locator ) ) ; //<S2SV> if ( PHAR_GET_16 ( locator . centraldisk ) != 0 || PHAR_GET_16 ( locator . disknumber ) != 0 ) { //<S2SV> php_stream_close ( fp ) ; //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>split<S2SV_blank>archives<S2SV_blank>spanning<S2SV_blank>multiple<S2SV_blank>zips<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>processed<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> if ( PHAR_GET_16 ( locator . counthere ) != PHAR_GET_16 ( locator . count ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>conflicting<S2SV_blank>file<S2SV_blank>count<S2SV_blank>in<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>record<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; //<S2SV> } //<S2SV> php_stream_close ( fp ) ; //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> mydata = pecalloc ( 1 , sizeof ( phar_archive_data ) , PHAR_G ( persist ) ) ; //<S2SV> mydata -> is_persistent = PHAR_G ( persist ) ; //<S2SV> if ( PHAR_GET_16 ( locator . comment_len ) ) { //<S2SV> metadata = p + sizeof ( locator ) ; //<S2SV> if ( PHAR_GET_16 ( locator . comment_len ) != size - ( metadata - buf ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>zip<S2SV_blank>file<S2SV_blank>comment<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; //<S2SV> } //<S2SV> php_stream_close ( fp ) ; //<S2SV> pefree ( mydata , mydata -> is_persistent ) ; //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> mydata -> metadata_len = PHAR_GET_16 ( locator . comment_len ) ; //<S2SV> if ( phar_parse_metadata ( & metadata , & mydata -> metadata , PHAR_GET_16 ( locator . comment_len ) ) == FAILURE ) { //<S2SV> mydata -> metadata_len = 0 ; //<S2SV> ZVAL_NEW_STR ( & mydata -> metadata , zend_string_init ( metadata , PHAR_GET_16 ( locator . comment_len ) , mydata -> is_persistent ) ) ; //<S2SV> } //<S2SV> } else { //<S2SV> ZVAL_UNDEF ( & mydata -> metadata ) ; //<S2SV> } //<S2SV> goto foundit ; //<S2SV> } //<S2SV> } //<S2SV> php_stream_close ( fp ) ; //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; //<S2SV> } //<S2SV> return FAILURE ; //<S2SV> foundit : //<S2SV> mydata -> fname = pestrndup ( fname , fname_len , mydata -> is_persistent ) ; //<S2SV> # ifdef PHP_WIN32 //<S2SV> phar_unixify_path_separators ( mydata -> fname , fname_len ) ; //<S2SV> # endif //<S2SV> mydata -> is_zip = 1 ; //<S2SV> mydata -> fname_len = fname_len ; //<S2SV> ext = strrchr ( mydata -> fname , '/' ) ; //<S2SV> if ( ext ) { //<S2SV> mydata -> ext = memchr ( ext , '.' , ( mydata -> fname + fname_len ) - ext ) ; //<S2SV> if ( mydata -> ext == ext ) { //<S2SV> mydata -> ext = memchr ( ext + 1 , '.' , ( mydata -> fname + fname_len ) - ext - 1 ) ; //<S2SV> } //<S2SV> if ( mydata -> ext ) { //<S2SV> mydata -> ext_len = ( mydata -> fname + fname_len ) - mydata -> ext ; //<S2SV> } //<S2SV> } //<S2SV> php_stream_seek ( fp , PHAR_GET_32 ( locator . cdir_offset ) , SEEK_SET ) ; //<S2SV> zend_hash_init ( & mydata -> manifest , PHAR_GET_16 ( locator . count ) , //<S2SV> zend_get_hash_value , destroy_phar_manifest_entry , ( zend_bool ) mydata -> is_persistent ) ; //<S2SV> zend_hash_init ( & mydata -> mounted_dirs , 5 , //<S2SV> zend_get_hash_value , NULL , ( zend_bool ) mydata -> is_persistent ) ; //<S2SV> zend_hash_init ( & mydata -> virtual_dirs , PHAR_GET_16 ( locator . count ) * 2 , //<S2SV> zend_get_hash_value , NULL , ( zend_bool ) mydata -> is_persistent ) ; //<S2SV> entry . phar = mydata ; //<S2SV> entry . is_zip = 1 ; //<S2SV> entry . fp_type = PHAR_FP ; //<S2SV> entry . is_persistent = mydata -> is_persistent ; //<S2SV> # define PHAR_ZIP_FAIL_FREE ( errmsg , save ) zend_hash_destroy ( & mydata -> manifest ) ; mydata -> manifest . u . flags = 0 ; zend_hash_destroy ( & mydata -> mounted_dirs ) ; mydata -> mounted_dirs . u . flags = 0 ; zend_hash_destroy ( & mydata -> virtual_dirs ) ; mydata -> virtual_dirs . u . flags = 0 ; php_stream_close ( fp ) ; zval_dtor ( & mydata -> metadata ) ; if ( mydata -> signature ) { efree ( mydata -> signature ) ; } if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , errmsg , mydata -> fname ) ; } pefree ( mydata -> fname , mydata -> is_persistent ) ; if ( mydata -> alias ) { pefree ( mydata -> alias , mydata -> is_persistent ) ; } pefree ( mydata , mydata -> is_persistent ) ; efree ( save ) ; return FAILURE ; //<S2SV> # define PHAR_ZIP_FAIL ( errmsg ) zend_hash_destroy ( & mydata -> manifest ) ; mydata -> manifest . u . flags = 0 ; zend_hash_destroy ( & mydata -> mounted_dirs ) ; mydata -> mounted_dirs . u . flags = 0 ; zend_hash_destroy ( & mydata -> virtual_dirs ) ; mydata -> virtual_dirs . u . flags = 0 ; php_stream_close ( fp ) ; zval_dtor ( & mydata -> metadata ) ; if ( mydata -> signature ) { efree ( mydata -> signature ) ; } if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , errmsg , mydata -> fname ) ; } pefree ( mydata -> fname , mydata -> is_persistent ) ; if ( mydata -> alias ) { pefree ( mydata -> alias , mydata -> is_persistent ) ; } pefree ( mydata , mydata -> is_persistent ) ; return FAILURE ; //<S2SV> for ( i = 0 ; i < PHAR_GET_16 ( locator . count ) ; ++ i ) { //<S2SV> phar_zip_central_dir_file zipentry ; //<S2SV> zend_off_t beforeus = php_stream_tell ( fp ) ; //<S2SV> if ( sizeof ( zipentry ) != php_stream_read ( fp , ( char * ) & zipentry , sizeof ( zipentry ) ) ) { //<S2SV> PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>truncated" ) ; //<S2SV> } //<S2SV> if ( memcmp ( "PK\\1\\2" , zipentry . signature , 4 ) ) { //<S2SV> PHAR_ZIP_FAIL ( "corrupted<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>no<S2SV_blank>magic<S2SV_blank>signature" ) ; //<S2SV> } //<S2SV> if ( entry . is_persistent ) { //<S2SV> entry . manifest_pos = i ; //<S2SV> } //<S2SV> entry . compressed_filesize = PHAR_GET_32 ( zipentry . compsize ) ; //<S2SV> entry . uncompressed_filesize = PHAR_GET_32 ( zipentry . uncompsize ) ; //<S2SV> entry . crc32 = PHAR_GET_32 ( zipentry . crc32 ) ; //<S2SV> entry . timestamp = phar_zip_d2u_time ( zipentry . timestamp , zipentry . datestamp ) ; //<S2SV> entry . flags = PHAR_ENT_PERM_DEF_FILE ; //<S2SV> entry . header_offset = PHAR_GET_32 ( zipentry . offset ) ; //<S2SV> entry . offset = entry . offset_abs = PHAR_GET_32 ( zipentry . offset ) + sizeof ( phar_zip_file_header ) + PHAR_GET_16 ( zipentry . filename_len ) + //<S2SV> PHAR_GET_16 ( zipentry . extra_len ) ; //<S2SV> if ( PHAR_GET_16 ( zipentry . flags ) & PHAR_ZIP_FLAG_ENCRYPTED ) { //<S2SV> PHAR_ZIP_FAIL ( "Cannot<S2SV_blank>process<S2SV_blank>encrypted<S2SV_blank>zip<S2SV_blank>files" ) ; //<S2SV> } //<S2SV> if ( ! PHAR_GET_16 ( zipentry . filename_len ) ) { //<S2SV> PHAR_ZIP_FAIL ( "Cannot<S2SV_blank>process<S2SV_blank>zips<S2SV_blank>created<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>(zero-length<S2SV_blank>filename)" ) ; //<S2SV> } //<S2SV> entry . filename_len = PHAR_GET_16 ( zipentry . filename_len ) ; //<S2SV> entry . filename = ( char * ) pemalloc ( entry . filename_len + 1 , entry . is_persistent ) ; //<S2SV> if ( entry . filename_len != php_stream_read ( fp , entry . filename , entry . filename_len ) ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>filename<S2SV_blank>from<S2SV_blank>central<S2SV_blank>directory,<S2SV_blank>truncated" ) ; //<S2SV> } //<S2SV> entry . filename [ entry . filename_len ] = '\\0' ; //<S2SV> if ( entry . filename [ entry . filename_len - 1 ] == '/' ) { //<S2SV> entry . is_dir = 1 ; //<S2SV> if ( entry . filename_len > 1 ) { //<S2SV> entry . filename_len -- ; //<S2SV> } //<S2SV> entry . flags |= PHAR_ENT_PERM_DEF_DIR ; //<S2SV> } else { //<S2SV> entry . is_dir = 0 ; //<S2SV> } //<S2SV> if ( entry . filename_len == sizeof ( ".phar/signature.bin" ) - 1 && ! strncmp ( entry . filename , ".phar/signature.bin" , sizeof ( ".phar/signature.bin" ) - 1 ) ) { //<S2SV> size_t read ; //<S2SV> php_stream * sigfile ; //<S2SV> zend_off_t now ; //<S2SV> char * sig ; //<S2SV> now = php_stream_tell ( fp ) ; //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> sigfile = php_stream_fopen_tmpfile ( ) ; //<S2SV> if ( ! sigfile ) { //<S2SV> PHAR_ZIP_FAIL ( "couldn\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file" ) ; //<S2SV> } //<S2SV> php_stream_seek ( fp , 0 , SEEK_SET ) ; //<S2SV> php_stream_copy_to_stream_ex ( fp , sigfile , entry . header_offset , NULL ) ; //<S2SV> php_stream_seek ( fp , PHAR_GET_32 ( locator . cdir_offset ) , SEEK_SET ) ; //<S2SV> php_stream_copy_to_stream_ex ( fp , sigfile , beforeus - PHAR_GET_32 ( locator . cdir_offset ) , NULL ) ; //<S2SV> if ( metadata ) { //<S2SV> php_stream_write ( sigfile , metadata , PHAR_GET_16 ( locator . comment_len ) ) ; //<S2SV> } //<S2SV> php_stream_seek ( fp , sizeof ( phar_zip_file_header ) + entry . header_offset + entry . filename_len + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; //<S2SV> sig = ( char * ) emalloc ( entry . uncompressed_filesize ) ; //<S2SV> read = php_stream_read ( fp , sig , entry . uncompressed_filesize ) ; //<S2SV> if ( read != entry . uncompressed_filesize || read <= 8 ) { //<S2SV> php_stream_close ( sigfile ) ; //<S2SV> efree ( sig ) ; //<S2SV> PHAR_ZIP_FAIL ( "signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>read" ) ; //<S2SV> } //<S2SV> mydata -> sig_flags = PHAR_GET_32 ( sig ) ; //<S2SV> if ( FAILURE == phar_verify_signature ( sigfile , php_stream_tell ( sigfile ) , mydata -> sig_flags , sig + 8 , entry . uncompressed_filesize - 8 , fname , & mydata -> signature , & mydata -> sig_len , error ) ) { //<S2SV> efree ( sig ) ; //<S2SV> if ( error ) { //<S2SV> char * save ; //<S2SV> php_stream_close ( sigfile ) ; //<S2SV> spprintf ( & save , 4096 , "signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified:<S2SV_blank>%s" , * error ) ; //<S2SV> efree ( * error ) ; //<S2SV> PHAR_ZIP_FAIL_FREE ( save , save ) ; //<S2SV> } else { //<S2SV> php_stream_close ( sigfile ) ; //<S2SV> PHAR_ZIP_FAIL ( "signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified" ) ; //<S2SV> } //<S2SV> } //<S2SV> php_stream_close ( sigfile ) ; //<S2SV> efree ( sig ) ; //<S2SV> if ( i != PHAR_GET_16 ( locator . count ) - 1 ) { //<S2SV> PHAR_ZIP_FAIL ( "entries<S2SV_blank>exist<S2SV_blank>after<S2SV_blank>signature,<S2SV_blank>invalid<S2SV_blank>phar" ) ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> phar_add_virtual_dirs ( mydata , entry . filename , entry . filename_len ) ; //<S2SV> if ( PHAR_GET_16 ( zipentry . extra_len ) ) { //<S2SV> zend_off_t loc = php_stream_tell ( fp ) ; //<S2SV> if ( FAILURE == phar_zip_process_extra ( fp , & entry , PHAR_GET_16 ( zipentry . extra_len ) ) ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "Unable<S2SV_blank>to<S2SV_blank>process<S2SV_blank>extra<S2SV_blank>field<S2SV_blank>header<S2SV_blank>for<S2SV_blank>file<S2SV_blank>in<S2SV_blank>central<S2SV_blank>directory" ) ; //<S2SV> } //<S2SV> php_stream_seek ( fp , loc + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; //<S2SV> } //<S2SV> switch ( PHAR_GET_16 ( zipentry . compressed ) ) { //<S2SV> case PHAR_ZIP_COMP_NONE : //<S2SV> break ; //<S2SV> case PHAR_ZIP_COMP_DEFLATE : //<S2SV> entry . flags |= PHAR_ENT_COMPRESSED_GZ ; //<S2SV> if ( ! PHAR_G ( has_zlib ) ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "zlib<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PHAR_ZIP_COMP_BZIP2 : //<S2SV> entry . flags |= PHAR_ENT_COMPRESSED_BZ2 ; //<S2SV> if ( ! PHAR_G ( has_bz2 ) ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "bzip2<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 1 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Shrunk)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 2 : //<S2SV> case 3 : //<S2SV> case 4 : //<S2SV> case 5 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Reduce)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 6 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Implode)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 7 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Tokenize)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 9 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Deflate64)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 10 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PKWare<S2SV_blank>Implode/old<S2SV_blank>IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 14 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(LZMA)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 18 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 19 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>LZ77)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 97 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(WavPack)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> case 98 : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PPMd)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> default : //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(unknown)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; //<S2SV> } //<S2SV> if ( PHAR_GET_16 ( zipentry . comment_len ) ) { //<S2SV> if ( PHAR_GET_16 ( zipentry . comment_len ) != php_stream_read ( fp , buf , PHAR_GET_16 ( zipentry . comment_len ) ) ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>file<S2SV_blank>comment,<S2SV_blank>truncated" ) ; //<S2SV> } //<S2SV> p = buf ; //<S2SV> entry . metadata_len = PHAR_GET_16 ( zipentry . comment_len ) ; //<S2SV> if ( phar_parse_metadata ( & p , & ( entry . metadata ) , PHAR_GET_16 ( zipentry . comment_len ) ) == FAILURE ) { //<S2SV> entry . metadata_len = 0 ; //<S2SV> ZVAL_NEW_STR ( & entry . metadata , zend_string_init ( buf , PHAR_GET_16 ( zipentry . comment_len ) , entry . is_persistent ) ) ; //<S2SV> } //<S2SV> } else { //<S2SV> ZVAL_UNDEF ( & entry . metadata ) ; //<S2SV> } //<S2SV> if ( ! actual_alias && entry . filename_len == sizeof ( ".phar/alias.txt" ) - 1 && ! strncmp ( entry . filename , ".phar/alias.txt" , sizeof ( ".phar/alias.txt" ) - 1 ) ) { //<S2SV> php_stream_filter * filter ; //<S2SV> zend_off_t saveloc ; //<S2SV> phar_zip_file_header local ; //<S2SV> saveloc = php_stream_tell ( fp ) ; //<S2SV> php_stream_seek ( fp , PHAR_GET_32 ( zipentry . offset ) , SEEK_SET ) ; //<S2SV> if ( sizeof ( local ) != php_stream_read ( fp , ( char * ) & local , sizeof ( local ) ) ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(cannot<S2SV_blank>read<S2SV_blank>local<S2SV_blank>file<S2SV_blank>header<S2SV_blank>for<S2SV_blank>alias)" ) ; //<S2SV> } //<S2SV> if ( entry . filename_len != PHAR_GET_16 ( local . filename_len ) || entry . crc32 != PHAR_GET_32 ( local . crc32 ) || entry . uncompressed_filesize != PHAR_GET_32 ( local . uncompsize ) || entry . compressed_filesize != PHAR_GET_32 ( local . compsize ) ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(local<S2SV_blank>header<S2SV_blank>of<S2SV_blank>alias<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>central<S2SV_blank>directory)" ) ; //<S2SV> } //<S2SV> entry . offset = entry . offset_abs = //<S2SV> sizeof ( local ) + entry . header_offset + PHAR_GET_16 ( local . filename_len ) + PHAR_GET_16 ( local . extra_len ) ; //<S2SV> php_stream_seek ( fp , entry . offset , SEEK_SET ) ; //<S2SV> fp -> writepos = 0 ; //<S2SV> fp -> readpos = 0 ; //<S2SV> php_stream_seek ( fp , entry . offset , SEEK_SET ) ; //<S2SV> fp -> writepos = 0 ; //<S2SV> fp -> readpos = 0 ; //<S2SV> mydata -> alias_len = entry . uncompressed_filesize ; //<S2SV> if ( entry . flags & PHAR_ENT_COMPRESSED_GZ ) { //<S2SV> filter = php_stream_filter_create ( "zlib.inflate" , NULL , php_stream_is_persistent ( fp ) ) ; //<S2SV> if ( ! filter ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>alias,<S2SV_blank>zlib<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> php_stream_filter_append ( & fp -> readfilters , filter ) ; //<S2SV> { //<S2SV> zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; //<S2SV> if ( str ) { //<S2SV> entry . uncompressed_filesize = ZSTR_LEN ( str ) ; //<S2SV> actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; //<S2SV> zend_string_release ( str ) ; //<S2SV> } else { //<S2SV> actual_alias = NULL ; //<S2SV> entry . uncompressed_filesize = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! entry . uncompressed_filesize || ! actual_alias ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated" ) ; //<S2SV> } //<S2SV> php_stream_filter_flush ( filter , 1 ) ; //<S2SV> php_stream_filter_remove ( filter , 1 ) ; //<S2SV> } else if ( entry . flags & PHAR_ENT_COMPRESSED_BZ2 ) { //<S2SV> filter = php_stream_filter_create ( "bzip2.decompress" , NULL , php_stream_is_persistent ( fp ) ) ; //<S2SV> if ( ! filter ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>bzip2<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> php_stream_filter_append ( & fp -> readfilters , filter ) ; //<S2SV> { //<S2SV> zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; //<S2SV> if ( str ) { //<S2SV> entry . uncompressed_filesize = ZSTR_LEN ( str ) ; //<S2SV> actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; //<S2SV> zend_string_release ( str ) ; //<S2SV> } else { //<S2SV> actual_alias = NULL ; //<S2SV> entry . uncompressed_filesize = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! entry . uncompressed_filesize || ! actual_alias ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated" ) ; //<S2SV> } //<S2SV> php_stream_filter_flush ( filter , 1 ) ; //<S2SV> php_stream_filter_remove ( filter , 1 ) ; //<S2SV> } else { //<S2SV> { //<S2SV> zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; //<S2SV> if ( str ) { //<S2SV> entry . uncompressed_filesize = ZSTR_LEN ( str ) ; //<S2SV> actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; //<S2SV> zend_string_release ( str ) ; //<S2SV> } else { //<S2SV> actual_alias = NULL ; //<S2SV> entry . uncompressed_filesize = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! entry . uncompressed_filesize || ! actual_alias ) { //<S2SV> pefree ( entry . filename , entry . is_persistent ) ; //<S2SV> PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated" ) ; //<S2SV> } //<S2SV> } //<S2SV> php_stream_seek ( fp , saveloc , SEEK_SET ) ; //<S2SV> } //<S2SV> phar_set_inode ( & entry ) ; //<S2SV> zend_hash_str_add_mem ( & mydata -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) ) ; //<S2SV> } //<S2SV> mydata -> fp = fp ; //<S2SV> if ( zend_hash_str_exists ( & ( mydata -> manifest ) , ".phar/stub.php" , sizeof ( ".phar/stub.php" ) - 1 ) ) { //<S2SV> mydata -> is_data = 0 ; //<S2SV> } else { //<S2SV> mydata -> is_data = 1 ; //<S2SV> } //<S2SV> zend_hash_str_add_ptr ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len , mydata ) ; //<S2SV> if ( actual_alias ) { //<S2SV> phar_archive_data * fd_ptr ; //<S2SV> if ( ! phar_validate_alias ( actual_alias , mydata -> alias_len ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>invalid<S2SV_blank>alias<S2SV_blank>\\"%s\\"<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , actual_alias , fname ) ; //<S2SV> } //<S2SV> efree ( actual_alias ) ; //<S2SV> zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> mydata -> is_temporary_alias = 0 ; //<S2SV> if ( NULL != ( fd_ptr = zend_hash_str_find_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len ) ) ) { //<S2SV> if ( SUCCESS != phar_free_alias ( fd_ptr , actual_alias , mydata -> alias_len ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"<S2SV_blank>with<S2SV_blank>implicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use" , fname ) ; //<S2SV> } //<S2SV> efree ( actual_alias ) ; //<S2SV> zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> mydata -> alias = entry . is_persistent ? pestrndup ( actual_alias , mydata -> alias_len , 1 ) : actual_alias ; //<S2SV> if ( entry . is_persistent ) { //<S2SV> efree ( actual_alias ) ; //<S2SV> } //<S2SV> zend_hash_str_add_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len , mydata ) ; //<S2SV> } else { //<S2SV> phar_archive_data * fd_ptr ; //<S2SV> if ( alias_len ) { //<S2SV> if ( NULL != ( fd_ptr = zend_hash_str_find_ptr ( & ( PHAR_G ( phar_alias_map ) ) , alias , alias_len ) ) ) { //<S2SV> if ( SUCCESS != phar_free_alias ( fd_ptr , alias , alias_len ) ) { //<S2SV> if ( error ) { //<S2SV> spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"<S2SV_blank>with<S2SV_blank>explicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use" , fname ) ; //<S2SV> } //<S2SV> zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; //<S2SV> return FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> zend_hash_str_add_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len , mydata ) ; //<S2SV> mydata -> alias = pestrndup ( alias , alias_len , mydata -> is_persistent ) ; //<S2SV> mydata -> alias_len = alias_len ; //<S2SV> } else { //<S2SV> mydata -> alias = pestrndup ( mydata -> fname , fname_len , mydata -> is_persistent ) ; //<S2SV> mydata -> alias_len = fname_len ; //<S2SV> } //<S2SV> mydata -> is_temporary_alias = 1 ; //<S2SV> } //<S2SV> if ( pphar ) { //<S2SV> * pphar = mydata ; //<S2SV> } //<S2SV> return SUCCESS ; //<S2SV> } //<S2SV> 