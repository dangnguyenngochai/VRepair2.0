static void php_imagepolygon ( INTERNAL_FUNCTION_PARAMETERS , int filled ) //<S2SV> { //<S2SV> zval * IM , * POINTS ; //<S2SV> long NPOINTS , COL ; //<S2SV> zval * * var = NULL ; //<S2SV> gdImagePtr im ; //<S2SV> gdPointPtr points ; //<S2SV> int npoints , col , nelem , i ; //<S2SV> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "rall" , & IM , & POINTS , & NPOINTS , & COL ) == FAILURE ) { //<S2SV> return ; //<S2SV> } //<S2SV> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , "Image" , le_gd ) ; //<S2SV> npoints = NPOINTS ; //<S2SV> col = COL ; //<S2SV> nelem = zend_hash_num_elements ( Z_ARRVAL_P ( POINTS ) ) ; //<S2SV> if ( nelem < 6 ) { //<S2SV> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>3<S2SV_blank>points<S2SV_blank>in<S2SV_blank>your<S2SV_blank>array" ) ; //<S2SV> RETURN_FALSE ; //<S2SV> } //<S2SV> if ( npoints <= 0 ) { //<S2SV> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>give<S2SV_blank>a<S2SV_blank>positive<S2SV_blank>number<S2SV_blank>of<S2SV_blank>points" ) ; //<S2SV> RETURN_FALSE ; //<S2SV> } //<S2SV> if ( nelem < npoints * 2 ) { //<S2SV> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Trying<S2SV_blank>to<S2SV_blank>use<S2SV_blank>%d<S2SV_blank>points<S2SV_blank>in<S2SV_blank>array<S2SV_blank>with<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>points" , npoints , nelem / 2 ) ; //<S2SV> RETURN_FALSE ; //<S2SV> } //<S2SV> points = ( gdPointPtr ) safe_emalloc ( npoints , sizeof ( gdPoint ) , 0 ) ; //<S2SV> for ( i = 0 ; i < npoints ; i ++ ) { //<S2SV> if ( zend_hash_index_find ( Z_ARRVAL_P ( POINTS ) , ( i * 2 ) , ( void * * ) & var ) == SUCCESS ) { //<S2SV> if ( Z_TYPE_PP ( var ) != IS_LONG ) { //<S2SV> zval lval ; //<S2SV> lval = * * var ; //<S2SV> zval_copy_ctor ( & lval ) ; //<S2SV> convert_to_long ( & lval ) ; //<S2SV> points [ i ] . x = Z_LVAL ( lval ) ; //<S2SV> } else { //<S2SV> points [ i ] . x = Z_LVAL_PP ( var ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( zend_hash_index_find ( Z_ARRVAL_P ( POINTS ) , ( i * 2 ) + 1 , ( void * * ) & var ) == SUCCESS ) { //<S2SV> if ( Z_TYPE_PP ( var ) != IS_LONG ) { //<S2SV> zval lval ; //<S2SV> lval = * * var ; //<S2SV> zval_copy_ctor ( & lval ) ; //<S2SV> convert_to_long ( & lval ) ; //<S2SV> points [ i ] . y = Z_LVAL ( lval ) ; //<S2SV> } else { //<S2SV> points [ i ] . y = Z_LVAL_PP ( var ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( filled ) { //<S2SV> gdImageFilledPolygon ( im , points , npoints , col ) ; //<S2SV> } else { //<S2SV> gdImagePolygon ( im , points , npoints , col ) ; //<S2SV> } //<S2SV> efree ( points ) ; //<S2SV> RETURN_TRUE ; //<S2SV> } //<S2SV> 