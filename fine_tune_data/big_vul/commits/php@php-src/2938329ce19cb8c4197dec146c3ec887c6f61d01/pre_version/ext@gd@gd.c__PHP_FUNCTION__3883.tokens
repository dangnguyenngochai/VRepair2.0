PHP_FUNCTION ( imageaffinematrixconcat ) //<S2SV> { //<S2SV> double m1 [ 6 ] ; //<S2SV> double m2 [ 6 ] ; //<S2SV> double mr [ 6 ] ; //<S2SV> zval * * tmp ; //<S2SV> zval * z_m1 ; //<S2SV> zval * z_m2 ; //<S2SV> int i , nelems ; //<S2SV> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "aa" , & z_m1 , & z_m2 ) == FAILURE ) { //<S2SV> return ; //<S2SV> } //<S2SV> if ( ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_m1 ) ) ) != 6 ) || ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_m2 ) ) ) != 6 ) { //<S2SV> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Affine<S2SV_blank>arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>six<S2SV_blank>elements" ) ; //<S2SV> RETURN_FALSE ; //<S2SV> } //<S2SV> for ( i = 0 ; i < 6 ; i ++ ) { //<S2SV> if ( zend_hash_index_find ( Z_ARRVAL_P ( z_m1 ) , i , ( void * * ) & tmp ) == SUCCESS ) { //<S2SV> switch ( Z_TYPE_PP ( tmp ) ) { //<S2SV> case IS_LONG : //<S2SV> m1 [ i ] = Z_LVAL_PP ( tmp ) ; //<S2SV> break ; //<S2SV> case IS_DOUBLE : //<S2SV> m1 [ i ] = Z_DVAL_PP ( tmp ) ; //<S2SV> break ; //<S2SV> case IS_STRING : //<S2SV> convert_to_double_ex ( tmp ) ; //<S2SV> m1 [ i ] = Z_DVAL_PP ( tmp ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i" , i ) ; //<S2SV> RETURN_FALSE ; //<S2SV> } //<S2SV> } //<S2SV> if ( zend_hash_index_find ( Z_ARRVAL_P ( z_m2 ) , i , ( void * * ) & tmp ) == SUCCESS ) { //<S2SV> switch ( Z_TYPE_PP ( tmp ) ) { //<S2SV> case IS_LONG : //<S2SV> m2 [ i ] = Z_LVAL_PP ( tmp ) ; //<S2SV> break ; //<S2SV> case IS_DOUBLE : //<S2SV> m2 [ i ] = Z_DVAL_PP ( tmp ) ; //<S2SV> break ; //<S2SV> case IS_STRING : //<S2SV> convert_to_double_ex ( tmp ) ; //<S2SV> m2 [ i ] = Z_DVAL_PP ( tmp ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i" , i ) ; //<S2SV> RETURN_FALSE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( gdAffineConcat ( mr , m1 , m2 ) != GD_TRUE ) { //<S2SV> RETURN_FALSE ; //<S2SV> } //<S2SV> array_init ( return_value ) ; //<S2SV> for ( i = 0 ; i < 6 ; i ++ ) { //<S2SV> add_index_double ( return_value , i , mr [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> 