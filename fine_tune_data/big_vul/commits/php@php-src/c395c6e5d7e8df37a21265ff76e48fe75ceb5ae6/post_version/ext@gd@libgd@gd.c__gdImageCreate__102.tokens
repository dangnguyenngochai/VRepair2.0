gdImagePtr gdImageCreate ( int sx , int sy ) //<S2SV> { //<S2SV> int i ; //<S2SV> gdImagePtr im ; //<S2SV> if ( overflow2 ( sx , sy ) ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( overflow2 ( sizeof ( unsigned char * ) , sy ) ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; //<S2SV> im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; //<S2SV> im -> AA_opacity = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; //<S2SV> im -> polyInts = 0 ; //<S2SV> im -> polyAllocated = 0 ; //<S2SV> im -> brush = 0 ; //<S2SV> im -> tile = 0 ; //<S2SV> im -> style = 0 ; //<S2SV> for ( i = 0 ; i < sy ; i ++ ) { //<S2SV> im -> pixels [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; //<S2SV> im -> AA_opacity [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; //<S2SV> } //<S2SV> im -> sx = sx ; //<S2SV> im -> sy = sy ; //<S2SV> im -> colorsTotal = 0 ; //<S2SV> im -> transparent = ( - 1 ) ; //<S2SV> im -> interlace = 0 ; //<S2SV> im -> thick = 1 ; //<S2SV> im -> AA = 0 ; //<S2SV> im -> AA_polygon = 0 ; //<S2SV> for ( i = 0 ; i < gdMaxColors ; i ++ ) { //<S2SV> im -> open [ i ] = 1 ; //<S2SV> im -> red [ i ] = 0 ; //<S2SV> im -> green [ i ] = 0 ; //<S2SV> im -> blue [ i ] = 0 ; //<S2SV> } //<S2SV> im -> trueColor = 0 ; //<S2SV> im -> tpixels = 0 ; //<S2SV> im -> cx1 = 0 ; //<S2SV> im -> cy1 = 0 ; //<S2SV> im -> cx2 = im -> sx - 1 ; //<S2SV> im -> cy2 = im -> sy - 1 ; //<S2SV> im -> interpolation = NULL ; //<S2SV> im -> interpolation_id = GD_BILINEAR_FIXED ; //<S2SV> return im ; //<S2SV> } //<S2SV> 