php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , //<S2SV> const char * path , const char * mode , int options , char * * opened_path , //<S2SV> php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) //<S2SV> { //<S2SV> php_stream * stream = NULL ; //<S2SV> php_url * resource = NULL ; //<S2SV> int use_ssl ; //<S2SV> int use_proxy = 0 ; //<S2SV> char * scratch = NULL ; //<S2SV> char * tmp = NULL ; //<S2SV> char * ua_str = NULL ; //<S2SV> zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ; //<S2SV> int scratch_len = 0 ; //<S2SV> int body = 0 ; //<S2SV> char location [ HTTP_HEADER_BLOCK_SIZE ] ; //<S2SV> zval * response_header = NULL ; //<S2SV> int reqok = 0 ; //<S2SV> char * http_header_line = NULL ; //<S2SV> char tmp_line [ 128 ] ; //<S2SV> size_t chunk_size = 0 , file_size = 0 ; //<S2SV> int eol_detect = 0 ; //<S2SV> char * transport_string , * errstr = NULL ; //<S2SV> int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ; //<S2SV> char * protocol_version = NULL ; //<S2SV> int protocol_version_len = 3 ; //<S2SV> struct timeval timeout ; //<S2SV> char * user_headers = NULL ; //<S2SV> int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ; //<S2SV> int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ; //<S2SV> int follow_location = 1 ; //<S2SV> php_stream_filter * transfer_encoding = NULL ; //<S2SV> int response_code ; //<S2SV> tmp_line [ 0 ] = '\\0' ; //<S2SV> if ( redirect_max < 1 ) { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Redirection<S2SV_blank>limit<S2SV_blank>reached,<S2SV_blank>aborting" ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> resource = php_url_parse ( path ) ; //<S2SV> if ( resource == NULL ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( strncasecmp ( resource -> scheme , "http" , sizeof ( "http" ) ) && strncasecmp ( resource -> scheme , "https" , sizeof ( "https" ) ) ) { //<S2SV> if ( ! context || //<S2SV> php_stream_context_get_option ( context , wrapper -> wops -> label , "proxy" , & tmpzval ) == FAILURE || //<S2SV> Z_TYPE_PP ( tmpzval ) != IS_STRING || //<S2SV> Z_STRLEN_PP ( tmpzval ) <= 0 ) { //<S2SV> php_url_free ( resource ) ; //<S2SV> return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ; //<S2SV> } //<S2SV> request_fulluri = 1 ; //<S2SV> use_ssl = 0 ; //<S2SV> use_proxy = 1 ; //<S2SV> transport_len = Z_STRLEN_PP ( tmpzval ) ; //<S2SV> transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; //<S2SV> } else { //<S2SV> if ( strpbrk ( mode , "awx+" ) ) { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP<S2SV_blank>wrapper<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>writeable<S2SV_blank>connections" ) ; //<S2SV> php_url_free ( resource ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ; //<S2SV> if ( use_ssl && resource -> port == 0 ) //<S2SV> resource -> port = 443 ; //<S2SV> else if ( resource -> port == 0 ) //<S2SV> resource -> port = 80 ; //<S2SV> if ( context && //<S2SV> php_stream_context_get_option ( context , wrapper -> wops -> label , "proxy" , & tmpzval ) == SUCCESS && //<S2SV> Z_TYPE_PP ( tmpzval ) == IS_STRING && //<S2SV> Z_STRLEN_PP ( tmpzval ) > 0 ) { //<S2SV> use_proxy = 1 ; //<S2SV> transport_len = Z_STRLEN_PP ( tmpzval ) ; //<S2SV> transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; //<S2SV> } else { //<S2SV> transport_len = spprintf ( & transport_string , 0 , "%s://%s:%d" , use_ssl ? "ssl" : "tcp" , resource -> host , resource -> port ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , "timeout" , & tmpzval ) == SUCCESS ) { //<S2SV> SEPARATE_ZVAL ( tmpzval ) ; //<S2SV> convert_to_double_ex ( tmpzval ) ; //<S2SV> timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ; //<S2SV> timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ; //<S2SV> } else { //<S2SV> timeout . tv_sec = FG ( default_socket_timeout ) ; //<S2SV> timeout . tv_usec = 0 ; //<S2SV> } //<S2SV> stream = php_stream_xport_create ( transport_string , transport_len , options , //<S2SV> STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , //<S2SV> NULL , & timeout , context , & errstr , NULL ) ; //<S2SV> if ( stream ) { //<S2SV> php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ; //<S2SV> } //<S2SV> if ( errstr ) { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "%s" , errstr ) ; //<S2SV> efree ( errstr ) ; //<S2SV> errstr = NULL ; //<S2SV> } //<S2SV> efree ( transport_string ) ; //<S2SV> if ( stream && use_proxy && use_ssl ) { //<S2SV> smart_str header = { 0 } ; //<S2SV> if ( ! context || php_stream_context_get_option ( context , "ssl" , "peer_name" , & tmpzval ) == FAILURE ) { //<S2SV> MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ; //<S2SV> ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ; //<S2SV> php_stream_context_set_option ( stream -> context , "ssl" , "peer_name" , ssl_proxy_peer_name ) ; //<S2SV> } //<S2SV> smart_str_appendl ( & header , "CONNECT<S2SV_blank>" , sizeof ( "CONNECT<S2SV_blank>" ) - 1 ) ; //<S2SV> smart_str_appends ( & header , resource -> host ) ; //<S2SV> smart_str_appendc ( & header , ':' ) ; //<S2SV> smart_str_append_unsigned ( & header , resource -> port ) ; //<S2SV> smart_str_appendl ( & header , "<S2SV_blank>HTTP/1.0\\r\\n" , sizeof ( "<S2SV_blank>HTTP/1.0\\r\\n" ) - 1 ) ; //<S2SV> if ( context && php_stream_context_get_option ( context , "http" , "header" , & tmpzval ) == SUCCESS ) { //<S2SV> char * s , * p ; //<S2SV> if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { //<S2SV> HashPosition pos ; //<S2SV> zval * * tmpheader = NULL ; //<S2SV> for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; //<S2SV> SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; //<S2SV> zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { //<S2SV> if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { //<S2SV> s = Z_STRVAL_PP ( tmpheader ) ; //<S2SV> do { //<S2SV> while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; //<S2SV> p = s ; //<S2SV> while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; //<S2SV> if ( * p == ':' ) { //<S2SV> p ++ ; //<S2SV> if ( p - s == sizeof ( "Proxy-Authorization:" ) - 1 && //<S2SV> zend_binary_strcasecmp ( s , sizeof ( "Proxy-Authorization:" ) - 1 , //<S2SV> "Proxy-Authorization:" , sizeof ( "Proxy-Authorization:" ) - 1 ) == 0 ) { //<S2SV> while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; //<S2SV> smart_str_appendl ( & header , s , p - s ) ; //<S2SV> smart_str_appendl ( & header , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; //<S2SV> goto finish ; //<S2SV> } else { //<S2SV> while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; //<S2SV> } //<S2SV> } //<S2SV> s = p ; //<S2SV> while ( * s == '\\r' || * s == '\\n' ) s ++ ; //<S2SV> } while ( * s != 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { //<S2SV> s = Z_STRVAL_PP ( tmpzval ) ; //<S2SV> do { //<S2SV> while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; //<S2SV> p = s ; //<S2SV> while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; //<S2SV> if ( * p == ':' ) { //<S2SV> p ++ ; //<S2SV> if ( p - s == sizeof ( "Proxy-Authorization:" ) - 1 && //<S2SV> zend_binary_strcasecmp ( s , sizeof ( "Proxy-Authorization:" ) - 1 , //<S2SV> "Proxy-Authorization:" , sizeof ( "Proxy-Authorization:" ) - 1 ) == 0 ) { //<S2SV> while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; //<S2SV> smart_str_appendl ( & header , s , p - s ) ; //<S2SV> smart_str_appendl ( & header , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; //<S2SV> goto finish ; //<S2SV> } else { //<S2SV> while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; //<S2SV> } //<S2SV> } //<S2SV> s = p ; //<S2SV> while ( * s == '\\r' || * s == '\\n' ) s ++ ; //<S2SV> } while ( * s != 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> finish : //<S2SV> smart_str_appendl ( & header , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; //<S2SV> if ( php_stream_write ( stream , header . c , header . len ) != header . len ) { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy" ) ; //<S2SV> php_stream_close ( stream ) ; //<S2SV> stream = NULL ; //<S2SV> } //<S2SV> smart_str_free ( & header ) ; //<S2SV> if ( stream ) { //<S2SV> char header_line [ HTTP_HEADER_BLOCK_SIZE ] ; //<S2SV> while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) { //<S2SV> if ( header_line [ 0 ] == '\\n' || //<S2SV> header_line [ 0 ] == '\\r' || //<S2SV> header_line [ 0 ] == '\\0' ) { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( stream ) { //<S2SV> if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || //<S2SV> php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy" ) ; //<S2SV> php_stream_close ( stream ) ; //<S2SV> stream = NULL ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( stream == NULL ) //<S2SV> goto out ; //<S2SV> if ( options & STREAM_WILL_CAST ) //<S2SV> chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; //<S2SV> eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; //<S2SV> stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; //<S2SV> php_stream_context_set ( stream , context ) ; //<S2SV> php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ; //<S2SV> if ( header_init && context && php_stream_context_get_option ( context , "http" , "max_redirects" , & tmpzval ) == SUCCESS ) { //<S2SV> SEPARATE_ZVAL ( tmpzval ) ; //<S2SV> convert_to_long_ex ( tmpzval ) ; //<S2SV> redirect_max = Z_LVAL_PP ( tmpzval ) ; //<S2SV> } //<S2SV> if ( context && php_stream_context_get_option ( context , "http" , "method" , & tmpzval ) == SUCCESS ) { //<S2SV> if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { //<S2SV> if ( ! redirected //<S2SV> || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( "GET" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) //<S2SV> || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( "HEAD" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) //<S2SV> ) { //<S2SV> scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ; //<S2SV> scratch = emalloc ( scratch_len ) ; //<S2SV> strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ; //<S2SV> strncat ( scratch , "<S2SV_blank>" , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( context && php_stream_context_get_option ( context , "http" , "protocol_version" , & tmpzval ) == SUCCESS ) { //<S2SV> SEPARATE_ZVAL ( tmpzval ) ; //<S2SV> convert_to_double_ex ( tmpzval ) ; //<S2SV> protocol_version_len = spprintf ( & protocol_version , 0 , "%.1F" , Z_DVAL_PP ( tmpzval ) ) ; //<S2SV> } //<S2SV> if ( ! scratch ) { //<S2SV> scratch_len = strlen ( path ) + 29 + protocol_version_len ; //<S2SV> scratch = emalloc ( scratch_len ) ; //<S2SV> strncpy ( scratch , "GET<S2SV_blank>" , scratch_len ) ; //<S2SV> } //<S2SV> if ( ! request_fulluri && //<S2SV> context && //<S2SV> php_stream_context_get_option ( context , "http" , "request_fulluri" , & tmpzval ) == SUCCESS ) { //<S2SV> zval ztmp = * * tmpzval ; //<S2SV> zval_copy_ctor ( & ztmp ) ; //<S2SV> convert_to_boolean ( & ztmp ) ; //<S2SV> request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ; //<S2SV> zval_dtor ( & ztmp ) ; //<S2SV> } //<S2SV> if ( request_fulluri ) { //<S2SV> strcat ( scratch , path ) ; //<S2SV> } else { //<S2SV> if ( resource -> path && * resource -> path ) { //<S2SV> strlcat ( scratch , resource -> path , scratch_len ) ; //<S2SV> } else { //<S2SV> strlcat ( scratch , "/" , scratch_len ) ; //<S2SV> } //<S2SV> if ( resource -> query ) { //<S2SV> strlcat ( scratch , "?" , scratch_len ) ; //<S2SV> strlcat ( scratch , resource -> query , scratch_len ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( protocol_version ) { //<S2SV> strlcat ( scratch , "<S2SV_blank>HTTP/" , scratch_len ) ; //<S2SV> strlcat ( scratch , protocol_version , scratch_len ) ; //<S2SV> strlcat ( scratch , "\\r\\n" , scratch_len ) ; //<S2SV> } else { //<S2SV> strlcat ( scratch , "<S2SV_blank>HTTP/1.0\\r\\n" , scratch_len ) ; //<S2SV> } //<S2SV> php_stream_write ( stream , scratch , strlen ( scratch ) ) ; //<S2SV> if ( context && php_stream_context_get_option ( context , "http" , "header" , & tmpzval ) == SUCCESS ) { //<S2SV> tmp = NULL ; //<S2SV> if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { //<S2SV> HashPosition pos ; //<S2SV> zval * * tmpheader = NULL ; //<S2SV> smart_str tmpstr = { 0 } ; //<S2SV> for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; //<S2SV> SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; //<S2SV> zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) //<S2SV> ) { //<S2SV> if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { //<S2SV> smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ; //<S2SV> smart_str_appendl ( & tmpstr , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> smart_str_0 ( & tmpstr ) ; //<S2SV> if ( tmpstr . c ) { //<S2SV> tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; //<S2SV> smart_str_free ( & tmpstr ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { //<S2SV> tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; //<S2SV> } //<S2SV> if ( tmp && strlen ( tmp ) > 0 ) { //<S2SV> char * s ; //<S2SV> user_headers = estrdup ( tmp ) ; //<S2SV> php_strtolower ( tmp , strlen ( tmp ) ) ; //<S2SV> if ( ! header_init ) { //<S2SV> strip_header ( user_headers , tmp , "content-length:" ) ; //<S2SV> strip_header ( user_headers , tmp , "content-type:" ) ; //<S2SV> } //<S2SV> if ( ( s = strstr ( tmp , "user-agent:" ) ) && //<S2SV> ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || //<S2SV> * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { //<S2SV> have_header |= HTTP_HEADER_USER_AGENT ; //<S2SV> } //<S2SV> if ( ( s = strstr ( tmp , "host:" ) ) && //<S2SV> ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || //<S2SV> * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { //<S2SV> have_header |= HTTP_HEADER_HOST ; //<S2SV> } //<S2SV> if ( ( s = strstr ( tmp , "from:" ) ) && //<S2SV> ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || //<S2SV> * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { //<S2SV> have_header |= HTTP_HEADER_FROM ; //<S2SV> } //<S2SV> if ( ( s = strstr ( tmp , "authorization:" ) ) && //<S2SV> ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || //<S2SV> * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { //<S2SV> have_header |= HTTP_HEADER_AUTH ; //<S2SV> } //<S2SV> if ( ( s = strstr ( tmp , "content-length:" ) ) && //<S2SV> ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || //<S2SV> * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { //<S2SV> have_header |= HTTP_HEADER_CONTENT_LENGTH ; //<S2SV> } //<S2SV> if ( ( s = strstr ( tmp , "content-type:" ) ) && //<S2SV> ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || //<S2SV> * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { //<S2SV> have_header |= HTTP_HEADER_TYPE ; //<S2SV> } //<S2SV> if ( ( s = strstr ( tmp , "connection:" ) ) && //<S2SV> ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || //<S2SV> * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { //<S2SV> have_header |= HTTP_HEADER_CONNECTION ; //<S2SV> } //<S2SV> if ( use_proxy && use_ssl && ( s = strstr ( tmp , "proxy-authorization:" ) ) && //<S2SV> ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || //<S2SV> * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { //<S2SV> char * p = s + sizeof ( "proxy-authorization:" ) - 1 ; //<S2SV> while ( s > tmp && ( * ( s - 1 ) == '<S2SV_blank>' || * ( s - 1 ) == '\\t' ) ) s -- ; //<S2SV> while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; //<S2SV> while ( * p == '\\r' || * p == '\\n' ) p ++ ; //<S2SV> if ( * p == 0 ) { //<S2SV> if ( s == tmp ) { //<S2SV> efree ( user_headers ) ; //<S2SV> user_headers = NULL ; //<S2SV> } else { //<S2SV> while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ; //<S2SV> user_headers [ s - tmp ] = 0 ; //<S2SV> } //<S2SV> } else { //<S2SV> memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( tmp ) { //<S2SV> efree ( tmp ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) { //<S2SV> php_url_decode ( resource -> user , strlen ( resource -> user ) ) ; //<S2SV> strcpy ( scratch , resource -> user ) ; //<S2SV> strcat ( scratch , ":" ) ; //<S2SV> if ( resource -> pass ) { //<S2SV> php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ; //<S2SV> strcat ( scratch , resource -> pass ) ; //<S2SV> } //<S2SV> tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; //<S2SV> if ( snprintf ( scratch , scratch_len , "Authorization:<S2SV_blank>Basic<S2SV_blank>%s\\r\\n" , tmp ) > 0 ) { //<S2SV> php_stream_write ( stream , scratch , strlen ( scratch ) ) ; //<S2SV> php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ; //<S2SV> } //<S2SV> efree ( tmp ) ; //<S2SV> tmp = NULL ; //<S2SV> } //<S2SV> if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) { //<S2SV> if ( snprintf ( scratch , scratch_len , "From:<S2SV_blank>%s\\r\\n" , FG ( from_address ) ) > 0 ) //<S2SV> php_stream_write ( stream , scratch , strlen ( scratch ) ) ; //<S2SV> } //<S2SV> if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { //<S2SV> if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || //<S2SV> ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { //<S2SV> if ( snprintf ( scratch , scratch_len , "Host:<S2SV_blank>%s:%i\\r\\n" , resource -> host , resource -> port ) > 0 ) //<S2SV> php_stream_write ( stream , scratch , strlen ( scratch ) ) ; //<S2SV> } else { //<S2SV> if ( snprintf ( scratch , scratch_len , "Host:<S2SV_blank>%s\\r\\n" , resource -> host ) > 0 ) { //<S2SV> php_stream_write ( stream , scratch , strlen ( scratch ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) { //<S2SV> php_stream_write_string ( stream , "Connection:<S2SV_blank>close\\r\\n" ) ; //<S2SV> } //<S2SV> if ( context && //<S2SV> php_stream_context_get_option ( context , "http" , "user_agent" , & ua_zval ) == SUCCESS && //<S2SV> Z_TYPE_PP ( ua_zval ) == IS_STRING ) { //<S2SV> ua_str = Z_STRVAL_PP ( ua_zval ) ; //<S2SV> } else if ( FG ( user_agent ) ) { //<S2SV> ua_str = FG ( user_agent ) ; //<S2SV> } //<S2SV> if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) { //<S2SV> # define _UA_HEADER "User-Agent:<S2SV_blank>%s\\r\\n" //<S2SV> char * ua ; //<S2SV> size_t ua_len ; //<S2SV> ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ; //<S2SV> if ( ua_len > sizeof ( _UA_HEADER ) ) { //<S2SV> ua = emalloc ( ua_len + 1 ) ; //<S2SV> if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) { //<S2SV> ua [ ua_len ] = 0 ; //<S2SV> php_stream_write ( stream , ua , ua_len ) ; //<S2SV> } else { //<S2SV> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Cannot<S2SV_blank>construct<S2SV_blank>User-agent<S2SV_blank>header" ) ; //<S2SV> } //<S2SV> if ( ua ) { //<S2SV> efree ( ua ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( user_headers ) { //<S2SV> if ( //<S2SV> header_init && //<S2SV> context && //<S2SV> ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && //<S2SV> php_stream_context_get_option ( context , "http" , "content" , & tmpzval ) == SUCCESS && //<S2SV> Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 //<S2SV> ) { //<S2SV> scratch_len = slprintf ( scratch , scratch_len , "Content-Length:<S2SV_blank>%d\\r\\n" , Z_STRLEN_PP ( tmpzval ) ) ; //<S2SV> php_stream_write ( stream , scratch , scratch_len ) ; //<S2SV> have_header |= HTTP_HEADER_CONTENT_LENGTH ; //<S2SV> } //<S2SV> php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ; //<S2SV> php_stream_write ( stream , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; //<S2SV> efree ( user_headers ) ; //<S2SV> } //<S2SV> if ( header_init && context && //<S2SV> php_stream_context_get_option ( context , "http" , "content" , & tmpzval ) == SUCCESS && //<S2SV> Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { //<S2SV> if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) { //<S2SV> scratch_len = slprintf ( scratch , scratch_len , "Content-Length:<S2SV_blank>%d\\r\\n" , Z_STRLEN_PP ( tmpzval ) ) ; //<S2SV> php_stream_write ( stream , scratch , scratch_len ) ; //<S2SV> } //<S2SV> if ( ! ( have_header & HTTP_HEADER_TYPE ) ) { //<S2SV> php_stream_write ( stream , "Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n" , //<S2SV> sizeof ( "Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n" ) - 1 ) ; //<S2SV> php_error_docref ( NULL TSRMLS_CC , E_NOTICE , "Content-type<S2SV_blank>not<S2SV_blank>specified<S2SV_blank>assuming<S2SV_blank>application/x-www-form-urlencoded" ) ; //<S2SV> } //<S2SV> php_stream_write ( stream , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; //<S2SV> php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; //<S2SV> } else { //<S2SV> php_stream_write ( stream , "\\r\\n" , sizeof ( "\\r\\n" ) - 1 ) ; //<S2SV> } //<S2SV> location [ 0 ] = '\\0' ; //<S2SV> if ( ! EG ( active_symbol_table ) ) { //<S2SV> zend_rebuild_symbol_table ( TSRMLS_C ) ; //<S2SV> } //<S2SV> if ( header_init ) { //<S2SV> zval * ztmp ; //<S2SV> MAKE_STD_ZVAL ( ztmp ) ; //<S2SV> array_init ( ztmp ) ; //<S2SV> ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , "http_response_header" , ztmp ) ; //<S2SV> } //<S2SV> { //<S2SV> zval * * rh ; //<S2SV> if ( zend_hash_find ( EG ( active_symbol_table ) , "http_response_header" , sizeof ( "http_response_header" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>http_response_header<S2SV_blank>overwritten" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> response_header = * rh ; //<S2SV> Z_ADDREF_P ( response_header ) ; //<S2SV> } //<S2SV> if ( ! php_stream_eof ( stream ) ) { //<S2SV> size_t tmp_line_len ; //<S2SV> if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) { //<S2SV> zval * http_response ; //<S2SV> if ( tmp_line_len > 9 ) { //<S2SV> response_code = atoi ( tmp_line + 9 ) ; //<S2SV> } else { //<S2SV> response_code = 0 ; //<S2SV> } //<S2SV> if ( context && SUCCESS == php_stream_context_get_option ( context , "http" , "ignore_errors" , & tmpzval ) ) { //<S2SV> ignore_errors = zend_is_true ( * tmpzval ) ; //<S2SV> } //<S2SV> if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) { //<S2SV> reqok = 1 ; //<S2SV> } //<S2SV> if ( response_code >= 100 && response_code < 200 ) { //<S2SV> while ( //<S2SV> ! php_stream_eof ( stream ) //<S2SV> && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL //<S2SV> && ( tmp_line_len < sizeof ( "HTTP/1" ) - 1 || strncasecmp ( tmp_line , "HTTP/1" , sizeof ( "HTTP/1" ) - 1 ) ) //<S2SV> ) ; //<S2SV> if ( tmp_line_len > 9 ) { //<S2SV> response_code = atoi ( tmp_line + 9 ) ; //<S2SV> } else { //<S2SV> response_code = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( response_code >= 200 && response_code < 400 ) { //<S2SV> reqok = 1 ; //<S2SV> } else { //<S2SV> switch ( response_code ) { //<S2SV> case 403 : //<S2SV> php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , //<S2SV> tmp_line , response_code ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> if ( ! tmp_line_len ) { //<S2SV> tmp_line [ 0 ] = '\\0' ; //<S2SV> } //<S2SV> php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , //<S2SV> tmp_line , response_code ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { //<S2SV> -- tmp_line_len ; //<S2SV> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { //<S2SV> -- tmp_line_len ; //<S2SV> } //<S2SV> } //<S2SV> MAKE_STD_ZVAL ( http_response ) ; //<S2SV> ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ; //<S2SV> zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ; //<S2SV> } //<S2SV> } else { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>socket!" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ; //<S2SV> while ( ! body && ! php_stream_eof ( stream ) ) { //<S2SV> size_t http_header_line_length ; //<S2SV> if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) { //<S2SV> char * e = http_header_line + http_header_line_length - 1 ; //<S2SV> if ( * e != '\\n' ) { //<S2SV> do { //<S2SV> if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>HTTP<S2SV_blank>headers" ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> e = http_header_line + http_header_line_length - 1 ; //<S2SV> } while ( * e != '\\n' ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> while ( * e == '\\n' || * e == '\\r' ) { //<S2SV> e -- ; //<S2SV> } //<S2SV> http_header_line_length = e - http_header_line + 1 ; //<S2SV> http_header_line [ http_header_line_length ] = '\\0' ; //<S2SV> if ( ! strncasecmp ( http_header_line , "Location:<S2SV_blank>" , 10 ) ) { //<S2SV> if ( context && php_stream_context_get_option ( context , "http" , "follow_location" , & tmpzval ) == SUCCESS ) { //<S2SV> SEPARATE_ZVAL ( tmpzval ) ; //<S2SV> convert_to_long_ex ( tmpzval ) ; //<S2SV> follow_location = Z_LVAL_PP ( tmpzval ) ; //<S2SV> } else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) { //<S2SV> follow_location = 0 ; //<S2SV> } //<S2SV> strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ; //<S2SV> } else if ( ! strncasecmp ( http_header_line , "Content-Type:<S2SV_blank>" , 14 ) ) { //<S2SV> php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ; //<S2SV> } else if ( ! strncasecmp ( http_header_line , "Content-Length:<S2SV_blank>" , 16 ) ) { //<S2SV> file_size = atoi ( http_header_line + 16 ) ; //<S2SV> php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ; //<S2SV> } else if ( ! strncasecmp ( http_header_line , "Transfer-Encoding:<S2SV_blank>chunked" , sizeof ( "Transfer-Encoding:<S2SV_blank>chunked" ) ) ) { //<S2SV> if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) { //<S2SV> long decode = 1 ; //<S2SV> if ( context && php_stream_context_get_option ( context , "http" , "auto_decode" , & tmpzval ) == SUCCESS ) { //<S2SV> SEPARATE_ZVAL ( tmpzval ) ; //<S2SV> convert_to_boolean ( * tmpzval ) ; //<S2SV> decode = Z_LVAL_PP ( tmpzval ) ; //<S2SV> } //<S2SV> if ( decode ) { //<S2SV> transfer_encoding = php_stream_filter_create ( "dechunk" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ; //<S2SV> if ( transfer_encoding ) { //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( http_header_line [ 0 ] == '\\0' ) { //<S2SV> body = 1 ; //<S2SV> } else { //<S2SV> zval * http_header ; //<S2SV> MAKE_STD_ZVAL ( http_header ) ; //<S2SV> ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; //<S2SV> zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; //<S2SV> } //<S2SV> } else { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) { //<S2SV> if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) { //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( location [ 0 ] != '\\0' ) //<S2SV> php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ; //<S2SV> php_stream_close ( stream ) ; //<S2SV> stream = NULL ; //<S2SV> if ( location [ 0 ] != '\\0' ) { //<S2SV> char new_path [ HTTP_HEADER_BLOCK_SIZE ] ; //<S2SV> char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; //<S2SV> * new_path = '\\0' ; //<S2SV> if ( strlen ( location ) < 8 || ( strncasecmp ( location , "http://" , sizeof ( "http://" ) - 1 ) && //<S2SV> strncasecmp ( location , "https://" , sizeof ( "https://" ) - 1 ) && //<S2SV> strncasecmp ( location , "ftp://" , sizeof ( "ftp://" ) - 1 ) && //<S2SV> strncasecmp ( location , "ftps://" , sizeof ( "ftps://" ) - 1 ) ) ) //<S2SV> { //<S2SV> if ( * location != '/' ) { //<S2SV> if ( * ( location + 1 ) != '\\0' && resource -> path ) { //<S2SV> char * s = strrchr ( resource -> path , '/' ) ; //<S2SV> if ( ! s ) { //<S2SV> s = resource -> path ; //<S2SV> if ( ! s [ 0 ] ) { //<S2SV> efree ( s ) ; //<S2SV> s = resource -> path = estrdup ( "/" ) ; //<S2SV> } else { //<S2SV> * s = '/' ; //<S2SV> } //<S2SV> } //<S2SV> s [ 1 ] = '\\0' ; //<S2SV> if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) { //<S2SV> snprintf ( loc_path , sizeof ( loc_path ) - 1 , "%s%s" , resource -> path , location ) ; //<S2SV> } else { //<S2SV> snprintf ( loc_path , sizeof ( loc_path ) - 1 , "%s/%s" , resource -> path , location ) ; //<S2SV> } //<S2SV> } else { //<S2SV> snprintf ( loc_path , sizeof ( loc_path ) - 1 , "/%s" , location ) ; //<S2SV> } //<S2SV> } else { //<S2SV> strlcpy ( loc_path , location , sizeof ( loc_path ) ) ; //<S2SV> } //<S2SV> if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) { //<S2SV> snprintf ( new_path , sizeof ( new_path ) - 1 , "%s://%s:%d%s" , resource -> scheme , resource -> host , resource -> port , loc_path ) ; //<S2SV> } else { //<S2SV> snprintf ( new_path , sizeof ( new_path ) - 1 , "%s://%s%s" , resource -> scheme , resource -> host , loc_path ) ; //<S2SV> } //<S2SV> } else { //<S2SV> strlcpy ( new_path , location , sizeof ( new_path ) ) ; //<S2SV> } //<S2SV> php_url_free ( resource ) ; //<S2SV> if ( ( resource = php_url_parse ( new_path ) ) == NULL ) { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s" , new_path ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s" , new_path ) ; goto out ; } s ++ ; } } } //<S2SV> if ( strncasecmp ( new_path , "http://" , sizeof ( "http://" ) - 1 ) || strncasecmp ( new_path , "https://" , sizeof ( "https://" ) - 1 ) ) { //<S2SV> CHECK_FOR_CNTRL_CHARS ( resource -> user ) //<S2SV> CHECK_FOR_CNTRL_CHARS ( resource -> pass ) //<S2SV> CHECK_FOR_CNTRL_CHARS ( resource -> path ) //<S2SV> } //<S2SV> stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ; //<S2SV> } else { //<S2SV> php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , "HTTP<S2SV_blank>request<S2SV_blank>failed!<S2SV_blank>%s" , tmp_line ) ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> if ( protocol_version ) { //<S2SV> efree ( protocol_version ) ; //<S2SV> } //<S2SV> if ( http_header_line ) { //<S2SV> efree ( http_header_line ) ; //<S2SV> } //<S2SV> if ( scratch ) { //<S2SV> efree ( scratch ) ; //<S2SV> } //<S2SV> if ( resource ) { //<S2SV> php_url_free ( resource ) ; //<S2SV> } //<S2SV> if ( stream ) { //<S2SV> if ( header_init ) { //<S2SV> stream -> wrapperdata = response_header ; //<S2SV> } else { //<S2SV> if ( response_header ) { //<S2SV> Z_DELREF_P ( response_header ) ; //<S2SV> } //<S2SV> } //<S2SV> php_stream_notify_progress_init ( context , 0 , file_size ) ; //<S2SV> if ( options & STREAM_WILL_CAST ) //<S2SV> php_stream_set_chunk_size ( stream , chunk_size ) ; //<S2SV> stream -> flags |= eol_detect ; //<S2SV> stream -> position = 0 ; //<S2SV> strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ; //<S2SV> if ( transfer_encoding ) { //<S2SV> php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( response_header ) { //<S2SV> Z_DELREF_P ( response_header ) ; //<S2SV> } //<S2SV> if ( transfer_encoding ) { //<S2SV> php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ; //<S2SV> } //<S2SV> } //<S2SV> return stream ; //<S2SV> } //<S2SV> 