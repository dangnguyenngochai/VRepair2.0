static zval * * spl_array_get_dimension_ptr_ptr ( int check_inherited , zval * object , zval * offset , int type TSRMLS_DC ) //<S2SV> { //<S2SV> spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ; //<S2SV> zval * * retval ; //<S2SV> char * key ; //<S2SV> uint len ; //<S2SV> long index ; //<S2SV> HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; //<S2SV> if ( ! offset || ! ht ) { //<S2SV> return & EG ( uninitialized_zval_ptr ) ; //<S2SV> } //<S2SV> if ( ( type == BP_VAR_W || type == BP_VAR_RW ) && ( ht -> nApplyCount > 0 ) ) { //<S2SV> zend_error ( E_WARNING , "Modification<S2SV_blank>of<S2SV_blank>ArrayObject<S2SV_blank>during<S2SV_blank>sorting<S2SV_blank>is<S2SV_blank>prohibited" ) ; //<S2SV> return & EG ( error_zval_ptr ) ; ; //<S2SV> } //<S2SV> switch ( Z_TYPE_P ( offset ) ) { //<S2SV> case IS_STRING : //<S2SV> key = Z_STRVAL_P ( offset ) ; //<S2SV> len = Z_STRLEN_P ( offset ) + 1 ; //<S2SV> string_offest : //<S2SV> if ( zend_symtable_find ( ht , key , len , ( void * * ) & retval ) == FAILURE ) { //<S2SV> switch ( type ) { //<S2SV> case BP_VAR_R : //<S2SV> zend_error ( E_NOTICE , "Undefined<S2SV_blank>index:<S2SV_blank>%s" , key ) ; //<S2SV> case BP_VAR_UNSET : //<S2SV> case BP_VAR_IS : //<S2SV> retval = & EG ( uninitialized_zval_ptr ) ; //<S2SV> break ; //<S2SV> case BP_VAR_RW : //<S2SV> zend_error ( E_NOTICE , "Undefined<S2SV_blank>index:<S2SV_blank>%s" , key ) ; //<S2SV> case BP_VAR_W : { //<S2SV> zval * value ; //<S2SV> ALLOC_INIT_ZVAL ( value ) ; //<S2SV> zend_symtable_update ( ht , key , len , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return retval ; //<S2SV> case IS_NULL : //<S2SV> key = "" ; //<S2SV> len = 1 ; //<S2SV> goto string_offest ; //<S2SV> case IS_RESOURCE : //<S2SV> zend_error ( E_STRICT , "Resource<S2SV_blank>ID#%ld<S2SV_blank>used<S2SV_blank>as<S2SV_blank>offset,<S2SV_blank>casting<S2SV_blank>to<S2SV_blank>integer<S2SV_blank>(%ld)" , Z_LVAL_P ( offset ) , Z_LVAL_P ( offset ) ) ; //<S2SV> case IS_DOUBLE : //<S2SV> case IS_BOOL : //<S2SV> case IS_LONG : //<S2SV> if ( offset -> type == IS_DOUBLE ) { //<S2SV> index = ( long ) Z_DVAL_P ( offset ) ; //<S2SV> } else { //<S2SV> index = Z_LVAL_P ( offset ) ; //<S2SV> } //<S2SV> if ( zend_hash_index_find ( ht , index , ( void * * ) & retval ) == FAILURE ) { //<S2SV> switch ( type ) { //<S2SV> case BP_VAR_R : //<S2SV> zend_error ( E_NOTICE , "Undefined<S2SV_blank>offset:<S2SV_blank>%ld" , index ) ; //<S2SV> case BP_VAR_UNSET : //<S2SV> case BP_VAR_IS : //<S2SV> retval = & EG ( uninitialized_zval_ptr ) ; //<S2SV> break ; //<S2SV> case BP_VAR_RW : //<S2SV> zend_error ( E_NOTICE , "Undefined<S2SV_blank>offset:<S2SV_blank>%ld" , index ) ; //<S2SV> case BP_VAR_W : { //<S2SV> zval * value ; //<S2SV> ALLOC_INIT_ZVAL ( value ) ; //<S2SV> zend_hash_index_update ( ht , index , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return retval ; //<S2SV> default : //<S2SV> zend_error ( E_WARNING , "Illegal<S2SV_blank>offset<S2SV_blank>type" ) ; //<S2SV> return ( type == BP_VAR_W || type == BP_VAR_RW ) ? //<S2SV> & EG ( error_zval_ptr ) : & EG ( uninitialized_zval_ptr ) ; //<S2SV> } //<S2SV> } //<S2SV> 