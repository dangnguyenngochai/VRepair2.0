enum_func_status //<S2SV> php_mysqlnd_rowp_read_text_protocol_aux ( MYSQLND_MEMORY_POOL_CHUNK * row_buffer , zval * * fields , //<S2SV> unsigned int field_count , const MYSQLND_FIELD * fields_metadata , //<S2SV> zend_bool as_int_or_float , zend_bool copy_data , MYSQLND_STATS * stats TSRMLS_DC ) //<S2SV> { //<S2SV> unsigned int i ; //<S2SV> zend_bool last_field_was_string = FALSE ; //<S2SV> zval * * current_field , * * end_field , * * start_field ; //<S2SV> zend_uchar * p = row_buffer -> ptr ; //<S2SV> size_t data_size = row_buffer -> app ; //<S2SV> zend_uchar * bit_area = ( zend_uchar * ) row_buffer -> ptr + data_size + 1 ; //<S2SV> const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; //<S2SV> DBG_ENTER ( "php_mysqlnd_rowp_read_text_protocol_aux" ) ; //<S2SV> if ( ! fields ) { //<S2SV> DBG_RETURN ( FAIL ) ; //<S2SV> } //<S2SV> end_field = ( start_field = fields ) + field_count ; //<S2SV> for ( i = 0 , current_field = start_field ; current_field < end_field ; current_field ++ , i ++ ) { //<S2SV> DBG_INF ( "Directly<S2SV_blank>creating<S2SV_blank>zval" ) ; //<S2SV> MAKE_STD_ZVAL ( * current_field ) ; //<S2SV> if ( ! * current_field ) { //<S2SV> DBG_RETURN ( FAIL ) ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 , current_field = start_field ; current_field < end_field ; current_field ++ , i ++ ) { //<S2SV> zend_uchar * this_field_len_pos = p ; //<S2SV> const unsigned long len = php_mysqlnd_net_field_length ( & p ) ; //<S2SV> if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { //<S2SV> php_error_docref ( NULL , E_WARNING , "Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>" MYSQLND_SZ_T_SPEC //<S2SV> "<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet" , ( p + len ) - packet_end - 1 ) ; //<S2SV> DBG_RETURN ( FAIL ) ; //<S2SV> } //<S2SV> if ( copy_data == FALSE && current_field > start_field && last_field_was_string ) { //<S2SV> * this_field_len_pos = '\\0' ; //<S2SV> } //<S2SV> if ( len == MYSQLND_NULL_LENGTH ) { //<S2SV> ZVAL_NULL ( * current_field ) ; //<S2SV> last_field_was_string = FALSE ; //<S2SV> } else { //<S2SV> # if defined ( MYSQLND_STRING_TO_INT_CONVERSION ) //<S2SV> struct st_mysqlnd_perm_bind perm_bind = //<S2SV> mysqlnd_ps_fetch_functions [ fields_metadata [ i ] . type ] ; //<S2SV> # endif //<S2SV> if ( MYSQLND_G ( collect_statistics ) ) { //<S2SV> enum_mysqlnd_collected_stats statistic ; //<S2SV> switch ( fields_metadata [ i ] . type ) { //<S2SV> case MYSQL_TYPE_DECIMAL : statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL ; break ; //<S2SV> case MYSQL_TYPE_TINY : statistic = STAT_TEXT_TYPE_FETCHED_INT8 ; break ; //<S2SV> case MYSQL_TYPE_SHORT : statistic = STAT_TEXT_TYPE_FETCHED_INT16 ; break ; //<S2SV> case MYSQL_TYPE_LONG : statistic = STAT_TEXT_TYPE_FETCHED_INT32 ; break ; //<S2SV> case MYSQL_TYPE_FLOAT : statistic = STAT_TEXT_TYPE_FETCHED_FLOAT ; break ; //<S2SV> case MYSQL_TYPE_DOUBLE : statistic = STAT_TEXT_TYPE_FETCHED_DOUBLE ; break ; //<S2SV> case MYSQL_TYPE_NULL : statistic = STAT_TEXT_TYPE_FETCHED_NULL ; break ; //<S2SV> case MYSQL_TYPE_TIMESTAMP : statistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP ; break ; //<S2SV> case MYSQL_TYPE_LONGLONG : statistic = STAT_TEXT_TYPE_FETCHED_INT64 ; break ; //<S2SV> case MYSQL_TYPE_INT24 : statistic = STAT_TEXT_TYPE_FETCHED_INT24 ; break ; //<S2SV> case MYSQL_TYPE_DATE : statistic = STAT_TEXT_TYPE_FETCHED_DATE ; break ; //<S2SV> case MYSQL_TYPE_TIME : statistic = STAT_TEXT_TYPE_FETCHED_TIME ; break ; //<S2SV> case MYSQL_TYPE_DATETIME : statistic = STAT_TEXT_TYPE_FETCHED_DATETIME ; break ; //<S2SV> case MYSQL_TYPE_YEAR : statistic = STAT_TEXT_TYPE_FETCHED_YEAR ; break ; //<S2SV> case MYSQL_TYPE_NEWDATE : statistic = STAT_TEXT_TYPE_FETCHED_DATE ; break ; //<S2SV> case MYSQL_TYPE_VARCHAR : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; //<S2SV> case MYSQL_TYPE_BIT : statistic = STAT_TEXT_TYPE_FETCHED_BIT ; break ; //<S2SV> case MYSQL_TYPE_NEWDECIMAL : statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL ; break ; //<S2SV> case MYSQL_TYPE_ENUM : statistic = STAT_TEXT_TYPE_FETCHED_ENUM ; break ; //<S2SV> case MYSQL_TYPE_SET : statistic = STAT_TEXT_TYPE_FETCHED_SET ; break ; //<S2SV> case MYSQL_TYPE_JSON : statistic = STAT_TEXT_TYPE_FETCHED_JSON ; break ; //<S2SV> case MYSQL_TYPE_TINY_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; //<S2SV> case MYSQL_TYPE_MEDIUM_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; //<S2SV> case MYSQL_TYPE_LONG_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; //<S2SV> case MYSQL_TYPE_BLOB : statistic = STAT_TEXT_TYPE_FETCHED_BLOB ; break ; //<S2SV> case MYSQL_TYPE_VAR_STRING : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; //<S2SV> case MYSQL_TYPE_STRING : statistic = STAT_TEXT_TYPE_FETCHED_STRING ; break ; //<S2SV> case MYSQL_TYPE_GEOMETRY : statistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY ; break ; //<S2SV> default : statistic = STAT_TEXT_TYPE_FETCHED_OTHER ; break ; //<S2SV> } //<S2SV> MYSQLND_INC_CONN_STATISTIC_W_VALUE2 ( stats , statistic , 1 , STAT_BYTES_RECEIVED_PURE_DATA_TEXT , len ) ; //<S2SV> } //<S2SV> # ifdef MYSQLND_STRING_TO_INT_CONVERSION //<S2SV> if ( as_int_or_float && perm_bind . php_type == IS_LONG ) { //<S2SV> zend_uchar save = * ( p + len ) ; //<S2SV> * ( p + len ) = '\\0' ; //<S2SV> if ( perm_bind . pack_len < SIZEOF_LONG ) { //<S2SV> int64_t v = //<S2SV> # ifndef PHP_WIN32 //<S2SV> atoll ( ( char * ) p ) ; //<S2SV> # else //<S2SV> _atoi64 ( ( char * ) p ) ; //<S2SV> # endif //<S2SV> ZVAL_LONG ( * current_field , ( long ) v ) ; //<S2SV> } else { //<S2SV> uint64_t v = //<S2SV> # ifndef PHP_WIN32 //<S2SV> ( uint64_t ) atoll ( ( char * ) p ) ; //<S2SV> # else //<S2SV> ( uint64_t ) _atoi64 ( ( char * ) p ) ; //<S2SV> # endif //<S2SV> zend_bool uns = fields_metadata [ i ] . flags & UNSIGNED_FLAG ? TRUE : FALSE ; //<S2SV> # if SIZEOF_LONG == 8 //<S2SV> if ( uns == TRUE && v > 9223372036854775807L ) //<S2SV> # elif SIZEOF_LONG == 4 //<S2SV> if ( ( uns == TRUE && v > L64 ( 2147483647 ) ) || //<S2SV> ( uns == FALSE && ( ( L64 ( 2147483647 ) < ( int64_t ) v ) || //<S2SV> ( L64 ( - 2147483648 ) > ( int64_t ) v ) ) ) ) //<S2SV> # else //<S2SV> # error Need fix for this architecture //<S2SV> # endif //<S2SV> { //<S2SV> ZVAL_STRINGL ( * current_field , ( char * ) p , len , 0 ) ; //<S2SV> } else { //<S2SV> ZVAL_LONG ( * current_field , ( long ) v ) ; //<S2SV> } //<S2SV> } //<S2SV> * ( p + len ) = save ; //<S2SV> } else if ( as_int_or_float && perm_bind . php_type == IS_DOUBLE ) { //<S2SV> zend_uchar save = * ( p + len ) ; //<S2SV> * ( p + len ) = '\\0' ; //<S2SV> ZVAL_DOUBLE ( * current_field , atof ( ( char * ) p ) ) ; //<S2SV> * ( p + len ) = save ; //<S2SV> } else //<S2SV> # endif //<S2SV> if ( fields_metadata [ i ] . type == MYSQL_TYPE_BIT ) { //<S2SV> zend_uchar * start = bit_area ; //<S2SV> ps_fetch_from_1_to_8_bytes ( * current_field , & ( fields_metadata [ i ] ) , 0 , & p , len TSRMLS_CC ) ; //<S2SV> p -= len ; //<S2SV> if ( Z_TYPE_PP ( current_field ) == IS_LONG ) { //<S2SV> bit_area += 1 + sprintf ( ( char * ) start , "%ld" , Z_LVAL_PP ( current_field ) ) ; //<S2SV> ZVAL_STRINGL ( * current_field , ( char * ) start , bit_area - start - 1 , copy_data ) ; //<S2SV> } else if ( Z_TYPE_PP ( current_field ) == IS_STRING ) { //<S2SV> memcpy ( bit_area , Z_STRVAL_PP ( current_field ) , Z_STRLEN_PP ( current_field ) ) ; //<S2SV> bit_area += Z_STRLEN_PP ( current_field ) ; //<S2SV> * bit_area ++ = '\\0' ; //<S2SV> zval_dtor ( * current_field ) ; //<S2SV> ZVAL_STRINGL ( * current_field , ( char * ) start , bit_area - start - 1 , copy_data ) ; //<S2SV> } //<S2SV> } else { //<S2SV> ZVAL_STRINGL ( * current_field , ( char * ) p , len , copy_data ) ; //<S2SV> } //<S2SV> p += len ; //<S2SV> last_field_was_string = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> if ( copy_data == FALSE && last_field_was_string ) { //<S2SV> row_buffer -> ptr [ data_size ] = '\\0' ; //<S2SV> } //<S2SV> DBG_RETURN ( PASS ) ; //<S2SV> } //<S2SV> 