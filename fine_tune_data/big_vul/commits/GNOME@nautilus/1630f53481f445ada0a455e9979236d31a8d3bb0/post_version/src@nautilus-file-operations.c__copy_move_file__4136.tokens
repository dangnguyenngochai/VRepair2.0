static void //<S2SV> copy_move_file ( CopyMoveJob * copy_job , //<S2SV> GFile * src , //<S2SV> GFile * dest_dir , //<S2SV> gboolean same_fs , //<S2SV> gboolean unique_names , //<S2SV> char * * dest_fs_type , //<S2SV> SourceInfo * source_info , //<S2SV> TransferInfo * transfer_info , //<S2SV> GHashTable * debuting_files , //<S2SV> GdkPoint * position , //<S2SV> gboolean overwrite , //<S2SV> gboolean * skipped_file , //<S2SV> gboolean readonly_source_fs ) //<S2SV> { //<S2SV> GFile * dest , * new_dest ; //<S2SV> g_autofree gchar * dest_uri = NULL ; //<S2SV> GError * error ; //<S2SV> GFileCopyFlags flags ; //<S2SV> char * primary , * secondary , * details ; //<S2SV> int response ; //<S2SV> ProgressData pdata ; //<S2SV> gboolean would_recurse , is_merge ; //<S2SV> CommonJob * job ; //<S2SV> gboolean res ; //<S2SV> int unique_name_nr ; //<S2SV> gboolean handled_invalid_filename ; //<S2SV> job = ( CommonJob * ) copy_job ; //<S2SV> if ( should_skip_file ( job , src ) ) //<S2SV> { //<S2SV> * skipped_file = TRUE ; //<S2SV> return ; //<S2SV> } //<S2SV> unique_name_nr = 1 ; //<S2SV> handled_invalid_filename = * dest_fs_type != NULL ; //<S2SV> if ( unique_names ) //<S2SV> { //<S2SV> dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ; //<S2SV> } //<S2SV> else if ( copy_job -> target_name != NULL ) //<S2SV> { //<S2SV> dest = get_target_file_with_custom_name ( src , dest_dir , * dest_fs_type , same_fs , //<S2SV> copy_job -> target_name ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ; //<S2SV> } //<S2SV> if ( test_dir_is_parent ( dest_dir , src ) ) //<S2SV> { //<S2SV> if ( job -> skip_all_error ) //<S2SV> { //<S2SV> goto out ; //<S2SV> } //<S2SV> primary = copy_job -> is_move ? g_strdup ( _ ( "You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself." ) ) //<S2SV> : g_strdup ( _ ( "You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself." ) ) ; //<S2SV> secondary = g_strdup ( _ ( "The<S2SV_blank>destination<S2SV_blank>folder<S2SV_blank>is<S2SV_blank>inside<S2SV_blank>the<S2SV_blank>source<S2SV_blank>folder." ) ) ; //<S2SV> response = run_cancel_or_skip_warning ( job , //<S2SV> primary , //<S2SV> secondary , //<S2SV> NULL , //<S2SV> source_info -> num_files , //<S2SV> source_info -> num_files - transfer_info -> num_files ) ; //<S2SV> if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) //<S2SV> { //<S2SV> abort_job ( job ) ; //<S2SV> } //<S2SV> else if ( response == 1 ) //<S2SV> { //<S2SV> job -> skip_all_error = TRUE ; //<S2SV> } //<S2SV> else if ( response == 2 ) //<S2SV> { //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> g_assert_not_reached ( ) ; //<S2SV> } //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( test_dir_is_parent ( src , dest ) ) //<S2SV> { //<S2SV> if ( job -> skip_all_error ) //<S2SV> { //<S2SV> goto out ; //<S2SV> } //<S2SV> primary = copy_job -> is_move ? g_strdup ( _ ( "You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>file<S2SV_blank>over<S2SV_blank>itself." ) ) //<S2SV> : g_strdup ( _ ( "You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>file<S2SV_blank>over<S2SV_blank>itself." ) ) ; //<S2SV> secondary = g_strdup ( _ ( "The<S2SV_blank>source<S2SV_blank>file<S2SV_blank>would<S2SV_blank>be<S2SV_blank>overwritten<S2SV_blank>by<S2SV_blank>the<S2SV_blank>destination." ) ) ; //<S2SV> response = run_cancel_or_skip_warning ( job , //<S2SV> primary , //<S2SV> secondary , //<S2SV> NULL , //<S2SV> source_info -> num_files , //<S2SV> source_info -> num_files - transfer_info -> num_files ) ; //<S2SV> if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) //<S2SV> { //<S2SV> abort_job ( job ) ; //<S2SV> } //<S2SV> else if ( response == 1 ) //<S2SV> { //<S2SV> job -> skip_all_error = TRUE ; //<S2SV> } //<S2SV> else if ( response == 2 ) //<S2SV> { //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> g_assert_not_reached ( ) ; //<S2SV> } //<S2SV> goto out ; //<S2SV> } //<S2SV> retry : //<S2SV> error = NULL ; //<S2SV> flags = G_FILE_COPY_NOFOLLOW_SYMLINKS ; //<S2SV> if ( overwrite ) //<S2SV> { //<S2SV> flags |= G_FILE_COPY_OVERWRITE ; //<S2SV> } //<S2SV> if ( readonly_source_fs ) //<S2SV> { //<S2SV> flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS ; //<S2SV> } //<S2SV> pdata . job = copy_job ; //<S2SV> pdata . last_size = 0 ; //<S2SV> pdata . source_info = source_info ; //<S2SV> pdata . transfer_info = transfer_info ; //<S2SV> if ( copy_job -> is_move ) //<S2SV> { //<S2SV> res = g_file_move ( src , dest , //<S2SV> flags , //<S2SV> job -> cancellable , //<S2SV> copy_file_progress_callback , //<S2SV> & pdata , //<S2SV> & error ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> res = g_file_copy ( src , dest , //<S2SV> flags , //<S2SV> job -> cancellable , //<S2SV> copy_file_progress_callback , //<S2SV> & pdata , //<S2SV> & error ) ; //<S2SV> } //<S2SV> if ( res ) //<S2SV> { //<S2SV> GFile * real ; //<S2SV> real = map_possibly_volatile_file_to_real ( dest , job -> cancellable , & error ) ; //<S2SV> if ( real == NULL ) //<S2SV> { //<S2SV> res = FALSE ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> g_object_unref ( dest ) ; //<S2SV> dest = real ; //<S2SV> } //<S2SV> } //<S2SV> if ( res ) //<S2SV> { //<S2SV> transfer_info -> num_files ++ ; //<S2SV> report_copy_progress ( copy_job , source_info , transfer_info ) ; //<S2SV> if ( debuting_files ) //<S2SV> { //<S2SV> dest_uri = g_file_get_uri ( dest ) ; //<S2SV> if ( position ) //<S2SV> { //<S2SV> nautilus_file_changes_queue_schedule_position_set ( dest , * position , job -> screen_num ) ; //<S2SV> } //<S2SV> else if ( eel_uri_is_desktop ( dest_uri ) ) //<S2SV> { //<S2SV> nautilus_file_changes_queue_schedule_position_remove ( dest ) ; //<S2SV> } //<S2SV> g_hash_table_replace ( debuting_files , g_object_ref ( dest ) , GINT_TO_POINTER ( TRUE ) ) ; //<S2SV> } //<S2SV> if ( copy_job -> is_move ) //<S2SV> { //<S2SV> nautilus_file_changes_queue_file_moved ( src , dest ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> nautilus_file_changes_queue_file_added ( dest ) ; //<S2SV> } //<S2SV> if ( copy_job -> desktop_location != NULL && //<S2SV> g_file_equal ( copy_job -> desktop_location , dest_dir ) && //<S2SV> is_trusted_desktop_file ( src , job -> cancellable ) ) //<S2SV> { //<S2SV> mark_desktop_file_executable ( job , //<S2SV> job -> cancellable , //<S2SV> dest , //<S2SV> FALSE ) ; //<S2SV> } //<S2SV> if ( job -> undo_info != NULL ) //<S2SV> { //<S2SV> nautilus_file_undo_info_ext_add_origin_target_pair ( NAUTILUS_FILE_UNDO_INFO_EXT ( job -> undo_info ) , //<S2SV> src , dest ) ; //<S2SV> } //<S2SV> g_object_unref ( dest ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! handled_invalid_filename && //<S2SV> IS_IO_ERROR ( error , INVALID_FILENAME ) ) //<S2SV> { //<S2SV> handled_invalid_filename = TRUE ; //<S2SV> g_assert ( * dest_fs_type == NULL ) ; //<S2SV> * dest_fs_type = query_fs_type ( dest_dir , job -> cancellable ) ; //<S2SV> if ( unique_names ) //<S2SV> { //<S2SV> new_dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> new_dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ; //<S2SV> } //<S2SV> if ( ! g_file_equal ( dest , new_dest ) ) //<S2SV> { //<S2SV> g_object_unref ( dest ) ; //<S2SV> dest = new_dest ; //<S2SV> g_error_free ( error ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> g_object_unref ( new_dest ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! overwrite && //<S2SV> IS_IO_ERROR ( error , EXISTS ) ) //<S2SV> { //<S2SV> gboolean is_merge ; //<S2SV> FileConflictResponse * response ; //<S2SV> g_error_free ( error ) ; //<S2SV> if ( unique_names ) //<S2SV> { //<S2SV> g_object_unref ( dest ) ; //<S2SV> dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> is_merge = FALSE ; //<S2SV> if ( is_dir ( dest ) && is_dir ( src ) ) //<S2SV> { //<S2SV> is_merge = TRUE ; //<S2SV> } //<S2SV> if ( ( is_merge && job -> merge_all ) || //<S2SV> ( ! is_merge && job -> replace_all ) ) //<S2SV> { //<S2SV> overwrite = TRUE ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> if ( job -> skip_all_conflict ) //<S2SV> { //<S2SV> goto out ; //<S2SV> } //<S2SV> response = handle_copy_move_conflict ( job , src , dest , dest_dir ) ; //<S2SV> if ( response -> id == GTK_RESPONSE_CANCEL || //<S2SV> response -> id == GTK_RESPONSE_DELETE_EVENT ) //<S2SV> { //<S2SV> file_conflict_response_free ( response ) ; //<S2SV> abort_job ( job ) ; //<S2SV> } //<S2SV> else if ( response -> id == CONFLICT_RESPONSE_SKIP ) //<S2SV> { //<S2SV> if ( response -> apply_to_all ) //<S2SV> { //<S2SV> job -> skip_all_conflict = TRUE ; //<S2SV> } //<S2SV> file_conflict_response_free ( response ) ; //<S2SV> } //<S2SV> else if ( response -> id == CONFLICT_RESPONSE_REPLACE ) //<S2SV> { //<S2SV> if ( response -> apply_to_all ) //<S2SV> { //<S2SV> if ( is_merge ) //<S2SV> { //<S2SV> job -> merge_all = TRUE ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> job -> replace_all = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> overwrite = TRUE ; //<S2SV> file_conflict_response_free ( response ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> else if ( response -> id == CONFLICT_RESPONSE_RENAME ) //<S2SV> { //<S2SV> g_object_unref ( dest ) ; //<S2SV> dest = get_target_file_for_display_name ( dest_dir , //<S2SV> response -> new_name ) ; //<S2SV> file_conflict_response_free ( response ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> g_assert_not_reached ( ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( overwrite && //<S2SV> IS_IO_ERROR ( error , IS_DIRECTORY ) ) //<S2SV> { //<S2SV> gboolean existing_file_deleted ; //<S2SV> DeleteExistingFileData data ; //<S2SV> g_error_free ( error ) ; //<S2SV> data . job = job ; //<S2SV> data . source = src ; //<S2SV> existing_file_deleted = //<S2SV> delete_file_recursively ( dest , //<S2SV> job -> cancellable , //<S2SV> existing_file_removed_callback , //<S2SV> & data ) ; //<S2SV> if ( existing_file_deleted ) //<S2SV> { //<S2SV> goto retry ; //<S2SV> } //<S2SV> } //<S2SV> else if ( IS_IO_ERROR ( error , WOULD_RECURSE ) || //<S2SV> IS_IO_ERROR ( error , WOULD_MERGE ) ) //<S2SV> { //<S2SV> is_merge = error -> code == G_IO_ERROR_WOULD_MERGE ; //<S2SV> would_recurse = error -> code == G_IO_ERROR_WOULD_RECURSE ; //<S2SV> g_error_free ( error ) ; //<S2SV> if ( overwrite && would_recurse ) //<S2SV> { //<S2SV> error = NULL ; //<S2SV> if ( ! g_file_delete ( dest , job -> cancellable , & error ) && //<S2SV> ! IS_IO_ERROR ( error , NOT_FOUND ) ) //<S2SV> { //<S2SV> if ( job -> skip_all_error ) //<S2SV> { //<S2SV> g_error_free ( error ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( copy_job -> is_move ) //<S2SV> { //<S2SV> primary = f ( _ ( "Error<S2SV_blank>while<S2SV_blank>moving<S2SV_blank>“%B”." ) , src ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> primary = f ( _ ( "Error<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>“%B”." ) , src ) ; //<S2SV> } //<S2SV> secondary = f ( _ ( "Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>the<S2SV_blank>already<S2SV_blank>existing<S2SV_blank>file<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>name<S2SV_blank>in<S2SV_blank>%F." ) , dest_dir ) ; //<S2SV> details = error -> message ; //<S2SV> response = run_warning ( job , //<S2SV> primary , //<S2SV> secondary , //<S2SV> details , //<S2SV> TRUE , //<S2SV> CANCEL , SKIP_ALL , SKIP , //<S2SV> NULL ) ; //<S2SV> g_error_free ( error ) ; //<S2SV> if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) //<S2SV> { //<S2SV> abort_job ( job ) ; //<S2SV> } //<S2SV> else if ( response == 1 ) //<S2SV> { //<S2SV> job -> skip_all_error = TRUE ; //<S2SV> } //<S2SV> else if ( response == 2 ) //<S2SV> { //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> g_assert_not_reached ( ) ; //<S2SV> } //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( error ) //<S2SV> { //<S2SV> g_error_free ( error ) ; //<S2SV> error = NULL ; //<S2SV> } //<S2SV> nautilus_file_changes_queue_file_removed ( dest ) ; //<S2SV> } //<S2SV> if ( is_merge ) //<S2SV> { //<S2SV> same_fs = FALSE ; //<S2SV> } //<S2SV> if ( ! copy_move_directory ( copy_job , src , & dest , same_fs , //<S2SV> would_recurse , dest_fs_type , //<S2SV> source_info , transfer_info , //<S2SV> debuting_files , skipped_file , //<S2SV> readonly_source_fs ) ) //<S2SV> { //<S2SV> g_assert ( * dest_fs_type != NULL ) ; //<S2SV> handled_invalid_filename = TRUE ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> g_object_unref ( dest ) ; //<S2SV> return ; //<S2SV> } //<S2SV> else if ( IS_IO_ERROR ( error , CANCELLED ) ) //<S2SV> { //<S2SV> g_error_free ( error ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( job -> skip_all_error ) //<S2SV> { //<S2SV> g_error_free ( error ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> primary = f ( _ ( "Error<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>“%B”." ) , src ) ; //<S2SV> secondary = f ( _ ( "There<S2SV_blank>was<S2SV_blank>an<S2SV_blank>error<S2SV_blank>copying<S2SV_blank>the<S2SV_blank>file<S2SV_blank>into<S2SV_blank>%F." ) , dest_dir ) ; //<S2SV> details = error -> message ; //<S2SV> response = run_cancel_or_skip_warning ( job , //<S2SV> primary , //<S2SV> secondary , //<S2SV> details , //<S2SV> source_info -> num_files , //<S2SV> source_info -> num_files - transfer_info -> num_files ) ; //<S2SV> g_error_free ( error ) ; //<S2SV> if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) //<S2SV> { //<S2SV> abort_job ( job ) ; //<S2SV> } //<S2SV> else if ( response == 1 ) //<S2SV> { //<S2SV> job -> skip_all_error = TRUE ; //<S2SV> } //<S2SV> else if ( response == 2 ) //<S2SV> { //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> g_assert_not_reached ( ) ; //<S2SV> } //<S2SV> } //<S2SV> out : //<S2SV> * skipped_file = TRUE ; //<S2SV> g_object_unref ( dest ) ; //<S2SV> } //<S2SV> 