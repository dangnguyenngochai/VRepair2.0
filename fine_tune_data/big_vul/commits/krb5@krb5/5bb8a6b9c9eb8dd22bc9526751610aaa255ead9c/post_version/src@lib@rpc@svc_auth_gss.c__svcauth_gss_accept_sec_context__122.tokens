static bool_t //<S2SV> svcauth_gss_accept_sec_context ( struct svc_req * rqst , //<S2SV> struct rpc_gss_init_res * gr ) //<S2SV> { //<S2SV> struct svc_rpc_gss_data * gd ; //<S2SV> struct rpc_gss_cred * gc ; //<S2SV> gss_buffer_desc recv_tok , seqbuf ; //<S2SV> gss_OID mech ; //<S2SV> OM_uint32 maj_stat = 0 , min_stat = 0 , ret_flags , seq ; //<S2SV> log_debug ( "in<S2SV_blank>svcauth_gss_accept_context()" ) ; //<S2SV> gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; //<S2SV> gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; //<S2SV> memset ( gr , 0 , sizeof ( * gr ) ) ; //<S2SV> memset ( & recv_tok , 0 , sizeof ( recv_tok ) ) ; //<S2SV> if ( ! svc_getargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , //<S2SV> ( caddr_t ) & recv_tok ) ) //<S2SV> return ( FALSE ) ; //<S2SV> gr -> gr_major = gss_accept_sec_context ( & gr -> gr_minor , //<S2SV> & gd -> ctx , //<S2SV> svcauth_gss_creds , //<S2SV> & recv_tok , //<S2SV> GSS_C_NO_CHANNEL_BINDINGS , //<S2SV> & gd -> client_name , //<S2SV> & mech , //<S2SV> & gr -> gr_token , //<S2SV> & ret_flags , //<S2SV> NULL , //<S2SV> NULL ) ; //<S2SV> svc_freeargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ; //<S2SV> log_status ( "accept_sec_context" , gr -> gr_major , gr -> gr_minor ) ; //<S2SV> if ( gr -> gr_major != GSS_S_COMPLETE && //<S2SV> gr -> gr_major != GSS_S_CONTINUE_NEEDED ) { //<S2SV> badauth ( gr -> gr_major , gr -> gr_minor , rqst -> rq_xprt ) ; //<S2SV> gd -> ctx = GSS_C_NO_CONTEXT ; //<S2SV> goto errout ; //<S2SV> } //<S2SV> gr -> gr_ctx . value = "xxxx" ; //<S2SV> gr -> gr_ctx . length = 4 ; //<S2SV> gr -> gr_win = sizeof ( gd -> seqmask ) * 8 ; //<S2SV> gd -> sec . mech = mech ; //<S2SV> gd -> sec . qop = GSS_C_QOP_DEFAULT ; //<S2SV> gd -> sec . svc = gc -> gc_svc ; //<S2SV> gd -> seq = gc -> gc_seq ; //<S2SV> gd -> win = gr -> gr_win ; //<S2SV> if ( gr -> gr_major == GSS_S_COMPLETE ) { //<S2SV> # ifdef SPKM //<S2SV> if ( ! g_OID_equal ( gss_mech_spkm3 , mech ) ) { //<S2SV> # endif //<S2SV> maj_stat = gss_display_name ( & min_stat , gd -> client_name , //<S2SV> & gd -> cname , & gd -> sec . mech ) ; //<S2SV> # ifdef SPKM //<S2SV> } //<S2SV> # endif //<S2SV> if ( maj_stat != GSS_S_COMPLETE ) { //<S2SV> log_status ( "display_name" , maj_stat , min_stat ) ; //<S2SV> goto errout ; //<S2SV> } //<S2SV> # ifdef DEBUG //<S2SV> # ifdef HAVE_HEIMDAL //<S2SV> log_debug ( "accepted<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%.*s<S2SV_blank>with<S2SV_blank>" //<S2SV> "<mech<S2SV_blank>{},<S2SV_blank>qop<S2SV_blank>%d,<S2SV_blank>svc<S2SV_blank>%d>" , //<S2SV> gd -> cname . length , ( char * ) gd -> cname . value , //<S2SV> gd -> sec . qop , gd -> sec . svc ) ; //<S2SV> # else //<S2SV> { //<S2SV> gss_buffer_desc mechname ; //<S2SV> gss_oid_to_str ( & min_stat , mech , & mechname ) ; //<S2SV> log_debug ( "accepted<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%.*s<S2SV_blank>with<S2SV_blank>" //<S2SV> "<mech<S2SV_blank>%.*s,<S2SV_blank>qop<S2SV_blank>%d,<S2SV_blank>svc<S2SV_blank>%d>" , //<S2SV> gd -> cname . length , ( char * ) gd -> cname . value , //<S2SV> mechname . length , ( char * ) mechname . value , //<S2SV> gd -> sec . qop , gd -> sec . svc ) ; //<S2SV> gss_release_buffer ( & min_stat , & mechname ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # endif //<S2SV> seq = htonl ( gr -> gr_win ) ; //<S2SV> seqbuf . value = & seq ; //<S2SV> seqbuf . length = sizeof ( seq ) ; //<S2SV> gss_release_buffer ( & min_stat , & gd -> checksum ) ; //<S2SV> maj_stat = gss_sign ( & min_stat , gd -> ctx , GSS_C_QOP_DEFAULT , //<S2SV> & seqbuf , & gd -> checksum ) ; //<S2SV> if ( maj_stat != GSS_S_COMPLETE ) { //<S2SV> goto errout ; //<S2SV> } //<S2SV> rqst -> rq_xprt -> xp_verf . oa_flavor = RPCSEC_GSS ; //<S2SV> rqst -> rq_xprt -> xp_verf . oa_base = gd -> checksum . value ; //<S2SV> rqst -> rq_xprt -> xp_verf . oa_length = gd -> checksum . length ; //<S2SV> } //<S2SV> return ( TRUE ) ; //<S2SV> errout : //<S2SV> gss_release_buffer ( & min_stat , & gr -> gr_token ) ; //<S2SV> return ( FALSE ) ; //<S2SV> } //<S2SV> 