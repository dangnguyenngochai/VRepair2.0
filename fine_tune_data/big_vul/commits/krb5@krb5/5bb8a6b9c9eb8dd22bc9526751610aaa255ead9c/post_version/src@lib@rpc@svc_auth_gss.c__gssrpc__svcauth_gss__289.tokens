enum auth_stat //<S2SV> gssrpc__svcauth_gss ( struct svc_req * rqst , struct rpc_msg * msg , //<S2SV> bool_t * no_dispatch ) //<S2SV> { //<S2SV> enum auth_stat retstat ; //<S2SV> XDR xdrs ; //<S2SV> SVCAUTH * auth ; //<S2SV> struct svc_rpc_gss_data * gd ; //<S2SV> struct rpc_gss_cred * gc ; //<S2SV> struct rpc_gss_init_res gr ; //<S2SV> int call_stat , offset ; //<S2SV> OM_uint32 min_stat ; //<S2SV> log_debug ( "in<S2SV_blank>svcauth_gss()" ) ; //<S2SV> rqst -> rq_xprt -> xp_verf = gssrpc__null_auth ; //<S2SV> if ( rqst -> rq_xprt -> xp_auth == NULL || //<S2SV> rqst -> rq_xprt -> xp_auth == & svc_auth_none ) { //<S2SV> if ( ( auth = calloc ( sizeof ( * auth ) , 1 ) ) == NULL ) { //<S2SV> fprintf ( stderr , "svcauth_gss:<S2SV_blank>out_of_memory\\n" ) ; //<S2SV> return ( AUTH_FAILED ) ; //<S2SV> } //<S2SV> if ( ( gd = calloc ( sizeof ( * gd ) , 1 ) ) == NULL ) { //<S2SV> fprintf ( stderr , "svcauth_gss:<S2SV_blank>out_of_memory\\n" ) ; //<S2SV> return ( AUTH_FAILED ) ; //<S2SV> } //<S2SV> auth -> svc_ah_ops = & svc_auth_gss_ops ; //<S2SV> SVCAUTH_PRIVATE ( auth ) = gd ; //<S2SV> rqst -> rq_xprt -> xp_auth = auth ; //<S2SV> } //<S2SV> else gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; //<S2SV> log_debug ( "xp_auth=%p,<S2SV_blank>gd=%p" , rqst -> rq_xprt -> xp_auth , gd ) ; //<S2SV> if ( rqst -> rq_cred . oa_length <= 0 ) //<S2SV> return ( AUTH_BADCRED ) ; //<S2SV> gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; //<S2SV> memset ( gc , 0 , sizeof ( * gc ) ) ; //<S2SV> log_debug ( "calling<S2SV_blank>xdrmem_create()" ) ; //<S2SV> log_debug ( "oa_base=%p,<S2SV_blank>oa_length=%u" , rqst -> rq_cred . oa_base , //<S2SV> rqst -> rq_cred . oa_length ) ; //<S2SV> xdrmem_create ( & xdrs , rqst -> rq_cred . oa_base , //<S2SV> rqst -> rq_cred . oa_length , XDR_DECODE ) ; //<S2SV> log_debug ( "xdrmem_create()<S2SV_blank>returned" ) ; //<S2SV> if ( ! xdr_rpc_gss_cred ( & xdrs , gc ) ) { //<S2SV> log_debug ( "xdr_rpc_gss_cred()<S2SV_blank>failed" ) ; //<S2SV> XDR_DESTROY ( & xdrs ) ; //<S2SV> return ( AUTH_BADCRED ) ; //<S2SV> } //<S2SV> XDR_DESTROY ( & xdrs ) ; //<S2SV> retstat = AUTH_FAILED ; //<S2SV> # define ret_freegc ( code ) do { retstat = code ; goto freegc ; } while ( 0 ) //<S2SV> if ( gc -> gc_v != RPCSEC_GSS_VERSION ) //<S2SV> ret_freegc ( AUTH_BADCRED ) ; //<S2SV> if ( gc -> gc_svc != RPCSEC_GSS_SVC_NONE && //<S2SV> gc -> gc_svc != RPCSEC_GSS_SVC_INTEGRITY && //<S2SV> gc -> gc_svc != RPCSEC_GSS_SVC_PRIVACY ) //<S2SV> ret_freegc ( AUTH_BADCRED ) ; //<S2SV> if ( gd -> established ) { //<S2SV> if ( gc -> gc_seq > MAXSEQ ) //<S2SV> ret_freegc ( RPCSEC_GSS_CTXPROBLEM ) ; //<S2SV> if ( ( offset = gd -> seqlast - gc -> gc_seq ) < 0 ) { //<S2SV> gd -> seqlast = gc -> gc_seq ; //<S2SV> offset = 0 - offset ; //<S2SV> gd -> seqmask <<= offset ; //<S2SV> offset = 0 ; //<S2SV> } else if ( ( u_int ) offset >= gd -> win || //<S2SV> ( gd -> seqmask & ( 1 << offset ) ) ) { //<S2SV> * no_dispatch = 1 ; //<S2SV> ret_freegc ( RPCSEC_GSS_CTXPROBLEM ) ; //<S2SV> } //<S2SV> gd -> seq = gc -> gc_seq ; //<S2SV> gd -> seqmask |= ( 1 << offset ) ; //<S2SV> } //<S2SV> if ( gd -> established ) { //<S2SV> rqst -> rq_clntname = ( char * ) gd -> client_name ; //<S2SV> rqst -> rq_svccred = ( char * ) gd -> ctx ; //<S2SV> } //<S2SV> switch ( gc -> gc_proc ) { //<S2SV> case RPCSEC_GSS_INIT : //<S2SV> case RPCSEC_GSS_CONTINUE_INIT : //<S2SV> if ( rqst -> rq_proc != NULLPROC ) //<S2SV> ret_freegc ( AUTH_FAILED ) ; //<S2SV> if ( ! svcauth_gss_acquire_cred ( ) ) //<S2SV> ret_freegc ( AUTH_FAILED ) ; //<S2SV> if ( ! svcauth_gss_accept_sec_context ( rqst , & gr ) ) //<S2SV> ret_freegc ( AUTH_REJECTEDCRED ) ; //<S2SV> if ( ! svcauth_gss_nextverf ( rqst , htonl ( gr . gr_win ) ) ) { //<S2SV> gss_release_buffer ( & min_stat , & gr . gr_token ) ; //<S2SV> ret_freegc ( AUTH_FAILED ) ; //<S2SV> } //<S2SV> * no_dispatch = TRUE ; //<S2SV> call_stat = svc_sendreply ( rqst -> rq_xprt , xdr_rpc_gss_init_res , //<S2SV> ( caddr_t ) & gr ) ; //<S2SV> gss_release_buffer ( & min_stat , & gr . gr_token ) ; //<S2SV> gss_release_buffer ( & min_stat , & gd -> checksum ) ; //<S2SV> if ( ! call_stat ) //<S2SV> ret_freegc ( AUTH_FAILED ) ; //<S2SV> if ( gr . gr_major == GSS_S_COMPLETE ) //<S2SV> gd -> established = TRUE ; //<S2SV> break ; //<S2SV> case RPCSEC_GSS_DATA : //<S2SV> if ( ! svcauth_gss_validate ( rqst , gd , msg ) ) //<S2SV> ret_freegc ( RPCSEC_GSS_CREDPROBLEM ) ; //<S2SV> if ( ! svcauth_gss_nextverf ( rqst , htonl ( gc -> gc_seq ) ) ) //<S2SV> ret_freegc ( AUTH_FAILED ) ; //<S2SV> break ; //<S2SV> case RPCSEC_GSS_DESTROY : //<S2SV> if ( rqst -> rq_proc != NULLPROC ) //<S2SV> ret_freegc ( AUTH_FAILED ) ; //<S2SV> if ( ! svcauth_gss_validate ( rqst , gd , msg ) ) //<S2SV> ret_freegc ( RPCSEC_GSS_CREDPROBLEM ) ; //<S2SV> if ( ! svcauth_gss_nextverf ( rqst , htonl ( gc -> gc_seq ) ) ) //<S2SV> ret_freegc ( AUTH_FAILED ) ; //<S2SV> * no_dispatch = TRUE ; //<S2SV> call_stat = svc_sendreply ( rqst -> rq_xprt , //<S2SV> xdr_void , ( caddr_t ) NULL ) ; //<S2SV> log_debug ( "sendreply<S2SV_blank>in<S2SV_blank>destroy:<S2SV_blank>%d" , call_stat ) ; //<S2SV> if ( ! svcauth_gss_release_cred ( ) ) //<S2SV> ret_freegc ( AUTH_FAILED ) ; //<S2SV> SVCAUTH_DESTROY ( rqst -> rq_xprt -> xp_auth ) ; //<S2SV> rqst -> rq_xprt -> xp_auth = & svc_auth_none ; //<S2SV> break ; //<S2SV> default : //<S2SV> ret_freegc ( AUTH_REJECTEDCRED ) ; //<S2SV> break ; //<S2SV> } //<S2SV> retstat = AUTH_OK ; //<S2SV> freegc : //<S2SV> xdr_free ( xdr_rpc_gss_cred , gc ) ; //<S2SV> log_debug ( "returning<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>svcauth_gss()" , retstat ) ; //<S2SV> return ( retstat ) ; //<S2SV> } //<S2SV> 