static krb5_error_code //<S2SV> pkinit_server_return_padata ( krb5_context context , //<S2SV> krb5_pa_data * padata , //<S2SV> krb5_data * req_pkt , //<S2SV> krb5_kdc_req * request , //<S2SV> krb5_kdc_rep * reply , //<S2SV> krb5_keyblock * encrypting_key , //<S2SV> krb5_pa_data * * send_pa , //<S2SV> krb5_kdcpreauth_callbacks cb , //<S2SV> krb5_kdcpreauth_rock rock , //<S2SV> krb5_kdcpreauth_moddata moddata , //<S2SV> krb5_kdcpreauth_modreq modreq ) //<S2SV> { //<S2SV> krb5_error_code retval = 0 ; //<S2SV> krb5_data scratch = { 0 , 0 , NULL } ; //<S2SV> krb5_pa_pk_as_req * reqp = NULL ; //<S2SV> krb5_pa_pk_as_req_draft9 * reqp9 = NULL ; //<S2SV> int i = 0 ; //<S2SV> unsigned char * subjectPublicKey = NULL ; //<S2SV> unsigned char * dh_pubkey = NULL , * server_key = NULL ; //<S2SV> unsigned int subjectPublicKey_len = 0 ; //<S2SV> unsigned int server_key_len = 0 , dh_pubkey_len = 0 ; //<S2SV> krb5_kdc_dh_key_info dhkey_info ; //<S2SV> krb5_data * encoded_dhkey_info = NULL ; //<S2SV> krb5_pa_pk_as_rep * rep = NULL ; //<S2SV> krb5_pa_pk_as_rep_draft9 * rep9 = NULL ; //<S2SV> krb5_data * out_data = NULL ; //<S2SV> krb5_octet_data secret ; //<S2SV> krb5_enctype enctype = - 1 ; //<S2SV> krb5_reply_key_pack * key_pack = NULL ; //<S2SV> krb5_reply_key_pack_draft9 * key_pack9 = NULL ; //<S2SV> krb5_data * encoded_key_pack = NULL ; //<S2SV> pkinit_kdc_context plgctx ; //<S2SV> pkinit_kdc_req_context reqctx ; //<S2SV> int fixed_keypack = 0 ; //<S2SV> * send_pa = NULL ; //<S2SV> if ( padata -> pa_type == KRB5_PADATA_PKINIT_KX ) { //<S2SV> return return_pkinit_kx ( context , request , reply , //<S2SV> encrypting_key , send_pa ) ; //<S2SV> } //<S2SV> if ( padata -> length <= 0 || padata -> contents == NULL ) //<S2SV> return 0 ; //<S2SV> if ( modreq == NULL ) { //<S2SV> pkiDebug ( "missing<S2SV_blank>request<S2SV_blank>context<S2SV_blank>\\n" ) ; //<S2SV> return EINVAL ; //<S2SV> } //<S2SV> plgctx = pkinit_find_realm_context ( context , moddata , request -> server ) ; //<S2SV> if ( plgctx == NULL ) { //<S2SV> pkiDebug ( "Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>correct<S2SV_blank>realm<S2SV_blank>context\\n" ) ; //<S2SV> return ENOENT ; //<S2SV> } //<S2SV> pkiDebug ( "pkinit_return_padata:<S2SV_blank>entered!\\n" ) ; //<S2SV> reqctx = ( pkinit_kdc_req_context ) modreq ; //<S2SV> if ( encrypting_key -> contents ) { //<S2SV> free ( encrypting_key -> contents ) ; //<S2SV> encrypting_key -> length = 0 ; //<S2SV> encrypting_key -> contents = NULL ; //<S2SV> } //<S2SV> for ( i = 0 ; i < request -> nktypes ; i ++ ) { //<S2SV> enctype = request -> ktype [ i ] ; //<S2SV> if ( ! krb5_c_valid_enctype ( enctype ) ) //<S2SV> continue ; //<S2SV> else { //<S2SV> pkiDebug ( "KDC<S2SV_blank>picked<S2SV_blank>etype<S2SV_blank>=<S2SV_blank>%d\\n" , enctype ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( i == request -> nktypes ) { //<S2SV> retval = KRB5KDC_ERR_ETYPE_NOSUPP ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> switch ( ( int ) reqctx -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> init_krb5_pa_pk_as_rep ( & rep ) ; //<S2SV> if ( rep == NULL ) { //<S2SV> retval = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> rep -> choice = choice_pa_pk_as_rep_encKeyPack ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> init_krb5_pa_pk_as_rep_draft9 ( & rep9 ) ; //<S2SV> if ( rep9 == NULL ) { //<S2SV> retval = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> rep9 -> choice = choice_pa_pk_as_rep_draft9_encKeyPack ; //<S2SV> break ; //<S2SV> default : //<S2SV> retval = KRB5KDC_ERR_PREAUTH_FAILED ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( reqctx -> rcv_auth_pack != NULL && //<S2SV> reqctx -> rcv_auth_pack -> clientPublicValue != NULL ) { //<S2SV> subjectPublicKey = //<S2SV> reqctx -> rcv_auth_pack -> clientPublicValue -> subjectPublicKey . data ; //<S2SV> subjectPublicKey_len = //<S2SV> reqctx -> rcv_auth_pack -> clientPublicValue -> subjectPublicKey . length ; //<S2SV> rep -> choice = choice_pa_pk_as_rep_dhInfo ; //<S2SV> } else if ( reqctx -> rcv_auth_pack9 != NULL && //<S2SV> reqctx -> rcv_auth_pack9 -> clientPublicValue != NULL ) { //<S2SV> subjectPublicKey = //<S2SV> reqctx -> rcv_auth_pack9 -> clientPublicValue -> subjectPublicKey . data ; //<S2SV> subjectPublicKey_len = //<S2SV> reqctx -> rcv_auth_pack9 -> clientPublicValue -> subjectPublicKey . length ; //<S2SV> rep9 -> choice = choice_pa_pk_as_rep_draft9_dhSignedData ; //<S2SV> } //<S2SV> if ( rep != NULL && ( rep -> choice == choice_pa_pk_as_rep_dhInfo || //<S2SV> rep -> choice == choice_pa_pk_as_rep_draft9_dhSignedData ) ) { //<S2SV> pkiDebug ( "received<S2SV_blank>DH<S2SV_blank>key<S2SV_blank>delivery<S2SV_blank>AS<S2SV_blank>REQ\\n" ) ; //<S2SV> retval = server_process_dh ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , subjectPublicKey , //<S2SV> subjectPublicKey_len , & dh_pubkey , & dh_pubkey_len , //<S2SV> & server_key , & server_key_len ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>process/create<S2SV_blank>dh<S2SV_blank>paramters\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( rep9 != NULL && //<S2SV> rep9 -> choice == choice_pa_pk_as_rep_draft9_dhSignedData ) || //<S2SV> ( rep != NULL && rep -> choice == choice_pa_pk_as_rep_dhInfo ) ) { //<S2SV> dhkey_info . subjectPublicKey . length = dh_pubkey_len ; //<S2SV> dhkey_info . subjectPublicKey . data = dh_pubkey ; //<S2SV> dhkey_info . nonce = request -> nonce ; //<S2SV> dhkey_info . dhKeyExpiration = 0 ; //<S2SV> retval = k5int_encode_krb5_kdc_dh_key_info ( & dhkey_info , //<S2SV> & encoded_dhkey_info ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "encode_krb5_kdc_dh_key_info<S2SV_blank>failed\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> # ifdef DEBUG_ASN1 //<S2SV> print_buffer_bin ( ( unsigned char * ) encoded_dhkey_info -> data , //<S2SV> encoded_dhkey_info -> length , //<S2SV> "/tmp/kdc_dh_key_info" ) ; //<S2SV> # endif //<S2SV> switch ( ( int ) padata -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> retval = cms_signeddata_create ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_SERVER , 1 , //<S2SV> ( unsigned char * ) encoded_dhkey_info -> data , //<S2SV> encoded_dhkey_info -> length , //<S2SV> & rep -> u . dh_Info . dhSignedData . data , //<S2SV> & rep -> u . dh_Info . dhSignedData . length ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>pkcs7<S2SV_blank>signed<S2SV_blank>data\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> retval = cms_signeddata_create ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_DRAFT9 , 1 , //<S2SV> ( unsigned char * ) encoded_dhkey_info -> data , //<S2SV> encoded_dhkey_info -> length , //<S2SV> & rep9 -> u . dhSignedData . data , //<S2SV> & rep9 -> u . dhSignedData . length ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>pkcs7<S2SV_blank>signed<S2SV_blank>data\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } else { //<S2SV> pkiDebug ( "received<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>delivery<S2SV_blank>AS<S2SV_blank>REQ\\n" ) ; //<S2SV> retval = krb5_c_make_random_key ( context , enctype , encrypting_key ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "unable<S2SV_blank>to<S2SV_blank>make<S2SV_blank>a<S2SV_blank>session<S2SV_blank>key\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> for ( i = 0 ; request -> padata [ i ] != NULL ; i ++ ) { //<S2SV> pkiDebug ( "%s:<S2SV_blank>Checking<S2SV_blank>pa_type<S2SV_blank>0x%08x\\n" , //<S2SV> __FUNCTION__ , request -> padata [ i ] -> pa_type ) ; //<S2SV> if ( request -> padata [ i ] -> pa_type == 132 ) //<S2SV> fixed_keypack = 1 ; //<S2SV> } //<S2SV> pkiDebug ( "%s:<S2SV_blank>return<S2SV_blank>checksum<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>nonce<S2SV_blank>=<S2SV_blank>%d\\n" , //<S2SV> __FUNCTION__ , fixed_keypack ) ; //<S2SV> if ( ( int ) padata -> pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack ) { //<S2SV> init_krb5_reply_key_pack ( & key_pack ) ; //<S2SV> if ( key_pack == NULL ) { //<S2SV> retval = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> retval = krb5_c_make_checksum ( context , 0 , //<S2SV> encrypting_key , KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM , //<S2SV> req_pkt , & key_pack -> asChecksum ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "unable<S2SV_blank>to<S2SV_blank>calculate<S2SV_blank>AS<S2SV_blank>REQ<S2SV_blank>checksum\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> # ifdef DEBUG_CKSUM //<S2SV> pkiDebug ( "calculating<S2SV_blank>checksum<S2SV_blank>on<S2SV_blank>buf<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d\\n" , req_pkt -> length ) ; //<S2SV> print_buffer ( req_pkt -> data , req_pkt -> length ) ; //<S2SV> pkiDebug ( "checksum<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d\\n" , key_pack -> asChecksum . length ) ; //<S2SV> print_buffer ( key_pack -> asChecksum . contents , //<S2SV> key_pack -> asChecksum . length ) ; //<S2SV> pkiDebug ( "encrypting<S2SV_blank>key<S2SV_blank>(%d)\\n" , encrypting_key -> length ) ; //<S2SV> print_buffer ( encrypting_key -> contents , encrypting_key -> length ) ; //<S2SV> # endif //<S2SV> krb5_copy_keyblock_contents ( context , encrypting_key , //<S2SV> & key_pack -> replyKey ) ; //<S2SV> retval = k5int_encode_krb5_reply_key_pack ( key_pack , //<S2SV> & encoded_key_pack ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>reply_key_pack\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> switch ( ( int ) padata -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> rep -> choice = choice_pa_pk_as_rep_encKeyPack ; //<S2SV> retval = cms_envelopeddata_create ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , padata -> pa_type , 1 , //<S2SV> ( unsigned char * ) encoded_key_pack -> data , //<S2SV> encoded_key_pack -> length , //<S2SV> & rep -> u . encKeyPack . data , & rep -> u . encKeyPack . length ) ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> if ( ! fixed_keypack ) { //<S2SV> init_krb5_reply_key_pack_draft9 ( & key_pack9 ) ; //<S2SV> if ( key_pack9 == NULL ) { //<S2SV> retval = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> key_pack9 -> nonce = reqctx -> rcv_auth_pack9 -> pkAuthenticator . nonce ; //<S2SV> krb5_copy_keyblock_contents ( context , encrypting_key , //<S2SV> & key_pack9 -> replyKey ) ; //<S2SV> retval = k5int_encode_krb5_reply_key_pack_draft9 ( key_pack9 , //<S2SV> & encoded_key_pack ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>reply_key_pack\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> rep9 -> choice = choice_pa_pk_as_rep_draft9_encKeyPack ; //<S2SV> retval = cms_envelopeddata_create ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , padata -> pa_type , 1 , //<S2SV> ( unsigned char * ) encoded_key_pack -> data , //<S2SV> encoded_key_pack -> length , //<S2SV> & rep9 -> u . encKeyPack . data , & rep9 -> u . encKeyPack . length ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>pkcs7<S2SV_blank>enveloped<S2SV_blank>data:<S2SV_blank>%s\\n" , //<S2SV> error_message ( retval ) ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> # ifdef DEBUG_ASN1 //<S2SV> print_buffer_bin ( ( unsigned char * ) encoded_key_pack -> data , //<S2SV> encoded_key_pack -> length , //<S2SV> "/tmp/kdc_key_pack" ) ; //<S2SV> switch ( ( int ) padata -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> print_buffer_bin ( rep -> u . encKeyPack . data , //<S2SV> rep -> u . encKeyPack . length , //<S2SV> "/tmp/kdc_enc_key_pack" ) ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> print_buffer_bin ( rep9 -> u . encKeyPack . data , //<S2SV> rep9 -> u . encKeyPack . length , //<S2SV> "/tmp/kdc_enc_key_pack" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> if ( ( rep != NULL && rep -> choice == choice_pa_pk_as_rep_dhInfo ) && //<S2SV> ( ( reqctx -> rcv_auth_pack != NULL && //<S2SV> reqctx -> rcv_auth_pack -> supportedKDFs != NULL ) ) ) { //<S2SV> if ( reqctx -> rcv_auth_pack != NULL && //<S2SV> reqctx -> rcv_auth_pack -> supportedKDFs != NULL ) { //<S2SV> retval = pkinit_pick_kdf_alg ( context , reqctx -> rcv_auth_pack -> supportedKDFs , //<S2SV> & ( rep -> u . dh_Info . kdfID ) ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "pkinit_pick_kdf_alg<S2SV_blank>failed:<S2SV_blank>%s\\n" , //<S2SV> error_message ( retval ) ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> switch ( ( int ) padata -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> retval = k5int_encode_krb5_pa_pk_as_rep ( rep , & out_data ) ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> retval = k5int_encode_krb5_pa_pk_as_rep_draft9 ( rep9 , & out_data ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>AS_REP\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> # ifdef DEBUG_ASN1 //<S2SV> if ( out_data != NULL ) //<S2SV> print_buffer_bin ( ( unsigned char * ) out_data -> data , out_data -> length , //<S2SV> "/tmp/kdc_as_rep" ) ; //<S2SV> # endif //<S2SV> if ( ( rep9 != NULL && //<S2SV> rep9 -> choice == choice_pa_pk_as_rep_draft9_dhSignedData ) || //<S2SV> ( rep != NULL && rep -> choice == choice_pa_pk_as_rep_dhInfo ) ) { //<S2SV> if ( rep -> u . dh_Info . kdfID ) { //<S2SV> secret . data = server_key ; //<S2SV> secret . length = server_key_len ; //<S2SV> retval = pkinit_alg_agility_kdf ( context , & secret , //<S2SV> rep -> u . dh_Info . kdfID , //<S2SV> request -> client , request -> server , //<S2SV> enctype , //<S2SV> ( krb5_octet_data * ) req_pkt , //<S2SV> ( krb5_octet_data * ) out_data , //<S2SV> encrypting_key ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "pkinit_alg_agility_kdf<S2SV_blank>failed:<S2SV_blank>%s\\n" , //<S2SV> error_message ( retval ) ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } else { //<S2SV> retval = pkinit_octetstring2key ( context , enctype , server_key , //<S2SV> server_key_len , encrypting_key ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "pkinit_octetstring2key<S2SV_blank>failed:<S2SV_blank>%s\\n" , //<S2SV> error_message ( retval ) ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> * send_pa = malloc ( sizeof ( krb5_pa_data ) ) ; //<S2SV> if ( * send_pa == NULL ) { //<S2SV> retval = ENOMEM ; //<S2SV> free ( out_data -> data ) ; //<S2SV> free ( out_data ) ; //<S2SV> out_data = NULL ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> ( * send_pa ) -> magic = KV5M_PA_DATA ; //<S2SV> switch ( ( int ) padata -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> ( * send_pa ) -> pa_type = KRB5_PADATA_PK_AS_REP ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> ( * send_pa ) -> pa_type = KRB5_PADATA_PK_AS_REP_OLD ; //<S2SV> break ; //<S2SV> } //<S2SV> ( * send_pa ) -> length = out_data -> length ; //<S2SV> ( * send_pa ) -> contents = ( krb5_octet * ) out_data -> data ; //<S2SV> cleanup : //<S2SV> pkinit_fini_kdc_req_context ( context , reqctx ) ; //<S2SV> free ( scratch . data ) ; //<S2SV> free ( out_data ) ; //<S2SV> if ( encoded_dhkey_info != NULL ) //<S2SV> krb5_free_data ( context , encoded_dhkey_info ) ; //<S2SV> if ( encoded_key_pack != NULL ) //<S2SV> krb5_free_data ( context , encoded_key_pack ) ; //<S2SV> free ( dh_pubkey ) ; //<S2SV> free ( server_key ) ; //<S2SV> switch ( ( int ) padata -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> free_krb5_pa_pk_as_req ( & reqp ) ; //<S2SV> free_krb5_pa_pk_as_rep ( & rep ) ; //<S2SV> free_krb5_reply_key_pack ( & key_pack ) ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> free_krb5_pa_pk_as_req_draft9 ( & reqp9 ) ; //<S2SV> free_krb5_pa_pk_as_rep_draft9 ( & rep9 ) ; //<S2SV> if ( ! fixed_keypack ) //<S2SV> free_krb5_reply_key_pack_draft9 ( & key_pack9 ) ; //<S2SV> else //<S2SV> free_krb5_reply_key_pack ( & key_pack ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( retval ) //<S2SV> pkiDebug ( "pkinit_verify_padata<S2SV_blank>failure" ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 