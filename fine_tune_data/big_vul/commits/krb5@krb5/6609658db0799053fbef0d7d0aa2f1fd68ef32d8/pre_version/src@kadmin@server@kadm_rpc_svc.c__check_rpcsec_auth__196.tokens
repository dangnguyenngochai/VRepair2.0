static int //<S2SV> check_rpcsec_auth ( struct svc_req * rqstp ) //<S2SV> { //<S2SV> gss_ctx_id_t ctx ; //<S2SV> krb5_context kctx ; //<S2SV> OM_uint32 maj_stat , min_stat ; //<S2SV> gss_name_t name ; //<S2SV> krb5_principal princ ; //<S2SV> int ret , success ; //<S2SV> krb5_data * c1 , * c2 , * realm ; //<S2SV> gss_buffer_desc gss_str ; //<S2SV> kadm5_server_handle_t handle ; //<S2SV> size_t slen ; //<S2SV> char * sdots ; //<S2SV> success = 0 ; //<S2SV> handle = ( kadm5_server_handle_t ) global_server_handle ; //<S2SV> if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) //<S2SV> return 0 ; //<S2SV> ctx = rqstp -> rq_svccred ; //<S2SV> maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , //<S2SV> NULL , NULL , NULL , NULL , NULL ) ; //<S2SV> if ( maj_stat != GSS_S_COMPLETE ) { //<S2SV> krb5_klog_syslog ( LOG_ERR , _ ( "check_rpcsec_auth:<S2SV_blank>failed<S2SV_blank>" //<S2SV> "inquire_context,<S2SV_blank>stat=%u" ) , maj_stat ) ; //<S2SV> log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; //<S2SV> goto fail_name ; //<S2SV> } //<S2SV> kctx = handle -> context ; //<S2SV> ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; //<S2SV> if ( ret == 0 ) //<S2SV> goto fail_name ; //<S2SV> slen = gss_str . length ; //<S2SV> trunc_name ( & slen , & sdots ) ; //<S2SV> if ( krb5_princ_size ( kctx , princ ) != 2 ) //<S2SV> goto fail_princ ; //<S2SV> c1 = krb5_princ_component ( kctx , princ , 0 ) ; //<S2SV> c2 = krb5_princ_component ( kctx , princ , 1 ) ; //<S2SV> realm = krb5_princ_realm ( kctx , princ ) ; //<S2SV> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 //<S2SV> && strncmp ( "kadmin" , c1 -> data , c1 -> length ) == 0 ) { //<S2SV> if ( strncmp ( "history" , c2 -> data , c2 -> length ) == 0 ) //<S2SV> goto fail_princ ; //<S2SV> else //<S2SV> success = 1 ; //<S2SV> } //<S2SV> fail_princ : //<S2SV> if ( ! success ) { //<S2SV> krb5_klog_syslog ( LOG_ERR , _ ( "bad<S2SV_blank>service<S2SV_blank>principal<S2SV_blank>%.*s%s" ) , //<S2SV> ( int ) slen , ( char * ) gss_str . value , sdots ) ; //<S2SV> } //<S2SV> gss_release_buffer ( & min_stat , & gss_str ) ; //<S2SV> krb5_free_principal ( kctx , princ ) ; //<S2SV> fail_name : //<S2SV> gss_release_name ( & min_stat , & name ) ; //<S2SV> return success ; //<S2SV> } //<S2SV> 