static struct berval * * //<S2SV> krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , //<S2SV> krb5_kvno mkvno ) { //<S2SV> struct berval * * ret = NULL ; //<S2SV> int currkvno ; //<S2SV> int num_versions = 1 ; //<S2SV> int i , j , last ; //<S2SV> krb5_error_code err = 0 ; //<S2SV> krb5_key_data * key_data = NULL ; //<S2SV> if ( n_key_data < 0 ) //<S2SV> return NULL ; //<S2SV> key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; //<S2SV> if ( key_data == NULL ) //<S2SV> goto cleanup ; //<S2SV> memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; //<S2SV> for ( i = 0 ; i < n_key_data ; i ++ ) { //<S2SV> if ( key_data [ i ] . key_data_ver == 1 ) { //<S2SV> key_data [ i ] . key_data_ver = 2 ; //<S2SV> key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; //<S2SV> key_data [ i ] . key_data_length [ 1 ] = 0 ; //<S2SV> key_data [ i ] . key_data_contents [ 1 ] = NULL ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < n_key_data - 1 ; i ++ ) //<S2SV> if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) //<S2SV> num_versions ++ ; //<S2SV> ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; //<S2SV> if ( ret == NULL ) { //<S2SV> err = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { //<S2SV> krb5_data * code ; //<S2SV> if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { //<S2SV> ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ; //<S2SV> if ( ret [ j ] == NULL ) //<S2SV> goto cleanup ; //<S2SV> err = asn1_encode_sequence_of_keys ( key_data + last , //<S2SV> ( krb5_int16 ) i - last + 1 , //<S2SV> mkvno , & code ) ; //<S2SV> if ( err ) //<S2SV> goto cleanup ; //<S2SV> ret [ j ] -> bv_len = code -> length ; //<S2SV> ret [ j ] -> bv_val = code -> data ; //<S2SV> free ( code ) ; //<S2SV> j ++ ; //<S2SV> last = i + 1 ; //<S2SV> if ( i < n_key_data - 1 ) //<S2SV> currkvno = key_data [ i + 1 ] . key_data_kvno ; //<S2SV> } //<S2SV> } //<S2SV> ret [ num_versions ] = NULL ; //<S2SV> cleanup : //<S2SV> free ( key_data ) ; //<S2SV> if ( err != 0 ) { //<S2SV> if ( ret != NULL ) { //<S2SV> for ( i = 0 ; ret [ i ] != NULL ; i ++ ) //<S2SV> free ( ret [ i ] ) ; //<S2SV> free ( ret ) ; //<S2SV> ret = NULL ; //<S2SV> } //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 