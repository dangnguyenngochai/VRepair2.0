OM_uint32 //<S2SV> kg_seal_iov ( OM_uint32 * minor_status , //<S2SV> gss_ctx_id_t context_handle , //<S2SV> int conf_req_flag , //<S2SV> gss_qop_t qop_req , //<S2SV> int * conf_state , //<S2SV> gss_iov_buffer_desc * iov , //<S2SV> int iov_count , //<S2SV> int toktype ) //<S2SV> { //<S2SV> krb5_gss_ctx_id_rec * ctx ; //<S2SV> krb5_error_code code ; //<S2SV> krb5_context context ; //<S2SV> if ( qop_req != 0 ) { //<S2SV> * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; //<S2SV> return GSS_S_FAILURE ; //<S2SV> } //<S2SV> ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; //<S2SV> if ( ctx -> terminated || ! ctx -> established ) { //<S2SV> * minor_status = KG_CTX_INCOMPLETE ; //<S2SV> return GSS_S_NO_CONTEXT ; //<S2SV> } //<S2SV> if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { //<S2SV> conf_req_flag = FALSE ; //<S2SV> } //<S2SV> context = ctx -> k5_context ; //<S2SV> switch ( ctx -> proto ) { //<S2SV> case 0 : //<S2SV> code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , //<S2SV> conf_state , iov , iov_count , toktype ) ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , //<S2SV> conf_state , iov , iov_count , toktype ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> code = G_UNKNOWN_QOP ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( code != 0 ) { //<S2SV> * minor_status = code ; //<S2SV> save_error_info ( * minor_status , context ) ; //<S2SV> return GSS_S_FAILURE ; //<S2SV> } //<S2SV> * minor_status = 0 ; //<S2SV> return GSS_S_COMPLETE ; //<S2SV> } //<S2SV> 