kadm5_ret_t //<S2SV> kadm5_create_principal_3 ( void * server_handle , //<S2SV> kadm5_principal_ent_t entry , long mask , //<S2SV> int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , //<S2SV> char * password ) //<S2SV> { //<S2SV> krb5_db_entry * kdb ; //<S2SV> osa_princ_ent_rec adb ; //<S2SV> kadm5_policy_ent_rec polent ; //<S2SV> krb5_boolean have_polent = FALSE ; //<S2SV> krb5_timestamp now ; //<S2SV> krb5_tl_data * tl_data_tail ; //<S2SV> unsigned int ret ; //<S2SV> kadm5_server_handle_t handle = server_handle ; //<S2SV> krb5_keyblock * act_mkey ; //<S2SV> krb5_kvno act_kvno ; //<S2SV> int new_n_ks_tuple = 0 ; //<S2SV> krb5_key_salt_tuple * new_ks_tuple = NULL ; //<S2SV> CHECK_HANDLE ( server_handle ) ; //<S2SV> krb5_clear_error_message ( handle -> context ) ; //<S2SV> check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; //<S2SV> if ( entry == NULL ) //<S2SV> return EINVAL ; //<S2SV> if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || //<S2SV> ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || //<S2SV> ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || //<S2SV> ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || //<S2SV> ( mask & KADM5_FAIL_AUTH_COUNT ) ) //<S2SV> return KADM5_BAD_MASK ; //<S2SV> if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) //<S2SV> return KADM5_BAD_MASK ; //<S2SV> if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) //<S2SV> return KADM5_BAD_MASK ; //<S2SV> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) //<S2SV> return KADM5_BAD_MASK ; //<S2SV> if ( ( mask & ~ ALL_PRINC_MASK ) ) //<S2SV> return KADM5_BAD_MASK ; //<S2SV> if ( mask & KADM5_TL_DATA ) { //<S2SV> for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; //<S2SV> tl_data_tail = tl_data_tail -> tl_data_next ) { //<S2SV> if ( tl_data_tail -> tl_data_type < 256 ) //<S2SV> return KADM5_BAD_TL_TYPE ; //<S2SV> } //<S2SV> } //<S2SV> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; //<S2SV> switch ( ret ) { //<S2SV> case KADM5_UNK_PRINC : //<S2SV> break ; //<S2SV> case 0 : //<S2SV> kdb_free_entry ( handle , kdb , & adb ) ; //<S2SV> return KADM5_DUP ; //<S2SV> default : //<S2SV> return ret ; //<S2SV> } //<S2SV> kdb = calloc ( 1 , sizeof ( * kdb ) ) ; //<S2SV> if ( kdb == NULL ) //<S2SV> return ENOMEM ; //<S2SV> memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; //<S2SV> if ( ( mask & KADM5_POLICY ) ) { //<S2SV> ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( password ) { //<S2SV> ret = passwd_check ( handle , password , have_polent ? & polent : NULL , //<S2SV> entry -> principal ) ; //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) //<S2SV> goto cleanup ; //<S2SV> kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; //<S2SV> kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; //<S2SV> if ( ( mask & KADM5_ATTRIBUTES ) ) //<S2SV> kdb -> attributes = entry -> attributes ; //<S2SV> else //<S2SV> kdb -> attributes = handle -> params . flags ; //<S2SV> if ( ( mask & KADM5_MAX_LIFE ) ) //<S2SV> kdb -> max_life = entry -> max_life ; //<S2SV> else //<S2SV> kdb -> max_life = handle -> params . max_life ; //<S2SV> if ( mask & KADM5_MAX_RLIFE ) //<S2SV> kdb -> max_renewable_life = entry -> max_renewable_life ; //<S2SV> else //<S2SV> kdb -> max_renewable_life = handle -> params . max_rlife ; //<S2SV> if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) //<S2SV> kdb -> expiration = entry -> princ_expire_time ; //<S2SV> else //<S2SV> kdb -> expiration = handle -> params . expiration ; //<S2SV> kdb -> pw_expiration = 0 ; //<S2SV> if ( have_polent ) { //<S2SV> if ( polent . pw_max_life ) //<S2SV> kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; //<S2SV> else //<S2SV> kdb -> pw_expiration = 0 ; //<S2SV> } //<S2SV> if ( ( mask & KADM5_PW_EXPIRATION ) ) //<S2SV> kdb -> pw_expiration = entry -> pw_expiration ; //<S2SV> kdb -> last_success = 0 ; //<S2SV> kdb -> last_failed = 0 ; //<S2SV> kdb -> fail_auth_count = 0 ; //<S2SV> ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) //<S2SV> goto cleanup ; //<S2SV> if ( mask & KADM5_TL_DATA ) { //<S2SV> for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; //<S2SV> tl_data_tail = tl_data_tail -> tl_data_next ) //<S2SV> { //<S2SV> ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , //<S2SV> & new_n_ks_tuple , & new_ks_tuple ) ; //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> if ( mask & KADM5_KEY_DATA ) { //<S2SV> assert ( entry -> n_key_data == 0 ) ; //<S2SV> } else if ( password ) { //<S2SV> ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , //<S2SV> new_n_ks_tuple , password , //<S2SV> ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , //<S2SV> FALSE , kdb ) ; //<S2SV> } else { //<S2SV> ret = krb5_dbe_crk ( handle -> context , & master_keyblock , //<S2SV> new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; //<S2SV> } //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , //<S2SV> KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , //<S2SV> new_n_ks_tuple , new_ks_tuple , password ) ; //<S2SV> if ( ret ) //<S2SV> goto cleanup ; //<S2SV> adb . admin_history_kvno = INITIAL_HIST_KVNO ; //<S2SV> if ( mask & KADM5_POLICY ) { //<S2SV> adb . aux_attributes = KADM5_POLICY ; //<S2SV> adb . policy = entry -> policy ; //<S2SV> } //<S2SV> kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; //<S2SV> ret = kdb_put_entry ( handle , kdb , & adb ) ; //<S2SV> ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , //<S2SV> KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , //<S2SV> new_n_ks_tuple , new_ks_tuple , password ) ; //<S2SV> cleanup : //<S2SV> free ( new_ks_tuple ) ; //<S2SV> krb5_db_free_principal ( handle -> context , kdb ) ; //<S2SV> if ( have_polent ) //<S2SV> ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 