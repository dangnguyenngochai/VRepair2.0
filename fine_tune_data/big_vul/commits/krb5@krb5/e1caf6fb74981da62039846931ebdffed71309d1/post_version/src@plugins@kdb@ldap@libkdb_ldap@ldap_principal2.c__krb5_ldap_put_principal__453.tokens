krb5_error_code //<S2SV> krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , //<S2SV> char * * db_args ) //<S2SV> { //<S2SV> int l = 0 , kerberos_principal_object_type = 0 ; //<S2SV> unsigned int ntrees = 0 , tre = 0 ; //<S2SV> krb5_error_code st = 0 , tempst = 0 ; //<S2SV> LDAP * ld = NULL ; //<S2SV> LDAPMessage * result = NULL , * ent = NULL ; //<S2SV> char * * subtreelist = NULL ; //<S2SV> char * user = NULL , * subtree = NULL , * principal_dn = NULL ; //<S2SV> char * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; //<S2SV> char * filtuser = NULL ; //<S2SV> struct berval * * bersecretkey = NULL ; //<S2SV> LDAPMod * * mods = NULL ; //<S2SV> krb5_boolean create_standalone = FALSE ; //<S2SV> krb5_boolean establish_links = FALSE ; //<S2SV> char * standalone_principal_dn = NULL ; //<S2SV> krb5_tl_data * tl_data = NULL ; //<S2SV> krb5_key_data * * keys = NULL ; //<S2SV> kdb5_dal_handle * dal_handle = NULL ; //<S2SV> krb5_ldap_context * ldap_context = NULL ; //<S2SV> krb5_ldap_server_handle * ldap_server_handle = NULL ; //<S2SV> osa_princ_ent_rec princ_ent = { 0 } ; //<S2SV> xargs_t xargs = { 0 } ; //<S2SV> char * polname = NULL ; //<S2SV> OPERATION optype ; //<S2SV> krb5_boolean found_entry = FALSE ; //<S2SV> krb5_clear_error_message ( context ) ; //<S2SV> SETUP_CONTEXT ( ) ; //<S2SV> if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) //<S2SV> return EINVAL ; //<S2SV> GET_HANDLE ( ) ; //<S2SV> if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { //<S2SV> st = EINVAL ; //<S2SV> k5_setmsg ( context , st , //<S2SV> _ ( "Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm" ) ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || //<S2SV> ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) //<S2SV> goto cleanup ; //<S2SV> filtuser = ldap_filter_correct ( user ) ; //<S2SV> if ( filtuser == NULL ) { //<S2SV> st = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_PRINCIPAL ) //<S2SV> optype = ADD_PRINCIPAL ; //<S2SV> else //<S2SV> optype = MODIFY_PRINCIPAL ; //<S2SV> if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || //<S2SV> ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) //<S2SV> goto cleanup ; //<S2SV> if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> if ( entry -> mask & KADM5_LOAD ) { //<S2SV> unsigned int tree = 0 ; //<S2SV> int numlentries = 0 ; //<S2SV> char * filter = NULL ; //<S2SV> if ( asprintf ( & filter , FILTER "%s))" , filtuser ) < 0 ) { //<S2SV> filter = NULL ; //<S2SV> st = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> found_entry = FALSE ; //<S2SV> for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { //<S2SV> if ( principal_dn == NULL ) { //<S2SV> LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; //<S2SV> } else { //<S2SV> LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; //<S2SV> } //<S2SV> if ( st == LDAP_SUCCESS ) { //<S2SV> numlentries = ldap_count_entries ( ld , result ) ; //<S2SV> if ( numlentries > 1 ) { //<S2SV> free ( filter ) ; //<S2SV> st = EINVAL ; //<S2SV> k5_setmsg ( context , st , //<S2SV> _ ( "operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>" //<S2SV> "entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\"%s\\"<S2SV_blank>found" ) , //<S2SV> user ) ; //<S2SV> goto cleanup ; //<S2SV> } else if ( numlentries == 1 ) { //<S2SV> found_entry = TRUE ; //<S2SV> if ( principal_dn == NULL ) { //<S2SV> ent = ldap_first_entry ( ld , result ) ; //<S2SV> if ( ent != NULL ) { //<S2SV> if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { //<S2SV> ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; //<S2SV> st = set_ldap_error ( context , st , 0 ) ; //<S2SV> free ( filter ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else if ( st != LDAP_NO_SUCH_OBJECT ) { //<S2SV> st = set_ldap_error ( context , st , 0 ) ; //<S2SV> free ( filter ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> ldap_msgfree ( result ) ; //<S2SV> result = NULL ; //<S2SV> } //<S2SV> free ( filter ) ; //<S2SV> if ( found_entry == FALSE && principal_dn != NULL ) { //<S2SV> create_standalone = TRUE ; //<S2SV> standalone_principal_dn = strdup ( principal_dn ) ; //<S2SV> CHECK_NULL ( standalone_principal_dn ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( principal_dn == NULL && xargs . dn == NULL ) { //<S2SV> if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( "krbtgt" ) && //<S2SV> strncmp ( entry -> princ -> data [ 0 ] . data , "krbtgt" , entry -> princ -> data [ 0 ] . length ) == 0 ) { //<S2SV> subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; //<S2SV> } else if ( xargs . containerdn ) { //<S2SV> if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { //<S2SV> if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { //<S2SV> int ost = st ; //<S2SV> st = EINVAL ; //<S2SV> k5_wrapmsg ( context , ost , st , _ ( "\'%s\'<S2SV_blank>not<S2SV_blank>found" ) , //<S2SV> xargs . containerdn ) ; //<S2SV> } //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> subtree = strdup ( xargs . containerdn ) ; //<S2SV> } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { //<S2SV> subtree = strdup ( ldap_context -> lrparams -> containerref ) ; //<S2SV> } else { //<S2SV> subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; //<S2SV> } //<S2SV> CHECK_NULL ( subtree ) ; //<S2SV> if ( asprintf ( & standalone_principal_dn , "krbprincipalname=%s,%s" , //<S2SV> filtuser , subtree ) < 0 ) //<S2SV> standalone_principal_dn = NULL ; //<S2SV> CHECK_NULL ( standalone_principal_dn ) ; //<S2SV> create_standalone = TRUE ; //<S2SV> free ( subtree ) ; //<S2SV> subtree = NULL ; //<S2SV> } //<S2SV> if ( xargs . dn_from_kbd == TRUE ) { //<S2SV> if ( subtreelist == NULL ) { //<S2SV> st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; //<S2SV> if ( st ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> st = validate_xargs ( context , ldap_server_handle , & xargs , //<S2SV> standalone_principal_dn , subtreelist , ntrees ) ; //<S2SV> if ( st ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( xargs . linkdn != NULL ) { //<S2SV> if ( optype == MODIFY_PRINCIPAL && //<S2SV> kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { //<S2SV> st = EINVAL ; //<S2SV> snprintf ( errbuf , sizeof ( errbuf ) , //<S2SV> _ ( "link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>" //<S2SV> "kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object" ) ) ; //<S2SV> k5_setmsg ( context , st , "%s" , errbuf ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> { //<S2SV> char * * linkdns = NULL ; //<S2SV> int j = 0 ; //<S2SV> if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { //<S2SV> snprintf ( errbuf , sizeof ( errbuf ) , //<S2SV> _ ( "Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references" ) ) ; //<S2SV> k5_setmsg ( context , st , "%s" , errbuf ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( linkdns != NULL ) { //<S2SV> st = EINVAL ; //<S2SV> snprintf ( errbuf , sizeof ( errbuf ) , //<S2SV> _ ( "kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>" //<S2SV> "object" ) ) ; //<S2SV> k5_setmsg ( context , st , "%s" , errbuf ) ; //<S2SV> for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) //<S2SV> free ( linkdns [ j ] ) ; //<S2SV> free ( linkdns ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> establish_links = TRUE ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_LAST_SUCCESS ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) //<S2SV> goto cleanup ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastSuccessfulAuth" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_LAST_FAILED ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) //<S2SV> goto cleanup ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastFailedAuth" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { //<S2SV> krb5_kvno fail_auth_count ; //<S2SV> fail_auth_count = entry -> fail_auth_count ; //<S2SV> if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) //<S2SV> fail_auth_count ++ ; //<S2SV> st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , //<S2SV> LDAP_MOD_REPLACE , //<S2SV> fail_auth_count ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { //<S2SV> int attr_mask = 0 ; //<S2SV> krb5_boolean has_fail_count ; //<S2SV> st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; //<S2SV> # ifdef LDAP_MOD_INCREMENT //<S2SV> if ( ldap_server_handle -> server_info -> modify_increment && //<S2SV> has_fail_count ) { //<S2SV> st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , //<S2SV> LDAP_MOD_INCREMENT , 1 ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> } else { //<S2SV> # endif //<S2SV> if ( has_fail_count ) { //<S2SV> st = krb5_add_int_mem_ldap_mod ( & mods , //<S2SV> "krbLoginFailedCount" , //<S2SV> LDAP_MOD_DELETE , //<S2SV> entry -> fail_auth_count ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , //<S2SV> LDAP_MOD_ADD , //<S2SV> entry -> fail_auth_count + 1 ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> # ifdef LDAP_MOD_INCREMENT //<S2SV> } //<S2SV> # endif //<S2SV> } else if ( optype == ADD_PRINCIPAL ) { //<S2SV> st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , //<S2SV> LDAP_MOD_ADD , 0 ) ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_MAX_LIFE ) { //<S2SV> if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbmaxticketlife" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_MAX_RLIFE ) { //<S2SV> if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbmaxrenewableage" , LDAP_MOD_REPLACE , //<S2SV> entry -> max_renewable_life ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_ATTRIBUTES ) { //<S2SV> if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbticketflags" , LDAP_MOD_REPLACE , //<S2SV> entry -> attributes ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_PRINCIPAL ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> strval [ 0 ] = user ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbprincipalname" , LDAP_MOD_REPLACE , strval ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) //<S2SV> goto cleanup ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbprincipalexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_PW_EXPIRATION ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) //<S2SV> goto cleanup ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpasswordexpiration" , //<S2SV> LDAP_MOD_REPLACE , //<S2SV> strval ) ) != 0 ) { //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_POLICY || entry -> mask & KADM5_KEY_HIST ) { //<S2SV> memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; //<S2SV> for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { //<S2SV> if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { //<S2SV> if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_POLICY ) { //<S2SV> if ( princ_ent . aux_attributes & KADM5_POLICY ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> strval [ 0 ] = polname ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_REPLACE , strval ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } else { //<S2SV> st = EINVAL ; //<S2SV> k5_setmsg ( context , st , "Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_POLICY_CLR ) { //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_DELETE , NULL ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_KEY_HIST ) { //<S2SV> bersecretkey = krb5_encode_histkey ( & princ_ent ) ; //<S2SV> if ( bersecretkey == NULL ) { //<S2SV> st = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> st = krb5_add_ber_mem_ldap_mod ( & mods , "krbpwdhistory" , //<S2SV> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , //<S2SV> bersecretkey ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> free_berdata ( bersecretkey ) ; //<S2SV> bersecretkey = NULL ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { //<S2SV> krb5_kvno mkvno ; //<S2SV> if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , //<S2SV> entry -> n_key_data , mkvno ) ; //<S2SV> if ( bersecretkey == NULL ) { //<S2SV> st = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( bersecretkey [ 0 ] != NULL || ! create_standalone ) { //<S2SV> st = krb5_add_ber_mem_ldap_mod ( & mods , "krbprincipalkey" , //<S2SV> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , //<S2SV> bersecretkey ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) //<S2SV> goto cleanup ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , //<S2SV> "krbpasswordexpiration" , //<S2SV> LDAP_MOD_REPLACE , strval ) ) != 0 ) { //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> } //<S2SV> { //<S2SV> krb5_timestamp last_pw_changed ; //<S2SV> if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , //<S2SV> & last_pw_changed ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) //<S2SV> goto cleanup ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastPwdChange" , //<S2SV> LDAP_MOD_REPLACE , strval ) ) != 0 ) { //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> st = update_ldap_mod_auth_ind ( context , entry , & mods ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> if ( entry -> tl_data != NULL ) { //<S2SV> int count = 0 ; //<S2SV> struct berval * * ber_tl_data = NULL ; //<S2SV> krb5_tl_data * ptr ; //<S2SV> krb5_timestamp unlock_time ; //<S2SV> for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { //<S2SV> if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE //<S2SV> # ifdef SECURID //<S2SV> || ptr -> tl_data_type == KRB5_TL_DB_ARGS //<S2SV> # endif //<S2SV> || ptr -> tl_data_type == KRB5_TL_KADM_DATA //<S2SV> || ptr -> tl_data_type == KDB_TL_USER_INFO //<S2SV> || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL //<S2SV> || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) //<S2SV> continue ; //<S2SV> count ++ ; //<S2SV> } //<S2SV> if ( count != 0 ) { //<S2SV> int j ; //<S2SV> ber_tl_data = ( struct berval * * ) calloc ( count + 1 , //<S2SV> sizeof ( struct berval * ) ) ; //<S2SV> if ( ber_tl_data == NULL ) { //<S2SV> st = ENOMEM ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { //<S2SV> if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE //<S2SV> # ifdef SECURID //<S2SV> || ptr -> tl_data_type == KRB5_TL_DB_ARGS //<S2SV> # endif //<S2SV> || ptr -> tl_data_type == KRB5_TL_KADM_DATA //<S2SV> || ptr -> tl_data_type == KDB_TL_USER_INFO //<S2SV> || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL //<S2SV> || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) //<S2SV> continue ; //<S2SV> if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) //<S2SV> break ; //<S2SV> j ++ ; //<S2SV> } //<S2SV> if ( st == 0 ) { //<S2SV> ber_tl_data [ count ] = NULL ; //<S2SV> st = krb5_add_ber_mem_ldap_mod ( & mods , "krbExtraData" , //<S2SV> LDAP_MOD_REPLACE | //<S2SV> LDAP_MOD_BVALUES , ber_tl_data ) ; //<S2SV> } //<S2SV> free_berdata ( ber_tl_data ) ; //<S2SV> if ( st != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , //<S2SV> & unlock_time ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> if ( unlock_time != 0 ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) //<S2SV> goto cleanup ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastAdminUnlock" , //<S2SV> LDAP_MOD_REPLACE , strval ) ) != 0 ) { //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> free ( strval [ 0 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( xargs . tktpolicydn != NULL ) { //<S2SV> int tmask = 0 ; //<S2SV> if ( strlen ( xargs . tktpolicydn ) != 0 ) { //<S2SV> st = checkattributevalue ( ld , xargs . tktpolicydn , "objectclass" , policyclass , & tmask ) ; //<S2SV> CHECK_CLASS_VALIDITY ( st , tmask , _ ( "ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>" ) ) ; //<S2SV> strval [ 0 ] = xargs . tktpolicydn ; //<S2SV> strval [ 1 ] = NULL ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbticketpolicyreference" , LDAP_MOD_REPLACE , strval ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } else { //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbticketpolicyreference" , LDAP_MOD_DELETE , NULL ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> if ( establish_links == TRUE ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> strval [ 0 ] = xargs . linkdn ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbObjectReferences" , LDAP_MOD_REPLACE , strval ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( mods == NULL ) //<S2SV> goto cleanup ; //<S2SV> if ( create_standalone == TRUE ) { //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> strval [ 0 ] = "krbprincipal" ; //<S2SV> strval [ 1 ] = "krbprincipalaux" ; //<S2SV> strval [ 2 ] = "krbTicketPolicyAux" ; //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "objectclass" , LDAP_MOD_ADD , strval ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; //<S2SV> if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { //<S2SV> st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; //<S2SV> if ( st != LDAP_SUCCESS ) { //<S2SV> snprintf ( errbuf , sizeof ( errbuf ) , //<S2SV> _ ( "Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>" //<S2SV> "entry):<S2SV_blank>%s" ) , ldap_err2string ( st ) ) ; //<S2SV> st = translate_ldap_error ( st , OP_ADD ) ; //<S2SV> k5_setmsg ( context , st , "%s" , errbuf ) ; //<S2SV> goto cleanup ; //<S2SV> } else { //<S2SV> st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( st != LDAP_SUCCESS ) { //<S2SV> snprintf ( errbuf , sizeof ( errbuf ) , _ ( "Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s" ) , //<S2SV> ldap_err2string ( st ) ) ; //<S2SV> st = translate_ldap_error ( st , OP_ADD ) ; //<S2SV> k5_setmsg ( context , st , "%s" , errbuf ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } else { //<S2SV> { //<S2SV> char * attrvalues [ ] = { "krbprincipalaux" , "krbTicketPolicyAux" , NULL } ; //<S2SV> int p , q , r = 0 , amask = 0 ; //<S2SV> if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , //<S2SV> "objectclass" , attrvalues , & amask ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> memset ( strval , 0 , sizeof ( strval ) ) ; //<S2SV> for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { //<S2SV> if ( ( p & amask ) == 0 ) //<S2SV> strval [ r ++ ] = attrvalues [ q ] ; //<S2SV> } //<S2SV> if ( r != 0 ) { //<S2SV> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "objectclass" , LDAP_MOD_ADD , strval ) ) != 0 ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> if ( xargs . dn != NULL ) //<S2SV> st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; //<S2SV> else //<S2SV> st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; //<S2SV> if ( st != LDAP_SUCCESS ) { //<S2SV> snprintf ( errbuf , sizeof ( errbuf ) , _ ( "User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s" ) , //<S2SV> ldap_err2string ( st ) ) ; //<S2SV> st = translate_ldap_error ( st , OP_MOD ) ; //<S2SV> k5_setmsg ( context , st , "%s" , errbuf ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) //<S2SV> entry -> fail_auth_count ++ ; //<S2SV> } //<S2SV> cleanup : //<S2SV> if ( user ) //<S2SV> free ( user ) ; //<S2SV> if ( filtuser ) //<S2SV> free ( filtuser ) ; //<S2SV> free_xargs ( xargs ) ; //<S2SV> if ( standalone_principal_dn ) //<S2SV> free ( standalone_principal_dn ) ; //<S2SV> if ( principal_dn ) //<S2SV> free ( principal_dn ) ; //<S2SV> if ( polname != NULL ) //<S2SV> free ( polname ) ; //<S2SV> for ( tre = 0 ; tre < ntrees ; tre ++ ) //<S2SV> free ( subtreelist [ tre ] ) ; //<S2SV> free ( subtreelist ) ; //<S2SV> if ( subtree ) //<S2SV> free ( subtree ) ; //<S2SV> if ( bersecretkey ) { //<S2SV> for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { //<S2SV> if ( bersecretkey [ l ] -> bv_val ) //<S2SV> free ( bersecretkey [ l ] -> bv_val ) ; //<S2SV> free ( bersecretkey [ l ] ) ; //<S2SV> } //<S2SV> free ( bersecretkey ) ; //<S2SV> } //<S2SV> if ( keys ) //<S2SV> free ( keys ) ; //<S2SV> ldap_mods_free ( mods , 1 ) ; //<S2SV> ldap_osa_free_princ_ent ( & princ_ent ) ; //<S2SV> ldap_msgfree ( result ) ; //<S2SV> krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; //<S2SV> return ( st ) ; //<S2SV> } //<S2SV> 