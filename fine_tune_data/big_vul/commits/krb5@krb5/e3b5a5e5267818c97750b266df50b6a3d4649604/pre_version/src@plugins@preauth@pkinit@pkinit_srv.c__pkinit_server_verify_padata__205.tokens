static void //<S2SV> pkinit_server_verify_padata ( krb5_context context , //<S2SV> krb5_data * req_pkt , //<S2SV> krb5_kdc_req * request , //<S2SV> krb5_enc_tkt_part * enc_tkt_reply , //<S2SV> krb5_pa_data * data , //<S2SV> krb5_kdcpreauth_callbacks cb , //<S2SV> krb5_kdcpreauth_rock rock , //<S2SV> krb5_kdcpreauth_moddata moddata , //<S2SV> krb5_kdcpreauth_verify_respond_fn respond , //<S2SV> void * arg ) //<S2SV> { //<S2SV> krb5_error_code retval = 0 ; //<S2SV> krb5_data authp_data = { 0 , 0 , NULL } , krb5_authz = { 0 , 0 , NULL } ; //<S2SV> krb5_pa_pk_as_req * reqp = NULL ; //<S2SV> krb5_pa_pk_as_req_draft9 * reqp9 = NULL ; //<S2SV> krb5_auth_pack * auth_pack = NULL ; //<S2SV> krb5_auth_pack_draft9 * auth_pack9 = NULL ; //<S2SV> pkinit_kdc_context plgctx = NULL ; //<S2SV> pkinit_kdc_req_context reqctx = NULL ; //<S2SV> krb5_checksum cksum = { 0 , 0 , 0 , NULL } ; //<S2SV> krb5_data * der_req = NULL ; //<S2SV> int valid_eku = 0 , valid_san = 0 ; //<S2SV> krb5_data k5data ; //<S2SV> int is_signed = 1 ; //<S2SV> krb5_pa_data * * e_data = NULL ; //<S2SV> krb5_kdcpreauth_modreq modreq = NULL ; //<S2SV> pkiDebug ( "pkinit_verify_padata:<S2SV_blank>entered!\\n" ) ; //<S2SV> if ( data == NULL || data -> length <= 0 || data -> contents == NULL ) { //<S2SV> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( moddata == NULL ) { //<S2SV> ( * respond ) ( arg , EINVAL , NULL , NULL , NULL ) ; //<S2SV> return ; //<S2SV> } //<S2SV> plgctx = pkinit_find_realm_context ( context , moddata , request -> server ) ; //<S2SV> if ( plgctx == NULL ) { //<S2SV> ( * respond ) ( arg , 0 , NULL , NULL , NULL ) ; //<S2SV> return ; //<S2SV> } //<S2SV> # ifdef DEBUG_ASN1 //<S2SV> print_buffer_bin ( data -> contents , data -> length , "/tmp/kdc_as_req" ) ; //<S2SV> # endif //<S2SV> retval = pkinit_init_kdc_req_context ( context , & reqctx ) ; //<S2SV> if ( retval ) //<S2SV> goto cleanup ; //<S2SV> reqctx -> pa_type = data -> pa_type ; //<S2SV> PADATA_TO_KRB5DATA ( data , & k5data ) ; //<S2SV> switch ( ( int ) data -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> pkiDebug ( "processing<S2SV_blank>KRB5_PADATA_PK_AS_REQ\\n" ) ; //<S2SV> retval = k5int_decode_krb5_pa_pk_as_req ( & k5data , & reqp ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "decode_krb5_pa_pk_as_req<S2SV_blank>failed\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> # ifdef DEBUG_ASN1 //<S2SV> print_buffer_bin ( reqp -> signedAuthPack . data , //<S2SV> reqp -> signedAuthPack . length , //<S2SV> "/tmp/kdc_signed_data" ) ; //<S2SV> # endif //<S2SV> retval = cms_signeddata_verify ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_CLIENT , //<S2SV> plgctx -> opts -> require_crl_checking , //<S2SV> ( unsigned char * ) //<S2SV> reqp -> signedAuthPack . data , reqp -> signedAuthPack . length , //<S2SV> ( unsigned char * * ) & authp_data . data , //<S2SV> & authp_data . length , //<S2SV> ( unsigned char * * ) & krb5_authz . data , //<S2SV> & krb5_authz . length , & is_signed ) ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> pkiDebug ( "processing<S2SV_blank>KRB5_PADATA_PK_AS_REQ_OLD\\n" ) ; //<S2SV> retval = k5int_decode_krb5_pa_pk_as_req_draft9 ( & k5data , & reqp9 ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "decode_krb5_pa_pk_as_req_draft9<S2SV_blank>failed\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> # ifdef DEBUG_ASN1 //<S2SV> print_buffer_bin ( reqp9 -> signedAuthPack . data , //<S2SV> reqp9 -> signedAuthPack . length , //<S2SV> "/tmp/kdc_signed_data_draft9" ) ; //<S2SV> # endif //<S2SV> retval = cms_signeddata_verify ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , CMS_SIGN_DRAFT9 , //<S2SV> plgctx -> opts -> require_crl_checking , //<S2SV> ( unsigned char * ) //<S2SV> reqp9 -> signedAuthPack . data , reqp9 -> signedAuthPack . length , //<S2SV> ( unsigned char * * ) & authp_data . data , //<S2SV> & authp_data . length , //<S2SV> ( unsigned char * * ) & krb5_authz . data , //<S2SV> & krb5_authz . length , NULL ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> pkiDebug ( "unrecognized<S2SV_blank>pa_type<S2SV_blank>=<S2SV_blank>%d\\n" , data -> pa_type ) ; //<S2SV> retval = EINVAL ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "pkcs7_signeddata_verify<S2SV_blank>failed\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( is_signed ) { //<S2SV> retval = verify_client_san ( context , plgctx , reqctx , request -> client , //<S2SV> & valid_san ) ; //<S2SV> if ( retval ) //<S2SV> goto cleanup ; //<S2SV> if ( ! valid_san ) { //<S2SV> pkiDebug ( "%s:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>an<S2SV_blank>acceptable<S2SV_blank>SAN<S2SV_blank>in<S2SV_blank>user<S2SV_blank>" //<S2SV> "certificate\\n" , __FUNCTION__ ) ; //<S2SV> retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> retval = verify_client_eku ( context , plgctx , reqctx , & valid_eku ) ; //<S2SV> if ( retval ) //<S2SV> goto cleanup ; //<S2SV> if ( ! valid_eku ) { //<S2SV> pkiDebug ( "%s:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>an<S2SV_blank>acceptable<S2SV_blank>EKU<S2SV_blank>in<S2SV_blank>user<S2SV_blank>" //<S2SV> "certificate\\n" , __FUNCTION__ ) ; //<S2SV> retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( ! krb5_principal_compare ( context , request -> client , //<S2SV> krb5_anonymous_principal ( ) ) ) { //<S2SV> retval = KRB5KDC_ERR_PREAUTH_FAILED ; //<S2SV> krb5_set_error_message ( context , retval , //<S2SV> _ ( "Pkinit<S2SV_blank>request<S2SV_blank>not<S2SV_blank>signed,<S2SV_blank>but<S2SV_blank>client<S2SV_blank>" //<S2SV> "not<S2SV_blank>anonymous." ) ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> # ifdef DEBUG_ASN1 //<S2SV> print_buffer_bin ( authp_data . data , authp_data . length , "/tmp/kdc_auth_pack" ) ; //<S2SV> # endif //<S2SV> OCTETDATA_TO_KRB5DATA ( & authp_data , & k5data ) ; //<S2SV> switch ( ( int ) data -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> retval = k5int_decode_krb5_auth_pack ( & k5data , & auth_pack ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>krb5_auth_pack\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> retval = krb5_check_clockskew ( context , //<S2SV> auth_pack -> pkAuthenticator . ctime ) ; //<S2SV> if ( retval ) //<S2SV> goto cleanup ; //<S2SV> if ( auth_pack -> clientPublicValue != NULL ) { //<S2SV> retval = server_check_dh ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , //<S2SV> & auth_pack -> clientPublicValue -> algorithm . parameters , //<S2SV> plgctx -> opts -> dh_min_bits ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "bad<S2SV_blank>dh<S2SV_blank>parameters\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } else if ( ! is_signed ) { //<S2SV> retval = KRB5KDC_ERR_PREAUTH_FAILED ; //<S2SV> krb5_set_error_message ( context , retval , //<S2SV> _ ( "Anonymous<S2SV_blank>pkinit<S2SV_blank>without<S2SV_blank>DH<S2SV_blank>public<S2SV_blank>" //<S2SV> "value<S2SV_blank>not<S2SV_blank>supported." ) ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> der_req = cb -> request_body ( context , rock ) ; //<S2SV> retval = krb5_c_make_checksum ( context , CKSUMTYPE_NIST_SHA , NULL , //<S2SV> 0 , der_req , & cksum ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "unable<S2SV_blank>to<S2SV_blank>calculate<S2SV_blank>AS<S2SV_blank>REQ<S2SV_blank>checksum\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( cksum . length != auth_pack -> pkAuthenticator . paChecksum . length || //<S2SV> k5_bcmp ( cksum . contents , //<S2SV> auth_pack -> pkAuthenticator . paChecksum . contents , //<S2SV> cksum . length ) != 0 ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>match<S2SV_blank>the<S2SV_blank>checksum\\n" ) ; //<S2SV> # ifdef DEBUG_CKSUM //<S2SV> pkiDebug ( "calculating<S2SV_blank>checksum<S2SV_blank>on<S2SV_blank>buf<S2SV_blank>size<S2SV_blank>(%d)\\n" , //<S2SV> req_pkt -> length ) ; //<S2SV> print_buffer ( req_pkt -> data , req_pkt -> length ) ; //<S2SV> pkiDebug ( "received<S2SV_blank>checksum<S2SV_blank>type=%d<S2SV_blank>size=%d<S2SV_blank>" , //<S2SV> auth_pack -> pkAuthenticator . paChecksum . checksum_type , //<S2SV> auth_pack -> pkAuthenticator . paChecksum . length ) ; //<S2SV> print_buffer ( auth_pack -> pkAuthenticator . paChecksum . contents , //<S2SV> auth_pack -> pkAuthenticator . paChecksum . length ) ; //<S2SV> pkiDebug ( "expected<S2SV_blank>checksum<S2SV_blank>type=%d<S2SV_blank>size=%d<S2SV_blank>" , //<S2SV> cksum . checksum_type , cksum . length ) ; //<S2SV> print_buffer ( cksum . contents , cksum . length ) ; //<S2SV> # endif //<S2SV> retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( reqp -> kdcPkId . data != NULL ) { //<S2SV> int valid_kdcPkId = 0 ; //<S2SV> retval = pkinit_check_kdc_pkid ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , //<S2SV> ( unsigned char * ) reqp -> kdcPkId . data , //<S2SV> reqp -> kdcPkId . length , & valid_kdcPkId ) ; //<S2SV> if ( retval ) //<S2SV> goto cleanup ; //<S2SV> if ( ! valid_kdcPkId ) //<S2SV> pkiDebug ( "kdcPkId<S2SV_blank>in<S2SV_blank>AS_REQ<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>KDC\'s<S2SV_blank>cert" //<S2SV> "RFC<S2SV_blank>says<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>and<S2SV_blank>proceed\\n" ) ; //<S2SV> } //<S2SV> reqctx -> rcv_auth_pack = auth_pack ; //<S2SV> auth_pack = NULL ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> retval = k5int_decode_krb5_auth_pack_draft9 ( & k5data , & auth_pack9 ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>krb5_auth_pack_draft9\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( auth_pack9 -> clientPublicValue != NULL ) { //<S2SV> retval = server_check_dh ( context , plgctx -> cryptoctx , //<S2SV> reqctx -> cryptoctx , plgctx -> idctx , //<S2SV> & auth_pack9 -> clientPublicValue -> algorithm . parameters , //<S2SV> plgctx -> opts -> dh_min_bits ) ; //<S2SV> if ( retval ) { //<S2SV> pkiDebug ( "bad<S2SV_blank>dh<S2SV_blank>parameters\\n" ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> reqctx -> rcv_auth_pack9 = auth_pack9 ; //<S2SV> auth_pack9 = NULL ; //<S2SV> break ; //<S2SV> } //<S2SV> enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; //<S2SV> modreq = ( krb5_kdcpreauth_modreq ) reqctx ; //<S2SV> reqctx = NULL ; //<S2SV> cleanup : //<S2SV> if ( retval && data -> pa_type == KRB5_PADATA_PK_AS_REQ ) { //<S2SV> pkiDebug ( "pkinit_verify_padata<S2SV_blank>failed:<S2SV_blank>creating<S2SV_blank>e-data\\n" ) ; //<S2SV> if ( pkinit_create_edata ( context , plgctx -> cryptoctx , reqctx -> cryptoctx , //<S2SV> plgctx -> idctx , plgctx -> opts , retval , & e_data ) ) //<S2SV> pkiDebug ( "pkinit_create_edata<S2SV_blank>failed\\n" ) ; //<S2SV> } //<S2SV> switch ( ( int ) data -> pa_type ) { //<S2SV> case KRB5_PADATA_PK_AS_REQ : //<S2SV> free_krb5_pa_pk_as_req ( & reqp ) ; //<S2SV> free ( cksum . contents ) ; //<S2SV> break ; //<S2SV> case KRB5_PADATA_PK_AS_REP_OLD : //<S2SV> case KRB5_PADATA_PK_AS_REQ_OLD : //<S2SV> free_krb5_pa_pk_as_req_draft9 ( & reqp9 ) ; //<S2SV> } //<S2SV> free ( authp_data . data ) ; //<S2SV> free ( krb5_authz . data ) ; //<S2SV> if ( reqctx != NULL ) //<S2SV> pkinit_fini_kdc_req_context ( context , reqctx ) ; //<S2SV> free_krb5_auth_pack ( & auth_pack ) ; //<S2SV> free_krb5_auth_pack_draft9 ( context , & auth_pack9 ) ; //<S2SV> ( * respond ) ( arg , retval , modreq , e_data , NULL ) ; //<S2SV> } //<S2SV> 