static krb5_error_code //<S2SV> process_chpw_request ( krb5_context context , void * server_handle , char * realm , //<S2SV> krb5_keytab keytab , const krb5_fulladdr * local_faddr , //<S2SV> const krb5_fulladdr * remote_faddr , krb5_data * req , //<S2SV> krb5_data * rep ) //<S2SV> { //<S2SV> krb5_error_code ret ; //<S2SV> char * ptr ; //<S2SV> unsigned int plen , vno ; //<S2SV> krb5_data ap_req , ap_rep = empty_data ( ) ; //<S2SV> krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ; //<S2SV> krb5_auth_context auth_context = NULL ; //<S2SV> krb5_principal changepw = NULL ; //<S2SV> krb5_principal client , target = NULL ; //<S2SV> krb5_ticket * ticket = NULL ; //<S2SV> krb5_replay_data replay ; //<S2SV> krb5_error krberror ; //<S2SV> int numresult ; //<S2SV> char strresult [ 1024 ] ; //<S2SV> char * clientstr = NULL , * targetstr = NULL ; //<S2SV> const char * errmsg = NULL ; //<S2SV> size_t clen ; //<S2SV> char * cdots ; //<S2SV> struct sockaddr_storage ss ; //<S2SV> socklen_t salen ; //<S2SV> char addrbuf [ 100 ] ; //<S2SV> krb5_address * addr = remote_faddr -> address ; //<S2SV> * rep = empty_data ( ) ; //<S2SV> if ( req -> length < 4 ) { //<S2SV> ret = KRB5KRB_AP_ERR_MODIFIED ; //<S2SV> numresult = KRB5_KPASSWD_MALFORMED ; //<S2SV> strlcpy ( strresult , "Request<S2SV_blank>was<S2SV_blank>truncated" , sizeof ( strresult ) ) ; //<S2SV> goto bailout ; //<S2SV> } //<S2SV> ptr = req -> data ; //<S2SV> plen = ( * ptr ++ & 0xff ) ; //<S2SV> plen = ( plen << 8 ) | ( * ptr ++ & 0xff ) ; //<S2SV> if ( plen != req -> length ) { //<S2SV> ret = KRB5KRB_AP_ERR_MODIFIED ; //<S2SV> numresult = KRB5_KPASSWD_MALFORMED ; //<S2SV> strlcpy ( strresult , "Request<S2SV_blank>length<S2SV_blank>was<S2SV_blank>inconsistent" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto bailout ; //<S2SV> } //<S2SV> vno = ( * ptr ++ & 0xff ) ; //<S2SV> vno = ( vno << 8 ) | ( * ptr ++ & 0xff ) ; //<S2SV> if ( vno != 1 && vno != RFC3244_VERSION ) { //<S2SV> ret = KRB5KDC_ERR_BAD_PVNO ; //<S2SV> numresult = KRB5_KPASSWD_BAD_VERSION ; //<S2SV> snprintf ( strresult , sizeof ( strresult ) , //<S2SV> "Request<S2SV_blank>contained<S2SV_blank>unknown<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>number<S2SV_blank>%d" , vno ) ; //<S2SV> goto bailout ; //<S2SV> } //<S2SV> ap_req . length = ( * ptr ++ & 0xff ) ; //<S2SV> ap_req . length = ( ap_req . length << 8 ) | ( * ptr ++ & 0xff ) ; //<S2SV> if ( ptr + ap_req . length >= req -> data + req -> length ) { //<S2SV> ret = KRB5KRB_AP_ERR_MODIFIED ; //<S2SV> numresult = KRB5_KPASSWD_MALFORMED ; //<S2SV> strlcpy ( strresult , "Request<S2SV_blank>was<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>AP-REQ" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto bailout ; //<S2SV> } //<S2SV> ap_req . data = ptr ; //<S2SV> ptr += ap_req . length ; //<S2SV> ret = krb5_auth_con_init ( context , & auth_context ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>initializing<S2SV_blank>auth<S2SV_blank>context" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> ret = krb5_auth_con_setflags ( context , auth_context , //<S2SV> KRB5_AUTH_CONTEXT_DO_SEQUENCE ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>initializing<S2SV_blank>auth<S2SV_blank>context" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , //<S2SV> "kadmin" , "changepw" , NULL ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>building<S2SV_blank>kadmin/changepw<S2SV_blank>principal" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> ret = krb5_rd_req ( context , & auth_context , & ap_req , changepw , keytab , //<S2SV> NULL , & ticket ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_AUTHERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>reading<S2SV_blank>application<S2SV_blank>request" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> ret = krb5_mk_rep ( context , auth_context , & ap_rep ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_AUTHERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>replying<S2SV_blank>to<S2SV_blank>application<S2SV_blank>request" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> cipher . length = ( req -> data + req -> length ) - ptr ; //<S2SV> cipher . data = ptr ; //<S2SV> ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>decrypting<S2SV_blank>request" , sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> client = ticket -> enc_part2 -> client ; //<S2SV> if ( vno == RFC3244_VERSION ) { //<S2SV> krb5_data * clear_data ; //<S2SV> ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ; //<S2SV> if ( ret != 0 ) { //<S2SV> numresult = KRB5_KPASSWD_MALFORMED ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>decoding<S2SV_blank>ChangePasswdData" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> zapfree ( clear . data , clear . length ) ; //<S2SV> clear = * clear_data ; //<S2SV> free ( clear_data ) ; //<S2SV> if ( target != NULL ) { //<S2SV> ret = krb5_unparse_name ( context , target , & targetstr ) ; //<S2SV> if ( ret != 0 ) { //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>unparsing<S2SV_blank>target<S2SV_blank>name<S2SV_blank>for<S2SV_blank>log" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ret = krb5_unparse_name ( context , client , & clientstr ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>unparsing<S2SV_blank>client<S2SV_blank>name<S2SV_blank>for<S2SV_blank>log" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> if ( vno == 1 && //<S2SV> ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) { //<S2SV> numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED ; //<S2SV> strlcpy ( strresult , "Ticket<S2SV_blank>must<S2SV_blank>be<S2SV_blank>derived<S2SV_blank>from<S2SV_blank>a<S2SV_blank>password" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> goto chpwfail ; //<S2SV> } //<S2SV> ptr = k5memdup0 ( clear . data , clear . length , & ret ) ; //<S2SV> ret = schpw_util_wrapper ( server_handle , client , target , //<S2SV> ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , //<S2SV> ptr , NULL , strresult , sizeof ( strresult ) ) ; //<S2SV> if ( ret ) //<S2SV> errmsg = krb5_get_error_message ( context , ret ) ; //<S2SV> zapfree ( clear . data , clear . length ) ; //<S2SV> zapfree ( ptr , clear . length ) ; //<S2SV> clear = empty_data ( ) ; //<S2SV> clen = strlen ( clientstr ) ; //<S2SV> trunc_name ( & clen , & cdots ) ; //<S2SV> switch ( addr -> addrtype ) { //<S2SV> case ADDRTYPE_INET : { //<S2SV> struct sockaddr_in * sin = ss2sin ( & ss ) ; //<S2SV> sin -> sin_family = AF_INET ; //<S2SV> memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ; //<S2SV> sin -> sin_port = htons ( remote_faddr -> port ) ; //<S2SV> salen = sizeof ( * sin ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case ADDRTYPE_INET6 : { //<S2SV> struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ; //<S2SV> sin6 -> sin6_family = AF_INET6 ; //<S2SV> memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ; //<S2SV> sin6 -> sin6_port = htons ( remote_faddr -> port ) ; //<S2SV> salen = sizeof ( * sin6 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> default : { //<S2SV> struct sockaddr * sa = ss2sa ( & ss ) ; //<S2SV> sa -> sa_family = AF_UNSPEC ; //<S2SV> salen = sizeof ( * sa ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( getnameinfo ( ss2sa ( & ss ) , salen , //<S2SV> addrbuf , sizeof ( addrbuf ) , NULL , 0 , //<S2SV> NI_NUMERICHOST | NI_NUMERICSERV ) != 0 ) //<S2SV> strlcpy ( addrbuf , "<unprintable>" , sizeof ( addrbuf ) ) ; //<S2SV> if ( vno == RFC3244_VERSION ) { //<S2SV> size_t tlen ; //<S2SV> char * tdots ; //<S2SV> const char * targetp ; //<S2SV> if ( target == NULL ) { //<S2SV> tlen = clen ; //<S2SV> tdots = cdots ; //<S2SV> targetp = targetstr ; //<S2SV> } else { //<S2SV> tlen = strlen ( targetstr ) ; //<S2SV> trunc_name ( & tlen , & tdots ) ; //<S2SV> targetp = clientstr ; //<S2SV> } //<S2SV> krb5_klog_syslog ( LOG_NOTICE , _ ( "setpw<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>by<S2SV_blank>%.*s%s<S2SV_blank>for<S2SV_blank>" //<S2SV> "%.*s%s:<S2SV_blank>%s" ) , addrbuf , ( int ) clen , //<S2SV> clientstr , cdots , ( int ) tlen , targetp , tdots , //<S2SV> errmsg ? errmsg : "success" ) ; //<S2SV> } else { //<S2SV> krb5_klog_syslog ( LOG_NOTICE , _ ( "chpw<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%.*s%s:<S2SV_blank>%s" ) , //<S2SV> addrbuf , ( int ) clen , clientstr , cdots , //<S2SV> errmsg ? errmsg : "success" ) ; //<S2SV> } //<S2SV> switch ( ret ) { //<S2SV> case KADM5_AUTH_CHANGEPW : //<S2SV> numresult = KRB5_KPASSWD_ACCESSDENIED ; //<S2SV> break ; //<S2SV> case KADM5_PASS_Q_TOOSHORT : //<S2SV> case KADM5_PASS_REUSE : //<S2SV> case KADM5_PASS_Q_CLASS : //<S2SV> case KADM5_PASS_Q_DICT : //<S2SV> case KADM5_PASS_Q_GENERIC : //<S2SV> case KADM5_PASS_TOOSOON : //<S2SV> numresult = KRB5_KPASSWD_SOFTERROR ; //<S2SV> break ; //<S2SV> case 0 : //<S2SV> numresult = KRB5_KPASSWD_SUCCESS ; //<S2SV> strlcpy ( strresult , "" , sizeof ( strresult ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> break ; //<S2SV> } //<S2SV> chpwfail : //<S2SV> clear . length = 2 + strlen ( strresult ) ; //<S2SV> clear . data = ( char * ) malloc ( clear . length ) ; //<S2SV> ptr = clear . data ; //<S2SV> * ptr ++ = ( numresult >> 8 ) & 0xff ; //<S2SV> * ptr ++ = numresult & 0xff ; //<S2SV> memcpy ( ptr , strresult , strlen ( strresult ) ) ; //<S2SV> cipher = empty_data ( ) ; //<S2SV> if ( ap_rep . length ) { //<S2SV> ret = krb5_auth_con_setaddrs ( context , auth_context , //<S2SV> local_faddr -> address , NULL ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> strlcpy ( strresult , //<S2SV> "Failed<S2SV_blank>storing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>internet<S2SV_blank>addresses" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> } else { //<S2SV> ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , //<S2SV> & replay ) ; //<S2SV> if ( ret ) { //<S2SV> numresult = KRB5_KPASSWD_HARDERROR ; //<S2SV> strlcpy ( strresult , "Failed<S2SV_blank>encrypting<S2SV_blank>reply" , //<S2SV> sizeof ( strresult ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( cipher . length == 0 ) { //<S2SV> if ( ap_rep . length ) { //<S2SV> free ( ap_rep . data ) ; //<S2SV> ap_rep = empty_data ( ) ; //<S2SV> } //<S2SV> krberror . ctime = 0 ; //<S2SV> krberror . cusec = 0 ; //<S2SV> krberror . susec = 0 ; //<S2SV> ret = krb5_timeofday ( context , & krberror . stime ) ; //<S2SV> if ( ret ) //<S2SV> goto bailout ; //<S2SV> krberror . error = ret ; //<S2SV> krberror . error -= ERROR_TABLE_BASE_krb5 ; //<S2SV> if ( krberror . error < 0 || krberror . error > 128 ) //<S2SV> krberror . error = KRB_ERR_GENERIC ; //<S2SV> krberror . client = NULL ; //<S2SV> ret = krb5_build_principal ( context , & krberror . server , //<S2SV> strlen ( realm ) , realm , //<S2SV> "kadmin" , "changepw" , NULL ) ; //<S2SV> if ( ret ) //<S2SV> goto bailout ; //<S2SV> krberror . text . length = 0 ; //<S2SV> krberror . e_data = clear ; //<S2SV> ret = krb5_mk_error ( context , & krberror , & cipher ) ; //<S2SV> krb5_free_principal ( context , krberror . server ) ; //<S2SV> if ( ret ) //<S2SV> goto bailout ; //<S2SV> } //<S2SV> ret = alloc_data ( rep , 6 + ap_rep . length + cipher . length ) ; //<S2SV> if ( ret ) //<S2SV> goto bailout ; //<S2SV> ptr = rep -> data ; //<S2SV> * ptr ++ = ( rep -> length >> 8 ) & 0xff ; //<S2SV> * ptr ++ = rep -> length & 0xff ; //<S2SV> * ptr ++ = 0 ; //<S2SV> * ptr ++ = 1 ; //<S2SV> * ptr ++ = ( ap_rep . length >> 8 ) & 0xff ; //<S2SV> * ptr ++ = ap_rep . length & 0xff ; //<S2SV> if ( ap_rep . length ) { //<S2SV> memcpy ( ptr , ap_rep . data , ap_rep . length ) ; //<S2SV> ptr += ap_rep . length ; //<S2SV> } //<S2SV> memcpy ( ptr , cipher . data , cipher . length ) ; //<S2SV> bailout : //<S2SV> krb5_auth_con_free ( context , auth_context ) ; //<S2SV> krb5_free_principal ( context , changepw ) ; //<S2SV> krb5_free_ticket ( context , ticket ) ; //<S2SV> free ( ap_rep . data ) ; //<S2SV> free ( clear . data ) ; //<S2SV> free ( cipher . data ) ; //<S2SV> krb5_free_principal ( context , target ) ; //<S2SV> krb5_free_unparsed_name ( context , targetstr ) ; //<S2SV> krb5_free_unparsed_name ( context , clientstr ) ; //<S2SV> krb5_free_error_message ( context , errmsg ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 