int //<S2SV> validate_as_request ( kdc_realm_t * kdc_active_realm , //<S2SV> register krb5_kdc_req * request , krb5_db_entry client , //<S2SV> krb5_db_entry server , krb5_timestamp kdc_time , //<S2SV> const char * * status , krb5_pa_data * * * e_data ) //<S2SV> { //<S2SV> int errcode ; //<S2SV> krb5_error_code ret ; //<S2SV> if ( request -> kdc_options & AS_INVALID_OPTIONS ) { //<S2SV> * status = "INVALID<S2SV_blank>AS<S2SV_blank>OPTIONS" ; //<S2SV> return KDC_ERR_BADOPTION ; //<S2SV> } //<S2SV> if ( client . expiration && client . expiration < kdc_time ) { //<S2SV> * status = "CLIENT<S2SV_blank>EXPIRED" ; //<S2SV> if ( vague_errors ) //<S2SV> return ( KRB_ERR_GENERIC ) ; //<S2SV> else //<S2SV> return ( KDC_ERR_NAME_EXP ) ; //<S2SV> } //<S2SV> if ( client . pw_expiration && client . pw_expiration < kdc_time && //<S2SV> ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { //<S2SV> * status = "CLIENT<S2SV_blank>KEY<S2SV_blank>EXPIRED" ; //<S2SV> if ( vague_errors ) //<S2SV> return ( KRB_ERR_GENERIC ) ; //<S2SV> else //<S2SV> return ( KDC_ERR_KEY_EXP ) ; //<S2SV> } //<S2SV> if ( server . expiration && server . expiration < kdc_time ) { //<S2SV> * status = "SERVICE<S2SV_blank>EXPIRED" ; //<S2SV> return ( KDC_ERR_SERVICE_EXP ) ; //<S2SV> } //<S2SV> if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && //<S2SV> ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { //<S2SV> * status = "REQUIRED<S2SV_blank>PWCHANGE" ; //<S2SV> return ( KDC_ERR_KEY_EXP ) ; //<S2SV> } //<S2SV> if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || //<S2SV> isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && //<S2SV> ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || //<S2SV> isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { //<S2SV> * status = "POSTDATE<S2SV_blank>NOT<S2SV_blank>ALLOWED" ; //<S2SV> return ( KDC_ERR_CANNOT_POSTDATE ) ; //<S2SV> } //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE ) && //<S2SV> ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) || //<S2SV> isflagset ( server . attributes , KRB5_KDB_DISALLOW_PROXIABLE ) ) ) { //<S2SV> * status = "PROXIABLE<S2SV_blank>NOT<S2SV_blank>ALLOWED" ; //<S2SV> return ( KDC_ERR_POLICY ) ; //<S2SV> } //<S2SV> if ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { //<S2SV> * status = "CLIENT<S2SV_blank>LOCKED<S2SV_blank>OUT" ; //<S2SV> return ( KDC_ERR_CLIENT_REVOKED ) ; //<S2SV> } //<S2SV> if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_ALL_TIX ) ) { //<S2SV> * status = "SERVICE<S2SV_blank>LOCKED<S2SV_blank>OUT" ; //<S2SV> return ( KDC_ERR_S_PRINCIPAL_UNKNOWN ) ; //<S2SV> } //<S2SV> if ( isflagset ( server . attributes , KRB5_KDB_DISALLOW_SVR ) ) { //<S2SV> * status = "SERVICE<S2SV_blank>NOT<S2SV_blank>ALLOWED" ; //<S2SV> return ( KDC_ERR_MUST_USE_USER2USER ) ; //<S2SV> } //<S2SV> if ( check_anon ( kdc_active_realm , request -> client , request -> server ) != 0 ) { //<S2SV> * status = "ANONYMOUS<S2SV_blank>NOT<S2SV_blank>ALLOWED" ; //<S2SV> return ( KDC_ERR_POLICY ) ; //<S2SV> } //<S2SV> ret = krb5_db_check_policy_as ( kdc_context , request , & client , & server , //<S2SV> kdc_time , status , e_data ) ; //<S2SV> if ( ret && ret != KRB5_PLUGIN_OP_NOTSUPP ) //<S2SV> return errcode_to_protocol ( ret ) ; //<S2SV> errcode = against_local_policy_as ( request , client , server , //<S2SV> kdc_time , status , e_data ) ; //<S2SV> if ( errcode ) //<S2SV> return errcode ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 