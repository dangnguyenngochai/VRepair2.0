static OM_uint32 //<S2SV> init_ctx_reselect ( OM_uint32 * minor_status , spnego_gss_ctx_id_t sc , //<S2SV> OM_uint32 acc_negState , gss_OID supportedMech , //<S2SV> gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , //<S2SV> OM_uint32 * negState , send_token_flag * tokflag ) //<S2SV> { //<S2SV> OM_uint32 tmpmin ; //<S2SV> size_t i ; //<S2SV> gss_delete_sec_context ( & tmpmin , & sc -> ctx_handle , //<S2SV> GSS_C_NO_BUFFER ) ; //<S2SV> for ( i = 0 ; i < sc -> mech_set -> count ; i ++ ) { //<S2SV> if ( g_OID_equal ( supportedMech , & sc -> mech_set -> elements [ i ] ) ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( i == sc -> mech_set -> count ) //<S2SV> return GSS_S_DEFECTIVE_TOKEN ; //<S2SV> sc -> internal_mech = & sc -> mech_set -> elements [ i ] ; //<S2SV> if ( acc_negState != REQUEST_MIC ) //<S2SV> return GSS_S_DEFECTIVE_TOKEN ; //<S2SV> sc -> mech_complete = 0 ; //<S2SV> sc -> mic_reqd = 1 ; //<S2SV> * negState = REQUEST_MIC ; //<S2SV> * tokflag = CONT_TOKEN_SEND ; //<S2SV> return GSS_S_CONTINUE_NEEDED ; //<S2SV> } //<S2SV> 