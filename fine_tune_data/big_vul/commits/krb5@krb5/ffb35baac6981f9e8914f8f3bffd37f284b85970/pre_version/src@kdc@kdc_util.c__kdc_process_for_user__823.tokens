static krb5_error_code //<S2SV> kdc_process_for_user ( kdc_realm_t * kdc_active_realm , //<S2SV> krb5_pa_data * pa_data , //<S2SV> krb5_keyblock * tgs_session , //<S2SV> krb5_pa_s4u_x509_user * * s4u_x509_user , //<S2SV> const char * * status ) //<S2SV> { //<S2SV> krb5_error_code code ; //<S2SV> krb5_pa_for_user * for_user ; //<S2SV> krb5_data req_data ; //<S2SV> req_data . length = pa_data -> length ; //<S2SV> req_data . data = ( char * ) pa_data -> contents ; //<S2SV> code = decode_krb5_pa_for_user ( & req_data , & for_user ) ; //<S2SV> if ( code ) //<S2SV> return code ; //<S2SV> code = verify_for_user_checksum ( kdc_context , tgs_session , for_user ) ; //<S2SV> if ( code ) { //<S2SV> * status = "INVALID_S4U2SELF_CHECKSUM" ; //<S2SV> krb5_free_pa_for_user ( kdc_context , for_user ) ; //<S2SV> return code ; //<S2SV> } //<S2SV> * s4u_x509_user = calloc ( 1 , sizeof ( krb5_pa_s4u_x509_user ) ) ; //<S2SV> if ( * s4u_x509_user == NULL ) { //<S2SV> krb5_free_pa_for_user ( kdc_context , for_user ) ; //<S2SV> return ENOMEM ; //<S2SV> } //<S2SV> ( * s4u_x509_user ) -> user_id . user = for_user -> user ; //<S2SV> for_user -> user = NULL ; //<S2SV> krb5_free_pa_for_user ( kdc_context , for_user ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 