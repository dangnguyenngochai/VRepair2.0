krb5_error_code //<S2SV> process_tgs_req ( struct server_handle * handle , krb5_data * pkt , //<S2SV> const krb5_fulladdr * from , krb5_data * * response ) //<S2SV> { //<S2SV> krb5_keyblock * subkey = 0 ; //<S2SV> krb5_keyblock * header_key = NULL ; //<S2SV> krb5_kdc_req * request = 0 ; //<S2SV> krb5_db_entry * server = NULL ; //<S2SV> krb5_db_entry * stkt_server = NULL ; //<S2SV> krb5_kdc_rep reply ; //<S2SV> krb5_enc_kdc_rep_part reply_encpart ; //<S2SV> krb5_ticket ticket_reply , * header_ticket = 0 ; //<S2SV> int st_idx = 0 ; //<S2SV> krb5_enc_tkt_part enc_tkt_reply ; //<S2SV> int newtransited = 0 ; //<S2SV> krb5_error_code retval = 0 ; //<S2SV> krb5_keyblock encrypting_key ; //<S2SV> krb5_timestamp kdc_time , authtime = 0 ; //<S2SV> krb5_keyblock session_key ; //<S2SV> krb5_keyblock * reply_key = NULL ; //<S2SV> krb5_key_data * server_key ; //<S2SV> krb5_principal cprinc = NULL , sprinc = NULL , altcprinc = NULL ; //<S2SV> krb5_last_req_entry * nolrarray [ 2 ] , nolrentry ; //<S2SV> int errcode ; //<S2SV> const char * status = 0 ; //<S2SV> krb5_enc_tkt_part * header_enc_tkt = NULL ; //<S2SV> krb5_enc_tkt_part * subject_tkt = NULL ; //<S2SV> krb5_db_entry * client = NULL , * header_server = NULL ; //<S2SV> krb5_db_entry * local_tgt , * local_tgt_storage = NULL ; //<S2SV> krb5_pa_s4u_x509_user * s4u_x509_user = NULL ; //<S2SV> krb5_authdata * * kdc_issued_auth_data = NULL ; //<S2SV> unsigned int c_flags = 0 , s_flags = 0 ; //<S2SV> krb5_boolean is_referral ; //<S2SV> const char * emsg = NULL ; //<S2SV> krb5_kvno ticket_kvno = 0 ; //<S2SV> struct kdc_request_state * state = NULL ; //<S2SV> krb5_pa_data * pa_tgs_req ; //<S2SV> krb5_data scratch ; //<S2SV> krb5_pa_data * * e_data = NULL ; //<S2SV> kdc_realm_t * kdc_active_realm = NULL ; //<S2SV> krb5_audit_state * au_state = NULL ; //<S2SV> krb5_data * * auth_indicators = NULL ; //<S2SV> memset ( & reply , 0 , sizeof ( reply ) ) ; //<S2SV> memset ( & reply_encpart , 0 , sizeof ( reply_encpart ) ) ; //<S2SV> memset ( & ticket_reply , 0 , sizeof ( ticket_reply ) ) ; //<S2SV> memset ( & enc_tkt_reply , 0 , sizeof ( enc_tkt_reply ) ) ; //<S2SV> session_key . contents = NULL ; //<S2SV> retval = decode_krb5_tgs_req ( pkt , & request ) ; //<S2SV> if ( retval ) //<S2SV> return retval ; //<S2SV> sprinc = request -> server ; //<S2SV> if ( request -> msg_type != KRB5_TGS_REQ ) { //<S2SV> krb5_free_kdc_req ( handle -> kdc_err_context , request ) ; //<S2SV> return KRB5_BADMSGTYPE ; //<S2SV> } //<S2SV> kdc_active_realm = setup_server_realm ( handle , request -> server ) ; //<S2SV> if ( kdc_active_realm == NULL ) { //<S2SV> krb5_free_kdc_req ( handle -> kdc_err_context , request ) ; //<S2SV> return KRB5KDC_ERR_WRONG_REALM ; //<S2SV> } //<S2SV> errcode = kdc_make_rstate ( kdc_active_realm , & state ) ; //<S2SV> if ( errcode != 0 ) { //<S2SV> krb5_free_kdc_req ( handle -> kdc_err_context , request ) ; //<S2SV> return errcode ; //<S2SV> } //<S2SV> errcode = kau_init_kdc_req ( kdc_context , request , from , & au_state ) ; //<S2SV> if ( errcode ) { //<S2SV> krb5_free_kdc_req ( handle -> kdc_err_context , request ) ; //<S2SV> return errcode ; //<S2SV> } //<S2SV> kau_tgs_req ( kdc_context , TRUE , au_state ) ; //<S2SV> errcode = kdc_process_tgs_req ( kdc_active_realm , //<S2SV> request , from , pkt , & header_ticket , //<S2SV> & header_server , & header_key , & subkey , //<S2SV> & pa_tgs_req ) ; //<S2SV> if ( header_ticket && header_ticket -> enc_part2 ) //<S2SV> cprinc = header_ticket -> enc_part2 -> client ; //<S2SV> if ( errcode ) { //<S2SV> status = "PROCESS_TGS" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ! header_ticket ) { //<S2SV> errcode = KRB5_NO_TKT_SUPPLIED ; //<S2SV> status = "UNEXPECTED<S2SV_blank>NULL<S2SV_blank>in<S2SV_blank>header_ticket" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> errcode = kau_make_tkt_id ( kdc_context , header_ticket , //<S2SV> & au_state -> tkt_in_id ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "GENERATE_TICKET_ID" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> scratch . length = pa_tgs_req -> length ; //<S2SV> scratch . data = ( char * ) pa_tgs_req -> contents ; //<S2SV> errcode = kdc_find_fast ( & request , & scratch , subkey , //<S2SV> header_ticket -> enc_part2 -> session , state , NULL ) ; //<S2SV> sprinc = request -> server ; //<S2SV> if ( errcode != 0 ) { //<S2SV> status = "FIND_FAST" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> errcode = get_local_tgt ( kdc_context , & sprinc -> realm , header_server , //<S2SV> & local_tgt , & local_tgt_storage ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "GET_LOCAL_TGT" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> au_state -> request = request ; //<S2SV> header_enc_tkt = header_ticket -> enc_part2 ; //<S2SV> au_state -> stage = SRVC_PRINC ; //<S2SV> setflag ( s_flags , KRB5_KDB_FLAG_ALIAS_OK ) ; //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_CANONICALIZE ) ) { //<S2SV> setflag ( c_flags , KRB5_KDB_FLAG_CANONICALIZE ) ; //<S2SV> setflag ( s_flags , KRB5_KDB_FLAG_CANONICALIZE ) ; //<S2SV> } //<S2SV> errcode = search_sprinc ( kdc_active_realm , request , s_flags , & server , //<S2SV> & status ) ; //<S2SV> if ( errcode != 0 ) //<S2SV> goto cleanup ; //<S2SV> sprinc = server -> princ ; //<S2SV> is_referral = is_cross_tgs_principal ( server -> princ ) && //<S2SV> ! krb5_principal_compare ( kdc_context , request -> server , server -> princ ) ; //<S2SV> au_state -> stage = VALIDATE_POL ; //<S2SV> if ( ( errcode = krb5_timeofday ( kdc_context , & kdc_time ) ) ) { //<S2SV> status = "TIME_OF_DAY" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ( retval = validate_tgs_request ( kdc_active_realm , //<S2SV> request , * server , header_ticket , //<S2SV> kdc_time , & status , & e_data ) ) ) { //<S2SV> if ( ! status ) //<S2SV> status = "UNKNOWN_REASON" ; //<S2SV> if ( retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION ) //<S2SV> au_state -> violation = PROT_CONSTRAINT ; //<S2SV> errcode = retval + ERROR_TABLE_BASE_krb5 ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ! is_local_principal ( kdc_active_realm , header_enc_tkt -> client ) ) //<S2SV> setflag ( c_flags , KRB5_KDB_FLAG_CROSS_REALM ) ; //<S2SV> errcode = kdc_process_s4u2self_req ( kdc_active_realm , //<S2SV> request , //<S2SV> header_enc_tkt -> client , //<S2SV> server , //<S2SV> subkey , //<S2SV> header_enc_tkt -> session , //<S2SV> kdc_time , //<S2SV> & s4u_x509_user , //<S2SV> & client , //<S2SV> & status ) ; //<S2SV> if ( s4u_x509_user != NULL || errcode != 0 ) { //<S2SV> if ( s4u_x509_user != NULL ) //<S2SV> au_state -> s4u2self_user = s4u_x509_user -> user_id . user ; //<S2SV> if ( errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION ) //<S2SV> au_state -> violation = PROT_CONSTRAINT ; //<S2SV> au_state -> status = status ; //<S2SV> kau_s4u2self ( kdc_context , errcode ? FALSE : TRUE , au_state ) ; //<S2SV> au_state -> s4u2self_user = NULL ; //<S2SV> } //<S2SV> if ( errcode ) //<S2SV> goto cleanup ; //<S2SV> if ( s4u_x509_user != NULL ) { //<S2SV> setflag ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) ; //<S2SV> if ( is_referral ) { //<S2SV> errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; //<S2SV> status = "LOOKING_UP_SERVER" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> errcode = decrypt_2ndtkt ( kdc_active_realm , request , c_flags , //<S2SV> & stkt_server , & status ) ; //<S2SV> if ( errcode ) //<S2SV> goto cleanup ; //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_CNAME_IN_ADDL_TKT ) ) { //<S2SV> errcode = kdc_process_s4u2proxy_req ( kdc_active_realm , //<S2SV> request , //<S2SV> request -> second_ticket [ st_idx ] -> enc_part2 , //<S2SV> stkt_server , //<S2SV> header_ticket -> enc_part2 -> client , //<S2SV> request -> server , //<S2SV> & status ) ; //<S2SV> if ( errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION ) //<S2SV> au_state -> violation = PROT_CONSTRAINT ; //<S2SV> else if ( errcode ) //<S2SV> au_state -> violation = LOCAL_POLICY ; //<S2SV> au_state -> status = status ; //<S2SV> retval = kau_make_tkt_id ( kdc_context , request -> second_ticket [ st_idx ] , //<S2SV> & au_state -> evid_tkt_id ) ; //<S2SV> if ( retval ) { //<S2SV> status = "GENERATE_TICKET_ID" ; //<S2SV> errcode = retval ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> kau_s4u2proxy ( kdc_context , errcode ? FALSE : TRUE , au_state ) ; //<S2SV> if ( errcode ) //<S2SV> goto cleanup ; //<S2SV> setflag ( c_flags , KRB5_KDB_FLAG_CONSTRAINED_DELEGATION ) ; //<S2SV> assert ( krb5_is_tgs_principal ( header_ticket -> server ) ) ; //<S2SV> assert ( client == NULL ) ; //<S2SV> client = stkt_server ; //<S2SV> stkt_server = NULL ; //<S2SV> } else if ( request -> kdc_options & KDC_OPT_ENC_TKT_IN_SKEY ) { //<S2SV> krb5_db_free_principal ( kdc_context , stkt_server ) ; //<S2SV> stkt_server = NULL ; //<S2SV> } else //<S2SV> assert ( stkt_server == NULL ) ; //<S2SV> au_state -> stage = ISSUE_TKT ; //<S2SV> errcode = gen_session_key ( kdc_active_realm , request , server , & session_key , //<S2SV> & status ) ; //<S2SV> if ( errcode ) //<S2SV> goto cleanup ; //<S2SV> if ( isflagset ( c_flags , KRB5_KDB_FLAG_CONSTRAINED_DELEGATION ) ) //<S2SV> subject_tkt = request -> second_ticket [ st_idx ] -> enc_part2 ; //<S2SV> else //<S2SV> subject_tkt = header_enc_tkt ; //<S2SV> authtime = subject_tkt -> times . authtime ; //<S2SV> if ( s4u_x509_user == NULL ) { //<S2SV> errcode = get_auth_indicators ( kdc_context , subject_tkt , local_tgt , //<S2SV> & auth_indicators ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "GET_AUTH_INDICATORS" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> errcode = check_indicators ( kdc_context , server , auth_indicators ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "HIGHER_AUTHENTICATION_REQUIRED" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( is_referral ) //<S2SV> ticket_reply . server = server -> princ ; //<S2SV> else //<S2SV> ticket_reply . server = request -> server ; //<S2SV> enc_tkt_reply . flags = OPTS2FLAGS ( request -> kdc_options ) ; //<S2SV> enc_tkt_reply . flags |= COPY_TKT_FLAGS ( header_enc_tkt -> flags ) ; //<S2SV> enc_tkt_reply . times . starttime = 0 ; //<S2SV> if ( isflagset ( server -> attributes , KRB5_KDB_OK_AS_DELEGATE ) ) //<S2SV> setflag ( enc_tkt_reply . flags , TKT_FLG_OK_AS_DELEGATE ) ; //<S2SV> setflag ( enc_tkt_reply . flags , TKT_FLG_ENC_PA_REP ) ; //<S2SV> enc_tkt_reply . caddrs = header_enc_tkt -> caddrs ; //<S2SV> reply_encpart . caddrs = 0 ; //<S2SV> reply_encpart . enc_padata = NULL ; //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_FORWARDABLE ) ) { //<S2SV> if ( isflagset ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) ) { //<S2SV> if ( client != NULL && //<S2SV> isflagset ( client -> attributes , KRB5_KDB_DISALLOW_FORWARDABLE ) ) //<S2SV> clear ( enc_tkt_reply . flags , TKT_FLG_FORWARDABLE ) ; //<S2SV> else if ( ! isflagset ( header_enc_tkt -> flags , TKT_FLG_FORWARDABLE ) ) //<S2SV> clear ( enc_tkt_reply . flags , TKT_FLG_FORWARDABLE ) ; //<S2SV> else if ( ! is_referral && //<S2SV> ! isflagset ( server -> attributes , //<S2SV> KRB5_KDB_OK_TO_AUTH_AS_DELEGATE ) ) //<S2SV> clear ( enc_tkt_reply . flags , TKT_FLG_FORWARDABLE ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_FORWARDED ) || //<S2SV> isflagset ( request -> kdc_options , KDC_OPT_PROXY ) ) { //<S2SV> enc_tkt_reply . caddrs = request -> addresses ; //<S2SV> reply_encpart . caddrs = request -> addresses ; //<S2SV> } //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_REQUEST_ANONYMOUS ) && //<S2SV> ! isflagset ( header_enc_tkt -> flags , TKT_FLG_ANONYMOUS ) ) //<S2SV> clear ( enc_tkt_reply . flags , TKT_FLG_ANONYMOUS ) ; //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) { //<S2SV> setflag ( enc_tkt_reply . flags , TKT_FLG_INVALID ) ; //<S2SV> enc_tkt_reply . times . starttime = request -> from ; //<S2SV> } else //<S2SV> enc_tkt_reply . times . starttime = kdc_time ; //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_VALIDATE ) ) { //<S2SV> assert ( isflagset ( c_flags , KRB5_KDB_FLAGS_S4U ) == 0 ) ; //<S2SV> ticket_reply = * ( header_ticket ) ; //<S2SV> enc_tkt_reply = * ( header_ticket -> enc_part2 ) ; //<S2SV> enc_tkt_reply . authorization_data = NULL ; //<S2SV> clear ( enc_tkt_reply . flags , TKT_FLG_INVALID ) ; //<S2SV> } //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_RENEW ) ) { //<S2SV> krb5_timestamp old_starttime ; //<S2SV> krb5_deltat old_life ; //<S2SV> assert ( isflagset ( c_flags , KRB5_KDB_FLAGS_S4U ) == 0 ) ; //<S2SV> ticket_reply = * ( header_ticket ) ; //<S2SV> enc_tkt_reply = * ( header_ticket -> enc_part2 ) ; //<S2SV> enc_tkt_reply . authorization_data = NULL ; //<S2SV> old_starttime = enc_tkt_reply . times . starttime ? //<S2SV> enc_tkt_reply . times . starttime : enc_tkt_reply . times . authtime ; //<S2SV> old_life = ts_delta ( enc_tkt_reply . times . endtime , old_starttime ) ; //<S2SV> enc_tkt_reply . times . starttime = kdc_time ; //<S2SV> enc_tkt_reply . times . endtime = //<S2SV> ts_min ( header_ticket -> enc_part2 -> times . renew_till , //<S2SV> ts_incr ( kdc_time , old_life ) ) ; //<S2SV> } else { //<S2SV> enc_tkt_reply . times . starttime = kdc_time ; //<S2SV> kdc_get_ticket_endtime ( kdc_active_realm , enc_tkt_reply . times . starttime , //<S2SV> header_enc_tkt -> times . endtime , request -> till , //<S2SV> client , server , & enc_tkt_reply . times . endtime ) ; //<S2SV> } //<S2SV> kdc_get_ticket_renewtime ( kdc_active_realm , request , header_enc_tkt , client , //<S2SV> server , & enc_tkt_reply ) ; //<S2SV> enc_tkt_reply . times . authtime = authtime ; //<S2SV> if ( enc_tkt_reply . times . starttime == enc_tkt_reply . times . authtime ) //<S2SV> enc_tkt_reply . times . starttime = 0 ; //<S2SV> if ( isflagset ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) ) { //<S2SV> altcprinc = s4u_x509_user -> user_id . user ; //<S2SV> } else if ( isflagset ( c_flags , KRB5_KDB_FLAG_CONSTRAINED_DELEGATION ) ) { //<S2SV> altcprinc = subject_tkt -> client ; //<S2SV> } else { //<S2SV> altcprinc = NULL ; //<S2SV> } //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_ENC_TKT_IN_SKEY ) ) { //<S2SV> krb5_enc_tkt_part * t2enc = request -> second_ticket [ st_idx ] -> enc_part2 ; //<S2SV> encrypting_key = * ( t2enc -> session ) ; //<S2SV> } else { //<S2SV> if ( ( errcode = krb5_dbe_find_enctype ( kdc_context , server , //<S2SV> - 1 , //<S2SV> - 1 , //<S2SV> 0 , //<S2SV> & server_key ) ) ) { //<S2SV> status = "FINDING_SERVER_KEY" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( ( errcode = krb5_dbe_decrypt_key_data ( kdc_context , NULL , //<S2SV> server_key , & encrypting_key , //<S2SV> NULL ) ) ) { //<S2SV> status = "DECRYPT_SERVER_KEY" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> if ( isflagset ( c_flags , KRB5_KDB_FLAG_CONSTRAINED_DELEGATION ) ) { //<S2SV> clear ( server -> attributes , KRB5_KDB_NO_AUTH_DATA_REQUIRED ) ; //<S2SV> } //<S2SV> if ( isflagset ( server -> attributes , KRB5_KDB_NO_AUTH_DATA_REQUIRED ) == 0 ) { //<S2SV> if ( ! isflagset ( c_flags , KRB5_KDB_FLAGS_S4U ) ) { //<S2SV> setflag ( c_flags , KRB5_KDB_FLAG_INCLUDE_PAC ) ; //<S2SV> setflag ( c_flags , KRB5_KDB_FLAG_MAP_PRINCIPALS ) ; //<S2SV> assert ( client == NULL ) ; //<S2SV> errcode = krb5_db_get_principal ( kdc_context , subject_tkt -> client , //<S2SV> c_flags , & client ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( isflagset ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) && //<S2SV> ! isflagset ( c_flags , KRB5_KDB_FLAG_CROSS_REALM ) ) //<S2SV> enc_tkt_reply . client = s4u_x509_user -> user_id . user ; //<S2SV> else //<S2SV> enc_tkt_reply . client = subject_tkt -> client ; //<S2SV> enc_tkt_reply . session = & session_key ; //<S2SV> enc_tkt_reply . transited . tr_type = KRB5_DOMAIN_X500_COMPRESS ; //<S2SV> enc_tkt_reply . transited . tr_contents = empty_string ; //<S2SV> if ( krb5_realm_compare ( kdc_context , header_ticket -> server , tgs_server ) || //<S2SV> krb5_realm_compare ( kdc_context , header_ticket -> server , //<S2SV> enc_tkt_reply . client ) ) { //<S2SV> enc_tkt_reply . transited = header_enc_tkt -> transited ; //<S2SV> } else { //<S2SV> if ( header_enc_tkt -> transited . tr_type != //<S2SV> KRB5_DOMAIN_X500_COMPRESS ) { //<S2SV> status = "VALIDATE_TRANSIT_TYPE" ; //<S2SV> errcode = KRB5KDC_ERR_TRTYPE_NOSUPP ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> memset ( & enc_tkt_reply . transited , 0 , sizeof ( enc_tkt_reply . transited ) ) ; //<S2SV> enc_tkt_reply . transited . tr_type = KRB5_DOMAIN_X500_COMPRESS ; //<S2SV> if ( ( errcode = //<S2SV> add_to_transited ( & header_enc_tkt -> transited . tr_contents , //<S2SV> & enc_tkt_reply . transited . tr_contents , //<S2SV> header_ticket -> server , //<S2SV> enc_tkt_reply . client , //<S2SV> request -> server ) ) ) { //<S2SV> status = "ADD_TO_TRANSITED_LIST" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> newtransited = 1 ; //<S2SV> } //<S2SV> if ( isflagset ( c_flags , KRB5_KDB_FLAG_CROSS_REALM ) ) { //<S2SV> errcode = validate_transit_path ( kdc_context , header_enc_tkt -> client , //<S2SV> server , header_server ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "NON_TRANSITIVE" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! isflagset ( request -> kdc_options , KDC_OPT_DISABLE_TRANSITED_CHECK ) ) { //<S2SV> errcode = kdc_check_transited_list ( kdc_active_realm , //<S2SV> & enc_tkt_reply . transited . tr_contents , //<S2SV> krb5_princ_realm ( kdc_context , header_enc_tkt -> client ) , //<S2SV> krb5_princ_realm ( kdc_context , request -> server ) ) ; //<S2SV> if ( errcode == 0 ) { //<S2SV> setflag ( enc_tkt_reply . flags , TKT_FLG_TRANSIT_POLICY_CHECKED ) ; //<S2SV> } else { //<S2SV> log_tgs_badtrans ( kdc_context , cprinc , sprinc , //<S2SV> & enc_tkt_reply . transited . tr_contents , errcode ) ; //<S2SV> } //<S2SV> } else //<S2SV> krb5_klog_syslog ( LOG_INFO , _ ( "not<S2SV_blank>checking<S2SV_blank>transit<S2SV_blank>path" ) ) ; //<S2SV> if ( kdc_active_realm -> realm_reject_bad_transit && //<S2SV> ! isflagset ( enc_tkt_reply . flags , TKT_FLG_TRANSIT_POLICY_CHECKED ) ) { //<S2SV> errcode = KRB5KDC_ERR_POLICY ; //<S2SV> status = "BAD_TRANSIT" ; //<S2SV> au_state -> violation = LOCAL_POLICY ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> errcode = handle_authdata ( kdc_context , c_flags , client , server , //<S2SV> header_server , local_tgt , //<S2SV> subkey != NULL ? subkey : //<S2SV> header_ticket -> enc_part2 -> session , //<S2SV> & encrypting_key , //<S2SV> header_key , //<S2SV> pkt , //<S2SV> request , //<S2SV> s4u_x509_user ? //<S2SV> s4u_x509_user -> user_id . user : NULL , //<S2SV> subject_tkt , //<S2SV> auth_indicators , //<S2SV> & enc_tkt_reply ) ; //<S2SV> if ( errcode ) { //<S2SV> krb5_klog_syslog ( LOG_INFO , _ ( "TGS_REQ<S2SV_blank>:<S2SV_blank>handle_authdata<S2SV_blank>(%d)" ) , //<S2SV> errcode ) ; //<S2SV> status = "HANDLE_AUTHDATA" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> ticket_reply . enc_part2 = & enc_tkt_reply ; //<S2SV> if ( isflagset ( request -> kdc_options , KDC_OPT_ENC_TKT_IN_SKEY ) ) { //<S2SV> krb5_enc_tkt_part * t2enc = request -> second_ticket [ st_idx ] -> enc_part2 ; //<S2SV> krb5_principal client2 = t2enc -> client ; //<S2SV> if ( ! krb5_principal_compare ( kdc_context , request -> server , client2 ) ) { //<S2SV> altcprinc = client2 ; //<S2SV> errcode = KRB5KDC_ERR_SERVER_NOMATCH ; //<S2SV> status = "2ND_TKT_MISMATCH" ; //<S2SV> au_state -> status = status ; //<S2SV> kau_u2u ( kdc_context , FALSE , au_state ) ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> ticket_kvno = 0 ; //<S2SV> ticket_reply . enc_part . enctype = t2enc -> session -> enctype ; //<S2SV> kau_u2u ( kdc_context , TRUE , au_state ) ; //<S2SV> st_idx ++ ; //<S2SV> } else { //<S2SV> ticket_kvno = server_key -> key_data_kvno ; //<S2SV> } //<S2SV> errcode = krb5_encrypt_tkt_part ( kdc_context , & encrypting_key , //<S2SV> & ticket_reply ) ; //<S2SV> if ( ! isflagset ( request -> kdc_options , KDC_OPT_ENC_TKT_IN_SKEY ) ) //<S2SV> krb5_free_keyblock_contents ( kdc_context , & encrypting_key ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "ENCRYPT_TICKET" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> ticket_reply . enc_part . kvno = ticket_kvno ; //<S2SV> au_state -> stage = ENCR_REP ; //<S2SV> reply . msg_type = KRB5_TGS_REP ; //<S2SV> if ( isflagset ( c_flags , KRB5_KDB_FLAG_PROTOCOL_TRANSITION ) && //<S2SV> krb5int_find_pa_data ( kdc_context , request -> padata , //<S2SV> KRB5_PADATA_S4U_X509_USER ) != NULL ) { //<S2SV> errcode = kdc_make_s4u2self_rep ( kdc_context , //<S2SV> subkey , //<S2SV> header_ticket -> enc_part2 -> session , //<S2SV> s4u_x509_user , //<S2SV> & reply , //<S2SV> & reply_encpart ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "MAKE_S4U2SELF_PADATA" ; //<S2SV> au_state -> status = status ; //<S2SV> } //<S2SV> kau_s4u2self ( kdc_context , errcode ? FALSE : TRUE , au_state ) ; //<S2SV> if ( errcode ) //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> reply . client = enc_tkt_reply . client ; //<S2SV> reply . enc_part . kvno = 0 ; //<S2SV> reply . ticket = & ticket_reply ; //<S2SV> reply_encpart . session = & session_key ; //<S2SV> reply_encpart . nonce = request -> nonce ; //<S2SV> reply_encpart . times = enc_tkt_reply . times ; //<S2SV> nolrentry . lr_type = KRB5_LRQ_NONE ; //<S2SV> nolrentry . value = 0 ; //<S2SV> nolrentry . magic = 0 ; //<S2SV> nolrarray [ 0 ] = & nolrentry ; //<S2SV> nolrarray [ 1 ] = 0 ; //<S2SV> reply_encpart . last_req = nolrarray ; //<S2SV> reply_encpart . key_exp = 0 ; //<S2SV> reply_encpart . flags = enc_tkt_reply . flags ; //<S2SV> reply_encpart . server = ticket_reply . server ; //<S2SV> reply . enc_part . enctype = subkey ? subkey -> enctype : //<S2SV> header_ticket -> enc_part2 -> session -> enctype ; //<S2SV> errcode = kdc_fast_response_handle_padata ( state , request , & reply , //<S2SV> subkey ? subkey -> enctype : header_ticket -> enc_part2 -> session -> enctype ) ; //<S2SV> if ( errcode != 0 ) { //<S2SV> status = "MAKE_FAST_RESPONSE" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> errcode = kdc_fast_handle_reply_key ( state , //<S2SV> subkey ? subkey : header_ticket -> enc_part2 -> session , & reply_key ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "MAKE_FAST_REPLY_KEY" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> errcode = return_enc_padata ( kdc_context , pkt , request , //<S2SV> reply_key , server , & reply_encpart , //<S2SV> is_referral && //<S2SV> isflagset ( s_flags , //<S2SV> KRB5_KDB_FLAG_CANONICALIZE ) ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "KDC_RETURN_ENC_PADATA" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> errcode = kau_make_tkt_id ( kdc_context , & ticket_reply , & au_state -> tkt_out_id ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "GENERATE_TICKET_ID" ; //<S2SV> goto cleanup ; //<S2SV> } //<S2SV> if ( kdc_fast_hide_client ( state ) ) //<S2SV> reply . client = ( krb5_principal ) krb5_anonymous_principal ( ) ; //<S2SV> errcode = krb5_encode_kdc_rep ( kdc_context , KRB5_TGS_REP , & reply_encpart , //<S2SV> subkey ? 1 : 0 , //<S2SV> reply_key , //<S2SV> & reply , response ) ; //<S2SV> if ( errcode ) { //<S2SV> status = "ENCODE_KDC_REP" ; //<S2SV> } else { //<S2SV> status = "ISSUE" ; //<S2SV> } //<S2SV> memset ( ticket_reply . enc_part . ciphertext . data , 0 , //<S2SV> ticket_reply . enc_part . ciphertext . length ) ; //<S2SV> free ( ticket_reply . enc_part . ciphertext . data ) ; //<S2SV> memset ( reply . enc_part . ciphertext . data , 0 , //<S2SV> reply . enc_part . ciphertext . length ) ; //<S2SV> free ( reply . enc_part . ciphertext . data ) ; //<S2SV> cleanup : //<S2SV> assert ( status != NULL ) ; //<S2SV> if ( reply_key ) //<S2SV> krb5_free_keyblock ( kdc_context , reply_key ) ; //<S2SV> if ( errcode ) //<S2SV> emsg = krb5_get_error_message ( kdc_context , errcode ) ; //<S2SV> au_state -> status = status ; //<S2SV> if ( ! errcode ) //<S2SV> au_state -> reply = & reply ; //<S2SV> kau_tgs_req ( kdc_context , errcode ? FALSE : TRUE , au_state ) ; //<S2SV> kau_free_kdc_req ( au_state ) ; //<S2SV> log_tgs_req ( kdc_context , from , request , & reply , cprinc , //<S2SV> sprinc , altcprinc , authtime , //<S2SV> c_flags , status , errcode , emsg ) ; //<S2SV> if ( errcode ) { //<S2SV> krb5_free_error_message ( kdc_context , emsg ) ; //<S2SV> emsg = NULL ; //<S2SV> } //<S2SV> if ( errcode ) { //<S2SV> int got_err = 0 ; //<S2SV> if ( status == 0 ) { //<S2SV> status = krb5_get_error_message ( kdc_context , errcode ) ; //<S2SV> got_err = 1 ; //<S2SV> } //<S2SV> errcode -= ERROR_TABLE_BASE_krb5 ; //<S2SV> if ( errcode < 0 || errcode > KRB_ERR_MAX ) //<S2SV> errcode = KRB_ERR_GENERIC ; //<S2SV> retval = prepare_error_tgs ( state , request , header_ticket , errcode , //<S2SV> ( server != NULL ) ? server -> princ : NULL , //<S2SV> response , status , e_data ) ; //<S2SV> if ( got_err ) { //<S2SV> krb5_free_error_message ( kdc_context , status ) ; //<S2SV> status = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( header_ticket != NULL ) //<S2SV> krb5_free_ticket ( kdc_context , header_ticket ) ; //<S2SV> if ( request != NULL ) //<S2SV> krb5_free_kdc_req ( kdc_context , request ) ; //<S2SV> if ( state ) //<S2SV> kdc_free_rstate ( state ) ; //<S2SV> krb5_db_free_principal ( kdc_context , server ) ; //<S2SV> krb5_db_free_principal ( kdc_context , stkt_server ) ; //<S2SV> krb5_db_free_principal ( kdc_context , header_server ) ; //<S2SV> krb5_db_free_principal ( kdc_context , client ) ; //<S2SV> krb5_db_free_principal ( kdc_context , local_tgt_storage ) ; //<S2SV> if ( session_key . contents != NULL ) //<S2SV> krb5_free_keyblock_contents ( kdc_context , & session_key ) ; //<S2SV> if ( newtransited ) //<S2SV> free ( enc_tkt_reply . transited . tr_contents . data ) ; //<S2SV> if ( s4u_x509_user != NULL ) //<S2SV> krb5_free_pa_s4u_x509_user ( kdc_context , s4u_x509_user ) ; //<S2SV> if ( kdc_issued_auth_data != NULL ) //<S2SV> krb5_free_authdata ( kdc_context , kdc_issued_auth_data ) ; //<S2SV> if ( subkey != NULL ) //<S2SV> krb5_free_keyblock ( kdc_context , subkey ) ; //<S2SV> if ( header_key != NULL ) //<S2SV> krb5_free_keyblock ( kdc_context , header_key ) ; //<S2SV> if ( reply . padata ) //<S2SV> krb5_free_pa_data ( kdc_context , reply . padata ) ; //<S2SV> if ( reply_encpart . enc_padata ) //<S2SV> krb5_free_pa_data ( kdc_context , reply_encpart . enc_padata ) ; //<S2SV> if ( enc_tkt_reply . authorization_data != NULL ) //<S2SV> krb5_free_authdata ( kdc_context , enc_tkt_reply . authorization_data ) ; //<S2SV> krb5_free_pa_data ( kdc_context , e_data ) ; //<S2SV> k5_free_data_ptr_list ( auth_indicators ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 