static void //<S2SV> finish_process_as_req ( struct as_req_state * state , krb5_error_code errcode ) //<S2SV> { //<S2SV> krb5_key_data * server_key ; //<S2SV> krb5_keyblock * as_encrypting_key = NULL ; //<S2SV> krb5_data * response = NULL ; //<S2SV> const char * emsg = 0 ; //<S2SV> int did_log = 0 ; //<S2SV> loop_respond_fn oldrespond ; //<S2SV> void * oldarg ; //<S2SV> kdc_realm_t * kdc_active_realm = state -> active_realm ; //<S2SV> krb5_audit_state * au_state = state -> au_state ; //<S2SV> assert ( state ) ; //<S2SV> oldrespond = state -> respond ; //<S2SV> oldarg = state -> arg ; //<S2SV> if ( errcode ) //<S2SV> goto egress ; //<S2SV> au_state -> stage = ENCR_REP ; //<S2SV> if ( ( errcode = validate_forwardable ( state -> request , * state -> client , //<S2SV> * state -> server , state -> kdc_time , //<S2SV> & state -> status ) ) ) { //<S2SV> errcode += ERROR_TABLE_BASE_krb5 ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> errcode = check_indicators ( kdc_context , state -> server , //<S2SV> state -> auth_indicators ) ; //<S2SV> if ( errcode ) { //<S2SV> state -> status = "HIGHER_AUTHENTICATION_REQUIRED" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> state -> ticket_reply . enc_part2 = & state -> enc_tkt_reply ; //<S2SV> if ( ( errcode = krb5_dbe_find_enctype ( kdc_context , state -> server , //<S2SV> - 1 , //<S2SV> - 1 , //<S2SV> 0 , //<S2SV> & server_key ) ) ) { //<S2SV> state -> status = "FINDING_SERVER_KEY" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> if ( ( errcode = krb5_dbe_decrypt_key_data ( kdc_context , NULL , //<S2SV> server_key , //<S2SV> & state -> server_keyblock , //<S2SV> NULL ) ) ) { //<S2SV> state -> status = "DECRYPT_SERVER_KEY" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> state -> reply . msg_type = KRB5_AS_REP ; //<S2SV> state -> reply . client = state -> enc_tkt_reply . client ; //<S2SV> state -> reply . ticket = & state -> ticket_reply ; //<S2SV> state -> reply_encpart . session = & state -> session_key ; //<S2SV> if ( ( errcode = fetch_last_req_info ( state -> client , //<S2SV> & state -> reply_encpart . last_req ) ) ) { //<S2SV> state -> status = "FETCH_LAST_REQ" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> state -> reply_encpart . nonce = state -> request -> nonce ; //<S2SV> state -> reply_encpart . key_exp = get_key_exp ( state -> client ) ; //<S2SV> state -> reply_encpart . flags = state -> enc_tkt_reply . flags ; //<S2SV> state -> reply_encpart . server = state -> ticket_reply . server ; //<S2SV> state -> reply_encpart . times = state -> enc_tkt_reply . times ; //<S2SV> state -> reply_encpart . times . authtime = state -> authtime = state -> kdc_time ; //<S2SV> state -> reply_encpart . caddrs = state -> enc_tkt_reply . caddrs ; //<S2SV> state -> reply_encpart . enc_padata = NULL ; //<S2SV> errcode = return_padata ( kdc_context , & state -> rock , state -> req_pkt , //<S2SV> state -> request , & state -> reply , //<S2SV> & state -> client_keyblock , & state -> pa_context ) ; //<S2SV> if ( errcode ) { //<S2SV> state -> status = "KDC_RETURN_PADATA" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> if ( state -> client_keyblock . enctype == ENCTYPE_NULL ) { //<S2SV> state -> status = "CANT_FIND_CLIENT_KEY" ; //<S2SV> errcode = KRB5KDC_ERR_ETYPE_NOSUPP ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> errcode = handle_authdata ( kdc_context , //<S2SV> state -> c_flags , //<S2SV> state -> client , //<S2SV> state -> server , //<S2SV> NULL , //<S2SV> state -> local_tgt , //<S2SV> & state -> client_keyblock , //<S2SV> & state -> server_keyblock , //<S2SV> NULL , //<S2SV> state -> req_pkt , //<S2SV> state -> request , //<S2SV> NULL , //<S2SV> NULL , //<S2SV> state -> auth_indicators , //<S2SV> & state -> enc_tkt_reply ) ; //<S2SV> if ( errcode ) { //<S2SV> krb5_klog_syslog ( LOG_INFO , _ ( "AS_REQ<S2SV_blank>:<S2SV_blank>handle_authdata<S2SV_blank>(%d)" ) , //<S2SV> errcode ) ; //<S2SV> state -> status = "HANDLE_AUTHDATA" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> errcode = krb5_encrypt_tkt_part ( kdc_context , & state -> server_keyblock , //<S2SV> & state -> ticket_reply ) ; //<S2SV> if ( errcode ) { //<S2SV> state -> status = "ENCRYPT_TICKET" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> errcode = kau_make_tkt_id ( kdc_context , & state -> ticket_reply , //<S2SV> & au_state -> tkt_out_id ) ; //<S2SV> if ( errcode ) { //<S2SV> state -> status = "GENERATE_TICKET_ID" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> state -> ticket_reply . enc_part . kvno = server_key -> key_data_kvno ; //<S2SV> errcode = kdc_fast_response_handle_padata ( state -> rstate , //<S2SV> state -> request , //<S2SV> & state -> reply , //<S2SV> state -> client_keyblock . enctype ) ; //<S2SV> if ( errcode ) { //<S2SV> state -> status = "MAKE_FAST_RESPONSE" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> state -> reply . enc_part . enctype = state -> client_keyblock . enctype ; //<S2SV> errcode = kdc_fast_handle_reply_key ( state -> rstate , & state -> client_keyblock , //<S2SV> & as_encrypting_key ) ; //<S2SV> if ( errcode ) { //<S2SV> state -> status = "MAKE_FAST_REPLY_KEY" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> errcode = return_enc_padata ( kdc_context , state -> req_pkt , state -> request , //<S2SV> as_encrypting_key , state -> server , //<S2SV> & state -> reply_encpart , FALSE ) ; //<S2SV> if ( errcode ) { //<S2SV> state -> status = "KDC_RETURN_ENC_PADATA" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> if ( kdc_fast_hide_client ( state -> rstate ) ) //<S2SV> state -> reply . client = ( krb5_principal ) krb5_anonymous_principal ( ) ; //<S2SV> errcode = krb5_encode_kdc_rep ( kdc_context , KRB5_AS_REP , //<S2SV> & state -> reply_encpart , 0 , //<S2SV> as_encrypting_key , //<S2SV> & state -> reply , & response ) ; //<S2SV> if ( state -> client_key != NULL ) //<S2SV> state -> reply . enc_part . kvno = state -> client_key -> key_data_kvno ; //<S2SV> if ( errcode ) { //<S2SV> state -> status = "ENCODE_KDC_REP" ; //<S2SV> goto egress ; //<S2SV> } //<S2SV> memset ( state -> reply . enc_part . ciphertext . data , 0 , //<S2SV> state -> reply . enc_part . ciphertext . length ) ; //<S2SV> free ( state -> reply . enc_part . ciphertext . data ) ; //<S2SV> log_as_req ( kdc_context , state -> local_addr , state -> remote_addr , //<S2SV> state -> request , & state -> reply , state -> client , state -> cname , //<S2SV> state -> server , state -> sname , state -> authtime , 0 , 0 , 0 ) ; //<S2SV> did_log = 1 ; //<S2SV> egress : //<S2SV> if ( errcode != 0 && state -> status == NULL ) //<S2SV> state -> status = "UNKNOWN_REASON" ; //<S2SV> au_state -> status = state -> status ; //<S2SV> au_state -> reply = & state -> reply ; //<S2SV> kau_as_req ( kdc_context , //<S2SV> ( errcode || state -> preauth_err ) ? FALSE : TRUE , au_state ) ; //<S2SV> kau_free_kdc_req ( au_state ) ; //<S2SV> free_padata_context ( kdc_context , state -> pa_context ) ; //<S2SV> if ( as_encrypting_key ) //<S2SV> krb5_free_keyblock ( kdc_context , as_encrypting_key ) ; //<S2SV> if ( errcode ) //<S2SV> emsg = krb5_get_error_message ( kdc_context , errcode ) ; //<S2SV> if ( state -> status ) { //<S2SV> log_as_req ( kdc_context , state -> local_addr , state -> remote_addr , //<S2SV> state -> request , & state -> reply , state -> client , //<S2SV> state -> cname , state -> server , state -> sname , state -> authtime , //<S2SV> state -> status , errcode , emsg ) ; //<S2SV> did_log = 1 ; //<S2SV> } //<S2SV> if ( errcode ) { //<S2SV> if ( state -> status == 0 ) { //<S2SV> state -> status = emsg ; //<S2SV> } //<S2SV> if ( errcode != KRB5KDC_ERR_DISCARD ) { //<S2SV> errcode -= ERROR_TABLE_BASE_krb5 ; //<S2SV> if ( errcode < 0 || errcode > KRB_ERR_MAX ) //<S2SV> errcode = KRB_ERR_GENERIC ; //<S2SV> errcode = prepare_error_as ( state -> rstate , state -> request , //<S2SV> state -> local_tgt , errcode , //<S2SV> state -> e_data , state -> typed_e_data , //<S2SV> ( ( state -> client != NULL ) ? //<S2SV> state -> client -> princ : NULL ) , //<S2SV> & response , state -> status ) ; //<S2SV> state -> status = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( emsg ) //<S2SV> krb5_free_error_message ( kdc_context , emsg ) ; //<S2SV> if ( state -> enc_tkt_reply . authorization_data != NULL ) //<S2SV> krb5_free_authdata ( kdc_context , //<S2SV> state -> enc_tkt_reply . authorization_data ) ; //<S2SV> if ( state -> server_keyblock . contents != NULL ) //<S2SV> krb5_free_keyblock_contents ( kdc_context , & state -> server_keyblock ) ; //<S2SV> if ( state -> client_keyblock . contents != NULL ) //<S2SV> krb5_free_keyblock_contents ( kdc_context , & state -> client_keyblock ) ; //<S2SV> if ( state -> reply . padata != NULL ) //<S2SV> krb5_free_pa_data ( kdc_context , state -> reply . padata ) ; //<S2SV> if ( state -> reply_encpart . enc_padata ) //<S2SV> krb5_free_pa_data ( kdc_context , state -> reply_encpart . enc_padata ) ; //<S2SV> if ( state -> cname != NULL ) //<S2SV> free ( state -> cname ) ; //<S2SV> if ( state -> sname != NULL ) //<S2SV> free ( state -> sname ) ; //<S2SV> krb5_db_free_principal ( kdc_context , state -> client ) ; //<S2SV> krb5_db_free_principal ( kdc_context , state -> server ) ; //<S2SV> krb5_db_free_principal ( kdc_context , state -> local_tgt_storage ) ; //<S2SV> if ( state -> session_key . contents != NULL ) //<S2SV> krb5_free_keyblock_contents ( kdc_context , & state -> session_key ) ; //<S2SV> if ( state -> ticket_reply . enc_part . ciphertext . data != NULL ) { //<S2SV> memset ( state -> ticket_reply . enc_part . ciphertext . data , 0 , //<S2SV> state -> ticket_reply . enc_part . ciphertext . length ) ; //<S2SV> free ( state -> ticket_reply . enc_part . ciphertext . data ) ; //<S2SV> } //<S2SV> krb5_free_pa_data ( kdc_context , state -> e_data ) ; //<S2SV> krb5_free_data ( kdc_context , state -> inner_body ) ; //<S2SV> kdc_free_rstate ( state -> rstate ) ; //<S2SV> krb5_free_kdc_req ( kdc_context , state -> request ) ; //<S2SV> k5_free_data_ptr_list ( state -> auth_indicators ) ; //<S2SV> assert ( did_log != 0 ) ; //<S2SV> free ( state ) ; //<S2SV> ( * oldrespond ) ( oldarg , errcode , response ) ; //<S2SV> } //<S2SV> 