static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) //<S2SV> { //<S2SV> Bool has_audio , has_video ; //<S2SV> s32 i ; //<S2SV> AVFormatContext * ctx ; //<S2SV> AVOutputFormat * fmt_out ; //<S2SV> Bool ret = GF_FALSE ; //<S2SV> char * ext , szName [ 1024 ] , szExt [ 20 ] ; //<S2SV> const char * szExtList ; //<S2SV> FFDemux * ffd ; //<S2SV> if ( ! plug || ! url ) //<S2SV> return GF_FALSE ; //<S2SV> if ( ! strnicmp ( url , "rtsp://" , 7 ) ) return GF_FALSE ; //<S2SV> if ( ! strnicmp ( url , "rtspu://" , 8 ) ) return GF_FALSE ; //<S2SV> if ( ! strnicmp ( url , "rtp://" , 6 ) ) return GF_FALSE ; //<S2SV> if ( ! strnicmp ( url , "plato://" , 8 ) ) return GF_FALSE ; //<S2SV> if ( ! strnicmp ( url , "udp://" , 6 ) ) return GF_FALSE ; //<S2SV> if ( ! strnicmp ( url , "tcp://" , 6 ) ) return GF_FALSE ; //<S2SV> if ( ! strnicmp ( url , "data:" , 5 ) ) return GF_FALSE ; //<S2SV> ffd = ( FFDemux * ) plug -> priv ; //<S2SV> if ( strlen ( url ) >= sizeof ( szName ) ) //<S2SV> return GF_FALSE ; //<S2SV> strcpy ( szName , url ) ; //<S2SV> ext = strrchr ( szName , '#' ) ; //<S2SV> if ( ext ) ext [ 0 ] = 0 ; //<S2SV> ext = strrchr ( szName , '?' ) ; //<S2SV> if ( ext ) ext [ 0 ] = 0 ; //<S2SV> ext = strrchr ( szName , '.' ) ; //<S2SV> if ( ext && strlen ( ext ) > 19 ) ext = NULL ; //<S2SV> if ( ext && strlen ( ext ) > 1 && strlen ( ext ) <= sizeof ( szExt ) ) { //<S2SV> strcpy ( szExt , & ext [ 1 ] ) ; //<S2SV> strlwr ( szExt ) ; //<S2SV> # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS //<S2SV> if ( strstr ( "ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp" , szExt ) ) return GF_FALSE ; //<S2SV> # endif //<S2SV> if ( ! strcmp ( szExt , "mp4" ) || ! strcmp ( szExt , "mpg4" ) || ! strcmp ( szExt , "m4a" ) || ! strcmp ( szExt , "m21" ) //<S2SV> || ! strcmp ( szExt , "m4v" ) || ! strcmp ( szExt , "m4a" ) //<S2SV> || ! strcmp ( szExt , "m4s" ) || ! strcmp ( szExt , "3gs" ) //<S2SV> || ! strcmp ( szExt , "3gp" ) || ! strcmp ( szExt , "3gpp" ) || ! strcmp ( szExt , "3gp2" ) || ! strcmp ( szExt , "3g2" ) //<S2SV> || ! strcmp ( szExt , "mp3" ) //<S2SV> || ! strcmp ( szExt , "ac3" ) //<S2SV> || ! strcmp ( szExt , "amr" ) //<S2SV> || ! strcmp ( szExt , "bt" ) || ! strcmp ( szExt , "wrl" ) || ! strcmp ( szExt , "x3dv" ) //<S2SV> || ! strcmp ( szExt , "xmt" ) || ! strcmp ( szExt , "xmta" ) || ! strcmp ( szExt , "x3d" ) //<S2SV> || ! strcmp ( szExt , "jpg" ) || ! strcmp ( szExt , "jpeg" ) || ! strcmp ( szExt , "png" ) //<S2SV> ) return GF_FALSE ; //<S2SV> { //<S2SV> u32 i ; //<S2SV> for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { //<S2SV> if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) //<S2SV> return GF_TRUE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ffd_parse_options ( ffd , url ) ; //<S2SV> ctx = NULL ; //<S2SV> if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { //<S2SV> AVInputFormat * av_in = NULL ; //<S2SV> if ( ext && ! strcmp ( szExt , "cmp" ) ) av_in = av_find_input_format ( "m4v" ) ; //<S2SV> if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { //<S2SV> return GF_FALSE ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ctx ) goto exit ; //<S2SV> if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; //<S2SV> has_video = has_audio = GF_FALSE ; //<S2SV> for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { //<S2SV> AVCodecContext * enc = ctx -> streams [ i ] -> codec ; //<S2SV> switch ( enc -> codec_type ) { //<S2SV> case AVMEDIA_TYPE_AUDIO : //<S2SV> if ( ! has_audio ) has_audio = GF_TRUE ; //<S2SV> break ; //<S2SV> case AVMEDIA_TYPE_VIDEO : //<S2SV> if ( ! has_video ) has_video = GF_TRUE ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! has_audio && ! has_video ) goto exit ; //<S2SV> ret = GF_TRUE ; //<S2SV> # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) //<S2SV> fmt_out = guess_stream_format ( NULL , url , NULL ) ; //<S2SV> # else //<S2SV> fmt_out = av_guess_format ( NULL , url , NULL ) ; //<S2SV> # endif //<S2SV> if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; //<S2SV> else { //<S2SV> ext = strrchr ( szName , '.' ) ; //<S2SV> if ( ext ) { //<S2SV> strcpy ( szExt , & ext [ 1 ] ) ; //<S2SV> strlwr ( szExt ) ; //<S2SV> szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , "MimeTypes" , "application/x-ffmpeg" ) ; //<S2SV> if ( ! szExtList ) { //<S2SV> gf_service_register_mime ( plug , "application/x-ffmpeg" , szExt , "Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)" ) ; //<S2SV> } else if ( ! strstr ( szExtList , szExt ) ) { //<S2SV> u32 len ; //<S2SV> char * buf ; //<S2SV> len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; //<S2SV> buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; //<S2SV> sprintf ( buf , "\\"%s<S2SV_blank>" , szExt ) ; //<S2SV> strcat ( buf , & szExtList [ 1 ] ) ; //<S2SV> gf_modules_set_option ( ( GF_BaseInterface * ) plug , "MimeTypes" , "application/x-ffmpeg" , buf ) ; //<S2SV> gf_free ( buf ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> exit : //<S2SV> # if FF_API_CLOSE_INPUT_FILE //<S2SV> if ( ctx ) av_close_input_file ( ctx ) ; //<S2SV> # else //<S2SV> if ( ctx ) avformat_close_input ( & ctx ) ; //<S2SV> # endif //<S2SV> return ret ; //<S2SV> } //<S2SV> 