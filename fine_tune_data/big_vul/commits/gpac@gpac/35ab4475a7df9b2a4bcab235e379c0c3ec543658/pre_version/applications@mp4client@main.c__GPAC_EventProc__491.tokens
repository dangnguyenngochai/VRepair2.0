Bool GPAC_EventProc ( void * ptr , GF_Event * evt ) //<S2SV> { //<S2SV> if ( ! term ) return 0 ; //<S2SV> if ( gui_mode == 1 ) { //<S2SV> if ( evt -> type == GF_EVENT_QUIT ) { //<S2SV> Run = 0 ; //<S2SV> } else if ( evt -> type == GF_EVENT_KEYDOWN ) { //<S2SV> switch ( evt -> key . key_code ) { //<S2SV> case GF_KEY_C : //<S2SV> if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { //<S2SV> hide_shell ( shell_visible ? 1 : 0 ) ; //<S2SV> if ( shell_visible ) gui_mode = 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> switch ( evt -> type ) { //<S2SV> case GF_EVENT_DURATION : //<S2SV> Duration = ( u64 ) ( 1000 * ( s64 ) evt -> duration . duration ) ; //<S2SV> CanSeek = evt -> duration . can_seek ; //<S2SV> break ; //<S2SV> case GF_EVENT_MESSAGE : //<S2SV> { //<S2SV> const char * servName ; //<S2SV> if ( ! evt -> message . service || ! strcmp ( evt -> message . service , the_url ) ) { //<S2SV> servName = "" ; //<S2SV> } else if ( ! strnicmp ( evt -> message . service , "data:" , 5 ) ) { //<S2SV> servName = "(embedded<S2SV_blank>data)" ; //<S2SV> } else { //<S2SV> servName = evt -> message . service ; //<S2SV> } //<S2SV> if ( ! evt -> message . message ) return 0 ; //<S2SV> if ( evt -> message . error ) { //<S2SV> if ( ! is_connected ) last_error = evt -> message . error ; //<S2SV> if ( evt -> message . error == GF_SCRIPT_INFO ) { //<S2SV> GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( "%s\\n" , evt -> message . message ) ) ; //<S2SV> } else { //<S2SV> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONSOLE , ( "%s<S2SV_blank>%s:<S2SV_blank>%s\\n" , servName , evt -> message . message , gf_error_to_string ( evt -> message . error ) ) ) ; //<S2SV> } //<S2SV> } else if ( ! be_quiet ) //<S2SV> GF_LOG ( GF_LOG_INFO , GF_LOG_CONSOLE , ( "%s<S2SV_blank>%s\\n" , servName , evt -> message . message ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_PROGRESS : //<S2SV> { //<S2SV> char * szTitle = "" ; //<S2SV> if ( evt -> progress . progress_type == 0 ) { //<S2SV> szTitle = "Buffer<S2SV_blank>" ; //<S2SV> if ( bench_mode && ( bench_mode != 3 ) ) { //<S2SV> if ( evt -> progress . done >= evt -> progress . total ) bench_buffer = 0 ; //<S2SV> else bench_buffer = 1 + 100 * evt -> progress . done / evt -> progress . total ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else if ( evt -> progress . progress_type == 1 ) { //<S2SV> if ( bench_mode ) break ; //<S2SV> szTitle = "Download<S2SV_blank>" ; //<S2SV> } //<S2SV> else if ( evt -> progress . progress_type == 2 ) szTitle = "Import<S2SV_blank>" ; //<S2SV> gf_set_progress ( szTitle , evt -> progress . done , evt -> progress . total ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_DBLCLICK : //<S2SV> gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; //<S2SV> return 0 ; //<S2SV> case GF_EVENT_MOUSEDOWN : //<S2SV> if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { //<S2SV> right_down = 1 ; //<S2SV> last_x = evt -> mouse . x ; //<S2SV> last_y = evt -> mouse . y ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case GF_EVENT_MOUSEUP : //<S2SV> if ( evt -> mouse . button == GF_MOUSE_RIGHT ) { //<S2SV> right_down = 0 ; //<S2SV> last_x = evt -> mouse . x ; //<S2SV> last_y = evt -> mouse . y ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case GF_EVENT_MOUSEMOVE : //<S2SV> if ( right_down && ( user . init_flags & GF_TERM_WINDOWLESS ) ) { //<S2SV> GF_Event move ; //<S2SV> move . move . x = evt -> mouse . x - last_x ; //<S2SV> move . move . y = last_y - evt -> mouse . y ; //<S2SV> move . type = GF_EVENT_MOVE ; //<S2SV> move . move . relative = 1 ; //<S2SV> gf_term_user_event ( term , & move ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case GF_EVENT_KEYUP : //<S2SV> switch ( evt -> key . key_code ) { //<S2SV> case GF_KEY_SPACE : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) switch_bench ( ! bench_mode ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_KEYDOWN : //<S2SV> gf_term_process_shortcut ( term , evt ) ; //<S2SV> switch ( evt -> key . key_code ) { //<S2SV> case GF_KEY_SPACE : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) { //<S2SV> if ( ! bench_mode ) switch_bench ( ! bench_mode ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_PAGEDOWN : //<S2SV> case GF_KEY_MEDIANEXTTRACK : //<S2SV> request_next_playlist_item = 1 ; //<S2SV> break ; //<S2SV> case GF_KEY_MEDIAPREVIOUSTRACK : //<S2SV> break ; //<S2SV> case GF_KEY_ESCAPE : //<S2SV> gf_term_set_option ( term , GF_OPT_FULLSCREEN , ! gf_term_get_option ( term , GF_OPT_FULLSCREEN ) ) ; //<S2SV> break ; //<S2SV> case GF_KEY_C : //<S2SV> if ( evt -> key . flags & ( GF_KEY_MOD_CTRL | GF_KEY_MOD_ALT ) ) { //<S2SV> hide_shell ( shell_visible ? 1 : 0 ) ; //<S2SV> if ( ! shell_visible ) gui_mode = 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_F : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , "Rendering<S2SV_blank>rate:<S2SV_blank>%f<S2SV_blank>FPS\\n" , gf_term_get_framerate ( term , 0 ) ) ; //<S2SV> break ; //<S2SV> case GF_KEY_T : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) fprintf ( stderr , "Scene<S2SV_blank>Time:<S2SV_blank>%f<S2SV_blank>\\n" , gf_term_get_time_in_ms ( term ) / 1000.0 ) ; //<S2SV> break ; //<S2SV> case GF_KEY_D : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) gf_term_set_option ( term , GF_OPT_DRAW_MODE , ( gf_term_get_option ( term , GF_OPT_DRAW_MODE ) == GF_DRAW_MODE_DEFER ) ? GF_DRAW_MODE_IMMEDIATE : GF_DRAW_MODE_DEFER ) ; //<S2SV> break ; //<S2SV> case GF_KEY_4 : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) //<S2SV> gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_4_3 ) ; //<S2SV> break ; //<S2SV> case GF_KEY_5 : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) //<S2SV> gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_16_9 ) ; //<S2SV> break ; //<S2SV> case GF_KEY_6 : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) //<S2SV> gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_FILL_SCREEN ) ; //<S2SV> break ; //<S2SV> case GF_KEY_7 : //<S2SV> if ( evt -> key . flags & GF_KEY_MOD_CTRL ) //<S2SV> gf_term_set_option ( term , GF_OPT_ASPECT_RATIO , GF_ASPECT_RATIO_KEEP ) ; //<S2SV> break ; //<S2SV> case GF_KEY_O : //<S2SV> if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { //<S2SV> if ( gf_term_get_option ( term , GF_OPT_MAIN_ADDON ) ) { //<S2SV> fprintf ( stderr , "Resuming<S2SV_blank>to<S2SV_blank>main<S2SV_blank>content\\n" ) ; //<S2SV> gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; //<S2SV> } else { //<S2SV> fprintf ( stderr , "Main<S2SV_blank>addon<S2SV_blank>not<S2SV_blank>enabled\\n" ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_P : //<S2SV> if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { //<S2SV> u32 pause_state = gf_term_get_option ( term , GF_OPT_PLAY_STATE ) ; //<S2SV> fprintf ( stderr , "[Status:<S2SV_blank>%s]\\n" , pause_state ? "Playing" : "Paused" ) ; //<S2SV> if ( ( pause_state == GF_STATE_PAUSED ) && ( evt -> key . flags & GF_KEY_MOD_SHIFT ) ) { //<S2SV> gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_PLAY_LIVE ) ; //<S2SV> } else { //<S2SV> gf_term_set_option ( term , GF_OPT_PLAY_STATE , ( pause_state == GF_STATE_PAUSED ) ? GF_STATE_PLAYING : GF_STATE_PAUSED ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_S : //<S2SV> if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { //<S2SV> gf_term_set_option ( term , GF_OPT_PLAY_STATE , GF_STATE_STEP_PAUSE ) ; //<S2SV> fprintf ( stderr , "Step<S2SV_blank>time:<S2SV_blank>" ) ; //<S2SV> PrintTime ( gf_term_get_time_in_ms ( term ) ) ; //<S2SV> fprintf ( stderr , "\\n" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_B : //<S2SV> if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) //<S2SV> ViewODs ( term , 1 ) ; //<S2SV> break ; //<S2SV> case GF_KEY_M : //<S2SV> if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) //<S2SV> ViewODs ( term , 0 ) ; //<S2SV> break ; //<S2SV> case GF_KEY_H : //<S2SV> if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { //<S2SV> gf_term_switch_quality ( term , 1 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_L : //<S2SV> if ( ( evt -> key . flags & GF_KEY_MOD_CTRL ) && is_connected ) { //<S2SV> gf_term_switch_quality ( term , 0 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_F5 : //<S2SV> if ( is_connected ) //<S2SV> reload = 1 ; //<S2SV> break ; //<S2SV> case GF_KEY_A : //<S2SV> addon_visible = ! addon_visible ; //<S2SV> gf_term_toggle_addons ( term , addon_visible ) ; //<S2SV> break ; //<S2SV> case GF_KEY_UP : //<S2SV> if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { //<S2SV> do_set_speed ( playback_speed * 2 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_DOWN : //<S2SV> if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { //<S2SV> do_set_speed ( playback_speed / 2 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_KEY_LEFT : //<S2SV> if ( ( evt -> key . flags & VK_MOD ) && is_connected ) { //<S2SV> do_set_speed ( - 1 * playback_speed ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_CONNECT : //<S2SV> if ( evt -> connect . is_connected ) { //<S2SV> is_connected = 1 ; //<S2SV> fprintf ( stderr , "Service<S2SV_blank>Connected\\n" ) ; //<S2SV> eos_seen = GF_FALSE ; //<S2SV> if ( playback_speed != FIX_ONE ) //<S2SV> gf_term_set_speed ( term , playback_speed ) ; //<S2SV> } else if ( is_connected ) { //<S2SV> fprintf ( stderr , "Service<S2SV_blank>%s\\n" , is_connected ? "Disconnected" : "Connection<S2SV_blank>Failed" ) ; //<S2SV> is_connected = 0 ; //<S2SV> Duration = 0 ; //<S2SV> } //<S2SV> if ( init_w && init_h ) { //<S2SV> gf_term_set_size ( term , init_w , init_h ) ; //<S2SV> } //<S2SV> ResetCaption ( ) ; //<S2SV> break ; //<S2SV> case GF_EVENT_EOS : //<S2SV> eos_seen = GF_TRUE ; //<S2SV> if ( playlist ) { //<S2SV> if ( Duration > 1500 ) //<S2SV> request_next_playlist_item = GF_TRUE ; //<S2SV> } //<S2SV> else if ( loop_at_end ) { //<S2SV> restart = 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_SIZE : //<S2SV> if ( user . init_flags & GF_TERM_WINDOWLESS ) { //<S2SV> GF_Event move ; //<S2SV> move . type = GF_EVENT_MOVE ; //<S2SV> move . move . align_x = align_mode & 0xFF ; //<S2SV> move . move . align_y = ( align_mode >> 8 ) & 0xFF ; //<S2SV> move . move . relative = 2 ; //<S2SV> gf_term_user_event ( term , & move ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_SCENE_SIZE : //<S2SV> if ( forced_width && forced_height ) { //<S2SV> GF_Event size ; //<S2SV> size . type = GF_EVENT_SIZE ; //<S2SV> size . size . width = forced_width ; //<S2SV> size . size . height = forced_height ; //<S2SV> gf_term_user_event ( term , & size ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_METADATA : //<S2SV> ResetCaption ( ) ; //<S2SV> break ; //<S2SV> case GF_EVENT_RELOAD : //<S2SV> if ( is_connected ) //<S2SV> reload = 1 ; //<S2SV> break ; //<S2SV> case GF_EVENT_DROPFILE : //<S2SV> { //<S2SV> u32 i , pos ; //<S2SV> if ( readonly_playlist ) { //<S2SV> gf_fclose ( playlist ) ; //<S2SV> playlist = NULL ; //<S2SV> } //<S2SV> readonly_playlist = 0 ; //<S2SV> if ( ! playlist ) { //<S2SV> readonly_playlist = 0 ; //<S2SV> playlist = gf_temp_file_new ( NULL ) ; //<S2SV> } //<S2SV> pos = ftell ( playlist ) ; //<S2SV> i = 0 ; //<S2SV> while ( i < evt -> open_file . nb_files ) { //<S2SV> if ( evt -> open_file . files [ i ] != NULL ) { //<S2SV> fprintf ( playlist , "%s\\n" , evt -> open_file . files [ i ] ) ; //<S2SV> } //<S2SV> i ++ ; //<S2SV> } //<S2SV> fseek ( playlist , pos , SEEK_SET ) ; //<S2SV> request_next_playlist_item = 1 ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case GF_EVENT_QUIT : //<S2SV> if ( evt -> message . error ) { //<S2SV> fprintf ( stderr , "A<S2SV_blank>fatal<S2SV_blank>error<S2SV_blank>was<S2SV_blank>encoutered:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>exiting<S2SV_blank>...\\n" , evt -> message . message ? evt -> message . message : "no<S2SV_blank>details" , gf_error_to_string ( evt -> message . error ) ) ; //<S2SV> } //<S2SV> Run = 0 ; //<S2SV> break ; //<S2SV> case GF_EVENT_DISCONNECT : //<S2SV> gf_term_disconnect ( term ) ; //<S2SV> break ; //<S2SV> case GF_EVENT_MIGRATE : //<S2SV> { //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_NAVIGATE_INFO : //<S2SV> if ( evt -> navigate . to_url ) fprintf ( stderr , "Go<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>\\"%s\\"\\r" , evt -> navigate . to_url ) ; //<S2SV> break ; //<S2SV> case GF_EVENT_NAVIGATE : //<S2SV> if ( gf_term_is_supported_url ( term , evt -> navigate . to_url , 1 , no_mime_check ) ) { //<S2SV> strcpy ( the_url , evt -> navigate . to_url ) ; //<S2SV> fprintf ( stderr , "Navigating<S2SV_blank>to<S2SV_blank>URL<S2SV_blank>%s\\n" , the_url ) ; //<S2SV> gf_term_navigate_to ( term , evt -> navigate . to_url ) ; //<S2SV> return 1 ; //<S2SV> } else { //<S2SV> fprintf ( stderr , "Navigation<S2SV_blank>destination<S2SV_blank>not<S2SV_blank>supported\\nGo<S2SV_blank>to<S2SV_blank>URL:<S2SV_blank>%s\\n" , evt -> navigate . to_url ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case GF_EVENT_SET_CAPTION : //<S2SV> gf_term_user_event ( term , evt ) ; //<S2SV> break ; //<S2SV> case GF_EVENT_AUTHORIZATION : //<S2SV> { //<S2SV> int maxTries = 1 ; //<S2SV> assert ( evt -> type == GF_EVENT_AUTHORIZATION ) ; //<S2SV> assert ( evt -> auth . user ) ; //<S2SV> assert ( evt -> auth . password ) ; //<S2SV> assert ( evt -> auth . site_url ) ; //<S2SV> while ( ( ! strlen ( evt -> auth . user ) || ! strlen ( evt -> auth . password ) ) && ( maxTries -- ) >= 0 ) { //<S2SV> fprintf ( stderr , "****<S2SV_blank>Authorization<S2SV_blank>required<S2SV_blank>for<S2SV_blank>site<S2SV_blank>%s<S2SV_blank>****\\n" , evt -> auth . site_url ) ; //<S2SV> fprintf ( stderr , "login<S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>" ) ; //<S2SV> read_line_input ( evt -> auth . user , 50 , 1 ) ; //<S2SV> fprintf ( stderr , "\\npassword:<S2SV_blank>" ) ; //<S2SV> read_line_input ( evt -> auth . password , 50 , 0 ) ; //<S2SV> fprintf ( stderr , "*********\\n" ) ; //<S2SV> } //<S2SV> if ( maxTries < 0 ) { //<S2SV> fprintf ( stderr , "****<S2SV_blank>No<S2SV_blank>User<S2SV_blank>or<S2SV_blank>password<S2SV_blank>has<S2SV_blank>been<S2SV_blank>filled,<S2SV_blank>aborting<S2SV_blank>***\\n" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> } //<S2SV> case GF_EVENT_ADDON_DETECTED : //<S2SV> if ( enable_add_ons ) { //<S2SV> fprintf ( stderr , "Media<S2SV_blank>Addon<S2SV_blank>%s<S2SV_blank>detected<S2SV_blank>-<S2SV_blank>enabling<S2SV_blank>it\\n" , evt -> addon_connect . addon_url ) ; //<S2SV> addon_visible = 1 ; //<S2SV> } //<S2SV> return enable_add_ons ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 