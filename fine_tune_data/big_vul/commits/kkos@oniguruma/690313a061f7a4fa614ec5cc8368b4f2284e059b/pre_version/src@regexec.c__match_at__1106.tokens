static int //<S2SV> match_at ( regex_t * reg , const UChar * str , const UChar * end , //<S2SV> # ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE //<S2SV> const UChar * right_range , //<S2SV> # endif //<S2SV> const UChar * sstart , UChar * sprev , OnigMatchArg * msa ) //<S2SV> { //<S2SV> static UChar FinishCode [ ] = { OP_FINISH } ; //<S2SV> int i , n , num_mem , best_len , pop_level ; //<S2SV> LengthType tlen , tlen2 ; //<S2SV> MemNumType mem ; //<S2SV> RelAddrType addr ; //<S2SV> UChar * s , * q , * sbegin ; //<S2SV> int is_alloca ; //<S2SV> char * alloc_base ; //<S2SV> OnigStackType * stk_base , * stk , * stk_end ; //<S2SV> OnigStackType * stkp ; //<S2SV> OnigStackIndex si ; //<S2SV> OnigStackIndex * repeat_stk ; //<S2SV> OnigStackIndex * mem_start_stk , * mem_end_stk ; //<S2SV> # ifdef USE_COMBINATION_EXPLOSION_CHECK //<S2SV> int scv ; //<S2SV> unsigned char * state_check_buff = msa -> state_check_buff ; //<S2SV> int num_comb_exp_check = reg -> num_comb_exp_check ; //<S2SV> # endif //<S2SV> UChar * p = reg -> p ; //<S2SV> OnigOptionType option = reg -> options ; //<S2SV> OnigEncoding encode = reg -> enc ; //<S2SV> OnigCaseFoldType case_fold_flag = reg -> case_fold_flag ; //<S2SV> pop_level = reg -> stack_pop_level ; //<S2SV> num_mem = reg -> num_mem ; //<S2SV> STACK_INIT ( INIT_MATCH_STACK_SIZE ) ; //<S2SV> UPDATE_FOR_STACK_REALLOC ; //<S2SV> for ( i = 1 ; i <= num_mem ; i ++ ) { //<S2SV> mem_start_stk [ i ] = mem_end_stk [ i ] = INVALID_STACK_INDEX ; //<S2SV> } //<S2SV> # ifdef ONIG_DEBUG_MATCH //<S2SV> fprintf ( stderr , "match_at:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>start:<S2SV_blank>%d,<S2SV_blank>sprev:<S2SV_blank>%d\\n" , //<S2SV> ( int ) str , ( int ) end , ( int ) sstart , ( int ) sprev ) ; //<S2SV> fprintf ( stderr , "size:<S2SV_blank>%d,<S2SV_blank>start<S2SV_blank>offset:<S2SV_blank>%d\\n" , //<S2SV> ( int ) ( end - str ) , ( int ) ( sstart - str ) ) ; //<S2SV> # endif //<S2SV> STACK_PUSH_ENSURED ( STK_ALT , FinishCode ) ; //<S2SV> best_len = ONIG_MISMATCH ; //<S2SV> s = ( UChar * ) sstart ; //<S2SV> while ( 1 ) { //<S2SV> # ifdef ONIG_DEBUG_MATCH //<S2SV> { //<S2SV> UChar * q , * bp , buf [ 50 ] ; //<S2SV> int len ; //<S2SV> fprintf ( stderr , "%4d><S2SV_blank>\\"" , ( int ) ( s - str ) ) ; //<S2SV> bp = buf ; //<S2SV> for ( i = 0 , q = s ; i < 7 && q < end ; i ++ ) { //<S2SV> len = enclen ( encode , q ) ; //<S2SV> while ( len -- > 0 ) * bp ++ = * q ++ ; //<S2SV> } //<S2SV> if ( q < end ) { xmemcpy ( bp , "...\\"" , 4 ) ; bp += 4 ; } //<S2SV> else { xmemcpy ( bp , "\\"" , 1 ) ; bp += 1 ; } //<S2SV> * bp = 0 ; //<S2SV> fputs ( ( char * ) buf , stderr ) ; //<S2SV> for ( i = 0 ; i < 20 - ( bp - buf ) ; i ++ ) fputc ( '<S2SV_blank>' , stderr ) ; //<S2SV> onig_print_compiled_byte_code ( stderr , p , NULL , encode ) ; //<S2SV> fprintf ( stderr , "\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> sbegin = s ; //<S2SV> switch ( * p ++ ) { //<S2SV> case OP_END : MOP_IN ( OP_END ) ; //<S2SV> n = s - sstart ; //<S2SV> if ( n > best_len ) { //<S2SV> OnigRegion * region ; //<S2SV> # ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE //<S2SV> if ( IS_FIND_LONGEST ( option ) ) { //<S2SV> if ( n > msa -> best_len ) { //<S2SV> msa -> best_len = n ; //<S2SV> msa -> best_s = ( UChar * ) sstart ; //<S2SV> } //<S2SV> else //<S2SV> goto end_best_len ; //<S2SV> } //<S2SV> # endif //<S2SV> best_len = n ; //<S2SV> region = msa -> region ; //<S2SV> if ( region ) { //<S2SV> # ifdef USE_POSIX_API_REGION_OPTION //<S2SV> if ( IS_POSIX_REGION ( msa -> options ) ) { //<S2SV> posix_regmatch_t * rmt = ( posix_regmatch_t * ) region ; //<S2SV> rmt [ 0 ] . rm_so = sstart - str ; //<S2SV> rmt [ 0 ] . rm_eo = s - str ; //<S2SV> for ( i = 1 ; i <= num_mem ; i ++ ) { //<S2SV> if ( mem_end_stk [ i ] != INVALID_STACK_INDEX ) { //<S2SV> if ( BIT_STATUS_AT ( reg -> bt_mem_start , i ) ) //<S2SV> rmt [ i ] . rm_so = STACK_AT ( mem_start_stk [ i ] ) -> u . mem . pstr - str ; //<S2SV> else //<S2SV> rmt [ i ] . rm_so = ( UChar * ) ( ( void * ) ( mem_start_stk [ i ] ) ) - str ; //<S2SV> rmt [ i ] . rm_eo = ( BIT_STATUS_AT ( reg -> bt_mem_end , i ) //<S2SV> ? STACK_AT ( mem_end_stk [ i ] ) -> u . mem . pstr //<S2SV> : ( UChar * ) ( ( void * ) mem_end_stk [ i ] ) ) - str ; //<S2SV> } //<S2SV> else { //<S2SV> rmt [ i ] . rm_so = rmt [ i ] . rm_eo = ONIG_REGION_NOTPOS ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> # endif //<S2SV> region -> beg [ 0 ] = sstart - str ; //<S2SV> region -> end [ 0 ] = s - str ; //<S2SV> for ( i = 1 ; i <= num_mem ; i ++ ) { //<S2SV> if ( mem_end_stk [ i ] != INVALID_STACK_INDEX ) { //<S2SV> if ( BIT_STATUS_AT ( reg -> bt_mem_start , i ) ) //<S2SV> region -> beg [ i ] = STACK_AT ( mem_start_stk [ i ] ) -> u . mem . pstr - str ; //<S2SV> else //<S2SV> region -> beg [ i ] = ( UChar * ) ( ( void * ) mem_start_stk [ i ] ) - str ; //<S2SV> region -> end [ i ] = ( BIT_STATUS_AT ( reg -> bt_mem_end , i ) //<S2SV> ? STACK_AT ( mem_end_stk [ i ] ) -> u . mem . pstr //<S2SV> : ( UChar * ) ( ( void * ) mem_end_stk [ i ] ) ) - str ; //<S2SV> } //<S2SV> else { //<S2SV> region -> beg [ i ] = region -> end [ i ] = ONIG_REGION_NOTPOS ; //<S2SV> } //<S2SV> } //<S2SV> # ifdef USE_CAPTURE_HISTORY //<S2SV> if ( reg -> capture_history != 0 ) { //<S2SV> int r ; //<S2SV> OnigCaptureTreeNode * node ; //<S2SV> if ( IS_NULL ( region -> history_root ) ) { //<S2SV> region -> history_root = node = history_node_new ( ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( node ) ; //<S2SV> } //<S2SV> else { //<S2SV> node = region -> history_root ; //<S2SV> history_tree_clear ( node ) ; //<S2SV> } //<S2SV> node -> group = 0 ; //<S2SV> node -> beg = sstart - str ; //<S2SV> node -> end = s - str ; //<S2SV> stkp = stk_base ; //<S2SV> r = make_capture_history_tree ( region -> history_root , & stkp , //<S2SV> stk , ( UChar * ) str , reg ) ; //<S2SV> if ( r < 0 ) { //<S2SV> best_len = r ; //<S2SV> goto finish ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef USE_POSIX_API_REGION_OPTION //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> # ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE //<S2SV> end_best_len : //<S2SV> # endif //<S2SV> MOP_OUT ; //<S2SV> if ( IS_FIND_CONDITION ( option ) ) { //<S2SV> if ( IS_FIND_NOT_EMPTY ( option ) && s == sstart ) { //<S2SV> best_len = ONIG_MISMATCH ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( IS_FIND_LONGEST ( option ) && DATA_ENSURE_CHECK1 ) { //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> goto finish ; //<S2SV> break ; //<S2SV> case OP_EXACT1 : MOP_IN ( OP_EXACT1 ) ; //<S2SV> # if 0 //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> # endif //<S2SV> if ( * p != * s ++ ) goto fail ; //<S2SV> DATA_ENSURE ( 0 ) ; //<S2SV> p ++ ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_EXACT1_IC : MOP_IN ( OP_EXACT1_IC ) ; //<S2SV> { //<S2SV> int len ; //<S2SV> UChar * q , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> len = ONIGENC_MBC_CASE_FOLD ( encode , //<S2SV> case_fold_flag , //<S2SV> & s , end , lowbuf ) ; //<S2SV> DATA_ENSURE ( 0 ) ; //<S2SV> q = lowbuf ; //<S2SV> while ( len -- > 0 ) { //<S2SV> if ( * p != * q ) { //<S2SV> goto fail ; //<S2SV> } //<S2SV> p ++ ; q ++ ; //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_EXACT2 : MOP_IN ( OP_EXACT2 ) ; //<S2SV> DATA_ENSURE ( 2 ) ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> sprev = s ; //<S2SV> p ++ ; s ++ ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACT3 : MOP_IN ( OP_EXACT3 ) ; //<S2SV> DATA_ENSURE ( 3 ) ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> sprev = s ; //<S2SV> p ++ ; s ++ ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACT4 : MOP_IN ( OP_EXACT4 ) ; //<S2SV> DATA_ENSURE ( 4 ) ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> sprev = s ; //<S2SV> p ++ ; s ++ ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACT5 : MOP_IN ( OP_EXACT5 ) ; //<S2SV> DATA_ENSURE ( 5 ) ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> sprev = s ; //<S2SV> p ++ ; s ++ ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACTN : MOP_IN ( OP_EXACTN ) ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> DATA_ENSURE ( tlen ) ; //<S2SV> while ( tlen -- > 0 ) { //<S2SV> if ( * p ++ != * s ++ ) goto fail ; //<S2SV> } //<S2SV> sprev = s - 1 ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACTN_IC : MOP_IN ( OP_EXACTN_IC ) ; //<S2SV> { //<S2SV> int len ; //<S2SV> UChar * q , * endp , lowbuf [ ONIGENC_MBC_CASE_FOLD_MAXLEN ] ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> endp = p + tlen ; //<S2SV> while ( p < endp ) { //<S2SV> sprev = s ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> len = ONIGENC_MBC_CASE_FOLD ( encode , //<S2SV> case_fold_flag , //<S2SV> & s , end , lowbuf ) ; //<S2SV> DATA_ENSURE ( 0 ) ; //<S2SV> q = lowbuf ; //<S2SV> while ( len -- > 0 ) { //<S2SV> if ( * p != * q ) goto fail ; //<S2SV> p ++ ; q ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACTMB2N1 : MOP_IN ( OP_EXACTMB2N1 ) ; //<S2SV> DATA_ENSURE ( 2 ) ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_EXACTMB2N2 : MOP_IN ( OP_EXACTMB2N2 ) ; //<S2SV> DATA_ENSURE ( 4 ) ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> sprev = s ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACTMB2N3 : MOP_IN ( OP_EXACTMB2N3 ) ; //<S2SV> DATA_ENSURE ( 6 ) ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> sprev = s ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACTMB2N : MOP_IN ( OP_EXACTMB2N ) ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> DATA_ENSURE ( tlen * 2 ) ; //<S2SV> while ( tlen -- > 0 ) { //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> } //<S2SV> sprev = s - 2 ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACTMB3N : MOP_IN ( OP_EXACTMB3N ) ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> DATA_ENSURE ( tlen * 3 ) ; //<S2SV> while ( tlen -- > 0 ) { //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> } //<S2SV> sprev = s - 3 ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_EXACTMBN : MOP_IN ( OP_EXACTMBN ) ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> GET_LENGTH_INC ( tlen2 , p ) ; //<S2SV> tlen2 *= tlen ; //<S2SV> DATA_ENSURE ( tlen2 ) ; //<S2SV> while ( tlen2 -- > 0 ) { //<S2SV> if ( * p != * s ) goto fail ; //<S2SV> p ++ ; s ++ ; //<S2SV> } //<S2SV> sprev = s - tlen ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_CCLASS : MOP_IN ( OP_CCLASS ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) == 0 ) goto fail ; //<S2SV> p += SIZE_BITSET ; //<S2SV> s += enclen ( encode , s ) ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_CCLASS_MB : MOP_IN ( OP_CCLASS_MB ) ; //<S2SV> if ( ! ONIGENC_IS_MBC_HEAD ( encode , s ) ) goto fail ; //<S2SV> cclass_mb : //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> { //<S2SV> OnigCodePoint code ; //<S2SV> UChar * ss ; //<S2SV> int mb_len ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> mb_len = enclen ( encode , s ) ; //<S2SV> DATA_ENSURE ( mb_len ) ; //<S2SV> ss = s ; //<S2SV> s += mb_len ; //<S2SV> code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; //<S2SV> # ifdef PLATFORM_UNALIGNED_WORD_ACCESS //<S2SV> if ( ! onig_is_in_code_range ( p , code ) ) goto fail ; //<S2SV> # else //<S2SV> q = p ; //<S2SV> ALIGNMENT_RIGHT ( q ) ; //<S2SV> if ( ! onig_is_in_code_range ( q , code ) ) goto fail ; //<S2SV> # endif //<S2SV> } //<S2SV> p += tlen ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_CCLASS_MIX : MOP_IN ( OP_CCLASS_MIX ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( ONIGENC_IS_MBC_HEAD ( encode , s ) ) { //<S2SV> p += SIZE_BITSET ; //<S2SV> goto cclass_mb ; //<S2SV> } //<S2SV> else { //<S2SV> if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) == 0 ) //<S2SV> goto fail ; //<S2SV> p += SIZE_BITSET ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> p += tlen ; //<S2SV> s ++ ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_CCLASS_NOT : MOP_IN ( OP_CCLASS_NOT ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) != 0 ) goto fail ; //<S2SV> p += SIZE_BITSET ; //<S2SV> s += enclen ( encode , s ) ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_CCLASS_MB_NOT : MOP_IN ( OP_CCLASS_MB_NOT ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( ! ONIGENC_IS_MBC_HEAD ( encode , s ) ) { //<S2SV> s ++ ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> p += tlen ; //<S2SV> goto cc_mb_not_success ; //<S2SV> } //<S2SV> cclass_mb_not : //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> { //<S2SV> OnigCodePoint code ; //<S2SV> UChar * ss ; //<S2SV> int mb_len = enclen ( encode , s ) ; //<S2SV> if ( ! DATA_ENSURE_CHECK ( mb_len ) ) { //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> s = ( UChar * ) end ; //<S2SV> p += tlen ; //<S2SV> goto cc_mb_not_success ; //<S2SV> } //<S2SV> ss = s ; //<S2SV> s += mb_len ; //<S2SV> code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; //<S2SV> # ifdef PLATFORM_UNALIGNED_WORD_ACCESS //<S2SV> if ( onig_is_in_code_range ( p , code ) ) goto fail ; //<S2SV> # else //<S2SV> q = p ; //<S2SV> ALIGNMENT_RIGHT ( q ) ; //<S2SV> if ( onig_is_in_code_range ( q , code ) ) goto fail ; //<S2SV> # endif //<S2SV> } //<S2SV> p += tlen ; //<S2SV> cc_mb_not_success : //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_CCLASS_MIX_NOT : MOP_IN ( OP_CCLASS_MIX_NOT ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( ONIGENC_IS_MBC_HEAD ( encode , s ) ) { //<S2SV> p += SIZE_BITSET ; //<S2SV> goto cclass_mb_not ; //<S2SV> } //<S2SV> else { //<S2SV> if ( BITSET_AT ( ( ( BitSetRef ) p ) , * s ) != 0 ) //<S2SV> goto fail ; //<S2SV> p += SIZE_BITSET ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> p += tlen ; //<S2SV> s ++ ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_CCLASS_NODE : MOP_IN ( OP_CCLASS_NODE ) ; //<S2SV> { //<S2SV> OnigCodePoint code ; //<S2SV> void * node ; //<S2SV> int mb_len ; //<S2SV> UChar * ss ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> GET_POINTER_INC ( node , p ) ; //<S2SV> mb_len = enclen ( encode , s ) ; //<S2SV> ss = s ; //<S2SV> s += mb_len ; //<S2SV> DATA_ENSURE ( 0 ) ; //<S2SV> code = ONIGENC_MBC_TO_CODE ( encode , ss , s ) ; //<S2SV> if ( onig_is_code_in_cc_len ( mb_len , code , node ) == 0 ) goto fail ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_ANYCHAR : MOP_IN ( OP_ANYCHAR ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> n = enclen ( encode , s ) ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; //<S2SV> s += n ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_ANYCHAR_ML : MOP_IN ( OP_ANYCHAR_ML ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> n = enclen ( encode , s ) ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> s += n ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_ANYCHAR_STAR : MOP_IN ( OP_ANYCHAR_STAR ) ; //<S2SV> while ( DATA_ENSURE_CHECK1 ) { //<S2SV> STACK_PUSH_ALT ( p , s , sprev ) ; //<S2SV> n = enclen ( encode , s ) ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; //<S2SV> sprev = s ; //<S2SV> s += n ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_ANYCHAR_ML_STAR : MOP_IN ( OP_ANYCHAR_ML_STAR ) ; //<S2SV> while ( DATA_ENSURE_CHECK1 ) { //<S2SV> STACK_PUSH_ALT ( p , s , sprev ) ; //<S2SV> n = enclen ( encode , s ) ; //<S2SV> if ( n > 1 ) { //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> sprev = s ; //<S2SV> s += n ; //<S2SV> } //<S2SV> else { //<S2SV> sprev = s ; //<S2SV> s ++ ; //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_ANYCHAR_STAR_PEEK_NEXT : MOP_IN ( OP_ANYCHAR_STAR_PEEK_NEXT ) ; //<S2SV> while ( DATA_ENSURE_CHECK1 ) { //<S2SV> if ( * p == * s ) { //<S2SV> STACK_PUSH_ALT ( p + 1 , s , sprev ) ; //<S2SV> } //<S2SV> n = enclen ( encode , s ) ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; //<S2SV> sprev = s ; //<S2SV> s += n ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_ANYCHAR_ML_STAR_PEEK_NEXT : MOP_IN ( OP_ANYCHAR_ML_STAR_PEEK_NEXT ) ; //<S2SV> while ( DATA_ENSURE_CHECK1 ) { //<S2SV> if ( * p == * s ) { //<S2SV> STACK_PUSH_ALT ( p + 1 , s , sprev ) ; //<S2SV> } //<S2SV> n = enclen ( encode , s ) ; //<S2SV> if ( n > 1 ) { //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> sprev = s ; //<S2SV> s += n ; //<S2SV> } //<S2SV> else { //<S2SV> sprev = s ; //<S2SV> s ++ ; //<S2SV> } //<S2SV> } //<S2SV> p ++ ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> # ifdef USE_COMBINATION_EXPLOSION_CHECK //<S2SV> case OP_STATE_CHECK_ANYCHAR_STAR : MOP_IN ( OP_STATE_CHECK_ANYCHAR_STAR ) ; //<S2SV> GET_STATE_CHECK_NUM_INC ( mem , p ) ; //<S2SV> while ( DATA_ENSURE_CHECK1 ) { //<S2SV> STATE_CHECK_VAL ( scv , mem ) ; //<S2SV> if ( scv ) goto fail ; //<S2SV> STACK_PUSH_ALT_WITH_STATE_CHECK ( p , s , sprev , mem ) ; //<S2SV> n = enclen ( encode , s ) ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) goto fail ; //<S2SV> sprev = s ; //<S2SV> s += n ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_STATE_CHECK_ANYCHAR_ML_STAR : //<S2SV> MOP_IN ( OP_STATE_CHECK_ANYCHAR_ML_STAR ) ; //<S2SV> GET_STATE_CHECK_NUM_INC ( mem , p ) ; //<S2SV> while ( DATA_ENSURE_CHECK1 ) { //<S2SV> STATE_CHECK_VAL ( scv , mem ) ; //<S2SV> if ( scv ) goto fail ; //<S2SV> STACK_PUSH_ALT_WITH_STATE_CHECK ( p , s , sprev , mem ) ; //<S2SV> n = enclen ( encode , s ) ; //<S2SV> if ( n > 1 ) { //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> sprev = s ; //<S2SV> s += n ; //<S2SV> } //<S2SV> else { //<S2SV> sprev = s ; //<S2SV> s ++ ; //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case OP_WORD : MOP_IN ( OP_WORD ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) //<S2SV> goto fail ; //<S2SV> s += enclen ( encode , s ) ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_NOT_WORD : MOP_IN ( OP_NOT_WORD ) ; //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) ) //<S2SV> goto fail ; //<S2SV> s += enclen ( encode , s ) ; //<S2SV> MOP_OUT ; //<S2SV> break ; //<S2SV> case OP_WORD_BOUND : MOP_IN ( OP_WORD_BOUND ) ; //<S2SV> if ( ON_STR_BEGIN ( s ) ) { //<S2SV> DATA_ENSURE ( 1 ) ; //<S2SV> if ( ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> else if ( ON_STR_END ( s ) ) { //<S2SV> if ( ! ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> else { //<S2SV> if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) //<S2SV> == ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_NOT_WORD_BOUND : MOP_IN ( OP_NOT_WORD_BOUND ) ; //<S2SV> if ( ON_STR_BEGIN ( s ) ) { //<S2SV> if ( DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD ( encode , s , end ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> else if ( ON_STR_END ( s ) ) { //<S2SV> if ( ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> else { //<S2SV> if ( ONIGENC_IS_MBC_WORD ( encode , s , end ) //<S2SV> != ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # ifdef USE_WORD_BEGIN_END //<S2SV> case OP_WORD_BEGIN : MOP_IN ( OP_WORD_BEGIN ) ; //<S2SV> if ( DATA_ENSURE_CHECK1 && ONIGENC_IS_MBC_WORD ( encode , s , end ) ) { //<S2SV> if ( ON_STR_BEGIN ( s ) || ! ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) { //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case OP_WORD_END : MOP_IN ( OP_WORD_END ) ; //<S2SV> if ( ! ON_STR_BEGIN ( s ) && ONIGENC_IS_MBC_WORD ( encode , sprev , end ) ) { //<S2SV> if ( ON_STR_END ( s ) || ! ONIGENC_IS_MBC_WORD ( encode , s , end ) ) { //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case OP_BEGIN_BUF : MOP_IN ( OP_BEGIN_BUF ) ; //<S2SV> if ( ! ON_STR_BEGIN ( s ) ) goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_END_BUF : MOP_IN ( OP_END_BUF ) ; //<S2SV> if ( ! ON_STR_END ( s ) ) goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_BEGIN_LINE : MOP_IN ( OP_BEGIN_LINE ) ; //<S2SV> if ( ON_STR_BEGIN ( s ) ) { //<S2SV> if ( IS_NOTBOL ( msa -> options ) ) goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> else if ( ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) && ! ON_STR_END ( s ) ) { //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case OP_END_LINE : MOP_IN ( OP_END_LINE ) ; //<S2SV> if ( ON_STR_END ( s ) ) { //<S2SV> # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE //<S2SV> if ( IS_EMPTY_STR || ! ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) ) { //<S2SV> # endif //<S2SV> if ( IS_NOTEOL ( msa -> options ) ) goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> else if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) ) { //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> # ifdef USE_CRNL_AS_LINE_TERMINATOR //<S2SV> else if ( ONIGENC_IS_MBC_CRNL ( encode , s , end ) ) { //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> # endif //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case OP_SEMI_END_BUF : MOP_IN ( OP_SEMI_END_BUF ) ; //<S2SV> if ( ON_STR_END ( s ) ) { //<S2SV> # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE //<S2SV> if ( IS_EMPTY_STR || ! ONIGENC_IS_MBC_NEWLINE ( encode , sprev , end ) ) { //<S2SV> # endif //<S2SV> if ( IS_NOTEOL ( msa -> options ) ) goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> else if ( ONIGENC_IS_MBC_NEWLINE ( encode , s , end ) && //<S2SV> ON_STR_END ( s + enclen ( encode , s ) ) ) { //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> # ifdef USE_CRNL_AS_LINE_TERMINATOR //<S2SV> else if ( ONIGENC_IS_MBC_CRNL ( encode , s , end ) ) { //<S2SV> UChar * ss = s + enclen ( encode , s ) ; //<S2SV> ss += enclen ( encode , ss ) ; //<S2SV> if ( ON_STR_END ( ss ) ) { //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case OP_BEGIN_POSITION : MOP_IN ( OP_BEGIN_POSITION ) ; //<S2SV> if ( s != msa -> start ) //<S2SV> goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_MEMORY_START_PUSH : MOP_IN ( OP_MEMORY_START_PUSH ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> STACK_PUSH_MEM_START ( mem , s ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_MEMORY_START : MOP_IN ( OP_MEMORY_START ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> mem_start_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_MEMORY_END_PUSH : MOP_IN ( OP_MEMORY_END_PUSH ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> STACK_PUSH_MEM_END ( mem , s ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_MEMORY_END : MOP_IN ( OP_MEMORY_END ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> mem_end_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # ifdef USE_SUBEXP_CALL //<S2SV> case OP_MEMORY_END_PUSH_REC : MOP_IN ( OP_MEMORY_END_PUSH_REC ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> STACK_GET_MEM_START ( mem , stkp ) ; //<S2SV> STACK_PUSH_MEM_END ( mem , s ) ; //<S2SV> mem_start_stk [ mem ] = GET_STACK_INDEX ( stkp ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_MEMORY_END_REC : MOP_IN ( OP_MEMORY_END_REC ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> mem_end_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) s ) ; //<S2SV> STACK_GET_MEM_START ( mem , stkp ) ; //<S2SV> if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) //<S2SV> mem_start_stk [ mem ] = GET_STACK_INDEX ( stkp ) ; //<S2SV> else //<S2SV> mem_start_stk [ mem ] = ( OnigStackIndex ) ( ( void * ) stkp -> u . mem . pstr ) ; //<S2SV> STACK_PUSH_MEM_END_MARK ( mem ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case OP_BACKREF1 : MOP_IN ( OP_BACKREF1 ) ; //<S2SV> mem = 1 ; //<S2SV> goto backref ; //<S2SV> break ; //<S2SV> case OP_BACKREF2 : MOP_IN ( OP_BACKREF2 ) ; //<S2SV> mem = 2 ; //<S2SV> goto backref ; //<S2SV> break ; //<S2SV> case OP_BACKREFN : MOP_IN ( OP_BACKREFN ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> backref : //<S2SV> { //<S2SV> int len ; //<S2SV> UChar * pstart , * pend ; //<S2SV> if ( mem > num_mem ) goto fail ; //<S2SV> if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; //<S2SV> if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; //<S2SV> if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) //<S2SV> pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; //<S2SV> else //<S2SV> pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; //<S2SV> pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) //<S2SV> ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr //<S2SV> : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; //<S2SV> n = pend - pstart ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> sprev = s ; //<S2SV> STRING_CMP ( pstart , s , n ) ; //<S2SV> while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) //<S2SV> sprev += len ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> break ; //<S2SV> case OP_BACKREFN_IC : MOP_IN ( OP_BACKREFN_IC ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> { //<S2SV> int len ; //<S2SV> UChar * pstart , * pend ; //<S2SV> if ( mem > num_mem ) goto fail ; //<S2SV> if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; //<S2SV> if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) goto fail ; //<S2SV> if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) //<S2SV> pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; //<S2SV> else //<S2SV> pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; //<S2SV> pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) //<S2SV> ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr //<S2SV> : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; //<S2SV> n = pend - pstart ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> sprev = s ; //<S2SV> STRING_CMP_IC ( case_fold_flag , pstart , & s , n ) ; //<S2SV> while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) //<S2SV> sprev += len ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> break ; //<S2SV> case OP_BACKREF_MULTI : MOP_IN ( OP_BACKREF_MULTI ) ; //<S2SV> { //<S2SV> int len , is_fail ; //<S2SV> UChar * pstart , * pend , * swork ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> for ( i = 0 ; i < tlen ; i ++ ) { //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) continue ; //<S2SV> if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) continue ; //<S2SV> if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) //<S2SV> pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; //<S2SV> else //<S2SV> pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; //<S2SV> pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) //<S2SV> ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr //<S2SV> : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; //<S2SV> n = pend - pstart ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> sprev = s ; //<S2SV> swork = s ; //<S2SV> STRING_CMP_VALUE ( pstart , swork , n , is_fail ) ; //<S2SV> if ( is_fail ) continue ; //<S2SV> s = swork ; //<S2SV> while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) //<S2SV> sprev += len ; //<S2SV> p += ( SIZE_MEMNUM * ( tlen - i - 1 ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( i == tlen ) goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> break ; //<S2SV> case OP_BACKREF_MULTI_IC : MOP_IN ( OP_BACKREF_MULTI_IC ) ; //<S2SV> { //<S2SV> int len , is_fail ; //<S2SV> UChar * pstart , * pend , * swork ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> for ( i = 0 ; i < tlen ; i ++ ) { //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> if ( mem_end_stk [ mem ] == INVALID_STACK_INDEX ) continue ; //<S2SV> if ( mem_start_stk [ mem ] == INVALID_STACK_INDEX ) continue ; //<S2SV> if ( BIT_STATUS_AT ( reg -> bt_mem_start , mem ) ) //<S2SV> pstart = STACK_AT ( mem_start_stk [ mem ] ) -> u . mem . pstr ; //<S2SV> else //<S2SV> pstart = ( UChar * ) ( ( void * ) mem_start_stk [ mem ] ) ; //<S2SV> pend = ( BIT_STATUS_AT ( reg -> bt_mem_end , mem ) //<S2SV> ? STACK_AT ( mem_end_stk [ mem ] ) -> u . mem . pstr //<S2SV> : ( UChar * ) ( ( void * ) mem_end_stk [ mem ] ) ) ; //<S2SV> n = pend - pstart ; //<S2SV> DATA_ENSURE ( n ) ; //<S2SV> sprev = s ; //<S2SV> swork = s ; //<S2SV> STRING_CMP_VALUE_IC ( case_fold_flag , pstart , & swork , n , is_fail ) ; //<S2SV> if ( is_fail ) continue ; //<S2SV> s = swork ; //<S2SV> while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) //<S2SV> sprev += len ; //<S2SV> p += ( SIZE_MEMNUM * ( tlen - i - 1 ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( i == tlen ) goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> break ; //<S2SV> # ifdef USE_BACKREF_WITH_LEVEL //<S2SV> case OP_BACKREF_WITH_LEVEL : //<S2SV> { //<S2SV> int len ; //<S2SV> OnigOptionType ic ; //<S2SV> LengthType level ; //<S2SV> GET_OPTION_INC ( ic , p ) ; //<S2SV> GET_LENGTH_INC ( level , p ) ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> sprev = s ; //<S2SV> if ( backref_match_at_nested_level ( reg , stk , stk_base , ic //<S2SV> , case_fold_flag , ( int ) level , ( int ) tlen , p , & s , end ) ) { //<S2SV> while ( sprev + ( len = enclen ( encode , sprev ) ) < s ) //<S2SV> sprev += len ; //<S2SV> p += ( SIZE_MEMNUM * tlen ) ; //<S2SV> } //<S2SV> else //<S2SV> goto fail ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> break ; //<S2SV> # endif //<S2SV> # if 0 //<S2SV> case OP_SET_OPTION_PUSH : MOP_IN ( OP_SET_OPTION_PUSH ) ; //<S2SV> GET_OPTION_INC ( option , p ) ; //<S2SV> STACK_PUSH_ALT ( p , s , sprev ) ; //<S2SV> p += SIZE_OP_SET_OPTION + SIZE_OP_FAIL ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_SET_OPTION : MOP_IN ( OP_SET_OPTION ) ; //<S2SV> GET_OPTION_INC ( option , p ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case OP_NULL_CHECK_START : MOP_IN ( OP_NULL_CHECK_START ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> STACK_PUSH_NULL_CHECK_START ( mem , s ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_NULL_CHECK_END : MOP_IN ( OP_NULL_CHECK_END ) ; //<S2SV> { //<S2SV> int isnull ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> STACK_NULL_CHECK ( isnull , mem , s ) ; //<S2SV> if ( isnull ) { //<S2SV> # ifdef ONIG_DEBUG_MATCH //<S2SV> fprintf ( stderr , "NULL_CHECK_END:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n" , //<S2SV> ( int ) mem , ( int ) s ) ; //<S2SV> # endif //<S2SV> null_check_found : //<S2SV> switch ( * p ++ ) { //<S2SV> case OP_JUMP : //<S2SV> case OP_PUSH : //<S2SV> p += SIZE_RELADDR ; //<S2SV> break ; //<S2SV> case OP_REPEAT_INC : //<S2SV> case OP_REPEAT_INC_NG : //<S2SV> case OP_REPEAT_INC_SG : //<S2SV> case OP_REPEAT_INC_NG_SG : //<S2SV> p += SIZE_MEMNUM ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto unexpected_bytecode_error ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT //<S2SV> case OP_NULL_CHECK_END_MEMST : MOP_IN ( OP_NULL_CHECK_END_MEMST ) ; //<S2SV> { //<S2SV> int isnull ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> STACK_NULL_CHECK_MEMST ( isnull , mem , s , reg ) ; //<S2SV> if ( isnull ) { //<S2SV> # ifdef ONIG_DEBUG_MATCH //<S2SV> fprintf ( stderr , "NULL_CHECK_END_MEMST:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n" , //<S2SV> ( int ) mem , ( int ) s ) ; //<S2SV> # endif //<S2SV> if ( isnull == - 1 ) goto fail ; //<S2SV> goto null_check_found ; //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef USE_SUBEXP_CALL //<S2SV> case OP_NULL_CHECK_END_MEMST_PUSH : //<S2SV> MOP_IN ( OP_NULL_CHECK_END_MEMST_PUSH ) ; //<S2SV> { //<S2SV> int isnull ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> # ifdef USE_MONOMANIAC_CHECK_CAPTURES_IN_ENDLESS_REPEAT //<S2SV> STACK_NULL_CHECK_MEMST_REC ( isnull , mem , s , reg ) ; //<S2SV> # else //<S2SV> STACK_NULL_CHECK_REC ( isnull , mem , s ) ; //<S2SV> # endif //<S2SV> if ( isnull ) { //<S2SV> # ifdef ONIG_DEBUG_MATCH //<S2SV> fprintf ( stderr , "NULL_CHECK_END_MEMST_PUSH:<S2SV_blank>skip<S2SV_blank><S2SV_blank>id:%d,<S2SV_blank>s:%d\\n" , //<S2SV> ( int ) mem , ( int ) s ) ; //<S2SV> # endif //<S2SV> if ( isnull == - 1 ) goto fail ; //<S2SV> goto null_check_found ; //<S2SV> } //<S2SV> else { //<S2SV> STACK_PUSH_NULL_CHECK_END ( mem ) ; //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case OP_JUMP : MOP_IN ( OP_JUMP ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> p += addr ; //<S2SV> MOP_OUT ; //<S2SV> CHECK_INTERRUPT_IN_MATCH_AT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_PUSH : MOP_IN ( OP_PUSH ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> STACK_PUSH_ALT ( p + addr , s , sprev ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # ifdef USE_COMBINATION_EXPLOSION_CHECK //<S2SV> case OP_STATE_CHECK_PUSH : MOP_IN ( OP_STATE_CHECK_PUSH ) ; //<S2SV> GET_STATE_CHECK_NUM_INC ( mem , p ) ; //<S2SV> STATE_CHECK_VAL ( scv , mem ) ; //<S2SV> if ( scv ) goto fail ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> STACK_PUSH_ALT_WITH_STATE_CHECK ( p + addr , s , sprev , mem ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_STATE_CHECK_PUSH_OR_JUMP : MOP_IN ( OP_STATE_CHECK_PUSH_OR_JUMP ) ; //<S2SV> GET_STATE_CHECK_NUM_INC ( mem , p ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> STATE_CHECK_VAL ( scv , mem ) ; //<S2SV> if ( scv ) { //<S2SV> p += addr ; //<S2SV> } //<S2SV> else { //<S2SV> STACK_PUSH_ALT_WITH_STATE_CHECK ( p + addr , s , sprev , mem ) ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_STATE_CHECK : MOP_IN ( OP_STATE_CHECK ) ; //<S2SV> GET_STATE_CHECK_NUM_INC ( mem , p ) ; //<S2SV> STATE_CHECK_VAL ( scv , mem ) ; //<S2SV> if ( scv ) goto fail ; //<S2SV> STACK_PUSH_STATE_CHECK ( s , mem ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case OP_POP : MOP_IN ( OP_POP ) ; //<S2SV> STACK_POP_ONE ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_PUSH_OR_JUMP_EXACT1 : MOP_IN ( OP_PUSH_OR_JUMP_EXACT1 ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> if ( * p == * s && DATA_ENSURE_CHECK1 ) { //<S2SV> p ++ ; //<S2SV> STACK_PUSH_ALT ( p + addr , s , sprev ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> p += ( addr + 1 ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_PUSH_IF_PEEK_NEXT : MOP_IN ( OP_PUSH_IF_PEEK_NEXT ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> if ( * p == * s ) { //<S2SV> p ++ ; //<S2SV> STACK_PUSH_ALT ( p + addr , s , sprev ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> } //<S2SV> p ++ ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_REPEAT : MOP_IN ( OP_REPEAT ) ; //<S2SV> { //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> STACK_ENSURE ( 1 ) ; //<S2SV> repeat_stk [ mem ] = GET_STACK_INDEX ( stk ) ; //<S2SV> STACK_PUSH_REPEAT ( mem , p ) ; //<S2SV> if ( reg -> repeat_range [ mem ] . lower == 0 ) { //<S2SV> STACK_PUSH_ALT ( p + addr , s , sprev ) ; //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_REPEAT_NG : MOP_IN ( OP_REPEAT_NG ) ; //<S2SV> { //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> STACK_ENSURE ( 1 ) ; //<S2SV> repeat_stk [ mem ] = GET_STACK_INDEX ( stk ) ; //<S2SV> STACK_PUSH_REPEAT ( mem , p ) ; //<S2SV> if ( reg -> repeat_range [ mem ] . lower == 0 ) { //<S2SV> STACK_PUSH_ALT ( p , s , sprev ) ; //<S2SV> p += addr ; //<S2SV> } //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_REPEAT_INC : MOP_IN ( OP_REPEAT_INC ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> si = repeat_stk [ mem ] ; //<S2SV> stkp = STACK_AT ( si ) ; //<S2SV> repeat_inc : //<S2SV> stkp -> u . repeat . count ++ ; //<S2SV> if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . upper ) { //<S2SV> } //<S2SV> else if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . lower ) { //<S2SV> STACK_PUSH_ALT ( p , s , sprev ) ; //<S2SV> p = STACK_AT ( si ) -> u . repeat . pcode ; //<S2SV> } //<S2SV> else { //<S2SV> p = stkp -> u . repeat . pcode ; //<S2SV> } //<S2SV> STACK_PUSH_REPEAT_INC ( si ) ; //<S2SV> MOP_OUT ; //<S2SV> CHECK_INTERRUPT_IN_MATCH_AT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_REPEAT_INC_SG : MOP_IN ( OP_REPEAT_INC_SG ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> STACK_GET_REPEAT ( mem , stkp ) ; //<S2SV> si = GET_STACK_INDEX ( stkp ) ; //<S2SV> goto repeat_inc ; //<S2SV> break ; //<S2SV> case OP_REPEAT_INC_NG : MOP_IN ( OP_REPEAT_INC_NG ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> si = repeat_stk [ mem ] ; //<S2SV> stkp = STACK_AT ( si ) ; //<S2SV> repeat_inc_ng : //<S2SV> stkp -> u . repeat . count ++ ; //<S2SV> if ( stkp -> u . repeat . count < reg -> repeat_range [ mem ] . upper ) { //<S2SV> if ( stkp -> u . repeat . count >= reg -> repeat_range [ mem ] . lower ) { //<S2SV> UChar * pcode = stkp -> u . repeat . pcode ; //<S2SV> STACK_PUSH_REPEAT_INC ( si ) ; //<S2SV> STACK_PUSH_ALT ( pcode , s , sprev ) ; //<S2SV> } //<S2SV> else { //<S2SV> p = stkp -> u . repeat . pcode ; //<S2SV> STACK_PUSH_REPEAT_INC ( si ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( stkp -> u . repeat . count == reg -> repeat_range [ mem ] . upper ) { //<S2SV> STACK_PUSH_REPEAT_INC ( si ) ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> CHECK_INTERRUPT_IN_MATCH_AT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_REPEAT_INC_NG_SG : MOP_IN ( OP_REPEAT_INC_NG_SG ) ; //<S2SV> GET_MEMNUM_INC ( mem , p ) ; //<S2SV> STACK_GET_REPEAT ( mem , stkp ) ; //<S2SV> si = GET_STACK_INDEX ( stkp ) ; //<S2SV> goto repeat_inc_ng ; //<S2SV> break ; //<S2SV> case OP_PUSH_POS : MOP_IN ( OP_PUSH_POS ) ; //<S2SV> STACK_PUSH_POS ( s , sprev ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_POP_POS : MOP_IN ( OP_POP_POS ) ; //<S2SV> { //<S2SV> STACK_POS_END ( stkp ) ; //<S2SV> s = stkp -> u . state . pstr ; //<S2SV> sprev = stkp -> u . state . pstr_prev ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_PUSH_POS_NOT : MOP_IN ( OP_PUSH_POS_NOT ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> STACK_PUSH_POS_NOT ( p + addr , s , sprev ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_FAIL_POS : MOP_IN ( OP_FAIL_POS ) ; //<S2SV> STACK_POP_TIL_POS_NOT ; //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> case OP_PUSH_STOP_BT : MOP_IN ( OP_PUSH_STOP_BT ) ; //<S2SV> STACK_PUSH_STOP_BT ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_POP_STOP_BT : MOP_IN ( OP_POP_STOP_BT ) ; //<S2SV> STACK_STOP_BT_END ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_LOOK_BEHIND : MOP_IN ( OP_LOOK_BEHIND ) ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> s = ( UChar * ) ONIGENC_STEP_BACK ( encode , str , s , ( int ) tlen ) ; //<S2SV> if ( IS_NULL ( s ) ) goto fail ; //<S2SV> sprev = ( UChar * ) onigenc_get_prev_char_head ( encode , str , s ) ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_PUSH_LOOK_BEHIND_NOT : MOP_IN ( OP_PUSH_LOOK_BEHIND_NOT ) ; //<S2SV> GET_RELADDR_INC ( addr , p ) ; //<S2SV> GET_LENGTH_INC ( tlen , p ) ; //<S2SV> q = ( UChar * ) ONIGENC_STEP_BACK ( encode , str , s , ( int ) tlen ) ; //<S2SV> if ( IS_NULL ( q ) ) { //<S2SV> p += addr ; //<S2SV> } //<S2SV> else { //<S2SV> STACK_PUSH_LOOK_BEHIND_NOT ( p + addr , s , sprev ) ; //<S2SV> s = q ; //<S2SV> sprev = ( UChar * ) onigenc_get_prev_char_head ( encode , str , s ) ; //<S2SV> } //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_FAIL_LOOK_BEHIND_NOT : MOP_IN ( OP_FAIL_LOOK_BEHIND_NOT ) ; //<S2SV> STACK_POP_TIL_LOOK_BEHIND_NOT ; //<S2SV> goto fail ; //<S2SV> break ; //<S2SV> # ifdef USE_SUBEXP_CALL //<S2SV> case OP_CALL : MOP_IN ( OP_CALL ) ; //<S2SV> GET_ABSADDR_INC ( addr , p ) ; //<S2SV> STACK_PUSH_CALL_FRAME ( p ) ; //<S2SV> p = reg -> p + addr ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> case OP_RETURN : MOP_IN ( OP_RETURN ) ; //<S2SV> STACK_RETURN ( p ) ; //<S2SV> STACK_PUSH_RETURN ; //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case OP_FINISH : //<S2SV> goto finish ; //<S2SV> break ; //<S2SV> fail : //<S2SV> MOP_OUT ; //<S2SV> case OP_FAIL : MOP_IN ( OP_FAIL ) ; //<S2SV> STACK_POP ; //<S2SV> p = stk -> u . state . pcode ; //<S2SV> s = stk -> u . state . pstr ; //<S2SV> sprev = stk -> u . state . pstr_prev ; //<S2SV> # ifdef USE_COMBINATION_EXPLOSION_CHECK //<S2SV> if ( stk -> u . state . state_check != 0 ) { //<S2SV> stk -> type = STK_STATE_CHECK_MARK ; //<S2SV> stk ++ ; //<S2SV> } //<S2SV> # endif //<S2SV> MOP_OUT ; //<S2SV> continue ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto bytecode_error ; //<S2SV> } //<S2SV> sprev = sbegin ; //<S2SV> } //<S2SV> finish : //<S2SV> STACK_SAVE ; //<S2SV> return best_len ; //<S2SV> # ifdef ONIG_DEBUG //<S2SV> stack_error : //<S2SV> STACK_SAVE ; //<S2SV> return ONIGERR_STACK_BUG ; //<S2SV> # endif //<S2SV> bytecode_error : //<S2SV> STACK_SAVE ; //<S2SV> return ONIGERR_UNDEFINED_BYTECODE ; //<S2SV> unexpected_bytecode_error : //<S2SV> STACK_SAVE ; //<S2SV> return ONIGERR_UNEXPECTED_BYTECODE ; //<S2SV> } //<S2SV> 