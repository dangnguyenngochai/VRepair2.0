static int //<S2SV> forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , //<S2SV> UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) //<S2SV> { //<S2SV> UChar * p , * pprev = ( UChar * ) NULL ; //<S2SV> # ifdef ONIG_DEBUG_SEARCH //<S2SV> fprintf ( stderr , "forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n" , //<S2SV> ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; //<S2SV> # endif //<S2SV> p = s ; //<S2SV> if ( reg -> dmin > 0 ) { //<S2SV> if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { //<S2SV> p += reg -> dmin ; //<S2SV> } //<S2SV> else { //<S2SV> UChar * q = p + reg -> dmin ; //<S2SV> if ( q >= end ) return 0 ; //<S2SV> while ( p < q ) p += enclen ( reg -> enc , p ) ; //<S2SV> } //<S2SV> } //<S2SV> retry : //<S2SV> switch ( reg -> optimize ) { //<S2SV> case ONIG_OPTIMIZE_EXACT : //<S2SV> p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; //<S2SV> break ; //<S2SV> case ONIG_OPTIMIZE_EXACT_IC : //<S2SV> p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , //<S2SV> reg -> exact , reg -> exact_end , p , end , range ) ; //<S2SV> break ; //<S2SV> case ONIG_OPTIMIZE_EXACT_BM : //<S2SV> p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; //<S2SV> break ; //<S2SV> case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : //<S2SV> p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; //<S2SV> break ; //<S2SV> case ONIG_OPTIMIZE_MAP : //<S2SV> p = map_search ( reg -> enc , reg -> map , p , range ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( p && p < range ) { //<S2SV> if ( p - reg -> dmin < s ) { //<S2SV> retry_gate : //<S2SV> pprev = p ; //<S2SV> p += enclen ( reg -> enc , p ) ; //<S2SV> goto retry ; //<S2SV> } //<S2SV> if ( reg -> sub_anchor ) { //<S2SV> UChar * prev ; //<S2SV> switch ( reg -> sub_anchor ) { //<S2SV> case ANCHOR_BEGIN_LINE : //<S2SV> if ( ! ON_STR_BEGIN ( p ) ) { //<S2SV> prev = onigenc_get_prev_char_head ( reg -> enc , //<S2SV> ( pprev ? pprev : str ) , p ) ; //<S2SV> if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) //<S2SV> goto retry_gate ; //<S2SV> } //<S2SV> break ; //<S2SV> case ANCHOR_END_LINE : //<S2SV> if ( ON_STR_END ( p ) ) { //<S2SV> # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE //<S2SV> prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , //<S2SV> ( pprev ? pprev : str ) , p ) ; //<S2SV> if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) //<S2SV> goto retry_gate ; //<S2SV> # endif //<S2SV> } //<S2SV> else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) //<S2SV> # ifdef USE_CRNL_AS_LINE_TERMINATOR //<S2SV> && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) //<S2SV> # endif //<S2SV> ) //<S2SV> goto retry_gate ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( reg -> dmax == 0 ) { //<S2SV> * low = p ; //<S2SV> if ( low_prev ) { //<S2SV> if ( * low > s ) //<S2SV> * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; //<S2SV> else //<S2SV> * low_prev = onigenc_get_prev_char_head ( reg -> enc , //<S2SV> ( pprev ? pprev : str ) , p ) ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { //<S2SV> * low = p - reg -> dmax ; //<S2SV> if ( * low > s ) { //<S2SV> * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , //<S2SV> * low , ( const UChar * * ) low_prev ) ; //<S2SV> if ( low_prev && IS_NULL ( * low_prev ) ) //<S2SV> * low_prev = onigenc_get_prev_char_head ( reg -> enc , //<S2SV> ( pprev ? pprev : s ) , * low ) ; //<S2SV> } //<S2SV> else { //<S2SV> if ( low_prev ) //<S2SV> * low_prev = onigenc_get_prev_char_head ( reg -> enc , //<S2SV> ( pprev ? pprev : str ) , * low ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> * high = p - reg -> dmin ; //<S2SV> # ifdef ONIG_DEBUG_SEARCH //<S2SV> fprintf ( stderr , //<S2SV> "forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n" , //<S2SV> ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; //<S2SV> # endif //<S2SV> return 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 