static int //<S2SV> fetch_token_in_cc ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) //<S2SV> { //<S2SV> int num ; //<S2SV> OnigCodePoint c , c2 ; //<S2SV> OnigSyntaxType * syn = env -> syntax ; //<S2SV> OnigEncoding enc = env -> enc ; //<S2SV> UChar * prev ; //<S2SV> UChar * p = * src ; //<S2SV> PFETCH_READY ; //<S2SV> if ( PEND ) { //<S2SV> tok -> type = TK_EOT ; //<S2SV> return tok -> type ; //<S2SV> } //<S2SV> PFETCH ( c ) ; //<S2SV> tok -> type = TK_CHAR ; //<S2SV> tok -> base = 0 ; //<S2SV> tok -> u . c = c ; //<S2SV> tok -> escaped = 0 ; //<S2SV> if ( c == ']' ) { //<S2SV> tok -> type = TK_CC_CLOSE ; //<S2SV> } //<S2SV> else if ( c == '-' ) { //<S2SV> tok -> type = TK_CC_RANGE ; //<S2SV> } //<S2SV> else if ( c == MC_ESC ( syn ) ) { //<S2SV> if ( ! IS_SYNTAX_BV ( syn , ONIG_SYN_BACKSLASH_ESCAPE_IN_CC ) ) //<S2SV> goto end ; //<S2SV> if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; //<S2SV> PFETCH ( c ) ; //<S2SV> tok -> escaped = 1 ; //<S2SV> tok -> u . c = c ; //<S2SV> switch ( c ) { //<S2SV> case 'w' : //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; //<S2SV> tok -> u . prop . not = 0 ; //<S2SV> break ; //<S2SV> case 'W' : //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; //<S2SV> tok -> u . prop . not = 1 ; //<S2SV> break ; //<S2SV> case 'd' : //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; //<S2SV> tok -> u . prop . not = 0 ; //<S2SV> break ; //<S2SV> case 'D' : //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; //<S2SV> tok -> u . prop . not = 1 ; //<S2SV> break ; //<S2SV> case 's' : //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; //<S2SV> tok -> u . prop . not = 0 ; //<S2SV> break ; //<S2SV> case 'S' : //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; //<S2SV> tok -> u . prop . not = 1 ; //<S2SV> break ; //<S2SV> case 'h' : //<S2SV> if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; //<S2SV> tok -> u . prop . not = 0 ; //<S2SV> break ; //<S2SV> case 'H' : //<S2SV> if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; //<S2SV> tok -> u . prop . not = 1 ; //<S2SV> break ; //<S2SV> case 'p' : //<S2SV> case 'P' : //<S2SV> if ( PEND ) break ; //<S2SV> c2 = PPEEK ; //<S2SV> if ( c2 == '{' && //<S2SV> IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY ) ) { //<S2SV> PINC ; //<S2SV> tok -> type = TK_CHAR_PROPERTY ; //<S2SV> tok -> u . prop . not = ( c == 'P' ? 1 : 0 ) ; //<S2SV> if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT ) ) { //<S2SV> PFETCH ( c2 ) ; //<S2SV> if ( c2 == '^' ) { //<S2SV> tok -> u . prop . not = ( tok -> u . prop . not == 0 ? 1 : 0 ) ; //<S2SV> } //<S2SV> else //<S2SV> PUNFETCH ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 'x' : //<S2SV> if ( PEND ) break ; //<S2SV> prev = p ; //<S2SV> if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_BRACE_HEX8 ) ) { //<S2SV> PINC ; //<S2SV> num = scan_unsigned_hexadecimal_number ( & p , end , 8 , enc ) ; //<S2SV> if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; //<S2SV> if ( ! PEND ) { //<S2SV> c2 = PPEEK ; //<S2SV> if ( ONIGENC_IS_CODE_XDIGIT ( enc , c2 ) ) //<S2SV> return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; //<S2SV> } //<S2SV> if ( p > prev + enclen ( enc , prev ) && ! PEND && ( PPEEK_IS ( '}' ) ) ) { //<S2SV> PINC ; //<S2SV> tok -> type = TK_CODE_POINT ; //<S2SV> tok -> base = 16 ; //<S2SV> tok -> u . code = ( OnigCodePoint ) num ; //<S2SV> } //<S2SV> else { //<S2SV> p = prev ; //<S2SV> } //<S2SV> } //<S2SV> else if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_HEX2 ) ) { //<S2SV> num = scan_unsigned_hexadecimal_number ( & p , end , 2 , enc ) ; //<S2SV> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; //<S2SV> if ( p == prev ) { //<S2SV> num = 0 ; //<S2SV> } //<S2SV> tok -> type = TK_RAW_BYTE ; //<S2SV> tok -> base = 16 ; //<S2SV> tok -> u . c = num ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'u' : //<S2SV> if ( PEND ) break ; //<S2SV> prev = p ; //<S2SV> if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_U_HEX4 ) ) { //<S2SV> num = scan_unsigned_hexadecimal_number ( & p , end , 4 , enc ) ; //<S2SV> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; //<S2SV> if ( p == prev ) { //<S2SV> num = 0 ; //<S2SV> } //<S2SV> tok -> type = TK_CODE_POINT ; //<S2SV> tok -> base = 16 ; //<S2SV> tok -> u . code = ( OnigCodePoint ) num ; //<S2SV> } //<S2SV> break ; //<S2SV> case '0' : //<S2SV> case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : //<S2SV> if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { //<S2SV> PUNFETCH ; //<S2SV> prev = p ; //<S2SV> num = scan_unsigned_octal_number ( & p , end , 3 , enc ) ; //<S2SV> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; //<S2SV> if ( p == prev ) { //<S2SV> num = 0 ; //<S2SV> } //<S2SV> tok -> type = TK_RAW_BYTE ; //<S2SV> tok -> base = 8 ; //<S2SV> tok -> u . c = num ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> PUNFETCH ; //<S2SV> num = fetch_escaped_value ( & p , end , env , & c2 ) ; //<S2SV> if ( num < 0 ) return num ; //<S2SV> if ( tok -> u . c != c2 ) { //<S2SV> tok -> u . code = c2 ; //<S2SV> tok -> type = TK_CODE_POINT ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else if ( c == '[' ) { //<S2SV> if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_POSIX_BRACKET ) && ( PPEEK_IS ( ':' ) ) ) { //<S2SV> OnigCodePoint send [ ] = { ( OnigCodePoint ) ':' , ( OnigCodePoint ) ']' } ; //<S2SV> tok -> backp = p ; //<S2SV> PINC ; //<S2SV> if ( str_exist_check_with_esc ( send , 2 , p , end , //<S2SV> ( OnigCodePoint ) ']' , enc , syn ) ) { //<S2SV> tok -> type = TK_POSIX_BRACKET_OPEN ; //<S2SV> } //<S2SV> else { //<S2SV> PUNFETCH ; //<S2SV> goto cc_in_cc ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> cc_in_cc : //<S2SV> if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_CCLASS_SET_OP ) ) { //<S2SV> tok -> type = TK_CC_CC_OPEN ; //<S2SV> } //<S2SV> else { //<S2SV> CC_ESC_WARN ( env , ( UChar * ) "[" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else if ( c == '&' ) { //<S2SV> if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_CCLASS_SET_OP ) && //<S2SV> ! PEND && ( PPEEK_IS ( '&' ) ) ) { //<S2SV> PINC ; //<S2SV> tok -> type = TK_CC_AND ; //<S2SV> } //<S2SV> } //<S2SV> end : //<S2SV> * src = p ; //<S2SV> return tok -> type ; //<S2SV> } //<S2SV> 