static int //<S2SV> next_state_val ( CClassNode * cc , OnigCodePoint * vs , OnigCodePoint v , //<S2SV> int * vs_israw , int v_israw , //<S2SV> enum CCVALTYPE intype , enum CCVALTYPE * type , //<S2SV> enum CCSTATE * state , ScanEnv * env ) //<S2SV> { //<S2SV> int r ; //<S2SV> switch ( * state ) { //<S2SV> case CCS_VALUE : //<S2SV> if ( * type == CCV_SB ) { //<S2SV> if ( * vs > 0xff ) //<S2SV> return ONIGERR_INVALID_CODE_POINT_VALUE ; //<S2SV> BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; //<S2SV> } //<S2SV> else if ( * type == CCV_CODE_POINT ) { //<S2SV> r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> } //<S2SV> break ; //<S2SV> case CCS_RANGE : //<S2SV> if ( intype == * type ) { //<S2SV> if ( intype == CCV_SB ) { //<S2SV> if ( * vs > 0xff || v > 0xff ) //<S2SV> return ONIGERR_INVALID_CODE_POINT_VALUE ; //<S2SV> if ( * vs > v ) { //<S2SV> if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) //<S2SV> goto ccs_range_end ; //<S2SV> else //<S2SV> return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; //<S2SV> } //<S2SV> bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) v ) ; //<S2SV> } //<S2SV> else { //<S2SV> r = add_code_range ( & ( cc -> mbuf ) , env , * vs , v ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> # if 0 //<S2SV> if ( intype == CCV_CODE_POINT && * type == CCV_SB ) { //<S2SV> # endif //<S2SV> if ( * vs > v ) { //<S2SV> if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) //<S2SV> goto ccs_range_end ; //<S2SV> else //<S2SV> return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; //<S2SV> } //<S2SV> bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) ( v < 0xff ? v : 0xff ) ) ; //<S2SV> r = add_code_range ( & ( cc -> mbuf ) , env , ( OnigCodePoint ) * vs , v ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> # if 0 //<S2SV> } //<S2SV> else //<S2SV> return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE ; //<S2SV> # endif //<S2SV> } //<S2SV> ccs_range_end : //<S2SV> * state = CCS_COMPLETE ; //<S2SV> break ; //<S2SV> case CCS_COMPLETE : //<S2SV> case CCS_START : //<S2SV> * state = CCS_VALUE ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> * vs_israw = v_israw ; //<S2SV> * vs = v ; //<S2SV> * type = intype ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 