static int //<S2SV> parse_exp ( Node * * np , PToken * tok , int term , UChar * * src , UChar * end , //<S2SV> ScanEnv * env , int group_head ) //<S2SV> { //<S2SV> int r , len , group ; //<S2SV> Node * qn ; //<S2SV> Node * * tp ; //<S2SV> unsigned int parse_depth ; //<S2SV> group = 0 ; //<S2SV> * np = NULL ; //<S2SV> if ( tok -> type == ( enum TokenSyms ) term ) //<S2SV> goto end_of_token ; //<S2SV> parse_depth = env -> parse_depth ; //<S2SV> switch ( tok -> type ) { //<S2SV> case TK_ALT : //<S2SV> case TK_EOT : //<S2SV> end_of_token : //<S2SV> * np = node_new_empty ( ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> return tok -> type ; //<S2SV> break ; //<S2SV> case TK_SUBEXP_OPEN : //<S2SV> r = parse_bag ( np , tok , TK_SUBEXP_CLOSE , src , end , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> if ( r == 1 ) { //<S2SV> if ( group_head == 0 ) //<S2SV> group = 1 ; //<S2SV> else { //<S2SV> Node * target = * np ; //<S2SV> * np = node_new_group ( target ) ; //<S2SV> if ( IS_NULL ( * np ) ) { //<S2SV> onig_node_free ( target ) ; //<S2SV> return ONIGERR_MEMORY ; //<S2SV> } //<S2SV> group = 2 ; //<S2SV> } //<S2SV> } //<S2SV> else if ( r == 2 ) { //<S2SV> Node * target ; //<S2SV> OnigOptionType prev = env -> options ; //<S2SV> env -> options = BAG_ ( * np ) -> o . options ; //<S2SV> r = fetch_token ( tok , src , end , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> r = parse_subexp ( & target , tok , term , src , end , env , 0 ) ; //<S2SV> env -> options = prev ; //<S2SV> if ( r < 0 ) { //<S2SV> onig_node_free ( target ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> NODE_BODY ( * np ) = target ; //<S2SV> return tok -> type ; //<S2SV> } //<S2SV> break ; //<S2SV> case TK_SUBEXP_CLOSE : //<S2SV> if ( ! IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP ) ) //<S2SV> return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS ; //<S2SV> if ( tok -> escaped ) goto tk_raw_byte ; //<S2SV> else goto tk_byte ; //<S2SV> break ; //<S2SV> case TK_STRING : //<S2SV> tk_byte : //<S2SV> { //<S2SV> * np = node_new_str ( tok -> backp , * src ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> while ( 1 ) { //<S2SV> r = fetch_token ( tok , src , end , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> if ( r != TK_STRING ) break ; //<S2SV> r = onig_node_str_cat ( * np , tok -> backp , * src ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> } //<S2SV> string_end : //<S2SV> tp = np ; //<S2SV> goto repeat ; //<S2SV> } //<S2SV> break ; //<S2SV> case TK_RAW_BYTE : //<S2SV> tk_raw_byte : //<S2SV> { //<S2SV> * np = node_new_str_raw_char ( ( UChar ) tok -> u . c ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> len = 1 ; //<S2SV> while ( 1 ) { //<S2SV> if ( len >= ONIGENC_MBC_MINLEN ( env -> enc ) ) { //<S2SV> if ( len == enclen ( env -> enc , STR_ ( * np ) -> s ) ) { //<S2SV> r = fetch_token ( tok , src , end , env ) ; //<S2SV> goto tk_raw_byte_end ; //<S2SV> } //<S2SV> } //<S2SV> r = fetch_token ( tok , src , end , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> if ( r != TK_RAW_BYTE ) //<S2SV> return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING ; //<S2SV> r = node_str_cat_char ( * np , ( UChar ) tok -> u . c ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> len ++ ; //<S2SV> } //<S2SV> tk_raw_byte_end : //<S2SV> if ( ! ONIGENC_IS_VALID_MBC_STRING ( env -> enc , STR_ ( * np ) -> s , STR_ ( * np ) -> end ) ) //<S2SV> return ONIGERR_INVALID_WIDE_CHAR_VALUE ; //<S2SV> NODE_STRING_CLEAR_RAW ( * np ) ; //<S2SV> goto string_end ; //<S2SV> } //<S2SV> break ; //<S2SV> case TK_CODE_POINT : //<S2SV> { //<S2SV> UChar buf [ ONIGENC_CODE_TO_MBC_MAXLEN ] ; //<S2SV> len = ONIGENC_CODE_TO_MBC ( env -> enc , tok -> u . code , buf ) ; //<S2SV> if ( len < 0 ) return len ; //<S2SV> # ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG //<S2SV> * np = node_new_str_raw ( buf , buf + len ) ; //<S2SV> # else //<S2SV> * np = node_new_str ( buf , buf + len ) ; //<S2SV> # endif //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case TK_QUOTE_OPEN : //<S2SV> { //<S2SV> OnigCodePoint end_op [ 2 ] ; //<S2SV> UChar * qstart , * qend , * nextp ; //<S2SV> end_op [ 0 ] = ( OnigCodePoint ) MC_ESC ( env -> syntax ) ; //<S2SV> end_op [ 1 ] = ( OnigCodePoint ) 'E' ; //<S2SV> qstart = * src ; //<S2SV> qend = find_str_position ( end_op , 2 , qstart , end , & nextp , env -> enc ) ; //<S2SV> if ( IS_NULL ( qend ) ) { //<S2SV> nextp = qend = end ; //<S2SV> } //<S2SV> * np = node_new_str ( qstart , qend ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> * src = nextp ; //<S2SV> } //<S2SV> break ; //<S2SV> case TK_CHAR_TYPE : //<S2SV> { //<S2SV> switch ( tok -> u . prop . ctype ) { //<S2SV> case ONIGENC_CTYPE_WORD : //<S2SV> * np = node_new_ctype ( tok -> u . prop . ctype , tok -> u . prop . not , env -> options ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> break ; //<S2SV> case ONIGENC_CTYPE_SPACE : //<S2SV> case ONIGENC_CTYPE_DIGIT : //<S2SV> case ONIGENC_CTYPE_XDIGIT : //<S2SV> { //<S2SV> CClassNode * cc ; //<S2SV> * np = node_new_cclass ( ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> cc = CCLASS_ ( * np ) ; //<S2SV> add_ctype_to_cc ( cc , tok -> u . prop . ctype , 0 , env ) ; //<S2SV> if ( tok -> u . prop . not != 0 ) NCCLASS_SET_NOT ( cc ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> return ONIGERR_PARSER_BUG ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TK_CHAR_PROPERTY : //<S2SV> r = parse_char_property ( np , tok , src , end , env ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> break ; //<S2SV> case TK_CC_OPEN : //<S2SV> { //<S2SV> CClassNode * cc ; //<S2SV> r = parse_char_class ( np , tok , src , end , env ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> cc = CCLASS_ ( * np ) ; //<S2SV> if ( IS_IGNORECASE ( env -> options ) ) { //<S2SV> IApplyCaseFoldArg iarg ; //<S2SV> iarg . env = env ; //<S2SV> iarg . cc = cc ; //<S2SV> iarg . alt_root = NULL_NODE ; //<S2SV> iarg . ptail = & ( iarg . alt_root ) ; //<S2SV> r = ONIGENC_APPLY_ALL_CASE_FOLD ( env -> enc , env -> case_fold_flag , //<S2SV> i_apply_case_fold , & iarg ) ; //<S2SV> if ( r != 0 ) { //<S2SV> onig_node_free ( iarg . alt_root ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> if ( IS_NOT_NULL ( iarg . alt_root ) ) { //<S2SV> Node * work = onig_node_new_alt ( * np , iarg . alt_root ) ; //<S2SV> if ( IS_NULL ( work ) ) { //<S2SV> onig_node_free ( iarg . alt_root ) ; //<S2SV> return ONIGERR_MEMORY ; //<S2SV> } //<S2SV> * np = work ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TK_ANYCHAR : //<S2SV> * np = node_new_anychar ( ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> break ; //<S2SV> case TK_ANYCHAR_ANYTIME : //<S2SV> * np = node_new_anychar ( ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> qn = node_new_quantifier ( 0 , INFINITE_REPEAT , 0 ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( qn ) ; //<S2SV> NODE_BODY ( qn ) = * np ; //<S2SV> * np = qn ; //<S2SV> break ; //<S2SV> case TK_BACKREF : //<S2SV> len = tok -> u . backref . num ; //<S2SV> * np = node_new_backref ( len , //<S2SV> ( len > 1 ? tok -> u . backref . refs : & ( tok -> u . backref . ref1 ) ) , //<S2SV> tok -> u . backref . by_name , //<S2SV> # ifdef USE_BACKREF_WITH_LEVEL //<S2SV> tok -> u . backref . exist_level , //<S2SV> tok -> u . backref . level , //<S2SV> # endif //<S2SV> env ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> break ; //<S2SV> # ifdef USE_CALL //<S2SV> case TK_CALL : //<S2SV> { //<S2SV> int gnum = tok -> u . call . gnum ; //<S2SV> * np = node_new_call ( tok -> u . call . name , tok -> u . call . name_end , //<S2SV> gnum , tok -> u . call . by_number ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> env -> num_call ++ ; //<S2SV> if ( tok -> u . call . by_number != 0 && gnum == 0 ) { //<S2SV> env -> has_call_zero = 1 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> # endif //<S2SV> case TK_ANCHOR : //<S2SV> { //<S2SV> int ascii_mode = //<S2SV> IS_WORD_ASCII ( env -> options ) && IS_WORD_ANCHOR_TYPE ( tok -> u . anchor ) ? 1 : 0 ; //<S2SV> * np = onig_node_new_anchor ( tok -> u . anchor , ascii_mode ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case TK_REPEAT : //<S2SV> case TK_INTERVAL : //<S2SV> if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS ) ) { //<S2SV> if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS ) ) //<S2SV> return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED ; //<S2SV> else { //<S2SV> * np = node_new_empty ( ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( * np ) ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> goto tk_byte ; //<S2SV> } //<S2SV> break ; //<S2SV> case TK_KEEP : //<S2SV> r = node_new_keep ( np , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> break ; //<S2SV> case TK_GENERAL_NEWLINE : //<S2SV> r = node_new_general_newline ( np , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> break ; //<S2SV> case TK_NO_NEWLINE : //<S2SV> r = node_new_no_newline ( np , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> break ; //<S2SV> case TK_TRUE_ANYCHAR : //<S2SV> r = node_new_true_anychar ( np , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> break ; //<S2SV> case TK_TEXT_SEGMENT : //<S2SV> r = make_text_segment ( np , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> break ; //<S2SV> default : //<S2SV> return ONIGERR_PARSER_BUG ; //<S2SV> break ; //<S2SV> } //<S2SV> { //<S2SV> tp = np ; //<S2SV> re_entry : //<S2SV> r = fetch_token ( tok , src , end , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> repeat : //<S2SV> if ( r == TK_REPEAT || r == TK_INTERVAL ) { //<S2SV> Node * target ; //<S2SV> if ( is_invalid_quantifier_target ( * tp ) ) //<S2SV> return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; //<S2SV> parse_depth ++ ; //<S2SV> if ( parse_depth > ParseDepthLimit ) //<S2SV> return ONIGERR_PARSE_DEPTH_LIMIT_OVER ; //<S2SV> qn = node_new_quantifier ( tok -> u . repeat . lower , tok -> u . repeat . upper , //<S2SV> r == TK_INTERVAL ) ; //<S2SV> CHECK_NULL_RETURN_MEMERR ( qn ) ; //<S2SV> QUANT_ ( qn ) -> greedy = tok -> u . repeat . greedy ; //<S2SV> if ( group == 2 ) { //<S2SV> target = node_drop_group ( * tp ) ; //<S2SV> * tp = NULL_NODE ; //<S2SV> } //<S2SV> else { //<S2SV> target = * tp ; //<S2SV> } //<S2SV> r = set_quantifier ( qn , target , group , env ) ; //<S2SV> if ( r < 0 ) { //<S2SV> onig_node_free ( qn ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> if ( tok -> u . repeat . possessive != 0 ) { //<S2SV> Node * en ; //<S2SV> en = node_new_bag ( BAG_STOP_BACKTRACK ) ; //<S2SV> if ( IS_NULL ( en ) ) { //<S2SV> onig_node_free ( qn ) ; //<S2SV> return ONIGERR_MEMORY ; //<S2SV> } //<S2SV> NODE_BODY ( en ) = qn ; //<S2SV> qn = en ; //<S2SV> } //<S2SV> if ( r == 0 ) { //<S2SV> * tp = qn ; //<S2SV> } //<S2SV> else if ( r == 1 ) { //<S2SV> onig_node_free ( qn ) ; //<S2SV> * tp = target ; //<S2SV> } //<S2SV> else if ( r == 2 ) { //<S2SV> Node * tmp ; //<S2SV> * tp = node_new_list ( * tp , NULL ) ; //<S2SV> if ( IS_NULL ( * tp ) ) { //<S2SV> onig_node_free ( qn ) ; //<S2SV> return ONIGERR_MEMORY ; //<S2SV> } //<S2SV> tmp = NODE_CDR ( * tp ) = node_new_list ( qn , NULL ) ; //<S2SV> if ( IS_NULL ( tmp ) ) { //<S2SV> onig_node_free ( qn ) ; //<S2SV> return ONIGERR_MEMORY ; //<S2SV> } //<S2SV> tp = & ( NODE_CAR ( tmp ) ) ; //<S2SV> } //<S2SV> group = 0 ; //<S2SV> goto re_entry ; //<S2SV> } //<S2SV> } //<S2SV> return r ; //<S2SV> } //<S2SV> 