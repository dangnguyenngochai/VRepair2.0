extern int //<S2SV> onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , //<S2SV> OnigCompileInfo * ci , OnigErrorInfo * einfo ) //<S2SV> { //<S2SV> int r ; //<S2SV> UChar * cpat , * cpat_end ; //<S2SV> if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; //<S2SV> if ( ci -> pattern_enc != ci -> target_enc ) { //<S2SV> return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION ; //<S2SV> } //<S2SV> else { //<S2SV> cpat = ( UChar * ) pattern ; //<S2SV> cpat_end = ( UChar * ) pattern_end ; //<S2SV> } //<S2SV> * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; //<S2SV> if ( IS_NULL ( * reg ) ) { //<S2SV> r = ONIGERR_MEMORY ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , //<S2SV> ci -> syntax ) ; //<S2SV> if ( r != 0 ) goto err ; //<S2SV> r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; //<S2SV> if ( r != 0 ) { //<S2SV> err : //<S2SV> onig_free ( * reg ) ; //<S2SV> * reg = NULL ; //<S2SV> } //<S2SV> err2 : //<S2SV> if ( cpat != pattern ) xfree ( cpat ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> 