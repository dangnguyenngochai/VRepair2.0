static int //<S2SV> compile_bag_node ( BagNode * node , regex_t * reg , ScanEnv * env ) //<S2SV> { //<S2SV> int r , len ; //<S2SV> switch ( node -> type ) { //<S2SV> case BAG_MEMORY : //<S2SV> r = compile_bag_memory_node ( node , reg , env ) ; //<S2SV> break ; //<S2SV> case BAG_OPTION : //<S2SV> r = compile_option_node ( node , reg , env ) ; //<S2SV> break ; //<S2SV> case BAG_STOP_BACKTRACK : //<S2SV> if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { //<S2SV> QuantNode * qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; //<S2SV> r = compile_tree_n_times ( NODE_QUANT_BODY ( qn ) , qn -> lower , reg , env ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> len = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; //<S2SV> if ( len < 0 ) return len ; //<S2SV> r = add_op ( reg , OP_PUSH ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> COP ( reg ) -> push . addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; //<S2SV> r = compile_tree ( NODE_QUANT_BODY ( qn ) , reg , env ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> r = add_op ( reg , OP_POP_OUT ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> r = add_op ( reg , OP_JUMP ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> COP ( reg ) -> jump . addr = - ( ( int ) SIZE_OP_PUSH + len + ( int ) SIZE_OP_POP_OUT ) ; //<S2SV> } //<S2SV> else { //<S2SV> r = add_op ( reg , OP_ATOMIC_START ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> r = compile_tree ( NODE_BAG_BODY ( node ) , reg , env ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> r = add_op ( reg , OP_ATOMIC_END ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case BAG_IF_ELSE : //<S2SV> { //<S2SV> int cond_len , then_len , else_len , jump_len ; //<S2SV> Node * cond = NODE_BAG_BODY ( node ) ; //<S2SV> Node * Then = node -> te . Then ; //<S2SV> Node * Else = node -> te . Else ; //<S2SV> r = add_op ( reg , OP_ATOMIC_START ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> cond_len = compile_length_tree ( cond , reg ) ; //<S2SV> if ( cond_len < 0 ) return cond_len ; //<S2SV> if ( IS_NOT_NULL ( Then ) ) { //<S2SV> then_len = compile_length_tree ( Then , reg ) ; //<S2SV> if ( then_len < 0 ) return then_len ; //<S2SV> } //<S2SV> else //<S2SV> then_len = 0 ; //<S2SV> jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP ; //<S2SV> r = add_op ( reg , OP_PUSH ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> COP ( reg ) -> push . addr = SIZE_INC_OP + jump_len ; //<S2SV> r = compile_tree ( cond , reg , env ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> r = add_op ( reg , OP_ATOMIC_END ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> if ( IS_NOT_NULL ( Then ) ) { //<S2SV> r = compile_tree ( Then , reg , env ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> } //<S2SV> if ( IS_NOT_NULL ( Else ) ) { //<S2SV> else_len = compile_length_tree ( Else , reg ) ; //<S2SV> if ( else_len < 0 ) return else_len ; //<S2SV> } //<S2SV> else //<S2SV> else_len = 0 ; //<S2SV> r = add_op ( reg , OP_JUMP ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> COP ( reg ) -> jump . addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP ; //<S2SV> r = add_op ( reg , OP_ATOMIC_END ) ; //<S2SV> if ( r != 0 ) return r ; //<S2SV> if ( IS_NOT_NULL ( Else ) ) { //<S2SV> r = compile_tree ( Else , reg , env ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> return r ; //<S2SV> } //<S2SV> 