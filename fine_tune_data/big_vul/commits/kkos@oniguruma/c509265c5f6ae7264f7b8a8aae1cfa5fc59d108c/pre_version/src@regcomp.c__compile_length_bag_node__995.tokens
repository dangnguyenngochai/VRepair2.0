static int //<S2SV> compile_length_bag_node ( BagNode * node , regex_t * reg ) //<S2SV> { //<S2SV> int len ; //<S2SV> int tlen ; //<S2SV> if ( node -> type == BAG_OPTION ) //<S2SV> return compile_length_option_node ( node , reg ) ; //<S2SV> if ( NODE_BAG_BODY ( node ) ) { //<S2SV> tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; //<S2SV> if ( tlen < 0 ) return tlen ; //<S2SV> } //<S2SV> else //<S2SV> tlen = 0 ; //<S2SV> switch ( node -> type ) { //<S2SV> case BAG_MEMORY : //<S2SV> # ifdef USE_CALL //<S2SV> if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { //<S2SV> len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; //<S2SV> return len ; //<S2SV> } //<S2SV> if ( NODE_IS_CALLED ( node ) ) { //<S2SV> len = SIZE_OP_MEMORY_START_PUSH + tlen //<S2SV> + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; //<S2SV> if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) //<S2SV> len += ( NODE_IS_RECURSION ( node ) //<S2SV> ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; //<S2SV> else //<S2SV> len += ( NODE_IS_RECURSION ( node ) //<S2SV> ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; //<S2SV> } //<S2SV> else if ( NODE_IS_RECURSION ( node ) ) { //<S2SV> len = SIZE_OP_MEMORY_START_PUSH ; //<S2SV> len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) //<S2SV> ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> { //<S2SV> if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) //<S2SV> len = SIZE_OP_MEMORY_START_PUSH ; //<S2SV> else //<S2SV> len = SIZE_OP_MEMORY_START ; //<S2SV> len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) //<S2SV> ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case BAG_STOP_BACKTRACK : //<S2SV> if ( NODE_IS_STOP_BT_SIMPLE_REPEAT ( node ) ) { //<S2SV> int v ; //<S2SV> QuantNode * qn ; //<S2SV> qn = QUANT_ ( NODE_BAG_BODY ( node ) ) ; //<S2SV> tlen = compile_length_tree ( NODE_QUANT_BODY ( qn ) , reg ) ; //<S2SV> if ( tlen < 0 ) return tlen ; //<S2SV> v = onig_positive_int_multiply ( qn -> lower , tlen ) ; //<S2SV> if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; //<S2SV> len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP ; //<S2SV> } //<S2SV> else { //<S2SV> len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; //<S2SV> } //<S2SV> break ; //<S2SV> case BAG_IF_ELSE : //<S2SV> { //<S2SV> Node * cond = NODE_BAG_BODY ( node ) ; //<S2SV> Node * Then = node -> te . Then ; //<S2SV> Node * Else = node -> te . Else ; //<S2SV> len = compile_length_tree ( cond , reg ) ; //<S2SV> if ( len < 0 ) return len ; //<S2SV> len += SIZE_OP_PUSH ; //<S2SV> len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END ; //<S2SV> if ( IS_NOT_NULL ( Then ) ) { //<S2SV> tlen = compile_length_tree ( Then , reg ) ; //<S2SV> if ( tlen < 0 ) return tlen ; //<S2SV> len += tlen ; //<S2SV> } //<S2SV> if ( IS_NOT_NULL ( Else ) ) { //<S2SV> len += SIZE_OP_JUMP ; //<S2SV> tlen = compile_length_tree ( Else , reg ) ; //<S2SV> if ( tlen < 0 ) return tlen ; //<S2SV> len += tlen ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case BAG_OPTION : //<S2SV> len = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> return len ; //<S2SV> } //<S2SV> 