int res_inverse ( vorbis_dsp_state * vd , vorbis_info_residue * info , //<S2SV> ogg_int32_t * * in , int * nonzero , int ch ) { //<S2SV> int i , j , k , s , used = 0 ; //<S2SV> codec_setup_info * ci = ( codec_setup_info * ) vd -> vi -> codec_setup ; //<S2SV> codebook * phrasebook = ci -> book_param + info -> groupbook ; //<S2SV> int samples_per_partition = info -> grouping ; //<S2SV> int partitions_per_word = phrasebook -> dim ; //<S2SV> int pcmend = ci -> blocksizes [ vd -> W ] ; //<S2SV> if ( info -> type < 2 ) { //<S2SV> int max = pcmend >> 1 ; //<S2SV> int end = ( info -> end < max ? info -> end : max ) ; //<S2SV> int n = end - info -> begin ; //<S2SV> if ( n > 0 ) { //<S2SV> int partvals = n / samples_per_partition ; //<S2SV> int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; //<S2SV> for ( i = 0 ; i < ch ; i ++ ) //<S2SV> if ( nonzero [ i ] ) //<S2SV> in [ used ++ ] = in [ i ] ; //<S2SV> ch = used ; //<S2SV> if ( used ) { //<S2SV> char * * partword = ( char * * ) alloca ( ch * sizeof ( * partword ) ) ; //<S2SV> for ( j = 0 ; j < ch ; j ++ ) //<S2SV> partword [ j ] = ( char * ) alloca ( partwords * partitions_per_word * //<S2SV> sizeof ( * partword [ j ] ) ) ; //<S2SV> for ( s = 0 ; s < info -> stages ; s ++ ) { //<S2SV> for ( i = 0 ; i < partvals ; ) { //<S2SV> if ( s == 0 ) { //<S2SV> partword [ 0 ] [ i + partitions_per_word - 1 ] = 1 ; //<S2SV> for ( k = partitions_per_word - 2 ; k >= 0 ; k -- ) //<S2SV> partword [ 0 ] [ i + k ] = partword [ 0 ] [ i + k + 1 ] * info -> partitions ; //<S2SV> for ( j = 1 ; j < ch ; j ++ ) //<S2SV> for ( k = partitions_per_word - 1 ; k >= 0 ; k -- ) //<S2SV> partword [ j ] [ i + k ] = partword [ j - 1 ] [ i + k ] ; //<S2SV> for ( j = 0 ; j < ch ; j ++ ) { //<S2SV> int temp = vorbis_book_decode ( phrasebook , & vd -> opb ) ; //<S2SV> if ( temp == - 1 ) goto eopbreak ; //<S2SV> for ( k = 0 ; k < partitions_per_word ; k ++ ) { //<S2SV> ogg_uint32_t div = partword [ j ] [ i + k ] ; //<S2SV> partword [ j ] [ i + k ] = temp / div ; //<S2SV> temp -= partword [ j ] [ i + k ] * div ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) //<S2SV> for ( j = 0 ; j < ch ; j ++ ) { //<S2SV> long offset = info -> begin + i * samples_per_partition ; //<S2SV> int idx = ( int ) partword [ j ] [ i ] ; //<S2SV> if ( idx < info -> partitions && info -> stagemasks [ idx ] & ( 1 << s ) ) { //<S2SV> codebook * stagebook = ci -> book_param + //<S2SV> info -> stagebooks [ ( partword [ j ] [ i ] << 3 ) + s ] ; //<S2SV> if ( info -> type ) { //<S2SV> if ( vorbis_book_decodev_add ( stagebook , in [ j ] + offset , & vd -> opb , //<S2SV> samples_per_partition , - 8 ) == - 1 ) //<S2SV> goto eopbreak ; //<S2SV> } else { //<S2SV> if ( vorbis_book_decodevs_add ( stagebook , in [ j ] + offset , & vd -> opb , //<S2SV> samples_per_partition , - 8 ) == - 1 ) //<S2SV> goto eopbreak ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> int max = ( pcmend * ch ) >> 1 ; //<S2SV> int end = ( info -> end < max ? info -> end : max ) ; //<S2SV> int n = end - info -> begin ; //<S2SV> if ( n > 0 ) { //<S2SV> int partvals = n / samples_per_partition ; //<S2SV> int partwords = ( partvals + partitions_per_word - 1 ) / partitions_per_word ; //<S2SV> char * partword = //<S2SV> ( char * ) alloca ( partwords * partitions_per_word * sizeof ( * partword ) ) ; //<S2SV> int beginoff = info -> begin / ch ; //<S2SV> for ( i = 0 ; i < ch ; i ++ ) if ( nonzero [ i ] ) break ; //<S2SV> if ( i == ch ) return ( 0 ) ; //<S2SV> samples_per_partition /= ch ; //<S2SV> for ( s = 0 ; s < info -> stages ; s ++ ) { //<S2SV> for ( i = 0 ; i < partvals ; ) { //<S2SV> if ( s == 0 ) { //<S2SV> int temp ; //<S2SV> partword [ i + partitions_per_word - 1 ] = 1 ; //<S2SV> for ( k = partitions_per_word - 2 ; k >= 0 ; k -- ) //<S2SV> partword [ i + k ] = partword [ i + k + 1 ] * info -> partitions ; //<S2SV> temp = vorbis_book_decode ( phrasebook , & vd -> opb ) ; //<S2SV> if ( temp == - 1 ) goto eopbreak ; //<S2SV> for ( k = 0 ; k < partitions_per_word ; k ++ ) { //<S2SV> ogg_uint32_t div = partword [ i + k ] ; //<S2SV> partword [ i + k ] = temp / div ; //<S2SV> temp -= partword [ i + k ] * div ; //<S2SV> } //<S2SV> } //<S2SV> for ( k = 0 ; k < partitions_per_word && i < partvals ; k ++ , i ++ ) //<S2SV> if ( info -> stagemasks [ ( int ) partword [ i ] ] & ( 1 << s ) ) { //<S2SV> codebook * stagebook = ci -> book_param + //<S2SV> info -> stagebooks [ ( partword [ i ] << 3 ) + s ] ; //<S2SV> if ( vorbis_book_decodevv_add ( stagebook , in , //<S2SV> i * samples_per_partition + beginoff , ch , //<S2SV> & vd -> opb , //<S2SV> samples_per_partition , - 8 ) == - 1 ) //<S2SV> goto eopbreak ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> eopbreak : //<S2SV> return 0 ; //<S2SV> } //<S2SV> 