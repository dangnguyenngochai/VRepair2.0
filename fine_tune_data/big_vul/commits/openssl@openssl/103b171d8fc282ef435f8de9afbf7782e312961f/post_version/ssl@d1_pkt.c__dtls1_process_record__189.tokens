static int //<S2SV> dtls1_process_record ( SSL * s ) //<S2SV> { //<S2SV> int i , al ; //<S2SV> int enc_err ; //<S2SV> SSL_SESSION * sess ; //<S2SV> SSL3_RECORD * rr ; //<S2SV> unsigned int mac_size ; //<S2SV> unsigned char md [ EVP_MAX_MD_SIZE ] ; //<S2SV> rr = & ( s -> s3 -> rrec ) ; //<S2SV> sess = s -> session ; //<S2SV> rr -> input = & ( s -> packet [ DTLS1_RT_HEADER_LENGTH ] ) ; //<S2SV> if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) //<S2SV> { //<S2SV> al = SSL_AD_RECORD_OVERFLOW ; //<S2SV> SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_ENCRYPTED_LENGTH_TOO_LONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> rr -> data = rr -> input ; //<S2SV> rr -> orig_len = rr -> length ; //<S2SV> enc_err = s -> method -> ssl3_enc -> enc ( s , 0 ) ; //<S2SV> if ( enc_err == 0 ) //<S2SV> { //<S2SV> rr -> length = 0 ; //<S2SV> s -> packet_length = 0 ; //<S2SV> goto err ; //<S2SV> } //<S2SV> # ifdef TLS_DEBUG //<S2SV> printf ( "dec<S2SV_blank>%d\\n" , rr -> length ) ; //<S2SV> { unsigned int z ; for ( z = 0 ; z < rr -> length ; z ++ ) printf ( "%02X%c" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } //<S2SV> printf ( "\\n" ) ; //<S2SV> # endif //<S2SV> if ( ( sess != NULL ) && //<S2SV> ( s -> enc_read_ctx != NULL ) && //<S2SV> ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) ) //<S2SV> { //<S2SV> unsigned char * mac = NULL ; //<S2SV> unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ; //<S2SV> mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; //<S2SV> OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; //<S2SV> if ( rr -> orig_len < mac_size || //<S2SV> ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && //<S2SV> rr -> orig_len < mac_size + 1 ) ) //<S2SV> { //<S2SV> al = SSL_AD_DECODE_ERROR ; //<S2SV> SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) //<S2SV> { //<S2SV> mac = mac_tmp ; //<S2SV> ssl3_cbc_copy_mac ( mac_tmp , rr , mac_size ) ; //<S2SV> rr -> length -= mac_size ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> rr -> length -= mac_size ; //<S2SV> mac = & rr -> data [ rr -> length ] ; //<S2SV> } //<S2SV> i = s -> method -> ssl3_enc -> mac ( s , md , 0 ) ; //<S2SV> if ( i < 0 || mac == NULL || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) //<S2SV> enc_err = - 1 ; //<S2SV> if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) //<S2SV> enc_err = - 1 ; //<S2SV> } //<S2SV> if ( enc_err < 0 ) //<S2SV> { //<S2SV> rr -> length = 0 ; //<S2SV> s -> packet_length = 0 ; //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( s -> expand != NULL ) //<S2SV> { //<S2SV> if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH ) //<S2SV> { //<S2SV> al = SSL_AD_RECORD_OVERFLOW ; //<S2SV> SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> if ( ! ssl3_do_uncompress ( s ) ) //<S2SV> { //<S2SV> al = SSL_AD_DECOMPRESSION_FAILURE ; //<S2SV> SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_BAD_DECOMPRESSION ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> } //<S2SV> if ( rr -> length > SSL3_RT_MAX_PLAIN_LENGTH ) //<S2SV> { //<S2SV> al = SSL_AD_RECORD_OVERFLOW ; //<S2SV> SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> rr -> off = 0 ; //<S2SV> s -> packet_length = 0 ; //<S2SV> return ( 1 ) ; //<S2SV> f_err : //<S2SV> ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; //<S2SV> err : //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> 