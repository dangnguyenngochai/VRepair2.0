int ssl3_accept ( SSL * s ) //<S2SV> { //<S2SV> BUF_MEM * buf ; //<S2SV> unsigned long alg_k , Time = ( unsigned long ) time ( NULL ) ; //<S2SV> void ( * cb ) ( const SSL * ssl , int type , int val ) = NULL ; //<S2SV> int ret = - 1 ; //<S2SV> int new_state , state , skip = 0 ; //<S2SV> RAND_add ( & Time , sizeof ( Time ) , 0 ) ; //<S2SV> ERR_clear_error ( ) ; //<S2SV> clear_sys_error ( ) ; //<S2SV> if ( s -> info_callback != NULL ) //<S2SV> cb = s -> info_callback ; //<S2SV> else if ( s -> ctx -> info_callback != NULL ) //<S2SV> cb = s -> ctx -> info_callback ; //<S2SV> s -> in_handshake ++ ; //<S2SV> if ( ! SSL_in_init ( s ) || SSL_in_before ( s ) ) SSL_clear ( s ) ; //<S2SV> if ( s -> cert == NULL ) //<S2SV> { //<S2SV> SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_NO_CERTIFICATE_SET ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> # ifndef OPENSSL_NO_HEARTBEATS //<S2SV> if ( s -> tlsext_hb_pending ) //<S2SV> { //<S2SV> s -> tlsext_hb_pending = 0 ; //<S2SV> s -> tlsext_hb_seq ++ ; //<S2SV> } //<S2SV> # endif //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> state = s -> state ; //<S2SV> switch ( s -> state ) //<S2SV> { //<S2SV> case SSL_ST_RENEGOTIATE : //<S2SV> s -> renegotiate = 1 ; //<S2SV> case SSL_ST_BEFORE : //<S2SV> case SSL_ST_ACCEPT : //<S2SV> case SSL_ST_BEFORE | SSL_ST_ACCEPT : //<S2SV> case SSL_ST_OK | SSL_ST_ACCEPT : //<S2SV> s -> server = 1 ; //<S2SV> if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_START , 1 ) ; //<S2SV> if ( ( s -> version >> 8 ) != 3 ) //<S2SV> { //<S2SV> SSLerr ( SSL_F_SSL3_ACCEPT , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( ! ssl_security ( s , SSL_SECOP_VERSION , 0 , //<S2SV> s -> version , NULL ) ) //<S2SV> { //<S2SV> SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_VERSION_TOO_LOW ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> s -> type = SSL_ST_ACCEPT ; //<S2SV> if ( s -> init_buf == NULL ) //<S2SV> { //<S2SV> if ( ( buf = BUF_MEM_new ( ) ) == NULL ) //<S2SV> { //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> if ( ! BUF_MEM_grow ( buf , SSL3_RT_MAX_PLAIN_LENGTH ) ) //<S2SV> { //<S2SV> BUF_MEM_free ( buf ) ; //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> s -> init_buf = buf ; //<S2SV> } //<S2SV> if ( ! ssl3_setup_buffers ( s ) ) //<S2SV> { //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> s -> init_num = 0 ; //<S2SV> s -> s3 -> flags &= ~ TLS1_FLAGS_SKIP_CERT_VERIFY ; //<S2SV> s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ; //<S2SV> s -> s3 -> change_cipher_spec = 0 ; //<S2SV> if ( s -> state != SSL_ST_RENEGOTIATE ) //<S2SV> { //<S2SV> if ( ! ssl_init_wbio_buffer ( s , 1 ) ) { ret = - 1 ; goto end ; } //<S2SV> ssl3_init_finished_mac ( s ) ; //<S2SV> s -> state = SSL3_ST_SR_CLNT_HELLO_A ; //<S2SV> s -> ctx -> stats . sess_accept ++ ; //<S2SV> } //<S2SV> else if ( ! s -> s3 -> send_connection_binding && //<S2SV> ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) //<S2SV> { //<S2SV> SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; //<S2SV> ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_HANDSHAKE_FAILURE ) ; //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> s -> ctx -> stats . sess_accept_renegotiate ++ ; //<S2SV> s -> state = SSL3_ST_SW_HELLO_REQ_A ; //<S2SV> } //<S2SV> break ; //<S2SV> case SSL3_ST_SW_HELLO_REQ_A : //<S2SV> case SSL3_ST_SW_HELLO_REQ_B : //<S2SV> s -> shutdown = 0 ; //<S2SV> ret = ssl3_send_hello_request ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> s -> s3 -> tmp . next_state = SSL3_ST_SW_HELLO_REQ_C ; //<S2SV> s -> state = SSL3_ST_SW_FLUSH ; //<S2SV> s -> init_num = 0 ; //<S2SV> ssl3_init_finished_mac ( s ) ; //<S2SV> break ; //<S2SV> case SSL3_ST_SW_HELLO_REQ_C : //<S2SV> s -> state = SSL_ST_OK ; //<S2SV> break ; //<S2SV> case SSL3_ST_SR_CLNT_HELLO_A : //<S2SV> case SSL3_ST_SR_CLNT_HELLO_B : //<S2SV> case SSL3_ST_SR_CLNT_HELLO_C : //<S2SV> ret = ssl3_get_client_hello ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> # ifndef OPENSSL_NO_SRP //<S2SV> s -> state = SSL3_ST_SR_CLNT_HELLO_D ; //<S2SV> case SSL3_ST_SR_CLNT_HELLO_D : //<S2SV> { //<S2SV> int al ; //<S2SV> if ( ( ret = ssl_check_srp_ext_ClientHello ( s , & al ) ) < 0 ) //<S2SV> { //<S2SV> s -> rwstate = SSL_X509_LOOKUP ; //<S2SV> goto end ; //<S2SV> } //<S2SV> if ( ret != SSL_ERROR_NONE ) //<S2SV> { //<S2SV> ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; //<S2SV> if ( al != TLS1_AD_UNKNOWN_PSK_IDENTITY ) //<S2SV> SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_CLIENTHELLO_TLSEXT ) ; //<S2SV> ret = SSL_TLSEXT_ERR_ALERT_FATAL ; //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> s -> renegotiate = 2 ; //<S2SV> s -> state = SSL3_ST_SW_SRVR_HELLO_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> case SSL3_ST_SW_SRVR_HELLO_A : //<S2SV> case SSL3_ST_SW_SRVR_HELLO_B : //<S2SV> ret = ssl3_send_server_hello ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> # ifndef OPENSSL_NO_TLSEXT //<S2SV> if ( s -> hit ) //<S2SV> { //<S2SV> if ( s -> tlsext_ticket_expected ) //<S2SV> s -> state = SSL3_ST_SW_SESSION_TICKET_A ; //<S2SV> else //<S2SV> s -> state = SSL3_ST_SW_CHANGE_A ; //<S2SV> } //<S2SV> # else //<S2SV> if ( s -> hit ) //<S2SV> s -> state = SSL3_ST_SW_CHANGE_A ; //<S2SV> # endif //<S2SV> else //<S2SV> s -> state = SSL3_ST_SW_CERT_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> case SSL3_ST_SW_CERT_A : //<S2SV> case SSL3_ST_SW_CERT_B : //<S2SV> if ( ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & ( SSL_aNULL | SSL_aKRB5 | SSL_aSRP ) ) //<S2SV> && ! ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) //<S2SV> { //<S2SV> ret = ssl3_send_server_certificate ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> # ifndef OPENSSL_NO_TLSEXT //<S2SV> if ( s -> tlsext_status_expected ) //<S2SV> s -> state = SSL3_ST_SW_CERT_STATUS_A ; //<S2SV> else //<S2SV> s -> state = SSL3_ST_SW_KEY_EXCH_A ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> skip = 1 ; //<S2SV> s -> state = SSL3_ST_SW_KEY_EXCH_A ; //<S2SV> } //<S2SV> # else //<S2SV> } //<S2SV> else //<S2SV> skip = 1 ; //<S2SV> s -> state = SSL3_ST_SW_KEY_EXCH_A ; //<S2SV> # endif //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> case SSL3_ST_SW_KEY_EXCH_A : //<S2SV> case SSL3_ST_SW_KEY_EXCH_B : //<S2SV> alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; //<S2SV> if ( ( s -> options & SSL_OP_EPHEMERAL_RSA ) //<S2SV> # ifndef OPENSSL_NO_KRB5 //<S2SV> && ! ( alg_k & SSL_kKRB5 ) //<S2SV> # endif //<S2SV> ) //<S2SV> s -> s3 -> tmp . use_rsa_tmp = 1 ; //<S2SV> else //<S2SV> s -> s3 -> tmp . use_rsa_tmp = 0 ; //<S2SV> if ( s -> s3 -> tmp . use_rsa_tmp //<S2SV> # ifndef OPENSSL_NO_PSK //<S2SV> || ( ( alg_k & SSL_kPSK ) && s -> ctx -> psk_identity_hint ) //<S2SV> # endif //<S2SV> # ifndef OPENSSL_NO_SRP //<S2SV> || ( alg_k & SSL_kSRP ) //<S2SV> # endif //<S2SV> || ( alg_k & SSL_kDHE ) //<S2SV> || ( alg_k & SSL_kECDHE ) //<S2SV> || ( ( alg_k & SSL_kRSA ) //<S2SV> && ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey == NULL //<S2SV> || ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) //<S2SV> && EVP_PKEY_size ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey ) * 8 > SSL_C_EXPORT_PKEYLENGTH ( s -> s3 -> tmp . new_cipher ) //<S2SV> ) //<S2SV> ) //<S2SV> ) //<S2SV> ) //<S2SV> { //<S2SV> ret = ssl3_send_server_key_exchange ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> } //<S2SV> else //<S2SV> skip = 1 ; //<S2SV> s -> state = SSL3_ST_SW_CERT_REQ_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> case SSL3_ST_SW_CERT_REQ_A : //<S2SV> case SSL3_ST_SW_CERT_REQ_B : //<S2SV> if ( //<S2SV> ! ( s -> verify_mode & SSL_VERIFY_PEER ) || //<S2SV> ( ( s -> session -> peer != NULL ) && //<S2SV> ( s -> verify_mode & SSL_VERIFY_CLIENT_ONCE ) ) || //<S2SV> ( ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) && //<S2SV> ! ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) || //<S2SV> ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aKRB5 ) || //<S2SV> ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aSRP ) //<S2SV> || ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) //<S2SV> { //<S2SV> skip = 1 ; //<S2SV> s -> s3 -> tmp . cert_request = 0 ; //<S2SV> s -> state = SSL3_ST_SW_SRVR_DONE_A ; //<S2SV> if ( s -> s3 -> handshake_buffer ) //<S2SV> if ( ! ssl3_digest_cached_records ( s ) ) //<S2SV> return - 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> s -> s3 -> tmp . cert_request = 1 ; //<S2SV> ret = ssl3_send_certificate_request ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> # ifndef NETSCAPE_HANG_BUG //<S2SV> s -> state = SSL3_ST_SW_SRVR_DONE_A ; //<S2SV> # else //<S2SV> s -> state = SSL3_ST_SW_FLUSH ; //<S2SV> s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ; //<S2SV> # endif //<S2SV> s -> init_num = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> case SSL3_ST_SW_SRVR_DONE_A : //<S2SV> case SSL3_ST_SW_SRVR_DONE_B : //<S2SV> ret = ssl3_send_server_done ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ; //<S2SV> s -> state = SSL3_ST_SW_FLUSH ; //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> case SSL3_ST_SW_FLUSH : //<S2SV> s -> rwstate = SSL_WRITING ; //<S2SV> if ( BIO_flush ( s -> wbio ) <= 0 ) //<S2SV> { //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> s -> rwstate = SSL_NOTHING ; //<S2SV> s -> state = s -> s3 -> tmp . next_state ; //<S2SV> break ; //<S2SV> case SSL3_ST_SR_CERT_A : //<S2SV> case SSL3_ST_SR_CERT_B : //<S2SV> if ( s -> s3 -> tmp . cert_request ) //<S2SV> { //<S2SV> ret = ssl3_get_client_certificate ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> } //<S2SV> s -> init_num = 0 ; //<S2SV> s -> state = SSL3_ST_SR_KEY_EXCH_A ; //<S2SV> break ; //<S2SV> case SSL3_ST_SR_KEY_EXCH_A : //<S2SV> case SSL3_ST_SR_KEY_EXCH_B : //<S2SV> ret = ssl3_get_client_key_exchange ( s ) ; //<S2SV> if ( ret <= 0 ) //<S2SV> goto end ; //<S2SV> if ( ret == 2 ) //<S2SV> { //<S2SV> # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) //<S2SV> s -> state = SSL3_ST_SR_FINISHED_A ; //<S2SV> # else //<S2SV> if ( s -> s3 -> next_proto_neg_seen ) //<S2SV> s -> state = SSL3_ST_SR_NEXT_PROTO_A ; //<S2SV> else //<S2SV> s -> state = SSL3_ST_SR_FINISHED_A ; //<S2SV> # endif //<S2SV> s -> init_num = 0 ; //<S2SV> } //<S2SV> else if ( SSL_USE_SIGALGS ( s ) ) //<S2SV> { //<S2SV> s -> state = SSL3_ST_SR_CERT_VRFY_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> if ( ! s -> session -> peer ) //<S2SV> break ; //<S2SV> if ( ! s -> s3 -> handshake_buffer ) //<S2SV> { //<S2SV> SSLerr ( SSL_F_SSL3_ACCEPT , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> s -> s3 -> flags |= TLS1_FLAGS_KEEP_HANDSHAKE ; //<S2SV> if ( ! ssl3_digest_cached_records ( s ) ) //<S2SV> return - 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int offset = 0 ; //<S2SV> int dgst_num ; //<S2SV> s -> state = SSL3_ST_SR_CERT_VRFY_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> if ( s -> s3 -> handshake_buffer ) //<S2SV> if ( ! ssl3_digest_cached_records ( s ) ) //<S2SV> return - 1 ; //<S2SV> for ( dgst_num = 0 ; dgst_num < SSL_MAX_DIGEST ; dgst_num ++ ) //<S2SV> if ( s -> s3 -> handshake_dgst [ dgst_num ] ) //<S2SV> { //<S2SV> int dgst_size ; //<S2SV> s -> method -> ssl3_enc -> cert_verify_mac ( s , EVP_MD_CTX_type ( s -> s3 -> handshake_dgst [ dgst_num ] ) , & ( s -> s3 -> tmp . cert_verify_md [ offset ] ) ) ; //<S2SV> dgst_size = EVP_MD_CTX_size ( s -> s3 -> handshake_dgst [ dgst_num ] ) ; //<S2SV> if ( dgst_size < 0 ) //<S2SV> { //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> offset += dgst_size ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case SSL3_ST_SR_CERT_VRFY_A : //<S2SV> case SSL3_ST_SR_CERT_VRFY_B : //<S2SV> if ( ! s -> s3 -> change_cipher_spec ) //<S2SV> s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; //<S2SV> ret = ssl3_get_cert_verify ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) //<S2SV> s -> state = SSL3_ST_SR_FINISHED_A ; //<S2SV> # else //<S2SV> if ( s -> s3 -> next_proto_neg_seen ) //<S2SV> s -> state = SSL3_ST_SR_NEXT_PROTO_A ; //<S2SV> else //<S2SV> s -> state = SSL3_ST_SR_FINISHED_A ; //<S2SV> # endif //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> # if ! defined ( OPENSSL_NO_TLSEXT ) && ! defined ( OPENSSL_NO_NEXTPROTONEG ) //<S2SV> case SSL3_ST_SR_NEXT_PROTO_A : //<S2SV> case SSL3_ST_SR_NEXT_PROTO_B : //<S2SV> if ( ! s -> s3 -> change_cipher_spec ) //<S2SV> s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; //<S2SV> ret = ssl3_get_next_proto ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> s -> init_num = 0 ; //<S2SV> s -> state = SSL3_ST_SR_FINISHED_A ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case SSL3_ST_SR_FINISHED_A : //<S2SV> case SSL3_ST_SR_FINISHED_B : //<S2SV> if ( ! s -> s3 -> change_cipher_spec ) //<S2SV> s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; //<S2SV> ret = ssl3_get_finished ( s , SSL3_ST_SR_FINISHED_A , //<S2SV> SSL3_ST_SR_FINISHED_B ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> if ( s -> hit ) //<S2SV> s -> state = SSL_ST_OK ; //<S2SV> # ifndef OPENSSL_NO_TLSEXT //<S2SV> else if ( s -> tlsext_ticket_expected ) //<S2SV> s -> state = SSL3_ST_SW_SESSION_TICKET_A ; //<S2SV> # endif //<S2SV> else //<S2SV> s -> state = SSL3_ST_SW_CHANGE_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> # ifndef OPENSSL_NO_TLSEXT //<S2SV> case SSL3_ST_SW_SESSION_TICKET_A : //<S2SV> case SSL3_ST_SW_SESSION_TICKET_B : //<S2SV> ret = ssl3_send_newsession_ticket ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> s -> state = SSL3_ST_SW_CHANGE_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> case SSL3_ST_SW_CERT_STATUS_A : //<S2SV> case SSL3_ST_SW_CERT_STATUS_B : //<S2SV> ret = ssl3_send_cert_status ( s ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> s -> state = SSL3_ST_SW_KEY_EXCH_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case SSL3_ST_SW_CHANGE_A : //<S2SV> case SSL3_ST_SW_CHANGE_B : //<S2SV> s -> session -> cipher = s -> s3 -> tmp . new_cipher ; //<S2SV> if ( ! s -> method -> ssl3_enc -> setup_key_block ( s ) ) //<S2SV> { ret = - 1 ; goto end ; } //<S2SV> ret = ssl3_send_change_cipher_spec ( s , //<S2SV> SSL3_ST_SW_CHANGE_A , SSL3_ST_SW_CHANGE_B ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> s -> state = SSL3_ST_SW_FINISHED_A ; //<S2SV> s -> init_num = 0 ; //<S2SV> if ( ! s -> method -> ssl3_enc -> change_cipher_state ( s , //<S2SV> SSL3_CHANGE_CIPHER_SERVER_WRITE ) ) //<S2SV> { //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> break ; //<S2SV> case SSL3_ST_SW_FINISHED_A : //<S2SV> case SSL3_ST_SW_FINISHED_B : //<S2SV> ret = ssl3_send_finished ( s , //<S2SV> SSL3_ST_SW_FINISHED_A , SSL3_ST_SW_FINISHED_B , //<S2SV> s -> method -> ssl3_enc -> server_finished_label , //<S2SV> s -> method -> ssl3_enc -> server_finished_label_len ) ; //<S2SV> if ( ret <= 0 ) goto end ; //<S2SV> s -> state = SSL3_ST_SW_FLUSH ; //<S2SV> if ( s -> hit ) //<S2SV> { //<S2SV> # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) //<S2SV> s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ; //<S2SV> # else //<S2SV> if ( s -> s3 -> next_proto_neg_seen ) //<S2SV> { //<S2SV> s -> s3 -> tmp . next_state = SSL3_ST_SR_NEXT_PROTO_A ; //<S2SV> } //<S2SV> else //<S2SV> s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ; //<S2SV> # endif //<S2SV> } //<S2SV> else //<S2SV> s -> s3 -> tmp . next_state = SSL_ST_OK ; //<S2SV> s -> init_num = 0 ; //<S2SV> break ; //<S2SV> case SSL_ST_OK : //<S2SV> ssl3_cleanup_key_block ( s ) ; //<S2SV> BUF_MEM_free ( s -> init_buf ) ; //<S2SV> s -> init_buf = NULL ; //<S2SV> ssl_free_wbio_buffer ( s ) ; //<S2SV> s -> init_num = 0 ; //<S2SV> if ( s -> renegotiate == 2 ) //<S2SV> { //<S2SV> s -> renegotiate = 0 ; //<S2SV> s -> new_session = 0 ; //<S2SV> ssl_update_cache ( s , SSL_SESS_CACHE_SERVER ) ; //<S2SV> s -> ctx -> stats . sess_accept_good ++ ; //<S2SV> s -> handshake_func = ssl3_accept ; //<S2SV> if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_DONE , 1 ) ; //<S2SV> } //<S2SV> ret = 1 ; //<S2SV> goto end ; //<S2SV> default : //<S2SV> SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_UNKNOWN_STATE ) ; //<S2SV> ret = - 1 ; //<S2SV> goto end ; //<S2SV> } //<S2SV> if ( ! s -> s3 -> tmp . reuse_message && ! skip ) //<S2SV> { //<S2SV> if ( s -> debug ) //<S2SV> { //<S2SV> if ( ( ret = BIO_flush ( s -> wbio ) ) <= 0 ) //<S2SV> goto end ; //<S2SV> } //<S2SV> if ( ( cb != NULL ) && ( s -> state != state ) ) //<S2SV> { //<S2SV> new_state = s -> state ; //<S2SV> s -> state = state ; //<S2SV> cb ( s , SSL_CB_ACCEPT_LOOP , 1 ) ; //<S2SV> s -> state = new_state ; //<S2SV> } //<S2SV> } //<S2SV> skip = 0 ; //<S2SV> } //<S2SV> end : //<S2SV> s -> in_handshake -- ; //<S2SV> if ( cb != NULL ) //<S2SV> cb ( s , SSL_CB_ACCEPT_EXIT , ret ) ; //<S2SV> return ( ret ) ; //<S2SV> } //<S2SV> 