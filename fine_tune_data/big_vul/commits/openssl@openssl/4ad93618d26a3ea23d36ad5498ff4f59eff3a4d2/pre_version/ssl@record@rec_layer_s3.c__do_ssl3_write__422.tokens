int do_ssl3_write ( SSL * s , int type , const unsigned char * buf , //<S2SV> unsigned int * pipelens , unsigned int numpipes , //<S2SV> int create_empty_fragment ) //<S2SV> { //<S2SV> unsigned char * outbuf [ SSL_MAX_PIPELINES ] , * plen [ SSL_MAX_PIPELINES ] ; //<S2SV> SSL3_RECORD wr [ SSL_MAX_PIPELINES ] ; //<S2SV> int i , mac_size , clear = 0 ; //<S2SV> int prefix_len = 0 ; //<S2SV> int eivlen ; //<S2SV> size_t align = 0 ; //<S2SV> SSL3_BUFFER * wb ; //<S2SV> SSL_SESSION * sess ; //<S2SV> unsigned int totlen = 0 ; //<S2SV> unsigned int j ; //<S2SV> for ( j = 0 ; j < numpipes ; j ++ ) //<S2SV> totlen += pipelens [ j ] ; //<S2SV> if ( RECORD_LAYER_write_pending ( & s -> rlayer ) ) //<S2SV> return ( ssl3_write_pending ( s , type , buf , totlen ) ) ; //<S2SV> if ( s -> s3 -> alert_dispatch ) { //<S2SV> i = s -> method -> ssl_dispatch_alert ( s ) ; //<S2SV> if ( i <= 0 ) //<S2SV> return ( i ) ; //<S2SV> } //<S2SV> if ( s -> rlayer . numwpipes < numpipes ) //<S2SV> if ( ! ssl3_setup_write_buffer ( s , numpipes , 0 ) ) //<S2SV> return - 1 ; //<S2SV> if ( totlen == 0 && ! create_empty_fragment ) //<S2SV> return 0 ; //<S2SV> sess = s -> session ; //<S2SV> if ( ( sess == NULL ) || //<S2SV> ( s -> enc_write_ctx == NULL ) || ( EVP_MD_CTX_md ( s -> write_hash ) == NULL ) ) { //<S2SV> clear = s -> enc_write_ctx ? 0 : 1 ; //<S2SV> mac_size = 0 ; //<S2SV> } else { //<S2SV> mac_size = EVP_MD_CTX_size ( s -> write_hash ) ; //<S2SV> if ( mac_size < 0 ) //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( ! clear && ! create_empty_fragment && ! s -> s3 -> empty_fragment_done ) { //<S2SV> if ( s -> s3 -> need_empty_fragments && type == SSL3_RT_APPLICATION_DATA ) { //<S2SV> unsigned int tmppipelen = 0 ; //<S2SV> prefix_len = do_ssl3_write ( s , type , buf , & tmppipelen , 1 , 1 ) ; //<S2SV> if ( prefix_len <= 0 ) //<S2SV> goto err ; //<S2SV> if ( prefix_len > //<S2SV> ( SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD ) ) { //<S2SV> SSLerr ( SSL_F_DO_SSL3_WRITE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> } //<S2SV> s -> s3 -> empty_fragment_done = 1 ; //<S2SV> } //<S2SV> if ( create_empty_fragment ) { //<S2SV> wb = & s -> rlayer . wbuf [ 0 ] ; //<S2SV> # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 //<S2SV> align = ( size_t ) SSL3_BUFFER_get_buf ( wb ) + 2 * SSL3_RT_HEADER_LENGTH ; //<S2SV> align = SSL3_ALIGN_PAYLOAD - 1 - ( ( align - 1 ) % SSL3_ALIGN_PAYLOAD ) ; //<S2SV> # endif //<S2SV> outbuf [ 0 ] = SSL3_BUFFER_get_buf ( wb ) + align ; //<S2SV> SSL3_BUFFER_set_offset ( wb , align ) ; //<S2SV> } else if ( prefix_len ) { //<S2SV> wb = & s -> rlayer . wbuf [ 0 ] ; //<S2SV> outbuf [ 0 ] = SSL3_BUFFER_get_buf ( wb ) + SSL3_BUFFER_get_offset ( wb ) //<S2SV> + prefix_len ; //<S2SV> } else { //<S2SV> for ( j = 0 ; j < numpipes ; j ++ ) { //<S2SV> wb = & s -> rlayer . wbuf [ j ] ; //<S2SV> # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 //<S2SV> align = ( size_t ) SSL3_BUFFER_get_buf ( wb ) + SSL3_RT_HEADER_LENGTH ; //<S2SV> align = SSL3_ALIGN_PAYLOAD - 1 - ( ( align - 1 ) % SSL3_ALIGN_PAYLOAD ) ; //<S2SV> # endif //<S2SV> outbuf [ j ] = SSL3_BUFFER_get_buf ( wb ) + align ; //<S2SV> SSL3_BUFFER_set_offset ( wb , align ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( s -> enc_write_ctx && SSL_USE_EXPLICIT_IV ( s ) ) { //<S2SV> int mode = EVP_CIPHER_CTX_mode ( s -> enc_write_ctx ) ; //<S2SV> if ( mode == EVP_CIPH_CBC_MODE ) { //<S2SV> eivlen = EVP_CIPHER_CTX_iv_length ( s -> enc_write_ctx ) ; //<S2SV> if ( eivlen <= 1 ) //<S2SV> eivlen = 0 ; //<S2SV> } //<S2SV> else if ( mode == EVP_CIPH_GCM_MODE ) //<S2SV> eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> else if ( mode == EVP_CIPH_CCM_MODE ) //<S2SV> eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> else //<S2SV> eivlen = 0 ; //<S2SV> } else //<S2SV> eivlen = 0 ; //<S2SV> totlen = 0 ; //<S2SV> memset ( wr , 0 , sizeof wr ) ; //<S2SV> for ( j = 0 ; j < numpipes ; j ++ ) { //<S2SV> * ( outbuf [ j ] ++ ) = type & 0xff ; //<S2SV> SSL3_RECORD_set_type ( & wr [ j ] , type ) ; //<S2SV> * ( outbuf [ j ] ++ ) = ( s -> version >> 8 ) ; //<S2SV> if ( SSL_get_state ( s ) == TLS_ST_CW_CLNT_HELLO //<S2SV> && ! s -> renegotiate && TLS1_get_version ( s ) > TLS1_VERSION ) //<S2SV> * ( outbuf [ j ] ++ ) = 0x1 ; //<S2SV> else //<S2SV> * ( outbuf [ j ] ++ ) = s -> version & 0xff ; //<S2SV> plen [ j ] = outbuf [ j ] ; //<S2SV> outbuf [ j ] += 2 ; //<S2SV> SSL3_RECORD_set_data ( & wr [ j ] , outbuf [ j ] + eivlen ) ; //<S2SV> SSL3_RECORD_set_length ( & wr [ j ] , ( int ) pipelens [ j ] ) ; //<S2SV> SSL3_RECORD_set_input ( & wr [ j ] , ( unsigned char * ) & buf [ totlen ] ) ; //<S2SV> totlen += pipelens [ j ] ; //<S2SV> if ( s -> compress != NULL ) { //<S2SV> if ( ! ssl3_do_compress ( s , & wr [ j ] ) ) { //<S2SV> SSLerr ( SSL_F_DO_SSL3_WRITE , SSL_R_COMPRESSION_FAILURE ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> } else { //<S2SV> memcpy ( wr [ j ] . data , wr [ j ] . input , wr [ j ] . length ) ; //<S2SV> SSL3_RECORD_reset_input ( & wr [ j ] ) ; //<S2SV> } //<S2SV> if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) { //<S2SV> if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , //<S2SV> & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , //<S2SV> 1 ) < 0 ) //<S2SV> goto err ; //<S2SV> SSL3_RECORD_add_length ( & wr [ j ] , mac_size ) ; //<S2SV> } //<S2SV> SSL3_RECORD_set_data ( & wr [ j ] , outbuf [ j ] ) ; //<S2SV> SSL3_RECORD_reset_input ( & wr [ j ] ) ; //<S2SV> if ( eivlen ) { //<S2SV> SSL3_RECORD_add_length ( & wr [ j ] , eivlen ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( s -> method -> ssl3_enc -> enc ( s , wr , numpipes , 1 ) < 1 ) //<S2SV> goto err ; //<S2SV> for ( j = 0 ; j < numpipes ; j ++ ) { //<S2SV> if ( SSL_USE_ETM ( s ) && mac_size != 0 ) { //<S2SV> if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , //<S2SV> outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) //<S2SV> goto err ; //<S2SV> SSL3_RECORD_add_length ( & wr [ j ] , mac_size ) ; //<S2SV> } //<S2SV> s2n ( SSL3_RECORD_get_length ( & wr [ j ] ) , plen [ j ] ) ; //<S2SV> if ( s -> msg_callback ) //<S2SV> s -> msg_callback ( 1 , 0 , SSL3_RT_HEADER , plen [ j ] - 5 , 5 , s , //<S2SV> s -> msg_callback_arg ) ; //<S2SV> SSL3_RECORD_set_type ( & wr [ j ] , type ) ; //<S2SV> SSL3_RECORD_add_length ( & wr [ j ] , SSL3_RT_HEADER_LENGTH ) ; //<S2SV> if ( create_empty_fragment ) { //<S2SV> if ( j > 0 ) { //<S2SV> SSLerr ( SSL_F_DO_SSL3_WRITE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> return SSL3_RECORD_get_length ( wr ) ; //<S2SV> } //<S2SV> SSL3_BUFFER_set_left ( & s -> rlayer . wbuf [ j ] , //<S2SV> prefix_len + SSL3_RECORD_get_length ( & wr [ j ] ) ) ; //<S2SV> } //<S2SV> s -> rlayer . wpend_tot = totlen ; //<S2SV> s -> rlayer . wpend_buf = buf ; //<S2SV> s -> rlayer . wpend_type = type ; //<S2SV> s -> rlayer . wpend_ret = totlen ; //<S2SV> return ssl3_write_pending ( s , type , buf , totlen ) ; //<S2SV> err : //<S2SV> return - 1 ; //<S2SV> } //<S2SV> 