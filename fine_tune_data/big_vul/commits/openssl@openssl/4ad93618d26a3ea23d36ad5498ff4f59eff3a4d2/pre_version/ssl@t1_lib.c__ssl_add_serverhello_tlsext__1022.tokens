unsigned char * ssl_add_serverhello_tlsext ( SSL * s , unsigned char * buf , //<S2SV> unsigned char * limit , int * al ) //<S2SV> { //<S2SV> int extdatalen = 0 ; //<S2SV> unsigned char * orig = buf ; //<S2SV> unsigned char * ret = buf ; //<S2SV> # ifndef OPENSSL_NO_NEXTPROTONEG //<S2SV> int next_proto_neg_seen ; //<S2SV> # endif //<S2SV> # ifndef OPENSSL_NO_EC //<S2SV> unsigned long alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; //<S2SV> unsigned long alg_a = s -> s3 -> tmp . new_cipher -> algorithm_auth ; //<S2SV> int using_ecc = ( alg_k & SSL_kECDHE ) || ( alg_a & SSL_aECDSA ) ; //<S2SV> using_ecc = using_ecc && ( s -> session -> tlsext_ecpointformatlist != NULL ) ; //<S2SV> # endif //<S2SV> ret += 2 ; //<S2SV> if ( ret >= limit ) //<S2SV> return NULL ; //<S2SV> if ( s -> s3 -> send_connection_binding ) { //<S2SV> int el ; //<S2SV> if ( ! ssl_add_serverhello_renegotiate_ext ( s , 0 , & el , 0 ) ) { //<S2SV> SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( CHECKLEN ( ret , 4 + el , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_renegotiate , ret ) ; //<S2SV> s2n ( el , ret ) ; //<S2SV> if ( ! ssl_add_serverhello_renegotiate_ext ( s , ret , & el , el ) ) { //<S2SV> SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> ret += el ; //<S2SV> } //<S2SV> if ( s -> version == SSL3_VERSION ) //<S2SV> goto done ; //<S2SV> if ( ! s -> hit && s -> servername_done == 1 //<S2SV> && s -> session -> tlsext_hostname != NULL ) { //<S2SV> if ( CHECKLEN ( ret , 4 , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_server_name , ret ) ; //<S2SV> s2n ( 0 , ret ) ; //<S2SV> } //<S2SV> # ifndef OPENSSL_NO_EC //<S2SV> if ( using_ecc ) { //<S2SV> const unsigned char * plist ; //<S2SV> size_t plistlen ; //<S2SV> tls1_get_formatlist ( s , & plist , & plistlen ) ; //<S2SV> if ( plistlen > 255 ) { //<S2SV> SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( CHECKLEN ( ret , 5 + plistlen , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_ec_point_formats , ret ) ; //<S2SV> s2n ( plistlen + 1 , ret ) ; //<S2SV> * ( ret ++ ) = ( unsigned char ) plistlen ; //<S2SV> memcpy ( ret , plist , plistlen ) ; //<S2SV> ret += plistlen ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( s -> tlsext_ticket_expected && tls_use_ticket ( s ) ) { //<S2SV> if ( CHECKLEN ( ret , 4 , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_session_ticket , ret ) ; //<S2SV> s2n ( 0 , ret ) ; //<S2SV> } else { //<S2SV> s -> tlsext_ticket_expected = 0 ; //<S2SV> } //<S2SV> if ( s -> tlsext_status_expected ) { //<S2SV> if ( CHECKLEN ( ret , 4 , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_status_request , ret ) ; //<S2SV> s2n ( 0 , ret ) ; //<S2SV> } //<S2SV> # ifndef OPENSSL_NO_SRTP //<S2SV> if ( SSL_IS_DTLS ( s ) && s -> srtp_profile ) { //<S2SV> int el ; //<S2SV> if ( ssl_add_serverhello_use_srtp_ext ( s , 0 , & el , 0 ) ) { //<S2SV> SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( CHECKLEN ( ret , 4 + el , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_use_srtp , ret ) ; //<S2SV> s2n ( el , ret ) ; //<S2SV> if ( ssl_add_serverhello_use_srtp_ext ( s , ret , & el , el ) ) { //<S2SV> SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> ret += el ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ( ( s -> s3 -> tmp . new_cipher -> id & 0xFFFF ) == 0x80 //<S2SV> || ( s -> s3 -> tmp . new_cipher -> id & 0xFFFF ) == 0x81 ) //<S2SV> && ( SSL_get_options ( s ) & SSL_OP_CRYPTOPRO_TLSEXT_BUG ) ) { //<S2SV> const unsigned char cryptopro_ext [ 36 ] = { //<S2SV> 0xfd , 0xe8 , //<S2SV> 0x00 , 0x20 , //<S2SV> 0x30 , 0x1e , 0x30 , 0x08 , 0x06 , 0x06 , 0x2a , 0x85 , //<S2SV> 0x03 , 0x02 , 0x02 , 0x09 , 0x30 , 0x08 , 0x06 , 0x06 , //<S2SV> 0x2a , 0x85 , 0x03 , 0x02 , 0x02 , 0x16 , 0x30 , 0x08 , //<S2SV> 0x06 , 0x06 , 0x2a , 0x85 , 0x03 , 0x02 , 0x02 , 0x17 //<S2SV> } ; //<S2SV> if ( CHECKLEN ( ret , sizeof ( cryptopro_ext ) , limit ) ) //<S2SV> return NULL ; //<S2SV> memcpy ( ret , cryptopro_ext , sizeof ( cryptopro_ext ) ) ; //<S2SV> ret += sizeof ( cryptopro_ext ) ; //<S2SV> } //<S2SV> # ifndef OPENSSL_NO_HEARTBEATS //<S2SV> if ( SSL_IS_DTLS ( s ) && ( s -> tlsext_heartbeat & SSL_DTLSEXT_HB_ENABLED ) ) { //<S2SV> if ( CHECKLEN ( ret , 5 , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_heartbeat , ret ) ; //<S2SV> s2n ( 1 , ret ) ; //<S2SV> if ( s -> tlsext_heartbeat & SSL_DTLSEXT_HB_DONT_RECV_REQUESTS ) //<S2SV> * ( ret ++ ) = SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; //<S2SV> else //<S2SV> * ( ret ++ ) = SSL_DTLSEXT_HB_ENABLED ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifndef OPENSSL_NO_NEXTPROTONEG //<S2SV> next_proto_neg_seen = s -> s3 -> next_proto_neg_seen ; //<S2SV> s -> s3 -> next_proto_neg_seen = 0 ; //<S2SV> if ( next_proto_neg_seen && s -> ctx -> next_protos_advertised_cb ) { //<S2SV> const unsigned char * npa ; //<S2SV> unsigned int npalen ; //<S2SV> int r ; //<S2SV> r = s -> ctx -> next_protos_advertised_cb ( s , & npa , & npalen , //<S2SV> s -> //<S2SV> ctx -> next_protos_advertised_cb_arg ) ; //<S2SV> if ( r == SSL_TLSEXT_ERR_OK ) { //<S2SV> if ( CHECKLEN ( ret , 4 + npalen , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_next_proto_neg , ret ) ; //<S2SV> s2n ( npalen , ret ) ; //<S2SV> memcpy ( ret , npa , npalen ) ; //<S2SV> ret += npalen ; //<S2SV> s -> s3 -> next_proto_neg_seen = 1 ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! custom_ext_add ( s , 1 , & ret , limit , al ) ) //<S2SV> return NULL ; //<S2SV> if ( s -> s3 -> flags & TLS1_FLAGS_ENCRYPT_THEN_MAC ) { //<S2SV> if ( SSL_IS_DTLS ( s ) || s -> s3 -> tmp . new_cipher -> algorithm_mac == SSL_AEAD //<S2SV> || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_RC4 //<S2SV> || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_eGOST2814789CNT //<S2SV> || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_eGOST2814789CNT12 ) //<S2SV> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; //<S2SV> else { //<S2SV> if ( CHECKLEN ( ret , 4 , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_encrypt_then_mac , ret ) ; //<S2SV> s2n ( 0 , ret ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( s -> s3 -> flags & TLS1_FLAGS_RECEIVED_EXTMS ) { //<S2SV> if ( CHECKLEN ( ret , 4 , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_extended_master_secret , ret ) ; //<S2SV> s2n ( 0 , ret ) ; //<S2SV> } //<S2SV> if ( s -> s3 -> alpn_selected != NULL ) { //<S2SV> const unsigned char * selected = s -> s3 -> alpn_selected ; //<S2SV> size_t len = s -> s3 -> alpn_selected_len ; //<S2SV> if ( CHECKLEN ( ret , 7 + len , limit ) ) //<S2SV> return NULL ; //<S2SV> s2n ( TLSEXT_TYPE_application_layer_protocol_negotiation , ret ) ; //<S2SV> s2n ( 3 + len , ret ) ; //<S2SV> s2n ( 1 + len , ret ) ; //<S2SV> * ret ++ = len ; //<S2SV> memcpy ( ret , selected , len ) ; //<S2SV> ret += len ; //<S2SV> } //<S2SV> done : //<S2SV> if ( ( extdatalen = ret - orig - 2 ) == 0 ) //<S2SV> return orig ; //<S2SV> s2n ( extdatalen , orig ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 