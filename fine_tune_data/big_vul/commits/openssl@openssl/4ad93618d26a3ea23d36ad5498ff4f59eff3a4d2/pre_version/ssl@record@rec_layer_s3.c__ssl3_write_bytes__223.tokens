int ssl3_write_bytes ( SSL * s , int type , const void * buf_ , int len ) //<S2SV> { //<S2SV> const unsigned char * buf = buf_ ; //<S2SV> int tot ; //<S2SV> unsigned int n , split_send_fragment , maxpipes ; //<S2SV> # if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK //<S2SV> unsigned int max_send_fragment , nw ; //<S2SV> unsigned int u_len = ( unsigned int ) len ; //<S2SV> # endif //<S2SV> SSL3_BUFFER * wb = & s -> rlayer . wbuf [ 0 ] ; //<S2SV> int i ; //<S2SV> if ( len < 0 ) { //<S2SV> SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_NEGATIVE_LENGTH ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> s -> rwstate = SSL_NOTHING ; //<S2SV> tot = s -> rlayer . wnum ; //<S2SV> if ( ( unsigned int ) len < s -> rlayer . wnum ) { //<S2SV> SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_BAD_LENGTH ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> s -> rlayer . wnum = 0 ; //<S2SV> if ( SSL_in_init ( s ) && ! ossl_statem_get_in_handshake ( s ) ) { //<S2SV> i = s -> handshake_func ( s ) ; //<S2SV> if ( i < 0 ) //<S2SV> return ( i ) ; //<S2SV> if ( i == 0 ) { //<S2SV> SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( wb -> left != 0 ) { //<S2SV> i = ssl3_write_pending ( s , type , & buf [ tot ] , s -> rlayer . wpend_tot ) ; //<S2SV> if ( i <= 0 ) { //<S2SV> s -> rlayer . wnum = tot ; //<S2SV> return i ; //<S2SV> } //<S2SV> tot += i ; //<S2SV> } //<S2SV> # if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK //<S2SV> if ( type == SSL3_RT_APPLICATION_DATA && //<S2SV> u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && //<S2SV> s -> compress == NULL && s -> msg_callback == NULL && //<S2SV> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && //<S2SV> EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & //<S2SV> EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) { //<S2SV> unsigned char aad [ 13 ] ; //<S2SV> EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param ; //<S2SV> int packlen ; //<S2SV> if ( ( max_send_fragment & 0xfff ) == 0 ) //<S2SV> max_send_fragment -= 512 ; //<S2SV> if ( tot == 0 || wb -> buf == NULL ) { //<S2SV> ssl3_release_write_buffer ( s ) ; //<S2SV> packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , //<S2SV> EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE , //<S2SV> max_send_fragment , NULL ) ; //<S2SV> if ( u_len >= 8 * max_send_fragment ) //<S2SV> packlen *= 8 ; //<S2SV> else //<S2SV> packlen *= 4 ; //<S2SV> if ( ! ssl3_setup_write_buffer ( s , 1 , packlen ) ) { //<S2SV> SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_MALLOC_FAILURE ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } else if ( tot == len ) { //<S2SV> ssl3_release_write_buffer ( s ) ; //<S2SV> return tot ; //<S2SV> } //<S2SV> n = ( len - tot ) ; //<S2SV> for ( ; ; ) { //<S2SV> if ( n < 4 * max_send_fragment ) { //<S2SV> ssl3_release_write_buffer ( s ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( s -> s3 -> alert_dispatch ) { //<S2SV> i = s -> method -> ssl_dispatch_alert ( s ) ; //<S2SV> if ( i <= 0 ) { //<S2SV> s -> rlayer . wnum = tot ; //<S2SV> return i ; //<S2SV> } //<S2SV> } //<S2SV> if ( n >= 8 * max_send_fragment ) //<S2SV> nw = max_send_fragment * ( mb_param . interleave = 8 ) ; //<S2SV> else //<S2SV> nw = max_send_fragment * ( mb_param . interleave = 4 ) ; //<S2SV> memcpy ( aad , s -> rlayer . write_sequence , 8 ) ; //<S2SV> aad [ 8 ] = type ; //<S2SV> aad [ 9 ] = ( unsigned char ) ( s -> version >> 8 ) ; //<S2SV> aad [ 10 ] = ( unsigned char ) ( s -> version ) ; //<S2SV> aad [ 11 ] = 0 ; //<S2SV> aad [ 12 ] = 0 ; //<S2SV> mb_param . out = NULL ; //<S2SV> mb_param . inp = aad ; //<S2SV> mb_param . len = nw ; //<S2SV> packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , //<S2SV> EVP_CTRL_TLS1_1_MULTIBLOCK_AAD , //<S2SV> sizeof ( mb_param ) , & mb_param ) ; //<S2SV> if ( packlen <= 0 || packlen > ( int ) wb -> len ) { //<S2SV> ssl3_release_write_buffer ( s ) ; //<S2SV> break ; //<S2SV> } //<S2SV> mb_param . out = wb -> buf ; //<S2SV> mb_param . inp = & buf [ tot ] ; //<S2SV> mb_param . len = nw ; //<S2SV> if ( EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , //<S2SV> EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT , //<S2SV> sizeof ( mb_param ) , & mb_param ) <= 0 ) //<S2SV> return - 1 ; //<S2SV> s -> rlayer . write_sequence [ 7 ] += mb_param . interleave ; //<S2SV> if ( s -> rlayer . write_sequence [ 7 ] < mb_param . interleave ) { //<S2SV> int j = 6 ; //<S2SV> while ( j >= 0 && ( ++ s -> rlayer . write_sequence [ j -- ] ) == 0 ) ; //<S2SV> } //<S2SV> wb -> offset = 0 ; //<S2SV> wb -> left = packlen ; //<S2SV> s -> rlayer . wpend_tot = nw ; //<S2SV> s -> rlayer . wpend_buf = & buf [ tot ] ; //<S2SV> s -> rlayer . wpend_type = type ; //<S2SV> s -> rlayer . wpend_ret = nw ; //<S2SV> i = ssl3_write_pending ( s , type , & buf [ tot ] , nw ) ; //<S2SV> if ( i <= 0 ) { //<S2SV> if ( i < 0 && ( ! s -> wbio || ! BIO_should_retry ( s -> wbio ) ) ) { //<S2SV> ssl3_release_write_buffer ( s ) ; //<S2SV> } //<S2SV> s -> rlayer . wnum = tot ; //<S2SV> return i ; //<S2SV> } //<S2SV> if ( i == ( int ) n ) { //<S2SV> ssl3_release_write_buffer ( s ) ; //<S2SV> return tot + i ; //<S2SV> } //<S2SV> n -= i ; //<S2SV> tot += i ; //<S2SV> } //<S2SV> } else //<S2SV> # endif //<S2SV> if ( tot == len ) { //<S2SV> if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) //<S2SV> ssl3_release_write_buffer ( s ) ; //<S2SV> return tot ; //<S2SV> } //<S2SV> n = ( len - tot ) ; //<S2SV> split_send_fragment = s -> split_send_fragment ; //<S2SV> maxpipes = s -> max_pipelines ; //<S2SV> if ( maxpipes > SSL_MAX_PIPELINES ) { //<S2SV> SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( maxpipes == 0 //<S2SV> || s -> enc_write_ctx == NULL //<S2SV> || ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) //<S2SV> & EVP_CIPH_FLAG_PIPELINE ) //<S2SV> || ! SSL_USE_EXPLICIT_IV ( s ) ) //<S2SV> maxpipes = 1 ; //<S2SV> if ( s -> max_send_fragment == 0 || split_send_fragment > s -> max_send_fragment //<S2SV> || split_send_fragment == 0 ) { //<S2SV> SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> for ( ; ; ) { //<S2SV> unsigned int pipelens [ SSL_MAX_PIPELINES ] , tmppipelen , remain ; //<S2SV> unsigned int numpipes , j ; //<S2SV> if ( n == 0 ) //<S2SV> numpipes = 1 ; //<S2SV> else //<S2SV> numpipes = ( ( n - 1 ) / split_send_fragment ) + 1 ; //<S2SV> if ( numpipes > maxpipes ) //<S2SV> numpipes = maxpipes ; //<S2SV> if ( n / numpipes >= s -> max_send_fragment ) { //<S2SV> for ( j = 0 ; j < numpipes ; j ++ ) { //<S2SV> pipelens [ j ] = s -> max_send_fragment ; //<S2SV> } //<S2SV> } else { //<S2SV> tmppipelen = n / numpipes ; //<S2SV> remain = n % numpipes ; //<S2SV> for ( j = 0 ; j < numpipes ; j ++ ) { //<S2SV> pipelens [ j ] = tmppipelen ; //<S2SV> if ( j < remain ) //<S2SV> pipelens [ j ] ++ ; //<S2SV> } //<S2SV> } //<S2SV> i = do_ssl3_write ( s , type , & ( buf [ tot ] ) , pipelens , numpipes , 0 ) ; //<S2SV> if ( i <= 0 ) { //<S2SV> s -> rlayer . wnum = tot ; //<S2SV> return i ; //<S2SV> } //<S2SV> if ( ( i == ( int ) n ) || //<S2SV> ( type == SSL3_RT_APPLICATION_DATA && //<S2SV> ( s -> mode & SSL_MODE_ENABLE_PARTIAL_WRITE ) ) ) { //<S2SV> s -> s3 -> empty_fragment_done = 0 ; //<S2SV> if ( ( i == ( int ) n ) && s -> mode & SSL_MODE_RELEASE_BUFFERS && //<S2SV> ! SSL_IS_DTLS ( s ) ) //<S2SV> ssl3_release_write_buffer ( s ) ; //<S2SV> return tot + i ; //<S2SV> } //<S2SV> n -= i ; //<S2SV> tot += i ; //<S2SV> } //<S2SV> } //<S2SV> 