int tls1_mac ( SSL * ssl , SSL3_RECORD * rec , unsigned char * md , int send ) //<S2SV> { //<S2SV> unsigned char * seq ; //<S2SV> EVP_MD_CTX * hash ; //<S2SV> size_t md_size ; //<S2SV> int i ; //<S2SV> EVP_MD_CTX * hmac = NULL , * mac_ctx ; //<S2SV> unsigned char header [ 13 ] ; //<S2SV> int stream_mac = ( send ? ( ssl -> mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM ) //<S2SV> : ( ssl -> mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM ) ) ; //<S2SV> int t ; //<S2SV> if ( send ) { //<S2SV> seq = RECORD_LAYER_get_write_sequence ( & ssl -> rlayer ) ; //<S2SV> hash = ssl -> write_hash ; //<S2SV> } else { //<S2SV> seq = RECORD_LAYER_get_read_sequence ( & ssl -> rlayer ) ; //<S2SV> hash = ssl -> read_hash ; //<S2SV> } //<S2SV> t = EVP_MD_CTX_size ( hash ) ; //<S2SV> OPENSSL_assert ( t >= 0 ) ; //<S2SV> md_size = t ; //<S2SV> if ( stream_mac ) { //<S2SV> mac_ctx = hash ; //<S2SV> } else { //<S2SV> hmac = EVP_MD_CTX_new ( ) ; //<S2SV> if ( hmac == NULL || ! EVP_MD_CTX_copy ( hmac , hash ) ) //<S2SV> return - 1 ; //<S2SV> mac_ctx = hmac ; //<S2SV> } //<S2SV> if ( SSL_IS_DTLS ( ssl ) ) { //<S2SV> unsigned char dtlsseq [ 8 ] , * p = dtlsseq ; //<S2SV> s2n ( send ? DTLS_RECORD_LAYER_get_w_epoch ( & ssl -> rlayer ) : //<S2SV> DTLS_RECORD_LAYER_get_r_epoch ( & ssl -> rlayer ) , p ) ; //<S2SV> memcpy ( p , & seq [ 2 ] , 6 ) ; //<S2SV> memcpy ( header , dtlsseq , 8 ) ; //<S2SV> } else //<S2SV> memcpy ( header , seq , 8 ) ; //<S2SV> header [ 8 ] = rec -> type ; //<S2SV> header [ 9 ] = ( unsigned char ) ( ssl -> version >> 8 ) ; //<S2SV> header [ 10 ] = ( unsigned char ) ( ssl -> version ) ; //<S2SV> header [ 11 ] = ( rec -> length ) >> 8 ; //<S2SV> header [ 12 ] = ( rec -> length ) & 0xff ; //<S2SV> if ( ! send && ! SSL_READ_ETM ( ssl ) && //<S2SV> EVP_CIPHER_CTX_mode ( ssl -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && //<S2SV> ssl3_cbc_record_digest_supported ( mac_ctx ) ) { //<S2SV> if ( ssl3_cbc_digest_record ( mac_ctx , //<S2SV> md , & md_size , //<S2SV> header , rec -> input , //<S2SV> rec -> length + md_size , rec -> orig_len , //<S2SV> ssl -> s3 -> read_mac_secret , //<S2SV> ssl -> s3 -> read_mac_secret_size , 0 ) <= 0 ) { //<S2SV> EVP_MD_CTX_free ( hmac ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( EVP_DigestSignUpdate ( mac_ctx , header , sizeof ( header ) ) <= 0 //<S2SV> || EVP_DigestSignUpdate ( mac_ctx , rec -> input , rec -> length ) <= 0 //<S2SV> || EVP_DigestSignFinal ( mac_ctx , md , & md_size ) <= 0 ) { //<S2SV> EVP_MD_CTX_free ( hmac ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( ! send && ! SSL_READ_ETM ( ssl ) && FIPS_mode ( ) ) //<S2SV> if ( ! tls_fips_digest_extra ( ssl -> enc_read_ctx , //<S2SV> mac_ctx , rec -> input , //<S2SV> rec -> length , rec -> orig_len ) ) { //<S2SV> EVP_MD_CTX_free ( hmac ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> EVP_MD_CTX_free ( hmac ) ; //<S2SV> # ifdef SSL_DEBUG //<S2SV> fprintf ( stderr , "seq=" ) ; //<S2SV> { //<S2SV> int z ; //<S2SV> for ( z = 0 ; z < 8 ; z ++ ) //<S2SV> fprintf ( stderr , "%02X<S2SV_blank>" , seq [ z ] ) ; //<S2SV> fprintf ( stderr , "\\n" ) ; //<S2SV> } //<S2SV> fprintf ( stderr , "rec=" ) ; //<S2SV> { //<S2SV> unsigned int z ; //<S2SV> for ( z = 0 ; z < rec -> length ; z ++ ) //<S2SV> fprintf ( stderr , "%02X<S2SV_blank>" , rec -> data [ z ] ) ; //<S2SV> fprintf ( stderr , "\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! SSL_IS_DTLS ( ssl ) ) { //<S2SV> for ( i = 7 ; i >= 0 ; i -- ) { //<S2SV> ++ seq [ i ] ; //<S2SV> if ( seq [ i ] != 0 ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> # ifdef SSL_DEBUG //<S2SV> { //<S2SV> unsigned int z ; //<S2SV> for ( z = 0 ; z < md_size ; z ++ ) //<S2SV> fprintf ( stderr , "%02X<S2SV_blank>" , md [ z ] ) ; //<S2SV> fprintf ( stderr , "\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> return ( md_size ) ; //<S2SV> } //<S2SV> 