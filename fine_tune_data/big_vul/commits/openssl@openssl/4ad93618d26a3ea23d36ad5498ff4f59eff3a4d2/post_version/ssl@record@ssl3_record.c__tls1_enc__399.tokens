int tls1_enc ( SSL * s , SSL3_RECORD * recs , unsigned int n_recs , int send ) //<S2SV> { //<S2SV> EVP_CIPHER_CTX * ds ; //<S2SV> size_t reclen [ SSL_MAX_PIPELINES ] ; //<S2SV> unsigned char buf [ SSL_MAX_PIPELINES ] [ EVP_AEAD_TLS1_AAD_LEN ] ; //<S2SV> int bs , i , j , k , pad = 0 , ret , mac_size = 0 ; //<S2SV> const EVP_CIPHER * enc ; //<S2SV> unsigned int ctr ; //<S2SV> if ( send ) { //<S2SV> if ( EVP_MD_CTX_md ( s -> write_hash ) ) { //<S2SV> int n = EVP_MD_CTX_size ( s -> write_hash ) ; //<S2SV> OPENSSL_assert ( n >= 0 ) ; //<S2SV> } //<S2SV> ds = s -> enc_write_ctx ; //<S2SV> if ( s -> enc_write_ctx == NULL ) //<S2SV> enc = NULL ; //<S2SV> else { //<S2SV> int ivlen ; //<S2SV> enc = EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ; //<S2SV> if ( SSL_USE_EXPLICIT_IV ( s ) //<S2SV> && EVP_CIPHER_mode ( enc ) == EVP_CIPH_CBC_MODE ) //<S2SV> ivlen = EVP_CIPHER_iv_length ( enc ) ; //<S2SV> else //<S2SV> ivlen = 0 ; //<S2SV> if ( ivlen > 1 ) { //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> if ( recs [ ctr ] . data != recs [ ctr ] . input ) { //<S2SV> SSLerr ( SSL_F_TLS1_ENC , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return - 1 ; //<S2SV> } else if ( RAND_bytes ( recs [ ctr ] . input , ivlen ) <= 0 ) { //<S2SV> SSLerr ( SSL_F_TLS1_ENC , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> if ( EVP_MD_CTX_md ( s -> read_hash ) ) { //<S2SV> int n = EVP_MD_CTX_size ( s -> read_hash ) ; //<S2SV> OPENSSL_assert ( n >= 0 ) ; //<S2SV> } //<S2SV> ds = s -> enc_read_ctx ; //<S2SV> if ( s -> enc_read_ctx == NULL ) //<S2SV> enc = NULL ; //<S2SV> else //<S2SV> enc = EVP_CIPHER_CTX_cipher ( s -> enc_read_ctx ) ; //<S2SV> } //<S2SV> if ( ( s -> session == NULL ) || ( ds == NULL ) || ( enc == NULL ) ) { //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> memmove ( recs [ ctr ] . data , recs [ ctr ] . input , recs [ ctr ] . length ) ; //<S2SV> recs [ ctr ] . input = recs [ ctr ] . data ; //<S2SV> } //<S2SV> ret = 1 ; //<S2SV> } else { //<S2SV> bs = EVP_CIPHER_block_size ( EVP_CIPHER_CTX_cipher ( ds ) ) ; //<S2SV> if ( n_recs > 1 ) { //<S2SV> if ( ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( ds ) ) //<S2SV> & EVP_CIPH_FLAG_PIPELINE ) ) { //<S2SV> SSLerr ( SSL_F_TLS1_ENC , SSL_R_PIPELINE_FAILURE ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> reclen [ ctr ] = recs [ ctr ] . length ; //<S2SV> if ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( ds ) ) //<S2SV> & EVP_CIPH_FLAG_AEAD_CIPHER ) { //<S2SV> unsigned char * seq ; //<S2SV> seq = send ? RECORD_LAYER_get_write_sequence ( & s -> rlayer ) //<S2SV> : RECORD_LAYER_get_read_sequence ( & s -> rlayer ) ; //<S2SV> if ( SSL_IS_DTLS ( s ) ) { //<S2SV> unsigned char dtlsseq [ 9 ] , * p = dtlsseq ; //<S2SV> s2n ( send ? DTLS_RECORD_LAYER_get_w_epoch ( & s -> rlayer ) : //<S2SV> DTLS_RECORD_LAYER_get_r_epoch ( & s -> rlayer ) , p ) ; //<S2SV> memcpy ( p , & seq [ 2 ] , 6 ) ; //<S2SV> memcpy ( buf [ ctr ] , dtlsseq , 8 ) ; //<S2SV> } else { //<S2SV> memcpy ( buf [ ctr ] , seq , 8 ) ; //<S2SV> for ( i = 7 ; i >= 0 ; i -- ) { //<S2SV> ++ seq [ i ] ; //<S2SV> if ( seq [ i ] != 0 ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> buf [ ctr ] [ 8 ] = recs [ ctr ] . type ; //<S2SV> buf [ ctr ] [ 9 ] = ( unsigned char ) ( s -> version >> 8 ) ; //<S2SV> buf [ ctr ] [ 10 ] = ( unsigned char ) ( s -> version ) ; //<S2SV> buf [ ctr ] [ 11 ] = recs [ ctr ] . length >> 8 ; //<S2SV> buf [ ctr ] [ 12 ] = recs [ ctr ] . length & 0xff ; //<S2SV> pad = EVP_CIPHER_CTX_ctrl ( ds , EVP_CTRL_AEAD_TLS1_AAD , //<S2SV> EVP_AEAD_TLS1_AAD_LEN , buf [ ctr ] ) ; //<S2SV> if ( pad <= 0 ) //<S2SV> return - 1 ; //<S2SV> if ( send ) { //<S2SV> reclen [ ctr ] += pad ; //<S2SV> recs [ ctr ] . length += pad ; //<S2SV> } //<S2SV> } else if ( ( bs != 1 ) && send ) { //<S2SV> i = bs - ( ( int ) reclen [ ctr ] % bs ) ; //<S2SV> j = i - 1 ; //<S2SV> for ( k = ( int ) reclen [ ctr ] ; k < ( int ) ( reclen [ ctr ] + i ) ; k ++ ) //<S2SV> recs [ ctr ] . input [ k ] = j ; //<S2SV> reclen [ ctr ] += i ; //<S2SV> recs [ ctr ] . length += i ; //<S2SV> } //<S2SV> if ( ! send ) { //<S2SV> if ( reclen [ ctr ] == 0 || reclen [ ctr ] % bs != 0 ) //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( n_recs > 1 ) { //<S2SV> unsigned char * data [ SSL_MAX_PIPELINES ] ; //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> data [ ctr ] = recs [ ctr ] . data ; //<S2SV> } //<S2SV> if ( EVP_CIPHER_CTX_ctrl ( ds , EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS , //<S2SV> n_recs , data ) <= 0 ) { //<S2SV> SSLerr ( SSL_F_TLS1_ENC , SSL_R_PIPELINE_FAILURE ) ; //<S2SV> } //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> data [ ctr ] = recs [ ctr ] . input ; //<S2SV> } //<S2SV> if ( EVP_CIPHER_CTX_ctrl ( ds , EVP_CTRL_SET_PIPELINE_INPUT_BUFS , //<S2SV> n_recs , data ) <= 0 //<S2SV> || EVP_CIPHER_CTX_ctrl ( ds , EVP_CTRL_SET_PIPELINE_INPUT_LENS , //<S2SV> n_recs , reclen ) <= 0 ) { //<S2SV> SSLerr ( SSL_F_TLS1_ENC , SSL_R_PIPELINE_FAILURE ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> i = EVP_Cipher ( ds , recs [ 0 ] . data , recs [ 0 ] . input , reclen [ 0 ] ) ; //<S2SV> if ( ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( ds ) ) //<S2SV> & EVP_CIPH_FLAG_CUSTOM_CIPHER ) //<S2SV> ? ( i < 0 ) //<S2SV> : ( i == 0 ) ) //<S2SV> return - 1 ; //<S2SV> if ( send == 0 ) { //<S2SV> if ( EVP_CIPHER_mode ( enc ) == EVP_CIPH_GCM_MODE ) { //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> recs [ ctr ] . data += EVP_GCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> recs [ ctr ] . input += EVP_GCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> recs [ ctr ] . length -= EVP_GCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> } //<S2SV> } else if ( EVP_CIPHER_mode ( enc ) == EVP_CIPH_CCM_MODE ) { //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> recs [ ctr ] . data += EVP_CCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> recs [ ctr ] . input += EVP_CCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> recs [ ctr ] . length -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ret = 1 ; //<S2SV> if ( ! SSL_READ_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL ) //<S2SV> mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; //<S2SV> if ( ( bs != 1 ) && ! send ) { //<S2SV> int tmpret ; //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> tmpret = tls1_cbc_remove_padding ( s , & recs [ ctr ] , bs , mac_size ) ; //<S2SV> if ( tmpret == 0 ) //<S2SV> return 0 ; //<S2SV> ret = constant_time_select_int ( constant_time_eq_int ( tmpret , 1 ) , //<S2SV> ret , - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( pad && ! send ) { //<S2SV> for ( ctr = 0 ; ctr < n_recs ; ctr ++ ) { //<S2SV> recs [ ctr ] . length -= pad ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 