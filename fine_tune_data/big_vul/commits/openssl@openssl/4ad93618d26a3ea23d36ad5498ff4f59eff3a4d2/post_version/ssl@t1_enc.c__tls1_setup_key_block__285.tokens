int tls1_setup_key_block ( SSL * s ) //<S2SV> { //<S2SV> unsigned char * p ; //<S2SV> const EVP_CIPHER * c ; //<S2SV> const EVP_MD * hash ; //<S2SV> int num ; //<S2SV> SSL_COMP * comp ; //<S2SV> int mac_type = NID_undef , mac_secret_size = 0 ; //<S2SV> int ret = 0 ; //<S2SV> if ( s -> s3 -> tmp . key_block_length != 0 ) //<S2SV> return ( 1 ) ; //<S2SV> if ( ! ssl_cipher_get_evp ( s -> session , & c , & hash , & mac_type , & mac_secret_size , //<S2SV> & comp , s -> tlsext_use_etm ) ) { //<S2SV> SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , SSL_R_CIPHER_OR_HASH_UNAVAILABLE ) ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> s -> s3 -> tmp . new_sym_enc = c ; //<S2SV> s -> s3 -> tmp . new_hash = hash ; //<S2SV> s -> s3 -> tmp . new_mac_pkey_type = mac_type ; //<S2SV> s -> s3 -> tmp . new_mac_secret_size = mac_secret_size ; //<S2SV> num = EVP_CIPHER_key_length ( c ) + mac_secret_size + EVP_CIPHER_iv_length ( c ) ; //<S2SV> num *= 2 ; //<S2SV> ssl3_cleanup_key_block ( s ) ; //<S2SV> if ( ( p = OPENSSL_malloc ( num ) ) == NULL ) { //<S2SV> SSLerr ( SSL_F_TLS1_SETUP_KEY_BLOCK , ERR_R_MALLOC_FAILURE ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> s -> s3 -> tmp . key_block_length = num ; //<S2SV> s -> s3 -> tmp . key_block = p ; //<S2SV> # ifdef SSL_DEBUG //<S2SV> printf ( "client<S2SV_blank>random\\n" ) ; //<S2SV> { //<S2SV> int z ; //<S2SV> for ( z = 0 ; z < SSL3_RANDOM_SIZE ; z ++ ) //<S2SV> printf ( "%02X%c" , s -> s3 -> client_random [ z ] , //<S2SV> ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; //<S2SV> } //<S2SV> printf ( "server<S2SV_blank>random\\n" ) ; //<S2SV> { //<S2SV> int z ; //<S2SV> for ( z = 0 ; z < SSL3_RANDOM_SIZE ; z ++ ) //<S2SV> printf ( "%02X%c" , s -> s3 -> server_random [ z ] , //<S2SV> ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; //<S2SV> } //<S2SV> printf ( "master<S2SV_blank>key\\n" ) ; //<S2SV> { //<S2SV> int z ; //<S2SV> for ( z = 0 ; z < s -> session -> master_key_length ; z ++ ) //<S2SV> printf ( "%02X%c" , s -> session -> master_key [ z ] , //<S2SV> ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! tls1_generate_key_block ( s , p , num ) ) //<S2SV> goto err ; //<S2SV> # ifdef SSL_DEBUG //<S2SV> printf ( "\\nkey<S2SV_blank>block\\n" ) ; //<S2SV> { //<S2SV> int z ; //<S2SV> for ( z = 0 ; z < num ; z ++ ) //<S2SV> printf ( "%02X%c" , p [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! ( s -> options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS ) //<S2SV> && s -> method -> version <= TLS1_VERSION ) { //<S2SV> s -> s3 -> need_empty_fragments = 1 ; //<S2SV> if ( s -> session -> cipher != NULL ) { //<S2SV> if ( s -> session -> cipher -> algorithm_enc == SSL_eNULL ) //<S2SV> s -> s3 -> need_empty_fragments = 0 ; //<S2SV> # ifndef OPENSSL_NO_RC4 //<S2SV> if ( s -> session -> cipher -> algorithm_enc == SSL_RC4 ) //<S2SV> s -> s3 -> need_empty_fragments = 0 ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> ret = 1 ; //<S2SV> err : //<S2SV> return ( ret ) ; //<S2SV> } //<S2SV> 