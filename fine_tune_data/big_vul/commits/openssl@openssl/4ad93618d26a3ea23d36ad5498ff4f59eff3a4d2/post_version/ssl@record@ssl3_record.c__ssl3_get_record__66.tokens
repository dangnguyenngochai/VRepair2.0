int ssl3_get_record ( SSL * s ) //<S2SV> { //<S2SV> int ssl_major , ssl_minor , al ; //<S2SV> int enc_err , n , i , ret = - 1 ; //<S2SV> SSL3_RECORD * rr ; //<S2SV> SSL3_BUFFER * rbuf ; //<S2SV> SSL_SESSION * sess ; //<S2SV> unsigned char * p ; //<S2SV> unsigned char md [ EVP_MAX_MD_SIZE ] ; //<S2SV> short version ; //<S2SV> unsigned mac_size ; //<S2SV> unsigned int num_recs = 0 ; //<S2SV> unsigned int max_recs ; //<S2SV> unsigned int j ; //<S2SV> rr = RECORD_LAYER_get_rrec ( & s -> rlayer ) ; //<S2SV> rbuf = RECORD_LAYER_get_rbuf ( & s -> rlayer ) ; //<S2SV> max_recs = s -> max_pipelines ; //<S2SV> if ( max_recs == 0 ) //<S2SV> max_recs = 1 ; //<S2SV> sess = s -> session ; //<S2SV> do { //<S2SV> if ( ( RECORD_LAYER_get_rstate ( & s -> rlayer ) != SSL_ST_READ_BODY ) || //<S2SV> ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) //<S2SV> < SSL3_RT_HEADER_LENGTH ) ) { //<S2SV> n = ssl3_read_n ( s , SSL3_RT_HEADER_LENGTH , //<S2SV> SSL3_BUFFER_get_len ( rbuf ) , 0 , //<S2SV> num_recs == 0 ? 1 : 0 ) ; //<S2SV> if ( n <= 0 ) //<S2SV> return ( n ) ; //<S2SV> RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_BODY ) ; //<S2SV> p = RECORD_LAYER_get_packet ( & s -> rlayer ) ; //<S2SV> if ( s -> server && RECORD_LAYER_is_first_record ( & s -> rlayer ) //<S2SV> && ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) { //<S2SV> rr [ num_recs ] . type = SSL3_RT_HANDSHAKE ; //<S2SV> rr [ num_recs ] . rec_version = SSL2_VERSION ; //<S2SV> rr [ num_recs ] . length = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ; //<S2SV> if ( rr [ num_recs ] . length > SSL3_BUFFER_get_len ( rbuf ) //<S2SV> - SSL2_RT_HEADER_LENGTH ) { //<S2SV> al = SSL_AD_RECORD_OVERFLOW ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_PACKET_LENGTH_TOO_LONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> if ( rr [ num_recs ] . length < MIN_SSL2_RECORD_LEN ) { //<S2SV> al = SSL_AD_HANDSHAKE_FAILURE ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( s -> msg_callback ) //<S2SV> s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , 5 , s , //<S2SV> s -> msg_callback_arg ) ; //<S2SV> rr [ num_recs ] . type = * ( p ++ ) ; //<S2SV> ssl_major = * ( p ++ ) ; //<S2SV> ssl_minor = * ( p ++ ) ; //<S2SV> version = ( ssl_major << 8 ) | ssl_minor ; //<S2SV> rr [ num_recs ] . rec_version = version ; //<S2SV> n2s ( p , rr [ num_recs ] . length ) ; //<S2SV> if ( ! s -> first_packet && version != s -> version ) { //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; //<S2SV> if ( ( s -> version & 0xFF00 ) == ( version & 0xFF00 ) //<S2SV> && ! s -> enc_write_ctx && ! s -> write_hash ) { //<S2SV> if ( rr -> type == SSL3_RT_ALERT ) { //<S2SV> goto err ; //<S2SV> } //<S2SV> s -> version = ( unsigned short ) version ; //<S2SV> } //<S2SV> al = SSL_AD_PROTOCOL_VERSION ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> if ( ( version >> 8 ) != SSL3_VERSION_MAJOR ) { //<S2SV> if ( RECORD_LAYER_is_first_record ( & s -> rlayer ) ) { //<S2SV> p = RECORD_LAYER_get_packet ( & s -> rlayer ) ; //<S2SV> if ( strncmp ( ( char * ) p , "GET<S2SV_blank>" , 4 ) == 0 || //<S2SV> strncmp ( ( char * ) p , "POST<S2SV_blank>" , 5 ) == 0 || //<S2SV> strncmp ( ( char * ) p , "HEAD<S2SV_blank>" , 5 ) == 0 || //<S2SV> strncmp ( ( char * ) p , "PUT<S2SV_blank>" , 4 ) == 0 ) { //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_HTTP_REQUEST ) ; //<S2SV> goto err ; //<S2SV> } else if ( strncmp ( ( char * ) p , "CONNE" , 5 ) == 0 ) { //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , //<S2SV> SSL_R_HTTPS_PROXY_REQUEST ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , //<S2SV> SSL_R_WRONG_VERSION_NUMBER ) ; //<S2SV> goto err ; //<S2SV> } else { //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , //<S2SV> SSL_R_WRONG_VERSION_NUMBER ) ; //<S2SV> al = SSL_AD_PROTOCOL_VERSION ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> } //<S2SV> if ( rr [ num_recs ] . length > //<S2SV> SSL3_BUFFER_get_len ( rbuf ) - SSL3_RT_HEADER_LENGTH ) { //<S2SV> al = SSL_AD_RECORD_OVERFLOW ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_PACKET_LENGTH_TOO_LONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( rr [ num_recs ] . rec_version == SSL2_VERSION ) { //<S2SV> i = rr [ num_recs ] . length + SSL2_RT_HEADER_LENGTH //<S2SV> - SSL3_RT_HEADER_LENGTH ; //<S2SV> } else { //<S2SV> i = rr [ num_recs ] . length ; //<S2SV> } //<S2SV> if ( i > 0 ) { //<S2SV> n = ssl3_read_n ( s , i , i , 1 , 0 ) ; //<S2SV> if ( n <= 0 ) //<S2SV> return ( n ) ; //<S2SV> } //<S2SV> RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_HEADER ) ; //<S2SV> if ( rr [ num_recs ] . rec_version == SSL2_VERSION ) { //<S2SV> rr [ num_recs ] . input = //<S2SV> & ( RECORD_LAYER_get_packet ( & s -> rlayer ) [ SSL2_RT_HEADER_LENGTH ] ) ; //<S2SV> } else { //<S2SV> rr [ num_recs ] . input = //<S2SV> & ( RECORD_LAYER_get_packet ( & s -> rlayer ) [ SSL3_RT_HEADER_LENGTH ] ) ; //<S2SV> } //<S2SV> if ( rr [ num_recs ] . length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { //<S2SV> al = SSL_AD_RECORD_OVERFLOW ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_ENCRYPTED_LENGTH_TOO_LONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> rr [ num_recs ] . data = rr [ num_recs ] . input ; //<S2SV> rr [ num_recs ] . orig_len = rr [ num_recs ] . length ; //<S2SV> rr [ num_recs ] . read = 0 ; //<S2SV> num_recs ++ ; //<S2SV> RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ; //<S2SV> RECORD_LAYER_clear_first_record ( & s -> rlayer ) ; //<S2SV> } while ( num_recs < max_recs //<S2SV> && rr [ num_recs - 1 ] . type == SSL3_RT_APPLICATION_DATA //<S2SV> && SSL_USE_EXPLICIT_IV ( s ) //<S2SV> && s -> enc_read_ctx != NULL //<S2SV> && ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_read_ctx ) ) //<S2SV> & EVP_CIPH_FLAG_PIPELINE ) //<S2SV> && ssl3_record_app_data_waiting ( s ) ) ; //<S2SV> if ( SSL_READ_ETM ( s ) && s -> read_hash ) { //<S2SV> unsigned char * mac ; //<S2SV> mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; //<S2SV> OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; //<S2SV> for ( j = 0 ; j < num_recs ; j ++ ) { //<S2SV> if ( rr [ j ] . length < mac_size ) { //<S2SV> al = SSL_AD_DECODE_ERROR ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> rr [ j ] . length -= mac_size ; //<S2SV> mac = rr [ j ] . data + rr [ j ] . length ; //<S2SV> i = s -> method -> ssl3_enc -> mac ( s , & rr [ j ] , md , 0 ) ; //<S2SV> if ( i < 0 || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) { //<S2SV> al = SSL_AD_BAD_RECORD_MAC ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , //<S2SV> SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> enc_err = s -> method -> ssl3_enc -> enc ( s , rr , num_recs , 0 ) ; //<S2SV> if ( enc_err == 0 ) { //<S2SV> al = SSL_AD_DECRYPTION_FAILED ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_BLOCK_CIPHER_PAD_IS_WRONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> # ifdef SSL_DEBUG //<S2SV> printf ( "dec<S2SV_blank>%d\\n" , rr -> length ) ; //<S2SV> { //<S2SV> unsigned int z ; //<S2SV> for ( z = 0 ; z < rr -> length ; z ++ ) //<S2SV> printf ( "%02X%c" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> # endif //<S2SV> if ( ( sess != NULL ) && //<S2SV> ( s -> enc_read_ctx != NULL ) && //<S2SV> ( ! SSL_READ_ETM ( s ) && EVP_MD_CTX_md ( s -> read_hash ) != NULL ) ) { //<S2SV> unsigned char * mac = NULL ; //<S2SV> unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ; //<S2SV> mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; //<S2SV> OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; //<S2SV> for ( j = 0 ; j < num_recs ; j ++ ) { //<S2SV> if ( rr [ j ] . orig_len < mac_size || //<S2SV> ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && //<S2SV> rr [ j ] . orig_len < mac_size + 1 ) ) { //<S2SV> al = SSL_AD_DECODE_ERROR ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) { //<S2SV> mac = mac_tmp ; //<S2SV> ssl3_cbc_copy_mac ( mac_tmp , & rr [ j ] , mac_size ) ; //<S2SV> rr [ j ] . length -= mac_size ; //<S2SV> } else { //<S2SV> rr [ j ] . length -= mac_size ; //<S2SV> mac = & rr [ j ] . data [ rr [ j ] . length ] ; //<S2SV> } //<S2SV> i = s -> method -> ssl3_enc -> mac ( s , & rr [ j ] , md , 0 ) ; //<S2SV> if ( i < 0 || mac == NULL //<S2SV> || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) //<S2SV> enc_err = - 1 ; //<S2SV> if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) //<S2SV> enc_err = - 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( enc_err < 0 ) { //<S2SV> al = SSL_AD_BAD_RECORD_MAC ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , //<S2SV> SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> for ( j = 0 ; j < num_recs ; j ++ ) { //<S2SV> if ( s -> expand != NULL ) { //<S2SV> if ( rr [ j ] . length > SSL3_RT_MAX_COMPRESSED_LENGTH ) { //<S2SV> al = SSL_AD_RECORD_OVERFLOW ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> if ( ! ssl3_do_uncompress ( s , & rr [ j ] ) ) { //<S2SV> al = SSL_AD_DECOMPRESSION_FAILURE ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_BAD_DECOMPRESSION ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> } //<S2SV> if ( rr [ j ] . length > SSL3_RT_MAX_PLAIN_LENGTH ) { //<S2SV> al = SSL_AD_RECORD_OVERFLOW ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> rr [ j ] . off = 0 ; //<S2SV> if ( rr [ j ] . length == 0 ) { //<S2SV> RECORD_LAYER_inc_empty_record_count ( & s -> rlayer ) ; //<S2SV> if ( RECORD_LAYER_get_empty_record_count ( & s -> rlayer ) //<S2SV> > MAX_EMPTY_RECORDS ) { //<S2SV> al = SSL_AD_UNEXPECTED_MESSAGE ; //<S2SV> SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_RECORD_TOO_SMALL ) ; //<S2SV> goto f_err ; //<S2SV> } //<S2SV> } else { //<S2SV> RECORD_LAYER_reset_empty_record_count ( & s -> rlayer ) ; //<S2SV> } //<S2SV> } //<S2SV> RECORD_LAYER_set_numrpipes ( & s -> rlayer , num_recs ) ; //<S2SV> return 1 ; //<S2SV> f_err : //<S2SV> ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; //<S2SV> err : //<S2SV> return ret ; //<S2SV> } //<S2SV> 