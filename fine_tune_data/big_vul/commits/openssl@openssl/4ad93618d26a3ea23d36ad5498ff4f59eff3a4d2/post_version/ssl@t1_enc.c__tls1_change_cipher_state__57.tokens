int tls1_change_cipher_state ( SSL * s , int which ) //<S2SV> { //<S2SV> unsigned char * p , * mac_secret ; //<S2SV> unsigned char tmp1 [ EVP_MAX_KEY_LENGTH ] ; //<S2SV> unsigned char tmp2 [ EVP_MAX_KEY_LENGTH ] ; //<S2SV> unsigned char iv1 [ EVP_MAX_IV_LENGTH * 2 ] ; //<S2SV> unsigned char iv2 [ EVP_MAX_IV_LENGTH * 2 ] ; //<S2SV> unsigned char * ms , * key , * iv ; //<S2SV> EVP_CIPHER_CTX * dd ; //<S2SV> const EVP_CIPHER * c ; //<S2SV> # ifndef OPENSSL_NO_COMP //<S2SV> const SSL_COMP * comp ; //<S2SV> # endif //<S2SV> const EVP_MD * m ; //<S2SV> int mac_type ; //<S2SV> int * mac_secret_size ; //<S2SV> EVP_MD_CTX * mac_ctx ; //<S2SV> EVP_PKEY * mac_key ; //<S2SV> int n , i , j , k , cl ; //<S2SV> int reuse_dd = 0 ; //<S2SV> c = s -> s3 -> tmp . new_sym_enc ; //<S2SV> m = s -> s3 -> tmp . new_hash ; //<S2SV> mac_type = s -> s3 -> tmp . new_mac_pkey_type ; //<S2SV> # ifndef OPENSSL_NO_COMP //<S2SV> comp = s -> s3 -> tmp . new_compression ; //<S2SV> # endif //<S2SV> if ( which & SSL3_CC_READ ) { //<S2SV> if ( s -> tlsext_use_etm ) //<S2SV> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; //<S2SV> else //<S2SV> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; //<S2SV> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) //<S2SV> s -> mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM ; //<S2SV> else //<S2SV> s -> mac_flags &= ~ SSL_MAC_FLAG_READ_MAC_STREAM ; //<S2SV> if ( s -> enc_read_ctx != NULL ) //<S2SV> reuse_dd = 1 ; //<S2SV> else if ( ( s -> enc_read_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) //<S2SV> goto err ; //<S2SV> else //<S2SV> EVP_CIPHER_CTX_reset ( s -> enc_read_ctx ) ; //<S2SV> dd = s -> enc_read_ctx ; //<S2SV> mac_ctx = ssl_replace_hash ( & s -> read_hash , NULL ) ; //<S2SV> if ( mac_ctx == NULL ) //<S2SV> goto err ; //<S2SV> # ifndef OPENSSL_NO_COMP //<S2SV> COMP_CTX_free ( s -> expand ) ; //<S2SV> s -> expand = NULL ; //<S2SV> if ( comp != NULL ) { //<S2SV> s -> expand = COMP_CTX_new ( comp -> method ) ; //<S2SV> if ( s -> expand == NULL ) { //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , //<S2SV> SSL_R_COMPRESSION_LIBRARY_ERROR ) ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! SSL_IS_DTLS ( s ) ) //<S2SV> RECORD_LAYER_reset_read_sequence ( & s -> rlayer ) ; //<S2SV> mac_secret = & ( s -> s3 -> read_mac_secret [ 0 ] ) ; //<S2SV> mac_secret_size = & ( s -> s3 -> read_mac_secret_size ) ; //<S2SV> } else { //<S2SV> if ( s -> tlsext_use_etm ) //<S2SV> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; //<S2SV> else //<S2SV> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; //<S2SV> if ( s -> s3 -> tmp . new_cipher -> algorithm2 & TLS1_STREAM_MAC ) //<S2SV> s -> mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM ; //<S2SV> else //<S2SV> s -> mac_flags &= ~ SSL_MAC_FLAG_WRITE_MAC_STREAM ; //<S2SV> if ( s -> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) ) //<S2SV> reuse_dd = 1 ; //<S2SV> else if ( ( s -> enc_write_ctx = EVP_CIPHER_CTX_new ( ) ) == NULL ) //<S2SV> goto err ; //<S2SV> dd = s -> enc_write_ctx ; //<S2SV> if ( SSL_IS_DTLS ( s ) ) { //<S2SV> mac_ctx = EVP_MD_CTX_new ( ) ; //<S2SV> if ( mac_ctx == NULL ) //<S2SV> goto err ; //<S2SV> s -> write_hash = mac_ctx ; //<S2SV> } else { //<S2SV> mac_ctx = ssl_replace_hash ( & s -> write_hash , NULL ) ; //<S2SV> if ( mac_ctx == NULL ) //<S2SV> goto err ; //<S2SV> } //<S2SV> # ifndef OPENSSL_NO_COMP //<S2SV> COMP_CTX_free ( s -> compress ) ; //<S2SV> s -> compress = NULL ; //<S2SV> if ( comp != NULL ) { //<S2SV> s -> compress = COMP_CTX_new ( comp -> method ) ; //<S2SV> if ( s -> compress == NULL ) { //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , //<S2SV> SSL_R_COMPRESSION_LIBRARY_ERROR ) ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! SSL_IS_DTLS ( s ) ) //<S2SV> RECORD_LAYER_reset_write_sequence ( & s -> rlayer ) ; //<S2SV> mac_secret = & ( s -> s3 -> write_mac_secret [ 0 ] ) ; //<S2SV> mac_secret_size = & ( s -> s3 -> write_mac_secret_size ) ; //<S2SV> } //<S2SV> if ( reuse_dd ) //<S2SV> EVP_CIPHER_CTX_reset ( dd ) ; //<S2SV> p = s -> s3 -> tmp . key_block ; //<S2SV> i = * mac_secret_size = s -> s3 -> tmp . new_mac_secret_size ; //<S2SV> cl = EVP_CIPHER_key_length ( c ) ; //<S2SV> j = cl ; //<S2SV> if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) //<S2SV> k = EVP_GCM_TLS_FIXED_IV_LEN ; //<S2SV> else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) //<S2SV> k = EVP_CCM_TLS_FIXED_IV_LEN ; //<S2SV> else //<S2SV> k = EVP_CIPHER_iv_length ( c ) ; //<S2SV> if ( ( which == SSL3_CHANGE_CIPHER_CLIENT_WRITE ) || //<S2SV> ( which == SSL3_CHANGE_CIPHER_SERVER_READ ) ) { //<S2SV> ms = & ( p [ 0 ] ) ; //<S2SV> n = i + i ; //<S2SV> key = & ( p [ n ] ) ; //<S2SV> n += j + j ; //<S2SV> iv = & ( p [ n ] ) ; //<S2SV> n += k + k ; //<S2SV> } else { //<S2SV> n = i ; //<S2SV> ms = & ( p [ n ] ) ; //<S2SV> n += i + j ; //<S2SV> key = & ( p [ n ] ) ; //<S2SV> n += j + k ; //<S2SV> iv = & ( p [ n ] ) ; //<S2SV> n += k ; //<S2SV> } //<S2SV> if ( n > s -> s3 -> tmp . key_block_length ) { //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> memcpy ( mac_secret , ms , i ) ; //<S2SV> if ( ! ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) ) { //<S2SV> mac_key = EVP_PKEY_new_mac_key ( mac_type , NULL , //<S2SV> mac_secret , * mac_secret_size ) ; //<S2SV> if ( mac_key == NULL //<S2SV> || EVP_DigestSignInit ( mac_ctx , NULL , m , NULL , mac_key ) <= 0 ) { //<S2SV> EVP_PKEY_free ( mac_key ) ; //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> EVP_PKEY_free ( mac_key ) ; //<S2SV> } //<S2SV> # ifdef SSL_DEBUG //<S2SV> printf ( "which<S2SV_blank>=<S2SV_blank>%04X\\nmac<S2SV_blank>key=" , which ) ; //<S2SV> { //<S2SV> int z ; //<S2SV> for ( z = 0 ; z < i ; z ++ ) //<S2SV> printf ( "%02X%c" , ms [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) { //<S2SV> if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , NULL , ( which & SSL3_CC_WRITE ) ) //<S2SV> || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_GCM_SET_IV_FIXED , k , iv ) ) { //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> } else if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_CCM_MODE ) { //<S2SV> int taglen ; //<S2SV> if ( s -> s3 -> tmp . //<S2SV> new_cipher -> algorithm_enc & ( SSL_AES128CCM8 | SSL_AES256CCM8 ) ) //<S2SV> taglen = 8 ; //<S2SV> else //<S2SV> taglen = 16 ; //<S2SV> if ( ! EVP_CipherInit_ex ( dd , c , NULL , NULL , NULL , ( which & SSL3_CC_WRITE ) ) //<S2SV> || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_IVLEN , 12 , NULL ) //<S2SV> || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_TAG , taglen , NULL ) //<S2SV> || ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_CCM_SET_IV_FIXED , k , iv ) //<S2SV> || ! EVP_CipherInit_ex ( dd , NULL , NULL , key , NULL , - 1 ) ) { //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( ! EVP_CipherInit_ex ( dd , c , NULL , key , iv , ( which & SSL3_CC_WRITE ) ) ) { //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( EVP_CIPHER_flags ( c ) & EVP_CIPH_FLAG_AEAD_CIPHER ) && * mac_secret_size //<S2SV> && ! EVP_CIPHER_CTX_ctrl ( dd , EVP_CTRL_AEAD_SET_MAC_KEY , //<S2SV> * mac_secret_size , mac_secret ) ) { //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> goto err2 ; //<S2SV> } //<S2SV> # ifdef OPENSSL_SSL_TRACE_CRYPTO //<S2SV> if ( s -> msg_callback ) { //<S2SV> int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0 ; //<S2SV> if ( * mac_secret_size ) //<S2SV> s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_MAC , //<S2SV> mac_secret , * mac_secret_size , //<S2SV> s , s -> msg_callback_arg ) ; //<S2SV> if ( c -> key_len ) //<S2SV> s -> msg_callback ( 2 , s -> version , wh | TLS1_RT_CRYPTO_KEY , //<S2SV> key , c -> key_len , s , s -> msg_callback_arg ) ; //<S2SV> if ( k ) { //<S2SV> if ( EVP_CIPHER_mode ( c ) == EVP_CIPH_GCM_MODE ) //<S2SV> wh |= TLS1_RT_CRYPTO_FIXED_IV ; //<S2SV> else //<S2SV> wh |= TLS1_RT_CRYPTO_IV ; //<S2SV> s -> msg_callback ( 2 , s -> version , wh , iv , k , s , s -> msg_callback_arg ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef SSL_DEBUG //<S2SV> printf ( "which<S2SV_blank>=<S2SV_blank>%04X\\nkey=" , which ) ; //<S2SV> { //<S2SV> int z ; //<S2SV> for ( z = 0 ; z < EVP_CIPHER_key_length ( c ) ; z ++ ) //<S2SV> printf ( "%02X%c" , key [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; //<S2SV> } //<S2SV> printf ( "\\niv=" ) ; //<S2SV> { //<S2SV> int z ; //<S2SV> for ( z = 0 ; z < k ; z ++ ) //<S2SV> printf ( "%02X%c" , iv [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> # endif //<S2SV> OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; //<S2SV> OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; //<S2SV> OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; //<S2SV> OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; //<S2SV> return ( 1 ) ; //<S2SV> err : //<S2SV> SSLerr ( SSL_F_TLS1_CHANGE_CIPHER_STATE , ERR_R_MALLOC_FAILURE ) ; //<S2SV> err2 : //<S2SV> OPENSSL_cleanse ( tmp1 , sizeof ( tmp1 ) ) ; //<S2SV> OPENSSL_cleanse ( tmp2 , sizeof ( tmp1 ) ) ; //<S2SV> OPENSSL_cleanse ( iv1 , sizeof ( iv1 ) ) ; //<S2SV> OPENSSL_cleanse ( iv2 , sizeof ( iv2 ) ) ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> 