static int tls_construct_cke_dhe ( SSL * s , unsigned char * * p , int * len , int * al ) //<S2SV> { //<S2SV> # ifndef OPENSSL_NO_DH //<S2SV> DH * dh_clnt = NULL ; //<S2SV> const BIGNUM * pub_key ; //<S2SV> EVP_PKEY * ckey = NULL , * skey = NULL ; //<S2SV> skey = s -> s3 -> peer_tmp ; //<S2SV> if ( skey == NULL ) { //<S2SV> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> ckey = ssl_generate_pkey ( skey ) ; //<S2SV> dh_clnt = EVP_PKEY_get0_DH ( ckey ) ; //<S2SV> if ( dh_clnt == NULL || ssl_derive ( s , ckey , skey ) == 0 ) { //<S2SV> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> EVP_PKEY_free ( ckey ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> DH_get0_key ( dh_clnt , & pub_key , NULL ) ; //<S2SV> * len = BN_num_bytes ( pub_key ) ; //<S2SV> s2n ( * len , * p ) ; //<S2SV> BN_bn2bin ( pub_key , * p ) ; //<S2SV> * len += 2 ; //<S2SV> EVP_PKEY_free ( ckey ) ; //<S2SV> return 1 ; //<S2SV> # else //<S2SV> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> * al = SSL_AD_INTERNAL_ERROR ; //<S2SV> return 0 ; //<S2SV> # endif //<S2SV> } //<S2SV> 