static int tls_construct_cke_ecdhe ( SSL * s , unsigned char * * p , int * len , int * al ) //<S2SV> { //<S2SV> # ifndef OPENSSL_NO_EC //<S2SV> unsigned char * encodedPoint = NULL ; //<S2SV> int encoded_pt_len = 0 ; //<S2SV> EVP_PKEY * ckey = NULL , * skey = NULL ; //<S2SV> skey = s -> s3 -> peer_tmp ; //<S2SV> if ( skey == NULL ) { //<S2SV> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> ckey = ssl_generate_pkey ( skey ) ; //<S2SV> if ( ssl_derive ( s , ckey , skey ) == 0 ) { //<S2SV> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EVP_LIB ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint ( ckey , & encodedPoint ) ; //<S2SV> if ( encoded_pt_len == 0 ) { //<S2SV> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_EC_LIB ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> EVP_PKEY_free ( ckey ) ; //<S2SV> ckey = NULL ; //<S2SV> * len = encoded_pt_len ; //<S2SV> * * p = * len ; //<S2SV> * p += 1 ; //<S2SV> memcpy ( * p , encodedPoint , * len ) ; //<S2SV> * len += 1 ; //<S2SV> OPENSSL_free ( encodedPoint ) ; //<S2SV> return 1 ; //<S2SV> err : //<S2SV> EVP_PKEY_free ( ckey ) ; //<S2SV> return 0 ; //<S2SV> # else //<S2SV> SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; //<S2SV> * al = SSL_AD_INTERNAL_ERROR ; //<S2SV> return 0 ; //<S2SV> # endif //<S2SV> } //<S2SV> 