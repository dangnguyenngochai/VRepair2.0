static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , //<S2SV> void * ptr ) //<S2SV> { //<S2SV> EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ; //<S2SV> switch ( type ) { //<S2SV> case EVP_CTRL_INIT : //<S2SV> if ( actx == NULL ) //<S2SV> actx = ctx -> cipher_data //<S2SV> = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; //<S2SV> if ( actx == NULL ) { //<S2SV> EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> actx -> len . aad = 0 ; //<S2SV> actx -> len . text = 0 ; //<S2SV> actx -> aad = 0 ; //<S2SV> actx -> mac_inited = 0 ; //<S2SV> actx -> tag_len = 0 ; //<S2SV> actx -> nonce_len = 12 ; //<S2SV> actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_COPY : //<S2SV> if ( actx ) { //<S2SV> EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ; //<S2SV> dst -> cipher_data = //<S2SV> OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; //<S2SV> if ( dst -> cipher_data == NULL ) { //<S2SV> EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_SET_IVLEN : //<S2SV> if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) //<S2SV> return 0 ; //<S2SV> actx -> nonce_len = arg ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_SET_IV_FIXED : //<S2SV> if ( arg != 12 ) //<S2SV> return 0 ; //<S2SV> actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] //<S2SV> = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ; //<S2SV> actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] //<S2SV> = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ; //<S2SV> actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] //<S2SV> = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_SET_TAG : //<S2SV> if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) //<S2SV> return 0 ; //<S2SV> if ( ptr != NULL ) { //<S2SV> memcpy ( actx -> tag , ptr , arg ) ; //<S2SV> actx -> tag_len = arg ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_GET_TAG : //<S2SV> if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) //<S2SV> return 0 ; //<S2SV> memcpy ( ptr , actx -> tag , arg ) ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_TLS1_AAD : //<S2SV> if ( arg != EVP_AEAD_TLS1_AAD_LEN ) //<S2SV> return 0 ; //<S2SV> { //<S2SV> unsigned int len ; //<S2SV> unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ; //<S2SV> len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | //<S2SV> aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ; //<S2SV> if ( ! ctx -> encrypt ) { //<S2SV> len -= POLY1305_BLOCK_SIZE ; //<S2SV> memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ; //<S2SV> aad = temp ; //<S2SV> temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ; //<S2SV> temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ; //<S2SV> } //<S2SV> actx -> tls_payload_length = len ; //<S2SV> actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ; //<S2SV> actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ; //<S2SV> actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ; //<S2SV> actx -> mac_inited = 0 ; //<S2SV> chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ; //<S2SV> return POLY1305_BLOCK_SIZE ; //<S2SV> } //<S2SV> case EVP_CTRL_AEAD_SET_MAC_KEY : //<S2SV> return 1 ; //<S2SV> default : //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> 