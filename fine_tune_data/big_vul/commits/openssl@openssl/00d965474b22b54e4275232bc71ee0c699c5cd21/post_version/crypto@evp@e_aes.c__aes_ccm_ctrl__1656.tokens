static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) //<S2SV> { //<S2SV> EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ; //<S2SV> switch ( type ) { //<S2SV> case EVP_CTRL_INIT : //<S2SV> cctx -> key_set = 0 ; //<S2SV> cctx -> iv_set = 0 ; //<S2SV> cctx -> L = 8 ; //<S2SV> cctx -> M = 12 ; //<S2SV> cctx -> tag_set = 0 ; //<S2SV> cctx -> len_set = 0 ; //<S2SV> cctx -> tls_aad_len = - 1 ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_TLS1_AAD : //<S2SV> if ( arg != EVP_AEAD_TLS1_AAD_LEN ) //<S2SV> return 0 ; //<S2SV> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; //<S2SV> cctx -> tls_aad_len = arg ; //<S2SV> { //<S2SV> uint16_t len = //<S2SV> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 //<S2SV> | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; //<S2SV> if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) //<S2SV> return 0 ; //<S2SV> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; //<S2SV> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) { //<S2SV> if ( len < cctx -> M ) //<S2SV> return 0 ; //<S2SV> len -= cctx -> M ; //<S2SV> } //<S2SV> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; //<S2SV> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; //<S2SV> } //<S2SV> return cctx -> M ; //<S2SV> case EVP_CTRL_CCM_SET_IV_FIXED : //<S2SV> if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) //<S2SV> return 0 ; //<S2SV> memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_SET_IVLEN : //<S2SV> arg = 15 - arg ; //<S2SV> case EVP_CTRL_CCM_SET_L : //<S2SV> if ( arg < 2 || arg > 8 ) //<S2SV> return 0 ; //<S2SV> cctx -> L = arg ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_SET_TAG : //<S2SV> if ( ( arg & 1 ) || arg < 4 || arg > 16 ) //<S2SV> return 0 ; //<S2SV> if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) //<S2SV> return 0 ; //<S2SV> if ( ptr ) { //<S2SV> cctx -> tag_set = 1 ; //<S2SV> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; //<S2SV> } //<S2SV> cctx -> M = arg ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_AEAD_GET_TAG : //<S2SV> if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) //<S2SV> return 0 ; //<S2SV> if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) //<S2SV> return 0 ; //<S2SV> cctx -> tag_set = 0 ; //<S2SV> cctx -> iv_set = 0 ; //<S2SV> cctx -> len_set = 0 ; //<S2SV> return 1 ; //<S2SV> case EVP_CTRL_COPY : //<S2SV> { //<S2SV> EVP_CIPHER_CTX * out = ptr ; //<S2SV> EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ; //<S2SV> if ( cctx -> ccm . key ) { //<S2SV> if ( cctx -> ccm . key != & cctx -> ks ) //<S2SV> return 0 ; //<S2SV> cctx_out -> ccm . key = & cctx_out -> ks ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> } //<S2SV> default : //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> 