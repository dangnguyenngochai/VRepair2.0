int //<S2SV> main ( int argc , //<S2SV> char * * argv ) //<S2SV> { //<S2SV> mode_t old_umask ; //<S2SV> cleanup_free char * base_path = NULL ; //<S2SV> int clone_flags ; //<S2SV> char * old_cwd = NULL ; //<S2SV> pid_t pid ; //<S2SV> int event_fd = - 1 ; //<S2SV> int child_wait_fd = - 1 ; //<S2SV> const char * new_cwd ; //<S2SV> uid_t ns_uid ; //<S2SV> gid_t ns_gid ; //<S2SV> struct stat sbuf ; //<S2SV> uint64_t val ; //<S2SV> int res UNUSED ; //<S2SV> real_uid = getuid ( ) ; //<S2SV> real_gid = getgid ( ) ; //<S2SV> acquire_privs ( ) ; //<S2SV> if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) //<S2SV> die_with_error ( "prctl(PR_SET_NO_NEW_CAPS)<S2SV_blank>failed" ) ; //<S2SV> read_overflowids ( ) ; //<S2SV> argv0 = argv [ 0 ] ; //<S2SV> if ( isatty ( 1 ) ) //<S2SV> host_tty_dev = ttyname ( 1 ) ; //<S2SV> argv ++ ; //<S2SV> argc -- ; //<S2SV> if ( argc == 0 ) //<S2SV> usage ( EXIT_FAILURE , stderr ) ; //<S2SV> parse_args ( & argc , & argv ) ; //<S2SV> if ( ! is_privileged && getuid ( ) != 0 ) //<S2SV> opt_unshare_user = TRUE ; //<S2SV> if ( opt_unshare_user_try && //<S2SV> stat ( "/proc/self/ns/user" , & sbuf ) == 0 ) //<S2SV> { //<S2SV> bool disabled = FALSE ; //<S2SV> if ( stat ( "/sys/module/user_namespace/parameters/enable" , & sbuf ) == 0 ) //<S2SV> { //<S2SV> cleanup_free char * enable = NULL ; //<S2SV> enable = load_file_at ( AT_FDCWD , "/sys/module/user_namespace/parameters/enable" ) ; //<S2SV> if ( enable != NULL && enable [ 0 ] == 'N' ) //<S2SV> disabled = TRUE ; //<S2SV> } //<S2SV> if ( ! disabled ) //<S2SV> opt_unshare_user = TRUE ; //<S2SV> } //<S2SV> if ( argc == 0 ) //<S2SV> usage ( EXIT_FAILURE , stderr ) ; //<S2SV> __debug__ ( ( "Creating<S2SV_blank>root<S2SV_blank>mount<S2SV_blank>point\\n" ) ) ; //<S2SV> if ( opt_sandbox_uid == - 1 ) //<S2SV> opt_sandbox_uid = real_uid ; //<S2SV> if ( opt_sandbox_gid == - 1 ) //<S2SV> opt_sandbox_gid = real_gid ; //<S2SV> if ( ! opt_unshare_user && opt_sandbox_uid != real_uid ) //<S2SV> die ( "Specifying<S2SV_blank>--uid<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; //<S2SV> if ( ! opt_unshare_user && opt_sandbox_gid != real_gid ) //<S2SV> die ( "Specifying<S2SV_blank>--gid<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; //<S2SV> if ( ! opt_unshare_uts && opt_sandbox_hostname != NULL ) //<S2SV> die ( "Specifying<S2SV_blank>--hostname<S2SV_blank>requires<S2SV_blank>--unshare-uts" ) ; //<S2SV> proc_fd = open ( "/proc" , O_RDONLY | O_PATH ) ; //<S2SV> if ( proc_fd == - 1 ) //<S2SV> die_with_error ( "Can\'t<S2SV_blank>open<S2SV_blank>/proc" ) ; //<S2SV> base_path = xasprintf ( "/run/user/%d/.bubblewrap" , real_uid ) ; //<S2SV> if ( mkdir ( base_path , 0755 ) && errno != EEXIST ) //<S2SV> { //<S2SV> free ( base_path ) ; //<S2SV> base_path = xasprintf ( "/tmp/.bubblewrap-%d" , real_uid ) ; //<S2SV> if ( mkdir ( base_path , 0755 ) && errno != EEXIST ) //<S2SV> die_with_error ( "Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> __debug__ ( ( "creating<S2SV_blank>new<S2SV_blank>namespace\\n" ) ) ; //<S2SV> if ( opt_unshare_pid ) //<S2SV> { //<S2SV> event_fd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ) ; //<S2SV> if ( event_fd == - 1 ) //<S2SV> die_with_error ( "eventfd()" ) ; //<S2SV> } //<S2SV> block_sigchild ( ) ; //<S2SV> clone_flags = SIGCHLD | CLONE_NEWNS ; //<S2SV> if ( opt_unshare_user ) //<S2SV> clone_flags |= CLONE_NEWUSER ; //<S2SV> if ( opt_unshare_pid ) //<S2SV> clone_flags |= CLONE_NEWPID ; //<S2SV> if ( opt_unshare_net ) //<S2SV> clone_flags |= CLONE_NEWNET ; //<S2SV> if ( opt_unshare_ipc ) //<S2SV> clone_flags |= CLONE_NEWIPC ; //<S2SV> if ( opt_unshare_uts ) //<S2SV> clone_flags |= CLONE_NEWUTS ; //<S2SV> if ( opt_unshare_cgroup ) //<S2SV> { //<S2SV> if ( stat ( "/proc/self/ns/cgroup" , & sbuf ) ) //<S2SV> { //<S2SV> if ( errno == ENOENT ) //<S2SV> die ( "Cannot<S2SV_blank>create<S2SV_blank>new<S2SV_blank>cgroup<S2SV_blank>namespace<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>it" ) ; //<S2SV> else //<S2SV> die_with_error ( "stat<S2SV_blank>on<S2SV_blank>/proc/self/ns/cgroup<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> clone_flags |= CLONE_NEWCGROUP ; //<S2SV> } //<S2SV> if ( opt_unshare_cgroup_try ) //<S2SV> if ( ! stat ( "/proc/self/ns/cgroup" , & sbuf ) ) //<S2SV> clone_flags |= CLONE_NEWCGROUP ; //<S2SV> child_wait_fd = eventfd ( 0 , EFD_CLOEXEC ) ; //<S2SV> if ( child_wait_fd == - 1 ) //<S2SV> die_with_error ( "eventfd()" ) ; //<S2SV> pid = raw_clone ( clone_flags , NULL ) ; //<S2SV> if ( pid == - 1 ) //<S2SV> { //<S2SV> if ( opt_unshare_user ) //<S2SV> { //<S2SV> if ( errno == EINVAL ) //<S2SV> die ( "Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank><S2SV_blank>bwrap<S2SV_blank>must<S2SV_blank>be<S2SV_blank>installed<S2SV_blank>setuid<S2SV_blank>on<S2SV_blank>such<S2SV_blank>systems." ) ; //<S2SV> else if ( errno == EPERM && ! is_privileged ) //<S2SV> die ( "No<S2SV_blank>permissions<S2SV_blank>to<S2SV_blank>creating<S2SV_blank>new<S2SV_blank>namespace,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>non-privileged<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank>On<S2SV_blank>e.g.<S2SV_blank>debian<S2SV_blank>this<S2SV_blank>can<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>with<S2SV_blank>\'sysctl<S2SV_blank>kernel.unprivileged_userns_clone=1\'." ) ; //<S2SV> } //<S2SV> die_with_error ( "Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> ns_uid = opt_sandbox_uid ; //<S2SV> ns_gid = opt_sandbox_gid ; //<S2SV> if ( pid != 0 ) //<S2SV> { //<S2SV> if ( is_privileged && opt_unshare_user ) //<S2SV> { //<S2SV> write_uid_gid_map ( ns_uid , real_uid , //<S2SV> ns_gid , real_gid , //<S2SV> pid , TRUE , opt_needs_devpts ) ; //<S2SV> } //<S2SV> drop_privs ( ) ; //<S2SV> val = 1 ; //<S2SV> res = write ( child_wait_fd , & val , 8 ) ; //<S2SV> close ( child_wait_fd ) ; //<S2SV> if ( opt_info_fd != - 1 ) //<S2SV> { //<S2SV> cleanup_free char * output = xasprintf ( "{\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\"child-pid\\":<S2SV_blank>%i\\n}\\n" , pid ) ; //<S2SV> size_t len = strlen ( output ) ; //<S2SV> if ( write ( opt_info_fd , output , len ) != len ) //<S2SV> die_with_error ( "Write<S2SV_blank>to<S2SV_blank>info_fd" ) ; //<S2SV> close ( opt_info_fd ) ; //<S2SV> } //<S2SV> monitor_child ( event_fd ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> if ( opt_info_fd != - 1 ) //<S2SV> close ( opt_info_fd ) ; //<S2SV> res = read ( child_wait_fd , & val , 8 ) ; //<S2SV> close ( child_wait_fd ) ; //<S2SV> switch_to_user_with_privs ( ) ; //<S2SV> if ( opt_unshare_net && loopback_setup ( ) != 0 ) //<S2SV> die ( "Can\'t<S2SV_blank>create<S2SV_blank>loopback<S2SV_blank>device" ) ; //<S2SV> ns_uid = opt_sandbox_uid ; //<S2SV> ns_gid = opt_sandbox_gid ; //<S2SV> if ( ! is_privileged && opt_unshare_user ) //<S2SV> { //<S2SV> if ( opt_needs_devpts ) //<S2SV> { //<S2SV> ns_uid = 0 ; //<S2SV> ns_gid = 0 ; //<S2SV> } //<S2SV> write_uid_gid_map ( ns_uid , real_uid , //<S2SV> ns_gid , real_gid , //<S2SV> - 1 , TRUE , FALSE ) ; //<S2SV> } //<S2SV> old_umask = umask ( 0 ) ; //<S2SV> resolve_symlinks_in_ops ( ) ; //<S2SV> if ( mount ( NULL , "/" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) //<S2SV> die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>/<S2SV_blank>slave" ) ; //<S2SV> if ( mount ( "" , base_path , "tmpfs" , MS_NODEV | MS_NOSUID , NULL ) != 0 ) //<S2SV> die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>tmpfs" ) ; //<S2SV> old_cwd = get_current_dir_name ( ) ; //<S2SV> if ( chdir ( base_path ) != 0 ) //<S2SV> die_with_error ( "chdir<S2SV_blank>base_path" ) ; //<S2SV> if ( mkdir ( "newroot" , 0755 ) ) //<S2SV> die_with_error ( "Creating<S2SV_blank>newroot<S2SV_blank>failed" ) ; //<S2SV> if ( mkdir ( "oldroot" , 0755 ) ) //<S2SV> die_with_error ( "Creating<S2SV_blank>oldroot<S2SV_blank>failed" ) ; //<S2SV> if ( pivot_root ( base_path , "oldroot" ) ) //<S2SV> die_with_error ( "pivot_root" ) ; //<S2SV> if ( chdir ( "/" ) != 0 ) //<S2SV> die_with_error ( "chdir<S2SV_blank>/<S2SV_blank>(base<S2SV_blank>path)" ) ; //<S2SV> if ( is_privileged ) //<S2SV> { //<S2SV> pid_t child ; //<S2SV> int privsep_sockets [ 2 ] ; //<S2SV> if ( socketpair ( AF_UNIX , SOCK_SEQPACKET | SOCK_CLOEXEC , 0 , privsep_sockets ) != 0 ) //<S2SV> die_with_error ( "Can\'t<S2SV_blank>create<S2SV_blank>privsep<S2SV_blank>socket" ) ; //<S2SV> child = fork ( ) ; //<S2SV> if ( child == - 1 ) //<S2SV> die_with_error ( "Can\'t<S2SV_blank>fork<S2SV_blank>unprivileged<S2SV_blank>helper" ) ; //<S2SV> if ( child == 0 ) //<S2SV> { //<S2SV> drop_privs ( ) ; //<S2SV> close ( privsep_sockets [ 0 ] ) ; //<S2SV> setup_newroot ( opt_unshare_pid , privsep_sockets [ 1 ] ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int status ; //<S2SV> uint32_t buffer [ 2048 ] ; //<S2SV> uint32_t op , flags ; //<S2SV> const char * arg1 , * arg2 ; //<S2SV> cleanup_fd int unpriv_socket = - 1 ; //<S2SV> unpriv_socket = privsep_sockets [ 0 ] ; //<S2SV> close ( privsep_sockets [ 1 ] ) ; //<S2SV> do //<S2SV> { //<S2SV> op = read_priv_sec_op ( unpriv_socket , buffer , sizeof ( buffer ) , //<S2SV> & flags , & arg1 , & arg2 ) ; //<S2SV> privileged_op ( - 1 , op , flags , arg1 , arg2 ) ; //<S2SV> if ( write ( unpriv_socket , buffer , 1 ) != 1 ) //<S2SV> die ( "Can\'t<S2SV_blank>write<S2SV_blank>to<S2SV_blank>op_socket" ) ; //<S2SV> } //<S2SV> while ( op != PRIV_SEP_OP_DONE ) ; //<S2SV> waitpid ( child , & status , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> setup_newroot ( opt_unshare_pid , - 1 ) ; //<S2SV> } //<S2SV> if ( mount ( "oldroot" , "oldroot" , NULL , MS_REC | MS_PRIVATE , NULL ) != 0 ) //<S2SV> die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>old<S2SV_blank>root<S2SV_blank>rprivate" ) ; //<S2SV> if ( umount2 ( "oldroot" , MNT_DETACH ) ) //<S2SV> die_with_error ( "unmount<S2SV_blank>old<S2SV_blank>root" ) ; //<S2SV> if ( opt_unshare_user && //<S2SV> ( ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ) ) //<S2SV> { //<S2SV> if ( unshare ( CLONE_NEWUSER ) ) //<S2SV> die_with_error ( "unshare<S2SV_blank>user<S2SV_blank>ns" ) ; //<S2SV> write_uid_gid_map ( opt_sandbox_uid , ns_uid , //<S2SV> opt_sandbox_gid , ns_gid , //<S2SV> - 1 , FALSE , FALSE ) ; //<S2SV> } //<S2SV> if ( chdir ( "/newroot" ) != 0 ) //<S2SV> die_with_error ( "chdir<S2SV_blank>newroot" ) ; //<S2SV> if ( chroot ( "/newroot" ) != 0 ) //<S2SV> die_with_error ( "chroot<S2SV_blank>/newroot" ) ; //<S2SV> if ( chdir ( "/" ) != 0 ) //<S2SV> die_with_error ( "chdir<S2SV_blank>/" ) ; //<S2SV> drop_privs ( ) ; //<S2SV> if ( opt_block_fd != - 1 ) //<S2SV> { //<S2SV> char b [ 1 ] ; //<S2SV> read ( opt_block_fd , b , 1 ) ; //<S2SV> close ( opt_block_fd ) ; //<S2SV> } //<S2SV> if ( opt_seccomp_fd != - 1 ) //<S2SV> { //<S2SV> cleanup_free char * seccomp_data = NULL ; //<S2SV> size_t seccomp_len ; //<S2SV> struct sock_fprog prog ; //<S2SV> seccomp_data = load_file_data ( opt_seccomp_fd , & seccomp_len ) ; //<S2SV> if ( seccomp_data == NULL ) //<S2SV> die_with_error ( "Can\'t<S2SV_blank>read<S2SV_blank>seccomp<S2SV_blank>data" ) ; //<S2SV> if ( seccomp_len % 8 != 0 ) //<S2SV> die ( "Invalid<S2SV_blank>seccomp<S2SV_blank>data,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8" ) ; //<S2SV> prog . len = seccomp_len / 8 ; //<S2SV> prog . filter = ( struct sock_filter * ) seccomp_data ; //<S2SV> close ( opt_seccomp_fd ) ; //<S2SV> if ( prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , & prog ) != 0 ) //<S2SV> die_with_error ( "prctl(PR_SET_SECCOMP)" ) ; //<S2SV> } //<S2SV> umask ( old_umask ) ; //<S2SV> new_cwd = "/" ; //<S2SV> if ( opt_chdir_path ) //<S2SV> { //<S2SV> if ( chdir ( opt_chdir_path ) ) //<S2SV> die_with_error ( "Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>%s" , opt_chdir_path ) ; //<S2SV> new_cwd = opt_chdir_path ; //<S2SV> } //<S2SV> else if ( chdir ( old_cwd ) == 0 ) //<S2SV> { //<S2SV> new_cwd = old_cwd ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> const char * home = getenv ( "HOME" ) ; //<S2SV> if ( home != NULL && //<S2SV> chdir ( home ) == 0 ) //<S2SV> new_cwd = home ; //<S2SV> } //<S2SV> xsetenv ( "PWD" , new_cwd , 1 ) ; //<S2SV> free ( old_cwd ) ; //<S2SV> __debug__ ( ( "forking<S2SV_blank>for<S2SV_blank>child\\n" ) ) ; //<S2SV> if ( opt_unshare_pid || lock_files != NULL || opt_sync_fd != - 1 ) //<S2SV> { //<S2SV> pid = fork ( ) ; //<S2SV> if ( pid == - 1 ) //<S2SV> die_with_error ( "Can\'t<S2SV_blank>fork<S2SV_blank>for<S2SV_blank>pid<S2SV_blank>1" ) ; //<S2SV> if ( pid != 0 ) //<S2SV> { //<S2SV> { //<S2SV> int dont_close [ 3 ] ; //<S2SV> int j = 0 ; //<S2SV> if ( event_fd != - 1 ) //<S2SV> dont_close [ j ++ ] = event_fd ; //<S2SV> if ( opt_sync_fd != - 1 ) //<S2SV> dont_close [ j ++ ] = opt_sync_fd ; //<S2SV> dont_close [ j ++ ] = - 1 ; //<S2SV> fdwalk ( proc_fd , close_extra_fds , dont_close ) ; //<S2SV> } //<S2SV> return do_init ( event_fd , pid ) ; //<S2SV> } //<S2SV> } //<S2SV> __debug__ ( ( "launch<S2SV_blank>executable<S2SV_blank>%s\\n" , argv [ 0 ] ) ) ; //<S2SV> if ( proc_fd != - 1 ) //<S2SV> close ( proc_fd ) ; //<S2SV> if ( opt_sync_fd != - 1 ) //<S2SV> close ( opt_sync_fd ) ; //<S2SV> unblock_sigchild ( ) ; //<S2SV> if ( setsid ( ) == ( pid_t ) - 1 ) //<S2SV> die_with_error ( "setsid" ) ; //<S2SV> if ( label_exec ( opt_exec_label ) == - 1 ) //<S2SV> die_with_error ( "label_exec<S2SV_blank>%s" , argv [ 0 ] ) ; //<S2SV> if ( execvp ( argv [ 0 ] , argv ) == - 1 ) //<S2SV> die_with_error ( "execvp<S2SV_blank>%s" , argv [ 0 ] ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 