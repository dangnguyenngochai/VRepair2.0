EAS_RESULT DLSParser ( EAS_HW_DATA_HANDLE hwInstData , EAS_FILE_HANDLE fileHandle , EAS_I32 offset , EAS_DLSLIB_HANDLE * ppDLS ) //<S2SV> { //<S2SV> EAS_RESULT result ; //<S2SV> SDLS_SYNTHESIZER_DATA dls ; //<S2SV> EAS_U32 temp ; //<S2SV> EAS_I32 pos ; //<S2SV> EAS_I32 chunkPos ; //<S2SV> EAS_I32 size ; //<S2SV> EAS_I32 instSize ; //<S2SV> EAS_I32 rgnPoolSize ; //<S2SV> EAS_I32 artPoolSize ; //<S2SV> EAS_I32 waveLenSize ; //<S2SV> EAS_I32 endDLS ; //<S2SV> EAS_I32 wvplPos ; //<S2SV> EAS_I32 wvplSize ; //<S2SV> EAS_I32 linsPos ; //<S2SV> EAS_I32 linsSize ; //<S2SV> EAS_I32 ptblPos ; //<S2SV> EAS_I32 ptblSize ; //<S2SV> void * p ; //<S2SV> EAS_HWMemSet ( & dls , 0 , sizeof ( dls ) ) ; //<S2SV> dls . hwInstData = hwInstData ; //<S2SV> dls . fileHandle = fileHandle ; //<S2SV> * ppDLS = NULL ; //<S2SV> if ( ( result = EAS_HWFileSeek ( dls . hwInstData , dls . fileHandle , offset ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> if ( ( result = EAS_HWReadFile ( dls . hwInstData , dls . fileHandle , & temp , sizeof ( temp ) , & size ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> dls . bigEndian = ( temp == CHUNK_RIFF ) ; //<S2SV> pos = offset ; //<S2SV> if ( ( result = NextChunk ( & dls , & pos , & temp , & size ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> if ( temp != CHUNK_DLS ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_FILE_FORMAT ; //<S2SV> } //<S2SV> linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0 ; //<S2SV> endDLS = offset + size ; //<S2SV> pos = offset + 12 ; //<S2SV> while ( pos < endDLS ) //<S2SV> { //<S2SV> chunkPos = pos ; //<S2SV> if ( ( result = NextChunk ( & dls , & pos , & temp , & size ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> switch ( temp ) //<S2SV> { //<S2SV> case CHUNK_CDL : //<S2SV> if ( ( result = Parse_cdl ( & dls , size , & temp ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> if ( ! temp ) //<S2SV> return EAS_ERROR_UNRECOGNIZED_FORMAT ; //<S2SV> break ; //<S2SV> case CHUNK_LINS : //<S2SV> linsPos = chunkPos + 12 ; //<S2SV> linsSize = size - 4 ; //<S2SV> break ; //<S2SV> case CHUNK_WVPL : //<S2SV> wvplPos = chunkPos + 12 ; //<S2SV> wvplSize = size - 4 ; //<S2SV> break ; //<S2SV> case CHUNK_PTBL : //<S2SV> ptblPos = chunkPos + 8 ; //<S2SV> ptblSize = size - 4 ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( linsSize == 0 ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_UNRECOGNIZED_FORMAT ; //<S2SV> } //<S2SV> if ( wvplSize == 0 ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_UNRECOGNIZED_FORMAT ; //<S2SV> } //<S2SV> if ( ( ptblSize == 0 ) || ( ptblSize > DLS_MAX_WAVE_COUNT * sizeof ( POOLCUE ) + sizeof ( POOLTABLE ) ) ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_UNRECOGNIZED_FORMAT ; //<S2SV> } //<S2SV> if ( ( result = Parse_ptbl ( & dls , ptblPos , wvplPos , wvplSize ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> if ( ( dls . waveCount == 0 ) || ( dls . waveCount > DLS_MAX_WAVE_COUNT ) ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_FILE_FORMAT ; //<S2SV> } //<S2SV> dls . wsmpData = EAS_HWMalloc ( dls . hwInstData , ( EAS_I32 ) ( sizeof ( S_WSMP_DATA ) * dls . waveCount ) ) ; //<S2SV> if ( dls . wsmpData == NULL ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_MALLOC_FAILED ; //<S2SV> } //<S2SV> EAS_HWMemSet ( dls . wsmpData , 0 , ( EAS_I32 ) ( sizeof ( S_WSMP_DATA ) * dls . waveCount ) ) ; //<S2SV> result = Parse_lins ( & dls , linsPos , linsSize ) ; //<S2SV> if ( result == EAS_SUCCESS ) //<S2SV> { //<S2SV> if ( ( dls . regionCount == 0 ) || ( dls . regionCount > DLS_MAX_REGION_COUNT ) ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_FILE_FORMAT ; //<S2SV> } //<S2SV> if ( ( dls . artCount == 0 ) || ( dls . artCount > DLS_MAX_ART_COUNT ) ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_FILE_FORMAT ; //<S2SV> } //<S2SV> if ( ( dls . instCount == 0 ) || ( dls . instCount > DLS_MAX_INST_COUNT ) ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_FILE_FORMAT ; //<S2SV> } //<S2SV> instSize = ( EAS_I32 ) ( sizeof ( S_PROGRAM ) * dls . instCount ) ; //<S2SV> rgnPoolSize = ( EAS_I32 ) ( sizeof ( S_DLS_REGION ) * dls . regionCount ) ; //<S2SV> dls . artCount ++ ; //<S2SV> artPoolSize = ( EAS_I32 ) ( sizeof ( S_DLS_ARTICULATION ) * dls . artCount ) ; //<S2SV> waveLenSize = ( EAS_I32 ) ( dls . waveCount * sizeof ( EAS_U32 ) ) ; //<S2SV> size = ( EAS_I32 ) sizeof ( S_EAS ) + instSize + rgnPoolSize + artPoolSize + ( 2 * waveLenSize ) + ( EAS_I32 ) dls . wavePoolSize ; //<S2SV> if ( size <= 0 ) { //<S2SV> return EAS_ERROR_FILE_FORMAT ; //<S2SV> } //<S2SV> dls . pDLS = EAS_HWMalloc ( dls . hwInstData , size ) ; //<S2SV> if ( dls . pDLS == NULL ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_MALLOC_FAILED ; //<S2SV> } //<S2SV> EAS_HWMemSet ( dls . pDLS , 0 , size ) ; //<S2SV> dls . pDLS -> refCount = 1 ; //<S2SV> p = PtrOfs ( dls . pDLS , sizeof ( S_EAS ) ) ; //<S2SV> dls . pDLS -> numDLSPrograms = ( EAS_U16 ) dls . instCount ; //<S2SV> dls . pDLS -> pDLSPrograms = p ; //<S2SV> p = PtrOfs ( p , instSize ) ; //<S2SV> dls . pDLS -> pDLSRegions = p ; //<S2SV> dls . pDLS -> numDLSRegions = ( EAS_U16 ) dls . regionCount ; //<S2SV> p = PtrOfs ( p , rgnPoolSize ) ; //<S2SV> dls . pDLS -> numDLSArticulations = ( EAS_U16 ) dls . artCount ; //<S2SV> dls . pDLS -> pDLSArticulations = p ; //<S2SV> p = PtrOfs ( p , artPoolSize ) ; //<S2SV> dls . pDLS -> numDLSSamples = ( EAS_U16 ) dls . waveCount ; //<S2SV> dls . pDLS -> pDLSSampleLen = p ; //<S2SV> p = PtrOfs ( p , waveLenSize ) ; //<S2SV> dls . pDLS -> pDLSSampleOffsets = p ; //<S2SV> p = PtrOfs ( p , waveLenSize ) ; //<S2SV> dls . pDLS -> pDLSSamples = p ; //<S2SV> dls . filterUsed = EAS_FALSE ; //<S2SV> result = Parse_ptbl ( & dls , ptblPos , wvplPos , wvplSize ) ; //<S2SV> } //<S2SV> if ( dls . pDLS ) { //<S2SV> Convert_art ( & dls , & defaultArt , 0 ) ; //<S2SV> dls . artCount = 1 ; //<S2SV> } //<S2SV> dls . regionCount = dls . instCount = 0 ; //<S2SV> if ( result == EAS_SUCCESS ) //<S2SV> result = Parse_lins ( & dls , linsPos , linsSize ) ; //<S2SV> if ( dls . wsmpData ) //<S2SV> EAS_HWFree ( dls . hwInstData , dls . wsmpData ) ; //<S2SV> if ( result == EAS_SUCCESS ) //<S2SV> { //<S2SV> * ppDLS = dls . pDLS ; //<S2SV> # ifdef _DEBUG_DLS //<S2SV> DumpDLS ( dls . pDLS ) ; //<S2SV> # endif //<S2SV> } //<S2SV> else //<S2SV> DLSCleanup ( dls . hwInstData , dls . pDLS ) ; //<S2SV> return result ; //<S2SV> } //<S2SV> 