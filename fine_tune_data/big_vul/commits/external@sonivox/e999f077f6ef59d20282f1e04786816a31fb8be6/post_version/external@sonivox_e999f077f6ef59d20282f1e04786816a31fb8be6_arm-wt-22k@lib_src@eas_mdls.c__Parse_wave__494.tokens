static EAS_RESULT Parse_wave ( SDLS_SYNTHESIZER_DATA * pDLSData , EAS_I32 pos , EAS_U16 waveIndex ) //<S2SV> { //<S2SV> EAS_RESULT result ; //<S2SV> EAS_U32 temp ; //<S2SV> EAS_I32 size ; //<S2SV> EAS_I32 endChunk ; //<S2SV> EAS_I32 chunkPos ; //<S2SV> EAS_I32 wsmpPos = 0 ; //<S2SV> EAS_I32 fmtPos = 0 ; //<S2SV> EAS_I32 dataPos = 0 ; //<S2SV> EAS_I32 dataSize = 0 ; //<S2SV> S_WSMP_DATA * p ; //<S2SV> void * pSample ; //<S2SV> S_WSMP_DATA wsmp ; //<S2SV> chunkPos = pos + 12 ; //<S2SV> if ( ( result = EAS_HWFileSeek ( pDLSData -> hwInstData , pDLSData -> fileHandle , pos ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> if ( temp != CHUNK_WAVE ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_FILE_FORMAT ; //<S2SV> } //<S2SV> pos = chunkPos ; //<S2SV> endChunk = pos + size ; //<S2SV> while ( pos < endChunk ) //<S2SV> { //<S2SV> chunkPos = pos ; //<S2SV> if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> switch ( temp ) //<S2SV> { //<S2SV> case CHUNK_WSMP : //<S2SV> wsmpPos = chunkPos + 8 ; //<S2SV> break ; //<S2SV> case CHUNK_FMT : //<S2SV> fmtPos = chunkPos + 8 ; //<S2SV> break ; //<S2SV> case CHUNK_DATA : //<S2SV> dataPos = chunkPos + 8 ; //<S2SV> dataSize = size ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( dataSize < 0 || dataSize > MAX_DLS_WAVE_SIZE ) //<S2SV> { //<S2SV> return EAS_ERROR_SOUND_LIBRARY ; //<S2SV> } //<S2SV> if ( pDLSData -> pDLS == NULL ) //<S2SV> p = & wsmp ; //<S2SV> else //<S2SV> p = & pDLSData -> wsmpData [ waveIndex ] ; //<S2SV> p -> fineTune = 0 ; //<S2SV> p -> unityNote = 60 ; //<S2SV> p -> gain = 0 ; //<S2SV> p -> loopStart = 0 ; //<S2SV> p -> loopLength = 0 ; //<S2SV> if ( ! fmtPos ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_UNRECOGNIZED_FORMAT ; //<S2SV> } //<S2SV> if ( ! dataPos ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_UNRECOGNIZED_FORMAT ; //<S2SV> } //<S2SV> if ( wsmpPos ) //<S2SV> { //<S2SV> if ( ( result = Parse_wsmp ( pDLSData , wsmpPos , p ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> } //<S2SV> if ( ( result = Parse_fmt ( pDLSData , fmtPos , p ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> if ( bitDepth == 8 ) //<S2SV> { //<S2SV> if ( p -> bitsPerSample == 8 ) //<S2SV> size = dataSize ; //<S2SV> else //<S2SV> size = dataSize >> 1 ; //<S2SV> if ( p -> loopLength ) //<S2SV> size ++ ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( p -> bitsPerSample == 16 ) //<S2SV> size = dataSize ; //<S2SV> else //<S2SV> size = dataSize << 1 ; //<S2SV> if ( p -> loopLength ) //<S2SV> size += 2 ; //<S2SV> } //<S2SV> if ( pDLSData -> pDLS == NULL ) //<S2SV> { //<S2SV> pDLSData -> wavePoolSize += ( EAS_U32 ) size ; //<S2SV> return EAS_SUCCESS ; //<S2SV> } //<S2SV> pSample = pDLSData -> pDLS -> pDLSSamples + pDLSData -> wavePoolOffset ; //<S2SV> pDLSData -> pDLS -> pDLSSampleOffsets [ waveIndex ] = pDLSData -> wavePoolOffset ; //<S2SV> pDLSData -> pDLS -> pDLSSampleLen [ waveIndex ] = ( EAS_U32 ) size ; //<S2SV> pDLSData -> wavePoolOffset += ( EAS_U32 ) size ; //<S2SV> if ( pDLSData -> wavePoolOffset > pDLSData -> wavePoolSize ) //<S2SV> { //<S2SV> { } //<S2SV> return EAS_ERROR_SOUND_LIBRARY ; //<S2SV> } //<S2SV> if ( ( result = Parse_data ( pDLSData , dataPos , dataSize , p , pSample ) ) != EAS_SUCCESS ) //<S2SV> return result ; //<S2SV> return EAS_SUCCESS ; //<S2SV> } //<S2SV> 