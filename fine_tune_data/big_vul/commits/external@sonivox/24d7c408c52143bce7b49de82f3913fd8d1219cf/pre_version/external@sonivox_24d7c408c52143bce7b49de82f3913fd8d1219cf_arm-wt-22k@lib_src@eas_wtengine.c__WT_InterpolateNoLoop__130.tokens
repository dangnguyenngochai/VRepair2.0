void WT_InterpolateNoLoop ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) //<S2SV> { //<S2SV> EAS_PCM * pOutputBuffer ; //<S2SV> EAS_I32 phaseInc ; //<S2SV> EAS_I32 phaseFrac ; //<S2SV> EAS_I32 acc0 ; //<S2SV> const EAS_SAMPLE * pSamples ; //<S2SV> EAS_I32 samp1 ; //<S2SV> EAS_I32 samp2 ; //<S2SV> EAS_I32 numSamples ; //<S2SV> numSamples = pWTIntFrame -> numSamples ; //<S2SV> if ( numSamples <= 0 ) { //<S2SV> ALOGE ( "b/26366256" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> pOutputBuffer = pWTIntFrame -> pAudioBuffer ; //<S2SV> phaseInc = pWTIntFrame -> frame . phaseIncrement ; //<S2SV> pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; //<S2SV> phaseFrac = ( EAS_I32 ) pWTVoice -> phaseFrac ; //<S2SV> # if defined ( _8_BIT_SAMPLES ) //<S2SV> samp1 = pSamples [ 0 ] << 8 ; //<S2SV> samp2 = pSamples [ 1 ] << 8 ; //<S2SV> # else //<S2SV> samp1 = pSamples [ 0 ] ; //<S2SV> samp2 = pSamples [ 1 ] ; //<S2SV> # endif //<S2SV> while ( numSamples -- ) { //<S2SV> acc0 = samp2 - samp1 ; //<S2SV> acc0 = acc0 * phaseFrac ; //<S2SV> acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; //<S2SV> * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; //<S2SV> phaseFrac += phaseInc ; //<S2SV> acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; //<S2SV> if ( acc0 > 0 ) { //<S2SV> pSamples += acc0 ; //<S2SV> phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; //<S2SV> # if defined ( _8_BIT_SAMPLES ) //<S2SV> samp1 = pSamples [ 0 ] << 8 ; //<S2SV> samp2 = pSamples [ 1 ] << 8 ; //<S2SV> # else //<S2SV> samp1 = pSamples [ 0 ] ; //<S2SV> samp2 = pSamples [ 1 ] ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; //<S2SV> pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; //<S2SV> } //<S2SV> 