EAS_BOOL WT_CheckSampleEnd ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame , EAS_BOOL update ) //<S2SV> { //<S2SV> EAS_U32 endPhaseAccum ; //<S2SV> EAS_U32 endPhaseFrac ; //<S2SV> EAS_I32 numSamples ; //<S2SV> EAS_BOOL done = EAS_FALSE ; //<S2SV> endPhaseFrac = pWTVoice -> phaseFrac + ( pWTIntFrame -> frame . phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS ) ; //<S2SV> endPhaseAccum = pWTVoice -> phaseAccum + GET_PHASE_INT_PART ( endPhaseFrac ) ; //<S2SV> if ( endPhaseAccum >= pWTVoice -> loopEnd ) //<S2SV> { //<S2SV> numSamples = ( EAS_I32 ) ( pWTVoice -> loopEnd - pWTVoice -> phaseAccum ) ; //<S2SV> numSamples = ( EAS_I32 ) ( ( numSamples << NUM_PHASE_FRAC_BITS ) - pWTVoice -> phaseFrac ) ; //<S2SV> if ( pWTIntFrame -> frame . phaseIncrement ) { //<S2SV> pWTIntFrame -> numSamples = 1 + ( numSamples / pWTIntFrame -> frame . phaseIncrement ) ; //<S2SV> } else { //<S2SV> pWTIntFrame -> numSamples = numSamples ; //<S2SV> } //<S2SV> if ( pWTIntFrame -> numSamples < 0 ) { //<S2SV> ALOGE ( "b/26366256" ) ; //<S2SV> pWTIntFrame -> numSamples = 0 ; //<S2SV> } //<S2SV> done = EAS_TRUE ; //<S2SV> } //<S2SV> if ( update ) //<S2SV> { //<S2SV> pWTVoice -> phaseFrac = endPhaseFrac ; //<S2SV> pWTVoice -> phaseAccum = endPhaseAccum ; //<S2SV> } //<S2SV> return done ; //<S2SV> } //<S2SV> 