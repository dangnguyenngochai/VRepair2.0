int //<S2SV> cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , //<S2SV> uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) //<S2SV> { //<S2SV> const cdf_section_header_t * shp ; //<S2SV> cdf_section_header_t sh ; //<S2SV> const uint8_t * p , * q , * e ; //<S2SV> int16_t s16 ; //<S2SV> int32_t s32 ; //<S2SV> uint32_t u32 ; //<S2SV> int64_t s64 ; //<S2SV> uint64_t u64 ; //<S2SV> cdf_timestamp_t tp ; //<S2SV> size_t i , o , o4 , nelements , j ; //<S2SV> cdf_property_info_t * inp ; //<S2SV> if ( offs > UINT32_MAX / 4 ) { //<S2SV> errno = EFTYPE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> shp = CAST ( const cdf_section_header_t * , ( const void * ) //<S2SV> ( ( const char * ) sst -> sst_tab + offs ) ) ; //<S2SV> if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) //<S2SV> goto out ; //<S2SV> sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; //<S2SV> # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) //<S2SV> if ( sh . sh_len > CDF_SHLEN_LIMIT ) { //<S2SV> errno = EFTYPE ; //<S2SV> goto out ; //<S2SV> } //<S2SV> sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; //<S2SV> # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) //<S2SV> if ( sh . sh_properties > CDF_PROP_LIMIT ) //<S2SV> goto out ; //<S2SV> DPRINTF ( ( "section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n" , sh . sh_len , //<S2SV> sh . sh_properties ) ) ; //<S2SV> if ( * maxcount ) { //<S2SV> if ( * maxcount > CDF_PROP_LIMIT ) //<S2SV> goto out ; //<S2SV> * maxcount += sh . sh_properties ; //<S2SV> inp = CAST ( cdf_property_info_t * , //<S2SV> realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; //<S2SV> } else { //<S2SV> * maxcount = sh . sh_properties ; //<S2SV> inp = CAST ( cdf_property_info_t * , //<S2SV> malloc ( * maxcount * sizeof ( * inp ) ) ) ; //<S2SV> } //<S2SV> if ( inp == NULL ) //<S2SV> goto out ; //<S2SV> * info = inp ; //<S2SV> inp += * count ; //<S2SV> * count += sh . sh_properties ; //<S2SV> p = CAST ( const uint8_t * , ( const void * ) //<S2SV> ( ( const char * ) ( const void * ) sst -> sst_tab + //<S2SV> offs + sizeof ( sh ) ) ) ; //<S2SV> e = CAST ( const uint8_t * , ( const void * ) //<S2SV> ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; //<S2SV> if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) //<S2SV> goto out ; //<S2SV> for ( i = 0 ; i < sh . sh_properties ; i ++ ) { //<S2SV> size_t tail = ( i << 1 ) + 1 ; //<S2SV> if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , //<S2SV> __LINE__ ) == - 1 ) //<S2SV> goto out ; //<S2SV> size_t ofs = CDF_GETUINT32 ( p , tail ) ; //<S2SV> q = ( const uint8_t * ) ( const void * ) //<S2SV> ( ( const char * ) ( const void * ) p + ofs //<S2SV> - 2 * sizeof ( uint32_t ) ) ; //<S2SV> if ( q < p ) { //<S2SV> DPRINTF ( ( "Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n" , q , p ) ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( q > e ) { //<S2SV> DPRINTF ( ( "Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n" , q , e ) ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; //<S2SV> inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; //<S2SV> DPRINTF ( ( "%" SIZE_T_FORMAT "u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n" , //<S2SV> i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) { //<S2SV> nelements = CDF_GETUINT32 ( q , 1 ) ; //<S2SV> if ( nelements == 0 ) { //<S2SV> DPRINTF ( ( "CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n" ) ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> o = 2 ; //<S2SV> } else { //<S2SV> nelements = 1 ; //<S2SV> o = 1 ; //<S2SV> } //<S2SV> o4 = o * sizeof ( uint32_t ) ; //<S2SV> if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) //<S2SV> goto unknown ; //<S2SV> switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { //<S2SV> case CDF_NULL : //<S2SV> case CDF_EMPTY : //<S2SV> break ; //<S2SV> case CDF_SIGNED16 : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; //<S2SV> inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; //<S2SV> break ; //<S2SV> case CDF_SIGNED32 : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; //<S2SV> inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; //<S2SV> break ; //<S2SV> case CDF_BOOL : //<S2SV> case CDF_UNSIGNED32 : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; //<S2SV> inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; //<S2SV> break ; //<S2SV> case CDF_SIGNED64 : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; //<S2SV> inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; //<S2SV> break ; //<S2SV> case CDF_UNSIGNED64 : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; //<S2SV> inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; //<S2SV> break ; //<S2SV> case CDF_FLOAT : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; //<S2SV> u32 = CDF_TOLE4 ( u32 ) ; //<S2SV> memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; //<S2SV> break ; //<S2SV> case CDF_DOUBLE : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; //<S2SV> u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; //<S2SV> memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; //<S2SV> break ; //<S2SV> case CDF_LENGTH32_STRING : //<S2SV> case CDF_LENGTH32_WSTRING : //<S2SV> if ( nelements > 1 ) { //<S2SV> size_t nelem = inp - * info ; //<S2SV> if ( * maxcount > CDF_PROP_LIMIT //<S2SV> || nelements > CDF_PROP_LIMIT ) //<S2SV> goto out ; //<S2SV> * maxcount += nelements ; //<S2SV> inp = CAST ( cdf_property_info_t * , //<S2SV> realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; //<S2SV> if ( inp == NULL ) //<S2SV> goto out ; //<S2SV> * info = inp ; //<S2SV> inp = * info + nelem ; //<S2SV> } //<S2SV> DPRINTF ( ( "nelements<S2SV_blank>=<S2SV_blank>%" SIZE_T_FORMAT "u\\n" , //<S2SV> nelements ) ) ; //<S2SV> for ( j = 0 ; j < nelements && i < sh . sh_properties ; //<S2SV> j ++ , i ++ ) //<S2SV> { //<S2SV> uint32_t l = CDF_GETUINT32 ( q , o ) ; //<S2SV> inp [ i ] . pi_str . s_len = l ; //<S2SV> inp [ i ] . pi_str . s_buf = ( const char * ) //<S2SV> ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; //<S2SV> DPRINTF ( ( "l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%" SIZE_T_FORMAT //<S2SV> "u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n" , l , //<S2SV> CDF_ROUND ( l , sizeof ( l ) ) , //<S2SV> inp [ i ] . pi_str . s_buf ) ) ; //<S2SV> if ( l & 1 ) //<S2SV> l ++ ; //<S2SV> o += l >> 1 ; //<S2SV> if ( q + o >= e ) //<S2SV> goto out ; //<S2SV> o4 = o * sizeof ( uint32_t ) ; //<S2SV> } //<S2SV> i -- ; //<S2SV> break ; //<S2SV> case CDF_FILETIME : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; //<S2SV> inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; //<S2SV> break ; //<S2SV> case CDF_CLIPBOARD : //<S2SV> if ( inp [ i ] . pi_type & CDF_VECTOR ) //<S2SV> goto unknown ; //<S2SV> break ; //<S2SV> default : //<S2SV> unknown : //<S2SV> DPRINTF ( ( "Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n" , //<S2SV> inp [ i ] . pi_type ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> out : //<S2SV> free ( * info ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> 