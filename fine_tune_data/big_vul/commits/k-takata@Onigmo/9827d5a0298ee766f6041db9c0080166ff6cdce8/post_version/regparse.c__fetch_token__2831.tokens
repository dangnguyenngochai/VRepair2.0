static int //<S2SV> fetch_token ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) //<S2SV> { //<S2SV> int r , num ; //<S2SV> OnigCodePoint c ; //<S2SV> OnigEncoding enc = env -> enc ; //<S2SV> const OnigSyntaxType * syn = env -> syntax ; //<S2SV> UChar * prev ; //<S2SV> UChar * p = * src ; //<S2SV> PFETCH_READY ; //<S2SV> start : //<S2SV> if ( PEND ) { //<S2SV> tok -> type = TK_EOT ; //<S2SV> return tok -> type ; //<S2SV> } //<S2SV> tok -> type = TK_STRING ; //<S2SV> tok -> base = 0 ; //<S2SV> tok -> backp = p ; //<S2SV> PFETCH ( c ) ; //<S2SV> if ( IS_MC_ESC_CODE ( c , syn ) ) { //<S2SV> if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; //<S2SV> tok -> backp = p ; //<S2SV> PFETCH ( c ) ; //<S2SV> tok -> u . c = c ; //<S2SV> tok -> escaped = 1 ; //<S2SV> switch ( c ) { //<S2SV> case '*' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF ) ) break ; //<S2SV> tok -> type = TK_OP_REPEAT ; //<S2SV> tok -> u . repeat . lower = 0 ; //<S2SV> tok -> u . repeat . upper = REPEAT_INFINITE ; //<S2SV> goto greedy_check ; //<S2SV> break ; //<S2SV> case '+' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_PLUS_ONE_INF ) ) break ; //<S2SV> tok -> type = TK_OP_REPEAT ; //<S2SV> tok -> u . repeat . lower = 1 ; //<S2SV> tok -> u . repeat . upper = REPEAT_INFINITE ; //<S2SV> goto greedy_check ; //<S2SV> break ; //<S2SV> case '?' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_QMARK_ZERO_ONE ) ) break ; //<S2SV> tok -> type = TK_OP_REPEAT ; //<S2SV> tok -> u . repeat . lower = 0 ; //<S2SV> tok -> u . repeat . upper = 1 ; //<S2SV> greedy_check : //<S2SV> if ( ! PEND && PPEEK_IS ( '?' ) && //<S2SV> IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_NON_GREEDY ) ) { //<S2SV> PFETCH ( c ) ; //<S2SV> tok -> u . repeat . greedy = 0 ; //<S2SV> tok -> u . repeat . possessive = 0 ; //<S2SV> } //<S2SV> else { //<S2SV> possessive_check : //<S2SV> if ( ! PEND && PPEEK_IS ( '+' ) && //<S2SV> ( ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT ) && //<S2SV> tok -> type != TK_INTERVAL ) || //<S2SV> ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL ) && //<S2SV> tok -> type == TK_INTERVAL ) ) ) { //<S2SV> PFETCH ( c ) ; //<S2SV> tok -> u . repeat . greedy = 1 ; //<S2SV> tok -> u . repeat . possessive = 1 ; //<S2SV> } //<S2SV> else { //<S2SV> tok -> u . repeat . greedy = 1 ; //<S2SV> tok -> u . repeat . possessive = 0 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case '{' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_BRACE_INTERVAL ) ) break ; //<S2SV> r = fetch_range_quantifier ( & p , end , tok , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> if ( r == 0 ) goto greedy_check ; //<S2SV> else if ( r == 2 ) { //<S2SV> if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) //<S2SV> goto possessive_check ; //<S2SV> goto greedy_check ; //<S2SV> } //<S2SV> break ; //<S2SV> case '|' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_VBAR_ALT ) ) break ; //<S2SV> tok -> type = TK_ALT ; //<S2SV> break ; //<S2SV> case '(' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; //<S2SV> tok -> type = TK_SUBEXP_OPEN ; //<S2SV> break ; //<S2SV> case ')' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; //<S2SV> tok -> type = TK_SUBEXP_CLOSE ; //<S2SV> break ; //<S2SV> case 'w' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; //<S2SV> tok -> u . prop . not = 0 ; //<S2SV> break ; //<S2SV> case 'W' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; //<S2SV> tok -> u . prop . not = 1 ; //<S2SV> break ; //<S2SV> case 'b' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ANCHOR_WORD_BOUND ; //<S2SV> tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) //<S2SV> && ! IS_WORD_BOUND_ALL_RANGE ( env -> option ) ; //<S2SV> break ; //<S2SV> case 'B' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ANCHOR_NOT_WORD_BOUND ; //<S2SV> tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) //<S2SV> && ! IS_WORD_BOUND_ALL_RANGE ( env -> option ) ; //<S2SV> break ; //<S2SV> # ifdef USE_WORD_BEGIN_END //<S2SV> case '<' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ANCHOR_WORD_BEGIN ; //<S2SV> tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) ; //<S2SV> break ; //<S2SV> case '>' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ANCHOR_WORD_END ; //<S2SV> tok -> u . anchor . ascii_range = IS_ASCII_RANGE ( env -> option ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case 's' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; //<S2SV> tok -> u . prop . not = 0 ; //<S2SV> break ; //<S2SV> case 'S' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; //<S2SV> tok -> u . prop . not = 1 ; //<S2SV> break ; //<S2SV> case 'd' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; //<S2SV> tok -> u . prop . not = 0 ; //<S2SV> break ; //<S2SV> case 'D' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; //<S2SV> tok -> u . prop . not = 1 ; //<S2SV> break ; //<S2SV> case 'h' : //<S2SV> if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; //<S2SV> tok -> u . prop . not = 0 ; //<S2SV> break ; //<S2SV> case 'H' : //<S2SV> if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; //<S2SV> tok -> type = TK_CHAR_TYPE ; //<S2SV> tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; //<S2SV> tok -> u . prop . not = 1 ; //<S2SV> break ; //<S2SV> case 'A' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; //<S2SV> begin_buf : //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ANCHOR_BEGIN_BUF ; //<S2SV> break ; //<S2SV> case 'Z' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ANCHOR_SEMI_END_BUF ; //<S2SV> break ; //<S2SV> case 'z' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; //<S2SV> end_buf : //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ANCHOR_END_BUF ; //<S2SV> break ; //<S2SV> case 'G' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR ) ) break ; //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ANCHOR_BEGIN_POSITION ; //<S2SV> break ; //<S2SV> case '`' : //<S2SV> if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; //<S2SV> goto begin_buf ; //<S2SV> break ; //<S2SV> case '\\'' : //<S2SV> if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; //<S2SV> goto end_buf ; //<S2SV> break ; //<S2SV> case 'x' : //<S2SV> if ( PEND ) break ; //<S2SV> prev = p ; //<S2SV> if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_BRACE_HEX8 ) ) { //<S2SV> PINC ; //<S2SV> num = scan_unsigned_hexadecimal_number ( & p , end , 0 , 8 , enc ) ; //<S2SV> if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; //<S2SV> if ( ! PEND ) { //<S2SV> if ( ONIGENC_IS_CODE_XDIGIT ( enc , PPEEK ) ) //<S2SV> return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; //<S2SV> } //<S2SV> if ( ( p > prev + enclen ( enc , prev , end ) ) && ! PEND && PPEEK_IS ( '}' ) ) { //<S2SV> PINC ; //<S2SV> tok -> type = TK_CODE_POINT ; //<S2SV> tok -> u . code = ( OnigCodePoint ) num ; //<S2SV> } //<S2SV> else { //<S2SV> p = prev ; //<S2SV> } //<S2SV> } //<S2SV> else if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_HEX2 ) ) { //<S2SV> num = scan_unsigned_hexadecimal_number ( & p , end , 0 , 2 , enc ) ; //<S2SV> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; //<S2SV> if ( p == prev ) { //<S2SV> num = 0 ; //<S2SV> } //<S2SV> tok -> type = TK_RAW_BYTE ; //<S2SV> tok -> base = 16 ; //<S2SV> tok -> u . c = num ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'u' : //<S2SV> if ( PEND ) break ; //<S2SV> prev = p ; //<S2SV> if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_U_HEX4 ) ) { //<S2SV> num = scan_unsigned_hexadecimal_number ( & p , end , 4 , 4 , enc ) ; //<S2SV> if ( num < - 1 ) return ONIGERR_TOO_SHORT_DIGITS ; //<S2SV> else if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; //<S2SV> if ( p == prev ) { //<S2SV> num = 0 ; //<S2SV> } //<S2SV> tok -> type = TK_CODE_POINT ; //<S2SV> tok -> base = 16 ; //<S2SV> tok -> u . code = ( OnigCodePoint ) num ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'o' : //<S2SV> if ( PEND ) break ; //<S2SV> prev = p ; //<S2SV> if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_O_BRACE_OCTAL ) ) { //<S2SV> PINC ; //<S2SV> num = scan_unsigned_octal_number ( & p , end , 11 , enc ) ; //<S2SV> if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; //<S2SV> if ( ! PEND ) { //<S2SV> OnigCodePoint c = PPEEK ; //<S2SV> if ( ONIGENC_IS_CODE_DIGIT ( enc , c ) && c < '8' ) //<S2SV> return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; //<S2SV> } //<S2SV> if ( ( p > prev + enclen ( enc , prev , end ) ) && ! PEND && PPEEK_IS ( '}' ) ) { //<S2SV> PINC ; //<S2SV> tok -> type = TK_CODE_POINT ; //<S2SV> tok -> u . code = ( OnigCodePoint ) num ; //<S2SV> } //<S2SV> else { //<S2SV> p = prev ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case '1' : case '2' : case '3' : case '4' : //<S2SV> case '5' : case '6' : case '7' : case '8' : case '9' : //<S2SV> PUNFETCH ; //<S2SV> prev = p ; //<S2SV> num = onig_scan_unsigned_number ( & p , end , enc ) ; //<S2SV> if ( num < 0 || num > ONIG_MAX_BACKREF_NUM ) { //<S2SV> goto skip_backref ; //<S2SV> } //<S2SV> if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DECIMAL_BACKREF ) && //<S2SV> ( num <= env -> num_mem || num <= 9 ) ) { //<S2SV> if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { //<S2SV> if ( num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ num ] ) ) //<S2SV> return ONIGERR_INVALID_BACKREF ; //<S2SV> } //<S2SV> tok -> type = TK_BACKREF ; //<S2SV> tok -> u . backref . num = 1 ; //<S2SV> tok -> u . backref . ref1 = num ; //<S2SV> tok -> u . backref . by_name = 0 ; //<S2SV> # ifdef USE_BACKREF_WITH_LEVEL //<S2SV> tok -> u . backref . exist_level = 0 ; //<S2SV> # endif //<S2SV> break ; //<S2SV> } //<S2SV> skip_backref : //<S2SV> if ( c == '8' || c == '9' ) { //<S2SV> p = prev ; PINC ; //<S2SV> break ; //<S2SV> } //<S2SV> p = prev ; //<S2SV> case '0' : //<S2SV> if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { //<S2SV> prev = p ; //<S2SV> num = scan_unsigned_octal_number ( & p , end , ( c == '0' ? 2 : 3 ) , enc ) ; //<S2SV> if ( num < 0 || 0xff < num ) return ONIGERR_TOO_BIG_NUMBER ; //<S2SV> if ( p == prev ) { //<S2SV> num = 0 ; //<S2SV> } //<S2SV> tok -> type = TK_RAW_BYTE ; //<S2SV> tok -> base = 8 ; //<S2SV> tok -> u . c = num ; //<S2SV> } //<S2SV> else if ( c != '0' ) { //<S2SV> PINC ; //<S2SV> } //<S2SV> break ; //<S2SV> # ifdef USE_NAMED_GROUP //<S2SV> case 'k' : //<S2SV> if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_K_NAMED_BACKREF ) ) { //<S2SV> PFETCH ( c ) ; //<S2SV> if ( c == '<' || c == '\\'' ) { //<S2SV> r = fetch_named_backref_token ( c , tok , & p , end , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> } //<S2SV> else { //<S2SV> PUNFETCH ; //<S2SV> onig_syntax_warn ( env , "invalid<S2SV_blank>back<S2SV_blank>reference" ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> # endif //<S2SV> # if defined ( USE_SUBEXP_CALL ) || defined ( USE_NAMED_GROUP ) //<S2SV> case 'g' : //<S2SV> # ifdef USE_NAMED_GROUP //<S2SV> if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_BRACE_BACKREF ) ) { //<S2SV> PFETCH ( c ) ; //<S2SV> if ( c == '{' ) { //<S2SV> r = fetch_named_backref_token ( c , tok , & p , end , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> } //<S2SV> else //<S2SV> PUNFETCH ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef USE_SUBEXP_CALL //<S2SV> if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_SUBEXP_CALL ) ) { //<S2SV> PFETCH ( c ) ; //<S2SV> if ( c == '<' || c == '\\'' ) { //<S2SV> int gnum = - 1 , rel = 0 ; //<S2SV> UChar * name_end ; //<S2SV> OnigCodePoint cnext ; //<S2SV> cnext = PPEEK ; //<S2SV> if ( cnext == '0' ) { //<S2SV> PINC ; //<S2SV> if ( PPEEK_IS ( get_name_end_code_point ( c ) ) ) { //<S2SV> PINC ; //<S2SV> name_end = p ; //<S2SV> gnum = 0 ; //<S2SV> } //<S2SV> } //<S2SV> else if ( cnext == '+' ) { //<S2SV> PINC ; //<S2SV> rel = 1 ; //<S2SV> } //<S2SV> prev = p ; //<S2SV> if ( gnum < 0 ) { //<S2SV> r = fetch_name ( ( OnigCodePoint ) c , & p , end , & name_end , env , & gnum , 1 ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> } //<S2SV> tok -> type = TK_CALL ; //<S2SV> tok -> u . call . name = prev ; //<S2SV> tok -> u . call . name_end = name_end ; //<S2SV> tok -> u . call . gnum = gnum ; //<S2SV> tok -> u . call . rel = rel ; //<S2SV> } //<S2SV> else { //<S2SV> onig_syntax_warn ( env , "invalid<S2SV_blank>subexp<S2SV_blank>call" ) ; //<S2SV> PUNFETCH ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> break ; //<S2SV> # endif //<S2SV> case 'Q' : //<S2SV> if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE ) ) { //<S2SV> tok -> type = TK_QUOTE_OPEN ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'p' : //<S2SV> case 'P' : //<S2SV> if ( PPEEK_IS ( '{' ) && //<S2SV> IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY ) ) { //<S2SV> PINC ; //<S2SV> tok -> type = TK_CHAR_PROPERTY ; //<S2SV> tok -> u . prop . not = ( c == 'P' ? 1 : 0 ) ; //<S2SV> if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT ) ) { //<S2SV> PFETCH ( c ) ; //<S2SV> if ( c == '^' ) { //<S2SV> tok -> u . prop . not = ( tok -> u . prop . not == 0 ? 1 : 0 ) ; //<S2SV> } //<S2SV> else //<S2SV> PUNFETCH ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> onig_syntax_warn ( env , "invalid<S2SV_blank>Unicode<S2SV_blank>Property<S2SV_blank>\\\\%c" , c ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'R' : //<S2SV> if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_R_LINEBREAK ) ) { //<S2SV> tok -> type = TK_LINEBREAK ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'X' : //<S2SV> if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_X_EXTENDED_GRAPHEME_CLUSTER ) ) { //<S2SV> tok -> type = TK_EXTENDED_GRAPHEME_CLUSTER ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'K' : //<S2SV> if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_K_KEEP ) ) { //<S2SV> tok -> type = TK_KEEP ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> { //<S2SV> OnigCodePoint c2 ; //<S2SV> PUNFETCH ; //<S2SV> num = fetch_escaped_value ( & p , end , env , & c2 ) ; //<S2SV> if ( num < 0 ) return num ; //<S2SV> if ( ( OnigCodePoint ) tok -> u . c != c2 ) { //<S2SV> tok -> type = TK_CODE_POINT ; //<S2SV> tok -> u . code = ( OnigCodePoint ) c2 ; //<S2SV> } //<S2SV> else { //<S2SV> p = tok -> backp + enclen ( enc , tok -> backp , end ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> tok -> u . c = c ; //<S2SV> tok -> escaped = 0 ; //<S2SV> # ifdef USE_VARIABLE_META_CHARS //<S2SV> if ( ( c != ONIG_INEFFECTIVE_META_CHAR ) && //<S2SV> IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VARIABLE_META_CHARACTERS ) ) { //<S2SV> if ( c == MC_ANYCHAR ( syn ) ) //<S2SV> goto any_char ; //<S2SV> else if ( c == MC_ANYTIME ( syn ) ) //<S2SV> goto anytime ; //<S2SV> else if ( c == MC_ZERO_OR_ONE_TIME ( syn ) ) //<S2SV> goto zero_or_one_time ; //<S2SV> else if ( c == MC_ONE_OR_MORE_TIME ( syn ) ) //<S2SV> goto one_or_more_time ; //<S2SV> else if ( c == MC_ANYCHAR_ANYTIME ( syn ) ) { //<S2SV> tok -> type = TK_ANYCHAR_ANYTIME ; //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> switch ( c ) { //<S2SV> case '.' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DOT_ANYCHAR ) ) break ; //<S2SV> # ifdef USE_VARIABLE_META_CHARS //<S2SV> any_char : //<S2SV> # endif //<S2SV> tok -> type = TK_ANYCHAR ; //<S2SV> break ; //<S2SV> case '*' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ASTERISK_ZERO_INF ) ) break ; //<S2SV> # ifdef USE_VARIABLE_META_CHARS //<S2SV> anytime : //<S2SV> # endif //<S2SV> tok -> type = TK_OP_REPEAT ; //<S2SV> tok -> u . repeat . lower = 0 ; //<S2SV> tok -> u . repeat . upper = REPEAT_INFINITE ; //<S2SV> goto greedy_check ; //<S2SV> break ; //<S2SV> case '+' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_PLUS_ONE_INF ) ) break ; //<S2SV> # ifdef USE_VARIABLE_META_CHARS //<S2SV> one_or_more_time : //<S2SV> # endif //<S2SV> tok -> type = TK_OP_REPEAT ; //<S2SV> tok -> u . repeat . lower = 1 ; //<S2SV> tok -> u . repeat . upper = REPEAT_INFINITE ; //<S2SV> goto greedy_check ; //<S2SV> break ; //<S2SV> case '?' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_ZERO_ONE ) ) break ; //<S2SV> # ifdef USE_VARIABLE_META_CHARS //<S2SV> zero_or_one_time : //<S2SV> # endif //<S2SV> tok -> type = TK_OP_REPEAT ; //<S2SV> tok -> u . repeat . lower = 0 ; //<S2SV> tok -> u . repeat . upper = 1 ; //<S2SV> goto greedy_check ; //<S2SV> break ; //<S2SV> case '{' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACE_INTERVAL ) ) break ; //<S2SV> r = fetch_range_quantifier ( & p , end , tok , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> if ( r == 0 ) goto greedy_check ; //<S2SV> else if ( r == 2 ) { //<S2SV> if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) //<S2SV> goto possessive_check ; //<S2SV> goto greedy_check ; //<S2SV> } //<S2SV> break ; //<S2SV> case '|' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VBAR_ALT ) ) break ; //<S2SV> tok -> type = TK_ALT ; //<S2SV> break ; //<S2SV> case '(' : //<S2SV> if ( PPEEK_IS ( '?' ) && //<S2SV> IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_QMARK_GROUP_EFFECT ) ) { //<S2SV> PINC ; //<S2SV> if ( PPEEK_IS ( '#' ) ) { //<S2SV> PFETCH ( c ) ; //<S2SV> while ( 1 ) { //<S2SV> if ( PEND ) return ONIGERR_END_PATTERN_IN_GROUP ; //<S2SV> PFETCH ( c ) ; //<S2SV> if ( c == MC_ESC ( syn ) ) { //<S2SV> if ( ! PEND ) PFETCH ( c ) ; //<S2SV> } //<S2SV> else { //<S2SV> if ( c == ')' ) break ; //<S2SV> } //<S2SV> } //<S2SV> goto start ; //<S2SV> } //<S2SV> # ifdef USE_PERL_SUBEXP_CALL //<S2SV> c = PPEEK ; //<S2SV> if ( ( c == '&' || c == 'R' || ONIGENC_IS_CODE_DIGIT ( enc , c ) ) && //<S2SV> IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_SUBEXP_CALL ) ) { //<S2SV> int gnum ; //<S2SV> UChar * name ; //<S2SV> UChar * name_end ; //<S2SV> if ( c == 'R' || c == '0' ) { //<S2SV> PINC ; //<S2SV> if ( ! PPEEK_IS ( ')' ) ) { //<S2SV> r = ONIGERR_INVALID_GROUP_NAME ; //<S2SV> onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; //<S2SV> return r ; //<S2SV> } //<S2SV> PINC ; //<S2SV> name_end = name = p ; //<S2SV> gnum = 0 ; //<S2SV> } //<S2SV> else { //<S2SV> int numref = 1 ; //<S2SV> if ( c == '&' ) { //<S2SV> PINC ; //<S2SV> numref = 0 ; //<S2SV> } //<S2SV> name = p ; //<S2SV> r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , numref ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> } //<S2SV> tok -> type = TK_CALL ; //<S2SV> tok -> u . call . name = name ; //<S2SV> tok -> u . call . name_end = name_end ; //<S2SV> tok -> u . call . gnum = gnum ; //<S2SV> tok -> u . call . rel = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> else if ( ( c == '-' || c == '+' ) && //<S2SV> IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_SUBEXP_CALL ) ) { //<S2SV> int gnum ; //<S2SV> UChar * name ; //<S2SV> UChar * name_end ; //<S2SV> OnigCodePoint cnext ; //<S2SV> PFETCH_READY ; //<S2SV> PINC ; //<S2SV> cnext = PPEEK ; //<S2SV> if ( ONIGENC_IS_CODE_DIGIT ( enc , cnext ) ) { //<S2SV> if ( c == '-' ) PUNFETCH ; //<S2SV> name = p ; //<S2SV> r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , 1 ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> tok -> type = TK_CALL ; //<S2SV> tok -> u . call . name = name ; //<S2SV> tok -> u . call . name_end = name_end ; //<S2SV> tok -> u . call . gnum = gnum ; //<S2SV> tok -> u . call . rel = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef USE_CAPITAL_P_NAMED_GROUP //<S2SV> if ( PPEEK_IS ( 'P' ) && //<S2SV> IS_SYNTAX_OP2 ( env -> syntax , ONIG_SYN_OP2_QMARK_CAPITAL_P_NAMED_GROUP ) ) { //<S2SV> int gnum ; //<S2SV> UChar * name ; //<S2SV> UChar * name_end ; //<S2SV> PFETCH_READY ; //<S2SV> PINC ; //<S2SV> if ( PEND ) return ONIGERR_UNDEFINED_GROUP_OPTION ; //<S2SV> PFETCH ( c ) ; //<S2SV> if ( c == '=' ) { //<S2SV> r = fetch_named_backref_token ( ( OnigCodePoint ) '(' , tok , & p , end , env ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> break ; //<S2SV> } //<S2SV> else if ( c == '>' ) { //<S2SV> name = p ; //<S2SV> r = fetch_name ( ( OnigCodePoint ) '(' , & p , end , & name_end , env , & gnum , 0 ) ; //<S2SV> if ( r < 0 ) return r ; //<S2SV> tok -> type = TK_CALL ; //<S2SV> tok -> u . call . name = name ; //<S2SV> tok -> u . call . name_end = name_end ; //<S2SV> tok -> u . call . gnum = gnum ; //<S2SV> tok -> u . call . rel = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> PUNFETCH ; //<S2SV> } //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; //<S2SV> tok -> type = TK_SUBEXP_OPEN ; //<S2SV> break ; //<S2SV> case ')' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; //<S2SV> tok -> type = TK_SUBEXP_CLOSE ; //<S2SV> break ; //<S2SV> case '^' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ( IS_SINGLELINE ( env -> option ) //<S2SV> ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE ) ; //<S2SV> break ; //<S2SV> case '$' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; //<S2SV> tok -> type = TK_ANCHOR ; //<S2SV> tok -> u . anchor . subtype = ( IS_SINGLELINE ( env -> option ) //<S2SV> ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE ) ; //<S2SV> break ; //<S2SV> case '[' : //<S2SV> if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACKET_CC ) ) break ; //<S2SV> tok -> type = TK_CC_OPEN ; //<S2SV> break ; //<S2SV> case ']' : //<S2SV> if ( * src > env -> pattern ) //<S2SV> CLOSE_BRACKET_WITHOUT_ESC_WARN ( env , ( UChar * ) "]" ) ; //<S2SV> break ; //<S2SV> case '#' : //<S2SV> if ( IS_EXTEND ( env -> option ) ) { //<S2SV> while ( ! PEND ) { //<S2SV> PFETCH ( c ) ; //<S2SV> if ( ONIGENC_IS_CODE_NEWLINE ( enc , c ) ) //<S2SV> break ; //<S2SV> } //<S2SV> goto start ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case '<S2SV_blank>' : case '\\t' : case '\\n' : case '\\r' : case '\\f' : //<S2SV> if ( IS_EXTEND ( env -> option ) ) //<S2SV> goto start ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> # ifdef USE_VARIABLE_META_CHARS //<S2SV> out : //<S2SV> # endif //<S2SV> * src = p ; //<S2SV> return tok -> type ; //<S2SV> } //<S2SV> 