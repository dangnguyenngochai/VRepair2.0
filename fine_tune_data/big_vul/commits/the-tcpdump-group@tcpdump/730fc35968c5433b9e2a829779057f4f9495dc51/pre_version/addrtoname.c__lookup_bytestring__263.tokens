static inline struct enamemem * //<S2SV> lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , //<S2SV> const unsigned int nlen ) //<S2SV> { //<S2SV> struct enamemem * tp ; //<S2SV> register u_int i , j , k ; //<S2SV> if ( nlen >= 6 ) { //<S2SV> k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; //<S2SV> j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; //<S2SV> i = ( bs [ 4 ] << 8 ) | bs [ 5 ] ; //<S2SV> } else if ( nlen >= 4 ) { //<S2SV> k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; //<S2SV> j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; //<S2SV> i = 0 ; //<S2SV> } else //<S2SV> i = j = k = 0 ; //<S2SV> tp = & bytestringtable [ ( i ^ j ) & ( HASHNAMESIZE - 1 ) ] ; //<S2SV> while ( tp -> e_nxt ) //<S2SV> if ( tp -> e_addr0 == i && //<S2SV> tp -> e_addr1 == j && //<S2SV> tp -> e_addr2 == k && //<S2SV> memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 ) //<S2SV> return tp ; //<S2SV> else //<S2SV> tp = tp -> e_nxt ; //<S2SV> tp -> e_addr0 = i ; //<S2SV> tp -> e_addr1 = j ; //<S2SV> tp -> e_addr2 = k ; //<S2SV> tp -> e_bs = ( u_char * ) calloc ( 1 , nlen + 1 ) ; //<S2SV> if ( tp -> e_bs == NULL ) //<S2SV> ( * ndo -> ndo_error ) ( ndo , "lookup_bytestring:<S2SV_blank>calloc" ) ; //<S2SV> memcpy ( tp -> e_bs , bs , nlen ) ; //<S2SV> tp -> e_nxt = ( struct enamemem * ) calloc ( 1 , sizeof ( * tp ) ) ; //<S2SV> if ( tp -> e_nxt == NULL ) //<S2SV> ( * ndo -> ndo_error ) ( ndo , "lookup_bytestring:<S2SV_blank>calloc" ) ; //<S2SV> return tp ; //<S2SV> } //<S2SV> 