void //<S2SV> vtp_print ( netdissect_options * ndo , //<S2SV> const u_char * pptr , u_int length ) //<S2SV> { //<S2SV> int type , len , tlv_len , tlv_value , mgmtd_len ; //<S2SV> const u_char * tptr ; //<S2SV> const struct vtp_vlan_ * vtp_vlan ; //<S2SV> if ( length < VTP_HEADER_LEN ) //<S2SV> goto trunc ; //<S2SV> tptr = pptr ; //<S2SV> ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; //<S2SV> type = * ( tptr + 1 ) ; //<S2SV> ND_PRINT ( ( ndo , "VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> * tptr , //<S2SV> tok2str ( vtp_message_type_values , "Unknown<S2SV_blank>message<S2SV_blank>type" , type ) , //<S2SV> type , //<S2SV> length ) ) ; //<S2SV> if ( ndo -> ndo_vflag < 1 ) { //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\tDomain<S2SV_blank>name:<S2SV_blank>" ) ) ; //<S2SV> mgmtd_len = * ( tptr + 3 ) ; //<S2SV> if ( mgmtd_len < 1 || mgmtd_len > 32 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]" , mgmtd_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>%s:<S2SV_blank>%u" , //<S2SV> tok2str ( vtp_header_values , "Unknown" , type ) , //<S2SV> * ( tptr + 2 ) ) ) ; //<S2SV> tptr += VTP_HEADER_LEN ; //<S2SV> switch ( type ) { //<S2SV> case VTP_SUMMARY_ADV : //<S2SV> ND_TCHECK2 ( * tptr , 8 ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s" , //<S2SV> EXTRACT_32BITS ( tptr ) , //<S2SV> ipaddr_string ( ndo , tptr + 4 ) ) ) ; //<S2SV> tptr += 8 ; //<S2SV> ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x" , //<S2SV> EXTRACT_32BITS ( tptr ) , //<S2SV> EXTRACT_32BITS ( tptr + 4 ) , //<S2SV> EXTRACT_32BITS ( tptr + 8 ) ) ) ; //<S2SV> tptr += VTP_UPDATE_TIMESTAMP_LEN ; //<S2SV> ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x" , //<S2SV> EXTRACT_32BITS ( tptr ) , //<S2SV> EXTRACT_32BITS ( tptr + 4 ) , //<S2SV> EXTRACT_32BITS ( tptr + 8 ) , //<S2SV> EXTRACT_32BITS ( tptr + 12 ) ) ) ; //<S2SV> tptr += VTP_MD5_DIGEST_LEN ; //<S2SV> break ; //<S2SV> case VTP_SUBSET_ADV : //<S2SV> ND_TCHECK_32BITS ( tptr ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x" , EXTRACT_32BITS ( tptr ) ) ) ; //<S2SV> tptr += 4 ; //<S2SV> while ( tptr < ( pptr + length ) ) { //<S2SV> ND_TCHECK_8BITS ( tptr ) ; //<S2SV> len = * tptr ; //<S2SV> if ( len == 0 ) //<S2SV> break ; //<S2SV> ND_TCHECK2 ( * tptr , len ) ; //<S2SV> vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; //<S2SV> if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK ( * vtp_vlan ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>" , //<S2SV> tok2str ( vtp_vlan_status , "Unknown" , vtp_vlan -> status ) , //<S2SV> tok2str ( vtp_vlan_type_values , "Unknown" , vtp_vlan -> type ) , //<S2SV> EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , //<S2SV> EXTRACT_16BITS ( & vtp_vlan -> mtu ) , //<S2SV> EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; //<S2SV> len -= VTP_VLAN_INFO_FIXED_PART_LEN ; //<S2SV> tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; //<S2SV> if ( len < 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK2 ( * tptr , vtp_vlan -> name_len ) ; //<S2SV> fn_printzp ( ndo , tptr , vtp_vlan -> name_len , NULL ) ; //<S2SV> len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; //<S2SV> tptr += 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; //<S2SV> while ( len > 0 ) { //<S2SV> if ( len < 2 ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK2 ( * tptr , 2 ) ; //<S2SV> type = * tptr ; //<S2SV> tlv_len = * ( tptr + 1 ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV" , //<S2SV> tok2str ( vtp_vlan_tlv_values , "Unknown" , type ) , //<S2SV> type ) ) ; //<S2SV> if ( len < tlv_len * 2 + 2 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; //<S2SV> if ( tlv_len != 1 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)" , tlv_len ) ) ; //<S2SV> return ; //<S2SV> } else { //<S2SV> tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; //<S2SV> switch ( type ) { //<S2SV> case VTP_VLAN_STE_HOP_COUNT : //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>%u" , tlv_value ) ) ; //<S2SV> break ; //<S2SV> case VTP_VLAN_PRUNING : //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tlv_value == 1 ? "Enabled" : "Disabled" , //<S2SV> tlv_value ) ) ; //<S2SV> break ; //<S2SV> case VTP_VLAN_STP_TYPE : //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tok2str ( vtp_stp_type_values , "Unknown" , tlv_value ) , //<S2SV> tlv_value ) ) ; //<S2SV> break ; //<S2SV> case VTP_VLAN_BRIDGE_TYPE : //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tlv_value == 1 ? "SRB" : "SRT" , //<S2SV> tlv_value ) ) ; //<S2SV> break ; //<S2SV> case VTP_VLAN_BACKUP_CRF_MODE : //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tlv_value == 1 ? "Backup" : "Not<S2SV_blank>backup" , //<S2SV> tlv_value ) ) ; //<S2SV> break ; //<S2SV> case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : //<S2SV> case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : //<S2SV> case VTP_VLAN_PARENT_VLAN : //<S2SV> case VTP_VLAN_TRANS_BRIDGED_VLAN : //<S2SV> case VTP_VLAN_ARP_HOP_COUNT : //<S2SV> default : //<S2SV> print_unknown_data ( ndo , tptr , "\\n\\t\\t<S2SV_blank><S2SV_blank>" , 2 + tlv_len * 2 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> len -= 2 + tlv_len * 2 ; //<S2SV> tptr += 2 + tlv_len * 2 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case VTP_ADV_REQUEST : //<S2SV> ND_TCHECK2 ( * tptr , 4 ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u" , EXTRACT_32BITS ( tptr ) ) ) ; //<S2SV> break ; //<S2SV> case VTP_JOIN_MESSAGE : //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "[|vtp]" ) ) ; //<S2SV> } //<S2SV> 