void //<S2SV> ip6_print ( netdissect_options * ndo , const u_char * bp , u_int length ) //<S2SV> { //<S2SV> register const struct ip6_hdr * ip6 ; //<S2SV> register int advance ; //<S2SV> u_int len ; //<S2SV> const u_char * ipend ; //<S2SV> register const u_char * cp ; //<S2SV> register u_int payload_len ; //<S2SV> int nh ; //<S2SV> int fragmented = 0 ; //<S2SV> u_int flow ; //<S2SV> ip6 = ( const struct ip6_hdr * ) bp ; //<S2SV> ND_TCHECK ( * ip6 ) ; //<S2SV> if ( length < sizeof ( struct ip6_hdr ) ) { //<S2SV> ND_PRINT ( ( ndo , "truncated-ip6<S2SV_blank>%u" , length ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! ndo -> ndo_eflag ) //<S2SV> ND_PRINT ( ( ndo , "IP6<S2SV_blank>" ) ) ; //<S2SV> if ( IP6_VERSION ( ip6 ) != 6 ) { //<S2SV> ND_PRINT ( ( ndo , "version<S2SV_blank>error:<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>6" , IP6_VERSION ( ip6 ) ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> payload_len = EXTRACT_16BITS ( & ip6 -> ip6_plen ) ; //<S2SV> len = payload_len + sizeof ( struct ip6_hdr ) ; //<S2SV> if ( length < len ) //<S2SV> ND_PRINT ( ( ndo , "truncated-ip6<S2SV_blank>-<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>missing!" , //<S2SV> len - length ) ) ; //<S2SV> if ( ndo -> ndo_vflag ) { //<S2SV> flow = EXTRACT_32BITS ( & ip6 -> ip6_flow ) ; //<S2SV> ND_PRINT ( ( ndo , "(" ) ) ; //<S2SV> # if 0 //<S2SV> if ( flow & 0x0f000000 ) //<S2SV> ND_PRINT ( ( ndo , "pri<S2SV_blank>0x%02x,<S2SV_blank>" , ( flow & 0x0f000000 ) >> 24 ) ) ; //<S2SV> if ( flow & 0x00ffffff ) //<S2SV> ND_PRINT ( ( ndo , "flowlabel<S2SV_blank>0x%06x,<S2SV_blank>" , flow & 0x00ffffff ) ) ; //<S2SV> # else //<S2SV> if ( flow & 0x0ff00000 ) //<S2SV> ND_PRINT ( ( ndo , "class<S2SV_blank>0x%02x,<S2SV_blank>" , ( flow & 0x0ff00000 ) >> 20 ) ) ; //<S2SV> if ( flow & 0x000fffff ) //<S2SV> ND_PRINT ( ( ndo , "flowlabel<S2SV_blank>0x%05x,<S2SV_blank>" , flow & 0x000fffff ) ) ; //<S2SV> # endif //<S2SV> ND_PRINT ( ( ndo , "hlim<S2SV_blank>%u,<S2SV_blank>next-header<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>payload<S2SV_blank>length:<S2SV_blank>%u)<S2SV_blank>" , //<S2SV> ip6 -> ip6_hlim , //<S2SV> tok2str ( ipproto_values , "unknown" , ip6 -> ip6_nxt ) , //<S2SV> ip6 -> ip6_nxt , //<S2SV> payload_len ) ) ; //<S2SV> } //<S2SV> ipend = bp + len ; //<S2SV> if ( ipend < ndo -> ndo_snapend ) //<S2SV> ndo -> ndo_snapend = ipend ; //<S2SV> cp = ( const u_char * ) ip6 ; //<S2SV> advance = sizeof ( struct ip6_hdr ) ; //<S2SV> nh = ip6 -> ip6_nxt ; //<S2SV> while ( cp < ndo -> ndo_snapend && advance > 0 ) { //<S2SV> cp += advance ; //<S2SV> len -= advance ; //<S2SV> if ( cp == ( const u_char * ) ( ip6 + 1 ) && //<S2SV> nh != IPPROTO_TCP && nh != IPPROTO_UDP && //<S2SV> nh != IPPROTO_DCCP && nh != IPPROTO_SCTP ) { //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , //<S2SV> ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; //<S2SV> } //<S2SV> switch ( nh ) { //<S2SV> case IPPROTO_HOPOPTS : //<S2SV> advance = hbhopt_print ( ndo , cp ) ; //<S2SV> if ( advance < 0 ) //<S2SV> return ; //<S2SV> nh = * cp ; //<S2SV> break ; //<S2SV> case IPPROTO_DSTOPTS : //<S2SV> advance = dstopt_print ( ndo , cp ) ; //<S2SV> if ( advance < 0 ) //<S2SV> return ; //<S2SV> nh = * cp ; //<S2SV> break ; //<S2SV> case IPPROTO_FRAGMENT : //<S2SV> advance = frag6_print ( ndo , cp , ( const u_char * ) ip6 ) ; //<S2SV> if ( advance < 0 || ndo -> ndo_snapend <= cp + advance ) //<S2SV> return ; //<S2SV> nh = * cp ; //<S2SV> fragmented = 1 ; //<S2SV> break ; //<S2SV> case IPPROTO_MOBILITY_OLD : //<S2SV> case IPPROTO_MOBILITY : //<S2SV> advance = mobility_print ( ndo , cp , ( const u_char * ) ip6 ) ; //<S2SV> nh = * cp ; //<S2SV> return ; //<S2SV> case IPPROTO_ROUTING : //<S2SV> advance = rt6_print ( ndo , cp , ( const u_char * ) ip6 ) ; //<S2SV> nh = * cp ; //<S2SV> break ; //<S2SV> case IPPROTO_SCTP : //<S2SV> sctp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; //<S2SV> return ; //<S2SV> case IPPROTO_DCCP : //<S2SV> dccp_print ( ndo , cp , ( const u_char * ) ip6 , len ) ; //<S2SV> return ; //<S2SV> case IPPROTO_TCP : //<S2SV> tcp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; //<S2SV> return ; //<S2SV> case IPPROTO_UDP : //<S2SV> udp_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; //<S2SV> return ; //<S2SV> case IPPROTO_ICMPV6 : //<S2SV> icmp6_print ( ndo , cp , len , ( const u_char * ) ip6 , fragmented ) ; //<S2SV> return ; //<S2SV> case IPPROTO_AH : //<S2SV> advance = ah_print ( ndo , cp ) ; //<S2SV> nh = * cp ; //<S2SV> break ; //<S2SV> case IPPROTO_ESP : //<S2SV> { //<S2SV> int enh , padlen ; //<S2SV> advance = esp_print ( ndo , cp , len , ( const u_char * ) ip6 , & enh , & padlen ) ; //<S2SV> nh = enh & 0xff ; //<S2SV> len -= padlen ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPPROTO_IPCOMP : //<S2SV> { //<S2SV> ipcomp_print ( ndo , cp ) ; //<S2SV> advance = - 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPPROTO_PIM : //<S2SV> pim_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; //<S2SV> return ; //<S2SV> case IPPROTO_OSPF : //<S2SV> ospf6_print ( ndo , cp , len ) ; //<S2SV> return ; //<S2SV> case IPPROTO_IPV6 : //<S2SV> ip6_print ( ndo , cp , len ) ; //<S2SV> return ; //<S2SV> case IPPROTO_IPV4 : //<S2SV> ip_print ( ndo , cp , len ) ; //<S2SV> return ; //<S2SV> case IPPROTO_PGM : //<S2SV> pgm_print ( ndo , cp , len , ( const u_char * ) ip6 ) ; //<S2SV> return ; //<S2SV> case IPPROTO_GRE : //<S2SV> gre_print ( ndo , cp , len ) ; //<S2SV> return ; //<S2SV> case IPPROTO_RSVP : //<S2SV> rsvp_print ( ndo , cp , len ) ; //<S2SV> return ; //<S2SV> case IPPROTO_NONE : //<S2SV> ND_PRINT ( ( ndo , "no<S2SV_blank>next<S2SV_blank>header" ) ) ; //<S2SV> return ; //<S2SV> default : //<S2SV> ND_PRINT ( ( ndo , "ip-proto-%d<S2SV_blank>%d" , nh , len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "[|ip6]" ) ) ; //<S2SV> } //<S2SV> 