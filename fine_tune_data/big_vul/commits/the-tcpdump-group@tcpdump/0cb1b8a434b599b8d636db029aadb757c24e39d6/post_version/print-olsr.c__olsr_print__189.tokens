void //<S2SV> olsr_print ( netdissect_options * ndo , //<S2SV> const u_char * pptr , u_int length , int is_ipv6 ) //<S2SV> { //<S2SV> union { //<S2SV> const struct olsr_common * common ; //<S2SV> const struct olsr_msg4 * msg4 ; //<S2SV> const struct olsr_msg6 * msg6 ; //<S2SV> const struct olsr_hello * hello ; //<S2SV> const struct olsr_hello_link * hello_link ; //<S2SV> const struct olsr_tc * tc ; //<S2SV> const struct olsr_hna4 * hna ; //<S2SV> } ptr ; //<S2SV> u_int msg_type , msg_len , msg_tlen , hello_len ; //<S2SV> uint16_t name_entry_type , name_entry_len ; //<S2SV> u_int name_entry_padding ; //<S2SV> uint8_t link_type , neighbor_type ; //<S2SV> const u_char * tptr , * msg_data ; //<S2SV> tptr = pptr ; //<S2SV> if ( length < sizeof ( struct olsr_common ) ) { //<S2SV> goto trunc ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; //<S2SV> ptr . common = ( const struct olsr_common * ) tptr ; //<S2SV> length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; //<S2SV> ND_PRINT ( ( ndo , "OLSRv%i,<S2SV_blank>seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> ( is_ipv6 == 0 ) ? 4 : 6 , //<S2SV> EXTRACT_16BITS ( ptr . common -> packet_seq ) , //<S2SV> length ) ) ; //<S2SV> tptr += sizeof ( struct olsr_common ) ; //<S2SV> if ( ndo -> ndo_vflag < 1 ) { //<S2SV> return ; //<S2SV> } //<S2SV> while ( tptr < ( pptr + length ) ) { //<S2SV> union //<S2SV> { //<S2SV> const struct olsr_msg4 * v4 ; //<S2SV> const struct olsr_msg6 * v6 ; //<S2SV> } msgptr ; //<S2SV> int msg_len_valid = 0 ; //<S2SV> if ( is_ipv6 ) //<S2SV> { //<S2SV> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg6 ) ) ; //<S2SV> msgptr . v6 = ( const struct olsr_msg6 * ) tptr ; //<S2SV> msg_type = msgptr . v6 -> msg_type ; //<S2SV> msg_len = EXTRACT_16BITS ( msgptr . v6 -> msg_len ) ; //<S2SV> if ( ( msg_len >= sizeof ( struct olsr_msg6 ) ) //<S2SV> && ( msg_len <= length ) ) //<S2SV> msg_len_valid = 1 ; //<S2SV> if ( msg_type == 0 || msg_len == 0 ) { //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u" //<S2SV> "\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s" , //<S2SV> tok2str ( olsr_msg_values , "Unknown" , msg_type ) , //<S2SV> msg_type , ip6addr_string ( ndo , msgptr . v6 -> originator ) , //<S2SV> msgptr . v6 -> ttl , //<S2SV> msgptr . v6 -> hopcount , //<S2SV> ME_TO_DOUBLE ( msgptr . v6 -> vtime ) , //<S2SV> EXTRACT_16BITS ( msgptr . v6 -> msg_seq ) , //<S2SV> msg_len , ( msg_len_valid == 0 ) ? "<S2SV_blank>(invalid)" : "" ) ) ; //<S2SV> if ( ! msg_len_valid ) { //<S2SV> return ; //<S2SV> } //<S2SV> msg_tlen = msg_len - sizeof ( struct olsr_msg6 ) ; //<S2SV> msg_data = tptr + sizeof ( struct olsr_msg6 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; //<S2SV> msgptr . v4 = ( const struct olsr_msg4 * ) tptr ; //<S2SV> msg_type = msgptr . v4 -> msg_type ; //<S2SV> msg_len = EXTRACT_16BITS ( msgptr . v4 -> msg_len ) ; //<S2SV> if ( ( msg_len >= sizeof ( struct olsr_msg4 ) ) //<S2SV> && ( msg_len <= length ) ) //<S2SV> msg_len_valid = 1 ; //<S2SV> if ( msg_type == 0 || msg_len == 0 ) { //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t%s<S2SV_blank>Message<S2SV_blank>(%#04x),<S2SV_blank>originator<S2SV_blank>%s,<S2SV_blank>ttl<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u" //<S2SV> "\\n\\t<S2SV_blank><S2SV_blank>vtime<S2SV_blank>%.3fs,<S2SV_blank>msg-seq<S2SV_blank>0x%04x,<S2SV_blank>length<S2SV_blank>%u%s" , //<S2SV> tok2str ( olsr_msg_values , "Unknown" , msg_type ) , //<S2SV> msg_type , ipaddr_string ( ndo , msgptr . v4 -> originator ) , //<S2SV> msgptr . v4 -> ttl , //<S2SV> msgptr . v4 -> hopcount , //<S2SV> ME_TO_DOUBLE ( msgptr . v4 -> vtime ) , //<S2SV> EXTRACT_16BITS ( msgptr . v4 -> msg_seq ) , //<S2SV> msg_len , ( msg_len_valid == 0 ) ? "<S2SV_blank>(invalid)" : "" ) ) ; //<S2SV> if ( ! msg_len_valid ) { //<S2SV> return ; //<S2SV> } //<S2SV> msg_tlen = msg_len - sizeof ( struct olsr_msg4 ) ; //<S2SV> msg_data = tptr + sizeof ( struct olsr_msg4 ) ; //<S2SV> } //<S2SV> switch ( msg_type ) { //<S2SV> case OLSR_HELLO_MSG : //<S2SV> case OLSR_HELLO_LQ_MSG : //<S2SV> if ( msg_tlen < sizeof ( struct olsr_hello ) ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello ) ) ; //<S2SV> ptr . hello = ( const struct olsr_hello * ) msg_data ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>hello-time<S2SV_blank>%.3fs,<S2SV_blank>MPR<S2SV_blank>willingness<S2SV_blank>%u" , //<S2SV> ME_TO_DOUBLE ( ptr . hello -> htime ) , ptr . hello -> will ) ) ; //<S2SV> msg_data += sizeof ( struct olsr_hello ) ; //<S2SV> msg_tlen -= sizeof ( struct olsr_hello ) ; //<S2SV> while ( msg_tlen >= sizeof ( struct olsr_hello_link ) ) { //<S2SV> int hello_len_valid = 0 ; //<S2SV> ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hello_link ) ) ; //<S2SV> ptr . hello_link = ( const struct olsr_hello_link * ) msg_data ; //<S2SV> hello_len = EXTRACT_16BITS ( ptr . hello_link -> len ) ; //<S2SV> link_type = OLSR_EXTRACT_LINK_TYPE ( ptr . hello_link -> link_code ) ; //<S2SV> neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE ( ptr . hello_link -> link_code ) ; //<S2SV> if ( ( hello_len <= msg_tlen ) //<S2SV> && ( hello_len >= sizeof ( struct olsr_hello_link ) ) ) //<S2SV> hello_len_valid = 1 ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>link-type<S2SV_blank>%s,<S2SV_blank>neighbor-type<S2SV_blank>%s,<S2SV_blank>len<S2SV_blank>%u%s" , //<S2SV> tok2str ( olsr_link_type_values , "Unknown" , link_type ) , //<S2SV> tok2str ( olsr_neighbor_type_values , "Unknown" , neighbor_type ) , //<S2SV> hello_len , //<S2SV> ( hello_len_valid == 0 ) ? "<S2SV_blank>(invalid)" : "" ) ) ; //<S2SV> if ( hello_len_valid == 0 ) //<S2SV> break ; //<S2SV> msg_data += sizeof ( struct olsr_hello_link ) ; //<S2SV> msg_tlen -= sizeof ( struct olsr_hello_link ) ; //<S2SV> hello_len -= sizeof ( struct olsr_hello_link ) ; //<S2SV> ND_TCHECK2 ( * msg_data , hello_len ) ; //<S2SV> if ( msg_type == OLSR_HELLO_MSG ) { //<S2SV> if ( olsr_print_neighbor ( ndo , msg_data , hello_len ) == - 1 ) //<S2SV> goto trunc ; //<S2SV> } else { //<S2SV> if ( is_ipv6 ) { //<S2SV> if ( olsr_print_lq_neighbor6 ( ndo , msg_data , hello_len ) == - 1 ) //<S2SV> goto trunc ; //<S2SV> } else { //<S2SV> if ( olsr_print_lq_neighbor4 ( ndo , msg_data , hello_len ) == - 1 ) //<S2SV> goto trunc ; //<S2SV> } //<S2SV> } //<S2SV> msg_data += hello_len ; //<S2SV> msg_tlen -= hello_len ; //<S2SV> } //<S2SV> break ; //<S2SV> case OLSR_TC_MSG : //<S2SV> case OLSR_TC_LQ_MSG : //<S2SV> if ( msg_tlen < sizeof ( struct olsr_tc ) ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_tc ) ) ; //<S2SV> ptr . tc = ( const struct olsr_tc * ) msg_data ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>advertised<S2SV_blank>neighbor<S2SV_blank>seq<S2SV_blank>0x%04x" , //<S2SV> EXTRACT_16BITS ( ptr . tc -> ans_seq ) ) ) ; //<S2SV> msg_data += sizeof ( struct olsr_tc ) ; //<S2SV> msg_tlen -= sizeof ( struct olsr_tc ) ; //<S2SV> if ( msg_type == OLSR_TC_MSG ) { //<S2SV> if ( olsr_print_neighbor ( ndo , msg_data , msg_tlen ) == - 1 ) //<S2SV> goto trunc ; //<S2SV> } else { //<S2SV> if ( is_ipv6 ) { //<S2SV> if ( olsr_print_lq_neighbor6 ( ndo , msg_data , msg_tlen ) == - 1 ) //<S2SV> goto trunc ; //<S2SV> } else { //<S2SV> if ( olsr_print_lq_neighbor4 ( ndo , msg_data , msg_tlen ) == - 1 ) //<S2SV> goto trunc ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case OLSR_MID_MSG : //<S2SV> { //<S2SV> size_t addr_size = sizeof ( struct in_addr ) ; //<S2SV> if ( is_ipv6 ) //<S2SV> addr_size = sizeof ( struct in6_addr ) ; //<S2SV> while ( msg_tlen >= addr_size ) { //<S2SV> ND_TCHECK2 ( * msg_data , addr_size ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>interface<S2SV_blank>address<S2SV_blank>%s" , //<S2SV> is_ipv6 ? ip6addr_string ( ndo , msg_data ) : //<S2SV> ipaddr_string ( ndo , msg_data ) ) ) ; //<S2SV> msg_data += addr_size ; //<S2SV> msg_tlen -= addr_size ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case OLSR_HNA_MSG : //<S2SV> if ( is_ipv6 ) //<S2SV> { //<S2SV> int i = 0 ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)" , //<S2SV> ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna6 ) ) ) ) ; //<S2SV> while ( msg_tlen >= sizeof ( struct olsr_hna6 ) ) { //<S2SV> const struct olsr_hna6 * hna6 ; //<S2SV> ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna6 ) ) ; //<S2SV> hna6 = ( const struct olsr_hna6 * ) msg_data ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%i:<S2SV_blank>%s/%u" , //<S2SV> i , ip6addr_string ( ndo , hna6 -> network ) , //<S2SV> mask62plen ( hna6 -> mask ) ) ) ; //<S2SV> msg_data += sizeof ( struct olsr_hna6 ) ; //<S2SV> msg_tlen -= sizeof ( struct olsr_hna6 ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int col = 0 ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Advertised<S2SV_blank>networks<S2SV_blank>(total<S2SV_blank>%u)" , //<S2SV> ( unsigned int ) ( msg_tlen / sizeof ( struct olsr_hna4 ) ) ) ) ; //<S2SV> while ( msg_tlen >= sizeof ( struct olsr_hna4 ) ) { //<S2SV> ND_TCHECK2 ( * msg_data , sizeof ( struct olsr_hna4 ) ) ; //<S2SV> ptr . hna = ( const struct olsr_hna4 * ) msg_data ; //<S2SV> if ( ! ptr . hna -> network [ 0 ] && ! ptr . hna -> network [ 1 ] && //<S2SV> ! ptr . hna -> network [ 2 ] && ! ptr . hna -> network [ 3 ] && //<S2SV> ! ptr . hna -> mask [ GW_HNA_PAD ] && //<S2SV> ptr . hna -> mask [ GW_HNA_FLAGS ] ) { //<S2SV> ND_PRINT ( ( ndo , "%sSmart-Gateway:%s%s%s%s%s<S2SV_blank>%u/%u" , //<S2SV> col == 0 ? "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" : ",<S2SV_blank>" , //<S2SV> ( ptr . hna -> mask [ GW_HNA_FLAGS ] & //<S2SV> GW_HNA_FLAG_LINKSPEED ) ? "<S2SV_blank>LINKSPEED" : "" , //<S2SV> ( ptr . hna -> mask [ GW_HNA_FLAGS ] & //<S2SV> GW_HNA_FLAG_IPV4 ) ? "<S2SV_blank>IPV4" : "" , //<S2SV> ( ptr . hna -> mask [ GW_HNA_FLAGS ] & //<S2SV> GW_HNA_FLAG_IPV4_NAT ) ? "<S2SV_blank>IPV4-NAT" : "" , //<S2SV> ( ptr . hna -> mask [ GW_HNA_FLAGS ] & //<S2SV> GW_HNA_FLAG_IPV6 ) ? "<S2SV_blank>IPV6" : "" , //<S2SV> ( ptr . hna -> mask [ GW_HNA_FLAGS ] & //<S2SV> GW_HNA_FLAG_IPV6PREFIX ) ? "<S2SV_blank>IPv6-PREFIX" : "" , //<S2SV> ( ptr . hna -> mask [ GW_HNA_FLAGS ] & //<S2SV> GW_HNA_FLAG_LINKSPEED ) ? //<S2SV> deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_UPLINK ] ) : 0 , //<S2SV> ( ptr . hna -> mask [ GW_HNA_FLAGS ] & //<S2SV> GW_HNA_FLAG_LINKSPEED ) ? //<S2SV> deserialize_gw_speed ( ptr . hna -> mask [ GW_HNA_DOWNLINK ] ) : 0 //<S2SV> ) ) ; //<S2SV> } else { //<S2SV> ND_PRINT ( ( ndo , "%s%s/%u" , //<S2SV> col == 0 ? "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" : ",<S2SV_blank>" , //<S2SV> ipaddr_string ( ndo , ptr . hna -> network ) , //<S2SV> mask2plen ( EXTRACT_32BITS ( ptr . hna -> mask ) ) ) ) ; //<S2SV> } //<S2SV> msg_data += sizeof ( struct olsr_hna4 ) ; //<S2SV> msg_tlen -= sizeof ( struct olsr_hna4 ) ; //<S2SV> col = ( col + 1 ) % 4 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case OLSR_NAMESERVICE_MSG : //<S2SV> { //<S2SV> u_int name_entries ; //<S2SV> u_int addr_size ; //<S2SV> int name_entries_valid ; //<S2SV> u_int i ; //<S2SV> if ( msg_tlen < 4 ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK2 ( * msg_data , 4 ) ; //<S2SV> name_entries = EXTRACT_16BITS ( msg_data + 2 ) ; //<S2SV> addr_size = 4 ; //<S2SV> if ( is_ipv6 ) //<S2SV> addr_size = 16 ; //<S2SV> name_entries_valid = 0 ; //<S2SV> if ( ( name_entries > 0 ) //<S2SV> && ( ( name_entries * ( 4 + addr_size ) ) <= msg_tlen ) ) //<S2SV> name_entries_valid = 1 ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Version<S2SV_blank>%u,<S2SV_blank>Entries<S2SV_blank>%u%s" , //<S2SV> EXTRACT_16BITS ( msg_data ) , //<S2SV> name_entries , ( name_entries_valid == 0 ) ? "<S2SV_blank>(invalid)" : "" ) ) ; //<S2SV> if ( name_entries_valid == 0 ) //<S2SV> break ; //<S2SV> msg_data += 4 ; //<S2SV> msg_tlen -= 4 ; //<S2SV> for ( i = 0 ; i < name_entries ; i ++ ) { //<S2SV> int name_entry_len_valid = 0 ; //<S2SV> if ( msg_tlen < 4 ) //<S2SV> break ; //<S2SV> ND_TCHECK2 ( * msg_data , 4 ) ; //<S2SV> name_entry_type = EXTRACT_16BITS ( msg_data ) ; //<S2SV> name_entry_len = EXTRACT_16BITS ( msg_data + 2 ) ; //<S2SV> msg_data += 4 ; //<S2SV> msg_tlen -= 4 ; //<S2SV> if ( ( name_entry_len > 0 ) && ( ( addr_size + name_entry_len ) <= msg_tlen ) ) //<S2SV> name_entry_len_valid = 1 ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>#%u:<S2SV_blank>type<S2SV_blank>%#06x,<S2SV_blank>length<S2SV_blank>%u%s" , //<S2SV> ( unsigned int ) i , name_entry_type , //<S2SV> name_entry_len , ( name_entry_len_valid == 0 ) ? "<S2SV_blank>(invalid)" : "" ) ) ; //<S2SV> if ( name_entry_len_valid == 0 ) //<S2SV> break ; //<S2SV> name_entry_padding = 0 ; //<S2SV> if ( name_entry_len % 4 != 0 ) //<S2SV> name_entry_padding = 4 - ( name_entry_len % 4 ) ; //<S2SV> if ( msg_tlen < addr_size + name_entry_len + name_entry_padding ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK2 ( * msg_data , addr_size + name_entry_len + name_entry_padding ) ; //<S2SV> if ( is_ipv6 ) //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"" , //<S2SV> ip6addr_string ( ndo , msg_data ) ) ) ; //<S2SV> else //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>address<S2SV_blank>%s,<S2SV_blank>name<S2SV_blank>\\"" , //<S2SV> ipaddr_string ( ndo , msg_data ) ) ) ; //<S2SV> ( void ) fn_printn ( ndo , msg_data + addr_size , name_entry_len , NULL ) ; //<S2SV> ND_PRINT ( ( ndo , "\\"" ) ) ; //<S2SV> msg_data += addr_size + name_entry_len + name_entry_padding ; //<S2SV> msg_tlen -= addr_size + name_entry_len + name_entry_padding ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case OLSR_POWERINFO_MSG : //<S2SV> default : //<S2SV> print_unknown_data ( ndo , msg_data , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , msg_tlen ) ; //<S2SV> break ; //<S2SV> } //<S2SV> tptr += msg_len ; //<S2SV> } //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "[|olsr]" ) ) ; //<S2SV> } //<S2SV> 