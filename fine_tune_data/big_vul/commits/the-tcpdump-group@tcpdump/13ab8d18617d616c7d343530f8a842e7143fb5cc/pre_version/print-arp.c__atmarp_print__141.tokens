static void //<S2SV> atmarp_print ( netdissect_options * ndo , //<S2SV> const u_char * bp , u_int length , u_int caplen ) //<S2SV> { //<S2SV> const struct atmarp_pkthdr * ap ; //<S2SV> u_short pro , hrd , op ; //<S2SV> ap = ( const struct atmarp_pkthdr * ) bp ; //<S2SV> ND_TCHECK ( * ap ) ; //<S2SV> hrd = ATMHRD ( ap ) ; //<S2SV> pro = ATMPRO ( ap ) ; //<S2SV> op = ATMOP ( ap ) ; //<S2SV> if ( ! ND_TTEST2 ( * aar_tpa ( ap ) , ATMTPROTO_LEN ( ap ) ) ) { //<S2SV> ND_PRINT ( ( ndo , "%s" , tstr ) ) ; //<S2SV> ND_DEFAULTPRINT ( ( const u_char * ) ap , length ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! ndo -> ndo_eflag ) { //<S2SV> ND_PRINT ( ( ndo , "ARP,<S2SV_blank>" ) ) ; //<S2SV> } //<S2SV> if ( ( pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL ) || //<S2SV> ATMSPROTO_LEN ( ap ) != 4 || //<S2SV> ATMTPROTO_LEN ( ap ) != 4 || //<S2SV> ndo -> ndo_vflag ) { //<S2SV> ND_PRINT ( ( ndo , "%s,<S2SV_blank>%s<S2SV_blank>(len<S2SV_blank>%u/%u)" , //<S2SV> tok2str ( arphrd_values , "Unknown<S2SV_blank>Hardware<S2SV_blank>(%u)" , hrd ) , //<S2SV> tok2str ( ethertype_values , "Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)" , pro ) , //<S2SV> ATMSPROTO_LEN ( ap ) , //<S2SV> ATMTPROTO_LEN ( ap ) ) ) ; //<S2SV> if ( ! ndo -> ndo_vflag ) { //<S2SV> goto out ; //<S2SV> } //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "%s%s<S2SV_blank>" , //<S2SV> ndo -> ndo_vflag ? ",<S2SV_blank>" : "" , //<S2SV> tok2str ( arpop_values , "Unknown<S2SV_blank>(%u)" , op ) ) ) ; //<S2SV> switch ( op ) { //<S2SV> case ARPOP_REQUEST : //<S2SV> ND_PRINT ( ( ndo , "who-has<S2SV_blank>%s" , ipaddr_string ( ndo , ATMTPA ( ap ) ) ) ) ; //<S2SV> if ( ATMTHRD_LEN ( ap ) != 0 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(" ) ) ; //<S2SV> atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , //<S2SV> ATMTSA ( ap ) , ATMTSLN ( ap ) ) ; //<S2SV> ND_PRINT ( ( ndo , ")" ) ) ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "tell<S2SV_blank>%s" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; //<S2SV> break ; //<S2SV> case ARPOP_REPLY : //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>is-at<S2SV_blank>" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; //<S2SV> atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , //<S2SV> ATMSSLN ( ap ) ) ; //<S2SV> break ; //<S2SV> case ARPOP_INVREQUEST : //<S2SV> ND_PRINT ( ( ndo , "who-is<S2SV_blank>" ) ) ; //<S2SV> atmarp_addr_print ( ndo , ATMTHA ( ap ) , ATMTHRD_LEN ( ap ) , ATMTSA ( ap ) , //<S2SV> ATMTSLN ( ap ) ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; //<S2SV> atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , //<S2SV> ATMSSLN ( ap ) ) ; //<S2SV> break ; //<S2SV> case ARPOP_INVREPLY : //<S2SV> atmarp_addr_print ( ndo , ATMSHA ( ap ) , ATMSHRD_LEN ( ap ) , ATMSSA ( ap ) , //<S2SV> ATMSSLN ( ap ) ) ; //<S2SV> ND_PRINT ( ( ndo , "at<S2SV_blank>%s" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; //<S2SV> break ; //<S2SV> case ARPOP_NAK : //<S2SV> ND_PRINT ( ( ndo , "for<S2SV_blank>%s" , ipaddr_string ( ndo , ATMSPA ( ap ) ) ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ND_DEFAULTPRINT ( ( const u_char * ) ap , caplen ) ; //<S2SV> return ; //<S2SV> } //<S2SV> out : //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "%s" , tstr ) ) ; //<S2SV> } //<S2SV> 