u_int //<S2SV> mfr_print ( netdissect_options * ndo , //<S2SV> register const u_char * p , u_int length ) //<S2SV> { //<S2SV> u_int tlen , idx , hdr_len = 0 ; //<S2SV> uint16_t sequence_num ; //<S2SV> uint8_t ie_type , ie_len ; //<S2SV> const uint8_t * tptr ; //<S2SV> ND_TCHECK2 ( * p , 4 ) ; //<S2SV> if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_CTRL_FRAME && p [ 1 ] == 0 ) { //<S2SV> ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Control,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) , //<S2SV> tok2str ( mfr_ctrl_msg_values , "Unknown<S2SV_blank>Message<S2SV_blank>(0x%02x)" , p [ 2 ] ) , //<S2SV> length ) ) ; //<S2SV> tptr = p + 3 ; //<S2SV> tlen = length - 3 ; //<S2SV> hdr_len = 3 ; //<S2SV> if ( ! ndo -> ndo_vflag ) //<S2SV> return hdr_len ; //<S2SV> while ( tlen > sizeof ( struct ie_tlv_header_t ) ) { //<S2SV> ND_TCHECK2 ( * tptr , sizeof ( struct ie_tlv_header_t ) ) ; //<S2SV> ie_type = tptr [ 0 ] ; //<S2SV> ie_len = tptr [ 1 ] ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\tIE<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>" , //<S2SV> tok2str ( mfr_ctrl_ie_values , "Unknown" , ie_type ) , //<S2SV> ie_type , //<S2SV> ie_len ) ) ; //<S2SV> if ( ie_type == 0 || ie_len <= sizeof ( struct ie_tlv_header_t ) ) //<S2SV> return hdr_len ; //<S2SV> ND_TCHECK2 ( * tptr , ie_len ) ; //<S2SV> tptr += sizeof ( struct ie_tlv_header_t ) ; //<S2SV> ie_len -= sizeof ( struct ie_tlv_header_t ) ; //<S2SV> tlen -= sizeof ( struct ie_tlv_header_t ) ; //<S2SV> switch ( ie_type ) { //<S2SV> case MFR_CTRL_IE_MAGIC_NUM : //<S2SV> if ( ie_len != 4 ) { //<S2SV> ND_PRINT ( ( ndo , "(invalid<S2SV_blank>length)" ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "0x%08x" , EXTRACT_32BITS ( tptr ) ) ) ; //<S2SV> break ; //<S2SV> case MFR_CTRL_IE_BUNDLE_ID : //<S2SV> case MFR_CTRL_IE_LINK_ID : //<S2SV> for ( idx = 0 ; idx < ie_len && idx < MFR_ID_STRING_MAXLEN ; idx ++ ) { //<S2SV> if ( * ( tptr + idx ) != 0 ) //<S2SV> safeputchar ( ndo , * ( tptr + idx ) ) ; //<S2SV> else //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case MFR_CTRL_IE_TIMESTAMP : //<S2SV> if ( ie_len == sizeof ( struct timeval ) ) { //<S2SV> ts_print ( ndo , ( const struct timeval * ) tptr ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case MFR_CTRL_IE_VENDOR_EXT : //<S2SV> case MFR_CTRL_IE_CAUSE : //<S2SV> default : //<S2SV> if ( ndo -> ndo_vflag <= 1 ) //<S2SV> print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , ie_len ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ndo -> ndo_vflag > 1 ) //<S2SV> print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , ie_len ) ; //<S2SV> tlen -= ie_len ; //<S2SV> tptr += ie_len ; //<S2SV> } //<S2SV> return hdr_len ; //<S2SV> } //<S2SV> sequence_num = ( p [ 0 ] & 0x1e ) << 7 | p [ 1 ] ; //<S2SV> if ( ( p [ 0 ] & MFR_BEC_MASK ) == MFR_FRAG_FRAME || //<S2SV> ( p [ 0 ] & MFR_BEC_MASK ) == MFR_B_BIT ) { //<S2SV> ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>" , //<S2SV> sequence_num , //<S2SV> bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; //<S2SV> hdr_len = 2 ; //<S2SV> fr_print ( ndo , p + hdr_len , length - hdr_len ) ; //<S2SV> return hdr_len ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "FRF.16<S2SV_blank>Frag,<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]" , //<S2SV> sequence_num , //<S2SV> bittok2str ( frf_flag_values , "none" , ( p [ 0 ] & MFR_BEC_MASK ) ) ) ) ; //<S2SV> print_unknown_data ( ndo , p , "\\n\\t" , length ) ; //<S2SV> return hdr_len ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "[|mfr]" ) ) ; //<S2SV> return length ; //<S2SV> } //<S2SV> 