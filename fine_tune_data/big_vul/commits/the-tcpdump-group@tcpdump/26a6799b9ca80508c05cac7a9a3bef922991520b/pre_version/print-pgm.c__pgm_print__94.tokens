void //<S2SV> pgm_print ( netdissect_options * ndo , //<S2SV> register const u_char * bp , register u_int length , //<S2SV> register const u_char * bp2 ) //<S2SV> { //<S2SV> register const struct pgm_header * pgm ; //<S2SV> register const struct ip * ip ; //<S2SV> register char ch ; //<S2SV> uint16_t sport , dport ; //<S2SV> u_int nla_afnum ; //<S2SV> char nla_buf [ INET6_ADDRSTRLEN ] ; //<S2SV> register const struct ip6_hdr * ip6 ; //<S2SV> uint8_t opt_type , opt_len ; //<S2SV> uint32_t seq , opts_len , len , offset ; //<S2SV> pgm = ( const struct pgm_header * ) bp ; //<S2SV> ip = ( const struct ip * ) bp2 ; //<S2SV> if ( IP_V ( ip ) == 6 ) //<S2SV> ip6 = ( const struct ip6_hdr * ) bp2 ; //<S2SV> else //<S2SV> ip6 = NULL ; //<S2SV> ch = '\\0' ; //<S2SV> if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { //<S2SV> if ( ip6 ) { //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]" , //<S2SV> ip6addr_string ( ndo , & ip6 -> ip6_src ) , //<S2SV> ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; //<S2SV> return ; //<S2SV> } else { //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]" , //<S2SV> ipaddr_string ( ndo , & ip -> ip_src ) , //<S2SV> ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; //<S2SV> dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; //<S2SV> if ( ip6 ) { //<S2SV> if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { //<S2SV> ND_PRINT ( ( ndo , "%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>" , //<S2SV> ip6addr_string ( ndo , & ip6 -> ip6_src ) , //<S2SV> tcpport_string ( ndo , sport ) , //<S2SV> ip6addr_string ( ndo , & ip6 -> ip6_dst ) , //<S2SV> tcpport_string ( ndo , dport ) ) ) ; //<S2SV> } else { //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>" , //<S2SV> tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( ip -> ip_p == IPPROTO_PGM ) { //<S2SV> ND_PRINT ( ( ndo , "%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>" , //<S2SV> ipaddr_string ( ndo , & ip -> ip_src ) , //<S2SV> tcpport_string ( ndo , sport ) , //<S2SV> ipaddr_string ( ndo , & ip -> ip_dst ) , //<S2SV> tcpport_string ( ndo , dport ) ) ) ; //<S2SV> } else { //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>" , //<S2SV> tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; //<S2SV> } //<S2SV> } //<S2SV> ND_TCHECK ( * pgm ) ; //<S2SV> ND_PRINT ( ( ndo , "PGM,<S2SV_blank>length<S2SV_blank>%u" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; //<S2SV> if ( ! ndo -> ndo_vflag ) //<S2SV> return ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>0x%02x%02x%02x%02x%02x%02x<S2SV_blank>" , //<S2SV> pgm -> pgm_gsid [ 0 ] , //<S2SV> pgm -> pgm_gsid [ 1 ] , //<S2SV> pgm -> pgm_gsid [ 2 ] , //<S2SV> pgm -> pgm_gsid [ 3 ] , //<S2SV> pgm -> pgm_gsid [ 4 ] , //<S2SV> pgm -> pgm_gsid [ 5 ] ) ) ; //<S2SV> switch ( pgm -> pgm_type ) { //<S2SV> case PGM_SPM : { //<S2SV> const struct pgm_spm * spm ; //<S2SV> spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; //<S2SV> ND_TCHECK ( * spm ) ; //<S2SV> bp = ( const u_char * ) ( spm + 1 ) ; //<S2SV> switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { //<S2SV> case AFNUM_INET : //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; //<S2SV> addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in_addr ) ; //<S2SV> break ; //<S2SV> case AFNUM_INET6 : //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; //<S2SV> addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in6_addr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto trunc ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "SPM<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>lead<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s" , //<S2SV> EXTRACT_32BITS ( & spm -> pgms_seq ) , //<S2SV> EXTRACT_32BITS ( & spm -> pgms_trailseq ) , //<S2SV> EXTRACT_32BITS ( & spm -> pgms_leadseq ) , //<S2SV> nla_buf ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PGM_POLL : { //<S2SV> const struct pgm_poll * poll_msg ; //<S2SV> poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; //<S2SV> ND_TCHECK ( * poll_msg ) ; //<S2SV> ND_PRINT ( ( ndo , "POLL<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u" , //<S2SV> EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , //<S2SV> EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; //<S2SV> bp = ( const u_char * ) ( poll_msg + 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PGM_POLR : { //<S2SV> const struct pgm_polr * polr ; //<S2SV> uint32_t ivl , rnd , mask ; //<S2SV> polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; //<S2SV> ND_TCHECK ( * polr ) ; //<S2SV> bp = ( const u_char * ) ( polr + 1 ) ; //<S2SV> switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { //<S2SV> case AFNUM_INET : //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; //<S2SV> addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in_addr ) ; //<S2SV> break ; //<S2SV> case AFNUM_INET6 : //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; //<S2SV> addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in6_addr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto trunc ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; //<S2SV> ivl = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; //<S2SV> rnd = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; //<S2SV> mask = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "POLR<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>rnd<S2SV_blank>0x%08x<S2SV_blank>" //<S2SV> "mask<S2SV_blank>0x%08x" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , //<S2SV> EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PGM_ODATA : { //<S2SV> const struct pgm_data * odata ; //<S2SV> odata = ( const struct pgm_data * ) ( pgm + 1 ) ; //<S2SV> ND_TCHECK ( * odata ) ; //<S2SV> ND_PRINT ( ( ndo , "ODATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u" , //<S2SV> EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , //<S2SV> EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; //<S2SV> bp = ( const u_char * ) ( odata + 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PGM_RDATA : { //<S2SV> const struct pgm_data * rdata ; //<S2SV> rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; //<S2SV> ND_TCHECK ( * rdata ) ; //<S2SV> ND_PRINT ( ( ndo , "RDATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u" , //<S2SV> EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , //<S2SV> EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; //<S2SV> bp = ( const u_char * ) ( rdata + 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PGM_NAK : //<S2SV> case PGM_NULLNAK : //<S2SV> case PGM_NCF : { //<S2SV> const struct pgm_nak * nak ; //<S2SV> char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; //<S2SV> nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; //<S2SV> ND_TCHECK ( * nak ) ; //<S2SV> bp = ( const u_char * ) ( nak + 1 ) ; //<S2SV> switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { //<S2SV> case AFNUM_INET : //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; //<S2SV> addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; //<S2SV> bp += sizeof ( struct in_addr ) ; //<S2SV> break ; //<S2SV> case AFNUM_INET6 : //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; //<S2SV> addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; //<S2SV> bp += sizeof ( struct in6_addr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto trunc ; //<S2SV> break ; //<S2SV> } //<S2SV> bp += ( 2 * sizeof ( uint16_t ) ) ; //<S2SV> switch ( EXTRACT_16BITS ( bp ) ) { //<S2SV> case AFNUM_INET : //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; //<S2SV> addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; //<S2SV> bp += sizeof ( struct in_addr ) ; //<S2SV> break ; //<S2SV> case AFNUM_INET6 : //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; //<S2SV> addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; //<S2SV> bp += sizeof ( struct in6_addr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto trunc ; //<S2SV> break ; //<S2SV> } //<S2SV> switch ( pgm -> pgm_type ) { //<S2SV> case PGM_NAK : //<S2SV> ND_PRINT ( ( ndo , "NAK<S2SV_blank>" ) ) ; //<S2SV> break ; //<S2SV> case PGM_NULLNAK : //<S2SV> ND_PRINT ( ( ndo , "NNAK<S2SV_blank>" ) ) ; //<S2SV> break ; //<S2SV> case PGM_NCF : //<S2SV> ND_PRINT ( ( ndo , "NCF<S2SV_blank>" ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "(%s<S2SV_blank>-><S2SV_blank>%s),<S2SV_blank>seq<S2SV_blank>%u" , //<S2SV> source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PGM_ACK : { //<S2SV> const struct pgm_ack * ack ; //<S2SV> ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; //<S2SV> ND_TCHECK ( * ack ) ; //<S2SV> ND_PRINT ( ( ndo , "ACK<S2SV_blank>seq<S2SV_blank>%u" , //<S2SV> EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; //<S2SV> bp = ( const u_char * ) ( ack + 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case PGM_SPMR : //<S2SV> ND_PRINT ( ( ndo , "SPMR" ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ND_PRINT ( ( ndo , "UNKNOWN<S2SV_blank>type<S2SV_blank>0x%02x" , pgm -> pgm_type ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { //<S2SV> if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { //<S2SV> ND_PRINT ( ( ndo , "[|OPT]" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> opt_type = * bp ++ ; //<S2SV> if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { //<S2SV> ND_PRINT ( ( ndo , "[First<S2SV_blank>option<S2SV_blank>bad,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>PGM_OPT_LENGTH,<S2SV_blank>is<S2SV_blank>%u]" , opt_type & PGM_OPT_MASK ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> opt_len = * bp ++ ; //<S2SV> if ( opt_len != 4 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> opts_len = EXTRACT_16BITS ( bp ) ; //<S2SV> if ( opts_len < 4 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>4]" , opts_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += sizeof ( uint16_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>%d" , opts_len ) ) ; //<S2SV> opts_len -= 4 ; //<S2SV> while ( opts_len ) { //<S2SV> if ( opts_len < PGM_MIN_OPT_LEN ) { //<S2SV> ND_PRINT ( ( ndo , "[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> opt_type = * bp ++ ; //<S2SV> opt_len = * bp ++ ; //<S2SV> if ( opt_len < PGM_MIN_OPT_LEN ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]" , opt_len , //<S2SV> PGM_MIN_OPT_LEN ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( opts_len < opt_len ) { //<S2SV> ND_PRINT ( ( ndo , "[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>[|OPT]" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> switch ( opt_type & PGM_OPT_MASK ) { //<S2SV> case PGM_OPT_LENGTH : //<S2SV> if ( opt_len != 4 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d" , EXTRACT_16BITS ( bp ) ) ) ; //<S2SV> bp += sizeof ( uint16_t ) ; //<S2SV> opts_len -= 4 ; //<S2SV> break ; //<S2SV> case PGM_OPT_FRAGMENT : //<S2SV> if ( opt_len != 16 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>16]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> seq = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> offset = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> len = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u" , seq , offset , len ) ) ; //<S2SV> opts_len -= 16 ; //<S2SV> break ; //<S2SV> case PGM_OPT_NAK_LIST : //<S2SV> bp += 2 ; //<S2SV> opt_len -= sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>NAK<S2SV_blank>LIST" ) ) ; //<S2SV> while ( opt_len ) { //<S2SV> if ( opt_len < sizeof ( uint32_t ) ) { //<S2SV> ND_PRINT ( ( ndo , "[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( bp ) ) ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> opt_len -= sizeof ( uint32_t ) ; //<S2SV> opts_len -= sizeof ( uint32_t ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PGM_OPT_JOIN : //<S2SV> if ( opt_len != 8 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> seq = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>JOIN<S2SV_blank>%u" , seq ) ) ; //<S2SV> opts_len -= 8 ; //<S2SV> break ; //<S2SV> case PGM_OPT_NAK_BO_IVL : //<S2SV> if ( opt_len != 12 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> offset = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> seq = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u" , offset , seq ) ) ; //<S2SV> opts_len -= 12 ; //<S2SV> break ; //<S2SV> case PGM_OPT_NAK_BO_RNG : //<S2SV> if ( opt_len != 12 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> offset = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> seq = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u" , offset , seq ) ) ; //<S2SV> opts_len -= 12 ; //<S2SV> break ; //<S2SV> case PGM_OPT_REDIRECT : //<S2SV> bp += 2 ; //<S2SV> nla_afnum = EXTRACT_16BITS ( bp ) ; //<S2SV> bp += ( 2 * sizeof ( uint16_t ) ) ; //<S2SV> switch ( nla_afnum ) { //<S2SV> case AFNUM_INET : //<S2SV> if ( opt_len != 4 + sizeof ( struct in_addr ) ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; //<S2SV> addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in_addr ) ; //<S2SV> opts_len -= 4 + sizeof ( struct in_addr ) ; //<S2SV> break ; //<S2SV> case AFNUM_INET6 : //<S2SV> if ( opt_len != 4 + sizeof ( struct in6_addr ) ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; //<S2SV> addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in6_addr ) ; //<S2SV> opts_len -= 4 + sizeof ( struct in6_addr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto trunc ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>REDIRECT<S2SV_blank>%s" , nla_buf ) ) ; //<S2SV> break ; //<S2SV> case PGM_OPT_PARITY_PRM : //<S2SV> if ( opt_len != 8 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> len = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u" , len ) ) ; //<S2SV> opts_len -= 8 ; //<S2SV> break ; //<S2SV> case PGM_OPT_PARITY_GRP : //<S2SV> if ( opt_len != 8 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> seq = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u" , seq ) ) ; //<S2SV> opts_len -= 8 ; //<S2SV> break ; //<S2SV> case PGM_OPT_CURR_TGSIZE : //<S2SV> if ( opt_len != 8 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>8]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> len = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u" , len ) ) ; //<S2SV> opts_len -= 8 ; //<S2SV> break ; //<S2SV> case PGM_OPT_NBR_UNREACH : //<S2SV> if ( opt_len != 4 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>NBR_UNREACH" ) ) ; //<S2SV> opts_len -= 4 ; //<S2SV> break ; //<S2SV> case PGM_OPT_PATH_NLA : //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>PATH_NLA<S2SV_blank>[%d]" , opt_len ) ) ; //<S2SV> bp += opt_len ; //<S2SV> opts_len -= opt_len ; //<S2SV> break ; //<S2SV> case PGM_OPT_SYN : //<S2SV> if ( opt_len != 4 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>SYN" ) ) ; //<S2SV> opts_len -= 4 ; //<S2SV> break ; //<S2SV> case PGM_OPT_FIN : //<S2SV> if ( opt_len != 4 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>FIN" ) ) ; //<S2SV> opts_len -= 4 ; //<S2SV> break ; //<S2SV> case PGM_OPT_RST : //<S2SV> if ( opt_len != 4 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>RST" ) ) ; //<S2SV> opts_len -= 4 ; //<S2SV> break ; //<S2SV> case PGM_OPT_CR : //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>CR" ) ) ; //<S2SV> bp += opt_len ; //<S2SV> opts_len -= opt_len ; //<S2SV> break ; //<S2SV> case PGM_OPT_CRQST : //<S2SV> if ( opt_len != 4 ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> bp += 2 ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>CRQST" ) ) ; //<S2SV> opts_len -= 4 ; //<S2SV> break ; //<S2SV> case PGM_OPT_PGMCC_DATA : //<S2SV> bp += 2 ; //<S2SV> offset = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> nla_afnum = EXTRACT_16BITS ( bp ) ; //<S2SV> bp += ( 2 * sizeof ( uint16_t ) ) ; //<S2SV> switch ( nla_afnum ) { //<S2SV> case AFNUM_INET : //<S2SV> if ( opt_len != 12 + sizeof ( struct in_addr ) ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; //<S2SV> addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in_addr ) ; //<S2SV> opts_len -= 12 + sizeof ( struct in_addr ) ; //<S2SV> break ; //<S2SV> case AFNUM_INET6 : //<S2SV> if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; //<S2SV> addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in6_addr ) ; //<S2SV> opts_len -= 12 + sizeof ( struct in6_addr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto trunc ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s" , offset , nla_buf ) ) ; //<S2SV> break ; //<S2SV> case PGM_OPT_PGMCC_FEEDBACK : //<S2SV> bp += 2 ; //<S2SV> offset = EXTRACT_32BITS ( bp ) ; //<S2SV> bp += sizeof ( uint32_t ) ; //<S2SV> nla_afnum = EXTRACT_16BITS ( bp ) ; //<S2SV> bp += ( 2 * sizeof ( uint16_t ) ) ; //<S2SV> switch ( nla_afnum ) { //<S2SV> case AFNUM_INET : //<S2SV> if ( opt_len != 12 + sizeof ( struct in_addr ) ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; //<S2SV> addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in_addr ) ; //<S2SV> opts_len -= 12 + sizeof ( struct in_addr ) ; //<S2SV> break ; //<S2SV> case AFNUM_INET6 : //<S2SV> if ( opt_len != 12 + sizeof ( struct in6_addr ) ) { //<S2SV> ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; //<S2SV> addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; //<S2SV> bp += sizeof ( struct in6_addr ) ; //<S2SV> opts_len -= 12 + sizeof ( struct in6_addr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> goto trunc ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s" , offset , nla_buf ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>OPT_%02X<S2SV_blank>[%d]<S2SV_blank>" , opt_type , opt_len ) ) ; //<S2SV> bp += opt_len ; //<S2SV> opts_len -= opt_len ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( opt_type & PGM_OPT_END ) //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>[%u]" , length ) ) ; //<S2SV> if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && //<S2SV> ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) //<S2SV> zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "[|pgm]" ) ) ; //<S2SV> if ( ch != '\\0' ) //<S2SV> ND_PRINT ( ( ndo , ">" ) ) ; //<S2SV> } //<S2SV> 