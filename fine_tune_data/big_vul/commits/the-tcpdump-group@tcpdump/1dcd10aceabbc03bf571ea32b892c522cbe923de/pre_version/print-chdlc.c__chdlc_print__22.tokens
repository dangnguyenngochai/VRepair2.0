u_int //<S2SV> chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) //<S2SV> { //<S2SV> u_int proto ; //<S2SV> const u_char * bp = p ; //<S2SV> if ( length < CHDLC_HDRLEN ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; //<S2SV> proto = EXTRACT_16BITS ( & p [ 2 ] ) ; //<S2SV> if ( ndo -> ndo_eflag ) { //<S2SV> ND_PRINT ( ( ndo , "%s,<S2SV_blank>ethertype<S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>length<S2SV_blank>%u:<S2SV_blank>" , //<S2SV> tok2str ( chdlc_cast_values , "0x%02x" , p [ 0 ] ) , //<S2SV> tok2str ( ethertype_values , "Unknown" , proto ) , //<S2SV> proto , //<S2SV> length ) ) ; //<S2SV> } //<S2SV> length -= CHDLC_HDRLEN ; //<S2SV> p += CHDLC_HDRLEN ; //<S2SV> switch ( proto ) { //<S2SV> case ETHERTYPE_IP : //<S2SV> ip_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case ETHERTYPE_IPV6 : //<S2SV> ip6_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case CHDLC_TYPE_SLARP : //<S2SV> chdlc_slarp_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> # if 0 //<S2SV> case CHDLC_TYPE_CDP : //<S2SV> chdlc_cdp_print ( p , length ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case ETHERTYPE_MPLS : //<S2SV> case ETHERTYPE_MPLS_MULTI : //<S2SV> mpls_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case ETHERTYPE_ISO : //<S2SV> if ( length < 2 ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK_16BITS ( p ) ; //<S2SV> if ( * ( p + 1 ) == 0x81 || //<S2SV> * ( p + 1 ) == 0x82 || //<S2SV> * ( p + 1 ) == 0x83 ) //<S2SV> isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; //<S2SV> else //<S2SV> isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> if ( ! ndo -> ndo_eflag ) //<S2SV> ND_PRINT ( ( ndo , "unknown<S2SV_blank>CHDLC<S2SV_blank>protocol<S2SV_blank>(0x%04x)" , proto ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> return ( CHDLC_HDRLEN ) ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "[|chdlc]" ) ) ; //<S2SV> return ndo -> ndo_snapend - bp ; //<S2SV> } //<S2SV> 