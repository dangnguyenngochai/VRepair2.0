static void //<S2SV> handle_ppp ( netdissect_options * ndo , //<S2SV> u_int proto , const u_char * p , int length ) //<S2SV> { //<S2SV> if ( ( proto & 0xff00 ) == 0x7e00 ) { //<S2SV> ppp_hdlc ( ndo , p - 1 , length ) ; //<S2SV> return ; //<S2SV> } //<S2SV> switch ( proto ) { //<S2SV> case PPP_LCP : //<S2SV> case PPP_IPCP : //<S2SV> case PPP_OSICP : //<S2SV> case PPP_MPLSCP : //<S2SV> case PPP_IPV6CP : //<S2SV> case PPP_CCP : //<S2SV> case PPP_BACP : //<S2SV> handle_ctrl_proto ( ndo , proto , p , length ) ; //<S2SV> break ; //<S2SV> case PPP_ML : //<S2SV> handle_mlppp ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case PPP_CHAP : //<S2SV> handle_chap ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case PPP_PAP : //<S2SV> handle_pap ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case PPP_BAP : //<S2SV> handle_bap ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case ETHERTYPE_IP : //<S2SV> case PPP_VJNC : //<S2SV> case PPP_IP : //<S2SV> ip_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case ETHERTYPE_IPV6 : //<S2SV> case PPP_IPV6 : //<S2SV> ip6_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case ETHERTYPE_IPX : //<S2SV> case PPP_IPX : //<S2SV> ipx_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case PPP_OSI : //<S2SV> isoclns_print ( ndo , p , length , length ) ; //<S2SV> break ; //<S2SV> case PPP_MPLS_UCAST : //<S2SV> case PPP_MPLS_MCAST : //<S2SV> mpls_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case PPP_COMP : //<S2SV> ND_PRINT ( ( ndo , "compressed<S2SV_blank>PPP<S2SV_blank>data" ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>" , tok2str ( ppptype2str , "unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)" , proto ) ) ) ; //<S2SV> print_unknown_data ( ndo , p , "\\n\\t" , length ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> 