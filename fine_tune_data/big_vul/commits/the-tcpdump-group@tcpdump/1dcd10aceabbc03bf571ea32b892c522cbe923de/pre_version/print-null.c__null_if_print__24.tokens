u_int //<S2SV> null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) //<S2SV> { //<S2SV> u_int length = h -> len ; //<S2SV> u_int caplen = h -> caplen ; //<S2SV> u_int family ; //<S2SV> if ( caplen < NULL_HDRLEN ) { //<S2SV> ND_PRINT ( ( ndo , "[|null]" ) ) ; //<S2SV> return ( NULL_HDRLEN ) ; //<S2SV> } //<S2SV> memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; //<S2SV> if ( ( family & 0xFFFF0000 ) != 0 ) //<S2SV> family = SWAPLONG ( family ) ; //<S2SV> if ( ndo -> ndo_eflag ) //<S2SV> null_hdr_print ( ndo , family , length ) ; //<S2SV> length -= NULL_HDRLEN ; //<S2SV> caplen -= NULL_HDRLEN ; //<S2SV> p += NULL_HDRLEN ; //<S2SV> switch ( family ) { //<S2SV> case BSD_AFNUM_INET : //<S2SV> ip_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case BSD_AFNUM_INET6_BSD : //<S2SV> case BSD_AFNUM_INET6_FREEBSD : //<S2SV> case BSD_AFNUM_INET6_DARWIN : //<S2SV> ip6_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case BSD_AFNUM_ISO : //<S2SV> isoclns_print ( ndo , p , length , caplen ) ; //<S2SV> break ; //<S2SV> case BSD_AFNUM_APPLETALK : //<S2SV> atalk_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case BSD_AFNUM_IPX : //<S2SV> ipx_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> if ( ! ndo -> ndo_eflag ) //<S2SV> null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; //<S2SV> if ( ! ndo -> ndo_suppress_default_print ) //<S2SV> ND_DEFAULTPRINT ( p , caplen ) ; //<S2SV> } //<S2SV> return ( NULL_HDRLEN ) ; //<S2SV> } //<S2SV> 