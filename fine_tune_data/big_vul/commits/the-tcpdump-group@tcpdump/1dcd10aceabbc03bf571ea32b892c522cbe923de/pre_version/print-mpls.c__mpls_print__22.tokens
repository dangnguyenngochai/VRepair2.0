void //<S2SV> mpls_print ( netdissect_options * ndo , const u_char * bp , u_int length ) //<S2SV> { //<S2SV> const u_char * p ; //<S2SV> uint32_t label_entry ; //<S2SV> uint16_t label_stack_depth = 0 ; //<S2SV> enum mpls_packet_type pt = PT_UNKNOWN ; //<S2SV> p = bp ; //<S2SV> ND_PRINT ( ( ndo , "MPLS" ) ) ; //<S2SV> do { //<S2SV> ND_TCHECK2 ( * p , sizeof ( label_entry ) ) ; //<S2SV> if ( length < sizeof ( label_entry ) ) { //<S2SV> ND_PRINT ( ( ndo , "[|MPLS],<S2SV_blank>length<S2SV_blank>%u" , length ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> label_entry = EXTRACT_32BITS ( p ) ; //<S2SV> ND_PRINT ( ( ndo , "%s(label<S2SV_blank>%u" , //<S2SV> ( label_stack_depth && ndo -> ndo_vflag ) ? "\\n\\t" : "<S2SV_blank>" , //<S2SV> MPLS_LABEL ( label_entry ) ) ) ; //<S2SV> label_stack_depth ++ ; //<S2SV> if ( ndo -> ndo_vflag && //<S2SV> MPLS_LABEL ( label_entry ) < sizeof ( mpls_labelname ) / sizeof ( mpls_labelname [ 0 ] ) ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(%s)" , mpls_labelname [ MPLS_LABEL ( label_entry ) ] ) ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>exp<S2SV_blank>%u" , MPLS_EXP ( label_entry ) ) ) ; //<S2SV> if ( MPLS_STACK ( label_entry ) ) //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>[S]" ) ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>ttl<S2SV_blank>%u)" , MPLS_TTL ( label_entry ) ) ) ; //<S2SV> p += sizeof ( label_entry ) ; //<S2SV> length -= sizeof ( label_entry ) ; //<S2SV> } while ( ! MPLS_STACK ( label_entry ) ) ; //<S2SV> switch ( MPLS_LABEL ( label_entry ) ) { //<S2SV> case 0 : //<S2SV> case 3 : //<S2SV> pt = PT_IPV4 ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> pt = PT_IPV6 ; //<S2SV> break ; //<S2SV> default : //<S2SV> ND_TCHECK ( * p ) ; //<S2SV> if ( length < 1 ) { //<S2SV> return ; //<S2SV> } //<S2SV> switch ( * p ) { //<S2SV> case 0x45 : //<S2SV> case 0x46 : //<S2SV> case 0x47 : //<S2SV> case 0x48 : //<S2SV> case 0x49 : //<S2SV> case 0x4a : //<S2SV> case 0x4b : //<S2SV> case 0x4c : //<S2SV> case 0x4d : //<S2SV> case 0x4e : //<S2SV> case 0x4f : //<S2SV> pt = PT_IPV4 ; //<S2SV> break ; //<S2SV> case 0x60 : //<S2SV> case 0x61 : //<S2SV> case 0x62 : //<S2SV> case 0x63 : //<S2SV> case 0x64 : //<S2SV> case 0x65 : //<S2SV> case 0x66 : //<S2SV> case 0x67 : //<S2SV> case 0x68 : //<S2SV> case 0x69 : //<S2SV> case 0x6a : //<S2SV> case 0x6b : //<S2SV> case 0x6c : //<S2SV> case 0x6d : //<S2SV> case 0x6e : //<S2SV> case 0x6f : //<S2SV> pt = PT_IPV6 ; //<S2SV> break ; //<S2SV> case 0x81 : //<S2SV> case 0x82 : //<S2SV> case 0x83 : //<S2SV> pt = PT_OSI ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( pt == PT_UNKNOWN ) { //<S2SV> if ( ! ndo -> ndo_suppress_default_print ) //<S2SV> ND_DEFAULTPRINT ( p , length ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , ndo -> ndo_vflag ? "\\n\\t" : "<S2SV_blank>" ) ) ; //<S2SV> switch ( pt ) { //<S2SV> case PT_IPV4 : //<S2SV> ip_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case PT_IPV6 : //<S2SV> ip6_print ( ndo , p , length ) ; //<S2SV> break ; //<S2SV> case PT_OSI : //<S2SV> isoclns_print ( ndo , p , length , length ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "[|MPLS]" ) ) ; //<S2SV> } //<S2SV> 