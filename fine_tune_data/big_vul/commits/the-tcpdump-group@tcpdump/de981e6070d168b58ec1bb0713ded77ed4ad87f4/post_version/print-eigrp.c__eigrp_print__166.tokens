void //<S2SV> eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) //<S2SV> { //<S2SV> const struct eigrp_common_header * eigrp_com_header ; //<S2SV> const struct eigrp_tlv_header * eigrp_tlv_header ; //<S2SV> const u_char * tptr , * tlv_tptr ; //<S2SV> u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; //<S2SV> uint8_t prefix [ 4 ] ; //<S2SV> union { //<S2SV> const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; //<S2SV> const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; //<S2SV> const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; //<S2SV> const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; //<S2SV> const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; //<S2SV> const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; //<S2SV> const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; //<S2SV> } tlv_ptr ; //<S2SV> tptr = pptr ; //<S2SV> eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; //<S2SV> ND_TCHECK ( * eigrp_com_header ) ; //<S2SV> if ( eigrp_com_header -> version != EIGRP_VERSION ) { //<S2SV> ND_PRINT ( ( ndo , "EIGRP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , eigrp_com_header -> version ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ndo -> ndo_vflag < 1 ) { //<S2SV> ND_PRINT ( ( ndo , "EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u" , //<S2SV> tok2str ( eigrp_opcode_values , "unknown<S2SV_blank>(%u)" , eigrp_com_header -> opcode ) , //<S2SV> len ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( len < sizeof ( struct eigrp_common_header ) ) { //<S2SV> ND_PRINT ( ( ndo , "EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> tok2str ( eigrp_opcode_values , "unknown<S2SV_blank>(%u)" , eigrp_com_header -> opcode ) , //<S2SV> len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> tlen = len - sizeof ( struct eigrp_common_header ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\tEIGRP<S2SV_blank>v%u,<S2SV_blank>opcode:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>chksum:<S2SV_blank>0x%04x,<S2SV_blank>Flags:<S2SV_blank>[%s]\\n\\tseq:<S2SV_blank>0x%08x,<S2SV_blank>ack:<S2SV_blank>0x%08x,<S2SV_blank>AS:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u" , //<S2SV> eigrp_com_header -> version , //<S2SV> tok2str ( eigrp_opcode_values , "unknown,<S2SV_blank>type:<S2SV_blank>%u" , eigrp_com_header -> opcode ) , //<S2SV> eigrp_com_header -> opcode , //<S2SV> EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , //<S2SV> tok2str ( eigrp_common_header_flag_values , //<S2SV> "none" , //<S2SV> EXTRACT_32BITS ( & eigrp_com_header -> flags ) ) , //<S2SV> EXTRACT_32BITS ( & eigrp_com_header -> seq ) , //<S2SV> EXTRACT_32BITS ( & eigrp_com_header -> ack ) , //<S2SV> EXTRACT_32BITS ( & eigrp_com_header -> asn ) , //<S2SV> tlen ) ) ; //<S2SV> tptr += sizeof ( const struct eigrp_common_header ) ; //<S2SV> while ( tlen > 0 ) { //<S2SV> ND_TCHECK2 ( * tptr , sizeof ( struct eigrp_tlv_header ) ) ; //<S2SV> eigrp_tlv_header = ( const struct eigrp_tlv_header * ) tptr ; //<S2SV> eigrp_tlv_len = EXTRACT_16BITS ( & eigrp_tlv_header -> length ) ; //<S2SV> eigrp_tlv_type = EXTRACT_16BITS ( & eigrp_tlv_header -> type ) ; //<S2SV> if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) || //<S2SV> eigrp_tlv_len > tlen ) { //<S2SV> print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u" , //<S2SV> tok2str ( eigrp_tlv_values , //<S2SV> "Unknown" , //<S2SV> eigrp_tlv_type ) , //<S2SV> eigrp_tlv_type , //<S2SV> eigrp_tlv_len ) ) ; //<S2SV> if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> tlv_tptr = tptr + sizeof ( struct eigrp_tlv_header ) ; //<S2SV> tlv_tlen = eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ; //<S2SV> ND_TCHECK2 ( * tptr , eigrp_tlv_len ) ; //<S2SV> switch ( eigrp_tlv_type ) { //<S2SV> case EIGRP_TLV_GENERAL_PARM : //<S2SV> tlv_ptr . eigrp_tlv_general_parm = ( const struct eigrp_tlv_general_parm_t * ) tlv_tptr ; //<S2SV> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>holdtime:<S2SV_blank>%us,<S2SV_blank>k1<S2SV_blank>%u,<S2SV_blank>k2<S2SV_blank>%u,<S2SV_blank>k3<S2SV_blank>%u,<S2SV_blank>k4<S2SV_blank>%u,<S2SV_blank>k5<S2SV_blank>%u" , //<S2SV> EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_general_parm -> holdtime ) , //<S2SV> tlv_ptr . eigrp_tlv_general_parm -> k1 , //<S2SV> tlv_ptr . eigrp_tlv_general_parm -> k2 , //<S2SV> tlv_ptr . eigrp_tlv_general_parm -> k3 , //<S2SV> tlv_ptr . eigrp_tlv_general_parm -> k4 , //<S2SV> tlv_ptr . eigrp_tlv_general_parm -> k5 ) ) ; //<S2SV> break ; //<S2SV> case EIGRP_TLV_SW_VERSION : //<S2SV> tlv_ptr . eigrp_tlv_sw_version = ( const struct eigrp_tlv_sw_version_t * ) tlv_tptr ; //<S2SV> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IOS<S2SV_blank>version:<S2SV_blank>%u.%u,<S2SV_blank>EIGRP<S2SV_blank>version<S2SV_blank>%u.%u" , //<S2SV> tlv_ptr . eigrp_tlv_sw_version -> ios_major , //<S2SV> tlv_ptr . eigrp_tlv_sw_version -> ios_minor , //<S2SV> tlv_ptr . eigrp_tlv_sw_version -> eigrp_major , //<S2SV> tlv_ptr . eigrp_tlv_sw_version -> eigrp_minor ) ) ; //<S2SV> break ; //<S2SV> case EIGRP_TLV_IP_INT : //<S2SV> tlv_ptr . eigrp_tlv_ip_int = ( const struct eigrp_tlv_ip_int_t * ) tlv_tptr ; //<S2SV> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> bit_length = tlv_ptr . eigrp_tlv_ip_int -> plen ; //<S2SV> if ( bit_length > 32 ) { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u" , bit_length ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> byte_length = ( bit_length + 7 ) / 8 ; //<S2SV> memset ( prefix , 0 , 4 ) ; //<S2SV> memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_int -> destination , byte_length ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>" , //<S2SV> ipaddr_string ( ndo , prefix ) , //<S2SV> bit_length ) ) ; //<S2SV> if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) == 0 ) //<S2SV> ND_PRINT ( ( ndo , "self" ) ) ; //<S2SV> else //<S2SV> ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_int -> nexthop ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u" , //<S2SV> ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> delay ) / 100 ) , //<S2SV> EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_int -> bandwidth ) , //<S2SV> EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_int -> mtu ) , //<S2SV> tlv_ptr . eigrp_tlv_ip_int -> hopcount , //<S2SV> tlv_ptr . eigrp_tlv_ip_int -> reliability , //<S2SV> tlv_ptr . eigrp_tlv_ip_int -> load ) ) ; //<S2SV> break ; //<S2SV> case EIGRP_TLV_IP_EXT : //<S2SV> tlv_ptr . eigrp_tlv_ip_ext = ( const struct eigrp_tlv_ip_ext_t * ) tlv_tptr ; //<S2SV> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> bit_length = tlv_ptr . eigrp_tlv_ip_ext -> plen ; //<S2SV> if ( bit_length > 32 ) { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>illegal<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u" , bit_length ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> byte_length = ( bit_length + 7 ) / 8 ; //<S2SV> memset ( prefix , 0 , 4 ) ; //<S2SV> memcpy ( prefix , & tlv_ptr . eigrp_tlv_ip_ext -> destination , byte_length ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>prefix:<S2SV_blank>%15s/%u,<S2SV_blank>nexthop:<S2SV_blank>" , //<S2SV> ipaddr_string ( ndo , prefix ) , //<S2SV> bit_length ) ) ; //<S2SV> if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) == 0 ) //<S2SV> ND_PRINT ( ( ndo , "self" ) ) ; //<S2SV> else //<S2SV> ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , & tlv_ptr . eigrp_tlv_ip_ext -> nexthop ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%s,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u" , //<S2SV> ipaddr_string ( ndo , tlv_ptr . eigrp_tlv_ip_ext -> origin_router ) , //<S2SV> EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> origin_as ) , //<S2SV> tok2str ( eigrp_ext_proto_id_values , "unknown" , tlv_ptr . eigrp_tlv_ip_ext -> proto_id ) , //<S2SV> tlv_ptr . eigrp_tlv_ip_ext -> flags , //<S2SV> EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> tag ) , //<S2SV> EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_ip_ext -> metric ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u" , //<S2SV> ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> delay ) / 100 ) , //<S2SV> EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> bandwidth ) , //<S2SV> EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_ip_ext -> mtu ) , //<S2SV> tlv_ptr . eigrp_tlv_ip_ext -> hopcount , //<S2SV> tlv_ptr . eigrp_tlv_ip_ext -> reliability , //<S2SV> tlv_ptr . eigrp_tlv_ip_ext -> load ) ) ; //<S2SV> break ; //<S2SV> case EIGRP_TLV_AT_CABLE_SETUP : //<S2SV> tlv_ptr . eigrp_tlv_at_cable_setup = ( const struct eigrp_tlv_at_cable_setup_t * ) tlv_tptr ; //<S2SV> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-range:<S2SV_blank>%u-%u,<S2SV_blank>Router-ID<S2SV_blank>%u" , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_start ) , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> cable_end ) , //<S2SV> EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_cable_setup -> router_id ) ) ) ; //<S2SV> break ; //<S2SV> case EIGRP_TLV_AT_INT : //<S2SV> tlv_ptr . eigrp_tlv_at_int = ( const struct eigrp_tlv_at_int_t * ) tlv_tptr ; //<S2SV> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>" , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_start ) , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> cable_end ) ) ) ; //<S2SV> if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) == 0 ) //<S2SV> ND_PRINT ( ( ndo , "self" ) ) ; //<S2SV> else //<S2SV> ND_PRINT ( ( ndo , "%u.%u" , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop ) , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_int -> nexthop [ 2 ] ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u" , //<S2SV> ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> delay ) / 100 ) , //<S2SV> EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_int -> bandwidth ) , //<S2SV> EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_int -> mtu ) , //<S2SV> tlv_ptr . eigrp_tlv_at_int -> hopcount , //<S2SV> tlv_ptr . eigrp_tlv_at_int -> reliability , //<S2SV> tlv_ptr . eigrp_tlv_at_int -> load ) ) ; //<S2SV> break ; //<S2SV> case EIGRP_TLV_AT_EXT : //<S2SV> tlv_ptr . eigrp_tlv_at_ext = ( const struct eigrp_tlv_at_ext_t * ) tlv_tptr ; //<S2SV> if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , //<S2SV> ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Cable-Range:<S2SV_blank>%u-%u,<S2SV_blank>nexthop:<S2SV_blank>" , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_start ) , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> cable_end ) ) ) ; //<S2SV> if ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) == 0 ) //<S2SV> ND_PRINT ( ( ndo , "self" ) ) ; //<S2SV> else //<S2SV> ND_PRINT ( ( ndo , "%u.%u" , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop ) , //<S2SV> EXTRACT_16BITS ( & tlv_ptr . eigrp_tlv_at_ext -> nexthop [ 2 ] ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>origin-router<S2SV_blank>%u,<S2SV_blank>origin-as<S2SV_blank>%u,<S2SV_blank>origin-proto<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>[0x%02x],<S2SV_blank>tag<S2SV_blank>0x%08x,<S2SV_blank>metric<S2SV_blank>%u" , //<S2SV> EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_router ) , //<S2SV> EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> origin_as ) , //<S2SV> tok2str ( eigrp_ext_proto_id_values , "unknown" , tlv_ptr . eigrp_tlv_at_ext -> proto_id ) , //<S2SV> tlv_ptr . eigrp_tlv_at_ext -> flags , //<S2SV> EXTRACT_32BITS ( tlv_ptr . eigrp_tlv_at_ext -> tag ) , //<S2SV> EXTRACT_16BITS ( tlv_ptr . eigrp_tlv_at_ext -> metric ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>delay<S2SV_blank>%u<S2SV_blank>ms,<S2SV_blank>bandwidth<S2SV_blank>%u<S2SV_blank>Kbps,<S2SV_blank>mtu<S2SV_blank>%u,<S2SV_blank>hop<S2SV_blank>%u,<S2SV_blank>reliability<S2SV_blank>%u,<S2SV_blank>load<S2SV_blank>%u" , //<S2SV> ( EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> delay ) / 100 ) , //<S2SV> EXTRACT_32BITS ( & tlv_ptr . eigrp_tlv_at_ext -> bandwidth ) , //<S2SV> EXTRACT_24BITS ( & tlv_ptr . eigrp_tlv_at_ext -> mtu ) , //<S2SV> tlv_ptr . eigrp_tlv_at_ext -> hopcount , //<S2SV> tlv_ptr . eigrp_tlv_at_ext -> reliability , //<S2SV> tlv_ptr . eigrp_tlv_at_ext -> load ) ) ; //<S2SV> break ; //<S2SV> case EIGRP_TLV_AUTH : //<S2SV> case EIGRP_TLV_SEQ : //<S2SV> case EIGRP_TLV_MCAST_SEQ : //<S2SV> case EIGRP_TLV_IPX_INT : //<S2SV> case EIGRP_TLV_IPX_EXT : //<S2SV> default : //<S2SV> if ( ndo -> ndo_vflag <= 1 ) //<S2SV> print_unknown_data ( ndo , tlv_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlv_tlen ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ndo -> ndo_vflag > 1 ) //<S2SV> print_unknown_data ( ndo , tptr + sizeof ( struct eigrp_tlv_header ) , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , //<S2SV> eigrp_tlv_len - sizeof ( struct eigrp_tlv_header ) ) ; //<S2SV> tptr += eigrp_tlv_len ; //<S2SV> tlen -= eigrp_tlv_len ; //<S2SV> } //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; //<S2SV> } //<S2SV> 