void //<S2SV> eap_print ( netdissect_options * ndo , //<S2SV> register const u_char * cp , //<S2SV> u_int length ) //<S2SV> { //<S2SV> const struct eap_frame_t * eap ; //<S2SV> const u_char * tptr ; //<S2SV> u_int tlen , type , subtype ; //<S2SV> int count = 0 , len ; //<S2SV> tptr = cp ; //<S2SV> tlen = length ; //<S2SV> eap = ( const struct eap_frame_t * ) cp ; //<S2SV> ND_TCHECK ( * eap ) ; //<S2SV> if ( ndo -> ndo_vflag < 1 ) { //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u" , //<S2SV> tok2str ( eap_frame_type_values , "unknown" , eap -> type ) , //<S2SV> eap -> type , //<S2SV> eap -> version , //<S2SV> EXTRACT_16BITS ( eap -> length ) ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u" , //<S2SV> tok2str ( eap_frame_type_values , "unknown" , eap -> type ) , //<S2SV> eap -> type , //<S2SV> eap -> version , //<S2SV> EXTRACT_16BITS ( eap -> length ) ) ) ; //<S2SV> tptr += sizeof ( const struct eap_frame_t ) ; //<S2SV> tlen -= sizeof ( const struct eap_frame_t ) ; //<S2SV> switch ( eap -> type ) { //<S2SV> case EAP_FRAME_TYPE_PACKET : //<S2SV> ND_TCHECK_8BITS ( tptr ) ; //<S2SV> type = * ( tptr ) ; //<S2SV> ND_TCHECK_16BITS ( tptr + 2 ) ; //<S2SV> len = EXTRACT_16BITS ( tptr + 2 ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>len<S2SV_blank>%u" , //<S2SV> tok2str ( eap_code_values , "unknown" , type ) , //<S2SV> type , //<S2SV> * ( tptr + 1 ) , //<S2SV> len ) ) ; //<S2SV> ND_TCHECK2 ( * tptr , len ) ; //<S2SV> if ( type <= 2 ) { //<S2SV> ND_TCHECK_8BITS ( tptr + 4 ) ; //<S2SV> subtype = * ( tptr + 4 ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tok2str ( eap_type_values , "unknown" , subtype ) , //<S2SV> subtype ) ) ; //<S2SV> switch ( subtype ) { //<S2SV> case EAP_TYPE_IDENTITY : //<S2SV> if ( len - 5 > 0 ) { //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Identity:<S2SV_blank>" ) ) ; //<S2SV> safeputs ( ndo , tptr + 5 , len - 5 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case EAP_TYPE_NOTIFICATION : //<S2SV> if ( len - 5 > 0 ) { //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Notification:<S2SV_blank>" ) ) ; //<S2SV> safeputs ( ndo , tptr + 5 , len - 5 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case EAP_TYPE_NAK : //<S2SV> count = 5 ; //<S2SV> while ( count < len ) { //<S2SV> ND_TCHECK_8BITS ( tptr + count ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>(%u)," , //<S2SV> tok2str ( eap_type_values , "unknown" , * ( tptr + count ) ) , //<S2SV> * ( tptr + count ) ) ) ; //<S2SV> count ++ ; //<S2SV> } //<S2SV> break ; //<S2SV> case EAP_TYPE_TTLS : //<S2SV> case EAP_TYPE_TLS : //<S2SV> ND_TCHECK_8BITS ( tptr + 5 ) ; //<S2SV> if ( subtype == EAP_TYPE_TTLS ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>TTLSv%u" , //<S2SV> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x," , //<S2SV> bittok2str ( eap_tls_flags_values , "none" , * ( tptr + 5 ) ) , //<S2SV> * ( tptr + 5 ) ) ) ; //<S2SV> if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { //<S2SV> ND_TCHECK_32BITS ( tptr + 6 ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len<S2SV_blank>%u" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case EAP_TYPE_FAST : //<S2SV> ND_TCHECK_8BITS ( tptr + 5 ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>FASTv%u" , //<S2SV> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x," , //<S2SV> bittok2str ( eap_tls_flags_values , "none" , * ( tptr + 5 ) ) , //<S2SV> * ( tptr + 5 ) ) ) ; //<S2SV> if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { //<S2SV> ND_TCHECK_32BITS ( tptr + 6 ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len<S2SV_blank>%u" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case EAP_TYPE_AKA : //<S2SV> case EAP_TYPE_SIM : //<S2SV> ND_TCHECK_8BITS ( tptr + 5 ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x," , //<S2SV> tok2str ( eap_aka_subtype_values , "unknown" , * ( tptr + 5 ) ) , //<S2SV> * ( tptr + 5 ) ) ) ; //<S2SV> break ; //<S2SV> case EAP_TYPE_MD5_CHALLENGE : //<S2SV> case EAP_TYPE_OTP : //<S2SV> case EAP_TYPE_GTC : //<S2SV> case EAP_TYPE_EXPANDED_TYPES : //<S2SV> case EAP_TYPE_EXPERIMENTAL : //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case EAP_FRAME_TYPE_LOGOFF : //<S2SV> case EAP_FRAME_TYPE_ENCAP_ASF_ALERT : //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "\\n\\t[|EAP]" ) ) ; //<S2SV> } //<S2SV> 