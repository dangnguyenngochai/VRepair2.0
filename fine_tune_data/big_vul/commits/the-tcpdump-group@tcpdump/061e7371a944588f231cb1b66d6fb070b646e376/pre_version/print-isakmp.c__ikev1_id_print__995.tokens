static const u_char * //<S2SV> ikev1_id_print ( netdissect_options * ndo , u_char tpay _U_ , //<S2SV> const struct isakmp_gen * ext , u_int item_len , //<S2SV> const u_char * ep _U_ , uint32_t phase , uint32_t doi _U_ , //<S2SV> uint32_t proto _U_ , int depth _U_ ) //<S2SV> { //<S2SV> # define USE_IPSECDOI_IN_PHASE1 1 //<S2SV> const struct ikev1_pl_id * p ; //<S2SV> struct ikev1_pl_id id ; //<S2SV> static const char * idtypestr [ ] = { //<S2SV> "IPv4" , "IPv4net" , "IPv6" , "IPv6net" , //<S2SV> } ; //<S2SV> static const char * ipsecidtypestr [ ] = { //<S2SV> NULL , "IPv4" , "FQDN" , "user<S2SV_blank>FQDN" , "IPv4net" , "IPv6" , //<S2SV> "IPv6net" , "IPv4range" , "IPv6range" , "ASN1<S2SV_blank>DN" , "ASN1<S2SV_blank>GN" , //<S2SV> "keyid" , //<S2SV> } ; //<S2SV> int len ; //<S2SV> const u_char * data ; //<S2SV> ND_PRINT ( ( ndo , "%s:" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; //<S2SV> p = ( const struct ikev1_pl_id * ) ext ; //<S2SV> ND_TCHECK ( * p ) ; //<S2SV> UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; //<S2SV> if ( sizeof ( * p ) < item_len ) { //<S2SV> data = ( const u_char * ) ( p + 1 ) ; //<S2SV> len = item_len - sizeof ( * p ) ; //<S2SV> } else { //<S2SV> data = NULL ; //<S2SV> len = 0 ; //<S2SV> } //<S2SV> # if 0 //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>[phase=%d<S2SV_blank>doi=%d<S2SV_blank>proto=%d]" , phase , doi , proto ) ) ; //<S2SV> # endif //<S2SV> switch ( phase ) { //<S2SV> # ifndef USE_IPSECDOI_IN_PHASE1 //<S2SV> case 1 : //<S2SV> # endif //<S2SV> default : //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>idtype=%s" , STR_OR_ID ( id . d . id_type , idtypestr ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>doi_data=%u" , //<S2SV> ( uint32_t ) ( ntohl ( id . d . doi_data ) & 0xffffff ) ) ) ; //<S2SV> break ; //<S2SV> # ifdef USE_IPSECDOI_IN_PHASE1 //<S2SV> case 1 : //<S2SV> # endif //<S2SV> case 2 : //<S2SV> { //<S2SV> const struct ipsecdoi_id * doi_p ; //<S2SV> struct ipsecdoi_id doi_id ; //<S2SV> const char * p_name ; //<S2SV> doi_p = ( const struct ipsecdoi_id * ) ext ; //<S2SV> ND_TCHECK ( * doi_p ) ; //<S2SV> UNALIGNED_MEMCPY ( & doi_id , ext , sizeof ( doi_id ) ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>idtype=%s" , STR_OR_ID ( doi_id . type , ipsecidtypestr ) ) ) ; //<S2SV> if ( ! ndo -> ndo_nflag && doi_id . proto_id && ( p_name = netdb_protoname ( doi_id . proto_id ) ) != NULL ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>protoid=%s" , p_name ) ) ; //<S2SV> else //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>protoid=%u" , doi_id . proto_id ) ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>port=%d" , ntohs ( doi_id . port ) ) ) ; //<S2SV> if ( ! len ) //<S2SV> break ; //<S2SV> if ( data == NULL ) //<S2SV> goto trunc ; //<S2SV> ND_TCHECK2 ( * data , len ) ; //<S2SV> switch ( doi_id . type ) { //<S2SV> case IPSECDOI_ID_IPV4_ADDR : //<S2SV> if ( len < 4 ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]" , len ) ) ; //<S2SV> else //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s" , len , ipaddr_string ( ndo , data ) ) ) ; //<S2SV> len = 0 ; //<S2SV> break ; //<S2SV> case IPSECDOI_ID_FQDN : //<S2SV> case IPSECDOI_ID_USER_FQDN : //<S2SV> { //<S2SV> int i ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>" , len ) ) ; //<S2SV> for ( i = 0 ; i < len ; i ++ ) //<S2SV> safeputchar ( ndo , data [ i ] ) ; //<S2SV> len = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPSECDOI_ID_IPV4_ADDR_SUBNET : //<S2SV> { //<S2SV> const u_char * mask ; //<S2SV> if ( len < 8 ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]" , len ) ) ; //<S2SV> else { //<S2SV> mask = data + sizeof ( struct in_addr ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s/%u.%u.%u.%u" , len , //<S2SV> ipaddr_string ( ndo , data ) , //<S2SV> mask [ 0 ] , mask [ 1 ] , mask [ 2 ] , mask [ 3 ] ) ) ; //<S2SV> } //<S2SV> len = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPSECDOI_ID_IPV6_ADDR : //<S2SV> if ( len < 16 ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>16]" , len ) ) ; //<S2SV> else //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s" , len , ip6addr_string ( ndo , data ) ) ) ; //<S2SV> len = 0 ; //<S2SV> break ; //<S2SV> case IPSECDOI_ID_IPV6_ADDR_SUBNET : //<S2SV> { //<S2SV> const u_char * mask ; //<S2SV> if ( len < 20 ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]" , len ) ) ; //<S2SV> else { //<S2SV> mask = ( const u_char * ) ( data + sizeof ( struct in6_addr ) ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x" , len , //<S2SV> ip6addr_string ( ndo , data ) , //<S2SV> mask [ 0 ] , mask [ 1 ] , mask [ 2 ] , mask [ 3 ] , //<S2SV> mask [ 4 ] , mask [ 5 ] , mask [ 6 ] , mask [ 7 ] , //<S2SV> mask [ 8 ] , mask [ 9 ] , mask [ 10 ] , mask [ 11 ] , //<S2SV> mask [ 12 ] , mask [ 13 ] , mask [ 14 ] , mask [ 15 ] ) ) ; //<S2SV> } //<S2SV> len = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> case IPSECDOI_ID_IPV4_ADDR_RANGE : //<S2SV> if ( len < 8 ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]" , len ) ) ; //<S2SV> else { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s-%s" , len , //<S2SV> ipaddr_string ( ndo , data ) , //<S2SV> ipaddr_string ( ndo , data + sizeof ( struct in_addr ) ) ) ) ; //<S2SV> } //<S2SV> len = 0 ; //<S2SV> break ; //<S2SV> case IPSECDOI_ID_IPV6_ADDR_RANGE : //<S2SV> if ( len < 32 ) //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]" , len ) ) ; //<S2SV> else { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s-%s" , len , //<S2SV> ip6addr_string ( ndo , data ) , //<S2SV> ip6addr_string ( ndo , data + sizeof ( struct in6_addr ) ) ) ) ; //<S2SV> } //<S2SV> len = 0 ; //<S2SV> break ; //<S2SV> case IPSECDOI_ID_DER_ASN1_DN : //<S2SV> case IPSECDOI_ID_DER_ASN1_GN : //<S2SV> case IPSECDOI_ID_KEY_ID : //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( data && len ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d" , len ) ) ; //<S2SV> if ( 2 < ndo -> ndo_vflag ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; //<S2SV> if ( ! rawprint ( ndo , ( const uint8_t * ) data , len ) ) //<S2SV> goto trunc ; //<S2SV> } //<S2SV> } //<S2SV> return ( const u_char * ) ext + item_len ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 