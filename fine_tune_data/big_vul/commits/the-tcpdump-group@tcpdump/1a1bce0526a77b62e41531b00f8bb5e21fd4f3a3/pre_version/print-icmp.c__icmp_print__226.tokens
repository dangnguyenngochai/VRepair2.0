void //<S2SV> icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , //<S2SV> int fragmented ) //<S2SV> { //<S2SV> char * cp ; //<S2SV> const struct icmp * dp ; //<S2SV> const struct icmp_ext_t * ext_dp ; //<S2SV> const struct ip * ip ; //<S2SV> const char * str , * fmt ; //<S2SV> const struct ip * oip ; //<S2SV> const struct udphdr * ouh ; //<S2SV> const uint8_t * obj_tptr ; //<S2SV> uint32_t raw_label ; //<S2SV> const u_char * snapend_save ; //<S2SV> const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; //<S2SV> u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; //<S2SV> char buf [ MAXHOSTNAMELEN + 100 ] ; //<S2SV> struct cksum_vec vec [ 1 ] ; //<S2SV> dp = ( const struct icmp * ) bp ; //<S2SV> ext_dp = ( const struct icmp_ext_t * ) bp ; //<S2SV> ip = ( const struct ip * ) bp2 ; //<S2SV> str = buf ; //<S2SV> ND_TCHECK ( dp -> icmp_code ) ; //<S2SV> switch ( dp -> icmp_type ) { //<S2SV> case ICMP_ECHO : //<S2SV> case ICMP_ECHOREPLY : //<S2SV> ND_TCHECK ( dp -> icmp_seq ) ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , "echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u" , //<S2SV> dp -> icmp_type == ICMP_ECHO ? //<S2SV> "request" : "reply" , //<S2SV> EXTRACT_16BITS ( & dp -> icmp_id ) , //<S2SV> EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; //<S2SV> break ; //<S2SV> case ICMP_UNREACH : //<S2SV> ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; //<S2SV> switch ( dp -> icmp_code ) { //<S2SV> case ICMP_UNREACH_PROTOCOL : //<S2SV> ND_TCHECK ( dp -> icmp_ip . ip_p ) ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable" , //<S2SV> ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , //<S2SV> dp -> icmp_ip . ip_p ) ; //<S2SV> break ; //<S2SV> case ICMP_UNREACH_PORT : //<S2SV> ND_TCHECK ( dp -> icmp_ip . ip_p ) ; //<S2SV> oip = & dp -> icmp_ip ; //<S2SV> hlen = IP_HL ( oip ) * 4 ; //<S2SV> ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; //<S2SV> ND_TCHECK ( ouh -> uh_dport ) ; //<S2SV> dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; //<S2SV> switch ( oip -> ip_p ) { //<S2SV> case IPPROTO_TCP : //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable" , //<S2SV> ipaddr_string ( ndo , & oip -> ip_dst ) , //<S2SV> tcpport_string ( ndo , dport ) ) ; //<S2SV> break ; //<S2SV> case IPPROTO_UDP : //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable" , //<S2SV> ipaddr_string ( ndo , & oip -> ip_dst ) , //<S2SV> udpport_string ( ndo , dport ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "%s<S2SV_blank>protocol<S2SV_blank>%u<S2SV_blank>port<S2SV_blank>%u<S2SV_blank>unreachable" , //<S2SV> ipaddr_string ( ndo , & oip -> ip_dst ) , //<S2SV> oip -> ip_p , dport ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case ICMP_UNREACH_NEEDFRAG : //<S2SV> { //<S2SV> register const struct mtu_discovery * mp ; //<S2SV> mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; //<S2SV> mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; //<S2SV> if ( mtu ) { //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)" , //<S2SV> ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; //<S2SV> } else { //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag" , //<S2SV> ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> fmt = tok2str ( unreach2str , "#%d<S2SV_blank>%%s<S2SV_blank>unreachable" , //<S2SV> dp -> icmp_code ) ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , fmt , //<S2SV> ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case ICMP_REDIRECT : //<S2SV> ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; //<S2SV> fmt = tok2str ( type2str , "redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s" , //<S2SV> dp -> icmp_code ) ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , fmt , //<S2SV> ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , //<S2SV> ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; //<S2SV> break ; //<S2SV> case ICMP_ROUTERADVERT : //<S2SV> { //<S2SV> register const struct ih_rdiscovery * ihp ; //<S2SV> register const struct id_rdiscovery * idp ; //<S2SV> u_int lifetime , num , size ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , "router<S2SV_blank>advertisement" ) ; //<S2SV> cp = buf + strlen ( buf ) ; //<S2SV> ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; //<S2SV> ND_TCHECK ( * ihp ) ; //<S2SV> ( void ) strncpy ( cp , "<S2SV_blank>lifetime<S2SV_blank>" , sizeof ( buf ) - ( cp - buf ) ) ; //<S2SV> cp = buf + strlen ( buf ) ; //<S2SV> lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; //<S2SV> if ( lifetime < 60 ) { //<S2SV> ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "%u" , //<S2SV> lifetime ) ; //<S2SV> } else if ( lifetime < 60 * 60 ) { //<S2SV> ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "%u:%02u" , //<S2SV> lifetime / 60 , lifetime % 60 ) ; //<S2SV> } else { //<S2SV> ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , //<S2SV> "%u:%02u:%02u" , //<S2SV> lifetime / 3600 , //<S2SV> ( lifetime % 3600 ) / 60 , //<S2SV> lifetime % 60 ) ; //<S2SV> } //<S2SV> cp = buf + strlen ( buf ) ; //<S2SV> num = ihp -> ird_addrnum ; //<S2SV> ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "<S2SV_blank>%d:" , num ) ; //<S2SV> cp = buf + strlen ( buf ) ; //<S2SV> size = ihp -> ird_addrsiz ; //<S2SV> if ( size != 2 ) { //<S2SV> ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , //<S2SV> "<S2SV_blank>[size<S2SV_blank>%d]" , size ) ; //<S2SV> break ; //<S2SV> } //<S2SV> idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; //<S2SV> while ( num -- > 0 ) { //<S2SV> ND_TCHECK ( * idp ) ; //<S2SV> ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , "<S2SV_blank>{%s<S2SV_blank>%u}" , //<S2SV> ipaddr_string ( ndo , & idp -> ird_addr ) , //<S2SV> EXTRACT_32BITS ( & idp -> ird_pref ) ) ; //<S2SV> cp = buf + strlen ( buf ) ; //<S2SV> ++ idp ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case ICMP_TIMXCEED : //<S2SV> ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; //<S2SV> switch ( dp -> icmp_code ) { //<S2SV> case ICMP_TIMXCEED_INTRANS : //<S2SV> str = "time<S2SV_blank>exceeded<S2SV_blank>in-transit" ; //<S2SV> break ; //<S2SV> case ICMP_TIMXCEED_REASS : //<S2SV> str = "ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded" ; //<S2SV> break ; //<S2SV> default : //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , "time<S2SV_blank>exceeded-#%u" , //<S2SV> dp -> icmp_code ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case ICMP_PARAMPROB : //<S2SV> if ( dp -> icmp_code ) //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%u" , dp -> icmp_code ) ; //<S2SV> else { //<S2SV> ND_TCHECK ( dp -> icmp_pptr ) ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u" , dp -> icmp_pptr ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case ICMP_MASKREPLY : //<S2SV> ND_TCHECK ( dp -> icmp_mask ) ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , "address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x" , //<S2SV> EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; //<S2SV> break ; //<S2SV> case ICMP_TSTAMP : //<S2SV> ND_TCHECK ( dp -> icmp_seq ) ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u" , //<S2SV> EXTRACT_16BITS ( & dp -> icmp_id ) , //<S2SV> EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; //<S2SV> break ; //<S2SV> case ICMP_TSTAMPREPLY : //<S2SV> ND_TCHECK ( dp -> icmp_ttime ) ; //<S2SV> ( void ) snprintf ( buf , sizeof ( buf ) , //<S2SV> "time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s" , //<S2SV> EXTRACT_16BITS ( & dp -> icmp_id ) , //<S2SV> EXTRACT_16BITS ( & dp -> icmp_seq ) , //<S2SV> icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; //<S2SV> ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ",<S2SV_blank>recv<S2SV_blank>%s" , //<S2SV> icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; //<S2SV> ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , ",<S2SV_blank>xmit<S2SV_blank>%s" , //<S2SV> icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> str = tok2str ( icmp2str , "type-#%d" , dp -> icmp_type ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u" , str , plen ) ) ; //<S2SV> if ( ndo -> ndo_vflag && ! fragmented ) { //<S2SV> if ( ND_TTEST2 ( * bp , plen ) ) { //<S2SV> uint16_t sum ; //<S2SV> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; //<S2SV> vec [ 0 ] . len = plen ; //<S2SV> sum = in_cksum ( vec , 1 ) ; //<S2SV> if ( sum != 0 ) { //<S2SV> uint16_t icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)" , //<S2SV> icmp_sum , //<S2SV> in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { //<S2SV> bp += 8 ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t" ) ) ; //<S2SV> ip = ( const struct ip * ) bp ; //<S2SV> ndo -> ndo_snaplen = ndo -> ndo_snapend - bp ; //<S2SV> snapend_save = ndo -> ndo_snapend ; //<S2SV> ND_TCHECK_16BITS ( & ip -> ip_len ) ; //<S2SV> ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; //<S2SV> ndo -> ndo_snapend = snapend_save ; //<S2SV> } //<S2SV> if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { //<S2SV> ND_TCHECK ( * ext_dp ) ; //<S2SV> if ( ! ext_dp -> icmp_length && //<S2SV> ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { //<S2SV> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; //<S2SV> vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; //<S2SV> if ( in_cksum ( vec , 1 ) ) { //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u" , //<S2SV> ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; //<S2SV> if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != //<S2SV> ICMP_MPLS_EXT_VERSION ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> hlen = plen - ICMP_EXTD_MINLEN ; //<S2SV> if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { //<S2SV> vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; //<S2SV> vec [ 0 ] . len = hlen ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , //<S2SV> in_cksum ( vec , 1 ) ? "in" : "" , //<S2SV> hlen ) ) ; //<S2SV> } //<S2SV> hlen -= 4 ; //<S2SV> obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; //<S2SV> while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { //<S2SV> icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; //<S2SV> ND_TCHECK ( * icmp_mpls_ext_object_header ) ; //<S2SV> obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; //<S2SV> obj_class_num = icmp_mpls_ext_object_header -> class_num ; //<S2SV> obj_ctype = icmp_mpls_ext_object_header -> ctype ; //<S2SV> obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> tok2str ( icmp_mpls_ext_obj_values , "unknown" , obj_class_num ) , //<S2SV> obj_class_num , //<S2SV> obj_ctype , //<S2SV> obj_tlen ) ) ; //<S2SV> hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; //<S2SV> if ( ( obj_class_num == 0 ) || //<S2SV> ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { //<S2SV> return ; //<S2SV> } //<S2SV> obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; //<S2SV> switch ( obj_class_num ) { //<S2SV> case 1 : //<S2SV> switch ( obj_ctype ) { //<S2SV> case 1 : //<S2SV> ND_TCHECK2 ( * obj_tptr , 4 ) ; //<S2SV> raw_label = EXTRACT_32BITS ( obj_tptr ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; //<S2SV> if ( MPLS_STACK ( raw_label ) ) //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>[S]" ) ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>ttl<S2SV_blank>%u" , MPLS_TTL ( raw_label ) ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 2 : //<S2SV> default : //<S2SV> print_unknown_data ( ndo , obj_tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , obj_tlen ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( hlen < obj_tlen ) //<S2SV> break ; //<S2SV> hlen -= obj_tlen ; //<S2SV> obj_tptr += obj_tlen ; //<S2SV> } //<S2SV> } //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "[|icmp]" ) ) ; //<S2SV> } //<S2SV> 