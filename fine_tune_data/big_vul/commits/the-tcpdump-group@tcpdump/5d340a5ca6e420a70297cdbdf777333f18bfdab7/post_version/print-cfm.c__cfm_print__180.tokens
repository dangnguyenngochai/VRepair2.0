void //<S2SV> cfm_print ( netdissect_options * ndo , //<S2SV> register const u_char * pptr , register u_int length ) //<S2SV> { //<S2SV> const struct cfm_common_header_t * cfm_common_header ; //<S2SV> const struct cfm_tlv_header_t * cfm_tlv_header ; //<S2SV> const uint8_t * tptr , * tlv_ptr ; //<S2SV> const uint8_t * namesp ; //<S2SV> u_int names_data_remaining ; //<S2SV> uint8_t md_nameformat , md_namelength ; //<S2SV> const uint8_t * md_name ; //<S2SV> uint8_t ma_nameformat , ma_namelength ; //<S2SV> const uint8_t * ma_name ; //<S2SV> u_int hexdump , tlen , cfm_tlv_len , cfm_tlv_type , ccm_interval ; //<S2SV> union { //<S2SV> const struct cfm_ccm_t * cfm_ccm ; //<S2SV> const struct cfm_lbm_t * cfm_lbm ; //<S2SV> const struct cfm_ltm_t * cfm_ltm ; //<S2SV> const struct cfm_ltr_t * cfm_ltr ; //<S2SV> } msg_ptr ; //<S2SV> tptr = pptr ; //<S2SV> cfm_common_header = ( const struct cfm_common_header_t * ) pptr ; //<S2SV> if ( length < sizeof ( * cfm_common_header ) ) //<S2SV> goto tooshort ; //<S2SV> ND_TCHECK ( * cfm_common_header ) ; //<S2SV> if ( CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) != CFM_VERSION ) { //<S2SV> ND_PRINT ( ( ndo , "CFMv%u<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , length ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "CFMv%u<S2SV_blank>%s,<S2SV_blank>MD<S2SV_blank>Level<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> CFM_EXTRACT_VERSION ( cfm_common_header -> mdlevel_version ) , //<S2SV> tok2str ( cfm_opcode_values , "unknown<S2SV_blank>(%u)" , cfm_common_header -> opcode ) , //<S2SV> CFM_EXTRACT_MD_LEVEL ( cfm_common_header -> mdlevel_version ) , //<S2SV> length ) ) ; //<S2SV> if ( ndo -> ndo_vflag < 1 ) { //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\tFirst<S2SV_blank>TLV<S2SV_blank>offset<S2SV_blank>%u" , cfm_common_header -> first_tlv_offset ) ) ; //<S2SV> tptr += sizeof ( const struct cfm_common_header_t ) ; //<S2SV> tlen = length - sizeof ( struct cfm_common_header_t ) ; //<S2SV> if ( cfm_common_header -> first_tlv_offset > tlen ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)" , tlen ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> switch ( cfm_common_header -> opcode ) { //<S2SV> case CFM_OPCODE_CCM : //<S2SV> msg_ptr . cfm_ccm = ( const struct cfm_ccm_t * ) tptr ; //<S2SV> if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ccm ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>1,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)" , //<S2SV> ( unsigned long ) sizeof ( * msg_ptr . cfm_ccm ) ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( tlen < sizeof ( * msg_ptr . cfm_ccm ) ) //<S2SV> goto tooshort ; //<S2SV> ND_TCHECK ( * msg_ptr . cfm_ccm ) ; //<S2SV> ccm_interval = CFM_EXTRACT_CCM_INTERVAL ( cfm_common_header -> flags ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[CCM<S2SV_blank>Interval<S2SV_blank>%u%s]" , //<S2SV> ccm_interval , //<S2SV> cfm_common_header -> flags & CFM_CCM_RDI_FLAG ? //<S2SV> ",<S2SV_blank>RDI" : "" ) ) ; //<S2SV> if ( ccm_interval ) { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>CCM<S2SV_blank>Interval<S2SV_blank>%.3fs" //<S2SV> ",<S2SV_blank>min<S2SV_blank>CCM<S2SV_blank>Lifetime<S2SV_blank>%.3fs,<S2SV_blank>max<S2SV_blank>CCM<S2SV_blank>Lifetime<S2SV_blank>%.3fs" , //<S2SV> ccm_interval_base [ ccm_interval ] , //<S2SV> ccm_interval_base [ ccm_interval ] * CCM_INTERVAL_MIN_MULTIPLIER , //<S2SV> ccm_interval_base [ ccm_interval ] * CCM_INTERVAL_MAX_MULTIPLIER ) ) ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Sequence<S2SV_blank>Number<S2SV_blank>0x%08x,<S2SV_blank>MA-End-Point-ID<S2SV_blank>0x%04x" , //<S2SV> EXTRACT_32BITS ( msg_ptr . cfm_ccm -> sequence ) , //<S2SV> EXTRACT_16BITS ( msg_ptr . cfm_ccm -> ma_epi ) ) ) ; //<S2SV> namesp = msg_ptr . cfm_ccm -> names ; //<S2SV> names_data_remaining = sizeof ( msg_ptr . cfm_ccm -> names ) ; //<S2SV> md_nameformat = * namesp ; //<S2SV> namesp ++ ; //<S2SV> names_data_remaining -- ; //<S2SV> if ( md_nameformat != CFM_CCM_MD_FORMAT_NONE ) { //<S2SV> md_namelength = * namesp ; //<S2SV> namesp ++ ; //<S2SV> names_data_remaining -- ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>Format<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> tok2str ( cfm_md_nameformat_values , "Unknown" , //<S2SV> md_nameformat ) , //<S2SV> md_nameformat , //<S2SV> md_namelength ) ) ; //<S2SV> if ( md_namelength > names_data_remaining - 3 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)" , names_data_remaining - 2 ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> md_name = namesp ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name:<S2SV_blank>" ) ) ; //<S2SV> switch ( md_nameformat ) { //<S2SV> case CFM_CCM_MD_FORMAT_DNS : //<S2SV> case CFM_CCM_MD_FORMAT_CHAR : //<S2SV> safeputs ( ndo , md_name , md_namelength ) ; //<S2SV> break ; //<S2SV> case CFM_CCM_MD_FORMAT_MAC : //<S2SV> if ( md_namelength == 6 ) { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>%s" , etheraddr_string ( ndo , //<S2SV> md_name ) ) ) ; //<S2SV> } else { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>(length<S2SV_blank>invalid)" ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case CFM_CCM_MA_FORMAT_8021 : //<S2SV> default : //<S2SV> print_unknown_data ( ndo , md_name , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , //<S2SV> md_namelength ) ; //<S2SV> } //<S2SV> namesp += md_namelength ; //<S2SV> names_data_remaining -= md_namelength ; //<S2SV> } else { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>MD<S2SV_blank>Name<S2SV_blank>Format<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tok2str ( cfm_md_nameformat_values , "Unknown" , //<S2SV> md_nameformat ) , //<S2SV> md_nameformat ) ) ; //<S2SV> } //<S2SV> ma_nameformat = * namesp ; //<S2SV> namesp ++ ; //<S2SV> names_data_remaining -- ; //<S2SV> ma_namelength = * namesp ; //<S2SV> namesp ++ ; //<S2SV> names_data_remaining -- ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>MA<S2SV_blank>Name-Format<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>MA<S2SV_blank>name<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> tok2str ( cfm_ma_nameformat_values , "Unknown" , //<S2SV> ma_nameformat ) , //<S2SV> ma_nameformat , //<S2SV> ma_namelength ) ) ; //<S2SV> if ( ma_namelength > names_data_remaining ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>large,<S2SV_blank>must<S2SV_blank>be<S2SV_blank><=<S2SV_blank>%u)" , names_data_remaining ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ma_name = namesp ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>MA<S2SV_blank>Name:<S2SV_blank>" ) ) ; //<S2SV> switch ( ma_nameformat ) { //<S2SV> case CFM_CCM_MA_FORMAT_CHAR : //<S2SV> safeputs ( ndo , ma_name , ma_namelength ) ; //<S2SV> break ; //<S2SV> case CFM_CCM_MA_FORMAT_8021 : //<S2SV> case CFM_CCM_MA_FORMAT_VID : //<S2SV> case CFM_CCM_MA_FORMAT_INT : //<S2SV> case CFM_CCM_MA_FORMAT_VPN : //<S2SV> default : //<S2SV> print_unknown_data ( ndo , ma_name , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , ma_namelength ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case CFM_OPCODE_LTM : //<S2SV> msg_ptr . cfm_ltm = ( const struct cfm_ltm_t * ) tptr ; //<S2SV> if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltm ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>4,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)" , //<S2SV> ( unsigned long ) sizeof ( * msg_ptr . cfm_ltm ) ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( tlen < sizeof ( * msg_ptr . cfm_ltm ) ) //<S2SV> goto tooshort ; //<S2SV> ND_TCHECK ( * msg_ptr . cfm_ltm ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s]" , //<S2SV> bittok2str ( cfm_ltm_flag_values , "none" , cfm_common_header -> flags ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Transaction-ID<S2SV_blank>0x%08x,<S2SV_blank>ttl<S2SV_blank>%u" , //<S2SV> EXTRACT_32BITS ( msg_ptr . cfm_ltm -> transaction_id ) , //<S2SV> msg_ptr . cfm_ltm -> ttl ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Original-MAC<S2SV_blank>%s,<S2SV_blank>Target-MAC<S2SV_blank>%s" , //<S2SV> etheraddr_string ( ndo , msg_ptr . cfm_ltm -> original_mac ) , //<S2SV> etheraddr_string ( ndo , msg_ptr . cfm_ltm -> target_mac ) ) ) ; //<S2SV> break ; //<S2SV> case CFM_OPCODE_LTR : //<S2SV> msg_ptr . cfm_ltr = ( const struct cfm_ltr_t * ) tptr ; //<S2SV> if ( cfm_common_header -> first_tlv_offset < sizeof ( * msg_ptr . cfm_ltr ) ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>small<S2SV_blank>5,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%lu)" , //<S2SV> ( unsigned long ) sizeof ( * msg_ptr . cfm_ltr ) ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( tlen < sizeof ( * msg_ptr . cfm_ltr ) ) //<S2SV> goto tooshort ; //<S2SV> ND_TCHECK ( * msg_ptr . cfm_ltr ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s]" , //<S2SV> bittok2str ( cfm_ltr_flag_values , "none" , cfm_common_header -> flags ) ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Transaction-ID<S2SV_blank>0x%08x,<S2SV_blank>ttl<S2SV_blank>%u" , //<S2SV> EXTRACT_32BITS ( msg_ptr . cfm_ltr -> transaction_id ) , //<S2SV> msg_ptr . cfm_ltr -> ttl ) ) ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Replay-Action<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tok2str ( cfm_ltr_replay_action_values , //<S2SV> "Unknown" , //<S2SV> msg_ptr . cfm_ltr -> replay_action ) , //<S2SV> msg_ptr . cfm_ltr -> replay_action ) ) ; //<S2SV> break ; //<S2SV> case CFM_OPCODE_LBR : //<S2SV> case CFM_OPCODE_LBM : //<S2SV> default : //<S2SV> print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , //<S2SV> tlen - cfm_common_header -> first_tlv_offset ) ; //<S2SV> break ; //<S2SV> } //<S2SV> tptr += cfm_common_header -> first_tlv_offset ; //<S2SV> tlen -= cfm_common_header -> first_tlv_offset ; //<S2SV> while ( tlen > 0 ) { //<S2SV> cfm_tlv_header = ( const struct cfm_tlv_header_t * ) tptr ; //<S2SV> ND_TCHECK2 ( * tptr , 1 ) ; //<S2SV> cfm_tlv_type = cfm_tlv_header -> type ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t%s<S2SV_blank>TLV<S2SV_blank>(0x%02x)" , //<S2SV> tok2str ( cfm_tlv_values , "Unknown" , cfm_tlv_type ) , //<S2SV> cfm_tlv_type ) ) ; //<S2SV> if ( cfm_tlv_type == CFM_TLV_END ) { //<S2SV> return ; //<S2SV> } //<S2SV> if ( tlen < sizeof ( struct cfm_tlv_header_t ) ) //<S2SV> goto tooshort ; //<S2SV> ND_TCHECK2 ( * tptr , sizeof ( struct cfm_tlv_header_t ) ) ; //<S2SV> cfm_tlv_len = EXTRACT_16BITS ( & cfm_tlv_header -> length ) ; //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>length<S2SV_blank>%u" , cfm_tlv_len ) ) ; //<S2SV> tptr += sizeof ( struct cfm_tlv_header_t ) ; //<S2SV> tlen -= sizeof ( struct cfm_tlv_header_t ) ; //<S2SV> tlv_ptr = tptr ; //<S2SV> if ( tlen < cfm_tlv_len ) //<S2SV> goto tooshort ; //<S2SV> ND_TCHECK2 ( * tptr , cfm_tlv_len ) ; //<S2SV> hexdump = FALSE ; //<S2SV> switch ( cfm_tlv_type ) { //<S2SV> case CFM_TLV_PORT_STATUS : //<S2SV> if ( cfm_tlv_len < 1 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tok2str ( cfm_tlv_port_status_values , "Unknown" , * tptr ) , //<S2SV> * tptr ) ) ; //<S2SV> break ; //<S2SV> case CFM_TLV_INTERFACE_STATUS : //<S2SV> if ( cfm_tlv_len < 1 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , //<S2SV> tok2str ( cfm_tlv_interface_status_values , "Unknown" , * tptr ) , //<S2SV> * tptr ) ) ; //<S2SV> break ; //<S2SV> case CFM_TLV_PRIVATE : //<S2SV> if ( cfm_tlv_len < 4 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , ",<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Sub-Type<S2SV_blank>%u" , //<S2SV> tok2str ( oui_values , "Unknown" , EXTRACT_24BITS ( tptr ) ) , //<S2SV> EXTRACT_24BITS ( tptr ) , //<S2SV> * ( tptr + 3 ) ) ) ; //<S2SV> hexdump = TRUE ; //<S2SV> break ; //<S2SV> case CFM_TLV_SENDER_ID : //<S2SV> { //<S2SV> u_int chassis_id_type , chassis_id_length ; //<S2SV> u_int mgmt_addr_length ; //<S2SV> if ( cfm_tlv_len < 1 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>1)" ) ) ; //<S2SV> goto next_tlv ; //<S2SV> } //<S2SV> chassis_id_length = * tptr ; //<S2SV> tptr ++ ; //<S2SV> tlen -- ; //<S2SV> cfm_tlv_len -- ; //<S2SV> if ( chassis_id_length ) { //<S2SV> if ( cfm_tlv_len < 1 ) { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)" ) ) ; //<S2SV> goto next_tlv ; //<S2SV> } //<S2SV> chassis_id_type = * tptr ; //<S2SV> cfm_tlv_len -- ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Chassis-ID<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Chassis-ID<S2SV_blank>length<S2SV_blank>%u" , //<S2SV> tok2str ( cfm_tlv_senderid_chassisid_values , //<S2SV> "Unknown" , //<S2SV> chassis_id_type ) , //<S2SV> chassis_id_type , //<S2SV> chassis_id_length ) ) ; //<S2SV> if ( cfm_tlv_len < chassis_id_length ) { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)" ) ) ; //<S2SV> goto next_tlv ; //<S2SV> } //<S2SV> switch ( chassis_id_type ) { //<S2SV> case CFM_CHASSIS_ID_MAC_ADDRESS : //<S2SV> if ( chassis_id_length != ETHER_ADDR_LEN ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)" ) ) ; //<S2SV> hexdump = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>MAC<S2SV_blank>%s" , etheraddr_string ( ndo , tptr + 1 ) ) ) ; //<S2SV> break ; //<S2SV> case CFM_CHASSIS_ID_NETWORK_ADDRESS : //<S2SV> hexdump |= cfm_network_addr_print ( ndo , tptr + 1 , chassis_id_length ) ; //<S2SV> break ; //<S2SV> case CFM_CHASSIS_ID_INTERFACE_NAME : //<S2SV> case CFM_CHASSIS_ID_INTERFACE_ALIAS : //<S2SV> case CFM_CHASSIS_ID_LOCAL : //<S2SV> case CFM_CHASSIS_ID_CHASSIS_COMPONENT : //<S2SV> case CFM_CHASSIS_ID_PORT_COMPONENT : //<S2SV> safeputs ( ndo , tptr + 1 , chassis_id_length ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> hexdump = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> cfm_tlv_len -= chassis_id_length ; //<S2SV> tptr += 1 + chassis_id_length ; //<S2SV> tlen -= 1 + chassis_id_length ; //<S2SV> } //<S2SV> if ( cfm_tlv_len == 0 ) { //<S2SV> break ; //<S2SV> } //<S2SV> mgmt_addr_length = * tptr ; //<S2SV> tptr ++ ; //<S2SV> tlen -- ; //<S2SV> cfm_tlv_len -- ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u" , mgmt_addr_length ) ) ; //<S2SV> if ( mgmt_addr_length ) { //<S2SV> if ( cfm_tlv_len < mgmt_addr_length ) { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)" ) ) ; //<S2SV> goto next_tlv ; //<S2SV> } //<S2SV> cfm_tlv_len -= mgmt_addr_length ; //<S2SV> hex_print ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>" , tptr , mgmt_addr_length ) ; //<S2SV> tptr += mgmt_addr_length ; //<S2SV> tlen -= mgmt_addr_length ; //<S2SV> if ( cfm_tlv_len < 1 ) { //<S2SV> ND_PRINT ( ( ndo , "<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)" ) ) ; //<S2SV> hexdump = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> mgmt_addr_length = * tptr ; //<S2SV> tptr ++ ; //<S2SV> tlen -- ; //<S2SV> cfm_tlv_len -- ; //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u" , mgmt_addr_length ) ) ; //<S2SV> if ( mgmt_addr_length ) { //<S2SV> if ( cfm_tlv_len < mgmt_addr_length ) { //<S2SV> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>(TLV<S2SV_blank>too<S2SV_blank>short)" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> cfm_tlv_len -= mgmt_addr_length ; //<S2SV> hex_print ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>" , tptr , mgmt_addr_length ) ; //<S2SV> tptr += mgmt_addr_length ; //<S2SV> tlen -= mgmt_addr_length ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case CFM_TLV_DATA : //<S2SV> case CFM_TLV_REPLY_INGRESS : //<S2SV> case CFM_TLV_REPLY_EGRESS : //<S2SV> default : //<S2SV> hexdump = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( hexdump || ndo -> ndo_vflag > 1 ) //<S2SV> print_unknown_data ( ndo , tlv_ptr , "\\n\\t<S2SV_blank><S2SV_blank>" , cfm_tlv_len ) ; //<S2SV> next_tlv : //<S2SV> tptr += cfm_tlv_len ; //<S2SV> tlen -= cfm_tlv_len ; //<S2SV> } //<S2SV> return ; //<S2SV> tooshort : //<S2SV> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short" ) ) ; //<S2SV> return ; //<S2SV> trunc : //<S2SV> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; //<S2SV> } //<S2SV> 