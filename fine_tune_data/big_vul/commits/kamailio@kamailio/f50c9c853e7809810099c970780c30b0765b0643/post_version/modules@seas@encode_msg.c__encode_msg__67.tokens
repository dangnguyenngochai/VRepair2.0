int encode_msg ( struct sip_msg * msg , char * payload , int len ) //<S2SV> { //<S2SV> int i , j , k , u , request ; //<S2SV> unsigned short int h ; //<S2SV> struct hdr_field * hf ; //<S2SV> struct msg_start * ms ; //<S2SV> struct sip_uri miuri ; //<S2SV> char * myerror = NULL ; //<S2SV> ptrdiff_t diff ; //<S2SV> if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) //<S2SV> return - 1 ; //<S2SV> if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) { //<S2SV> myerror = "in<S2SV_blank>parse_headers" ; //<S2SV> goto error ; //<S2SV> } //<S2SV> memset ( payload , 0 , len ) ; //<S2SV> ms = & msg -> first_line ; //<S2SV> if ( ms -> type == SIP_REQUEST ) //<S2SV> request = 1 ; //<S2SV> else if ( ms -> type == SIP_REPLY ) //<S2SV> request = 0 ; //<S2SV> else { //<S2SV> myerror = "message<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>request<S2SV_blank>nor<S2SV_blank>response" ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( request ) { //<S2SV> for ( h = 0 ; h < 32 ; j = ( 0x01 << h ) , h ++ ) //<S2SV> if ( j & ms -> u . request . method_value ) //<S2SV> break ; //<S2SV> } else { //<S2SV> h = ( unsigned short ) ( ms -> u . reply . statuscode ) ; //<S2SV> } //<S2SV> if ( h == 32 ) { //<S2SV> myerror = "unknown<S2SV_blank>message<S2SV_blank>type\\n" ; //<S2SV> goto error ; //<S2SV> } //<S2SV> h = htons ( h ) ; //<S2SV> memcpy ( payload , & h , 2 ) ; //<S2SV> h = htons ( ( unsigned short int ) msg -> len ) ; //<S2SV> memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ; //<S2SV> if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) { //<S2SV> myerror = "body<S2SV_blank>starts<S2SV_blank>before<S2SV_blank>the<S2SV_blank>message<S2SV_blank>(uh<S2SV_blank>?)" ; //<S2SV> goto error ; //<S2SV> } else //<S2SV> h = htons ( ( unsigned short int ) diff ) ; //<S2SV> memcpy ( payload + CONTENT_IDX , & h , 2 ) ; //<S2SV> payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? //<S2SV> ( ms -> u . request . method . s - msg -> buf ) : //<S2SV> ( ms -> u . reply . status . s - msg -> buf ) ) ; //<S2SV> payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? //<S2SV> ( ms -> u . request . method . len ) : //<S2SV> ( ms -> u . reply . status . len ) ) ; //<S2SV> payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? //<S2SV> ( ms -> u . request . uri . s - msg -> buf ) : //<S2SV> ( ms -> u . reply . reason . s - msg -> buf ) ) ; //<S2SV> payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? //<S2SV> ( ms -> u . request . uri . len ) : //<S2SV> ( ms -> u . reply . reason . len ) ) ; //<S2SV> payload [ VERSION_IDX ] = ( unsigned char ) ( request ? //<S2SV> ( ms -> u . request . version . s - msg -> buf ) : //<S2SV> ( ms -> u . reply . version . s - msg -> buf ) ) ; //<S2SV> if ( request ) { //<S2SV> if ( parse_uri ( ms -> u . request . uri . s , ms -> u . request . uri . len , & miuri ) < 0 ) { //<S2SV> LM_ERR ( "<%.*s>\\n" , ms -> u . request . uri . len , ms -> u . request . uri . s ) ; //<S2SV> myerror = "while<S2SV_blank>parsing<S2SV_blank>the<S2SV_blank>R-URI" ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( 0 > ( j = encode_uri2 ( msg -> buf , //<S2SV> ms -> u . request . method . s - msg -> buf + ms -> len , //<S2SV> ms -> u . request . uri , & miuri , //<S2SV> ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) //<S2SV> { //<S2SV> myerror = "ENCODE_MSG:<S2SV_blank>ERROR<S2SV_blank>while<S2SV_blank>encoding<S2SV_blank>the<S2SV_blank>R-URI" ; //<S2SV> goto error ; //<S2SV> } //<S2SV> payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ; //<S2SV> k = REQUEST_URI_IDX + 1 + j ; //<S2SV> } else //<S2SV> k = REQUEST_URI_IDX ; //<S2SV> u = k ; //<S2SV> k ++ ; //<S2SV> for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , i ++ ) ; //<S2SV> i ++ ; //<S2SV> j = k + 3 * i ; //<S2SV> for ( i = 0 , hf = msg -> headers ; hf ; hf = hf -> next , k += 3 ) { //<S2SV> payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ; //<S2SV> h = htons ( j ) ; //<S2SV> memcpy ( & payload [ k + 1 ] , & h , 2 ) ; //<S2SV> if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) { //<S2SV> LM_ERR ( "encoding<S2SV_blank>header<S2SV_blank>%.*s\\n" , hf -> name . len , hf -> name . s ) ; //<S2SV> goto error ; //<S2SV> k -= 3 ; //<S2SV> continue ; //<S2SV> } //<S2SV> j += ( unsigned short int ) i ; //<S2SV> } //<S2SV> payload [ u ] = ( unsigned char ) ( ( k - u - 1 ) / 3 ) ; //<S2SV> j = htons ( j ) ; //<S2SV> memcpy ( & payload [ k + 1 ] , & j , 2 ) ; //<S2SV> k += 3 ; //<S2SV> j = ntohs ( j ) ; //<S2SV> if ( len < j + msg -> len + 1 ) { //<S2SV> LM_ERR ( "not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ; //<S2SV> LM_DBG ( "msglen<S2SV_blank>=<S2SV_blank>%d,msg<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n" , msg -> len , j ) ; //<S2SV> j = htons ( j ) ; //<S2SV> memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ; //<S2SV> return GET_PAY_SIZE ( payload ) ; //<S2SV> error : //<S2SV> LM_ERR ( "%s\\n" , myerror ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> 