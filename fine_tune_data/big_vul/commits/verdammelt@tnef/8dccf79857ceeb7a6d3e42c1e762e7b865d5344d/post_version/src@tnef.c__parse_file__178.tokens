int //<S2SV> parse_file ( FILE * input_file , char * directory , //<S2SV> char * body_filename , char * body_pref , //<S2SV> int flags ) //<S2SV> { //<S2SV> uint32 d ; //<S2SV> uint16 key ; //<S2SV> Attr * attr = NULL ; //<S2SV> File * file = NULL ; //<S2SV> int rtf_size = 0 , html_size = 0 ; //<S2SV> MessageBody body ; //<S2SV> memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; //<S2SV> g_flags = flags ; //<S2SV> d = geti32 ( input_file ) ; //<S2SV> if ( d != TNEF_SIGNATURE ) //<S2SV> { //<S2SV> fprintf ( stdout , "Seems<S2SV_blank>not<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>TNEF<S2SV_blank>file\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> key = geti16 ( input_file ) ; //<S2SV> debug_print ( "TNEF<S2SV_blank>Key:<S2SV_blank>%hx\\n" , key ) ; //<S2SV> while ( data_left ( input_file ) ) //<S2SV> { //<S2SV> attr = read_object ( input_file ) ; //<S2SV> if ( attr == NULL ) break ; //<S2SV> if ( attr -> name == attATTACHRENDDATA ) //<S2SV> { //<S2SV> if ( file ) //<S2SV> { //<S2SV> file_write ( file , directory ) ; //<S2SV> file_free ( file ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> file = CHECKED_XCALLOC ( File , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> switch ( attr -> lvl_type ) //<S2SV> { //<S2SV> case LVL_MESSAGE : //<S2SV> if ( attr -> name == attBODY ) //<S2SV> { //<S2SV> body . text_body = get_text_data ( attr ) ; //<S2SV> } //<S2SV> else if ( attr -> name == attMAPIPROPS ) //<S2SV> { //<S2SV> MAPI_Attr * * mapi_attrs //<S2SV> = mapi_attr_read ( attr -> len , attr -> buf ) ; //<S2SV> if ( mapi_attrs ) //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) //<S2SV> { //<S2SV> MAPI_Attr * a = mapi_attrs [ i ] ; //<S2SV> if ( a -> type == szMAPI_BINARY && a -> name == MAPI_BODY_HTML ) //<S2SV> { //<S2SV> body . html_bodies = get_html_data ( a ) ; //<S2SV> html_size = a -> num_values ; //<S2SV> } //<S2SV> else if ( a -> type == szMAPI_BINARY && a -> name == MAPI_RTF_COMPRESSED ) //<S2SV> { //<S2SV> body . rtf_bodies = get_rtf_data ( a ) ; //<S2SV> rtf_size = a -> num_values ; //<S2SV> } //<S2SV> } //<S2SV> mapi_attr_free_list ( mapi_attrs ) ; //<S2SV> XFREE ( mapi_attrs ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case LVL_ATTACHMENT : //<S2SV> file_add_attr ( file , attr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> fprintf ( stderr , "Invalid<S2SV_blank>lvl<S2SV_blank>type<S2SV_blank>on<S2SV_blank>attribute:<S2SV_blank>%d\\n" , //<S2SV> attr -> lvl_type ) ; //<S2SV> return 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> attr_free ( attr ) ; //<S2SV> XFREE ( attr ) ; //<S2SV> } //<S2SV> if ( file ) //<S2SV> { //<S2SV> file_write ( file , directory ) ; //<S2SV> file_free ( file ) ; //<S2SV> XFREE ( file ) ; //<S2SV> } //<S2SV> if ( flags & SAVEBODY ) //<S2SV> { //<S2SV> int i = 0 ; //<S2SV> int all_flag = 0 ; //<S2SV> if ( strcmp ( body_pref , "all" ) == 0 ) //<S2SV> { //<S2SV> all_flag = 1 ; //<S2SV> body_pref = "rht" ; //<S2SV> } //<S2SV> for ( ; i < 3 ; i ++ ) //<S2SV> { //<S2SV> File * * files //<S2SV> = get_body_files ( body_filename , body_pref [ i ] , & body ) ; //<S2SV> if ( files ) //<S2SV> { //<S2SV> int j = 0 ; //<S2SV> for ( ; files [ j ] ; j ++ ) //<S2SV> { //<S2SV> file_write ( files [ j ] , directory ) ; //<S2SV> file_free ( files [ j ] ) ; //<S2SV> XFREE ( files [ j ] ) ; //<S2SV> } //<S2SV> XFREE ( files ) ; //<S2SV> if ( ! all_flag ) break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( body . text_body ) //<S2SV> { //<S2SV> free_bodies ( body . text_body , 1 ) ; //<S2SV> XFREE ( body . text_body ) ; //<S2SV> } //<S2SV> if ( rtf_size > 0 ) //<S2SV> { //<S2SV> free_bodies ( body . rtf_bodies , rtf_size ) ; //<S2SV> XFREE ( body . rtf_bodies ) ; //<S2SV> } //<S2SV> if ( html_size > 0 ) //<S2SV> { //<S2SV> free_bodies ( body . html_bodies , html_size ) ; //<S2SV> XFREE ( body . html_bodies ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 