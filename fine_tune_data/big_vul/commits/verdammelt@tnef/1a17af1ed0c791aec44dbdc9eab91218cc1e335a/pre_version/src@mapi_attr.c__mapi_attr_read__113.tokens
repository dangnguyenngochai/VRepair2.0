MAPI_Attr * * //<S2SV> mapi_attr_read ( size_t len , unsigned char * buf ) //<S2SV> { //<S2SV> size_t idx = 0 ; //<S2SV> uint32 i , j ; //<S2SV> assert ( len > 4 ) ; //<S2SV> uint32 num_properties = GETINT32 ( buf + idx ) ; //<S2SV> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; //<S2SV> idx += 4 ; //<S2SV> if ( ! attrs ) return NULL ; //<S2SV> for ( i = 0 ; i < num_properties ; i ++ ) //<S2SV> { //<S2SV> MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; //<S2SV> MAPI_Value * v = NULL ; //<S2SV> CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; //<S2SV> CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; //<S2SV> if ( a -> name & GUID_EXISTS_FLAG ) //<S2SV> { //<S2SV> a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; //<S2SV> copy_guid_from_buf ( a -> guid , buf + idx , len ) ; //<S2SV> idx += sizeof ( GUID ) ; //<S2SV> CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; //<S2SV> if ( a -> num_names > 0 ) //<S2SV> { //<S2SV> size_t i ; //<S2SV> a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; //<S2SV> for ( i = 0 ; i < a -> num_names ; i ++ ) //<S2SV> { //<S2SV> size_t j ; //<S2SV> CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; //<S2SV> a -> names [ i ] . data //<S2SV> = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; //<S2SV> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) //<S2SV> a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; //<S2SV> idx += pad_to_4byte ( a -> names [ i ] . len ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; //<S2SV> } //<S2SV> } //<S2SV> if ( a -> type & MULTI_VALUE_FLAG || //<S2SV> a -> type == szMAPI_STRING || //<S2SV> a -> type == szMAPI_UNICODE_STRING || //<S2SV> a -> type == szMAPI_OBJECT || //<S2SV> a -> type == szMAPI_BINARY ) //<S2SV> { //<S2SV> CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; //<S2SV> idx += 4 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> a -> num_values = 1 ; //<S2SV> } //<S2SV> if ( a -> type & MULTI_VALUE_FLAG ) //<S2SV> { //<S2SV> a -> type -= MULTI_VALUE_FLAG ; //<S2SV> } //<S2SV> v = alloc_mapi_values ( a ) ; //<S2SV> for ( j = 0 ; j < a -> num_values ; j ++ ) //<S2SV> { //<S2SV> switch ( a -> type ) //<S2SV> { //<S2SV> case szMAPI_SHORT : //<S2SV> v -> len = 2 ; //<S2SV> CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; //<S2SV> idx += 4 ; //<S2SV> break ; //<S2SV> case szMAPI_INT : //<S2SV> v -> len = 4 ; //<S2SV> CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; //<S2SV> idx += 4 ; //<S2SV> v ++ ; //<S2SV> break ; //<S2SV> case szMAPI_FLOAT : //<S2SV> case szMAPI_BOOLEAN : //<S2SV> v -> len = 4 ; //<S2SV> CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; //<S2SV> idx += v -> len ; //<S2SV> break ; //<S2SV> case szMAPI_SYSTIME : //<S2SV> v -> len = 8 ; //<S2SV> CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; //<S2SV> CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; //<S2SV> idx += 8 ; //<S2SV> v ++ ; //<S2SV> break ; //<S2SV> case szMAPI_DOUBLE : //<S2SV> case szMAPI_APPTIME : //<S2SV> case szMAPI_CURRENCY : //<S2SV> case szMAPI_INT8BYTE : //<S2SV> v -> len = 8 ; //<S2SV> CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; //<S2SV> CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; //<S2SV> idx += v -> len ; //<S2SV> break ; //<S2SV> case szMAPI_CLSID : //<S2SV> v -> len = sizeof ( GUID ) ; //<S2SV> copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; //<S2SV> idx += v -> len ; //<S2SV> break ; //<S2SV> case szMAPI_STRING : //<S2SV> case szMAPI_UNICODE_STRING : //<S2SV> case szMAPI_OBJECT : //<S2SV> case szMAPI_BINARY : //<S2SV> CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ; //<S2SV> if ( a -> type == szMAPI_UNICODE_STRING ) //<S2SV> { //<S2SV> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; //<S2SV> memmove ( v -> data . buf , buf + idx , v -> len ) ; //<S2SV> } //<S2SV> idx += pad_to_4byte ( v -> len ) ; //<S2SV> v ++ ; //<S2SV> break ; //<S2SV> case szMAPI_NULL : //<S2SV> case szMAPI_ERROR : //<S2SV> case szMAPI_UNSPECIFIED : //<S2SV> fprintf ( stderr , //<S2SV> "Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n" ) ; //<S2SV> if ( ! ENCODE_SKIP ) exit ( 1 ) ; //<S2SV> return NULL ; //<S2SV> default : //<S2SV> fprintf ( stderr , //<S2SV> "Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n" ) ; //<S2SV> if ( ! ENCODE_SKIP ) exit ( 1 ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> attrs [ i ] = NULL ; //<S2SV> return attrs ; //<S2SV> } //<S2SV> 