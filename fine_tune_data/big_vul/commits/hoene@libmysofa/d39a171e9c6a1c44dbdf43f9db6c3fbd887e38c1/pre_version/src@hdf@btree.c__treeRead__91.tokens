int treeRead ( struct READER * reader , struct DATAOBJECT * data ) { //<S2SV> int i , j , err , olen , elements , size , x , y , z , b , e , dy , dz , sx , sy , sz , dzy , //<S2SV> szy ; //<S2SV> char * input , * output ; //<S2SV> uint8_t node_type , node_level ; //<S2SV> uint16_t entries_used ; //<S2SV> uint32_t size_of_chunk ; //<S2SV> uint32_t filter_mask ; //<S2SV> uint64_t address_of_left_sibling , address_of_right_sibling , start [ 4 ] , //<S2SV> child_pointer , key , store ; //<S2SV> char buf [ 4 ] ; //<S2SV> UNUSED ( node_level ) ; //<S2SV> UNUSED ( address_of_right_sibling ) ; //<S2SV> UNUSED ( address_of_left_sibling ) ; //<S2SV> UNUSED ( key ) ; //<S2SV> if ( data -> ds . dimensionality > 3 ) { //<S2SV> log ( "TREE<S2SV_blank>dimensions<S2SV_blank>><S2SV_blank>3" ) ; //<S2SV> return MYSOFA_INVALID_FORMAT ; //<S2SV> } //<S2SV> if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , "TREE" , 4 ) ) { //<S2SV> log ( "cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>TREE\\n" ) ; //<S2SV> return MYSOFA_INVALID_FORMAT ; //<S2SV> } log ( "%08lX<S2SV_blank>%.4s\\n" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; //<S2SV> node_type = ( uint8_t ) fgetc ( reader -> fhd ) ; //<S2SV> node_level = ( uint8_t ) fgetc ( reader -> fhd ) ; //<S2SV> entries_used = ( uint16_t ) readValue ( reader , 2 ) ; //<S2SV> if ( entries_used > 0x1000 ) //<S2SV> return MYSOFA_UNSUPPORTED_FORMAT ; //<S2SV> address_of_left_sibling = readValue ( reader , //<S2SV> reader -> superblock . size_of_offsets ) ; //<S2SV> address_of_right_sibling = readValue ( reader , //<S2SV> reader -> superblock . size_of_offsets ) ; //<S2SV> elements = 1 ; //<S2SV> for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) //<S2SV> elements *= data -> datalayout_chunk [ j ] ; //<S2SV> dy = data -> datalayout_chunk [ 1 ] ; //<S2SV> dz = data -> datalayout_chunk [ 2 ] ; //<S2SV> sx = data -> ds . dimension_size [ 0 ] ; //<S2SV> sy = data -> ds . dimension_size [ 1 ] ; //<S2SV> sz = data -> ds . dimension_size [ 2 ] ; //<S2SV> dzy = dz * dy ; //<S2SV> szy = sz * sy ; //<S2SV> size = data -> datalayout_chunk [ data -> ds . dimensionality ] ; //<S2SV> log ( "elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\n" , elements , size ) ; //<S2SV> if ( ! ( output = malloc ( elements * size ) ) ) { //<S2SV> return MYSOFA_NO_MEMORY ; //<S2SV> } //<S2SV> for ( e = 0 ; e < entries_used * 2 ; e ++ ) { //<S2SV> if ( node_type == 0 ) { //<S2SV> key = readValue ( reader , reader -> superblock . size_of_lengths ) ; //<S2SV> } else { //<S2SV> size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ; //<S2SV> filter_mask = ( uint32_t ) readValue ( reader , 4 ) ; //<S2SV> if ( filter_mask ) { //<S2SV> log ( "TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\n" ) ; //<S2SV> free ( output ) ; //<S2SV> return MYSOFA_INVALID_FORMAT ; //<S2SV> } //<S2SV> for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) { //<S2SV> start [ j ] = readValue ( reader , 8 ) ; //<S2SV> log ( "start<S2SV_blank>%d<S2SV_blank>%lu\\n" , j , start [ j ] ) ; //<S2SV> } //<S2SV> if ( readValue ( reader , 8 ) ) { //<S2SV> break ; //<S2SV> } //<S2SV> child_pointer = readValue ( reader , //<S2SV> reader -> superblock . size_of_offsets ) ; //<S2SV> log ( "<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\n" , child_pointer , size_of_chunk ) ; //<S2SV> store = ftell ( reader -> fhd ) ; //<S2SV> if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) { //<S2SV> free ( output ) ; //<S2SV> return errno ; //<S2SV> } //<S2SV> if ( ! ( input = malloc ( size_of_chunk ) ) ) { //<S2SV> free ( output ) ; //<S2SV> return MYSOFA_NO_MEMORY ; //<S2SV> } //<S2SV> if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) { //<S2SV> free ( output ) ; //<S2SV> free ( input ) ; //<S2SV> return MYSOFA_INVALID_FORMAT ; //<S2SV> } //<S2SV> olen = elements * size ; //<S2SV> err = gunzip ( size_of_chunk , input , & olen , output ) ; //<S2SV> free ( input ) ; //<S2SV> log ( "<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\n" , err , olen , elements * size ) ; //<S2SV> if ( err || olen != elements * size ) { //<S2SV> free ( output ) ; //<S2SV> return MYSOFA_INVALID_FORMAT ; //<S2SV> } //<S2SV> switch ( data -> ds . dimensionality ) { //<S2SV> case 1 : //<S2SV> for ( i = 0 ; i < olen ; i ++ ) { //<S2SV> b = i / elements ; //<S2SV> x = i % elements + start [ 0 ] ; //<S2SV> if ( x < sx ) { //<S2SV> j = x * size + b ; //<S2SV> ( ( char * ) data -> data ) [ j ] = output [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 2 : //<S2SV> for ( i = 0 ; i < olen ; i ++ ) { //<S2SV> b = i / elements ; //<S2SV> x = i % elements ; //<S2SV> y = x % dy + start [ 1 ] ; //<S2SV> x = x / dy + start [ 0 ] ; //<S2SV> if ( y < sy && x < sx ) { //<S2SV> j = ( ( x * sy + y ) * size ) + b ; //<S2SV> ( ( char * ) data -> data ) [ j ] = output [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 3 : //<S2SV> for ( i = 0 ; i < olen ; i ++ ) { //<S2SV> b = i / elements ; //<S2SV> x = i % elements ; //<S2SV> z = x % dz + start [ 2 ] ; //<S2SV> y = ( x / dz ) % dy + start [ 1 ] ; //<S2SV> x = ( x / dzy ) + start [ 0 ] ; //<S2SV> if ( z < sz && y < sy && x < sx ) { //<S2SV> j = ( x * szy + y * sz + z ) * size + b ; //<S2SV> ( ( char * ) data -> data ) [ j ] = output [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> log ( "invalid<S2SV_blank>dim\\n" ) ; //<S2SV> return MYSOFA_INTERNAL_ERROR ; //<S2SV> } //<S2SV> if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) { //<S2SV> free ( output ) ; //<S2SV> return errno ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> free ( output ) ; //<S2SV> if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) < 0 ) //<S2SV> return errno ; //<S2SV> return MYSOFA_OK ; //<S2SV> } //<S2SV> 