static int b_unpack ( lua_State * L ) { //<S2SV> Header h ; //<S2SV> const char * fmt = luaL_checkstring ( L , 1 ) ; //<S2SV> size_t ld ; //<S2SV> const char * data = luaL_checklstring ( L , 2 , & ld ) ; //<S2SV> size_t pos = luaL_optinteger ( L , 3 , 1 ) ; //<S2SV> luaL_argcheck ( L , pos > 0 , 3 , "offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater" ) ; //<S2SV> pos -- ; //<S2SV> int n = 0 ; //<S2SV> defaultoptions ( & h ) ; //<S2SV> while ( * fmt ) { //<S2SV> int opt = * fmt ++ ; //<S2SV> size_t size = optsize ( L , opt , & fmt ) ; //<S2SV> pos += gettoalign ( pos , & h , opt , size ) ; //<S2SV> luaL_argcheck ( L , size <= ld && pos <= ld - size , //<S2SV> 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; //<S2SV> luaL_checkstack ( L , 2 , "too<S2SV_blank>many<S2SV_blank>results" ) ; //<S2SV> switch ( opt ) { //<S2SV> case 'b' : case 'B' : case 'h' : case 'H' : //<S2SV> case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { //<S2SV> int issigned = islower ( opt ) ; //<S2SV> lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; //<S2SV> lua_pushnumber ( L , res ) ; n ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'x' : { //<S2SV> break ; //<S2SV> } //<S2SV> case 'f' : { //<S2SV> float f ; //<S2SV> memcpy ( & f , data + pos , size ) ; //<S2SV> correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; //<S2SV> lua_pushnumber ( L , f ) ; n ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'd' : { //<S2SV> double d ; //<S2SV> memcpy ( & d , data + pos , size ) ; //<S2SV> correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; //<S2SV> lua_pushnumber ( L , d ) ; n ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> case 'c' : { //<S2SV> if ( size == 0 ) { //<S2SV> if ( n == 0 || ! lua_isnumber ( L , - 1 ) ) //<S2SV> luaL_error ( L , "format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" ) ; //<S2SV> size = lua_tonumber ( L , - 1 ) ; //<S2SV> lua_pop ( L , 1 ) ; n -- ; //<S2SV> luaL_argcheck ( L , size <= ld && pos <= ld - size , //<S2SV> 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; //<S2SV> } //<S2SV> lua_pushlstring ( L , data + pos , size ) ; n ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> case 's' : { //<S2SV> const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; //<S2SV> if ( e == NULL ) //<S2SV> luaL_error ( L , "unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data" ) ; //<S2SV> size = ( e - ( data + pos ) ) + 1 ; //<S2SV> lua_pushlstring ( L , data + pos , size - 1 ) ; n ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> default : controloptions ( L , opt , & fmt , & h ) ; //<S2SV> } //<S2SV> pos += size ; //<S2SV> } //<S2SV> lua_pushinteger ( L , pos + 1 ) ; //<S2SV> return n + 1 ; //<S2SV> } //<S2SV> 