void configSetCommand ( client * c ) { //<S2SV> robj * o ; //<S2SV> long long ll ; //<S2SV> int err ; //<S2SV> serverAssertWithInfo ( c , c -> argv [ 2 ] , sdsEncodedObject ( c -> argv [ 2 ] ) ) ; //<S2SV> serverAssertWithInfo ( c , c -> argv [ 3 ] , sdsEncodedObject ( c -> argv [ 3 ] ) ) ; //<S2SV> o = c -> argv [ 3 ] ; //<S2SV> if ( 0 ) { //<S2SV> config_set_special_field ( "dbfilename" ) { //<S2SV> if ( ! pathIsBaseName ( o -> ptr ) ) { //<S2SV> addReplyError ( c , "dbfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> zfree ( server . rdb_filename ) ; //<S2SV> server . rdb_filename = zstrdup ( o -> ptr ) ; //<S2SV> } config_set_special_field ( "requirepass" ) { //<S2SV> if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ; //<S2SV> zfree ( server . requirepass ) ; //<S2SV> server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; //<S2SV> } config_set_special_field ( "masterauth" ) { //<S2SV> zfree ( server . masterauth ) ; //<S2SV> server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; //<S2SV> } config_set_special_field ( "cluster-announce-ip" ) { //<S2SV> zfree ( server . cluster_announce_ip ) ; //<S2SV> server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; //<S2SV> } config_set_special_field ( "maxclients" ) { //<S2SV> int orig_value = server . maxclients ; //<S2SV> if ( getLongLongFromObject ( o , & ll ) == C_ERR || ll < 1 ) goto badfmt ; //<S2SV> server . maxclients = ll ; //<S2SV> if ( ll > orig_value ) { //<S2SV> adjustOpenFilesLimit ( ) ; //<S2SV> if ( server . maxclients != ll ) { //<S2SV> addReplyErrorFormat ( c , "The<S2SV_blank>operating<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients,<S2SV_blank>try<S2SV_blank>with<S2SV_blank>%d" , server . maxclients ) ; //<S2SV> server . maxclients = orig_value ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ( unsigned int ) aeGetSetSize ( server . el ) < //<S2SV> server . maxclients + CONFIG_FDSET_INCR ) //<S2SV> { //<S2SV> if ( aeResizeSetSize ( server . el , //<S2SV> server . maxclients + CONFIG_FDSET_INCR ) == AE_ERR ) //<S2SV> { //<S2SV> addReplyError ( c , "The<S2SV_blank>event<S2SV_blank>loop<S2SV_blank>API<S2SV_blank>used<S2SV_blank>by<S2SV_blank>Redis<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients" ) ; //<S2SV> server . maxclients = orig_value ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } config_set_special_field ( "appendonly" ) { //<S2SV> int enable = yesnotoi ( o -> ptr ) ; //<S2SV> if ( enable == - 1 ) goto badfmt ; //<S2SV> if ( enable == 0 && server . aof_state != AOF_OFF ) { //<S2SV> stopAppendOnly ( ) ; //<S2SV> } else if ( enable && server . aof_state == AOF_OFF ) { //<S2SV> if ( startAppendOnly ( ) == C_ERR ) { //<S2SV> addReplyError ( c , //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>on<S2SV_blank>AOF.<S2SV_blank>Check<S2SV_blank>server<S2SV_blank>logs." ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> } config_set_special_field ( "save" ) { //<S2SV> int vlen , j ; //<S2SV> sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , "<S2SV_blank>" , 1 , & vlen ) ; //<S2SV> if ( vlen & 1 ) { //<S2SV> sdsfreesplitres ( v , vlen ) ; //<S2SV> goto badfmt ; //<S2SV> } //<S2SV> for ( j = 0 ; j < vlen ; j ++ ) { //<S2SV> char * eptr ; //<S2SV> long val ; //<S2SV> val = strtoll ( v [ j ] , & eptr , 10 ) ; //<S2SV> if ( eptr [ 0 ] != '\\0' || //<S2SV> ( ( j & 1 ) == 0 && val < 1 ) || //<S2SV> ( ( j & 1 ) == 1 && val < 0 ) ) { //<S2SV> sdsfreesplitres ( v , vlen ) ; //<S2SV> goto badfmt ; //<S2SV> } //<S2SV> } //<S2SV> resetServerSaveParams ( ) ; //<S2SV> for ( j = 0 ; j < vlen ; j += 2 ) { //<S2SV> time_t seconds ; //<S2SV> int changes ; //<S2SV> seconds = strtoll ( v [ j ] , NULL , 10 ) ; //<S2SV> changes = strtoll ( v [ j + 1 ] , NULL , 10 ) ; //<S2SV> appendServerSaveParams ( seconds , changes ) ; //<S2SV> } //<S2SV> sdsfreesplitres ( v , vlen ) ; //<S2SV> } config_set_special_field ( "dir" ) { //<S2SV> if ( chdir ( ( char * ) o -> ptr ) == - 1 ) { //<S2SV> addReplyErrorFormat ( c , "Changing<S2SV_blank>directory:<S2SV_blank>%s" , strerror ( errno ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } config_set_special_field ( "client-output-buffer-limit" ) { //<S2SV> int vlen , j ; //<S2SV> sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , "<S2SV_blank>" , 1 , & vlen ) ; //<S2SV> if ( vlen % 4 ) { //<S2SV> sdsfreesplitres ( v , vlen ) ; //<S2SV> goto badfmt ; //<S2SV> } //<S2SV> for ( j = 0 ; j < vlen ; j ++ ) { //<S2SV> long val ; //<S2SV> if ( ( j % 4 ) == 0 ) { //<S2SV> int class = getClientTypeByName ( v [ j ] ) ; //<S2SV> if ( class == - 1 || class == CLIENT_TYPE_MASTER ) { //<S2SV> sdsfreesplitres ( v , vlen ) ; //<S2SV> goto badfmt ; //<S2SV> } //<S2SV> } else { //<S2SV> val = memtoll ( v [ j ] , & err ) ; //<S2SV> if ( err || val < 0 ) { //<S2SV> sdsfreesplitres ( v , vlen ) ; //<S2SV> goto badfmt ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( j = 0 ; j < vlen ; j += 4 ) { //<S2SV> int class ; //<S2SV> unsigned long long hard , soft ; //<S2SV> int soft_seconds ; //<S2SV> class = getClientTypeByName ( v [ j ] ) ; //<S2SV> hard = strtoll ( v [ j + 1 ] , NULL , 10 ) ; //<S2SV> soft = strtoll ( v [ j + 2 ] , NULL , 10 ) ; //<S2SV> soft_seconds = strtoll ( v [ j + 3 ] , NULL , 10 ) ; //<S2SV> server . client_obuf_limits [ class ] . hard_limit_bytes = hard ; //<S2SV> server . client_obuf_limits [ class ] . soft_limit_bytes = soft ; //<S2SV> server . client_obuf_limits [ class ] . soft_limit_seconds = soft_seconds ; //<S2SV> } //<S2SV> sdsfreesplitres ( v , vlen ) ; //<S2SV> } config_set_special_field ( "notify-keyspace-events" ) { //<S2SV> int flags = keyspaceEventsStringToFlags ( o -> ptr ) ; //<S2SV> if ( flags == - 1 ) goto badfmt ; //<S2SV> server . notify_keyspace_events = flags ; //<S2SV> } config_set_special_field ( "slave-announce-ip" ) { //<S2SV> zfree ( server . slave_announce_ip ) ; //<S2SV> server . slave_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; //<S2SV> } config_set_bool_field ( //<S2SV> "rdbcompression" , server . rdb_compression ) { //<S2SV> } config_set_bool_field ( //<S2SV> "repl-disable-tcp-nodelay" , server . repl_disable_tcp_nodelay ) { //<S2SV> } config_set_bool_field ( //<S2SV> "repl-diskless-sync" , server . repl_diskless_sync ) { //<S2SV> } config_set_bool_field ( //<S2SV> "cluster-require-full-coverage" , server . cluster_require_full_coverage ) { //<S2SV> } config_set_bool_field ( //<S2SV> "aof-rewrite-incremental-fsync" , server . aof_rewrite_incremental_fsync ) { //<S2SV> } config_set_bool_field ( //<S2SV> "aof-load-truncated" , server . aof_load_truncated ) { //<S2SV> } config_set_bool_field ( //<S2SV> "aof-use-rdb-preamble" , server . aof_use_rdb_preamble ) { //<S2SV> } config_set_bool_field ( //<S2SV> "slave-serve-stale-data" , server . repl_serve_stale_data ) { //<S2SV> } config_set_bool_field ( //<S2SV> "slave-read-only" , server . repl_slave_ro ) { //<S2SV> } config_set_bool_field ( //<S2SV> "activerehashing" , server . activerehashing ) { //<S2SV> } config_set_bool_field ( //<S2SV> "protected-mode" , server . protected_mode ) { //<S2SV> } config_set_bool_field ( //<S2SV> "stop-writes-on-bgsave-error" , server . stop_writes_on_bgsave_err ) { //<S2SV> } config_set_bool_field ( //<S2SV> "lazyfree-lazy-eviction" , server . lazyfree_lazy_eviction ) { //<S2SV> } config_set_bool_field ( //<S2SV> "lazyfree-lazy-expire" , server . lazyfree_lazy_expire ) { //<S2SV> } config_set_bool_field ( //<S2SV> "lazyfree-lazy-server-del" , server . lazyfree_lazy_server_del ) { //<S2SV> } config_set_bool_field ( //<S2SV> "slave-lazy-flush" , server . repl_slave_lazy_flush ) { //<S2SV> } config_set_bool_field ( //<S2SV> "no-appendfsync-on-rewrite" , server . aof_no_fsync_on_rewrite ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "tcp-keepalive" , server . tcpkeepalive , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "maxmemory-samples" , server . maxmemory_samples , 1 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "lfu-log-factor" , server . lfu_log_factor , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "lfu-decay-time" , server . lfu_decay_time , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "timeout" , server . maxidletime , 0 , LONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "auto-aof-rewrite-percentage" , server . aof_rewrite_perc , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "auto-aof-rewrite-min-size" , server . aof_rewrite_min_size , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "hash-max-ziplist-entries" , server . hash_max_ziplist_entries , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "hash-max-ziplist-value" , server . hash_max_ziplist_value , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "list-max-ziplist-size" , server . list_max_ziplist_size , INT_MIN , INT_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "list-compress-depth" , server . list_compress_depth , 0 , INT_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "set-max-intset-entries" , server . set_max_intset_entries , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "zset-max-ziplist-entries" , server . zset_max_ziplist_entries , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "zset-max-ziplist-value" , server . zset_max_ziplist_value , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "hll-sparse-max-bytes" , server . hll_sparse_max_bytes , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "lua-time-limit" , server . lua_time_limit , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "slowlog-log-slower-than" , server . slowlog_log_slower_than , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "slowlog-max-len" , ll , 0 , LLONG_MAX ) { //<S2SV> server . slowlog_max_len = ( unsigned ) ll ; //<S2SV> } config_set_numerical_field ( //<S2SV> "latency-monitor-threshold" , server . latency_monitor_threshold , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "repl-ping-slave-period" , server . repl_ping_slave_period , 1 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "repl-timeout" , server . repl_timeout , 1 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "repl-backlog-ttl" , server . repl_backlog_time_limit , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "repl-diskless-sync-delay" , server . repl_diskless_sync_delay , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "slave-priority" , server . slave_priority , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "slave-announce-port" , server . slave_announce_port , 0 , 65535 ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "min-slaves-to-write" , server . repl_min_slaves_to_write , 0 , LLONG_MAX ) { //<S2SV> refreshGoodSlavesCount ( ) ; //<S2SV> } config_set_numerical_field ( //<S2SV> "min-slaves-max-lag" , server . repl_min_slaves_max_lag , 0 , LLONG_MAX ) { //<S2SV> refreshGoodSlavesCount ( ) ; //<S2SV> } config_set_numerical_field ( //<S2SV> "cluster-node-timeout" , server . cluster_node_timeout , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "cluster-announce-port" , server . cluster_announce_port , 0 , 65535 ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "cluster-announce-bus-port" , server . cluster_announce_bus_port , 0 , 65535 ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "cluster-migration-barrier" , server . cluster_migration_barrier , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "cluster-slave-validity-factor" , server . cluster_slave_validity_factor , 0 , LLONG_MAX ) { //<S2SV> } config_set_numerical_field ( //<S2SV> "hz" , server . hz , 0 , LLONG_MAX ) { //<S2SV> if ( server . hz < CONFIG_MIN_HZ ) server . hz = CONFIG_MIN_HZ ; //<S2SV> if ( server . hz > CONFIG_MAX_HZ ) server . hz = CONFIG_MAX_HZ ; //<S2SV> } config_set_numerical_field ( //<S2SV> "watchdog-period" , ll , 0 , LLONG_MAX ) { //<S2SV> if ( ll ) //<S2SV> enableWatchdog ( ll ) ; //<S2SV> else //<S2SV> disableWatchdog ( ) ; //<S2SV> } config_set_memory_field ( "maxmemory" , server . maxmemory ) { //<S2SV> if ( server . maxmemory ) { //<S2SV> if ( server . maxmemory < zmalloc_used_memory ( ) ) { //<S2SV> serverLog ( LL_WARNING , "WARNING:<S2SV_blank>the<S2SV_blank>new<S2SV_blank>maxmemory<S2SV_blank>value<S2SV_blank>set<S2SV_blank>via<S2SV_blank>CONFIG<S2SV_blank>SET<S2SV_blank>is<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>the<S2SV_blank>current<S2SV_blank>memory<S2SV_blank>usage.<S2SV_blank>This<S2SV_blank>will<S2SV_blank>result<S2SV_blank>in<S2SV_blank>keys<S2SV_blank>eviction<S2SV_blank>and/or<S2SV_blank>inability<S2SV_blank>to<S2SV_blank>accept<S2SV_blank>new<S2SV_blank>write<S2SV_blank>commands<S2SV_blank>depending<S2SV_blank>on<S2SV_blank>the<S2SV_blank>maxmemory-policy." ) ; //<S2SV> } //<S2SV> freeMemoryIfNeeded ( ) ; //<S2SV> } //<S2SV> } config_set_memory_field ( "repl-backlog-size" , ll ) { //<S2SV> resizeReplicationBacklog ( ll ) ; //<S2SV> } config_set_enum_field ( //<S2SV> "loglevel" , server . verbosity , loglevel_enum ) { //<S2SV> } config_set_enum_field ( //<S2SV> "maxmemory-policy" , server . maxmemory_policy , maxmemory_policy_enum ) { //<S2SV> } config_set_enum_field ( //<S2SV> "appendfsync" , server . aof_fsync , aof_fsync_enum ) { //<S2SV> } config_set_else { //<S2SV> addReplyErrorFormat ( c , "Unsupported<S2SV_blank>CONFIG<S2SV_blank>parameter:<S2SV_blank>%s" , //<S2SV> ( char * ) c -> argv [ 2 ] -> ptr ) ; //<S2SV> return ; //<S2SV> } //<S2SV> addReply ( c , shared . ok ) ; //<S2SV> return ; //<S2SV> badfmt : //<S2SV> addReplyErrorFormat ( c , "Invalid<S2SV_blank>argument<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>CONFIG<S2SV_blank>SET<S2SV_blank>\'%s\'" , //<S2SV> ( char * ) o -> ptr , //<S2SV> ( char * ) c -> argv [ 2 ] -> ptr ) ; //<S2SV> } //<S2SV> 