int mp_unpack_full ( lua_State * L , int limit , int offset ) { //<S2SV> size_t len ; //<S2SV> const char * s ; //<S2SV> mp_cur c ; //<S2SV> int cnt ; //<S2SV> int decode_all = ( ! limit && ! offset ) ; //<S2SV> s = luaL_checklstring ( L , 1 , & len ) ; //<S2SV> if ( offset < 0 || limit < 0 ) //<S2SV> return luaL_error ( L , //<S2SV> "Invalid<S2SV_blank>request<S2SV_blank>to<S2SV_blank>unpack<S2SV_blank>with<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d." , //<S2SV> offset , len ) ; //<S2SV> else if ( offset > len ) //<S2SV> return luaL_error ( L , //<S2SV> "Start<S2SV_blank>offset<S2SV_blank>%d<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>input<S2SV_blank>length<S2SV_blank>%d." , offset , len ) ; //<S2SV> if ( decode_all ) limit = INT_MAX ; //<S2SV> mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; //<S2SV> for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { //<S2SV> mp_decode_to_lua_type ( L , & c ) ; //<S2SV> if ( c . err == MP_CUR_ERROR_EOF ) { //<S2SV> return luaL_error ( L , "Missing<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>input." ) ; //<S2SV> } else if ( c . err == MP_CUR_ERROR_BADFMT ) { //<S2SV> return luaL_error ( L , "Bad<S2SV_blank>data<S2SV_blank>format<S2SV_blank>in<S2SV_blank>input." ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! decode_all ) { //<S2SV> int offset = len - c . left ; //<S2SV> lua_pushinteger ( L , c . left == 0 ? - 1 : offset ) ; //<S2SV> lua_insert ( L , 2 ) ; //<S2SV> cnt += 1 ; //<S2SV> } //<S2SV> return cnt ; //<S2SV> } //<S2SV> 