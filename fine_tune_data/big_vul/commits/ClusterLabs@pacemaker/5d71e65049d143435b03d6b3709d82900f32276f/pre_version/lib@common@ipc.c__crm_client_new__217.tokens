crm_client_t * //<S2SV> crm_client_new ( qb_ipcs_connection_t * c , uid_t uid_client , gid_t gid_client ) //<S2SV> { //<S2SV> static uid_t uid_server = 0 ; //<S2SV> static gid_t gid_cluster = 0 ; //<S2SV> crm_client_t * client = NULL ; //<S2SV> CRM_LOG_ASSERT ( c ) ; //<S2SV> if ( c == NULL ) { //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( gid_cluster == 0 ) { //<S2SV> uid_server = getuid ( ) ; //<S2SV> if ( crm_user_lookup ( CRM_DAEMON_USER , NULL , & gid_cluster ) < 0 ) { //<S2SV> static bool have_error = FALSE ; //<S2SV> if ( have_error == FALSE ) { //<S2SV> crm_warn ( "Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>group<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , CRM_DAEMON_USER ) ; //<S2SV> have_error = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( gid_cluster != 0 && gid_client != 0 ) { //<S2SV> uid_t best_uid = - 1 ; //<S2SV> if ( uid_client == 0 || uid_server == 0 ) { //<S2SV> best_uid = QB_MAX ( uid_client , uid_server ) ; //<S2SV> crm_trace ( "Allowing<S2SV_blank>user<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>clean<S2SV_blank>up<S2SV_blank>after<S2SV_blank>disconnect" , best_uid ) ; //<S2SV> } //<S2SV> crm_trace ( "Giving<S2SV_blank>access<S2SV_blank>to<S2SV_blank>group<S2SV_blank>%u" , gid_cluster ) ; //<S2SV> qb_ipcs_connection_auth_set ( c , best_uid , gid_cluster , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) ; //<S2SV> } //<S2SV> crm_client_init ( ) ; //<S2SV> client = calloc ( 1 , sizeof ( crm_client_t ) ) ; //<S2SV> client -> ipcs = c ; //<S2SV> client -> kind = CRM_CLIENT_IPC ; //<S2SV> client -> pid = crm_ipcs_client_pid ( c ) ; //<S2SV> client -> id = crm_generate_uuid ( ) ; //<S2SV> crm_debug ( "Connecting<S2SV_blank>%p<S2SV_blank>for<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>pid=%u<S2SV_blank>id=%s" , c , uid_client , gid_client , client -> pid , client -> id ) ; //<S2SV> # if ENABLE_ACL //<S2SV> client -> user = uid2username ( uid_client ) ; //<S2SV> # endif //<S2SV> g_hash_table_insert ( client_connections , c , client ) ; //<S2SV> return client ; //<S2SV> } //<S2SV> 