void processRequest ( struct reqelem * req ) //<S2SV> { //<S2SV> ssize_t n ; //<S2SV> unsigned int l , m ; //<S2SV> unsigned char buf [ 2048 ] ; //<S2SV> const unsigned char * p ; //<S2SV> int type ; //<S2SV> struct device * d = devlist ; //<S2SV> unsigned char rbuf [ 4096 ] ; //<S2SV> unsigned char * rp = rbuf + 1 ; //<S2SV> unsigned char nrep = 0 ; //<S2SV> time_t t ; //<S2SV> struct service * newserv = NULL ; //<S2SV> struct service * serv ; //<S2SV> n = read ( req -> socket , buf , sizeof ( buf ) ) ; //<S2SV> if ( n < 0 ) { //<S2SV> if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) //<S2SV> return ; //<S2SV> syslog ( LOG_ERR , "(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m" , req -> socket ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( n == 0 ) { //<S2SV> syslog ( LOG_INFO , "(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed" , req -> socket ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> t = time ( NULL ) ; //<S2SV> type = buf [ 0 ] ; //<S2SV> p = buf + 1 ; //<S2SV> DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; //<S2SV> if ( p + l > buf + n ) { //<S2SV> syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( l == 0 && type != 3 ) { //<S2SV> syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length=0)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> syslog ( LOG_INFO , "(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'" , //<S2SV> req -> socket , type , l , p ) ; //<S2SV> switch ( type ) { //<S2SV> case 1 : //<S2SV> case 2 : //<S2SV> case 3 : //<S2SV> while ( d && ( nrep < 255 ) ) { //<S2SV> if ( d -> t < t ) { //<S2SV> syslog ( LOG_INFO , "outdated<S2SV_blank>device" ) ; //<S2SV> } else { //<S2SV> if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l //<S2SV> + d -> headers [ HEADER_USN ] . l + 6 //<S2SV> + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) //<S2SV> break ; //<S2SV> if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) //<S2SV> || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) //<S2SV> || ( type == 3 ) ) { //<S2SV> m = d -> headers [ HEADER_LOCATION ] . l ; //<S2SV> CODELENGTH ( m , rp ) ; //<S2SV> memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; //<S2SV> rp += d -> headers [ HEADER_LOCATION ] . l ; //<S2SV> m = d -> headers [ HEADER_NT ] . l ; //<S2SV> CODELENGTH ( m , rp ) ; //<S2SV> memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; //<S2SV> rp += d -> headers [ HEADER_NT ] . l ; //<S2SV> m = d -> headers [ HEADER_USN ] . l ; //<S2SV> CODELENGTH ( m , rp ) ; //<S2SV> memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; //<S2SV> rp += d -> headers [ HEADER_USN ] . l ; //<S2SV> nrep ++ ; //<S2SV> } //<S2SV> } //<S2SV> d = d -> next ; //<S2SV> } //<S2SV> for ( serv = servicelisthead . lh_first ; //<S2SV> serv && ( nrep < 255 ) ; //<S2SV> serv = serv -> entries . le_next ) { //<S2SV> if ( strlen ( serv -> location ) + strlen ( serv -> st ) //<S2SV> + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) //<S2SV> break ; //<S2SV> if ( ( type == 1 && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) //<S2SV> || ( type == 2 && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) //<S2SV> || ( type == 3 ) ) { //<S2SV> m = strlen ( serv -> location ) ; //<S2SV> CODELENGTH ( m , rp ) ; //<S2SV> memcpy ( rp , serv -> location , m ) ; //<S2SV> rp += m ; //<S2SV> m = strlen ( serv -> st ) ; //<S2SV> CODELENGTH ( m , rp ) ; //<S2SV> memcpy ( rp , serv -> st , m ) ; //<S2SV> rp += m ; //<S2SV> m = strlen ( serv -> usn ) ; //<S2SV> CODELENGTH ( m , rp ) ; //<S2SV> memcpy ( rp , serv -> usn , m ) ; //<S2SV> rp += m ; //<S2SV> nrep ++ ; //<S2SV> } //<S2SV> } //<S2SV> rbuf [ 0 ] = nrep ; //<S2SV> syslog ( LOG_DEBUG , "(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s" , //<S2SV> req -> socket , nrep , ( nrep > 1 ) ? "s" : "" ) ; //<S2SV> if ( write ( req -> socket , rbuf , rp - rbuf ) < 0 ) { //<S2SV> syslog ( LOG_ERR , "(s=%d)<S2SV_blank>write:<S2SV_blank>%m" , req -> socket ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> break ; //<S2SV> case 4 : //<S2SV> newserv = malloc ( sizeof ( struct service ) ) ; //<S2SV> if ( ! newserv ) { //<S2SV> syslog ( LOG_ERR , "cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( containsForbiddenChars ( p , l ) ) { //<S2SV> syslog ( LOG_ERR , "bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> newserv -> st = malloc ( l + 1 ) ; //<S2SV> if ( ! newserv -> st ) { //<S2SV> syslog ( LOG_ERR , "cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> memcpy ( newserv -> st , p , l ) ; //<S2SV> newserv -> st [ l ] = '\\0' ; //<S2SV> p += l ; //<S2SV> if ( p >= buf + n ) { //<S2SV> syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; //<S2SV> if ( p + l > buf + n ) { //<S2SV> syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( containsForbiddenChars ( p , l ) ) { //<S2SV> syslog ( LOG_ERR , "bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> syslog ( LOG_INFO , "usn=\'%.*s\'" , l , p ) ; //<S2SV> newserv -> usn = malloc ( l + 1 ) ; //<S2SV> if ( ! newserv -> usn ) { //<S2SV> syslog ( LOG_ERR , "cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> memcpy ( newserv -> usn , p , l ) ; //<S2SV> newserv -> usn [ l ] = '\\0' ; //<S2SV> p += l ; //<S2SV> DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; //<S2SV> if ( p + l > buf + n ) { //<S2SV> syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( containsForbiddenChars ( p , l ) ) { //<S2SV> syslog ( LOG_ERR , "bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> syslog ( LOG_INFO , "server=\'%.*s\'" , l , p ) ; //<S2SV> newserv -> server = malloc ( l + 1 ) ; //<S2SV> if ( ! newserv -> server ) { //<S2SV> syslog ( LOG_ERR , "cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> memcpy ( newserv -> server , p , l ) ; //<S2SV> newserv -> server [ l ] = '\\0' ; //<S2SV> p += l ; //<S2SV> DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; //<S2SV> if ( p + l > buf + n ) { //<S2SV> syslog ( LOG_WARNING , "bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( containsForbiddenChars ( p , l ) ) { //<S2SV> syslog ( LOG_ERR , "bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> syslog ( LOG_INFO , "location=\'%.*s\'" , l , p ) ; //<S2SV> newserv -> location = malloc ( l + 1 ) ; //<S2SV> if ( ! newserv -> location ) { //<S2SV> syslog ( LOG_ERR , "cannot<S2SV_blank>allocate<S2SV_blank>memory" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> memcpy ( newserv -> location , p , l ) ; //<S2SV> newserv -> location [ l ] = '\\0' ; //<S2SV> for ( serv = servicelisthead . lh_first ; //<S2SV> serv ; //<S2SV> serv = serv -> entries . le_next ) { //<S2SV> if ( 0 == strcmp ( newserv -> usn , serv -> usn ) //<S2SV> && 0 == strcmp ( newserv -> st , serv -> st ) ) { //<S2SV> syslog ( LOG_INFO , "Service<S2SV_blank>allready<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..." ) ; //<S2SV> free ( newserv -> st ) ; //<S2SV> free ( newserv -> usn ) ; //<S2SV> free ( serv -> server ) ; //<S2SV> serv -> server = newserv -> server ; //<S2SV> free ( serv -> location ) ; //<S2SV> serv -> location = newserv -> location ; //<S2SV> free ( newserv ) ; //<S2SV> newserv = NULL ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; //<S2SV> newserv = NULL ; //<S2SV> break ; //<S2SV> default : //<S2SV> syslog ( LOG_WARNING , "Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d" , type ) ; //<S2SV> rbuf [ 0 ] = '\\0' ; //<S2SV> if ( write ( req -> socket , rbuf , 1 ) < 0 ) { //<S2SV> syslog ( LOG_ERR , "(s=%d)<S2SV_blank>write:<S2SV_blank>%m" , req -> socket ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> } //<S2SV> return ; //<S2SV> error : //<S2SV> if ( newserv ) { //<S2SV> free ( newserv -> st ) ; //<S2SV> free ( newserv -> usn ) ; //<S2SV> free ( newserv -> server ) ; //<S2SV> free ( newserv -> location ) ; //<S2SV> free ( newserv ) ; //<S2SV> newserv = NULL ; //<S2SV> } //<S2SV> close ( req -> socket ) ; //<S2SV> req -> socket = - 1 ; //<S2SV> return ; //<S2SV> } //<S2SV> 