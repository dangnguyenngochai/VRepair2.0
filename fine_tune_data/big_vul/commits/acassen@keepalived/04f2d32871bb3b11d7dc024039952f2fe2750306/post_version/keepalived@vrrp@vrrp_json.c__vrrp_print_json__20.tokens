void //<S2SV> vrrp_print_json ( void ) //<S2SV> { //<S2SV> FILE * file ; //<S2SV> element e ; //<S2SV> struct json_object * array ; //<S2SV> if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) //<S2SV> return ; //<S2SV> file = fopen_safe ( "/tmp/keepalived.json" , "w" ) ; //<S2SV> if ( ! file ) { //<S2SV> log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>/tmp/keepalived.json<S2SV_blank>(%d:<S2SV_blank>%s)" , //<S2SV> errno , strerror ( errno ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> array = json_object_new_array ( ) ; //<S2SV> for ( e = LIST_HEAD ( vrrp_data -> vrrp ) ; e ; ELEMENT_NEXT ( e ) ) { //<S2SV> struct json_object * instance_json , * json_stats , * json_data , //<S2SV> * vips , * evips , * track_ifp , * track_script ; //<S2SV> # ifdef _HAVE_FIB_ROUTING_ //<S2SV> struct json_object * vroutes , * vrules ; //<S2SV> # endif //<S2SV> element f ; //<S2SV> vrrp_t * vrrp = ELEMENT_DATA ( e ) ; //<S2SV> instance_json = json_object_new_object ( ) ; //<S2SV> json_stats = json_object_new_object ( ) ; //<S2SV> json_data = json_object_new_object ( ) ; //<S2SV> vips = json_object_new_array ( ) ; //<S2SV> evips = json_object_new_array ( ) ; //<S2SV> track_ifp = json_object_new_array ( ) ; //<S2SV> track_script = json_object_new_array ( ) ; //<S2SV> # ifdef _HAVE_FIB_ROUTING_ //<S2SV> vroutes = json_object_new_array ( ) ; //<S2SV> vrules = json_object_new_array ( ) ; //<S2SV> # endif //<S2SV> json_object_object_add ( json_data , "iname" , //<S2SV> json_object_new_string ( vrrp -> iname ) ) ; //<S2SV> json_object_object_add ( json_data , "dont_track_primary" , //<S2SV> json_object_new_int ( vrrp -> dont_track_primary ) ) ; //<S2SV> json_object_object_add ( json_data , "skip_check_adv_addr" , //<S2SV> json_object_new_int ( vrrp -> skip_check_adv_addr ) ) ; //<S2SV> json_object_object_add ( json_data , "strict_mode" , //<S2SV> json_object_new_int ( ( int ) vrrp -> strict_mode ) ) ; //<S2SV> # ifdef _HAVE_VRRP_VMAC_ //<S2SV> json_object_object_add ( json_data , "vmac_ifname" , //<S2SV> json_object_new_string ( vrrp -> vmac_ifname ) ) ; //<S2SV> # endif //<S2SV> if ( ! LIST_ISEMPTY ( vrrp -> track_ifp ) ) { //<S2SV> for ( f = LIST_HEAD ( vrrp -> track_ifp ) ; f ; ELEMENT_NEXT ( f ) ) { //<S2SV> interface_t * ifp = ELEMENT_DATA ( f ) ; //<S2SV> json_object_array_add ( track_ifp , //<S2SV> json_object_new_string ( ifp -> ifname ) ) ; //<S2SV> } //<S2SV> } //<S2SV> json_object_object_add ( json_data , "track_ifp" , track_ifp ) ; //<S2SV> if ( ! LIST_ISEMPTY ( vrrp -> track_script ) ) { //<S2SV> for ( f = LIST_HEAD ( vrrp -> track_script ) ; f ; ELEMENT_NEXT ( f ) ) { //<S2SV> tracked_sc_t * tsc = ELEMENT_DATA ( f ) ; //<S2SV> vrrp_script_t * vscript = tsc -> scr ; //<S2SV> json_object_array_add ( track_script , //<S2SV> json_object_new_string ( cmd_str ( & vscript -> script ) ) ) ; //<S2SV> } //<S2SV> } //<S2SV> json_object_object_add ( json_data , "track_script" , track_script ) ; //<S2SV> json_object_object_add ( json_data , "ifp_ifname" , //<S2SV> json_object_new_string ( vrrp -> ifp -> ifname ) ) ; //<S2SV> json_object_object_add ( json_data , "master_priority" , //<S2SV> json_object_new_int ( vrrp -> master_priority ) ) ; //<S2SV> json_object_object_add ( json_data , "last_transition" , //<S2SV> json_object_new_double ( timeval_to_double ( & vrrp -> last_transition ) ) ) ; //<S2SV> json_object_object_add ( json_data , "garp_delay" , //<S2SV> json_object_new_double ( vrrp -> garp_delay / TIMER_HZ_FLOAT ) ) ; //<S2SV> json_object_object_add ( json_data , "garp_refresh" , //<S2SV> json_object_new_int ( ( int ) vrrp -> garp_refresh . tv_sec ) ) ; //<S2SV> json_object_object_add ( json_data , "garp_rep" , //<S2SV> json_object_new_int ( ( int ) vrrp -> garp_rep ) ) ; //<S2SV> json_object_object_add ( json_data , "garp_refresh_rep" , //<S2SV> json_object_new_int ( ( int ) vrrp -> garp_refresh_rep ) ) ; //<S2SV> json_object_object_add ( json_data , "garp_lower_prio_delay" , //<S2SV> json_object_new_int ( ( int ) ( vrrp -> garp_lower_prio_delay / TIMER_HZ ) ) ) ; //<S2SV> json_object_object_add ( json_data , "garp_lower_prio_rep" , //<S2SV> json_object_new_int ( ( int ) vrrp -> garp_lower_prio_rep ) ) ; //<S2SV> json_object_object_add ( json_data , "lower_prio_no_advert" , //<S2SV> json_object_new_int ( ( int ) vrrp -> lower_prio_no_advert ) ) ; //<S2SV> json_object_object_add ( json_data , "higher_prio_send_advert" , //<S2SV> json_object_new_int ( ( int ) vrrp -> higher_prio_send_advert ) ) ; //<S2SV> json_object_object_add ( json_data , "vrid" , //<S2SV> json_object_new_int ( vrrp -> vrid ) ) ; //<S2SV> json_object_object_add ( json_data , "base_priority" , //<S2SV> json_object_new_int ( vrrp -> base_priority ) ) ; //<S2SV> json_object_object_add ( json_data , "effective_priority" , //<S2SV> json_object_new_int ( vrrp -> effective_priority ) ) ; //<S2SV> json_object_object_add ( json_data , "vipset" , //<S2SV> json_object_new_boolean ( vrrp -> vipset ) ) ; //<S2SV> if ( ! LIST_ISEMPTY ( vrrp -> vip ) ) { //<S2SV> for ( f = LIST_HEAD ( vrrp -> vip ) ; f ; ELEMENT_NEXT ( f ) ) { //<S2SV> ip_address_t * vip = ELEMENT_DATA ( f ) ; //<S2SV> char ipaddr [ INET6_ADDRSTRLEN ] ; //<S2SV> inet_ntop ( vrrp -> family , & ( vip -> u . sin . sin_addr . s_addr ) , //<S2SV> ipaddr , INET6_ADDRSTRLEN ) ; //<S2SV> json_object_array_add ( vips , //<S2SV> json_object_new_string ( ipaddr ) ) ; //<S2SV> } //<S2SV> } //<S2SV> json_object_object_add ( json_data , "vips" , vips ) ; //<S2SV> if ( ! LIST_ISEMPTY ( vrrp -> evip ) ) { //<S2SV> for ( f = LIST_HEAD ( vrrp -> evip ) ; f ; ELEMENT_NEXT ( f ) ) { //<S2SV> ip_address_t * evip = ELEMENT_DATA ( f ) ; //<S2SV> char ipaddr [ INET6_ADDRSTRLEN ] ; //<S2SV> inet_ntop ( vrrp -> family , & ( evip -> u . sin . sin_addr . s_addr ) , //<S2SV> ipaddr , INET6_ADDRSTRLEN ) ; //<S2SV> json_object_array_add ( evips , //<S2SV> json_object_new_string ( ipaddr ) ) ; //<S2SV> } //<S2SV> } //<S2SV> json_object_object_add ( json_data , "evips" , evips ) ; //<S2SV> json_object_object_add ( json_data , "promote_secondaries" , //<S2SV> json_object_new_boolean ( vrrp -> promote_secondaries ) ) ; //<S2SV> # ifdef _HAVE_FIB_ROUTING_ //<S2SV> if ( ! LIST_ISEMPTY ( vrrp -> vroutes ) ) { //<S2SV> for ( f = LIST_HEAD ( vrrp -> vroutes ) ; f ; ELEMENT_NEXT ( f ) ) { //<S2SV> ip_route_t * route = ELEMENT_DATA ( f ) ; //<S2SV> char * buf = MALLOC ( ROUTE_BUF_SIZE ) ; //<S2SV> format_iproute ( route , buf , ROUTE_BUF_SIZE ) ; //<S2SV> json_object_array_add ( vroutes , //<S2SV> json_object_new_string ( buf ) ) ; //<S2SV> } //<S2SV> } //<S2SV> json_object_object_add ( json_data , "vroutes" , vroutes ) ; //<S2SV> if ( ! LIST_ISEMPTY ( vrrp -> vrules ) ) { //<S2SV> for ( f = LIST_HEAD ( vrrp -> vrules ) ; f ; ELEMENT_NEXT ( f ) ) { //<S2SV> ip_rule_t * rule = ELEMENT_DATA ( f ) ; //<S2SV> char * buf = MALLOC ( RULE_BUF_SIZE ) ; //<S2SV> format_iprule ( rule , buf , RULE_BUF_SIZE ) ; //<S2SV> json_object_array_add ( vrules , //<S2SV> json_object_new_string ( buf ) ) ; //<S2SV> } //<S2SV> } //<S2SV> json_object_object_add ( json_data , "vrules" , vrules ) ; //<S2SV> # endif //<S2SV> json_object_object_add ( json_data , "adver_int" , //<S2SV> json_object_new_double ( vrrp -> adver_int / TIMER_HZ_FLOAT ) ) ; //<S2SV> json_object_object_add ( json_data , "master_adver_int" , //<S2SV> json_object_new_double ( vrrp -> master_adver_int / TIMER_HZ_FLOAT ) ) ; //<S2SV> json_object_object_add ( json_data , "accept" , //<S2SV> json_object_new_int ( ( int ) vrrp -> accept ) ) ; //<S2SV> json_object_object_add ( json_data , "nopreempt" , //<S2SV> json_object_new_boolean ( vrrp -> nopreempt ) ) ; //<S2SV> json_object_object_add ( json_data , "preempt_delay" , //<S2SV> json_object_new_int ( ( int ) ( vrrp -> preempt_delay / TIMER_HZ ) ) ) ; //<S2SV> json_object_object_add ( json_data , "state" , //<S2SV> json_object_new_int ( vrrp -> state ) ) ; //<S2SV> json_object_object_add ( json_data , "wantstate" , //<S2SV> json_object_new_int ( vrrp -> wantstate ) ) ; //<S2SV> json_object_object_add ( json_data , "version" , //<S2SV> json_object_new_int ( vrrp -> version ) ) ; //<S2SV> if ( vrrp -> script_backup ) //<S2SV> json_object_object_add ( json_data , "script_backup" , //<S2SV> json_object_new_string ( cmd_str ( vrrp -> script_backup ) ) ) ; //<S2SV> if ( vrrp -> script_master ) //<S2SV> json_object_object_add ( json_data , "script_master" , //<S2SV> json_object_new_string ( cmd_str ( vrrp -> script_master ) ) ) ; //<S2SV> if ( vrrp -> script_fault ) //<S2SV> json_object_object_add ( json_data , "script_fault" , //<S2SV> json_object_new_string ( cmd_str ( vrrp -> script_fault ) ) ) ; //<S2SV> if ( vrrp -> script_stop ) //<S2SV> json_object_object_add ( json_data , "script_stop" , //<S2SV> json_object_new_string ( cmd_str ( vrrp -> script_stop ) ) ) ; //<S2SV> if ( vrrp -> script ) //<S2SV> json_object_object_add ( json_data , "script" , //<S2SV> json_object_new_string ( cmd_str ( vrrp -> script ) ) ) ; //<S2SV> if ( vrrp -> script_master_rx_lower_pri ) //<S2SV> json_object_object_add ( json_data , "script_master_rx_lower_pri" , //<S2SV> json_object_new_string ( cmd_str ( vrrp -> script_master_rx_lower_pri ) ) ) ; //<S2SV> json_object_object_add ( json_data , "smtp_alert" , //<S2SV> json_object_new_boolean ( vrrp -> smtp_alert ) ) ; //<S2SV> # ifdef _WITH_VRRP_AUTH_ //<S2SV> if ( vrrp -> auth_type ) { //<S2SV> json_object_object_add ( json_data , "auth_type" , //<S2SV> json_object_new_int ( vrrp -> auth_type ) ) ; //<S2SV> if ( vrrp -> auth_type != VRRP_AUTH_AH ) { //<S2SV> char auth_data [ sizeof ( vrrp -> auth_data ) + 1 ] ; //<S2SV> memcpy ( auth_data , vrrp -> auth_data , sizeof ( vrrp -> auth_data ) ) ; //<S2SV> auth_data [ sizeof ( vrrp -> auth_data ) ] = '\\0' ; //<S2SV> json_object_object_add ( json_data , "auth_data" , //<S2SV> json_object_new_string ( auth_data ) ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> json_object_object_add ( json_data , "auth_type" , //<S2SV> json_object_new_int ( 0 ) ) ; //<S2SV> # endif //<S2SV> json_object_object_add ( json_stats , "advert_rcvd" , //<S2SV> json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_rcvd ) ) ; //<S2SV> json_object_object_add ( json_stats , "advert_sent" , //<S2SV> json_object_new_int64 ( vrrp -> stats -> advert_sent ) ) ; //<S2SV> json_object_object_add ( json_stats , "become_master" , //<S2SV> json_object_new_int64 ( vrrp -> stats -> become_master ) ) ; //<S2SV> json_object_object_add ( json_stats , "release_master" , //<S2SV> json_object_new_int64 ( vrrp -> stats -> release_master ) ) ; //<S2SV> json_object_object_add ( json_stats , "packet_len_err" , //<S2SV> json_object_new_int64 ( ( int64_t ) vrrp -> stats -> packet_len_err ) ) ; //<S2SV> json_object_object_add ( json_stats , "advert_interval_err" , //<S2SV> json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_interval_err ) ) ; //<S2SV> json_object_object_add ( json_stats , "ip_ttl_err" , //<S2SV> json_object_new_int64 ( ( int64_t ) vrrp -> stats -> ip_ttl_err ) ) ; //<S2SV> json_object_object_add ( json_stats , "invalid_type_rcvd" , //<S2SV> json_object_new_int64 ( ( int64_t ) vrrp -> stats -> invalid_type_rcvd ) ) ; //<S2SV> json_object_object_add ( json_stats , "addr_list_err" , //<S2SV> json_object_new_int64 ( ( int64_t ) vrrp -> stats -> addr_list_err ) ) ; //<S2SV> json_object_object_add ( json_stats , "invalid_authtype" , //<S2SV> json_object_new_int64 ( vrrp -> stats -> invalid_authtype ) ) ; //<S2SV> # ifdef _WITH_VRRP_AUTH_ //<S2SV> json_object_object_add ( json_stats , "authtype_mismatch" , //<S2SV> json_object_new_int64 ( vrrp -> stats -> authtype_mismatch ) ) ; //<S2SV> json_object_object_add ( json_stats , "auth_failure" , //<S2SV> json_object_new_int64 ( vrrp -> stats -> auth_failure ) ) ; //<S2SV> # endif //<S2SV> json_object_object_add ( json_stats , "pri_zero_rcvd" , //<S2SV> json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_rcvd ) ) ; //<S2SV> json_object_object_add ( json_stats , "pri_zero_sent" , //<S2SV> json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_sent ) ) ; //<S2SV> json_object_object_add ( instance_json , "data" , json_data ) ; //<S2SV> json_object_object_add ( instance_json , "stats" , json_stats ) ; //<S2SV> json_object_array_add ( array , instance_json ) ; //<S2SV> } //<S2SV> fprintf ( file , "%s" , json_object_to_json_string ( array ) ) ; //<S2SV> fclose ( file ) ; //<S2SV> } //<S2SV> 