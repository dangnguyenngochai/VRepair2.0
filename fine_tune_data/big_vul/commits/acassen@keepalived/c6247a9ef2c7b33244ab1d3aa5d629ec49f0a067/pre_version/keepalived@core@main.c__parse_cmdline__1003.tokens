static bool //<S2SV> parse_cmdline ( int argc , char * * argv ) //<S2SV> { //<S2SV> int c ; //<S2SV> bool reopen_log = false ; //<S2SV> int signum ; //<S2SV> struct utsname uname_buf ; //<S2SV> int longindex ; //<S2SV> int curind ; //<S2SV> bool bad_option = false ; //<S2SV> unsigned facility ; //<S2SV> struct option long_options [ ] = { //<S2SV> { "use-file" , required_argument , NULL , 'f' } , //<S2SV> # if defined _WITH_VRRP_ && defined _WITH_LVS_ //<S2SV> { "vrrp" , no_argument , NULL , 'P' } , //<S2SV> { "check" , no_argument , NULL , 'C' } , //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> { "no_bfd" , no_argument , NULL , 'B' } , //<S2SV> # endif //<S2SV> { "all" , no_argument , NULL , 3 } , //<S2SV> { "log-console" , no_argument , NULL , 'l' } , //<S2SV> { "log-detail" , no_argument , NULL , 'D' } , //<S2SV> { "log-facility" , required_argument , NULL , 'S' } , //<S2SV> { "log-file" , optional_argument , NULL , 'g' } , //<S2SV> { "flush-log-file" , no_argument , NULL , 2 } , //<S2SV> { "no-syslog" , no_argument , NULL , 'G' } , //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> { "release-vips" , no_argument , NULL , 'X' } , //<S2SV> { "dont-release-vrrp" , no_argument , NULL , 'V' } , //<S2SV> # endif //<S2SV> # ifdef _WITH_LVS_ //<S2SV> { "dont-release-ipvs" , no_argument , NULL , 'I' } , //<S2SV> # endif //<S2SV> { "dont-respawn" , no_argument , NULL , 'R' } , //<S2SV> { "dont-fork" , no_argument , NULL , 'n' } , //<S2SV> { "dump-conf" , no_argument , NULL , 'd' } , //<S2SV> { "pid" , required_argument , NULL , 'p' } , //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> { "vrrp_pid" , required_argument , NULL , 'r' } , //<S2SV> # endif //<S2SV> # ifdef _WITH_LVS_ //<S2SV> { "checkers_pid" , required_argument , NULL , 'c' } , //<S2SV> { "address-monitoring" , no_argument , NULL , 'a' } , //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> { "bfd_pid" , required_argument , NULL , 'b' } , //<S2SV> # endif //<S2SV> # ifdef _WITH_SNMP_ //<S2SV> { "snmp" , no_argument , NULL , 'x' } , //<S2SV> { "snmp-agent-socket" , required_argument , NULL , 'A' } , //<S2SV> # endif //<S2SV> { "core-dump" , no_argument , NULL , 'm' } , //<S2SV> { "core-dump-pattern" , optional_argument , NULL , 'M' } , //<S2SV> # ifdef _MEM_CHECK_LOG_ //<S2SV> { "mem-check-log" , no_argument , NULL , 'L' } , //<S2SV> # endif //<S2SV> # if HAVE_DECL_CLONE_NEWNET //<S2SV> { "namespace" , required_argument , NULL , 's' } , //<S2SV> # endif //<S2SV> { "config-id" , required_argument , NULL , 'i' } , //<S2SV> { "signum" , required_argument , NULL , 4 } , //<S2SV> { "config-test" , optional_argument , NULL , 't' } , //<S2SV> # ifdef _WITH_PERF_ //<S2SV> { "perf" , optional_argument , NULL , 5 } , //<S2SV> # endif //<S2SV> # ifdef WITH_DEBUG_OPTIONS //<S2SV> { "debug" , optional_argument , NULL , 6 } , //<S2SV> # endif //<S2SV> { "version" , no_argument , NULL , 'v' } , //<S2SV> { "help" , no_argument , NULL , 'h' } , //<S2SV> { NULL , 0 , NULL , 0 } //<S2SV> } ; //<S2SV> curind = optind ; //<S2SV> while ( longindex = - 1 , ( c = getopt_long ( argc , argv , ":vhlndDRS:f:p:i:mM::g::Gt::" //<S2SV> # if defined _WITH_VRRP_ && defined _WITH_LVS_ //<S2SV> "PC" //<S2SV> # endif //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> "r:VX" //<S2SV> # endif //<S2SV> # ifdef _WITH_LVS_ //<S2SV> "ac:I" //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> "Bb:" //<S2SV> # endif //<S2SV> # ifdef _WITH_SNMP_ //<S2SV> "xA:" //<S2SV> # endif //<S2SV> # ifdef _MEM_CHECK_LOG_ //<S2SV> "L" //<S2SV> # endif //<S2SV> # if HAVE_DECL_CLONE_NEWNET //<S2SV> "s:" //<S2SV> # endif //<S2SV> , long_options , & longindex ) ) != - 1 ) { //<S2SV> if ( longindex >= 0 && long_options [ longindex ] . has_arg == required_argument && optarg && ! optarg [ 0 ] ) { //<S2SV> c = ':' ; //<S2SV> optarg = NULL ; //<S2SV> } //<S2SV> switch ( c ) { //<S2SV> case 'v' : //<S2SV> fprintf ( stderr , "%s" , version_string ) ; //<S2SV> # ifdef GIT_COMMIT //<S2SV> fprintf ( stderr , ",<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s" , GIT_COMMIT ) ; //<S2SV> # endif //<S2SV> fprintf ( stderr , "\\n\\n%s\\n\\n" , COPYRIGHT_STRING ) ; //<S2SV> fprintf ( stderr , "Built<S2SV_blank>with<S2SV_blank>kernel<S2SV_blank>headers<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d\\n" , //<S2SV> ( LINUX_VERSION_CODE >> 16 ) & 0xff , //<S2SV> ( LINUX_VERSION_CODE >> 8 ) & 0xff , //<S2SV> ( LINUX_VERSION_CODE ) & 0xff ) ; //<S2SV> uname ( & uname_buf ) ; //<S2SV> fprintf ( stderr , "Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n\\n" , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; //<S2SV> fprintf ( stderr , "configure<S2SV_blank>options:<S2SV_blank>%s\\n\\n" , KEEPALIVED_CONFIGURE_OPTIONS ) ; //<S2SV> fprintf ( stderr , "Config<S2SV_blank>options:<S2SV_blank>%s\\n\\n" , CONFIGURATION_OPTIONS ) ; //<S2SV> fprintf ( stderr , "System<S2SV_blank>options:<S2SV_blank>%s\\n" , SYSTEM_OPTIONS ) ; //<S2SV> exit ( 0 ) ; //<S2SV> break ; //<S2SV> case 'h' : //<S2SV> usage ( argv [ 0 ] ) ; //<S2SV> exit ( 0 ) ; //<S2SV> break ; //<S2SV> case 'l' : //<S2SV> __set_bit ( LOG_CONSOLE_BIT , & debug ) ; //<S2SV> reopen_log = true ; //<S2SV> break ; //<S2SV> case 'n' : //<S2SV> __set_bit ( DONT_FORK_BIT , & debug ) ; //<S2SV> break ; //<S2SV> case 'd' : //<S2SV> __set_bit ( DUMP_CONF_BIT , & debug ) ; //<S2SV> break ; //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> case 'V' : //<S2SV> __set_bit ( DONT_RELEASE_VRRP_BIT , & debug ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef _WITH_LVS_ //<S2SV> case 'I' : //<S2SV> __set_bit ( DONT_RELEASE_IPVS_BIT , & debug ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case 'D' : //<S2SV> if ( __test_bit ( LOG_DETAIL_BIT , & debug ) ) //<S2SV> __set_bit ( LOG_EXTRA_DETAIL_BIT , & debug ) ; //<S2SV> else //<S2SV> __set_bit ( LOG_DETAIL_BIT , & debug ) ; //<S2SV> break ; //<S2SV> case 'R' : //<S2SV> __set_bit ( DONT_RESPAWN_BIT , & debug ) ; //<S2SV> break ; //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> case 'X' : //<S2SV> __set_bit ( RELEASE_VIPS_BIT , & debug ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case 'S' : //<S2SV> if ( ! read_unsigned ( optarg , & facility , 0 , LOG_FACILITY_MAX , false ) ) //<S2SV> fprintf ( stderr , "Invalid<S2SV_blank>log<S2SV_blank>facility<S2SV_blank>\'%s\'\\n" , optarg ) ; //<S2SV> else { //<S2SV> log_facility = LOG_FACILITY [ facility ] . facility ; //<S2SV> reopen_log = true ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'g' : //<S2SV> if ( optarg && optarg [ 0 ] ) //<S2SV> log_file_name = optarg ; //<S2SV> else //<S2SV> log_file_name = "/tmp/keepalived.log" ; //<S2SV> open_log_file ( log_file_name , NULL , NULL , NULL ) ; //<S2SV> break ; //<S2SV> case 'G' : //<S2SV> __set_bit ( NO_SYSLOG_BIT , & debug ) ; //<S2SV> reopen_log = true ; //<S2SV> break ; //<S2SV> case 't' : //<S2SV> __set_bit ( CONFIG_TEST_BIT , & debug ) ; //<S2SV> __set_bit ( DONT_RESPAWN_BIT , & debug ) ; //<S2SV> __set_bit ( DONT_FORK_BIT , & debug ) ; //<S2SV> __set_bit ( NO_SYSLOG_BIT , & debug ) ; //<S2SV> if ( optarg && optarg [ 0 ] ) { //<S2SV> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; //<S2SV> if ( fd == - 1 ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config-test<S2SV_blank>log<S2SV_blank>file<S2SV_blank>%s\\n" , optarg ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> dup2 ( fd , STDERR_FILENO ) ; //<S2SV> close ( fd ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'f' : //<S2SV> conf_file = optarg ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> set_flush_log_file ( ) ; //<S2SV> break ; //<S2SV> # if defined _WITH_VRRP_ && defined _WITH_LVS_ //<S2SV> case 'P' : //<S2SV> __clear_bit ( DAEMON_CHECKERS , & daemon_mode ) ; //<S2SV> break ; //<S2SV> case 'C' : //<S2SV> __clear_bit ( DAEMON_VRRP , & daemon_mode ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> case 'B' : //<S2SV> __clear_bit ( DAEMON_BFD , & daemon_mode ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case 'p' : //<S2SV> main_pidfile = optarg ; //<S2SV> break ; //<S2SV> # ifdef _WITH_LVS_ //<S2SV> case 'c' : //<S2SV> checkers_pidfile = optarg ; //<S2SV> break ; //<S2SV> case 'a' : //<S2SV> __set_bit ( LOG_ADDRESS_CHANGES , & debug ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> case 'r' : //<S2SV> vrrp_pidfile = optarg ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> case 'b' : //<S2SV> bfd_pidfile = optarg ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef _WITH_SNMP_ //<S2SV> case 'x' : //<S2SV> snmp = 1 ; //<S2SV> break ; //<S2SV> case 'A' : //<S2SV> snmp_socket = optarg ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case 'M' : //<S2SV> set_core_dump_pattern = true ; //<S2SV> if ( optarg && optarg [ 0 ] ) //<S2SV> core_dump_pattern = optarg ; //<S2SV> case 'm' : //<S2SV> create_core_dump = true ; //<S2SV> break ; //<S2SV> # ifdef _MEM_CHECK_LOG_ //<S2SV> case 'L' : //<S2SV> __set_bit ( MEM_CHECK_LOG_BIT , & debug ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # if HAVE_DECL_CLONE_NEWNET //<S2SV> case 's' : //<S2SV> override_namespace = MALLOC ( strlen ( optarg ) + 1 ) ; //<S2SV> strcpy ( override_namespace , optarg ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case 'i' : //<S2SV> FREE_PTR ( config_id ) ; //<S2SV> config_id = MALLOC ( strlen ( optarg ) + 1 ) ; //<S2SV> strcpy ( config_id , optarg ) ; //<S2SV> break ; //<S2SV> case 4 : //<S2SV> signum = get_signum ( optarg ) ; //<S2SV> if ( signum == - 1 ) { //<S2SV> fprintf ( stderr , "Unknown<S2SV_blank>sigfunc<S2SV_blank>%s\\n" , optarg ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> printf ( "%d\\n" , signum ) ; //<S2SV> exit ( 0 ) ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> __set_bit ( RUN_ALL_CHILDREN , & daemon_mode ) ; //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> __set_bit ( DAEMON_VRRP , & daemon_mode ) ; //<S2SV> # endif //<S2SV> # ifdef _WITH_LVS_ //<S2SV> __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> __set_bit ( DAEMON_BFD , & daemon_mode ) ; //<S2SV> # endif //<S2SV> break ; //<S2SV> # ifdef _WITH_PERF_ //<S2SV> case 5 : //<S2SV> if ( optarg && optarg [ 0 ] ) { //<S2SV> if ( ! strcmp ( optarg , "run" ) ) //<S2SV> perf_run = PERF_RUN ; //<S2SV> else if ( ! strcmp ( optarg , "all" ) ) //<S2SV> perf_run = PERF_ALL ; //<S2SV> else if ( ! strcmp ( optarg , "end" ) ) //<S2SV> perf_run = PERF_END ; //<S2SV> else //<S2SV> log_message ( LOG_INFO , "Unknown<S2SV_blank>perf<S2SV_blank>start<S2SV_blank>point<S2SV_blank>%s" , optarg ) ; //<S2SV> } //<S2SV> else //<S2SV> perf_run = PERF_RUN ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef WITH_DEBUG_OPTIONS //<S2SV> case 6 : //<S2SV> set_debug_options ( optarg && optarg [ 0 ] ? optarg : NULL ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case '?' : //<S2SV> if ( optopt && argv [ curind ] [ 1 ] != '-' ) //<S2SV> fprintf ( stderr , "Unknown<S2SV_blank>option<S2SV_blank>-%c\\n" , optopt ) ; //<S2SV> else //<S2SV> fprintf ( stderr , "Unknown<S2SV_blank>option<S2SV_blank>%s\\n" , argv [ curind ] ) ; //<S2SV> bad_option = true ; //<S2SV> break ; //<S2SV> case ':' : //<S2SV> if ( optopt && argv [ curind ] [ 1 ] != '-' ) //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>-%c\\n" , optopt ) ; //<S2SV> else //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>--%s\\n" , long_options [ longindex ] . name ) ; //<S2SV> bad_option = true ; //<S2SV> break ; //<S2SV> default : //<S2SV> exit ( 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> curind = optind ; //<S2SV> } //<S2SV> if ( optind < argc ) { //<S2SV> printf ( "Unexpected<S2SV_blank>argument(s):<S2SV_blank>" ) ; //<S2SV> while ( optind < argc ) //<S2SV> printf ( "%s<S2SV_blank>" , argv [ optind ++ ] ) ; //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> if ( bad_option ) //<S2SV> exit ( 1 ) ; //<S2SV> return reopen_log ; //<S2SV> } //<S2SV> 