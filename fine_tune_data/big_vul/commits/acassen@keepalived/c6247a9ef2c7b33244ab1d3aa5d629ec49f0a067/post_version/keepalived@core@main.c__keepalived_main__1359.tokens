int //<S2SV> keepalived_main ( int argc , char * * argv ) //<S2SV> { //<S2SV> bool report_stopped = true ; //<S2SV> struct utsname uname_buf ; //<S2SV> char * end ; //<S2SV> set_time_now ( ) ; //<S2SV> save_cmd_line_options ( argc , argv ) ; //<S2SV> debug = 0 ; //<S2SV> # ifndef _DEBUG_ //<S2SV> prog_type = PROG_TYPE_PARENT ; //<S2SV> # endif //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> __set_bit ( DAEMON_VRRP , & daemon_mode ) ; //<S2SV> # endif //<S2SV> # ifdef _WITH_LVS_ //<S2SV> __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> __set_bit ( DAEMON_BFD , & daemon_mode ) ; //<S2SV> # endif //<S2SV> umask ( 022 ) ; //<S2SV> openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ; //<S2SV> # ifdef _MEM_CHECK_ //<S2SV> mem_log_init ( PACKAGE_NAME , "Parent<S2SV_blank>process" ) ; //<S2SV> # endif //<S2SV> if ( uname ( & uname_buf ) ) //<S2SV> log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>uname()<S2SV_blank>information<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d" , errno ) ; //<S2SV> else { //<S2SV> os_major = ( unsigned ) strtoul ( uname_buf . release , & end , 10 ) ; //<S2SV> if ( * end != '.' ) //<S2SV> os_major = 0 ; //<S2SV> else { //<S2SV> os_minor = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; //<S2SV> if ( * end != '.' ) //<S2SV> os_major = 0 ; //<S2SV> else { //<S2SV> if ( ! isdigit ( end [ 1 ] ) ) //<S2SV> os_major = 0 ; //<S2SV> else //<S2SV> os_release = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! os_major ) //<S2SV> log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>%s" , uname_buf . release ) ; //<S2SV> if ( ! config_id ) { //<S2SV> end = strchrnul ( uname_buf . nodename , '.' ) ; //<S2SV> config_id = MALLOC ( ( size_t ) ( end - uname_buf . nodename ) + 1 ) ; //<S2SV> strncpy ( config_id , uname_buf . nodename , ( size_t ) ( end - uname_buf . nodename ) ) ; //<S2SV> config_id [ end - uname_buf . nodename ] = '\\0' ; //<S2SV> } //<S2SV> } //<S2SV> if ( parse_cmdline ( argc , argv ) ) { //<S2SV> closelog ( ) ; //<S2SV> if ( ! __test_bit ( NO_SYSLOG_BIT , & debug ) ) //<S2SV> openlog ( PACKAGE_NAME , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; //<S2SV> } //<S2SV> if ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) //<S2SV> enable_console_log ( ) ; //<S2SV> # ifdef GIT_COMMIT //<S2SV> log_message ( LOG_INFO , "Starting<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s" , version_string , GIT_COMMIT ) ; //<S2SV> # else //<S2SV> log_message ( LOG_INFO , "Starting<S2SV_blank>%s" , version_string ) ; //<S2SV> # endif //<S2SV> core_dump_init ( ) ; //<S2SV> if ( os_major ) { //<S2SV> if ( KERNEL_VERSION ( os_major , os_minor , os_release ) < LINUX_VERSION_CODE ) { //<S2SV> log_message ( LOG_INFO , "WARNING<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>was<S2SV_blank>build<S2SV_blank>for<S2SV_blank>newer<S2SV_blank>Linux<S2SV_blank>%d.%d.%d,<S2SV_blank>running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s" , //<S2SV> ( LINUX_VERSION_CODE >> 16 ) & 0xff , //<S2SV> ( LINUX_VERSION_CODE >> 8 ) & 0xff , //<S2SV> ( LINUX_VERSION_CODE ) & 0xff , //<S2SV> uname_buf . sysname , uname_buf . release , uname_buf . version ) ; //<S2SV> } else { //<S2SV> log_message ( LOG_INFO , "Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>(built<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d)" , //<S2SV> uname_buf . sysname , uname_buf . release , uname_buf . version , //<S2SV> ( LINUX_VERSION_CODE >> 16 ) & 0xff , //<S2SV> ( LINUX_VERSION_CODE >> 8 ) & 0xff , //<S2SV> ( LINUX_VERSION_CODE ) & 0xff ) ; //<S2SV> } //<S2SV> } //<S2SV> # ifndef _DEBUG_ //<S2SV> log_command_line ( 0 ) ; //<S2SV> # endif //<S2SV> if ( ! check_conf_file ( conf_file ) ) { //<S2SV> if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) //<S2SV> config_test_exit ( ) ; //<S2SV> goto end ; //<S2SV> } //<S2SV> global_data = alloc_global_data ( ) ; //<S2SV> global_data -> umask = umask_val ; //<S2SV> read_config_file ( ) ; //<S2SV> init_global_data ( global_data , NULL ) ; //<S2SV> # if HAVE_DECL_CLONE_NEWNET //<S2SV> if ( override_namespace ) { //<S2SV> if ( global_data -> network_namespace ) { //<S2SV> log_message ( LOG_INFO , "Overriding<S2SV_blank>config<S2SV_blank>net_namespace<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>command<S2SV_blank>line<S2SV_blank>namespace<S2SV_blank>\'%s\'" , global_data -> network_namespace , override_namespace ) ; //<S2SV> FREE ( global_data -> network_namespace ) ; //<S2SV> } //<S2SV> global_data -> network_namespace = override_namespace ; //<S2SV> override_namespace = NULL ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) && //<S2SV> ( global_data -> instance_name //<S2SV> # if HAVE_DECL_CLONE_NEWNET //<S2SV> || global_data -> network_namespace //<S2SV> # endif //<S2SV> ) ) { //<S2SV> if ( ( syslog_ident = make_syslog_ident ( PACKAGE_NAME ) ) ) { //<S2SV> log_message ( LOG_INFO , "Changing<S2SV_blank>syslog<S2SV_blank>ident<S2SV_blank>to<S2SV_blank>%s" , syslog_ident ) ; //<S2SV> closelog ( ) ; //<S2SV> openlog ( syslog_ident , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; //<S2SV> } //<S2SV> else //<S2SV> log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>syslog<S2SV_blank>ident" ) ; //<S2SV> use_pid_dir = true ; //<S2SV> open_log_file ( log_file_name , //<S2SV> NULL , //<S2SV> # if HAVE_DECL_CLONE_NEWNET //<S2SV> global_data -> network_namespace , //<S2SV> # else //<S2SV> NULL , //<S2SV> # endif //<S2SV> global_data -> instance_name ) ; //<S2SV> } //<S2SV> set_child_finder_name ( find_keepalived_child_name ) ; //<S2SV> if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { //<S2SV> if ( use_pid_dir ) { //<S2SV> create_pid_dir ( ) ; //<S2SV> } //<S2SV> } //<S2SV> # if HAVE_DECL_CLONE_NEWNET //<S2SV> if ( global_data -> network_namespace ) { //<S2SV> if ( global_data -> network_namespace && ! set_namespaces ( global_data -> network_namespace ) ) { //<S2SV> log_message ( LOG_ERR , "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>exiting" , global_data -> network_namespace ) ; //<S2SV> goto end ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { //<S2SV> if ( global_data -> instance_name ) { //<S2SV> if ( ! main_pidfile && ( main_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) //<S2SV> free_main_pidfile = true ; //<S2SV> # ifdef _WITH_LVS_ //<S2SV> if ( ! checkers_pidfile && ( checkers_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR CHECKERS_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) //<S2SV> free_checkers_pidfile = true ; //<S2SV> # endif //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> if ( ! vrrp_pidfile && ( vrrp_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) //<S2SV> free_vrrp_pidfile = true ; //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> if ( ! bfd_pidfile && ( bfd_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) //<S2SV> free_bfd_pidfile = true ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( use_pid_dir ) { //<S2SV> if ( ! main_pidfile ) //<S2SV> main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; //<S2SV> # ifdef _WITH_LVS_ //<S2SV> if ( ! checkers_pidfile ) //<S2SV> checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; //<S2SV> # endif //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> if ( ! vrrp_pidfile ) //<S2SV> vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION ; //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> if ( ! bfd_pidfile ) //<S2SV> bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION ; //<S2SV> # endif //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ! main_pidfile ) //<S2SV> main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; //<S2SV> # ifdef _WITH_LVS_ //<S2SV> if ( ! checkers_pidfile ) //<S2SV> checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; //<S2SV> # endif //<S2SV> # ifdef _WITH_VRRP_ //<S2SV> if ( ! vrrp_pidfile ) //<S2SV> vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION ; //<S2SV> # endif //<S2SV> # ifdef _WITH_BFD_ //<S2SV> if ( ! bfd_pidfile ) //<S2SV> bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( keepalived_running ( daemon_mode ) ) { //<S2SV> log_message ( LOG_INFO , "daemon<S2SV_blank>is<S2SV_blank>already<S2SV_blank>running" ) ; //<S2SV> report_stopped = false ; //<S2SV> goto end ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! __test_bit ( DONT_FORK_BIT , & debug ) && //<S2SV> xdaemon ( false , false , true ) > 0 ) { //<S2SV> closelog ( ) ; //<S2SV> FREE_PTR ( config_id ) ; //<S2SV> FREE_PTR ( orig_core_dump_pattern ) ; //<S2SV> close_std_fd ( ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> # ifdef _MEM_CHECK_ //<S2SV> enable_mem_log_termination ( ) ; //<S2SV> # endif //<S2SV> if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) { //<S2SV> validate_config ( ) ; //<S2SV> config_test_exit ( ) ; //<S2SV> } //<S2SV> if ( ! pidfile_write ( main_pidfile , getpid ( ) ) ) //<S2SV> goto end ; //<S2SV> master = thread_make_master ( ) ; //<S2SV> signal_init ( ) ; //<S2SV> if ( ! start_keepalived ( ) ) //<S2SV> log_message ( LOG_INFO , "Warning<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>has<S2SV_blank>no<S2SV_blank>configuration<S2SV_blank>to<S2SV_blank>run" ) ; //<S2SV> initialise_debug_options ( ) ; //<S2SV> # ifdef THREAD_DUMP //<S2SV> register_parent_thread_addresses ( ) ; //<S2SV> # endif //<S2SV> launch_thread_scheduler ( master ) ; //<S2SV> stop_keepalived ( ) ; //<S2SV> # ifdef THREAD_DUMP //<S2SV> deregister_thread_addresses ( ) ; //<S2SV> # endif //<S2SV> end : //<S2SV> if ( report_stopped ) { //<S2SV> # ifdef GIT_COMMIT //<S2SV> log_message ( LOG_INFO , "Stopped<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s" , version_string , GIT_COMMIT ) ; //<S2SV> # else //<S2SV> log_message ( LOG_INFO , "Stopped<S2SV_blank>%s" , version_string ) ; //<S2SV> # endif //<S2SV> } //<S2SV> # if HAVE_DECL_CLONE_NEWNET //<S2SV> if ( global_data && global_data -> network_namespace ) //<S2SV> clear_namespaces ( ) ; //<S2SV> # endif //<S2SV> if ( use_pid_dir ) //<S2SV> remove_pid_dir ( ) ; //<S2SV> if ( orig_core_dump_pattern ) //<S2SV> update_core_dump_pattern ( orig_core_dump_pattern ) ; //<S2SV> free_parent_mallocs_startup ( false ) ; //<S2SV> free_parent_mallocs_exit ( ) ; //<S2SV> free_global_data ( global_data ) ; //<S2SV> closelog ( ) ; //<S2SV> # ifndef _MEM_CHECK_LOG_ //<S2SV> FREE_PTR ( syslog_ident ) ; //<S2SV> # else //<S2SV> if ( syslog_ident ) //<S2SV> free ( syslog_ident ) ; //<S2SV> # endif //<S2SV> close_std_fd ( ) ; //<S2SV> exit ( KEEPALIVED_EXIT_OK ) ; //<S2SV> } //<S2SV> 