int append_camera_metadata ( camera_metadata_t * dst , //<S2SV> const camera_metadata_t * src ) { //<S2SV> if ( dst == NULL || src == NULL ) return ERROR ; //<S2SV> if ( dst -> entry_capacity < src -> entry_count + dst -> entry_count ) return ERROR ; //<S2SV> if ( dst -> data_capacity < src -> data_count + dst -> data_count ) return ERROR ; //<S2SV> memcpy ( get_entries ( dst ) + dst -> entry_count , get_entries ( src ) , //<S2SV> sizeof ( camera_metadata_buffer_entry_t [ src -> entry_count ] ) ) ; //<S2SV> memcpy ( get_data ( dst ) + dst -> data_count , get_data ( src ) , //<S2SV> sizeof ( uint8_t [ src -> data_count ] ) ) ; //<S2SV> if ( dst -> data_count != 0 ) { //<S2SV> camera_metadata_buffer_entry_t * entry = get_entries ( dst ) + dst -> entry_count ; //<S2SV> for ( size_t i = 0 ; i < src -> entry_count ; i ++ , entry ++ ) { //<S2SV> if ( calculate_camera_metadata_entry_data_size ( entry -> type , //<S2SV> entry -> count ) > 0 ) { //<S2SV> entry -> data . offset += dst -> data_count ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( dst -> entry_count == 0 ) { //<S2SV> dst -> flags |= src -> flags & FLAG_SORTED ; //<S2SV> } else if ( src -> entry_count != 0 ) { //<S2SV> dst -> flags &= ~ FLAG_SORTED ; //<S2SV> } else { //<S2SV> } //<S2SV> dst -> entry_count += src -> entry_count ; //<S2SV> dst -> data_count += src -> data_count ; //<S2SV> assert ( validate_camera_metadata_structure ( dst , NULL ) == OK ) ; //<S2SV> return OK ; //<S2SV> } //<S2SV> 