stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) //<S2SV> { //<S2SV> struct state * st = md -> st ; //<S2SV> lset_t policy = POLICY_IKEV2_ALLOW ; //<S2SV> struct connection * c = find_host_connection ( & md -> iface -> ip_addr , //<S2SV> md -> iface -> port , //<S2SV> & md -> sender , //<S2SV> md -> sender_port , //<S2SV> POLICY_IKEV2_ALLOW ) ; //<S2SV> # if 0 //<S2SV> if ( c == NULL ) { //<S2SV> pb_stream pre_sa_pbs = sa_pd -> pbs ; //<S2SV> policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; //<S2SV> c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , //<S2SV> ( ip_address * ) NULL , md -> sender_port , //<S2SV> policy ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( c == NULL ) { //<S2SV> { //<S2SV> struct connection * d ; //<S2SV> d = find_host_connection ( & md -> iface -> ip_addr , //<S2SV> pluto_port , //<S2SV> ( ip_address * ) NULL , //<S2SV> md -> sender_port , policy ) ; //<S2SV> for ( ; d != NULL ; d = d -> hp_next ) { //<S2SV> if ( d -> kind == CK_GROUP ) { //<S2SV> } else { //<S2SV> if ( d -> kind == CK_TEMPLATE && //<S2SV> ! ( d -> policy & POLICY_OPPO ) ) { //<S2SV> c = d ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( addrinsubnet ( & md -> sender , //<S2SV> & d -> spd . that . client ) //<S2SV> && //<S2SV> ( c == NULL || //<S2SV> ! subnetinsubnet ( & c -> spd . that . //<S2SV> client , //<S2SV> & d -> spd . that . //<S2SV> client ) ) ) //<S2SV> c = d ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( c == NULL ) { //<S2SV> loglog ( RC_LOG_SERIOUS , "initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u" //<S2SV> "<S2SV_blank>but<S2SV_blank>no<S2SV_blank>connection<S2SV_blank>has<S2SV_blank>been<S2SV_blank>authorized%s%s" , //<S2SV> ip_str ( //<S2SV> & md -> iface -> ip_addr ) , //<S2SV> ntohs ( portof ( & md -> iface -> ip_addr ) ) , //<S2SV> ( policy != LEMPTY ) ? "<S2SV_blank>with<S2SV_blank>policy=" : "" , //<S2SV> ( policy != //<S2SV> LEMPTY ) ? bitnamesof ( sa_policy_bit_names , //<S2SV> policy ) : "" ) ; //<S2SV> return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; //<S2SV> } //<S2SV> if ( c -> kind != CK_TEMPLATE ) { //<S2SV> loglog ( RC_LOG_SERIOUS , "initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u" //<S2SV> "<S2SV_blank>but<S2SV_blank>\\"%s\\"<S2SV_blank>forbids<S2SV_blank>connection" , //<S2SV> ip_str ( //<S2SV> & md -> iface -> ip_addr ) , pluto_port , //<S2SV> c -> name ) ; //<S2SV> return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; //<S2SV> } //<S2SV> c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; //<S2SV> } else { //<S2SV> if ( ( c -> kind == CK_TEMPLATE ) && c -> spd . that . virt ) { //<S2SV> DBG ( DBG_CONTROL , //<S2SV> DBG_log ( //<S2SV> "local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>virt<S2SV_blank>(vnet/vhost)<S2SV_blank>set<S2SV_blank>without<S2SV_blank>wildcards<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation" ) ) ; //<S2SV> c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; //<S2SV> } else if ( ( c -> kind == CK_TEMPLATE ) && //<S2SV> ( c -> policy & POLICY_IKEV2_ALLOW_NARROWING ) ) { //<S2SV> DBG ( DBG_CONTROL , //<S2SV> DBG_log ( //<S2SV> "local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>narrowing=yes<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation" ) ) ; //<S2SV> c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; //<S2SV> } //<S2SV> } //<S2SV> DBG_log ( "found<S2SV_blank>connection:<S2SV_blank>%s\\n" , c ? c -> name : "<none>" ) ; //<S2SV> if ( ! st ) { //<S2SV> st = new_state ( ) ; //<S2SV> memcpy ( st -> st_icookie , md -> hdr . isa_icookie , COOKIE_SIZE ) ; //<S2SV> get_cookie ( FALSE , st -> st_rcookie , COOKIE_SIZE , & md -> sender ) ; //<S2SV> initialize_new_state ( st , c , policy , 0 , NULL_FD , //<S2SV> pcim_stranger_crypto ) ; //<S2SV> st -> st_ikev2 = TRUE ; //<S2SV> change_state ( st , STATE_PARENT_R1 ) ; //<S2SV> st -> st_msgid_lastack = INVALID_MSGID ; //<S2SV> st -> st_msgid_nextuse = 0 ; //<S2SV> md -> st = st ; //<S2SV> md -> from_state = STATE_IKEv2_BASE ; //<S2SV> } //<S2SV> if ( force_busy == TRUE ) { //<S2SV> u_char dcookie [ SHA1_DIGEST_SIZE ] ; //<S2SV> chunk_t dc ; //<S2SV> ikev2_get_dcookie ( dcookie , st -> st_ni , & md -> sender , //<S2SV> st -> st_icookie ) ; //<S2SV> dc . ptr = dcookie ; //<S2SV> dc . len = SHA1_DIGEST_SIZE ; //<S2SV> if ( md -> chain [ ISAKMP_NEXT_v2KE ] && //<S2SV> md -> chain [ ISAKMP_NEXT_v2N ] && //<S2SV> ( md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type == //<S2SV> v2N_COOKIE ) ) { //<S2SV> u_int8_t spisize ; //<S2SV> const pb_stream * dc_pbs ; //<S2SV> chunk_t blob ; //<S2SV> DBG ( DBG_CONTROLMORE , //<S2SV> DBG_log ( "received<S2SV_blank>a<S2SV_blank>DOS<S2SV_blank>cookie<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>verify<S2SV_blank>it" ) ) ; //<S2SV> spisize = //<S2SV> md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . //<S2SV> isan_spisize ; //<S2SV> dc_pbs = & md -> chain [ ISAKMP_NEXT_v2N ] -> pbs ; //<S2SV> blob . ptr = dc_pbs -> cur + spisize ; //<S2SV> blob . len = pbs_left ( dc_pbs ) - spisize ; //<S2SV> DBG ( DBG_CONTROLMORE , //<S2SV> DBG_dump_chunk ( "dcookie<S2SV_blank>received<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>Packet" , //<S2SV> blob ) ; //<S2SV> DBG_dump ( "dcookie<S2SV_blank>computed" , dcookie , //<S2SV> SHA1_DIGEST_SIZE ) ) ; //<S2SV> if ( memcmp ( blob . ptr , dcookie , SHA1_DIGEST_SIZE ) != 0 ) { //<S2SV> libreswan_log ( //<S2SV> "mismatch<S2SV_blank>in<S2SV_blank>DOS<S2SV_blank>v2N_COOKIE,send<S2SV_blank>a<S2SV_blank>new<S2SV_blank>one" ) ; //<S2SV> SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; //<S2SV> return STF_FAIL + v2N_INVALID_IKE_SPI ; //<S2SV> } //<S2SV> DBG ( DBG_CONTROLMORE , //<S2SV> DBG_log ( "dcookie<S2SV_blank>received<S2SV_blank>match<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>one" ) ) ; //<S2SV> } else { //<S2SV> DBG ( DBG_CONTROLMORE , //<S2SV> DBG_log ( //<S2SV> "busy<S2SV_blank>mode<S2SV_blank>on.<S2SV_blank>receieved<S2SV_blank>I1<S2SV_blank>without<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>dcookie" ) ; //<S2SV> DBG_log ( "send<S2SV_blank>a<S2SV_blank>dcookie<S2SV_blank>and<S2SV_blank>forget<S2SV_blank>this<S2SV_blank>state" ) ) ; //<S2SV> SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; //<S2SV> return STF_FAIL ; //<S2SV> } //<S2SV> } else { //<S2SV> DBG ( DBG_CONTROLMORE , //<S2SV> DBG_log ( "will<S2SV_blank>not<S2SV_blank>send/process<S2SV_blank>a<S2SV_blank>dcookie" ) ) ; //<S2SV> } //<S2SV> { //<S2SV> struct ikev2_ke * ke ; //<S2SV> char fromname [ ADDRTOT_BUF ] ; //<S2SV> addrtot ( & md -> sender , 0 , fromname , ADDRTOT_BUF ) ; //<S2SV> if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { //<S2SV> if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { //<S2SV> libreswan_log ( "Received<S2SV_blank>Notify(%d):<S2SV_blank>%s" , //<S2SV> md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , //<S2SV> enum_name ( & ikev2_notify_names , //<S2SV> md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; //<S2SV> } //<S2SV> libreswan_log ( //<S2SV> "rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present" , //<S2SV> fromname , md -> sender_port ) ; //<S2SV> return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; //<S2SV> } //<S2SV> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; //<S2SV> st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; //<S2SV> if ( st -> st_oakley . group == NULL ) { //<S2SV> libreswan_log ( //<S2SV> "rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u" , //<S2SV> fromname , md -> sender_port , //<S2SV> ke -> isak_group ) ; //<S2SV> return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> struct ke_continuation * ke = alloc_thing ( //<S2SV> struct ke_continuation , //<S2SV> "ikev2_inI1outR1<S2SV_blank>KE" ) ; //<S2SV> stf_status e ; //<S2SV> ke -> md = md ; //<S2SV> set_suspended ( st , ke -> md ) ; //<S2SV> if ( ! st -> st_sec_in_use ) { //<S2SV> pcrc_init ( & ke -> ke_pcrc ) ; //<S2SV> ke -> ke_pcrc . pcrc_func = //<S2SV> ikev2_parent_inI1outR1_continue ; //<S2SV> e = build_ke ( & ke -> ke_pcrc , st , st -> st_oakley . group , //<S2SV> pcim_stranger_crypto ) ; //<S2SV> if ( e != STF_SUSPEND && e != STF_INLINE ) { //<S2SV> loglog ( RC_CRYPTOFAILED , "system<S2SV_blank>too<S2SV_blank>busy" ) ; //<S2SV> delete_state ( st ) ; //<S2SV> } //<S2SV> } else { //<S2SV> e = //<S2SV> ikev2_parent_inI1outR1_tail ( ( struct //<S2SV> pluto_crypto_req_cont //<S2SV> * ) ke , //<S2SV> NULL ) ; //<S2SV> } //<S2SV> reset_globals ( ) ; //<S2SV> return e ; //<S2SV> } //<S2SV> } //<S2SV> 