void //<S2SV> xmlParsePEReference ( xmlParserCtxtPtr ctxt ) //<S2SV> { //<S2SV> const xmlChar * name ; //<S2SV> xmlEntityPtr entity = NULL ; //<S2SV> xmlParserInputPtr input ; //<S2SV> if ( RAW != '%' ) //<S2SV> return ; //<S2SV> NEXT ; //<S2SV> name = xmlParseName ( ctxt ) ; //<S2SV> if ( name == NULL ) { //<S2SV> xmlFatalErrMsg ( ctxt , XML_ERR_NAME_REQUIRED , //<S2SV> "xmlParsePEReference:<S2SV_blank>no<S2SV_blank>name\\n" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( RAW != ';' ) { //<S2SV> xmlFatalErr ( ctxt , XML_ERR_ENTITYREF_SEMICOL_MISSING , NULL ) ; //<S2SV> return ; //<S2SV> } //<S2SV> NEXT ; //<S2SV> ctxt -> nbentities ++ ; //<S2SV> if ( ( ctxt -> sax != NULL ) && //<S2SV> ( ctxt -> sax -> getParameterEntity != NULL ) ) //<S2SV> entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; //<S2SV> if ( ctxt -> instate == XML_PARSER_EOF ) //<S2SV> return ; //<S2SV> if ( entity == NULL ) { //<S2SV> if ( ( ctxt -> standalone == 1 ) || //<S2SV> ( ( ctxt -> hasExternalSubset == 0 ) && //<S2SV> ( ctxt -> hasPErefs == 0 ) ) ) { //<S2SV> xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , //<S2SV> "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , //<S2SV> name ) ; //<S2SV> } else { //<S2SV> xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , //<S2SV> "PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n" , //<S2SV> name , NULL ) ; //<S2SV> ctxt -> valid = 0 ; //<S2SV> } //<S2SV> xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; //<S2SV> } else { //<S2SV> if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && //<S2SV> ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { //<S2SV> xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , //<S2SV> "Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\n" , //<S2SV> name , NULL ) ; //<S2SV> } else if ( ctxt -> input -> free != deallocblankswrapper ) { //<S2SV> input = xmlNewBlanksWrapperInputStream ( ctxt , entity ) ; //<S2SV> if ( xmlPushInput ( ctxt , input ) < 0 ) //<S2SV> return ; //<S2SV> } else { //<S2SV> if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && //<S2SV> ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && //<S2SV> ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && //<S2SV> ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && //<S2SV> ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && //<S2SV> ( ctxt -> replaceEntities == 0 ) && //<S2SV> ( ctxt -> validate == 0 ) ) //<S2SV> return ; //<S2SV> input = xmlNewEntityInputStream ( ctxt , entity ) ; //<S2SV> if ( xmlPushInput ( ctxt , input ) < 0 ) //<S2SV> return ; //<S2SV> if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && //<S2SV> ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && //<S2SV> ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { //<S2SV> xmlParseTextDecl ( ctxt ) ; //<S2SV> if ( ctxt -> errNo == //<S2SV> XML_ERR_UNSUPPORTED_ENCODING ) { //<S2SV> xmlHaltParser ( ctxt ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ctxt -> hasPErefs = 1 ; //<S2SV> } //<S2SV> 