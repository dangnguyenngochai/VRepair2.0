static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags , //<S2SV> struct in6_addr * addr , uint32_t * ifindex , int * hoplimit ) //<S2SV> { //<S2SV> struct sockaddr_in6 sin6 ; //<S2SV> unsigned char cbuf [ 2 * CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ; //<S2SV> struct iovec iovec ; //<S2SV> struct msghdr msghdr ; //<S2SV> struct cmsghdr * cmsghdr ; //<S2SV> ssize_t len ; //<S2SV> iovec . iov_len = * buflen ; //<S2SV> iovec . iov_base = buf ; //<S2SV> memset ( & msghdr , 0 , sizeof ( msghdr ) ) ; //<S2SV> msghdr . msg_name = & sin6 ; //<S2SV> msghdr . msg_namelen = sizeof ( sin6 ) ; //<S2SV> msghdr . msg_iov = & iovec ; //<S2SV> msghdr . msg_iovlen = 1 ; //<S2SV> msghdr . msg_control = cbuf ; //<S2SV> msghdr . msg_controllen = sizeof ( cbuf ) ; //<S2SV> len = recvmsg ( sockfd , & msghdr , flags ) ; //<S2SV> if ( len == - 1 ) //<S2SV> return - errno ; //<S2SV> * buflen = len ; //<S2SV> * ifindex = sin6 . sin6_scope_id ; //<S2SV> for ( cmsghdr = CMSG_FIRSTHDR ( & msghdr ) ; cmsghdr ; //<S2SV> cmsghdr = CMSG_NXTHDR ( & msghdr , cmsghdr ) ) { //<S2SV> if ( cmsghdr -> cmsg_level != IPPROTO_IPV6 ) //<S2SV> continue ; //<S2SV> switch ( cmsghdr -> cmsg_type ) { //<S2SV> case IPV6_PKTINFO : //<S2SV> if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) { //<S2SV> struct in6_pktinfo * pktinfo ; //<S2SV> pktinfo = ( struct in6_pktinfo * ) CMSG_DATA ( cmsghdr ) ; //<S2SV> * ifindex = pktinfo -> ipi6_ifindex ; //<S2SV> } //<S2SV> break ; //<S2SV> case IPV6_HOPLIMIT : //<S2SV> if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { //<S2SV> int * val ; //<S2SV> val = ( int * ) CMSG_DATA ( cmsghdr ) ; //<S2SV> * hoplimit = * val ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> * addr = sin6 . sin6_addr ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 