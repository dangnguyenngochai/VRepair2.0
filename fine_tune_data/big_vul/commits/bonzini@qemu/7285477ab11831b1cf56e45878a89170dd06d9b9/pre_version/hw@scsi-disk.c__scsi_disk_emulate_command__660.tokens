static int scsi_disk_emulate_command ( SCSIDiskReq * r , uint8_t * outbuf ) //<S2SV> { //<S2SV> SCSIRequest * req = & r -> req ; //<S2SV> SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; //<S2SV> uint64_t nb_sectors ; //<S2SV> int buflen = 0 ; //<S2SV> switch ( req -> cmd . buf [ 0 ] ) { //<S2SV> case TEST_UNIT_READY : //<S2SV> if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) //<S2SV> goto not_ready ; //<S2SV> break ; //<S2SV> case INQUIRY : //<S2SV> buflen = scsi_disk_emulate_inquiry ( req , outbuf ) ; //<S2SV> if ( buflen < 0 ) //<S2SV> goto illegal_request ; //<S2SV> break ; //<S2SV> case MODE_SENSE : //<S2SV> case MODE_SENSE_10 : //<S2SV> buflen = scsi_disk_emulate_mode_sense ( r , outbuf ) ; //<S2SV> if ( buflen < 0 ) //<S2SV> goto illegal_request ; //<S2SV> break ; //<S2SV> case READ_TOC : //<S2SV> buflen = scsi_disk_emulate_read_toc ( req , outbuf ) ; //<S2SV> if ( buflen < 0 ) //<S2SV> goto illegal_request ; //<S2SV> break ; //<S2SV> case RESERVE : //<S2SV> if ( req -> cmd . buf [ 1 ] & 1 ) //<S2SV> goto illegal_request ; //<S2SV> break ; //<S2SV> case RESERVE_10 : //<S2SV> if ( req -> cmd . buf [ 1 ] & 3 ) //<S2SV> goto illegal_request ; //<S2SV> break ; //<S2SV> case RELEASE : //<S2SV> if ( req -> cmd . buf [ 1 ] & 1 ) //<S2SV> goto illegal_request ; //<S2SV> break ; //<S2SV> case RELEASE_10 : //<S2SV> if ( req -> cmd . buf [ 1 ] & 3 ) //<S2SV> goto illegal_request ; //<S2SV> break ; //<S2SV> case START_STOP : //<S2SV> if ( scsi_disk_emulate_start_stop ( r ) < 0 ) { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case ALLOW_MEDIUM_REMOVAL : //<S2SV> s -> tray_locked = req -> cmd . buf [ 4 ] & 1 ; //<S2SV> bdrv_lock_medium ( s -> bs , req -> cmd . buf [ 4 ] & 1 ) ; //<S2SV> break ; //<S2SV> case READ_CAPACITY_10 : //<S2SV> memset ( outbuf , 0 , 8 ) ; //<S2SV> bdrv_get_geometry ( s -> bs , & nb_sectors ) ; //<S2SV> if ( ! nb_sectors ) //<S2SV> goto not_ready ; //<S2SV> nb_sectors /= s -> cluster_size ; //<S2SV> nb_sectors -- ; //<S2SV> s -> max_lba = nb_sectors ; //<S2SV> if ( nb_sectors > UINT32_MAX ) //<S2SV> nb_sectors = UINT32_MAX ; //<S2SV> outbuf [ 0 ] = ( nb_sectors >> 24 ) & 0xff ; //<S2SV> outbuf [ 1 ] = ( nb_sectors >> 16 ) & 0xff ; //<S2SV> outbuf [ 2 ] = ( nb_sectors >> 8 ) & 0xff ; //<S2SV> outbuf [ 3 ] = nb_sectors & 0xff ; //<S2SV> outbuf [ 4 ] = 0 ; //<S2SV> outbuf [ 5 ] = 0 ; //<S2SV> outbuf [ 6 ] = s -> cluster_size * 2 ; //<S2SV> outbuf [ 7 ] = 0 ; //<S2SV> buflen = 8 ; //<S2SV> break ; //<S2SV> case GET_CONFIGURATION : //<S2SV> memset ( outbuf , 0 , 8 ) ; //<S2SV> outbuf [ 7 ] = 8 ; //<S2SV> buflen = 8 ; //<S2SV> break ; //<S2SV> case SERVICE_ACTION_IN_16 : //<S2SV> if ( ( req -> cmd . buf [ 1 ] & 31 ) == SAI_READ_CAPACITY_16 ) { //<S2SV> DPRINTF ( "SAI<S2SV_blank>READ<S2SV_blank>CAPACITY(16)\\n" ) ; //<S2SV> memset ( outbuf , 0 , req -> cmd . xfer ) ; //<S2SV> bdrv_get_geometry ( s -> bs , & nb_sectors ) ; //<S2SV> if ( ! nb_sectors ) //<S2SV> goto not_ready ; //<S2SV> nb_sectors /= s -> cluster_size ; //<S2SV> nb_sectors -- ; //<S2SV> s -> max_lba = nb_sectors ; //<S2SV> outbuf [ 0 ] = ( nb_sectors >> 56 ) & 0xff ; //<S2SV> outbuf [ 1 ] = ( nb_sectors >> 48 ) & 0xff ; //<S2SV> outbuf [ 2 ] = ( nb_sectors >> 40 ) & 0xff ; //<S2SV> outbuf [ 3 ] = ( nb_sectors >> 32 ) & 0xff ; //<S2SV> outbuf [ 4 ] = ( nb_sectors >> 24 ) & 0xff ; //<S2SV> outbuf [ 5 ] = ( nb_sectors >> 16 ) & 0xff ; //<S2SV> outbuf [ 6 ] = ( nb_sectors >> 8 ) & 0xff ; //<S2SV> outbuf [ 7 ] = nb_sectors & 0xff ; //<S2SV> outbuf [ 8 ] = 0 ; //<S2SV> outbuf [ 9 ] = 0 ; //<S2SV> outbuf [ 10 ] = s -> cluster_size * 2 ; //<S2SV> outbuf [ 11 ] = 0 ; //<S2SV> outbuf [ 12 ] = 0 ; //<S2SV> outbuf [ 13 ] = get_physical_block_exp ( & s -> qdev . conf ) ; //<S2SV> if ( s -> qdev . conf . discard_granularity ) { //<S2SV> outbuf [ 14 ] = 0x80 ; //<S2SV> } //<S2SV> buflen = req -> cmd . xfer ; //<S2SV> break ; //<S2SV> } //<S2SV> DPRINTF ( "Unsupported<S2SV_blank>Service<S2SV_blank>Action<S2SV_blank>In\\n" ) ; //<S2SV> goto illegal_request ; //<S2SV> case VERIFY_10 : //<S2SV> break ; //<S2SV> default : //<S2SV> scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> return buflen ; //<S2SV> not_ready : //<S2SV> if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) { //<S2SV> scsi_check_condition ( r , SENSE_CODE ( NO_MEDIUM ) ) ; //<S2SV> } else { //<S2SV> scsi_check_condition ( r , SENSE_CODE ( LUN_NOT_READY ) ) ; //<S2SV> } //<S2SV> return - 1 ; //<S2SV> illegal_request : //<S2SV> if ( r -> req . status == - 1 ) { //<S2SV> scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; //<S2SV> } //<S2SV> return - 1 ; //<S2SV> } //<S2SV> 