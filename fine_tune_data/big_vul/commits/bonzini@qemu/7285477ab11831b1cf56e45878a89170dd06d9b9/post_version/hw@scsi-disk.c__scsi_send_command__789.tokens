static int32_t scsi_send_command ( SCSIRequest * req , uint8_t * buf ) //<S2SV> { //<S2SV> SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; //<S2SV> SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; //<S2SV> int32_t len ; //<S2SV> uint8_t command ; //<S2SV> int rc ; //<S2SV> command = buf [ 0 ] ; //<S2SV> DPRINTF ( "Command:<S2SV_blank>lun=%d<S2SV_blank>tag=0x%x<S2SV_blank>data=0x%02x" , req -> lun , req -> tag , buf [ 0 ] ) ; //<S2SV> # ifdef DEBUG_SCSI //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 1 ; i < r -> req . cmd . len ; i ++ ) { //<S2SV> printf ( "<S2SV_blank>0x%02x" , buf [ i ] ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> switch ( command ) { //<S2SV> case TEST_UNIT_READY : //<S2SV> case INQUIRY : //<S2SV> case MODE_SENSE : //<S2SV> case MODE_SENSE_10 : //<S2SV> case RESERVE : //<S2SV> case RESERVE_10 : //<S2SV> case RELEASE : //<S2SV> case RELEASE_10 : //<S2SV> case START_STOP : //<S2SV> case ALLOW_MEDIUM_REMOVAL : //<S2SV> case READ_CAPACITY_10 : //<S2SV> case READ_TOC : //<S2SV> case GET_CONFIGURATION : //<S2SV> case SERVICE_ACTION_IN_16 : //<S2SV> case VERIFY_10 : //<S2SV> rc = scsi_disk_emulate_command ( r ) ; //<S2SV> if ( rc < 0 ) { //<S2SV> return 0 ; //<S2SV> } //<S2SV> r -> iov . iov_len = rc ; //<S2SV> break ; //<S2SV> case SYNCHRONIZE_CACHE : //<S2SV> bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ; //<S2SV> r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ; //<S2SV> if ( r -> req . aiocb == NULL ) { //<S2SV> scsi_flush_complete ( r , - EIO ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case READ_6 : //<S2SV> case READ_10 : //<S2SV> case READ_12 : //<S2SV> case READ_16 : //<S2SV> len = r -> req . cmd . xfer / s -> qdev . blocksize ; //<S2SV> DPRINTF ( "Read<S2SV_blank>(sector<S2SV_blank>%" PRId64 ",<S2SV_blank>count<S2SV_blank>%d)\\n" , r -> req . cmd . lba , len ) ; //<S2SV> if ( r -> req . cmd . lba > s -> max_lba ) //<S2SV> goto illegal_lba ; //<S2SV> r -> sector = r -> req . cmd . lba * s -> cluster_size ; //<S2SV> r -> sector_count = len * s -> cluster_size ; //<S2SV> break ; //<S2SV> case WRITE_6 : //<S2SV> case WRITE_10 : //<S2SV> case WRITE_12 : //<S2SV> case WRITE_16 : //<S2SV> case WRITE_VERIFY_10 : //<S2SV> case WRITE_VERIFY_12 : //<S2SV> case WRITE_VERIFY_16 : //<S2SV> len = r -> req . cmd . xfer / s -> qdev . blocksize ; //<S2SV> DPRINTF ( "Write<S2SV_blank>%s(sector<S2SV_blank>%" PRId64 ",<S2SV_blank>count<S2SV_blank>%d)\\n" , //<S2SV> ( command & 0xe ) == 0xe ? "And<S2SV_blank>Verify<S2SV_blank>" : "" , //<S2SV> r -> req . cmd . lba , len ) ; //<S2SV> if ( r -> req . cmd . lba > s -> max_lba ) //<S2SV> goto illegal_lba ; //<S2SV> r -> sector = r -> req . cmd . lba * s -> cluster_size ; //<S2SV> r -> sector_count = len * s -> cluster_size ; //<S2SV> break ; //<S2SV> case MODE_SELECT : //<S2SV> DPRINTF ( "Mode<S2SV_blank>Select(6)<S2SV_blank>(len<S2SV_blank>%lu)\\n" , ( long ) r -> req . cmd . xfer ) ; //<S2SV> if ( r -> req . cmd . xfer > 12 ) { //<S2SV> goto fail ; //<S2SV> } //<S2SV> break ; //<S2SV> case MODE_SELECT_10 : //<S2SV> DPRINTF ( "Mode<S2SV_blank>Select(10)<S2SV_blank>(len<S2SV_blank>%lu)\\n" , ( long ) r -> req . cmd . xfer ) ; //<S2SV> if ( r -> req . cmd . xfer > 16 ) { //<S2SV> goto fail ; //<S2SV> } //<S2SV> break ; //<S2SV> case SEEK_6 : //<S2SV> case SEEK_10 : //<S2SV> DPRINTF ( "Seek(%d)<S2SV_blank>(sector<S2SV_blank>%" PRId64 ")\\n" , command == SEEK_6 ? 6 : 10 , //<S2SV> r -> req . cmd . lba ) ; //<S2SV> if ( r -> req . cmd . lba > s -> max_lba ) { //<S2SV> goto illegal_lba ; //<S2SV> } //<S2SV> break ; //<S2SV> case WRITE_SAME_16 : //<S2SV> len = r -> req . cmd . xfer / s -> qdev . blocksize ; //<S2SV> DPRINTF ( "WRITE<S2SV_blank>SAME(16)<S2SV_blank>(sector<S2SV_blank>%" PRId64 ",<S2SV_blank>count<S2SV_blank>%d)\\n" , //<S2SV> r -> req . cmd . lba , len ) ; //<S2SV> if ( r -> req . cmd . lba > s -> max_lba ) { //<S2SV> goto illegal_lba ; //<S2SV> } //<S2SV> if ( ! ( buf [ 1 ] & 0x8 ) ) { //<S2SV> goto fail ; //<S2SV> } //<S2SV> rc = bdrv_discard ( s -> bs , r -> req . cmd . lba * s -> cluster_size , //<S2SV> len * s -> cluster_size ) ; //<S2SV> if ( rc < 0 ) { //<S2SV> goto fail ; //<S2SV> } //<S2SV> break ; //<S2SV> case REQUEST_SENSE : //<S2SV> abort ( ) ; //<S2SV> default : //<S2SV> DPRINTF ( "Unknown<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>(%2.2x)\\n" , buf [ 0 ] ) ; //<S2SV> scsi_check_condition ( r , SENSE_CODE ( INVALID_OPCODE ) ) ; //<S2SV> return 0 ; //<S2SV> fail : //<S2SV> scsi_check_condition ( r , SENSE_CODE ( INVALID_FIELD ) ) ; //<S2SV> return 0 ; //<S2SV> illegal_lba : //<S2SV> scsi_check_condition ( r , SENSE_CODE ( LBA_OUT_OF_RANGE ) ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( r -> sector_count == 0 && r -> iov . iov_len == 0 ) { //<S2SV> scsi_req_complete ( & r -> req , GOOD ) ; //<S2SV> } //<S2SV> len = r -> sector_count * 512 + r -> iov . iov_len ; //<S2SV> if ( r -> req . cmd . mode == SCSI_XFER_TO_DEV ) { //<S2SV> return - len ; //<S2SV> } else { //<S2SV> if ( ! r -> sector_count ) //<S2SV> r -> sector_count = - 1 ; //<S2SV> return len ; //<S2SV> } //<S2SV> } //<S2SV> 