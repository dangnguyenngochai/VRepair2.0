static void scsi_dma_restart_bh ( void * opaque ) //<S2SV> { //<S2SV> SCSIDiskState * s = opaque ; //<S2SV> SCSIRequest * req ; //<S2SV> SCSIDiskReq * r ; //<S2SV> qemu_bh_delete ( s -> bh ) ; //<S2SV> s -> bh = NULL ; //<S2SV> QTAILQ_FOREACH ( req , & s -> qdev . requests , next ) { //<S2SV> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; //<S2SV> if ( r -> status & SCSI_REQ_STATUS_RETRY ) { //<S2SV> int status = r -> status ; //<S2SV> int ret ; //<S2SV> r -> status &= //<S2SV> ~ ( SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK ) ; //<S2SV> switch ( status & SCSI_REQ_STATUS_RETRY_TYPE_MASK ) { //<S2SV> case SCSI_REQ_STATUS_RETRY_READ : //<S2SV> scsi_read_data ( & r -> req ) ; //<S2SV> break ; //<S2SV> case SCSI_REQ_STATUS_RETRY_WRITE : //<S2SV> scsi_write_data ( & r -> req ) ; //<S2SV> break ; //<S2SV> case SCSI_REQ_STATUS_RETRY_FLUSH : //<S2SV> ret = scsi_disk_emulate_command ( r ) ; //<S2SV> if ( ret == 0 ) { //<S2SV> scsi_req_complete ( & r -> req , GOOD ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 