int //<S2SV> connection_exit_begin_conn ( cell_t * cell , circuit_t * circ ) //<S2SV> { //<S2SV> edge_connection_t * n_stream ; //<S2SV> relay_header_t rh ; //<S2SV> char * address = NULL ; //<S2SV> uint16_t port = 0 ; //<S2SV> or_circuit_t * or_circ = NULL ; //<S2SV> origin_circuit_t * origin_circ = NULL ; //<S2SV> crypt_path_t * layer_hint = NULL ; //<S2SV> const or_options_t * options = get_options ( ) ; //<S2SV> begin_cell_t bcell ; //<S2SV> int rv ; //<S2SV> uint8_t end_reason = 0 ; //<S2SV> assert_circuit_ok ( circ ) ; //<S2SV> if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) { //<S2SV> or_circ = TO_OR_CIRCUIT ( circ ) ; //<S2SV> } else { //<S2SV> tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; //<S2SV> origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; //<S2SV> layer_hint = origin_circ -> cpath -> prev ; //<S2SV> } //<S2SV> relay_header_unpack ( & rh , cell -> payload ) ; //<S2SV> if ( rh . length > RELAY_PAYLOAD_SIZE ) //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> if ( ! server_mode ( options ) && //<S2SV> circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "Relay<S2SV_blank>begin<S2SV_blank>cell<S2SV_blank>at<S2SV_blank>non-server.<S2SV_blank>Closing." ) ; //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , //<S2SV> END_STREAM_REASON_EXITPOLICY , NULL ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> rv = begin_cell_parse ( cell , & bcell , & end_reason ) ; //<S2SV> if ( rv < - 1 ) { //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } else if ( rv == - 1 ) { //<S2SV> tor_free ( bcell . address ) ; //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , layer_hint ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! bcell . is_begindir ) { //<S2SV> address = bcell . address ; //<S2SV> port = bcell . port ; //<S2SV> if ( or_circ && or_circ -> p_chan ) { //<S2SV> if ( ! options -> AllowSingleHopExits && //<S2SV> ( or_circ -> is_first_hop || //<S2SV> ( ! connection_or_digest_is_known_relay ( //<S2SV> or_circ -> p_chan -> identity_digest ) && //<S2SV> should_refuse_unknown_exits ( options ) ) ) ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "Attempt<S2SV_blank>by<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>open<S2SV_blank>a<S2SV_blank>stream<S2SV_blank>%s.<S2SV_blank>Closing." , //<S2SV> safe_str ( channel_get_canonical_remote_descr ( or_circ -> p_chan ) ) , //<S2SV> or_circ -> is_first_hop ? "on<S2SV_blank>first<S2SV_blank>hop<S2SV_blank>of<S2SV_blank>circuit" : //<S2SV> "from<S2SV_blank>unknown<S2SV_blank>relay" ) ; //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , //<S2SV> or_circ -> is_first_hop ? //<S2SV> END_STREAM_REASON_TORPROTOCOL : //<S2SV> END_STREAM_REASON_MISC , //<S2SV> NULL ) ; //<S2SV> tor_free ( address ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { //<S2SV> if ( ! directory_permits_begindir_requests ( options ) || //<S2SV> circ -> purpose != CIRCUIT_PURPOSE_OR ) { //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , //<S2SV> END_STREAM_REASON_NOTDIRECTORY , layer_hint ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( or_circ && or_circ -> p_chan ) //<S2SV> address = tor_strdup ( channel_get_actual_remote_address ( or_circ -> p_chan ) ) ; //<S2SV> else //<S2SV> address = tor_strdup ( "127.0.0.1" ) ; //<S2SV> port = 1 ; //<S2SV> } else { //<S2SV> log_warn ( LD_BUG , "Got<S2SV_blank>an<S2SV_blank>unexpected<S2SV_blank>command<S2SV_blank>%d" , ( int ) rh . command ) ; //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , //<S2SV> END_STREAM_REASON_INTERNAL , layer_hint ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! options -> IPv6Exit ) { //<S2SV> bcell . flags &= ~ BEGIN_FLAG_IPV6_PREFERRED ; //<S2SV> if ( bcell . flags & BEGIN_FLAG_IPV4_NOT_OK ) { //<S2SV> tor_free ( address ) ; //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , //<S2SV> END_STREAM_REASON_EXITPOLICY , layer_hint ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> log_debug ( LD_EXIT , "Creating<S2SV_blank>new<S2SV_blank>exit<S2SV_blank>connection." ) ; //<S2SV> n_stream = edge_connection_new ( CONN_TYPE_EXIT , AF_INET ) ; //<S2SV> n_stream -> dirreq_id = circ -> dirreq_id ; //<S2SV> n_stream -> base_ . purpose = EXIT_PURPOSE_CONNECT ; //<S2SV> n_stream -> begincell_flags = bcell . flags ; //<S2SV> n_stream -> stream_id = rh . stream_id ; //<S2SV> n_stream -> base_ . port = port ; //<S2SV> n_stream -> package_window = STREAMWINDOW_START ; //<S2SV> n_stream -> deliver_window = STREAMWINDOW_START ; //<S2SV> if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) { //<S2SV> tor_assert ( origin_circ ) ; //<S2SV> log_info ( LD_REND , "begin<S2SV_blank>is<S2SV_blank>for<S2SV_blank>rendezvous.<S2SV_blank>configuring<S2SV_blank>stream." ) ; //<S2SV> n_stream -> base_ . address = tor_strdup ( "(rendezvous)" ) ; //<S2SV> n_stream -> base_ . state = EXIT_CONN_STATE_CONNECTING ; //<S2SV> n_stream -> rend_data = rend_data_dup ( origin_circ -> rend_data ) ; //<S2SV> tor_assert ( connection_edge_is_rendezvous_stream ( n_stream ) ) ; //<S2SV> assert_circuit_ok ( circ ) ; //<S2SV> const int r = rend_service_set_connection_addr_port ( n_stream , origin_circ ) ; //<S2SV> if ( r < 0 ) { //<S2SV> log_info ( LD_REND , "Didn\'t<S2SV_blank>find<S2SV_blank>rendezvous<S2SV_blank>service<S2SV_blank>(port<S2SV_blank>%d)" , //<S2SV> n_stream -> base_ . port ) ; //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , //<S2SV> END_STREAM_REASON_DONE , //<S2SV> layer_hint ) ; //<S2SV> connection_free ( TO_CONN ( n_stream ) ) ; //<S2SV> tor_free ( address ) ; //<S2SV> if ( r < - 1 ) //<S2SV> return END_CIRC_AT_ORIGIN ; //<S2SV> else //<S2SV> return 0 ; //<S2SV> } //<S2SV> assert_circuit_ok ( circ ) ; //<S2SV> log_debug ( LD_REND , "Finished<S2SV_blank>assigning<S2SV_blank>addr/port" ) ; //<S2SV> n_stream -> cpath_layer = origin_circ -> cpath -> prev ; //<S2SV> n_stream -> next_stream = origin_circ -> p_streams ; //<S2SV> n_stream -> on_circuit = circ ; //<S2SV> origin_circ -> p_streams = n_stream ; //<S2SV> assert_circuit_ok ( circ ) ; //<S2SV> origin_circ -> rend_data -> nr_streams ++ ; //<S2SV> connection_exit_connect ( n_stream ) ; //<S2SV> pathbias_mark_use_success ( origin_circ ) ; //<S2SV> tor_free ( address ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> tor_strlower ( address ) ; //<S2SV> n_stream -> base_ . address = address ; //<S2SV> n_stream -> base_ . state = EXIT_CONN_STATE_RESOLVEFAILED ; //<S2SV> if ( we_are_hibernating ( ) ) { //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , //<S2SV> END_STREAM_REASON_HIBERNATING , NULL ) ; //<S2SV> connection_free ( TO_CONN ( n_stream ) ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> n_stream -> on_circuit = circ ; //<S2SV> if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { //<S2SV> tor_addr_t tmp_addr ; //<S2SV> tor_assert ( or_circ ) ; //<S2SV> if ( or_circ -> p_chan && //<S2SV> channel_get_addr_if_possible ( or_circ -> p_chan , & tmp_addr ) ) { //<S2SV> tor_addr_copy ( & n_stream -> base_ . addr , & tmp_addr ) ; //<S2SV> } //<S2SV> return connection_exit_connect_dir ( n_stream ) ; //<S2SV> } //<S2SV> log_debug ( LD_EXIT , "about<S2SV_blank>to<S2SV_blank>start<S2SV_blank>the<S2SV_blank>dns_resolve()." ) ; //<S2SV> switch ( dns_resolve ( n_stream ) ) { //<S2SV> case 1 : //<S2SV> assert_circuit_ok ( circ ) ; //<S2SV> log_debug ( LD_EXIT , "about<S2SV_blank>to<S2SV_blank>call<S2SV_blank>connection_exit_connect()." ) ; //<S2SV> connection_exit_connect ( n_stream ) ; //<S2SV> return 0 ; //<S2SV> case - 1 : //<S2SV> relay_send_end_cell_from_edge ( rh . stream_id , circ , //<S2SV> END_STREAM_REASON_RESOLVEFAILED , NULL ) ; //<S2SV> break ; //<S2SV> case 0 : //<S2SV> assert_circuit_ok ( circ ) ; //<S2SV> break ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 