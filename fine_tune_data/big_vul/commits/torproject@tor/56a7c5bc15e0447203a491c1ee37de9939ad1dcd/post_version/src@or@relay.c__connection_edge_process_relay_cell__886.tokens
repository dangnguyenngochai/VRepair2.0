static int //<S2SV> connection_edge_process_relay_cell ( cell_t * cell , circuit_t * circ , //<S2SV> edge_connection_t * conn , //<S2SV> crypt_path_t * layer_hint ) //<S2SV> { //<S2SV> static int num_seen = 0 ; //<S2SV> relay_header_t rh ; //<S2SV> unsigned domain = layer_hint ? LD_APP : LD_EXIT ; //<S2SV> int reason ; //<S2SV> int optimistic_data = 0 ; //<S2SV> tor_assert ( cell ) ; //<S2SV> tor_assert ( circ ) ; //<S2SV> relay_header_unpack ( & rh , cell -> payload ) ; //<S2SV> num_seen ++ ; //<S2SV> log_debug ( domain , "Now<S2SV_blank>seen<S2SV_blank>%d<S2SV_blank>relay<S2SV_blank>cells<S2SV_blank>here<S2SV_blank>(command<S2SV_blank>%d,<S2SV_blank>stream<S2SV_blank>%d)." , //<S2SV> num_seen , rh . command , rh . stream_id ) ; //<S2SV> if ( rh . length > RELAY_PAYLOAD_SIZE ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "Relay<S2SV_blank>cell<S2SV_blank>length<S2SV_blank>field<S2SV_blank>too<S2SV_blank>long.<S2SV_blank>Closing<S2SV_blank>circuit." ) ; //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } //<S2SV> if ( rh . stream_id == 0 ) { //<S2SV> switch ( rh . command ) { //<S2SV> case RELAY_COMMAND_BEGIN : //<S2SV> case RELAY_COMMAND_CONNECTED : //<S2SV> case RELAY_COMMAND_DATA : //<S2SV> case RELAY_COMMAND_END : //<S2SV> case RELAY_COMMAND_RESOLVE : //<S2SV> case RELAY_COMMAND_RESOLVED : //<S2SV> case RELAY_COMMAND_BEGIN_DIR : //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , "Relay<S2SV_blank>command<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>zero<S2SV_blank>" //<S2SV> "stream_id.<S2SV_blank>Dropping." , ( int ) rh . command ) ; //<S2SV> return 0 ; //<S2SV> default : //<S2SV> ; //<S2SV> } //<S2SV> } //<S2SV> if ( conn && ! connection_state_is_open ( TO_CONN ( conn ) ) ) { //<S2SV> if ( conn -> base_ . type == CONN_TYPE_EXIT && //<S2SV> ( conn -> base_ . state == EXIT_CONN_STATE_CONNECTING || //<S2SV> conn -> base_ . state == EXIT_CONN_STATE_RESOLVING ) && //<S2SV> rh . command == RELAY_COMMAND_DATA ) { //<S2SV> optimistic_data = 1 ; //<S2SV> } else { //<S2SV> return connection_edge_process_relay_cell_not_open ( //<S2SV> & rh , cell , circ , conn , layer_hint ) ; //<S2SV> } //<S2SV> } //<S2SV> switch ( rh . command ) { //<S2SV> case RELAY_COMMAND_DROP : //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_BEGIN : //<S2SV> case RELAY_COMMAND_BEGIN_DIR : //<S2SV> if ( layer_hint && //<S2SV> circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_APP , //<S2SV> "Relay<S2SV_blank>begin<S2SV_blank>request<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>AP.<S2SV_blank>Dropping." ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED && //<S2SV> layer_hint != TO_ORIGIN_CIRCUIT ( circ ) -> cpath -> prev ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_APP , //<S2SV> "Relay<S2SV_blank>begin<S2SV_blank>request<S2SV_blank>to<S2SV_blank>Hidden<S2SV_blank>Service<S2SV_blank>" //<S2SV> "from<S2SV_blank>intermediary<S2SV_blank>node.<S2SV_blank>Dropping." ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( conn ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , domain , //<S2SV> "Begin<S2SV_blank>cell<S2SV_blank>for<S2SV_blank>known<S2SV_blank>stream.<S2SV_blank>Dropping." ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( rh . command == RELAY_COMMAND_BEGIN_DIR && //<S2SV> circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { //<S2SV> static uint64_t next_id = 0 ; //<S2SV> circ -> dirreq_id = ++ next_id ; //<S2SV> TO_OR_CIRCUIT ( circ ) -> p_chan -> dirreq_id = circ -> dirreq_id ; //<S2SV> } //<S2SV> return connection_exit_begin_conn ( cell , circ ) ; //<S2SV> case RELAY_COMMAND_DATA : //<S2SV> ++ stats_n_data_cells_received ; //<S2SV> if ( ( layer_hint && -- layer_hint -> deliver_window < 0 ) || //<S2SV> ( ! layer_hint && -- circ -> deliver_window < 0 ) ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "(relay<S2SV_blank>data)<S2SV_blank>circ<S2SV_blank>deliver_window<S2SV_blank>below<S2SV_blank>0.<S2SV_blank>Killing." ) ; //<S2SV> if ( conn ) { //<S2SV> connection_edge_end ( conn , END_STREAM_REASON_TORPROTOCOL ) ; //<S2SV> connection_mark_for_close ( TO_CONN ( conn ) ) ; //<S2SV> } //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } //<S2SV> log_debug ( domain , "circ<S2SV_blank>deliver_window<S2SV_blank>now<S2SV_blank>%d." , layer_hint ? //<S2SV> layer_hint -> deliver_window : circ -> deliver_window ) ; //<S2SV> circuit_consider_sending_sendme ( circ , layer_hint ) ; //<S2SV> if ( ! conn ) { //<S2SV> log_info ( domain , "data<S2SV_blank>cell<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream<S2SV_blank>(streamid<S2SV_blank>%d)." , //<S2SV> rh . stream_id ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( -- conn -> deliver_window < 0 ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "(relay<S2SV_blank>data)<S2SV_blank>conn<S2SV_blank>deliver_window<S2SV_blank>below<S2SV_blank>0.<S2SV_blank>Killing." ) ; //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } //<S2SV> stats_n_data_bytes_received += rh . length ; //<S2SV> connection_write_to_buf ( ( char * ) ( cell -> payload + RELAY_HEADER_SIZE ) , //<S2SV> rh . length , TO_CONN ( conn ) ) ; //<S2SV> if ( ! optimistic_data ) { //<S2SV> connection_edge_consider_sending_sendme ( conn ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_END : //<S2SV> reason = rh . length > 0 ? //<S2SV> get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) : END_STREAM_REASON_MISC ; //<S2SV> if ( ! conn ) { //<S2SV> log_info ( domain , "end<S2SV_blank>cell<S2SV_blank>(%s)<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream." , //<S2SV> stream_end_reason_to_string ( reason ) ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> log_info ( domain , TOR_SOCKET_T_FORMAT ":<S2SV_blank>end<S2SV_blank>cell<S2SV_blank>(%s)<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>%d.<S2SV_blank>" //<S2SV> "Removing<S2SV_blank>stream." , //<S2SV> conn -> base_ . s , //<S2SV> stream_end_reason_to_string ( reason ) , //<S2SV> conn -> stream_id ) ; //<S2SV> if ( conn -> base_ . type == CONN_TYPE_AP ) { //<S2SV> entry_connection_t * entry_conn = EDGE_TO_ENTRY_CONN ( conn ) ; //<S2SV> if ( entry_conn -> socks_request && //<S2SV> ! entry_conn -> socks_request -> has_finished ) //<S2SV> log_warn ( LD_BUG , //<S2SV> "open<S2SV_blank>stream<S2SV_blank>hasn\'t<S2SV_blank>sent<S2SV_blank>socks<S2SV_blank>answer<S2SV_blank>yet?<S2SV_blank>Closing." ) ; //<S2SV> } //<S2SV> conn -> edge_has_sent_end = 1 ; //<S2SV> if ( ! conn -> end_reason ) //<S2SV> conn -> end_reason = reason | END_STREAM_REASON_FLAG_REMOTE ; //<S2SV> if ( ! conn -> base_ . marked_for_close ) { //<S2SV> connection_mark_and_flush ( TO_CONN ( conn ) ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_EXTEND : //<S2SV> case RELAY_COMMAND_EXTEND2 : { //<S2SV> static uint64_t total_n_extend = 0 , total_nonearly = 0 ; //<S2SV> total_n_extend ++ ; //<S2SV> if ( rh . stream_id ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , domain , //<S2SV> "\'extend\'<S2SV_blank>cell<S2SV_blank>received<S2SV_blank>for<S2SV_blank>non-zero<S2SV_blank>stream.<S2SV_blank>Dropping." ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( cell -> command != CELL_RELAY_EARLY && //<S2SV> ! networkstatus_get_param ( NULL , "AllowNonearlyExtend" , 0 , 0 , 1 ) ) { //<S2SV> # define EARLY_WARNING_INTERVAL 3600 //<S2SV> static ratelim_t early_warning_limit = //<S2SV> RATELIM_INIT ( EARLY_WARNING_INTERVAL ) ; //<S2SV> char * m ; //<S2SV> if ( cell -> command == CELL_RELAY ) { //<S2SV> ++ total_nonearly ; //<S2SV> if ( ( m = rate_limit_log ( & early_warning_limit , approx_time ( ) ) ) ) { //<S2SV> double percentage = ( ( double ) total_nonearly ) / total_n_extend ; //<S2SV> percentage *= 100 ; //<S2SV> log_fn ( LOG_PROTOCOL_WARN , domain , "EXTEND<S2SV_blank>cell<S2SV_blank>received,<S2SV_blank>" //<S2SV> "but<S2SV_blank>not<S2SV_blank>via<S2SV_blank>RELAY_EARLY.<S2SV_blank>Dropping.%s" , m ) ; //<S2SV> log_fn ( LOG_PROTOCOL_WARN , domain , "<S2SV_blank><S2SV_blank>(We<S2SV_blank>have<S2SV_blank>dropped<S2SV_blank>%.02f%%<S2SV_blank>of<S2SV_blank>" //<S2SV> "all<S2SV_blank>EXTEND<S2SV_blank>cells<S2SV_blank>for<S2SV_blank>this<S2SV_blank>reason)" , percentage ) ; //<S2SV> tor_free ( m ) ; //<S2SV> } //<S2SV> } else { //<S2SV> log_fn ( LOG_WARN , domain , //<S2SV> "EXTEND<S2SV_blank>cell<S2SV_blank>received,<S2SV_blank>in<S2SV_blank>a<S2SV_blank>cell<S2SV_blank>with<S2SV_blank>type<S2SV_blank>%d!<S2SV_blank>Dropping." , //<S2SV> cell -> command ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> return circuit_extend ( cell , circ ) ; //<S2SV> } //<S2SV> case RELAY_COMMAND_EXTENDED : //<S2SV> case RELAY_COMMAND_EXTENDED2 : //<S2SV> if ( ! layer_hint ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "\'extended\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>non-origin.<S2SV_blank>Dropping." ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> log_debug ( domain , "Got<S2SV_blank>an<S2SV_blank>extended<S2SV_blank>cell!<S2SV_blank>Yay." ) ; //<S2SV> { //<S2SV> extended_cell_t extended_cell ; //<S2SV> if ( extended_cell_parse ( & extended_cell , rh . command , //<S2SV> ( const uint8_t * ) cell -> payload + RELAY_HEADER_SIZE , //<S2SV> rh . length ) < 0 ) { //<S2SV> log_warn ( LD_PROTOCOL , //<S2SV> "Can\'t<S2SV_blank>parse<S2SV_blank>EXTENDED<S2SV_blank>cell;<S2SV_blank>killing<S2SV_blank>circuit." ) ; //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } //<S2SV> if ( ( reason = circuit_finish_handshake ( TO_ORIGIN_CIRCUIT ( circ ) , //<S2SV> & extended_cell . created_cell ) ) < 0 ) { //<S2SV> log_warn ( domain , "circuit_finish_handshake<S2SV_blank>failed." ) ; //<S2SV> return reason ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( reason = circuit_send_next_onion_skin ( TO_ORIGIN_CIRCUIT ( circ ) ) ) < 0 ) { //<S2SV> log_info ( domain , "circuit_send_next_onion_skin()<S2SV_blank>failed." ) ; //<S2SV> return reason ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_TRUNCATE : //<S2SV> if ( layer_hint ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_APP , //<S2SV> "\'truncate\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>origin.<S2SV_blank>Dropping." ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( circ -> n_hop ) { //<S2SV> if ( circ -> n_chan ) //<S2SV> log_warn ( LD_BUG , "n_chan<S2SV_blank>and<S2SV_blank>n_hop<S2SV_blank>set<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>circuit!" ) ; //<S2SV> extend_info_free ( circ -> n_hop ) ; //<S2SV> circ -> n_hop = NULL ; //<S2SV> tor_free ( circ -> n_chan_create_cell ) ; //<S2SV> circuit_set_state ( circ , CIRCUIT_STATE_OPEN ) ; //<S2SV> } //<S2SV> if ( circ -> n_chan ) { //<S2SV> uint8_t trunc_reason = get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ; //<S2SV> circuit_clear_cell_queue ( circ , circ -> n_chan ) ; //<S2SV> channel_send_destroy ( circ -> n_circ_id , circ -> n_chan , //<S2SV> trunc_reason ) ; //<S2SV> circuit_set_n_circid_chan ( circ , 0 , NULL ) ; //<S2SV> } //<S2SV> log_debug ( LD_EXIT , "Processed<S2SV_blank>\'truncate\',<S2SV_blank>replying." ) ; //<S2SV> { //<S2SV> char payload [ 1 ] ; //<S2SV> payload [ 0 ] = ( char ) END_CIRC_REASON_REQUESTED ; //<S2SV> relay_send_command_from_edge ( 0 , circ , RELAY_COMMAND_TRUNCATED , //<S2SV> payload , sizeof ( payload ) , NULL ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_TRUNCATED : //<S2SV> if ( ! layer_hint ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_EXIT , //<S2SV> "\'truncated\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>non-origin.<S2SV_blank>Dropping." ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> circuit_truncated ( TO_ORIGIN_CIRCUIT ( circ ) , layer_hint , //<S2SV> get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ) ; //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_CONNECTED : //<S2SV> if ( conn ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "\'connected\'<S2SV_blank>unsupported<S2SV_blank>while<S2SV_blank>open.<S2SV_blank>Closing<S2SV_blank>circ." ) ; //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } //<S2SV> log_info ( domain , //<S2SV> "\'connected\'<S2SV_blank>received,<S2SV_blank>no<S2SV_blank>conn<S2SV_blank>attached<S2SV_blank>anymore.<S2SV_blank>Ignoring." ) ; //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_SENDME : //<S2SV> if ( ! rh . stream_id ) { //<S2SV> if ( layer_hint ) { //<S2SV> if ( layer_hint -> package_window + CIRCWINDOW_INCREMENT > //<S2SV> CIRCWINDOW_START_MAX ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "Unexpected<S2SV_blank>sendme<S2SV_blank>cell<S2SV_blank>from<S2SV_blank>exit<S2SV_blank>relay.<S2SV_blank>" //<S2SV> "Closing<S2SV_blank>circ." ) ; //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } //<S2SV> layer_hint -> package_window += CIRCWINDOW_INCREMENT ; //<S2SV> log_debug ( LD_APP , "circ-level<S2SV_blank>sendme<S2SV_blank>at<S2SV_blank>origin,<S2SV_blank>packagewindow<S2SV_blank>%d." , //<S2SV> layer_hint -> package_window ) ; //<S2SV> circuit_resume_edge_reading ( circ , layer_hint ) ; //<S2SV> } else { //<S2SV> if ( circ -> package_window + CIRCWINDOW_INCREMENT > //<S2SV> CIRCWINDOW_START_MAX ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "Unexpected<S2SV_blank>sendme<S2SV_blank>cell<S2SV_blank>from<S2SV_blank>client.<S2SV_blank>" //<S2SV> "Closing<S2SV_blank>circ<S2SV_blank>(window<S2SV_blank>%d)." , //<S2SV> circ -> package_window ) ; //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } //<S2SV> circ -> package_window += CIRCWINDOW_INCREMENT ; //<S2SV> log_debug ( LD_APP , //<S2SV> "circ-level<S2SV_blank>sendme<S2SV_blank>at<S2SV_blank>non-origin,<S2SV_blank>packagewindow<S2SV_blank>%d." , //<S2SV> circ -> package_window ) ; //<S2SV> circuit_resume_edge_reading ( circ , layer_hint ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! conn ) { //<S2SV> log_info ( domain , "sendme<S2SV_blank>cell<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream<S2SV_blank>(streamid<S2SV_blank>%d)." , //<S2SV> rh . stream_id ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> conn -> package_window += STREAMWINDOW_INCREMENT ; //<S2SV> log_debug ( domain , "stream-level<S2SV_blank>sendme,<S2SV_blank>packagewindow<S2SV_blank>now<S2SV_blank>%d." , //<S2SV> conn -> package_window ) ; //<S2SV> if ( circuit_queue_streams_are_blocked ( circ ) ) { //<S2SV> return 0 ; //<S2SV> } //<S2SV> connection_start_reading ( TO_CONN ( conn ) ) ; //<S2SV> if ( connection_edge_package_raw_inbuf ( conn , 1 , NULL ) < 0 ) { //<S2SV> connection_mark_for_close ( TO_CONN ( conn ) ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_RESOLVE : //<S2SV> if ( layer_hint ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_APP , //<S2SV> "resolve<S2SV_blank>request<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>AP;<S2SV_blank>dropping." ) ; //<S2SV> return 0 ; //<S2SV> } else if ( conn ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , domain , //<S2SV> "resolve<S2SV_blank>request<S2SV_blank>for<S2SV_blank>known<S2SV_blank>stream;<S2SV_blank>dropping." ) ; //<S2SV> return 0 ; //<S2SV> } else if ( circ -> purpose != CIRCUIT_PURPOSE_OR ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , domain , //<S2SV> "resolve<S2SV_blank>request<S2SV_blank>on<S2SV_blank>circ<S2SV_blank>with<S2SV_blank>purpose<S2SV_blank>%d;<S2SV_blank>dropping" , //<S2SV> circ -> purpose ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> connection_exit_begin_resolve ( cell , TO_OR_CIRCUIT ( circ ) ) ; //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_RESOLVED : //<S2SV> if ( conn ) { //<S2SV> log_fn ( LOG_PROTOCOL_WARN , domain , //<S2SV> "\'resolved\'<S2SV_blank>unsupported<S2SV_blank>while<S2SV_blank>open.<S2SV_blank>Closing<S2SV_blank>circ." ) ; //<S2SV> return - END_CIRC_REASON_TORPROTOCOL ; //<S2SV> } //<S2SV> log_info ( domain , //<S2SV> "\'resolved\'<S2SV_blank>received,<S2SV_blank>no<S2SV_blank>conn<S2SV_blank>attached<S2SV_blank>anymore.<S2SV_blank>Ignoring." ) ; //<S2SV> return 0 ; //<S2SV> case RELAY_COMMAND_ESTABLISH_INTRO : //<S2SV> case RELAY_COMMAND_ESTABLISH_RENDEZVOUS : //<S2SV> case RELAY_COMMAND_INTRODUCE1 : //<S2SV> case RELAY_COMMAND_INTRODUCE2 : //<S2SV> case RELAY_COMMAND_INTRODUCE_ACK : //<S2SV> case RELAY_COMMAND_RENDEZVOUS1 : //<S2SV> case RELAY_COMMAND_RENDEZVOUS2 : //<S2SV> case RELAY_COMMAND_INTRO_ESTABLISHED : //<S2SV> case RELAY_COMMAND_RENDEZVOUS_ESTABLISHED : //<S2SV> rend_process_relay_cell ( circ , layer_hint , //<S2SV> rh . command , rh . length , //<S2SV> cell -> payload + RELAY_HEADER_SIZE ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , //<S2SV> "Received<S2SV_blank>unknown<S2SV_blank>relay<S2SV_blank>command<S2SV_blank>%d.<S2SV_blank>Perhaps<S2SV_blank>the<S2SV_blank>other<S2SV_blank>side<S2SV_blank>is<S2SV_blank>using<S2SV_blank>" //<S2SV> "a<S2SV_blank>newer<S2SV_blank>version<S2SV_blank>of<S2SV_blank>Tor?<S2SV_blank>Dropping." , //<S2SV> rh . command ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 