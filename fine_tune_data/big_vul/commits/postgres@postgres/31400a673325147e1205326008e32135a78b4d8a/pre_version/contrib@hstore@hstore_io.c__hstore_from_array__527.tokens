Datum //<S2SV> hstore_from_array ( PG_FUNCTION_ARGS ) //<S2SV> { //<S2SV> ArrayType * in_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; //<S2SV> int ndims = ARR_NDIM ( in_array ) ; //<S2SV> int count ; //<S2SV> int32 buflen ; //<S2SV> HStore * out ; //<S2SV> Pairs * pairs ; //<S2SV> Datum * in_datums ; //<S2SV> bool * in_nulls ; //<S2SV> int in_count ; //<S2SV> int i ; //<S2SV> Assert ( ARR_ELEMTYPE ( in_array ) == TEXTOID ) ; //<S2SV> switch ( ndims ) //<S2SV> { //<S2SV> case 0 : //<S2SV> out = hstorePairs ( NULL , 0 , 0 ) ; //<S2SV> PG_RETURN_POINTER ( out ) ; //<S2SV> case 1 : //<S2SV> if ( ( ARR_DIMS ( in_array ) [ 0 ] ) % 2 ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , //<S2SV> errmsg ( "array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>even<S2SV_blank>number<S2SV_blank>of<S2SV_blank>elements" ) ) ) ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> if ( ( ARR_DIMS ( in_array ) [ 1 ] ) != 2 ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , //<S2SV> errmsg ( "array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>two<S2SV_blank>columns" ) ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , //<S2SV> errmsg ( "wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts" ) ) ) ; //<S2SV> } //<S2SV> deconstruct_array ( in_array , //<S2SV> TEXTOID , - 1 , false , 'i' , //<S2SV> & in_datums , & in_nulls , & in_count ) ; //<S2SV> count = in_count / 2 ; //<S2SV> pairs = palloc ( count * sizeof ( Pairs ) ) ; //<S2SV> for ( i = 0 ; i < count ; ++ i ) //<S2SV> { //<S2SV> if ( in_nulls [ i * 2 ] ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , //<S2SV> errmsg ( "null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key" ) ) ) ; //<S2SV> if ( in_nulls [ i * 2 + 1 ] ) //<S2SV> { //<S2SV> pairs [ i ] . key = VARDATA_ANY ( in_datums [ i * 2 ] ) ; //<S2SV> pairs [ i ] . val = NULL ; //<S2SV> pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 ] ) ) ; //<S2SV> pairs [ i ] . vallen = 4 ; //<S2SV> pairs [ i ] . isnull = true ; //<S2SV> pairs [ i ] . needfree = false ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pairs [ i ] . key = VARDATA_ANY ( in_datums [ i * 2 ] ) ; //<S2SV> pairs [ i ] . val = VARDATA_ANY ( in_datums [ i * 2 + 1 ] ) ; //<S2SV> pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 ] ) ) ; //<S2SV> pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( in_datums [ i * 2 + 1 ] ) ) ; //<S2SV> pairs [ i ] . isnull = false ; //<S2SV> pairs [ i ] . needfree = false ; //<S2SV> } //<S2SV> } //<S2SV> count = hstoreUniquePairs ( pairs , count , & buflen ) ; //<S2SV> out = hstorePairs ( pairs , count , buflen ) ; //<S2SV> PG_RETURN_POINTER ( out ) ; //<S2SV> } //<S2SV> 