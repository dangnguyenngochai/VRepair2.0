Datum //<S2SV> hstore_from_record ( PG_FUNCTION_ARGS ) //<S2SV> { //<S2SV> HeapTupleHeader rec ; //<S2SV> int32 buflen ; //<S2SV> HStore * out ; //<S2SV> Pairs * pairs ; //<S2SV> Oid tupType ; //<S2SV> int32 tupTypmod ; //<S2SV> TupleDesc tupdesc ; //<S2SV> HeapTupleData tuple ; //<S2SV> RecordIOData * my_extra ; //<S2SV> int ncolumns ; //<S2SV> int i , //<S2SV> j ; //<S2SV> Datum * values ; //<S2SV> bool * nulls ; //<S2SV> if ( PG_ARGISNULL ( 0 ) ) //<S2SV> { //<S2SV> Oid argtype = get_fn_expr_argtype ( fcinfo -> flinfo , 0 ) ; //<S2SV> tupType = argtype ; //<S2SV> tupTypmod = - 1 ; //<S2SV> rec = NULL ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> rec = PG_GETARG_HEAPTUPLEHEADER ( 0 ) ; //<S2SV> tupType = HeapTupleHeaderGetTypeId ( rec ) ; //<S2SV> tupTypmod = HeapTupleHeaderGetTypMod ( rec ) ; //<S2SV> } //<S2SV> tupdesc = lookup_rowtype_tupdesc ( tupType , tupTypmod ) ; //<S2SV> ncolumns = tupdesc -> natts ; //<S2SV> my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; //<S2SV> if ( my_extra == NULL || //<S2SV> my_extra -> ncolumns != ncolumns ) //<S2SV> { //<S2SV> fcinfo -> flinfo -> fn_extra = //<S2SV> MemoryContextAlloc ( fcinfo -> flinfo -> fn_mcxt , //<S2SV> sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) //<S2SV> + ncolumns * sizeof ( ColumnIOData ) ) ; //<S2SV> my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; //<S2SV> my_extra -> record_type = InvalidOid ; //<S2SV> my_extra -> record_typmod = 0 ; //<S2SV> } //<S2SV> if ( my_extra -> record_type != tupType || //<S2SV> my_extra -> record_typmod != tupTypmod ) //<S2SV> { //<S2SV> MemSet ( my_extra , 0 , //<S2SV> sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) //<S2SV> + ncolumns * sizeof ( ColumnIOData ) ) ; //<S2SV> my_extra -> record_type = tupType ; //<S2SV> my_extra -> record_typmod = tupTypmod ; //<S2SV> my_extra -> ncolumns = ncolumns ; //<S2SV> } //<S2SV> pairs = palloc ( ncolumns * sizeof ( Pairs ) ) ; //<S2SV> if ( rec ) //<S2SV> { //<S2SV> tuple . t_len = HeapTupleHeaderGetDatumLength ( rec ) ; //<S2SV> ItemPointerSetInvalid ( & ( tuple . t_self ) ) ; //<S2SV> tuple . t_tableOid = InvalidOid ; //<S2SV> tuple . t_data = rec ; //<S2SV> values = ( Datum * ) palloc ( ncolumns * sizeof ( Datum ) ) ; //<S2SV> nulls = ( bool * ) palloc ( ncolumns * sizeof ( bool ) ) ; //<S2SV> heap_deform_tuple ( & tuple , tupdesc , values , nulls ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> values = NULL ; //<S2SV> nulls = NULL ; //<S2SV> } //<S2SV> for ( i = 0 , j = 0 ; i < ncolumns ; ++ i ) //<S2SV> { //<S2SV> ColumnIOData * column_info = & my_extra -> columns [ i ] ; //<S2SV> Oid column_type = tupdesc -> attrs [ i ] -> atttypid ; //<S2SV> char * value ; //<S2SV> if ( tupdesc -> attrs [ i ] -> attisdropped ) //<S2SV> continue ; //<S2SV> pairs [ j ] . key = NameStr ( tupdesc -> attrs [ i ] -> attname ) ; //<S2SV> pairs [ j ] . keylen = hstoreCheckKeyLen ( strlen ( NameStr ( tupdesc -> attrs [ i ] -> attname ) ) ) ; //<S2SV> if ( ! nulls || nulls [ i ] ) //<S2SV> { //<S2SV> pairs [ j ] . val = NULL ; //<S2SV> pairs [ j ] . vallen = 4 ; //<S2SV> pairs [ j ] . isnull = true ; //<S2SV> pairs [ j ] . needfree = false ; //<S2SV> ++ j ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( column_info -> column_type != column_type ) //<S2SV> { //<S2SV> bool typIsVarlena ; //<S2SV> getTypeOutputInfo ( column_type , //<S2SV> & column_info -> typiofunc , //<S2SV> & typIsVarlena ) ; //<S2SV> fmgr_info_cxt ( column_info -> typiofunc , & column_info -> proc , //<S2SV> fcinfo -> flinfo -> fn_mcxt ) ; //<S2SV> column_info -> column_type = column_type ; //<S2SV> } //<S2SV> value = OutputFunctionCall ( & column_info -> proc , values [ i ] ) ; //<S2SV> pairs [ j ] . val = value ; //<S2SV> pairs [ j ] . vallen = hstoreCheckValLen ( strlen ( value ) ) ; //<S2SV> pairs [ j ] . isnull = false ; //<S2SV> pairs [ j ] . needfree = false ; //<S2SV> ++ j ; //<S2SV> } //<S2SV> ncolumns = hstoreUniquePairs ( pairs , j , & buflen ) ; //<S2SV> out = hstorePairs ( pairs , ncolumns , buflen ) ; //<S2SV> ReleaseTupleDesc ( tupdesc ) ; //<S2SV> PG_RETURN_POINTER ( out ) ; //<S2SV> } //<S2SV> 