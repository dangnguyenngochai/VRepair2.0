TSQuery //<S2SV> parse_tsquery ( char * buf , //<S2SV> PushFunction pushval , //<S2SV> Datum opaque , //<S2SV> bool isplain ) //<S2SV> { //<S2SV> struct TSQueryParserStateData state ; //<S2SV> int i ; //<S2SV> TSQuery query ; //<S2SV> int commonlen ; //<S2SV> QueryItem * ptr ; //<S2SV> ListCell * cell ; //<S2SV> state . buffer = buf ; //<S2SV> state . buf = buf ; //<S2SV> state . state = ( isplain ) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND ; //<S2SV> state . count = 0 ; //<S2SV> state . polstr = NIL ; //<S2SV> state . valstate = init_tsvector_parser ( state . buffer , true , true ) ; //<S2SV> state . sumlen = 0 ; //<S2SV> state . lenop = 64 ; //<S2SV> state . curop = state . op = ( char * ) palloc ( state . lenop ) ; //<S2SV> * ( state . curop ) = '\\0' ; //<S2SV> makepol ( & state , pushval , opaque ) ; //<S2SV> close_tsvector_parser ( state . valstate ) ; //<S2SV> if ( list_length ( state . polstr ) == 0 ) //<S2SV> { //<S2SV> ereport ( NOTICE , //<S2SV> ( errmsg ( "text-search<S2SV_blank>query<S2SV_blank>doesn\'t<S2SV_blank>contain<S2SV_blank>lexemes:<S2SV_blank>\\"%s\\"" , //<S2SV> state . buffer ) ) ) ; //<S2SV> query = ( TSQuery ) palloc ( HDRSIZETQ ) ; //<S2SV> SET_VARSIZE ( query , HDRSIZETQ ) ; //<S2SV> query -> size = 0 ; //<S2SV> return query ; //<S2SV> } //<S2SV> if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , //<S2SV> errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ; //<S2SV> commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ; //<S2SV> query = ( TSQuery ) palloc0 ( commonlen ) ; //<S2SV> SET_VARSIZE ( query , commonlen ) ; //<S2SV> query -> size = list_length ( state . polstr ) ; //<S2SV> ptr = GETQUERY ( query ) ; //<S2SV> i = 0 ; //<S2SV> foreach ( cell , state . polstr ) //<S2SV> { //<S2SV> QueryItem * item = ( QueryItem * ) lfirst ( cell ) ; //<S2SV> switch ( item -> type ) //<S2SV> { //<S2SV> case QI_VAL : //<S2SV> memcpy ( & ptr [ i ] , item , sizeof ( QueryOperand ) ) ; //<S2SV> break ; //<S2SV> case QI_VALSTOP : //<S2SV> ptr [ i ] . type = QI_VALSTOP ; //<S2SV> break ; //<S2SV> case QI_OPR : //<S2SV> memcpy ( & ptr [ i ] , item , sizeof ( QueryOperator ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> elog ( ERROR , "unrecognized<S2SV_blank>QueryItem<S2SV_blank>type:<S2SV_blank>%d" , item -> type ) ; //<S2SV> } //<S2SV> i ++ ; //<S2SV> } //<S2SV> memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; //<S2SV> pfree ( state . op ) ; //<S2SV> findoprnd ( ptr , query -> size ) ; //<S2SV> return query ; //<S2SV> } //<S2SV> 