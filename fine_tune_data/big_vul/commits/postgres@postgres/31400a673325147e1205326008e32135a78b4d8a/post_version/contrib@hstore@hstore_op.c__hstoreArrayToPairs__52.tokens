Pairs * //<S2SV> hstoreArrayToPairs ( ArrayType * a , int * npairs ) //<S2SV> { //<S2SV> Datum * key_datums ; //<S2SV> bool * key_nulls ; //<S2SV> int key_count ; //<S2SV> Pairs * key_pairs ; //<S2SV> int bufsiz ; //<S2SV> int i , //<S2SV> j ; //<S2SV> deconstruct_array ( a , //<S2SV> TEXTOID , - 1 , false , 'i' , //<S2SV> & key_datums , & key_nulls , & key_count ) ; //<S2SV> if ( key_count == 0 ) //<S2SV> { //<S2SV> * npairs = 0 ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , //<S2SV> errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , //<S2SV> key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; //<S2SV> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; //<S2SV> for ( i = 0 , j = 0 ; i < key_count ; i ++ ) //<S2SV> { //<S2SV> if ( ! key_nulls [ i ] ) //<S2SV> { //<S2SV> key_pairs [ j ] . key = VARDATA ( key_datums [ i ] ) ; //<S2SV> key_pairs [ j ] . keylen = VARSIZE ( key_datums [ i ] ) - VARHDRSZ ; //<S2SV> key_pairs [ j ] . val = NULL ; //<S2SV> key_pairs [ j ] . vallen = 0 ; //<S2SV> key_pairs [ j ] . needfree = 0 ; //<S2SV> key_pairs [ j ] . isnull = 1 ; //<S2SV> j ++ ; //<S2SV> } //<S2SV> } //<S2SV> * npairs = hstoreUniquePairs ( key_pairs , j , & bufsiz ) ; //<S2SV> return key_pairs ; //<S2SV> } //<S2SV> 