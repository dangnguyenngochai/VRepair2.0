Datum //<S2SV> hstore_from_arrays ( PG_FUNCTION_ARGS ) //<S2SV> { //<S2SV> int32 buflen ; //<S2SV> HStore * out ; //<S2SV> Pairs * pairs ; //<S2SV> Datum * key_datums ; //<S2SV> bool * key_nulls ; //<S2SV> int key_count ; //<S2SV> Datum * value_datums ; //<S2SV> bool * value_nulls ; //<S2SV> int value_count ; //<S2SV> ArrayType * key_array ; //<S2SV> ArrayType * value_array ; //<S2SV> int i ; //<S2SV> if ( PG_ARGISNULL ( 0 ) ) //<S2SV> PG_RETURN_NULL ( ) ; //<S2SV> key_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; //<S2SV> Assert ( ARR_ELEMTYPE ( key_array ) == TEXTOID ) ; //<S2SV> if ( ARR_NDIM ( key_array ) > 1 ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , //<S2SV> errmsg ( "wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts" ) ) ) ; //<S2SV> deconstruct_array ( key_array , //<S2SV> TEXTOID , - 1 , false , 'i' , //<S2SV> & key_datums , & key_nulls , & key_count ) ; //<S2SV> if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , //<S2SV> errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , //<S2SV> key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; //<S2SV> if ( PG_ARGISNULL ( 1 ) ) //<S2SV> { //<S2SV> value_array = NULL ; //<S2SV> value_count = key_count ; //<S2SV> value_datums = NULL ; //<S2SV> value_nulls = NULL ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> value_array = PG_GETARG_ARRAYTYPE_P ( 1 ) ; //<S2SV> Assert ( ARR_ELEMTYPE ( value_array ) == TEXTOID ) ; //<S2SV> if ( ARR_NDIM ( value_array ) > 1 ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , //<S2SV> errmsg ( "wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts" ) ) ) ; //<S2SV> if ( ( ARR_NDIM ( key_array ) > 0 || ARR_NDIM ( value_array ) > 0 ) && //<S2SV> ( ARR_NDIM ( key_array ) != ARR_NDIM ( value_array ) || //<S2SV> ARR_DIMS ( key_array ) [ 0 ] != ARR_DIMS ( value_array ) [ 0 ] || //<S2SV> ARR_LBOUND ( key_array ) [ 0 ] != ARR_LBOUND ( value_array ) [ 0 ] ) ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , //<S2SV> errmsg ( "arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>same<S2SV_blank>bounds" ) ) ) ; //<S2SV> deconstruct_array ( value_array , //<S2SV> TEXTOID , - 1 , false , 'i' , //<S2SV> & value_datums , & value_nulls , & value_count ) ; //<S2SV> Assert ( key_count == value_count ) ; //<S2SV> } //<S2SV> pairs = palloc ( key_count * sizeof ( Pairs ) ) ; //<S2SV> for ( i = 0 ; i < key_count ; ++ i ) //<S2SV> { //<S2SV> if ( key_nulls [ i ] ) //<S2SV> ereport ( ERROR , //<S2SV> ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , //<S2SV> errmsg ( "null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key" ) ) ) ; //<S2SV> if ( ! value_nulls || value_nulls [ i ] ) //<S2SV> { //<S2SV> pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; //<S2SV> pairs [ i ] . val = NULL ; //<S2SV> pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; //<S2SV> pairs [ i ] . vallen = 4 ; //<S2SV> pairs [ i ] . isnull = true ; //<S2SV> pairs [ i ] . needfree = false ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; //<S2SV> pairs [ i ] . val = VARDATA_ANY ( value_datums [ i ] ) ; //<S2SV> pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; //<S2SV> pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( value_datums [ i ] ) ) ; //<S2SV> pairs [ i ] . isnull = false ; //<S2SV> pairs [ i ] . needfree = false ; //<S2SV> } //<S2SV> } //<S2SV> key_count = hstoreUniquePairs ( pairs , key_count , & buflen ) ; //<S2SV> out = hstorePairs ( pairs , key_count , buflen ) ; //<S2SV> PG_RETURN_POINTER ( out ) ; //<S2SV> } //<S2SV> 