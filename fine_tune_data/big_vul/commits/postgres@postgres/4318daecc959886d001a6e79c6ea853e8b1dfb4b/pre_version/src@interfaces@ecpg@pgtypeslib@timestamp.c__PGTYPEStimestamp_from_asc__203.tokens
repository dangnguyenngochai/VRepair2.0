timestamp //<S2SV> PGTYPEStimestamp_from_asc ( char * str , char * * endptr ) //<S2SV> { //<S2SV> timestamp result ; //<S2SV> # ifdef HAVE_INT64_TIMESTAMP //<S2SV> int64 noresult = 0 ; //<S2SV> # else //<S2SV> double noresult = 0.0 ; //<S2SV> # endif //<S2SV> fsec_t fsec ; //<S2SV> struct tm tt , //<S2SV> * tm = & tt ; //<S2SV> int dtype ; //<S2SV> int nf ; //<S2SV> char * field [ MAXDATEFIELDS ] ; //<S2SV> int ftype [ MAXDATEFIELDS ] ; //<S2SV> char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; //<S2SV> char * realptr ; //<S2SV> char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; //<S2SV> if ( strlen ( str ) >= sizeof ( lowstr ) ) //<S2SV> { //<S2SV> errno = PGTYPES_TS_BAD_TIMESTAMP ; //<S2SV> return ( noresult ) ; //<S2SV> } //<S2SV> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || //<S2SV> DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) //<S2SV> { //<S2SV> errno = PGTYPES_TS_BAD_TIMESTAMP ; //<S2SV> return ( noresult ) ; //<S2SV> } //<S2SV> switch ( dtype ) //<S2SV> { //<S2SV> case DTK_DATE : //<S2SV> if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 ) //<S2SV> { //<S2SV> errno = PGTYPES_TS_BAD_TIMESTAMP ; //<S2SV> return ( noresult ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case DTK_EPOCH : //<S2SV> result = SetEpochTimestamp ( ) ; //<S2SV> break ; //<S2SV> case DTK_LATE : //<S2SV> TIMESTAMP_NOEND ( result ) ; //<S2SV> break ; //<S2SV> case DTK_EARLY : //<S2SV> TIMESTAMP_NOBEGIN ( result ) ; //<S2SV> break ; //<S2SV> case DTK_INVALID : //<S2SV> errno = PGTYPES_TS_BAD_TIMESTAMP ; //<S2SV> return ( noresult ) ; //<S2SV> default : //<S2SV> errno = PGTYPES_TS_BAD_TIMESTAMP ; //<S2SV> return ( noresult ) ; //<S2SV> } //<S2SV> errno = 0 ; //<S2SV> return result ; //<S2SV> } //<S2SV> 