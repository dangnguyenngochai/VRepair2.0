date //<S2SV> PGTYPESdate_from_asc ( char * str , char * * endptr ) //<S2SV> { //<S2SV> date dDate ; //<S2SV> fsec_t fsec ; //<S2SV> struct tm tt , //<S2SV> * tm = & tt ; //<S2SV> int dtype ; //<S2SV> int nf ; //<S2SV> char * field [ MAXDATEFIELDS ] ; //<S2SV> int ftype [ MAXDATEFIELDS ] ; //<S2SV> char lowstr [ MAXDATELEN + 1 ] ; //<S2SV> char * realptr ; //<S2SV> char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; //<S2SV> bool EuroDates = FALSE ; //<S2SV> errno = 0 ; //<S2SV> if ( strlen ( str ) >= sizeof ( lowstr ) ) //<S2SV> { //<S2SV> errno = PGTYPES_DATE_BAD_DATE ; //<S2SV> return INT_MIN ; //<S2SV> } //<S2SV> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || //<S2SV> DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , EuroDates ) != 0 ) //<S2SV> { //<S2SV> errno = PGTYPES_DATE_BAD_DATE ; //<S2SV> return INT_MIN ; //<S2SV> } //<S2SV> switch ( dtype ) //<S2SV> { //<S2SV> case DTK_DATE : //<S2SV> break ; //<S2SV> case DTK_EPOCH : //<S2SV> if ( GetEpochTime ( tm ) < 0 ) //<S2SV> { //<S2SV> errno = PGTYPES_DATE_BAD_DATE ; //<S2SV> return INT_MIN ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> errno = PGTYPES_DATE_BAD_DATE ; //<S2SV> return INT_MIN ; //<S2SV> } //<S2SV> dDate = ( date2j ( tm -> tm_year , tm -> tm_mon , tm -> tm_mday ) - date2j ( 2000 , 1 , 1 ) ) ; //<S2SV> return dDate ; //<S2SV> } //<S2SV> 