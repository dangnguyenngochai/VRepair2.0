interval * //<S2SV> PGTYPESinterval_from_asc ( char * str , char * * endptr ) //<S2SV> { //<S2SV> interval * result = NULL ; //<S2SV> fsec_t fsec ; //<S2SV> struct tm tt , //<S2SV> * tm = & tt ; //<S2SV> int dtype ; //<S2SV> int nf ; //<S2SV> char * field [ MAXDATEFIELDS ] ; //<S2SV> int ftype [ MAXDATEFIELDS ] ; //<S2SV> char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; //<S2SV> char * realptr ; //<S2SV> char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; //<S2SV> tm -> tm_year = 0 ; //<S2SV> tm -> tm_mon = 0 ; //<S2SV> tm -> tm_mday = 0 ; //<S2SV> tm -> tm_hour = 0 ; //<S2SV> tm -> tm_min = 0 ; //<S2SV> tm -> tm_sec = 0 ; //<S2SV> fsec = 0 ; //<S2SV> if ( strlen ( str ) > MAXDATELEN ) //<S2SV> { //<S2SV> errno = PGTYPES_INTVL_BAD_INTERVAL ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || //<S2SV> ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && //<S2SV> DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) //<S2SV> { //<S2SV> errno = PGTYPES_INTVL_BAD_INTERVAL ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; //<S2SV> if ( ! result ) //<S2SV> return NULL ; //<S2SV> if ( dtype != DTK_DELTA ) //<S2SV> { //<S2SV> errno = PGTYPES_INTVL_BAD_INTERVAL ; //<S2SV> free ( result ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( tm2interval ( tm , fsec , result ) != 0 ) //<S2SV> { //<S2SV> errno = PGTYPES_INTVL_BAD_INTERVAL ; //<S2SV> free ( result ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> errno = 0 ; //<S2SV> return result ; //<S2SV> } //<S2SV> 