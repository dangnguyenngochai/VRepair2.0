static int start_decoder ( vorb * f ) //<S2SV> { //<S2SV> uint8 header [ 6 ] , x , y ; //<S2SV> int len , i , j , k , max_submaps = 0 ; //<S2SV> int longest_floorlist = 0 ; //<S2SV> if ( ! start_page ( f ) ) return FALSE ; //<S2SV> if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> if ( f -> segments [ 0 ] != 30 ) { //<S2SV> if ( f -> segments [ 0 ] == 64 && //<S2SV> getn ( f , header , 6 ) && //<S2SV> header [ 0 ] == 'f' && //<S2SV> header [ 1 ] == 'i' && //<S2SV> header [ 2 ] == 's' && //<S2SV> header [ 3 ] == 'h' && //<S2SV> header [ 4 ] == 'e' && //<S2SV> header [ 5 ] == 'a' && //<S2SV> get8 ( f ) == 'd' && //<S2SV> get8 ( f ) == '\\0' ) return error ( f , VORBIS_ogg_skeleton_not_supported ) ; //<S2SV> else //<S2SV> return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> } //<S2SV> if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; //<S2SV> if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; //<S2SV> f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> get32 ( f ) ; //<S2SV> get32 ( f ) ; //<S2SV> get32 ( f ) ; //<S2SV> x = get8 ( f ) ; //<S2SV> { //<S2SV> int log0 , log1 ; //<S2SV> log0 = x & 15 ; //<S2SV> log1 = x >> 4 ; //<S2SV> f -> blocksize_0 = 1 << log0 ; //<S2SV> f -> blocksize_1 = 1 << log1 ; //<S2SV> if ( log0 < 6 || log0 > 13 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( log1 < 6 || log1 > 13 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( log0 > log1 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> x = get8 ( f ) ; //<S2SV> if ( ! ( x & 1 ) ) return error ( f , VORBIS_invalid_first_page ) ; //<S2SV> if ( ! start_page ( f ) ) return FALSE ; //<S2SV> if ( ! start_packet ( f ) ) return FALSE ; //<S2SV> do { //<S2SV> len = next_segment ( f ) ; //<S2SV> skip ( f , len ) ; //<S2SV> f -> bytes_in_seg = 0 ; //<S2SV> } while ( len ) ; //<S2SV> if ( ! start_packet ( f ) ) return FALSE ; //<S2SV> # ifndef STB_VORBIS_NO_PUSHDATA_API //<S2SV> if ( IS_PUSH_MODE ( f ) ) { //<S2SV> if ( ! is_whole_packet_present ( f , TRUE ) ) { //<S2SV> if ( f -> error == VORBIS_invalid_stream ) //<S2SV> f -> error = VORBIS_invalid_setup ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> crc32_init ( ) ; //<S2SV> if ( get8_packet ( f ) != VORBIS_packet_setup ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> for ( i = 0 ; i < 6 ; ++ i ) header [ i ] = get8_packet ( f ) ; //<S2SV> if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> f -> codebook_count = get_bits ( f , 8 ) + 1 ; //<S2SV> f -> codebooks = ( Codebook * ) setup_malloc ( f , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; //<S2SV> if ( f -> codebooks == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> memset ( f -> codebooks , 0 , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; //<S2SV> for ( i = 0 ; i < f -> codebook_count ; ++ i ) { //<S2SV> uint32 * values ; //<S2SV> int ordered , sorted_count ; //<S2SV> int total = 0 ; //<S2SV> uint8 * lengths ; //<S2SV> Codebook * c = f -> codebooks + i ; //<S2SV> CHECK ( f ) ; //<S2SV> x = get_bits ( f , 8 ) ; if ( x != 0x42 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> x = get_bits ( f , 8 ) ; if ( x != 0x43 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> x = get_bits ( f , 8 ) ; if ( x != 0x56 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> x = get_bits ( f , 8 ) ; //<S2SV> c -> dimensions = ( get_bits ( f , 8 ) << 8 ) + x ; //<S2SV> x = get_bits ( f , 8 ) ; //<S2SV> y = get_bits ( f , 8 ) ; //<S2SV> c -> entries = ( get_bits ( f , 8 ) << 16 ) + ( y << 8 ) + x ; //<S2SV> ordered = get_bits ( f , 1 ) ; //<S2SV> c -> sparse = ordered ? 0 : get_bits ( f , 1 ) ; //<S2SV> if ( c -> dimensions == 0 && c -> entries != 0 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( c -> sparse ) //<S2SV> lengths = ( uint8 * ) setup_temp_malloc ( f , c -> entries ) ; //<S2SV> else //<S2SV> lengths = c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; //<S2SV> if ( ! lengths ) return error ( f , VORBIS_outofmem ) ; //<S2SV> if ( ordered ) { //<S2SV> int current_entry = 0 ; //<S2SV> int current_length = get_bits ( f , 5 ) + 1 ; //<S2SV> while ( current_entry < c -> entries ) { //<S2SV> int limit = c -> entries - current_entry ; //<S2SV> int n = get_bits ( f , ilog ( limit ) ) ; //<S2SV> if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } //<S2SV> memset ( lengths + current_entry , current_length , n ) ; //<S2SV> current_entry += n ; //<S2SV> ++ current_length ; //<S2SV> } //<S2SV> } else { //<S2SV> for ( j = 0 ; j < c -> entries ; ++ j ) { //<S2SV> int present = c -> sparse ? get_bits ( f , 1 ) : 1 ; //<S2SV> if ( present ) { //<S2SV> lengths [ j ] = get_bits ( f , 5 ) + 1 ; //<S2SV> ++ total ; //<S2SV> if ( lengths [ j ] == 32 ) //<S2SV> return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } else { //<S2SV> lengths [ j ] = NO_CODE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( c -> sparse && total >= c -> entries >> 2 ) { //<S2SV> if ( c -> entries > ( int ) f -> setup_temp_memory_required ) //<S2SV> f -> setup_temp_memory_required = c -> entries ; //<S2SV> c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; //<S2SV> if ( c -> codeword_lengths == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> memcpy ( c -> codeword_lengths , lengths , c -> entries ) ; //<S2SV> setup_temp_free ( f , lengths , c -> entries ) ; //<S2SV> lengths = c -> codeword_lengths ; //<S2SV> c -> sparse = 0 ; //<S2SV> } //<S2SV> if ( c -> sparse ) { //<S2SV> sorted_count = total ; //<S2SV> } else { //<S2SV> sorted_count = 0 ; //<S2SV> # ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH //<S2SV> for ( j = 0 ; j < c -> entries ; ++ j ) //<S2SV> if ( lengths [ j ] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths [ j ] != NO_CODE ) //<S2SV> ++ sorted_count ; //<S2SV> # endif //<S2SV> } //<S2SV> c -> sorted_entries = sorted_count ; //<S2SV> values = NULL ; //<S2SV> CHECK ( f ) ; //<S2SV> if ( ! c -> sparse ) { //<S2SV> c -> codewords = ( uint32 * ) setup_malloc ( f , sizeof ( c -> codewords [ 0 ] ) * c -> entries ) ; //<S2SV> if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; //<S2SV> } else { //<S2SV> unsigned int size ; //<S2SV> if ( c -> sorted_entries ) { //<S2SV> c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> sorted_entries ) ; //<S2SV> if ( ! c -> codeword_lengths ) return error ( f , VORBIS_outofmem ) ; //<S2SV> c -> codewords = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; //<S2SV> if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; //<S2SV> values = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * values ) * c -> sorted_entries ) ; //<S2SV> if ( ! values ) return error ( f , VORBIS_outofmem ) ; //<S2SV> } //<S2SV> size = c -> entries + ( sizeof ( * c -> codewords ) + sizeof ( * values ) ) * c -> sorted_entries ; //<S2SV> if ( size > f -> setup_temp_memory_required ) //<S2SV> f -> setup_temp_memory_required = size ; //<S2SV> } //<S2SV> if ( ! compute_codewords ( c , lengths , c -> entries , values ) ) { //<S2SV> if ( c -> sparse ) setup_temp_free ( f , values , 0 ) ; //<S2SV> return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> if ( c -> sorted_entries ) { //<S2SV> c -> sorted_codewords = ( uint32 * ) setup_malloc ( f , sizeof ( * c -> sorted_codewords ) * ( c -> sorted_entries + 1 ) ) ; //<S2SV> if ( c -> sorted_codewords == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> c -> sorted_values = ( int * ) setup_malloc ( f , sizeof ( * c -> sorted_values ) * ( c -> sorted_entries + 1 ) ) ; //<S2SV> if ( c -> sorted_values == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> ++ c -> sorted_values ; //<S2SV> c -> sorted_values [ - 1 ] = - 1 ; //<S2SV> compute_sorted_huffman ( c , lengths , values ) ; //<S2SV> } //<S2SV> if ( c -> sparse ) { //<S2SV> setup_temp_free ( f , values , sizeof ( * values ) * c -> sorted_entries ) ; //<S2SV> setup_temp_free ( f , c -> codewords , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; //<S2SV> setup_temp_free ( f , lengths , c -> entries ) ; //<S2SV> c -> codewords = NULL ; //<S2SV> } //<S2SV> compute_accelerated_huffman ( c ) ; //<S2SV> CHECK ( f ) ; //<S2SV> c -> lookup_type = get_bits ( f , 4 ) ; //<S2SV> if ( c -> lookup_type > 2 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( c -> lookup_type > 0 ) { //<S2SV> uint16 * mults ; //<S2SV> c -> minimum_value = float32_unpack ( get_bits ( f , 32 ) ) ; //<S2SV> c -> delta_value = float32_unpack ( get_bits ( f , 32 ) ) ; //<S2SV> c -> value_bits = get_bits ( f , 4 ) + 1 ; //<S2SV> c -> sequence_p = get_bits ( f , 1 ) ; //<S2SV> if ( c -> lookup_type == 1 ) { //<S2SV> int values = lookup1_values ( c -> entries , c -> dimensions ) ; //<S2SV> if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> c -> lookup_values = ( uint32 ) values ; //<S2SV> } else { //<S2SV> c -> lookup_values = c -> entries * c -> dimensions ; //<S2SV> } //<S2SV> if ( c -> lookup_values == 0 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> mults = ( uint16 * ) setup_temp_malloc ( f , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; //<S2SV> if ( mults == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { //<S2SV> int q = get_bits ( f , c -> value_bits ) ; //<S2SV> if ( q == EOP ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } //<S2SV> mults [ j ] = q ; //<S2SV> } //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK //<S2SV> if ( c -> lookup_type == 1 ) { //<S2SV> int len , sparse = c -> sparse ; //<S2SV> float last = 0 ; //<S2SV> if ( sparse ) { //<S2SV> if ( c -> sorted_entries == 0 ) goto skip ; //<S2SV> c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> sorted_entries * c -> dimensions ) ; //<S2SV> } else //<S2SV> c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> entries * c -> dimensions ) ; //<S2SV> if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } //<S2SV> len = sparse ? c -> sorted_entries : c -> entries ; //<S2SV> for ( j = 0 ; j < len ; ++ j ) { //<S2SV> unsigned int z = sparse ? c -> sorted_values [ j ] : j ; //<S2SV> unsigned int div = 1 ; //<S2SV> for ( k = 0 ; k < c -> dimensions ; ++ k ) { //<S2SV> int off = ( z / div ) % c -> lookup_values ; //<S2SV> float val = mults [ off ] ; //<S2SV> val = mults [ off ] * c -> delta_value + c -> minimum_value + last ; //<S2SV> c -> multiplicands [ j * c -> dimensions + k ] = val ; //<S2SV> if ( c -> sequence_p ) //<S2SV> last = val ; //<S2SV> if ( k + 1 < c -> dimensions ) { //<S2SV> if ( div > UINT_MAX / ( unsigned int ) c -> lookup_values ) { //<S2SV> setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; //<S2SV> return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> div *= c -> lookup_values ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> c -> lookup_type = 2 ; //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> { //<S2SV> float last = 0 ; //<S2SV> CHECK ( f ) ; //<S2SV> c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> lookup_values ) ; //<S2SV> if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } //<S2SV> for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { //<S2SV> float val = mults [ j ] * c -> delta_value + c -> minimum_value + last ; //<S2SV> c -> multiplicands [ j ] = val ; //<S2SV> if ( c -> sequence_p ) //<S2SV> last = val ; //<S2SV> } //<S2SV> } //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK //<S2SV> skip : ; //<S2SV> # endif //<S2SV> setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; //<S2SV> CHECK ( f ) ; //<S2SV> } //<S2SV> CHECK ( f ) ; //<S2SV> } //<S2SV> x = get_bits ( f , 6 ) + 1 ; //<S2SV> for ( i = 0 ; i < x ; ++ i ) { //<S2SV> uint32 z = get_bits ( f , 16 ) ; //<S2SV> if ( z != 0 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> f -> floor_count = get_bits ( f , 6 ) + 1 ; //<S2SV> f -> floor_config = ( Floor * ) setup_malloc ( f , f -> floor_count * sizeof ( * f -> floor_config ) ) ; //<S2SV> if ( f -> floor_config == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> for ( i = 0 ; i < f -> floor_count ; ++ i ) { //<S2SV> f -> floor_types [ i ] = get_bits ( f , 16 ) ; //<S2SV> if ( f -> floor_types [ i ] > 1 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( f -> floor_types [ i ] == 0 ) { //<S2SV> Floor0 * g = & f -> floor_config [ i ] . floor0 ; //<S2SV> g -> order = get_bits ( f , 8 ) ; //<S2SV> g -> rate = get_bits ( f , 16 ) ; //<S2SV> g -> bark_map_size = get_bits ( f , 16 ) ; //<S2SV> g -> amplitude_bits = get_bits ( f , 6 ) ; //<S2SV> g -> amplitude_offset = get_bits ( f , 8 ) ; //<S2SV> g -> number_of_books = get_bits ( f , 4 ) + 1 ; //<S2SV> for ( j = 0 ; j < g -> number_of_books ; ++ j ) //<S2SV> g -> book_list [ j ] = get_bits ( f , 8 ) ; //<S2SV> return error ( f , VORBIS_feature_not_supported ) ; //<S2SV> } else { //<S2SV> stbv__floor_ordering p [ 31 * 8 + 2 ] ; //<S2SV> Floor1 * g = & f -> floor_config [ i ] . floor1 ; //<S2SV> int max_class = - 1 ; //<S2SV> g -> partitions = get_bits ( f , 5 ) ; //<S2SV> for ( j = 0 ; j < g -> partitions ; ++ j ) { //<S2SV> g -> partition_class_list [ j ] = get_bits ( f , 4 ) ; //<S2SV> if ( g -> partition_class_list [ j ] > max_class ) //<S2SV> max_class = g -> partition_class_list [ j ] ; //<S2SV> } //<S2SV> for ( j = 0 ; j <= max_class ; ++ j ) { //<S2SV> g -> class_dimensions [ j ] = get_bits ( f , 3 ) + 1 ; //<S2SV> g -> class_subclasses [ j ] = get_bits ( f , 2 ) ; //<S2SV> if ( g -> class_subclasses [ j ] ) { //<S2SV> g -> class_masterbooks [ j ] = get_bits ( f , 8 ) ; //<S2SV> if ( g -> class_masterbooks [ j ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> for ( k = 0 ; k < 1 << g -> class_subclasses [ j ] ; ++ k ) { //<S2SV> g -> subclass_books [ j ] [ k ] = get_bits ( f , 8 ) - 1 ; //<S2SV> if ( g -> subclass_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> } //<S2SV> g -> floor1_multiplier = get_bits ( f , 2 ) + 1 ; //<S2SV> g -> rangebits = get_bits ( f , 4 ) ; //<S2SV> g -> Xlist [ 0 ] = 0 ; //<S2SV> g -> Xlist [ 1 ] = 1 << g -> rangebits ; //<S2SV> g -> values = 2 ; //<S2SV> for ( j = 0 ; j < g -> partitions ; ++ j ) { //<S2SV> int c = g -> partition_class_list [ j ] ; //<S2SV> for ( k = 0 ; k < g -> class_dimensions [ c ] ; ++ k ) { //<S2SV> g -> Xlist [ g -> values ] = get_bits ( f , g -> rangebits ) ; //<S2SV> ++ g -> values ; //<S2SV> } //<S2SV> } //<S2SV> for ( j = 0 ; j < g -> values ; ++ j ) { //<S2SV> p [ j ] . x = g -> Xlist [ j ] ; //<S2SV> p [ j ] . id = j ; //<S2SV> } //<S2SV> qsort ( p , g -> values , sizeof ( p [ 0 ] ) , point_compare ) ; //<S2SV> for ( j = 0 ; j < g -> values - 1 ; ++ j ) //<S2SV> if ( p [ j ] . x == p [ j + 1 ] . x ) //<S2SV> return error ( f , VORBIS_invalid_setup ) ; //<S2SV> for ( j = 0 ; j < g -> values ; ++ j ) //<S2SV> g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ; //<S2SV> for ( j = 2 ; j < g -> values ; ++ j ) { //<S2SV> int low , hi ; //<S2SV> neighbors ( g -> Xlist , j , & low , & hi ) ; //<S2SV> g -> neighbors [ j ] [ 0 ] = low ; //<S2SV> g -> neighbors [ j ] [ 1 ] = hi ; //<S2SV> } //<S2SV> if ( g -> values > longest_floorlist ) //<S2SV> longest_floorlist = g -> values ; //<S2SV> } //<S2SV> } //<S2SV> f -> residue_count = get_bits ( f , 6 ) + 1 ; //<S2SV> f -> residue_config = ( Residue * ) setup_malloc ( f , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; //<S2SV> if ( f -> residue_config == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> memset ( f -> residue_config , 0 , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; //<S2SV> for ( i = 0 ; i < f -> residue_count ; ++ i ) { //<S2SV> uint8 residue_cascade [ 64 ] ; //<S2SV> Residue * r = f -> residue_config + i ; //<S2SV> f -> residue_types [ i ] = get_bits ( f , 16 ) ; //<S2SV> if ( f -> residue_types [ i ] > 2 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> r -> begin = get_bits ( f , 24 ) ; //<S2SV> r -> end = get_bits ( f , 24 ) ; //<S2SV> if ( r -> end < r -> begin ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> r -> part_size = get_bits ( f , 24 ) + 1 ; //<S2SV> r -> classifications = get_bits ( f , 6 ) + 1 ; //<S2SV> r -> classbook = get_bits ( f , 8 ) ; //<S2SV> if ( r -> classbook >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> for ( j = 0 ; j < r -> classifications ; ++ j ) { //<S2SV> uint8 high_bits = 0 ; //<S2SV> uint8 low_bits = get_bits ( f , 3 ) ; //<S2SV> if ( get_bits ( f , 1 ) ) //<S2SV> high_bits = get_bits ( f , 5 ) ; //<S2SV> residue_cascade [ j ] = high_bits * 8 + low_bits ; //<S2SV> } //<S2SV> r -> residue_books = ( short ( * ) [ 8 ] ) setup_malloc ( f , sizeof ( r -> residue_books [ 0 ] ) * r -> classifications ) ; //<S2SV> if ( r -> residue_books == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> for ( j = 0 ; j < r -> classifications ; ++ j ) { //<S2SV> for ( k = 0 ; k < 8 ; ++ k ) { //<S2SV> if ( residue_cascade [ j ] & ( 1 << k ) ) { //<S2SV> r -> residue_books [ j ] [ k ] = get_bits ( f , 8 ) ; //<S2SV> if ( r -> residue_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } else { //<S2SV> r -> residue_books [ j ] [ k ] = - 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> r -> classdata = ( uint8 * * ) setup_malloc ( f , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; //<S2SV> if ( ! r -> classdata ) return error ( f , VORBIS_outofmem ) ; //<S2SV> memset ( r -> classdata , 0 , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; //<S2SV> for ( j = 0 ; j < f -> codebooks [ r -> classbook ] . entries ; ++ j ) { //<S2SV> int classwords = f -> codebooks [ r -> classbook ] . dimensions ; //<S2SV> int temp = j ; //<S2SV> r -> classdata [ j ] = ( uint8 * ) setup_malloc ( f , sizeof ( r -> classdata [ j ] [ 0 ] ) * classwords ) ; //<S2SV> if ( r -> classdata [ j ] == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> for ( k = classwords - 1 ; k >= 0 ; -- k ) { //<S2SV> r -> classdata [ j ] [ k ] = temp % r -> classifications ; //<S2SV> temp /= r -> classifications ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> f -> mapping_count = get_bits ( f , 6 ) + 1 ; //<S2SV> f -> mapping = ( Mapping * ) setup_malloc ( f , f -> mapping_count * sizeof ( * f -> mapping ) ) ; //<S2SV> if ( f -> mapping == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> memset ( f -> mapping , 0 , f -> mapping_count * sizeof ( * f -> mapping ) ) ; //<S2SV> for ( i = 0 ; i < f -> mapping_count ; ++ i ) { //<S2SV> Mapping * m = f -> mapping + i ; //<S2SV> int mapping_type = get_bits ( f , 16 ) ; //<S2SV> if ( mapping_type != 0 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> m -> chan = ( MappingChannel * ) setup_malloc ( f , f -> channels * sizeof ( * m -> chan ) ) ; //<S2SV> if ( m -> chan == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> if ( get_bits ( f , 1 ) ) //<S2SV> m -> submaps = get_bits ( f , 4 ) + 1 ; //<S2SV> else //<S2SV> m -> submaps = 1 ; //<S2SV> if ( m -> submaps > max_submaps ) //<S2SV> max_submaps = m -> submaps ; //<S2SV> if ( get_bits ( f , 1 ) ) { //<S2SV> m -> coupling_steps = get_bits ( f , 8 ) + 1 ; //<S2SV> if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> for ( k = 0 ; k < m -> coupling_steps ; ++ k ) { //<S2SV> m -> chan [ k ] . magnitude = get_bits ( f , ilog ( f -> channels - 1 ) ) ; //<S2SV> m -> chan [ k ] . angle = get_bits ( f , ilog ( f -> channels - 1 ) ) ; //<S2SV> if ( m -> chan [ k ] . magnitude >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( m -> chan [ k ] . angle >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( m -> chan [ k ] . magnitude == m -> chan [ k ] . angle ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> } else //<S2SV> m -> coupling_steps = 0 ; //<S2SV> if ( get_bits ( f , 2 ) ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( m -> submaps > 1 ) { //<S2SV> for ( j = 0 ; j < f -> channels ; ++ j ) { //<S2SV> m -> chan [ j ] . mux = get_bits ( f , 4 ) ; //<S2SV> if ( m -> chan [ j ] . mux >= m -> submaps ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> } else //<S2SV> for ( j = 0 ; j < f -> channels ; ++ j ) //<S2SV> m -> chan [ j ] . mux = 0 ; //<S2SV> for ( j = 0 ; j < m -> submaps ; ++ j ) { //<S2SV> get_bits ( f , 8 ) ; //<S2SV> m -> submap_floor [ j ] = get_bits ( f , 8 ) ; //<S2SV> m -> submap_residue [ j ] = get_bits ( f , 8 ) ; //<S2SV> if ( m -> submap_floor [ j ] >= f -> floor_count ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( m -> submap_residue [ j ] >= f -> residue_count ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> } //<S2SV> f -> mode_count = get_bits ( f , 6 ) + 1 ; //<S2SV> for ( i = 0 ; i < f -> mode_count ; ++ i ) { //<S2SV> Mode * m = f -> mode_config + i ; //<S2SV> m -> blockflag = get_bits ( f , 1 ) ; //<S2SV> m -> windowtype = get_bits ( f , 16 ) ; //<S2SV> m -> transformtype = get_bits ( f , 16 ) ; //<S2SV> m -> mapping = get_bits ( f , 8 ) ; //<S2SV> if ( m -> windowtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( m -> transformtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> if ( m -> mapping >= f -> mapping_count ) return error ( f , VORBIS_invalid_setup ) ; //<S2SV> } //<S2SV> flush_packet ( f ) ; //<S2SV> f -> previous_length = 0 ; //<S2SV> for ( i = 0 ; i < f -> channels ; ++ i ) { //<S2SV> f -> channel_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 ) ; //<S2SV> f -> previous_window [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; //<S2SV> f -> finalY [ i ] = ( int16 * ) setup_malloc ( f , sizeof ( int16 ) * longest_floorlist ) ; //<S2SV> if ( f -> channel_buffers [ i ] == NULL || f -> previous_window [ i ] == NULL || f -> finalY [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> memset ( f -> channel_buffers [ i ] , 0 , sizeof ( float ) * f -> blocksize_1 ) ; //<S2SV> # ifdef STB_VORBIS_NO_DEFER_FLOOR //<S2SV> f -> floor_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; //<S2SV> if ( f -> floor_buffers [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( ! init_blocksize ( f , 0 , f -> blocksize_0 ) ) return FALSE ; //<S2SV> if ( ! init_blocksize ( f , 1 , f -> blocksize_1 ) ) return FALSE ; //<S2SV> f -> blocksize [ 0 ] = f -> blocksize_0 ; //<S2SV> f -> blocksize [ 1 ] = f -> blocksize_1 ; //<S2SV> # ifdef STB_VORBIS_DIVIDE_TABLE //<S2SV> if ( integer_divide_table [ 1 ] [ 1 ] == 0 ) //<S2SV> for ( i = 0 ; i < DIVTAB_NUMER ; ++ i ) //<S2SV> for ( j = 1 ; j < DIVTAB_DENOM ; ++ j ) //<S2SV> integer_divide_table [ i ] [ j ] = i / j ; //<S2SV> # endif //<S2SV> { //<S2SV> uint32 imdct_mem = ( f -> blocksize_1 * sizeof ( float ) >> 1 ) ; //<S2SV> uint32 classify_mem ; //<S2SV> int i , max_part_read = 0 ; //<S2SV> for ( i = 0 ; i < f -> residue_count ; ++ i ) { //<S2SV> Residue * r = f -> residue_config + i ; //<S2SV> unsigned int actual_size = f -> blocksize_1 / 2 ; //<S2SV> unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; //<S2SV> unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; //<S2SV> int n_read = limit_r_end - limit_r_begin ; //<S2SV> int part_read = n_read / r -> part_size ; //<S2SV> if ( part_read > max_part_read ) //<S2SV> max_part_read = part_read ; //<S2SV> } //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( uint8 * ) ) ; //<S2SV> # else //<S2SV> classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( int * ) ) ; //<S2SV> # endif //<S2SV> f -> temp_memory_required = classify_mem ; //<S2SV> if ( imdct_mem > f -> temp_memory_required ) //<S2SV> f -> temp_memory_required = imdct_mem ; //<S2SV> } //<S2SV> f -> first_decode = TRUE ; //<S2SV> if ( f -> alloc . alloc_buffer ) { //<S2SV> assert ( f -> temp_offset == f -> alloc . alloc_buffer_length_in_bytes ) ; //<S2SV> if ( f -> setup_offset + sizeof ( * f ) + f -> temp_memory_required > ( unsigned ) f -> temp_offset ) //<S2SV> return error ( f , VORBIS_outofmem ) ; //<S2SV> } //<S2SV> f -> first_audio_page_offset = stb_vorbis_get_file_offset ( f ) ; //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 