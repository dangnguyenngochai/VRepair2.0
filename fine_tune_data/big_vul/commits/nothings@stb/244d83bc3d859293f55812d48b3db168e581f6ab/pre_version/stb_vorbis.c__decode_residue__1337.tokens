static void decode_residue ( vorb * f , float * residue_buffers [ ] , int ch , int n , int rn , uint8 * do_not_decode ) //<S2SV> { //<S2SV> int i , j , pass ; //<S2SV> Residue * r = f -> residue_config + rn ; //<S2SV> int rtype = f -> residue_types [ rn ] ; //<S2SV> int c = r -> classbook ; //<S2SV> int classwords = f -> codebooks [ c ] . dimensions ; //<S2SV> int n_read = r -> end - r -> begin ; //<S2SV> int part_read = n_read / r -> part_size ; //<S2SV> int temp_alloc_point = temp_alloc_save ( f ) ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> uint8 * * * part_classdata = ( uint8 * * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * part_classdata ) ) ; //<S2SV> # else //<S2SV> int * * classifications = ( int * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * classifications ) ) ; //<S2SV> # endif //<S2SV> CHECK ( f ) ; //<S2SV> for ( i = 0 ; i < ch ; ++ i ) //<S2SV> if ( ! do_not_decode [ i ] ) //<S2SV> memset ( residue_buffers [ i ] , 0 , sizeof ( float ) * n ) ; //<S2SV> if ( rtype == 2 && ch != 1 ) { //<S2SV> for ( j = 0 ; j < ch ; ++ j ) //<S2SV> if ( ! do_not_decode [ j ] ) //<S2SV> break ; //<S2SV> if ( j == ch ) //<S2SV> goto done ; //<S2SV> for ( pass = 0 ; pass < 8 ; ++ pass ) { //<S2SV> int pcount = 0 , class_set = 0 ; //<S2SV> if ( ch == 2 ) { //<S2SV> while ( pcount < part_read ) { //<S2SV> int z = r -> begin + pcount * r -> part_size ; //<S2SV> int c_inter = ( z & 1 ) , p_inter = z >> 1 ; //<S2SV> if ( pass == 0 ) { //<S2SV> Codebook * c = f -> codebooks + r -> classbook ; //<S2SV> int q ; //<S2SV> DECODE ( q , f , c ) ; //<S2SV> if ( q == EOP ) goto done ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; //<S2SV> # else //<S2SV> for ( i = classwords - 1 ; i >= 0 ; -- i ) { //<S2SV> classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; //<S2SV> q /= r -> classifications ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { //<S2SV> int z = r -> begin + pcount * r -> part_size ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> int c = part_classdata [ 0 ] [ class_set ] [ i ] ; //<S2SV> # else //<S2SV> int c = classifications [ 0 ] [ pcount ] ; //<S2SV> # endif //<S2SV> int b = r -> residue_books [ c ] [ pass ] ; //<S2SV> if ( b >= 0 ) { //<S2SV> Codebook * book = f -> codebooks + b ; //<S2SV> # ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK //<S2SV> if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) //<S2SV> goto done ; //<S2SV> # else //<S2SV> if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) //<S2SV> goto done ; //<S2SV> # endif //<S2SV> } else { //<S2SV> z += r -> part_size ; //<S2SV> c_inter = z & 1 ; //<S2SV> p_inter = z >> 1 ; //<S2SV> } //<S2SV> } //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> ++ class_set ; //<S2SV> # endif //<S2SV> } //<S2SV> } else if ( ch == 1 ) { //<S2SV> while ( pcount < part_read ) { //<S2SV> int z = r -> begin + pcount * r -> part_size ; //<S2SV> int c_inter = 0 , p_inter = z ; //<S2SV> if ( pass == 0 ) { //<S2SV> Codebook * c = f -> codebooks + r -> classbook ; //<S2SV> int q ; //<S2SV> DECODE ( q , f , c ) ; //<S2SV> if ( q == EOP ) goto done ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; //<S2SV> # else //<S2SV> for ( i = classwords - 1 ; i >= 0 ; -- i ) { //<S2SV> classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; //<S2SV> q /= r -> classifications ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { //<S2SV> int z = r -> begin + pcount * r -> part_size ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> int c = part_classdata [ 0 ] [ class_set ] [ i ] ; //<S2SV> # else //<S2SV> int c = classifications [ 0 ] [ pcount ] ; //<S2SV> # endif //<S2SV> int b = r -> residue_books [ c ] [ pass ] ; //<S2SV> if ( b >= 0 ) { //<S2SV> Codebook * book = f -> codebooks + b ; //<S2SV> if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) //<S2SV> goto done ; //<S2SV> } else { //<S2SV> z += r -> part_size ; //<S2SV> c_inter = 0 ; //<S2SV> p_inter = z ; //<S2SV> } //<S2SV> } //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> ++ class_set ; //<S2SV> # endif //<S2SV> } //<S2SV> } else { //<S2SV> while ( pcount < part_read ) { //<S2SV> int z = r -> begin + pcount * r -> part_size ; //<S2SV> int c_inter = z % ch , p_inter = z / ch ; //<S2SV> if ( pass == 0 ) { //<S2SV> Codebook * c = f -> codebooks + r -> classbook ; //<S2SV> int q ; //<S2SV> DECODE ( q , f , c ) ; //<S2SV> if ( q == EOP ) goto done ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> part_classdata [ 0 ] [ class_set ] = r -> classdata [ q ] ; //<S2SV> # else //<S2SV> for ( i = classwords - 1 ; i >= 0 ; -- i ) { //<S2SV> classifications [ 0 ] [ i + pcount ] = q % r -> classifications ; //<S2SV> q /= r -> classifications ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { //<S2SV> int z = r -> begin + pcount * r -> part_size ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> int c = part_classdata [ 0 ] [ class_set ] [ i ] ; //<S2SV> # else //<S2SV> int c = classifications [ 0 ] [ pcount ] ; //<S2SV> # endif //<S2SV> int b = r -> residue_books [ c ] [ pass ] ; //<S2SV> if ( b >= 0 ) { //<S2SV> Codebook * book = f -> codebooks + b ; //<S2SV> if ( ! codebook_decode_deinterleave_repeat ( f , book , residue_buffers , ch , & c_inter , & p_inter , n , r -> part_size ) ) //<S2SV> goto done ; //<S2SV> } else { //<S2SV> z += r -> part_size ; //<S2SV> c_inter = z % ch ; //<S2SV> p_inter = z / ch ; //<S2SV> } //<S2SV> } //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> ++ class_set ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> goto done ; //<S2SV> } //<S2SV> CHECK ( f ) ; //<S2SV> for ( pass = 0 ; pass < 8 ; ++ pass ) { //<S2SV> int pcount = 0 , class_set = 0 ; //<S2SV> while ( pcount < part_read ) { //<S2SV> if ( pass == 0 ) { //<S2SV> for ( j = 0 ; j < ch ; ++ j ) { //<S2SV> if ( ! do_not_decode [ j ] ) { //<S2SV> Codebook * c = f -> codebooks + r -> classbook ; //<S2SV> int temp ; //<S2SV> DECODE ( temp , f , c ) ; //<S2SV> if ( temp == EOP ) goto done ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> part_classdata [ j ] [ class_set ] = r -> classdata [ temp ] ; //<S2SV> # else //<S2SV> for ( i = classwords - 1 ; i >= 0 ; -- i ) { //<S2SV> classifications [ j ] [ i + pcount ] = temp % r -> classifications ; //<S2SV> temp /= r -> classifications ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < classwords && pcount < part_read ; ++ i , ++ pcount ) { //<S2SV> for ( j = 0 ; j < ch ; ++ j ) { //<S2SV> if ( ! do_not_decode [ j ] ) { //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> int c = part_classdata [ j ] [ class_set ] [ i ] ; //<S2SV> # else //<S2SV> int c = classifications [ j ] [ pcount ] ; //<S2SV> # endif //<S2SV> int b = r -> residue_books [ c ] [ pass ] ; //<S2SV> if ( b >= 0 ) { //<S2SV> float * target = residue_buffers [ j ] ; //<S2SV> int offset = r -> begin + pcount * r -> part_size ; //<S2SV> int n = r -> part_size ; //<S2SV> Codebook * book = f -> codebooks + b ; //<S2SV> if ( ! residue_decode ( f , book , target , offset , n , rtype ) ) //<S2SV> goto done ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> ++ class_set ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> done : //<S2SV> CHECK ( f ) ; //<S2SV> # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE //<S2SV> temp_free ( f , part_classdata ) ; //<S2SV> # else //<S2SV> temp_free ( f , classifications ) ; //<S2SV> # endif //<S2SV> temp_alloc_restore ( f , temp_alloc_point ) ; //<S2SV> } //<S2SV> 