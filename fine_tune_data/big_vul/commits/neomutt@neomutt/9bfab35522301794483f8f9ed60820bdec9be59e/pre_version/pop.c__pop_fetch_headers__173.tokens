static int pop_fetch_headers ( struct Context * ctx ) //<S2SV> { //<S2SV> struct PopData * pop_data = ( struct PopData * ) ctx -> data ; //<S2SV> struct Progress progress ; //<S2SV> # ifdef USE_HCACHE //<S2SV> header_cache_t * hc = pop_hcache_open ( pop_data , ctx -> path ) ; //<S2SV> # endif //<S2SV> time ( & pop_data -> check_time ) ; //<S2SV> pop_data -> clear_cache = false ; //<S2SV> for ( int i = 0 ; i < ctx -> msgcount ; i ++ ) //<S2SV> ctx -> hdrs [ i ] -> refno = - 1 ; //<S2SV> const int old_count = ctx -> msgcount ; //<S2SV> int ret = pop_fetch_data ( pop_data , "UIDL\\r\\n" , NULL , fetch_uidl , ctx ) ; //<S2SV> const int new_count = ctx -> msgcount ; //<S2SV> ctx -> msgcount = old_count ; //<S2SV> if ( pop_data -> cmd_uidl == 2 ) //<S2SV> { //<S2SV> if ( ret == 0 ) //<S2SV> { //<S2SV> pop_data -> cmd_uidl = 1 ; //<S2SV> mutt_debug ( 1 , "set<S2SV_blank>UIDL<S2SV_blank>capability\\n" ) ; //<S2SV> } //<S2SV> if ( ret == - 2 && pop_data -> cmd_uidl == 2 ) //<S2SV> { //<S2SV> pop_data -> cmd_uidl = 0 ; //<S2SV> mutt_debug ( 1 , "unset<S2SV_blank>UIDL<S2SV_blank>capability\\n" ) ; //<S2SV> snprintf ( pop_data -> err_msg , sizeof ( pop_data -> err_msg ) , "%s" , //<S2SV> _ ( "Command<S2SV_blank>UIDL<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server." ) ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ctx -> quiet ) //<S2SV> { //<S2SV> mutt_progress_init ( & progress , _ ( "Fetching<S2SV_blank>message<S2SV_blank>headers..." ) , //<S2SV> MUTT_PROGRESS_MSG , ReadInc , new_count - old_count ) ; //<S2SV> } //<S2SV> if ( ret == 0 ) //<S2SV> { //<S2SV> int i , deleted ; //<S2SV> for ( i = 0 , deleted = 0 ; i < old_count ; i ++ ) //<S2SV> { //<S2SV> if ( ctx -> hdrs [ i ] -> refno == - 1 ) //<S2SV> { //<S2SV> ctx -> hdrs [ i ] -> deleted = true ; //<S2SV> deleted ++ ; //<S2SV> } //<S2SV> } //<S2SV> if ( deleted > 0 ) //<S2SV> { //<S2SV> mutt_error ( //<S2SV> ngettext ( "%d<S2SV_blank>message<S2SV_blank>has<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." , //<S2SV> "%d<S2SV_blank>messages<S2SV_blank>have<S2SV_blank>been<S2SV_blank>lost.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." , deleted ) , //<S2SV> deleted ) ; //<S2SV> } //<S2SV> bool hcached = false ; //<S2SV> for ( i = old_count ; i < new_count ; i ++ ) //<S2SV> { //<S2SV> if ( ! ctx -> quiet ) //<S2SV> mutt_progress_update ( & progress , i + 1 - old_count , - 1 ) ; //<S2SV> # ifdef USE_HCACHE //<S2SV> void * data = mutt_hcache_fetch ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; //<S2SV> if ( data ) //<S2SV> { //<S2SV> char * uidl = mutt_str_strdup ( ctx -> hdrs [ i ] -> data ) ; //<S2SV> int refno = ctx -> hdrs [ i ] -> refno ; //<S2SV> int index = ctx -> hdrs [ i ] -> index ; //<S2SV> struct Header * h = mutt_hcache_restore ( ( unsigned char * ) data ) ; //<S2SV> mutt_hcache_free ( hc , & data ) ; //<S2SV> mutt_header_free ( & ctx -> hdrs [ i ] ) ; //<S2SV> ctx -> hdrs [ i ] = h ; //<S2SV> ctx -> hdrs [ i ] -> refno = refno ; //<S2SV> ctx -> hdrs [ i ] -> index = index ; //<S2SV> ctx -> hdrs [ i ] -> data = uidl ; //<S2SV> ret = 0 ; //<S2SV> hcached = true ; //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> if ( ( ret = pop_read_header ( pop_data , ctx -> hdrs [ i ] ) ) < 0 ) //<S2SV> break ; //<S2SV> # ifdef USE_HCACHE //<S2SV> else //<S2SV> { //<S2SV> mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , //<S2SV> ctx -> hdrs [ i ] , 0 ) ; //<S2SV> } //<S2SV> # endif //<S2SV> const bool bcached = //<S2SV> ( mutt_bcache_exists ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) == 0 ) ; //<S2SV> ctx -> hdrs [ i ] -> old = false ; //<S2SV> ctx -> hdrs [ i ] -> read = false ; //<S2SV> if ( hcached ) //<S2SV> { //<S2SV> if ( bcached ) //<S2SV> ctx -> hdrs [ i ] -> read = true ; //<S2SV> else if ( MarkOld ) //<S2SV> ctx -> hdrs [ i ] -> old = true ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( bcached ) //<S2SV> ctx -> hdrs [ i ] -> read = true ; //<S2SV> } //<S2SV> ctx -> msgcount ++ ; //<S2SV> } //<S2SV> if ( i > old_count ) //<S2SV> mx_update_context ( ctx , i - old_count ) ; //<S2SV> } //<S2SV> # ifdef USE_HCACHE //<S2SV> mutt_hcache_close ( hc ) ; //<S2SV> # endif //<S2SV> if ( ret < 0 ) //<S2SV> { //<S2SV> for ( int i = ctx -> msgcount ; i < new_count ; i ++ ) //<S2SV> mutt_header_free ( & ctx -> hdrs [ i ] ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( MessageCacheClean ) //<S2SV> mutt_bcache_list ( pop_data -> bcache , msg_cache_check , ( void * ) ctx ) ; //<S2SV> mutt_clear_error ( ) ; //<S2SV> return ( new_count - old_count ) ; //<S2SV> } //<S2SV> 