static int pop_fetch_message ( struct Context * ctx , struct Message * msg , int msgno ) //<S2SV> { //<S2SV> void * uidl = NULL ; //<S2SV> char buf [ LONG_STRING ] ; //<S2SV> char path [ PATH_MAX ] ; //<S2SV> struct Progress progressbar ; //<S2SV> struct PopData * pop_data = ( struct PopData * ) ctx -> data ; //<S2SV> struct PopCache * cache = NULL ; //<S2SV> struct Header * h = ctx -> hdrs [ msgno ] ; //<S2SV> unsigned short bcache = 1 ; //<S2SV> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; //<S2SV> if ( msg -> fp ) //<S2SV> return 0 ; //<S2SV> cache = & pop_data -> cache [ h -> index % POP_CACHE_LEN ] ; //<S2SV> if ( cache -> path ) //<S2SV> { //<S2SV> if ( cache -> index == h -> index ) //<S2SV> { //<S2SV> msg -> fp = fopen ( cache -> path , "r" ) ; //<S2SV> if ( msg -> fp ) //<S2SV> return 0 ; //<S2SV> mutt_perror ( cache -> path ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> unlink ( cache -> path ) ; //<S2SV> FREE ( & cache -> path ) ; //<S2SV> } //<S2SV> } //<S2SV> while ( true ) //<S2SV> { //<S2SV> if ( pop_reconnect ( ctx ) < 0 ) //<S2SV> return - 1 ; //<S2SV> if ( h -> refno < 0 ) //<S2SV> { //<S2SV> mutt_error ( //<S2SV> _ ( "The<S2SV_blank>message<S2SV_blank>index<S2SV_blank>is<S2SV_blank>incorrect.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox." ) ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> mutt_progress_init ( & progressbar , _ ( "Fetching<S2SV_blank>message..." ) , MUTT_PROGRESS_SIZE , //<S2SV> NetInc , h -> content -> length + h -> content -> offset - 1 ) ; //<S2SV> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; //<S2SV> if ( ! msg -> fp ) //<S2SV> { //<S2SV> bcache = 0 ; //<S2SV> mutt_mktemp ( path , sizeof ( path ) ) ; //<S2SV> msg -> fp = mutt_file_fopen ( path , "w+" ) ; //<S2SV> if ( ! msg -> fp ) //<S2SV> { //<S2SV> mutt_perror ( path ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> snprintf ( buf , sizeof ( buf ) , "RETR<S2SV_blank>%d\\r\\n" , h -> refno ) ; //<S2SV> const int ret = pop_fetch_data ( pop_data , buf , & progressbar , fetch_message , msg -> fp ) ; //<S2SV> if ( ret == 0 ) //<S2SV> break ; //<S2SV> mutt_file_fclose ( & msg -> fp ) ; //<S2SV> if ( ! bcache ) //<S2SV> unlink ( path ) ; //<S2SV> if ( ret == - 2 ) //<S2SV> { //<S2SV> mutt_error ( "%s" , pop_data -> err_msg ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( ret == - 3 ) //<S2SV> { //<S2SV> mutt_error ( _ ( "Can\'t<S2SV_blank>write<S2SV_blank>message<S2SV_blank>to<S2SV_blank>temporary<S2SV_blank>file!" ) ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( bcache ) //<S2SV> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; //<S2SV> else //<S2SV> { //<S2SV> cache -> index = h -> index ; //<S2SV> cache -> path = mutt_str_strdup ( path ) ; //<S2SV> } //<S2SV> rewind ( msg -> fp ) ; //<S2SV> uidl = h -> data ; //<S2SV> if ( ctx -> subj_hash && h -> env -> real_subj ) //<S2SV> mutt_hash_delete ( ctx -> subj_hash , h -> env -> real_subj , h ) ; //<S2SV> mutt_label_hash_remove ( ctx , h ) ; //<S2SV> mutt_env_free ( & h -> env ) ; //<S2SV> h -> env = mutt_rfc822_read_header ( msg -> fp , h , 0 , 0 ) ; //<S2SV> if ( ctx -> subj_hash && h -> env -> real_subj ) //<S2SV> mutt_hash_insert ( ctx -> subj_hash , h -> env -> real_subj , h ) ; //<S2SV> mutt_label_hash_add ( ctx , h ) ; //<S2SV> h -> data = uidl ; //<S2SV> h -> lines = 0 ; //<S2SV> fgets ( buf , sizeof ( buf ) , msg -> fp ) ; //<S2SV> while ( ! feof ( msg -> fp ) ) //<S2SV> { //<S2SV> ctx -> hdrs [ msgno ] -> lines ++ ; //<S2SV> fgets ( buf , sizeof ( buf ) , msg -> fp ) ; //<S2SV> } //<S2SV> h -> content -> length = ftello ( msg -> fp ) - h -> content -> offset ; //<S2SV> if ( ! WithCrypto ) //<S2SV> h -> security = crypt_query ( h -> content ) ; //<S2SV> mutt_clear_error ( ) ; //<S2SV> rewind ( msg -> fp ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 