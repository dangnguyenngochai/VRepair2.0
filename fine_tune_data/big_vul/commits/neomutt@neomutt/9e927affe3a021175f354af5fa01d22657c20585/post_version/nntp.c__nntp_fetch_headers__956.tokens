static int nntp_fetch_headers ( struct Context * ctx , void * hc , anum_t first , //<S2SV> anum_t last , int restore ) //<S2SV> { //<S2SV> struct NntpData * nntp_data = ctx -> data ; //<S2SV> struct FetchCtx fc ; //<S2SV> struct Header * hdr = NULL ; //<S2SV> char buf [ HUGE_STRING ] ; //<S2SV> int rc = 0 ; //<S2SV> int oldmsgcount = ctx -> msgcount ; //<S2SV> anum_t current ; //<S2SV> anum_t first_over = first ; //<S2SV> # ifdef USE_HCACHE //<S2SV> void * hdata = NULL ; //<S2SV> # endif //<S2SV> if ( ! last || first > last ) //<S2SV> return 0 ; //<S2SV> fc . ctx = ctx ; //<S2SV> fc . first = first ; //<S2SV> fc . last = last ; //<S2SV> fc . restore = restore ; //<S2SV> fc . messages = mutt_mem_calloc ( last - first + 1 , sizeof ( unsigned char ) ) ; //<S2SV> if ( fc . messages == NULL ) //<S2SV> return - 1 ; //<S2SV> # ifdef USE_HCACHE //<S2SV> fc . hc = hc ; //<S2SV> # endif //<S2SV> if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP && ! nntp_data -> deleted ) //<S2SV> { //<S2SV> if ( ! ctx -> quiet ) //<S2SV> mutt_message ( _ ( "Fetching<S2SV_blank>list<S2SV_blank>of<S2SV_blank>articles..." ) ) ; //<S2SV> if ( nntp_data -> nserv -> hasLISTGROUPrange ) //<S2SV> snprintf ( buf , sizeof ( buf ) , "LISTGROUP<S2SV_blank>%s<S2SV_blank>%u-%u\\r\\n" , nntp_data -> group , first , last ) ; //<S2SV> else //<S2SV> snprintf ( buf , sizeof ( buf ) , "LISTGROUP<S2SV_blank>%s\\r\\n" , nntp_data -> group ) ; //<S2SV> rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_numbers , & fc ) ; //<S2SV> if ( rc > 0 ) //<S2SV> { //<S2SV> mutt_error ( "LISTGROUP:<S2SV_blank>%s" , buf ) ; //<S2SV> } //<S2SV> if ( rc == 0 ) //<S2SV> { //<S2SV> for ( current = first ; current <= last && rc == 0 ; current ++ ) //<S2SV> { //<S2SV> if ( fc . messages [ current - first ] ) //<S2SV> continue ; //<S2SV> snprintf ( buf , sizeof ( buf ) , "%u" , current ) ; //<S2SV> if ( nntp_data -> bcache ) //<S2SV> { //<S2SV> mutt_debug ( 2 , "#1<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n" , buf ) ; //<S2SV> mutt_bcache_del ( nntp_data -> bcache , buf ) ; //<S2SV> } //<S2SV> # ifdef USE_HCACHE //<S2SV> if ( fc . hc ) //<S2SV> { //<S2SV> mutt_debug ( 2 , "mutt_hcache_delete<S2SV_blank>%s\\n" , buf ) ; //<S2SV> mutt_hcache_delete ( fc . hc , buf , strlen ( buf ) ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> for ( current = first ; current <= last ; current ++ ) //<S2SV> fc . messages [ current - first ] = 1 ; //<S2SV> } //<S2SV> if ( ! ctx -> quiet ) //<S2SV> { //<S2SV> mutt_progress_init ( & fc . progress , _ ( "Fetching<S2SV_blank>message<S2SV_blank>headers..." ) , //<S2SV> MUTT_PROGRESS_MSG , ReadInc , last - first + 1 ) ; //<S2SV> } //<S2SV> for ( current = first ; current <= last && rc == 0 ; current ++ ) //<S2SV> { //<S2SV> if ( ! ctx -> quiet ) //<S2SV> mutt_progress_update ( & fc . progress , current - first + 1 , - 1 ) ; //<S2SV> # ifdef USE_HCACHE //<S2SV> snprintf ( buf , sizeof ( buf ) , "%u" , current ) ; //<S2SV> # endif //<S2SV> if ( ! fc . messages [ current - first ] ) //<S2SV> continue ; //<S2SV> if ( ctx -> msgcount >= ctx -> hdrmax ) //<S2SV> mx_alloc_memory ( ctx ) ; //<S2SV> # ifdef USE_HCACHE //<S2SV> hdata = mutt_hcache_fetch ( fc . hc , buf , strlen ( buf ) ) ; //<S2SV> if ( hdata ) //<S2SV> { //<S2SV> mutt_debug ( 2 , "mutt_hcache_fetch<S2SV_blank>%s\\n" , buf ) ; //<S2SV> ctx -> hdrs [ ctx -> msgcount ] = hdr = mutt_hcache_restore ( hdata ) ; //<S2SV> mutt_hcache_free ( fc . hc , & hdata ) ; //<S2SV> hdr -> data = 0 ; //<S2SV> if ( hdr -> deleted && ! restore ) //<S2SV> { //<S2SV> mutt_header_free ( & hdr ) ; //<S2SV> if ( nntp_data -> bcache ) //<S2SV> { //<S2SV> mutt_debug ( 2 , "#2<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n" , buf ) ; //<S2SV> mutt_bcache_del ( nntp_data -> bcache , buf ) ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> hdr -> read = false ; //<S2SV> hdr -> old = false ; //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> if ( nntp_data -> deleted ) //<S2SV> continue ; //<S2SV> else if ( nntp_data -> nserv -> hasOVER || nntp_data -> nserv -> hasXOVER ) //<S2SV> { //<S2SV> if ( NntpListgroup && nntp_data -> nserv -> hasLISTGROUP ) //<S2SV> break ; //<S2SV> else //<S2SV> continue ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> FILE * fp = mutt_file_mkstemp ( ) ; //<S2SV> if ( ! fp ) //<S2SV> { //<S2SV> mutt_perror ( "mutt_file_mkstemp()<S2SV_blank>failed!" ) ; //<S2SV> rc = - 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> snprintf ( buf , sizeof ( buf ) , "HEAD<S2SV_blank>%u\\r\\n" , current ) ; //<S2SV> rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , fetch_tempfile , fp ) ; //<S2SV> if ( rc ) //<S2SV> { //<S2SV> mutt_file_fclose ( & fp ) ; //<S2SV> if ( rc < 0 ) //<S2SV> break ; //<S2SV> if ( mutt_str_strncmp ( "423" , buf , 3 ) != 0 ) //<S2SV> { //<S2SV> mutt_error ( "HEAD:<S2SV_blank>%s" , buf ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( nntp_data -> bcache ) //<S2SV> { //<S2SV> snprintf ( buf , sizeof ( buf ) , "%u" , current ) ; //<S2SV> mutt_debug ( 2 , "#3<S2SV_blank>mutt_bcache_del<S2SV_blank>%s\\n" , buf ) ; //<S2SV> mutt_bcache_del ( nntp_data -> bcache , buf ) ; //<S2SV> } //<S2SV> rc = 0 ; //<S2SV> continue ; //<S2SV> } //<S2SV> hdr = ctx -> hdrs [ ctx -> msgcount ] = mutt_header_new ( ) ; //<S2SV> hdr -> env = mutt_rfc822_read_header ( fp , hdr , 0 , 0 ) ; //<S2SV> hdr -> received = hdr -> date_sent ; //<S2SV> mutt_file_fclose ( & fp ) ; //<S2SV> } //<S2SV> hdr -> index = ctx -> msgcount ++ ; //<S2SV> hdr -> read = false ; //<S2SV> hdr -> old = false ; //<S2SV> hdr -> deleted = false ; //<S2SV> hdr -> data = mutt_mem_calloc ( 1 , sizeof ( struct NntpHeaderData ) ) ; //<S2SV> NHDR ( hdr ) -> article_num = current ; //<S2SV> if ( restore ) //<S2SV> hdr -> changed = true ; //<S2SV> else //<S2SV> { //<S2SV> nntp_article_status ( ctx , hdr , NULL , NHDR ( hdr ) -> article_num ) ; //<S2SV> if ( ! hdr -> read ) //<S2SV> nntp_parse_xref ( ctx , hdr ) ; //<S2SV> } //<S2SV> if ( current > nntp_data -> last_loaded ) //<S2SV> nntp_data -> last_loaded = current ; //<S2SV> first_over = current + 1 ; //<S2SV> } //<S2SV> if ( ! NntpListgroup || ! nntp_data -> nserv -> hasLISTGROUP ) //<S2SV> current = first_over ; //<S2SV> if ( current <= last && rc == 0 && ! nntp_data -> deleted ) //<S2SV> { //<S2SV> char * cmd = nntp_data -> nserv -> hasOVER ? "OVER" : "XOVER" ; //<S2SV> snprintf ( buf , sizeof ( buf ) , "%s<S2SV_blank>%u-%u\\r\\n" , cmd , current , last ) ; //<S2SV> rc = nntp_fetch_lines ( nntp_data , buf , sizeof ( buf ) , NULL , parse_overview_line , & fc ) ; //<S2SV> if ( rc > 0 ) //<S2SV> { //<S2SV> mutt_error ( "%s:<S2SV_blank>%s" , cmd , buf ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ctx -> msgcount > oldmsgcount ) //<S2SV> mx_update_context ( ctx , ctx -> msgcount - oldmsgcount ) ; //<S2SV> FREE ( & fc . messages ) ; //<S2SV> if ( rc != 0 ) //<S2SV> return - 1 ; //<S2SV> mutt_clear_error ( ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 