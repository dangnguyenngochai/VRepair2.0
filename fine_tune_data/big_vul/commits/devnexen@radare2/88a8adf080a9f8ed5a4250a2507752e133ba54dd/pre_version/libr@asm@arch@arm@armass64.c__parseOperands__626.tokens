static bool parseOperands ( char * str , ArmOp * op ) { //<S2SV> char * t = strdup ( str ) ; //<S2SV> int operand = 0 ; //<S2SV> char * token = t ; //<S2SV> char * x ; //<S2SV> int imm_count = 0 ; //<S2SV> int mem_opt = 0 ; //<S2SV> if ( ! token ) { //<S2SV> return false ; //<S2SV> } //<S2SV> while ( token ) { //<S2SV> char * next = strchr ( token , ',' ) ; //<S2SV> if ( next ) { //<S2SV> * next ++ = 0 ; //<S2SV> } //<S2SV> while ( token [ 0 ] == '<S2SV_blank>' ) { //<S2SV> token ++ ; //<S2SV> } //<S2SV> if ( operand >= MAX_OPERANDS ) { //<S2SV> eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> op -> operands [ operand ] . type = ARM_NOTYPE ; //<S2SV> op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; //<S2SV> op -> operands [ operand ] . shift = ARM_NO_SHIFT ; //<S2SV> while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { //<S2SV> token ++ ; //<S2SV> } //<S2SV> if ( ! strncmp ( token , "lsl" , 3 ) ) { //<S2SV> op -> operands [ operand ] . shift = ARM_LSL ; //<S2SV> } else if ( ! strncmp ( token , "lsr" , 3 ) ) { //<S2SV> op -> operands [ operand ] . shift = ARM_LSR ; //<S2SV> } else if ( ! strncmp ( token , "asr" , 3 ) ) { //<S2SV> op -> operands [ operand ] . shift = ARM_ASR ; //<S2SV> } //<S2SV> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { //<S2SV> op -> operands_count ++ ; //<S2SV> op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; //<S2SV> if ( op -> operands [ operand ] . shift_amount > 63 ) { //<S2SV> return false ; //<S2SV> } //<S2SV> operand ++ ; //<S2SV> token = next ; //<S2SV> continue ; //<S2SV> } //<S2SV> switch ( token [ 0 ] ) { //<S2SV> case 'x' : //<S2SV> x = strchr ( token , ',' ) ; //<S2SV> if ( x ) { //<S2SV> x [ 0 ] = '\\0' ; //<S2SV> } //<S2SV> op -> operands_count ++ ; //<S2SV> op -> operands [ operand ] . type = ARM_GPR ; //<S2SV> op -> operands [ operand ] . reg_type = ARM_REG64 ; //<S2SV> op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; //<S2SV> if ( op -> operands [ operand ] . reg > 31 ) { //<S2SV> return false ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'w' : //<S2SV> op -> operands_count ++ ; //<S2SV> op -> operands [ operand ] . type = ARM_GPR ; //<S2SV> op -> operands [ operand ] . reg_type = ARM_REG32 ; //<S2SV> op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; //<S2SV> if ( op -> operands [ operand ] . reg > 31 ) { //<S2SV> return false ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'v' : //<S2SV> op -> operands_count ++ ; //<S2SV> op -> operands [ operand ] . type = ARM_FP ; //<S2SV> op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; //<S2SV> break ; //<S2SV> case 's' : //<S2SV> case 'S' : //<S2SV> if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { //<S2SV> if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { //<S2SV> op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> op -> operands_count ++ ; //<S2SV> op -> operands [ operand ] . type = ARM_GPR ; //<S2SV> op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; //<S2SV> op -> operands [ operand ] . reg = 31 ; //<S2SV> break ; //<S2SV> } //<S2SV> mem_opt = get_mem_option ( token ) ; //<S2SV> if ( mem_opt != - 1 ) { //<S2SV> op -> operands_count ++ ; //<S2SV> op -> operands [ operand ] . type = ARM_MEM_OPT ; //<S2SV> op -> operands [ operand ] . mem_option = mem_opt ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'L' : //<S2SV> case 'l' : //<S2SV> case 'I' : //<S2SV> case 'i' : //<S2SV> case 'N' : //<S2SV> case 'n' : //<S2SV> case 'O' : //<S2SV> case 'o' : //<S2SV> case 'p' : //<S2SV> case 'P' : //<S2SV> mem_opt = get_mem_option ( token ) ; //<S2SV> if ( mem_opt != - 1 ) { //<S2SV> op -> operands_count ++ ; //<S2SV> op -> operands [ operand ] . type = ARM_MEM_OPT ; //<S2SV> op -> operands [ operand ] . mem_option = mem_opt ; //<S2SV> } //<S2SV> break ; //<S2SV> case '-' : //<S2SV> op -> operands [ operand ] . sign = - 1 ; //<S2SV> default : //<S2SV> op -> operands_count ++ ; //<S2SV> op -> operands [ operand ] . type = ARM_CONSTANT ; //<S2SV> op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; //<S2SV> imm_count ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> token = next ; //<S2SV> operand ++ ; //<S2SV> if ( operand > MAX_OPERANDS ) { //<S2SV> free ( t ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> } //<S2SV> free ( t ) ; //<S2SV> return true ; //<S2SV> } //<S2SV> 