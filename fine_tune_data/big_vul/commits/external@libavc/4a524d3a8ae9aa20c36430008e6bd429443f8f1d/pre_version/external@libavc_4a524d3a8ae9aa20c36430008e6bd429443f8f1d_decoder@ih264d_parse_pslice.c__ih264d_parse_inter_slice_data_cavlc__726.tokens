WORD32 ih264d_parse_inter_slice_data_cavlc ( dec_struct_t * ps_dec , //<S2SV> dec_slice_params_t * ps_slice , //<S2SV> UWORD16 u2_first_mb_in_slice ) //<S2SV> { //<S2SV> UWORD32 uc_more_data_flag ; //<S2SV> WORD32 i2_cur_mb_addr ; //<S2SV> UWORD32 u1_num_mbs , u1_num_mbsNby2 , u1_mb_idx ; //<S2SV> UWORD32 i2_mb_skip_run ; //<S2SV> UWORD32 u1_read_mb_type ; //<S2SV> UWORD32 u1_mbaff ; //<S2SV> UWORD32 u1_num_mbs_next , u1_end_of_row ; //<S2SV> const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; //<S2SV> UWORD32 u1_slice_end = 0 ; //<S2SV> UWORD32 u1_tfr_n_mb = 0 ; //<S2SV> UWORD32 u1_decode_nmb = 0 ; //<S2SV> dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; //<S2SV> UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; //<S2SV> UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; //<S2SV> deblk_mb_t * ps_cur_deblk_mb ; //<S2SV> dec_mb_info_t * ps_cur_mb_info ; //<S2SV> parse_pmbarams_t * ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; //<S2SV> UWORD32 u1_inter_mb_type ; //<S2SV> UWORD32 u1_deblk_mb_type ; //<S2SV> UWORD32 u1_mb_threshold ; //<S2SV> WORD32 ret = OK ; //<S2SV> if ( ps_slice -> u1_slice_type == P_SLICE ) //<S2SV> { //<S2SV> u1_inter_mb_type = P_MB ; //<S2SV> u1_deblk_mb_type = D_INTER_MB ; //<S2SV> u1_mb_threshold = 5 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> u1_inter_mb_type = B_MB ; //<S2SV> u1_deblk_mb_type = D_B_SLICE ; //<S2SV> u1_mb_threshold = 23 ; //<S2SV> } //<S2SV> ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; //<S2SV> ih264d_update_qp ( ps_dec , 0 ) ; //<S2SV> u1_mb_idx = ps_dec -> u1_mb_idx ; //<S2SV> u1_num_mbs = u1_mb_idx ; //<S2SV> u1_num_mbsNby2 = 0 ; //<S2SV> u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; //<S2SV> i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; //<S2SV> i2_mb_skip_run = 0 ; //<S2SV> uc_more_data_flag = 1 ; //<S2SV> u1_read_mb_type = 0 ; //<S2SV> while ( ! u1_slice_end ) //<S2SV> { //<S2SV> UWORD8 u1_mb_type ; //<S2SV> ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; //<S2SV> if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) //<S2SV> { //<S2SV> ret = ERROR_MB_ADDRESS_T ; //<S2SV> break ; //<S2SV> } //<S2SV> ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; //<S2SV> ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; //<S2SV> ps_cur_mb_info -> u1_Mux = 0 ; //<S2SV> ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; //<S2SV> ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; //<S2SV> ps_cur_mb_info -> u1_end_of_slice = 0 ; //<S2SV> ps_parse_mb_data -> u1_num_part = 1 ; //<S2SV> ps_parse_mb_data -> u1_isI_mb = 0 ; //<S2SV> if ( ( ! i2_mb_skip_run ) && ( ! u1_read_mb_type ) ) //<S2SV> { //<S2SV> UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; //<S2SV> UWORD32 u4_word , u4_ldz ; //<S2SV> NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; //<S2SV> u4_ldz = CLZ ( u4_word ) ; //<S2SV> u4_bitstream_offset += ( u4_ldz + 1 ) ; //<S2SV> u4_word = 0 ; //<S2SV> if ( u4_ldz ) //<S2SV> { //<S2SV> GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , //<S2SV> u4_ldz ) ; //<S2SV> } //<S2SV> * pu4_bitstrm_ofst = u4_bitstream_offset ; //<S2SV> i2_mb_skip_run = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; //<S2SV> COPYTHECONTEXT ( "mb_skip_run" , i2_mb_skip_run ) ; //<S2SV> uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; //<S2SV> u1_read_mb_type = uc_more_data_flag ; //<S2SV> } //<S2SV> ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; //<S2SV> if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) //<S2SV> ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , //<S2SV> ps_dec -> u1_mb_ngbr_availablity , //<S2SV> ps_dec -> u1_cur_mb_fld_dec_flag ) ; //<S2SV> if ( i2_mb_skip_run ) //<S2SV> { //<S2SV> ps_dec -> i1_prev_mb_qp_delta = 0 ; //<S2SV> ps_dec -> u1_sub_mb_num = 0 ; //<S2SV> ps_cur_mb_info -> u1_mb_type = MB_SKIP ; //<S2SV> ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; //<S2SV> ps_cur_mb_info -> u1_cbp = 0 ; //<S2SV> { //<S2SV> parse_part_params_t * ps_part_info = ps_dec -> ps_part ; //<S2SV> ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; //<S2SV> ps_part_info -> u1_sub_mb_num = 0 ; //<S2SV> ps_dec -> ps_part ++ ; //<S2SV> } //<S2SV> ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; //<S2SV> ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; //<S2SV> ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; //<S2SV> i2_mb_skip_run -- ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> u1_read_mb_type = 0 ; //<S2SV> { //<S2SV> UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; //<S2SV> UWORD32 u4_word , u4_ldz , u4_temp ; //<S2SV> NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; //<S2SV> u4_ldz = CLZ ( u4_word ) ; //<S2SV> u4_bitstream_offset += ( u4_ldz + 1 ) ; //<S2SV> u4_word = 0 ; //<S2SV> if ( u4_ldz ) //<S2SV> GETBITS ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf , //<S2SV> u4_ldz ) ; //<S2SV> * pu4_bitstrm_ofst = u4_bitstream_offset ; //<S2SV> u4_temp = ( ( 1 << u4_ldz ) + u4_word - 1 ) ; //<S2SV> if ( u4_temp > ( UWORD32 ) ( 25 + u1_mb_threshold ) ) //<S2SV> return ERROR_MB_TYPE ; //<S2SV> u1_mb_type = u4_temp ; //<S2SV> COPYTHECONTEXT ( "u1_mb_type" , u1_mb_type ) ; //<S2SV> } //<S2SV> ps_cur_mb_info -> u1_mb_type = u1_mb_type ; //<S2SV> if ( u1_mb_type < u1_mb_threshold ) //<S2SV> { //<S2SV> ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; //<S2SV> ret = ps_dec -> pf_parse_inter_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs , //<S2SV> u1_num_mbsNby2 ) ; //<S2SV> if ( ret != OK ) //<S2SV> return ret ; //<S2SV> ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_parse_mb_data -> u1_num_part = 0 ; //<S2SV> ps_parse_mb_data -> u1_isI_mb = 1 ; //<S2SV> if ( ( 25 + u1_mb_threshold ) == u1_mb_type ) //<S2SV> { //<S2SV> ps_cur_mb_info -> ps_curmb -> u1_mb_type = I_PCM_MB ; //<S2SV> ret = ih264d_parse_ipcm_mb ( ps_dec , ps_cur_mb_info , u1_num_mbs ) ; //<S2SV> if ( ret != OK ) //<S2SV> return ret ; //<S2SV> ps_dec -> u1_qp = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ret = ih264d_parse_imb_cavlc ( //<S2SV> ps_dec , ps_cur_mb_info , u1_num_mbs , //<S2SV> ( UWORD8 ) ( u1_mb_type - u1_mb_threshold ) ) ; //<S2SV> if ( ret != OK ) //<S2SV> return ret ; //<S2SV> } //<S2SV> ps_cur_deblk_mb -> u1_mb_type |= D_INTRA_MB ; //<S2SV> } //<S2SV> uc_more_data_flag = MORE_RBSP_DATA ( ps_bitstrm ) ; //<S2SV> } //<S2SV> ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; //<S2SV> if ( u1_mbaff ) //<S2SV> { //<S2SV> ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; //<S2SV> } //<S2SV> i2_cur_mb_addr ++ ; //<S2SV> u1_num_mbs ++ ; //<S2SV> ps_dec -> u2_total_mbs_coded ++ ; //<S2SV> u1_num_mbsNby2 ++ ; //<S2SV> ps_parse_mb_data ++ ; //<S2SV> u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; //<S2SV> u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; //<S2SV> u1_slice_end = ( ! ( uc_more_data_flag || i2_mb_skip_run ) ) ; //<S2SV> u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row //<S2SV> || u1_slice_end ; //<S2SV> u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; //<S2SV> ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; //<S2SV> if ( u1_decode_nmb ) //<S2SV> { //<S2SV> ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; //<S2SV> u1_num_mbsNby2 = 0 ; //<S2SV> { //<S2SV> ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; //<S2SV> ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; //<S2SV> } //<S2SV> } //<S2SV> if ( u1_decode_nmb ) //<S2SV> { //<S2SV> if ( ps_dec -> u1_separate_parse ) //<S2SV> { //<S2SV> ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , //<S2SV> u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; //<S2SV> ps_dec -> ps_nmb_info += u1_num_mbs ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , //<S2SV> u1_num_mbs_next , u1_tfr_n_mb , //<S2SV> u1_end_of_row ) ; //<S2SV> } //<S2SV> if ( u1_tfr_n_mb ) //<S2SV> u1_num_mbs = 0 ; //<S2SV> u1_mb_idx = u1_num_mbs ; //<S2SV> ps_dec -> u1_mb_idx = u1_num_mbs ; //<S2SV> } //<S2SV> } //<S2SV> ps_dec -> u4_num_mbs_cur_nmb = 0 ; //<S2SV> ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr //<S2SV> - ( u2_first_mb_in_slice << u1_mbaff ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 