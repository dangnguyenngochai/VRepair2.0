static void handle_data_packet ( struct mt_connection * curconn , struct mt_mactelnet_hdr * pkthdr , int data_len ) { //<S2SV> struct mt_mactelnet_control_hdr cpkt ; //<S2SV> struct mt_packet pdata ; //<S2SV> unsigned char * data = pkthdr -> data ; //<S2SV> unsigned int act_size = 0 ; //<S2SV> int got_user_packet = 0 ; //<S2SV> int got_pass_packet = 0 ; //<S2SV> int got_width_packet = 0 ; //<S2SV> int got_height_packet = 0 ; //<S2SV> int success ; //<S2SV> success = parse_control_packet ( data , data_len - MT_HEADER_LEN , & cpkt ) ; //<S2SV> while ( success ) { //<S2SV> if ( cpkt . cptype == MT_CPTYPE_BEGINAUTH ) { //<S2SV> int plen , i ; //<S2SV> if ( ! curconn -> have_pass_salt ) { //<S2SV> for ( i = 0 ; i < 16 ; ++ i ) { //<S2SV> curconn -> pass_salt [ i ] = rand ( ) % 256 ; //<S2SV> } //<S2SV> curconn -> have_pass_salt = 1 ; //<S2SV> memset ( curconn -> trypassword , 0 , sizeof ( curconn -> trypassword ) ) ; //<S2SV> } //<S2SV> init_packet ( & pdata , MT_PTYPE_DATA , pkthdr -> dstaddr , pkthdr -> srcaddr , pkthdr -> seskey , curconn -> outcounter ) ; //<S2SV> plen = add_control_packet ( & pdata , MT_CPTYPE_PASSSALT , ( curconn -> pass_salt ) , 16 ) ; //<S2SV> curconn -> outcounter += plen ; //<S2SV> send_udp ( curconn , & pdata ) ; //<S2SV> } else if ( cpkt . cptype == MT_CPTYPE_USERNAME && curconn -> state != STATE_ACTIVE ) { //<S2SV> memcpy ( curconn -> username , cpkt . data , act_size = ( cpkt . length > MT_MNDP_MAX_STRING_SIZE - 1 ? MT_MNDP_MAX_STRING_SIZE - 1 : cpkt . length ) ) ; //<S2SV> curconn -> username [ act_size ] = 0 ; //<S2SV> got_user_packet = 1 ; //<S2SV> } else if ( cpkt . cptype == MT_CPTYPE_TERM_WIDTH && cpkt . length >= 2 ) { //<S2SV> unsigned short width ; //<S2SV> memcpy ( & width , cpkt . data , 2 ) ; //<S2SV> curconn -> terminal_width = le16toh ( width ) ; //<S2SV> got_width_packet = 1 ; //<S2SV> } else if ( cpkt . cptype == MT_CPTYPE_TERM_HEIGHT && cpkt . length >= 2 ) { //<S2SV> unsigned short height ; //<S2SV> memcpy ( & height , cpkt . data , 2 ) ; //<S2SV> curconn -> terminal_height = le16toh ( height ) ; //<S2SV> got_height_packet = 1 ; //<S2SV> } else if ( cpkt . cptype == MT_CPTYPE_TERM_TYPE ) { //<S2SV> memcpy ( curconn -> terminal_type , cpkt . data , act_size = ( cpkt . length > 30 - 1 ? 30 - 1 : cpkt . length ) ) ; //<S2SV> curconn -> terminal_type [ act_size ] = 0 ; //<S2SV> } else if ( cpkt . cptype == MT_CPTYPE_PASSWORD ) { //<S2SV> # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) //<S2SV> mlock ( curconn -> trypassword , 17 ) ; //<S2SV> # endif //<S2SV> memcpy ( curconn -> trypassword , cpkt . data , 17 ) ; //<S2SV> got_pass_packet = 1 ; //<S2SV> } else if ( cpkt . cptype == MT_CPTYPE_PLAINDATA ) { //<S2SV> if ( curconn -> state == STATE_ACTIVE && curconn -> ptsfd != - 1 ) { //<S2SV> write ( curconn -> ptsfd , cpkt . data , cpkt . length ) ; //<S2SV> } //<S2SV> } else { //<S2SV> syslog ( LOG_WARNING , _ ( "(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d" ) , curconn -> seskey , cpkt . cptype ) ; //<S2SV> } //<S2SV> success = parse_control_packet ( NULL , 0 , & cpkt ) ; //<S2SV> } //<S2SV> if ( got_user_packet && got_pass_packet ) { //<S2SV> user_login ( curconn , pkthdr ) ; //<S2SV> } //<S2SV> if ( curconn -> state == STATE_ACTIVE && ( got_width_packet || got_height_packet ) ) { //<S2SV> set_terminal_size ( curconn -> ptsfd , curconn -> terminal_width , curconn -> terminal_height ) ; //<S2SV> } //<S2SV> } //<S2SV> 