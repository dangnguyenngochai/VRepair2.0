static void user_login ( struct mt_connection * curconn , struct mt_mactelnet_hdr * pkthdr ) { //<S2SV> struct mt_packet pdata ; //<S2SV> unsigned char md5sum [ 17 ] ; //<S2SV> char md5data [ 100 ] ; //<S2SV> struct mt_credentials * user ; //<S2SV> char * slavename ; //<S2SV> int act_pass_len ; //<S2SV> read_userfile ( ) ; //<S2SV> if ( ( user = find_user ( curconn -> username ) ) != NULL ) { //<S2SV> md5_state_t state ; //<S2SV> # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) //<S2SV> mlock ( md5data , sizeof ( md5data ) ) ; //<S2SV> mlock ( md5sum , sizeof ( md5sum ) ) ; //<S2SV> if ( user -> password != NULL ) { //<S2SV> mlock ( user -> password , strlen ( user -> password ) ) ; //<S2SV> } //<S2SV> # endif //<S2SV> act_pass_len = strlen ( user -> password ) ; //<S2SV> act_pass_len = act_pass_len <= 82 ? act_pass_len : 82 ; //<S2SV> md5data [ 0 ] = 0 ; //<S2SV> memcpy ( md5data + 1 , user -> password , act_pass_len ) ; //<S2SV> memcpy ( md5data + 1 + act_pass_len , curconn -> pass_salt , 16 ) ; //<S2SV> md5_init ( & state ) ; //<S2SV> md5_append ( & state , ( const md5_byte_t * ) md5data , 1 + act_pass_len + 16 ) ; //<S2SV> md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ; //<S2SV> md5sum [ 0 ] = 0 ; //<S2SV> init_packet ( & pdata , MT_PTYPE_DATA , pkthdr -> dstaddr , pkthdr -> srcaddr , pkthdr -> seskey , curconn -> outcounter ) ; //<S2SV> curconn -> outcounter += add_control_packet ( & pdata , MT_CPTYPE_END_AUTH , NULL , 0 ) ; //<S2SV> send_udp ( curconn , & pdata ) ; //<S2SV> if ( curconn -> state == STATE_ACTIVE ) { //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> if ( user == NULL || memcmp ( md5sum , curconn -> trypassword , 17 ) != 0 ) { //<S2SV> syslog ( LOG_NOTICE , _ ( "(%d)<S2SV_blank>Invalid<S2SV_blank>login<S2SV_blank>by<S2SV_blank>%s." ) , curconn -> seskey , curconn -> username ) ; //<S2SV> abort_connection ( curconn , pkthdr , _ ( "Login<S2SV_blank>failed,<S2SV_blank>incorrect<S2SV_blank>username<S2SV_blank>or<S2SV_blank>password\\r\\n" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> curconn -> state = STATE_ACTIVE ; //<S2SV> curconn -> terminal_mode = 1 ; //<S2SV> curconn -> ptsfd = posix_openpt ( O_RDWR ) ; //<S2SV> if ( curconn -> ptsfd == - 1 || grantpt ( curconn -> ptsfd ) == - 1 || unlockpt ( curconn -> ptsfd ) == - 1 ) { //<S2SV> syslog ( LOG_ERR , "posix_openpt:<S2SV_blank>%s" , strerror ( errno ) ) ; //<S2SV> abort_connection ( curconn , pkthdr , _ ( "Terminal<S2SV_blank>error\\r\\n" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> slavename = ptsname ( curconn -> ptsfd ) ; //<S2SV> if ( slavename != NULL ) { //<S2SV> pid_t pid ; //<S2SV> struct stat sb ; //<S2SV> struct passwd * user = ( struct passwd * ) malloc ( sizeof ( struct passwd ) ) ; //<S2SV> struct passwd * tmpuser = user ; //<S2SV> char * buffer = malloc ( 1024 ) ; //<S2SV> if ( user == NULL || buffer == NULL ) { //<S2SV> syslog ( LOG_CRIT , _ ( "(%d)<S2SV_blank>Error<S2SV_blank>allocating<S2SV_blank>memory." ) , curconn -> seskey ) ; //<S2SV> abort_connection ( curconn , pkthdr , _ ( "System<S2SV_blank>error,<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\r\\n" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( getpwnam_r ( curconn -> username , user , buffer , 1024 , & tmpuser ) != 0 ) { //<S2SV> syslog ( LOG_WARNING , _ ( "(%d)<S2SV_blank>Login<S2SV_blank>ok,<S2SV_blank>but<S2SV_blank>local<S2SV_blank>user<S2SV_blank>not<S2SV_blank>accessible<S2SV_blank>(%s)." ) , curconn -> seskey , curconn -> username ) ; //<S2SV> abort_connection ( curconn , pkthdr , _ ( "Local<S2SV_blank>user<S2SV_blank>not<S2SV_blank>accessible\\r\\n" ) ) ; //<S2SV> free ( user ) ; //<S2SV> free ( buffer ) ; //<S2SV> return ; //<S2SV> } //<S2SV> chown ( slavename , user -> pw_uid , user -> pw_gid ) ; //<S2SV> curconn -> slavefd = open ( slavename , O_RDWR ) ; //<S2SV> if ( curconn -> slavefd == - 1 ) { //<S2SV> syslog ( LOG_ERR , _ ( "Error<S2SV_blank>opening<S2SV_blank>%s:<S2SV_blank>%s" ) , slavename , strerror ( errno ) ) ; //<S2SV> abort_connection ( curconn , pkthdr , _ ( "Error<S2SV_blank>opening<S2SV_blank>terminal\\r\\n" ) ) ; //<S2SV> list_remove_connection ( curconn ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ( pid = fork ( ) ) == 0 ) { //<S2SV> struct net_interface * interface ; //<S2SV> uwtmp_login ( curconn ) ; //<S2SV> syslog ( LOG_INFO , _ ( "(%d)<S2SV_blank>User<S2SV_blank>%s<S2SV_blank>logged<S2SV_blank>in." ) , curconn -> seskey , curconn -> username ) ; //<S2SV> setenv ( "USER" , user -> pw_name , 1 ) ; //<S2SV> setenv ( "HOME" , user -> pw_dir , 1 ) ; //<S2SV> setenv ( "SHELL" , user -> pw_shell , 1 ) ; //<S2SV> setenv ( "TERM" , curconn -> terminal_type , 1 ) ; //<S2SV> close ( sockfd ) ; //<S2SV> close ( insockfd ) ; //<S2SV> DL_FOREACH ( interfaces , interface ) { //<S2SV> if ( interface -> socketfd > 0 ) { //<S2SV> close ( interface -> socketfd ) ; //<S2SV> } //<S2SV> } //<S2SV> setsid ( ) ; //<S2SV> fcntl ( curconn -> slavefd , F_SETFD , FD_CLOEXEC ) ; //<S2SV> close ( curconn -> ptsfd ) ; //<S2SV> close ( 0 ) ; //<S2SV> dup ( curconn -> slavefd ) ; //<S2SV> close ( 1 ) ; //<S2SV> dup ( curconn -> slavefd ) ; //<S2SV> close ( 2 ) ; //<S2SV> dup ( curconn -> slavefd ) ; //<S2SV> ioctl ( 0 , TIOCSCTTY , 1 ) ; //<S2SV> tcsetpgrp ( 0 , getpid ( ) ) ; //<S2SV> if ( ( setgid ( user -> pw_gid ) != 0 ) || ( setuid ( user -> pw_uid ) != 0 ) ) { //<S2SV> syslog ( LOG_ERR , _ ( "(%d)<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>log<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d:%d):<S2SV_blank>setuid/setgid:<S2SV_blank>%s" ) , curconn -> seskey , curconn -> username , user -> pw_uid , user -> pw_gid , strerror ( errno ) ) ; //<S2SV> abort_connection ( curconn , pkthdr , _ ( "Internal<S2SV_blank>error\\r\\n" ) ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> if ( stat ( _PATH_NOLOGIN , & sb ) == 0 && getuid ( ) != 0 ) { //<S2SV> syslog ( LOG_NOTICE , _ ( "(%d)<S2SV_blank>User<S2SV_blank>%s<S2SV_blank>disconnected<S2SV_blank>with<S2SV_blank>" _PATH_NOLOGIN "<S2SV_blank>message." ) , curconn -> seskey , curconn -> username ) ; //<S2SV> display_nologin ( ) ; //<S2SV> curconn -> state = STATE_CLOSED ; //<S2SV> init_packet ( & pdata , MT_PTYPE_END , pkthdr -> dstaddr , pkthdr -> srcaddr , pkthdr -> seskey , curconn -> outcounter ) ; //<S2SV> send_udp ( curconn , & pdata ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> display_motd ( ) ; //<S2SV> chdir ( user -> pw_dir ) ; //<S2SV> execl ( user -> pw_shell , user -> pw_shell , "-" , ( char * ) 0 ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> free ( user ) ; //<S2SV> free ( buffer ) ; //<S2SV> close ( curconn -> slavefd ) ; //<S2SV> curconn -> pid = pid ; //<S2SV> set_terminal_size ( curconn -> ptsfd , curconn -> terminal_width , curconn -> terminal_height ) ; //<S2SV> } //<S2SV> } //<S2SV> 