int add_control_packet ( struct mt_packet * packet , enum mt_cptype cptype , void * cpdata , unsigned short data_len ) { //<S2SV> unsigned char * data = packet -> data + packet -> size ; //<S2SV> unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; //<S2SV> if ( act_size > MT_PACKET_LEN - packet -> size ) { //<S2SV> fprintf ( stderr , _ ( "add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n" ) , MT_PACKET_LEN ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( cptype == MT_CPTYPE_PLAINDATA ) { //<S2SV> memcpy ( data , cpdata , data_len ) ; //<S2SV> packet -> size += data_len ; //<S2SV> return data_len ; //<S2SV> } //<S2SV> memcpy ( data , mt_mactelnet_cpmagic , sizeof ( mt_mactelnet_cpmagic ) ) ; //<S2SV> data [ 4 ] = cptype ; //<S2SV> # if BYTE_ORDER == LITTLE_ENDIAN //<S2SV> { //<S2SV> unsigned int templen ; //<S2SV> templen = htonl ( data_len ) ; //<S2SV> memcpy ( data + 5 , & templen , sizeof ( templen ) ) ; //<S2SV> } //<S2SV> # else //<S2SV> memcpy ( data + 5 , & data_len , sizeof ( data_len ) ) ; //<S2SV> # endif //<S2SV> if ( data_len > 0 ) { //<S2SV> memcpy ( data + MT_CPHEADER_LEN , cpdata , data_len ) ; //<S2SV> } //<S2SV> packet -> size += act_size ; //<S2SV> return act_size ; //<S2SV> } //<S2SV> 