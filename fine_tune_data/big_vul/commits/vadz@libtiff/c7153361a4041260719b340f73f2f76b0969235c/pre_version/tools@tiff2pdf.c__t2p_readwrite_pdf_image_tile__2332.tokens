tsize_t t2p_readwrite_pdf_image_tile ( T2P * t2p , TIFF * input , TIFF * output , ttile_t tile ) { //<S2SV> uint16 edge = 0 ; //<S2SV> tsize_t written = 0 ; //<S2SV> unsigned char * buffer = NULL ; //<S2SV> tsize_t bufferoffset = 0 ; //<S2SV> unsigned char * samplebuffer = NULL ; //<S2SV> tsize_t samplebufferoffset = 0 ; //<S2SV> tsize_t read = 0 ; //<S2SV> uint16 i = 0 ; //<S2SV> ttile_t tilecount = 0 ; //<S2SV> ttile_t septilecount = 0 ; //<S2SV> tsize_t septilesize = 0 ; //<S2SV> # ifdef JPEG_SUPPORT //<S2SV> unsigned char * jpt ; //<S2SV> float * xfloatp ; //<S2SV> uint32 xuint32 = 0 ; //<S2SV> # endif //<S2SV> if ( t2p -> t2p_error != T2P_ERR_OK ) //<S2SV> return ( 0 ) ; //<S2SV> edge |= t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; //<S2SV> edge |= t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; //<S2SV> if ( ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) && ( ( edge == 0 ) //<S2SV> # if defined ( JPEG_SUPPORT ) || defined ( OJPEG_SUPPORT ) //<S2SV> || ( t2p -> pdf_compression == T2P_COMPRESS_JPEG ) //<S2SV> # endif //<S2SV> ) //<S2SV> ) { //<S2SV> # ifdef CCITT_SUPPORT //<S2SV> if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { //<S2SV> buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; //<S2SV> if ( buffer == NULL ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>" //<S2SV> "for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s" , //<S2SV> ( unsigned long ) t2p -> tiff_datasize , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> TIFFReadRawTile ( input , tile , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; //<S2SV> if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { //<S2SV> TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; //<S2SV> } //<S2SV> t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> return ( t2p -> tiff_datasize ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef ZIP_SUPPORT //<S2SV> if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { //<S2SV> buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; //<S2SV> if ( buffer == NULL ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>" //<S2SV> "for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s" , //<S2SV> ( unsigned long ) t2p -> tiff_datasize , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> TIFFReadRawTile ( input , tile , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; //<S2SV> if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { //<S2SV> TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; //<S2SV> } //<S2SV> t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> return ( t2p -> tiff_datasize ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef OJPEG_SUPPORT //<S2SV> if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { //<S2SV> if ( ! t2p -> pdf_ojpegdata ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>" //<S2SV> "bad<S2SV_blank>tables" , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; //<S2SV> if ( buffer == NULL ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>" //<S2SV> "for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s" , //<S2SV> ( unsigned long ) t2p -> tiff_datasize , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; //<S2SV> if ( edge != 0 ) { //<S2SV> if ( t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ) { //<S2SV> buffer [ 7 ] = //<S2SV> ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength >> 8 ) & 0xff ; //<S2SV> buffer [ 8 ] = //<S2SV> ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) & 0xff ; //<S2SV> } //<S2SV> if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ) { //<S2SV> buffer [ 9 ] = //<S2SV> ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth >> 8 ) & 0xff ; //<S2SV> buffer [ 10 ] = //<S2SV> ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth ) & 0xff ; //<S2SV> } //<S2SV> } //<S2SV> bufferoffset = t2p -> pdf_ojpegdatalength ; //<S2SV> bufferoffset += TIFFReadRawTile ( input , //<S2SV> tile , //<S2SV> ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , //<S2SV> - 1 ) ; //<S2SV> ( ( unsigned char * ) buffer ) [ bufferoffset ++ ] = 0xff ; //<S2SV> ( ( unsigned char * ) buffer ) [ bufferoffset ++ ] = 0xd9 ; //<S2SV> t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> return ( bufferoffset ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef JPEG_SUPPORT //<S2SV> if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { //<S2SV> unsigned char table_end [ 2 ] ; //<S2SV> uint32 count = 0 ; //<S2SV> buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; //<S2SV> if ( buffer == NULL ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>" TIFF_SIZE_FORMAT "<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>" //<S2SV> "for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s" , //<S2SV> ( TIFF_SIZE_T ) t2p -> tiff_datasize , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { //<S2SV> if ( count >= 4 ) { //<S2SV> int retTIFFReadRawTile ; //<S2SV> _TIFFmemcpy ( buffer , jpt , count - 2 ) ; //<S2SV> bufferoffset += count - 2 ; //<S2SV> table_end [ 0 ] = buffer [ bufferoffset - 2 ] ; //<S2SV> table_end [ 1 ] = buffer [ bufferoffset - 1 ] ; //<S2SV> xuint32 = bufferoffset ; //<S2SV> bufferoffset -= 2 ; //<S2SV> retTIFFReadRawTile = TIFFReadRawTile ( //<S2SV> input , //<S2SV> tile , //<S2SV> ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , //<S2SV> - 1 ) ; //<S2SV> if ( retTIFFReadRawTile < 0 ) //<S2SV> { //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> bufferoffset += retTIFFReadRawTile ; //<S2SV> buffer [ xuint32 - 2 ] = table_end [ 0 ] ; //<S2SV> buffer [ xuint32 - 1 ] = table_end [ 1 ] ; //<S2SV> } //<S2SV> } //<S2SV> t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> return ( bufferoffset ) ; //<S2SV> } //<S2SV> # endif //<S2SV> ( void ) 0 ; //<S2SV> } //<S2SV> if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { //<S2SV> buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; //<S2SV> if ( buffer == NULL ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>" //<S2SV> "t2p_readwrite_pdf_image_tile,<S2SV_blank>%s" , //<S2SV> ( unsigned long ) t2p -> tiff_datasize , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> read = TIFFReadEncodedTile ( //<S2SV> input , //<S2SV> tile , //<S2SV> ( tdata_t ) & buffer [ bufferoffset ] , //<S2SV> t2p -> tiff_datasize ) ; //<S2SV> if ( read == - 1 ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s" , //<S2SV> tile , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( t2p -> pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { //<S2SV> septilesize = TIFFTileSize ( input ) ; //<S2SV> septilecount = TIFFNumberOfTiles ( input ) ; //<S2SV> tilecount = septilecount / t2p -> tiff_samplesperpixel ; //<S2SV> buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; //<S2SV> if ( buffer == NULL ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>" //<S2SV> "for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s" , //<S2SV> ( unsigned long ) t2p -> tiff_datasize , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> samplebuffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; //<S2SV> if ( samplebuffer == NULL ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>" //<S2SV> "for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s" , //<S2SV> ( unsigned long ) t2p -> tiff_datasize , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> samplebufferoffset = 0 ; //<S2SV> for ( i = 0 ; i < t2p -> tiff_samplesperpixel ; i ++ ) { //<S2SV> read = //<S2SV> TIFFReadEncodedTile ( input , //<S2SV> tile + i * tilecount , //<S2SV> ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , //<S2SV> septilesize ) ; //<S2SV> if ( read == - 1 ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s" , //<S2SV> tile + i * tilecount , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> _TIFFfree ( samplebuffer ) ; //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> samplebufferoffset += read ; //<S2SV> } //<S2SV> t2p_sample_planar_separate_to_contig ( //<S2SV> t2p , //<S2SV> & ( buffer [ bufferoffset ] ) , //<S2SV> samplebuffer , //<S2SV> samplebufferoffset ) ; //<S2SV> bufferoffset += samplebufferoffset ; //<S2SV> _TIFFfree ( samplebuffer ) ; //<S2SV> } //<S2SV> if ( buffer == NULL ) { //<S2SV> buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; //<S2SV> if ( buffer == NULL ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>" //<S2SV> "for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s" , //<S2SV> ( unsigned long ) t2p -> tiff_datasize , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> read = TIFFReadEncodedTile ( //<S2SV> input , //<S2SV> tile , //<S2SV> ( tdata_t ) & buffer [ bufferoffset ] , //<S2SV> t2p -> tiff_datasize ) ; //<S2SV> if ( read == - 1 ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s" , //<S2SV> tile , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { //<S2SV> t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( //<S2SV> ( tdata_t ) buffer , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth //<S2SV> * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; //<S2SV> } //<S2SV> if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { //<S2SV> t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( //<S2SV> ( tdata_t ) buffer , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth //<S2SV> * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; //<S2SV> } //<S2SV> if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>YCbCr<S2SV_blank>to<S2SV_blank>RGB<S2SV_blank>in<S2SV_blank>tile<S2SV_blank>for<S2SV_blank>%s" , //<S2SV> TIFFFileName ( input ) ) ; //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { //<S2SV> t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( //<S2SV> ( tdata_t ) buffer , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth //<S2SV> * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) != 0 ) { //<S2SV> t2p_tile_collapse_left ( //<S2SV> buffer , //<S2SV> TIFFTileRowSize ( input ) , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; //<S2SV> } //<S2SV> t2p_disable ( output ) ; //<S2SV> TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; //<S2SV> TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; //<S2SV> TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; //<S2SV> if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) == 0 ) { //<S2SV> TIFFSetField ( //<S2SV> output , //<S2SV> TIFFTAG_IMAGEWIDTH , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth ) ; //<S2SV> } else { //<S2SV> TIFFSetField ( //<S2SV> output , //<S2SV> TIFFTAG_IMAGEWIDTH , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth ) ; //<S2SV> } //<S2SV> if ( t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) == 0 ) { //<S2SV> TIFFSetField ( //<S2SV> output , //<S2SV> TIFFTAG_IMAGELENGTH , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; //<S2SV> TIFFSetField ( //<S2SV> output , //<S2SV> TIFFTAG_ROWSPERSTRIP , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; //<S2SV> } else { //<S2SV> TIFFSetField ( //<S2SV> output , //<S2SV> TIFFTAG_IMAGELENGTH , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) ; //<S2SV> TIFFSetField ( //<S2SV> output , //<S2SV> TIFFTAG_ROWSPERSTRIP , //<S2SV> t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) ; //<S2SV> } //<S2SV> TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; //<S2SV> TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; //<S2SV> switch ( t2p -> pdf_compression ) { //<S2SV> case T2P_COMPRESS_NONE : //<S2SV> TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; //<S2SV> break ; //<S2SV> # ifdef CCITT_SUPPORT //<S2SV> case T2P_COMPRESS_G4 : //<S2SV> TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef JPEG_SUPPORT //<S2SV> case T2P_COMPRESS_JPEG : //<S2SV> if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { //<S2SV> uint16 hor = 0 , ver = 0 ; //<S2SV> if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { //<S2SV> if ( hor != 0 && ver != 0 ) { //<S2SV> TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { //<S2SV> TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; //<S2SV> } //<S2SV> } //<S2SV> TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) ; //<S2SV> TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; //<S2SV> if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { //<S2SV> TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; //<S2SV> if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { //<S2SV> TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; //<S2SV> } else { //<S2SV> TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { //<S2SV> ( void ) 0 ; //<S2SV> } //<S2SV> if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { //<S2SV> ( void ) 0 ; //<S2SV> } //<S2SV> if ( t2p -> pdf_defaultcompressionquality != 0 ) { //<S2SV> TIFFSetField ( output , //<S2SV> TIFFTAG_JPEGQUALITY , //<S2SV> t2p -> pdf_defaultcompressionquality ) ; //<S2SV> } //<S2SV> break ; //<S2SV> # endif //<S2SV> # ifdef ZIP_SUPPORT //<S2SV> case T2P_COMPRESS_ZIP : //<S2SV> TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; //<S2SV> if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { //<S2SV> TIFFSetField ( output , //<S2SV> TIFFTAG_PREDICTOR , //<S2SV> t2p -> pdf_defaultcompressionquality % 100 ) ; //<S2SV> } //<S2SV> if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { //<S2SV> TIFFSetField ( output , //<S2SV> TIFFTAG_ZIPQUALITY , //<S2SV> ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; //<S2SV> } //<S2SV> break ; //<S2SV> # endif //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> t2p_enable ( output ) ; //<S2SV> t2p -> outputwritten = 0 ; //<S2SV> bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , //<S2SV> TIFFStripSize ( output ) ) ; //<S2SV> if ( buffer != NULL ) { //<S2SV> _TIFFfree ( buffer ) ; //<S2SV> buffer = NULL ; //<S2SV> } //<S2SV> if ( bufferoffset == - 1 ) { //<S2SV> TIFFError ( TIFF2PDF_MODULE , //<S2SV> "Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>tile<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s" , //<S2SV> TIFFFileName ( output ) ) ; //<S2SV> t2p -> t2p_error = T2P_ERR_ERROR ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> written = t2p -> outputwritten ; //<S2SV> return ( written ) ; //<S2SV> } //<S2SV> 