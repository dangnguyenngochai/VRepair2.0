static int //<S2SV> PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) //<S2SV> { //<S2SV> static const char module [ ] = "PredictorEncodeTile" ; //<S2SV> TIFFPredictorState * sp = PredictorState ( tif ) ; //<S2SV> uint8 * working_copy ; //<S2SV> tmsize_t cc = cc0 , rowsize ; //<S2SV> unsigned char * bp ; //<S2SV> int result_code ; //<S2SV> assert ( sp != NULL ) ; //<S2SV> assert ( sp -> encodepfunc != NULL ) ; //<S2SV> assert ( sp -> encodetile != NULL ) ; //<S2SV> working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; //<S2SV> if ( working_copy == NULL ) //<S2SV> { //<S2SV> TIFFErrorExt ( tif -> tif_clientdata , module , //<S2SV> "Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>allocating<S2SV_blank>" TIFF_SSIZE_FORMAT "<S2SV_blank>byte<S2SV_blank>temp<S2SV_blank>buffer." , //<S2SV> cc0 ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> memcpy ( working_copy , bp0 , cc0 ) ; //<S2SV> bp = working_copy ; //<S2SV> rowsize = sp -> rowsize ; //<S2SV> assert ( rowsize > 0 ) ; //<S2SV> assert ( ( cc0 % rowsize ) == 0 ) ; //<S2SV> while ( cc > 0 ) { //<S2SV> ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; //<S2SV> cc -= rowsize ; //<S2SV> bp += rowsize ; //<S2SV> } //<S2SV> result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; //<S2SV> _TIFFfree ( working_copy ) ; //<S2SV> return result_code ; //<S2SV> } //<S2SV> 