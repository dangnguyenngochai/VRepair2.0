static int //<S2SV> fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) //<S2SV> { //<S2SV> tmsize_t stride = PredictorState ( tif ) -> stride ; //<S2SV> uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; //<S2SV> tmsize_t wc = cc / bps ; //<S2SV> tmsize_t count = cc ; //<S2SV> uint8 * cp = ( uint8 * ) cp0 ; //<S2SV> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; //<S2SV> if ( cc % ( bps * stride ) != 0 ) //<S2SV> { //<S2SV> TIFFErrorExt ( tif -> tif_clientdata , "fpAcc" , //<S2SV> "%s" , "cc%(bps*stride))!=0" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! tmp ) //<S2SV> return 0 ; //<S2SV> while ( count > stride ) { //<S2SV> REPEAT4 ( stride , cp [ stride ] = //<S2SV> ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) //<S2SV> count -= stride ; //<S2SV> } //<S2SV> _TIFFmemcpy ( tmp , cp0 , cc ) ; //<S2SV> cp = ( uint8 * ) cp0 ; //<S2SV> for ( count = 0 ; count < wc ; count ++ ) { //<S2SV> uint32 byte ; //<S2SV> for ( byte = 0 ; byte < bps ; byte ++ ) { //<S2SV> # if WORDS_BIGENDIAN //<S2SV> cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; //<S2SV> # else //<S2SV> cp [ bps * count + byte ] = //<S2SV> tmp [ ( bps - byte - 1 ) * wc + count ] ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> _TIFFfree ( tmp ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> 