static int readSeparateStripsIntoBuffer ( TIFF * in , uint8 * obuf , uint32 length , //<S2SV> uint32 width , uint16 spp , //<S2SV> struct dump_opts * dump ) //<S2SV> { //<S2SV> int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; //<S2SV> uint32 j ; //<S2SV> int32 bytes_read = 0 ; //<S2SV> uint16 bps , planar ; //<S2SV> uint32 nstrips ; //<S2SV> uint32 strips_per_sample ; //<S2SV> uint32 src_rowsize , dst_rowsize , rows_processed , rps ; //<S2SV> uint32 rows_this_strip = 0 ; //<S2SV> tsample_t s ; //<S2SV> tstrip_t strip ; //<S2SV> tsize_t scanlinesize = TIFFScanlineSize ( in ) ; //<S2SV> tsize_t stripsize = TIFFStripSize ( in ) ; //<S2SV> unsigned char * srcbuffs [ MAX_SAMPLES ] ; //<S2SV> unsigned char * buff = NULL ; //<S2SV> unsigned char * dst = NULL ; //<S2SV> if ( obuf == NULL ) //<S2SV> { //<S2SV> TIFFError ( "readSeparateStripsIntoBuffer" , "Invalid<S2SV_blank>buffer<S2SV_blank>argument" ) ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> memset ( srcbuffs , '\\0' , sizeof ( srcbuffs ) ) ; //<S2SV> TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; //<S2SV> if ( rps > length ) //<S2SV> rps = length ; //<S2SV> bytes_per_sample = ( bps + 7 ) / 8 ; //<S2SV> bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; //<S2SV> if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) //<S2SV> shift_width = bytes_per_pixel ; //<S2SV> else //<S2SV> shift_width = bytes_per_sample + 1 ; //<S2SV> src_rowsize = ( ( bps * width ) + 7 ) / 8 ; //<S2SV> dst_rowsize = ( ( bps * width * spp ) + 7 ) / 8 ; //<S2SV> dst = obuf ; //<S2SV> if ( ( dump -> infile != NULL ) && ( dump -> level == 3 ) ) //<S2SV> { //<S2SV> dump_info ( dump -> infile , dump -> format , "" , //<S2SV> "Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Scanline<S2SV_blank>size,<S2SV_blank>%4d<S2SV_blank>bytes" , //<S2SV> width , length , scanlinesize ) ; //<S2SV> dump_info ( dump -> infile , dump -> format , "" , //<S2SV> "Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d,<S2SV_blank>Shift<S2SV_blank>width<S2SV_blank>%d" , //<S2SV> bps , spp , shift_width ) ; //<S2SV> } //<S2SV> nstrips = TIFFNumberOfStrips ( in ) ; //<S2SV> strips_per_sample = nstrips / spp ; //<S2SV> for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) //<S2SV> { //<S2SV> srcbuffs [ s ] = NULL ; //<S2SV> buff = _TIFFmalloc ( stripsize ) ; //<S2SV> if ( ! buff ) //<S2SV> { //<S2SV> TIFFError ( "readSeparateStripsIntoBuffer" , //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>strip<S2SV_blank>read<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d" , s ) ; //<S2SV> for ( i = 0 ; i < s ; i ++ ) //<S2SV> _TIFFfree ( srcbuffs [ i ] ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> srcbuffs [ s ] = buff ; //<S2SV> } //<S2SV> rows_processed = 0 ; //<S2SV> for ( j = 0 ; ( j < strips_per_sample ) && ( result == 1 ) ; j ++ ) //<S2SV> { //<S2SV> for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) //<S2SV> { //<S2SV> buff = srcbuffs [ s ] ; //<S2SV> strip = ( s * strips_per_sample ) + j ; //<S2SV> bytes_read = TIFFReadEncodedStrip ( in , strip , buff , stripsize ) ; //<S2SV> rows_this_strip = bytes_read / src_rowsize ; //<S2SV> if ( bytes_read < 0 && ! ignore ) //<S2SV> { //<S2SV> TIFFError ( TIFFFileName ( in ) , //<S2SV> "Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d" , //<S2SV> ( unsigned long ) strip , s + 1 ) ; //<S2SV> result = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> # ifdef DEVELMODE //<S2SV> TIFFError ( "" , "Strip<S2SV_blank>%2d,<S2SV_blank>read<S2SV_blank>%5d<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>%4d<S2SV_blank>scanlines,<S2SV_blank>shift<S2SV_blank>width<S2SV_blank>%d" , //<S2SV> strip , bytes_read , rows_this_strip , shift_width ) ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( rps > rows_this_strip ) //<S2SV> rps = rows_this_strip ; //<S2SV> dst = obuf + ( dst_rowsize * rows_processed ) ; //<S2SV> if ( ( bps % 8 ) == 0 ) //<S2SV> { //<S2SV> if ( combineSeparateSamplesBytes ( srcbuffs , dst , width , rps , //<S2SV> spp , bps , dump -> infile , //<S2SV> dump -> format , dump -> level ) ) //<S2SV> { //<S2SV> result = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> switch ( shift_width ) //<S2SV> { //<S2SV> case 1 : if ( combineSeparateSamples8bits ( srcbuffs , dst , width , rps , //<S2SV> spp , bps , dump -> infile , //<S2SV> dump -> format , dump -> level ) ) //<S2SV> { //<S2SV> result = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 2 : if ( combineSeparateSamples16bits ( srcbuffs , dst , width , rps , //<S2SV> spp , bps , dump -> infile , //<S2SV> dump -> format , dump -> level ) ) //<S2SV> { //<S2SV> result = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 3 : if ( combineSeparateSamples24bits ( srcbuffs , dst , width , rps , //<S2SV> spp , bps , dump -> infile , //<S2SV> dump -> format , dump -> level ) ) //<S2SV> { //<S2SV> result = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case 4 : //<S2SV> case 5 : //<S2SV> case 6 : //<S2SV> case 7 : //<S2SV> case 8 : if ( combineSeparateSamples32bits ( srcbuffs , dst , width , rps , //<S2SV> spp , bps , dump -> infile , //<S2SV> dump -> format , dump -> level ) ) //<S2SV> { //<S2SV> result = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> default : TIFFError ( "readSeparateStripsIntoBuffer" , "Unsupported<S2SV_blank>bit<S2SV_blank>depth:<S2SV_blank>%d" , bps ) ; //<S2SV> result = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( rows_processed + rps ) > length ) //<S2SV> { //<S2SV> rows_processed = length ; //<S2SV> rps = length - rows_processed ; //<S2SV> } //<S2SV> else //<S2SV> rows_processed += rps ; //<S2SV> } //<S2SV> for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) //<S2SV> { //<S2SV> buff = srcbuffs [ s ] ; //<S2SV> if ( buff != NULL ) //<S2SV> _TIFFfree ( buff ) ; //<S2SV> } //<S2SV> return ( result ) ; //<S2SV> } //<S2SV> 