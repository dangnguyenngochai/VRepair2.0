static int //<S2SV> loadImage ( TIFF * in , struct image_data * image , struct dump_opts * dump , unsigned char * * read_ptr ) //<S2SV> { //<S2SV> uint32 i ; //<S2SV> float xres = 0.0 , yres = 0.0 ; //<S2SV> uint16 nstrips = 0 , ntiles = 0 , planar = 0 ; //<S2SV> uint16 bps = 0 , spp = 0 , res_unit = 0 ; //<S2SV> uint16 orientation = 0 ; //<S2SV> uint16 input_compression = 0 , input_photometric = 0 ; //<S2SV> uint16 subsampling_horiz , subsampling_vert ; //<S2SV> uint32 width = 0 , length = 0 ; //<S2SV> uint32 stsize = 0 , tlsize = 0 , buffsize = 0 , scanlinesize = 0 ; //<S2SV> uint32 tw = 0 , tl = 0 ; //<S2SV> uint32 tile_rowsize = 0 ; //<S2SV> unsigned char * read_buff = NULL ; //<S2SV> unsigned char * new_buff = NULL ; //<S2SV> int readunit = 0 ; //<S2SV> static uint32 prev_readsize = 0 ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_SAMPLESPERPIXEL , & spp ) ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; //<S2SV> if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ) //<S2SV> TIFFError ( "loadImage" , "Image<S2SV_blank>lacks<S2SV_blank>Photometric<S2SV_blank>interpreation<S2SV_blank>tag" ) ; //<S2SV> if ( ! TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & width ) ) //<S2SV> TIFFError ( "loadimage" , "Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>width<S2SV_blank>tag" ) ; //<S2SV> if ( ! TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & length ) ) //<S2SV> TIFFError ( "loadimage" , "Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>length<S2SV_blank>tag" ) ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_XRESOLUTION , & xres ) ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_YRESOLUTION , & yres ) ; //<S2SV> if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_RESOLUTIONUNIT , & res_unit ) ) //<S2SV> res_unit = RESUNIT_INCH ; //<S2SV> if ( ! TIFFGetField ( in , TIFFTAG_COMPRESSION , & input_compression ) ) //<S2SV> input_compression = COMPRESSION_NONE ; //<S2SV> # ifdef DEBUG2 //<S2SV> char compressionid [ 16 ] ; //<S2SV> switch ( input_compression ) //<S2SV> { //<S2SV> case COMPRESSION_NONE : //<S2SV> strcpy ( compressionid , "None/dump" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_CCITTRLE : //<S2SV> strcpy ( compressionid , "Huffman<S2SV_blank>RLE" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_CCITTFAX3 : //<S2SV> strcpy ( compressionid , "Group3<S2SV_blank>Fax" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_CCITTFAX4 : //<S2SV> strcpy ( compressionid , "Group4<S2SV_blank>Fax" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_LZW : //<S2SV> strcpy ( compressionid , "LZW" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_OJPEG : //<S2SV> strcpy ( compressionid , "Old<S2SV_blank>Jpeg" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_JPEG : //<S2SV> strcpy ( compressionid , "New<S2SV_blank>Jpeg" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_NEXT : //<S2SV> strcpy ( compressionid , "Next<S2SV_blank>RLE" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_CCITTRLEW : //<S2SV> strcpy ( compressionid , "CITTRLEW" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_PACKBITS : //<S2SV> strcpy ( compressionid , "Mac<S2SV_blank>Packbits" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_THUNDERSCAN : //<S2SV> strcpy ( compressionid , "Thunderscan" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_IT8CTPAD : //<S2SV> strcpy ( compressionid , "IT8<S2SV_blank>padded" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_IT8LW : //<S2SV> strcpy ( compressionid , "IT8<S2SV_blank>RLE" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_IT8MP : //<S2SV> strcpy ( compressionid , "IT8<S2SV_blank>mono" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_IT8BL : //<S2SV> strcpy ( compressionid , "IT8<S2SV_blank>lineart" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_PIXARFILM : //<S2SV> strcpy ( compressionid , "Pixar<S2SV_blank>10<S2SV_blank>bit" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_PIXARLOG : //<S2SV> strcpy ( compressionid , "Pixar<S2SV_blank>11bit" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_DEFLATE : //<S2SV> strcpy ( compressionid , "Deflate" ) ; //<S2SV> break ; //<S2SV> case COMPRESSION_ADOBE_DEFLATE : //<S2SV> strcpy ( compressionid , "Adobe<S2SV_blank>deflate" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> strcpy ( compressionid , "None/unknown" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> TIFFError ( "loadImage" , "Input<S2SV_blank>compression<S2SV_blank>%s" , compressionid ) ; //<S2SV> # endif //<S2SV> scanlinesize = TIFFScanlineSize ( in ) ; //<S2SV> image -> bps = bps ; //<S2SV> image -> spp = spp ; //<S2SV> image -> planar = planar ; //<S2SV> image -> width = width ; //<S2SV> image -> length = length ; //<S2SV> image -> xres = xres ; //<S2SV> image -> yres = yres ; //<S2SV> image -> res_unit = res_unit ; //<S2SV> image -> compression = input_compression ; //<S2SV> image -> photometric = input_photometric ; //<S2SV> # ifdef DEBUG2 //<S2SV> char photometricid [ 12 ] ; //<S2SV> switch ( input_photometric ) //<S2SV> { //<S2SV> case PHOTOMETRIC_MINISWHITE : //<S2SV> strcpy ( photometricid , "MinIsWhite" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_MINISBLACK : //<S2SV> strcpy ( photometricid , "MinIsBlack" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_RGB : //<S2SV> strcpy ( photometricid , "RGB" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_PALETTE : //<S2SV> strcpy ( photometricid , "Palette" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_MASK : //<S2SV> strcpy ( photometricid , "Mask" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_SEPARATED : //<S2SV> strcpy ( photometricid , "Separated" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_YCBCR : //<S2SV> strcpy ( photometricid , "YCBCR" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_CIELAB : //<S2SV> strcpy ( photometricid , "CIELab" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_ICCLAB : //<S2SV> strcpy ( photometricid , "ICCLab" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_ITULAB : //<S2SV> strcpy ( photometricid , "ITULab" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_LOGL : //<S2SV> strcpy ( photometricid , "LogL" ) ; //<S2SV> break ; //<S2SV> case PHOTOMETRIC_LOGLUV : //<S2SV> strcpy ( photometricid , "LOGLuv" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> strcpy ( photometricid , "Unknown" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> TIFFError ( "loadImage" , "Input<S2SV_blank>photometric<S2SV_blank>interpretation<S2SV_blank>%s" , photometricid ) ; //<S2SV> # endif //<S2SV> image -> orientation = orientation ; //<S2SV> switch ( orientation ) //<S2SV> { //<S2SV> case 0 : //<S2SV> case ORIENTATION_TOPLEFT : //<S2SV> image -> adjustments = 0 ; //<S2SV> break ; //<S2SV> case ORIENTATION_TOPRIGHT : //<S2SV> image -> adjustments = MIRROR_HORIZ ; //<S2SV> break ; //<S2SV> case ORIENTATION_BOTRIGHT : //<S2SV> image -> adjustments = ROTATECW_180 ; //<S2SV> break ; //<S2SV> case ORIENTATION_BOTLEFT : //<S2SV> image -> adjustments = MIRROR_VERT ; //<S2SV> break ; //<S2SV> case ORIENTATION_LEFTTOP : //<S2SV> image -> adjustments = MIRROR_VERT | ROTATECW_90 ; //<S2SV> break ; //<S2SV> case ORIENTATION_RIGHTTOP : //<S2SV> image -> adjustments = ROTATECW_90 ; //<S2SV> break ; //<S2SV> case ORIENTATION_RIGHTBOT : //<S2SV> image -> adjustments = MIRROR_VERT | ROTATECW_270 ; //<S2SV> break ; //<S2SV> case ORIENTATION_LEFTBOT : //<S2SV> image -> adjustments = ROTATECW_270 ; //<S2SV> break ; //<S2SV> default : //<S2SV> image -> adjustments = 0 ; //<S2SV> image -> orientation = ORIENTATION_TOPLEFT ; //<S2SV> } //<S2SV> if ( ( bps == 0 ) || ( spp == 0 ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Invalid<S2SV_blank>samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>(%d)<S2SV_blank>or<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>(%d)" , //<S2SV> spp , bps ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> if ( TIFFIsTiled ( in ) ) //<S2SV> { //<S2SV> readunit = TILE ; //<S2SV> tlsize = TIFFTileSize ( in ) ; //<S2SV> ntiles = TIFFNumberOfTiles ( in ) ; //<S2SV> TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; //<S2SV> TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; //<S2SV> tile_rowsize = TIFFTileRowSize ( in ) ; //<S2SV> if ( ntiles == 0 || tlsize == 0 || tile_rowsize == 0 ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>tiled,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>tiles,<S2SV_blank>tile<S2SV_blank>size,<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero." ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> buffsize = tlsize * ntiles ; //<S2SV> if ( tlsize != ( buffsize / ntiles ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size" ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> if ( buffsize < ( uint32 ) ( ntiles * tl * tile_rowsize ) ) //<S2SV> { //<S2SV> buffsize = ntiles * tl * tile_rowsize ; //<S2SV> if ( ntiles != ( buffsize / tl / tile_rowsize ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size" ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> # ifdef DEBUG2 //<S2SV> TIFFError ( "loadImage" , //<S2SV> "Tilesize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>ntiles<S2SV_blank>*<S2SV_blank>tilelength<S2SV_blank>*<S2SV_blank>tilerowsize<S2SV_blank>%lu" , //<S2SV> tlsize , ( unsigned long ) buffsize ) ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( dump -> infile != NULL ) //<S2SV> dump_info ( dump -> infile , dump -> format , "" , //<S2SV> "Tilesize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Tiles:<S2SV_blank>%u,<S2SV_blank>Tile<S2SV_blank>row<S2SV_blank>size:<S2SV_blank>%u" , //<S2SV> tlsize , ntiles , tile_rowsize ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> uint32 buffsize_check ; //<S2SV> readunit = STRIP ; //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; //<S2SV> stsize = TIFFStripSize ( in ) ; //<S2SV> nstrips = TIFFNumberOfStrips ( in ) ; //<S2SV> if ( nstrips == 0 || stsize == 0 ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>striped,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>stipes<S2SV_blank>or<S2SV_blank>stripe<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero." ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> buffsize = stsize * nstrips ; //<S2SV> if ( stsize != ( buffsize / nstrips ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size" ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> buffsize_check = ( ( length * width * spp * bps ) + 7 ) ; //<S2SV> if ( length != ( ( buffsize_check - 7 ) / width / spp / bps ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Integer<S2SV_blank>overflow<S2SV_blank>detected." ) ; //<S2SV> exit ( - 1 ) ; //<S2SV> } //<S2SV> if ( buffsize < ( uint32 ) ( ( ( length * width * spp * bps ) + 7 ) / 8 ) ) //<S2SV> { //<S2SV> buffsize = ( ( length * width * spp * bps ) + 7 ) / 8 ; //<S2SV> # ifdef DEBUG2 //<S2SV> TIFFError ( "loadImage" , //<S2SV> "Stripsize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>imagelength<S2SV_blank>*<S2SV_blank>width<S2SV_blank>*<S2SV_blank>spp<S2SV_blank>*<S2SV_blank>bps<S2SV_blank>/<S2SV_blank>8<S2SV_blank>=<S2SV_blank>%lu" , //<S2SV> stsize , ( unsigned long ) buffsize ) ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( dump -> infile != NULL ) //<S2SV> dump_info ( dump -> infile , dump -> format , "" , //<S2SV> "Stripsize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Strips:<S2SV_blank>%u,<S2SV_blank>Rows<S2SV_blank>per<S2SV_blank>Strip:<S2SV_blank>%u,<S2SV_blank>Scanline<S2SV_blank>size:<S2SV_blank>%u" , //<S2SV> stsize , nstrips , rowsperstrip , scanlinesize ) ; //<S2SV> } //<S2SV> if ( input_compression == COMPRESSION_JPEG ) //<S2SV> { //<S2SV> jpegcolormode = JPEGCOLORMODE_RGB ; //<S2SV> TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( input_photometric == PHOTOMETRIC_YCBCR ) //<S2SV> { //<S2SV> TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , //<S2SV> & subsampling_horiz , & subsampling_vert ) ; //<S2SV> if ( subsampling_horiz != 1 || subsampling_vert != 1 ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , //<S2SV> "Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image<S2SV_blank>with<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>horiz<S2SV_blank>%d<S2SV_blank>vert" , //<S2SV> subsampling_horiz , subsampling_vert ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> read_buff = * read_ptr ; //<S2SV> if ( ! read_buff ) //<S2SV> read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; //<S2SV> else //<S2SV> { //<S2SV> if ( prev_readsize < buffsize ) //<S2SV> { //<S2SV> new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ; //<S2SV> if ( ! new_buff ) //<S2SV> { //<S2SV> free ( read_buff ) ; //<S2SV> read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; //<S2SV> } //<S2SV> else //<S2SV> read_buff = new_buff ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! read_buff ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer" ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> read_buff [ buffsize ] = 0 ; //<S2SV> read_buff [ buffsize + 1 ] = 0 ; //<S2SV> read_buff [ buffsize + 2 ] = 0 ; //<S2SV> prev_readsize = buffsize ; //<S2SV> * read_ptr = read_buff ; //<S2SV> switch ( readunit ) { //<S2SV> case STRIP : //<S2SV> if ( planar == PLANARCONFIG_CONTIG ) //<S2SV> { //<S2SV> if ( ! ( readContigStripsIntoBuffer ( in , read_buff ) ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer" ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ! ( readSeparateStripsIntoBuffer ( in , read_buff , length , width , spp , dump ) ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer" ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TILE : //<S2SV> if ( planar == PLANARCONFIG_CONTIG ) //<S2SV> { //<S2SV> if ( ! ( readContigTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer" ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ! ( readSeparateTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) //<S2SV> { //<S2SV> TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer" ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> default : TIFFError ( "loadImage" , "Unsupported<S2SV_blank>image<S2SV_blank>file<S2SV_blank>format" ) ; //<S2SV> return ( - 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( dump -> infile != NULL ) && ( dump -> level == 2 ) ) //<S2SV> { //<S2SV> dump_info ( dump -> infile , dump -> format , "loadImage" , //<S2SV> "Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Raw<S2SV_blank>image<S2SV_blank>data,<S2SV_blank>%4d<S2SV_blank>bytes" , //<S2SV> width , length , buffsize ) ; //<S2SV> dump_info ( dump -> infile , dump -> format , "" , //<S2SV> "Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d" , bps , spp ) ; //<S2SV> for ( i = 0 ; i < length ; i ++ ) //<S2SV> dump_buffer ( dump -> infile , dump -> format , 1 , scanlinesize , //<S2SV> i , read_buff + ( i * scanlinesize ) ) ; //<S2SV> } //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> 