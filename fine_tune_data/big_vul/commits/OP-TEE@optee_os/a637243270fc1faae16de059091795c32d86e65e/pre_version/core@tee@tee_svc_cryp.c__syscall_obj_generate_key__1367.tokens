TEE_Result syscall_obj_generate_key ( unsigned long obj , unsigned long key_size , //<S2SV> const struct utee_attribute * usr_params , //<S2SV> unsigned long param_count ) //<S2SV> { //<S2SV> TEE_Result res ; //<S2SV> struct tee_ta_session * sess ; //<S2SV> const struct tee_cryp_obj_type_props * type_props ; //<S2SV> struct tee_obj * o ; //<S2SV> struct tee_cryp_obj_secret * key ; //<S2SV> size_t byte_size ; //<S2SV> TEE_Attribute * params = NULL ; //<S2SV> res = tee_ta_get_current_session ( & sess ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , //<S2SV> tee_svc_uref_to_vaddr ( obj ) , & o ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) //<S2SV> return TEE_ERROR_BAD_STATE ; //<S2SV> if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) //<S2SV> return TEE_ERROR_BAD_STATE ; //<S2SV> type_props = tee_svc_find_type_props ( o -> info . objectType ) ; //<S2SV> if ( ! type_props ) //<S2SV> return TEE_ERROR_NOT_SUPPORTED ; //<S2SV> if ( key_size % type_props -> quanta != 0 ) //<S2SV> return TEE_ERROR_NOT_SUPPORTED ; //<S2SV> if ( key_size < type_props -> min_size ) //<S2SV> return TEE_ERROR_NOT_SUPPORTED ; //<S2SV> if ( key_size > type_props -> max_size ) //<S2SV> return TEE_ERROR_NOT_SUPPORTED ; //<S2SV> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; //<S2SV> if ( ! params ) //<S2SV> return TEE_ERROR_OUT_OF_MEMORY ; //<S2SV> res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count , //<S2SV> params ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> res = tee_svc_cryp_check_attr ( ATTR_USAGE_GENERATE_KEY , type_props , //<S2SV> params , param_count ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> switch ( o -> info . objectType ) { //<S2SV> case TEE_TYPE_AES : //<S2SV> case TEE_TYPE_DES : //<S2SV> case TEE_TYPE_DES3 : //<S2SV> case TEE_TYPE_HMAC_MD5 : //<S2SV> case TEE_TYPE_HMAC_SHA1 : //<S2SV> case TEE_TYPE_HMAC_SHA224 : //<S2SV> case TEE_TYPE_HMAC_SHA256 : //<S2SV> case TEE_TYPE_HMAC_SHA384 : //<S2SV> case TEE_TYPE_HMAC_SHA512 : //<S2SV> case TEE_TYPE_GENERIC_SECRET : //<S2SV> byte_size = key_size / 8 ; //<S2SV> if ( o -> info . objectType == TEE_TYPE_DES || //<S2SV> o -> info . objectType == TEE_TYPE_DES3 ) { //<S2SV> byte_size = ( key_size + key_size / 7 ) / 8 ; //<S2SV> } //<S2SV> key = ( struct tee_cryp_obj_secret * ) o -> attr ; //<S2SV> if ( byte_size > key -> alloc_size ) { //<S2SV> res = TEE_ERROR_EXCESS_DATA ; //<S2SV> goto out ; //<S2SV> } //<S2SV> res = crypto_rng_read ( ( void * ) ( key + 1 ) , byte_size ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> key -> key_size = byte_size ; //<S2SV> o -> have_attrs = ( 1 << type_props -> num_type_attrs ) - 1 ; //<S2SV> break ; //<S2SV> case TEE_TYPE_RSA_KEYPAIR : //<S2SV> res = tee_svc_obj_generate_key_rsa ( o , type_props , key_size , //<S2SV> params , param_count ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> case TEE_TYPE_DSA_KEYPAIR : //<S2SV> res = tee_svc_obj_generate_key_dsa ( o , type_props , key_size ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> case TEE_TYPE_DH_KEYPAIR : //<S2SV> res = tee_svc_obj_generate_key_dh ( o , type_props , key_size , //<S2SV> params , param_count ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> case TEE_TYPE_ECDSA_KEYPAIR : //<S2SV> case TEE_TYPE_ECDH_KEYPAIR : //<S2SV> res = tee_svc_obj_generate_key_ecc ( o , type_props , key_size , //<S2SV> params , param_count ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> break ; //<S2SV> default : //<S2SV> res = TEE_ERROR_BAD_FORMAT ; //<S2SV> } //<S2SV> out : //<S2SV> free ( params ) ; //<S2SV> if ( res == TEE_SUCCESS ) { //<S2SV> o -> info . keySize = key_size ; //<S2SV> o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; //<S2SV> } //<S2SV> return res ; //<S2SV> } //<S2SV> 