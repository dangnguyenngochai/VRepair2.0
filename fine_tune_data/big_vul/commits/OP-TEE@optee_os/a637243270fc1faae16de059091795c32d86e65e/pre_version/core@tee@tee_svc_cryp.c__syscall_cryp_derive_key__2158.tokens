TEE_Result syscall_cryp_derive_key ( unsigned long state , //<S2SV> const struct utee_attribute * usr_params , //<S2SV> unsigned long param_count , unsigned long derived_key ) //<S2SV> { //<S2SV> TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; //<S2SV> struct tee_ta_session * sess ; //<S2SV> struct tee_obj * ko ; //<S2SV> struct tee_obj * so ; //<S2SV> struct tee_cryp_state * cs ; //<S2SV> struct tee_cryp_obj_secret * sk ; //<S2SV> const struct tee_cryp_obj_type_props * type_props ; //<S2SV> TEE_Attribute * params = NULL ; //<S2SV> struct user_ta_ctx * utc ; //<S2SV> res = tee_ta_get_current_session ( & sess ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> utc = to_user_ta_ctx ( sess -> ctx ) ; //<S2SV> res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; //<S2SV> if ( ! params ) //<S2SV> return TEE_ERROR_OUT_OF_MEMORY ; //<S2SV> res = copy_in_attrs ( utc , usr_params , param_count , params ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> res = tee_obj_get ( utc , cs -> key1 , & ko ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> sk = so -> attr ; //<S2SV> type_props = tee_svc_find_type_props ( so -> info . objectType ) ; //<S2SV> if ( ! type_props ) { //<S2SV> res = TEE_ERROR_NOT_SUPPORTED ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { //<S2SV> size_t alloc_size ; //<S2SV> struct bignum * pub ; //<S2SV> struct bignum * ss ; //<S2SV> if ( param_count != 1 || //<S2SV> params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> goto out ; //<S2SV> } //<S2SV> alloc_size = params [ 0 ] . content . ref . length * 8 ; //<S2SV> pub = crypto_bignum_allocate ( alloc_size ) ; //<S2SV> ss = crypto_bignum_allocate ( alloc_size ) ; //<S2SV> if ( pub && ss ) { //<S2SV> crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , //<S2SV> params [ 0 ] . content . ref . length , pub ) ; //<S2SV> res = crypto_acipher_dh_shared_secret ( ko -> attr , //<S2SV> pub , ss ) ; //<S2SV> if ( res == TEE_SUCCESS ) { //<S2SV> sk -> key_size = crypto_bignum_num_bytes ( ss ) ; //<S2SV> crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; //<S2SV> so -> info . handleFlags |= //<S2SV> TEE_HANDLE_FLAG_INITIALIZED ; //<S2SV> set_attribute ( so , type_props , //<S2SV> TEE_ATTR_SECRET_VALUE ) ; //<S2SV> } //<S2SV> } else { //<S2SV> res = TEE_ERROR_OUT_OF_MEMORY ; //<S2SV> } //<S2SV> crypto_bignum_free ( pub ) ; //<S2SV> crypto_bignum_free ( ss ) ; //<S2SV> } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { //<S2SV> size_t alloc_size ; //<S2SV> struct ecc_public_key key_public ; //<S2SV> uint8_t * pt_secret ; //<S2SV> unsigned long pt_secret_len ; //<S2SV> if ( param_count != 2 || //<S2SV> params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || //<S2SV> params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> goto out ; //<S2SV> } //<S2SV> switch ( cs -> algo ) { //<S2SV> case TEE_ALG_ECDH_P192 : //<S2SV> alloc_size = 192 ; //<S2SV> break ; //<S2SV> case TEE_ALG_ECDH_P224 : //<S2SV> alloc_size = 224 ; //<S2SV> break ; //<S2SV> case TEE_ALG_ECDH_P256 : //<S2SV> alloc_size = 256 ; //<S2SV> break ; //<S2SV> case TEE_ALG_ECDH_P384 : //<S2SV> alloc_size = 384 ; //<S2SV> break ; //<S2SV> case TEE_ALG_ECDH_P521 : //<S2SV> alloc_size = 521 ; //<S2SV> break ; //<S2SV> default : //<S2SV> res = TEE_ERROR_NOT_IMPLEMENTED ; //<S2SV> goto out ; //<S2SV> } //<S2SV> res = crypto_acipher_alloc_ecc_public_key ( & key_public , //<S2SV> alloc_size ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; //<S2SV> crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , //<S2SV> params [ 0 ] . content . ref . length , //<S2SV> key_public . x ) ; //<S2SV> crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , //<S2SV> params [ 1 ] . content . ref . length , //<S2SV> key_public . y ) ; //<S2SV> pt_secret = ( uint8_t * ) ( sk + 1 ) ; //<S2SV> pt_secret_len = sk -> alloc_size ; //<S2SV> res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , //<S2SV> pt_secret , //<S2SV> & pt_secret_len ) ; //<S2SV> if ( res == TEE_SUCCESS ) { //<S2SV> sk -> key_size = pt_secret_len ; //<S2SV> so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; //<S2SV> set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; //<S2SV> } //<S2SV> crypto_acipher_free_ecc_public_key ( & key_public ) ; //<S2SV> } //<S2SV> # if defined ( CFG_CRYPTO_HKDF ) //<S2SV> else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { //<S2SV> void * salt , * info ; //<S2SV> size_t salt_len , info_len , okm_len ; //<S2SV> uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; //<S2SV> struct tee_cryp_obj_secret * ik = ko -> attr ; //<S2SV> const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; //<S2SV> res = get_hkdf_params ( params , param_count , & salt , & salt_len , //<S2SV> & info , & info_len , & okm_len ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> if ( okm_len > ik -> alloc_size ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> goto out ; //<S2SV> } //<S2SV> res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , //<S2SV> info , info_len , ( uint8_t * ) ( sk + 1 ) , //<S2SV> okm_len ) ; //<S2SV> if ( res == TEE_SUCCESS ) { //<S2SV> sk -> key_size = okm_len ; //<S2SV> so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; //<S2SV> set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> # if defined ( CFG_CRYPTO_CONCAT_KDF ) //<S2SV> else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { //<S2SV> void * info ; //<S2SV> size_t info_len , derived_key_len ; //<S2SV> uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; //<S2SV> struct tee_cryp_obj_secret * ss = ko -> attr ; //<S2SV> const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; //<S2SV> res = get_concat_kdf_params ( params , param_count , & info , //<S2SV> & info_len , & derived_key_len ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> if ( derived_key_len > ss -> alloc_size ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> goto out ; //<S2SV> } //<S2SV> res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , //<S2SV> info , info_len , ( uint8_t * ) ( sk + 1 ) , //<S2SV> derived_key_len ) ; //<S2SV> if ( res == TEE_SUCCESS ) { //<S2SV> sk -> key_size = derived_key_len ; //<S2SV> so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; //<S2SV> set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> # if defined ( CFG_CRYPTO_PBKDF2 ) //<S2SV> else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { //<S2SV> void * salt ; //<S2SV> size_t salt_len , iteration_count , derived_key_len ; //<S2SV> uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; //<S2SV> struct tee_cryp_obj_secret * ss = ko -> attr ; //<S2SV> const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; //<S2SV> res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , //<S2SV> & derived_key_len , & iteration_count ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> if ( derived_key_len > ss -> alloc_size ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> goto out ; //<S2SV> } //<S2SV> res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , //<S2SV> salt_len , iteration_count , //<S2SV> ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; //<S2SV> if ( res == TEE_SUCCESS ) { //<S2SV> sk -> key_size = derived_key_len ; //<S2SV> so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; //<S2SV> set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> else //<S2SV> res = TEE_ERROR_NOT_SUPPORTED ; //<S2SV> out : //<S2SV> free ( params ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> 