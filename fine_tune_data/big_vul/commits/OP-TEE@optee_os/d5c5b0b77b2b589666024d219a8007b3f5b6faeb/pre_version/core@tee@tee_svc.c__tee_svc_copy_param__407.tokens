static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , //<S2SV> struct tee_ta_session * called_sess , //<S2SV> struct utee_params * callee_params , //<S2SV> struct tee_ta_param * param , //<S2SV> void * tmp_buf_va [ TEE_NUM_PARAMS ] , //<S2SV> struct mobj * * mobj_tmp ) //<S2SV> { //<S2SV> size_t n ; //<S2SV> TEE_Result res ; //<S2SV> size_t req_mem = 0 ; //<S2SV> size_t s ; //<S2SV> uint8_t * dst = 0 ; //<S2SV> bool ta_private_memref [ TEE_NUM_PARAMS ] ; //<S2SV> struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; //<S2SV> void * va ; //<S2SV> size_t dst_offs ; //<S2SV> if ( ! callee_params ) { //<S2SV> memset ( param , 0 , sizeof ( * param ) ) ; //<S2SV> } else { //<S2SV> res = tee_mmu_check_access_rights ( utc , //<S2SV> TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , //<S2SV> ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> utee_param_to_param ( param , callee_params ) ; //<S2SV> } //<S2SV> if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { //<S2SV> return TEE_SUCCESS ; //<S2SV> } //<S2SV> for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { //<S2SV> ta_private_memref [ n ] = false ; //<S2SV> switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { //<S2SV> case TEE_PARAM_TYPE_MEMREF_INPUT : //<S2SV> case TEE_PARAM_TYPE_MEMREF_OUTPUT : //<S2SV> case TEE_PARAM_TYPE_MEMREF_INOUT : //<S2SV> va = ( void * ) param -> u [ n ] . mem . offs ; //<S2SV> s = param -> u [ n ] . mem . size ; //<S2SV> if ( ! va ) { //<S2SV> if ( s ) //<S2SV> return TEE_ERROR_BAD_PARAMETERS ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { //<S2SV> s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; //<S2SV> if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) //<S2SV> return TEE_ERROR_BAD_PARAMETERS ; //<S2SV> ta_private_memref [ n ] = true ; //<S2SV> break ; //<S2SV> } //<S2SV> res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , //<S2SV> & param -> u [ n ] . mem . mobj , //<S2SV> & param -> u [ n ] . mem . offs ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( req_mem == 0 ) //<S2SV> return TEE_SUCCESS ; //<S2SV> res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> dst_offs = 0 ; //<S2SV> for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { //<S2SV> if ( ! ta_private_memref [ n ] ) //<S2SV> continue ; //<S2SV> s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; //<S2SV> switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { //<S2SV> case TEE_PARAM_TYPE_MEMREF_INPUT : //<S2SV> case TEE_PARAM_TYPE_MEMREF_INOUT : //<S2SV> va = ( void * ) param -> u [ n ] . mem . offs ; //<S2SV> if ( va ) { //<S2SV> res = tee_svc_copy_from_user ( dst , va , //<S2SV> param -> u [ n ] . mem . size ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> param -> u [ n ] . mem . offs = dst_offs ; //<S2SV> param -> u [ n ] . mem . mobj = * mobj_tmp ; //<S2SV> tmp_buf_va [ n ] = dst ; //<S2SV> dst += s ; //<S2SV> dst_offs += s ; //<S2SV> } //<S2SV> break ; //<S2SV> case TEE_PARAM_TYPE_MEMREF_OUTPUT : //<S2SV> va = ( void * ) param -> u [ n ] . mem . offs ; //<S2SV> if ( va ) { //<S2SV> param -> u [ n ] . mem . offs = dst_offs ; //<S2SV> param -> u [ n ] . mem . mobj = * mobj_tmp ; //<S2SV> tmp_buf_va [ n ] = dst ; //<S2SV> dst += s ; //<S2SV> dst_offs += s ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> return TEE_SUCCESS ; //<S2SV> } //<S2SV> 