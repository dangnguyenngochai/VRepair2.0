static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , //<S2SV> struct tee_ta_param * p , //<S2SV> struct utee_params * up ) //<S2SV> { //<S2SV> size_t n ; //<S2SV> uint32_t types = up -> types ; //<S2SV> p -> types = types ; //<S2SV> for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { //<S2SV> uintptr_t a = up -> vals [ n * 2 ] ; //<S2SV> size_t b = up -> vals [ n * 2 + 1 ] ; //<S2SV> uint32_t flags = TEE_MEMORY_ACCESS_READ | //<S2SV> TEE_MEMORY_ACCESS_ANY_OWNER ; //<S2SV> switch ( TEE_PARAM_TYPE_GET ( types , n ) ) { //<S2SV> case TEE_PARAM_TYPE_MEMREF_OUTPUT : //<S2SV> case TEE_PARAM_TYPE_MEMREF_INOUT : //<S2SV> flags |= TEE_MEMORY_ACCESS_WRITE ; //<S2SV> case TEE_PARAM_TYPE_MEMREF_INPUT : //<S2SV> p -> u [ n ] . mem . mobj = & mobj_virt ; //<S2SV> p -> u [ n ] . mem . offs = a ; //<S2SV> p -> u [ n ] . mem . size = b ; //<S2SV> if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) //<S2SV> return TEE_ERROR_ACCESS_DENIED ; //<S2SV> break ; //<S2SV> case TEE_PARAM_TYPE_VALUE_INPUT : //<S2SV> case TEE_PARAM_TYPE_VALUE_INOUT : //<S2SV> p -> u [ n ] . val . a = a ; //<S2SV> p -> u [ n ] . val . b = b ; //<S2SV> break ; //<S2SV> default : //<S2SV> memset ( & p -> u [ n ] , 0 , sizeof ( p -> u [ n ] ) ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return TEE_SUCCESS ; //<S2SV> } //<S2SV> 