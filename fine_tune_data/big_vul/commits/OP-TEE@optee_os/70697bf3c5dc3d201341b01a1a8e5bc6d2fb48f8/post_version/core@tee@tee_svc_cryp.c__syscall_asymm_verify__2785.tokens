TEE_Result syscall_asymm_verify ( unsigned long state , //<S2SV> const struct utee_attribute * usr_params , //<S2SV> size_t num_params , const void * data , size_t data_len , //<S2SV> const void * sig , size_t sig_len ) //<S2SV> { //<S2SV> TEE_Result res ; //<S2SV> struct tee_cryp_state * cs ; //<S2SV> struct tee_ta_session * sess ; //<S2SV> struct tee_obj * o ; //<S2SV> size_t hash_size ; //<S2SV> int salt_len = 0 ; //<S2SV> TEE_Attribute * params = NULL ; //<S2SV> uint32_t hash_algo ; //<S2SV> struct user_ta_ctx * utc ; //<S2SV> res = tee_ta_get_current_session ( & sess ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> utc = to_user_ta_ctx ( sess -> ctx ) ; //<S2SV> res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> if ( cs -> mode != TEE_MODE_VERIFY ) //<S2SV> return TEE_ERROR_BAD_PARAMETERS ; //<S2SV> res = tee_mmu_check_access_rights ( utc , //<S2SV> TEE_MEMORY_ACCESS_READ | //<S2SV> TEE_MEMORY_ACCESS_ANY_OWNER , //<S2SV> ( uaddr_t ) data , data_len ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> res = tee_mmu_check_access_rights ( utc , //<S2SV> TEE_MEMORY_ACCESS_READ | //<S2SV> TEE_MEMORY_ACCESS_ANY_OWNER , //<S2SV> ( uaddr_t ) sig , sig_len ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> size_t alloc_size = 0 ; //<S2SV> if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) //<S2SV> return TEE_ERROR_OVERFLOW ; //<S2SV> params = malloc ( alloc_size ) ; //<S2SV> if ( ! params ) //<S2SV> return TEE_ERROR_OUT_OF_MEMORY ; //<S2SV> res = copy_in_attrs ( utc , usr_params , num_params , params ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> res = tee_obj_get ( utc , cs -> key1 , & o ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> goto out ; //<S2SV> } //<S2SV> switch ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) ) { //<S2SV> case TEE_MAIN_ALGO_RSA : //<S2SV> if ( cs -> algo != TEE_ALG_RSASSA_PKCS1_V1_5 ) { //<S2SV> hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; //<S2SV> res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> break ; //<S2SV> if ( data_len != hash_size ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> break ; //<S2SV> } //<S2SV> salt_len = pkcs1_get_salt_len ( params , num_params , //<S2SV> hash_size ) ; //<S2SV> } //<S2SV> res = crypto_acipher_rsassa_verify ( cs -> algo , o -> attr , salt_len , //<S2SV> data , data_len , sig , //<S2SV> sig_len ) ; //<S2SV> break ; //<S2SV> case TEE_MAIN_ALGO_DSA : //<S2SV> hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; //<S2SV> res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> break ; //<S2SV> if ( data_len > hash_size ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> break ; //<S2SV> } //<S2SV> res = crypto_acipher_dsa_verify ( cs -> algo , o -> attr , data , //<S2SV> data_len , sig , sig_len ) ; //<S2SV> break ; //<S2SV> case TEE_MAIN_ALGO_ECDSA : //<S2SV> res = crypto_acipher_ecc_verify ( cs -> algo , o -> attr , data , //<S2SV> data_len , sig , sig_len ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> res = TEE_ERROR_NOT_SUPPORTED ; //<S2SV> } //<S2SV> out : //<S2SV> free ( params ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> 