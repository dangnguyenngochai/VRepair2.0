TEE_Result syscall_asymm_operate ( unsigned long state , //<S2SV> const struct utee_attribute * usr_params , //<S2SV> size_t num_params , const void * src_data , size_t src_len , //<S2SV> void * dst_data , uint64_t * dst_len ) //<S2SV> { //<S2SV> TEE_Result res ; //<S2SV> struct tee_cryp_state * cs ; //<S2SV> struct tee_ta_session * sess ; //<S2SV> uint64_t dlen64 ; //<S2SV> size_t dlen ; //<S2SV> struct tee_obj * o ; //<S2SV> void * label = NULL ; //<S2SV> size_t label_len = 0 ; //<S2SV> size_t n ; //<S2SV> int salt_len ; //<S2SV> TEE_Attribute * params = NULL ; //<S2SV> struct user_ta_ctx * utc ; //<S2SV> res = tee_ta_get_current_session ( & sess ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> utc = to_user_ta_ctx ( sess -> ctx ) ; //<S2SV> res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> res = tee_mmu_check_access_rights ( //<S2SV> utc , //<S2SV> TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , //<S2SV> ( uaddr_t ) src_data , src_len ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> res = tee_svc_copy_from_user ( & dlen64 , dst_len , sizeof ( dlen64 ) ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> dlen = dlen64 ; //<S2SV> res = tee_mmu_check_access_rights ( //<S2SV> utc , //<S2SV> TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | //<S2SV> TEE_MEMORY_ACCESS_ANY_OWNER , //<S2SV> ( uaddr_t ) dst_data , dlen ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> return res ; //<S2SV> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; //<S2SV> if ( ! params ) //<S2SV> return TEE_ERROR_OUT_OF_MEMORY ; //<S2SV> res = copy_in_attrs ( utc , usr_params , num_params , params ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> res = tee_obj_get ( utc , cs -> key1 , & o ) ; //<S2SV> if ( res != TEE_SUCCESS ) //<S2SV> goto out ; //<S2SV> if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { //<S2SV> res = TEE_ERROR_GENERIC ; //<S2SV> goto out ; //<S2SV> } //<S2SV> switch ( cs -> algo ) { //<S2SV> case TEE_ALG_RSA_NOPAD : //<S2SV> if ( cs -> mode == TEE_MODE_ENCRYPT ) { //<S2SV> res = crypto_acipher_rsanopad_encrypt ( o -> attr , src_data , //<S2SV> src_len , dst_data , //<S2SV> & dlen ) ; //<S2SV> } else if ( cs -> mode == TEE_MODE_DECRYPT ) { //<S2SV> res = crypto_acipher_rsanopad_decrypt ( o -> attr , src_data , //<S2SV> src_len , dst_data , //<S2SV> & dlen ) ; //<S2SV> } else { //<S2SV> res = TEE_ERROR_GENERIC ; //<S2SV> } //<S2SV> break ; //<S2SV> case TEE_ALG_RSAES_PKCS1_V1_5 : //<S2SV> case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1 : //<S2SV> case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224 : //<S2SV> case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256 : //<S2SV> case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384 : //<S2SV> case TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512 : //<S2SV> for ( n = 0 ; n < num_params ; n ++ ) { //<S2SV> if ( params [ n ] . attributeID == TEE_ATTR_RSA_OAEP_LABEL ) { //<S2SV> label = params [ n ] . content . ref . buffer ; //<S2SV> label_len = params [ n ] . content . ref . length ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( cs -> mode == TEE_MODE_ENCRYPT ) { //<S2SV> res = crypto_acipher_rsaes_encrypt ( cs -> algo , o -> attr , //<S2SV> label , label_len , //<S2SV> src_data , src_len , //<S2SV> dst_data , & dlen ) ; //<S2SV> } else if ( cs -> mode == TEE_MODE_DECRYPT ) { //<S2SV> res = crypto_acipher_rsaes_decrypt ( //<S2SV> cs -> algo , o -> attr , label , label_len , //<S2SV> src_data , src_len , dst_data , & dlen ) ; //<S2SV> } else { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> } //<S2SV> break ; //<S2SV> # if defined ( CFG_CRYPTO_RSASSA_NA1 ) //<S2SV> case TEE_ALG_RSASSA_PKCS1_V1_5 : //<S2SV> # endif //<S2SV> case TEE_ALG_RSASSA_PKCS1_V1_5_MD5 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_V1_5_SHA1 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_V1_5_SHA224 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_V1_5_SHA256 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_V1_5_SHA384 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_V1_5_SHA512 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384 : //<S2SV> case TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512 : //<S2SV> if ( cs -> mode != TEE_MODE_SIGN ) { //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> break ; //<S2SV> } //<S2SV> salt_len = pkcs1_get_salt_len ( params , num_params , src_len ) ; //<S2SV> res = crypto_acipher_rsassa_sign ( cs -> algo , o -> attr , salt_len , //<S2SV> src_data , src_len , dst_data , //<S2SV> & dlen ) ; //<S2SV> break ; //<S2SV> case TEE_ALG_DSA_SHA1 : //<S2SV> case TEE_ALG_DSA_SHA224 : //<S2SV> case TEE_ALG_DSA_SHA256 : //<S2SV> res = crypto_acipher_dsa_sign ( cs -> algo , o -> attr , src_data , //<S2SV> src_len , dst_data , & dlen ) ; //<S2SV> break ; //<S2SV> case TEE_ALG_ECDSA_P192 : //<S2SV> case TEE_ALG_ECDSA_P224 : //<S2SV> case TEE_ALG_ECDSA_P256 : //<S2SV> case TEE_ALG_ECDSA_P384 : //<S2SV> case TEE_ALG_ECDSA_P521 : //<S2SV> res = crypto_acipher_ecc_sign ( cs -> algo , o -> attr , src_data , //<S2SV> src_len , dst_data , & dlen ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> res = TEE_ERROR_BAD_PARAMETERS ; //<S2SV> break ; //<S2SV> } //<S2SV> out : //<S2SV> free ( params ) ; //<S2SV> if ( res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER ) { //<S2SV> TEE_Result res2 ; //<S2SV> dlen64 = dlen ; //<S2SV> res2 = tee_svc_copy_to_user ( dst_len , & dlen64 , sizeof ( * dst_len ) ) ; //<S2SV> if ( res2 != TEE_SUCCESS ) //<S2SV> return res2 ; //<S2SV> } //<S2SV> return res ; //<S2SV> } //<S2SV> 