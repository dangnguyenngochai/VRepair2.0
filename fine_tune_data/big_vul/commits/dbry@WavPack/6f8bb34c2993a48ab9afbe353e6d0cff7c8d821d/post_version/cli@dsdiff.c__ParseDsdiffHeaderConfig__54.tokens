int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) //<S2SV> { //<S2SV> int64_t infilesize , total_samples ; //<S2SV> DFFFileHeader dff_file_header ; //<S2SV> DFFChunkHeader dff_chunk_header ; //<S2SV> uint32_t bcount ; //<S2SV> infilesize = DoGetFileSize ( infile ) ; //<S2SV> memcpy ( & dff_file_header , fourcc , 4 ) ; //<S2SV> if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || //<S2SV> bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , "DSD<S2SV_blank>" , 4 ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> # if 1 //<S2SV> WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; //<S2SV> if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && //<S2SV> dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_file_header . ckDataSize ) ; //<S2SV> # endif //<S2SV> while ( 1 ) { //<S2SV> if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || //<S2SV> bcount != sizeof ( DFFChunkHeader ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld" , dff_chunk_header . ckDataSize ) ; //<S2SV> if ( ! strncmp ( dff_chunk_header . ckID , "FVER" , 4 ) ) { //<S2SV> uint32_t version ; //<S2SV> if ( dff_chunk_header . ckDataSize != sizeof ( version ) || //<S2SV> ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || //<S2SV> bcount != sizeof ( version ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackBigEndianToNative ( & version , "L" ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x" , version ) ; //<S2SV> } //<S2SV> else if ( ! strncmp ( dff_chunk_header . ckID , "PROP" , 4 ) ) { //<S2SV> char * prop_chunk ; //<S2SV> if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ; //<S2SV> prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; //<S2SV> if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || //<S2SV> bcount != dff_chunk_header . ckDataSize ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; //<S2SV> free ( prop_chunk ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> free ( prop_chunk ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( ! strncmp ( prop_chunk , "SND<S2SV_blank>" , 4 ) ) { //<S2SV> char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; //<S2SV> uint16_t numChannels , chansSpecified , chanMask = 0 ; //<S2SV> uint32_t sampleRate ; //<S2SV> while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { //<S2SV> memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; //<S2SV> cptr += sizeof ( dff_chunk_header ) ; //<S2SV> WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; //<S2SV> if ( eptr - cptr >= dff_chunk_header . ckDataSize ) { //<S2SV> if ( ! strncmp ( dff_chunk_header . ckID , "FS<S2SV_blank><S2SV_blank>" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { //<S2SV> memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; //<S2SV> WavpackBigEndianToNative ( & sampleRate , "L" ) ; //<S2SV> cptr += dff_chunk_header . ckDataSize ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz" , sampleRate ) ; //<S2SV> } //<S2SV> else if ( ! strncmp ( dff_chunk_header . ckID , "CHNL" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { //<S2SV> memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; //<S2SV> WavpackBigEndianToNative ( & numChannels , "S" ) ; //<S2SV> cptr += sizeof ( numChannels ) ; //<S2SV> chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; //<S2SV> while ( chansSpecified -- ) { //<S2SV> if ( ! strncmp ( cptr , "SLFT" , 4 ) || ! strncmp ( cptr , "MLFT" , 4 ) ) //<S2SV> chanMask |= 0x1 ; //<S2SV> else if ( ! strncmp ( cptr , "SRGT" , 4 ) || ! strncmp ( cptr , "MRGT" , 4 ) ) //<S2SV> chanMask |= 0x2 ; //<S2SV> else if ( ! strncmp ( cptr , "LS<S2SV_blank><S2SV_blank>" , 4 ) ) //<S2SV> chanMask |= 0x10 ; //<S2SV> else if ( ! strncmp ( cptr , "RS<S2SV_blank><S2SV_blank>" , 4 ) ) //<S2SV> chanMask |= 0x20 ; //<S2SV> else if ( ! strncmp ( cptr , "C<S2SV_blank><S2SV_blank><S2SV_blank>" , 4 ) ) //<S2SV> chanMask |= 0x4 ; //<S2SV> else if ( ! strncmp ( cptr , "LFE<S2SV_blank>" , 4 ) ) //<S2SV> chanMask |= 0x8 ; //<S2SV> else //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; //<S2SV> cptr += 4 ; //<S2SV> } //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x" , numChannels , chanMask ) ; //<S2SV> } //<S2SV> else if ( ! strncmp ( dff_chunk_header . ckID , "CMPR" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { //<S2SV> if ( strncmp ( cptr , "DSD<S2SV_blank>" , 4 ) ) { //<S2SV> error_line ( "DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\"%c%c%c%c\\"!" , //<S2SV> cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; //<S2SV> free ( prop_chunk ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> cptr += dff_chunk_header . ckDataSize ; //<S2SV> } //<S2SV> else { //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , dff_chunk_header . ckID [ 0 ] , //<S2SV> dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; //<S2SV> cptr += dff_chunk_header . ckDataSize ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; //<S2SV> free ( prop_chunk ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { //<S2SV> error_line ( "this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; //<S2SV> free ( prop_chunk ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( chanMask ) //<S2SV> config -> channel_mask = chanMask ; //<S2SV> config -> bits_per_sample = 8 ; //<S2SV> config -> bytes_per_sample = 1 ; //<S2SV> config -> num_channels = numChannels ; //<S2SV> config -> sample_rate = sampleRate / 8 ; //<S2SV> config -> qmode |= QMODE_DSD_MSB_FIRST ; //<S2SV> } //<S2SV> else if ( debug_logging_mode ) //<S2SV> error_line ( "got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , //<S2SV> prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; //<S2SV> free ( prop_chunk ) ; //<S2SV> } //<S2SV> else if ( ! strncmp ( dff_chunk_header . ckID , "DSD<S2SV_blank>" , 4 ) ) { //<S2SV> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; //<S2SV> break ; //<S2SV> } //<S2SV> else { //<S2SV> int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; //<S2SV> char * buff ; //<S2SV> if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> buff = malloc ( bytes_to_copy ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , //<S2SV> dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , //<S2SV> dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; //<S2SV> if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || //<S2SV> bcount != bytes_to_copy || //<S2SV> ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> free ( buff ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> free ( buff ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples" , total_samples ) ; //<S2SV> if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { //<S2SV> error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> return WAVPACK_NO_ERROR ; //<S2SV> } //<S2SV> 