int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) //<S2SV> { //<S2SV> int64_t total_samples = 0 , infilesize ; //<S2SV> Wave64ChunkHeader chunk_header ; //<S2SV> Wave64FileHeader filehdr ; //<S2SV> WaveHeader WaveHeader ; //<S2SV> uint32_t bcount ; //<S2SV> infilesize = DoGetFileSize ( infile ) ; //<S2SV> memcpy ( & filehdr , fourcc , 4 ) ; //<S2SV> if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || //<S2SV> bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || //<S2SV> memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> # if 1 //<S2SV> WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; //<S2SV> if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && //<S2SV> filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> # endif //<S2SV> while ( 1 ) { //<S2SV> if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || //<S2SV> bcount != sizeof ( Wave64ChunkHeader ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; //<S2SV> chunk_header . ckSize -= sizeof ( chunk_header ) ; //<S2SV> if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { //<S2SV> int supported = TRUE , format ; //<S2SV> chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; //<S2SV> if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || //<S2SV> ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || //<S2SV> bcount != chunk_header . ckSize ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; //<S2SV> if ( debug_logging_mode ) { //<S2SV> error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; //<S2SV> error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; //<S2SV> error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; //<S2SV> if ( chunk_header . ckSize > 16 ) //<S2SV> error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , //<S2SV> WaveHeader . ValidBitsPerSample ) ; //<S2SV> if ( chunk_header . ckSize > 20 ) //<S2SV> error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; //<S2SV> } //<S2SV> if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) //<S2SV> config -> qmode |= QMODE_ADOBE_MODE ; //<S2SV> format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? //<S2SV> WaveHeader . SubFormat : WaveHeader . FormatTag ; //<S2SV> config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? //<S2SV> WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; //<S2SV> if ( format != 1 && format != 3 ) //<S2SV> supported = FALSE ; //<S2SV> if ( format == 3 && config -> bits_per_sample != 32 ) //<S2SV> supported = FALSE ; //<S2SV> if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || //<S2SV> WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || //<S2SV> WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || //<S2SV> WaveHeader . BlockAlign % WaveHeader . NumChannels ) //<S2SV> supported = FALSE ; //<S2SV> if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) //<S2SV> supported = FALSE ; //<S2SV> if ( ! supported ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( chunk_header . ckSize < 40 ) { //<S2SV> if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { //<S2SV> if ( WaveHeader . NumChannels <= 2 ) //<S2SV> config -> channel_mask = 0x5 - WaveHeader . NumChannels ; //<S2SV> else if ( WaveHeader . NumChannels <= 18 ) //<S2SV> config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; //<S2SV> else //<S2SV> config -> channel_mask = 0x3ffff ; //<S2SV> } //<S2SV> } //<S2SV> else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { //<S2SV> error_line ( "this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( WaveHeader . ChannelMask ) //<S2SV> config -> channel_mask = WaveHeader . ChannelMask ; //<S2SV> if ( format == 3 ) //<S2SV> config -> float_norm_exp = 127 ; //<S2SV> else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && //<S2SV> WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { //<S2SV> if ( WaveHeader . BitsPerSample == 24 ) //<S2SV> config -> float_norm_exp = 127 + 23 ; //<S2SV> else if ( WaveHeader . BitsPerSample == 32 ) //<S2SV> config -> float_norm_exp = 127 + 15 ; //<S2SV> } //<S2SV> if ( debug_logging_mode ) { //<S2SV> if ( config -> float_norm_exp == 127 ) //<S2SV> error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; //<S2SV> else //<S2SV> error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , //<S2SV> config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { //<S2SV> if ( ! WaveHeader . NumChannels ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { //<S2SV> config -> qmode |= QMODE_IGNORE_LENGTH ; //<S2SV> if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) //<S2SV> total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; //<S2SV> else //<S2SV> total_samples = - 1 ; //<S2SV> } //<S2SV> else { //<S2SV> if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { //<S2SV> error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; //<S2SV> if ( ! total_samples ) { //<S2SV> error_line ( "this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( total_samples > MAX_WAVPACK_SAMPLES ) { //<S2SV> error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; //<S2SV> config -> num_channels = WaveHeader . NumChannels ; //<S2SV> config -> sample_rate = WaveHeader . SampleRate ; //<S2SV> break ; //<S2SV> } //<S2SV> else { //<S2SV> int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; //<S2SV> char * buff = malloc ( bytes_to_copy ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , //<S2SV> chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , //<S2SV> chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; //<S2SV> if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || //<S2SV> bcount != bytes_to_copy || //<S2SV> ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> free ( buff ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> free ( buff ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { //<S2SV> error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> return WAVPACK_NO_ERROR ; //<S2SV> } //<S2SV> 