int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) //<S2SV> { //<S2SV> int is_rf64 = ! strncmp ( fourcc , "RF64" , 4 ) , got_ds64 = 0 ; //<S2SV> int64_t total_samples = 0 , infilesize ; //<S2SV> RiffChunkHeader riff_chunk_header ; //<S2SV> ChunkHeader chunk_header ; //<S2SV> WaveHeader WaveHeader ; //<S2SV> DS64Chunk ds64_chunk ; //<S2SV> uint32_t bcount ; //<S2SV> CLEAR ( WaveHeader ) ; //<S2SV> CLEAR ( ds64_chunk ) ; //<S2SV> infilesize = DoGetFileSize ( infile ) ; //<S2SV> if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { //<S2SV> error_line ( "can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> memcpy ( & riff_chunk_header , fourcc , 4 ) ; //<S2SV> if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || //<S2SV> bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , "WAVE" , 4 ) ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> while ( 1 ) { //<S2SV> if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || //<S2SV> bcount != sizeof ( ChunkHeader ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; //<S2SV> if ( ! strncmp ( chunk_header . ckID , "ds64" , 4 ) ) { //<S2SV> if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || //<S2SV> ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || //<S2SV> bcount != sizeof ( DS64Chunk ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> got_ds64 = 1 ; //<S2SV> WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , //<S2SV> ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; //<S2SV> if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> while ( ds64_chunk . tableLength -- ) { //<S2SV> CS64Chunk cs64_chunk ; //<S2SV> if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || //<S2SV> bcount != sizeof ( CS64Chunk ) || //<S2SV> ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else if ( ! strncmp ( chunk_header . ckID , "fmt<S2SV_blank>" , 4 ) ) { //<S2SV> int supported = TRUE , format ; //<S2SV> if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || //<S2SV> ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || //<S2SV> bcount != chunk_header . ckSize ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; //<S2SV> if ( debug_logging_mode ) { //<S2SV> error_line ( "format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d" , chunk_header . ckSize ) ; //<S2SV> error_line ( "FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; //<S2SV> error_line ( "BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; //<S2SV> if ( chunk_header . ckSize > 16 ) //<S2SV> error_line ( "cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d" , WaveHeader . cbSize , //<S2SV> WaveHeader . ValidBitsPerSample ) ; //<S2SV> if ( chunk_header . ckSize > 20 ) //<S2SV> error_line ( "ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; //<S2SV> } //<S2SV> if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) //<S2SV> config -> qmode |= QMODE_ADOBE_MODE ; //<S2SV> format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? //<S2SV> WaveHeader . SubFormat : WaveHeader . FormatTag ; //<S2SV> config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? //<S2SV> WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; //<S2SV> if ( format != 1 && format != 3 ) //<S2SV> supported = FALSE ; //<S2SV> if ( format == 3 && config -> bits_per_sample != 32 ) //<S2SV> supported = FALSE ; //<S2SV> if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || //<S2SV> WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || //<S2SV> WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || //<S2SV> WaveHeader . BlockAlign % WaveHeader . NumChannels ) //<S2SV> supported = FALSE ; //<S2SV> if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) //<S2SV> supported = FALSE ; //<S2SV> if ( ! supported ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( chunk_header . ckSize < 40 ) { //<S2SV> if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { //<S2SV> if ( WaveHeader . NumChannels <= 2 ) //<S2SV> config -> channel_mask = 0x5 - WaveHeader . NumChannels ; //<S2SV> else if ( WaveHeader . NumChannels <= 18 ) //<S2SV> config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; //<S2SV> else //<S2SV> config -> channel_mask = 0x3ffff ; //<S2SV> } //<S2SV> } //<S2SV> else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { //<S2SV> error_line ( "this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( WaveHeader . ChannelMask ) //<S2SV> config -> channel_mask = WaveHeader . ChannelMask ; //<S2SV> if ( format == 3 ) //<S2SV> config -> float_norm_exp = 127 ; //<S2SV> else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && //<S2SV> WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { //<S2SV> if ( WaveHeader . BitsPerSample == 24 ) //<S2SV> config -> float_norm_exp = 127 + 23 ; //<S2SV> else if ( WaveHeader . BitsPerSample == 32 ) //<S2SV> config -> float_norm_exp = 127 + 15 ; //<S2SV> } //<S2SV> if ( debug_logging_mode ) { //<S2SV> if ( config -> float_norm_exp == 127 ) //<S2SV> error_line ( "data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point" ) ; //<S2SV> else if ( config -> float_norm_exp ) //<S2SV> error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)" , //<S2SV> config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; //<S2SV> else //<S2SV> error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , //<S2SV> config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( ! strncmp ( chunk_header . ckID , "data" , 4 ) ) { //<S2SV> int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? //<S2SV> ds64_chunk . dataSize64 : chunk_header . ckSize ; //<S2SV> if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { //<S2SV> error_line ( "this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( config -> qmode & QMODE_IGNORE_LENGTH ) { //<S2SV> if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) //<S2SV> total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; //<S2SV> else //<S2SV> total_samples = - 1 ; //<S2SV> } //<S2SV> else { //<S2SV> total_samples = data_chunk_size / WaveHeader . BlockAlign ; //<S2SV> if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( ! total_samples ) { //<S2SV> error_line ( "this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( total_samples > MAX_WAVPACK_SAMPLES ) { //<S2SV> error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; //<S2SV> config -> num_channels = WaveHeader . NumChannels ; //<S2SV> config -> sample_rate = WaveHeader . SampleRate ; //<S2SV> break ; //<S2SV> } //<S2SV> else { //<S2SV> int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; //<S2SV> char * buff = malloc ( bytes_to_copy ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , //<S2SV> chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , //<S2SV> chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; //<S2SV> if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || //<S2SV> bcount != bytes_to_copy || //<S2SV> ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> free ( buff ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> free ( buff ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { //<S2SV> error_line ( "%s:<S2SV_blank>%s" , infilename , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> return WAVPACK_NO_ERROR ; //<S2SV> } //<S2SV> 