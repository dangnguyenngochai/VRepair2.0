int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) //<S2SV> { //<S2SV> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; //<S2SV> unsigned char * channel_identities = NULL ; //<S2SV> unsigned char * channel_reorder = NULL ; //<S2SV> int64_t total_samples = 0 , infilesize ; //<S2SV> CAFFileHeader caf_file_header ; //<S2SV> CAFChunkHeader caf_chunk_header ; //<S2SV> CAFAudioFormat caf_audio_format ; //<S2SV> int i ; //<S2SV> infilesize = DoGetFileSize ( infile ) ; //<S2SV> memcpy ( & caf_file_header , fourcc , 4 ) ; //<S2SV> if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || //<S2SV> bcount != sizeof ( CAFFileHeader ) - 4 ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; //<S2SV> if ( caf_file_header . mFileVersion != 1 ) { //<S2SV> error_line ( "%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!" , infilename , caf_file_header . mFileVersion ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> while ( 1 ) { //<S2SV> if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || //<S2SV> bcount != sizeof ( CAFChunkHeader ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; //<S2SV> if ( ! strncmp ( caf_chunk_header . mChunkType , "desc" , 4 ) ) { //<S2SV> int supported = TRUE ; //<S2SV> if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || //<S2SV> ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || //<S2SV> bcount != caf_chunk_header . mChunkSize ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; //<S2SV> if ( debug_logging_mode ) { //<S2SV> char formatstr [ 5 ] ; //<S2SV> memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; //<S2SV> formatstr [ 4 ] = 0 ; //<S2SV> error_line ( "format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g" , //<S2SV> formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; //<S2SV> error_line ( "packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames" , //<S2SV> caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; //<S2SV> error_line ( "channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; //<S2SV> } //<S2SV> if ( strncmp ( caf_audio_format . mFormatID , "lpcm" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) //<S2SV> supported = FALSE ; //<S2SV> else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || //<S2SV> caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) //<S2SV> supported = FALSE ; //<S2SV> else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) //<S2SV> supported = FALSE ; //<S2SV> else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || //<S2SV> ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) //<S2SV> supported = FALSE ; //<S2SV> else if ( caf_audio_format . mFramesPerPacket != 1 || //<S2SV> caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || //<S2SV> caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || //<S2SV> caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) //<S2SV> supported = FALSE ; //<S2SV> if ( ! supported ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; //<S2SV> config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; //<S2SV> config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; //<S2SV> config -> num_channels = caf_audio_format . mChannelsPerFrame ; //<S2SV> config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; //<S2SV> if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) //<S2SV> config -> qmode |= QMODE_BIG_ENDIAN ; //<S2SV> if ( config -> bytes_per_sample == 1 ) //<S2SV> config -> qmode |= QMODE_SIGNED_BYTES ; //<S2SV> if ( debug_logging_mode ) { //<S2SV> if ( config -> float_norm_exp == 127 ) //<S2SV> error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" ) ; //<S2SV> else //<S2SV> error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , //<S2SV> config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" , config -> bytes_per_sample ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( ! strncmp ( caf_chunk_header . mChunkType , "chan" , 4 ) ) { //<S2SV> CAFChannelLayout * caf_channel_layout ; //<S2SV> if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) { //<S2SV> error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; //<S2SV> caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; //<S2SV> if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || //<S2SV> bcount != caf_chunk_header . mChunkSize ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; //<S2SV> free ( caf_channel_layout ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> free ( caf_channel_layout ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; //<S2SV> chan_chunk = 1 ; //<S2SV> if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { //<S2SV> error_line ( "this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; //<S2SV> free ( caf_channel_layout ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> switch ( caf_channel_layout -> mChannelLayoutTag ) { //<S2SV> case kCAFChannelLayoutTag_UseChannelDescriptions : //<S2SV> { //<S2SV> CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; //<S2SV> int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; //<S2SV> int label , cindex = 0 , idents = 0 ; //<S2SV> if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || //<S2SV> num_descriptions != config -> num_channels ) { //<S2SV> error_line ( "channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!" ) ; //<S2SV> free ( caf_channel_layout ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( num_descriptions >= 256 ) { //<S2SV> error_line ( "%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> channel_reorder = malloc ( num_descriptions ) ; //<S2SV> memset ( channel_reorder , - 1 , num_descriptions ) ; //<S2SV> channel_identities = malloc ( num_descriptions + 1 ) ; //<S2SV> for ( i = 0 ; i < num_descriptions ; ++ i ) { //<S2SV> WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d" , i + 1 , descriptions [ i ] . mChannelLabel ) ; //<S2SV> } //<S2SV> for ( label = 1 ; label <= 18 ; ++ label ) //<S2SV> for ( i = 0 ; i < num_descriptions ; ++ i ) //<S2SV> if ( descriptions [ i ] . mChannelLabel == label ) { //<S2SV> config -> channel_mask |= 1 << ( label - 1 ) ; //<S2SV> channel_reorder [ i ] = cindex ++ ; //<S2SV> break ; //<S2SV> } //<S2SV> for ( i = 0 ; i < num_descriptions ; ++ i ) //<S2SV> if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { //<S2SV> uint32_t clabel = descriptions [ i ] . mChannelLabel ; //<S2SV> if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) //<S2SV> channel_identities [ idents ++ ] = 0xff ; //<S2SV> else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) //<S2SV> channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; //<S2SV> else { //<S2SV> error_line ( "warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d" , clabel ) ; //<S2SV> channel_identities [ idents ++ ] = 0xff ; //<S2SV> } //<S2SV> channel_reorder [ i ] = cindex ++ ; //<S2SV> } //<S2SV> for ( i = 0 ; i < num_descriptions ; ++ i ) //<S2SV> if ( channel_reorder [ i ] != i ) //<S2SV> break ; //<S2SV> if ( i == num_descriptions ) { //<S2SV> free ( channel_reorder ) ; //<S2SV> channel_reorder = NULL ; //<S2SV> } //<S2SV> else { //<S2SV> config -> qmode |= QMODE_REORDERED_CHANS ; //<S2SV> channel_layout = num_descriptions ; //<S2SV> } //<S2SV> if ( ! idents ) { //<S2SV> free ( channel_identities ) ; //<S2SV> channel_identities = NULL ; //<S2SV> } //<S2SV> else //<S2SV> channel_identities [ idents ] = 0 ; //<S2SV> if ( debug_logging_mode ) { //<S2SV> error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS" , //<S2SV> caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , //<S2SV> caf_channel_layout -> mNumberChannelDescriptions , idents ) ; //<S2SV> if ( channel_reorder && num_descriptions <= 8 ) { //<S2SV> char reorder_string [ ] = "12345678" ; //<S2SV> for ( i = 0 ; i < num_descriptions ; ++ i ) //<S2SV> reorder_string [ i ] = channel_reorder [ i ] + '1' ; //<S2SV> reorder_string [ i ] = 0 ; //<S2SV> error_line ( "reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\"%s\\"\\n" , reorder_string ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case kCAFChannelLayoutTag_UseChannelBitmap : //<S2SV> config -> channel_mask = caf_channel_layout -> mChannelBitmap ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x" , //<S2SV> caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) //<S2SV> if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { //<S2SV> config -> channel_mask = layouts [ i ] . mChannelBitmap ; //<S2SV> channel_layout = layouts [ i ] . mChannelLayoutTag ; //<S2SV> if ( layouts [ i ] . mChannelReorder ) { //<S2SV> channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; //<S2SV> config -> qmode |= QMODE_REORDERED_CHANS ; //<S2SV> } //<S2SV> if ( layouts [ i ] . mChannelIdentities ) //<S2SV> channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s" , //<S2SV> channel_layout , config -> channel_mask , channel_reorder ? "yes" : "no" , channel_identities ? "yes" : "no" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( i == NUM_LAYOUTS && debug_logging_mode ) //<S2SV> error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned" , //<S2SV> caf_channel_layout -> mChannelLayoutTag ) ; //<S2SV> break ; //<S2SV> } //<S2SV> free ( caf_channel_layout ) ; //<S2SV> } //<S2SV> else if ( ! strncmp ( caf_chunk_header . mChunkType , "data" , 4 ) ) { //<S2SV> uint32_t mEditCount ; //<S2SV> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || //<S2SV> bcount != sizeof ( mEditCount ) ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { //<S2SV> config -> qmode |= QMODE_IGNORE_LENGTH ; //<S2SV> if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) //<S2SV> total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; //<S2SV> else //<S2SV> total_samples = - 1 ; //<S2SV> } //<S2SV> else { //<S2SV> if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { //<S2SV> error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { //<S2SV> error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; //<S2SV> if ( ! total_samples ) { //<S2SV> error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( total_samples > MAX_WAVPACK_SAMPLES ) { //<S2SV> error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> else { //<S2SV> uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; //<S2SV> char * buff ; //<S2SV> if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { //<S2SV> error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> buff = malloc ( bytes_to_copy ) ; //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , //<S2SV> caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , //<S2SV> caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; //<S2SV> if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || //<S2SV> bcount != bytes_to_copy || //<S2SV> ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && //<S2SV> ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> free ( buff ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> free ( buff ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) //<S2SV> config -> channel_mask = 0x5 - config -> num_channels ; //<S2SV> if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { //<S2SV> error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( channel_identities ) //<S2SV> free ( channel_identities ) ; //<S2SV> if ( channel_layout || channel_reorder ) { //<S2SV> if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { //<S2SV> error_line ( "problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)" ) ; //<S2SV> return WAVPACK_SOFT_ERROR ; //<S2SV> } //<S2SV> if ( channel_reorder ) //<S2SV> free ( channel_reorder ) ; //<S2SV> } //<S2SV> return WAVPACK_NO_ERROR ; //<S2SV> } //<S2SV> 