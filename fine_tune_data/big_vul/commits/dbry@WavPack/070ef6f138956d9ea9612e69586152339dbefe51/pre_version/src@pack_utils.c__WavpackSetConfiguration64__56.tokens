int WavpackSetConfiguration64 ( WavpackContext * wpc , WavpackConfig * config , int64_t total_samples , const unsigned char * chan_ids ) //<S2SV> { //<S2SV> uint32_t flags , bps = 0 ; //<S2SV> uint32_t chan_mask = config -> channel_mask ; //<S2SV> int num_chans = config -> num_channels ; //<S2SV> int i ; //<S2SV> wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ; //<S2SV> if ( ( config -> qmode & QMODE_DSD_AUDIO ) && config -> bytes_per_sample == 1 && config -> bits_per_sample == 8 ) { //<S2SV> # ifdef ENABLE_DSD //<S2SV> wpc -> dsd_multiplier = 1 ; //<S2SV> flags = DSD_FLAG ; //<S2SV> for ( i = 14 ; i >= 0 ; -- i ) //<S2SV> if ( config -> sample_rate % sample_rates [ i ] == 0 ) { //<S2SV> int divisor = config -> sample_rate / sample_rates [ i ] ; //<S2SV> if ( divisor && ( divisor & ( divisor - 1 ) ) == 0 ) { //<S2SV> config -> sample_rate /= divisor ; //<S2SV> wpc -> dsd_multiplier = divisor ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( config -> flags & CONFIG_HYBRID_FLAG ) { //<S2SV> strcpy ( wpc -> error_message , "hybrid<S2SV_blank>mode<S2SV_blank>not<S2SV_blank>available<S2SV_blank>for<S2SV_blank>DSD!" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> config -> flags &= ( CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS ) ; //<S2SV> config -> float_norm_exp = config -> xmode = 0 ; //<S2SV> # else //<S2SV> strcpy ( wpc -> error_message , "libwavpack<S2SV_blank>not<S2SV_blank>configured<S2SV_blank>for<S2SV_blank>DSD!" ) ; //<S2SV> return FALSE ; //<S2SV> # endif //<S2SV> } //<S2SV> else //<S2SV> flags = config -> bytes_per_sample - 1 ; //<S2SV> wpc -> total_samples = total_samples ; //<S2SV> wpc -> config . sample_rate = config -> sample_rate ; //<S2SV> wpc -> config . num_channels = config -> num_channels ; //<S2SV> wpc -> config . channel_mask = config -> channel_mask ; //<S2SV> wpc -> config . bits_per_sample = config -> bits_per_sample ; //<S2SV> wpc -> config . bytes_per_sample = config -> bytes_per_sample ; //<S2SV> wpc -> config . block_samples = config -> block_samples ; //<S2SV> wpc -> config . flags = config -> flags ; //<S2SV> wpc -> config . qmode = config -> qmode ; //<S2SV> if ( config -> flags & CONFIG_VERY_HIGH_FLAG ) //<S2SV> wpc -> config . flags |= CONFIG_HIGH_FLAG ; //<S2SV> for ( i = 0 ; i < 15 ; ++ i ) //<S2SV> if ( wpc -> config . sample_rate == sample_rates [ i ] ) //<S2SV> break ; //<S2SV> flags |= i << SRATE_LSB ; //<S2SV> if ( ! ( flags & DSD_FLAG ) ) { //<S2SV> if ( config -> float_norm_exp ) { //<S2SV> wpc -> config . float_norm_exp = config -> float_norm_exp ; //<S2SV> wpc -> config . flags |= CONFIG_FLOAT_DATA ; //<S2SV> flags |= FLOAT_DATA ; //<S2SV> } //<S2SV> else //<S2SV> flags |= ( ( config -> bytes_per_sample * 8 ) - config -> bits_per_sample ) << SHIFT_LSB ; //<S2SV> if ( config -> flags & CONFIG_HYBRID_FLAG ) { //<S2SV> flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE ; //<S2SV> if ( ! ( wpc -> config . flags & CONFIG_SHAPE_OVERRIDE ) ) { //<S2SV> wpc -> config . flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING ; //<S2SV> flags |= HYBRID_SHAPE | NEW_SHAPING ; //<S2SV> } //<S2SV> else if ( wpc -> config . flags & CONFIG_HYBRID_SHAPE ) { //<S2SV> wpc -> config . shaping_weight = config -> shaping_weight ; //<S2SV> flags |= HYBRID_SHAPE | NEW_SHAPING ; //<S2SV> } //<S2SV> if ( wpc -> config . flags & ( CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC ) ) //<S2SV> flags |= CROSS_DECORR ; //<S2SV> if ( config -> flags & CONFIG_BITRATE_KBPS ) { //<S2SV> bps = ( uint32_t ) floor ( config -> bitrate * 256000.0 / config -> sample_rate / config -> num_channels + 0.5 ) ; //<S2SV> if ( bps > ( 64 << 8 ) ) //<S2SV> bps = 64 << 8 ; //<S2SV> } //<S2SV> else //<S2SV> bps = ( uint32_t ) floor ( config -> bitrate * 256.0 + 0.5 ) ; //<S2SV> } //<S2SV> else //<S2SV> flags |= CROSS_DECORR ; //<S2SV> if ( ! ( config -> flags & CONFIG_JOINT_OVERRIDE ) || ( config -> flags & CONFIG_JOINT_STEREO ) ) //<S2SV> flags |= JOINT_STEREO ; //<S2SV> if ( config -> flags & CONFIG_CREATE_WVC ) //<S2SV> wpc -> wvc_flag = TRUE ; //<S2SV> } //<S2SV> if ( chan_ids ) { //<S2SV> int lastchan = 0 , mask_copy = chan_mask ; //<S2SV> if ( ( int ) strlen ( ( char * ) chan_ids ) > num_chans ) { //<S2SV> strcpy ( wpc -> error_message , "chan_ids<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>num<S2SV_blank>channels!" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> while ( * chan_ids ) //<S2SV> if ( * chan_ids <= 32 && * chan_ids > lastchan && ( mask_copy & ( 1 << ( * chan_ids - 1 ) ) ) ) { //<S2SV> mask_copy &= ~ ( 1 << ( * chan_ids - 1 ) ) ; //<S2SV> lastchan = * chan_ids ++ ; //<S2SV> } //<S2SV> else //<S2SV> break ; //<S2SV> for ( i = 0 ; chan_ids [ i ] ; i ++ ) //<S2SV> if ( chan_ids [ i ] != 0xff ) { //<S2SV> wpc -> channel_identities = ( unsigned char * ) strdup ( ( char * ) chan_ids ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> for ( wpc -> current_stream = 0 ; num_chans ; wpc -> current_stream ++ ) { //<S2SV> WavpackStream * wps = malloc ( sizeof ( WavpackStream ) ) ; //<S2SV> unsigned char left_chan_id = 0 , right_chan_id = 0 ; //<S2SV> int pos , chans = 1 ; //<S2SV> wpc -> streams = realloc ( wpc -> streams , ( wpc -> current_stream + 1 ) * sizeof ( wpc -> streams [ 0 ] ) ) ; //<S2SV> wpc -> streams [ wpc -> current_stream ] = wps ; //<S2SV> CLEAR ( * wps ) ; //<S2SV> if ( chan_mask ) //<S2SV> for ( pos = 0 ; pos < 32 ; ++ pos ) //<S2SV> if ( chan_mask & ( 1 << pos ) ) { //<S2SV> if ( left_chan_id ) { //<S2SV> right_chan_id = pos + 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> else { //<S2SV> chan_mask &= ~ ( 1 << pos ) ; //<S2SV> left_chan_id = pos + 1 ; //<S2SV> } //<S2SV> } //<S2SV> while ( ! right_chan_id && chan_ids && * chan_ids ) //<S2SV> if ( left_chan_id ) //<S2SV> right_chan_id = * chan_ids ; //<S2SV> else //<S2SV> left_chan_id = * chan_ids ++ ; //<S2SV> if ( ! left_chan_id ) //<S2SV> left_chan_id = right_chan_id = 0xff ; //<S2SV> else if ( ! right_chan_id ) //<S2SV> right_chan_id = 0xff ; //<S2SV> if ( num_chans >= 2 ) { //<S2SV> if ( ( config -> flags & CONFIG_PAIR_UNDEF_CHANS ) && left_chan_id == 0xff && right_chan_id == 0xff ) //<S2SV> chans = 2 ; //<S2SV> else //<S2SV> for ( i = 0 ; i < NUM_STEREO_PAIRS ; ++ i ) //<S2SV> if ( ( left_chan_id == stereo_pairs [ i ] . a && right_chan_id == stereo_pairs [ i ] . b ) || //<S2SV> ( left_chan_id == stereo_pairs [ i ] . b && right_chan_id == stereo_pairs [ i ] . a ) ) { //<S2SV> if ( right_chan_id <= 32 && ( chan_mask & ( 1 << ( right_chan_id - 1 ) ) ) ) //<S2SV> chan_mask &= ~ ( 1 << ( right_chan_id - 1 ) ) ; //<S2SV> else if ( chan_ids && * chan_ids == right_chan_id ) //<S2SV> chan_ids ++ ; //<S2SV> chans = 2 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> num_chans -= chans ; //<S2SV> if ( num_chans && wpc -> current_stream == NEW_MAX_STREAMS - 1 ) //<S2SV> break ; //<S2SV> memcpy ( wps -> wphdr . ckID , "wvpk" , 4 ) ; //<S2SV> wps -> wphdr . ckSize = sizeof ( WavpackHeader ) - 8 ; //<S2SV> SET_TOTAL_SAMPLES ( wps -> wphdr , wpc -> total_samples ) ; //<S2SV> wps -> wphdr . version = wpc -> stream_version ; //<S2SV> wps -> wphdr . flags = flags ; //<S2SV> wps -> bits = bps ; //<S2SV> if ( ! wpc -> current_stream ) //<S2SV> wps -> wphdr . flags |= INITIAL_BLOCK ; //<S2SV> if ( ! num_chans ) //<S2SV> wps -> wphdr . flags |= FINAL_BLOCK ; //<S2SV> if ( chans == 1 ) { //<S2SV> wps -> wphdr . flags &= ~ ( JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE ) ; //<S2SV> wps -> wphdr . flags |= MONO_FLAG ; //<S2SV> } //<S2SV> } //<S2SV> wpc -> num_streams = wpc -> current_stream ; //<S2SV> wpc -> current_stream = 0 ; //<S2SV> if ( num_chans ) { //<S2SV> strcpy ( wpc -> error_message , "too<S2SV_blank>many<S2SV_blank>channels!" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> if ( config -> flags & CONFIG_EXTRA_MODE ) //<S2SV> wpc -> config . xmode = config -> xmode ? config -> xmode : 1 ; //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 