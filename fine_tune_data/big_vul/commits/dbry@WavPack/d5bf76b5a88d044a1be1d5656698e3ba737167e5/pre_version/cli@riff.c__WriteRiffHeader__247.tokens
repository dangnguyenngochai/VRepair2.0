int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) //<S2SV> { //<S2SV> int do_rf64 = 0 , write_junk = 1 ; //<S2SV> ChunkHeader ds64hdr , datahdr , fmthdr ; //<S2SV> RiffChunkHeader riffhdr ; //<S2SV> DS64Chunk ds64_chunk ; //<S2SV> JunkChunk junkchunk ; //<S2SV> WaveHeader wavhdr ; //<S2SV> uint32_t bcount ; //<S2SV> int64_t total_data_bytes , total_riff_bytes ; //<S2SV> int num_channels = WavpackGetNumChannels ( wpc ) ; //<S2SV> int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; //<S2SV> int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; //<S2SV> int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; //<S2SV> int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; //<S2SV> int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; //<S2SV> int wavhdrsize = 16 ; //<S2SV> if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { //<S2SV> error_line ( "can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> if ( total_samples == - 1 ) //<S2SV> total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; //<S2SV> total_data_bytes = total_samples * bytes_per_sample * num_channels ; //<S2SV> if ( total_data_bytes > 0xff000000 ) { //<S2SV> if ( debug_logging_mode ) //<S2SV> error_line ( "total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64" , total_data_bytes ) ; //<S2SV> write_junk = 0 ; //<S2SV> do_rf64 = 1 ; //<S2SV> } //<S2SV> else if ( debug_logging_mode ) //<S2SV> error_line ( "total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff" , total_data_bytes ) ; //<S2SV> CLEAR ( wavhdr ) ; //<S2SV> wavhdr . FormatTag = format ; //<S2SV> wavhdr . NumChannels = num_channels ; //<S2SV> wavhdr . SampleRate = sample_rate ; //<S2SV> wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; //<S2SV> wavhdr . BlockAlign = bytes_per_sample * num_channels ; //<S2SV> wavhdr . BitsPerSample = bits_per_sample ; //<S2SV> if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { //<S2SV> wavhdrsize = sizeof ( wavhdr ) ; //<S2SV> wavhdr . cbSize = 22 ; //<S2SV> wavhdr . ValidBitsPerSample = bits_per_sample ; //<S2SV> wavhdr . SubFormat = format ; //<S2SV> wavhdr . ChannelMask = channel_mask ; //<S2SV> wavhdr . FormatTag = 0xfffe ; //<S2SV> wavhdr . BitsPerSample = bytes_per_sample * 8 ; //<S2SV> wavhdr . GUID [ 4 ] = 0x10 ; //<S2SV> wavhdr . GUID [ 6 ] = 0x80 ; //<S2SV> wavhdr . GUID [ 9 ] = 0xaa ; //<S2SV> wavhdr . GUID [ 11 ] = 0x38 ; //<S2SV> wavhdr . GUID [ 12 ] = 0x9b ; //<S2SV> wavhdr . GUID [ 13 ] = 0x71 ; //<S2SV> } //<S2SV> strncpy ( riffhdr . ckID , do_rf64 ? "RF64" : "RIFF" , sizeof ( riffhdr . ckID ) ) ; //<S2SV> strncpy ( riffhdr . formType , "WAVE" , sizeof ( riffhdr . formType ) ) ; //<S2SV> total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; //<S2SV> if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; //<S2SV> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; //<S2SV> strncpy ( fmthdr . ckID , "fmt<S2SV_blank>" , sizeof ( fmthdr . ckID ) ) ; //<S2SV> strncpy ( datahdr . ckID , "data" , sizeof ( datahdr . ckID ) ) ; //<S2SV> fmthdr . ckSize = wavhdrsize ; //<S2SV> if ( write_junk ) { //<S2SV> CLEAR ( junkchunk ) ; //<S2SV> strncpy ( junkchunk . ckID , "junk" , sizeof ( junkchunk . ckID ) ) ; //<S2SV> junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; //<S2SV> WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; //<S2SV> } //<S2SV> if ( do_rf64 ) { //<S2SV> strncpy ( ds64hdr . ckID , "ds64" , sizeof ( ds64hdr . ckID ) ) ; //<S2SV> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; //<S2SV> CLEAR ( ds64_chunk ) ; //<S2SV> ds64_chunk . riffSize64 = total_riff_bytes ; //<S2SV> ds64_chunk . dataSize64 = total_data_bytes ; //<S2SV> ds64_chunk . sampleCount64 = total_samples ; //<S2SV> riffhdr . ckSize = ( uint32_t ) - 1 ; //<S2SV> datahdr . ckSize = ( uint32_t ) - 1 ; //<S2SV> WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; //<S2SV> WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; //<S2SV> } //<S2SV> else { //<S2SV> riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; //<S2SV> datahdr . ckSize = ( uint32_t ) total_data_bytes ; //<S2SV> } //<S2SV> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; //<S2SV> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; //<S2SV> WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; //<S2SV> WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; //<S2SV> if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || //<S2SV> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || //<S2SV> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || //<S2SV> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || //<S2SV> ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || //<S2SV> ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || //<S2SV> ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { //<S2SV> error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 