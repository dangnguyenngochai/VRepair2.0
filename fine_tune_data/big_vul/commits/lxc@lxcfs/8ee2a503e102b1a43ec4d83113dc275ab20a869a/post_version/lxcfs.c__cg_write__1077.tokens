int cg_write ( const char * path , const char * buf , size_t size , off_t offset , //<S2SV> struct fuse_file_info * fi ) //<S2SV> { //<S2SV> struct fuse_context * fc = fuse_get_context ( ) ; //<S2SV> char * localbuf = NULL ; //<S2SV> struct cgfs_files * k = NULL ; //<S2SV> struct file_info * f = ( struct file_info * ) fi -> fh ; //<S2SV> bool r ; //<S2SV> if ( f -> type != LXC_TYPE_CGFILE ) { //<S2SV> fprintf ( stderr , "Internal<S2SV_blank>error:<S2SV_blank>directory<S2SV_blank>cache<S2SV_blank>info<S2SV_blank>used<S2SV_blank>in<S2SV_blank>cg_write\\n" ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> if ( offset ) //<S2SV> return 0 ; //<S2SV> if ( ! fc ) //<S2SV> return - EIO ; //<S2SV> localbuf = alloca ( size + 1 ) ; //<S2SV> localbuf [ size ] = '\\0' ; //<S2SV> memcpy ( localbuf , buf , size ) ; //<S2SV> if ( ( k = cgfs_get_key ( f -> controller , f -> cgroup , f -> file ) ) == NULL ) { //<S2SV> size = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! fc_may_access ( fc , f -> controller , f -> cgroup , f -> file , O_WRONLY ) ) { //<S2SV> size = - EACCES ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( strcmp ( f -> file , "tasks" ) == 0 || //<S2SV> strcmp ( f -> file , "/tasks" ) == 0 || //<S2SV> strcmp ( f -> file , "/cgroup.procs" ) == 0 || //<S2SV> strcmp ( f -> file , "cgroup.procs" ) == 0 ) //<S2SV> r = do_write_pids ( fc -> pid , fc -> uid , f -> controller , f -> cgroup , f -> file , localbuf ) ; //<S2SV> else //<S2SV> r = cgfs_set_value ( f -> controller , f -> cgroup , f -> file , localbuf ) ; //<S2SV> if ( ! r ) //<S2SV> size = - EINVAL ; //<S2SV> out : //<S2SV> free_key ( k ) ; //<S2SV> return size ; //<S2SV> } //<S2SV> 