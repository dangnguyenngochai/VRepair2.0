static int cg_open ( const char * path , struct fuse_file_info * fi ) //<S2SV> { //<S2SV> const char * cgroup ; //<S2SV> char * fpath = NULL , * path1 , * path2 , * cgdir = NULL , * controller ; //<S2SV> struct cgfs_files * k = NULL ; //<S2SV> struct file_info * file_info ; //<S2SV> struct fuse_context * fc = fuse_get_context ( ) ; //<S2SV> int ret ; //<S2SV> if ( ! fc ) //<S2SV> return - EIO ; //<S2SV> controller = pick_controller_from_path ( fc , path ) ; //<S2SV> if ( ! controller ) //<S2SV> return - EIO ; //<S2SV> cgroup = find_cgroup_in_path ( path ) ; //<S2SV> if ( ! cgroup ) //<S2SV> return - EINVAL ; //<S2SV> get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; //<S2SV> if ( ! fpath ) { //<S2SV> path1 = "/" ; //<S2SV> path2 = cgdir ; //<S2SV> } else { //<S2SV> path1 = cgdir ; //<S2SV> path2 = fpath ; //<S2SV> } //<S2SV> k = cgfs_get_key ( controller , path1 , path2 ) ; //<S2SV> if ( ! k ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> free_key ( k ) ; //<S2SV> if ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) { //<S2SV> ret = - ENOENT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! fc_may_access ( fc , controller , path1 , path2 , fi -> flags ) ) { //<S2SV> ret = - EACCES ; //<S2SV> goto out ; //<S2SV> } //<S2SV> file_info = malloc ( sizeof ( * file_info ) ) ; //<S2SV> if ( ! file_info ) { //<S2SV> ret = - ENOMEM ; //<S2SV> goto out ; //<S2SV> } //<S2SV> file_info -> controller = must_copy_string ( controller ) ; //<S2SV> file_info -> cgroup = must_copy_string ( path1 ) ; //<S2SV> file_info -> file = must_copy_string ( path2 ) ; //<S2SV> file_info -> type = LXC_TYPE_CGFILE ; //<S2SV> file_info -> buf = NULL ; //<S2SV> file_info -> buflen = 0 ; //<S2SV> fi -> fh = ( unsigned long ) file_info ; //<S2SV> ret = 0 ; //<S2SV> out : //<S2SV> free ( cgdir ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 