static int cg_rmdir ( const char * path ) //<S2SV> { //<S2SV> struct fuse_context * fc = fuse_get_context ( ) ; //<S2SV> char * fpath = NULL , * cgdir = NULL , * controller , * next = NULL ; //<S2SV> const char * cgroup ; //<S2SV> int ret ; //<S2SV> if ( ! fc ) //<S2SV> return - EIO ; //<S2SV> controller = pick_controller_from_path ( fc , path ) ; //<S2SV> if ( ! controller ) //<S2SV> return - EINVAL ; //<S2SV> cgroup = find_cgroup_in_path ( path ) ; //<S2SV> if ( ! cgroup ) //<S2SV> return - EINVAL ; //<S2SV> get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; //<S2SV> if ( ! fpath ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , & next ) ) { //<S2SV> if ( ! fpath || strcmp ( next , fpath ) == 0 ) //<S2SV> ret = - EBUSY ; //<S2SV> else //<S2SV> ret = - ENOENT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { //<S2SV> ret = - EACCES ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { //<S2SV> ret = - EACCES ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! cgfs_remove ( controller , cgroup ) ) { //<S2SV> ret = - EINVAL ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = 0 ; //<S2SV> out : //<S2SV> free ( cgdir ) ; //<S2SV> free ( next ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 