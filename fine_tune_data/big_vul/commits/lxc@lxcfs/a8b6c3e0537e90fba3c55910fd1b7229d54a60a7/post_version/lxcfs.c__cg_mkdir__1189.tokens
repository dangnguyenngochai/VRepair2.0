int cg_mkdir ( const char * path , mode_t mode ) //<S2SV> { //<S2SV> struct fuse_context * fc = fuse_get_context ( ) ; //<S2SV> char * fpath = NULL , * path1 , * cgdir = NULL , * controller , * next = NULL ; //<S2SV> const char * cgroup ; //<S2SV> int ret ; //<S2SV> if ( ! fc ) //<S2SV> return - EIO ; //<S2SV> controller = pick_controller_from_path ( fc , path ) ; //<S2SV> if ( ! controller ) //<S2SV> return - EINVAL ; //<S2SV> cgroup = find_cgroup_in_path ( path ) ; //<S2SV> if ( ! cgroup ) //<S2SV> return - EINVAL ; //<S2SV> get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; //<S2SV> if ( ! fpath ) //<S2SV> path1 = "/" ; //<S2SV> else //<S2SV> path1 = cgdir ; //<S2SV> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next ) ) { //<S2SV> if ( fpath && strcmp ( next , fpath ) == 0 ) //<S2SV> ret = - EEXIST ; //<S2SV> else //<S2SV> ret = - ENOENT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { //<S2SV> ret = - EACCES ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { //<S2SV> ret = - EACCES ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = cgfs_create ( controller , cgroup , fc -> uid , fc -> gid ) ; //<S2SV> printf ( "cgfs_create<S2SV_blank>returned<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>%s\\n" , ret , controller , cgroup ) ; //<S2SV> out : //<S2SV> free ( cgdir ) ; //<S2SV> free ( next ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 