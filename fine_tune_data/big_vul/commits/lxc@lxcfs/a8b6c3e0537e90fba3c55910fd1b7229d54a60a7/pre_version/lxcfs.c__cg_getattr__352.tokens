static int cg_getattr ( const char * path , struct stat * sb ) //<S2SV> { //<S2SV> struct timespec now ; //<S2SV> struct fuse_context * fc = fuse_get_context ( ) ; //<S2SV> char * cgdir = NULL ; //<S2SV> char * fpath = NULL , * path1 , * path2 ; //<S2SV> struct cgfs_files * k = NULL ; //<S2SV> const char * cgroup ; //<S2SV> const char * controller = NULL ; //<S2SV> int ret = - ENOENT ; //<S2SV> if ( ! fc ) //<S2SV> return - EIO ; //<S2SV> memset ( sb , 0 , sizeof ( struct stat ) ) ; //<S2SV> if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) //<S2SV> return - EINVAL ; //<S2SV> sb -> st_uid = sb -> st_gid = 0 ; //<S2SV> sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; //<S2SV> sb -> st_size = 0 ; //<S2SV> if ( strcmp ( path , "/cgroup" ) == 0 ) { //<S2SV> sb -> st_mode = S_IFDIR | 00755 ; //<S2SV> sb -> st_nlink = 2 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> controller = pick_controller_from_path ( fc , path ) ; //<S2SV> if ( ! controller ) //<S2SV> return - EIO ; //<S2SV> cgroup = find_cgroup_in_path ( path ) ; //<S2SV> if ( ! cgroup ) { //<S2SV> sb -> st_mode = S_IFDIR | 00755 ; //<S2SV> sb -> st_nlink = 2 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; //<S2SV> if ( ! fpath ) { //<S2SV> path1 = "/" ; //<S2SV> path2 = cgdir ; //<S2SV> } else { //<S2SV> path1 = cgdir ; //<S2SV> path2 = fpath ; //<S2SV> } //<S2SV> if ( is_child_cgroup ( controller , path1 , path2 ) ) { //<S2SV> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { //<S2SV> sb -> st_mode = S_IFDIR | 00555 ; //<S2SV> sb -> st_nlink = 2 ; //<S2SV> ret = 0 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { //<S2SV> ret = - EACCES ; //<S2SV> goto out ; //<S2SV> } //<S2SV> sb -> st_mode = S_IFDIR | 00755 ; //<S2SV> k = cgfs_get_key ( controller , cgroup , "tasks" ) ; //<S2SV> if ( ! k ) { //<S2SV> sb -> st_uid = sb -> st_gid = 0 ; //<S2SV> } else { //<S2SV> sb -> st_uid = k -> uid ; //<S2SV> sb -> st_gid = k -> gid ; //<S2SV> } //<S2SV> free_key ( k ) ; //<S2SV> sb -> st_nlink = 2 ; //<S2SV> ret = 0 ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { //<S2SV> sb -> st_mode = S_IFREG | k -> mode ; //<S2SV> sb -> st_nlink = 1 ; //<S2SV> sb -> st_uid = k -> uid ; //<S2SV> sb -> st_gid = k -> gid ; //<S2SV> sb -> st_size = 0 ; //<S2SV> free_key ( k ) ; //<S2SV> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { //<S2SV> ret = - ENOENT ; //<S2SV> goto out ; //<S2SV> } //<S2SV> if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { //<S2SV> ret = - EACCES ; //<S2SV> goto out ; //<S2SV> } //<S2SV> ret = 0 ; //<S2SV> } //<S2SV> out : //<S2SV> free ( cgdir ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 