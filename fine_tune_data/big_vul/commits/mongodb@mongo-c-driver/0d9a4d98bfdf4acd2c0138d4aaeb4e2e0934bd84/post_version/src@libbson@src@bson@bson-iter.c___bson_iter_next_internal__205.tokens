static bool //<S2SV> _bson_iter_next_internal ( bson_iter_t * iter , //<S2SV> uint32_t next_keylen , //<S2SV> const char * * key , //<S2SV> uint32_t * bson_type , //<S2SV> bool * unsupported ) //<S2SV> { //<S2SV> const uint8_t * data ; //<S2SV> uint32_t o ; //<S2SV> unsigned int len ; //<S2SV> BSON_ASSERT ( iter ) ; //<S2SV> * unsupported = false ; //<S2SV> if ( ! iter -> raw ) { //<S2SV> * key = NULL ; //<S2SV> * bson_type = BSON_TYPE_EOD ; //<S2SV> return false ; //<S2SV> } //<S2SV> data = iter -> raw ; //<S2SV> len = iter -> len ; //<S2SV> iter -> off = iter -> next_off ; //<S2SV> iter -> type = iter -> off ; //<S2SV> iter -> key = iter -> off + 1 ; //<S2SV> iter -> d1 = 0 ; //<S2SV> iter -> d2 = 0 ; //<S2SV> iter -> d3 = 0 ; //<S2SV> iter -> d4 = 0 ; //<S2SV> if ( next_keylen == 0 ) { //<S2SV> for ( o = iter -> key ; o < len ; o ++ ) { //<S2SV> if ( ! data [ o ] ) { //<S2SV> iter -> d1 = ++ o ; //<S2SV> goto fill_data_fields ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> o = iter -> key + next_keylen + 1 ; //<S2SV> iter -> d1 = o ; //<S2SV> goto fill_data_fields ; //<S2SV> } //<S2SV> goto mark_invalid ; //<S2SV> fill_data_fields : //<S2SV> * key = bson_iter_key_unsafe ( iter ) ; //<S2SV> * bson_type = ITER_TYPE ( iter ) ; //<S2SV> switch ( * bson_type ) { //<S2SV> case BSON_TYPE_DATE_TIME : //<S2SV> case BSON_TYPE_DOUBLE : //<S2SV> case BSON_TYPE_INT64 : //<S2SV> case BSON_TYPE_TIMESTAMP : //<S2SV> iter -> next_off = o + 8 ; //<S2SV> break ; //<S2SV> case BSON_TYPE_CODE : //<S2SV> case BSON_TYPE_SYMBOL : //<S2SV> case BSON_TYPE_UTF8 : { //<S2SV> uint32_t l ; //<S2SV> if ( ( o + 4 ) >= len ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> d2 = o + 4 ; //<S2SV> memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; //<S2SV> l = BSON_UINT32_FROM_LE ( l ) ; //<S2SV> if ( l > ( len - ( o + 4 ) ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> next_off = o + 4 + l ; //<S2SV> if ( BSON_UNLIKELY ( ( l == 0 ) || ( iter -> next_off >= len ) ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> if ( BSON_UNLIKELY ( ( iter -> raw + iter -> d2 ) [ l - 1 ] != '\\0' ) ) { //<S2SV> iter -> err_off = o + 4 + l - 1 ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> } break ; //<S2SV> case BSON_TYPE_BINARY : { //<S2SV> bson_subtype_t subtype ; //<S2SV> uint32_t l ; //<S2SV> if ( o >= ( len - 4 ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> d2 = o + 4 ; //<S2SV> iter -> d3 = o + 5 ; //<S2SV> memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; //<S2SV> l = BSON_UINT32_FROM_LE ( l ) ; //<S2SV> if ( l >= ( len - o - 4 ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> subtype = * ( iter -> raw + iter -> d2 ) ; //<S2SV> if ( subtype == BSON_SUBTYPE_BINARY_DEPRECATED ) { //<S2SV> int32_t binary_len ; //<S2SV> if ( l < 4 ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> memcpy ( & binary_len , ( iter -> raw + iter -> d3 ) , sizeof ( binary_len ) ) ; //<S2SV> binary_len = BSON_UINT32_FROM_LE ( binary_len ) ; //<S2SV> if ( binary_len + 4 != l ) { //<S2SV> iter -> err_off = iter -> d3 ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> } //<S2SV> iter -> next_off = o + 5 + l ; //<S2SV> } break ; //<S2SV> case BSON_TYPE_ARRAY : //<S2SV> case BSON_TYPE_DOCUMENT : { //<S2SV> uint32_t l ; //<S2SV> if ( o >= ( len - 4 ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; //<S2SV> l = BSON_UINT32_FROM_LE ( l ) ; //<S2SV> if ( ( l > len ) || ( l > ( len - o ) ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> next_off = o + l ; //<S2SV> } break ; //<S2SV> case BSON_TYPE_OID : //<S2SV> iter -> next_off = o + 12 ; //<S2SV> break ; //<S2SV> case BSON_TYPE_BOOL : { //<S2SV> char val ; //<S2SV> if ( iter -> d1 >= len ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> memcpy ( & val , iter -> raw + iter -> d1 , 1 ) ; //<S2SV> if ( val != 0x00 && val != 0x01 ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> next_off = o + 1 ; //<S2SV> } break ; //<S2SV> case BSON_TYPE_REGEX : { //<S2SV> bool eor = false ; //<S2SV> bool eoo = false ; //<S2SV> for ( ; o < len ; o ++ ) { //<S2SV> if ( ! data [ o ] ) { //<S2SV> iter -> d2 = ++ o ; //<S2SV> eor = true ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! eor ) { //<S2SV> iter -> err_off = iter -> next_off ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> for ( ; o < len ; o ++ ) { //<S2SV> if ( ! data [ o ] ) { //<S2SV> eoo = true ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! eoo ) { //<S2SV> iter -> err_off = iter -> next_off ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> next_off = o + 1 ; //<S2SV> } break ; //<S2SV> case BSON_TYPE_DBPOINTER : { //<S2SV> uint32_t l ; //<S2SV> if ( o >= ( len - 4 ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> d2 = o + 4 ; //<S2SV> memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; //<S2SV> l = BSON_UINT32_FROM_LE ( l ) ; //<S2SV> if ( l == 0 || l > ( len - o - 4 ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> if ( * ( iter -> raw + o + l + 3 ) ) { //<S2SV> iter -> err_off = o + l + 3 ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> d3 = o + 4 + l ; //<S2SV> iter -> next_off = o + 4 + l + 12 ; //<S2SV> } break ; //<S2SV> case BSON_TYPE_CODEWSCOPE : { //<S2SV> uint32_t l ; //<S2SV> uint32_t doclen ; //<S2SV> if ( ( len < 19 ) || ( o >= ( len - 14 ) ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> d2 = o + 4 ; //<S2SV> iter -> d3 = o + 8 ; //<S2SV> memcpy ( & l , iter -> raw + iter -> d1 , sizeof ( l ) ) ; //<S2SV> l = BSON_UINT32_FROM_LE ( l ) ; //<S2SV> if ( ( l < 14 ) || ( l >= ( len - o ) ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> next_off = o + l ; //<S2SV> if ( iter -> next_off >= len ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> memcpy ( & l , iter -> raw + iter -> d2 , sizeof ( l ) ) ; //<S2SV> l = BSON_UINT32_FROM_LE ( l ) ; //<S2SV> if ( l == 0 || l >= ( len - o - 4 - 4 ) ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> if ( ( o + 4 + 4 + l + 4 ) >= iter -> next_off ) { //<S2SV> iter -> err_off = o + 4 ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> d4 = o + 4 + 4 + l ; //<S2SV> memcpy ( & doclen , iter -> raw + iter -> d4 , sizeof ( doclen ) ) ; //<S2SV> doclen = BSON_UINT32_FROM_LE ( doclen ) ; //<S2SV> if ( ( o + 4 + 4 + l + doclen ) != iter -> next_off ) { //<S2SV> iter -> err_off = o + 4 + 4 + l ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> } break ; //<S2SV> case BSON_TYPE_INT32 : //<S2SV> iter -> next_off = o + 4 ; //<S2SV> break ; //<S2SV> case BSON_TYPE_DECIMAL128 : //<S2SV> iter -> next_off = o + 16 ; //<S2SV> break ; //<S2SV> case BSON_TYPE_MAXKEY : //<S2SV> case BSON_TYPE_MINKEY : //<S2SV> case BSON_TYPE_NULL : //<S2SV> case BSON_TYPE_UNDEFINED : //<S2SV> iter -> next_off = o ; //<S2SV> break ; //<S2SV> default : //<S2SV> * unsupported = true ; //<S2SV> case BSON_TYPE_EOD : //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> if ( iter -> next_off >= len ) { //<S2SV> iter -> err_off = o ; //<S2SV> goto mark_invalid ; //<S2SV> } //<S2SV> iter -> err_off = 0 ; //<S2SV> return true ; //<S2SV> mark_invalid : //<S2SV> iter -> raw = NULL ; //<S2SV> iter -> len = 0 ; //<S2SV> iter -> next_off = 0 ; //<S2SV> return false ; //<S2SV> } //<S2SV> 