static void //<S2SV> test_bson_validate ( void ) //<S2SV> { //<S2SV> char filename [ 64 ] ; //<S2SV> size_t offset ; //<S2SV> bson_t * b ; //<S2SV> int i ; //<S2SV> bson_error_t error ; //<S2SV> for ( i = 1 ; i <= 38 ; i ++ ) { //<S2SV> bson_snprintf ( filename , sizeof filename , "test%u.bson" , i ) ; //<S2SV> b = get_bson ( filename ) ; //<S2SV> BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; //<S2SV> bson_destroy ( b ) ; //<S2SV> } //<S2SV> b = get_bson ( "codewscope.bson" ) ; //<S2SV> BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; //<S2SV> bson_destroy ( b ) ; //<S2SV> b = get_bson ( "empty_key.bson" ) ; //<S2SV> BSON_ASSERT ( bson_validate ( b , //<S2SV> BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | //<S2SV> BSON_VALIDATE_DOLLAR_KEYS | //<S2SV> BSON_VALIDATE_DOT_KEYS , //<S2SV> & offset ) ) ; //<S2SV> bson_destroy ( b ) ; //<S2SV> # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) //<S2SV> VALIDATE_TEST ( "overflow2.bson" , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> 9 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( "trailingnull.bson" , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> 14 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( "dollarquery.bson" , //<S2SV> BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , //<S2SV> 4 , //<S2SV> BSON_VALIDATE_DOLLAR_KEYS , //<S2SV> "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$query\\"" ) ; //<S2SV> VALIDATE_TEST ( "dotquery.bson" , //<S2SV> BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , //<S2SV> 4 , //<S2SV> BSON_VALIDATE_DOT_KEYS , //<S2SV> "keys<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\\".\\":<S2SV_blank>\\"abc.def\\"" ) ; //<S2SV> VALIDATE_TEST ( "overflow3.bson" , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> 9 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( "overflow3.bson" , //<S2SV> BSON_VALIDATE_UTF8 , //<S2SV> 9 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( "overflow4.bson" , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> 9 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( "empty_key.bson" , //<S2SV> BSON_VALIDATE_EMPTY_KEYS , //<S2SV> 4 , //<S2SV> BSON_VALIDATE_EMPTY_KEYS , //<S2SV> "empty<S2SV_blank>key" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test40.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test41.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test42.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test43.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test44.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test45.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test46.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test47.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test48.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test49.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( "test50.bson" , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> 10 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>code-with-scope" ) ; //<S2SV> VALIDATE_TEST ( "test51.bson" , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> 10 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>code-with-scope" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test52.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( //<S2SV> "test53.bson" , BSON_VALIDATE_NONE , 6 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( "test54.bson" , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> 12 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>BSON" ) ; //<S2SV> VALIDATE_TEST ( "test59.bson" , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> 9 , //<S2SV> BSON_VALIDATE_NONE , //<S2SV> "corrupt<S2SV_blank>BSON" ) ; //<S2SV> b = BCON_NEW ( "my_dbref" , //<S2SV> "{" , //<S2SV> "$ref" , //<S2SV> BCON_UTF8 ( "collection" ) , //<S2SV> "$id" , //<S2SV> BCON_INT32 ( 1 ) , //<S2SV> "}" ) ; //<S2SV> BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; //<S2SV> BSON_ASSERT ( //<S2SV> bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; //<S2SV> bson_destroy ( b ) ; //<S2SV> b = BCON_NEW ( "my_dbref" , "{" , "$id" , BCON_INT32 ( 1 ) , "}" ) ; //<S2SV> BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; //<S2SV> BSON_ASSERT ( //<S2SV> ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; //<S2SV> ASSERT_ERROR_CONTAINS ( error , //<S2SV> BSON_ERROR_INVALID , //<S2SV> BSON_VALIDATE_DOLLAR_KEYS , //<S2SV> "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$id\\"" ) ; //<S2SV> bson_destroy ( b ) ; //<S2SV> b = BCON_NEW ( "my_dbref" , //<S2SV> "{" , //<S2SV> "$ref" , //<S2SV> BCON_UTF8 ( "collection" ) , //<S2SV> "$ref" , //<S2SV> BCON_UTF8 ( "collection" ) , //<S2SV> "}" ) ; //<S2SV> BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; //<S2SV> BSON_ASSERT ( //<S2SV> ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; //<S2SV> ASSERT_ERROR_CONTAINS ( error , //<S2SV> BSON_ERROR_INVALID , //<S2SV> BSON_VALIDATE_DOLLAR_KEYS , //<S2SV> "keys<S2SV_blank>cannot<S2SV_blank>begin<S2SV_blank>with<S2SV_blank>\\"$\\":<S2SV_blank>\\"$ref\\"" ) ; //<S2SV> bson_destroy ( b ) ; //<S2SV> b = BCON_NEW ( "my_dbref" , //<S2SV> "{" , //<S2SV> "$ref" , //<S2SV> BCON_UTF8 ( "collection" ) , //<S2SV> "extra" , //<S2SV> BCON_INT32 ( 2 ) , //<S2SV> "$id" , //<S2SV> BCON_INT32 ( 1 ) , //<S2SV> "}" ) ; //<S2SV> BSON_ASSERT ( bson_validate_with_error ( b , BSON_VALIDATE_NONE , & error ) ) ; //<S2SV> BSON_ASSERT ( //<S2SV> ! bson_validate_with_error ( b , BSON_VALIDATE_DOLLAR_KEYS , & error ) ) ; //<S2SV> ASSERT_ERROR_CONTAINS ( error , //<S2SV> BSON_ERROR_INVALID , //<S2SV> BSON_VALIDATE_DOLLAR_KEYS , //<S2SV> "invalid<S2SV_blank>key<S2SV_blank>within<S2SV_blank>DBRef<S2SV_blank>subdocument:<S2SV_blank>\\"extra\\"" ) ; //<S2SV> bson_destroy ( b ) ; //<S2SV> # undef VALIDATE_TEST //<S2SV> } //<S2SV> 