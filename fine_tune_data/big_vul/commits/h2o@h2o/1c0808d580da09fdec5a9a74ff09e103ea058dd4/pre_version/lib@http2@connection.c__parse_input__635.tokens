static void parse_input ( h2o_http2_conn_t * conn ) //<S2SV> { //<S2SV> size_t http2_max_concurrent_requests_per_connection = conn -> super . ctx -> globalconf -> http2 . max_concurrent_requests_per_connection ; //<S2SV> int perform_early_exit = 0 ; //<S2SV> if ( conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed != http2_max_concurrent_requests_per_connection ) //<S2SV> perform_early_exit = 1 ; //<S2SV> while ( conn -> state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn -> sock -> input -> size != 0 ) { //<S2SV> if ( perform_early_exit == 1 && //<S2SV> conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed == http2_max_concurrent_requests_per_connection ) //<S2SV> goto EarlyExit ; //<S2SV> const char * err_desc = NULL ; //<S2SV> ssize_t ret = conn -> _read_expect ( conn , ( uint8_t * ) conn -> sock -> input -> bytes , conn -> sock -> input -> size , & err_desc ) ; //<S2SV> if ( ret == H2O_HTTP2_ERROR_INCOMPLETE ) { //<S2SV> break ; //<S2SV> } else if ( ret < 0 ) { //<S2SV> if ( ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY ) { //<S2SV> enqueue_goaway ( conn , ( int ) ret , //<S2SV> err_desc != NULL ? ( h2o_iovec_t ) { ( char * ) err_desc , strlen ( err_desc ) } : ( h2o_iovec_t ) { } ) ; //<S2SV> } //<S2SV> close_connection ( conn ) ; //<S2SV> return ; //<S2SV> } //<S2SV> h2o_buffer_consume ( & conn -> sock -> input , ret ) ; //<S2SV> } //<S2SV> if ( ! h2o_socket_is_reading ( conn -> sock ) ) //<S2SV> h2o_socket_read_start ( conn -> sock , on_read ) ; //<S2SV> return ; //<S2SV> EarlyExit : //<S2SV> if ( h2o_socket_is_reading ( conn -> sock ) ) //<S2SV> h2o_socket_read_stop ( conn -> sock ) ; //<S2SV> } //<S2SV> 