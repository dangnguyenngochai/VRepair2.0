opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , //<S2SV> opj_cp_t * p_cp , //<S2SV> OPJ_UINT32 p_tile_no ) //<S2SV> { //<S2SV> OPJ_UINT32 pino ; //<S2SV> OPJ_UINT32 compno , resno ; //<S2SV> OPJ_UINT32 * l_tmp_data ; //<S2SV> OPJ_UINT32 * * l_tmp_ptr ; //<S2SV> OPJ_UINT32 l_max_res ; //<S2SV> OPJ_UINT32 l_max_prec ; //<S2SV> OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; //<S2SV> OPJ_UINT32 l_dx_min , l_dy_min ; //<S2SV> OPJ_UINT32 l_bound ; //<S2SV> OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; //<S2SV> OPJ_UINT32 l_data_stride ; //<S2SV> opj_pi_iterator_t * l_pi = 00 ; //<S2SV> opj_tcp_t * l_tcp = 00 ; //<S2SV> const opj_tccp_t * l_tccp = 00 ; //<S2SV> opj_pi_comp_t * l_current_comp = 00 ; //<S2SV> opj_image_comp_t * l_img_comp = 00 ; //<S2SV> opj_pi_iterator_t * l_current_pi = 00 ; //<S2SV> OPJ_UINT32 * l_encoding_value_ptr = 00 ; //<S2SV> assert ( p_cp != 00 ) ; //<S2SV> assert ( p_image != 00 ) ; //<S2SV> assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; //<S2SV> l_tcp = & p_cp -> tcps [ p_tile_no ] ; //<S2SV> l_bound = l_tcp -> numpocs + 1 ; //<S2SV> l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; //<S2SV> l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( //<S2SV> l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; //<S2SV> if //<S2SV> ( ! l_tmp_data ) //<S2SV> { //<S2SV> return 00 ; //<S2SV> } //<S2SV> l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( //<S2SV> p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; //<S2SV> if //<S2SV> ( ! l_tmp_ptr ) //<S2SV> { //<S2SV> opj_free ( l_tmp_data ) ; //<S2SV> return 00 ; //<S2SV> } //<S2SV> l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; //<S2SV> if ( ! l_pi ) { //<S2SV> opj_free ( l_tmp_data ) ; //<S2SV> opj_free ( l_tmp_ptr ) ; //<S2SV> return 00 ; //<S2SV> } //<S2SV> l_encoding_value_ptr = l_tmp_data ; //<S2SV> for //<S2SV> ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) //<S2SV> { //<S2SV> l_tmp_ptr [ compno ] = l_encoding_value_ptr ; //<S2SV> l_encoding_value_ptr += l_data_stride ; //<S2SV> } //<S2SV> opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; //<S2SV> l_step_p = 1 ; //<S2SV> l_step_c = l_max_prec * l_step_p ; //<S2SV> l_step_r = p_image -> numcomps * l_step_c ; //<S2SV> l_step_l = l_max_res * l_step_r ; //<S2SV> l_current_pi = l_pi ; //<S2SV> l_current_pi -> include = 00 ; //<S2SV> if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) //<S2SV> { //<S2SV> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; //<S2SV> } //<S2SV> if //<S2SV> ( ! l_current_pi -> include ) //<S2SV> { //<S2SV> opj_free ( l_tmp_data ) ; //<S2SV> opj_free ( l_tmp_ptr ) ; //<S2SV> opj_pi_destroy ( l_pi , l_bound ) ; //<S2SV> return 00 ; //<S2SV> } //<S2SV> l_current_comp = l_current_pi -> comps ; //<S2SV> l_img_comp = p_image -> comps ; //<S2SV> l_tccp = l_tcp -> tccps ; //<S2SV> l_current_pi -> tx0 = l_tx0 ; //<S2SV> l_current_pi -> ty0 = l_ty0 ; //<S2SV> l_current_pi -> tx1 = l_tx1 ; //<S2SV> l_current_pi -> ty1 = l_ty1 ; //<S2SV> l_current_pi -> step_p = l_step_p ; //<S2SV> l_current_pi -> step_c = l_step_c ; //<S2SV> l_current_pi -> step_r = l_step_r ; //<S2SV> l_current_pi -> step_l = l_step_l ; //<S2SV> for //<S2SV> ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) //<S2SV> { //<S2SV> opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; //<S2SV> l_encoding_value_ptr = l_tmp_ptr [ compno ] ; //<S2SV> l_current_comp -> dx = l_img_comp -> dx ; //<S2SV> l_current_comp -> dy = l_img_comp -> dy ; //<S2SV> for //<S2SV> ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) //<S2SV> { //<S2SV> l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; //<S2SV> l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; //<S2SV> l_res -> pw = * ( l_encoding_value_ptr ++ ) ; //<S2SV> l_res -> ph = * ( l_encoding_value_ptr ++ ) ; //<S2SV> ++ l_res ; //<S2SV> } //<S2SV> ++ l_current_comp ; //<S2SV> ++ l_img_comp ; //<S2SV> ++ l_tccp ; //<S2SV> } //<S2SV> ++ l_current_pi ; //<S2SV> for ( pino = 1 ; pino < l_bound ; ++ pino ) //<S2SV> { //<S2SV> l_current_comp = l_current_pi -> comps ; //<S2SV> l_img_comp = p_image -> comps ; //<S2SV> l_tccp = l_tcp -> tccps ; //<S2SV> l_current_pi -> tx0 = l_tx0 ; //<S2SV> l_current_pi -> ty0 = l_ty0 ; //<S2SV> l_current_pi -> tx1 = l_tx1 ; //<S2SV> l_current_pi -> ty1 = l_ty1 ; //<S2SV> l_current_pi -> step_p = l_step_p ; //<S2SV> l_current_pi -> step_c = l_step_c ; //<S2SV> l_current_pi -> step_r = l_step_r ; //<S2SV> l_current_pi -> step_l = l_step_l ; //<S2SV> for //<S2SV> ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) //<S2SV> { //<S2SV> opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; //<S2SV> l_encoding_value_ptr = l_tmp_ptr [ compno ] ; //<S2SV> l_current_comp -> dx = l_img_comp -> dx ; //<S2SV> l_current_comp -> dy = l_img_comp -> dy ; //<S2SV> for //<S2SV> ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) //<S2SV> { //<S2SV> l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; //<S2SV> l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; //<S2SV> l_res -> pw = * ( l_encoding_value_ptr ++ ) ; //<S2SV> l_res -> ph = * ( l_encoding_value_ptr ++ ) ; //<S2SV> ++ l_res ; //<S2SV> } //<S2SV> ++ l_current_comp ; //<S2SV> ++ l_img_comp ; //<S2SV> ++ l_tccp ; //<S2SV> } //<S2SV> l_current_pi -> include = ( l_current_pi - 1 ) -> include ; //<S2SV> ++ l_current_pi ; //<S2SV> } //<S2SV> opj_free ( l_tmp_data ) ; //<S2SV> l_tmp_data = 00 ; //<S2SV> opj_free ( l_tmp_ptr ) ; //<S2SV> l_tmp_ptr = 00 ; //<S2SV> if //<S2SV> ( l_tcp -> POC ) //<S2SV> { //<S2SV> opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; //<S2SV> } //<S2SV> return l_pi ; //<S2SV> } //<S2SV> 