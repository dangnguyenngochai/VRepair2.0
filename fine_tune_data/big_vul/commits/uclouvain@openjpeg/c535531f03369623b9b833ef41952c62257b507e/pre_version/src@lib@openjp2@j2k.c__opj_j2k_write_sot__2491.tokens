static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , //<S2SV> OPJ_BYTE * p_data , //<S2SV> OPJ_UINT32 p_total_data_size , //<S2SV> OPJ_UINT32 * p_data_written , //<S2SV> const opj_stream_private_t * p_stream , //<S2SV> opj_event_mgr_t * p_manager //<S2SV> ) //<S2SV> { //<S2SV> assert ( p_j2k != 00 ) ; //<S2SV> assert ( p_manager != 00 ) ; //<S2SV> assert ( p_stream != 00 ) ; //<S2SV> OPJ_UNUSED ( p_stream ) ; //<S2SV> OPJ_UNUSED ( p_manager ) ; //<S2SV> if ( p_total_data_size < 12 ) { //<S2SV> opj_event_msg ( p_manager , EVT_ERROR , //<S2SV> "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n" ) ; //<S2SV> return OPJ_FALSE ; //<S2SV> } //<S2SV> opj_write_bytes ( p_data , J2K_MS_SOT , //<S2SV> 2 ) ; //<S2SV> p_data += 2 ; //<S2SV> opj_write_bytes ( p_data , 10 , //<S2SV> 2 ) ; //<S2SV> p_data += 2 ; //<S2SV> opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , //<S2SV> 2 ) ; //<S2SV> p_data += 2 ; //<S2SV> p_data += 4 ; //<S2SV> opj_write_bytes ( p_data , //<S2SV> p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , //<S2SV> 1 ) ; //<S2SV> ++ p_data ; //<S2SV> opj_write_bytes ( p_data , //<S2SV> p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , //<S2SV> 1 ) ; //<S2SV> ++ p_data ; //<S2SV> # ifdef USE_JPWL //<S2SV> assert ( 0 && "TODO" ) ; //<S2SV> # endif //<S2SV> * p_data_written = 12 ; //<S2SV> return OPJ_TRUE ; //<S2SV> } //<S2SV> 