static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , //<S2SV> opj_tcd_t * p_tile_coder , //<S2SV> OPJ_BYTE * p_data , //<S2SV> OPJ_UINT32 * p_data_written , //<S2SV> OPJ_UINT32 p_total_data_size , //<S2SV> const opj_stream_private_t * p_stream , //<S2SV> opj_event_mgr_t * p_manager //<S2SV> ) //<S2SV> { //<S2SV> opj_codestream_info_t * l_cstr_info = 00 ; //<S2SV> OPJ_UINT32 l_remaining_data ; //<S2SV> assert ( p_j2k != 00 ) ; //<S2SV> assert ( p_manager != 00 ) ; //<S2SV> assert ( p_stream != 00 ) ; //<S2SV> OPJ_UNUSED ( p_stream ) ; //<S2SV> if ( p_total_data_size < 4 ) { //<S2SV> opj_event_msg ( p_manager , EVT_ERROR , //<S2SV> "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n" ) ; //<S2SV> return OPJ_FALSE ; //<S2SV> } //<S2SV> opj_write_bytes ( p_data , J2K_MS_SOD , //<S2SV> 2 ) ; //<S2SV> p_data += 2 ; //<S2SV> l_remaining_data = p_total_data_size - 4 ; //<S2SV> p_tile_coder -> tp_num = //<S2SV> p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; //<S2SV> p_tile_coder -> cur_tp_num = //<S2SV> p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; //<S2SV> # ifdef USE_JPWL //<S2SV> assert ( 0 && "TODO" ) ; //<S2SV> # endif //<S2SV> if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { //<S2SV> p_tile_coder -> tcd_image -> tiles -> packno = 0 ; //<S2SV> if ( l_cstr_info ) { //<S2SV> l_cstr_info -> packno = 0 ; //<S2SV> } //<S2SV> } //<S2SV> * p_data_written = 0 ; //<S2SV> if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , //<S2SV> p_data_written , l_remaining_data , l_cstr_info , //<S2SV> p_manager ) ) { //<S2SV> opj_event_msg ( p_manager , EVT_ERROR , "Cannot<S2SV_blank>encode<S2SV_blank>tile\\n" ) ; //<S2SV> return OPJ_FALSE ; //<S2SV> } //<S2SV> * p_data_written += 2 ; //<S2SV> return OPJ_TRUE ; //<S2SV> } //<S2SV> 