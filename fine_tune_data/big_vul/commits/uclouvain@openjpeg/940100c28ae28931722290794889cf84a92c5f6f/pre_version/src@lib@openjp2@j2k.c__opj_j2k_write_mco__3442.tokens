static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , //<S2SV> struct opj_stream_private * p_stream , //<S2SV> struct opj_event_mgr * p_manager //<S2SV> ) //<S2SV> { //<S2SV> OPJ_BYTE * l_current_data = 00 ; //<S2SV> OPJ_UINT32 l_mco_size ; //<S2SV> opj_tcp_t * l_tcp = 00 ; //<S2SV> opj_simple_mcc_decorrelation_data_t * l_mcc_record ; //<S2SV> OPJ_UINT32 i ; //<S2SV> assert ( p_j2k != 00 ) ; //<S2SV> assert ( p_manager != 00 ) ; //<S2SV> assert ( p_stream != 00 ) ; //<S2SV> l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; //<S2SV> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; //<S2SV> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; //<S2SV> if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { //<S2SV> OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; //<S2SV> if ( ! new_header_tile_data ) { //<S2SV> opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; //<S2SV> p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; //<S2SV> p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; //<S2SV> opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>write<S2SV_blank>MCO<S2SV_blank>marker\\n" ) ; //<S2SV> return OPJ_FALSE ; //<S2SV> } //<S2SV> p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; //<S2SV> p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; //<S2SV> } //<S2SV> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; //<S2SV> l_current_data += 2 ; //<S2SV> opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; //<S2SV> l_current_data += 2 ; //<S2SV> opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; //<S2SV> ++ l_current_data ; //<S2SV> l_mcc_record = l_tcp -> m_mcc_records ; //<S2SV> for ( i = 0 ; i < l_tcp -> m_nb_mcc_records ; ++ i ) { //<S2SV> opj_write_bytes ( l_current_data , l_mcc_record -> m_index , 1 ) ; //<S2SV> ++ l_current_data ; //<S2SV> ++ l_mcc_record ; //<S2SV> } //<S2SV> if ( opj_stream_write_data ( p_stream , p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size , p_manager ) != l_mco_size ) { //<S2SV> return OPJ_FALSE ; //<S2SV> } //<S2SV> return OPJ_TRUE ; //<S2SV> } //<S2SV> 