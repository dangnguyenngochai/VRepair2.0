opj_image_t * bmptoimage ( const char * filename , opj_cparameters_t * parameters ) //<S2SV> { //<S2SV> opj_image_cmptparm_t cmptparm [ 4 ] ; //<S2SV> OPJ_UINT8 lut_R [ 256 ] , lut_G [ 256 ] , lut_B [ 256 ] ; //<S2SV> OPJ_UINT8 const * pLUT [ 3 ] ; //<S2SV> opj_image_t * image = NULL ; //<S2SV> FILE * IN ; //<S2SV> OPJ_BITMAPFILEHEADER File_h ; //<S2SV> OPJ_BITMAPINFOHEADER Info_h ; //<S2SV> OPJ_UINT32 i , palette_len , numcmpts = 1U ; //<S2SV> OPJ_BOOL l_result = OPJ_FALSE ; //<S2SV> OPJ_UINT8 * pData = NULL ; //<S2SV> OPJ_UINT32 stride ; //<S2SV> pLUT [ 0 ] = lut_R ; pLUT [ 1 ] = lut_G ; pLUT [ 2 ] = lut_B ; //<S2SV> IN = fopen ( filename , "rb" ) ; //<S2SV> if ( ! IN ) //<S2SV> { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!!\\n" , filename ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! bmp_read_file_header ( IN , & File_h ) ) { //<S2SV> fclose ( IN ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! bmp_read_info_header ( IN , & Info_h ) ) { //<S2SV> fclose ( IN ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( Info_h . biBitCount <= 8U ) //<S2SV> { //<S2SV> memset ( & lut_R [ 0 ] , 0 , sizeof ( lut_R ) ) ; //<S2SV> memset ( & lut_G [ 0 ] , 0 , sizeof ( lut_G ) ) ; //<S2SV> memset ( & lut_B [ 0 ] , 0 , sizeof ( lut_B ) ) ; //<S2SV> palette_len = Info_h . biClrUsed ; //<S2SV> if ( ( palette_len == 0U ) && ( Info_h . biBitCount <= 8U ) ) { //<S2SV> palette_len = ( 1U << Info_h . biBitCount ) ; //<S2SV> } //<S2SV> if ( palette_len > 256U ) { //<S2SV> palette_len = 256U ; //<S2SV> } //<S2SV> if ( palette_len > 0U ) { //<S2SV> OPJ_UINT8 has_color = 0U ; //<S2SV> for ( i = 0U ; i < palette_len ; i ++ ) { //<S2SV> lut_B [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; //<S2SV> lut_G [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; //<S2SV> lut_R [ i ] = ( OPJ_UINT8 ) getc ( IN ) ; //<S2SV> ( void ) getc ( IN ) ; //<S2SV> has_color |= ( lut_B [ i ] ^ lut_G [ i ] ) | ( lut_G [ i ] ^ lut_R [ i ] ) ; //<S2SV> } //<S2SV> if ( has_color ) { //<S2SV> numcmpts = 3U ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> numcmpts = 3U ; //<S2SV> if ( ( Info_h . biCompression == 3 ) && ( Info_h . biAlphaMask != 0U ) ) { //<S2SV> numcmpts ++ ; //<S2SV> } //<S2SV> } //<S2SV> stride = ( ( Info_h . biWidth * Info_h . biBitCount + 31U ) / 32U ) * 4U ; //<S2SV> if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) { //<S2SV> stride = ( ( Info_h . biWidth * 8U + 31U ) / 32U ) * 4U ; //<S2SV> } //<S2SV> pData = ( OPJ_UINT8 * ) calloc ( 1 , stride * Info_h . biHeight * sizeof ( OPJ_UINT8 ) ) ; //<S2SV> if ( pData == NULL ) { //<S2SV> fclose ( IN ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> fseek ( IN , 0 , SEEK_SET ) ; //<S2SV> fseek ( IN , ( long ) File_h . bfOffBits , SEEK_SET ) ; //<S2SV> switch ( Info_h . biCompression ) { //<S2SV> case 0 : //<S2SV> case 3 : //<S2SV> l_result = bmp_read_raw_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> l_result = bmp_read_rle8_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> l_result = bmp_read_rle4_data ( IN , pData , stride , Info_h . biWidth , Info_h . biHeight ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> fprintf ( stderr , "Unsupported<S2SV_blank>BMP<S2SV_blank>compression\\n" ) ; //<S2SV> l_result = OPJ_FALSE ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! l_result ) { //<S2SV> free ( pData ) ; //<S2SV> fclose ( IN ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> memset ( & cmptparm [ 0 ] , 0 , sizeof ( cmptparm ) ) ; //<S2SV> for ( i = 0 ; i < 4U ; i ++ ) //<S2SV> { //<S2SV> cmptparm [ i ] . prec = 8 ; //<S2SV> cmptparm [ i ] . bpp = 8 ; //<S2SV> cmptparm [ i ] . sgnd = 0 ; //<S2SV> cmptparm [ i ] . dx = ( OPJ_UINT32 ) parameters -> subsampling_dx ; //<S2SV> cmptparm [ i ] . dy = ( OPJ_UINT32 ) parameters -> subsampling_dy ; //<S2SV> cmptparm [ i ] . w = Info_h . biWidth ; //<S2SV> cmptparm [ i ] . h = Info_h . biHeight ; //<S2SV> } //<S2SV> image = opj_image_create ( numcmpts , & cmptparm [ 0 ] , ( numcmpts == 1U ) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB ) ; //<S2SV> if ( ! image ) { //<S2SV> fclose ( IN ) ; //<S2SV> free ( pData ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( numcmpts == 4U ) { //<S2SV> image -> comps [ 3 ] . alpha = 1 ; //<S2SV> } //<S2SV> image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; //<S2SV> image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; //<S2SV> image -> x1 = image -> x0 + ( Info_h . biWidth - 1U ) * ( OPJ_UINT32 ) parameters -> subsampling_dx + 1U ; //<S2SV> image -> y1 = image -> y0 + ( Info_h . biHeight - 1U ) * ( OPJ_UINT32 ) parameters -> subsampling_dy + 1U ; //<S2SV> if ( Info_h . biBitCount == 24 && Info_h . biCompression == 0 ) { //<S2SV> bmp24toimage ( pData , stride , image ) ; //<S2SV> } //<S2SV> else if ( Info_h . biBitCount == 8 && Info_h . biCompression == 0 ) { //<S2SV> bmp8toimage ( pData , stride , image , pLUT ) ; //<S2SV> } //<S2SV> else if ( Info_h . biBitCount == 8 && Info_h . biCompression == 1 ) { //<S2SV> bmp8toimage ( pData , stride , image , pLUT ) ; //<S2SV> } //<S2SV> else if ( Info_h . biBitCount == 4 && Info_h . biCompression == 2 ) { //<S2SV> bmp8toimage ( pData , stride , image , pLUT ) ; //<S2SV> } //<S2SV> else if ( Info_h . biBitCount == 32 && Info_h . biCompression == 0 ) { //<S2SV> bmpmask32toimage ( pData , stride , image , 0x00FF0000U , 0x0000FF00U , 0x000000FFU , 0x00000000U ) ; //<S2SV> } //<S2SV> else if ( Info_h . biBitCount == 32 && Info_h . biCompression == 3 ) { //<S2SV> bmpmask32toimage ( pData , stride , image , Info_h . biRedMask , Info_h . biGreenMask , Info_h . biBlueMask , Info_h . biAlphaMask ) ; //<S2SV> } //<S2SV> else if ( Info_h . biBitCount == 16 && Info_h . biCompression == 0 ) { //<S2SV> bmpmask16toimage ( pData , stride , image , 0x7C00U , 0x03E0U , 0x001FU , 0x0000U ) ; //<S2SV> } //<S2SV> else if ( Info_h . biBitCount == 16 && Info_h . biCompression == 3 ) { //<S2SV> if ( ( Info_h . biRedMask == 0U ) && ( Info_h . biGreenMask == 0U ) && ( Info_h . biBlueMask == 0U ) ) { //<S2SV> Info_h . biRedMask = 0xF800U ; //<S2SV> Info_h . biGreenMask = 0x07E0U ; //<S2SV> Info_h . biBlueMask = 0x001FU ; //<S2SV> } //<S2SV> bmpmask16toimage ( pData , stride , image , Info_h . biRedMask , Info_h . biGreenMask , Info_h . biBlueMask , Info_h . biAlphaMask ) ; //<S2SV> } //<S2SV> else { //<S2SV> opj_image_destroy ( image ) ; //<S2SV> image = NULL ; //<S2SV> fprintf ( stderr , "Other<S2SV_blank>system<S2SV_blank>than<S2SV_blank>24<S2SV_blank>bits/pixels<S2SV_blank>or<S2SV_blank>8<S2SV_blank>bits<S2SV_blank>(no<S2SV_blank>RLE<S2SV_blank>coding)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>implemented<S2SV_blank>[%d]\\n" , Info_h . biBitCount ) ; //<S2SV> } //<S2SV> free ( pData ) ; //<S2SV> fclose ( IN ) ; //<S2SV> return image ; //<S2SV> } //<S2SV> 