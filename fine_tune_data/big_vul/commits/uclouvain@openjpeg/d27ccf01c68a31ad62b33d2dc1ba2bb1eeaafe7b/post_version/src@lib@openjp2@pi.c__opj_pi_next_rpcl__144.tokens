static OPJ_BOOL opj_pi_next_rpcl ( opj_pi_iterator_t * pi ) //<S2SV> { //<S2SV> opj_pi_comp_t * comp = NULL ; //<S2SV> opj_pi_resolution_t * res = NULL ; //<S2SV> OPJ_UINT32 index = 0 ; //<S2SV> if ( ! pi -> first ) { //<S2SV> goto LABEL_SKIP ; //<S2SV> } else { //<S2SV> OPJ_UINT32 compno , resno ; //<S2SV> pi -> first = 0 ; //<S2SV> pi -> dx = 0 ; //<S2SV> pi -> dy = 0 ; //<S2SV> for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { //<S2SV> comp = & pi -> comps [ compno ] ; //<S2SV> for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { //<S2SV> OPJ_UINT32 dx , dy ; //<S2SV> res = & comp -> resolutions [ resno ] ; //<S2SV> dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; //<S2SV> dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; //<S2SV> pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; //<S2SV> pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! pi -> tp_on ) { //<S2SV> pi -> poc . ty0 = pi -> ty0 ; //<S2SV> pi -> poc . tx0 = pi -> tx0 ; //<S2SV> pi -> poc . ty1 = pi -> ty1 ; //<S2SV> pi -> poc . tx1 = pi -> tx1 ; //<S2SV> } //<S2SV> for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < pi -> poc . resno1 ; pi -> resno ++ ) { //<S2SV> for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; //<S2SV> pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { //<S2SV> for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; //<S2SV> pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { //<S2SV> for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { //<S2SV> OPJ_UINT32 levelno ; //<S2SV> OPJ_INT32 trx0 , try0 ; //<S2SV> OPJ_INT32 trx1 , try1 ; //<S2SV> OPJ_UINT32 rpx , rpy ; //<S2SV> OPJ_INT32 prci , prcj ; //<S2SV> comp = & pi -> comps [ pi -> compno ] ; //<S2SV> if ( pi -> resno >= comp -> numresolutions ) { //<S2SV> continue ; //<S2SV> } //<S2SV> res = & comp -> resolutions [ pi -> resno ] ; //<S2SV> levelno = comp -> numresolutions - 1 - pi -> resno ; //<S2SV> trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; //<S2SV> try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; //<S2SV> trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; //<S2SV> try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; //<S2SV> rpx = res -> pdx + levelno ; //<S2SV> rpy = res -> pdy + levelno ; //<S2SV> if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || //<S2SV> rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && //<S2SV> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && //<S2SV> ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , //<S2SV> ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) //<S2SV> - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; //<S2SV> prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , //<S2SV> ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) //<S2SV> - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; //<S2SV> pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; //<S2SV> for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { //<S2SV> index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * //<S2SV> pi -> step_c + pi -> precno * pi -> step_p ; //<S2SV> if ( ! pi -> include [ index ] ) { //<S2SV> pi -> include [ index ] = 1 ; //<S2SV> return OPJ_TRUE ; //<S2SV> } //<S2SV> LABEL_SKIP : //<S2SV> ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return OPJ_FALSE ; //<S2SV> } //<S2SV> 