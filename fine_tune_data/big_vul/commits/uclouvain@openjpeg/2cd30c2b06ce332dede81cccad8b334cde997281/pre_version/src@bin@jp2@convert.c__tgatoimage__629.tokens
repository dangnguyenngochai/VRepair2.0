opj_image_t * tgatoimage ( const char * filename , opj_cparameters_t * parameters ) //<S2SV> { //<S2SV> FILE * f ; //<S2SV> opj_image_t * image ; //<S2SV> unsigned int image_width , image_height , pixel_bit_depth ; //<S2SV> unsigned int x , y ; //<S2SV> int flip_image = 0 ; //<S2SV> opj_image_cmptparm_t cmptparm [ 4 ] ; //<S2SV> int numcomps ; //<S2SV> OPJ_COLOR_SPACE color_space ; //<S2SV> OPJ_BOOL mono ; //<S2SV> OPJ_BOOL save_alpha ; //<S2SV> int subsampling_dx , subsampling_dy ; //<S2SV> int i ; //<S2SV> f = fopen ( filename , "rb" ) ; //<S2SV> if ( ! f ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!!\\n" , filename ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! tga_readheader ( f , & pixel_bit_depth , & image_width , & image_height , //<S2SV> & flip_image ) ) { //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! ( ( pixel_bit_depth == 24 ) || ( pixel_bit_depth == 32 ) ) ) { //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> memset ( & cmptparm [ 0 ] , 0 , 4 * sizeof ( opj_image_cmptparm_t ) ) ; //<S2SV> mono = ( pixel_bit_depth == 8 ) || //<S2SV> ( pixel_bit_depth == 16 ) ; //<S2SV> save_alpha = ( pixel_bit_depth == 16 ) || //<S2SV> ( pixel_bit_depth == 32 ) ; //<S2SV> if ( mono ) { //<S2SV> color_space = OPJ_CLRSPC_GRAY ; //<S2SV> numcomps = save_alpha ? 2 : 1 ; //<S2SV> } else { //<S2SV> numcomps = save_alpha ? 4 : 3 ; //<S2SV> color_space = OPJ_CLRSPC_SRGB ; //<S2SV> } //<S2SV> subsampling_dx = parameters -> subsampling_dx ; //<S2SV> subsampling_dy = parameters -> subsampling_dy ; //<S2SV> for ( i = 0 ; i < numcomps ; i ++ ) { //<S2SV> cmptparm [ i ] . prec = 8 ; //<S2SV> cmptparm [ i ] . bpp = 8 ; //<S2SV> cmptparm [ i ] . sgnd = 0 ; //<S2SV> cmptparm [ i ] . dx = ( OPJ_UINT32 ) subsampling_dx ; //<S2SV> cmptparm [ i ] . dy = ( OPJ_UINT32 ) subsampling_dy ; //<S2SV> cmptparm [ i ] . w = image_width ; //<S2SV> cmptparm [ i ] . h = image_height ; //<S2SV> } //<S2SV> image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm [ 0 ] , color_space ) ; //<S2SV> if ( ! image ) { //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; //<S2SV> image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; //<S2SV> image -> x1 = ! image -> x0 ? ( OPJ_UINT32 ) ( image_width - 1 ) * //<S2SV> ( OPJ_UINT32 ) subsampling_dx + 1 : image -> x0 + ( OPJ_UINT32 ) ( image_width - 1 ) * //<S2SV> ( OPJ_UINT32 ) subsampling_dx + 1 ; //<S2SV> image -> y1 = ! image -> y0 ? ( OPJ_UINT32 ) ( image_height - 1 ) * //<S2SV> ( OPJ_UINT32 ) subsampling_dy + 1 : image -> y0 + ( OPJ_UINT32 ) ( image_height - 1 ) * //<S2SV> ( OPJ_UINT32 ) subsampling_dy + 1 ; //<S2SV> for ( y = 0 ; y < image_height ; y ++ ) { //<S2SV> int index ; //<S2SV> if ( flip_image ) { //<S2SV> index = ( int ) ( ( image_height - y - 1 ) * image_width ) ; //<S2SV> } else { //<S2SV> index = ( int ) ( y * image_width ) ; //<S2SV> } //<S2SV> if ( numcomps == 3 ) { //<S2SV> for ( x = 0 ; x < image_width ; x ++ ) { //<S2SV> unsigned char r , g , b ; //<S2SV> if ( ! fread ( & b , 1 , 1 , f ) ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> opj_image_destroy ( image ) ; //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! fread ( & g , 1 , 1 , f ) ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> opj_image_destroy ( image ) ; //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! fread ( & r , 1 , 1 , f ) ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> opj_image_destroy ( image ) ; //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> image -> comps [ 0 ] . data [ index ] = r ; //<S2SV> image -> comps [ 1 ] . data [ index ] = g ; //<S2SV> image -> comps [ 2 ] . data [ index ] = b ; //<S2SV> index ++ ; //<S2SV> } //<S2SV> } else if ( numcomps == 4 ) { //<S2SV> for ( x = 0 ; x < image_width ; x ++ ) { //<S2SV> unsigned char r , g , b , a ; //<S2SV> if ( ! fread ( & b , 1 , 1 , f ) ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> opj_image_destroy ( image ) ; //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! fread ( & g , 1 , 1 , f ) ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> opj_image_destroy ( image ) ; //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! fread ( & r , 1 , 1 , f ) ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> opj_image_destroy ( image ) ; //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( ! fread ( & a , 1 , 1 , f ) ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> opj_image_destroy ( image ) ; //<S2SV> fclose ( f ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> image -> comps [ 0 ] . data [ index ] = r ; //<S2SV> image -> comps [ 1 ] . data [ index ] = g ; //<S2SV> image -> comps [ 2 ] . data [ index ] = b ; //<S2SV> image -> comps [ 3 ] . data [ index ] = a ; //<S2SV> index ++ ; //<S2SV> } //<S2SV> } else { //<S2SV> fprintf ( stderr , "Currently<S2SV_blank>unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>:<S2SV_blank>%s\\n" , filename ) ; //<S2SV> } //<S2SV> } //<S2SV> fclose ( f ) ; //<S2SV> return image ; //<S2SV> } //<S2SV> 