static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , //<S2SV> unsigned int * width , unsigned int * height , int * flip_image ) //<S2SV> { //<S2SV> int palette_size ; //<S2SV> unsigned char tga [ TGA_HEADER_SIZE ] ; //<S2SV> unsigned char id_len , image_type ; //<S2SV> unsigned char pixel_depth , image_desc ; //<S2SV> unsigned short cmap_len , cmap_entry_size ; //<S2SV> unsigned short image_w , image_h ; //<S2SV> if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> id_len = tga [ 0 ] ; //<S2SV> image_type = tga [ 2 ] ; //<S2SV> cmap_len = get_tga_ushort ( & tga [ 5 ] ) ; //<S2SV> cmap_entry_size = tga [ 7 ] ; //<S2SV> # if 0 //<S2SV> x_origin = get_tga_ushort ( & tga [ 8 ] ) ; //<S2SV> y_origin = get_tga_ushort ( & tga [ 10 ] ) ; //<S2SV> # endif //<S2SV> image_w = get_tga_ushort ( & tga [ 12 ] ) ; //<S2SV> image_h = get_tga_ushort ( & tga [ 14 ] ) ; //<S2SV> pixel_depth = tga [ 16 ] ; //<S2SV> image_desc = tga [ 17 ] ; //<S2SV> * bits_per_pixel = ( unsigned int ) pixel_depth ; //<S2SV> * width = ( unsigned int ) image_w ; //<S2SV> * height = ( unsigned int ) image_h ; //<S2SV> if ( id_len ) { //<S2SV> unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; //<S2SV> if ( id == 0 ) { //<S2SV> fprintf ( stderr , "tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! fread ( id , id_len , 1 , fp ) ) { //<S2SV> fprintf ( stderr , //<S2SV> "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; //<S2SV> free ( id ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> free ( id ) ; //<S2SV> } //<S2SV> if ( image_type > 8 ) { //<S2SV> fprintf ( stderr , "Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> * flip_image = ! ( image_desc & 32 ) ; //<S2SV> palette_size = cmap_len * ( cmap_entry_size / 8 ) ; //<S2SV> if ( palette_size > 0 ) { //<S2SV> fprintf ( stderr , "File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported." ) ; //<S2SV> fseek ( fp , palette_size , SEEK_CUR ) ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> } //<S2SV> 