static pngquant_error rwpng_read_image24_libpng ( FILE * infile , png24_image * mainprog_ptr , int verbose ) //<S2SV> { //<S2SV> png_structp png_ptr = NULL ; //<S2SV> png_infop info_ptr = NULL ; //<S2SV> png_size_t rowbytes ; //<S2SV> int color_type , bit_depth ; //<S2SV> png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , //<S2SV> rwpng_error_handler , verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler ) ; //<S2SV> if ( ! png_ptr ) { //<S2SV> return PNG_OUT_OF_MEMORY_ERROR ; //<S2SV> } //<S2SV> info_ptr = png_create_info_struct ( png_ptr ) ; //<S2SV> if ( ! info_ptr ) { //<S2SV> png_destroy_read_struct ( & png_ptr , NULL , NULL ) ; //<S2SV> return PNG_OUT_OF_MEMORY_ERROR ; //<S2SV> } //<S2SV> if ( setjmp ( mainprog_ptr -> jmpbuf ) ) { //<S2SV> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; //<S2SV> return LIBPNG_FATAL_ERROR ; //<S2SV> } //<S2SV> # if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) //<S2SV> png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ; //<S2SV> # endif //<S2SV> # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) //<S2SV> png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) "pHYs\\0iTXt\\0tEXt\\0zTXt" , 4 ) ; //<S2SV> # endif //<S2SV> png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ; //<S2SV> struct rwpng_read_data read_data = { infile , 0 } ; //<S2SV> png_set_read_fn ( png_ptr , & read_data , user_read_data ) ; //<S2SV> png_read_info ( png_ptr , info_ptr ) ; //<S2SV> png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , //<S2SV> & bit_depth , & color_type , NULL , NULL , NULL ) ; //<S2SV> if ( ! ( color_type & PNG_COLOR_MASK_ALPHA ) ) { //<S2SV> # ifdef PNG_READ_FILLER_SUPPORTED //<S2SV> png_set_expand ( png_ptr ) ; //<S2SV> png_set_filler ( png_ptr , 65535L , PNG_FILLER_AFTER ) ; //<S2SV> # else //<S2SV> fprintf ( stderr , "pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>image<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>RGBA<S2SV_blank>nor<S2SV_blank>GA\\n" ) ; //<S2SV> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; //<S2SV> mainprog_ptr -> retval = WRONG_INPUT_COLOR_TYPE ; //<S2SV> return mainprog_ptr -> retval ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( bit_depth == 16 ) { //<S2SV> png_set_strip_16 ( png_ptr ) ; //<S2SV> } //<S2SV> if ( ! ( color_type & PNG_COLOR_MASK_COLOR ) ) { //<S2SV> png_set_gray_to_rgb ( png_ptr ) ; //<S2SV> } //<S2SV> double gamma = 0.45455 ; //<S2SV> if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_sRGB ) ) { //<S2SV> mainprog_ptr -> input_color = RWPNG_SRGB ; //<S2SV> mainprog_ptr -> output_color = RWPNG_SRGB ; //<S2SV> } else { //<S2SV> png_get_gAMA ( png_ptr , info_ptr , & gamma ) ; //<S2SV> if ( gamma > 0 && gamma <= 1.0 ) { //<S2SV> mainprog_ptr -> input_color = RWPNG_GAMA_ONLY ; //<S2SV> mainprog_ptr -> output_color = RWPNG_GAMA_ONLY ; //<S2SV> } else { //<S2SV> fprintf ( stderr , "pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>ignored<S2SV_blank>out-of-range<S2SV_blank>gamma<S2SV_blank>%f\\n" , gamma ) ; //<S2SV> mainprog_ptr -> input_color = RWPNG_NONE ; //<S2SV> mainprog_ptr -> output_color = RWPNG_NONE ; //<S2SV> gamma = 0.45455 ; //<S2SV> } //<S2SV> } //<S2SV> mainprog_ptr -> gamma = gamma ; //<S2SV> png_set_interlace_handling ( png_ptr ) ; //<S2SV> png_read_update_info ( png_ptr , info_ptr ) ; //<S2SV> rowbytes = png_get_rowbytes ( png_ptr , info_ptr ) ; //<S2SV> if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { //<S2SV> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; //<S2SV> return PNG_OUT_OF_MEMORY_ERROR ; //<S2SV> } //<S2SV> if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) { //<S2SV> fprintf ( stderr , "pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\n" ) ; //<S2SV> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; //<S2SV> return PNG_OUT_OF_MEMORY_ERROR ; //<S2SV> } //<S2SV> png_bytepp row_pointers = rwpng_create_row_pointers ( info_ptr , png_ptr , mainprog_ptr -> rgba_data , mainprog_ptr -> height , 0 ) ; //<S2SV> png_read_image ( png_ptr , row_pointers ) ; //<S2SV> png_read_end ( png_ptr , NULL ) ; //<S2SV> # if USE_LCMS //<S2SV> # if PNG_LIBPNG_VER < 10500 //<S2SV> png_charp ProfileData ; //<S2SV> # else //<S2SV> png_bytep ProfileData ; //<S2SV> # endif //<S2SV> png_uint_32 ProfileLen ; //<S2SV> cmsHPROFILE hInProfile = NULL ; //<S2SV> int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR ; //<S2SV> if ( png_get_iCCP ( png_ptr , info_ptr , & ( png_charp ) { 0 } , & ( int ) { 0 } , & ProfileData , & ProfileLen ) ) { //<S2SV> hInProfile = cmsOpenProfileFromMem ( ProfileData , ProfileLen ) ; //<S2SV> cmsColorSpaceSignature colorspace = cmsGetColorSpace ( hInProfile ) ; //<S2SV> if ( colorspace == cmsSigRgbData && COLOR_PNG ) { //<S2SV> mainprog_ptr -> input_color = RWPNG_ICCP ; //<S2SV> mainprog_ptr -> output_color = RWPNG_SRGB ; //<S2SV> } else { //<S2SV> if ( colorspace == cmsSigGrayData && ! COLOR_PNG ) { //<S2SV> mainprog_ptr -> input_color = RWPNG_ICCP_WARN_GRAY ; //<S2SV> mainprog_ptr -> output_color = RWPNG_SRGB ; //<S2SV> } //<S2SV> cmsCloseProfile ( hInProfile ) ; //<S2SV> hInProfile = NULL ; //<S2SV> } //<S2SV> } //<S2SV> if ( hInProfile == NULL && COLOR_PNG && //<S2SV> ! png_get_valid ( png_ptr , info_ptr , PNG_INFO_sRGB ) && //<S2SV> png_get_valid ( png_ptr , info_ptr , PNG_INFO_gAMA ) && //<S2SV> png_get_valid ( png_ptr , info_ptr , PNG_INFO_cHRM ) ) { //<S2SV> cmsCIExyY WhitePoint ; //<S2SV> cmsCIExyYTRIPLE Primaries ; //<S2SV> png_get_cHRM ( png_ptr , info_ptr , & WhitePoint . x , & WhitePoint . y , //<S2SV> & Primaries . Red . x , & Primaries . Red . y , //<S2SV> & Primaries . Green . x , & Primaries . Green . y , //<S2SV> & Primaries . Blue . x , & Primaries . Blue . y ) ; //<S2SV> WhitePoint . Y = Primaries . Red . Y = Primaries . Green . Y = Primaries . Blue . Y = 1.0 ; //<S2SV> cmsToneCurve * GammaTable [ 3 ] ; //<S2SV> GammaTable [ 0 ] = GammaTable [ 1 ] = GammaTable [ 2 ] = cmsBuildGamma ( NULL , 1 / gamma ) ; //<S2SV> hInProfile = cmsCreateRGBProfile ( & WhitePoint , & Primaries , GammaTable ) ; //<S2SV> cmsFreeToneCurve ( GammaTable [ 0 ] ) ; //<S2SV> mainprog_ptr -> input_color = RWPNG_GAMA_CHRM ; //<S2SV> mainprog_ptr -> output_color = RWPNG_SRGB ; //<S2SV> } //<S2SV> if ( hInProfile != NULL ) { //<S2SV> cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile ( ) ; //<S2SV> cmsHTRANSFORM hTransform = cmsCreateTransform ( hInProfile , TYPE_RGBA_8 , //<S2SV> hOutProfile , TYPE_RGBA_8 , //<S2SV> INTENT_PERCEPTUAL , //<S2SV> omp_get_max_threads ( ) > 1 ? cmsFLAGS_NOCACHE : 0 ) ; //<S2SV> # pragma omp parallel for if ( mainprog_ptr -> height * mainprog_ptr -> width > 8000 ) schedule ( static ) //<S2SV> for ( unsigned int i = 0 ; i < mainprog_ptr -> height ; i ++ ) { //<S2SV> cmsDoTransform ( hTransform , row_pointers [ i ] , //<S2SV> row_pointers [ i ] , //<S2SV> mainprog_ptr -> width ) ; //<S2SV> } //<S2SV> cmsDeleteTransform ( hTransform ) ; //<S2SV> cmsCloseProfile ( hOutProfile ) ; //<S2SV> cmsCloseProfile ( hInProfile ) ; //<S2SV> mainprog_ptr -> gamma = 0.45455 ; //<S2SV> } //<S2SV> # endif //<S2SV> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; //<S2SV> mainprog_ptr -> file_size = read_data . bytes_read ; //<S2SV> mainprog_ptr -> row_pointers = ( unsigned char * * ) row_pointers ; //<S2SV> return SUCCESS ; //<S2SV> } //<S2SV> 