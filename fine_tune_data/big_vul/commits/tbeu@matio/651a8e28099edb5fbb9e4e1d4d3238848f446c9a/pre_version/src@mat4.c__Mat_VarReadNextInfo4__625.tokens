matvar_t * //<S2SV> Mat_VarReadNextInfo4 ( mat_t * mat ) //<S2SV> { //<S2SV> int M , O , data_type , class_type ; //<S2SV> mat_int32_t tmp ; //<S2SV> long nBytes ; //<S2SV> size_t readresult ; //<S2SV> matvar_t * matvar = NULL ; //<S2SV> union { //<S2SV> mat_uint32_t u ; //<S2SV> mat_uint8_t c [ 4 ] ; //<S2SV> } endian ; //<S2SV> if ( mat == NULL || mat -> fp == NULL ) //<S2SV> return NULL ; //<S2SV> else if ( NULL == ( matvar = Mat_VarCalloc ( ) ) ) //<S2SV> return NULL ; //<S2SV> readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; //<S2SV> if ( 1 != readresult ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> endian . u = 0x01020304 ; //<S2SV> if ( tmp < 0 || tmp > 4052 ) { //<S2SV> if ( Mat_int32Swap ( & tmp ) > 4052 ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> } //<S2SV> M = ( int ) floor ( tmp / 1000.0 ) ; //<S2SV> switch ( M ) { //<S2SV> case 0 : //<S2SV> mat -> byteswap = endian . c [ 0 ] != 4 ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> mat -> byteswap = endian . c [ 0 ] != 1 ; //<S2SV> break ; //<S2SV> default : //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> tmp -= M * 1000 ; //<S2SV> O = ( int ) floor ( tmp / 100.0 ) ; //<S2SV> if ( 0 != O ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> tmp -= O * 100 ; //<S2SV> data_type = ( int ) floor ( tmp / 10.0 ) ; //<S2SV> switch ( data_type ) { //<S2SV> case 0 : //<S2SV> matvar -> data_type = MAT_T_DOUBLE ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> matvar -> data_type = MAT_T_SINGLE ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> matvar -> data_type = MAT_T_INT32 ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> matvar -> data_type = MAT_T_INT16 ; //<S2SV> break ; //<S2SV> case 4 : //<S2SV> matvar -> data_type = MAT_T_UINT16 ; //<S2SV> break ; //<S2SV> case 5 : //<S2SV> matvar -> data_type = MAT_T_UINT8 ; //<S2SV> break ; //<S2SV> default : //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> tmp -= data_type * 10 ; //<S2SV> class_type = ( int ) floor ( tmp / 1.0 ) ; //<S2SV> switch ( class_type ) { //<S2SV> case 0 : //<S2SV> matvar -> class_type = MAT_C_DOUBLE ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> matvar -> class_type = MAT_C_CHAR ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> matvar -> class_type = MAT_C_SPARSE ; //<S2SV> break ; //<S2SV> default : //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> matvar -> rank = 2 ; //<S2SV> matvar -> dims = ( size_t * ) calloc ( 2 , sizeof ( * matvar -> dims ) ) ; //<S2SV> if ( NULL == matvar -> dims ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; //<S2SV> if ( mat -> byteswap ) //<S2SV> Mat_int32Swap ( & tmp ) ; //<S2SV> matvar -> dims [ 0 ] = tmp ; //<S2SV> if ( 1 != readresult ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; //<S2SV> if ( mat -> byteswap ) //<S2SV> Mat_int32Swap ( & tmp ) ; //<S2SV> matvar -> dims [ 1 ] = tmp ; //<S2SV> if ( 1 != readresult ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> readresult = fread ( & ( matvar -> isComplex ) , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; //<S2SV> if ( 1 != readresult ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( matvar -> isComplex && MAT_C_CHAR == matvar -> class_type ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; //<S2SV> if ( 1 != readresult ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> if ( mat -> byteswap ) //<S2SV> Mat_int32Swap ( & tmp ) ; //<S2SV> if ( tmp < 1 ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> matvar -> name = ( char * ) malloc ( tmp ) ; //<S2SV> if ( NULL == matvar -> name ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> readresult = fread ( matvar -> name , 1 , tmp , ( FILE * ) mat -> fp ) ; //<S2SV> if ( tmp != readresult ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ; //<S2SV> if ( matvar -> internal -> datapos == - 1L ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> Mat_Critical ( "Couldn\'t<S2SV_blank>determine<S2SV_blank>file<S2SV_blank>position" ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> { //<S2SV> int err ; //<S2SV> size_t tmp2 = Mat_SizeOf ( matvar -> data_type ) ; //<S2SV> if ( matvar -> isComplex ) //<S2SV> tmp2 *= 2 ; //<S2SV> err = SafeMulDims ( matvar , & tmp2 ) ; //<S2SV> if ( err ) { //<S2SV> Mat_VarFree ( matvar ) ; //<S2SV> Mat_Critical ( "Integer<S2SV_blank>multiplication<S2SV_blank>overflow" ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> nBytes = ( long ) tmp2 ; //<S2SV> } //<S2SV> ( void ) fseek ( ( FILE * ) mat -> fp , nBytes , SEEK_CUR ) ; //<S2SV> return matvar ; //<S2SV> } //<S2SV> 