static void Process_ipfix_template_add ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { //<S2SV> input_translation_t * translation_table ; //<S2SV> ipfix_template_record_t * ipfix_template_record ; //<S2SV> ipfix_template_elements_std_t * NextElement ; //<S2SV> int i ; //<S2SV> while ( size_left ) { //<S2SV> uint32_t table_id , count , size_required ; //<S2SV> uint32_t num_extensions = 0 ; //<S2SV> if ( size_left && size_left < 4 ) { //<S2SV> LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , //<S2SV> exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; //<S2SV> size_left = 0 ; //<S2SV> continue ; //<S2SV> } //<S2SV> ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; //<S2SV> size_left -= 4 ; //<S2SV> table_id = ntohs ( ipfix_template_record -> TemplateID ) ; //<S2SV> count = ntohs ( ipfix_template_record -> FieldCount ) ; //<S2SV> dbg_printf ( "\\n[%u]<S2SV_blank>Template<S2SV_blank>ID:<S2SV_blank>%u\\n" , exporter -> info . id , table_id ) ; //<S2SV> dbg_printf ( "FieldCount:<S2SV_blank>%u<S2SV_blank>buffersize:<S2SV_blank>%u\\n" , count , size_left ) ; //<S2SV> memset ( ( void * ) cache . common_extensions , 0 , ( Max_num_extensions + 1 ) * sizeof ( uint32_t ) ) ; //<S2SV> memset ( ( void * ) cache . lookup_info , 0 , 65536 * sizeof ( struct element_param_s ) ) ; //<S2SV> for ( i = 1 ; ipfix_element_map [ i ] . id != 0 ; i ++ ) { //<S2SV> uint32_t Type = ipfix_element_map [ i ] . id ; //<S2SV> if ( ipfix_element_map [ i ] . id == ipfix_element_map [ i - 1 ] . id ) //<S2SV> continue ; //<S2SV> cache . lookup_info [ Type ] . index = i ; //<S2SV> } //<S2SV> cache . input_order = calloc ( count , sizeof ( struct order_s ) ) ; //<S2SV> if ( ! cache . input_order ) { //<S2SV> LogError ( "Process_ipfix:<S2SV_blank>Panic!<S2SV_blank>malloc():<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d:<S2SV_blank>%s" , __FILE__ , __LINE__ , strerror ( errno ) ) ; //<S2SV> size_left = 0 ; //<S2SV> continue ; //<S2SV> } //<S2SV> cache . input_count = count ; //<S2SV> size_required = 4 * count ; //<S2SV> if ( size_left < size_required ) { //<S2SV> LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , //<S2SV> exporter -> info . id , size_required , size_left ) ; //<S2SV> dbg_printf ( "ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , size_required , size_left ) ; //<S2SV> return ; //<S2SV> } //<S2SV> NextElement = ( ipfix_template_elements_std_t * ) ipfix_template_record -> elements ; //<S2SV> for ( i = 0 ; i < count ; i ++ ) { //<S2SV> uint16_t Type , Length ; //<S2SV> uint32_t ext_id ; //<S2SV> int Enterprise ; //<S2SV> Type = ntohs ( NextElement -> Type ) ; //<S2SV> Length = ntohs ( NextElement -> Length ) ; //<S2SV> Enterprise = Type & 0x8000 ? 1 : 0 ; //<S2SV> Type = Type & 0x7FFF ; //<S2SV> ext_id = MapElement ( Type , Length , i ) ; //<S2SV> if ( ext_id && extension_descriptor [ ext_id ] . enabled ) { //<S2SV> if ( cache . common_extensions [ ext_id ] == 0 ) { //<S2SV> cache . common_extensions [ ext_id ] = 1 ; //<S2SV> num_extensions ++ ; //<S2SV> } //<S2SV> } //<S2SV> if ( Enterprise ) { //<S2SV> ipfix_template_elements_e_t * e = ( ipfix_template_elements_e_t * ) NextElement ; //<S2SV> size_required += 4 ; //<S2SV> if ( size_left < size_required ) { //<S2SV> LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , //<S2SV> exporter -> info . id , size_required , size_left ) ; //<S2SV> dbg_printf ( "ERROR:<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>for<S2SV_blank>template<S2SV_blank>elements!<S2SV_blank>required:<S2SV_blank>%i,<S2SV_blank>left:<S2SV_blank>%u" , size_required , size_left ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ntohl ( e -> EnterpriseNumber ) == IPFIX_ReverseInformationElement ) { //<S2SV> dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>Reverse<S2SV_blank>Information<S2SV_blank>Element:<S2SV_blank>%u\\n" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; //<S2SV> } else { //<S2SV> dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>1,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u<S2SV_blank>EnterpriseNumber:<S2SV_blank>%u\\n" , i , Type , Length , ntohl ( e -> EnterpriseNumber ) ) ; //<S2SV> } //<S2SV> e ++ ; //<S2SV> NextElement = ( ipfix_template_elements_std_t * ) e ; //<S2SV> } else { //<S2SV> dbg_printf ( "<S2SV_blank>[%i]<S2SV_blank>Enterprise:<S2SV_blank>0,<S2SV_blank>Type:<S2SV_blank>%u,<S2SV_blank>Length<S2SV_blank>%u\\n" , i , Type , Length ) ; //<S2SV> NextElement ++ ; //<S2SV> } //<S2SV> } //<S2SV> dbg_printf ( "Processed:<S2SV_blank>%u\\n" , size_required ) ; //<S2SV> if ( compact_input_order ( ) ) { //<S2SV> if ( extension_descriptor [ EX_ROUTER_IP_v4 ] . enabled ) { //<S2SV> if ( cache . common_extensions [ EX_ROUTER_IP_v4 ] == 0 ) { //<S2SV> cache . common_extensions [ EX_ROUTER_IP_v4 ] = 1 ; //<S2SV> num_extensions ++ ; //<S2SV> } //<S2SV> dbg_printf ( "Add<S2SV_blank>sending<S2SV_blank>router<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>(%s)<S2SV_blank>=><S2SV_blank>Extension:<S2SV_blank>%u\\n" , //<S2SV> fs -> sa_family == PF_INET6 ? "ipv6" : "ipv4" , EX_ROUTER_IP_v4 ) ; //<S2SV> } //<S2SV> extension_descriptor [ EX_ROUTER_ID ] . enabled = 0 ; //<S2SV> if ( extension_descriptor [ EX_RECEIVED ] . enabled ) { //<S2SV> if ( cache . common_extensions [ EX_RECEIVED ] == 0 ) { //<S2SV> cache . common_extensions [ EX_RECEIVED ] = 1 ; //<S2SV> num_extensions ++ ; //<S2SV> } //<S2SV> dbg_printf ( "Force<S2SV_blank>add<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>time,<S2SV_blank>Extension:<S2SV_blank>%u\\n" , EX_RECEIVED ) ; //<S2SV> } //<S2SV> # ifdef DEVEL //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 4 ; extension_descriptor [ i ] . id ; i ++ ) { //<S2SV> if ( cache . common_extensions [ i ] ) { //<S2SV> printf ( "Enabled<S2SV_blank>extension:<S2SV_blank>%i\\n" , i ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> translation_table = setup_translation_table ( exporter , table_id ) ; //<S2SV> if ( translation_table -> extension_map_changed ) { //<S2SV> dbg_printf ( "Translation<S2SV_blank>Table<S2SV_blank>changed!<S2SV_blank>Add<S2SV_blank>extension<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n" , translation_table -> extension_info . map -> map_id ) ; //<S2SV> AddExtensionMap ( fs , translation_table -> extension_info . map ) ; //<S2SV> translation_table -> extension_map_changed = 0 ; //<S2SV> dbg_printf ( "Translation<S2SV_blank>Table<S2SV_blank>added!<S2SV_blank>map<S2SV_blank>ID:<S2SV_blank>%i\\n" , translation_table -> extension_info . map -> map_id ) ; //<S2SV> } //<S2SV> if ( ! reorder_sequencer ( translation_table ) ) { //<S2SV> LogError ( "Process_ipfix:<S2SV_blank>[%u]<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>reorder<S2SV_blank>sequencer.<S2SV_blank>Remove<S2SV_blank>table<S2SV_blank>id:<S2SV_blank>%u" , //<S2SV> exporter -> info . id , table_id ) ; //<S2SV> remove_translation_table ( fs , exporter , table_id ) ; //<S2SV> } //<S2SV> } else { //<S2SV> dbg_printf ( "Template<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>any<S2SV_blank>common<S2SV_blank>fields<S2SV_blank>-<S2SV_blank>skip\\n" ) ; //<S2SV> } //<S2SV> size_left -= size_required ; //<S2SV> DataPtr = DataPtr + size_required + 4 ; //<S2SV> if ( size_left < 4 ) { //<S2SV> dbg_printf ( "Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n" , size_left ) ; //<S2SV> size_left = 0 ; //<S2SV> } //<S2SV> free ( cache . input_order ) ; //<S2SV> cache . input_order = NULL ; //<S2SV> } //<S2SV> } //<S2SV> 