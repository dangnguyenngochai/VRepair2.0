struct tcp_sock_t * tcp_open ( uint16_t port ) //<S2SV> { //<S2SV> struct tcp_sock_t * this = calloc ( 1 , sizeof * this ) ; //<S2SV> if ( this == NULL ) { //<S2SV> ERR ( "callocing<S2SV_blank>this<S2SV_blank>failed" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> this -> sd = - 1 ; //<S2SV> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; //<S2SV> if ( this -> sd < 0 ) { //<S2SV> ERR ( "sockect<S2SV_blank>open<S2SV_blank>failed" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> struct sockaddr_in6 addr ; //<S2SV> memset ( & addr , 0 , sizeof addr ) ; //<S2SV> addr . sin6_family = AF_INET6 ; //<S2SV> addr . sin6_port = htons ( port ) ; //<S2SV> addr . sin6_addr = in6addr_any ; //<S2SV> if ( bind ( this -> sd , //<S2SV> ( struct sockaddr * ) & addr , //<S2SV> sizeof addr ) < 0 ) { //<S2SV> if ( g_options . only_desired_port == 1 ) //<S2SV> ERR ( "Bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>" //<S2SV> "Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions." ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( listen ( this -> sd , HTTP_MAX_PENDING_CONNS ) < 0 ) { //<S2SV> ERR ( "listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> return this ; //<S2SV> error : //<S2SV> if ( this != NULL ) { //<S2SV> if ( this -> sd != - 1 ) { //<S2SV> close ( this -> sd ) ; //<S2SV> } //<S2SV> free ( this ) ; //<S2SV> } //<S2SV> return NULL ; //<S2SV> } //<S2SV> 