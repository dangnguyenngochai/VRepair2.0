static void start_daemon ( ) //<S2SV> { //<S2SV> struct usb_sock_t * usb_sock ; //<S2SV> if ( g_options . noprinter_mode == 0 ) { //<S2SV> usb_sock = usb_open ( ) ; //<S2SV> if ( usb_sock == NULL ) //<S2SV> goto cleanup_usb ; //<S2SV> } else //<S2SV> usb_sock = NULL ; //<S2SV> uint16_t desired_port = g_options . desired_port ; //<S2SV> struct tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ; //<S2SV> for ( ; ; ) { //<S2SV> tcp_socket = tcp_open ( desired_port ) ; //<S2SV> tcp6_socket = tcp6_open ( desired_port ) ; //<S2SV> if ( tcp_socket || tcp6_socket || g_options . only_desired_port ) //<S2SV> break ; //<S2SV> desired_port ++ ; //<S2SV> if ( desired_port == 1 || desired_port == 0 ) //<S2SV> desired_port = 49152 ; //<S2SV> NOTE ( "Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d" , desired_port ) ; //<S2SV> } //<S2SV> if ( tcp_socket == NULL && tcp6_socket == NULL ) //<S2SV> goto cleanup_tcp ; //<S2SV> uint16_t real_port ; //<S2SV> if ( tcp_socket ) //<S2SV> real_port = tcp_port_number_get ( tcp_socket ) ; //<S2SV> else //<S2SV> real_port = tcp_port_number_get ( tcp6_socket ) ; //<S2SV> if ( desired_port != 0 && g_options . only_desired_port == 1 && //<S2SV> desired_port != real_port ) { //<S2SV> ERR ( "Received<S2SV_blank>port<S2SV_blank>number<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>requested<S2SV_blank>port<S2SV_blank>number." //<S2SV> "<S2SV_blank>The<S2SV_blank>requested<S2SV_blank>port<S2SV_blank>number<S2SV_blank>may<S2SV_blank>be<S2SV_blank>too<S2SV_blank>high." ) ; //<S2SV> goto cleanup_tcp ; //<S2SV> } //<S2SV> printf ( "%u|" , real_port ) ; //<S2SV> fflush ( stdout ) ; //<S2SV> NOTE ( "Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable" , //<S2SV> real_port , tcp_socket ? "" : "not<S2SV_blank>" , tcp6_socket ? "" : "not<S2SV_blank>" ) ; //<S2SV> uint16_t pid ; //<S2SV> if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) { //<S2SV> printf ( "%u|" , pid ) ; //<S2SV> exit ( 0 ) ; //<S2SV> } //<S2SV> if ( usb_can_callback ( usb_sock ) ) //<S2SV> usb_register_callback ( usb_sock ) ; //<S2SV> for ( ; ; ) { //<S2SV> struct service_thread_param * args = calloc ( 1 , sizeof ( * args ) ) ; //<S2SV> if ( args == NULL ) { //<S2SV> ERR ( "Failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>space<S2SV_blank>for<S2SV_blank>thread<S2SV_blank>args" ) ; //<S2SV> goto cleanup_thread ; //<S2SV> } //<S2SV> args -> usb_sock = usb_sock ; //<S2SV> args -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket ) ; //<S2SV> if ( args -> tcp == NULL ) { //<S2SV> ERR ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>tcp<S2SV_blank>connection" ) ; //<S2SV> goto cleanup_thread ; //<S2SV> } //<S2SV> int status = pthread_create ( & args -> thread_handle , NULL , //<S2SV> & service_connection , args ) ; //<S2SV> if ( status ) { //<S2SV> ERR ( "Failed<S2SV_blank>to<S2SV_blank>spawn<S2SV_blank>thread,<S2SV_blank>error<S2SV_blank>%d" , status ) ; //<S2SV> goto cleanup_thread ; //<S2SV> } //<S2SV> continue ; //<S2SV> cleanup_thread : //<S2SV> if ( args != NULL ) { //<S2SV> if ( args -> tcp != NULL ) //<S2SV> tcp_conn_close ( args -> tcp ) ; //<S2SV> free ( args ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> cleanup_tcp : //<S2SV> if ( tcp_socket != NULL ) //<S2SV> tcp_close ( tcp_socket ) ; //<S2SV> if ( tcp6_socket != NULL ) //<S2SV> tcp_close ( tcp6_socket ) ; //<S2SV> cleanup_usb : //<S2SV> if ( usb_sock != NULL ) //<S2SV> usb_close ( usb_sock ) ; //<S2SV> return ; //<S2SV> } //<S2SV> 