static CURLcode smtp_connect ( struct connectdata * conn , //<S2SV> bool * done ) //<S2SV> { //<S2SV> CURLcode result ; //<S2SV> struct smtp_conn * smtpc = & conn -> proto . smtpc ; //<S2SV> struct SessionHandle * data = conn -> data ; //<S2SV> struct pingpong * pp = & smtpc -> pp ; //<S2SV> const char * path = conn -> data -> state . path ; //<S2SV> int len ; //<S2SV> char localhost [ HOSTNAME_MAX + 1 ] ; //<S2SV> * done = FALSE ; //<S2SV> Curl_reset_reqproto ( conn ) ; //<S2SV> result = smtp_init ( conn ) ; //<S2SV> if ( CURLE_OK != result ) //<S2SV> return result ; //<S2SV> conn -> bits . close = FALSE ; //<S2SV> pp -> response_time = RESP_TIMEOUT ; //<S2SV> pp -> statemach_act = smtp_statemach_act ; //<S2SV> pp -> endofresp = smtp_endofresp ; //<S2SV> pp -> conn = conn ; //<S2SV> if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { //<S2SV> struct HTTP http_proxy ; //<S2SV> struct FTP * smtp_save ; //<S2SV> smtp_save = data -> state . proto . smtp ; //<S2SV> memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; //<S2SV> data -> state . proto . http = & http_proxy ; //<S2SV> result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , //<S2SV> conn -> host . name , conn -> remote_port ) ; //<S2SV> data -> state . proto . smtp = smtp_save ; //<S2SV> if ( CURLE_OK != result ) //<S2SV> return result ; //<S2SV> } //<S2SV> if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && //<S2SV> data -> state . used_interface != Curl_if_multi ) { //<S2SV> result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; //<S2SV> if ( result ) //<S2SV> return result ; //<S2SV> } //<S2SV> Curl_pp_init ( pp ) ; //<S2SV> pp -> response_time = RESP_TIMEOUT ; //<S2SV> pp -> statemach_act = smtp_statemach_act ; //<S2SV> pp -> endofresp = smtp_endofresp ; //<S2SV> pp -> conn = conn ; //<S2SV> if ( ! * path ) { //<S2SV> if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) //<S2SV> path = localhost ; //<S2SV> else //<S2SV> path = "localhost" ; //<S2SV> } //<S2SV> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; //<S2SV> if ( ! smtpc -> domain ) //<S2SV> return CURLE_OUT_OF_MEMORY ; //<S2SV> state ( conn , SMTP_SERVERGREET ) ; //<S2SV> if ( data -> state . used_interface == Curl_if_multi ) //<S2SV> result = smtp_multi_statemach ( conn , done ) ; //<S2SV> else { //<S2SV> result = smtp_easy_statemach ( conn ) ; //<S2SV> if ( ! result ) //<S2SV> * done = TRUE ; //<S2SV> } //<S2SV> return result ; //<S2SV> } //<S2SV> 