static void //<S2SV> create_watching_parent ( void ) //<S2SV> { //<S2SV> pid_t child ; //<S2SV> sigset_t ourset ; //<S2SV> struct sigaction oldact [ 3 ] ; //<S2SV> int status = 0 ; //<S2SV> int retval ; //<S2SV> retval = pam_open_session ( pamh , 0 ) ; //<S2SV> if ( is_pam_failure ( retval ) ) //<S2SV> { //<S2SV> cleanup_pam ( retval ) ; //<S2SV> errx ( EXIT_FAILURE , _ ( "cannot<S2SV_blank>open<S2SV_blank>session:<S2SV_blank>%s" ) , //<S2SV> pam_strerror ( pamh , retval ) ) ; //<S2SV> } //<S2SV> else //<S2SV> _pam_session_opened = 1 ; //<S2SV> memset ( oldact , 0 , sizeof ( oldact ) ) ; //<S2SV> child = fork ( ) ; //<S2SV> if ( child == ( pid_t ) - 1 ) //<S2SV> { //<S2SV> cleanup_pam ( PAM_ABORT ) ; //<S2SV> err ( EXIT_FAILURE , _ ( "cannot<S2SV_blank>create<S2SV_blank>child<S2SV_blank>process" ) ) ; //<S2SV> } //<S2SV> if ( child == 0 ) //<S2SV> return ; //<S2SV> if ( chdir ( "/" ) != 0 ) //<S2SV> warn ( _ ( "cannot<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>%s" ) , "/" ) ; //<S2SV> sigfillset ( & ourset ) ; //<S2SV> if ( sigprocmask ( SIG_BLOCK , & ourset , NULL ) ) //<S2SV> { //<S2SV> warn ( _ ( "cannot<S2SV_blank>block<S2SV_blank>signals" ) ) ; //<S2SV> caught_signal = true ; //<S2SV> } //<S2SV> if ( ! caught_signal ) //<S2SV> { //<S2SV> struct sigaction action ; //<S2SV> action . sa_handler = su_catch_sig ; //<S2SV> sigemptyset ( & action . sa_mask ) ; //<S2SV> action . sa_flags = 0 ; //<S2SV> sigemptyset ( & ourset ) ; //<S2SV> if ( ! same_session ) //<S2SV> { //<S2SV> if ( sigaddset ( & ourset , SIGINT ) || sigaddset ( & ourset , SIGQUIT ) ) //<S2SV> { //<S2SV> warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; //<S2SV> caught_signal = true ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) //<S2SV> || sigaddset ( & ourset , SIGALRM ) //<S2SV> || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) //<S2SV> || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) { //<S2SV> warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; //<S2SV> caught_signal = true ; //<S2SV> } //<S2SV> if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) //<S2SV> || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) //<S2SV> { //<S2SV> warn ( _ ( "cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler" ) ) ; //<S2SV> caught_signal = true ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! caught_signal ) //<S2SV> { //<S2SV> pid_t pid ; //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> pid = waitpid ( child , & status , WUNTRACED ) ; //<S2SV> if ( pid != ( pid_t ) - 1 && WIFSTOPPED ( status ) ) //<S2SV> { //<S2SV> kill ( getpid ( ) , SIGSTOP ) ; //<S2SV> kill ( pid , SIGCONT ) ; //<S2SV> } //<S2SV> else //<S2SV> break ; //<S2SV> } //<S2SV> if ( pid != ( pid_t ) - 1 ) //<S2SV> { //<S2SV> if ( WIFSIGNALED ( status ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "%s%s\\n" , strsignal ( WTERMSIG ( status ) ) , //<S2SV> WCOREDUMP ( status ) ? _ ( "<S2SV_blank>(core<S2SV_blank>dumped)" ) : "" ) ; //<S2SV> status = WTERMSIG ( status ) + 128 ; //<S2SV> } //<S2SV> else //<S2SV> status = WEXITSTATUS ( status ) ; //<S2SV> child = ( pid_t ) - 1 ; //<S2SV> } //<S2SV> else if ( caught_signal ) //<S2SV> status = caught_signal + 128 ; //<S2SV> else //<S2SV> status = 1 ; //<S2SV> } //<S2SV> else //<S2SV> status = 1 ; //<S2SV> if ( caught_signal && child != ( pid_t ) - 1 ) //<S2SV> { //<S2SV> fprintf ( stderr , _ ( "\\nSession<S2SV_blank>terminated,<S2SV_blank>killing<S2SV_blank>shell..." ) ) ; //<S2SV> kill ( child , SIGTERM ) ; //<S2SV> } //<S2SV> cleanup_pam ( PAM_SUCCESS ) ; //<S2SV> if ( caught_signal ) //<S2SV> { //<S2SV> if ( child != ( pid_t ) - 1 ) //<S2SV> { //<S2SV> sleep ( 2 ) ; //<S2SV> kill ( child , SIGKILL ) ; //<S2SV> fprintf ( stderr , _ ( "<S2SV_blank>...killed.\\n" ) ) ; //<S2SV> } //<S2SV> switch ( caught_signal ) { //<S2SV> case SIGTERM : //<S2SV> sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ; //<S2SV> break ; //<S2SV> case SIGINT : //<S2SV> sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ; //<S2SV> break ; //<S2SV> case SIGQUIT : //<S2SV> sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> caught_signal = SIGKILL ; //<S2SV> break ; //<S2SV> } //<S2SV> kill ( getpid ( ) , caught_signal ) ; //<S2SV> } //<S2SV> exit ( status ) ; //<S2SV> } //<S2SV> 