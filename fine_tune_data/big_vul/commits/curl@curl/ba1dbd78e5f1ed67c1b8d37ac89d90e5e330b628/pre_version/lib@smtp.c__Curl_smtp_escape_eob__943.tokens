CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) //<S2SV> { //<S2SV> ssize_t i ; //<S2SV> ssize_t si ; //<S2SV> struct Curl_easy * data = conn -> data ; //<S2SV> struct SMTP * smtp = data -> req . protop ; //<S2SV> char * scratch = data -> state . scratch ; //<S2SV> char * newscratch = NULL ; //<S2SV> char * oldscratch = NULL ; //<S2SV> size_t eob_sent ; //<S2SV> if ( ! scratch || data -> set . crlf ) { //<S2SV> oldscratch = scratch ; //<S2SV> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; //<S2SV> if ( ! newscratch ) { //<S2SV> failf ( data , "Failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>scratch<S2SV_blank>buffer!" ) ; //<S2SV> return CURLE_OUT_OF_MEMORY ; //<S2SV> } //<S2SV> } //<S2SV> eob_sent = smtp -> eob ; //<S2SV> for ( i = 0 , si = 0 ; i < nread ; i ++ ) { //<S2SV> if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { //<S2SV> smtp -> eob ++ ; //<S2SV> if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) //<S2SV> smtp -> trailing_crlf = TRUE ; //<S2SV> else //<S2SV> smtp -> trailing_crlf = FALSE ; //<S2SV> } //<S2SV> else if ( smtp -> eob ) { //<S2SV> memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; //<S2SV> si += smtp -> eob - eob_sent ; //<S2SV> if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) //<S2SV> smtp -> eob = 1 ; //<S2SV> else //<S2SV> smtp -> eob = 0 ; //<S2SV> eob_sent = 0 ; //<S2SV> smtp -> trailing_crlf = FALSE ; //<S2SV> } //<S2SV> if ( SMTP_EOB_FIND_LEN == smtp -> eob ) { //<S2SV> memcpy ( & scratch [ si ] , & SMTP_EOB_REPL [ eob_sent ] , //<S2SV> SMTP_EOB_REPL_LEN - eob_sent ) ; //<S2SV> si += SMTP_EOB_REPL_LEN - eob_sent ; //<S2SV> smtp -> eob = 0 ; //<S2SV> eob_sent = 0 ; //<S2SV> } //<S2SV> else if ( ! smtp -> eob ) //<S2SV> scratch [ si ++ ] = data -> req . upload_fromhere [ i ] ; //<S2SV> } //<S2SV> if ( smtp -> eob - eob_sent ) { //<S2SV> memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; //<S2SV> si += smtp -> eob - eob_sent ; //<S2SV> } //<S2SV> if ( si != nread ) { //<S2SV> data -> req . upload_fromhere = scratch ; //<S2SV> data -> state . scratch = scratch ; //<S2SV> free ( oldscratch ) ; //<S2SV> data -> req . upload_present = si ; //<S2SV> } //<S2SV> else //<S2SV> free ( newscratch ) ; //<S2SV> return CURLE_OK ; //<S2SV> } //<S2SV> 