CURLcode Curl_close ( struct Curl_easy * data ) //<S2SV> { //<S2SV> struct Curl_multi * m ; //<S2SV> if ( ! data ) //<S2SV> return CURLE_OK ; //<S2SV> Curl_expire_clear ( data ) ; //<S2SV> m = data -> multi ; //<S2SV> if ( m ) //<S2SV> curl_multi_remove_handle ( data -> multi , data ) ; //<S2SV> if ( data -> multi_easy ) //<S2SV> curl_multi_cleanup ( data -> multi_easy ) ; //<S2SV> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; //<S2SV> data -> magic = 0 ; //<S2SV> if ( data -> state . rangestringalloc ) //<S2SV> free ( data -> state . range ) ; //<S2SV> Curl_free_request_state ( data ) ; //<S2SV> Curl_ssl_close_all ( data ) ; //<S2SV> Curl_safefree ( data -> state . first_host ) ; //<S2SV> Curl_safefree ( data -> state . scratch ) ; //<S2SV> Curl_ssl_free_certinfo ( data ) ; //<S2SV> free ( data -> req . newurl ) ; //<S2SV> data -> req . newurl = NULL ; //<S2SV> if ( data -> change . referer_alloc ) { //<S2SV> Curl_safefree ( data -> change . referer ) ; //<S2SV> data -> change . referer_alloc = FALSE ; //<S2SV> } //<S2SV> data -> change . referer = NULL ; //<S2SV> Curl_up_free ( data ) ; //<S2SV> Curl_safefree ( data -> state . buffer ) ; //<S2SV> Curl_safefree ( data -> state . headerbuff ) ; //<S2SV> Curl_safefree ( data -> state . ulbuf ) ; //<S2SV> Curl_flush_cookies ( data , 1 ) ; //<S2SV> Curl_digest_cleanup ( data ) ; //<S2SV> Curl_safefree ( data -> info . contenttype ) ; //<S2SV> Curl_safefree ( data -> info . wouldredirect ) ; //<S2SV> Curl_resolver_cleanup ( data -> state . resolver ) ; //<S2SV> Curl_http2_cleanup_dependencies ( data ) ; //<S2SV> Curl_convert_close ( data ) ; //<S2SV> if ( data -> share ) { //<S2SV> Curl_share_lock ( data , CURL_LOCK_DATA_SHARE , CURL_LOCK_ACCESS_SINGLE ) ; //<S2SV> data -> share -> dirty -- ; //<S2SV> Curl_share_unlock ( data , CURL_LOCK_DATA_SHARE ) ; //<S2SV> } //<S2SV> Curl_wildcard_dtor ( & data -> wildcard ) ; //<S2SV> Curl_freeset ( data ) ; //<S2SV> free ( data ) ; //<S2SV> return CURLE_OK ; //<S2SV> } //<S2SV> 