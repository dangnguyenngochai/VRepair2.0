static int dprintf_formatf ( //<S2SV> void * data , //<S2SV> int ( * stream ) ( int , FILE * ) , //<S2SV> const char * format , //<S2SV> va_list ap_save ) //<S2SV> { //<S2SV> const char * digits = lower_digits ; //<S2SV> char * f ; //<S2SV> int done = 0 ; //<S2SV> long param ; //<S2SV> long param_num = 0 ; //<S2SV> va_stack_t vto [ MAX_PARAMETERS ] ; //<S2SV> char * endpos [ MAX_PARAMETERS ] ; //<S2SV> char * * end ; //<S2SV> char work [ BUFFSIZE ] ; //<S2SV> va_stack_t * p ; //<S2SV> char * workend = & work [ sizeof ( work ) - 2 ] ; //<S2SV> if ( dprintf_Pass1 ( format , vto , endpos , ap_save ) ) //<S2SV> return - 1 ; //<S2SV> end = & endpos [ 0 ] ; //<S2SV> f = ( char * ) format ; //<S2SV> while ( * f != '\\0' ) { //<S2SV> int is_alt ; //<S2SV> long width ; //<S2SV> long prec ; //<S2SV> int is_neg ; //<S2SV> long base ; //<S2SV> mp_uintmax_t num ; //<S2SV> mp_intmax_t signed_num ; //<S2SV> char * w ; //<S2SV> if ( * f != '%' ) { //<S2SV> do { //<S2SV> OUTCHAR ( * f ) ; //<S2SV> } while ( * ++ f && ( '%' != * f ) ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> ++ f ; //<S2SV> if ( * f == '%' ) { //<S2SV> ++ f ; //<S2SV> OUTCHAR ( '%' ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> param = dprintf_DollarString ( f , & f ) ; //<S2SV> if ( ! param ) //<S2SV> param = param_num ; //<S2SV> else //<S2SV> -- param ; //<S2SV> param_num ++ ; //<S2SV> p = & vto [ param ] ; //<S2SV> if ( p -> flags & FLAGS_WIDTHPARAM ) { //<S2SV> width = ( long ) vto [ p -> width ] . data . num . as_signed ; //<S2SV> param_num ++ ; //<S2SV> if ( width < 0 ) { //<S2SV> width = - width ; //<S2SV> p -> flags |= FLAGS_LEFT ; //<S2SV> p -> flags &= ~ FLAGS_PAD_NIL ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> width = p -> width ; //<S2SV> if ( p -> flags & FLAGS_PRECPARAM ) { //<S2SV> prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; //<S2SV> param_num ++ ; //<S2SV> if ( prec < 0 ) //<S2SV> prec = - 1 ; //<S2SV> } //<S2SV> else if ( p -> flags & FLAGS_PREC ) //<S2SV> prec = p -> precision ; //<S2SV> else //<S2SV> prec = - 1 ; //<S2SV> is_alt = ( p -> flags & FLAGS_ALT ) ? 1 : 0 ; //<S2SV> switch ( p -> type ) { //<S2SV> case FORMAT_INT : //<S2SV> num = p -> data . num . as_unsigned ; //<S2SV> if ( p -> flags & FLAGS_CHAR ) { //<S2SV> if ( ! ( p -> flags & FLAGS_LEFT ) ) //<S2SV> while ( -- width > 0 ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> OUTCHAR ( ( char ) num ) ; //<S2SV> if ( p -> flags & FLAGS_LEFT ) //<S2SV> while ( -- width > 0 ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( p -> flags & FLAGS_OCTAL ) { //<S2SV> base = 8 ; //<S2SV> goto unsigned_number ; //<S2SV> } //<S2SV> else if ( p -> flags & FLAGS_HEX ) { //<S2SV> digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; //<S2SV> base = 16 ; //<S2SV> goto unsigned_number ; //<S2SV> } //<S2SV> else if ( p -> flags & FLAGS_UNSIGNED ) { //<S2SV> base = 10 ; //<S2SV> goto unsigned_number ; //<S2SV> } //<S2SV> base = 10 ; //<S2SV> is_neg = ( p -> data . num . as_signed < ( mp_intmax_t ) 0 ) ? 1 : 0 ; //<S2SV> if ( is_neg ) { //<S2SV> signed_num = p -> data . num . as_signed + ( mp_intmax_t ) 1 ; //<S2SV> signed_num = - signed_num ; //<S2SV> num = ( mp_uintmax_t ) signed_num ; //<S2SV> num += ( mp_uintmax_t ) 1 ; //<S2SV> } //<S2SV> goto number ; //<S2SV> unsigned_number : //<S2SV> is_neg = 0 ; //<S2SV> number : //<S2SV> if ( prec == - 1 ) //<S2SV> prec = 1 ; //<S2SV> w = workend ; //<S2SV> while ( num > 0 ) { //<S2SV> * w -- = digits [ num % base ] ; //<S2SV> num /= base ; //<S2SV> } //<S2SV> width -= ( long ) ( workend - w ) ; //<S2SV> prec -= ( long ) ( workend - w ) ; //<S2SV> if ( is_alt && base == 8 && prec <= 0 ) { //<S2SV> * w -- = '0' ; //<S2SV> -- width ; //<S2SV> } //<S2SV> if ( prec > 0 ) { //<S2SV> width -= prec ; //<S2SV> while ( prec -- > 0 ) //<S2SV> * w -- = '0' ; //<S2SV> } //<S2SV> if ( is_alt && base == 16 ) //<S2SV> width -= 2 ; //<S2SV> if ( is_neg || ( p -> flags & FLAGS_SHOWSIGN ) || ( p -> flags & FLAGS_SPACE ) ) //<S2SV> -- width ; //<S2SV> if ( ! ( p -> flags & FLAGS_LEFT ) && ! ( p -> flags & FLAGS_PAD_NIL ) ) //<S2SV> while ( width -- > 0 ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> if ( is_neg ) //<S2SV> OUTCHAR ( '-' ) ; //<S2SV> else if ( p -> flags & FLAGS_SHOWSIGN ) //<S2SV> OUTCHAR ( '+' ) ; //<S2SV> else if ( p -> flags & FLAGS_SPACE ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> if ( is_alt && base == 16 ) { //<S2SV> OUTCHAR ( '0' ) ; //<S2SV> if ( p -> flags & FLAGS_UPPER ) //<S2SV> OUTCHAR ( 'X' ) ; //<S2SV> else //<S2SV> OUTCHAR ( 'x' ) ; //<S2SV> } //<S2SV> if ( ! ( p -> flags & FLAGS_LEFT ) && ( p -> flags & FLAGS_PAD_NIL ) ) //<S2SV> while ( width -- > 0 ) //<S2SV> OUTCHAR ( '0' ) ; //<S2SV> while ( ++ w <= workend ) { //<S2SV> OUTCHAR ( * w ) ; //<S2SV> } //<S2SV> if ( p -> flags & FLAGS_LEFT ) //<S2SV> while ( width -- > 0 ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> break ; //<S2SV> case FORMAT_STRING : //<S2SV> { //<S2SV> static const char null [ ] = "(nil)" ; //<S2SV> const char * str ; //<S2SV> size_t len ; //<S2SV> str = ( char * ) p -> data . str ; //<S2SV> if ( str == NULL ) { //<S2SV> if ( prec == - 1 || prec >= ( long ) sizeof ( null ) - 1 ) { //<S2SV> str = null ; //<S2SV> len = sizeof ( null ) - 1 ; //<S2SV> p -> flags &= ( ~ FLAGS_ALT ) ; //<S2SV> } //<S2SV> else { //<S2SV> str = "" ; //<S2SV> len = 0 ; //<S2SV> } //<S2SV> } //<S2SV> else if ( prec != - 1 ) //<S2SV> len = ( size_t ) prec ; //<S2SV> else //<S2SV> len = strlen ( str ) ; //<S2SV> width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ; //<S2SV> if ( p -> flags & FLAGS_ALT ) //<S2SV> OUTCHAR ( \'"\' ) ; //<S2SV> if ( ! ( p -> flags & FLAGS_LEFT ) ) //<S2SV> while ( width -- > 0 ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> while ( ( len -- > 0 ) && * str ) //<S2SV> OUTCHAR ( * str ++ ) ; //<S2SV> if ( p -> flags & FLAGS_LEFT ) //<S2SV> while ( width -- > 0 ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> if ( p -> flags & FLAGS_ALT ) //<S2SV> OUTCHAR ( \'"\' ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case FORMAT_PTR : //<S2SV> { //<S2SV> void * ptr ; //<S2SV> ptr = ( void * ) p -> data . ptr ; //<S2SV> if ( ptr != NULL ) { //<S2SV> base = 16 ; //<S2SV> digits = ( p -> flags & FLAGS_UPPER ) ? upper_digits : lower_digits ; //<S2SV> is_alt = 1 ; //<S2SV> num = ( size_t ) ptr ; //<S2SV> is_neg = 0 ; //<S2SV> goto number ; //<S2SV> } //<S2SV> else { //<S2SV> static const char strnil [ ] = "(nil)" ; //<S2SV> const char * point ; //<S2SV> width -= ( long ) ( sizeof ( strnil ) - 1 ) ; //<S2SV> if ( p -> flags & FLAGS_LEFT ) //<S2SV> while ( width -- > 0 ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> for ( point = strnil ; * point != '\\0' ; ++ point ) //<S2SV> OUTCHAR ( * point ) ; //<S2SV> if ( ! ( p -> flags & FLAGS_LEFT ) ) //<S2SV> while ( width -- > 0 ) //<S2SV> OUTCHAR ( '<S2SV_blank>' ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case FORMAT_DOUBLE : //<S2SV> { //<S2SV> char formatbuf [ 32 ] = "%" ; //<S2SV> char * fptr = & formatbuf [ 1 ] ; //<S2SV> size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ; //<S2SV> int len ; //<S2SV> width = - 1 ; //<S2SV> if ( p -> flags & FLAGS_WIDTH ) //<S2SV> width = p -> width ; //<S2SV> else if ( p -> flags & FLAGS_WIDTHPARAM ) //<S2SV> width = ( long ) vto [ p -> width ] . data . num . as_signed ; //<S2SV> prec = - 1 ; //<S2SV> if ( p -> flags & FLAGS_PREC ) //<S2SV> prec = p -> precision ; //<S2SV> else if ( p -> flags & FLAGS_PRECPARAM ) //<S2SV> prec = ( long ) vto [ p -> precision ] . data . num . as_signed ; //<S2SV> if ( p -> flags & FLAGS_LEFT ) //<S2SV> * fptr ++ = '-' ; //<S2SV> if ( p -> flags & FLAGS_SHOWSIGN ) //<S2SV> * fptr ++ = '+' ; //<S2SV> if ( p -> flags & FLAGS_SPACE ) //<S2SV> * fptr ++ = '<S2SV_blank>' ; //<S2SV> if ( p -> flags & FLAGS_ALT ) //<S2SV> * fptr ++ = '#' ; //<S2SV> * fptr = 0 ; //<S2SV> if ( width >= 0 ) { //<S2SV> if ( width >= ( long ) sizeof ( work ) ) //<S2SV> width = sizeof ( work ) - 1 ; //<S2SV> len = curl_msnprintf ( fptr , left , "%ld" , width ) ; //<S2SV> fptr += len ; //<S2SV> left -= len ; //<S2SV> } //<S2SV> if ( prec >= 0 ) { //<S2SV> size_t maxprec = sizeof ( work ) - 2 ; //<S2SV> double val = p -> data . dnum ; //<S2SV> while ( val >= 10.0 ) { //<S2SV> val /= 10 ; //<S2SV> maxprec -- ; //<S2SV> } //<S2SV> if ( prec > ( long ) maxprec ) //<S2SV> prec = maxprec - 1 ; //<S2SV> len = curl_msnprintf ( fptr , left , ".%ld" , prec ) ; //<S2SV> fptr += len ; //<S2SV> } //<S2SV> if ( p -> flags & FLAGS_LONG ) //<S2SV> * fptr ++ = 'l' ; //<S2SV> if ( p -> flags & FLAGS_FLOATE ) //<S2SV> * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'E' : 'e' ) ; //<S2SV> else if ( p -> flags & FLAGS_FLOATG ) //<S2SV> * fptr ++ = ( char ) ( ( p -> flags & FLAGS_UPPER ) ? 'G' : 'g' ) ; //<S2SV> else //<S2SV> * fptr ++ = 'f' ; //<S2SV> * fptr = 0 ; //<S2SV> ( sprintf ) ( work , formatbuf , p -> data . dnum ) ; //<S2SV> # ifdef CURLDEBUG //<S2SV> assert ( strlen ( work ) <= sizeof ( work ) ) ; //<S2SV> # endif //<S2SV> for ( fptr = work ; * fptr ; fptr ++ ) //<S2SV> OUTCHAR ( * fptr ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case FORMAT_INTPTR : //<S2SV> # ifdef HAVE_LONG_LONG_TYPE //<S2SV> if ( p -> flags & FLAGS_LONGLONG ) //<S2SV> * ( LONG_LONG_TYPE * ) p -> data . ptr = ( LONG_LONG_TYPE ) done ; //<S2SV> else //<S2SV> # endif //<S2SV> if ( p -> flags & FLAGS_LONG ) //<S2SV> * ( long * ) p -> data . ptr = ( long ) done ; //<S2SV> else if ( ! ( p -> flags & FLAGS_SHORT ) ) //<S2SV> * ( int * ) p -> data . ptr = ( int ) done ; //<S2SV> else //<S2SV> * ( short * ) p -> data . ptr = ( short ) done ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> f = * end ++ ; //<S2SV> } //<S2SV> return done ; //<S2SV> } //<S2SV> 