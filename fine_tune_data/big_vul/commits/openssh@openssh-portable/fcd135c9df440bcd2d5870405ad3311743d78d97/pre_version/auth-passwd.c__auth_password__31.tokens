int //<S2SV> auth_password ( Authctxt * authctxt , const char * password ) //<S2SV> { //<S2SV> struct passwd * pw = authctxt -> pw ; //<S2SV> int result , ok = authctxt -> valid ; //<S2SV> # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) //<S2SV> static int expire_checked = 0 ; //<S2SV> # endif //<S2SV> # ifndef HAVE_CYGWIN //<S2SV> if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) //<S2SV> ok = 0 ; //<S2SV> # endif //<S2SV> if ( * password == '\\0' && options . permit_empty_passwd == 0 ) //<S2SV> return 0 ; //<S2SV> # ifdef KRB5 //<S2SV> if ( options . kerberos_authentication == 1 ) { //<S2SV> int ret = auth_krb5_password ( authctxt , password ) ; //<S2SV> if ( ret == 1 || ret == 0 ) //<S2SV> return ret && ok ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef HAVE_CYGWIN //<S2SV> { //<S2SV> HANDLE hToken = cygwin_logon_user ( pw , password ) ; //<S2SV> if ( hToken == INVALID_HANDLE_VALUE ) //<S2SV> return 0 ; //<S2SV> cygwin_set_impersonation_token ( hToken ) ; //<S2SV> return ok ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef USE_PAM //<S2SV> if ( options . use_pam ) //<S2SV> return ( sshpam_auth_passwd ( authctxt , password ) && ok ) ; //<S2SV> # endif //<S2SV> # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) //<S2SV> if ( ! expire_checked ) { //<S2SV> expire_checked = 1 ; //<S2SV> if ( auth_shadow_pwexpired ( authctxt ) ) //<S2SV> authctxt -> force_pwchange = 1 ; //<S2SV> } //<S2SV> # endif //<S2SV> result = sys_auth_passwd ( authctxt , password ) ; //<S2SV> if ( authctxt -> force_pwchange ) //<S2SV> disable_forwarding ( ) ; //<S2SV> return ( result && ok ) ; //<S2SV> } //<S2SV> 