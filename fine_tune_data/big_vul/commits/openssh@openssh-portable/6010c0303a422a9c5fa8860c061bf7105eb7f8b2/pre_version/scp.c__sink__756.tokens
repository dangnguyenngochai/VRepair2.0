void //<S2SV> sink ( int argc , char * * argv ) //<S2SV> { //<S2SV> static BUF buffer ; //<S2SV> struct stat stb ; //<S2SV> enum { //<S2SV> YES , NO , DISPLAYED //<S2SV> } wrerr ; //<S2SV> BUF * bp ; //<S2SV> off_t i ; //<S2SV> size_t j , count ; //<S2SV> int amt , exists , first , ofd ; //<S2SV> mode_t mode , omode , mask ; //<S2SV> off_t size , statbytes ; //<S2SV> unsigned long long ull ; //<S2SV> int setimes , targisdir , wrerrno = 0 ; //<S2SV> char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; //<S2SV> struct timeval tv [ 2 ] ; //<S2SV> # define atime tv [ 0 ] //<S2SV> # define mtime tv [ 1 ] //<S2SV> # define SCREWUP ( str ) { why = str ; goto screwup ; } //<S2SV> if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) //<S2SV> SCREWUP ( "Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size" ) ; //<S2SV> setimes = targisdir = 0 ; //<S2SV> mask = umask ( 0 ) ; //<S2SV> if ( ! pflag ) //<S2SV> ( void ) umask ( mask ) ; //<S2SV> if ( argc != 1 ) { //<S2SV> run_err ( "ambiguous<S2SV_blank>target" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> targ = * argv ; //<S2SV> if ( targetshouldbedirectory ) //<S2SV> verifydir ( targ ) ; //<S2SV> ( void ) atomicio ( vwrite , remout , "" , 1 ) ; //<S2SV> if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) //<S2SV> targisdir = 1 ; //<S2SV> for ( first = 1 ; ; first = 0 ) { //<S2SV> cp = buf ; //<S2SV> if ( atomicio ( read , remin , cp , 1 ) != 1 ) //<S2SV> return ; //<S2SV> if ( * cp ++ == '\\n' ) //<S2SV> SCREWUP ( "unexpected<S2SV_blank><newline>" ) ; //<S2SV> do { //<S2SV> if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) //<S2SV> SCREWUP ( "lost<S2SV_blank>connection" ) ; //<S2SV> * cp ++ = ch ; //<S2SV> } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; //<S2SV> * cp = 0 ; //<S2SV> if ( verbose_mode ) //<S2SV> fmprintf ( stderr , "Sink:<S2SV_blank>%s" , buf ) ; //<S2SV> if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { //<S2SV> if ( iamremote == 0 ) { //<S2SV> ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , //<S2SV> NULL , "%s" , buf + 1 ) ; //<S2SV> ( void ) atomicio ( vwrite , STDERR_FILENO , //<S2SV> visbuf , strlen ( visbuf ) ) ; //<S2SV> } //<S2SV> if ( buf [ 0 ] == '\\02' ) //<S2SV> exit ( 1 ) ; //<S2SV> ++ errs ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( buf [ 0 ] == 'E' ) { //<S2SV> ( void ) atomicio ( vwrite , remout , "" , 1 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ch == '\\n' ) //<S2SV> * -- cp = 0 ; //<S2SV> cp = buf ; //<S2SV> if ( * cp == 'T' ) { //<S2SV> setimes ++ ; //<S2SV> cp ++ ; //<S2SV> if ( ! isdigit ( ( unsigned char ) * cp ) ) //<S2SV> SCREWUP ( "mtime.sec<S2SV_blank>not<S2SV_blank>present" ) ; //<S2SV> ull = strtoull ( cp , & cp , 10 ) ; //<S2SV> if ( ! cp || * cp ++ != '<S2SV_blank>' ) //<S2SV> SCREWUP ( "mtime.sec<S2SV_blank>not<S2SV_blank>delimited" ) ; //<S2SV> if ( TYPE_OVERFLOW ( time_t , ull ) ) //<S2SV> setimes = 0 ; //<S2SV> mtime . tv_sec = ull ; //<S2SV> mtime . tv_usec = strtol ( cp , & cp , 10 ) ; //<S2SV> if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || //<S2SV> mtime . tv_usec > 999999 ) //<S2SV> SCREWUP ( "mtime.usec<S2SV_blank>not<S2SV_blank>delimited" ) ; //<S2SV> if ( ! isdigit ( ( unsigned char ) * cp ) ) //<S2SV> SCREWUP ( "atime.sec<S2SV_blank>not<S2SV_blank>present" ) ; //<S2SV> ull = strtoull ( cp , & cp , 10 ) ; //<S2SV> if ( ! cp || * cp ++ != '<S2SV_blank>' ) //<S2SV> SCREWUP ( "atime.sec<S2SV_blank>not<S2SV_blank>delimited" ) ; //<S2SV> if ( TYPE_OVERFLOW ( time_t , ull ) ) //<S2SV> setimes = 0 ; //<S2SV> atime . tv_sec = ull ; //<S2SV> atime . tv_usec = strtol ( cp , & cp , 10 ) ; //<S2SV> if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || //<S2SV> atime . tv_usec > 999999 ) //<S2SV> SCREWUP ( "atime.usec<S2SV_blank>not<S2SV_blank>delimited" ) ; //<S2SV> ( void ) atomicio ( vwrite , remout , "" , 1 ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( * cp != 'C' && * cp != 'D' ) { //<S2SV> if ( first ) { //<S2SV> run_err ( "%s" , cp ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> SCREWUP ( "expected<S2SV_blank>control<S2SV_blank>record" ) ; //<S2SV> } //<S2SV> mode = 0 ; //<S2SV> for ( ++ cp ; cp < buf + 5 ; cp ++ ) { //<S2SV> if ( * cp < '0' || * cp > '7' ) //<S2SV> SCREWUP ( "bad<S2SV_blank>mode" ) ; //<S2SV> mode = ( mode << 3 ) | ( * cp - '0' ) ; //<S2SV> } //<S2SV> if ( ! pflag ) //<S2SV> mode &= ~ mask ; //<S2SV> if ( * cp ++ != '<S2SV_blank>' ) //<S2SV> SCREWUP ( "mode<S2SV_blank>not<S2SV_blank>delimited" ) ; //<S2SV> if ( ! isdigit ( ( unsigned char ) * cp ) ) //<S2SV> SCREWUP ( "size<S2SV_blank>not<S2SV_blank>present" ) ; //<S2SV> ull = strtoull ( cp , & cp , 10 ) ; //<S2SV> if ( ! cp || * cp ++ != '<S2SV_blank>' ) //<S2SV> SCREWUP ( "size<S2SV_blank>not<S2SV_blank>delimited" ) ; //<S2SV> if ( TYPE_OVERFLOW ( off_t , ull ) ) //<S2SV> SCREWUP ( "size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" ) ; //<S2SV> size = ( off_t ) ull ; //<S2SV> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , ".." ) == 0 ) ) { //<S2SV> run_err ( "error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s" , cp ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> if ( targisdir ) { //<S2SV> static char * namebuf ; //<S2SV> static size_t cursize ; //<S2SV> size_t need ; //<S2SV> need = strlen ( targ ) + strlen ( cp ) + 250 ; //<S2SV> if ( need > cursize ) { //<S2SV> free ( namebuf ) ; //<S2SV> namebuf = xmalloc ( need ) ; //<S2SV> cursize = need ; //<S2SV> } //<S2SV> ( void ) snprintf ( namebuf , need , "%s%s%s" , targ , //<S2SV> strcmp ( targ , "/" ) ? "/" : "" , cp ) ; //<S2SV> np = namebuf ; //<S2SV> } else //<S2SV> np = targ ; //<S2SV> curfile = cp ; //<S2SV> exists = stat ( np , & stb ) == 0 ; //<S2SV> if ( buf [ 0 ] == 'D' ) { //<S2SV> int mod_flag = pflag ; //<S2SV> if ( ! iamrecursive ) //<S2SV> SCREWUP ( "received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r" ) ; //<S2SV> if ( exists ) { //<S2SV> if ( ! S_ISDIR ( stb . st_mode ) ) { //<S2SV> errno = ENOTDIR ; //<S2SV> goto bad ; //<S2SV> } //<S2SV> if ( pflag ) //<S2SV> ( void ) chmod ( np , mode ) ; //<S2SV> } else { //<S2SV> mod_flag = 1 ; //<S2SV> if ( mkdir ( np , mode | S_IRWXU ) < 0 ) //<S2SV> goto bad ; //<S2SV> } //<S2SV> vect [ 0 ] = xstrdup ( np ) ; //<S2SV> sink ( 1 , vect ) ; //<S2SV> if ( setimes ) { //<S2SV> setimes = 0 ; //<S2SV> if ( utimes ( vect [ 0 ] , tv ) < 0 ) //<S2SV> run_err ( "%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s" , //<S2SV> vect [ 0 ] , strerror ( errno ) ) ; //<S2SV> } //<S2SV> if ( mod_flag ) //<S2SV> ( void ) chmod ( vect [ 0 ] , mode ) ; //<S2SV> free ( vect [ 0 ] ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> omode = mode ; //<S2SV> mode |= S_IWUSR ; //<S2SV> if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) < 0 ) { //<S2SV> bad : run_err ( "%s:<S2SV_blank>%s" , np , strerror ( errno ) ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> ( void ) atomicio ( vwrite , remout , "" , 1 ) ; //<S2SV> if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { //<S2SV> ( void ) close ( ofd ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> cp = bp -> buf ; //<S2SV> wrerr = NO ; //<S2SV> statbytes = 0 ; //<S2SV> if ( showprogress ) //<S2SV> start_progress_meter ( curfile , size , & statbytes ) ; //<S2SV> set_nonblock ( remin ) ; //<S2SV> for ( count = i = 0 ; i < size ; i += bp -> cnt ) { //<S2SV> amt = bp -> cnt ; //<S2SV> if ( i + amt > size ) //<S2SV> amt = size - i ; //<S2SV> count += amt ; //<S2SV> do { //<S2SV> j = atomicio6 ( read , remin , cp , amt , //<S2SV> scpio , & statbytes ) ; //<S2SV> if ( j == 0 ) { //<S2SV> run_err ( "%s" , j != EPIPE ? //<S2SV> strerror ( errno ) : //<S2SV> "dropped<S2SV_blank>connection" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> amt -= j ; //<S2SV> cp += j ; //<S2SV> } while ( amt > 0 ) ; //<S2SV> if ( count == bp -> cnt ) { //<S2SV> if ( wrerr == NO ) { //<S2SV> if ( atomicio ( vwrite , ofd , bp -> buf , //<S2SV> count ) != count ) { //<S2SV> wrerr = YES ; //<S2SV> wrerrno = errno ; //<S2SV> } //<S2SV> } //<S2SV> count = 0 ; //<S2SV> cp = bp -> buf ; //<S2SV> } //<S2SV> } //<S2SV> unset_nonblock ( remin ) ; //<S2SV> if ( count != 0 && wrerr == NO && //<S2SV> atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { //<S2SV> wrerr = YES ; //<S2SV> wrerrno = errno ; //<S2SV> } //<S2SV> if ( wrerr == NO && ( ! exists || S_ISREG ( stb . st_mode ) ) && //<S2SV> ftruncate ( ofd , size ) != 0 ) { //<S2SV> run_err ( "%s:<S2SV_blank>truncate:<S2SV_blank>%s" , np , strerror ( errno ) ) ; //<S2SV> wrerr = DISPLAYED ; //<S2SV> } //<S2SV> if ( pflag ) { //<S2SV> if ( exists || omode != mode ) //<S2SV> # ifdef HAVE_FCHMOD //<S2SV> if ( fchmod ( ofd , omode ) ) { //<S2SV> # else //<S2SV> if ( chmod ( np , omode ) ) { //<S2SV> # endif //<S2SV> run_err ( "%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s" , //<S2SV> np , strerror ( errno ) ) ; //<S2SV> wrerr = DISPLAYED ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( ! exists && omode != mode ) //<S2SV> # ifdef HAVE_FCHMOD //<S2SV> if ( fchmod ( ofd , omode & ~ mask ) ) { //<S2SV> # else //<S2SV> if ( chmod ( np , omode & ~ mask ) ) { //<S2SV> # endif //<S2SV> run_err ( "%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s" , //<S2SV> np , strerror ( errno ) ) ; //<S2SV> wrerr = DISPLAYED ; //<S2SV> } //<S2SV> } //<S2SV> if ( close ( ofd ) == - 1 ) { //<S2SV> wrerr = YES ; //<S2SV> wrerrno = errno ; //<S2SV> } //<S2SV> ( void ) response ( ) ; //<S2SV> if ( showprogress ) //<S2SV> stop_progress_meter ( ) ; //<S2SV> if ( setimes && wrerr == NO ) { //<S2SV> setimes = 0 ; //<S2SV> if ( utimes ( np , tv ) < 0 ) { //<S2SV> run_err ( "%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s" , //<S2SV> np , strerror ( errno ) ) ; //<S2SV> wrerr = DISPLAYED ; //<S2SV> } //<S2SV> } //<S2SV> switch ( wrerr ) { //<S2SV> case YES : //<S2SV> run_err ( "%s:<S2SV_blank>%s" , np , strerror ( wrerrno ) ) ; //<S2SV> break ; //<S2SV> case NO : //<S2SV> ( void ) atomicio ( vwrite , remout , "" , 1 ) ; //<S2SV> break ; //<S2SV> case DISPLAYED : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> screwup : //<S2SV> run_err ( "protocol<S2SV_blank>error:<S2SV_blank>%s" , why ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> 