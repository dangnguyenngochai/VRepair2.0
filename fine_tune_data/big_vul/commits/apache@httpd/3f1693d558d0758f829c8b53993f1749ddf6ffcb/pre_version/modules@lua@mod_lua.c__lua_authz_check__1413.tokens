static authz_status lua_authz_check ( request_rec * r , const char * require_line , //<S2SV> const void * parsed_require_line ) //<S2SV> { //<S2SV> apr_pool_t * pool ; //<S2SV> ap_lua_vm_spec * spec ; //<S2SV> lua_State * L ; //<S2SV> ap_lua_server_cfg * server_cfg = ap_get_module_config ( r -> server -> module_config , //<S2SV> & lua_module ) ; //<S2SV> const ap_lua_dir_cfg * cfg = ap_get_module_config ( r -> per_dir_config , //<S2SV> & lua_module ) ; //<S2SV> const lua_authz_provider_spec * prov_spec = parsed_require_line ; //<S2SV> int result ; //<S2SV> int nargs = 0 ; //<S2SV> spec = create_vm_spec ( & pool , r , cfg , server_cfg , prov_spec -> file_name , //<S2SV> NULL , 0 , prov_spec -> function_name , "authz<S2SV_blank>provider" ) ; //<S2SV> L = ap_lua_get_lua_state ( pool , spec , r ) ; //<S2SV> if ( L == NULL ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02314 ) //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>VM<S2SV_blank>for<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s" , prov_spec -> name ) ; //<S2SV> return AUTHZ_GENERAL_ERROR ; //<S2SV> } //<S2SV> lua_getglobal ( L , prov_spec -> function_name ) ; //<S2SV> if ( ! lua_isfunction ( L , - 1 ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_CRIT , 0 , r , APLOGNO ( 02319 ) //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>entry<S2SV_blank>function<S2SV_blank>\'%s\'<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>function)" , //<S2SV> prov_spec -> function_name , prov_spec -> file_name ) ; //<S2SV> ap_lua_release_state ( L , spec , r ) ; //<S2SV> return AUTHZ_GENERAL_ERROR ; //<S2SV> } //<S2SV> ap_lua_run_lua_request ( L , r ) ; //<S2SV> if ( prov_spec -> args ) { //<S2SV> int i ; //<S2SV> if ( ! lua_checkstack ( L , prov_spec -> args -> nelts ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02315 ) //<S2SV> "Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>arguments" , prov_spec -> name ) ; //<S2SV> ap_lua_release_state ( L , spec , r ) ; //<S2SV> return AUTHZ_GENERAL_ERROR ; //<S2SV> } //<S2SV> for ( i = 0 ; i < prov_spec -> args -> nelts ; i ++ ) { //<S2SV> const char * arg = APR_ARRAY_IDX ( prov_spec -> args , i , const char * ) ; //<S2SV> lua_pushstring ( L , arg ) ; //<S2SV> } //<S2SV> nargs = prov_spec -> args -> nelts ; //<S2SV> } //<S2SV> if ( lua_pcall ( L , 1 + nargs , 1 , 0 ) ) { //<S2SV> const char * err = lua_tostring ( L , - 1 ) ; //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02316 ) //<S2SV> "Error<S2SV_blank>executing<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>%s" , prov_spec -> name , err ) ; //<S2SV> ap_lua_release_state ( L , spec , r ) ; //<S2SV> return AUTHZ_GENERAL_ERROR ; //<S2SV> } //<S2SV> if ( ! lua_isnumber ( L , - 1 ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02317 ) //<S2SV> "Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s<S2SV_blank>did<S2SV_blank>not<S2SV_blank>return<S2SV_blank>integer" , prov_spec -> name ) ; //<S2SV> ap_lua_release_state ( L , spec , r ) ; //<S2SV> return AUTHZ_GENERAL_ERROR ; //<S2SV> } //<S2SV> result = lua_tointeger ( L , - 1 ) ; //<S2SV> ap_lua_release_state ( L , spec , r ) ; //<S2SV> switch ( result ) { //<S2SV> case AUTHZ_DENIED : //<S2SV> case AUTHZ_GRANTED : //<S2SV> case AUTHZ_NEUTRAL : //<S2SV> case AUTHZ_GENERAL_ERROR : //<S2SV> case AUTHZ_DENIED_NO_USER : //<S2SV> return result ; //<S2SV> default : //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02318 ) //<S2SV> "Error:<S2SV_blank>authz<S2SV_blank>provider<S2SV_blank>%s:<S2SV_blank>invalid<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d" , //<S2SV> prov_spec -> name , result ) ; //<S2SV> } //<S2SV> return AUTHZ_GENERAL_ERROR ; //<S2SV> } //<S2SV> 