apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , //<S2SV> ap_input_mode_t mode , apr_read_type_e block , //<S2SV> apr_off_t readbytes ) //<S2SV> { //<S2SV> core_server_config * conf ; //<S2SV> apr_bucket * e ; //<S2SV> http_ctx_t * ctx = f -> ctx ; //<S2SV> apr_status_t rv ; //<S2SV> apr_off_t totalread ; //<S2SV> int again ; //<S2SV> conf = ( core_server_config * ) //<S2SV> ap_get_module_config ( f -> r -> server -> module_config , & core_module ) ; //<S2SV> if ( mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE ) { //<S2SV> return ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; //<S2SV> } //<S2SV> if ( ! ctx ) { //<S2SV> const char * tenc , * lenp ; //<S2SV> f -> ctx = ctx = apr_pcalloc ( f -> r -> pool , sizeof ( * ctx ) ) ; //<S2SV> ctx -> state = BODY_NONE ; //<S2SV> if ( ! f -> r -> proxyreq ) { //<S2SV> ctx -> limit = ap_get_limit_req_body ( f -> r ) ; //<S2SV> } //<S2SV> else { //<S2SV> ctx -> limit = 0 ; //<S2SV> } //<S2SV> tenc = apr_table_get ( f -> r -> headers_in , "Transfer-Encoding" ) ; //<S2SV> lenp = apr_table_get ( f -> r -> headers_in , "Content-Length" ) ; //<S2SV> if ( tenc ) { //<S2SV> if ( strcasecmp ( tenc , "chunked" ) == 0 //<S2SV> || ap_find_last_token ( f -> r -> pool , tenc , "chunked" ) ) { //<S2SV> ctx -> state = BODY_CHUNK ; //<S2SV> } //<S2SV> else if ( f -> r -> proxyreq == PROXYREQ_RESPONSE ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) //<S2SV> "Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>" //<S2SV> "using<S2SV_blank>read-until-close" , tenc ) ; //<S2SV> tenc = NULL ; //<S2SV> } //<S2SV> else { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01585 ) //<S2SV> "Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s" , tenc ) ; //<S2SV> return APR_EGENERAL ; //<S2SV> } //<S2SV> lenp = NULL ; //<S2SV> } //<S2SV> if ( lenp ) { //<S2SV> char * endstr ; //<S2SV> ctx -> state = BODY_LENGTH ; //<S2SV> if ( apr_strtoff ( & ctx -> remaining , lenp , & endstr , 10 ) //<S2SV> || endstr == lenp || * endstr || ctx -> remaining < 0 ) { //<S2SV> ctx -> remaining = 0 ; //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01587 ) //<S2SV> "Invalid<S2SV_blank>Content-Length" ) ; //<S2SV> return APR_EINVAL ; //<S2SV> } //<S2SV> if ( ctx -> limit && ctx -> limit < ctx -> remaining ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01588 ) //<S2SV> "Requested<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%" APR_OFF_T_FMT //<S2SV> "<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit" //<S2SV> "<S2SV_blank>of<S2SV_blank>%" APR_OFF_T_FMT , ctx -> remaining , ctx -> limit ) ; //<S2SV> return APR_ENOSPC ; //<S2SV> } //<S2SV> } //<S2SV> if ( ctx -> state == BODY_NONE && f -> r -> proxyreq != PROXYREQ_RESPONSE ) { //<S2SV> e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; //<S2SV> APR_BRIGADE_INSERT_TAIL ( b , e ) ; //<S2SV> ctx -> eos_sent = 1 ; //<S2SV> return APR_SUCCESS ; //<S2SV> } //<S2SV> if ( ( ctx -> state == BODY_CHUNK //<S2SV> || ( ctx -> state == BODY_LENGTH && ctx -> remaining > 0 ) ) //<S2SV> && f -> r -> expecting_100 && f -> r -> proto_num >= HTTP_VERSION ( 1 , 1 ) //<S2SV> && ! ( f -> r -> eos_sent || f -> r -> bytes_sent ) ) { //<S2SV> if ( ! ap_is_HTTP_SUCCESS ( f -> r -> status ) ) { //<S2SV> ctx -> state = BODY_NONE ; //<S2SV> ctx -> eos_sent = 1 ; //<S2SV> } //<S2SV> else { //<S2SV> char * tmp ; //<S2SV> int len ; //<S2SV> apr_bucket_brigade * bb ; //<S2SV> bb = apr_brigade_create ( f -> r -> pool , f -> c -> bucket_alloc ) ; //<S2SV> f -> r -> expecting_100 = 0 ; //<S2SV> tmp = apr_pstrcat ( f -> r -> pool , AP_SERVER_PROTOCOL "<S2SV_blank>" , //<S2SV> ap_get_status_line ( HTTP_CONTINUE ) , CRLF CRLF , NULL ) ; //<S2SV> len = strlen ( tmp ) ; //<S2SV> ap_xlate_proto_to_ascii ( tmp , len ) ; //<S2SV> e = apr_bucket_pool_create ( tmp , len , f -> r -> pool , //<S2SV> f -> c -> bucket_alloc ) ; //<S2SV> APR_BRIGADE_INSERT_HEAD ( bb , e ) ; //<S2SV> e = apr_bucket_flush_create ( f -> c -> bucket_alloc ) ; //<S2SV> APR_BRIGADE_INSERT_TAIL ( bb , e ) ; //<S2SV> rv = ap_pass_brigade ( f -> c -> output_filters , bb ) ; //<S2SV> apr_brigade_cleanup ( bb ) ; //<S2SV> if ( rv != APR_SUCCESS ) { //<S2SV> return AP_FILTER_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ctx -> eos_sent ) { //<S2SV> e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; //<S2SV> APR_BRIGADE_INSERT_TAIL ( b , e ) ; //<S2SV> return APR_SUCCESS ; //<S2SV> } //<S2SV> do { //<S2SV> apr_brigade_cleanup ( b ) ; //<S2SV> again = 0 ; //<S2SV> switch ( ctx -> state ) { //<S2SV> case BODY_CHUNK : //<S2SV> case BODY_CHUNK_PART : //<S2SV> case BODY_CHUNK_EXT : //<S2SV> case BODY_CHUNK_LF : //<S2SV> case BODY_CHUNK_END : //<S2SV> case BODY_CHUNK_END_LF : { //<S2SV> rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ; //<S2SV> if ( block == APR_NONBLOCK_READ //<S2SV> && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) //<S2SV> || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { //<S2SV> return APR_EAGAIN ; //<S2SV> } //<S2SV> if ( rv == APR_EOF ) { //<S2SV> return APR_INCOMPLETE ; //<S2SV> } //<S2SV> if ( rv != APR_SUCCESS ) { //<S2SV> return rv ; //<S2SV> } //<S2SV> e = APR_BRIGADE_FIRST ( b ) ; //<S2SV> while ( e != APR_BRIGADE_SENTINEL ( b ) ) { //<S2SV> const char * buffer ; //<S2SV> apr_size_t len ; //<S2SV> if ( ! APR_BUCKET_IS_METADATA ( e ) ) { //<S2SV> rv = apr_bucket_read ( e , & buffer , & len , APR_BLOCK_READ ) ; //<S2SV> if ( rv == APR_SUCCESS ) { //<S2SV> rv = parse_chunk_size ( ctx , buffer , len , //<S2SV> f -> r -> server -> limit_req_fieldsize ) ; //<S2SV> } //<S2SV> if ( rv != APR_SUCCESS ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , rv , f -> r , APLOGNO ( 01590 ) //<S2SV> "Error<S2SV_blank>reading<S2SV_blank>chunk<S2SV_blank>%s<S2SV_blank>" , //<S2SV> ( APR_ENOSPC == rv ) ? "(overflow)" : "" ) ; //<S2SV> return rv ; //<S2SV> } //<S2SV> } //<S2SV> apr_bucket_delete ( e ) ; //<S2SV> e = APR_BRIGADE_FIRST ( b ) ; //<S2SV> } //<S2SV> again = 1 ; //<S2SV> if ( ctx -> state == BODY_CHUNK_TRAILER ) { //<S2SV> return read_chunked_trailers ( ctx , f , b , //<S2SV> conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case BODY_NONE : //<S2SV> case BODY_LENGTH : //<S2SV> case BODY_CHUNK_DATA : { //<S2SV> if ( ctx -> state != BODY_NONE && ctx -> remaining < readbytes ) { //<S2SV> readbytes = ctx -> remaining ; //<S2SV> } //<S2SV> if ( readbytes > 0 ) { //<S2SV> rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; //<S2SV> if ( block == APR_NONBLOCK_READ //<S2SV> && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) //<S2SV> || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { //<S2SV> return APR_EAGAIN ; //<S2SV> } //<S2SV> if ( rv == APR_EOF && ctx -> state != BODY_NONE //<S2SV> && ctx -> remaining > 0 ) { //<S2SV> return APR_INCOMPLETE ; //<S2SV> } //<S2SV> if ( rv != APR_SUCCESS ) { //<S2SV> return rv ; //<S2SV> } //<S2SV> apr_brigade_length ( b , 0 , & totalread ) ; //<S2SV> AP_DEBUG_ASSERT ( totalread >= 0 ) ; //<S2SV> if ( ctx -> state != BODY_NONE ) { //<S2SV> ctx -> remaining -= totalread ; //<S2SV> if ( ctx -> remaining > 0 ) { //<S2SV> e = APR_BRIGADE_LAST ( b ) ; //<S2SV> if ( APR_BUCKET_IS_EOS ( e ) ) { //<S2SV> apr_bucket_delete ( e ) ; //<S2SV> return APR_INCOMPLETE ; //<S2SV> } //<S2SV> } //<S2SV> else if ( ctx -> state == BODY_CHUNK_DATA ) { //<S2SV> ctx -> state = BODY_CHUNK_END ; //<S2SV> ctx -> chunk_used = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ctx -> state == BODY_LENGTH && ctx -> remaining == 0 ) { //<S2SV> e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; //<S2SV> APR_BRIGADE_INSERT_TAIL ( b , e ) ; //<S2SV> ctx -> eos_sent = 1 ; //<S2SV> } //<S2SV> if ( ctx -> limit ) { //<S2SV> ctx -> limit_used += totalread ; //<S2SV> if ( ctx -> limit < ctx -> limit_used ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01591 ) //<S2SV> "Read<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%" APR_OFF_T_FMT //<S2SV> "<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit" //<S2SV> "<S2SV_blank>of<S2SV_blank>%" APR_OFF_T_FMT , ctx -> limit_used , ctx -> limit ) ; //<S2SV> return APR_ENOSPC ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case BODY_CHUNK_TRAILER : { //<S2SV> rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; //<S2SV> if ( block == APR_NONBLOCK_READ //<S2SV> && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) //<S2SV> || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { //<S2SV> return APR_EAGAIN ; //<S2SV> } //<S2SV> if ( rv != APR_SUCCESS ) { //<S2SV> return rv ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> default : { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) //<S2SV> "Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)" , ( int ) ctx -> state ) ; //<S2SV> return APR_EGENERAL ; //<S2SV> } //<S2SV> } //<S2SV> } while ( again ) ; //<S2SV> return APR_SUCCESS ; //<S2SV> } //<S2SV> 