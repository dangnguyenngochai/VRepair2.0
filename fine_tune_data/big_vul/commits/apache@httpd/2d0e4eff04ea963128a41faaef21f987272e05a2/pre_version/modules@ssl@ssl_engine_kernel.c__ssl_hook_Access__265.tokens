int ssl_hook_Access ( request_rec * r ) //<S2SV> { //<S2SV> SSLDirConfigRec * dc = myDirConfig ( r ) ; //<S2SV> SSLSrvConfigRec * sc = mySrvConfig ( r -> server ) ; //<S2SV> SSLConnRec * sslconn = myConnConfig ( r -> connection ) ; //<S2SV> SSL * ssl = sslconn ? sslconn -> ssl : NULL ; //<S2SV> server_rec * handshakeserver = sslconn ? sslconn -> server : NULL ; //<S2SV> SSLSrvConfigRec * hssc = handshakeserver ? mySrvConfig ( handshakeserver ) : NULL ; //<S2SV> SSL_CTX * ctx = NULL ; //<S2SV> apr_array_header_t * requires ; //<S2SV> ssl_require_t * ssl_requires ; //<S2SV> int ok , i ; //<S2SV> BOOL renegotiate = FALSE , renegotiate_quick = FALSE ; //<S2SV> X509 * cert ; //<S2SV> X509 * peercert ; //<S2SV> X509_STORE * cert_store = NULL ; //<S2SV> X509_STORE_CTX * cert_store_ctx ; //<S2SV> STACK_OF ( SSL_CIPHER ) * cipher_list_old = NULL , * cipher_list = NULL ; //<S2SV> const SSL_CIPHER * cipher = NULL ; //<S2SV> int depth , verify_old , verify , n , is_slave = 0 ; //<S2SV> const char * ncipher_suite ; //<S2SV> if ( ! ( sslconn && ssl ) && r -> connection -> master ) { //<S2SV> sslconn = myConnConfig ( r -> connection -> master ) ; //<S2SV> ssl = sslconn ? sslconn -> ssl : NULL ; //<S2SV> handshakeserver = sslconn ? sslconn -> server : NULL ; //<S2SV> hssc = handshakeserver ? mySrvConfig ( handshakeserver ) : NULL ; //<S2SV> is_slave = 1 ; //<S2SV> } //<S2SV> if ( ssl ) { //<S2SV> if ( ! SSL_is_init_finished ( ssl ) ) { //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> ctx = SSL_get_SSL_CTX ( ssl ) ; //<S2SV> } //<S2SV> if ( dc -> bSSLRequired && ! ssl ) { //<S2SV> if ( ( sc -> enabled == SSL_ENABLED_OPTIONAL ) && ! is_slave ) { //<S2SV> apr_table_setn ( r -> err_headers_out , "Upgrade" , "TLS/1.0,<S2SV_blank>HTTP/1.1" ) ; //<S2SV> apr_table_setn ( r -> err_headers_out , "Connection" , "Upgrade" ) ; //<S2SV> return HTTP_UPGRADE_REQUIRED ; //<S2SV> } //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02219 ) //<S2SV> "access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>%s" , //<S2SV> r -> filename , "SSL<S2SV_blank>connection<S2SV_blank>required" ) ; //<S2SV> apr_table_setn ( r -> notes , "ssl-access-forbidden" , "1" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> if ( sc -> enabled == SSL_ENABLED_FALSE || ! ssl ) { //<S2SV> return DECLINED ; //<S2SV> } //<S2SV> # ifdef HAVE_SRP //<S2SV> if ( SSL_get_srp_username ( ssl ) ) { //<S2SV> return DECLINED ; //<S2SV> } //<S2SV> # endif //<S2SV> ncipher_suite = ( dc -> szCipherSuite ? //<S2SV> dc -> szCipherSuite : ( r -> server != handshakeserver ) ? //<S2SV> sc -> server -> auth . cipher_suite : NULL ) ; //<S2SV> if ( ncipher_suite && ( ! sslconn -> cipher_suite //<S2SV> || strcmp ( ncipher_suite , sslconn -> cipher_suite ) ) ) { //<S2SV> if ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) { //<S2SV> cipher = SSL_get_current_cipher ( ssl ) ; //<S2SV> } //<S2SV> else { //<S2SV> cipher_list_old = ( STACK_OF ( SSL_CIPHER ) * ) SSL_get_ciphers ( ssl ) ; //<S2SV> if ( cipher_list_old ) { //<S2SV> cipher_list_old = sk_SSL_CIPHER_dup ( cipher_list_old ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( is_slave ) { //<S2SV> apr_table_setn ( r -> notes , "ssl-renegotiate-forbidden" , "cipher-suite" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> if ( ! SSL_set_cipher_list ( ssl , ncipher_suite ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , APLOGNO ( 02253 ) //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>reconfigure<S2SV_blank>(per-directory)<S2SV_blank>" //<S2SV> "permitted<S2SV_blank>SSL<S2SV_blank>ciphers" ) ; //<S2SV> ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; //<S2SV> if ( cipher_list_old ) { //<S2SV> sk_SSL_CIPHER_free ( cipher_list_old ) ; //<S2SV> } //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> cipher_list = ( STACK_OF ( SSL_CIPHER ) * ) SSL_get_ciphers ( ssl ) ; //<S2SV> if ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) { //<S2SV> if ( ( ! cipher && cipher_list ) || //<S2SV> ( cipher && ! cipher_list ) ) //<S2SV> { //<S2SV> renegotiate = TRUE ; //<S2SV> } //<S2SV> else if ( cipher && cipher_list && //<S2SV> ( sk_SSL_CIPHER_find ( cipher_list , cipher ) < 0 ) ) //<S2SV> { //<S2SV> renegotiate = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> if ( ( ! cipher_list_old && cipher_list ) || //<S2SV> ( cipher_list_old && ! cipher_list ) ) //<S2SV> { //<S2SV> renegotiate = TRUE ; //<S2SV> } //<S2SV> else if ( cipher_list_old && cipher_list ) { //<S2SV> for ( n = 0 ; //<S2SV> ! renegotiate && ( n < sk_SSL_CIPHER_num ( cipher_list ) ) ; //<S2SV> n ++ ) //<S2SV> { //<S2SV> const SSL_CIPHER * value = sk_SSL_CIPHER_value ( cipher_list , n ) ; //<S2SV> if ( sk_SSL_CIPHER_find ( cipher_list_old , value ) < 0 ) { //<S2SV> renegotiate = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> for ( n = 0 ; //<S2SV> ! renegotiate && ( n < sk_SSL_CIPHER_num ( cipher_list_old ) ) ; //<S2SV> n ++ ) //<S2SV> { //<S2SV> const SSL_CIPHER * value = sk_SSL_CIPHER_value ( cipher_list_old , n ) ; //<S2SV> if ( sk_SSL_CIPHER_find ( cipher_list , value ) < 0 ) { //<S2SV> renegotiate = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( cipher_list_old ) { //<S2SV> sk_SSL_CIPHER_free ( cipher_list_old ) ; //<S2SV> } //<S2SV> if ( renegotiate ) { //<S2SV> if ( is_slave ) { //<S2SV> apr_table_setn ( r -> notes , "ssl-renegotiate-forbidden" , "cipher-suite" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> # ifdef SSL_OP_CIPHER_SERVER_PREFERENCE //<S2SV> if ( sc -> cipher_server_pref == TRUE ) { //<S2SV> SSL_set_options ( ssl , SSL_OP_CIPHER_SERVER_PREFERENCE ) ; //<S2SV> } //<S2SV> # endif //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02220 ) //<S2SV> "Reconfigured<S2SV_blank>cipher<S2SV_blank>suite<S2SV_blank>will<S2SV_blank>force<S2SV_blank>renegotiation" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( dc -> nVerifyClient != SSL_CVERIFY_UNSET ) || //<S2SV> ( sc -> server -> auth . verify_mode != SSL_CVERIFY_UNSET ) ) { //<S2SV> verify_old = SSL_get_verify_mode ( ssl ) ; //<S2SV> verify = SSL_VERIFY_NONE ; //<S2SV> if ( ( dc -> nVerifyClient == SSL_CVERIFY_REQUIRE ) || //<S2SV> ( sc -> server -> auth . verify_mode == SSL_CVERIFY_REQUIRE ) ) { //<S2SV> verify |= SSL_VERIFY_PEER_STRICT ; //<S2SV> } //<S2SV> if ( ( dc -> nVerifyClient == SSL_CVERIFY_OPTIONAL ) || //<S2SV> ( dc -> nVerifyClient == SSL_CVERIFY_OPTIONAL_NO_CA ) || //<S2SV> ( sc -> server -> auth . verify_mode == SSL_CVERIFY_OPTIONAL ) || //<S2SV> ( sc -> server -> auth . verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA ) ) //<S2SV> { //<S2SV> verify |= SSL_VERIFY_PEER ; //<S2SV> } //<S2SV> SSL_set_verify ( ssl , verify , ssl_callback_SSLVerify ) ; //<S2SV> SSL_set_verify_result ( ssl , X509_V_OK ) ; //<S2SV> if ( ! renegotiate && verify != verify_old ) { //<S2SV> if ( ( ( verify_old == SSL_VERIFY_NONE ) && //<S2SV> ( verify != SSL_VERIFY_NONE ) ) || //<S2SV> ( ! ( verify_old & SSL_VERIFY_PEER ) && //<S2SV> ( verify & SSL_VERIFY_PEER ) ) || //<S2SV> ( ! ( verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) && //<S2SV> ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) ) //<S2SV> { //<S2SV> renegotiate = TRUE ; //<S2SV> if ( is_slave ) { //<S2SV> apr_table_setn ( r -> notes , "ssl-renegotiate-forbidden" , "verify-client" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> if ( ( dc -> nOptions & SSL_OPT_OPTRENEGOTIATE ) && //<S2SV> ( verify_old == SSL_VERIFY_NONE ) && //<S2SV> ( ( peercert = SSL_get_peer_certificate ( ssl ) ) != NULL ) ) //<S2SV> { //<S2SV> renegotiate_quick = TRUE ; //<S2SV> X509_free ( peercert ) ; //<S2SV> } //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02255 ) //<S2SV> "Changed<S2SV_blank>client<S2SV_blank>verification<S2SV_blank>type<S2SV_blank>will<S2SV_blank>force<S2SV_blank>" //<S2SV> "%srenegotiation" , //<S2SV> renegotiate_quick ? "quick<S2SV_blank>" : "" ) ; //<S2SV> } //<S2SV> else if ( verify != SSL_VERIFY_NONE ) { //<S2SV> n = ( sslconn -> verify_depth != UNSET ) //<S2SV> ? sslconn -> verify_depth //<S2SV> : hssc -> server -> auth . verify_depth ; //<S2SV> sslconn -> verify_depth = ( dc -> nVerifyDepth != UNSET ) //<S2SV> ? dc -> nVerifyDepth //<S2SV> : sc -> server -> auth . verify_depth ; //<S2SV> if ( sslconn -> verify_depth < n ) { //<S2SV> renegotiate = TRUE ; //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02254 ) //<S2SV> "Reduced<S2SV_blank>client<S2SV_blank>verification<S2SV_blank>depth<S2SV_blank>will<S2SV_blank>" //<S2SV> "force<S2SV_blank>renegotiation" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( r -> server != handshakeserver ) //<S2SV> && renegotiate //<S2SV> && ( ( verify & SSL_VERIFY_PEER ) || //<S2SV> ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) ) { //<S2SV> # define MODSSL_CFG_CA_NE ( f , sc1 , sc2 ) ( sc1 -> server -> auth . f && ( ! sc2 -> server -> auth . f || strNE ( sc1 -> server -> auth . f , sc2 -> server -> auth . f ) ) ) //<S2SV> if ( MODSSL_CFG_CA_NE ( ca_cert_file , sc , hssc ) || //<S2SV> MODSSL_CFG_CA_NE ( ca_cert_path , sc , hssc ) ) { //<S2SV> if ( verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02256 ) //<S2SV> "Non-default<S2SV_blank>virtual<S2SV_blank>host<S2SV_blank>with<S2SV_blank>SSLVerify<S2SV_blank>set<S2SV_blank>to<S2SV_blank>" //<S2SV> "\'require\'<S2SV_blank>and<S2SV_blank>VirtualHost-specific<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>" //<S2SV> "list<S2SV_blank>is<S2SV_blank>only<S2SV_blank>available<S2SV_blank>to<S2SV_blank>clients<S2SV_blank>with<S2SV_blank>TLS<S2SV_blank>server<S2SV_blank>" //<S2SV> "name<S2SV_blank>indication<S2SV_blank>(SNI)<S2SV_blank>support" ) ; //<S2SV> SSL_set_verify ( ssl , verify_old , NULL ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } else //<S2SV> sslconn -> verify_info = "GENEROUS" ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( renegotiate && ! renegotiate_quick //<S2SV> && ( apr_table_get ( r -> headers_in , "transfer-encoding" ) //<S2SV> || ( apr_table_get ( r -> headers_in , "content-length" ) //<S2SV> && strcmp ( apr_table_get ( r -> headers_in , "content-length" ) , "0" ) ) ) //<S2SV> && ! r -> expecting_100 ) { //<S2SV> int rv ; //<S2SV> apr_size_t rsize ; //<S2SV> rsize = dc -> nRenegBufferSize == UNSET ? DEFAULT_RENEG_BUFFER_SIZE : //<S2SV> dc -> nRenegBufferSize ; //<S2SV> if ( rsize > 0 ) { //<S2SV> rv = ssl_io_buffer_fill ( r , rsize ) ; //<S2SV> } //<S2SV> else { //<S2SV> rv = HTTP_REQUEST_ENTITY_TOO_LARGE ; //<S2SV> } //<S2SV> if ( rv ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02257 ) //<S2SV> "could<S2SV_blank>not<S2SV_blank>buffer<S2SV_blank>message<S2SV_blank>body<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>" //<S2SV> "SSL<S2SV_blank>renegotiation<S2SV_blank>to<S2SV_blank>proceed" ) ; //<S2SV> return rv ; //<S2SV> } //<S2SV> } //<S2SV> if ( renegotiate ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02221 ) //<S2SV> "Requesting<S2SV_blank>connection<S2SV_blank>re-negotiation" ) ; //<S2SV> if ( renegotiate_quick ) { //<S2SV> STACK_OF ( X509 ) * cert_stack ; //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02258 ) //<S2SV> "Performing<S2SV_blank>quick<S2SV_blank>renegotiation:<S2SV_blank>" //<S2SV> "just<S2SV_blank>re-verifying<S2SV_blank>the<S2SV_blank>peer" ) ; //<S2SV> cert_stack = ( STACK_OF ( X509 ) * ) SSL_get_peer_cert_chain ( ssl ) ; //<S2SV> cert = SSL_get_peer_certificate ( ssl ) ; //<S2SV> if ( ! cert_stack && cert ) { //<S2SV> cert_stack = sk_X509_new_null ( ) ; //<S2SV> sk_X509_push ( cert_stack , cert ) ; //<S2SV> } //<S2SV> if ( ! cert_stack || ( sk_X509_num ( cert_stack ) == 0 ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02222 ) //<S2SV> "Cannot<S2SV_blank>find<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>chain" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> if ( ! ( cert_store || //<S2SV> ( cert_store = SSL_CTX_get_cert_store ( ctx ) ) ) ) //<S2SV> { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02223 ) //<S2SV> "Cannot<S2SV_blank>find<S2SV_blank>certificate<S2SV_blank>storage" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> if ( ! cert ) { //<S2SV> cert = sk_X509_value ( cert_stack , 0 ) ; //<S2SV> } //<S2SV> cert_store_ctx = X509_STORE_CTX_new ( ) ; //<S2SV> X509_STORE_CTX_init ( cert_store_ctx , cert_store , cert , cert_stack ) ; //<S2SV> depth = SSL_get_verify_depth ( ssl ) ; //<S2SV> if ( depth >= 0 ) { //<S2SV> X509_STORE_CTX_set_depth ( cert_store_ctx , depth ) ; //<S2SV> } //<S2SV> X509_STORE_CTX_set_ex_data ( cert_store_ctx , //<S2SV> SSL_get_ex_data_X509_STORE_CTX_idx ( ) , //<S2SV> ( char * ) ssl ) ; //<S2SV> if ( ! X509_verify_cert ( cert_store_ctx ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02224 ) //<S2SV> "Re-negotiation<S2SV_blank>verification<S2SV_blank>step<S2SV_blank>failed" ) ; //<S2SV> ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; //<S2SV> } //<S2SV> SSL_set_verify_result ( ssl , X509_STORE_CTX_get_error ( cert_store_ctx ) ) ; //<S2SV> X509_STORE_CTX_cleanup ( cert_store_ctx ) ; //<S2SV> X509_STORE_CTX_free ( cert_store_ctx ) ; //<S2SV> if ( cert_stack != SSL_get_peer_cert_chain ( ssl ) ) { //<S2SV> sk_X509_pop_free ( cert_stack , X509_free ) ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> char peekbuf [ 1 ] ; //<S2SV> const char * reneg_support ; //<S2SV> request_rec * id = r -> main ? r -> main : r ; //<S2SV> if ( has_buffered_data ( r ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02259 ) //<S2SV> "insecure<S2SV_blank>SSL<S2SV_blank>re-negotiation<S2SV_blank>required,<S2SV_blank>but<S2SV_blank>" //<S2SV> "a<S2SV_blank>pipelined<S2SV_blank>request<S2SV_blank>is<S2SV_blank>present;<S2SV_blank>keepalive<S2SV_blank>" //<S2SV> "disabled" ) ; //<S2SV> r -> connection -> keepalive = AP_CONN_CLOSE ; //<S2SV> } //<S2SV> # if defined ( SSL_get_secure_renegotiation_support ) //<S2SV> reneg_support = SSL_get_secure_renegotiation_support ( ssl ) ? //<S2SV> "client<S2SV_blank>does" : "client<S2SV_blank>does<S2SV_blank>not" ; //<S2SV> # else //<S2SV> reneg_support = "server<S2SV_blank>does<S2SV_blank>not" ; //<S2SV> # endif //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , APLOGNO ( 02260 ) //<S2SV> "Performing<S2SV_blank>full<S2SV_blank>renegotiation:<S2SV_blank>complete<S2SV_blank>handshake<S2SV_blank>" //<S2SV> "protocol<S2SV_blank>(%s<S2SV_blank>support<S2SV_blank>secure<S2SV_blank>renegotiation)" , //<S2SV> reneg_support ) ; //<S2SV> SSL_set_session_id_context ( ssl , //<S2SV> ( unsigned char * ) & id , //<S2SV> sizeof ( id ) ) ; //<S2SV> sslconn -> reneg_state = RENEG_ALLOW ; //<S2SV> SSL_renegotiate ( ssl ) ; //<S2SV> SSL_do_handshake ( ssl ) ; //<S2SV> if ( ! SSL_is_init_finished ( ssl ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02225 ) //<S2SV> "Re-negotiation<S2SV_blank>request<S2SV_blank>failed" ) ; //<S2SV> ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; //<S2SV> r -> connection -> keepalive = AP_CONN_CLOSE ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02226 ) //<S2SV> "Awaiting<S2SV_blank>re-negotiation<S2SV_blank>handshake" ) ; //<S2SV> SSL_peek ( ssl , peekbuf , 0 ) ; //<S2SV> sslconn -> reneg_state = RENEG_REJECT ; //<S2SV> if ( ! SSL_is_init_finished ( ssl ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02261 ) //<S2SV> "Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed" ) ; //<S2SV> ssl_log_ssl_error ( SSLLOG_MARK , APLOG_ERR , r -> server ) ; //<S2SV> r -> connection -> keepalive = AP_CONN_CLOSE ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> sslconn -> server = r -> server ; //<S2SV> } //<S2SV> if ( ( cert = SSL_get_peer_certificate ( ssl ) ) ) { //<S2SV> if ( sslconn -> client_cert ) { //<S2SV> X509_free ( sslconn -> client_cert ) ; //<S2SV> } //<S2SV> sslconn -> client_cert = cert ; //<S2SV> sslconn -> client_dn = NULL ; //<S2SV> } //<S2SV> if ( ( dc -> nVerifyClient != SSL_CVERIFY_NONE ) || //<S2SV> ( sc -> server -> auth . verify_mode != SSL_CVERIFY_NONE ) ) { //<S2SV> BOOL do_verify = ( ( dc -> nVerifyClient == SSL_CVERIFY_REQUIRE ) || //<S2SV> ( sc -> server -> auth . verify_mode == SSL_CVERIFY_REQUIRE ) ) ; //<S2SV> if ( do_verify && ( SSL_get_verify_result ( ssl ) != X509_V_OK ) ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02262 ) //<S2SV> "Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed:<S2SV_blank>" //<S2SV> "Client<S2SV_blank>verification<S2SV_blank>failed" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> if ( do_verify ) { //<S2SV> if ( ( peercert = SSL_get_peer_certificate ( ssl ) ) == NULL ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02263 ) //<S2SV> "Re-negotiation<S2SV_blank>handshake<S2SV_blank>failed:<S2SV_blank>" //<S2SV> "Client<S2SV_blank>certificate<S2SV_blank>missing" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> X509_free ( peercert ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cipher_list ) { //<S2SV> cipher = SSL_get_current_cipher ( ssl ) ; //<S2SV> if ( sk_SSL_CIPHER_find ( cipher_list , cipher ) < 0 ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02264 ) //<S2SV> "SSL<S2SV_blank>cipher<S2SV_blank>suite<S2SV_blank>not<S2SV_blank>renegotiated:<S2SV_blank>" //<S2SV> "access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>denied<S2SV_blank>using<S2SV_blank>cipher<S2SV_blank>%s" , //<S2SV> r -> filename , //<S2SV> SSL_CIPHER_get_name ( cipher ) ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> } //<S2SV> if ( ncipher_suite ) { //<S2SV> sslconn -> cipher_suite = ncipher_suite ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( dc -> nOptions & SSL_OPT_FAKEBASICAUTH ) == 0 && dc -> szUserName ) { //<S2SV> char * val = ssl_var_lookup ( r -> pool , r -> server , r -> connection , //<S2SV> r , ( char * ) dc -> szUserName ) ; //<S2SV> if ( val && val [ 0 ] ) //<S2SV> r -> user = val ; //<S2SV> else //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_WARNING , 0 , r , APLOGNO ( 02227 ) //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>r->user<S2SV_blank>to<S2SV_blank>\'%s\'" , dc -> szUserName ) ; //<S2SV> } //<S2SV> requires = dc -> aRequirement ; //<S2SV> ssl_requires = ( ssl_require_t * ) requires -> elts ; //<S2SV> for ( i = 0 ; i < requires -> nelts ; i ++ ) { //<S2SV> ssl_require_t * req = & ssl_requires [ i ] ; //<S2SV> const char * errstring ; //<S2SV> ok = ap_expr_exec ( r , req -> mpExpr , & errstring ) ; //<S2SV> if ( ok < 0 ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02265 ) //<S2SV> "access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>" //<S2SV> "SSL<S2SV_blank>requirement<S2SV_blank>expression:<S2SV_blank>%s" , //<S2SV> r -> filename , errstring ) ; //<S2SV> apr_table_setn ( r -> notes , "ssl-access-forbidden" , "1" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> if ( ok != 1 ) { //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02266 ) //<S2SV> "Access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>denied<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>" //<S2SV> "(requirement<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>fulfilled)" , //<S2SV> r -> filename , r -> useragent_ip ) ; //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , r , APLOGNO ( 02228 ) //<S2SV> "Failed<S2SV_blank>expression:<S2SV_blank>%s" , req -> cpExpr ) ; //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02229 ) //<S2SV> "access<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>failed,<S2SV_blank>reason:<S2SV_blank>%s" , //<S2SV> r -> filename , //<S2SV> "SSL<S2SV_blank>requirement<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>fulfilled" ) ; //<S2SV> apr_table_setn ( r -> notes , "ssl-access-forbidden" , "1" ) ; //<S2SV> return HTTP_FORBIDDEN ; //<S2SV> } //<S2SV> } //<S2SV> return DECLINED ; //<S2SV> } //<S2SV> 