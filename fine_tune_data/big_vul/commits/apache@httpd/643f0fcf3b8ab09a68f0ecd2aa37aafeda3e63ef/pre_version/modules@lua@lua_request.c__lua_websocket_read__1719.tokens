static int lua_websocket_read ( lua_State * L ) //<S2SV> { //<S2SV> apr_socket_t * sock ; //<S2SV> apr_status_t rv ; //<S2SV> int n = 0 ; //<S2SV> apr_size_t len = 1 ; //<S2SV> apr_size_t plen = 0 ; //<S2SV> unsigned short payload_short = 0 ; //<S2SV> apr_uint64_t payload_long = 0 ; //<S2SV> unsigned char * mask_bytes ; //<S2SV> char byte ; //<S2SV> int plaintext ; //<S2SV> request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; //<S2SV> plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1 ; //<S2SV> mask_bytes = apr_pcalloc ( r -> pool , 4 ) ; //<S2SV> sock = ap_get_conn_socket ( r -> connection ) ; //<S2SV> if ( plaintext ) { //<S2SV> rv = apr_socket_recv ( sock , & byte , & len ) ; //<S2SV> } //<S2SV> else { //<S2SV> rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; //<S2SV> } //<S2SV> if ( rv == APR_SUCCESS ) { //<S2SV> unsigned char ubyte , fin , opcode , mask , payload ; //<S2SV> ubyte = ( unsigned char ) byte ; //<S2SV> fin = ubyte >> ( CHAR_BIT - 1 ) ; //<S2SV> opcode = ubyte & 0xf ; //<S2SV> if ( plaintext ) { //<S2SV> rv = apr_socket_recv ( sock , & byte , & len ) ; //<S2SV> } //<S2SV> else { //<S2SV> rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; //<S2SV> } //<S2SV> if ( rv == APR_SUCCESS ) { //<S2SV> ubyte = ( unsigned char ) byte ; //<S2SV> mask = ubyte >> ( CHAR_BIT - 1 ) ; //<S2SV> payload = ubyte & 0x7f ; //<S2SV> plen = payload ; //<S2SV> if ( payload == 126 ) { //<S2SV> len = 2 ; //<S2SV> if ( plaintext ) { //<S2SV> rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ) ; //<S2SV> } //<S2SV> else { //<S2SV> rv = lua_websocket_readbytes ( r -> connection , //<S2SV> ( char * ) & payload_short , 2 ) ; //<S2SV> } //<S2SV> payload_short = ntohs ( payload_short ) ; //<S2SV> if ( rv == APR_SUCCESS ) { //<S2SV> plen = payload_short ; //<S2SV> } //<S2SV> else { //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( payload == 127 ) { //<S2SV> len = 8 ; //<S2SV> if ( plaintext ) { //<S2SV> rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ) ; //<S2SV> } //<S2SV> else { //<S2SV> rv = lua_websocket_readbytes ( r -> connection , //<S2SV> ( char * ) & payload_long , 8 ) ; //<S2SV> } //<S2SV> if ( rv == APR_SUCCESS ) { //<S2SV> plen = ap_ntoh64 ( & payload_long ) ; //<S2SV> } //<S2SV> else { //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , //<S2SV> "Websocket:<S2SV_blank>Reading<S2SV_blank>%" APR_SIZE_T_FMT "<S2SV_blank>(%s)<S2SV_blank>bytes,<S2SV_blank>masking<S2SV_blank>is<S2SV_blank>%s.<S2SV_blank>%s" , //<S2SV> plen , //<S2SV> ( payload >= 126 ) ? "extra<S2SV_blank>payload" : "no<S2SV_blank>extra<S2SV_blank>payload" , //<S2SV> mask ? "on" : "off" , //<S2SV> fin ? "This<S2SV_blank>is<S2SV_blank>a<S2SV_blank>final<S2SV_blank>frame" : "more<S2SV_blank>to<S2SV_blank>follow" ) ; //<S2SV> if ( mask ) { //<S2SV> len = 4 ; //<S2SV> if ( plaintext ) { //<S2SV> rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ) ; //<S2SV> } //<S2SV> else { //<S2SV> rv = lua_websocket_readbytes ( r -> connection , //<S2SV> ( char * ) mask_bytes , 4 ) ; //<S2SV> } //<S2SV> if ( rv != APR_SUCCESS ) { //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 ) { //<S2SV> apr_size_t remaining = plen ; //<S2SV> apr_size_t received ; //<S2SV> apr_off_t at = 0 ; //<S2SV> char * buffer = apr_palloc ( r -> pool , plen + 1 ) ; //<S2SV> buffer [ plen ] = 0 ; //<S2SV> if ( plaintext ) { //<S2SV> while ( remaining > 0 ) { //<S2SV> received = remaining ; //<S2SV> rv = apr_socket_recv ( sock , buffer + at , & received ) ; //<S2SV> if ( received > 0 ) { //<S2SV> remaining -= received ; //<S2SV> at += received ; //<S2SV> } //<S2SV> } //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , //<S2SV> "Websocket:<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%" APR_OFF_T_FMT "<S2SV_blank>bytes,<S2SV_blank>pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack" , //<S2SV> at ) ; //<S2SV> } //<S2SV> else { //<S2SV> rv = lua_websocket_readbytes ( r -> connection , buffer , //<S2SV> remaining ) ; //<S2SV> ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , //<S2SV> "Websocket:<S2SV_blank>SSL<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%" APR_SIZE_T_FMT "<S2SV_blank>bytes,<S2SV_blank>" "pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack" , //<S2SV> remaining ) ; //<S2SV> } //<S2SV> if ( mask ) { //<S2SV> for ( n = 0 ; n < plen ; n ++ ) { //<S2SV> buffer [ n ] ^= mask_bytes [ n % 4 ] ; //<S2SV> } //<S2SV> } //<S2SV> lua_pushlstring ( L , buffer , ( size_t ) plen ) ; //<S2SV> lua_pushboolean ( L , fin ) ; //<S2SV> return 2 ; //<S2SV> } //<S2SV> if ( opcode == 0x09 ) { //<S2SV> char frame [ 2 ] ; //<S2SV> plen = 2 ; //<S2SV> frame [ 0 ] = 0x8A ; //<S2SV> frame [ 1 ] = 0 ; //<S2SV> apr_socket_send ( sock , frame , & plen ) ; //<S2SV> lua_websocket_read ( L ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 