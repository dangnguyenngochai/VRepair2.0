int mainloop ( CLIENT * client ) { //<S2SV> struct nbd_request request ; //<S2SV> struct nbd_reply reply ; //<S2SV> gboolean go_on = TRUE ; //<S2SV> # ifdef DODBG //<S2SV> int i = 0 ; //<S2SV> # endif //<S2SV> negotiate ( client -> net , client , NULL ) ; //<S2SV> DEBUG ( "Entering<S2SV_blank>request<S2SV_blank>loop!\\n" ) ; //<S2SV> reply . magic = htonl ( NBD_REPLY_MAGIC ) ; //<S2SV> reply . error = 0 ; //<S2SV> while ( go_on ) { //<S2SV> char buf [ BUFSIZE ] ; //<S2SV> size_t len ; //<S2SV> # ifdef DODBG //<S2SV> i ++ ; //<S2SV> printf ( "%d:<S2SV_blank>" , i ) ; //<S2SV> # endif //<S2SV> readit ( client -> net , & request , sizeof ( request ) ) ; //<S2SV> request . from = ntohll ( request . from ) ; //<S2SV> request . type = ntohl ( request . type ) ; //<S2SV> if ( request . type == NBD_CMD_DISC ) { //<S2SV> msg2 ( LOG_INFO , "Disconnect<S2SV_blank>request<S2SV_blank>received." ) ; //<S2SV> if ( client -> server -> flags & F_COPYONWRITE ) { //<S2SV> if ( client -> difmap ) g_free ( client -> difmap ) ; //<S2SV> close ( client -> difffile ) ; //<S2SV> unlink ( client -> difffilename ) ; //<S2SV> free ( client -> difffilename ) ; //<S2SV> } //<S2SV> go_on = FALSE ; //<S2SV> continue ; //<S2SV> } //<S2SV> len = ntohl ( request . len ) ; //<S2SV> if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) //<S2SV> err ( "Not<S2SV_blank>enough<S2SV_blank>magic." ) ; //<S2SV> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) //<S2SV> err ( "Request<S2SV_blank>too<S2SV_blank>big!" ) ; //<S2SV> # ifdef DODBG //<S2SV> printf ( "%s<S2SV_blank>from<S2SV_blank>%llu<S2SV_blank>(%llu)<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>" , request . type ? "WRITE" : //<S2SV> "READ" , ( unsigned long long ) request . from , //<S2SV> ( unsigned long long ) request . from / 512 , len ) ; //<S2SV> # endif //<S2SV> memcpy ( reply . handle , request . handle , sizeof ( reply . handle ) ) ; //<S2SV> if ( ( request . from + len ) > ( OFFT_MAX ) ) { //<S2SV> DEBUG ( "[Number<S2SV_blank>too<S2SV_blank>large!]" ) ; //<S2SV> ERROR ( client , reply , EINVAL ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( ( ssize_t ) ( ( off_t ) request . from + len ) > client -> exportsize ) ) { //<S2SV> DEBUG ( "[RANGE!]" ) ; //<S2SV> ERROR ( client , reply , EINVAL ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( request . type == NBD_CMD_WRITE ) { //<S2SV> DEBUG ( "wr:<S2SV_blank>net->buf,<S2SV_blank>" ) ; //<S2SV> readit ( client -> net , buf , len ) ; //<S2SV> DEBUG ( "buf->exp,<S2SV_blank>" ) ; //<S2SV> if ( ( client -> server -> flags & F_READONLY ) || //<S2SV> ( client -> server -> flags & F_AUTOREADONLY ) ) { //<S2SV> DEBUG ( "[WRITE<S2SV_blank>to<S2SV_blank>READONLY!]" ) ; //<S2SV> ERROR ( client , reply , EPERM ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( expwrite ( request . from , buf , len , client ) ) { //<S2SV> DEBUG ( "Write<S2SV_blank>failed:<S2SV_blank>%m" ) ; //<S2SV> ERROR ( client , reply , errno ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> SEND ( client -> net , reply ) ; //<S2SV> DEBUG ( "OK!\\n" ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> DEBUG ( "exp->buf,<S2SV_blank>" ) ; //<S2SV> if ( expread ( request . from , buf + sizeof ( struct nbd_reply ) , len , client ) ) { //<S2SV> DEBUG ( "Read<S2SV_blank>failed:<S2SV_blank>%m" ) ; //<S2SV> ERROR ( client , reply , errno ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> DEBUG ( "buf->net,<S2SV_blank>" ) ; //<S2SV> memcpy ( buf , & reply , sizeof ( struct nbd_reply ) ) ; //<S2SV> writeit ( client -> net , buf , len + sizeof ( struct nbd_reply ) ) ; //<S2SV> DEBUG ( "OK!\\n" ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 