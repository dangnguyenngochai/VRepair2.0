bgp_size_t bgp_packet_attribute ( struct bgp * bgp , struct peer * peer , //<S2SV> struct stream * s , struct attr * attr , //<S2SV> struct bpacket_attr_vec_arr * vecarr , //<S2SV> struct prefix * p , afi_t afi , safi_t safi , //<S2SV> struct peer * from , struct prefix_rd * prd , //<S2SV> mpls_label_t * label , uint32_t num_labels , //<S2SV> int addpath_encode , uint32_t addpath_tx_id ) //<S2SV> { //<S2SV> size_t cp ; //<S2SV> size_t aspath_sizep ; //<S2SV> struct aspath * aspath ; //<S2SV> int send_as4_path = 0 ; //<S2SV> int send_as4_aggregator = 0 ; //<S2SV> int use32bit = ( CHECK_FLAG ( peer -> cap , PEER_CAP_AS4_RCV ) ) ? 1 : 0 ; //<S2SV> if ( ! bgp ) //<S2SV> bgp = peer -> bgp ; //<S2SV> cp = stream_get_endp ( s ) ; //<S2SV> if ( p //<S2SV> && ! ( ( afi == AFI_IP && safi == SAFI_UNICAST ) //<S2SV> && ! peer_cap_enhe ( peer , afi , safi ) ) ) { //<S2SV> size_t mpattrlen_pos = 0 ; //<S2SV> mpattrlen_pos = bgp_packet_mpattr_start ( s , peer , afi , safi , //<S2SV> vecarr , attr ) ; //<S2SV> bgp_packet_mpattr_prefix ( s , afi , safi , p , prd , label , //<S2SV> num_labels , addpath_encode , //<S2SV> addpath_tx_id , attr ) ; //<S2SV> bgp_packet_mpattr_end ( s , mpattrlen_pos ) ; //<S2SV> } //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_ORIGIN ) ; //<S2SV> stream_putc ( s , 1 ) ; //<S2SV> stream_putc ( s , attr -> origin ) ; //<S2SV> if ( peer -> sort == BGP_PEER_EBGP //<S2SV> && ( ! CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , //<S2SV> PEER_FLAG_AS_PATH_UNCHANGED ) //<S2SV> || attr -> aspath -> segments == NULL ) //<S2SV> && ( ! CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , //<S2SV> PEER_FLAG_RSERVER_CLIENT ) ) ) { //<S2SV> aspath = aspath_dup ( attr -> aspath ) ; //<S2SV> aspath = aspath_delete_confed_seq ( aspath ) ; //<S2SV> if ( CHECK_FLAG ( bgp -> config , BGP_CONFIG_CONFEDERATION ) ) { //<S2SV> aspath = aspath_add_seq ( aspath , bgp -> confed_id ) ; //<S2SV> } else { //<S2SV> if ( peer -> change_local_as ) { //<S2SV> if ( ! CHECK_FLAG ( //<S2SV> peer -> flags , //<S2SV> PEER_FLAG_LOCAL_AS_REPLACE_AS ) ) { //<S2SV> aspath = aspath_add_seq ( aspath , //<S2SV> peer -> local_as ) ; //<S2SV> } //<S2SV> aspath = aspath_add_seq ( aspath , //<S2SV> peer -> change_local_as ) ; //<S2SV> } else { //<S2SV> aspath = aspath_add_seq ( aspath , peer -> local_as ) ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( peer -> sort == BGP_PEER_CONFED ) { //<S2SV> aspath = aspath_dup ( attr -> aspath ) ; //<S2SV> aspath = aspath_add_confed_seq ( aspath , peer -> local_as ) ; //<S2SV> } else //<S2SV> aspath = attr -> aspath ; //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN ) ; //<S2SV> stream_putc ( s , BGP_ATTR_AS_PATH ) ; //<S2SV> aspath_sizep = stream_get_endp ( s ) ; //<S2SV> stream_putw ( s , 0 ) ; //<S2SV> stream_putw_at ( s , aspath_sizep , aspath_put ( s , aspath , use32bit ) ) ; //<S2SV> if ( ! use32bit && aspath_has_as4 ( aspath ) ) //<S2SV> send_as4_path = //<S2SV> 1 ; //<S2SV> if ( afi == AFI_IP && safi == SAFI_UNICAST //<S2SV> && ! peer_cap_enhe ( peer , afi , safi ) ) { //<S2SV> if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_NEXT_HOP ) ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_NEXT_HOP ) ; //<S2SV> bpacket_attr_vec_arr_set_vec ( vecarr , BGP_ATTR_VEC_NH , s , //<S2SV> attr ) ; //<S2SV> stream_putc ( s , 4 ) ; //<S2SV> stream_put_ipv4 ( s , attr -> nexthop . s_addr ) ; //<S2SV> } else if ( peer_cap_enhe ( from , afi , safi ) ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_NEXT_HOP ) ; //<S2SV> bpacket_attr_vec_arr_set_vec ( vecarr , BGP_ATTR_VEC_NH , s , //<S2SV> NULL ) ; //<S2SV> stream_putc ( s , 4 ) ; //<S2SV> stream_put_ipv4 ( s , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_MULTI_EXIT_DISC ) //<S2SV> || bgp -> maxmed_active ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; //<S2SV> stream_putc ( s , BGP_ATTR_MULTI_EXIT_DISC ) ; //<S2SV> stream_putc ( s , 4 ) ; //<S2SV> stream_putl ( s , ( bgp -> maxmed_active ? bgp -> maxmed_value //<S2SV> : attr -> med ) ) ; //<S2SV> } //<S2SV> if ( peer -> sort == BGP_PEER_IBGP || peer -> sort == BGP_PEER_CONFED ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_LOCAL_PREF ) ; //<S2SV> stream_putc ( s , 4 ) ; //<S2SV> stream_putl ( s , attr -> local_pref ) ; //<S2SV> } //<S2SV> if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_ATOMIC_AGGREGATE ) ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_ATOMIC_AGGREGATE ) ; //<S2SV> stream_putc ( s , 0 ) ; //<S2SV> } //<S2SV> if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_AGGREGATOR ) ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_AGGREGATOR ) ; //<S2SV> if ( use32bit ) { //<S2SV> stream_putc ( s , 8 ) ; //<S2SV> stream_putl ( s , attr -> aggregator_as ) ; //<S2SV> } else { //<S2SV> stream_putc ( s , 6 ) ; //<S2SV> if ( attr -> aggregator_as > 65535 ) { //<S2SV> stream_putw ( s , BGP_AS_TRANS ) ; //<S2SV> send_as4_aggregator = 1 ; //<S2SV> } else //<S2SV> stream_putw ( s , ( uint16_t ) attr -> aggregator_as ) ; //<S2SV> } //<S2SV> stream_put_ipv4 ( s , attr -> aggregator_addr . s_addr ) ; //<S2SV> } //<S2SV> if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_COMMUNITY ) //<S2SV> && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_COMMUNITIES ) ) ) { //<S2SV> if ( attr -> community -> size * 4 > 255 ) { //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS //<S2SV> | BGP_ATTR_FLAG_EXTLEN ) ; //<S2SV> stream_putc ( s , BGP_ATTR_COMMUNITIES ) ; //<S2SV> stream_putw ( s , attr -> community -> size * 4 ) ; //<S2SV> } else { //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_COMMUNITIES ) ; //<S2SV> stream_putc ( s , attr -> community -> size * 4 ) ; //<S2SV> } //<S2SV> stream_put ( s , attr -> community -> val , attr -> community -> size * 4 ) ; //<S2SV> } //<S2SV> if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , //<S2SV> PEER_FLAG_SEND_LARGE_COMMUNITY ) //<S2SV> && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_LARGE_COMMUNITIES ) ) ) { //<S2SV> if ( lcom_length ( attr -> lcommunity ) > 255 ) { //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS //<S2SV> | BGP_ATTR_FLAG_EXTLEN ) ; //<S2SV> stream_putc ( s , BGP_ATTR_LARGE_COMMUNITIES ) ; //<S2SV> stream_putw ( s , lcom_length ( attr -> lcommunity ) ) ; //<S2SV> } else { //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_LARGE_COMMUNITIES ) ; //<S2SV> stream_putc ( s , lcom_length ( attr -> lcommunity ) ) ; //<S2SV> } //<S2SV> stream_put ( s , attr -> lcommunity -> val , //<S2SV> lcom_length ( attr -> lcommunity ) ) ; //<S2SV> } //<S2SV> if ( peer -> sort == BGP_PEER_IBGP && from //<S2SV> && from -> sort == BGP_PEER_IBGP ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; //<S2SV> stream_putc ( s , BGP_ATTR_ORIGINATOR_ID ) ; //<S2SV> stream_putc ( s , 4 ) ; //<S2SV> if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_ORIGINATOR_ID ) ) //<S2SV> stream_put_in_addr ( s , & attr -> originator_id ) ; //<S2SV> else //<S2SV> stream_put_in_addr ( s , & from -> remote_id ) ; //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL ) ; //<S2SV> stream_putc ( s , BGP_ATTR_CLUSTER_LIST ) ; //<S2SV> if ( attr -> cluster ) { //<S2SV> stream_putc ( s , attr -> cluster -> length + 4 ) ; //<S2SV> if ( bgp -> config & BGP_CONFIG_CLUSTER_ID ) //<S2SV> stream_put_in_addr ( s , & bgp -> cluster_id ) ; //<S2SV> else //<S2SV> stream_put_in_addr ( s , & bgp -> router_id ) ; //<S2SV> stream_put ( s , attr -> cluster -> list , //<S2SV> attr -> cluster -> length ) ; //<S2SV> } else { //<S2SV> stream_putc ( s , 4 ) ; //<S2SV> if ( bgp -> config & BGP_CONFIG_CLUSTER_ID ) //<S2SV> stream_put_in_addr ( s , & bgp -> cluster_id ) ; //<S2SV> else //<S2SV> stream_put_in_addr ( s , & bgp -> router_id ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( CHECK_FLAG ( peer -> af_flags [ afi ] [ safi ] , PEER_FLAG_SEND_EXT_COMMUNITY ) //<S2SV> && ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_EXT_COMMUNITIES ) ) ) { //<S2SV> if ( peer -> sort == BGP_PEER_IBGP //<S2SV> || peer -> sort == BGP_PEER_CONFED ) { //<S2SV> if ( attr -> ecommunity -> size * 8 > 255 ) { //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_TRANS //<S2SV> | BGP_ATTR_FLAG_EXTLEN ) ; //<S2SV> stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; //<S2SV> stream_putw ( s , attr -> ecommunity -> size * 8 ) ; //<S2SV> } else { //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_EXT_COMMUNITIES ) ; //<S2SV> stream_putc ( s , attr -> ecommunity -> size * 8 ) ; //<S2SV> } //<S2SV> stream_put ( s , attr -> ecommunity -> val , //<S2SV> attr -> ecommunity -> size * 8 ) ; //<S2SV> } else { //<S2SV> uint8_t * pnt ; //<S2SV> int tbit ; //<S2SV> int ecom_tr_size = 0 ; //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < attr -> ecommunity -> size ; i ++ ) { //<S2SV> pnt = attr -> ecommunity -> val + ( i * 8 ) ; //<S2SV> tbit = * pnt ; //<S2SV> if ( CHECK_FLAG ( tbit , //<S2SV> ECOMMUNITY_FLAG_NON_TRANSITIVE ) ) //<S2SV> continue ; //<S2SV> ecom_tr_size ++ ; //<S2SV> } //<S2SV> if ( ecom_tr_size ) { //<S2SV> if ( ecom_tr_size * 8 > 255 ) { //<S2SV> stream_putc ( //<S2SV> s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_TRANS //<S2SV> | BGP_ATTR_FLAG_EXTLEN ) ; //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_EXT_COMMUNITIES ) ; //<S2SV> stream_putw ( s , ecom_tr_size * 8 ) ; //<S2SV> } else { //<S2SV> stream_putc ( //<S2SV> s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_EXT_COMMUNITIES ) ; //<S2SV> stream_putc ( s , ecom_tr_size * 8 ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < attr -> ecommunity -> size ; i ++ ) { //<S2SV> pnt = attr -> ecommunity -> val + ( i * 8 ) ; //<S2SV> tbit = * pnt ; //<S2SV> if ( CHECK_FLAG ( //<S2SV> tbit , //<S2SV> ECOMMUNITY_FLAG_NON_TRANSITIVE ) ) //<S2SV> continue ; //<S2SV> stream_put ( s , pnt , 8 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( safi == SAFI_LABELED_UNICAST ) { //<S2SV> if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_PREFIX_SID ) ) { //<S2SV> uint32_t label_index ; //<S2SV> label_index = attr -> label_index ; //<S2SV> if ( label_index != BGP_INVALID_LABEL_INDEX ) { //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_PREFIX_SID ) ; //<S2SV> stream_putc ( s , 10 ) ; //<S2SV> stream_putc ( s , BGP_PREFIX_SID_LABEL_INDEX ) ; //<S2SV> stream_putw ( s , //<S2SV> BGP_PREFIX_SID_LABEL_INDEX_LENGTH ) ; //<S2SV> stream_putc ( s , 0 ) ; //<S2SV> stream_putw ( s , 0 ) ; //<S2SV> stream_putl ( s , label_index ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( send_as4_path ) { //<S2SV> aspath = aspath_delete_confed_seq ( aspath ) ; //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_EXTLEN ) ; //<S2SV> stream_putc ( s , BGP_ATTR_AS4_PATH ) ; //<S2SV> aspath_sizep = stream_get_endp ( s ) ; //<S2SV> stream_putw ( s , 0 ) ; //<S2SV> stream_putw_at ( s , aspath_sizep , aspath_put ( s , aspath , 1 ) ) ; //<S2SV> } //<S2SV> if ( aspath != attr -> aspath ) //<S2SV> aspath_free ( aspath ) ; //<S2SV> if ( send_as4_aggregator ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_AS4_AGGREGATOR ) ; //<S2SV> stream_putc ( s , 8 ) ; //<S2SV> stream_putl ( s , attr -> aggregator_as ) ; //<S2SV> stream_put_ipv4 ( s , attr -> aggregator_addr . s_addr ) ; //<S2SV> } //<S2SV> if ( ( ( afi == AFI_IP || afi == AFI_IP6 ) //<S2SV> && ( safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN ) ) //<S2SV> || ( afi == AFI_L2VPN && safi == SAFI_EVPN ) ) { //<S2SV> bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_ENCAP ) ; //<S2SV> # if ENABLE_BGP_VNC_ATTR //<S2SV> bgp_packet_mpattr_tea ( bgp , peer , s , attr , BGP_ATTR_VNC ) ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( attr -> flag & ATTR_FLAG_BIT ( BGP_ATTR_PMSI_TUNNEL ) ) { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS ) ; //<S2SV> stream_putc ( s , BGP_ATTR_PMSI_TUNNEL ) ; //<S2SV> stream_putc ( s , 9 ) ; //<S2SV> stream_putc ( s , 0 ) ; //<S2SV> stream_putc ( s , PMSI_TNLTYPE_INGR_REPL ) ; //<S2SV> stream_put ( s , & ( attr -> label ) , //<S2SV> BGP_LABEL_BYTES ) ; //<S2SV> stream_put_ipv4 ( s , attr -> nexthop . s_addr ) ; //<S2SV> } //<S2SV> if ( attr -> transit ) //<S2SV> stream_put ( s , attr -> transit -> val , attr -> transit -> length ) ; //<S2SV> return stream_get_endp ( s ) - cp ; //<S2SV> } //<S2SV> 