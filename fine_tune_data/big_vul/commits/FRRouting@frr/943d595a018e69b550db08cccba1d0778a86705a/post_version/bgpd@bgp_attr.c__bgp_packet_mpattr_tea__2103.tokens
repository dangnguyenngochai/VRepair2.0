static void bgp_packet_mpattr_tea ( struct bgp * bgp , struct peer * peer , //<S2SV> struct stream * s , struct attr * attr , //<S2SV> uint8_t attrtype ) //<S2SV> { //<S2SV> unsigned int attrlenfield = 0 ; //<S2SV> unsigned int attrhdrlen = 0 ; //<S2SV> struct bgp_attr_encap_subtlv * subtlvs ; //<S2SV> struct bgp_attr_encap_subtlv * st ; //<S2SV> const char * attrname ; //<S2SV> if ( ! attr || ( attrtype == BGP_ATTR_ENCAP //<S2SV> && ( ! attr -> encap_tunneltype //<S2SV> || attr -> encap_tunneltype == BGP_ENCAP_TYPE_MPLS ) ) ) //<S2SV> return ; //<S2SV> switch ( attrtype ) { //<S2SV> case BGP_ATTR_ENCAP : //<S2SV> attrname = "Tunnel<S2SV_blank>Encap" ; //<S2SV> subtlvs = attr -> encap_subtlvs ; //<S2SV> if ( subtlvs == NULL ) //<S2SV> return ; //<S2SV> attrlenfield = 2 + 2 ; //<S2SV> attrhdrlen = 1 + 1 ; //<S2SV> break ; //<S2SV> # if ENABLE_BGP_VNC_ATTR //<S2SV> case BGP_ATTR_VNC : //<S2SV> attrname = "VNC" ; //<S2SV> subtlvs = attr -> vnc_subtlvs ; //<S2SV> if ( subtlvs == NULL ) //<S2SV> return ; //<S2SV> attrlenfield = 0 ; //<S2SV> attrhdrlen = 2 + 2 ; //<S2SV> break ; //<S2SV> # endif //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> } //<S2SV> for ( st = subtlvs ; st ; st = st -> next ) { //<S2SV> attrlenfield += ( attrhdrlen + st -> length ) ; //<S2SV> } //<S2SV> if ( attrlenfield > 0xffff ) { //<S2SV> zlog_info ( "%s<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(length=%d),<S2SV_blank>can\'t<S2SV_blank>send<S2SV_blank>it" , //<S2SV> attrname , attrlenfield ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( attrlenfield > 0xff ) { //<S2SV> stream_putc ( s , //<S2SV> BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL //<S2SV> | BGP_ATTR_FLAG_EXTLEN ) ; //<S2SV> stream_putc ( s , attrtype ) ; //<S2SV> stream_putw ( s , attrlenfield & 0xffff ) ; //<S2SV> } else { //<S2SV> stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL ) ; //<S2SV> stream_putc ( s , attrtype ) ; //<S2SV> stream_putc ( s , attrlenfield & 0xff ) ; //<S2SV> } //<S2SV> if ( attrtype == BGP_ATTR_ENCAP ) { //<S2SV> stream_putw ( s , attr -> encap_tunneltype ) ; //<S2SV> stream_putw ( s , attrlenfield - 4 ) ; //<S2SV> } //<S2SV> for ( st = subtlvs ; st ; st = st -> next ) { //<S2SV> if ( attrtype == BGP_ATTR_ENCAP ) { //<S2SV> stream_putc ( s , st -> type ) ; //<S2SV> stream_putc ( s , st -> length ) ; //<S2SV> # if ENABLE_BGP_VNC //<S2SV> } else { //<S2SV> stream_putw ( s , st -> type ) ; //<S2SV> stream_putw ( s , st -> length ) ; //<S2SV> # endif //<S2SV> } //<S2SV> stream_put ( s , st -> value , st -> length ) ; //<S2SV> } //<S2SV> } //<S2SV> 