bgp_attr_parse_ret_t bgp_attr_parse ( struct peer * peer , struct attr * attr , //<S2SV> bgp_size_t size , struct bgp_nlri * mp_update , //<S2SV> struct bgp_nlri * mp_withdraw ) //<S2SV> { //<S2SV> bgp_attr_parse_ret_t ret ; //<S2SV> uint8_t flag = 0 ; //<S2SV> uint8_t type = 0 ; //<S2SV> bgp_size_t length ; //<S2SV> uint8_t * startp , * endp ; //<S2SV> uint8_t * attr_endp ; //<S2SV> uint8_t seen [ BGP_ATTR_BITMAP_SIZE ] ; //<S2SV> struct aspath * as4_path = NULL ; //<S2SV> as_t as4_aggregator = 0 ; //<S2SV> struct in_addr as4_aggregator_addr = { . s_addr = 0 } ; //<S2SV> memset ( seen , 0 , BGP_ATTR_BITMAP_SIZE ) ; //<S2SV> endp = BGP_INPUT_PNT ( peer ) + size ; //<S2SV> while ( BGP_INPUT_PNT ( peer ) < endp ) { //<S2SV> if ( endp - BGP_INPUT_PNT ( peer ) < BGP_ATTR_MIN_LEN ) { //<S2SV> flog_warn ( //<S2SV> EC_BGP_ATTRIBUTE_TOO_SMALL , //<S2SV> "%s:<S2SV_blank>error<S2SV_blank>BGP<S2SV_blank>attribute<S2SV_blank>length<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>min<S2SV_blank>len" , //<S2SV> peer -> host , //<S2SV> ( unsigned long ) ( endp //<S2SV> - stream_pnt ( BGP_INPUT ( peer ) ) ) ) ; //<S2SV> bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , //<S2SV> BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; //<S2SV> return BGP_ATTR_PARSE_ERROR ; //<S2SV> } //<S2SV> startp = BGP_INPUT_PNT ( peer ) ; //<S2SV> flag = 0xF0 & stream_getc ( BGP_INPUT ( peer ) ) ; //<S2SV> type = stream_getc ( BGP_INPUT ( peer ) ) ; //<S2SV> if ( CHECK_FLAG ( flag , BGP_ATTR_FLAG_EXTLEN ) //<S2SV> && ( ( endp - startp ) < ( BGP_ATTR_MIN_LEN + 1 ) ) ) { //<S2SV> flog_warn ( //<S2SV> EC_BGP_EXT_ATTRIBUTE_TOO_SMALL , //<S2SV> "%s:<S2SV_blank>Extended<S2SV_blank>length<S2SV_blank>set,<S2SV_blank>but<S2SV_blank>just<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>attr<S2SV_blank>header" , //<S2SV> peer -> host , //<S2SV> ( unsigned long ) ( endp //<S2SV> - stream_pnt ( BGP_INPUT ( peer ) ) ) ) ; //<S2SV> bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , //<S2SV> BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; //<S2SV> return BGP_ATTR_PARSE_ERROR ; //<S2SV> } //<S2SV> if ( CHECK_FLAG ( flag , BGP_ATTR_FLAG_EXTLEN ) ) //<S2SV> length = stream_getw ( BGP_INPUT ( peer ) ) ; //<S2SV> else //<S2SV> length = stream_getc ( BGP_INPUT ( peer ) ) ; //<S2SV> if ( CHECK_BITMAP ( seen , type ) ) { //<S2SV> flog_warn ( //<S2SV> EC_BGP_ATTRIBUTE_REPEATED , //<S2SV> "%s:<S2SV_blank>error<S2SV_blank>BGP<S2SV_blank>attribute<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>appears<S2SV_blank>twice<S2SV_blank>in<S2SV_blank>a<S2SV_blank>message" , //<S2SV> peer -> host , type ) ; //<S2SV> bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , //<S2SV> BGP_NOTIFY_UPDATE_MAL_ATTR ) ; //<S2SV> return BGP_ATTR_PARSE_ERROR ; //<S2SV> } //<S2SV> SET_BITMAP ( seen , type ) ; //<S2SV> attr_endp = BGP_INPUT_PNT ( peer ) + length ; //<S2SV> if ( attr_endp > endp ) { //<S2SV> flog_warn ( //<S2SV> EC_BGP_ATTRIBUTE_TOO_LARGE , //<S2SV> "%s:<S2SV_blank>BGP<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>attribute<S2SV_blank>total<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d.<S2SV_blank><S2SV_blank>attr_endp<S2SV_blank>is<S2SV_blank>%p.<S2SV_blank><S2SV_blank>endp<S2SV_blank>is<S2SV_blank>%p" , //<S2SV> peer -> host , type , length , size , attr_endp , //<S2SV> endp ) ; //<S2SV> unsigned char ndata [ BGP_MAX_PACKET_SIZE ] ; //<S2SV> memset ( ndata , 0x00 , sizeof ( ndata ) ) ; //<S2SV> size_t lfl = //<S2SV> CHECK_FLAG ( flag , BGP_ATTR_FLAG_EXTLEN ) ? 2 : 1 ; //<S2SV> stream_forward_getp ( BGP_INPUT ( peer ) , - ( 1 + lfl ) ) ; //<S2SV> stream_get ( & ndata [ 0 ] , BGP_INPUT ( peer ) , 1 ) ; //<S2SV> stream_get ( & ndata [ 1 ] , BGP_INPUT ( peer ) , lfl ) ; //<S2SV> size_t atl = attr_endp - startp ; //<S2SV> size_t ndl = MIN ( atl , STREAM_READABLE ( BGP_INPUT ( peer ) ) ) ; //<S2SV> stream_get ( & ndata [ lfl + 1 ] , BGP_INPUT ( peer ) , ndl ) ; //<S2SV> bgp_notify_send_with_data ( //<S2SV> peer , BGP_NOTIFY_UPDATE_ERR , //<S2SV> BGP_NOTIFY_UPDATE_ATTR_LENG_ERR , ndata , //<S2SV> ndl + lfl + 1 ) ; //<S2SV> return BGP_ATTR_PARSE_ERROR ; //<S2SV> } //<S2SV> struct bgp_attr_parser_args attr_args = { //<S2SV> . peer = peer , //<S2SV> . length = length , //<S2SV> . attr = attr , //<S2SV> . type = type , //<S2SV> . flags = flag , //<S2SV> . startp = startp , //<S2SV> . total = attr_endp - startp , //<S2SV> } ; //<S2SV> if ( bgp_attr_flag_invalid ( & attr_args ) ) { //<S2SV> ret = bgp_attr_malformed ( //<S2SV> & attr_args , BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR , //<S2SV> attr_args . total ) ; //<S2SV> if ( ret == BGP_ATTR_PARSE_PROCEED ) //<S2SV> continue ; //<S2SV> return ret ; //<S2SV> } //<S2SV> switch ( type ) { //<S2SV> case BGP_ATTR_ORIGIN : //<S2SV> ret = bgp_attr_origin ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_AS_PATH : //<S2SV> ret = bgp_attr_aspath ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_AS4_PATH : //<S2SV> ret = bgp_attr_as4_path ( & attr_args , & as4_path ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_NEXT_HOP : //<S2SV> ret = bgp_attr_nexthop ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_MULTI_EXIT_DISC : //<S2SV> ret = bgp_attr_med ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_LOCAL_PREF : //<S2SV> ret = bgp_attr_local_pref ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_ATOMIC_AGGREGATE : //<S2SV> ret = bgp_attr_atomic ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_AGGREGATOR : //<S2SV> ret = bgp_attr_aggregator ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_AS4_AGGREGATOR : //<S2SV> ret = bgp_attr_as4_aggregator ( & attr_args , //<S2SV> & as4_aggregator , //<S2SV> & as4_aggregator_addr ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_COMMUNITIES : //<S2SV> ret = bgp_attr_community ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_LARGE_COMMUNITIES : //<S2SV> ret = bgp_attr_large_community ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_ORIGINATOR_ID : //<S2SV> ret = bgp_attr_originator_id ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_CLUSTER_LIST : //<S2SV> ret = bgp_attr_cluster_list ( & attr_args ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_MP_REACH_NLRI : //<S2SV> ret = bgp_mp_reach_parse ( & attr_args , mp_update ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_MP_UNREACH_NLRI : //<S2SV> ret = bgp_mp_unreach_parse ( & attr_args , mp_withdraw ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_EXT_COMMUNITIES : //<S2SV> ret = bgp_attr_ext_communities ( & attr_args ) ; //<S2SV> break ; //<S2SV> # if ENABLE_BGP_VNC_ATTR //<S2SV> case BGP_ATTR_VNC : //<S2SV> # endif //<S2SV> case BGP_ATTR_ENCAP : //<S2SV> ret = bgp_attr_encap ( type , peer , length , attr , flag , //<S2SV> startp ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_PREFIX_SID : //<S2SV> ret = bgp_attr_prefix_sid ( length , //<S2SV> & attr_args , mp_update ) ; //<S2SV> break ; //<S2SV> case BGP_ATTR_PMSI_TUNNEL : //<S2SV> ret = bgp_attr_pmsi_tunnel ( & attr_args ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> ret = bgp_attr_unknown ( & attr_args ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS ) { //<S2SV> bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , //<S2SV> BGP_NOTIFY_UPDATE_MAL_ATTR ) ; //<S2SV> ret = BGP_ATTR_PARSE_ERROR ; //<S2SV> } //<S2SV> if ( ret == BGP_ATTR_PARSE_EOR ) { //<S2SV> if ( as4_path ) //<S2SV> aspath_unintern ( & as4_path ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( ret == BGP_ATTR_PARSE_ERROR ) { //<S2SV> flog_warn ( EC_BGP_ATTRIBUTE_PARSE_ERROR , //<S2SV> "%s:<S2SV_blank>Attribute<S2SV_blank>%s,<S2SV_blank>parse<S2SV_blank>error" , peer -> host , //<S2SV> lookup_msg ( attr_str , type , NULL ) ) ; //<S2SV> if ( as4_path ) //<S2SV> aspath_unintern ( & as4_path ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( ret == BGP_ATTR_PARSE_WITHDRAW ) { //<S2SV> flog_warn ( //<S2SV> EC_BGP_ATTRIBUTE_PARSE_WITHDRAW , //<S2SV> "%s:<S2SV_blank>Attribute<S2SV_blank>%s,<S2SV_blank>parse<S2SV_blank>error<S2SV_blank>-<S2SV_blank>treating<S2SV_blank>as<S2SV_blank>withdrawal" , //<S2SV> peer -> host , lookup_msg ( attr_str , type , NULL ) ) ; //<S2SV> if ( as4_path ) //<S2SV> aspath_unintern ( & as4_path ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( BGP_INPUT_PNT ( peer ) != attr_endp ) { //<S2SV> flog_warn ( EC_BGP_ATTRIBUTE_FETCH_ERROR , //<S2SV> "%s:<S2SV_blank>BGP<S2SV_blank>attribute<S2SV_blank>%s,<S2SV_blank>fetch<S2SV_blank>error" , //<S2SV> peer -> host , lookup_msg ( attr_str , type , NULL ) ) ; //<S2SV> bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , //<S2SV> BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; //<S2SV> if ( as4_path ) //<S2SV> aspath_unintern ( & as4_path ) ; //<S2SV> return BGP_ATTR_PARSE_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> if ( BGP_INPUT_PNT ( peer ) != endp ) { //<S2SV> flog_warn ( EC_BGP_ATTRIBUTES_MISMATCH , //<S2SV> "%s:<S2SV_blank>BGP<S2SV_blank>attribute<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>mismatch" , peer -> host , //<S2SV> lookup_msg ( attr_str , type , NULL ) ) ; //<S2SV> bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , //<S2SV> BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; //<S2SV> if ( as4_path ) //<S2SV> aspath_unintern ( & as4_path ) ; //<S2SV> return BGP_ATTR_PARSE_ERROR ; //<S2SV> } //<S2SV> if ( ( ret = bgp_attr_check ( peer , attr ) ) < 0 ) { //<S2SV> if ( as4_path ) //<S2SV> aspath_unintern ( & as4_path ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( CHECK_FLAG ( attr -> flag , ATTR_FLAG_BIT ( BGP_ATTR_AS_PATH ) ) //<S2SV> && bgp_attr_munge_as4_attrs ( peer , attr , as4_path , as4_aggregator , //<S2SV> & as4_aggregator_addr ) ) { //<S2SV> bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , //<S2SV> BGP_NOTIFY_UPDATE_MAL_ATTR ) ; //<S2SV> if ( as4_path ) //<S2SV> aspath_unintern ( & as4_path ) ; //<S2SV> return BGP_ATTR_PARSE_ERROR ; //<S2SV> } //<S2SV> if ( as4_path ) { //<S2SV> aspath_unintern ( & as4_path ) ; //<S2SV> } //<S2SV> if ( attr -> flag & ( ATTR_FLAG_BIT ( BGP_ATTR_AS_PATH ) ) ) { //<S2SV> ret = bgp_attr_aspath_check ( peer , attr ) ; //<S2SV> if ( ret != BGP_ATTR_PARSE_PROCEED ) //<S2SV> return ret ; //<S2SV> } //<S2SV> if ( attr -> transit ) //<S2SV> attr -> transit = transit_intern ( attr -> transit ) ; //<S2SV> if ( attr -> encap_subtlvs ) //<S2SV> attr -> encap_subtlvs = //<S2SV> encap_intern ( attr -> encap_subtlvs , ENCAP_SUBTLV_TYPE ) ; //<S2SV> # if ENABLE_BGP_VNC //<S2SV> if ( attr -> vnc_subtlvs ) //<S2SV> attr -> vnc_subtlvs = //<S2SV> encap_intern ( attr -> vnc_subtlvs , VNC_SUBTLV_TYPE ) ; //<S2SV> # endif //<S2SV> return BGP_ATTR_PARSE_PROCEED ; //<S2SV> } //<S2SV> 