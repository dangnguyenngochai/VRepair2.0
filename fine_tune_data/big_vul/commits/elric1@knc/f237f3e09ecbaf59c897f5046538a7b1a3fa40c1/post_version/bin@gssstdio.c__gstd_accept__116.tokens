void * //<S2SV> gstd_accept ( int fd , char * * display_creds , char * * export_name , char * * mech ) //<S2SV> { //<S2SV> gss_name_t client ; //<S2SV> gss_OID mech_oid ; //<S2SV> struct gstd_tok * tok ; //<S2SV> gss_ctx_id_t ctx = GSS_C_NO_CONTEXT ; //<S2SV> gss_buffer_desc in , out ; //<S2SV> OM_uint32 maj , min ; //<S2SV> int ret ; //<S2SV> * display_creds = NULL ; //<S2SV> * export_name = NULL ; //<S2SV> out . length = 0 ; //<S2SV> in . length = 0 ; //<S2SV> read_packet ( fd , & in , 60000 , 1 ) ; //<S2SV> again : //<S2SV> while ( ( ret = read_packet ( fd , & in , 60000 , 0 ) ) == - 2 ) //<S2SV> ; //<S2SV> if ( ret < 1 ) //<S2SV> return NULL ; //<S2SV> maj = gss_accept_sec_context ( & min , & ctx , GSS_C_NO_CREDENTIAL , //<S2SV> & in , GSS_C_NO_CHANNEL_BINDINGS , & client , & mech_oid , & out , NULL , //<S2SV> NULL , NULL ) ; //<S2SV> gss_release_buffer ( & min , & in ) ; //<S2SV> if ( out . length && write_packet ( fd , & out ) ) { //<S2SV> gss_release_buffer ( & min , & out ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> gss_release_buffer ( & min , & out ) ; //<S2SV> GSTD_GSS_ERROR ( maj , min , NULL , "gss_accept_sec_context" ) ; //<S2SV> if ( maj & GSS_S_CONTINUE_NEEDED ) //<S2SV> goto again ; //<S2SV> * display_creds = gstd_get_display_name ( client ) ; //<S2SV> * export_name = gstd_get_export_name ( client ) ; //<S2SV> * mech = gstd_get_mech ( mech_oid ) ; //<S2SV> gss_release_name ( & min , & client ) ; //<S2SV> SETUP_GSTD_TOK ( tok , ctx , fd , "gstd_accept" ) ; //<S2SV> return tok ; //<S2SV> } //<S2SV> 