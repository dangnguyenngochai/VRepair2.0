static void _out_verify ( conn_t out , nad_t nad ) { //<S2SV> int attr , ns ; //<S2SV> jid_t from , to ; //<S2SV> conn_t in ; //<S2SV> char * rkey ; //<S2SV> int valid ; //<S2SV> attr = nad_find_attr ( nad , 0 , - 1 , "from" , NULL ) ; //<S2SV> if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { //<S2SV> log_debug ( ZONE , "missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>from<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet" ) ; //<S2SV> nad_free ( nad ) ; //<S2SV> return ; //<S2SV> } //<S2SV> attr = nad_find_attr ( nad , 0 , - 1 , "to" , NULL ) ; //<S2SV> if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { //<S2SV> log_debug ( ZONE , "missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>to<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet" ) ; //<S2SV> jid_free ( from ) ; //<S2SV> nad_free ( nad ) ; //<S2SV> return ; //<S2SV> } //<S2SV> attr = nad_find_attr ( nad , 0 , - 1 , "id" , NULL ) ; //<S2SV> if ( attr < 0 ) { //<S2SV> log_debug ( ZONE , "missing<S2SV_blank>id<S2SV_blank>on<S2SV_blank>db<S2SV_blank>verify<S2SV_blank>packet" ) ; //<S2SV> jid_free ( from ) ; //<S2SV> jid_free ( to ) ; //<S2SV> nad_free ( nad ) ; //<S2SV> return ; //<S2SV> } //<S2SV> in = xhash_getx ( out -> s2s -> in , NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ; //<S2SV> if ( in == NULL ) { //<S2SV> log_debug ( ZONE , "got<S2SV_blank>a<S2SV_blank>verify<S2SV_blank>for<S2SV_blank>incoming<S2SV_blank>conn<S2SV_blank>%.*s,<S2SV_blank>but<S2SV_blank>it<S2SV_blank>doesn\'t<S2SV_blank>exist,<S2SV_blank>dropping<S2SV_blank>the<S2SV_blank>packet" , NAD_AVAL_L ( nad , attr ) , NAD_AVAL ( nad , attr ) ) ; //<S2SV> jid_free ( from ) ; //<S2SV> jid_free ( to ) ; //<S2SV> nad_free ( nad ) ; //<S2SV> return ; //<S2SV> } //<S2SV> rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; //<S2SV> attr = nad_find_attr ( nad , 0 , - 1 , "type" , "valid" ) ; //<S2SV> if ( attr >= 0 ) { //<S2SV> xhash_put ( in -> states , pstrdup ( xhash_pool ( in -> states ) , rkey ) , ( void * ) conn_VALID ) ; //<S2SV> log_write ( in -> s2s -> log , LOG_NOTICE , "[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>incoming<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s" , in -> fd -> fd , in -> ip , in -> port , rkey , ( in -> s -> flags & SX_SSL_WRAPPER ) ? ",<S2SV_blank>TLS<S2SV_blank>negotiated" : "" , in -> s -> compressed ? ",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled" : "" ) ; //<S2SV> valid = 1 ; //<S2SV> } else { //<S2SV> log_write ( in -> s2s -> log , LOG_NOTICE , "[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>incoming<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>invalid" , in -> fd -> fd , in -> ip , in -> port , rkey ) ; //<S2SV> valid = 0 ; //<S2SV> } //<S2SV> free ( rkey ) ; //<S2SV> nad_free ( nad ) ; //<S2SV> -- out -> verify ; //<S2SV> nad = nad_new ( ) ; //<S2SV> ns = nad_add_namespace ( nad , uri_DIALBACK , "db" ) ; //<S2SV> nad_append_elem ( nad , ns , "result" , 0 ) ; //<S2SV> nad_append_attr ( nad , - 1 , "to" , from -> domain ) ; //<S2SV> nad_append_attr ( nad , - 1 , "from" , to -> domain ) ; //<S2SV> nad_append_attr ( nad , - 1 , "type" , valid ? "valid" : "invalid" ) ; //<S2SV> sx_nad_write ( in -> s , nad ) ; //<S2SV> if ( ! valid ) { //<S2SV> sx_error ( in -> s , stream_err_INVALID_ID , "dialback<S2SV_blank>negotiation<S2SV_blank>failed" ) ; //<S2SV> sx_close ( in -> s ) ; //<S2SV> } //<S2SV> jid_free ( from ) ; //<S2SV> jid_free ( to ) ; //<S2SV> } //<S2SV> 