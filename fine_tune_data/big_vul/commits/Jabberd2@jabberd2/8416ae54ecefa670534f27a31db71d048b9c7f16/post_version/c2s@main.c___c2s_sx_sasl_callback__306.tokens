static int _c2s_sx_sasl_callback ( int cb , void * arg , void * * res , sx_t s , void * cbarg ) { //<S2SV> c2s_t c2s = ( c2s_t ) cbarg ; //<S2SV> const char * my_realm , * mech ; //<S2SV> sx_sasl_creds_t creds ; //<S2SV> static char buf [ 3072 ] ; //<S2SV> char mechbuf [ 256 ] ; //<S2SV> struct jid_st jid ; //<S2SV> jid_static_buf jid_buf ; //<S2SV> int i , r ; //<S2SV> sess_t sess ; //<S2SV> char skey [ 44 ] ; //<S2SV> host_t host ; //<S2SV> jid_static ( & jid , & jid_buf ) ; //<S2SV> assert ( s != NULL ) ; //<S2SV> sprintf ( skey , "%d" , s -> tag ) ; //<S2SV> sess = xhash_get ( c2s -> sessions , skey ) ; //<S2SV> switch ( cb ) { //<S2SV> case sx_sasl_cb_GET_REALM : //<S2SV> if ( s -> req_to == NULL ) //<S2SV> my_realm = "" ; //<S2SV> else { //<S2SV> host = xhash_get ( c2s -> hosts , s -> req_to ) ; //<S2SV> if ( host == NULL ) { //<S2SV> log_write ( c2s -> log , LOG_ERR , "SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s" , s -> req_to ) ; //<S2SV> * res = ( void * ) NULL ; //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> } //<S2SV> my_realm = host -> realm ; //<S2SV> if ( my_realm == NULL ) //<S2SV> my_realm = s -> req_to ; //<S2SV> } //<S2SV> strncpy ( buf , my_realm , 256 ) ; //<S2SV> * res = ( void * ) buf ; //<S2SV> log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>realm:<S2SV_blank>realm<S2SV_blank>is<S2SV_blank>\'%s\'" , buf ) ; //<S2SV> return sx_sasl_ret_OK ; //<S2SV> break ; //<S2SV> case sx_sasl_cb_GET_PASS : //<S2SV> assert ( sess != NULL ) ; //<S2SV> creds = ( sx_sasl_creds_t ) arg ; //<S2SV> log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>get<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)" , creds -> authnid , creds -> realm ) ; //<S2SV> if ( sess -> host -> ar -> get_password && ( sess -> host -> ar -> get_password ) ( //<S2SV> sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : "" , buf ) == 0 ) { //<S2SV> * res = buf ; //<S2SV> return sx_sasl_ret_OK ; //<S2SV> } //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> case sx_sasl_cb_CHECK_PASS : //<S2SV> assert ( sess != NULL ) ; //<S2SV> creds = ( sx_sasl_creds_t ) arg ; //<S2SV> log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>pass<S2SV_blank>(authnid=%s,<S2SV_blank>realm=%s)" , creds -> authnid , creds -> realm ) ; //<S2SV> if ( sess -> host -> ar -> check_password != NULL ) { //<S2SV> if ( ( sess -> host -> ar -> check_password ) ( //<S2SV> sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : "" , ( char * ) creds -> pass ) == 0 ) //<S2SV> return sx_sasl_ret_OK ; //<S2SV> else //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> } //<S2SV> if ( sess -> host -> ar -> get_password != NULL ) { //<S2SV> if ( ( sess -> host -> ar -> get_password ) ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( creds -> realm != NULL ) ? ( char * ) creds -> realm : "" , buf ) != 0 ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> if ( strcmp ( creds -> pass , buf ) == 0 ) //<S2SV> return sx_sasl_ret_OK ; //<S2SV> } //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> break ; //<S2SV> case sx_sasl_cb_CHECK_AUTHZID : //<S2SV> assert ( sess != NULL ) ; //<S2SV> creds = ( sx_sasl_creds_t ) arg ; //<S2SV> if ( creds -> authzid == NULL || creds -> authzid [ 0 ] == '\\0' ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> if ( jid_reset ( & jid , creds -> authzid , - 1 ) == NULL ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> if ( ! s -> req_to || ( strcmp ( jid . domain , s -> req_to ) != 0 ) ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> if ( jid . resource [ 0 ] != '\\0' ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> if ( sess -> host -> ar -> user_authz_allowed ) { //<S2SV> if ( sess -> host -> ar -> user_authz_allowed ( sess -> host -> ar , sess , ( char * ) creds -> authnid , ( char * ) creds -> realm , ( char * ) creds -> authzid ) ) //<S2SV> return sx_sasl_ret_OK ; //<S2SV> } else { //<S2SV> if ( strcmp ( creds -> authnid , jid . node ) == 0 && //<S2SV> ( sess -> host -> ar -> user_exists ) ( sess -> host -> ar , sess , jid . node , jid . domain ) ) //<S2SV> return sx_sasl_ret_OK ; //<S2SV> } //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> case sx_sasl_cb_GEN_AUTHZID : //<S2SV> jid_reset ( & jid , s -> req_to , - 1 ) ; //<S2SV> jid_random_part ( & jid , jid_NODE ) ; //<S2SV> strcpy ( buf , jid . node ) ; //<S2SV> * res = ( void * ) buf ; //<S2SV> return sx_sasl_ret_OK ; //<S2SV> break ; //<S2SV> case sx_sasl_cb_CHECK_MECH : //<S2SV> mech = ( char * ) arg ; //<S2SV> strncpy ( mechbuf , mech , sizeof ( mechbuf ) ) ; //<S2SV> mechbuf [ sizeof ( mechbuf ) - 1 ] = '\\0' ; //<S2SV> for ( i = 0 ; mechbuf [ i ] ; i ++ ) mechbuf [ i ] = tolower ( mechbuf [ i ] ) ; //<S2SV> log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)" , mechbuf ) ; //<S2SV> host = xhash_get ( c2s -> hosts , s -> req_to ) ; //<S2SV> if ( host == NULL ) { //<S2SV> log_write ( c2s -> log , LOG_WARNING , "SASL<S2SV_blank>callback<S2SV_blank>for<S2SV_blank>non-existing<S2SV_blank>host:<S2SV_blank>%s" , s -> req_to ) ; //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> } //<S2SV> if ( strcmp ( mechbuf , "digest-md5" ) == 0 ) { //<S2SV> if ( host -> ar -> get_password == NULL ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> } else if ( strcmp ( mechbuf , "plain" ) == 0 ) { //<S2SV> if ( host -> ar -> get_password == NULL && host -> ar -> check_password == NULL ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> } //<S2SV> if ( s -> ssf > 0 ) { //<S2SV> r = snprintf ( buf , sizeof ( buf ) , "authreg.ssl-mechanisms.sasl.%s" , mechbuf ) ; //<S2SV> if ( r < - 1 || r > sizeof ( buf ) ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> if ( config_get ( c2s -> config , buf ) != NULL ) //<S2SV> return sx_sasl_ret_OK ; //<S2SV> } //<S2SV> r = snprintf ( buf , sizeof ( buf ) , "authreg.mechanisms.sasl.%s" , mechbuf ) ; //<S2SV> if ( r < - 1 || r > sizeof ( buf ) ) //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> if ( config_get ( c2s -> config , buf ) != NULL ) //<S2SV> return sx_sasl_ret_OK ; //<S2SV> else //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> return sx_sasl_ret_FAIL ; //<S2SV> } //<S2SV> 