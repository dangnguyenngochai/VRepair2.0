static void _sx_sasl_client_process ( sx_t s , sx_plugin_t p , Gsasl_session * sd , const char * mech , const char * in , int inlen ) { //<S2SV> _sx_sasl_t ctx = ( _sx_sasl_t ) p -> private ; //<S2SV> _sx_sasl_sess_t sctx = NULL ; //<S2SV> char * buf = NULL , * out = NULL , * realm = NULL , * * ext_id ; //<S2SV> char hostname [ 256 ] ; //<S2SV> int ret ; //<S2SV> # ifdef HAVE_SSL //<S2SV> int i ; //<S2SV> # endif //<S2SV> size_t buflen , outlen ; //<S2SV> assert ( ctx ) ; //<S2SV> assert ( ctx -> cb ) ; //<S2SV> if ( mech != NULL ) { //<S2SV> _sx_debug ( ZONE , "auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)" , mech ) ; //<S2SV> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { //<S2SV> _sx_debug ( ZONE , "client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\'t<S2SV_blank>offer" , mech ) ; //<S2SV> _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ret = gsasl_server_start ( ctx -> gsasl_ctx , mech , & sd ) ; //<S2SV> if ( ret != GSASL_OK ) { //<S2SV> _sx_debug ( ZONE , "gsasl_server_start<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s" , ret , gsasl_strerror ( ret ) ) ; //<S2SV> _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_TEMPORARY_FAILURE , gsasl_strerror ( ret ) ) , 0 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ( ctx -> cb ) ( sx_sasl_cb_GET_REALM , NULL , ( void * * ) & realm , s , ctx -> cbarg ) ; //<S2SV> sctx = gsasl_session_hook_get ( sd ) ; //<S2SV> if ( sctx != NULL ) free ( sctx ) ; //<S2SV> sctx = ( _sx_sasl_sess_t ) calloc ( 1 , sizeof ( struct _sx_sasl_sess_st ) ) ; //<S2SV> sctx -> s = s ; //<S2SV> sctx -> ctx = ctx ; //<S2SV> gsasl_session_hook_set ( sd , ( void * ) sctx ) ; //<S2SV> gsasl_property_set ( sd , GSASL_SERVICE , ctx -> appname ) ; //<S2SV> gsasl_property_set ( sd , GSASL_REALM , realm ) ; //<S2SV> hostname [ 0 ] = '\\0' ; //<S2SV> gethostname ( hostname , 256 ) ; //<S2SV> hostname [ 255 ] = '\\0' ; //<S2SV> gsasl_property_set ( sd , GSASL_HOSTNAME , hostname ) ; //<S2SV> ext_id = NULL ; //<S2SV> # ifdef HAVE_SSL //<S2SV> for ( i = 0 ; i < s -> env -> nplugins ; i ++ ) //<S2SV> if ( s -> env -> plugins [ i ] -> magic == SX_SSL_MAGIC && s -> plugin_data [ s -> env -> plugins [ i ] -> index ] != NULL ) //<S2SV> ext_id = ( ( _sx_ssl_conn_t ) s -> plugin_data [ s -> env -> plugins [ i ] -> index ] ) -> external_id ; //<S2SV> if ( ext_id != NULL ) { //<S2SV> for ( i = 0 ; i < SX_CONN_EXTERNAL_ID_MAX_COUNT ; i ++ ) //<S2SV> if ( ext_id [ i ] != NULL ) { //<S2SV> ctx -> ext_id [ i ] = strdup ( ext_id [ i ] ) ; //<S2SV> } else { //<S2SV> ctx -> ext_id [ i ] = NULL ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> _sx_debug ( ZONE , "sasl<S2SV_blank>context<S2SV_blank>initialised<S2SV_blank>for<S2SV_blank>%d" , s -> tag ) ; //<S2SV> s -> plugin_data [ p -> index ] = ( void * ) sd ; //<S2SV> if ( strcmp ( mech , "ANONYMOUS" ) == 0 ) { //<S2SV> ( ctx -> cb ) ( sx_sasl_cb_GEN_AUTHZID , NULL , ( void * * ) & out , s , ctx -> cbarg ) ; //<S2SV> buf = strdup ( out ) ; //<S2SV> buflen = strlen ( buf ) ; //<S2SV> } else if ( strstr ( in , "<" ) != NULL && strncmp ( in , "=" , strstr ( in , "<" ) - in ) == 0 ) { //<S2SV> _sx_debug ( ZONE , "gsasl<S2SV_blank>auth<S2SV_blank>string<S2SV_blank>is<S2SV_blank>empty" ) ; //<S2SV> buf = strdup ( "" ) ; //<S2SV> buflen = strlen ( buf ) ; //<S2SV> } else { //<S2SV> ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; //<S2SV> if ( ret != GSASL_OK ) { //<S2SV> _sx_debug ( ZONE , "gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s" , ret , gsasl_strerror ( ret ) ) ; //<S2SV> _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; //<S2SV> if ( buf != NULL ) free ( buf ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; //<S2SV> } //<S2SV> else { //<S2SV> ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; //<S2SV> if ( ret != GSASL_OK ) { //<S2SV> _sx_debug ( ZONE , "gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s" , ret , gsasl_strerror ( ret ) ) ; //<S2SV> _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! sd ) { //<S2SV> _sx_debug ( ZONE , "response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism<S2SV_blank>(decoded:<S2SV_blank>%.*s)" , buflen , buf ) ; //<S2SV> _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_MECH_TOO_WEAK , "response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism" ) , 0 ) ; //<S2SV> if ( buf != NULL ) free ( buf ) ; //<S2SV> return ; //<S2SV> } //<S2SV> _sx_debug ( ZONE , "response<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(decoded:<S2SV_blank>%.*s)" , buflen , buf ) ; //<S2SV> ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; //<S2SV> } //<S2SV> if ( buf != NULL ) free ( buf ) ; //<S2SV> if ( ret == GSASL_OK ) { //<S2SV> _sx_debug ( ZONE , "sasl<S2SV_blank>handshake<S2SV_blank>completed" ) ; //<S2SV> ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; //<S2SV> if ( ret == GSASL_OK ) { //<S2SV> _sx_nad_write ( s , _sx_sasl_success ( s , buf , buflen ) , 0 ) ; //<S2SV> free ( buf ) ; //<S2SV> ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify = _sx_sasl_notify_success ; //<S2SV> ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify_arg = ( void * ) p ; //<S2SV> } //<S2SV> else { //<S2SV> _sx_debug ( ZONE , "gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s" , ret , gsasl_strerror ( ret ) ) ; //<S2SV> _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; //<S2SV> if ( buf != NULL ) free ( buf ) ; //<S2SV> } //<S2SV> if ( out != NULL ) free ( out ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ret == GSASL_NEEDS_MORE ) { //<S2SV> _sx_debug ( ZONE , "sasl<S2SV_blank>handshake<S2SV_blank>in<S2SV_blank>progress<S2SV_blank>(challenge:<S2SV_blank>%.*s)" , outlen , out ) ; //<S2SV> ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; //<S2SV> if ( ret == GSASL_OK ) { //<S2SV> _sx_nad_write ( s , _sx_sasl_challenge ( s , buf , buflen ) , 0 ) ; //<S2SV> free ( buf ) ; //<S2SV> } //<S2SV> else { //<S2SV> _sx_debug ( ZONE , "gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s" , ret , gsasl_strerror ( ret ) ) ; //<S2SV> _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; //<S2SV> if ( buf != NULL ) free ( buf ) ; //<S2SV> } //<S2SV> if ( out != NULL ) free ( out ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( out != NULL ) free ( out ) ; //<S2SV> _sx_debug ( ZONE , "sasl<S2SV_blank>handshake<S2SV_blank>failed;<S2SV_blank>(%d):<S2SV_blank>%s" , ret , gsasl_strerror ( ret ) ) ; //<S2SV> switch ( ret ) { //<S2SV> case GSASL_AUTHENTICATION_ERROR : //<S2SV> case GSASL_NO_ANONYMOUS_TOKEN : //<S2SV> case GSASL_NO_AUTHID : //<S2SV> case GSASL_NO_AUTHZID : //<S2SV> case GSASL_NO_PASSWORD : //<S2SV> case GSASL_NO_PASSCODE : //<S2SV> case GSASL_NO_PIN : //<S2SV> case GSASL_NO_SERVICE : //<S2SV> case GSASL_NO_HOSTNAME : //<S2SV> out = _sasl_err_NOT_AUTHORIZED ; //<S2SV> break ; //<S2SV> case GSASL_UNKNOWN_MECHANISM : //<S2SV> case GSASL_MECHANISM_PARSE_ERROR : //<S2SV> out = _sasl_err_INVALID_MECHANISM ; //<S2SV> break ; //<S2SV> case GSASL_BASE64_ERROR : //<S2SV> out = _sasl_err_INCORRECT_ENCODING ; //<S2SV> break ; //<S2SV> default : //<S2SV> out = _sasl_err_MALFORMED_REQUEST ; //<S2SV> } //<S2SV> _sx_nad_write ( s , _sx_sasl_failure ( s , out , gsasl_strerror ( ret ) ) , 0 ) ; //<S2SV> } //<S2SV> 