smb_sdrc_t //<S2SV> smb2_flush ( smb_request_t * sr ) //<S2SV> { //<S2SV> smb_ofile_t * of = NULL ; //<S2SV> uint16_t StructSize ; //<S2SV> uint16_t reserved1 ; //<S2SV> uint32_t reserved2 ; //<S2SV> smb2fid_t smb2fid ; //<S2SV> uint32_t status ; //<S2SV> int rc = 0 ; //<S2SV> rc = smb_mbc_decodef ( //<S2SV> & sr -> smb_data , "wwlqq" , //<S2SV> & StructSize , //<S2SV> & reserved1 , //<S2SV> & reserved2 , //<S2SV> & smb2fid . persistent , //<S2SV> & smb2fid . temporal ) ; //<S2SV> if ( rc ) //<S2SV> return ( SDRC_ERROR ) ; //<S2SV> if ( StructSize != 24 ) //<S2SV> return ( SDRC_ERROR ) ; //<S2SV> status = smb2sr_lookup_fid ( sr , & smb2fid ) ; //<S2SV> if ( status ) { //<S2SV> smb2sr_put_error ( sr , status ) ; //<S2SV> return ( SDRC_SUCCESS ) ; //<S2SV> } //<S2SV> of = sr -> fid_ofile ; //<S2SV> if ( ( of -> f_node -> flags & NODE_FLAGS_WRITE_THROUGH ) == 0 ) //<S2SV> ( void ) smb_fsop_commit ( sr , of -> f_cr , of -> f_node ) ; //<S2SV> ( void ) smb_mbc_encodef ( //<S2SV> & sr -> reply , "wwl" , //<S2SV> 4 , //<S2SV> 0 ) ; //<S2SV> return ( SDRC_SUCCESS ) ; //<S2SV> } //<S2SV> 