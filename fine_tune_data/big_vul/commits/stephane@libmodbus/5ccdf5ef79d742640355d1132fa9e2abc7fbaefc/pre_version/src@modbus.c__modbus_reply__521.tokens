int modbus_reply ( modbus_t * ctx , const uint8_t * req , //<S2SV> int req_length , modbus_mapping_t * mb_mapping ) //<S2SV> { //<S2SV> int offset ; //<S2SV> int slave ; //<S2SV> int function ; //<S2SV> uint16_t address ; //<S2SV> uint8_t rsp [ MAX_MESSAGE_LENGTH ] ; //<S2SV> int rsp_length = 0 ; //<S2SV> sft_t sft ; //<S2SV> if ( ctx == NULL ) { //<S2SV> errno = EINVAL ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> offset = ctx -> backend -> header_length ; //<S2SV> slave = req [ offset - 1 ] ; //<S2SV> function = req [ offset ] ; //<S2SV> address = ( req [ offset + 1 ] << 8 ) + req [ offset + 2 ] ; //<S2SV> sft . slave = slave ; //<S2SV> sft . function = function ; //<S2SV> sft . t_id = ctx -> backend -> prepare_response_tid ( req , & req_length ) ; //<S2SV> switch ( function ) { //<S2SV> case MODBUS_FC_READ_COILS : //<S2SV> case MODBUS_FC_READ_DISCRETE_INPUTS : { //<S2SV> unsigned int is_input = ( function == MODBUS_FC_READ_DISCRETE_INPUTS ) ; //<S2SV> int start_bits = is_input ? mb_mapping -> start_input_bits : mb_mapping -> start_bits ; //<S2SV> int nb_bits = is_input ? mb_mapping -> nb_input_bits : mb_mapping -> nb_bits ; //<S2SV> uint8_t * tab_bits = is_input ? mb_mapping -> tab_input_bits : mb_mapping -> tab_bits ; //<S2SV> const char * const name = is_input ? "read_input_bits" : "read_bits" ; //<S2SV> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; //<S2SV> int mapping_address = address - start_bits ; //<S2SV> if ( nb < 1 || MODBUS_MAX_READ_BITS < nb ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , //<S2SV> "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n" , //<S2SV> nb , name , MODBUS_MAX_READ_BITS ) ; //<S2SV> } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_bits ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , //<S2SV> MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n" , //<S2SV> mapping_address < 0 ? address : address + nb , name ) ; //<S2SV> } else { //<S2SV> rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; //<S2SV> rsp [ rsp_length ++ ] = ( nb / 8 ) + ( ( nb % 8 ) ? 1 : 0 ) ; //<S2SV> rsp_length = response_io_status ( tab_bits , mapping_address , nb , //<S2SV> rsp , rsp_length ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case MODBUS_FC_READ_HOLDING_REGISTERS : //<S2SV> case MODBUS_FC_READ_INPUT_REGISTERS : { //<S2SV> unsigned int is_input = ( function == MODBUS_FC_READ_INPUT_REGISTERS ) ; //<S2SV> int start_registers = is_input ? mb_mapping -> start_input_registers : mb_mapping -> start_registers ; //<S2SV> int nb_registers = is_input ? mb_mapping -> nb_input_registers : mb_mapping -> nb_registers ; //<S2SV> uint16_t * tab_registers = is_input ? mb_mapping -> tab_input_registers : mb_mapping -> tab_registers ; //<S2SV> const char * const name = is_input ? "read_input_registers" : "read_registers" ; //<S2SV> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; //<S2SV> int mapping_address = address - start_registers ; //<S2SV> if ( nb < 1 || MODBUS_MAX_READ_REGISTERS < nb ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , //<S2SV> "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(max<S2SV_blank>%d)\\n" , //<S2SV> nb , name , MODBUS_MAX_READ_REGISTERS ) ; //<S2SV> } else if ( mapping_address < 0 || ( mapping_address + nb ) > nb_registers ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>%s\\n" , //<S2SV> mapping_address < 0 ? address : address + nb , name ) ; //<S2SV> } else { //<S2SV> int i ; //<S2SV> rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; //<S2SV> rsp [ rsp_length ++ ] = nb << 1 ; //<S2SV> for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { //<S2SV> rsp [ rsp_length ++ ] = tab_registers [ i ] >> 8 ; //<S2SV> rsp [ rsp_length ++ ] = tab_registers [ i ] & 0xFF ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case MODBUS_FC_WRITE_SINGLE_COIL : { //<S2SV> int mapping_address = address - mb_mapping -> start_bits ; //<S2SV> if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_bits ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit\\n" , //<S2SV> address ) ; //<S2SV> } else { //<S2SV> int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; //<S2SV> if ( data == 0xFF00 || data == 0x0 ) { //<S2SV> mb_mapping -> tab_bits [ mapping_address ] = data ? ON : OFF ; //<S2SV> memcpy ( rsp , req , req_length ) ; //<S2SV> rsp_length = req_length ; //<S2SV> } else { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , //<S2SV> MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>value<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bit<S2SV_blank>request<S2SV_blank>at<S2SV_blank>address<S2SV_blank>%0X\\n" , //<S2SV> data , address ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case MODBUS_FC_WRITE_SINGLE_REGISTER : { //<S2SV> int mapping_address = address - mb_mapping -> start_registers ; //<S2SV> if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , //<S2SV> MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n" , //<S2SV> address ) ; //<S2SV> } else { //<S2SV> int data = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; //<S2SV> mb_mapping -> tab_registers [ mapping_address ] = data ; //<S2SV> memcpy ( rsp , req , req_length ) ; //<S2SV> rsp_length = req_length ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case MODBUS_FC_WRITE_MULTIPLE_COILS : { //<S2SV> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; //<S2SV> int mapping_address = address - mb_mapping -> start_bits ; //<S2SV> if ( nb < 1 || MODBUS_MAX_WRITE_BITS < nb ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , //<S2SV> "Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_bits<S2SV_blank>(max<S2SV_blank>%d)\\n" , //<S2SV> nb , MODBUS_MAX_WRITE_BITS ) ; //<S2SV> } else if ( mapping_address < 0 || //<S2SV> ( mapping_address + nb ) > mb_mapping -> nb_bits ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , //<S2SV> MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_bits\\n" , //<S2SV> mapping_address < 0 ? address : address + nb ) ; //<S2SV> } else { //<S2SV> modbus_set_bits_from_bytes ( mb_mapping -> tab_bits , mapping_address , nb , //<S2SV> & req [ offset + 6 ] ) ; //<S2SV> rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; //<S2SV> memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; //<S2SV> rsp_length += 4 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case MODBUS_FC_WRITE_MULTIPLE_REGISTERS : { //<S2SV> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; //<S2SV> int mapping_address = address - mb_mapping -> start_registers ; //<S2SV> if ( nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , //<S2SV> "Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>values<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>write_registers<S2SV_blank>(max<S2SV_blank>%d)\\n" , //<S2SV> nb , MODBUS_MAX_WRITE_REGISTERS ) ; //<S2SV> } else if ( mapping_address < 0 || //<S2SV> ( mapping_address + nb ) > mb_mapping -> nb_registers ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_registers\\n" , //<S2SV> mapping_address < 0 ? address : address + nb ) ; //<S2SV> } else { //<S2SV> int i , j ; //<S2SV> for ( i = mapping_address , j = 6 ; i < mapping_address + nb ; i ++ , j += 2 ) { //<S2SV> mb_mapping -> tab_registers [ i ] = //<S2SV> ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; //<S2SV> } //<S2SV> rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; //<S2SV> memcpy ( rsp + rsp_length , req + rsp_length , 4 ) ; //<S2SV> rsp_length += 4 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case MODBUS_FC_REPORT_SLAVE_ID : { //<S2SV> int str_len ; //<S2SV> int byte_count_pos ; //<S2SV> rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; //<S2SV> byte_count_pos = rsp_length ++ ; //<S2SV> rsp [ rsp_length ++ ] = _REPORT_SLAVE_ID ; //<S2SV> rsp [ rsp_length ++ ] = 0xFF ; //<S2SV> str_len = 3 + strlen ( LIBMODBUS_VERSION_STRING ) ; //<S2SV> memcpy ( rsp + rsp_length , "LMB" LIBMODBUS_VERSION_STRING , str_len ) ; //<S2SV> rsp_length += str_len ; //<S2SV> rsp [ byte_count_pos ] = rsp_length - byte_count_pos - 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case MODBUS_FC_READ_EXCEPTION_STATUS : //<S2SV> if ( ctx -> debug ) { //<S2SV> fprintf ( stderr , "FIXME<S2SV_blank>Not<S2SV_blank>implemented\\n" ) ; //<S2SV> } //<S2SV> errno = ENOPROTOOPT ; //<S2SV> return - 1 ; //<S2SV> break ; //<S2SV> case MODBUS_FC_MASK_WRITE_REGISTER : { //<S2SV> int mapping_address = address - mb_mapping -> start_registers ; //<S2SV> if ( mapping_address < 0 || mapping_address >= mb_mapping -> nb_registers ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>in<S2SV_blank>write_register\\n" , //<S2SV> address ) ; //<S2SV> } else { //<S2SV> uint16_t data = mb_mapping -> tab_registers [ mapping_address ] ; //<S2SV> uint16_t and = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; //<S2SV> uint16_t or = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; //<S2SV> data = ( data & and ) | ( or & ( ~ and ) ) ; //<S2SV> mb_mapping -> tab_registers [ mapping_address ] = data ; //<S2SV> memcpy ( rsp , req , req_length ) ; //<S2SV> rsp_length = req_length ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case MODBUS_FC_WRITE_AND_READ_REGISTERS : { //<S2SV> int nb = ( req [ offset + 3 ] << 8 ) + req [ offset + 4 ] ; //<S2SV> uint16_t address_write = ( req [ offset + 5 ] << 8 ) + req [ offset + 6 ] ; //<S2SV> int nb_write = ( req [ offset + 7 ] << 8 ) + req [ offset + 8 ] ; //<S2SV> int nb_write_bytes = req [ offset + 9 ] ; //<S2SV> int mapping_address = address - mb_mapping -> start_registers ; //<S2SV> int mapping_address_write = address_write - mb_mapping -> start_registers ; //<S2SV> if ( nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write || //<S2SV> nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb || //<S2SV> nb_write_bytes != nb_write * 2 ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE , rsp , TRUE , //<S2SV> "Illegal<S2SV_blank>nb<S2SV_blank>of<S2SV_blank>values<S2SV_blank>(W%d,<S2SV_blank>R%d)<S2SV_blank>in<S2SV_blank>write_and_read_registers<S2SV_blank>(max<S2SV_blank>W%d,<S2SV_blank>R%d)\\n" , //<S2SV> nb_write , nb , MODBUS_MAX_WR_WRITE_REGISTERS , MODBUS_MAX_WR_READ_REGISTERS ) ; //<S2SV> } else if ( mapping_address < 0 || //<S2SV> ( mapping_address + nb ) > mb_mapping -> nb_registers || //<S2SV> mapping_address < 0 || //<S2SV> ( mapping_address_write + nb_write ) > mb_mapping -> nb_registers ) { //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS , rsp , FALSE , //<S2SV> "Illegal<S2SV_blank>data<S2SV_blank>read<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>or<S2SV_blank>write<S2SV_blank>address<S2SV_blank>0x%0X<S2SV_blank>write_and_read_registers\\n" , //<S2SV> mapping_address < 0 ? address : address + nb , //<S2SV> mapping_address_write < 0 ? address_write : address_write + nb_write ) ; //<S2SV> } else { //<S2SV> int i , j ; //<S2SV> rsp_length = ctx -> backend -> build_response_basis ( & sft , rsp ) ; //<S2SV> rsp [ rsp_length ++ ] = nb << 1 ; //<S2SV> for ( i = mapping_address_write , j = 10 ; //<S2SV> i < mapping_address_write + nb_write ; i ++ , j += 2 ) { //<S2SV> mb_mapping -> tab_registers [ i ] = //<S2SV> ( req [ offset + j ] << 8 ) + req [ offset + j + 1 ] ; //<S2SV> } //<S2SV> for ( i = mapping_address ; i < mapping_address + nb ; i ++ ) { //<S2SV> rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] >> 8 ; //<S2SV> rsp [ rsp_length ++ ] = mb_mapping -> tab_registers [ i ] & 0xFF ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> rsp_length = response_exception ( //<S2SV> ctx , & sft , MODBUS_EXCEPTION_ILLEGAL_FUNCTION , rsp , TRUE , //<S2SV> "Unknown<S2SV_blank>Modbus<S2SV_blank>function<S2SV_blank>code:<S2SV_blank>0x%0X\\n" , function ) ; //<S2SV> break ; //<S2SV> } //<S2SV> return ( ctx -> backend -> backend_type == _MODBUS_BACKEND_TYPE_RTU && //<S2SV> slave == MODBUS_BROADCAST_ADDRESS ) ? 0 : send_msg ( ctx , rsp , rsp_length ) ; //<S2SV> } //<S2SV> 