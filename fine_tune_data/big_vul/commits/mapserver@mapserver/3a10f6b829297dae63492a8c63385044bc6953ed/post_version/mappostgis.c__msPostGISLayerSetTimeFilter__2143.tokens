int msPostGISLayerSetTimeFilter ( layerObj * lp , const char * timestring , const char * timefield ) //<S2SV> { //<S2SV> char * * atimes , * * aranges = NULL ; //<S2SV> int numtimes = 0 , i = 0 , numranges = 0 ; //<S2SV> size_t buffer_size = 512 ; //<S2SV> char buffer [ 512 ] , bufferTmp [ 512 ] ; //<S2SV> buffer [ 0 ] = '\\0' ; //<S2SV> bufferTmp [ 0 ] = '\\0' ; //<S2SV> if ( ! lp || ! timestring || ! timefield ) //<S2SV> return MS_FALSE ; //<S2SV> if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { //<S2SV> msSetError ( MS_MISCERR , "Invalid<S2SV_blank>time<S2SV_blank>filter." , "msPostGISLayerSetTimeFilter()" ) ; //<S2SV> return MS_FALSE ; //<S2SV> } //<S2SV> if ( strstr ( timestring , "," ) == NULL && //<S2SV> strstr ( timestring , "/" ) == NULL ) { //<S2SV> createPostgresTimeCompareSimple ( timefield , timestring , buffer , buffer_size ) ; //<S2SV> } else { //<S2SV> atimes = msStringSplit ( timestring , ',' , & numtimes ) ; //<S2SV> if ( atimes == NULL || numtimes < 1 ) //<S2SV> return MS_FALSE ; //<S2SV> strlcat ( buffer , "(" , buffer_size ) ; //<S2SV> for ( i = 0 ; i < numtimes ; i ++ ) { //<S2SV> if ( i != 0 ) { //<S2SV> strlcat ( buffer , "<S2SV_blank>OR<S2SV_blank>" , buffer_size ) ; //<S2SV> } //<S2SV> strlcat ( buffer , "(" , buffer_size ) ; //<S2SV> aranges = msStringSplit ( atimes [ i ] , '/' , & numranges ) ; //<S2SV> if ( ! aranges ) return MS_FALSE ; //<S2SV> if ( numranges == 1 ) { //<S2SV> createPostgresTimeCompareSimple ( timefield , atimes [ i ] , bufferTmp , buffer_size ) ; //<S2SV> strlcat ( buffer , bufferTmp , buffer_size ) ; //<S2SV> } else if ( numranges == 2 ) { //<S2SV> createPostgresTimeCompareRange ( timefield , aranges [ 0 ] , aranges [ 1 ] , bufferTmp , buffer_size ) ; //<S2SV> strlcat ( buffer , bufferTmp , buffer_size ) ; //<S2SV> } else { //<S2SV> return MS_FALSE ; //<S2SV> } //<S2SV> msFreeCharArray ( aranges , numranges ) ; //<S2SV> strlcat ( buffer , ")" , buffer_size ) ; //<S2SV> } //<S2SV> strlcat ( buffer , ")" , buffer_size ) ; //<S2SV> msFreeCharArray ( atimes , numtimes ) ; //<S2SV> } //<S2SV> if ( ! * buffer ) { //<S2SV> return MS_FALSE ; //<S2SV> } //<S2SV> if ( lp -> filteritem ) free ( lp -> filteritem ) ; //<S2SV> lp -> filteritem = msStrdup ( timefield ) ; //<S2SV> if ( & lp -> filter ) { //<S2SV> if ( lp -> filter . type == MS_EXPRESSION ) { //<S2SV> snprintf ( bufferTmp , buffer_size , "(%s)<S2SV_blank>and<S2SV_blank>%s" , lp -> filter . string , buffer ) ; //<S2SV> loadExpressionString ( & lp -> filter , bufferTmp ) ; //<S2SV> } else { //<S2SV> freeExpression ( & lp -> filter ) ; //<S2SV> loadExpressionString ( & lp -> filter , buffer ) ; //<S2SV> } //<S2SV> } //<S2SV> return MS_TRUE ; //<S2SV> } //<S2SV> 