static enum try_read_result try_read_network ( conn * c ) { //<S2SV> enum try_read_result gotdata = READ_NO_DATA_RECEIVED ; //<S2SV> int res ; //<S2SV> int num_allocs = 0 ; //<S2SV> assert ( c != NULL ) ; //<S2SV> if ( c -> rcurr != c -> rbuf ) { //<S2SV> if ( c -> rbytes != 0 ) //<S2SV> memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; //<S2SV> c -> rcurr = c -> rbuf ; //<S2SV> } //<S2SV> while ( 1 ) { //<S2SV> if ( c -> rbytes >= c -> rsize ) { //<S2SV> if ( num_allocs == 4 ) { //<S2SV> return gotdata ; //<S2SV> } //<S2SV> ++ num_allocs ; //<S2SV> char * new_rbuf = realloc ( c -> rbuf , c -> rsize * 2 ) ; //<S2SV> if ( ! new_rbuf ) { //<S2SV> if ( settings . verbose > 0 ) //<S2SV> fprintf ( stderr , "Couldn\'t<S2SV_blank>realloc<S2SV_blank>input<S2SV_blank>buffer\\n" ) ; //<S2SV> c -> rbytes = 0 ; //<S2SV> out_string ( c , "SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>reading<S2SV_blank>request" ) ; //<S2SV> c -> write_and_go = conn_closing ; //<S2SV> return READ_MEMORY_ERROR ; //<S2SV> } //<S2SV> c -> rcurr = c -> rbuf = new_rbuf ; //<S2SV> c -> rsize *= 2 ; //<S2SV> } //<S2SV> int avail = c -> rsize - c -> rbytes ; //<S2SV> res = read ( c -> sfd , c -> rbuf + c -> rbytes , avail ) ; //<S2SV> if ( res > 0 ) { //<S2SV> pthread_mutex_lock ( & c -> thread -> stats . mutex ) ; //<S2SV> c -> thread -> stats . bytes_read += res ; //<S2SV> pthread_mutex_unlock ( & c -> thread -> stats . mutex ) ; //<S2SV> gotdata = READ_DATA_RECEIVED ; //<S2SV> c -> rbytes += res ; //<S2SV> if ( res == avail ) { //<S2SV> continue ; //<S2SV> } else { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( res == 0 ) { //<S2SV> return READ_ERROR ; //<S2SV> } //<S2SV> if ( res == - 1 ) { //<S2SV> if ( errno == EAGAIN || errno == EWOULDBLOCK ) { //<S2SV> break ; //<S2SV> } //<S2SV> return READ_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> return gotdata ; //<S2SV> } //<S2SV> 