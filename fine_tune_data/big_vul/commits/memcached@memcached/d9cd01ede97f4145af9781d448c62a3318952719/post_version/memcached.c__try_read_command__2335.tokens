static int try_read_command ( conn * c ) { //<S2SV> assert ( c != NULL ) ; //<S2SV> assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; //<S2SV> assert ( c -> rbytes > 0 ) ; //<S2SV> if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { //<S2SV> if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { //<S2SV> c -> protocol = binary_prot ; //<S2SV> } else { //<S2SV> c -> protocol = ascii_prot ; //<S2SV> } //<S2SV> if ( settings . verbose > 1 ) { //<S2SV> fprintf ( stderr , "%d:<S2SV_blank>Client<S2SV_blank>using<S2SV_blank>the<S2SV_blank>%s<S2SV_blank>protocol\\n" , c -> sfd , //<S2SV> prot_text ( c -> protocol ) ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( c -> protocol == binary_prot ) { //<S2SV> if ( c -> rbytes < sizeof ( c -> binary_header ) ) { //<S2SV> return 0 ; //<S2SV> } else { //<S2SV> # ifdef NEED_ALIGN //<S2SV> if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { //<S2SV> memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; //<S2SV> c -> rcurr = c -> rbuf ; //<S2SV> if ( settings . verbose > 1 ) { //<S2SV> fprintf ( stderr , "%d:<S2SV_blank>Realign<S2SV_blank>input<S2SV_blank>buffer\\n" , c -> sfd ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> protocol_binary_request_header * req ; //<S2SV> req = ( protocol_binary_request_header * ) c -> rcurr ; //<S2SV> if ( settings . verbose > 1 ) { //<S2SV> int ii ; //<S2SV> fprintf ( stderr , "<%d<S2SV_blank>Read<S2SV_blank>binary<S2SV_blank>protocol<S2SV_blank>data:" , c -> sfd ) ; //<S2SV> for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { //<S2SV> if ( ii % 4 == 0 ) { //<S2SV> fprintf ( stderr , "\\n<%d<S2SV_blank><S2SV_blank><S2SV_blank>" , c -> sfd ) ; //<S2SV> } //<S2SV> fprintf ( stderr , "<S2SV_blank>0x%02x" , req -> bytes [ ii ] ) ; //<S2SV> } //<S2SV> fprintf ( stderr , "\\n" ) ; //<S2SV> } //<S2SV> c -> binary_header = * req ; //<S2SV> c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; //<S2SV> c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; //<S2SV> c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; //<S2SV> if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { //<S2SV> if ( settings . verbose ) { //<S2SV> fprintf ( stderr , "Invalid<S2SV_blank>magic:<S2SV_blank><S2SV_blank>%x\\n" , //<S2SV> c -> binary_header . request . magic ) ; //<S2SV> } //<S2SV> conn_set_state ( c , conn_closing ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> c -> msgcurr = 0 ; //<S2SV> c -> msgused = 0 ; //<S2SV> c -> iovused = 0 ; //<S2SV> if ( add_msghdr ( c ) != 0 ) { //<S2SV> out_string ( c , "SERVER_ERROR<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory" ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> c -> cmd = c -> binary_header . request . opcode ; //<S2SV> c -> keylen = c -> binary_header . request . keylen ; //<S2SV> c -> opaque = c -> binary_header . request . opaque ; //<S2SV> c -> cas = 0 ; //<S2SV> dispatch_bin_command ( c ) ; //<S2SV> c -> rbytes -= sizeof ( c -> binary_header ) ; //<S2SV> c -> rcurr += sizeof ( c -> binary_header ) ; //<S2SV> } //<S2SV> } else { //<S2SV> char * el , * cont ; //<S2SV> if ( c -> rbytes == 0 ) //<S2SV> return 0 ; //<S2SV> el = memchr ( c -> rcurr , '\\n' , c -> rbytes ) ; //<S2SV> if ( ! el ) { //<S2SV> if ( c -> rbytes > 1024 ) { //<S2SV> char * ptr = c -> rcurr ; //<S2SV> while ( * ptr == '<S2SV_blank>' ) { //<S2SV> ++ ptr ; //<S2SV> } //<S2SV> if ( ptr - c -> rcurr > 100 || //<S2SV> ( strncmp ( ptr , "get<S2SV_blank>" , 4 ) && strncmp ( ptr , "gets<S2SV_blank>" , 5 ) ) ) { //<S2SV> conn_set_state ( c , conn_closing ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> cont = el + 1 ; //<S2SV> if ( ( el - c -> rcurr ) > 1 && * ( el - 1 ) == '\\r' ) { //<S2SV> el -- ; //<S2SV> } //<S2SV> * el = '\\0' ; //<S2SV> assert ( cont <= ( c -> rcurr + c -> rbytes ) ) ; //<S2SV> process_command ( c , c -> rcurr ) ; //<S2SV> c -> rbytes -= ( cont - c -> rcurr ) ; //<S2SV> c -> rcurr = cont ; //<S2SV> assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> } //<S2SV> 