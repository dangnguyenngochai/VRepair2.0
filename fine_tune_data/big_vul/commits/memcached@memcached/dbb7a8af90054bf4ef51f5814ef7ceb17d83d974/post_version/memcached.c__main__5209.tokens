int main ( int argc , char * * argv ) { //<S2SV> int c ; //<S2SV> bool lock_memory = false ; //<S2SV> bool do_daemonize = false ; //<S2SV> bool preallocate = false ; //<S2SV> int maxcore = 0 ; //<S2SV> char * username = NULL ; //<S2SV> char * pid_file = NULL ; //<S2SV> struct passwd * pw ; //<S2SV> struct rlimit rlim ; //<S2SV> char * buf ; //<S2SV> char unit = '\\0' ; //<S2SV> int size_max = 0 ; //<S2SV> int retval = EXIT_SUCCESS ; //<S2SV> static int * l_socket = NULL ; //<S2SV> static int * u_socket = NULL ; //<S2SV> bool protocol_specified = false ; //<S2SV> bool tcp_specified = false ; //<S2SV> bool udp_specified = false ; //<S2SV> bool start_lru_maintainer = true ; //<S2SV> bool start_lru_crawler = true ; //<S2SV> bool start_assoc_maint = true ; //<S2SV> enum hashfunc_type hash_type = MURMUR3_HASH ; //<S2SV> uint32_t tocrawl ; //<S2SV> uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; //<S2SV> bool use_slab_sizes = false ; //<S2SV> char * slab_sizes_unparsed = NULL ; //<S2SV> bool slab_chunk_size_changed = false ; //<S2SV> # ifdef EXTSTORE //<S2SV> void * storage = NULL ; //<S2SV> char * storage_file = NULL ; //<S2SV> struct extstore_conf ext_cf ; //<S2SV> # endif //<S2SV> char * subopts , * subopts_orig ; //<S2SV> char * subopts_value ; //<S2SV> enum { //<S2SV> MAXCONNS_FAST = 0 , //<S2SV> HASHPOWER_INIT , //<S2SV> NO_HASHEXPAND , //<S2SV> SLAB_REASSIGN , //<S2SV> SLAB_AUTOMOVE , //<S2SV> SLAB_AUTOMOVE_RATIO , //<S2SV> SLAB_AUTOMOVE_WINDOW , //<S2SV> TAIL_REPAIR_TIME , //<S2SV> HASH_ALGORITHM , //<S2SV> LRU_CRAWLER , //<S2SV> LRU_CRAWLER_SLEEP , //<S2SV> LRU_CRAWLER_TOCRAWL , //<S2SV> LRU_MAINTAINER , //<S2SV> HOT_LRU_PCT , //<S2SV> WARM_LRU_PCT , //<S2SV> HOT_MAX_FACTOR , //<S2SV> WARM_MAX_FACTOR , //<S2SV> TEMPORARY_TTL , //<S2SV> IDLE_TIMEOUT , //<S2SV> WATCHER_LOGBUF_SIZE , //<S2SV> WORKER_LOGBUF_SIZE , //<S2SV> SLAB_SIZES , //<S2SV> SLAB_CHUNK_MAX , //<S2SV> TRACK_SIZES , //<S2SV> NO_INLINE_ASCII_RESP , //<S2SV> MODERN , //<S2SV> NO_MODERN , //<S2SV> NO_CHUNKED_ITEMS , //<S2SV> NO_SLAB_REASSIGN , //<S2SV> NO_SLAB_AUTOMOVE , //<S2SV> NO_MAXCONNS_FAST , //<S2SV> INLINE_ASCII_RESP , //<S2SV> NO_LRU_CRAWLER , //<S2SV> NO_LRU_MAINTAINER , //<S2SV> NO_DROP_PRIVILEGES , //<S2SV> # ifdef MEMCACHED_DEBUG //<S2SV> RELAXED_PRIVILEGES , //<S2SV> # endif //<S2SV> # ifdef EXTSTORE //<S2SV> EXT_PAGE_SIZE , //<S2SV> EXT_PAGE_COUNT , //<S2SV> EXT_WBUF_SIZE , //<S2SV> EXT_THREADS , //<S2SV> EXT_IO_DEPTH , //<S2SV> EXT_PATH , //<S2SV> EXT_ITEM_SIZE , //<S2SV> EXT_ITEM_AGE , //<S2SV> EXT_LOW_TTL , //<S2SV> EXT_RECACHE_RATE , //<S2SV> EXT_COMPACT_UNDER , //<S2SV> EXT_DROP_UNDER , //<S2SV> EXT_MAX_FRAG , //<S2SV> EXT_DROP_UNREAD , //<S2SV> SLAB_AUTOMOVE_FREERATIO , //<S2SV> # endif //<S2SV> } ; //<S2SV> char * const subopts_tokens [ ] = { //<S2SV> [ MAXCONNS_FAST ] = "maxconns_fast" , //<S2SV> [ HASHPOWER_INIT ] = "hashpower" , //<S2SV> [ NO_HASHEXPAND ] = "no_hashexpand" , //<S2SV> [ SLAB_REASSIGN ] = "slab_reassign" , //<S2SV> [ SLAB_AUTOMOVE ] = "slab_automove" , //<S2SV> [ SLAB_AUTOMOVE_RATIO ] = "slab_automove_ratio" , //<S2SV> [ SLAB_AUTOMOVE_WINDOW ] = "slab_automove_window" , //<S2SV> [ TAIL_REPAIR_TIME ] = "tail_repair_time" , //<S2SV> [ HASH_ALGORITHM ] = "hash_algorithm" , //<S2SV> [ LRU_CRAWLER ] = "lru_crawler" , //<S2SV> [ LRU_CRAWLER_SLEEP ] = "lru_crawler_sleep" , //<S2SV> [ LRU_CRAWLER_TOCRAWL ] = "lru_crawler_tocrawl" , //<S2SV> [ LRU_MAINTAINER ] = "lru_maintainer" , //<S2SV> [ HOT_LRU_PCT ] = "hot_lru_pct" , //<S2SV> [ WARM_LRU_PCT ] = "warm_lru_pct" , //<S2SV> [ HOT_MAX_FACTOR ] = "hot_max_factor" , //<S2SV> [ WARM_MAX_FACTOR ] = "warm_max_factor" , //<S2SV> [ TEMPORARY_TTL ] = "temporary_ttl" , //<S2SV> [ IDLE_TIMEOUT ] = "idle_timeout" , //<S2SV> [ WATCHER_LOGBUF_SIZE ] = "watcher_logbuf_size" , //<S2SV> [ WORKER_LOGBUF_SIZE ] = "worker_logbuf_size" , //<S2SV> [ SLAB_SIZES ] = "slab_sizes" , //<S2SV> [ SLAB_CHUNK_MAX ] = "slab_chunk_max" , //<S2SV> [ TRACK_SIZES ] = "track_sizes" , //<S2SV> [ NO_INLINE_ASCII_RESP ] = "no_inline_ascii_resp" , //<S2SV> [ MODERN ] = "modern" , //<S2SV> [ NO_MODERN ] = "no_modern" , //<S2SV> [ NO_CHUNKED_ITEMS ] = "no_chunked_items" , //<S2SV> [ NO_SLAB_REASSIGN ] = "no_slab_reassign" , //<S2SV> [ NO_SLAB_AUTOMOVE ] = "no_slab_automove" , //<S2SV> [ NO_MAXCONNS_FAST ] = "no_maxconns_fast" , //<S2SV> [ INLINE_ASCII_RESP ] = "inline_ascii_resp" , //<S2SV> [ NO_LRU_CRAWLER ] = "no_lru_crawler" , //<S2SV> [ NO_LRU_MAINTAINER ] = "no_lru_maintainer" , //<S2SV> [ NO_DROP_PRIVILEGES ] = "no_drop_privileges" , //<S2SV> # ifdef MEMCACHED_DEBUG //<S2SV> [ RELAXED_PRIVILEGES ] = "relaxed_privileges" , //<S2SV> # endif //<S2SV> # ifdef EXTSTORE //<S2SV> [ EXT_PAGE_SIZE ] = "ext_page_size" , //<S2SV> [ EXT_PAGE_COUNT ] = "ext_page_count" , //<S2SV> [ EXT_WBUF_SIZE ] = "ext_wbuf_size" , //<S2SV> [ EXT_THREADS ] = "ext_threads" , //<S2SV> [ EXT_IO_DEPTH ] = "ext_io_depth" , //<S2SV> [ EXT_PATH ] = "ext_path" , //<S2SV> [ EXT_ITEM_SIZE ] = "ext_item_size" , //<S2SV> [ EXT_ITEM_AGE ] = "ext_item_age" , //<S2SV> [ EXT_LOW_TTL ] = "ext_low_ttl" , //<S2SV> [ EXT_RECACHE_RATE ] = "ext_recache_rate" , //<S2SV> [ EXT_COMPACT_UNDER ] = "ext_compact_under" , //<S2SV> [ EXT_DROP_UNDER ] = "ext_drop_under" , //<S2SV> [ EXT_MAX_FRAG ] = "ext_max_frag" , //<S2SV> [ EXT_DROP_UNREAD ] = "ext_drop_unread" , //<S2SV> [ SLAB_AUTOMOVE_FREERATIO ] = "slab_automove_freeratio" , //<S2SV> # endif //<S2SV> NULL //<S2SV> } ; //<S2SV> if ( ! sanitycheck ( ) ) { //<S2SV> return EX_OSERR ; //<S2SV> } //<S2SV> signal ( SIGINT , sig_handler ) ; //<S2SV> signal ( SIGTERM , sig_handler ) ; //<S2SV> settings_init ( ) ; //<S2SV> # ifdef EXTSTORE //<S2SV> settings . ext_item_size = 512 ; //<S2SV> settings . ext_item_age = UINT_MAX ; //<S2SV> settings . ext_low_ttl = 0 ; //<S2SV> settings . ext_recache_rate = 2000 ; //<S2SV> settings . ext_max_frag = 0.8 ; //<S2SV> settings . ext_drop_unread = false ; //<S2SV> settings . ext_wbuf_size = 1024 * 1024 * 4 ; //<S2SV> settings . ext_compact_under = 0 ; //<S2SV> settings . ext_drop_under = 0 ; //<S2SV> settings . slab_automove_freeratio = 0.01 ; //<S2SV> ext_cf . page_size = 1024 * 1024 * 64 ; //<S2SV> ext_cf . page_count = 64 ; //<S2SV> ext_cf . wbuf_size = settings . ext_wbuf_size ; //<S2SV> ext_cf . io_threadcount = 1 ; //<S2SV> ext_cf . io_depth = 1 ; //<S2SV> ext_cf . page_buckets = 4 ; //<S2SV> ext_cf . wbuf_count = ext_cf . page_buckets ; //<S2SV> # endif //<S2SV> init_lru_maintainer ( ) ; //<S2SV> setbuf ( stderr , NULL ) ; //<S2SV> char * shortopts = //<S2SV> "a:" //<S2SV> "A" //<S2SV> "p:" //<S2SV> "s:" //<S2SV> "U:" //<S2SV> "m:" //<S2SV> "M" //<S2SV> "c:" //<S2SV> "k" //<S2SV> "hiV" //<S2SV> "r" //<S2SV> "v" //<S2SV> "d" //<S2SV> "l:" //<S2SV> "u:" //<S2SV> "P:" //<S2SV> "f:" //<S2SV> "n:" //<S2SV> "t:" //<S2SV> "D:" //<S2SV> "L" //<S2SV> "R:" //<S2SV> "C" //<S2SV> "b:" //<S2SV> "B:" //<S2SV> "I:" //<S2SV> "S" //<S2SV> "F" //<S2SV> "X" //<S2SV> "o:" //<S2SV> ; //<S2SV> # ifdef HAVE_GETOPT_LONG //<S2SV> const struct option longopts [ ] = { //<S2SV> { "unix-mask" , required_argument , 0 , 'a' } , //<S2SV> { "enable-shutdown" , no_argument , 0 , 'A' } , //<S2SV> { "port" , required_argument , 0 , 'p' } , //<S2SV> { "unix-socket" , required_argument , 0 , 's' } , //<S2SV> { "udp-port" , required_argument , 0 , 'U' } , //<S2SV> { "memory-limit" , required_argument , 0 , 'm' } , //<S2SV> { "disable-evictions" , no_argument , 0 , 'M' } , //<S2SV> { "conn-limit" , required_argument , 0 , 'c' } , //<S2SV> { "lock-memory" , no_argument , 0 , 'k' } , //<S2SV> { "help" , no_argument , 0 , 'h' } , //<S2SV> { "license" , no_argument , 0 , 'i' } , //<S2SV> { "version" , no_argument , 0 , 'V' } , //<S2SV> { "enable-coredumps" , no_argument , 0 , 'r' } , //<S2SV> { "verbose" , optional_argument , 0 , 'v' } , //<S2SV> { "daemon" , no_argument , 0 , 'd' } , //<S2SV> { "listen" , required_argument , 0 , 'l' } , //<S2SV> { "user" , required_argument , 0 , 'u' } , //<S2SV> { "pidfile" , required_argument , 0 , 'P' } , //<S2SV> { "slab-growth-factor" , required_argument , 0 , 'f' } , //<S2SV> { "slab-min-size" , required_argument , 0 , 'n' } , //<S2SV> { "threads" , required_argument , 0 , 't' } , //<S2SV> { "enable-largepages" , no_argument , 0 , 'L' } , //<S2SV> { "max-reqs-per-event" , required_argument , 0 , 'R' } , //<S2SV> { "disable-cas" , no_argument , 0 , 'C' } , //<S2SV> { "listen-backlog" , required_argument , 0 , 'b' } , //<S2SV> { "protocol" , required_argument , 0 , 'B' } , //<S2SV> { "max-item-size" , required_argument , 0 , 'I' } , //<S2SV> { "enable-sasl" , no_argument , 0 , 'S' } , //<S2SV> { "disable-flush-all" , no_argument , 0 , 'F' } , //<S2SV> { "disable-dumping" , no_argument , 0 , 'X' } , //<S2SV> { "extended" , required_argument , 0 , 'o' } , //<S2SV> { 0 , 0 , 0 , 0 } //<S2SV> } ; //<S2SV> int optindex ; //<S2SV> while ( - 1 != ( c = getopt_long ( argc , argv , shortopts , //<S2SV> longopts , & optindex ) ) ) { //<S2SV> # else //<S2SV> while ( - 1 != ( c = getopt ( argc , argv , shortopts ) ) ) { //<S2SV> # endif //<S2SV> switch ( c ) { //<S2SV> case 'A' : //<S2SV> settings . shutdown_command = true ; //<S2SV> break ; //<S2SV> case 'a' : //<S2SV> settings . access = strtol ( optarg , NULL , 8 ) ; //<S2SV> break ; //<S2SV> case 'U' : //<S2SV> settings . udpport = atoi ( optarg ) ; //<S2SV> udp_specified = true ; //<S2SV> break ; //<S2SV> case 'p' : //<S2SV> settings . port = atoi ( optarg ) ; //<S2SV> tcp_specified = true ; //<S2SV> break ; //<S2SV> case 's' : //<S2SV> settings . socketpath = optarg ; //<S2SV> break ; //<S2SV> case 'm' : //<S2SV> settings . maxbytes = ( ( size_t ) atoi ( optarg ) ) * 1024 * 1024 ; //<S2SV> break ; //<S2SV> case 'M' : //<S2SV> settings . evict_to_free = 0 ; //<S2SV> break ; //<S2SV> case 'c' : //<S2SV> settings . maxconns = atoi ( optarg ) ; //<S2SV> if ( settings . maxconns <= 0 ) { //<S2SV> fprintf ( stderr , "Maximum<S2SV_blank>connections<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'h' : //<S2SV> usage ( ) ; //<S2SV> exit ( EXIT_SUCCESS ) ; //<S2SV> case 'i' : //<S2SV> usage_license ( ) ; //<S2SV> exit ( EXIT_SUCCESS ) ; //<S2SV> case 'V' : //<S2SV> printf ( PACKAGE "<S2SV_blank>" VERSION "\\n" ) ; //<S2SV> exit ( EXIT_SUCCESS ) ; //<S2SV> case 'k' : //<S2SV> lock_memory = true ; //<S2SV> break ; //<S2SV> case 'v' : //<S2SV> settings . verbose ++ ; //<S2SV> break ; //<S2SV> case 'l' : //<S2SV> if ( settings . inter != NULL ) { //<S2SV> if ( strstr ( settings . inter , optarg ) != NULL ) { //<S2SV> break ; //<S2SV> } //<S2SV> size_t len = strlen ( settings . inter ) + strlen ( optarg ) + 2 ; //<S2SV> char * p = malloc ( len ) ; //<S2SV> if ( p == NULL ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> snprintf ( p , len , "%s,%s" , settings . inter , optarg ) ; //<S2SV> free ( settings . inter ) ; //<S2SV> settings . inter = p ; //<S2SV> } else { //<S2SV> settings . inter = strdup ( optarg ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'd' : //<S2SV> do_daemonize = true ; //<S2SV> break ; //<S2SV> case 'r' : //<S2SV> maxcore = 1 ; //<S2SV> break ; //<S2SV> case 'R' : //<S2SV> settings . reqs_per_event = atoi ( optarg ) ; //<S2SV> if ( settings . reqs_per_event == 0 ) { //<S2SV> fprintf ( stderr , "Number<S2SV_blank>of<S2SV_blank>requests<S2SV_blank>per<S2SV_blank>event<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'u' : //<S2SV> username = optarg ; //<S2SV> break ; //<S2SV> case 'P' : //<S2SV> pid_file = optarg ; //<S2SV> break ; //<S2SV> case 'f' : //<S2SV> settings . factor = atof ( optarg ) ; //<S2SV> if ( settings . factor <= 1.0 ) { //<S2SV> fprintf ( stderr , "Factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>1\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'n' : //<S2SV> settings . chunk_size = atoi ( optarg ) ; //<S2SV> if ( settings . chunk_size == 0 ) { //<S2SV> fprintf ( stderr , "Chunk<S2SV_blank>size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case 't' : //<S2SV> settings . num_threads = atoi ( optarg ) ; //<S2SV> if ( settings . num_threads <= 0 ) { //<S2SV> fprintf ( stderr , "Number<S2SV_blank>of<S2SV_blank>threads<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( settings . num_threads > 64 ) { //<S2SV> fprintf ( stderr , "WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker" //<S2SV> "threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\n" //<S2SV> "<S2SV_blank>Set<S2SV_blank>this<S2SV_blank>value<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cores<S2SV_blank>in" //<S2SV> "<S2SV_blank>your<S2SV_blank>machine<S2SV_blank>or<S2SV_blank>less.\\n" ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'D' : //<S2SV> if ( ! optarg || ! optarg [ 0 ] ) { //<S2SV> fprintf ( stderr , "No<S2SV_blank>delimiter<S2SV_blank>specified\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . prefix_delimiter = optarg [ 0 ] ; //<S2SV> settings . detail_enabled = 1 ; //<S2SV> break ; //<S2SV> case 'L' : //<S2SV> if ( enable_large_pages ( ) == 0 ) { //<S2SV> preallocate = true ; //<S2SV> } else { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\n" //<S2SV> "(There<S2SV_blank>is<S2SV_blank>no<S2SV_blank>Linux<S2SV_blank>support<S2SV_blank>as<S2SV_blank>of<S2SV_blank>this<S2SV_blank>version)\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'C' : //<S2SV> settings . use_cas = false ; //<S2SV> break ; //<S2SV> case 'b' : //<S2SV> settings . backlog = atoi ( optarg ) ; //<S2SV> break ; //<S2SV> case 'B' : //<S2SV> protocol_specified = true ; //<S2SV> if ( strcmp ( optarg , "auto" ) == 0 ) { //<S2SV> settings . binding_protocol = negotiating_prot ; //<S2SV> } else if ( strcmp ( optarg , "binary" ) == 0 ) { //<S2SV> settings . binding_protocol = binary_prot ; //<S2SV> } else if ( strcmp ( optarg , "ascii" ) == 0 ) { //<S2SV> settings . binding_protocol = ascii_prot ; //<S2SV> } else { //<S2SV> fprintf ( stderr , "Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\n" //<S2SV> "<S2SV_blank>--<S2SV_blank>should<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>auto,<S2SV_blank>binary,<S2SV_blank>or<S2SV_blank>ascii\\n" , optarg ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'I' : //<S2SV> buf = strdup ( optarg ) ; //<S2SV> unit = buf [ strlen ( buf ) - 1 ] ; //<S2SV> if ( unit == 'k' || unit == 'm' || //<S2SV> unit == 'K' || unit == 'M' ) { //<S2SV> buf [ strlen ( buf ) - 1 ] = '\\0' ; //<S2SV> size_max = atoi ( buf ) ; //<S2SV> if ( unit == 'k' || unit == 'K' ) //<S2SV> size_max *= 1024 ; //<S2SV> if ( unit == 'm' || unit == 'M' ) //<S2SV> size_max *= 1024 * 1024 ; //<S2SV> settings . item_size_max = size_max ; //<S2SV> } else { //<S2SV> settings . item_size_max = atoi ( buf ) ; //<S2SV> } //<S2SV> free ( buf ) ; //<S2SV> break ; //<S2SV> case 'S' : //<S2SV> # ifndef ENABLE_SASL //<S2SV> fprintf ( stderr , "This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> # endif //<S2SV> settings . sasl = true ; //<S2SV> break ; //<S2SV> case 'F' : //<S2SV> settings . flush_enabled = false ; //<S2SV> break ; //<S2SV> case 'X' : //<S2SV> settings . dump_enabled = false ; //<S2SV> break ; //<S2SV> case 'o' : //<S2SV> subopts_orig = subopts = strdup ( optarg ) ; //<S2SV> while ( * subopts != '\\0' ) { //<S2SV> switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) { //<S2SV> case MAXCONNS_FAST : //<S2SV> settings . maxconns_fast = true ; //<S2SV> break ; //<S2SV> case HASHPOWER_INIT : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . hashpower_init = atoi ( subopts_value ) ; //<S2SV> if ( settings . hashpower_init < 12 ) { //<S2SV> fprintf ( stderr , "Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\n" , //<S2SV> settings . hashpower_init ) ; //<S2SV> return 1 ; //<S2SV> } else if ( settings . hashpower_init > 32 ) { //<S2SV> fprintf ( stderr , "Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\n" //<S2SV> "Choose<S2SV_blank>a<S2SV_blank>value<S2SV_blank>based<S2SV_blank>on<S2SV_blank>\\"STAT<S2SV_blank>hash_power_level\\"<S2SV_blank>from<S2SV_blank>a<S2SV_blank>running<S2SV_blank>instance\\n" , //<S2SV> settings . hashpower_init ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case NO_HASHEXPAND : //<S2SV> start_assoc_maint = false ; //<S2SV> break ; //<S2SV> case SLAB_REASSIGN : //<S2SV> settings . slab_reassign = true ; //<S2SV> break ; //<S2SV> case SLAB_AUTOMOVE : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> settings . slab_automove = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> settings . slab_automove = atoi ( subopts_value ) ; //<S2SV> if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) { //<S2SV> fprintf ( stderr , "slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case SLAB_AUTOMOVE_RATIO : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . slab_automove_ratio = atof ( subopts_value ) ; //<S2SV> if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) { //<S2SV> fprintf ( stderr , "slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case SLAB_AUTOMOVE_WINDOW : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . slab_automove_window = atoi ( subopts_value ) ; //<S2SV> if ( settings . slab_automove_window < 3 ) { //<S2SV> fprintf ( stderr , "slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case TAIL_REPAIR_TIME : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . tail_repair_time = atoi ( subopts_value ) ; //<S2SV> if ( settings . tail_repair_time < 10 ) { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case HASH_ALGORITHM : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } ; //<S2SV> if ( strcmp ( subopts_value , "jenkins" ) == 0 ) { //<S2SV> hash_type = JENKINS_HASH ; //<S2SV> } else if ( strcmp ( subopts_value , "murmur3" ) == 0 ) { //<S2SV> hash_type = MURMUR3_HASH ; //<S2SV> } else { //<S2SV> fprintf ( stderr , "Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case LRU_CRAWLER : //<S2SV> start_lru_crawler = true ; //<S2SV> break ; //<S2SV> case LRU_CRAWLER_SLEEP : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . lru_crawler_sleep = atoi ( subopts_value ) ; //<S2SV> if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) { //<S2SV> fprintf ( stderr , "LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case LRU_CRAWLER_TOCRAWL : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) { //<S2SV> fprintf ( stderr , "lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . lru_crawler_tocrawl = tocrawl ; //<S2SV> break ; //<S2SV> case LRU_MAINTAINER : //<S2SV> start_lru_maintainer = true ; //<S2SV> settings . lru_segmented = true ; //<S2SV> break ; //<S2SV> case HOT_LRU_PCT : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . hot_lru_pct = atoi ( subopts_value ) ; //<S2SV> if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) { //<S2SV> fprintf ( stderr , "hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case WARM_LRU_PCT : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . warm_lru_pct = atoi ( subopts_value ) ; //<S2SV> if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) { //<S2SV> fprintf ( stderr , "warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case HOT_MAX_FACTOR : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . hot_max_factor = atof ( subopts_value ) ; //<S2SV> if ( settings . hot_max_factor <= 0 ) { //<S2SV> fprintf ( stderr , "hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case WARM_MAX_FACTOR : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . warm_max_factor = atof ( subopts_value ) ; //<S2SV> if ( settings . warm_max_factor <= 0 ) { //<S2SV> fprintf ( stderr , "warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case TEMPORARY_TTL : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . temp_lru = true ; //<S2SV> settings . temporary_ttl = atoi ( subopts_value ) ; //<S2SV> break ; //<S2SV> case IDLE_TIMEOUT : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . idle_timeout = atoi ( subopts_value ) ; //<S2SV> break ; //<S2SV> case WATCHER_LOGBUF_SIZE : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . logger_watcher_buf_size *= 1024 ; //<S2SV> break ; //<S2SV> case WORKER_LOGBUF_SIZE : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> settings . logger_buf_size *= 1024 ; //<S2SV> case SLAB_SIZES : //<S2SV> slab_sizes_unparsed = subopts_value ; //<S2SV> break ; //<S2SV> case SLAB_CHUNK_MAX : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\n" ) ; //<S2SV> } //<S2SV> if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\n" ) ; //<S2SV> } //<S2SV> slab_chunk_size_changed = true ; //<S2SV> break ; //<S2SV> case TRACK_SIZES : //<S2SV> item_stats_sizes_init ( ) ; //<S2SV> break ; //<S2SV> case NO_INLINE_ASCII_RESP : //<S2SV> settings . inline_ascii_response = false ; //<S2SV> break ; //<S2SV> case INLINE_ASCII_RESP : //<S2SV> settings . inline_ascii_response = true ; //<S2SV> break ; //<S2SV> case NO_CHUNKED_ITEMS : //<S2SV> settings . slab_chunk_size_max = settings . slab_page_size ; //<S2SV> break ; //<S2SV> case NO_SLAB_REASSIGN : //<S2SV> settings . slab_reassign = false ; //<S2SV> break ; //<S2SV> case NO_SLAB_AUTOMOVE : //<S2SV> settings . slab_automove = 0 ; //<S2SV> break ; //<S2SV> case NO_MAXCONNS_FAST : //<S2SV> settings . maxconns_fast = false ; //<S2SV> break ; //<S2SV> case NO_LRU_CRAWLER : //<S2SV> settings . lru_crawler = false ; //<S2SV> start_lru_crawler = false ; //<S2SV> break ; //<S2SV> case NO_LRU_MAINTAINER : //<S2SV> start_lru_maintainer = false ; //<S2SV> settings . lru_segmented = false ; //<S2SV> break ; //<S2SV> # ifdef EXTSTORE //<S2SV> case EXT_PAGE_SIZE : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> ext_cf . page_size *= 1024 * 1024 ; //<S2SV> break ; //<S2SV> case EXT_PAGE_COUNT : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_WBUF_SIZE : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> ext_cf . wbuf_size *= 1024 * 1024 ; //<S2SV> settings . ext_wbuf_size = ext_cf . wbuf_size ; //<S2SV> break ; //<S2SV> case EXT_THREADS : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_IO_DEPTH : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_ITEM_SIZE : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_ITEM_AGE : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_LOW_TTL : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_RECACHE_RATE : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_COMPACT_UNDER : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_DROP_UNDER : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_MAX_FRAG : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case SLAB_AUTOMOVE_FREERATIO : //<S2SV> if ( subopts_value == NULL ) { //<S2SV> fprintf ( stderr , "Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) { //<S2SV> fprintf ( stderr , "could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> break ; //<S2SV> case EXT_DROP_UNREAD : //<S2SV> settings . ext_drop_unread = true ; //<S2SV> break ; //<S2SV> case EXT_PATH : //<S2SV> storage_file = strdup ( subopts_value ) ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case MODERN : //<S2SV> break ; //<S2SV> case NO_MODERN : //<S2SV> if ( ! slab_chunk_size_changed ) { //<S2SV> settings . slab_chunk_size_max = settings . slab_page_size ; //<S2SV> } //<S2SV> settings . slab_reassign = false ; //<S2SV> settings . slab_automove = 0 ; //<S2SV> settings . maxconns_fast = false ; //<S2SV> settings . inline_ascii_response = true ; //<S2SV> settings . lru_segmented = false ; //<S2SV> hash_type = JENKINS_HASH ; //<S2SV> start_lru_crawler = false ; //<S2SV> start_lru_maintainer = false ; //<S2SV> break ; //<S2SV> case NO_DROP_PRIVILEGES : //<S2SV> settings . drop_privileges = false ; //<S2SV> break ; //<S2SV> # ifdef MEMCACHED_DEBUG //<S2SV> case RELAXED_PRIVILEGES : //<S2SV> settings . relaxed_privileges = true ; //<S2SV> break ; //<S2SV> # endif //<S2SV> default : //<S2SV> printf ( "Illegal<S2SV_blank>suboption<S2SV_blank>\\"%s\\"\\n" , subopts_value ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> free ( subopts_orig ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> fprintf ( stderr , "Illegal<S2SV_blank>argument<S2SV_blank>\\"%c\\"\\n" , c ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( settings . item_size_max < 1024 ) { //<S2SV> fprintf ( stderr , "Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . item_size_max > 1024 * 1024 ) { //<S2SV> if ( ! slab_chunk_size_changed ) { //<S2SV> settings . slab_chunk_size_max = settings . slab_page_size / 2 ; //<S2SV> } //<S2SV> } //<S2SV> if ( settings . slab_chunk_size_max > settings . item_size_max ) { //<S2SV> fprintf ( stderr , "slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\n" , //<S2SV> settings . slab_chunk_size_max , settings . item_size_max ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) { //<S2SV> fprintf ( stderr , "-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\n" , //<S2SV> settings . item_size_max , settings . slab_chunk_size_max ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) { //<S2SV> fprintf ( stderr , "slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\n" , //<S2SV> settings . slab_chunk_size_max , settings . slab_page_size ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> # ifdef EXTSTORE //<S2SV> if ( storage_file ) { //<S2SV> if ( settings . item_size_max > ext_cf . wbuf_size ) { //<S2SV> fprintf ( stderr , "-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\n" , //<S2SV> settings . item_size_max , ext_cf . wbuf_size ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . inline_ascii_response ) { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . udpport ) { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( slab_sizes_unparsed != NULL ) { //<S2SV> if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) { //<S2SV> use_slab_sizes = true ; //<S2SV> } else { //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) { //<S2SV> fprintf ( stderr , "hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . temp_lru && ! start_lru_maintainer ) { //<S2SV> fprintf ( stderr , "temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( hash_init ( hash_type ) != 0 ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( settings . inter != NULL && strchr ( settings . inter , ',' ) ) { //<S2SV> settings . num_threads_per_udp = 1 ; //<S2SV> } else { //<S2SV> settings . num_threads_per_udp = settings . num_threads ; //<S2SV> } //<S2SV> if ( settings . sasl ) { //<S2SV> if ( ! protocol_specified ) { //<S2SV> settings . binding_protocol = binary_prot ; //<S2SV> } else { //<S2SV> if ( settings . binding_protocol != binary_prot ) { //<S2SV> fprintf ( stderr , "ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { //<S2SV> settings . port = settings . udpport ; //<S2SV> } //<S2SV> if ( maxcore != 0 ) { //<S2SV> struct rlimit rlim_new ; //<S2SV> if ( getrlimit ( RLIMIT_CORE , & rlim ) == 0 ) { //<S2SV> rlim_new . rlim_cur = rlim_new . rlim_max = RLIM_INFINITY ; //<S2SV> if ( setrlimit ( RLIMIT_CORE , & rlim_new ) != 0 ) { //<S2SV> rlim_new . rlim_cur = rlim_new . rlim_max = rlim . rlim_max ; //<S2SV> ( void ) setrlimit ( RLIMIT_CORE , & rlim_new ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( getrlimit ( RLIMIT_CORE , & rlim ) != 0 ) || rlim . rlim_cur == 0 ) { //<S2SV> fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>corefile<S2SV_blank>creation\\n" ) ; //<S2SV> exit ( EX_OSERR ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( getrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { //<S2SV> fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>getrlimit<S2SV_blank>number<S2SV_blank>of<S2SV_blank>files\\n" ) ; //<S2SV> exit ( EX_OSERR ) ; //<S2SV> } else { //<S2SV> rlim . rlim_cur = settings . maxconns ; //<S2SV> rlim . rlim_max = settings . maxconns ; //<S2SV> if ( setrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { //<S2SV> fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>rlimit<S2SV_blank>for<S2SV_blank>open<S2SV_blank>files.<S2SV_blank>Try<S2SV_blank>starting<S2SV_blank>as<S2SV_blank>root<S2SV_blank>or<S2SV_blank>requesting<S2SV_blank>smaller<S2SV_blank>maxconns<S2SV_blank>value.\\n" ) ; //<S2SV> exit ( EX_OSERR ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( getuid ( ) == 0 || geteuid ( ) == 0 ) { //<S2SV> if ( username == 0 || * username == '\\0' ) { //<S2SV> fprintf ( stderr , "can\'t<S2SV_blank>run<S2SV_blank>as<S2SV_blank>root<S2SV_blank>without<S2SV_blank>the<S2SV_blank>-u<S2SV_blank>switch\\n" ) ; //<S2SV> exit ( EX_USAGE ) ; //<S2SV> } //<S2SV> if ( ( pw = getpwnam ( username ) ) == 0 ) { //<S2SV> fprintf ( stderr , "can\'t<S2SV_blank>find<S2SV_blank>the<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to\\n" , username ) ; //<S2SV> exit ( EX_NOUSER ) ; //<S2SV> } //<S2SV> if ( setgid ( pw -> pw_gid ) < 0 || setuid ( pw -> pw_uid ) < 0 ) { //<S2SV> fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>assume<S2SV_blank>identity<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%s\\n" , username ) ; //<S2SV> exit ( EX_OSERR ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( settings . sasl ) { //<S2SV> init_sasl ( ) ; //<S2SV> } //<S2SV> if ( do_daemonize ) { //<S2SV> if ( sigignore ( SIGHUP ) == - 1 ) { //<S2SV> perror ( "Failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGHUP" ) ; //<S2SV> } //<S2SV> if ( daemonize ( maxcore , settings . verbose ) == - 1 ) { //<S2SV> fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>daemon()<S2SV_blank>in<S2SV_blank>order<S2SV_blank>to<S2SV_blank>daemonize\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( lock_memory ) { //<S2SV> # ifdef HAVE_MLOCKALL //<S2SV> int res = mlockall ( MCL_CURRENT | MCL_FUTURE ) ; //<S2SV> if ( res != 0 ) { //<S2SV> fprintf ( stderr , "warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>failed:<S2SV_blank>%s\\n" , //<S2SV> strerror ( errno ) ) ; //<S2SV> } //<S2SV> # else //<S2SV> fprintf ( stderr , "warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform.<S2SV_blank><S2SV_blank>proceeding<S2SV_blank>without.\\n" ) ; //<S2SV> # endif //<S2SV> } //<S2SV> # if defined ( LIBEVENT_VERSION_NUMBER ) && LIBEVENT_VERSION_NUMBER >= 0x02000101 //<S2SV> struct event_config * ev_config ; //<S2SV> ev_config = event_config_new ( ) ; //<S2SV> event_config_set_flag ( ev_config , EVENT_BASE_FLAG_NOLOCK ) ; //<S2SV> main_base = event_base_new_with_config ( ev_config ) ; //<S2SV> event_config_free ( ev_config ) ; //<S2SV> # else //<S2SV> main_base = event_init ( ) ; //<S2SV> # endif //<S2SV> logger_init ( ) ; //<S2SV> stats_init ( ) ; //<S2SV> assoc_init ( settings . hashpower_init ) ; //<S2SV> conn_init ( ) ; //<S2SV> slabs_init ( settings . maxbytes , settings . factor , preallocate , //<S2SV> use_slab_sizes ? slab_sizes : NULL ) ; //<S2SV> # ifdef EXTSTORE //<S2SV> if ( storage_file ) { //<S2SV> enum extstore_res eres ; //<S2SV> if ( settings . ext_compact_under == 0 ) { //<S2SV> settings . ext_compact_under = ext_cf . page_count / 4 ; //<S2SV> settings . ext_drop_under = ext_cf . page_count / 4 ; //<S2SV> } //<S2SV> crc32c_init ( ) ; //<S2SV> for ( int x = 0 ; x < MAX_NUMBER_OF_SLAB_CLASSES ; x ++ ) { //<S2SV> settings . ext_free_memchunks [ x ] = 0 ; //<S2SV> } //<S2SV> storage = extstore_init ( storage_file , & ext_cf , & eres ) ; //<S2SV> if ( storage == NULL ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>external<S2SV_blank>storage:<S2SV_blank>%s\\n" , //<S2SV> extstore_err ( eres ) ) ; //<S2SV> if ( eres == EXTSTORE_INIT_OPEN_FAIL ) { //<S2SV> perror ( "extstore<S2SV_blank>open" ) ; //<S2SV> } //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> ext_storage = storage ; //<S2SV> slabs_prefill_global ( ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( sigignore ( SIGPIPE ) == - 1 ) { //<S2SV> perror ( "failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGPIPE;<S2SV_blank>sigaction" ) ; //<S2SV> exit ( EX_OSERR ) ; //<S2SV> } //<S2SV> # ifdef EXTSTORE //<S2SV> slabs_set_storage ( storage ) ; //<S2SV> memcached_thread_init ( settings . num_threads , storage ) ; //<S2SV> init_lru_crawler ( storage ) ; //<S2SV> # else //<S2SV> memcached_thread_init ( settings . num_threads , NULL ) ; //<S2SV> init_lru_crawler ( NULL ) ; //<S2SV> # endif //<S2SV> if ( start_assoc_maint && start_assoc_maintenance_thread ( ) == - 1 ) { //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( start_lru_crawler && start_item_crawler_thread ( ) != 0 ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>crawler<S2SV_blank>thread\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> # ifdef EXTSTORE //<S2SV> if ( storage && start_storage_compact_thread ( storage ) != 0 ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>storage<S2SV_blank>compaction<S2SV_blank>thread\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( start_lru_maintainer && start_lru_maintainer_thread ( storage ) != 0 ) { //<S2SV> # else //<S2SV> if ( start_lru_maintainer && start_lru_maintainer_thread ( NULL ) != 0 ) { //<S2SV> # endif //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>maintainer<S2SV_blank>thread\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( settings . slab_reassign && //<S2SV> start_slab_maintenance_thread ( ) == - 1 ) { //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( settings . idle_timeout && start_conn_timeout_thread ( ) == - 1 ) { //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> clock_handler ( 0 , 0 , 0 ) ; //<S2SV> if ( settings . socketpath != NULL ) { //<S2SV> errno = 0 ; //<S2SV> if ( server_socket_unix ( settings . socketpath , settings . access ) ) { //<S2SV> vperror ( "failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UNIX<S2SV_blank>socket:<S2SV_blank>%s" , settings . socketpath ) ; //<S2SV> exit ( EX_OSERR ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( settings . socketpath == NULL ) { //<S2SV> const char * portnumber_filename = getenv ( "MEMCACHED_PORT_FILENAME" ) ; //<S2SV> char * temp_portnumber_filename = NULL ; //<S2SV> size_t len ; //<S2SV> FILE * portnumber_file = NULL ; //<S2SV> if ( portnumber_filename != NULL ) { //<S2SV> len = strlen ( portnumber_filename ) + 4 + 1 ; //<S2SV> temp_portnumber_filename = malloc ( len ) ; //<S2SV> snprintf ( temp_portnumber_filename , //<S2SV> len , //<S2SV> "%s.lck" , portnumber_filename ) ; //<S2SV> portnumber_file = fopen ( temp_portnumber_filename , "a" ) ; //<S2SV> if ( portnumber_file == NULL ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\\"%s\\":<S2SV_blank>%s\\n" , //<S2SV> temp_portnumber_filename , strerror ( errno ) ) ; //<S2SV> } //<S2SV> } //<S2SV> errno = 0 ; //<S2SV> if ( settings . port && server_sockets ( settings . port , tcp_transport , //<S2SV> portnumber_file ) ) { //<S2SV> vperror ( "failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>TCP<S2SV_blank>port<S2SV_blank>%d" , settings . port ) ; //<S2SV> exit ( EX_OSERR ) ; //<S2SV> } //<S2SV> errno = 0 ; //<S2SV> if ( settings . udpport && server_sockets ( settings . udpport , udp_transport , //<S2SV> portnumber_file ) ) { //<S2SV> vperror ( "failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UDP<S2SV_blank>port<S2SV_blank>%d" , settings . udpport ) ; //<S2SV> exit ( EX_OSERR ) ; //<S2SV> } //<S2SV> if ( portnumber_file ) { //<S2SV> fclose ( portnumber_file ) ; //<S2SV> rename ( temp_portnumber_filename , portnumber_filename ) ; //<S2SV> } //<S2SV> if ( temp_portnumber_filename ) //<S2SV> free ( temp_portnumber_filename ) ; //<S2SV> } //<S2SV> usleep ( 1000 ) ; //<S2SV> if ( stats_state . curr_conns + stats_state . reserved_fds >= settings . maxconns - 1 ) { //<S2SV> fprintf ( stderr , "Maxconns<S2SV_blank>setting<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low,<S2SV_blank>use<S2SV_blank>-c<S2SV_blank>to<S2SV_blank>increase.\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( pid_file != NULL ) { //<S2SV> save_pid ( pid_file ) ; //<S2SV> } //<S2SV> if ( settings . drop_privileges ) { //<S2SV> drop_privileges ( ) ; //<S2SV> } //<S2SV> uriencode_init ( ) ; //<S2SV> if ( event_base_loop ( main_base , 0 ) != 0 ) { //<S2SV> retval = EXIT_FAILURE ; //<S2SV> } //<S2SV> stop_assoc_maintenance_thread ( ) ; //<S2SV> if ( do_daemonize ) //<S2SV> remove_pidfile ( pid_file ) ; //<S2SV> if ( settings . inter ) //<S2SV> free ( settings . inter ) ; //<S2SV> if ( l_socket ) //<S2SV> free ( l_socket ) ; //<S2SV> if ( u_socket ) //<S2SV> free ( u_socket ) ; //<S2SV> event_base_free ( main_base ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 