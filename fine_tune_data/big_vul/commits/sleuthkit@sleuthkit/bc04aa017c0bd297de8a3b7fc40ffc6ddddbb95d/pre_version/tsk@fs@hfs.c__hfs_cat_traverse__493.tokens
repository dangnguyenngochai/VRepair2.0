uint8_t //<S2SV> hfs_cat_traverse ( HFS_INFO * hfs , //<S2SV> TSK_HFS_BTREE_CB a_cb , void * ptr ) //<S2SV> { //<S2SV> TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; //<S2SV> uint32_t cur_node ; //<S2SV> char * node ; //<S2SV> uint16_t nodesize ; //<S2SV> uint8_t is_done = 0 ; //<S2SV> tsk_error_reset ( ) ; //<S2SV> nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; //<S2SV> if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) //<S2SV> return 1 ; //<S2SV> cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; //<S2SV> if ( cur_node == 0 ) { //<S2SV> if ( tsk_verbose ) //<S2SV> tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>" //<S2SV> "empty<S2SV_blank>extents<S2SV_blank>btree\\n" ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( tsk_verbose ) //<S2SV> tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>" //<S2SV> "root<S2SV_blank>node<S2SV_blank>%" PRIu32 ";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%" //<S2SV> PRIu16 "\\n" , cur_node , nodesize ) ; //<S2SV> is_done = 0 ; //<S2SV> while ( is_done == 0 ) { //<S2SV> TSK_OFF_T cur_off ; //<S2SV> uint16_t num_rec ; //<S2SV> ssize_t cnt ; //<S2SV> hfs_btree_node * node_desc ; //<S2SV> if ( cur_node > tsk_getu32 ( fs -> endian , //<S2SV> hfs -> catalog_header . totalNodes ) ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file" , cur_node ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> cur_off = cur_node * nodesize ; //<S2SV> cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , //<S2SV> node , nodesize , 0 ) ; //<S2SV> if ( cnt != nodesize ) { //<S2SV> if ( cnt >= 0 ) { //<S2SV> tsk_error_reset ( ) ; //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_READ ) ; //<S2SV> } //<S2SV> tsk_error_set_errstr2 //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%" //<S2SV> PRIuOFF , cur_node , cur_off ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( nodesize < sizeof ( hfs_btree_node ) ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid" , nodesize ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> node_desc = ( hfs_btree_node * ) node ; //<S2SV> num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; //<S2SV> if ( tsk_verbose ) //<S2SV> tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%" PRIu32 //<S2SV> "<S2SV_blank>@<S2SV_blank>%" PRIu64 "<S2SV_blank>has<S2SV_blank>%" PRIu16 "<S2SV_blank>records\\n" , //<S2SV> cur_node , cur_off , num_rec ) ; //<S2SV> if ( num_rec == 0 ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%" //<S2SV> PRIu32 , cur_node ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { //<S2SV> uint32_t next_node = 0 ; //<S2SV> int rec ; //<S2SV> for ( rec = 0 ; rec < num_rec ; ++ rec ) { //<S2SV> size_t rec_off ; //<S2SV> hfs_btree_key_cat * key ; //<S2SV> uint8_t retval ; //<S2SV> int keylen ; //<S2SV> rec_off = //<S2SV> tsk_getu16 ( fs -> endian , //<S2SV> & node [ nodesize - ( rec + 1 ) * 2 ] ) ; //<S2SV> if ( rec_off > nodesize ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" //<S2SV> PRIu16 ")" , rec , cur_node , ( int ) rec_off , //<S2SV> nodesize ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; //<S2SV> keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; //<S2SV> if ( ( keylen ) > nodesize ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" //<S2SV> PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> retval = //<S2SV> a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , //<S2SV> cur_off + rec_off , ptr ) ; //<S2SV> if ( retval == HFS_BTREE_CB_ERR ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr2 //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> else if ( ( retval == HFS_BTREE_CB_IDX_LT ) //<S2SV> || ( next_node == 0 ) ) { //<S2SV> hfs_btree_index_record * idx_rec ; //<S2SV> int keylen = //<S2SV> 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , //<S2SV> key -> key_len ) , & ( hfs -> catalog_header ) ) ; //<S2SV> if ( rec_off + keylen > nodesize ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" //<S2SV> PRIu16 ")" , rec , cur_node , //<S2SV> ( int ) rec_off + keylen , nodesize ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> idx_rec = //<S2SV> ( hfs_btree_index_record * ) & node [ rec_off + //<S2SV> keylen ] ; //<S2SV> next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; //<S2SV> } //<S2SV> if ( retval == HFS_BTREE_CB_IDX_EQGT ) { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( next_node == 0 ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d" , //<S2SV> cur_node ) ; //<S2SV> is_done = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( next_node == cur_node ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node" , //<S2SV> cur_node ) ; //<S2SV> is_done = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> cur_node = next_node ; //<S2SV> } //<S2SV> else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { //<S2SV> int rec ; //<S2SV> for ( rec = 0 ; rec < num_rec ; ++ rec ) { //<S2SV> size_t rec_off ; //<S2SV> hfs_btree_key_cat * key ; //<S2SV> uint8_t retval ; //<S2SV> int keylen ; //<S2SV> rec_off = //<S2SV> tsk_getu16 ( fs -> endian , //<S2SV> & node [ nodesize - ( rec + 1 ) * 2 ] ) ; //<S2SV> if ( rec_off > nodesize ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" //<S2SV> PRIu16 ")" , rec , cur_node , ( int ) rec_off , //<S2SV> nodesize ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; //<S2SV> keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; //<S2SV> if ( ( keylen ) > nodesize ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" //<S2SV> PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> retval = //<S2SV> a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , //<S2SV> cur_off + rec_off , ptr ) ; //<S2SV> if ( retval == HFS_BTREE_CB_LEAF_STOP ) { //<S2SV> is_done = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> else if ( retval == HFS_BTREE_CB_ERR ) { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr2 //<S2SV> ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( is_done == 0 ) { //<S2SV> cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; //<S2SV> if ( cur_node == 0 ) { //<S2SV> is_done = 1 ; //<S2SV> } //<S2SV> if ( tsk_verbose ) //<S2SV> tsk_fprintf ( stderr , //<S2SV> "hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf" ) ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; //<S2SV> tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%" PRIu32 //<S2SV> "<S2SV_blank>(%" PRIu64 ")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%" PRIu8 ")" , //<S2SV> cur_node , cur_off , node_desc -> type ) ; //<S2SV> free ( node ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> free ( node ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 