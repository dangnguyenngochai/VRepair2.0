int main ( int argc , char * * argv ) { //<S2SV> if ( ! parse_args ( argc , argv ) ) { //<S2SV> usage ( argv [ 0 ] ) ; //<S2SV> } //<S2SV> if ( bond && discoverable ) { //<S2SV> fprintf ( stderr , "Can<S2SV_blank>only<S2SV_blank>select<S2SV_blank>either<S2SV_blank>bond<S2SV_blank>or<S2SV_blank>discoverable,<S2SV_blank>not<S2SV_blank>both\\n" ) ; //<S2SV> usage ( argv [ 0 ] ) ; //<S2SV> } //<S2SV> if ( sco_listen && sco_connect ) { //<S2SV> fprintf ( stderr , "Can<S2SV_blank>only<S2SV_blank>select<S2SV_blank>either<S2SV_blank>sco_listen<S2SV_blank>or<S2SV_blank>sco_connect,<S2SV_blank>not<S2SV_blank>both\\n" ) ; //<S2SV> usage ( argv [ 0 ] ) ; //<S2SV> } //<S2SV> if ( ! bond && ! discover && ! discoverable && ! up && ! get_name && ! set_name && ! sco_listen && ! sco_connect ) { //<S2SV> fprintf ( stderr , "Must<S2SV_blank>specify<S2SV_blank>one<S2SV_blank>command\\n" ) ; //<S2SV> usage ( argv [ 0 ] ) ; //<S2SV> } //<S2SV> if ( signal ( SIGINT , sig_handler ) == SIG_ERR ) { //<S2SV> fprintf ( stderr , "Will<S2SV_blank>be<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>catch<S2SV_blank>signals\\n" ) ; //<S2SV> } //<S2SV> fprintf ( stdout , "Bringing<S2SV_blank>up<S2SV_blank>bluetooth<S2SV_blank>adapter\\n" ) ; //<S2SV> if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Bluetooth<S2SV_blank>HAL.\\n" ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( discover ) { //<S2SV> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> fprintf ( stdout , "Starting<S2SV_blank>to<S2SV_blank>start<S2SV_blank>discovery\\n" ) ; //<S2SV> CALL_AND_WAIT ( bt_interface -> start_discovery ( ) , discovery_state_changed ) ; //<S2SV> fprintf ( stdout , "Started<S2SV_blank>discovery<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>seconds\\n" , timeout_in_sec ) ; //<S2SV> sleep ( timeout_in_sec ) ; //<S2SV> fprintf ( stdout , "Starting<S2SV_blank>to<S2SV_blank>cancel<S2SV_blank>discovery\\n" ) ; //<S2SV> CALL_AND_WAIT ( bt_interface -> cancel_discovery ( ) , discovery_state_changed ) ; //<S2SV> fprintf ( stdout , "Cancelled<S2SV_blank>discovery<S2SV_blank>after<S2SV_blank>%d<S2SV_blank>seconds\\n" , timeout_in_sec ) ; //<S2SV> } //<S2SV> if ( discoverable ) { //<S2SV> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> bt_property_t * property = property_new_scan_mode ( BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE ) ; //<S2SV> int rc = bt_interface -> set_adapter_property ( property ) ; //<S2SV> fprintf ( stdout , "Set<S2SV_blank>rc:%d<S2SV_blank>device<S2SV_blank>as<S2SV_blank>discoverable<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>seconds\\n" , rc , timeout_in_sec ) ; //<S2SV> sleep ( timeout_in_sec ) ; //<S2SV> property_free ( property ) ; //<S2SV> } //<S2SV> if ( bond ) { //<S2SV> if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { //<S2SV> fprintf ( stderr , "Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device<S2SV_blank>address<S2SV_blank>[<S2SV_blank>--bdaddr=xx:yy:zz:aa:bb:cc<S2SV_blank>]\\n" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> int rc = bt_interface -> create_bond ( & bt_remote_bdaddr , 0 ) ; //<S2SV> fprintf ( stdout , "Started<S2SV_blank>bonding:%d<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>seconds\\n" , rc , timeout_in_sec ) ; //<S2SV> sleep ( timeout_in_sec ) ; //<S2SV> } //<S2SV> if ( up ) { //<S2SV> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> fprintf ( stdout , "Waiting<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>seconds\\n" , timeout_in_sec ) ; //<S2SV> sleep ( timeout_in_sec ) ; //<S2SV> } //<S2SV> if ( get_name ) { //<S2SV> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> int error ; //<S2SV> CALL_AND_WAIT ( error = bt_interface -> get_adapter_property ( BT_PROPERTY_BDNAME ) , adapter_properties ) ; //<S2SV> if ( error != BT_STATUS_SUCCESS ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>adapter<S2SV_blank>property\\n" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> bt_property_t * property = adapter_get_property ( BT_PROPERTY_BDNAME ) ; //<S2SV> const bt_bdname_t * name = property_as_name ( property ) ; //<S2SV> if ( name ) //<S2SV> printf ( "Queried<S2SV_blank>bluetooth<S2SV_blank>device<S2SV_blank>name:%s\\n" , name -> name ) ; //<S2SV> else //<S2SV> printf ( "No<S2SV_blank>name\\n" ) ; //<S2SV> } //<S2SV> if ( set_name ) { //<S2SV> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> bt_property_t * property = property_new_name ( bd_name ) ; //<S2SV> printf ( "Setting<S2SV_blank>bluetooth<S2SV_blank>device<S2SV_blank>name<S2SV_blank>to:%s\\n" , bd_name ) ; //<S2SV> int error ; //<S2SV> CALL_AND_WAIT ( error = bt_interface -> set_adapter_property ( property ) , adapter_properties ) ; //<S2SV> if ( error != BT_STATUS_SUCCESS ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>adapter<S2SV_blank>property\\n" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> CALL_AND_WAIT ( error = bt_interface -> get_adapter_property ( BT_PROPERTY_BDNAME ) , adapter_properties ) ; //<S2SV> if ( error != BT_STATUS_SUCCESS ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>adapter<S2SV_blank>property\\n" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> property_free ( property ) ; //<S2SV> sleep ( timeout_in_sec ) ; //<S2SV> } //<S2SV> if ( sco_listen ) { //<S2SV> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> bt_property_t * property = property_new_scan_mode ( BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE ) ; //<S2SV> CALL_AND_WAIT ( bt_interface -> set_adapter_property ( property ) , adapter_properties ) ; //<S2SV> property_free ( property ) ; //<S2SV> const btsock_interface_t * sock = bt_interface -> get_profile_interface ( BT_PROFILE_SOCKETS_ID ) ; //<S2SV> int rfcomm_fd = INVALID_FD ; //<S2SV> int error = sock -> listen ( BTSOCK_RFCOMM , "meow" , ( const uint8_t * ) & HFP_AG_UUID , 0 , & rfcomm_fd , 0 ) ; //<S2SV> if ( error != BT_STATUS_SUCCESS ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>for<S2SV_blank>incoming<S2SV_blank>RFCOMM<S2SV_blank>socket:<S2SV_blank>%d\\n" , error ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> int sock_fd = INVALID_FD ; //<S2SV> error = sock -> listen ( BTSOCK_SCO , NULL , NULL , 5 , & sock_fd , 0 ) ; //<S2SV> if ( error != BT_STATUS_SUCCESS ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>for<S2SV_blank>incoming<S2SV_blank>SCO<S2SV_blank>sockets:<S2SV_blank>%d\\n" , error ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> fprintf ( stdout , "Waiting<S2SV_blank>for<S2SV_blank>incoming<S2SV_blank>SCO<S2SV_blank>connections...\\n" ) ; //<S2SV> sleep ( timeout_in_sec ) ; //<S2SV> } //<S2SV> if ( sco_connect ) { //<S2SV> if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { //<S2SV> fprintf ( stderr , "Must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device<S2SV_blank>address<S2SV_blank>[<S2SV_blank>--bdaddr=xx:yy:zz:aa:bb:cc<S2SV_blank>]\\n" ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>up\\n" ) ; //<S2SV> const btsock_interface_t * sock = bt_interface -> get_profile_interface ( BT_PROFILE_SOCKETS_ID ) ; //<S2SV> int rfcomm_fd = INVALID_FD ; //<S2SV> int error = sock -> connect ( & bt_remote_bdaddr , BTSOCK_RFCOMM , ( const uint8_t * ) & HFP_AG_UUID , 0 , & rfcomm_fd , 0 ) ; //<S2SV> if ( error != BT_STATUS_SUCCESS ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>RFCOMM<S2SV_blank>socket:<S2SV_blank>%d.\\n" , error ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> WAIT ( acl_state_changed ) ; //<S2SV> fprintf ( stdout , "Establishing<S2SV_blank>SCO<S2SV_blank>connection...\\n" ) ; //<S2SV> int sock_fd = INVALID_FD ; //<S2SV> error = sock -> connect ( & bt_remote_bdaddr , BTSOCK_SCO , NULL , 5 , & sock_fd , 0 ) ; //<S2SV> if ( error != BT_STATUS_SUCCESS ) { //<S2SV> fprintf ( stderr , "Unable<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>SCO<S2SV_blank>socket:<S2SV_blank>%d.\\n" , error ) ; //<S2SV> exit ( 1 ) ; //<S2SV> } //<S2SV> sleep ( timeout_in_sec ) ; //<S2SV> } //<S2SV> CALL_AND_WAIT ( bt_interface -> disable ( ) , adapter_state_changed ) ; //<S2SV> fprintf ( stdout , "BT<S2SV_blank>adapter<S2SV_blank>is<S2SV_blank>down\\n" ) ; //<S2SV> } //<S2SV> 