static reactor_status_t run_reactor ( reactor_t * reactor , int iterations ) { //<S2SV> assert ( reactor != NULL ) ; //<S2SV> reactor -> run_thread = pthread_self ( ) ; //<S2SV> reactor -> is_running = true ; //<S2SV> struct epoll_event events [ MAX_EVENTS ] ; //<S2SV> for ( int i = 0 ; iterations == 0 || i < iterations ; ++ i ) { //<S2SV> pthread_mutex_lock ( & reactor -> list_lock ) ; //<S2SV> list_clear ( reactor -> invalidation_list ) ; //<S2SV> pthread_mutex_unlock ( & reactor -> list_lock ) ; //<S2SV> int ret ; //<S2SV> do { //<S2SV> ret = TEMP_FAILURE_RETRY ( epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ) ; //<S2SV> } while ( ret == - 1 && errno == EINTR ) ; //<S2SV> if ( ret == - 1 ) { //<S2SV> LOG_ERROR ( "%s<S2SV_blank>error<S2SV_blank>in<S2SV_blank>epoll_wait:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; //<S2SV> reactor -> is_running = false ; //<S2SV> return REACTOR_STATUS_ERROR ; //<S2SV> } //<S2SV> for ( int j = 0 ; j < ret ; ++ j ) { //<S2SV> if ( events [ j ] . data . ptr == NULL ) { //<S2SV> eventfd_t value ; //<S2SV> eventfd_read ( reactor -> event_fd , & value ) ; //<S2SV> reactor -> is_running = false ; //<S2SV> return REACTOR_STATUS_STOP ; //<S2SV> } //<S2SV> reactor_object_t * object = ( reactor_object_t * ) events [ j ] . data . ptr ; //<S2SV> pthread_mutex_lock ( & reactor -> list_lock ) ; //<S2SV> if ( list_contains ( reactor -> invalidation_list , object ) ) { //<S2SV> pthread_mutex_unlock ( & reactor -> list_lock ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> pthread_mutex_lock ( & object -> lock ) ; //<S2SV> pthread_mutex_unlock ( & reactor -> list_lock ) ; //<S2SV> reactor -> object_removed = false ; //<S2SV> if ( events [ j ] . events & ( EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR ) && object -> read_ready ) //<S2SV> object -> read_ready ( object -> context ) ; //<S2SV> if ( ! reactor -> object_removed && events [ j ] . events & EPOLLOUT && object -> write_ready ) //<S2SV> object -> write_ready ( object -> context ) ; //<S2SV> pthread_mutex_unlock ( & object -> lock ) ; //<S2SV> if ( reactor -> object_removed ) { //<S2SV> pthread_mutex_destroy ( & object -> lock ) ; //<S2SV> osi_free ( object ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> reactor -> is_running = false ; //<S2SV> return REACTOR_STATUS_DONE ; //<S2SV> } //<S2SV> 