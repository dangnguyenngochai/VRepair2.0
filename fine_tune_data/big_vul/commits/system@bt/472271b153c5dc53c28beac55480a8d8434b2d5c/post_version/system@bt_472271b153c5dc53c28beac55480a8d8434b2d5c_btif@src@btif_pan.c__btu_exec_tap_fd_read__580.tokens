static void btu_exec_tap_fd_read ( void * p_param ) { //<S2SV> struct pollfd ufd ; //<S2SV> int fd = ( int ) p_param ; //<S2SV> if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) //<S2SV> return ; //<S2SV> for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { //<S2SV> BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; //<S2SV> if ( ! buffer ) { //<S2SV> BTIF_TRACE_WARNING ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>packet." , __func__ ) ; //<S2SV> break ; //<S2SV> } //<S2SV> buffer -> offset = PAN_MINIMUM_OFFSET ; //<S2SV> buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; //<S2SV> UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; //<S2SV> if ( ! btpan_cb . congest_packet_size ) { //<S2SV> ssize_t ret = TEMP_FAILURE_RETRY ( read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ) ; //<S2SV> switch ( ret ) { //<S2SV> case - 1 : //<S2SV> BTIF_TRACE_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>from<S2SV_blank>driver:<S2SV_blank>%s" , __func__ , strerror ( errno ) ) ; //<S2SV> GKI_freebuf ( buffer ) ; //<S2SV> btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; //<S2SV> return ; //<S2SV> case 0 : //<S2SV> BTIF_TRACE_WARNING ( "%s<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>reached." , __func__ ) ; //<S2SV> GKI_freebuf ( buffer ) ; //<S2SV> btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; //<S2SV> return ; //<S2SV> default : //<S2SV> btpan_cb . congest_packet_size = ret ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> memcpy ( packet , btpan_cb . congest_packet , MIN ( btpan_cb . congest_packet_size , buffer -> len ) ) ; //<S2SV> buffer -> len = MIN ( btpan_cb . congest_packet_size , buffer -> len ) ; //<S2SV> if ( buffer -> len > sizeof ( tETH_HDR ) && should_forward ( ( tETH_HDR * ) packet ) ) { //<S2SV> tETH_HDR hdr ; //<S2SV> memcpy ( & hdr , packet , sizeof ( tETH_HDR ) ) ; //<S2SV> buffer -> len -= sizeof ( tETH_HDR ) ; //<S2SV> buffer -> offset += sizeof ( tETH_HDR ) ; //<S2SV> if ( forward_bnep ( & hdr , buffer ) != FORWARD_CONGEST ) //<S2SV> btpan_cb . congest_packet_size = 0 ; //<S2SV> } else { //<S2SV> BTIF_TRACE_WARNING ( "%s<S2SV_blank>dropping<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d" , __func__ , buffer -> len ) ; //<S2SV> btpan_cb . congest_packet_size = 0 ; //<S2SV> GKI_freebuf ( buffer ) ; //<S2SV> } //<S2SV> ufd . fd = fd ; //<S2SV> ufd . events = POLLIN ; //<S2SV> ufd . revents = 0 ; //<S2SV> if ( TEMP_FAILURE_RETRY ( poll ( & ufd , 1 , 0 ) ) <= 0 || IS_EXCEPTION ( ufd . revents ) ) //<S2SV> break ; //<S2SV> } //<S2SV> btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; //<S2SV> } //<S2SV> 