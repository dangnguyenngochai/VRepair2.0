ssize_t socket_write_and_transfer_fd ( const socket_t * socket , const void * buf , size_t count , int fd ) { //<S2SV> assert ( socket != NULL ) ; //<S2SV> assert ( buf != NULL ) ; //<S2SV> if ( fd == INVALID_FD ) //<S2SV> return socket_write ( socket , buf , count ) ; //<S2SV> struct msghdr msg ; //<S2SV> struct iovec iov ; //<S2SV> char control_buf [ CMSG_SPACE ( sizeof ( int ) ) ] ; //<S2SV> iov . iov_base = ( void * ) buf ; //<S2SV> iov . iov_len = count ; //<S2SV> msg . msg_iov = & iov ; //<S2SV> msg . msg_iovlen = 1 ; //<S2SV> msg . msg_control = control_buf ; //<S2SV> msg . msg_controllen = sizeof ( control_buf ) ; //<S2SV> msg . msg_name = NULL ; //<S2SV> msg . msg_namelen = 0 ; //<S2SV> struct cmsghdr * header = CMSG_FIRSTHDR ( & msg ) ; //<S2SV> header -> cmsg_level = SOL_SOCKET ; //<S2SV> header -> cmsg_type = SCM_RIGHTS ; //<S2SV> header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; //<S2SV> * ( int * ) CMSG_DATA ( header ) = fd ; //<S2SV> ssize_t ret = TEMP_FAILURE_RETRY ( sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ) ; //<S2SV> close ( fd ) ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 