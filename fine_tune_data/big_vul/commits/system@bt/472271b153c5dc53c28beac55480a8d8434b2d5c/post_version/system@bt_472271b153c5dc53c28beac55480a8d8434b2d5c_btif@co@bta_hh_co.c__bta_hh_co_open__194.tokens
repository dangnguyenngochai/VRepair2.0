void bta_hh_co_open ( UINT8 dev_handle , UINT8 sub_class , tBTA_HH_ATTR_MASK attr_mask , //<S2SV> UINT8 app_id ) //<S2SV> { //<S2SV> UINT32 i ; //<S2SV> btif_hh_device_t * p_dev = NULL ; //<S2SV> if ( dev_handle == BTA_HH_INVALID_HANDLE ) { //<S2SV> APPL_TRACE_WARNING ( "%s:<S2SV_blank>Oops,<S2SV_blank>dev_handle<S2SV_blank>(%d)<S2SV_blank>is<S2SV_blank>invalid..." , //<S2SV> __FUNCTION__ , dev_handle ) ; //<S2SV> return ; //<S2SV> } //<S2SV> for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { //<S2SV> p_dev = & btif_hh_cb . devices [ i ] ; //<S2SV> if ( p_dev -> dev_status != BTHH_CONN_STATE_UNKNOWN && //<S2SV> p_dev -> dev_handle == dev_handle ) { //<S2SV> APPL_TRACE_WARNING ( "%s:<S2SV_blank>Found<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>device<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>handle<S2SV_blank>" //<S2SV> "dev_status<S2SV_blank>=<S2SV_blank>%d" , __FUNCTION__ , //<S2SV> p_dev -> dev_status ) ; //<S2SV> APPL_TRACE_WARNING ( "%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>bd_addr<S2SV_blank>=<S2SV_blank>[%02X:%02X:%02X:%02X:%02X:]" , __FUNCTION__ , //<S2SV> p_dev -> bd_addr . address [ 0 ] , p_dev -> bd_addr . address [ 1 ] , p_dev -> bd_addr . address [ 2 ] , //<S2SV> p_dev -> bd_addr . address [ 3 ] , p_dev -> bd_addr . address [ 4 ] ) ; //<S2SV> APPL_TRACE_WARNING ( "%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>attr_mask<S2SV_blank>=<S2SV_blank>0x%04x,<S2SV_blank>sub_class<S2SV_blank>=<S2SV_blank>0x%02x,<S2SV_blank>app_id<S2SV_blank>=<S2SV_blank>%d" , //<S2SV> __FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; //<S2SV> if ( p_dev -> fd < 0 ) { //<S2SV> p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ; //<S2SV> if ( p_dev -> fd < 0 ) { //<S2SV> APPL_TRACE_ERROR ( "%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s" , //<S2SV> __FUNCTION__ , strerror ( errno ) ) ; //<S2SV> return ; //<S2SV> } else //<S2SV> APPL_TRACE_DEBUG ( "%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d" , __FUNCTION__ , p_dev -> fd ) ; //<S2SV> } //<S2SV> p_dev -> hh_keep_polling = 1 ; //<S2SV> p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; //<S2SV> break ; //<S2SV> } //<S2SV> p_dev = NULL ; //<S2SV> } //<S2SV> if ( p_dev == NULL ) { //<S2SV> for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { //<S2SV> if ( btif_hh_cb . devices [ i ] . dev_status == BTHH_CONN_STATE_UNKNOWN ) { //<S2SV> p_dev = & btif_hh_cb . devices [ i ] ; //<S2SV> p_dev -> dev_handle = dev_handle ; //<S2SV> p_dev -> attr_mask = attr_mask ; //<S2SV> p_dev -> sub_class = sub_class ; //<S2SV> p_dev -> app_id = app_id ; //<S2SV> p_dev -> local_vup = FALSE ; //<S2SV> btif_hh_cb . device_num ++ ; //<S2SV> p_dev -> fd = TEMP_FAILURE_RETRY ( open ( dev_path , O_RDWR | O_CLOEXEC ) ) ; //<S2SV> if ( p_dev -> fd < 0 ) { //<S2SV> APPL_TRACE_ERROR ( "%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s" , //<S2SV> __FUNCTION__ , strerror ( errno ) ) ; //<S2SV> return ; //<S2SV> } else { //<S2SV> APPL_TRACE_DEBUG ( "%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d" , __FUNCTION__ , p_dev -> fd ) ; //<S2SV> p_dev -> hh_keep_polling = 1 ; //<S2SV> p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( p_dev == NULL ) { //<S2SV> APPL_TRACE_ERROR ( "%s:<S2SV_blank>Error:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>HID<S2SV_blank>devices<S2SV_blank>are<S2SV_blank>connected" , __FUNCTION__ ) ; //<S2SV> return ; //<S2SV> } //<S2SV> p_dev -> dev_status = BTHH_CONN_STATE_CONNECTED ; //<S2SV> APPL_TRACE_DEBUG ( "%s:<S2SV_blank>Return<S2SV_blank>device<S2SV_blank>status<S2SV_blank>%d" , __FUNCTION__ , p_dev -> dev_status ) ; //<S2SV> } //<S2SV> 