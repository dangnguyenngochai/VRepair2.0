void btsock_l2cap_signaled ( int fd , int flags , uint32_t user_id ) //<S2SV> { //<S2SV> l2cap_socket * sock ; //<S2SV> char drop_it = FALSE ; //<S2SV> pthread_mutex_lock ( & state_lock ) ; //<S2SV> sock = btsock_l2cap_find_by_id_l ( user_id ) ; //<S2SV> if ( sock ) { //<S2SV> if ( ( flags & SOCK_THREAD_FD_RD ) && ! sock -> server ) { //<S2SV> if ( sock -> connected ) { //<S2SV> int size = 0 ; //<S2SV> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( TEMP_FAILURE_RETRY ( ioctl ( sock -> our_fd , FIONREAD , & size ) ) //<S2SV> == 0 && size ) ) { //<S2SV> uint8_t * buffer = osi_malloc ( L2CAP_MAX_SDU_LENGTH ) ; //<S2SV> if ( buffer != NULL ) { //<S2SV> int count = TEMP_FAILURE_RETRY ( recv ( fd , buffer , L2CAP_MAX_SDU_LENGTH , //<S2SV> MSG_NOSIGNAL | MSG_DONTWAIT ) ) ; //<S2SV> APPL_TRACE_DEBUG ( "btsock_l2cap_signaled<S2SV_blank>-<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>received<S2SV_blank>from<S2SV_blank>socket" , //<S2SV> count ) ; //<S2SV> if ( sock -> fixed_chan ) { //<S2SV> if ( BTA_JvL2capWriteFixed ( sock -> channel , ( BD_ADDR * ) & sock -> addr , //<S2SV> ( UINT32 ) buffer , btsock_l2cap_cbk , buffer , count , //<S2SV> ( void * ) user_id ) != BTA_JV_SUCCESS ) { //<S2SV> on_l2cap_write_fixed_done ( buffer , user_id ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( BTA_JvL2capWrite ( sock -> handle , ( UINT32 ) buffer , buffer , count , //<S2SV> ( void * ) user_id ) != BTA_JV_SUCCESS ) { //<S2SV> on_l2cap_write_done ( buffer , user_id ) ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> APPL_TRACE_ERROR ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>data<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>JAVA..." ) //<S2SV> } //<S2SV> } //<S2SV> } else //<S2SV> drop_it = TRUE ; //<S2SV> } //<S2SV> if ( flags & SOCK_THREAD_FD_WR ) { //<S2SV> if ( flush_incoming_que_on_wr_signal_l ( sock ) && sock -> connected ) //<S2SV> btsock_thread_add_fd ( pth , sock -> our_fd , BTSOCK_L2CAP , SOCK_THREAD_FD_WR , sock -> id ) ; //<S2SV> } //<S2SV> if ( drop_it || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { //<S2SV> int size = 0 ; //<S2SV> if ( drop_it || TEMP_FAILURE_RETRY ( ioctl ( sock -> our_fd , FIONREAD , & size ) ) != 0 || size == 0 ) //<S2SV> btsock_l2cap_free_l ( sock ) ; //<S2SV> } //<S2SV> } //<S2SV> pthread_mutex_unlock ( & state_lock ) ; //<S2SV> } //<S2SV> 