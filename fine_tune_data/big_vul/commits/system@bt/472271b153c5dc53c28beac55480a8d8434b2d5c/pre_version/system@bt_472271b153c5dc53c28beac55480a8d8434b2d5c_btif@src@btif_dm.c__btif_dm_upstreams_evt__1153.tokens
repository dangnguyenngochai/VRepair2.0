static void btif_dm_upstreams_evt ( UINT16 event , char * p_param ) //<S2SV> { //<S2SV> tBTA_DM_SEC * p_data = ( tBTA_DM_SEC * ) p_param ; //<S2SV> tBTA_SERVICE_MASK service_mask ; //<S2SV> uint32_t i ; //<S2SV> bt_bdaddr_t bd_addr ; //<S2SV> BTIF_TRACE_EVENT ( "btif_dm_upstreams_cback<S2SV_blank><S2SV_blank>ev:<S2SV_blank>%s" , dump_dm_event ( event ) ) ; //<S2SV> switch ( event ) //<S2SV> { //<S2SV> case BTA_DM_ENABLE_EVT : //<S2SV> { //<S2SV> BD_NAME bdname ; //<S2SV> bt_status_t status ; //<S2SV> bt_property_t prop ; //<S2SV> prop . type = BT_PROPERTY_BDNAME ; //<S2SV> prop . len = BD_NAME_LEN ; //<S2SV> prop . val = ( void * ) bdname ; //<S2SV> status = btif_storage_get_adapter_property ( & prop ) ; //<S2SV> if ( status == BT_STATUS_SUCCESS ) //<S2SV> { //<S2SV> BTA_DmSetDeviceName ( ( char * ) prop . val ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> BTA_DmSetDeviceName ( btif_get_default_local_name ( ) ) ; //<S2SV> } //<S2SV> # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) //<S2SV> BTA_DmBleConfigLocalPrivacy ( BLE_LOCAL_PRIVACY_ENABLED ) ; //<S2SV> # endif //<S2SV> service_mask = btif_get_enabled_services_mask ( ) ; //<S2SV> for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) //<S2SV> { //<S2SV> if ( service_mask & //<S2SV> ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) //<S2SV> { //<S2SV> btif_in_execute_service_request ( i , TRUE ) ; //<S2SV> } //<S2SV> } //<S2SV> memset ( & pairing_cb , 0 , sizeof ( btif_dm_pairing_cb_t ) ) ; //<S2SV> pairing_cb . bond_type = BOND_TYPE_PERSISTENT ; //<S2SV> btif_storage_load_bonded_devices ( ) ; //<S2SV> btif_storage_load_autopair_device_list ( ) ; //<S2SV> btif_enable_bluetooth_evt ( p_data -> enable . status ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case BTA_DM_DISABLE_EVT : //<S2SV> service_mask = btif_get_enabled_services_mask ( ) ; //<S2SV> for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) //<S2SV> { //<S2SV> if ( service_mask & //<S2SV> ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) //<S2SV> { //<S2SV> btif_in_execute_service_request ( i , FALSE ) ; //<S2SV> } //<S2SV> } //<S2SV> btif_disable_bluetooth_evt ( ) ; //<S2SV> break ; //<S2SV> case BTA_DM_PIN_REQ_EVT : //<S2SV> btif_dm_pin_req_evt ( & p_data -> pin_req ) ; //<S2SV> break ; //<S2SV> case BTA_DM_AUTH_CMPL_EVT : //<S2SV> btif_dm_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BOND_CANCEL_CMPL_EVT : //<S2SV> if ( pairing_cb . state == BT_BOND_STATE_BONDING ) //<S2SV> { //<S2SV> bdcpy ( bd_addr . address , pairing_cb . bd_addr ) ; //<S2SV> btm_set_bond_type_dev ( pairing_cb . bd_addr , BOND_TYPE_UNKNOWN ) ; //<S2SV> bond_state_changed ( p_data -> bond_cancel_cmpl . result , & bd_addr , BT_BOND_STATE_NONE ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case BTA_DM_SP_CFM_REQ_EVT : //<S2SV> btif_dm_ssp_cfm_req_evt ( & p_data -> cfm_req ) ; //<S2SV> break ; //<S2SV> case BTA_DM_SP_KEY_NOTIF_EVT : //<S2SV> btif_dm_ssp_key_notif_evt ( & p_data -> key_notif ) ; //<S2SV> break ; //<S2SV> case BTA_DM_DEV_UNPAIRED_EVT : //<S2SV> bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; //<S2SV> btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; //<S2SV> # if ( defined ( BTA_HH_INCLUDED ) && ( BTA_HH_INCLUDED == TRUE ) ) //<S2SV> btif_hh_remove_device ( bd_addr ) ; //<S2SV> # endif //<S2SV> btif_storage_remove_bonded_device ( & bd_addr ) ; //<S2SV> bond_state_changed ( BT_STATUS_SUCCESS , & bd_addr , BT_BOND_STATE_NONE ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BUSY_LEVEL_EVT : //<S2SV> { //<S2SV> if ( p_data -> busy_level . level_flags & BTM_BL_INQUIRY_PAGING_MASK ) //<S2SV> { //<S2SV> if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_STARTED ) //<S2SV> { //<S2SV> HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , //<S2SV> BT_DISCOVERY_STARTED ) ; //<S2SV> btif_dm_inquiry_in_progress = TRUE ; //<S2SV> } //<S2SV> else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_CANCELLED ) //<S2SV> { //<S2SV> HAL_CBACK ( bt_hal_cbacks , discovery_state_changed_cb , //<S2SV> BT_DISCOVERY_STOPPED ) ; //<S2SV> btif_dm_inquiry_in_progress = FALSE ; //<S2SV> } //<S2SV> else if ( p_data -> busy_level . level_flags == BTM_BL_INQUIRY_COMPLETE ) //<S2SV> { //<S2SV> btif_dm_inquiry_in_progress = FALSE ; //<S2SV> } //<S2SV> } //<S2SV> } break ; //<S2SV> case BTA_DM_LINK_UP_EVT : //<S2SV> bdcpy ( bd_addr . address , p_data -> link_up . bd_addr ) ; //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_LINK_UP_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_CONNECTED" ) ; //<S2SV> btif_update_remote_version_property ( & bd_addr ) ; //<S2SV> HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , //<S2SV> & bd_addr , BT_ACL_STATE_CONNECTED ) ; //<S2SV> break ; //<S2SV> case BTA_DM_LINK_DOWN_EVT : //<S2SV> bdcpy ( bd_addr . address , p_data -> link_down . bd_addr ) ; //<S2SV> btm_set_bond_type_dev ( p_data -> link_down . bd_addr , BOND_TYPE_UNKNOWN ) ; //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_LINK_DOWN_EVT.<S2SV_blank>Sending<S2SV_blank>BT_ACL_STATE_DISCONNECTED" ) ; //<S2SV> HAL_CBACK ( bt_hal_cbacks , acl_state_changed_cb , BT_STATUS_SUCCESS , //<S2SV> & bd_addr , BT_ACL_STATE_DISCONNECTED ) ; //<S2SV> break ; //<S2SV> case BTA_DM_HW_ERROR_EVT : //<S2SV> BTIF_TRACE_ERROR ( "Received<S2SV_blank>H/W<S2SV_blank>Error.<S2SV_blank>" ) ; //<S2SV> btif_config_flush ( ) ; //<S2SV> usleep ( 100000 ) ; //<S2SV> kill ( getpid ( ) , SIGKILL ) ; //<S2SV> break ; //<S2SV> # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) //<S2SV> case BTA_DM_BLE_KEY_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_KEY_EVT<S2SV_blank>key_type=0x%02x<S2SV_blank>" , p_data -> ble_key . key_type ) ; //<S2SV> if ( pairing_cb . state != BT_BOND_STATE_BONDING ) //<S2SV> { //<S2SV> BTIF_TRACE_DEBUG ( "Bond<S2SV_blank>state<S2SV_blank>not<S2SV_blank>sent<S2SV_blank>to<S2SV_blank>App<S2SV_blank>so<S2SV_blank>far.Notify<S2SV_blank>the<S2SV_blank>app<S2SV_blank>now" ) ; //<S2SV> bond_state_changed ( BT_STATUS_SUCCESS , ( bt_bdaddr_t * ) p_data -> ble_key . bd_addr , //<S2SV> BT_BOND_STATE_BONDING ) ; //<S2SV> } //<S2SV> else if ( memcmp ( pairing_cb . bd_addr , p_data -> ble_key . bd_addr , BD_ADDR_LEN ) != 0 ) //<S2SV> { //<S2SV> BTIF_TRACE_ERROR ( "BD<S2SV_blank>mismatch<S2SV_blank>discard<S2SV_blank>BLE<S2SV_blank>key_type=%d<S2SV_blank>" , p_data -> ble_key . key_type ) ; //<S2SV> break ; //<S2SV> } //<S2SV> switch ( p_data -> ble_key . key_type ) //<S2SV> { //<S2SV> case BTA_LE_KEY_PENC : //<S2SV> BTIF_TRACE_DEBUG ( "Rcv<S2SV_blank>BTA_LE_KEY_PENC" ) ; //<S2SV> pairing_cb . ble . is_penc_key_rcvd = TRUE ; //<S2SV> pairing_cb . ble . penc_key = p_data -> ble_key . p_key_value -> penc_key ; //<S2SV> break ; //<S2SV> case BTA_LE_KEY_PID : //<S2SV> BTIF_TRACE_DEBUG ( "Rcv<S2SV_blank>BTA_LE_KEY_PID" ) ; //<S2SV> pairing_cb . ble . is_pid_key_rcvd = TRUE ; //<S2SV> pairing_cb . ble . pid_key = p_data -> ble_key . p_key_value -> pid_key ; //<S2SV> break ; //<S2SV> case BTA_LE_KEY_PCSRK : //<S2SV> BTIF_TRACE_DEBUG ( "Rcv<S2SV_blank>BTA_LE_KEY_PCSRK" ) ; //<S2SV> pairing_cb . ble . is_pcsrk_key_rcvd = TRUE ; //<S2SV> pairing_cb . ble . pcsrk_key = p_data -> ble_key . p_key_value -> pcsrk_key ; //<S2SV> break ; //<S2SV> case BTA_LE_KEY_LENC : //<S2SV> BTIF_TRACE_DEBUG ( "Rcv<S2SV_blank>BTA_LE_KEY_LENC" ) ; //<S2SV> pairing_cb . ble . is_lenc_key_rcvd = TRUE ; //<S2SV> pairing_cb . ble . lenc_key = p_data -> ble_key . p_key_value -> lenc_key ; //<S2SV> break ; //<S2SV> case BTA_LE_KEY_LCSRK : //<S2SV> BTIF_TRACE_DEBUG ( "Rcv<S2SV_blank>BTA_LE_KEY_LCSRK" ) ; //<S2SV> pairing_cb . ble . is_lcsrk_key_rcvd = TRUE ; //<S2SV> pairing_cb . ble . lcsrk_key = p_data -> ble_key . p_key_value -> lcsrk_key ; //<S2SV> break ; //<S2SV> case BTA_LE_KEY_LID : //<S2SV> BTIF_TRACE_DEBUG ( "Rcv<S2SV_blank>BTA_LE_KEY_LID" ) ; //<S2SV> pairing_cb . ble . is_lidk_key_rcvd = TRUE ; //<S2SV> break ; //<S2SV> default : //<S2SV> BTIF_TRACE_ERROR ( "unknown<S2SV_blank>BLE<S2SV_blank>key<S2SV_blank>type<S2SV_blank>(0x%02x)" , p_data -> ble_key . key_type ) ; //<S2SV> break ; //<S2SV> } //<S2SV> break ; //<S2SV> case BTA_DM_BLE_SEC_REQ_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_SEC_REQ_EVT.<S2SV_blank>" ) ; //<S2SV> btif_dm_ble_sec_req_evt ( & p_data -> ble_req ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BLE_PASSKEY_NOTIF_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_PASSKEY_NOTIF_EVT.<S2SV_blank>" ) ; //<S2SV> btif_dm_ble_key_notif_evt ( & p_data -> key_notif ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BLE_PASSKEY_REQ_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>" ) ; //<S2SV> btif_dm_ble_passkey_req_evt ( & p_data -> pin_req ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BLE_NC_REQ_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_PASSKEY_REQ_EVT.<S2SV_blank>" ) ; //<S2SV> btif_dm_ble_key_nc_req_evt ( & p_data -> key_notif ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BLE_OOB_REQ_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_OOB_REQ_EVT.<S2SV_blank>" ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BLE_LOCAL_IR_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_LOCAL_IR_EVT.<S2SV_blank>" ) ; //<S2SV> ble_local_key_cb . is_id_keys_rcvd = TRUE ; //<S2SV> memcpy ( & ble_local_key_cb . id_keys . irk [ 0 ] , //<S2SV> & p_data -> ble_id_keys . irk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; //<S2SV> memcpy ( & ble_local_key_cb . id_keys . ir [ 0 ] , //<S2SV> & p_data -> ble_id_keys . ir [ 0 ] , sizeof ( BT_OCTET16 ) ) ; //<S2SV> memcpy ( & ble_local_key_cb . id_keys . dhk [ 0 ] , //<S2SV> & p_data -> ble_id_keys . dhk [ 0 ] , sizeof ( BT_OCTET16 ) ) ; //<S2SV> btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . irk [ 0 ] , //<S2SV> BTIF_DM_LE_LOCAL_KEY_IRK , //<S2SV> BT_OCTET16_LEN ) ; //<S2SV> btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . ir [ 0 ] , //<S2SV> BTIF_DM_LE_LOCAL_KEY_IR , //<S2SV> BT_OCTET16_LEN ) ; //<S2SV> btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . id_keys . dhk [ 0 ] , //<S2SV> BTIF_DM_LE_LOCAL_KEY_DHK , //<S2SV> BT_OCTET16_LEN ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BLE_LOCAL_ER_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_LOCAL_ER_EVT.<S2SV_blank>" ) ; //<S2SV> ble_local_key_cb . is_er_rcvd = TRUE ; //<S2SV> memcpy ( & ble_local_key_cb . er [ 0 ] , & p_data -> ble_er [ 0 ] , sizeof ( BT_OCTET16 ) ) ; //<S2SV> btif_storage_add_ble_local_key ( ( char * ) & ble_local_key_cb . er [ 0 ] , //<S2SV> BTIF_DM_LE_LOCAL_KEY_ER , //<S2SV> BT_OCTET16_LEN ) ; //<S2SV> break ; //<S2SV> case BTA_DM_BLE_AUTH_CMPL_EVT : //<S2SV> BTIF_TRACE_DEBUG ( "BTA_DM_BLE_AUTH_CMPL_EVT.<S2SV_blank>" ) ; //<S2SV> btif_dm_ble_auth_cmpl_evt ( & p_data -> auth_cmpl ) ; //<S2SV> break ; //<S2SV> case BTA_DM_LE_FEATURES_READ : //<S2SV> { //<S2SV> tBTM_BLE_VSC_CB cmn_vsc_cb ; //<S2SV> bt_local_le_features_t local_le_features ; //<S2SV> char buf [ 512 ] ; //<S2SV> bt_property_t prop ; //<S2SV> prop . type = BT_PROPERTY_LOCAL_LE_FEATURES ; //<S2SV> prop . val = ( void * ) buf ; //<S2SV> prop . len = sizeof ( buf ) ; //<S2SV> BTM_BleGetVendorCapabilities ( & cmn_vsc_cb ) ; //<S2SV> local_le_features . local_privacy_enabled = BTM_BleLocalPrivacyEnabled ( ) ; //<S2SV> prop . len = sizeof ( bt_local_le_features_t ) ; //<S2SV> if ( cmn_vsc_cb . filter_support == 1 ) //<S2SV> local_le_features . max_adv_filter_supported = cmn_vsc_cb . max_filter ; //<S2SV> else //<S2SV> local_le_features . max_adv_filter_supported = 0 ; //<S2SV> local_le_features . max_adv_instance = cmn_vsc_cb . adv_inst_max ; //<S2SV> local_le_features . max_irk_list_size = cmn_vsc_cb . max_irk_list_sz ; //<S2SV> local_le_features . rpa_offload_supported = cmn_vsc_cb . rpa_offloading ; //<S2SV> local_le_features . activity_energy_info_supported = cmn_vsc_cb . energy_support ; //<S2SV> local_le_features . scan_result_storage_size = cmn_vsc_cb . tot_scan_results_strg ; //<S2SV> local_le_features . version_supported = cmn_vsc_cb . version_supported ; //<S2SV> local_le_features . total_trackable_advertisers = //<S2SV> cmn_vsc_cb . total_trackable_advertisers ; //<S2SV> local_le_features . extended_scan_support = cmn_vsc_cb . extended_scan_support > 0 ; //<S2SV> local_le_features . debug_logging_supported = cmn_vsc_cb . debug_logging_supported > 0 ; //<S2SV> memcpy ( prop . val , & local_le_features , prop . len ) ; //<S2SV> HAL_CBACK ( bt_hal_cbacks , adapter_properties_cb , BT_STATUS_SUCCESS , 1 , & prop ) ; //<S2SV> break ; //<S2SV> } //<S2SV> case BTA_DM_ENER_INFO_READ : //<S2SV> { //<S2SV> btif_activity_energy_info_cb_t * p_ener_data = ( btif_activity_energy_info_cb_t * ) p_param ; //<S2SV> bt_activity_energy_info energy_info ; //<S2SV> energy_info . status = p_ener_data -> status ; //<S2SV> energy_info . ctrl_state = p_ener_data -> ctrl_state ; //<S2SV> energy_info . rx_time = p_ener_data -> rx_time ; //<S2SV> energy_info . tx_time = p_ener_data -> tx_time ; //<S2SV> energy_info . idle_time = p_ener_data -> idle_time ; //<S2SV> energy_info . energy_used = p_ener_data -> energy_used ; //<S2SV> HAL_CBACK ( bt_hal_cbacks , energy_info_cb , & energy_info ) ; //<S2SV> break ; //<S2SV> } //<S2SV> # endif //<S2SV> case BTA_DM_AUTHORIZE_EVT : //<S2SV> case BTA_DM_SIG_STRENGTH_EVT : //<S2SV> case BTA_DM_SP_RMT_OOB_EVT : //<S2SV> case BTA_DM_SP_KEYPRESS_EVT : //<S2SV> case BTA_DM_ROLE_CHG_EVT : //<S2SV> default : //<S2SV> BTIF_TRACE_WARNING ( "btif_dm_cback<S2SV_blank>:<S2SV_blank>unhandled<S2SV_blank>event<S2SV_blank>(%d)" , event ) ; //<S2SV> break ; //<S2SV> } //<S2SV> btif_dm_data_free ( event , p_data ) ; //<S2SV> } //<S2SV> 