static int process_cmd_sock ( int h ) //<S2SV> { //<S2SV> sock_cmd_t cmd = { - 1 , 0 , 0 , 0 , 0 } ; //<S2SV> int fd = ts [ h ] . cmd_fdr ; //<S2SV> if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) ) //<S2SV> { //<S2SV> APPL_TRACE_ERROR ( "recv<S2SV_blank>cmd<S2SV_blank>errno:%d" , errno ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> APPL_TRACE_DEBUG ( "cmd.id:%d" , cmd . id ) ; //<S2SV> switch ( cmd . id ) //<S2SV> { //<S2SV> case CMD_ADD_FD : //<S2SV> add_poll ( h , cmd . fd , cmd . type , cmd . flags , cmd . user_id ) ; //<S2SV> break ; //<S2SV> case CMD_REMOVE_FD : //<S2SV> for ( int i = 1 ; i < MAX_POLL ; ++ i ) //<S2SV> { //<S2SV> poll_slot_t * poll_slot = & ts [ h ] . ps [ i ] ; //<S2SV> if ( poll_slot -> pfd . fd == cmd . fd ) //<S2SV> { //<S2SV> remove_poll ( h , poll_slot , poll_slot -> flags ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> close ( cmd . fd ) ; //<S2SV> break ; //<S2SV> case CMD_WAKEUP : //<S2SV> break ; //<S2SV> case CMD_USER_PRIVATE : //<S2SV> asrt ( ts [ h ] . cmd_callback ) ; //<S2SV> if ( ts [ h ] . cmd_callback ) //<S2SV> ts [ h ] . cmd_callback ( fd , cmd . type , cmd . flags , cmd . user_id ) ; //<S2SV> break ; //<S2SV> case CMD_EXIT : //<S2SV> return FALSE ; //<S2SV> default : //<S2SV> APPL_TRACE_DEBUG ( "unknown<S2SV_blank>cmd:<S2SV_blank>%d" , cmd . id ) ; //<S2SV> break ; //<S2SV> } //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 