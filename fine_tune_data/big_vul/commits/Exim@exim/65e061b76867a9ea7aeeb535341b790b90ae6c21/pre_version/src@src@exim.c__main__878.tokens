int //<S2SV> main ( int argc , char * * cargv ) //<S2SV> { //<S2SV> uschar * * argv = USS cargv ; //<S2SV> int arg_receive_timeout = - 1 ; //<S2SV> int arg_smtp_receive_timeout = - 1 ; //<S2SV> int arg_error_handling = error_handling ; //<S2SV> int filter_sfd = - 1 ; //<S2SV> int filter_ufd = - 1 ; //<S2SV> int group_count ; //<S2SV> int i , rv ; //<S2SV> int list_queue_option = 0 ; //<S2SV> int msg_action = 0 ; //<S2SV> int msg_action_arg = - 1 ; //<S2SV> int namelen = ( argv [ 0 ] == NULL ) ? 0 : Ustrlen ( argv [ 0 ] ) ; //<S2SV> int queue_only_reason = 0 ; //<S2SV> # ifdef EXIM_PERL //<S2SV> int perl_start_option = 0 ; //<S2SV> # endif //<S2SV> int recipients_arg = argc ; //<S2SV> int sender_address_domain = 0 ; //<S2SV> int test_retry_arg = - 1 ; //<S2SV> int test_rewrite_arg = - 1 ; //<S2SV> BOOL arg_queue_only = FALSE ; //<S2SV> BOOL bi_option = FALSE ; //<S2SV> BOOL checking = FALSE ; //<S2SV> BOOL count_queue = FALSE ; //<S2SV> BOOL expansion_test = FALSE ; //<S2SV> BOOL extract_recipients = FALSE ; //<S2SV> BOOL flag_G = FALSE ; //<S2SV> BOOL flag_n = FALSE ; //<S2SV> BOOL forced_delivery = FALSE ; //<S2SV> BOOL f_end_dot = FALSE ; //<S2SV> BOOL deliver_give_up = FALSE ; //<S2SV> BOOL list_queue = FALSE ; //<S2SV> BOOL list_options = FALSE ; //<S2SV> BOOL list_config = FALSE ; //<S2SV> BOOL local_queue_only ; //<S2SV> BOOL more = TRUE ; //<S2SV> BOOL one_msg_action = FALSE ; //<S2SV> BOOL opt_D_used = FALSE ; //<S2SV> BOOL queue_only_set = FALSE ; //<S2SV> BOOL receiving_message = TRUE ; //<S2SV> BOOL sender_ident_set = FALSE ; //<S2SV> BOOL session_local_queue_only ; //<S2SV> BOOL unprivileged ; //<S2SV> BOOL removed_privilege = FALSE ; //<S2SV> BOOL usage_wanted = FALSE ; //<S2SV> BOOL verify_address_mode = FALSE ; //<S2SV> BOOL verify_as_sender = FALSE ; //<S2SV> BOOL version_printed = FALSE ; //<S2SV> uschar * alias_arg = NULL ; //<S2SV> uschar * called_as = US "" ; //<S2SV> uschar * cmdline_syslog_name = NULL ; //<S2SV> uschar * start_queue_run_id = NULL ; //<S2SV> uschar * stop_queue_run_id = NULL ; //<S2SV> uschar * expansion_test_message = NULL ; //<S2SV> uschar * ftest_domain = NULL ; //<S2SV> uschar * ftest_localpart = NULL ; //<S2SV> uschar * ftest_prefix = NULL ; //<S2SV> uschar * ftest_suffix = NULL ; //<S2SV> uschar * log_oneline = NULL ; //<S2SV> uschar * malware_test_file = NULL ; //<S2SV> uschar * real_sender_address ; //<S2SV> uschar * originator_home = US "/" ; //<S2SV> size_t sz ; //<S2SV> void * reset_point ; //<S2SV> struct passwd * pw ; //<S2SV> struct stat statbuf ; //<S2SV> pid_t passed_qr_pid = ( pid_t ) 0 ; //<S2SV> int passed_qr_pipe = - 1 ; //<S2SV> gid_t group_list [ NGROUPS_MAX ] ; //<S2SV> enum commandline_info info_flag = CMDINFO_NONE ; //<S2SV> BOOL info_stdout = FALSE ; //<S2SV> static uschar * rsopts [ ] = { US "f" , US "ff" , US "r" , US "rf" , US "rff" } ; //<S2SV> extern char * * environ ; //<S2SV> # ifdef EXIM_USERNAME //<S2SV> if ( route_finduser ( US EXIM_USERNAME , & pw , & exim_uid ) ) //<S2SV> { //<S2SV> if ( exim_uid == 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>refusing<S2SV_blank>to<S2SV_blank>run<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>0<S2SV_blank>for<S2SV_blank>\\"%s\\"\\n" , //<S2SV> EXIM_USERNAME ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( pw ) //<S2SV> exim_gid = pw -> pw_gid ; //<S2SV> # ifndef EXIM_GROUPNAME //<S2SV> else //<S2SV> { //<S2SV> fprintf ( stderr , //<S2SV> "exim:<S2SV_blank>ref:name<S2SV_blank>should<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>usercode,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>group.\\n" //<S2SV> "exim:<S2SV_blank>can\'t<S2SV_blank>let<S2SV_blank>you<S2SV_blank>get<S2SV_blank>away<S2SV_blank>with<S2SV_blank>it<S2SV_blank>unless<S2SV_blank>you<S2SV_blank>also<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>group.\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\"%s\\"\\n" , //<S2SV> EXIM_USERNAME ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef EXIM_GROUPNAME //<S2SV> if ( ! route_findgroup ( US EXIM_GROUPNAME , & exim_gid ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\"%s\\"\\n" , //<S2SV> EXIM_GROUPNAME ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef CONFIGURE_OWNERNAME //<S2SV> if ( ! route_finduser ( US CONFIGURE_OWNERNAME , NULL , & config_uid ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>name<S2SV_blank>\\"%s\\"\\n" , //<S2SV> CONFIGURE_OWNERNAME ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> # endif //<S2SV> system_filter_uid = exim_uid ; //<S2SV> # ifdef CONFIGURE_GROUPNAME //<S2SV> if ( ! route_findgroup ( US CONFIGURE_GROUPNAME , & config_gid ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>find<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>name<S2SV_blank>\\"%s\\"\\n" , //<S2SV> CONFIGURE_GROUPNAME ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef OS_INIT //<S2SV> OS_INIT //<S2SV> # endif //<S2SV> running_in_test_harness = //<S2SV> * running_status == '<' && Ustrcmp ( running_status , "<<<testing>>>" ) == 0 ; //<S2SV> setlocale ( LC_ALL , "C" ) ; //<S2SV> os_non_restarting_signal ( SIGALRM , sigalrm_handler ) ; //<S2SV> if ( ! ( log_buffer = US malloc ( LOG_BUFFER_SIZE ) ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>store<S2SV_blank>for<S2SV_blank>log<S2SV_blank>buffer\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> bits_set ( log_selector , log_selector_size , log_default ) ; //<S2SV> if ( fstat ( fileno ( stderr ) , & statbuf ) >= 0 ) log_stderr = stderr ; //<S2SV> pcre_malloc = function_store_get ; //<S2SV> pcre_free = function_dummy_free ; //<S2SV> big_buffer = store_malloc ( big_buffer_size ) ; //<S2SV> set_process_info ( "initializing" ) ; //<S2SV> os_restarting_signal ( SIGUSR1 , usr1_handler ) ; //<S2SV> signal ( SIGHUP , SIG_IGN ) ; //<S2SV> signal ( SIGPIPE , SIG_IGN ) ; //<S2SV> # ifdef SA_NOCLDWAIT //<S2SV> { //<S2SV> struct sigaction act ; //<S2SV> act . sa_handler = SIG_DFL ; //<S2SV> sigemptyset ( & ( act . sa_mask ) ) ; //<S2SV> act . sa_flags = 0 ; //<S2SV> sigaction ( SIGCHLD , & act , NULL ) ; //<S2SV> } //<S2SV> # else //<S2SV> signal ( SIGCHLD , SIG_DFL ) ; //<S2SV> # endif //<S2SV> sighup_argv = argv ; //<S2SV> version_init ( ) ; //<S2SV> message_id_option [ 0 ] = '-' ; //<S2SV> message_id_external = message_id_option + 1 ; //<S2SV> message_id_external [ 0 ] = 'E' ; //<S2SV> message_id = message_id_external + 1 ; //<S2SV> message_id [ 0 ] = 0 ; //<S2SV> ( void ) umask ( 0 ) ; //<S2SV> regex_ismsgid = //<S2SV> regex_must_compile ( US "^(?:[^\\\\W_]{6}-){2}[^\\\\W_]{2}$" , FALSE , TRUE ) ; //<S2SV> regex_smtp_code = //<S2SV> regex_must_compile ( US "^\\\\d\\\\d\\\\d\\\\s(?:\\\\d\\\\.\\\\d\\\\d?\\\\d?\\\\.\\\\d\\\\d?\\\\d?\\\\s)?" , //<S2SV> FALSE , TRUE ) ; //<S2SV> # ifdef WHITELIST_D_MACROS //<S2SV> regex_whitelisted_macro = //<S2SV> regex_must_compile ( US "^[A-Za-z0-9_/.-]*$" , FALSE , TRUE ) ; //<S2SV> # endif //<S2SV> for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; //<S2SV> if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , "mailq" ) == 0 ) || //<S2SV> ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , "/mailq" , 6 ) == 0 ) ) //<S2SV> { //<S2SV> list_queue = TRUE ; //<S2SV> receiving_message = FALSE ; //<S2SV> called_as = US "-mailq" ; //<S2SV> } //<S2SV> if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , "rmail" ) == 0 ) || //<S2SV> ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , "/rmail" , 6 ) == 0 ) ) //<S2SV> { //<S2SV> dot_ends = FALSE ; //<S2SV> called_as = US "-rmail" ; //<S2SV> errors_sender_rc = EXIT_SUCCESS ; //<S2SV> } //<S2SV> if ( ( namelen == 5 && Ustrcmp ( argv [ 0 ] , "rsmtp" ) == 0 ) || //<S2SV> ( namelen > 5 && Ustrncmp ( argv [ 0 ] + namelen - 6 , "/rsmtp" , 6 ) == 0 ) ) //<S2SV> { //<S2SV> smtp_input = smtp_batched_input = TRUE ; //<S2SV> called_as = US "-rsmtp" ; //<S2SV> } //<S2SV> if ( ( namelen == 4 && Ustrcmp ( argv [ 0 ] , "runq" ) == 0 ) || //<S2SV> ( namelen > 4 && Ustrncmp ( argv [ 0 ] + namelen - 5 , "/runq" , 5 ) == 0 ) ) //<S2SV> { //<S2SV> queue_interval = 0 ; //<S2SV> receiving_message = FALSE ; //<S2SV> called_as = US "-runq" ; //<S2SV> } //<S2SV> if ( ( namelen == 10 && Ustrcmp ( argv [ 0 ] , "newaliases" ) == 0 ) || //<S2SV> ( namelen > 10 && Ustrncmp ( argv [ 0 ] + namelen - 11 , "/newaliases" , 11 ) == 0 ) ) //<S2SV> { //<S2SV> bi_option = TRUE ; //<S2SV> receiving_message = FALSE ; //<S2SV> called_as = US "-newaliases" ; //<S2SV> } //<S2SV> original_euid = geteuid ( ) ; //<S2SV> real_uid = getuid ( ) ; //<S2SV> real_gid = getgid ( ) ; //<S2SV> if ( real_uid == root_uid ) //<S2SV> { //<S2SV> rv = setgid ( real_gid ) ; //<S2SV> if ( rv ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>setgid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n" , //<S2SV> ( long int ) real_gid , strerror ( errno ) ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> rv = setuid ( real_uid ) ; //<S2SV> if ( rv ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>setuid(%ld)<S2SV_blank>failed:<S2SV_blank>%s\\n" , //<S2SV> ( long int ) real_uid , strerror ( errno ) ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> unprivileged = ( real_uid != root_uid && original_euid != root_uid ) ; //<S2SV> for ( i = 1 ; i < argc ; i ++ ) //<S2SV> { //<S2SV> BOOL badarg = FALSE ; //<S2SV> uschar * arg = argv [ i ] ; //<S2SV> uschar * argrest ; //<S2SV> int switchchar ; //<S2SV> if ( arg [ 0 ] != '-' ) //<S2SV> { //<S2SV> recipients_arg = i ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( Ustrcmp ( arg , "--" ) == 0 ) //<S2SV> { //<S2SV> recipients_arg = i + 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> switchchar = arg [ 1 ] ; //<S2SV> argrest = arg + 2 ; //<S2SV> if ( Ustrncmp ( arg + 1 , "oe" , 2 ) == 0 || //<S2SV> Ustrncmp ( arg + 1 , "qR" , 2 ) == 0 || //<S2SV> Ustrncmp ( arg + 1 , "qS" , 2 ) == 0 ) //<S2SV> { //<S2SV> switchchar = arg [ 2 ] ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> else if ( Ustrncmp ( arg + 1 , "qqR" , 3 ) == 0 || Ustrncmp ( arg + 1 , "qqS" , 3 ) == 0 ) //<S2SV> { //<S2SV> switchchar = arg [ 3 ] ; //<S2SV> argrest += 2 ; //<S2SV> queue_2stage = TRUE ; //<S2SV> } //<S2SV> else if ( arg [ 1 ] == 'r' ) switchchar = 'f' ; //<S2SV> else if ( Ustrcmp ( arg , "-ov" ) == 0 ) //<S2SV> { //<S2SV> switchchar = 'v' ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> else if ( switchchar == '-' ) //<S2SV> { //<S2SV> if ( Ustrcmp ( argrest , "help" ) == 0 ) //<S2SV> { //<S2SV> usage_wanted = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "version" ) == 0 ) //<S2SV> { //<S2SV> switchchar = 'b' ; //<S2SV> argrest = US "V" ; //<S2SV> } //<S2SV> } //<S2SV> switch ( switchchar ) //<S2SV> { //<S2SV> case 'A' : //<S2SV> if ( * argrest == '\\0' ) { badarg = TRUE ; break ; } //<S2SV> else //<S2SV> { //<S2SV> BOOL ignore = FALSE ; //<S2SV> switch ( * argrest ) //<S2SV> { //<S2SV> case 'c' : //<S2SV> case 'm' : //<S2SV> if ( * ( argrest + 1 ) == '\\0' ) //<S2SV> ignore = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( ! ignore ) { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> break ; //<S2SV> case 'B' : //<S2SV> if ( * argrest == 0 ) i ++ ; //<S2SV> break ; //<S2SV> case 'b' : //<S2SV> receiving_message = FALSE ; //<S2SV> if ( * argrest == 'd' ) //<S2SV> { //<S2SV> daemon_listen = TRUE ; //<S2SV> if ( * ( ++ argrest ) == 'f' ) background_daemon = FALSE ; //<S2SV> else if ( * argrest != 0 ) { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> else if ( * argrest == 'e' ) //<S2SV> { //<S2SV> expansion_test = checking = TRUE ; //<S2SV> if ( argrest [ 1 ] == 'm' ) //<S2SV> { //<S2SV> if ( ++ i >= argc ) { badarg = TRUE ; break ; } //<S2SV> expansion_test_message = argv [ i ] ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> if ( argrest [ 1 ] != 0 ) { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> else if ( * argrest == 'F' ) //<S2SV> { //<S2SV> filter_test |= checking = FTEST_SYSTEM ; //<S2SV> if ( * ( ++ argrest ) != 0 ) { badarg = TRUE ; break ; } //<S2SV> if ( ++ i < argc ) filter_test_sfile = argv [ i ] ; else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n" , argv [ i - 1 ] ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( * argrest == 'f' ) //<S2SV> { //<S2SV> if ( * ( ++ argrest ) == 0 ) //<S2SV> { //<S2SV> filter_test |= checking = FTEST_USER ; //<S2SV> if ( ++ i < argc ) filter_test_ufile = argv [ i ] ; else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n" , argv [ i - 1 ] ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ++ i >= argc ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n" , arg ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( Ustrcmp ( argrest , "d" ) == 0 ) ftest_domain = argv [ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "l" ) == 0 ) ftest_localpart = argv [ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "p" ) == 0 ) ftest_prefix = argv [ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "s" ) == 0 ) ftest_suffix = argv [ i ] ; //<S2SV> else { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "h" ) == 0 || Ustrcmp ( argrest , "hc" ) == 0 ) //<S2SV> { //<S2SV> if ( ++ i >= argc ) { badarg = TRUE ; break ; } //<S2SV> sender_host_address = argv [ i ] ; //<S2SV> host_checking = checking = log_testing_mode = TRUE ; //<S2SV> host_checking_callout = argrest [ 1 ] == 'c' ; //<S2SV> message_logs = FALSE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "i" ) == 0 ) bi_option = TRUE ; //<S2SV> else if ( argrest [ 0 ] == 'I' && Ustrlen ( argrest ) >= 2 && argrest [ 1 ] == ':' ) //<S2SV> { //<S2SV> uschar * p = & argrest [ 2 ] ; //<S2SV> info_flag = CMDINFO_HELP ; //<S2SV> if ( Ustrlen ( p ) ) //<S2SV> { //<S2SV> if ( strcmpic ( p , CUS "sieve" ) == 0 ) //<S2SV> { //<S2SV> info_flag = CMDINFO_SIEVE ; //<S2SV> info_stdout = TRUE ; //<S2SV> } //<S2SV> else if ( strcmpic ( p , CUS "dscp" ) == 0 ) //<S2SV> { //<S2SV> info_flag = CMDINFO_DSCP ; //<S2SV> info_stdout = TRUE ; //<S2SV> } //<S2SV> else if ( strcmpic ( p , CUS "help" ) == 0 ) //<S2SV> { //<S2SV> info_stdout = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "m" ) == 0 ) receiving_message = TRUE ; //<S2SV> else if ( Ustrcmp ( argrest , "malware" ) == 0 ) //<S2SV> { //<S2SV> if ( ++ i >= argc ) { badarg = TRUE ; break ; } //<S2SV> checking = TRUE ; //<S2SV> malware_test_file = argv [ i ] ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "nq" ) == 0 ) //<S2SV> { //<S2SV> allow_unqualified_sender = FALSE ; //<S2SV> allow_unqualified_recipient = FALSE ; //<S2SV> } //<S2SV> else if ( * argrest == 'p' ) //<S2SV> { //<S2SV> if ( * ( ++ argrest ) == 'c' ) //<S2SV> { //<S2SV> count_queue = TRUE ; //<S2SV> if ( * ( ++ argrest ) != 0 ) badarg = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( * argrest == 'r' ) //<S2SV> { //<S2SV> list_queue_option = 8 ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> else list_queue_option = 0 ; //<S2SV> list_queue = TRUE ; //<S2SV> if ( * argrest == 0 ) { } //<S2SV> else if ( Ustrcmp ( argrest , "u" ) == 0 ) list_queue_option += 1 ; //<S2SV> else if ( Ustrcmp ( argrest , "a" ) == 0 ) list_queue_option += 2 ; //<S2SV> else //<S2SV> { //<S2SV> badarg = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "P" ) == 0 ) //<S2SV> { //<S2SV> if ( argv [ i + 1 ] && Ustrcmp ( argv [ i + 1 ] , "config" ) == 0 ) //<S2SV> { //<S2SV> list_config = TRUE ; //<S2SV> readconf_save_config ( version_string ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> list_options = TRUE ; //<S2SV> debug_selector |= D_v ; //<S2SV> debug_file = stderr ; //<S2SV> } //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "rt" ) == 0 ) //<S2SV> { //<S2SV> checking = TRUE ; //<S2SV> test_retry_arg = i + 1 ; //<S2SV> goto END_ARG ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "rw" ) == 0 ) //<S2SV> { //<S2SV> checking = TRUE ; //<S2SV> test_rewrite_arg = i + 1 ; //<S2SV> goto END_ARG ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "S" ) == 0 ) //<S2SV> smtp_input = smtp_batched_input = receiving_message = TRUE ; //<S2SV> else if ( Ustrcmp ( argrest , "s" ) == 0 ) smtp_input = receiving_message = TRUE ; //<S2SV> else if ( Ustrcmp ( argrest , "t" ) == 0 ) //<S2SV> address_test_mode = checking = log_testing_mode = TRUE ; //<S2SV> else if ( Ustrcmp ( argrest , "v" ) == 0 ) //<S2SV> verify_address_mode = checking = log_testing_mode = TRUE ; //<S2SV> else if ( Ustrcmp ( argrest , "vs" ) == 0 ) //<S2SV> { //<S2SV> verify_address_mode = checking = log_testing_mode = TRUE ; //<S2SV> verify_as_sender = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "V" ) == 0 ) //<S2SV> { //<S2SV> printf ( "Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>#%s<S2SV_blank>built<S2SV_blank>%s\\n" , version_string , //<S2SV> version_cnumber , version_date ) ; //<S2SV> printf ( "%s\\n" , CS version_copyright ) ; //<S2SV> version_printed = TRUE ; //<S2SV> show_whats_supported ( stdout ) ; //<S2SV> log_testing_mode = TRUE ; //<S2SV> } //<S2SV> else if ( * argrest == 'w' ) //<S2SV> { //<S2SV> inetd_wait_mode = TRUE ; //<S2SV> background_daemon = FALSE ; //<S2SV> daemon_listen = TRUE ; //<S2SV> if ( * ( ++ argrest ) != '\\0' ) //<S2SV> { //<S2SV> inetd_wait_timeout = readconf_readtime ( argrest , 0 , FALSE ) ; //<S2SV> if ( inetd_wait_timeout <= 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n" , argv [ i ] ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'C' : //<S2SV> if ( * argrest == 0 ) //<S2SV> { //<S2SV> if ( ++ i < argc ) argrest = argv [ i ] ; else //<S2SV> { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> if ( Ustrcmp ( config_main_filelist , argrest ) != 0 ) //<S2SV> { //<S2SV> # ifdef ALT_CONFIG_PREFIX //<S2SV> int sep = 0 ; //<S2SV> int len = Ustrlen ( ALT_CONFIG_PREFIX ) ; //<S2SV> const uschar * list = argrest ; //<S2SV> uschar * filename ; //<S2SV> while ( ( filename = string_nextinlist ( & list , & sep , big_buffer , //<S2SV> big_buffer_size ) ) != NULL ) //<S2SV> { //<S2SV> if ( ( Ustrlen ( filename ) < len || //<S2SV> Ustrncmp ( filename , ALT_CONFIG_PREFIX , len ) != 0 || //<S2SV> Ustrstr ( filename , "/../" ) != NULL ) && //<S2SV> ( Ustrcmp ( filename , "/dev/null" ) != 0 || real_uid != root_uid ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "-C<S2SV_blank>Permission<S2SV_blank>denied\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( real_uid != root_uid ) //<S2SV> { //<S2SV> # ifdef TRUSTED_CONFIG_LIST //<S2SV> if ( real_uid != exim_uid //<S2SV> # ifdef CONFIGURE_OWNER //<S2SV> && real_uid != config_uid //<S2SV> # endif //<S2SV> ) //<S2SV> trusted_config = FALSE ; //<S2SV> else //<S2SV> { //<S2SV> FILE * trust_list = Ufopen ( TRUSTED_CONFIG_LIST , "rb" ) ; //<S2SV> if ( trust_list ) //<S2SV> { //<S2SV> struct stat statbuf ; //<S2SV> if ( fstat ( fileno ( trust_list ) , & statbuf ) != 0 || //<S2SV> ( statbuf . st_uid != root_uid //<S2SV> # ifdef CONFIGURE_OWNER //<S2SV> && statbuf . st_uid != config_uid //<S2SV> # endif //<S2SV> ) || //<S2SV> ( statbuf . st_gid != root_gid //<S2SV> # ifdef CONFIGURE_GROUP //<S2SV> && statbuf . st_gid != config_gid //<S2SV> # endif //<S2SV> && ( statbuf . st_mode & 020 ) != 0 //<S2SV> ) || //<S2SV> ( statbuf . st_mode & 2 ) != 0 ) //<S2SV> { //<S2SV> trusted_config = FALSE ; //<S2SV> fclose ( trust_list ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> void * reset_point = store_get ( 0 ) ; //<S2SV> uschar * trusted_configs [ 32 ] ; //<S2SV> int nr_configs = 0 ; //<S2SV> int i = 0 ; //<S2SV> while ( Ufgets ( big_buffer , big_buffer_size , trust_list ) ) //<S2SV> { //<S2SV> uschar * start = big_buffer , * nl ; //<S2SV> while ( * start && isspace ( * start ) ) //<S2SV> start ++ ; //<S2SV> if ( * start != '/' ) //<S2SV> continue ; //<S2SV> nl = Ustrchr ( start , '\\n' ) ; //<S2SV> if ( nl ) //<S2SV> * nl = 0 ; //<S2SV> trusted_configs [ nr_configs ++ ] = string_copy ( start ) ; //<S2SV> if ( nr_configs == 32 ) //<S2SV> break ; //<S2SV> } //<S2SV> fclose ( trust_list ) ; //<S2SV> if ( nr_configs ) //<S2SV> { //<S2SV> int sep = 0 ; //<S2SV> const uschar * list = argrest ; //<S2SV> uschar * filename ; //<S2SV> while ( trusted_config && ( filename = string_nextinlist ( & list , //<S2SV> & sep , big_buffer , big_buffer_size ) ) != NULL ) //<S2SV> { //<S2SV> for ( i = 0 ; i < nr_configs ; i ++ ) //<S2SV> { //<S2SV> if ( Ustrcmp ( filename , trusted_configs [ i ] ) == 0 ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( i == nr_configs ) //<S2SV> { //<S2SV> trusted_config = FALSE ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> store_reset ( reset_point ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> trusted_config = FALSE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> trusted_config = FALSE ; //<S2SV> } //<S2SV> } //<S2SV> # else //<S2SV> trusted_config = FALSE ; //<S2SV> # endif //<S2SV> } //<S2SV> config_main_filelist = argrest ; //<S2SV> config_changed = TRUE ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'D' : //<S2SV> # ifdef DISABLE_D_OPTION //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>-D<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available<S2SV_blank>in<S2SV_blank>this<S2SV_blank>Exim<S2SV_blank>binary\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> # else //<S2SV> { //<S2SV> int ptr = 0 ; //<S2SV> macro_item * m ; //<S2SV> uschar name [ 24 ] ; //<S2SV> uschar * s = argrest ; //<S2SV> opt_D_used = TRUE ; //<S2SV> while ( isspace ( * s ) ) s ++ ; //<S2SV> if ( * s < 'A' || * s > 'Z' ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>macro<S2SV_blank>name<S2SV_blank>set<S2SV_blank>by<S2SV_blank>-D<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>" //<S2SV> "an<S2SV_blank>upper<S2SV_blank>case<S2SV_blank>letter\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> while ( isalnum ( * s ) || * s == '_' ) //<S2SV> { //<S2SV> if ( ptr < sizeof ( name ) - 1 ) name [ ptr ++ ] = * s ; //<S2SV> s ++ ; //<S2SV> } //<S2SV> name [ ptr ] = 0 ; //<S2SV> if ( ptr == 0 ) { badarg = TRUE ; break ; } //<S2SV> while ( isspace ( * s ) ) s ++ ; //<S2SV> if ( * s != 0 ) //<S2SV> { //<S2SV> if ( * s ++ != '=' ) { badarg = TRUE ; break ; } //<S2SV> while ( isspace ( * s ) ) s ++ ; //<S2SV> } //<S2SV> for ( m = macros ; m ; m = m -> next ) //<S2SV> if ( Ustrcmp ( m -> name , name ) == 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>duplicated<S2SV_blank>-D<S2SV_blank>in<S2SV_blank>command<S2SV_blank>line\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> m = macro_create ( name , s , TRUE , FALSE ) ; //<S2SV> if ( clmacro_count >= MAX_CLMACROS ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>-D<S2SV_blank>options<S2SV_blank>on<S2SV_blank>command<S2SV_blank>line\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> clmacros [ clmacro_count ++ ] = string_sprintf ( "-D%s=%s" , m -> name , //<S2SV> m -> replacement ) ; //<S2SV> } //<S2SV> # endif //<S2SV> break ; //<S2SV> case 'd' : //<S2SV> if ( Ustrcmp ( argrest , "ropcr" ) == 0 ) //<S2SV> { //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> unsigned int selector = D_default ; //<S2SV> debug_selector = 0 ; //<S2SV> debug_file = NULL ; //<S2SV> if ( * argrest == 'd' ) //<S2SV> { //<S2SV> debug_daemon = TRUE ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> if ( * argrest != 0 ) //<S2SV> decode_bits ( & selector , 1 , debug_notall , argrest , //<S2SV> debug_options , debug_options_count , US "debug" , 0 ) ; //<S2SV> debug_selector = selector ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'E' : //<S2SV> local_error_message = TRUE ; //<S2SV> if ( mac_ismsgid ( argrest ) ) message_reference = argrest ; //<S2SV> break ; //<S2SV> case 'e' : //<S2SV> if ( Ustrcmp ( argrest , "e" ) == 0 ) //<S2SV> { //<S2SV> arg_error_handling = ERRORS_SENDER ; //<S2SV> errors_sender_rc = EXIT_SUCCESS ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "m" ) == 0 ) arg_error_handling = ERRORS_SENDER ; //<S2SV> else if ( Ustrcmp ( argrest , "p" ) == 0 ) arg_error_handling = ERRORS_STDERR ; //<S2SV> else if ( Ustrcmp ( argrest , "q" ) == 0 ) arg_error_handling = ERRORS_STDERR ; //<S2SV> else if ( Ustrcmp ( argrest , "w" ) == 0 ) arg_error_handling = ERRORS_SENDER ; //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'F' : //<S2SV> if ( * argrest == 0 ) //<S2SV> { //<S2SV> if ( ++ i < argc ) argrest = argv [ i ] ; else //<S2SV> { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> originator_name = argrest ; //<S2SV> sender_name_forced = TRUE ; //<S2SV> break ; //<S2SV> case 'f' : //<S2SV> { //<S2SV> int dummy_start , dummy_end ; //<S2SV> uschar * errmess ; //<S2SV> if ( * argrest == 0 ) //<S2SV> { //<S2SV> if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else //<S2SV> { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> if ( * argrest == 0 ) //<S2SV> sender_address = string_sprintf ( "" ) ; //<S2SV> else //<S2SV> { //<S2SV> uschar * temp = argrest + Ustrlen ( argrest ) - 1 ; //<S2SV> while ( temp >= argrest && isspace ( * temp ) ) temp -- ; //<S2SV> if ( temp >= argrest && * temp == '.' ) f_end_dot = TRUE ; //<S2SV> allow_domain_literals = TRUE ; //<S2SV> strip_trailing_dot = TRUE ; //<S2SV> # ifdef SUPPORT_I18N //<S2SV> allow_utf8_domains = TRUE ; //<S2SV> # endif //<S2SV> sender_address = parse_extract_address ( argrest , & errmess , //<S2SV> & dummy_start , & dummy_end , & sender_address_domain , TRUE ) ; //<S2SV> # ifdef SUPPORT_I18N //<S2SV> message_smtputf8 = string_is_utf8 ( sender_address ) ; //<S2SV> allow_utf8_domains = FALSE ; //<S2SV> # endif //<S2SV> allow_domain_literals = FALSE ; //<S2SV> strip_trailing_dot = FALSE ; //<S2SV> if ( sender_address == NULL ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\"%s\\":<S2SV_blank>%s\\n" , argrest , errmess ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> sender_address_forced = TRUE ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'G' : //<S2SV> flag_G = TRUE ; //<S2SV> break ; //<S2SV> case 'h' : //<S2SV> if ( * argrest == 0 ) //<S2SV> { //<S2SV> if ( ++ i < argc ) argrest = argv [ i ] ; else //<S2SV> { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> if ( ! isdigit ( * argrest ) ) badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'i' : //<S2SV> if ( * argrest == 0 ) dot_ends = FALSE ; else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'L' : //<S2SV> if ( * argrest == '\\0' ) //<S2SV> { //<S2SV> if ( ++ i < argc ) argrest = argv [ i ] ; else //<S2SV> { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> sz = Ustrlen ( argrest ) ; //<S2SV> if ( sz > 32 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\\"%s\\"\\n" , argrest ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( sz < 1 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>the<S2SV_blank>-L<S2SV_blank>syslog<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> cmdline_syslog_name = argrest ; //<S2SV> break ; //<S2SV> case 'M' : //<S2SV> receiving_message = FALSE ; //<S2SV> if ( Ustrcmp ( argrest , "C" ) == 0 ) //<S2SV> { //<S2SV> union sockaddr_46 interface_sock ; //<S2SV> EXIM_SOCKLEN_T size = sizeof ( interface_sock ) ; //<S2SV> if ( argc != i + 6 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>or<S2SV_blank>too<S2SV_blank>few<S2SV_blank>arguments<S2SV_blank>after<S2SV_blank>-MC\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( msg_action_arg >= 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>incompatible<S2SV_blank>arguments\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> continue_transport = argv [ ++ i ] ; //<S2SV> continue_hostname = argv [ ++ i ] ; //<S2SV> continue_host_address = argv [ ++ i ] ; //<S2SV> continue_sequence = Uatoi ( argv [ ++ i ] ) ; //<S2SV> msg_action = MSG_DELIVER ; //<S2SV> msg_action_arg = ++ i ; //<S2SV> forced_delivery = TRUE ; //<S2SV> queue_run_pid = passed_qr_pid ; //<S2SV> queue_run_pipe = passed_qr_pipe ; //<S2SV> if ( ! mac_ismsgid ( argv [ i ] ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option\\n" , //<S2SV> argv [ i ] ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( ! continue_proxy_cipher ) //<S2SV> if ( getsockname ( fileno ( stdin ) , ( struct sockaddr * ) ( & interface_sock ) , //<S2SV> & size ) == 0 ) //<S2SV> sending_ip_address = host_ntoa ( - 1 , & interface_sock , NULL , //<S2SV> & sending_port ) ; //<S2SV> else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>getsockname()<S2SV_blank>failed<S2SV_blank>after<S2SV_blank>-MC<S2SV_blank>option:<S2SV_blank>%s\\n" , //<S2SV> strerror ( errno ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( running_in_test_harness ) millisleep ( 500 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> else if ( * argrest == 'C' && argrest [ 1 ] && ! argrest [ 2 ] ) //<S2SV> { //<S2SV> switch ( argrest [ 1 ] ) //<S2SV> { //<S2SV> case 'A' : smtp_authenticated = TRUE ; break ; //<S2SV> case 'D' : smtp_peer_options |= PEER_OFFERED_DSN ; break ; //<S2SV> case 'G' : if ( ++ i < argc ) queue_name = string_copy ( argv [ i ] ) ; //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'K' : smtp_peer_options |= PEER_OFFERED_CHUNKING ; break ; //<S2SV> case 'P' : smtp_peer_options |= PEER_OFFERED_PIPE ; break ; //<S2SV> case 'Q' : if ( ++ i < argc ) passed_qr_pid = ( pid_t ) ( Uatol ( argv [ i ] ) ) ; //<S2SV> else badarg = TRUE ; //<S2SV> if ( ++ i < argc ) passed_qr_pipe = ( int ) ( Uatol ( argv [ i ] ) ) ; //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'S' : smtp_peer_options |= PEER_OFFERED_SIZE ; break ; //<S2SV> # ifdef SUPPORT_TLS //<S2SV> case 't' : if ( ++ i < argc ) sending_ip_address = argv [ i ] ; //<S2SV> else badarg = TRUE ; //<S2SV> if ( ++ i < argc ) sending_port = ( int ) ( Uatol ( argv [ i ] ) ) ; //<S2SV> else badarg = TRUE ; //<S2SV> if ( ++ i < argc ) continue_proxy_cipher = argv [ i ] ; //<S2SV> else badarg = TRUE ; //<S2SV> case 'T' : smtp_peer_options |= PEER_OFFERED_TLS ; break ; //<S2SV> # endif //<S2SV> default : badarg = TRUE ; break ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> else if ( * argrest == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_DELIVER ; //<S2SV> forced_delivery = deliver_force_thaw = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "ar" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_ADD_RECIPIENT ; //<S2SV> one_msg_action = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "c" ) == 0 ) msg_action = MSG_DELIVER ; //<S2SV> else if ( Ustrcmp ( argrest , "es" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_EDIT_SENDER ; //<S2SV> one_msg_action = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "f" ) == 0 ) msg_action = MSG_FREEZE ; //<S2SV> else if ( Ustrcmp ( argrest , "g" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_DELIVER ; //<S2SV> deliver_give_up = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "mad" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_MARK_ALL_DELIVERED ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "md" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_MARK_DELIVERED ; //<S2SV> one_msg_action = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "rm" ) == 0 ) msg_action = MSG_REMOVE ; //<S2SV> else if ( Ustrcmp ( argrest , "set" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_LOAD ; //<S2SV> one_msg_action = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "t" ) == 0 ) msg_action = MSG_THAW ; //<S2SV> else if ( Ustrcmp ( argrest , "vb" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_SHOW_BODY ; //<S2SV> one_msg_action = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "vc" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_SHOW_COPY ; //<S2SV> one_msg_action = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "vh" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_SHOW_HEADER ; //<S2SV> one_msg_action = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "vl" ) == 0 ) //<S2SV> { //<S2SV> msg_action = MSG_SHOW_LOG ; //<S2SV> one_msg_action = TRUE ; //<S2SV> } //<S2SV> else { badarg = TRUE ; break ; } //<S2SV> msg_action_arg = i + 1 ; //<S2SV> if ( msg_action_arg >= argc ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>no<S2SV_blank>message<S2SV_blank>ids<S2SV_blank>given<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n" , arg ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( ! one_msg_action ) //<S2SV> { //<S2SV> int j ; //<S2SV> for ( j = msg_action_arg ; j < argc ; j ++ ) if ( ! mac_ismsgid ( argv [ j ] ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n" , //<S2SV> argv [ j ] , arg ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> goto END_ARG ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ! mac_ismsgid ( argv [ msg_action_arg ] ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>malformed<S2SV_blank>message<S2SV_blank>id<S2SV_blank>%s<S2SV_blank>after<S2SV_blank>%s<S2SV_blank>option\\n" , //<S2SV> argv [ msg_action_arg ] , arg ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> i ++ ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'm' : //<S2SV> if ( * argrest != 0 ) badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'N' : //<S2SV> if ( * argrest == 0 ) //<S2SV> { //<S2SV> dont_deliver = TRUE ; //<S2SV> debug_selector |= D_v ; //<S2SV> debug_file = stderr ; //<S2SV> } //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'n' : //<S2SV> flag_n = TRUE ; //<S2SV> break ; //<S2SV> case 'O' : //<S2SV> if ( * argrest == 0 ) //<S2SV> { //<S2SV> if ( ++ i >= argc ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-O\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 'o' : //<S2SV> if ( * argrest == 'A' ) //<S2SV> { //<S2SV> alias_arg = argrest + 1 ; //<S2SV> if ( alias_arg [ 0 ] == 0 ) //<S2SV> { //<S2SV> if ( i + 1 < argc ) alias_arg = argv [ ++ i ] ; else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oA\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else if ( * argrest == 'B' ) //<S2SV> { //<S2SV> uschar * p = argrest + 1 ; //<S2SV> if ( p [ 0 ] == 0 ) //<S2SV> { //<S2SV> if ( i + 1 < argc && isdigit ( ( argv [ i + 1 ] [ 0 ] ) ) ) p = argv [ ++ i ] ; else //<S2SV> { //<S2SV> connection_max_messages = 1 ; //<S2SV> p = NULL ; //<S2SV> } //<S2SV> } //<S2SV> if ( p != NULL ) //<S2SV> { //<S2SV> if ( ! isdigit ( * p ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>number<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-oB\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> connection_max_messages = Uatoi ( p ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "db" ) == 0 ) //<S2SV> { //<S2SV> synchronous_delivery = FALSE ; //<S2SV> arg_queue_only = FALSE ; //<S2SV> queue_only_set = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "df" ) == 0 || Ustrcmp ( argrest , "di" ) == 0 ) //<S2SV> { //<S2SV> synchronous_delivery = TRUE ; //<S2SV> arg_queue_only = FALSE ; //<S2SV> queue_only_set = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "dq" ) == 0 ) //<S2SV> { //<S2SV> synchronous_delivery = FALSE ; //<S2SV> arg_queue_only = TRUE ; //<S2SV> queue_only_set = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "dqs" ) == 0 ) //<S2SV> { //<S2SV> queue_smtp = TRUE ; //<S2SV> arg_queue_only = FALSE ; //<S2SV> queue_only_set = TRUE ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "i" ) == 0 || //<S2SV> Ustrcmp ( argrest , "itrue" ) == 0 ) //<S2SV> dot_ends = FALSE ; //<S2SV> else if ( * argrest == 'M' ) //<S2SV> { //<S2SV> if ( i + 1 >= argc ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>data<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-o%s\\n" , argrest ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( Ustrcmp ( argrest , "Ma" ) == 0 ) sender_host_address = argv [ ++ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "Maa" ) == 0 ) //<S2SV> sender_host_authenticated = argv [ ++ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "Mas" ) == 0 ) authenticated_sender = argv [ ++ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "Mai" ) == 0 ) authenticated_id = argv [ ++ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "Mi" ) == 0 ) interface_address = argv [ ++ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "Mm" ) == 0 ) //<S2SV> { //<S2SV> if ( ! mac_ismsgid ( argv [ i + 1 ] ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>message<S2SV_blank>ID\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( ! trusted_config ) //<S2SV> { //<S2SV> fprintf ( stderr , "-oMm<S2SV_blank>must<S2SV_blank>be<S2SV_blank>called<S2SV_blank>by<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user/config\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> message_reference = argv [ ++ i ] ; //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "Mr" ) == 0 ) received_protocol = argv [ ++ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "Ms" ) == 0 ) sender_host_name = argv [ ++ i ] ; //<S2SV> else if ( Ustrcmp ( argrest , "Mt" ) == 0 ) //<S2SV> { //<S2SV> sender_ident_set = TRUE ; //<S2SV> sender_ident = argv [ ++ i ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> badarg = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "m" ) == 0 ) { } //<S2SV> else if ( Ustrcmp ( argrest , "o" ) == 0 ) { } //<S2SV> else if ( Ustrcmp ( argrest , "P" ) == 0 ) //<S2SV> override_pid_file_path = argv [ ++ i ] ; //<S2SV> else if ( * argrest == 'r' || * argrest == 's' ) //<S2SV> { //<S2SV> int * tp = ( * argrest == 'r' ) ? //<S2SV> & arg_receive_timeout : & arg_smtp_receive_timeout ; //<S2SV> if ( argrest [ 1 ] == 0 ) //<S2SV> { //<S2SV> if ( i + 1 < argc ) * tp = readconf_readtime ( argv [ ++ i ] , 0 , FALSE ) ; //<S2SV> } //<S2SV> else * tp = readconf_readtime ( argrest + 1 , 0 , FALSE ) ; //<S2SV> if ( * tp < 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n" , argv [ i ] ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( Ustrcmp ( argrest , "X" ) == 0 ) //<S2SV> override_local_interfaces = argv [ ++ i ] ; //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'p' : //<S2SV> # ifdef EXIM_PERL //<S2SV> if ( * argrest == 's' && argrest [ 1 ] == 0 ) //<S2SV> { //<S2SV> perl_start_option = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( * argrest == 'd' && argrest [ 1 ] == 0 ) //<S2SV> { //<S2SV> perl_start_option = - 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( * argrest == 0 ) //<S2SV> { //<S2SV> if ( i + 1 < argc ) argrest = argv [ ++ i ] ; else //<S2SV> { badarg = TRUE ; break ; } //<S2SV> } //<S2SV> if ( * argrest != 0 ) //<S2SV> { //<S2SV> uschar * hn = Ustrchr ( argrest , ':' ) ; //<S2SV> if ( hn == NULL ) //<S2SV> { //<S2SV> received_protocol = argrest ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int old_pool = store_pool ; //<S2SV> store_pool = POOL_PERM ; //<S2SV> received_protocol = string_copyn ( argrest , hn - argrest ) ; //<S2SV> store_pool = old_pool ; //<S2SV> sender_host_name = hn + 1 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 'q' : //<S2SV> receiving_message = FALSE ; //<S2SV> if ( queue_interval >= 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>-q<S2SV_blank>specified<S2SV_blank>more<S2SV_blank>than<S2SV_blank>once\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( * argrest == 'q' ) //<S2SV> { //<S2SV> queue_2stage = TRUE ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> if ( * argrest == 'i' ) //<S2SV> { //<S2SV> queue_run_first_delivery = TRUE ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> if ( * argrest == 'f' ) //<S2SV> { //<S2SV> queue_run_force = TRUE ; //<S2SV> if ( * ++ argrest == 'f' ) //<S2SV> { //<S2SV> deliver_force_thaw = TRUE ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> } //<S2SV> if ( * argrest == 'l' ) //<S2SV> { //<S2SV> queue_run_local = TRUE ; //<S2SV> argrest ++ ; //<S2SV> } //<S2SV> if ( * argrest == 'G' ) //<S2SV> { //<S2SV> int i ; //<S2SV> for ( argrest ++ , i = 0 ; argrest [ i ] && argrest [ i ] != '/' ; ) i ++ ; //<S2SV> queue_name = string_copyn ( argrest , i ) ; //<S2SV> argrest += i ; //<S2SV> if ( * argrest == '/' ) argrest ++ ; //<S2SV> } //<S2SV> if ( * argrest == 0 && //<S2SV> ( i + 1 >= argc || argv [ i + 1 ] [ 0 ] == '-' || mac_ismsgid ( argv [ i + 1 ] ) ) ) //<S2SV> { //<S2SV> queue_interval = 0 ; //<S2SV> if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) //<S2SV> start_queue_run_id = argv [ ++ i ] ; //<S2SV> if ( i + 1 < argc && mac_ismsgid ( argv [ i + 1 ] ) ) //<S2SV> stop_queue_run_id = argv [ ++ i ] ; //<S2SV> } //<S2SV> else if ( ( queue_interval = readconf_readtime ( * argrest ? argrest : argv [ ++ i ] , //<S2SV> 0 , FALSE ) ) <= 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>bad<S2SV_blank>time<S2SV_blank>value<S2SV_blank>%s:<S2SV_blank>abandoned\\n" , argv [ i ] ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'R' : //<S2SV> receiving_message = FALSE ; //<S2SV> if ( * argrest != 0 ) //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) //<S2SV> if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) //<S2SV> { //<S2SV> if ( i != 2 ) queue_run_force = TRUE ; //<S2SV> if ( i >= 2 ) deliver_selectstring_regex = TRUE ; //<S2SV> if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; //<S2SV> argrest += Ustrlen ( rsopts [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( * argrest ) //<S2SV> deliver_selectstring = argrest ; //<S2SV> else if ( i + 1 < argc ) //<S2SV> deliver_selectstring = argv [ ++ i ] ; //<S2SV> else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-R\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'S' : //<S2SV> receiving_message = FALSE ; //<S2SV> if ( * argrest ) //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < nelem ( rsopts ) ; i ++ ) //<S2SV> if ( Ustrcmp ( argrest , rsopts [ i ] ) == 0 ) //<S2SV> { //<S2SV> if ( i != 2 ) queue_run_force = TRUE ; //<S2SV> if ( i >= 2 ) deliver_selectstring_sender_regex = TRUE ; //<S2SV> if ( i == 1 || i == 4 ) deliver_force_thaw = TRUE ; //<S2SV> argrest += Ustrlen ( rsopts [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( * argrest ) //<S2SV> deliver_selectstring_sender = argrest ; //<S2SV> else if ( i + 1 < argc ) //<S2SV> deliver_selectstring_sender = argv [ ++ i ] ; //<S2SV> else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-S\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'T' : //<S2SV> if ( running_in_test_harness && Ustrcmp ( argrest , "qt" ) == 0 ) //<S2SV> fudged_queue_times = argv [ ++ i ] ; //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 't' : //<S2SV> if ( * argrest == 0 ) extract_recipients = TRUE ; //<S2SV> else if ( Ustrcmp ( argrest , "i" ) == 0 ) //<S2SV> { //<S2SV> extract_recipients = TRUE ; //<S2SV> dot_ends = FALSE ; //<S2SV> } //<S2SV> # ifdef SUPPORT_TLS //<S2SV> else if ( Ustrcmp ( argrest , "ls-on-connect" ) == 0 ) tls_in . on_connect = TRUE ; //<S2SV> # endif //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'U' : //<S2SV> break ; //<S2SV> case 'v' : //<S2SV> if ( * argrest == 0 ) //<S2SV> { //<S2SV> debug_selector |= D_v ; //<S2SV> debug_file = stderr ; //<S2SV> } //<S2SV> else badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'x' : //<S2SV> if ( * argrest != 0 ) badarg = TRUE ; //<S2SV> break ; //<S2SV> case 'X' : //<S2SV> if ( * argrest == '\\0' ) //<S2SV> if ( ++ i >= argc ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>string<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>-X\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case 'z' : //<S2SV> if ( * argrest == '\\0' ) //<S2SV> if ( ++ i < argc ) log_oneline = argv [ i ] ; else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>file<S2SV_blank>name<S2SV_blank>expected<S2SV_blank>after<S2SV_blank>%s\\n" , argv [ i - 1 ] ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> badarg = TRUE ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( badarg ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim<S2SV_blank>abandoned:<S2SV_blank>unknown,<S2SV_blank>malformed,<S2SV_blank>or<S2SV_blank>incomplete<S2SV_blank>" //<S2SV> "option<S2SV_blank>%s\\n" , arg ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( deliver_selectstring || deliver_selectstring_sender ) //<S2SV> && queue_interval < 0 ) //<S2SV> queue_interval = 0 ; //<S2SV> END_ARG : //<S2SV> if ( usage_wanted ) exim_usage ( called_as ) ; //<S2SV> if ( ( //<S2SV> ( smtp_input || extract_recipients || recipients_arg < argc ) && //<S2SV> ( daemon_listen || queue_interval >= 0 || bi_option || //<S2SV> test_retry_arg >= 0 || test_rewrite_arg >= 0 || //<S2SV> filter_test != FTEST_NONE || ( msg_action_arg > 0 && ! one_msg_action ) ) //<S2SV> ) || //<S2SV> ( //<S2SV> msg_action_arg > 0 && //<S2SV> ( daemon_listen || queue_interval > 0 || list_options || //<S2SV> ( checking && msg_action != MSG_LOAD ) || //<S2SV> bi_option || test_retry_arg >= 0 || test_rewrite_arg >= 0 ) //<S2SV> ) || //<S2SV> ( //<S2SV> ( daemon_listen || queue_interval > 0 ) && //<S2SV> ( sender_address != NULL || list_options || list_queue || checking || //<S2SV> bi_option ) //<S2SV> ) || //<S2SV> ( //<S2SV> daemon_listen && queue_interval == 0 //<S2SV> ) || //<S2SV> ( //<S2SV> inetd_wait_mode && queue_interval >= 0 //<S2SV> ) || //<S2SV> ( //<S2SV> list_options && //<S2SV> ( checking || smtp_input || extract_recipients || //<S2SV> filter_test != FTEST_NONE || bi_option ) //<S2SV> ) || //<S2SV> ( //<S2SV> verify_address_mode && //<S2SV> ( address_test_mode || smtp_input || extract_recipients || //<S2SV> filter_test != FTEST_NONE || bi_option ) //<S2SV> ) || //<S2SV> ( //<S2SV> address_test_mode && ( smtp_input || extract_recipients || //<S2SV> filter_test != FTEST_NONE || bi_option ) //<S2SV> ) || //<S2SV> ( //<S2SV> smtp_input && ( sender_address != NULL || filter_test != FTEST_NONE || //<S2SV> extract_recipients ) //<S2SV> ) || //<S2SV> ( //<S2SV> deliver_selectstring != NULL && queue_interval < 0 //<S2SV> ) || //<S2SV> ( //<S2SV> msg_action == MSG_LOAD && //<S2SV> ( ! expansion_test || expansion_test_message != NULL ) //<S2SV> ) //<S2SV> ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>incompatible<S2SV_blank>command-line<S2SV_blank>options<S2SV_blank>or<S2SV_blank>arguments\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( debug_selector != 0 ) //<S2SV> { //<S2SV> debug_file = stderr ; //<S2SV> debug_fd = fileno ( debug_file ) ; //<S2SV> background_daemon = FALSE ; //<S2SV> if ( running_in_test_harness ) millisleep ( 100 ) ; //<S2SV> if ( debug_selector != D_v ) //<S2SV> { //<S2SV> debug_printf ( "Exim<S2SV_blank>version<S2SV_blank>%s<S2SV_blank>uid=%ld<S2SV_blank>gid=%ld<S2SV_blank>pid=%d<S2SV_blank>D=%x\\n" , //<S2SV> version_string , ( long int ) real_uid , ( long int ) real_gid , ( int ) getpid ( ) , //<S2SV> debug_selector ) ; //<S2SV> if ( ! version_printed ) //<S2SV> show_whats_supported ( stderr ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( unprivileged ) //<S2SV> { //<S2SV> DEBUG ( D_any ) debug_print_ids ( US "Exim<S2SV_blank>has<S2SV_blank>no<S2SV_blank>root<S2SV_blank>privilege:" ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> struct rlimit rlp ; //<S2SV> # ifdef RLIMIT_NOFILE //<S2SV> if ( getrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) //<S2SV> { //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC , "getrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s" , //<S2SV> strerror ( errno ) ) ; //<S2SV> rlp . rlim_cur = rlp . rlim_max = 0 ; //<S2SV> } //<S2SV> if ( rlp . rlim_cur < 1000 ) //<S2SV> { //<S2SV> rlp . rlim_cur = rlp . rlim_max = 1000 ; //<S2SV> if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) //<S2SV> { //<S2SV> rlp . rlim_cur = rlp . rlim_max = 256 ; //<S2SV> if ( setrlimit ( RLIMIT_NOFILE , & rlp ) < 0 ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC , "setrlimit(RLIMIT_NOFILE)<S2SV_blank>failed:<S2SV_blank>%s" , //<S2SV> strerror ( errno ) ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef RLIMIT_NPROC //<S2SV> if ( getrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) //<S2SV> { //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC , "getrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s" , //<S2SV> strerror ( errno ) ) ; //<S2SV> rlp . rlim_cur = rlp . rlim_max = 0 ; //<S2SV> } //<S2SV> # ifdef RLIM_INFINITY //<S2SV> if ( rlp . rlim_cur != RLIM_INFINITY && rlp . rlim_cur < 1000 ) //<S2SV> { //<S2SV> rlp . rlim_cur = rlp . rlim_max = RLIM_INFINITY ; //<S2SV> # else //<S2SV> if ( rlp . rlim_cur < 1000 ) //<S2SV> { //<S2SV> rlp . rlim_cur = rlp . rlim_max = 1000 ; //<S2SV> # endif //<S2SV> if ( setrlimit ( RLIMIT_NPROC , & rlp ) < 0 ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC , "setrlimit(RLIMIT_NPROC)<S2SV_blank>failed:<S2SV_blank>%s" , //<S2SV> strerror ( errno ) ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> group_count = getgroups ( NGROUPS_MAX , group_list ) ; //<S2SV> if ( group_count < 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>getgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( setgroups ( 0 , NULL ) != 0 ) //<S2SV> { //<S2SV> if ( setgroups ( 1 , group_list ) != 0 && ! unprivileged ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>setgroups()<S2SV_blank>failed:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( //<S2SV> ( ! trusted_config || //<S2SV> ! macros_trusted ( opt_D_used ) ) && //<S2SV> real_uid != root_uid && //<S2SV> ! running_in_test_harness //<S2SV> ) || //<S2SV> expansion_test //<S2SV> || //<S2SV> filter_test != FTEST_NONE ) //<S2SV> { //<S2SV> setgroups ( group_count , group_list ) ; //<S2SV> exim_setugid ( real_uid , real_gid , FALSE , //<S2SV> US "-C,<S2SV_blank>-D,<S2SV_blank>-be<S2SV_blank>or<S2SV_blank>-bf<S2SV_blank>forces<S2SV_blank>real<S2SV_blank>uid" ) ; //<S2SV> removed_privilege = TRUE ; //<S2SV> if ( ( log_stderr != NULL ) && ( real_uid != exim_uid ) ) //<S2SV> really_exim = FALSE ; //<S2SV> } //<S2SV> else exim_setugid ( geteuid ( ) , getegid ( ) , FALSE , US "forcing<S2SV_blank>real<S2SV_blank>=<S2SV_blank>effective" ) ; //<S2SV> if ( ( filter_test & FTEST_SYSTEM ) != 0 ) //<S2SV> { //<S2SV> filter_sfd = Uopen ( filter_test_sfile , O_RDONLY , 0 ) ; //<S2SV> if ( filter_sfd < 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n" , filter_test_sfile , //<S2SV> strerror ( errno ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( filter_test & FTEST_USER ) != 0 ) //<S2SV> { //<S2SV> filter_ufd = Uopen ( filter_test_ufile , O_RDONLY , 0 ) ; //<S2SV> if ( filter_ufd < 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n" , filter_test_ufile , //<S2SV> strerror ( errno ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> init_lookup_list ( ) ; //<S2SV> # ifdef SUPPORT_I18N //<S2SV> if ( running_in_test_harness ) smtputf8_advertise_hosts = NULL ; //<S2SV> # endif //<S2SV> if ( ( initial_cwd = os_getcwd ( NULL , 0 ) ) == NULL ) //<S2SV> { //<S2SV> perror ( "exim:<S2SV_blank>can\'t<S2SV_blank>get<S2SV_blank>the<S2SV_blank>current<S2SV_blank>working<S2SV_blank>directory" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> readconf_main ( checking || list_options ) ; //<S2SV> if ( builtin_macros_create_trigger ) DEBUG ( D_any ) //<S2SV> debug_printf ( "Builtin<S2SV_blank>macros<S2SV_blank>created<S2SV_blank>(expensive)<S2SV_blank>due<S2SV_blank>to<S2SV_blank>config<S2SV_blank>line<S2SV_blank>\'%.*s\'\\n" , //<S2SV> Ustrlen ( builtin_macros_create_trigger ) - 1 , builtin_macros_create_trigger ) ; //<S2SV> if ( cleanup_environment ( ) == FALSE ) //<S2SV> log_write ( 0 , LOG_PANIC_DIE , "Can\'t<S2SV_blank>cleanup<S2SV_blank>environment" ) ; //<S2SV> if ( real_uid == root_uid || real_uid == exim_uid || real_gid == exim_gid ) //<S2SV> admin_user = TRUE ; //<S2SV> else //<S2SV> { //<S2SV> int i , j ; //<S2SV> for ( i = 0 ; i < group_count && ! admin_user ; i ++ ) //<S2SV> if ( group_list [ i ] == exim_gid ) //<S2SV> admin_user = TRUE ; //<S2SV> else if ( admin_groups ) //<S2SV> for ( j = 1 ; j <= ( int ) admin_groups [ 0 ] && ! admin_user ; j ++ ) //<S2SV> if ( admin_groups [ j ] == group_list [ i ] ) //<S2SV> admin_user = TRUE ; //<S2SV> } //<S2SV> if ( real_uid == root_uid || real_uid == exim_uid ) //<S2SV> trusted_caller = TRUE ; //<S2SV> else //<S2SV> { //<S2SV> int i , j ; //<S2SV> if ( trusted_users ) //<S2SV> for ( i = 1 ; i <= ( int ) trusted_users [ 0 ] && ! trusted_caller ; i ++ ) //<S2SV> if ( trusted_users [ i ] == real_uid ) //<S2SV> trusted_caller = TRUE ; //<S2SV> if ( trusted_groups ) //<S2SV> for ( i = 1 ; i <= ( int ) trusted_groups [ 0 ] && ! trusted_caller ; i ++ ) //<S2SV> if ( trusted_groups [ i ] == real_gid ) //<S2SV> trusted_caller = TRUE ; //<S2SV> else for ( j = 0 ; j < group_count && ! trusted_caller ; j ++ ) //<S2SV> if ( trusted_groups [ i ] == group_list [ j ] ) //<S2SV> trusted_caller = TRUE ; //<S2SV> } //<S2SV> if ( checking && commandline_checks_require_admin && ! admin_user ) { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>those<S2SV_blank>command-line<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>set<S2SV_blank>to<S2SV_blank>require<S2SV_blank>admin\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> decode_bits ( log_selector , log_selector_size , log_notall , //<S2SV> log_selector_string , log_options , log_options_count , US "log" , 0 ) ; //<S2SV> DEBUG ( D_any ) //<S2SV> { //<S2SV> int i ; //<S2SV> debug_printf ( "configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n" , config_main_filename ) ; //<S2SV> debug_printf ( "log<S2SV_blank>selectors<S2SV_blank>=" ) ; //<S2SV> for ( i = 0 ; i < log_selector_size ; i ++ ) //<S2SV> debug_printf ( "<S2SV_blank>%08x" , log_selector [ i ] ) ; //<S2SV> debug_printf ( "\\n" ) ; //<S2SV> } //<S2SV> if ( sender_address != NULL ) //<S2SV> { //<S2SV> if ( sender_address [ sender_address_domain ] == '[' && ! allow_domain_literals ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\"%s\\":<S2SV_blank>domain<S2SV_blank>literals<S2SV_blank>not<S2SV_blank>" //<S2SV> "allowed\\n" , sender_address ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( f_end_dot && ! strip_trailing_dot ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>bad<S2SV_blank>-f<S2SV_blank>address<S2SV_blank>\\"%s.\\":<S2SV_blank>domain<S2SV_blank>is<S2SV_blank>malformed<S2SV_blank>" //<S2SV> "(trailing<S2SV_blank>dot<S2SV_blank>not<S2SV_blank>allowed)\\n" , sender_address ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> if ( cmdline_syslog_name != NULL ) //<S2SV> { //<S2SV> if ( admin_user ) //<S2SV> { //<S2SV> syslog_processname = cmdline_syslog_name ; //<S2SV> log_file_path = string_copy ( CUS "syslog" ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> fprintf ( stderr , //<S2SV> "exim:<S2SV_blank>you<S2SV_blank>lack<S2SV_blank>sufficient<S2SV_blank>privilege<S2SV_blank>to<S2SV_blank>specify<S2SV_blank>syslog<S2SV_blank>process<S2SV_blank>name\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> if ( Ustrlen ( log_file_path ) > 200 ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , //<S2SV> "log_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting" ) ; //<S2SV> if ( Ustrlen ( pid_file_path ) > 200 ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , //<S2SV> "pid_file_path<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting" ) ; //<S2SV> if ( Ustrlen ( spool_directory ) > 200 ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , //<S2SV> "spool_directory<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>200<S2SV_blank>chars:<S2SV_blank>aborting" ) ; //<S2SV> if ( Ustrlen ( syslog_processname ) > 32 ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , //<S2SV> "syslog_processname<S2SV_blank>is<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>32<S2SV_blank>chars:<S2SV_blank>aborting" ) ; //<S2SV> if ( log_oneline ) //<S2SV> if ( admin_user ) //<S2SV> { //<S2SV> log_write ( 0 , LOG_MAIN , "%s" , log_oneline ) ; //<S2SV> return EXIT_SUCCESS ; //<S2SV> } //<S2SV> else //<S2SV> return EXIT_FAILURE ; //<S2SV> # ifdef EXIM_TMPDIR //<S2SV> { //<S2SV> uschar * * p ; //<S2SV> if ( environ ) for ( p = USS environ ; * p ; p ++ ) //<S2SV> if ( Ustrncmp ( * p , "TMPDIR=" , 7 ) == 0 && Ustrcmp ( * p + 7 , EXIM_TMPDIR ) != 0 ) //<S2SV> { //<S2SV> uschar * newp = store_malloc ( Ustrlen ( EXIM_TMPDIR ) + 8 ) ; //<S2SV> sprintf ( CS newp , "TMPDIR=%s" , EXIM_TMPDIR ) ; //<S2SV> * p = newp ; //<S2SV> DEBUG ( D_any ) debug_printf ( "reset<S2SV_blank>TMPDIR=%s<S2SV_blank>in<S2SV_blank>environment\\n" , EXIM_TMPDIR ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( timezone_string && strcmpic ( timezone_string , US "UTC" ) == 0 ) //<S2SV> timestamps_utc = TRUE ; //<S2SV> else //<S2SV> { //<S2SV> uschar * envtz = US getenv ( "TZ" ) ; //<S2SV> if ( envtz //<S2SV> ? ! timezone_string || Ustrcmp ( timezone_string , envtz ) != 0 //<S2SV> : timezone_string != NULL //<S2SV> ) //<S2SV> { //<S2SV> uschar * * p = USS environ ; //<S2SV> uschar * * new ; //<S2SV> uschar * * newp ; //<S2SV> int count = 0 ; //<S2SV> if ( environ ) while ( * p ++ ) count ++ ; //<S2SV> if ( ! envtz ) count ++ ; //<S2SV> newp = new = store_malloc ( sizeof ( uschar * ) * ( count + 1 ) ) ; //<S2SV> if ( environ ) for ( p = USS environ ; * p ; p ++ ) //<S2SV> if ( Ustrncmp ( * p , "TZ=" , 3 ) != 0 ) * newp ++ = * p ; //<S2SV> if ( timezone_string ) //<S2SV> { //<S2SV> * newp = store_malloc ( Ustrlen ( timezone_string ) + 4 ) ; //<S2SV> sprintf ( CS * newp ++ , "TZ=%s" , timezone_string ) ; //<S2SV> } //<S2SV> * newp = NULL ; //<S2SV> environ = CSS new ; //<S2SV> tzset ( ) ; //<S2SV> DEBUG ( D_any ) debug_printf ( "Reset<S2SV_blank>TZ<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s\\n" , timezone_string , //<S2SV> tod_stamp ( tod_log ) ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( removed_privilege //<S2SV> && ( ! trusted_config || opt_D_used ) //<S2SV> && real_uid == exim_uid ) //<S2SV> if ( deliver_drop_privilege ) //<S2SV> really_exim = TRUE ; //<S2SV> else //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC , //<S2SV> "exim<S2SV_blank>user<S2SV_blank>lost<S2SV_blank>privilege<S2SV_blank>for<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>option" , //<S2SV> trusted_config ? "-D" : "-C" ) ; //<S2SV> # ifdef EXIM_PERL //<S2SV> if ( perl_start_option != 0 ) //<S2SV> opt_perl_at_start = ( perl_start_option > 0 ) ; //<S2SV> if ( opt_perl_at_start && opt_perl_startup != NULL ) //<S2SV> { //<S2SV> uschar * errstr ; //<S2SV> DEBUG ( D_any ) debug_printf ( "Starting<S2SV_blank>Perl<S2SV_blank>interpreter\\n" ) ; //<S2SV> errstr = init_perl ( opt_perl_startup ) ; //<S2SV> if ( errstr != NULL ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>error<S2SV_blank>in<S2SV_blank>perl_startup<S2SV_blank>code:<S2SV_blank>%s\\n" , errstr ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> opt_perl_started = TRUE ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ( ( debug_selector & D_any ) != 0 || LOGGING ( arguments ) ) //<S2SV> && really_exim && ! list_options && ! checking ) //<S2SV> { //<S2SV> int i ; //<S2SV> uschar * p = big_buffer ; //<S2SV> Ustrcpy ( p , "cwd=<S2SV_blank>(failed)" ) ; //<S2SV> Ustrncpy ( p + 4 , initial_cwd , big_buffer_size - 5 ) ; //<S2SV> while ( * p ) p ++ ; //<S2SV> ( void ) string_format ( p , big_buffer_size - ( p - big_buffer ) , "<S2SV_blank>%d<S2SV_blank>args:" , argc ) ; //<S2SV> while ( * p ) p ++ ; //<S2SV> for ( i = 0 ; i < argc ; i ++ ) //<S2SV> { //<S2SV> int len = Ustrlen ( argv [ i ] ) ; //<S2SV> const uschar * printing ; //<S2SV> uschar * quote ; //<S2SV> if ( p + len + 8 >= big_buffer + big_buffer_size ) //<S2SV> { //<S2SV> Ustrcpy ( p , "<S2SV_blank>..." ) ; //<S2SV> log_write ( 0 , LOG_MAIN , "%s" , big_buffer ) ; //<S2SV> Ustrcpy ( big_buffer , "..." ) ; //<S2SV> p = big_buffer + 3 ; //<S2SV> } //<S2SV> printing = string_printing ( argv [ i ] ) ; //<S2SV> if ( printing [ 0 ] == 0 ) quote = US "\\"" ; else //<S2SV> { //<S2SV> const uschar * pp = printing ; //<S2SV> quote = US "" ; //<S2SV> while ( * pp != 0 ) if ( isspace ( * pp ++ ) ) { quote = US "\\"" ; break ; } //<S2SV> } //<S2SV> sprintf ( CS p , "<S2SV_blank>%s%.*s%s" , quote , ( int ) ( big_buffer_size - //<S2SV> ( p - big_buffer ) - 4 ) , printing , quote ) ; //<S2SV> while ( * p ) p ++ ; //<S2SV> } //<S2SV> if ( LOGGING ( arguments ) ) //<S2SV> log_write ( 0 , LOG_MAIN , "%s" , big_buffer ) ; //<S2SV> else //<S2SV> debug_printf ( "%s\\n" , big_buffer ) ; //<S2SV> } //<S2SV> if ( Uchdir ( spool_directory ) != 0 ) //<S2SV> { //<S2SV> int dummy ; //<S2SV> ( void ) directory_make ( spool_directory , US "" , SPOOL_DIRECTORY_MODE , FALSE ) ; //<S2SV> dummy = Uchdir ( spool_directory ) ; //<S2SV> } //<S2SV> if ( bi_option ) //<S2SV> { //<S2SV> ( void ) fclose ( config_file ) ; //<S2SV> if ( bi_command != NULL ) //<S2SV> { //<S2SV> int i = 0 ; //<S2SV> uschar * argv [ 3 ] ; //<S2SV> argv [ i ++ ] = bi_command ; //<S2SV> if ( alias_arg != NULL ) argv [ i ++ ] = alias_arg ; //<S2SV> argv [ i ++ ] = NULL ; //<S2SV> setgroups ( group_count , group_list ) ; //<S2SV> exim_setugid ( real_uid , real_gid , FALSE , US "running<S2SV_blank>bi_command" ) ; //<S2SV> DEBUG ( D_exec ) debug_printf ( "exec<S2SV_blank>%.256s<S2SV_blank>%.256s\\n" , argv [ 0 ] , //<S2SV> ( argv [ 1 ] == NULL ) ? US "" : argv [ 1 ] ) ; //<S2SV> execv ( CS argv [ 0 ] , ( char * const * ) argv ) ; //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>exec<S2SV_blank>failed:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> DEBUG ( D_any ) debug_printf ( "-bi<S2SV_blank>used<S2SV_blank>but<S2SV_blank>bi_command<S2SV_blank>not<S2SV_blank>set;<S2SV_blank>exiting\\n" ) ; //<S2SV> exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( trusted_caller ) DEBUG ( D_any ) debug_printf ( "trusted<S2SV_blank>user\\n" ) ; //<S2SV> if ( admin_user ) DEBUG ( D_any ) debug_printf ( "admin<S2SV_blank>user\\n" ) ; //<S2SV> if ( ! admin_user ) //<S2SV> { //<S2SV> BOOL debugset = ( debug_selector & ~ D_v ) != 0 ; //<S2SV> if ( deliver_give_up || daemon_listen || malware_test_file || //<S2SV> ( count_queue && queue_list_requires_admin ) || //<S2SV> ( list_queue && queue_list_requires_admin ) || //<S2SV> ( queue_interval >= 0 && prod_requires_admin ) || //<S2SV> ( debugset && ! running_in_test_harness ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:%s<S2SV_blank>permission<S2SV_blank>denied\\n" , debugset ? "<S2SV_blank>debugging" : "" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( real_uid != root_uid && real_uid != exim_uid && //<S2SV> ( continue_hostname != NULL || //<S2SV> ( dont_deliver && //<S2SV> ( queue_interval >= 0 || daemon_listen || msg_action_arg > 0 ) //<S2SV> ) ) && ! running_in_test_harness ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>Permission<S2SV_blank>denied\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( ! trusted_caller && ! checking ) //<S2SV> { //<S2SV> sender_host_name = sender_host_address = interface_address = //<S2SV> sender_ident = received_protocol = NULL ; //<S2SV> sender_host_port = interface_port = 0 ; //<S2SV> sender_host_authenticated = authenticated_sender = authenticated_id = NULL ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( sender_host_address != NULL ) //<S2SV> sender_host_port = check_port ( sender_host_address ) ; //<S2SV> if ( interface_address != NULL ) //<S2SV> interface_port = check_port ( interface_address ) ; //<S2SV> } //<S2SV> if ( flag_G ) //<S2SV> { //<S2SV> if ( trusted_caller ) //<S2SV> { //<S2SV> suppress_local_fixups = suppress_local_fixups_default = TRUE ; //<S2SV> DEBUG ( D_acl ) debug_printf ( "suppress_local_fixups<S2SV_blank>forced<S2SV_blank>on<S2SV_blank>by<S2SV_blank>-G\\n" ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>permission<S2SV_blank>denied<S2SV_blank>(-G<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>trusted<S2SV_blank>user)\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> if ( smtp_input ) //<S2SV> { //<S2SV> union sockaddr_46 inetd_sock ; //<S2SV> EXIM_SOCKLEN_T size = sizeof ( inetd_sock ) ; //<S2SV> if ( getpeername ( 0 , ( struct sockaddr * ) ( & inetd_sock ) , & size ) == 0 ) //<S2SV> { //<S2SV> int family = ( ( struct sockaddr * ) ( & inetd_sock ) ) -> sa_family ; //<S2SV> if ( family == AF_INET || family == AF_INET6 ) //<S2SV> { //<S2SV> union sockaddr_46 interface_sock ; //<S2SV> size = sizeof ( interface_sock ) ; //<S2SV> if ( getsockname ( 0 , ( struct sockaddr * ) ( & interface_sock ) , & size ) == 0 ) //<S2SV> interface_address = host_ntoa ( - 1 , & interface_sock , NULL , //<S2SV> & interface_port ) ; //<S2SV> if ( host_is_tls_on_connect_port ( interface_port ) ) tls_in . on_connect = TRUE ; //<S2SV> if ( real_uid == root_uid || real_uid == exim_uid || interface_port < 1024 ) //<S2SV> { //<S2SV> is_inetd = TRUE ; //<S2SV> sender_host_address = host_ntoa ( - 1 , ( struct sockaddr * ) ( & inetd_sock ) , //<S2SV> NULL , & sender_host_port ) ; //<S2SV> if ( mua_wrapper ) log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , "Input<S2SV_blank>from<S2SV_blank>" //<S2SV> "inetd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set" ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> fprintf ( stderr , //<S2SV> "exim:<S2SV_blank>Permission<S2SV_blank>denied<S2SV_blank>(unprivileged<S2SV_blank>user,<S2SV_blank>unprivileged<S2SV_blank>port)\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # ifdef LOAD_AVG_NEEDS_ROOT //<S2SV> if ( receiving_message && //<S2SV> ( queue_only_load >= 0 || //<S2SV> ( is_inetd && smtp_load_reserve >= 0 ) //<S2SV> ) ) //<S2SV> { //<S2SV> load_average = OS_GETLOADAVG ( ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( queue_only_set && ( queue_only_override || arg_queue_only ) ) //<S2SV> queue_only = arg_queue_only ; //<S2SV> if ( arg_receive_timeout >= 0 ) receive_timeout = arg_receive_timeout ; //<S2SV> if ( arg_smtp_receive_timeout >= 0 ) //<S2SV> smtp_receive_timeout = arg_smtp_receive_timeout ; //<S2SV> if ( ! unprivileged && //<S2SV> ! removed_privilege && //<S2SV> ! daemon_listen && //<S2SV> queue_interval <= 0 && //<S2SV> ( //<S2SV> deliver_drop_privilege || //<S2SV> ( //<S2SV> queue_interval < 0 && //<S2SV> ( msg_action_arg < 0 || //<S2SV> msg_action != MSG_DELIVER ) && //<S2SV> ( ! checking || ! address_test_mode ) //<S2SV> ) ) ) //<S2SV> exim_setugid ( exim_uid , exim_gid , TRUE , US "privilege<S2SV_blank>not<S2SV_blank>needed" ) ; //<S2SV> else //<S2SV> { //<S2SV> int rv ; //<S2SV> rv = setgid ( exim_gid ) ; //<S2SV> if ( rv == - 1 ) //<S2SV> if ( ! ( unprivileged || removed_privilege ) ) //<S2SV> { //<S2SV> fprintf ( stderr , //<S2SV> "exim:<S2SV_blank>changing<S2SV_blank>group<S2SV_blank>failed:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> else //<S2SV> DEBUG ( D_any ) debug_printf ( "changing<S2SV_blank>group<S2SV_blank>to<S2SV_blank>%ld<S2SV_blank>failed:<S2SV_blank>%s\\n" , //<S2SV> ( long int ) exim_gid , strerror ( errno ) ) ; //<S2SV> } //<S2SV> if ( malware_test_file ) //<S2SV> { //<S2SV> # ifdef WITH_CONTENT_SCAN //<S2SV> int result ; //<S2SV> set_process_info ( "scanning<S2SV_blank>file<S2SV_blank>for<S2SV_blank>malware" ) ; //<S2SV> result = malware_in_file ( malware_test_file ) ; //<S2SV> if ( result == FAIL ) //<S2SV> { //<S2SV> printf ( "No<S2SV_blank>malware<S2SV_blank>found.\\n" ) ; //<S2SV> exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( result != OK ) //<S2SV> { //<S2SV> printf ( "Malware<S2SV_blank>lookup<S2SV_blank>returned<S2SV_blank>non-okay/fail:<S2SV_blank>%d\\n" , result ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( malware_name ) //<S2SV> printf ( "Malware<S2SV_blank>found:<S2SV_blank>%s\\n" , malware_name ) ; //<S2SV> else //<S2SV> printf ( "Malware<S2SV_blank>scan<S2SV_blank>detected<S2SV_blank>malware<S2SV_blank>of<S2SV_blank>unknown<S2SV_blank>name.\\n" ) ; //<S2SV> # else //<S2SV> printf ( "Malware<S2SV_blank>scanning<S2SV_blank>not<S2SV_blank>enabled<S2SV_blank>at<S2SV_blank>compile<S2SV_blank>time.\\n" ) ; //<S2SV> # endif //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( list_queue ) //<S2SV> { //<S2SV> set_process_info ( "listing<S2SV_blank>the<S2SV_blank>queue" ) ; //<S2SV> queue_list ( list_queue_option , argv + recipients_arg , argc - recipients_arg ) ; //<S2SV> exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( count_queue ) //<S2SV> { //<S2SV> set_process_info ( "counting<S2SV_blank>the<S2SV_blank>queue" ) ; //<S2SV> queue_count ( ) ; //<S2SV> exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( msg_action_arg > 0 && msg_action != MSG_DELIVER && msg_action != MSG_LOAD ) //<S2SV> { //<S2SV> int yield = EXIT_SUCCESS ; //<S2SV> set_process_info ( "acting<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>messages" ) ; //<S2SV> if ( ! one_msg_action ) //<S2SV> { //<S2SV> for ( i = msg_action_arg ; i < argc ; i ++ ) //<S2SV> if ( ! queue_action ( argv [ i ] , msg_action , NULL , 0 , 0 ) ) //<S2SV> yield = EXIT_FAILURE ; //<S2SV> } //<S2SV> else if ( ! queue_action ( argv [ msg_action_arg ] , msg_action , argv , argc , //<S2SV> recipients_arg ) ) yield = EXIT_FAILURE ; //<S2SV> exit ( yield ) ; //<S2SV> } //<S2SV> readconf_rest ( ) ; //<S2SV> store_pool = POOL_MAIN ; //<S2SV> if ( test_retry_arg >= 0 ) //<S2SV> { //<S2SV> retry_config * yield ; //<S2SV> int basic_errno = 0 ; //<S2SV> int more_errno = 0 ; //<S2SV> uschar * s1 , * s2 ; //<S2SV> if ( test_retry_arg >= argc ) //<S2SV> { //<S2SV> printf ( "-brt<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>domain<S2SV_blank>or<S2SV_blank>address<S2SV_blank>argument\\n" ) ; //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> s1 = argv [ test_retry_arg ++ ] ; //<S2SV> s2 = NULL ; //<S2SV> if ( Ustrchr ( s1 , '@' ) == NULL && Ustrchr ( s1 , '.' ) == NULL ) //<S2SV> { //<S2SV> printf ( "Warning:<S2SV_blank>\\"%s\\"<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\'@\'<S2SV_blank>and<S2SV_blank>no<S2SV_blank>\'.\'<S2SV_blank>characters.<S2SV_blank>It<S2SV_blank>is<S2SV_blank>" //<S2SV> "being<S2SV_blank>\\ntreated<S2SV_blank>as<S2SV_blank>a<S2SV_blank>one-component<S2SV_blank>domain,<S2SV_blank>not<S2SV_blank>as<S2SV_blank>a<S2SV_blank>local<S2SV_blank>part.\\n\\n" , //<S2SV> s1 ) ; //<S2SV> } //<S2SV> if ( test_retry_arg < argc && Ustrchr ( argv [ test_retry_arg ] , '.' ) != NULL ) //<S2SV> s2 = argv [ test_retry_arg ++ ] ; //<S2SV> if ( test_retry_arg < argc ) //<S2SV> { //<S2SV> uschar * ss = argv [ test_retry_arg ] ; //<S2SV> uschar * error = //<S2SV> readconf_retry_error ( ss , ss + Ustrlen ( ss ) , & basic_errno , & more_errno ) ; //<S2SV> if ( error != NULL ) //<S2SV> { //<S2SV> printf ( "%s\\n" , CS error ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( basic_errno == ERRNO_MAIL4XX || //<S2SV> basic_errno == ERRNO_RCPT4XX || //<S2SV> basic_errno == ERRNO_DATA4XX ) //<S2SV> { //<S2SV> int code = ( more_errno >> 8 ) & 255 ; //<S2SV> if ( code == 255 ) //<S2SV> more_errno = ( more_errno & 0xffff00ff ) | ( 21 << 8 ) ; //<S2SV> else if ( code > 100 ) //<S2SV> more_errno = ( more_errno & 0xffff00ff ) | ( ( code - 96 ) << 8 ) ; //<S2SV> } //<S2SV> } //<S2SV> yield = retry_find_config ( s1 , s2 , basic_errno , more_errno ) ; //<S2SV> if ( yield == NULL ) printf ( "No<S2SV_blank>retry<S2SV_blank>information<S2SV_blank>found\\n" ) ; else //<S2SV> { //<S2SV> retry_rule * r ; //<S2SV> more_errno = yield -> more_errno ; //<S2SV> printf ( "Retry<S2SV_blank>rule:<S2SV_blank>%s<S2SV_blank><S2SV_blank>" , yield -> pattern ) ; //<S2SV> if ( yield -> basic_errno == ERRNO_EXIMQUOTA ) //<S2SV> { //<S2SV> printf ( "quota%s%s<S2SV_blank><S2SV_blank>" , //<S2SV> ( more_errno > 0 ) ? "_" : "" , //<S2SV> ( more_errno > 0 ) ? readconf_printtime ( more_errno ) : US "" ) ; //<S2SV> } //<S2SV> else if ( yield -> basic_errno == ECONNREFUSED ) //<S2SV> { //<S2SV> printf ( "refused%s%s<S2SV_blank><S2SV_blank>" , //<S2SV> ( more_errno > 0 ) ? "_" : "" , //<S2SV> ( more_errno == 'M' ) ? "MX" : //<S2SV> ( more_errno == 'A' ) ? "A" : "" ) ; //<S2SV> } //<S2SV> else if ( yield -> basic_errno == ETIMEDOUT ) //<S2SV> { //<S2SV> printf ( "timeout" ) ; //<S2SV> if ( ( more_errno & RTEF_CTOUT ) != 0 ) printf ( "_connect" ) ; //<S2SV> more_errno &= 255 ; //<S2SV> if ( more_errno != 0 ) printf ( "_%s" , //<S2SV> ( more_errno == 'M' ) ? "MX" : "A" ) ; //<S2SV> printf ( "<S2SV_blank><S2SV_blank>" ) ; //<S2SV> } //<S2SV> else if ( yield -> basic_errno == ERRNO_AUTHFAIL ) //<S2SV> printf ( "auth_failed<S2SV_blank><S2SV_blank>" ) ; //<S2SV> else printf ( "*<S2SV_blank><S2SV_blank>" ) ; //<S2SV> for ( r = yield -> rules ; r != NULL ; r = r -> next ) //<S2SV> { //<S2SV> printf ( "%c,%s" , r -> rule , readconf_printtime ( r -> timeout ) ) ; //<S2SV> printf ( ",%s" , readconf_printtime ( r -> p1 ) ) ; //<S2SV> if ( r -> rule == 'G' ) //<S2SV> { //<S2SV> int x = r -> p2 ; //<S2SV> int f = x % 1000 ; //<S2SV> int d = 100 ; //<S2SV> printf ( ",%d." , x / 1000 ) ; //<S2SV> do //<S2SV> { //<S2SV> printf ( "%d" , f / d ) ; //<S2SV> f %= d ; //<S2SV> d /= 10 ; //<S2SV> } //<S2SV> while ( f != 0 ) ; //<S2SV> } //<S2SV> printf ( ";<S2SV_blank>" ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( list_options ) //<S2SV> { //<S2SV> set_process_info ( "listing<S2SV_blank>variables" ) ; //<S2SV> if ( recipients_arg >= argc ) readconf_print ( US "all" , NULL , flag_n ) ; //<S2SV> else for ( i = recipients_arg ; i < argc ; i ++ ) //<S2SV> { //<S2SV> if ( i < argc - 1 && //<S2SV> ( Ustrcmp ( argv [ i ] , "router" ) == 0 || //<S2SV> Ustrcmp ( argv [ i ] , "transport" ) == 0 || //<S2SV> Ustrcmp ( argv [ i ] , "authenticator" ) == 0 || //<S2SV> Ustrcmp ( argv [ i ] , "macro" ) == 0 || //<S2SV> Ustrcmp ( argv [ i ] , "environment" ) == 0 ) ) //<S2SV> { //<S2SV> readconf_print ( argv [ i + 1 ] , argv [ i ] , flag_n ) ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> else readconf_print ( argv [ i ] , NULL , flag_n ) ; //<S2SV> } //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( list_config ) //<S2SV> { //<S2SV> set_process_info ( "listing<S2SV_blank>config" ) ; //<S2SV> readconf_print ( US "config" , NULL , flag_n ) ; //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> # ifndef DISABLE_DKIM //<S2SV> dkim_exim_init ( ) ; //<S2SV> # endif //<S2SV> deliver_init ( ) ; //<S2SV> if ( msg_action_arg > 0 && msg_action != MSG_LOAD ) //<S2SV> { //<S2SV> if ( prod_requires_admin && ! admin_user ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>Permission<S2SV_blank>denied\\n" ) ; //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> set_process_info ( "delivering<S2SV_blank>specified<S2SV_blank>messages" ) ; //<S2SV> if ( deliver_give_up ) forced_delivery = deliver_force_thaw = TRUE ; //<S2SV> for ( i = msg_action_arg ; i < argc ; i ++ ) //<S2SV> { //<S2SV> int status ; //<S2SV> pid_t pid ; //<S2SV> if ( i == argc - 1 ) //<S2SV> ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; //<S2SV> else if ( ( pid = fork ( ) ) == 0 ) //<S2SV> { //<S2SV> ( void ) deliver_message ( argv [ i ] , forced_delivery , deliver_give_up ) ; //<S2SV> _exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> else if ( pid < 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>delivery<S2SV_blank>process<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s\\n" , argv [ i ] , //<S2SV> strerror ( errno ) ) ; //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> else wait ( & status ) ; //<S2SV> } //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( queue_interval == 0 && ! daemon_listen ) //<S2SV> { //<S2SV> DEBUG ( D_queue_run ) debug_printf ( "Single<S2SV_blank>queue<S2SV_blank>run%s%s%s%s\\n" , //<S2SV> ( start_queue_run_id == NULL ) ? US "" : US "<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>" , //<S2SV> ( start_queue_run_id == NULL ) ? US "" : start_queue_run_id , //<S2SV> ( stop_queue_run_id == NULL ) ? US "" : US "<S2SV_blank>stopping<S2SV_blank>at<S2SV_blank>" , //<S2SV> ( stop_queue_run_id == NULL ) ? US "" : stop_queue_run_id ) ; //<S2SV> if ( * queue_name ) //<S2SV> set_process_info ( "running<S2SV_blank>the<S2SV_blank>\'%s\'<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)" , queue_name ) ; //<S2SV> else //<S2SV> set_process_info ( "running<S2SV_blank>the<S2SV_blank>queue<S2SV_blank>(single<S2SV_blank>queue<S2SV_blank>run)" ) ; //<S2SV> queue_run ( start_queue_run_id , stop_queue_run_id , FALSE ) ; //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> for ( i = 0 ; ; ) //<S2SV> { //<S2SV> if ( ( pw = getpwuid ( real_uid ) ) != NULL ) //<S2SV> { //<S2SV> originator_login = string_copy ( US pw -> pw_name ) ; //<S2SV> originator_home = string_copy ( US pw -> pw_dir ) ; //<S2SV> if ( originator_name == NULL ) //<S2SV> { //<S2SV> if ( sender_address == NULL || //<S2SV> ( ! trusted_caller && filter_test == FTEST_NONE ) ) //<S2SV> { //<S2SV> uschar * name = US pw -> pw_gecos ; //<S2SV> uschar * amp = Ustrchr ( name , '&' ) ; //<S2SV> uschar buffer [ 256 ] ; //<S2SV> if ( amp != NULL ) //<S2SV> { //<S2SV> int loffset ; //<S2SV> string_format ( buffer , sizeof ( buffer ) , "%.*s%n%s%s" , //<S2SV> amp - name , name , & loffset , originator_login , amp + 1 ) ; //<S2SV> buffer [ loffset ] = toupper ( buffer [ loffset ] ) ; //<S2SV> name = buffer ; //<S2SV> } //<S2SV> if ( gecos_pattern != NULL && gecos_name != NULL ) //<S2SV> { //<S2SV> const pcre * re ; //<S2SV> re = regex_must_compile ( gecos_pattern , FALSE , TRUE ) ; //<S2SV> if ( regex_match_and_setup ( re , name , 0 , - 1 ) ) //<S2SV> { //<S2SV> uschar * new_name = expand_string ( gecos_name ) ; //<S2SV> expand_nmax = - 1 ; //<S2SV> if ( new_name != NULL ) //<S2SV> { //<S2SV> DEBUG ( D_receive ) debug_printf ( "user<S2SV_blank>name<S2SV_blank>\\"%s\\"<S2SV_blank>extracted<S2SV_blank>from<S2SV_blank>" //<S2SV> "gecos<S2SV_blank>field<S2SV_blank>\\"%s\\"\\n" , new_name , name ) ; //<S2SV> name = new_name ; //<S2SV> } //<S2SV> else DEBUG ( D_receive ) debug_printf ( "failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>gecos_name<S2SV_blank>string<S2SV_blank>" //<S2SV> "\\"%s\\":<S2SV_blank>%s\\n" , gecos_name , expand_string_message ) ; //<S2SV> } //<S2SV> else DEBUG ( D_receive ) debug_printf ( "gecos_pattern<S2SV_blank>\\"%s\\"<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>" //<S2SV> "gecos<S2SV_blank>field<S2SV_blank>\\"%s\\"\\n" , gecos_pattern , name ) ; //<S2SV> store_free ( ( void * ) re ) ; //<S2SV> } //<S2SV> originator_name = string_copy ( name ) ; //<S2SV> } //<S2SV> else originator_name = US "" ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> if ( ++ i > finduser_retries ) break ; //<S2SV> sleep ( 1 ) ; //<S2SV> } //<S2SV> if ( originator_login == NULL || running_in_test_harness ) //<S2SV> { //<S2SV> if ( unknown_login != NULL ) //<S2SV> { //<S2SV> originator_login = expand_string ( unknown_login ) ; //<S2SV> if ( originator_name == NULL && unknown_username != NULL ) //<S2SV> originator_name = expand_string ( unknown_username ) ; //<S2SV> if ( originator_name == NULL ) originator_name = US "" ; //<S2SV> } //<S2SV> if ( originator_login == NULL ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>user<S2SV_blank>name<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%d" , //<S2SV> ( int ) real_uid ) ; //<S2SV> } //<S2SV> originator_name = string_copy ( parse_fix_phrase ( originator_name , //<S2SV> Ustrlen ( originator_name ) , big_buffer , big_buffer_size ) ) ; //<S2SV> originator_uid = real_uid ; //<S2SV> originator_gid = real_gid ; //<S2SV> DEBUG ( D_receive ) debug_printf ( "originator:<S2SV_blank>uid=%d<S2SV_blank>gid=%d<S2SV_blank>login=%s<S2SV_blank>name=%s\\n" , //<S2SV> ( int ) originator_uid , ( int ) originator_gid , originator_login , originator_name ) ; //<S2SV> if ( daemon_listen || inetd_wait_mode || queue_interval > 0 ) //<S2SV> { //<S2SV> if ( mua_wrapper ) //<S2SV> { //<S2SV> fprintf ( stderr , "Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>mua_wrapper<S2SV_blank>is<S2SV_blank>set\\n" ) ; //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , "Daemon<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>run<S2SV_blank>when<S2SV_blank>" //<S2SV> "mua_wrapper<S2SV_blank>is<S2SV_blank>set" ) ; //<S2SV> } //<S2SV> daemon_go ( ) ; //<S2SV> } //<S2SV> if ( sender_ident == NULL ) sender_ident = originator_login ; //<S2SV> else if ( sender_ident [ 0 ] == 0 ) sender_ident = NULL ; //<S2SV> if ( test_rewrite_arg >= 0 ) //<S2SV> { //<S2SV> really_exim = FALSE ; //<S2SV> if ( test_rewrite_arg >= argc ) //<S2SV> { //<S2SV> printf ( "-brw<S2SV_blank>needs<S2SV_blank>an<S2SV_blank>address<S2SV_blank>argument\\n" ) ; //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> rewrite_test ( argv [ test_rewrite_arg ] ) ; //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( ( sender_address == NULL && ! smtp_input ) || //<S2SV> ( ! trusted_caller && filter_test == FTEST_NONE ) ) //<S2SV> { //<S2SV> sender_local = TRUE ; //<S2SV> if ( authenticated_sender == NULL && ! host_checking ) //<S2SV> authenticated_sender = string_sprintf ( "%s@%s" , originator_login , //<S2SV> qualify_domain_sender ) ; //<S2SV> if ( authenticated_id == NULL && ! host_checking ) //<S2SV> authenticated_id = originator_login ; //<S2SV> } //<S2SV> if ( ( ! smtp_input && sender_address == NULL ) || //<S2SV> ! receive_check_set_sender ( sender_address ) ) //<S2SV> { //<S2SV> if ( sender_address == NULL //<S2SV> || //<S2SV> ( sender_address [ 0 ] != 0 && //<S2SV> ! checking ) ) //<S2SV> { //<S2SV> sender_address = originator_login ; //<S2SV> sender_address_forced = FALSE ; //<S2SV> sender_address_domain = 0 ; //<S2SV> } //<S2SV> } //<S2SV> sender_set_untrusted = sender_address != originator_login && ! trusted_caller ; //<S2SV> if ( sender_address != NULL && sender_address [ 0 ] != 0 && //<S2SV> sender_address_domain == 0 ) //<S2SV> sender_address = string_sprintf ( "%s@%s" , local_part_quote ( sender_address ) , //<S2SV> qualify_domain_sender ) ; //<S2SV> DEBUG ( D_receive ) debug_printf ( "sender<S2SV_blank>address<S2SV_blank>=<S2SV_blank>%s\\n" , sender_address ) ; //<S2SV> if ( verify_address_mode || address_test_mode ) //<S2SV> { //<S2SV> int exit_value = 0 ; //<S2SV> int flags = vopt_qualify ; //<S2SV> if ( verify_address_mode ) //<S2SV> { //<S2SV> if ( ! verify_as_sender ) flags |= vopt_is_recipient ; //<S2SV> DEBUG ( D_verify ) debug_print_ids ( US "Verifying:" ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> flags |= vopt_is_recipient ; //<S2SV> debug_selector |= D_v ; //<S2SV> debug_file = stderr ; //<S2SV> debug_fd = fileno ( debug_file ) ; //<S2SV> DEBUG ( D_verify ) debug_print_ids ( US "Address<S2SV_blank>testing:" ) ; //<S2SV> } //<S2SV> if ( recipients_arg < argc ) //<S2SV> { //<S2SV> while ( recipients_arg < argc ) //<S2SV> { //<S2SV> uschar * s = argv [ recipients_arg ++ ] ; //<S2SV> while ( * s != 0 ) //<S2SV> { //<S2SV> BOOL finished = FALSE ; //<S2SV> uschar * ss = parse_find_address_end ( s , FALSE ) ; //<S2SV> if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; //<S2SV> test_address ( s , flags , & exit_value ) ; //<S2SV> s = ss ; //<S2SV> if ( ! finished ) //<S2SV> while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else for ( ; ; ) //<S2SV> { //<S2SV> uschar * s = get_stdinput ( NULL , NULL ) ; //<S2SV> if ( s == NULL ) break ; //<S2SV> test_address ( s , flags , & exit_value ) ; //<S2SV> } //<S2SV> route_tidyup ( ) ; //<S2SV> exim_exit ( exit_value ) ; //<S2SV> } //<S2SV> if ( expansion_test ) //<S2SV> { //<S2SV> dns_init ( FALSE , FALSE , FALSE ) ; //<S2SV> if ( msg_action_arg > 0 && msg_action == MSG_LOAD ) //<S2SV> { //<S2SV> uschar spoolname [ 256 ] ; //<S2SV> if ( ! admin_user ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>permission<S2SV_blank>denied\\n" ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> message_id = argv [ msg_action_arg ] ; //<S2SV> ( void ) string_format ( spoolname , sizeof ( spoolname ) , "%s-H" , message_id ) ; //<S2SV> if ( ( deliver_datafile = spool_open_datafile ( message_id ) ) < 0 ) //<S2SV> printf ( "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>datafile<S2SV_blank>%s\\n" , message_id ) ; //<S2SV> if ( spool_read_header ( spoolname , TRUE , FALSE ) != spool_read_OK ) //<S2SV> printf ( "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>message<S2SV_blank>%s\\n" , message_id ) ; //<S2SV> } //<S2SV> else if ( expansion_test_message != NULL ) //<S2SV> { //<S2SV> int save_stdin = dup ( 0 ) ; //<S2SV> int fd = Uopen ( expansion_test_message , O_RDONLY , 0 ) ; //<S2SV> if ( fd < 0 ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s\\n" , expansion_test_message , //<S2SV> strerror ( errno ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> ( void ) dup2 ( fd , 0 ) ; //<S2SV> filter_test = FTEST_USER ; //<S2SV> message_ended = END_NOTENDED ; //<S2SV> read_message_body ( receive_msg ( extract_recipients ) ) ; //<S2SV> message_linecount += body_linecount ; //<S2SV> ( void ) dup2 ( save_stdin , 0 ) ; //<S2SV> ( void ) close ( save_stdin ) ; //<S2SV> clearerr ( stdin ) ; //<S2SV> } //<S2SV> enable_dollar_recipients = TRUE ; //<S2SV> if ( recipients_arg < argc ) //<S2SV> { //<S2SV> while ( recipients_arg < argc ) //<S2SV> { //<S2SV> uschar * s = argv [ recipients_arg ++ ] ; //<S2SV> uschar * ss = expand_string ( s ) ; //<S2SV> if ( ss == NULL ) printf ( "Failed:<S2SV_blank>%s\\n" , expand_string_message ) ; //<S2SV> else printf ( "%s\\n" , CS ss ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> char * ( * fn_readline ) ( const char * ) = NULL ; //<S2SV> void ( * fn_addhist ) ( const char * ) = NULL ; //<S2SV> # ifdef USE_READLINE //<S2SV> void * dlhandle = set_readline ( & fn_readline , & fn_addhist ) ; //<S2SV> # endif //<S2SV> for ( ; ; ) //<S2SV> { //<S2SV> uschar * ss ; //<S2SV> uschar * source = get_stdinput ( fn_readline , fn_addhist ) ; //<S2SV> if ( source == NULL ) break ; //<S2SV> ss = expand_string ( source ) ; //<S2SV> if ( ss == NULL ) //<S2SV> printf ( "Failed:<S2SV_blank>%s\\n" , expand_string_message ) ; //<S2SV> else printf ( "%s\\n" , CS ss ) ; //<S2SV> } //<S2SV> # ifdef USE_READLINE //<S2SV> if ( dlhandle != NULL ) dlclose ( dlhandle ) ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( deliver_datafile >= 0 ) //<S2SV> { //<S2SV> ( void ) close ( deliver_datafile ) ; //<S2SV> deliver_datafile = - 1 ; //<S2SV> } //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> smtp_active_hostname = primary_hostname ; //<S2SV> if ( raw_active_hostname != NULL ) //<S2SV> { //<S2SV> uschar * nah = expand_string ( raw_active_hostname ) ; //<S2SV> if ( nah == NULL ) //<S2SV> { //<S2SV> if ( ! expand_string_forcedfail ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , "failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>\\"%s\\"<S2SV_blank>" //<S2SV> "(smtp_active_hostname):<S2SV_blank>%s" , raw_active_hostname , //<S2SV> expand_string_message ) ; //<S2SV> } //<S2SV> else if ( nah [ 0 ] != 0 ) smtp_active_hostname = nah ; //<S2SV> } //<S2SV> if ( host_checking ) //<S2SV> { //<S2SV> int x [ 4 ] ; //<S2SV> int size ; //<S2SV> if ( ! sender_ident_set ) //<S2SV> { //<S2SV> sender_ident = NULL ; //<S2SV> if ( running_in_test_harness && sender_host_port != 0 && //<S2SV> interface_address != NULL && interface_port != 0 ) //<S2SV> verify_get_ident ( 1413 ) ; //<S2SV> } //<S2SV> size = host_aton ( sender_host_address , x ) ; //<S2SV> sender_host_address = store_get ( 48 ) ; //<S2SV> ( void ) host_nmtoa ( size , x , - 1 , sender_host_address , ':' ) ; //<S2SV> host_build_sender_fullhost ( ) ; //<S2SV> smtp_input = TRUE ; //<S2SV> smtp_in = stdin ; //<S2SV> smtp_out = stdout ; //<S2SV> sender_local = FALSE ; //<S2SV> sender_host_notsocket = TRUE ; //<S2SV> debug_file = stderr ; //<S2SV> debug_fd = fileno ( debug_file ) ; //<S2SV> fprintf ( stdout , "\\n****<S2SV_blank>SMTP<S2SV_blank>testing<S2SV_blank>session<S2SV_blank>as<S2SV_blank>if<S2SV_blank>from<S2SV_blank>host<S2SV_blank>%s\\n" //<S2SV> "****<S2SV_blank>but<S2SV_blank>without<S2SV_blank>any<S2SV_blank>ident<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>callback.\\n" //<S2SV> "****<S2SV_blank>This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>for<S2SV_blank>real!\\n\\n" , //<S2SV> sender_host_address ) ; //<S2SV> memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; //<S2SV> if ( verify_check_host ( & hosts_connection_nolog ) == OK ) //<S2SV> BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; //<S2SV> log_write ( L_smtp_connection , LOG_MAIN , "%s" , smtp_get_connection_info ( ) ) ; //<S2SV> if ( smtp_start_session ( ) ) //<S2SV> { //<S2SV> for ( reset_point = store_get ( 0 ) ; ; store_reset ( reset_point ) ) //<S2SV> { //<S2SV> if ( smtp_setup_msg ( ) <= 0 ) break ; //<S2SV> if ( ! receive_msg ( FALSE ) ) break ; //<S2SV> return_path = sender_address = NULL ; //<S2SV> dnslist_domain = dnslist_matched = NULL ; //<S2SV> # ifndef DISABLE_DKIM //<S2SV> dkim_cur_signer = NULL ; //<S2SV> # endif //<S2SV> acl_var_m = NULL ; //<S2SV> deliver_localpart_orig = NULL ; //<S2SV> deliver_domain_orig = NULL ; //<S2SV> callout_address = sending_ip_address = NULL ; //<S2SV> sender_rate = sender_rate_limit = sender_rate_period = NULL ; //<S2SV> } //<S2SV> smtp_log_no_mail ( ) ; //<S2SV> } //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( recipients_arg >= argc && ! extract_recipients && ! smtp_input ) //<S2SV> { //<S2SV> if ( version_printed ) //<S2SV> { //<S2SV> printf ( "Configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>%s\\n" , config_main_filename ) ; //<S2SV> return EXIT_SUCCESS ; //<S2SV> } //<S2SV> if ( info_flag != CMDINFO_NONE ) //<S2SV> { //<S2SV> show_exim_information ( info_flag , info_stdout ? stdout : stderr ) ; //<S2SV> return info_stdout ? EXIT_SUCCESS : EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( filter_test == FTEST_NONE ) //<S2SV> exim_usage ( called_as ) ; //<S2SV> } //<S2SV> if ( mua_wrapper ) //<S2SV> { //<S2SV> synchronous_delivery = TRUE ; //<S2SV> arg_error_handling = ERRORS_STDERR ; //<S2SV> remote_max_parallel = 1 ; //<S2SV> deliver_drop_privilege = TRUE ; //<S2SV> queue_smtp = FALSE ; //<S2SV> queue_smtp_domains = NULL ; //<S2SV> # ifdef SUPPORT_I18N //<S2SV> message_utf8_downconvert = - 1 ; //<S2SV> # endif //<S2SV> } //<S2SV> if ( ! smtp_input ) error_handling = arg_error_handling ; //<S2SV> else if ( is_inetd ) //<S2SV> { //<S2SV> ( void ) fclose ( stderr ) ; //<S2SV> exim_nullstd ( ) ; //<S2SV> verify_get_ident ( IDENT_PORT ) ; //<S2SV> host_build_sender_fullhost ( ) ; //<S2SV> set_process_info ( "handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>inetd" , //<S2SV> sender_fullhost ) ; //<S2SV> } //<S2SV> if ( sender_host_address != NULL && sender_fullhost == NULL ) //<S2SV> { //<S2SV> host_build_sender_fullhost ( ) ; //<S2SV> set_process_info ( "handling<S2SV_blank>incoming<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>via<S2SV_blank>-oMa" , //<S2SV> sender_fullhost ) ; //<S2SV> sender_host_notsocket = TRUE ; //<S2SV> } //<S2SV> else if ( ! is_inetd ) sender_host_unknown = TRUE ; //<S2SV> if ( fstat ( 1 , & statbuf ) < 0 ) ( void ) dup2 ( 0 , 1 ) ; //<S2SV> if ( smtp_input ) //<S2SV> { //<S2SV> if ( ! is_inetd ) set_process_info ( "accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>%sSMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>" , //<S2SV> smtp_batched_input ? "batched<S2SV_blank>" : "" , //<S2SV> ( sender_address != NULL ) ? sender_address : originator_login ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int old_pool = store_pool ; //<S2SV> store_pool = POOL_PERM ; //<S2SV> if ( ! received_protocol ) //<S2SV> received_protocol = string_sprintf ( "local%s" , called_as ) ; //<S2SV> store_pool = old_pool ; //<S2SV> set_process_info ( "accepting<S2SV_blank>a<S2SV_blank>local<S2SV_blank>non-SMTP<S2SV_blank>message<S2SV_blank>from<S2SV_blank><%s>" , //<S2SV> sender_address ) ; //<S2SV> } //<S2SV> queue_check_only ( ) ; //<S2SV> session_local_queue_only = queue_only ; //<S2SV> if ( ( ! smtp_input || smtp_batched_input ) && ! receive_check_fs ( 0 ) ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>insufficient<S2SV_blank>disk<S2SV_blank>space\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( smtp_input ) //<S2SV> { //<S2SV> smtp_in = stdin ; //<S2SV> smtp_out = stdout ; //<S2SV> memset ( sender_host_cache , 0 , sizeof ( sender_host_cache ) ) ; //<S2SV> if ( verify_check_host ( & hosts_connection_nolog ) == OK ) //<S2SV> BIT_CLEAR ( log_selector , log_selector_size , Li_smtp_connection ) ; //<S2SV> log_write ( L_smtp_connection , LOG_MAIN , "%s" , smtp_get_connection_info ( ) ) ; //<S2SV> if ( ! smtp_start_session ( ) ) //<S2SV> { //<S2SV> mac_smtp_fflush ( ) ; //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> thismessage_size_limit = expand_string_integer ( message_size_limit , TRUE ) ; //<S2SV> if ( expand_string_message ) //<S2SV> if ( thismessage_size_limit == - 1 ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , "failed<S2SV_blank>to<S2SV_blank>expand<S2SV_blank>" //<S2SV> "message_size_limit:<S2SV_blank>%s" , expand_string_message ) ; //<S2SV> else //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC_DIE , "invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>" //<S2SV> "message_size_limit:<S2SV_blank>%s" , expand_string_message ) ; //<S2SV> } //<S2SV> if ( ! synchronous_delivery ) //<S2SV> { //<S2SV> # ifdef SA_NOCLDWAIT //<S2SV> struct sigaction act ; //<S2SV> act . sa_handler = SIG_IGN ; //<S2SV> sigemptyset ( & ( act . sa_mask ) ) ; //<S2SV> act . sa_flags = SA_NOCLDWAIT ; //<S2SV> sigaction ( SIGCHLD , & act , NULL ) ; //<S2SV> # else //<S2SV> signal ( SIGCHLD , SIG_IGN ) ; //<S2SV> # endif //<S2SV> } //<S2SV> reset_point = store_get ( 0 ) ; //<S2SV> real_sender_address = sender_address ; //<S2SV> while ( more ) //<S2SV> { //<S2SV> message_id [ 0 ] = 0 ; //<S2SV> if ( smtp_input ) //<S2SV> { //<S2SV> int rc ; //<S2SV> if ( ( rc = smtp_setup_msg ( ) ) > 0 ) //<S2SV> { //<S2SV> if ( real_sender_address != NULL && //<S2SV> ! receive_check_set_sender ( sender_address ) ) //<S2SV> { //<S2SV> sender_address = raw_sender = real_sender_address ; //<S2SV> sender_address_unrewritten = NULL ; //<S2SV> } //<S2SV> if ( smtp_batched_input && acl_not_smtp_start != NULL ) //<S2SV> { //<S2SV> uschar * user_msg , * log_msg ; //<S2SV> enable_dollar_recipients = TRUE ; //<S2SV> ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , //<S2SV> & user_msg , & log_msg ) ; //<S2SV> enable_dollar_recipients = FALSE ; //<S2SV> } //<S2SV> more = receive_msg ( extract_recipients ) ; //<S2SV> if ( message_id [ 0 ] == 0 ) //<S2SV> { //<S2SV> cancel_cutthrough_connection ( TRUE , US "receive<S2SV_blank>dropped" ) ; //<S2SV> if ( more ) goto moreloop ; //<S2SV> smtp_log_no_mail ( ) ; //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cancel_cutthrough_connection ( TRUE , US "message<S2SV_blank>setup<S2SV_blank>dropped" ) ; //<S2SV> smtp_log_no_mail ( ) ; //<S2SV> exim_exit ( ( rc == 0 ) ? EXIT_SUCCESS : EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int i ; //<S2SV> int rcount = 0 ; //<S2SV> int count = argc - recipients_arg ; //<S2SV> uschar * * list = argv + recipients_arg ; //<S2SV> active_local_sender_retain = local_sender_retain ; //<S2SV> active_local_from_check = local_from_check ; //<S2SV> raw_sender = string_copy ( sender_address ) ; //<S2SV> for ( i = 0 ; i < count ; i ++ ) //<S2SV> { //<S2SV> int start , end , domain ; //<S2SV> uschar * errmess ; //<S2SV> uschar * s = list [ i ] ; //<S2SV> while ( * s != 0 ) //<S2SV> { //<S2SV> BOOL finished = FALSE ; //<S2SV> uschar * recipient ; //<S2SV> uschar * ss = parse_find_address_end ( s , FALSE ) ; //<S2SV> if ( * ss == ',' ) * ss = 0 ; else finished = TRUE ; //<S2SV> if ( recipients_max > 0 && ++ rcount > recipients_max && //<S2SV> ! extract_recipients ) //<S2SV> if ( error_handling == ERRORS_STDERR ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>recipients\\n" ) ; //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> return //<S2SV> moan_to_sender ( ERRMESS_TOOMANYRECIP , NULL , NULL , stdin , TRUE ) ? //<S2SV> errors_sender_rc : EXIT_FAILURE ; //<S2SV> } //<S2SV> # ifdef SUPPORT_I18N //<S2SV> { //<S2SV> BOOL b = allow_utf8_domains ; //<S2SV> allow_utf8_domains = TRUE ; //<S2SV> # endif //<S2SV> recipient = //<S2SV> parse_extract_address ( s , & errmess , & start , & end , & domain , FALSE ) ; //<S2SV> # ifdef SUPPORT_I18N //<S2SV> if ( string_is_utf8 ( recipient ) ) //<S2SV> message_smtputf8 = TRUE ; //<S2SV> else //<S2SV> allow_utf8_domains = b ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( domain == 0 && ! allow_unqualified_recipient ) //<S2SV> { //<S2SV> recipient = NULL ; //<S2SV> errmess = US "unqualified<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>not<S2SV_blank>allowed" ; //<S2SV> } //<S2SV> if ( recipient == NULL ) //<S2SV> { //<S2SV> if ( error_handling == ERRORS_STDERR ) //<S2SV> { //<S2SV> fprintf ( stderr , "exim:<S2SV_blank>bad<S2SV_blank>recipient<S2SV_blank>address<S2SV_blank>\\"%s\\":<S2SV_blank>%s\\n" , //<S2SV> string_printing ( list [ i ] ) , errmess ) ; //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> error_block eblock ; //<S2SV> eblock . next = NULL ; //<S2SV> eblock . text1 = string_printing ( list [ i ] ) ; //<S2SV> eblock . text2 = errmess ; //<S2SV> return //<S2SV> moan_to_sender ( ERRMESS_BADARGADDRESS , & eblock , NULL , stdin , TRUE ) ? //<S2SV> errors_sender_rc : EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> receive_add_recipient ( recipient , - 1 ) ; //<S2SV> s = ss ; //<S2SV> if ( ! finished ) //<S2SV> while ( * ( ++ s ) != 0 && ( * s == ',' || isspace ( * s ) ) ) ; //<S2SV> } //<S2SV> } //<S2SV> DEBUG ( D_receive ) //<S2SV> { //<S2SV> int i ; //<S2SV> if ( sender_address != NULL ) debug_printf ( "Sender:<S2SV_blank>%s\\n" , sender_address ) ; //<S2SV> if ( recipients_list != NULL ) //<S2SV> { //<S2SV> debug_printf ( "Recipients:\\n" ) ; //<S2SV> for ( i = 0 ; i < recipients_count ; i ++ ) //<S2SV> debug_printf ( "<S2SV_blank><S2SV_blank>%s\\n" , recipients_list [ i ] . address ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( acl_not_smtp_start ) //<S2SV> { //<S2SV> uschar * user_msg , * log_msg ; //<S2SV> enable_dollar_recipients = TRUE ; //<S2SV> ( void ) acl_check ( ACL_WHERE_NOTSMTP_START , NULL , acl_not_smtp_start , //<S2SV> & user_msg , & log_msg ) ; //<S2SV> enable_dollar_recipients = FALSE ; //<S2SV> } //<S2SV> if ( ! receive_timeout ) //<S2SV> { //<S2SV> struct timeval t = { 30 * 60 , 0 } ; //<S2SV> fd_set r ; //<S2SV> FD_ZERO ( & r ) ; FD_SET ( 0 , & r ) ; //<S2SV> if ( select ( 1 , & r , NULL , NULL , & t ) == 0 ) mainlog_close ( ) ; //<S2SV> } //<S2SV> message_ended = END_NOTENDED ; //<S2SV> more = receive_msg ( extract_recipients ) ; //<S2SV> if ( message_id [ 0 ] == 0 ) exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( filter_test != FTEST_NONE ) //<S2SV> { //<S2SV> deliver_domain = ( ftest_domain != NULL ) ? //<S2SV> ftest_domain : qualify_domain_recipient ; //<S2SV> deliver_domain_orig = deliver_domain ; //<S2SV> deliver_localpart = ( ftest_localpart != NULL ) ? //<S2SV> ftest_localpart : originator_login ; //<S2SV> deliver_localpart_orig = deliver_localpart ; //<S2SV> deliver_localpart_prefix = ftest_prefix ; //<S2SV> deliver_localpart_suffix = ftest_suffix ; //<S2SV> deliver_home = originator_home ; //<S2SV> if ( return_path == NULL ) //<S2SV> { //<S2SV> printf ( "Return-path<S2SV_blank>copied<S2SV_blank>from<S2SV_blank>sender\\n" ) ; //<S2SV> return_path = string_copy ( sender_address ) ; //<S2SV> } //<S2SV> else //<S2SV> printf ( "Return-path<S2SV_blank>=<S2SV_blank>%s\\n" , ( return_path [ 0 ] == 0 ) ? US "<>" : return_path ) ; //<S2SV> printf ( "Sender<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n" , ( sender_address [ 0 ] == 0 ) ? US "<>" : sender_address ) ; //<S2SV> receive_add_recipient ( //<S2SV> string_sprintf ( "%s%s%s@%s" , //<S2SV> ( ftest_prefix == NULL ) ? US "" : ftest_prefix , //<S2SV> deliver_localpart , //<S2SV> ( ftest_suffix == NULL ) ? US "" : ftest_suffix , //<S2SV> deliver_domain ) , - 1 ) ; //<S2SV> printf ( "Recipient<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n" , recipients_list [ 0 ] . address ) ; //<S2SV> if ( ftest_prefix != NULL ) printf ( "Prefix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n" , ftest_prefix ) ; //<S2SV> if ( ftest_suffix != NULL ) printf ( "Suffix<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%s\\n" , ftest_suffix ) ; //<S2SV> if ( chdir ( "/" ) ) //<S2SV> { //<S2SV> DEBUG ( D_receive ) debug_printf ( "chdir(\\"/\\")<S2SV_blank>failed\\n" ) ; //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( ( filter_test & FTEST_SYSTEM ) != 0 ) //<S2SV> { //<S2SV> if ( ! filter_runtest ( filter_sfd , filter_test_sfile , TRUE , more ) ) //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> memcpy ( filter_sn , filter_n , sizeof ( filter_sn ) ) ; //<S2SV> if ( ( filter_test & FTEST_USER ) != 0 ) //<S2SV> { //<S2SV> if ( ! filter_runtest ( filter_ufd , filter_test_ufile , FALSE , more ) ) //<S2SV> exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> } //<S2SV> if ( ! session_local_queue_only && //<S2SV> smtp_accept_queue_per_connection > 0 && //<S2SV> receive_messagecount > smtp_accept_queue_per_connection ) //<S2SV> { //<S2SV> session_local_queue_only = TRUE ; //<S2SV> queue_only_reason = 2 ; //<S2SV> } //<S2SV> local_queue_only = session_local_queue_only ; //<S2SV> if ( ! local_queue_only && queue_only_load >= 0 ) //<S2SV> { //<S2SV> local_queue_only = ( load_average = OS_GETLOADAVG ( ) ) > queue_only_load ; //<S2SV> if ( local_queue_only ) //<S2SV> { //<S2SV> queue_only_reason = 3 ; //<S2SV> if ( queue_only_load_latch ) session_local_queue_only = TRUE ; //<S2SV> } //<S2SV> } //<S2SV> if ( mua_wrapper ) //<S2SV> local_queue_only = queue_only_policy = deliver_freeze = FALSE ; //<S2SV> if ( local_queue_only ) //<S2SV> { //<S2SV> cancel_cutthrough_connection ( TRUE , US "no<S2SV_blank>delivery;<S2SV_blank>queueing" ) ; //<S2SV> switch ( queue_only_reason ) //<S2SV> { //<S2SV> case 2 : //<S2SV> log_write ( L_delay_delivery , //<S2SV> LOG_MAIN , "no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>messages<S2SV_blank>" //<S2SV> "received<S2SV_blank>in<S2SV_blank>one<S2SV_blank>connection" , smtp_accept_queue_per_connection ) ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> log_write ( L_delay_delivery , //<S2SV> LOG_MAIN , "no<S2SV_blank>immediate<S2SV_blank>delivery:<S2SV_blank>load<S2SV_blank>average<S2SV_blank>%.2f" , //<S2SV> ( double ) load_average / 1000.0 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else if ( queue_only_policy || deliver_freeze ) //<S2SV> cancel_cutthrough_connection ( TRUE , US "no<S2SV_blank>delivery;<S2SV_blank>queueing" ) ; //<S2SV> else //<S2SV> { //<S2SV> pid_t pid ; //<S2SV> search_tidyup ( ) ; //<S2SV> if ( ( pid = fork ( ) ) == 0 ) //<S2SV> { //<S2SV> int rc ; //<S2SV> close_unwanted ( ) ; //<S2SV> exim_nullstd ( ) ; //<S2SV> if ( geteuid ( ) != root_uid && ! deliver_drop_privilege && ! unprivileged ) //<S2SV> { //<S2SV> delivery_re_exec ( CEE_EXEC_EXIT ) ; //<S2SV> } //<S2SV> rc = deliver_message ( message_id , FALSE , FALSE ) ; //<S2SV> search_tidyup ( ) ; //<S2SV> _exit ( ( ! mua_wrapper || rc == DELIVER_MUA_SUCCEEDED ) ? //<S2SV> EXIT_SUCCESS : EXIT_FAILURE ) ; //<S2SV> } //<S2SV> if ( pid < 0 ) //<S2SV> { //<S2SV> cancel_cutthrough_connection ( TRUE , US "delivery<S2SV_blank>fork<S2SV_blank>failed" ) ; //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC , "failed<S2SV_blank>to<S2SV_blank>fork<S2SV_blank>automatic<S2SV_blank>delivery<S2SV_blank>" //<S2SV> "process:<S2SV_blank>%s" , strerror ( errno ) ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> release_cutthrough_connection ( US "msg<S2SV_blank>passed<S2SV_blank>for<S2SV_blank>delivery" ) ; //<S2SV> if ( synchronous_delivery ) //<S2SV> { //<S2SV> int status ; //<S2SV> while ( wait ( & status ) != pid ) ; //<S2SV> if ( ( status & 0x00ff ) != 0 ) //<S2SV> log_write ( 0 , LOG_MAIN | LOG_PANIC , //<S2SV> "process<S2SV_blank>%d<S2SV_blank>crashed<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d<S2SV_blank>while<S2SV_blank>delivering<S2SV_blank>%s" , //<S2SV> ( int ) pid , status & 0x00ff , message_id ) ; //<S2SV> if ( mua_wrapper && ( status & 0xffff ) != 0 ) exim_exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # ifndef SIG_IGN_WORKS //<S2SV> while ( waitpid ( - 1 , NULL , WNOHANG ) > 0 ) ; //<S2SV> # endif //<S2SV> moreloop : //<S2SV> return_path = sender_address = NULL ; //<S2SV> authenticated_sender = NULL ; //<S2SV> deliver_localpart_orig = NULL ; //<S2SV> deliver_domain_orig = NULL ; //<S2SV> deliver_host = deliver_host_address = NULL ; //<S2SV> dnslist_domain = dnslist_matched = NULL ; //<S2SV> # ifdef WITH_CONTENT_SCAN //<S2SV> malware_name = NULL ; //<S2SV> # endif //<S2SV> callout_address = NULL ; //<S2SV> sending_ip_address = NULL ; //<S2SV> acl_var_m = NULL ; //<S2SV> { int i ; for ( i = 0 ; i < REGEX_VARS ; i ++ ) regex_vars [ i ] = NULL ; } //<S2SV> store_reset ( reset_point ) ; //<S2SV> } //<S2SV> exim_exit ( EXIT_SUCCESS ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 