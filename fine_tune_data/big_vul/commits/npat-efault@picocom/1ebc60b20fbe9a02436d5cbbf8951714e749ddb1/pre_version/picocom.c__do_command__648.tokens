int //<S2SV> do_command ( unsigned char c ) //<S2SV> { //<S2SV> static int dtr_up = 0 ; //<S2SV> int newbaud , newflow , newparity , newbits ; //<S2SV> const char * xfr_cmd ; //<S2SV> char * fname ; //<S2SV> int r ; //<S2SV> switch ( c ) { //<S2SV> case KEY_EXIT : //<S2SV> return 1 ; //<S2SV> case KEY_QUIT : //<S2SV> term_set_hupcl ( tty_fd , 0 ) ; //<S2SV> term_flush ( tty_fd ) ; //<S2SV> term_apply ( tty_fd ) ; //<S2SV> term_erase ( tty_fd ) ; //<S2SV> return 1 ; //<S2SV> case KEY_STATUS : //<S2SV> show_status ( dtr_up ) ; //<S2SV> break ; //<S2SV> case KEY_PULSE : //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>pulse<S2SV_blank>DTR<S2SV_blank>***\\r\\n" ) ; //<S2SV> if ( term_pulse_dtr ( tty_fd ) < 0 ) //<S2SV> fd_printf ( STO , "***<S2SV_blank>FAILED\\r\\n" ) ; //<S2SV> break ; //<S2SV> case KEY_TOGGLE : //<S2SV> if ( dtr_up ) //<S2SV> r = term_lower_dtr ( tty_fd ) ; //<S2SV> else //<S2SV> r = term_raise_dtr ( tty_fd ) ; //<S2SV> if ( r >= 0 ) dtr_up = ! dtr_up ; //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>DTR:<S2SV_blank>%s<S2SV_blank>***\\r\\n" , //<S2SV> dtr_up ? "up" : "down" ) ; //<S2SV> break ; //<S2SV> case KEY_BAUD_UP : //<S2SV> case KEY_BAUD_DN : //<S2SV> if ( c == KEY_BAUD_UP ) //<S2SV> opts . baud = baud_up ( opts . baud ) ; //<S2SV> else //<S2SV> opts . baud = baud_down ( opts . baud ) ; //<S2SV> term_set_baudrate ( tty_fd , opts . baud ) ; //<S2SV> tty_q . len = 0 ; term_flush ( tty_fd ) ; //<S2SV> term_apply ( tty_fd ) ; //<S2SV> newbaud = term_get_baudrate ( tty_fd , NULL ) ; //<S2SV> if ( opts . baud != newbaud ) { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>baud:<S2SV_blank>%d<S2SV_blank>(%d)<S2SV_blank>***\\r\\n" , //<S2SV> opts . baud , newbaud ) ; //<S2SV> } else { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>baud:<S2SV_blank>%d<S2SV_blank>***\\r\\n" , opts . baud ) ; //<S2SV> } //<S2SV> set_tty_write_sz ( newbaud ) ; //<S2SV> break ; //<S2SV> case KEY_FLOW : //<S2SV> opts . flow = flow_next ( opts . flow ) ; //<S2SV> term_set_flowcntrl ( tty_fd , opts . flow ) ; //<S2SV> tty_q . len = 0 ; term_flush ( tty_fd ) ; //<S2SV> term_apply ( tty_fd ) ; //<S2SV> newflow = term_get_flowcntrl ( tty_fd ) ; //<S2SV> if ( opts . flow != newflow ) { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>flow:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>***\\r\\n" , //<S2SV> flow_str [ opts . flow ] , flow_str [ newflow ] ) ; //<S2SV> } else { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>flow:<S2SV_blank>%s<S2SV_blank>***\\r\\n" , //<S2SV> flow_str [ opts . flow ] ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case KEY_PARITY : //<S2SV> opts . parity = parity_next ( opts . parity ) ; //<S2SV> term_set_parity ( tty_fd , opts . parity ) ; //<S2SV> tty_q . len = 0 ; term_flush ( tty_fd ) ; //<S2SV> term_apply ( tty_fd ) ; //<S2SV> newparity = term_get_parity ( tty_fd ) ; //<S2SV> if ( opts . parity != newparity ) { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>parity:<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>***\\r\\n" , //<S2SV> parity_str [ opts . parity ] , //<S2SV> parity_str [ newparity ] ) ; //<S2SV> } else { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>parity:<S2SV_blank>%s<S2SV_blank>***\\r\\n" , //<S2SV> parity_str [ opts . parity ] ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case KEY_BITS : //<S2SV> opts . databits = bits_next ( opts . databits ) ; //<S2SV> term_set_databits ( tty_fd , opts . databits ) ; //<S2SV> tty_q . len = 0 ; term_flush ( tty_fd ) ; //<S2SV> term_apply ( tty_fd ) ; //<S2SV> newbits = term_get_databits ( tty_fd ) ; //<S2SV> if ( opts . databits != newbits ) { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>databits:<S2SV_blank>%d<S2SV_blank>(%d)<S2SV_blank>***\\r\\n" , //<S2SV> opts . databits , newbits ) ; //<S2SV> } else { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>databits:<S2SV_blank>%d<S2SV_blank>***\\r\\n" , //<S2SV> opts . databits ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case KEY_LECHO : //<S2SV> opts . lecho = ! opts . lecho ; //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>local<S2SV_blank>echo:<S2SV_blank>%s<S2SV_blank>***\\r\\n" , //<S2SV> opts . lecho ? "yes" : "no" ) ; //<S2SV> break ; //<S2SV> case KEY_SEND : //<S2SV> case KEY_RECEIVE : //<S2SV> xfr_cmd = ( c == KEY_SEND ) ? opts . send_cmd : opts . receive_cmd ; //<S2SV> if ( xfr_cmd [ 0 ] == '\\0' ) { //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>command<S2SV_blank>disabled<S2SV_blank>***\\r\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> fname = read_filename ( ) ; //<S2SV> if ( fname == NULL ) { //<S2SV> fd_printf ( STO , "***<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>filename<S2SV_blank>***\\r\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> run_cmd ( tty_fd , xfr_cmd , fname , NULL ) ; //<S2SV> free ( fname ) ; //<S2SV> break ; //<S2SV> case KEY_BREAK : //<S2SV> term_break ( tty_fd ) ; //<S2SV> fd_printf ( STO , "\\r\\n***<S2SV_blank>break<S2SV_blank>sent<S2SV_blank>***\\r\\n" ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 