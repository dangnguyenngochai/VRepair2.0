void ihevcd_parse_sei_payload ( codec_t * ps_codec , //<S2SV> UWORD32 u4_payload_type , //<S2SV> UWORD32 u4_payload_size , //<S2SV> WORD8 i1_nal_type ) //<S2SV> { //<S2SV> parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; //<S2SV> bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; //<S2SV> WORD32 payload_bits_remaining = 0 ; //<S2SV> sps_t * ps_sps ; //<S2SV> UWORD32 i ; //<S2SV> for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) //<S2SV> { //<S2SV> ps_sps = ps_codec -> ps_sps_base + i ; //<S2SV> if ( ps_sps -> i1_sps_valid ) //<S2SV> { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( NULL == ps_sps ) //<S2SV> { //<S2SV> return ; //<S2SV> } //<S2SV> if ( NAL_PREFIX_SEI == i1_nal_type ) //<S2SV> { //<S2SV> switch ( u4_payload_type ) //<S2SV> { //<S2SV> case SEI_BUFFERING_PERIOD : //<S2SV> ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; //<S2SV> ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; //<S2SV> break ; //<S2SV> case SEI_PICTURE_TIMING : //<S2SV> ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; //<S2SV> ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; //<S2SV> break ; //<S2SV> case SEI_TIME_CODE : //<S2SV> ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; //<S2SV> ihevcd_parse_time_code_sei ( ps_codec ) ; //<S2SV> break ; //<S2SV> case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : //<S2SV> ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; //<S2SV> ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; //<S2SV> break ; //<S2SV> case SEI_USER_DATA_REGISTERED_ITU_T_T35 : //<S2SV> ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; //<S2SV> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , //<S2SV> u4_payload_size ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> for ( i = 0 ; i < u4_payload_size ; i ++ ) //<S2SV> { //<S2SV> ihevcd_bits_flush ( ps_bitstrm , 8 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> switch ( u4_payload_type ) //<S2SV> { //<S2SV> case SEI_USER_DATA_REGISTERED_ITU_T_T35 : //<S2SV> ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; //<S2SV> ihevcd_parse_user_data_registered_itu_t_t35 ( ps_codec , //<S2SV> u4_payload_size ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> for ( i = 0 ; i < u4_payload_size ; i ++ ) //<S2SV> { //<S2SV> ihevcd_bits_flush ( ps_bitstrm , 8 ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> payload_bits_remaining = ihevcd_bits_num_bits_remaining ( ps_bitstrm ) ; //<S2SV> if ( payload_bits_remaining ) //<S2SV> { //<S2SV> WORD32 final_bits ; //<S2SV> WORD32 final_payload_bits = 0 ; //<S2SV> WORD32 mask = 0xFF ; //<S2SV> UWORD32 u4_dummy ; //<S2SV> UWORD32 u4_reserved_payload_extension_data ; //<S2SV> UNUSED ( u4_dummy ) ; //<S2SV> UNUSED ( u4_reserved_payload_extension_data ) ; //<S2SV> while ( payload_bits_remaining > 9 ) //<S2SV> { //<S2SV> BITS_PARSE ( "reserved_payload_extension_data" , //<S2SV> u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; //<S2SV> payload_bits_remaining -- ; //<S2SV> } //<S2SV> final_bits = ihevcd_bits_nxt ( ps_bitstrm , payload_bits_remaining ) ; //<S2SV> while ( final_bits & ( mask >> final_payload_bits ) ) //<S2SV> { //<S2SV> final_payload_bits ++ ; //<S2SV> continue ; //<S2SV> } //<S2SV> while ( payload_bits_remaining > ( 9 - final_payload_bits ) ) //<S2SV> { //<S2SV> BITS_PARSE ( "reserved_payload_extension_data" , //<S2SV> u4_reserved_payload_extension_data , ps_bitstrm , 1 ) ; //<S2SV> payload_bits_remaining -- ; //<S2SV> } //<S2SV> BITS_PARSE ( "payload_bit_equal_to_one" , u4_dummy , ps_bitstrm , 1 ) ; //<S2SV> payload_bits_remaining -- ; //<S2SV> while ( payload_bits_remaining ) //<S2SV> { //<S2SV> BITS_PARSE ( "payload_bit_equal_to_zero" , u4_dummy , ps_bitstrm , 1 ) ; //<S2SV> payload_bits_remaining -- ; //<S2SV> } //<S2SV> } //<S2SV> return ; //<S2SV> } //<S2SV> 