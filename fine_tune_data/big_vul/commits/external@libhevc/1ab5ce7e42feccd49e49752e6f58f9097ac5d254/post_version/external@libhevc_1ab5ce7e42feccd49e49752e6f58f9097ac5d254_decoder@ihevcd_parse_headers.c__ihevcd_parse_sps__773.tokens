IHEVCD_ERROR_T ihevcd_parse_sps ( codec_t * ps_codec ) //<S2SV> { //<S2SV> IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; //<S2SV> WORD32 value ; //<S2SV> WORD32 i ; //<S2SV> WORD32 vps_id ; //<S2SV> WORD32 sps_max_sub_layers ; //<S2SV> WORD32 sps_id ; //<S2SV> WORD32 sps_temporal_id_nesting_flag ; //<S2SV> sps_t * ps_sps ; //<S2SV> profile_tier_lvl_info_t s_ptl ; //<S2SV> bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; //<S2SV> BITS_PARSE ( "video_parameter_set_id" , value , ps_bitstrm , 4 ) ; //<S2SV> vps_id = value ; //<S2SV> vps_id = CLIP3 ( vps_id , 0 , MAX_VPS_CNT - 1 ) ; //<S2SV> BITS_PARSE ( "sps_max_sub_layers_minus1" , value , ps_bitstrm , 3 ) ; //<S2SV> sps_max_sub_layers = value + 1 ; //<S2SV> sps_max_sub_layers = CLIP3 ( sps_max_sub_layers , 1 , 7 ) ; //<S2SV> BITS_PARSE ( "sps_temporal_id_nesting_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> sps_temporal_id_nesting_flag = value ; //<S2SV> ret = ihevcd_profile_tier_level ( ps_bitstrm , & ( s_ptl ) , 1 , //<S2SV> ( sps_max_sub_layers - 1 ) ) ; //<S2SV> UEV_PARSE ( "seq_parameter_set_id" , value , ps_bitstrm ) ; //<S2SV> sps_id = value ; //<S2SV> if ( ( sps_id >= MAX_SPS_CNT ) || ( sps_id < 0 ) ) //<S2SV> { //<S2SV> if ( ps_codec -> i4_sps_done ) //<S2SV> return IHEVCD_UNSUPPORTED_SPS_ID ; //<S2SV> else //<S2SV> sps_id = 0 ; //<S2SV> } //<S2SV> ps_sps = ( ps_codec -> s_parse . ps_sps_base + MAX_SPS_CNT - 1 ) ; //<S2SV> ps_sps -> i1_sps_id = sps_id ; //<S2SV> ps_sps -> i1_vps_id = vps_id ; //<S2SV> ps_sps -> i1_sps_max_sub_layers = sps_max_sub_layers ; //<S2SV> ps_sps -> i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag ; //<S2SV> ps_codec -> i4_sps_id = sps_id ; //<S2SV> memcpy ( & ps_sps -> s_ptl , & s_ptl , sizeof ( profile_tier_lvl_info_t ) ) ; //<S2SV> UEV_PARSE ( "chroma_format_idc" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_chroma_format_idc = value ; //<S2SV> if ( ps_sps -> i1_chroma_format_idc != CHROMA_FMT_IDC_YUV420 ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_error_code = IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC ; //<S2SV> return ( IHEVCD_ERROR_T ) IHEVCD_UNSUPPORTED_CHROMA_FMT_IDC ; //<S2SV> } //<S2SV> if ( CHROMA_FMT_IDC_YUV444_PLANES == ps_sps -> i1_chroma_format_idc ) //<S2SV> { //<S2SV> BITS_PARSE ( "separate_colour_plane_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_separate_colour_plane_flag = value ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_sps -> i1_separate_colour_plane_flag = 0 ; //<S2SV> } //<S2SV> UEV_PARSE ( "pic_width_in_luma_samples" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i2_pic_width_in_luma_samples = value ; //<S2SV> UEV_PARSE ( "pic_height_in_luma_samples" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i2_pic_height_in_luma_samples = value ; //<S2SV> if ( ( 0 >= ps_sps -> i2_pic_width_in_luma_samples ) || ( 0 >= ps_sps -> i2_pic_height_in_luma_samples ) ) //<S2SV> return IHEVCD_INVALID_PARAMETER ; //<S2SV> ps_sps -> i2_pic_width_in_luma_samples = ALIGN8 ( ps_sps -> i2_pic_width_in_luma_samples ) ; //<S2SV> ps_sps -> i2_pic_height_in_luma_samples = ALIGN8 ( ps_sps -> i2_pic_height_in_luma_samples ) ; //<S2SV> if ( ( ps_sps -> i2_pic_width_in_luma_samples > ps_codec -> i4_max_wd ) || //<S2SV> ( ps_sps -> i2_pic_width_in_luma_samples * ps_sps -> i2_pic_height_in_luma_samples > //<S2SV> ps_codec -> i4_max_wd * ps_codec -> i4_max_ht ) || //<S2SV> ( ps_sps -> i2_pic_height_in_luma_samples > MAX ( ps_codec -> i4_max_wd , ps_codec -> i4_max_ht ) ) ) //<S2SV> { //<S2SV> ps_codec -> i4_new_max_wd = ps_sps -> i2_pic_width_in_luma_samples ; //<S2SV> ps_codec -> i4_new_max_ht = ps_sps -> i2_pic_height_in_luma_samples ; //<S2SV> return ( IHEVCD_ERROR_T ) IHEVCD_UNSUPPORTED_DIMENSIONS ; //<S2SV> } //<S2SV> BITS_PARSE ( "pic_cropping_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_pic_cropping_flag = value ; //<S2SV> if ( ps_sps -> i1_pic_cropping_flag ) //<S2SV> { //<S2SV> UEV_PARSE ( "pic_crop_left_offset" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i2_pic_crop_left_offset = value ; //<S2SV> UEV_PARSE ( "pic_crop_right_offset" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i2_pic_crop_right_offset = value ; //<S2SV> UEV_PARSE ( "pic_crop_top_offset" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i2_pic_crop_top_offset = value ; //<S2SV> UEV_PARSE ( "pic_crop_bottom_offset" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i2_pic_crop_bottom_offset = value ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_sps -> i2_pic_crop_left_offset = 0 ; //<S2SV> ps_sps -> i2_pic_crop_right_offset = 0 ; //<S2SV> ps_sps -> i2_pic_crop_top_offset = 0 ; //<S2SV> ps_sps -> i2_pic_crop_bottom_offset = 0 ; //<S2SV> } //<S2SV> UEV_PARSE ( "bit_depth_luma_minus8" , value , ps_bitstrm ) ; //<S2SV> if ( 0 != value ) //<S2SV> return IHEVCD_UNSUPPORTED_BIT_DEPTH ; //<S2SV> UEV_PARSE ( "bit_depth_chroma_minus8" , value , ps_bitstrm ) ; //<S2SV> if ( 0 != value ) //<S2SV> return IHEVCD_UNSUPPORTED_BIT_DEPTH ; //<S2SV> UEV_PARSE ( "log2_max_pic_order_cnt_lsb_minus4" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_log2_max_pic_order_cnt_lsb = value + 4 ; //<S2SV> BITS_PARSE ( "sps_sub_layer_ordering_info_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_sps_sub_layer_ordering_info_present_flag = value ; //<S2SV> i = ( ps_sps -> i1_sps_sub_layer_ordering_info_present_flag ? 0 : ( ps_sps -> i1_sps_max_sub_layers - 1 ) ) ; //<S2SV> for ( ; i < ps_sps -> i1_sps_max_sub_layers ; i ++ ) //<S2SV> { //<S2SV> UEV_PARSE ( "max_dec_pic_buffering" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] = value + 1 ; //<S2SV> if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) //<S2SV> { //<S2SV> return IHEVCD_INVALID_PARAMETER ; //<S2SV> } //<S2SV> UEV_PARSE ( "num_reorder_pics" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> ai1_sps_max_num_reorder_pics [ i ] = value ; //<S2SV> if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) //<S2SV> { //<S2SV> return IHEVCD_INVALID_PARAMETER ; //<S2SV> } //<S2SV> UEV_PARSE ( "max_latency_increase" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> ai1_sps_max_latency_increase [ i ] = value ; //<S2SV> } //<S2SV> UEV_PARSE ( "log2_min_coding_block_size_minus3" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_log2_min_coding_block_size = value + 3 ; //<S2SV> UEV_PARSE ( "log2_diff_max_min_coding_block_size" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_log2_diff_max_min_coding_block_size = value ; //<S2SV> UEV_PARSE ( "log2_min_transform_block_size_minus2" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_log2_min_transform_block_size = value + 2 ; //<S2SV> UEV_PARSE ( "log2_diff_max_min_transform_block_size" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_log2_diff_max_min_transform_block_size = value ; //<S2SV> ps_sps -> i1_log2_max_transform_block_size = ps_sps -> i1_log2_min_transform_block_size + //<S2SV> ps_sps -> i1_log2_diff_max_min_transform_block_size ; //<S2SV> ps_sps -> i1_log2_ctb_size = ps_sps -> i1_log2_min_coding_block_size + //<S2SV> ps_sps -> i1_log2_diff_max_min_coding_block_size ; //<S2SV> if ( ( ps_sps -> i1_log2_min_coding_block_size < 3 ) || //<S2SV> ( ps_sps -> i1_log2_min_transform_block_size < 2 ) || //<S2SV> ( ps_sps -> i1_log2_diff_max_min_transform_block_size < 0 ) || //<S2SV> ( ps_sps -> i1_log2_max_transform_block_size > ps_sps -> i1_log2_ctb_size ) || //<S2SV> ( ps_sps -> i1_log2_ctb_size < 4 ) || //<S2SV> ( ps_sps -> i1_log2_ctb_size > 6 ) ) //<S2SV> { //<S2SV> return IHEVCD_INVALID_PARAMETER ; //<S2SV> } //<S2SV> ps_sps -> i1_log2_min_pcm_coding_block_size = 0 ; //<S2SV> ps_sps -> i1_log2_diff_max_min_pcm_coding_block_size = 0 ; //<S2SV> UEV_PARSE ( "max_transform_hierarchy_depth_inter" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_max_transform_hierarchy_depth_inter = value ; //<S2SV> UEV_PARSE ( "max_transform_hierarchy_depth_intra" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_max_transform_hierarchy_depth_intra = value ; //<S2SV> BITS_PARSE ( "scaling_list_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_scaling_list_enable_flag = value ; //<S2SV> if ( ps_sps -> i1_scaling_list_enable_flag ) //<S2SV> { //<S2SV> COPY_DEFAULT_SCALING_LIST ( ps_sps -> pi2_scaling_mat ) ; //<S2SV> BITS_PARSE ( "sps_scaling_list_data_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_sps_scaling_list_data_present_flag = value ; //<S2SV> if ( ps_sps -> i1_sps_scaling_list_data_present_flag ) //<S2SV> ihevcd_scaling_list_data ( ps_codec , ps_sps -> pi2_scaling_mat ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> COPY_FLAT_SCALING_LIST ( ps_sps -> pi2_scaling_mat ) ; //<S2SV> } //<S2SV> BITS_PARSE ( "asymmetric_motion_partitions_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_amp_enabled_flag = value ; //<S2SV> BITS_PARSE ( "sample_adaptive_offset_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_sample_adaptive_offset_enabled_flag = value ; //<S2SV> BITS_PARSE ( "pcm_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_pcm_enabled_flag = value ; //<S2SV> if ( ps_sps -> i1_pcm_enabled_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "pcm_sample_bit_depth_luma" , value , ps_bitstrm , 4 ) ; //<S2SV> ps_sps -> i1_pcm_sample_bit_depth_luma = value + 1 ; //<S2SV> BITS_PARSE ( "pcm_sample_bit_depth_chroma" , value , ps_bitstrm , 4 ) ; //<S2SV> ps_sps -> i1_pcm_sample_bit_depth_chroma = value + 1 ; //<S2SV> UEV_PARSE ( "log2_min_pcm_coding_block_size_minus3" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_log2_min_pcm_coding_block_size = value + 3 ; //<S2SV> UEV_PARSE ( "log2_diff_max_min_pcm_coding_block_size" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_log2_diff_max_min_pcm_coding_block_size = value ; //<S2SV> BITS_PARSE ( "pcm_loop_filter_disable_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_pcm_loop_filter_disable_flag = value ; //<S2SV> } //<S2SV> UEV_PARSE ( "num_short_term_ref_pic_sets" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_num_short_term_ref_pic_sets = value ; //<S2SV> ps_sps -> i1_num_short_term_ref_pic_sets = CLIP3 ( ps_sps -> i1_num_short_term_ref_pic_sets , 0 , MAX_STREF_PICS_SPS ) ; //<S2SV> for ( i = 0 ; i < ps_sps -> i1_num_short_term_ref_pic_sets ; i ++ ) //<S2SV> ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , i , & ps_sps -> as_stref_picset [ i ] ) ; //<S2SV> BITS_PARSE ( "long_term_ref_pics_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_long_term_ref_pics_present_flag = value ; //<S2SV> if ( ps_sps -> i1_long_term_ref_pics_present_flag ) //<S2SV> { //<S2SV> UEV_PARSE ( "num_long_term_ref_pics_sps" , value , ps_bitstrm ) ; //<S2SV> ps_sps -> i1_num_long_term_ref_pics_sps = value ; //<S2SV> for ( i = 0 ; i < ps_sps -> i1_num_long_term_ref_pics_sps ; i ++ ) //<S2SV> { //<S2SV> BITS_PARSE ( "lt_ref_pic_poc_lsb_sps[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; //<S2SV> ps_sps -> ai1_lt_ref_pic_poc_lsb_sps [ i ] = value ; //<S2SV> BITS_PARSE ( "used_by_curr_pic_lt_sps_flag[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ i ] = value ; //<S2SV> } //<S2SV> } //<S2SV> BITS_PARSE ( "sps_temporal_mvp_enable_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_sps_temporal_mvp_enable_flag = value ; //<S2SV> BITS_PARSE ( "sps_strong_intra_smoothing_enable_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_strong_intra_smoothing_enable_flag = value ; //<S2SV> BITS_PARSE ( "vui_parameters_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_sps -> i1_vui_parameters_present_flag = value ; //<S2SV> if ( ps_sps -> i1_vui_parameters_present_flag ) //<S2SV> ihevcd_parse_vui_parameters ( ps_bitstrm , //<S2SV> & ps_sps -> s_vui_parameters , //<S2SV> ps_sps -> i1_sps_max_sub_layers - 1 ) ; //<S2SV> BITS_PARSE ( "sps_extension_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> { //<S2SV> WORD32 numerator ; //<S2SV> WORD32 ceil_offset ; //<S2SV> ceil_offset = ( 1 << ps_sps -> i1_log2_ctb_size ) - 1 ; //<S2SV> numerator = ps_sps -> i2_pic_width_in_luma_samples ; //<S2SV> ps_sps -> i2_pic_wd_in_ctb = ( ( numerator + ceil_offset ) / //<S2SV> ( 1 << ps_sps -> i1_log2_ctb_size ) ) ; //<S2SV> numerator = ps_sps -> i2_pic_height_in_luma_samples ; //<S2SV> ps_sps -> i2_pic_ht_in_ctb = ( ( numerator + ceil_offset ) / //<S2SV> ( 1 << ps_sps -> i1_log2_ctb_size ) ) ; //<S2SV> ps_sps -> i4_pic_size_in_ctb = ps_sps -> i2_pic_ht_in_ctb * //<S2SV> ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> if ( 0 == ps_codec -> i4_sps_done ) //<S2SV> ps_codec -> s_parse . i4_next_ctb_indx = ps_sps -> i4_pic_size_in_ctb ; //<S2SV> numerator = ps_sps -> i2_pic_width_in_luma_samples ; //<S2SV> ps_sps -> i2_pic_wd_in_min_cb = numerator / //<S2SV> ( 1 << ps_sps -> i1_log2_min_coding_block_size ) ; //<S2SV> numerator = ps_sps -> i2_pic_height_in_luma_samples ; //<S2SV> ps_sps -> i2_pic_ht_in_min_cb = numerator / //<S2SV> ( 1 << ps_sps -> i1_log2_min_coding_block_size ) ; //<S2SV> } //<S2SV> if ( ( 0 != ps_codec -> i4_first_pic_done ) && //<S2SV> ( ( ps_codec -> i4_wd != ps_sps -> i2_pic_width_in_luma_samples ) || //<S2SV> ( ps_codec -> i4_ht != ps_sps -> i2_pic_height_in_luma_samples ) ) ) //<S2SV> { //<S2SV> ps_codec -> i4_reset_flag = 1 ; //<S2SV> ps_codec -> i4_error_code = IVD_RES_CHANGED ; //<S2SV> return ( IHEVCD_ERROR_T ) IHEVCD_FAIL ; //<S2SV> } //<S2SV> { //<S2SV> WORD32 disp_wd , disp_ht ; //<S2SV> WORD32 crop_unit_x , crop_unit_y ; //<S2SV> crop_unit_x = 1 ; //<S2SV> crop_unit_y = 1 ; //<S2SV> if ( CHROMA_FMT_IDC_YUV420 == ps_sps -> i1_chroma_format_idc ) //<S2SV> { //<S2SV> crop_unit_x = 2 ; //<S2SV> crop_unit_y = 2 ; //<S2SV> } //<S2SV> disp_wd = ps_sps -> i2_pic_width_in_luma_samples ; //<S2SV> disp_wd -= ps_sps -> i2_pic_crop_left_offset * crop_unit_x ; //<S2SV> disp_wd -= ps_sps -> i2_pic_crop_right_offset * crop_unit_x ; //<S2SV> disp_ht = ps_sps -> i2_pic_height_in_luma_samples ; //<S2SV> disp_ht -= ps_sps -> i2_pic_crop_top_offset * crop_unit_y ; //<S2SV> disp_ht -= ps_sps -> i2_pic_crop_bottom_offset * crop_unit_y ; //<S2SV> if ( ( 0 >= disp_wd ) || ( 0 >= disp_ht ) ) //<S2SV> return IHEVCD_INVALID_PARAMETER ; //<S2SV> ps_codec -> i4_disp_wd = disp_wd ; //<S2SV> ps_codec -> i4_disp_ht = disp_ht ; //<S2SV> ps_codec -> i4_wd = ps_sps -> i2_pic_width_in_luma_samples ; //<S2SV> ps_codec -> i4_ht = ps_sps -> i2_pic_height_in_luma_samples ; //<S2SV> { //<S2SV> WORD32 ref_strd ; //<S2SV> ref_strd = ALIGN32 ( ps_sps -> i2_pic_width_in_luma_samples + PAD_WD ) ; //<S2SV> if ( ps_codec -> i4_strd < ref_strd ) //<S2SV> { //<S2SV> ps_codec -> i4_strd = ref_strd ; //<S2SV> } //<S2SV> } //<S2SV> if ( 0 == ps_codec -> i4_share_disp_buf ) //<S2SV> { //<S2SV> if ( ps_codec -> i4_disp_strd < ps_codec -> i4_disp_wd ) //<S2SV> { //<S2SV> ps_codec -> i4_disp_strd = ps_codec -> i4_disp_wd ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ps_codec -> i4_disp_strd < ps_codec -> i4_strd ) //<S2SV> { //<S2SV> ps_codec -> i4_disp_strd = ps_codec -> i4_strd ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ps_codec -> i4_sps_done = 1 ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 