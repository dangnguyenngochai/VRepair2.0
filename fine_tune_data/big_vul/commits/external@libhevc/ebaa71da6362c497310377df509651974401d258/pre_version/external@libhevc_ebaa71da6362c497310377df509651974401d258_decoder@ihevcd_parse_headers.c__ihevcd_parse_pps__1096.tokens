IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) //<S2SV> { //<S2SV> IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; //<S2SV> WORD32 value ; //<S2SV> WORD32 pps_id ; //<S2SV> pps_t * ps_pps ; //<S2SV> sps_t * ps_sps ; //<S2SV> bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; //<S2SV> if ( 0 == ps_codec -> i4_sps_done ) //<S2SV> return IHEVCD_INVALID_HEADER ; //<S2SV> UEV_PARSE ( "pic_parameter_set_id" , value , ps_bitstrm ) ; //<S2SV> pps_id = value ; //<S2SV> if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) //<S2SV> { //<S2SV> if ( ps_codec -> i4_pps_done ) //<S2SV> return IHEVCD_UNSUPPORTED_PPS_ID ; //<S2SV> else //<S2SV> pps_id = 0 ; //<S2SV> } //<S2SV> ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; //<S2SV> ps_pps -> i1_pps_id = pps_id ; //<S2SV> UEV_PARSE ( "seq_parameter_set_id" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_sps_id = value ; //<S2SV> ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; //<S2SV> ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; //<S2SV> if ( 0 == ps_sps -> i1_sps_valid ) //<S2SV> { //<S2SV> return IHEVCD_INVALID_HEADER ; //<S2SV> } //<S2SV> BITS_PARSE ( "dependent_slices_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_dependent_slice_enabled_flag = value ; //<S2SV> BITS_PARSE ( "output_flag_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_output_flag_present_flag = value ; //<S2SV> BITS_PARSE ( "num_extra_slice_header_bits" , value , ps_bitstrm , 3 ) ; //<S2SV> ps_pps -> i1_num_extra_slice_header_bits = value ; //<S2SV> BITS_PARSE ( "sign_data_hiding_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_sign_data_hiding_flag = value ; //<S2SV> BITS_PARSE ( "cabac_init_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_cabac_init_present_flag = value ; //<S2SV> UEV_PARSE ( "num_ref_idx_l0_default_active_minus1" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_num_ref_idx_l0_default_active = value + 1 ; //<S2SV> UEV_PARSE ( "num_ref_idx_l1_default_active_minus1" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_num_ref_idx_l1_default_active = value + 1 ; //<S2SV> SEV_PARSE ( "pic_init_qp_minus26" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_pic_init_qp = value + 26 ; //<S2SV> BITS_PARSE ( "constrained_intra_pred_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_constrained_intra_pred_flag = value ; //<S2SV> BITS_PARSE ( "transform_skip_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_transform_skip_enabled_flag = value ; //<S2SV> BITS_PARSE ( "cu_qp_delta_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_cu_qp_delta_enabled_flag = value ; //<S2SV> if ( ps_pps -> i1_cu_qp_delta_enabled_flag ) //<S2SV> { //<S2SV> UEV_PARSE ( "diff_cu_qp_delta_depth" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_diff_cu_qp_delta_depth = value ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_pps -> i1_diff_cu_qp_delta_depth = 0 ; //<S2SV> } //<S2SV> ps_pps -> i1_log2_min_cu_qp_delta_size = ps_sps -> i1_log2_ctb_size - ps_pps -> i1_diff_cu_qp_delta_depth ; //<S2SV> SEV_PARSE ( "cb_qp_offset" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_pic_cb_qp_offset = value ; //<S2SV> SEV_PARSE ( "cr_qp_offset" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_pic_cr_qp_offset = value ; //<S2SV> BITS_PARSE ( "slicelevel_chroma_qp_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag = value ; //<S2SV> BITS_PARSE ( "weighted_pred_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_weighted_pred_flag = value ; //<S2SV> BITS_PARSE ( "weighted_bipred_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_weighted_bipred_flag = value ; //<S2SV> BITS_PARSE ( "transquant_bypass_enable_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_transquant_bypass_enable_flag = value ; //<S2SV> BITS_PARSE ( "tiles_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_tiles_enabled_flag = value ; //<S2SV> BITS_PARSE ( "entropy_coding_sync_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_entropy_coding_sync_enabled_flag = value ; //<S2SV> ps_pps -> i1_loop_filter_across_tiles_enabled_flag = 0 ; //<S2SV> if ( ps_pps -> i1_tiles_enabled_flag ) //<S2SV> { //<S2SV> UEV_PARSE ( "num_tile_columns_minus1" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_num_tile_columns = value + 1 ; //<S2SV> UEV_PARSE ( "num_tile_rows_minus1" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_num_tile_rows = value + 1 ; //<S2SV> if ( ( ps_pps -> i1_num_tile_columns < 1 ) || //<S2SV> ( ps_pps -> i1_num_tile_columns > ps_sps -> i2_pic_wd_in_ctb ) || //<S2SV> ( ps_pps -> i1_num_tile_rows < 1 ) || //<S2SV> ( ps_pps -> i1_num_tile_rows > ps_sps -> i2_pic_ht_in_ctb ) ) //<S2SV> return IHEVCD_INVALID_HEADER ; //<S2SV> BITS_PARSE ( "uniform_spacing_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_uniform_spacing_flag = value ; //<S2SV> { //<S2SV> WORD32 start ; //<S2SV> WORD32 i , j ; //<S2SV> start = 0 ; //<S2SV> for ( i = 0 ; i < ps_pps -> i1_num_tile_columns ; i ++ ) //<S2SV> { //<S2SV> tile_t * ps_tile ; //<S2SV> if ( ! ps_pps -> i1_uniform_spacing_flag ) //<S2SV> { //<S2SV> if ( i < ( ps_pps -> i1_num_tile_columns - 1 ) ) //<S2SV> { //<S2SV> UEV_PARSE ( "column_width_minus1[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm ) ; //<S2SV> value += 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> value = ps_sps -> i2_pic_wd_in_ctb - start ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> value = ( ( i + 1 ) * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns - //<S2SV> ( i * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns ; //<S2SV> } //<S2SV> for ( j = 0 ; j < ps_pps -> i1_num_tile_rows ; j ++ ) //<S2SV> { //<S2SV> ps_tile = ps_pps -> ps_tile + j * ps_pps -> i1_num_tile_columns + i ; //<S2SV> ps_tile -> u1_pos_x = start ; //<S2SV> ps_tile -> u2_wd = value ; //<S2SV> } //<S2SV> start += value ; //<S2SV> if ( ( start > ps_sps -> i2_pic_wd_in_ctb ) || //<S2SV> ( value <= 0 ) ) //<S2SV> return IHEVCD_INVALID_HEADER ; //<S2SV> } //<S2SV> start = 0 ; //<S2SV> for ( i = 0 ; i < ( ps_pps -> i1_num_tile_rows ) ; i ++ ) //<S2SV> { //<S2SV> tile_t * ps_tile ; //<S2SV> if ( ! ps_pps -> i1_uniform_spacing_flag ) //<S2SV> { //<S2SV> if ( i < ( ps_pps -> i1_num_tile_rows - 1 ) ) //<S2SV> { //<S2SV> UEV_PARSE ( "row_height_minus1[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm ) ; //<S2SV> value += 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> value = ps_sps -> i2_pic_ht_in_ctb - start ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> value = ( ( i + 1 ) * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows - //<S2SV> ( i * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows ; //<S2SV> } //<S2SV> for ( j = 0 ; j < ps_pps -> i1_num_tile_columns ; j ++ ) //<S2SV> { //<S2SV> ps_tile = ps_pps -> ps_tile + i * ps_pps -> i1_num_tile_columns + j ; //<S2SV> ps_tile -> u1_pos_y = start ; //<S2SV> ps_tile -> u2_ht = value ; //<S2SV> } //<S2SV> start += value ; //<S2SV> if ( ( start > ps_sps -> i2_pic_ht_in_ctb ) || //<S2SV> ( value <= 0 ) ) //<S2SV> return IHEVCD_INVALID_HEADER ; //<S2SV> } //<S2SV> } //<S2SV> BITS_PARSE ( "loop_filter_across_tiles_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_loop_filter_across_tiles_enabled_flag = value ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_pps -> i1_num_tile_columns = 1 ; //<S2SV> ps_pps -> i1_num_tile_rows = 1 ; //<S2SV> ps_pps -> i1_uniform_spacing_flag = 1 ; //<S2SV> ps_pps -> ps_tile -> u1_pos_x = 0 ; //<S2SV> ps_pps -> ps_tile -> u1_pos_y = 0 ; //<S2SV> ps_pps -> ps_tile -> u2_wd = ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> ps_pps -> ps_tile -> u2_ht = ps_sps -> i2_pic_ht_in_ctb ; //<S2SV> } //<S2SV> BITS_PARSE ( "loop_filter_across_slices_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_loop_filter_across_slices_enabled_flag = value ; //<S2SV> BITS_PARSE ( "deblocking_filter_control_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_deblocking_filter_control_present_flag = value ; //<S2SV> ps_pps -> i1_pic_disable_deblocking_filter_flag = 0 ; //<S2SV> ps_pps -> i1_deblocking_filter_override_enabled_flag = 0 ; //<S2SV> ps_pps -> i1_beta_offset_div2 = 0 ; //<S2SV> ps_pps -> i1_tc_offset_div2 = 0 ; //<S2SV> if ( ps_pps -> i1_deblocking_filter_control_present_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "deblocking_filter_override_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_deblocking_filter_override_enabled_flag = value ; //<S2SV> BITS_PARSE ( "pic_disable_deblocking_filter_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_pic_disable_deblocking_filter_flag = value ; //<S2SV> if ( ! ps_pps -> i1_pic_disable_deblocking_filter_flag ) //<S2SV> { //<S2SV> SEV_PARSE ( "pps_beta_offset_div2" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_beta_offset_div2 = value ; //<S2SV> SEV_PARSE ( "pps_tc_offset_div2" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_tc_offset_div2 = value ; //<S2SV> } //<S2SV> } //<S2SV> BITS_PARSE ( "pps_scaling_list_data_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_pps_scaling_list_data_present_flag = value ; //<S2SV> if ( ps_pps -> i1_pps_scaling_list_data_present_flag ) //<S2SV> { //<S2SV> COPY_DEFAULT_SCALING_LIST ( ps_pps -> pi2_scaling_mat ) ; //<S2SV> ihevcd_scaling_list_data ( ps_codec , ps_pps -> pi2_scaling_mat ) ; //<S2SV> } //<S2SV> BITS_PARSE ( "lists_modification_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_lists_modification_present_flag = value ; //<S2SV> UEV_PARSE ( "log2_parallel_merge_level_minus2" , value , ps_bitstrm ) ; //<S2SV> ps_pps -> i1_log2_parallel_merge_level = value + 2 ; //<S2SV> BITS_PARSE ( "slice_header_extension_present_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_pps -> i1_slice_header_extension_present_flag = value ; //<S2SV> BITS_PARSE ( "pps_extension_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_codec -> i4_pps_done = 1 ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 