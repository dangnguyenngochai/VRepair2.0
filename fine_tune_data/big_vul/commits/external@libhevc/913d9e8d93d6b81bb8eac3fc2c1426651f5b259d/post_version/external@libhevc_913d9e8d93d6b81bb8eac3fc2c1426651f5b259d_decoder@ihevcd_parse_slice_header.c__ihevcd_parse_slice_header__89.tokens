IHEVCD_ERROR_T ihevcd_parse_slice_header ( codec_t * ps_codec , //<S2SV> nal_header_t * ps_nal ) //<S2SV> { //<S2SV> IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; //<S2SV> WORD32 value ; //<S2SV> WORD32 i , j ; //<S2SV> WORD32 sps_id ; //<S2SV> pps_t * ps_pps ; //<S2SV> sps_t * ps_sps ; //<S2SV> slice_header_t * ps_slice_hdr ; //<S2SV> WORD32 disable_deblocking_filter_flag ; //<S2SV> bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; //<S2SV> WORD32 idr_pic_flag ; //<S2SV> WORD32 pps_id ; //<S2SV> WORD32 first_slice_in_pic_flag ; //<S2SV> WORD32 no_output_of_prior_pics_flag = 0 ; //<S2SV> WORD8 i1_nal_unit_type = ps_nal -> i1_nal_unit_type ; //<S2SV> WORD32 num_poc_total_curr = 0 ; //<S2SV> WORD32 slice_address ; //<S2SV> if ( ps_codec -> i4_slice_error == 1 ) //<S2SV> return ret ; //<S2SV> idr_pic_flag = ( NAL_IDR_W_LP == i1_nal_unit_type ) || //<S2SV> ( NAL_IDR_N_LP == i1_nal_unit_type ) ; //<S2SV> BITS_PARSE ( "first_slice_in_pic_flag" , first_slice_in_pic_flag , ps_bitstrm , 1 ) ; //<S2SV> if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && //<S2SV> ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) //<S2SV> { //<S2SV> BITS_PARSE ( "no_output_of_prior_pics_flag" , no_output_of_prior_pics_flag , ps_bitstrm , 1 ) ; //<S2SV> } //<S2SV> UEV_PARSE ( "pic_parameter_set_id" , pps_id , ps_bitstrm ) ; //<S2SV> pps_id = CLIP3 ( pps_id , 0 , MAX_PPS_CNT - 2 ) ; //<S2SV> ps_pps = ps_codec -> s_parse . ps_pps_base + pps_id ; //<S2SV> if ( 0 == ps_pps -> i1_pps_valid ) //<S2SV> { //<S2SV> pps_t * ps_pps_ref = ps_codec -> ps_pps_base ; //<S2SV> while ( 0 == ps_pps_ref -> i1_pps_valid ) //<S2SV> ps_pps_ref ++ ; //<S2SV> if ( ( ps_pps_ref - ps_codec -> ps_pps_base >= MAX_PPS_CNT - 1 ) ) //<S2SV> return IHEVCD_INVALID_HEADER ; //<S2SV> ihevcd_copy_pps ( ps_codec , pps_id , ps_pps_ref -> i1_pps_id ) ; //<S2SV> } //<S2SV> sps_id = ps_pps -> i1_sps_id ; //<S2SV> ps_sps = ps_codec -> s_parse . ps_sps_base + sps_id ; //<S2SV> if ( ( 0 != ps_codec -> u4_pic_cnt || ps_codec -> i4_pic_present ) && //<S2SV> first_slice_in_pic_flag ) //<S2SV> { //<S2SV> if ( ps_codec -> i4_pic_present ) //<S2SV> { //<S2SV> slice_header_t * ps_slice_hdr_next ; //<S2SV> ps_codec -> i4_slice_error = 1 ; //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx -- ; //<S2SV> if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx = 0 ; //<S2SV> ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; //<S2SV> ps_slice_hdr_next -> i2_ctb_x = 0 ; //<S2SV> ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; //<S2SV> return ret ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_codec -> i4_slice_error = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( first_slice_in_pic_flag ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( 0 == ps_codec -> i4_pic_present ) //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx = 1 ; //<S2SV> } //<S2SV> ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; //<S2SV> if ( ( ps_pps -> i1_dependent_slice_enabled_flag ) && //<S2SV> ( ! first_slice_in_pic_flag ) ) //<S2SV> { //<S2SV> BITS_PARSE ( "dependent_slice_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> if ( value && ( ps_codec -> s_parse . i4_cur_slice_idx > 0 ) ) //<S2SV> { //<S2SV> ihevcd_copy_slice_hdr ( ps_codec , //<S2SV> ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) , //<S2SV> ( ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_dependent_slice_flag = value ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_slice_hdr -> i1_dependent_slice_flag = 0 ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_nal_unit_type = i1_nal_unit_type ; //<S2SV> ps_slice_hdr -> i1_pps_id = pps_id ; //<S2SV> ps_slice_hdr -> i1_first_slice_in_pic_flag = first_slice_in_pic_flag ; //<S2SV> ps_slice_hdr -> i1_no_output_of_prior_pics_flag = 1 ; //<S2SV> if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && //<S2SV> ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) //<S2SV> { //<S2SV> ps_slice_hdr -> i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_pps_id = pps_id ; //<S2SV> if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) //<S2SV> { //<S2SV> WORD32 num_bits ; //<S2SV> num_bits = 32 - CLZ ( ps_sps -> i4_pic_size_in_ctb - 1 ) ; //<S2SV> BITS_PARSE ( "slice_address" , value , ps_bitstrm , num_bits ) ; //<S2SV> slice_address = value ; //<S2SV> if ( value >= ps_sps -> i4_pic_size_in_ctb ) //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> slice_address = 0 ; //<S2SV> } //<S2SV> if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) //<S2SV> { //<S2SV> ps_slice_hdr -> i1_pic_output_flag = 1 ; //<S2SV> ps_slice_hdr -> i4_pic_order_cnt_lsb = 0 ; //<S2SV> ps_slice_hdr -> i1_num_long_term_sps = 0 ; //<S2SV> ps_slice_hdr -> i1_num_long_term_pics = 0 ; //<S2SV> for ( i = 0 ; i < ps_pps -> i1_num_extra_slice_header_bits ; i ++ ) //<S2SV> { //<S2SV> BITS_PARSE ( "slice_reserved_undetermined_flag[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , 1 ) ; //<S2SV> } //<S2SV> UEV_PARSE ( "slice_type" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_slice_type = value ; //<S2SV> if ( ( ps_slice_hdr -> i1_nal_unit_type >= NAL_BLA_W_LP ) && //<S2SV> ( ps_slice_hdr -> i1_nal_unit_type <= NAL_RSV_RAP_VCL23 ) ) //<S2SV> ps_slice_hdr -> i1_slice_type = ISLICE ; //<S2SV> if ( ( ps_slice_hdr -> i1_slice_type < 0 ) || //<S2SV> ( ps_slice_hdr -> i1_slice_type > 2 ) ) //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> if ( ps_pps -> i1_output_flag_present_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "pic_output_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_pic_output_flag = value ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_colour_plane_id = 0 ; //<S2SV> if ( 1 == ps_sps -> i1_separate_colour_plane_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "colour_plane_id" , value , ps_bitstrm , 2 ) ; //<S2SV> ps_slice_hdr -> i1_colour_plane_id = value ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = 0 ; //<S2SV> if ( ! idr_pic_flag ) //<S2SV> { //<S2SV> WORD32 st_rps_idx ; //<S2SV> WORD32 num_neg_pics ; //<S2SV> WORD32 num_pos_pics ; //<S2SV> WORD8 * pi1_used ; //<S2SV> BITS_PARSE ( "pic_order_cnt_lsb" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; //<S2SV> ps_slice_hdr -> i4_pic_order_cnt_lsb = value ; //<S2SV> BITS_PARSE ( "short_term_ref_pic_set_sps_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag = value ; //<S2SV> if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) //<S2SV> { //<S2SV> WORD32 numbits ; //<S2SV> ps_slice_hdr -> i1_short_term_ref_pic_set_idx = 0 ; //<S2SV> if ( ps_sps -> i1_num_short_term_ref_pic_sets > 1 ) //<S2SV> { //<S2SV> numbits = 32 - CLZ ( ps_sps -> i1_num_short_term_ref_pic_sets - 1 ) ; //<S2SV> BITS_PARSE ( "short_term_ref_pic_set_idx" , value , ps_bitstrm , numbits ) ; //<S2SV> ps_slice_hdr -> i1_short_term_ref_pic_set_idx = value ; //<S2SV> } //<S2SV> st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; //<S2SV> num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; //<S2SV> num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; //<S2SV> pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ihevcd_short_term_ref_pic_set ( ps_bitstrm , //<S2SV> & ps_sps -> as_stref_picset [ 0 ] , //<S2SV> ps_sps -> i1_num_short_term_ref_pic_sets , //<S2SV> ps_sps -> i1_num_short_term_ref_pic_sets , //<S2SV> & ps_slice_hdr -> s_stref_picset ) ; //<S2SV> st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; //<S2SV> num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; //<S2SV> num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; //<S2SV> pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; //<S2SV> } //<S2SV> if ( ps_sps -> i1_long_term_ref_pics_present_flag ) //<S2SV> { //<S2SV> if ( ps_sps -> i1_num_long_term_ref_pics_sps > 0 ) //<S2SV> { //<S2SV> UEV_PARSE ( "num_long_term_sps" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_num_long_term_sps = value ; //<S2SV> ps_slice_hdr -> i1_num_long_term_sps = CLIP3 ( ps_slice_hdr -> i1_num_long_term_sps , //<S2SV> 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics ) ; //<S2SV> } //<S2SV> UEV_PARSE ( "num_long_term_pics" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_num_long_term_pics = value ; //<S2SV> ps_slice_hdr -> i1_num_long_term_pics = CLIP3 ( ps_slice_hdr -> i1_num_long_term_pics , //<S2SV> 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics - //<S2SV> ps_slice_hdr -> i1_num_long_term_sps ) ; //<S2SV> for ( i = 0 ; i < ( ps_slice_hdr -> i1_num_long_term_sps + //<S2SV> ps_slice_hdr -> i1_num_long_term_pics ) ; i ++ ) //<S2SV> { //<S2SV> if ( i < ps_slice_hdr -> i1_num_long_term_sps ) //<S2SV> { //<S2SV> WORD32 num_bits = 32 - CLZ ( ps_sps -> i1_num_long_term_ref_pics_sps ) ; //<S2SV> BITS_PARSE ( "lt_idx_sps[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , num_bits ) ; //<S2SV> ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = ps_sps -> ai1_lt_ref_pic_poc_lsb_sps [ value ] ; //<S2SV> ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ value ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> BITS_PARSE ( "poc_lsb_lt[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; //<S2SV> ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = value ; //<S2SV> BITS_PARSE ( "used_by_curr_pic_lt_flag[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = value ; //<S2SV> } //<S2SV> BITS_PARSE ( "delta_poc_msb_present_flag[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] = value ; //<S2SV> ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = 0 ; //<S2SV> if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) //<S2SV> { //<S2SV> UEV_PARSE ( "delata_poc_msb_cycle_lt[<S2SV_blank>i<S2SV_blank>]" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = value ; //<S2SV> } //<S2SV> if ( ( i != 0 ) && ( i != ps_slice_hdr -> i1_num_long_term_sps ) ) //<S2SV> { //<S2SV> ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] += ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i - 1 ] ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < num_neg_pics + num_pos_pics ; i ++ ) //<S2SV> { //<S2SV> if ( pi1_used [ i ] ) //<S2SV> { //<S2SV> num_poc_total_curr ++ ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) //<S2SV> { //<S2SV> if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) //<S2SV> { //<S2SV> num_poc_total_curr ++ ; //<S2SV> } //<S2SV> } //<S2SV> if ( ps_sps -> i1_sps_temporal_mvp_enable_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "enable_temporal_mvp_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = value ; //<S2SV> } //<S2SV> } //<S2SV> ps_slice_hdr -> i1_slice_sao_luma_flag = 0 ; //<S2SV> ps_slice_hdr -> i1_slice_sao_chroma_flag = 0 ; //<S2SV> if ( ps_sps -> i1_sample_adaptive_offset_enabled_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "slice_sao_luma_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_slice_sao_luma_flag = value ; //<S2SV> BITS_PARSE ( "slice_sao_chroma_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_slice_sao_chroma_flag = value ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_max_num_merge_cand = 1 ; //<S2SV> ps_slice_hdr -> i1_cabac_init_flag = 0 ; //<S2SV> ps_slice_hdr -> i1_num_ref_idx_l0_active = 0 ; //<S2SV> ps_slice_hdr -> i1_num_ref_idx_l1_active = 0 ; //<S2SV> ps_slice_hdr -> i1_slice_cb_qp_offset = 0 ; //<S2SV> ps_slice_hdr -> i1_slice_cr_qp_offset = 0 ; //<S2SV> if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || //<S2SV> ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) //<S2SV> { //<S2SV> BITS_PARSE ( "num_ref_idx_active_override_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_num_ref_idx_active_override_flag = value ; //<S2SV> if ( ps_slice_hdr -> i1_num_ref_idx_active_override_flag ) //<S2SV> { //<S2SV> UEV_PARSE ( "num_ref_idx_l0_active_minus1" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_num_ref_idx_l0_active = value + 1 ; //<S2SV> if ( BSLICE == ps_slice_hdr -> i1_slice_type ) //<S2SV> { //<S2SV> UEV_PARSE ( "num_ref_idx_l1_active_minus1" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_num_ref_idx_l1_active = value + 1 ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_slice_hdr -> i1_num_ref_idx_l0_active = ps_pps -> i1_num_ref_idx_l0_default_active ; //<S2SV> if ( BSLICE == ps_slice_hdr -> i1_slice_type ) //<S2SV> { //<S2SV> ps_slice_hdr -> i1_num_ref_idx_l1_active = ps_pps -> i1_num_ref_idx_l1_default_active ; //<S2SV> } //<S2SV> } //<S2SV> ps_slice_hdr -> i1_num_ref_idx_l0_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l0_active , 0 , MAX_DPB_SIZE - 1 ) ; //<S2SV> ps_slice_hdr -> i1_num_ref_idx_l1_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l1_active , 0 , MAX_DPB_SIZE - 1 ) ; //<S2SV> if ( 0 == num_poc_total_curr ) //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> if ( ( ps_pps -> i1_lists_modification_present_flag ) && ( num_poc_total_curr > 1 ) ) //<S2SV> { //<S2SV> ihevcd_ref_pic_list_modification ( ps_bitstrm , //<S2SV> ps_slice_hdr , num_poc_total_curr ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 = 0 ; //<S2SV> ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 = 0 ; //<S2SV> } //<S2SV> if ( BSLICE == ps_slice_hdr -> i1_slice_type ) //<S2SV> { //<S2SV> BITS_PARSE ( "mvd_l1_zero_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_mvd_l1_zero_flag = value ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_cabac_init_flag = 0 ; //<S2SV> if ( ps_pps -> i1_cabac_init_present_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "cabac_init_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_cabac_init_flag = value ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_collocated_from_l0_flag = 1 ; //<S2SV> ps_slice_hdr -> i1_collocated_ref_idx = 0 ; //<S2SV> if ( ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag ) //<S2SV> { //<S2SV> if ( BSLICE == ps_slice_hdr -> i1_slice_type ) //<S2SV> { //<S2SV> BITS_PARSE ( "collocated_from_l0_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_collocated_from_l0_flag = value ; //<S2SV> } //<S2SV> if ( ( ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l0_active > 1 ) ) || //<S2SV> ( ! ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l1_active > 1 ) ) ) //<S2SV> { //<S2SV> UEV_PARSE ( "collocated_ref_idx" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_collocated_ref_idx = value ; //<S2SV> } //<S2SV> } //<S2SV> ps_slice_hdr -> i1_collocated_ref_idx = CLIP3 ( ps_slice_hdr -> i1_collocated_ref_idx , 0 , MAX_DPB_SIZE - 1 ) ; //<S2SV> if ( ( ps_pps -> i1_weighted_pred_flag && ( PSLICE == ps_slice_hdr -> i1_slice_type ) ) || //<S2SV> ( ps_pps -> i1_weighted_bipred_flag && ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) ) //<S2SV> { //<S2SV> ihevcd_parse_pred_wt_ofst ( ps_bitstrm , ps_sps , ps_pps , ps_slice_hdr ) ; //<S2SV> } //<S2SV> UEV_PARSE ( "five_minus_max_num_merge_cand" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_max_num_merge_cand = 5 - value ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_max_num_merge_cand = CLIP3 ( ps_slice_hdr -> i1_max_num_merge_cand , 1 , 5 ) ; //<S2SV> SEV_PARSE ( "slice_qp_delta" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_slice_qp_delta = value ; //<S2SV> if ( ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag ) //<S2SV> { //<S2SV> SEV_PARSE ( "slice_cb_qp_offset" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_slice_cb_qp_offset = value ; //<S2SV> SEV_PARSE ( "slice_cr_qp_offset" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_slice_cr_qp_offset = value ; //<S2SV> } //<S2SV> ps_slice_hdr -> i1_deblocking_filter_override_flag = 0 ; //<S2SV> ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; //<S2SV> ps_slice_hdr -> i1_beta_offset_div2 = ps_pps -> i1_beta_offset_div2 ; //<S2SV> ps_slice_hdr -> i1_tc_offset_div2 = ps_pps -> i1_tc_offset_div2 ; //<S2SV> disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; //<S2SV> if ( ps_pps -> i1_deblocking_filter_control_present_flag ) //<S2SV> { //<S2SV> if ( ps_pps -> i1_deblocking_filter_override_enabled_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "deblocking_filter_override_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_deblocking_filter_override_flag = value ; //<S2SV> } //<S2SV> if ( ps_slice_hdr -> i1_deblocking_filter_override_flag ) //<S2SV> { //<S2SV> BITS_PARSE ( "slice_disable_deblocking_filter_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = value ; //<S2SV> disable_deblocking_filter_flag = ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ; //<S2SV> if ( ! ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) //<S2SV> { //<S2SV> SEV_PARSE ( "beta_offset_div2" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_beta_offset_div2 = value ; //<S2SV> SEV_PARSE ( "tc_offset_div2" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_tc_offset_div2 = value ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = ps_pps -> i1_loop_filter_across_slices_enabled_flag ; //<S2SV> if ( ps_pps -> i1_loop_filter_across_slices_enabled_flag && //<S2SV> ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag || ! disable_deblocking_filter_flag ) ) //<S2SV> { //<S2SV> BITS_PARSE ( "slice_loop_filter_across_slices_enabled_flag" , value , ps_bitstrm , 1 ) ; //<S2SV> ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = value ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ! first_slice_in_pic_flag ) && //<S2SV> ( ps_codec -> i4_pic_present ) ) //<S2SV> { //<S2SV> slice_header_t * ps_slice_hdr_base = ps_codec -> ps_slice_hdr_base ; //<S2SV> if ( ( ps_slice_hdr_base -> i1_pps_id != ps_slice_hdr -> i1_pps_id ) || //<S2SV> ( ps_slice_hdr_base -> i4_pic_order_cnt_lsb != ps_slice_hdr -> i4_pic_order_cnt_lsb ) ) //<S2SV> { //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> } //<S2SV> } //<S2SV> if ( 0 == ps_codec -> i4_pic_present ) //<S2SV> { //<S2SV> ps_slice_hdr -> i4_abs_pic_order_cnt = ihevcd_calc_poc ( ps_codec , ps_nal , ps_sps -> i1_log2_max_pic_order_cnt_lsb , ps_slice_hdr -> i4_pic_order_cnt_lsb ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_slice_hdr -> i4_abs_pic_order_cnt = ps_codec -> s_parse . i4_abs_pic_order_cnt ; //<S2SV> } //<S2SV> if ( ! first_slice_in_pic_flag ) //<S2SV> { //<S2SV> if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) //<S2SV> { //<S2SV> if ( slice_address > ps_codec -> s_parse . i4_next_ctb_indx ) //<S2SV> { //<S2SV> if ( ps_codec -> i4_pic_present ) //<S2SV> { //<S2SV> ps_codec -> i4_slice_error = 1 ; //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx -- ; //<S2SV> if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx = 0 ; //<S2SV> return ret ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> } //<S2SV> } //<S2SV> else if ( slice_address < ps_codec -> s_parse . i4_next_ctb_indx ) //<S2SV> { //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_codec -> i4_slice_error = 0 ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ps_codec -> i4_pic_present ) //<S2SV> { //<S2SV> slice_header_t * ps_slice_hdr_next ; //<S2SV> ps_codec -> i4_slice_error = 1 ; //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx -- ; //<S2SV> if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx = 0 ; //<S2SV> ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; //<S2SV> ps_slice_hdr_next -> i2_ctb_x = 0 ; //<S2SV> ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; //<S2SV> return ret ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ps_slice_hdr -> i1_dependent_slice_flag ) //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; //<S2SV> } //<S2SV> ps_slice_hdr -> i4_num_entry_point_offsets = 0 ; //<S2SV> if ( ( ps_pps -> i1_tiles_enabled_flag ) || //<S2SV> ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) //<S2SV> { //<S2SV> UEV_PARSE ( "num_entry_point_offsets" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i4_num_entry_point_offsets = value ; //<S2SV> { //<S2SV> WORD32 max_num_entry_point_offsets ; //<S2SV> if ( ( ps_pps -> i1_tiles_enabled_flag ) && //<S2SV> ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) //<S2SV> { //<S2SV> max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; //<S2SV> } //<S2SV> else if ( ps_pps -> i1_tiles_enabled_flag ) //<S2SV> { //<S2SV> max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ps_pps -> i1_num_tile_rows ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> max_num_entry_point_offsets = ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; //<S2SV> } //<S2SV> ps_slice_hdr -> i4_num_entry_point_offsets = CLIP3 ( ps_slice_hdr -> i4_num_entry_point_offsets , //<S2SV> 0 , max_num_entry_point_offsets ) ; //<S2SV> } //<S2SV> if ( ps_slice_hdr -> i4_num_entry_point_offsets > 0 ) //<S2SV> { //<S2SV> UEV_PARSE ( "offset_len_minus1" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i1_offset_len = value + 1 ; //<S2SV> for ( i = 0 ; i < ps_slice_hdr -> i4_num_entry_point_offsets ; i ++ ) //<S2SV> { //<S2SV> BITS_PARSE ( "entry_point_offset" , value , ps_bitstrm , ps_slice_hdr -> i1_offset_len ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ps_pps -> i1_slice_header_extension_present_flag ) //<S2SV> { //<S2SV> UEV_PARSE ( "slice_header_extension_length" , value , ps_bitstrm ) ; //<S2SV> ps_slice_hdr -> i2_slice_header_extension_length = value ; //<S2SV> for ( i = 0 ; i < ps_slice_hdr -> i2_slice_header_extension_length ; i ++ ) //<S2SV> { //<S2SV> BITS_PARSE ( "slice_header_extension_data_byte" , value , ps_bitstrm , 8 ) ; //<S2SV> } //<S2SV> } //<S2SV> ihevcd_bits_flush_to_byte_boundary ( ps_bitstrm ) ; //<S2SV> { //<S2SV> dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; //<S2SV> WORD32 r_idx ; //<S2SV> if ( ( NAL_IDR_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || //<S2SV> ( NAL_IDR_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || //<S2SV> ( NAL_BLA_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || //<S2SV> ( NAL_BLA_W_DLP == ps_slice_hdr -> i1_nal_unit_type ) || //<S2SV> ( NAL_BLA_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || //<S2SV> ( 0 == ps_codec -> u4_pic_cnt ) ) //<S2SV> { //<S2SV> for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) //<S2SV> { //<S2SV> if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) //<S2SV> { //<S2SV> pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; //<S2SV> mv_buf_t * ps_mv_buf ; //<S2SV> ihevc_dpb_mgr_del_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; //<S2SV> ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ; //<S2SV> for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j ++ ) //<S2SV> { //<S2SV> if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) //<S2SV> { //<S2SV> ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , j , BUF_MGR_REF ) ; //<S2SV> break ; //<S2SV> } //<S2SV> ps_mv_buf ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( r_idx = 0 ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) //<S2SV> { //<S2SV> ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = NULL ; //<S2SV> ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = NULL ; //<S2SV> ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = NULL ; //<S2SV> ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = NULL ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ret = ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; //<S2SV> if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) //<S2SV> { //<S2SV> return ret ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ps_codec -> i4_pic_present ) //<S2SV> { //<S2SV> pic_buf_t * ps_pic_buf_ref ; //<S2SV> mv_buf_t * ps_mv_buf_ref ; //<S2SV> WORD32 r_idx ; //<S2SV> dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; //<S2SV> buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; //<S2SV> ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ps_slice_hdr -> i4_abs_pic_order_cnt ) ; //<S2SV> if ( NULL == ps_pic_buf_ref ) //<S2SV> { //<S2SV> ps_pic_buf_ref = ps_codec -> as_process [ 0 ] . ps_cur_pic ; //<S2SV> ps_mv_buf_ref = ps_codec -> s_parse . ps_cur_mv_buf ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_mv_buf_ref = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf_ref -> i4_abs_poc ) ; //<S2SV> } //<S2SV> for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) //<S2SV> { //<S2SV> if ( NULL == ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ) //<S2SV> { //<S2SV> ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; //<S2SV> ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; //<S2SV> } //<S2SV> } //<S2SV> for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) //<S2SV> { //<S2SV> ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; //<S2SV> ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; //<S2SV> } //<S2SV> for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) //<S2SV> { //<S2SV> if ( NULL == ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ) //<S2SV> { //<S2SV> ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; //<S2SV> ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; //<S2SV> } //<S2SV> } //<S2SV> for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) //<S2SV> { //<S2SV> ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; //<S2SV> ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) //<S2SV> { //<S2SV> ps_slice_hdr -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> ps_slice_hdr -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) //<S2SV> { //<S2SV> ps_slice_hdr -> i2_independent_ctb_x = ps_slice_hdr -> i2_ctb_x ; //<S2SV> ps_slice_hdr -> i2_independent_ctb_y = ps_slice_hdr -> i2_ctb_y ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_slice_hdr -> i2_ctb_x = 0 ; //<S2SV> ps_slice_hdr -> i2_ctb_y = 0 ; //<S2SV> ps_slice_hdr -> i2_independent_ctb_x = 0 ; //<S2SV> ps_slice_hdr -> i2_independent_ctb_y = 0 ; //<S2SV> } //<S2SV> if ( ( ! first_slice_in_pic_flag ) && //<S2SV> ( 0 == ps_codec -> i4_pic_present ) ) //<S2SV> { //<S2SV> slice_header_t * ps_slice_hdr_prev = ps_codec -> s_parse . ps_slice_hdr_base ; //<S2SV> ihevcd_copy_slice_hdr ( ps_codec , 0 , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; //<S2SV> ps_codec -> i4_slice_error = 1 ; //<S2SV> ps_slice_hdr_prev -> i2_ctb_x = 0 ; //<S2SV> ps_slice_hdr_prev -> i2_ctb_y = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_x = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_y = 0 ; //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx = 0 ; //<S2SV> if ( ( ps_slice_hdr -> i2_ctb_x == 0 ) && //<S2SV> ( ps_slice_hdr -> i2_ctb_y == 0 ) ) //<S2SV> { //<S2SV> ps_slice_hdr -> i2_ctb_x ++ ; //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> if ( ( i1_nal_unit_type < NAL_BLA_W_LP ) && //<S2SV> ( i1_nal_unit_type % 2 == 0 ) ) //<S2SV> { //<S2SV> if ( IVD_SKIP_B == ps_codec -> e_pic_skip_mode ) //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> } //<S2SV> if ( ( IVD_SKIP_PB == ps_codec -> e_pic_skip_mode ) && //<S2SV> ( ISLICE != ps_slice_hdr -> i1_slice_type ) ) //<S2SV> { //<S2SV> return IHEVCD_IGNORE_SLICE ; //<S2SV> } //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 