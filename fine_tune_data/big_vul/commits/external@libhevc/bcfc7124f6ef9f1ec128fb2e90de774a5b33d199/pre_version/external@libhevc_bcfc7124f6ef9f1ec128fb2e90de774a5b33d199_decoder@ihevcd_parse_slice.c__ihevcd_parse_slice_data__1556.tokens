IHEVCD_ERROR_T ihevcd_parse_slice_data ( codec_t * ps_codec ) //<S2SV> { //<S2SV> IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; //<S2SV> WORD32 end_of_slice_flag ; //<S2SV> sps_t * ps_sps ; //<S2SV> pps_t * ps_pps ; //<S2SV> slice_header_t * ps_slice_hdr ; //<S2SV> WORD32 end_of_pic ; //<S2SV> tile_t * ps_tile , * ps_tile_prev ; //<S2SV> WORD32 i ; //<S2SV> WORD32 ctb_addr ; //<S2SV> WORD32 tile_idx ; //<S2SV> WORD32 cabac_init_idc ; //<S2SV> WORD32 ctb_size ; //<S2SV> WORD32 num_ctb_in_row ; //<S2SV> WORD32 num_min4x4_in_ctb ; //<S2SV> WORD32 slice_qp ; //<S2SV> WORD32 slice_start_ctb_idx ; //<S2SV> WORD32 tile_start_ctb_idx ; //<S2SV> ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base ; //<S2SV> ps_pps = ps_codec -> s_parse . ps_pps_base ; //<S2SV> ps_sps = ps_codec -> s_parse . ps_sps_base ; //<S2SV> ps_slice_hdr += ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; //<S2SV> ps_pps += ps_slice_hdr -> i1_pps_id ; //<S2SV> ps_sps += ps_pps -> i1_sps_id ; //<S2SV> if ( 0 != ps_codec -> s_parse . i4_cur_slice_idx ) //<S2SV> { //<S2SV> if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_cur_independent_slice_idx = //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> ctb_size = 1 << ps_sps -> i1_log2_ctb_size ; //<S2SV> num_min4x4_in_ctb = ( ctb_size / 4 ) * ( ctb_size / 4 ) ; //<S2SV> num_ctb_in_row = ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> if ( 0 == ps_codec -> i4_slice_error ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_x = ps_slice_hdr -> i2_ctb_x ; //<S2SV> ps_codec -> s_parse . i4_ctb_y = ps_slice_hdr -> i2_ctb_y ; //<S2SV> } //<S2SV> ps_codec -> s_parse . ps_pps = ps_pps ; //<S2SV> ps_codec -> s_parse . ps_sps = ps_sps ; //<S2SV> ps_codec -> s_parse . ps_slice_hdr = ps_slice_hdr ; //<S2SV> ihevcd_get_tile_pos ( ps_pps , ps_sps , ps_codec -> s_parse . i4_ctb_x , //<S2SV> ps_codec -> s_parse . i4_ctb_y , //<S2SV> & ps_codec -> s_parse . i4_ctb_tile_x , //<S2SV> & ps_codec -> s_parse . i4_ctb_tile_y , //<S2SV> & tile_idx ) ; //<S2SV> ps_codec -> s_parse . ps_tile = ps_pps -> ps_tile + tile_idx ; //<S2SV> ps_codec -> s_parse . i4_cur_tile_idx = tile_idx ; //<S2SV> ps_tile = ps_codec -> s_parse . ps_tile ; //<S2SV> if ( tile_idx ) //<S2SV> ps_tile_prev = ps_tile - 1 ; //<S2SV> else //<S2SV> ps_tile_prev = ps_tile ; //<S2SV> if ( 0 == ps_codec -> i4_slice_error ) //<S2SV> { //<S2SV> if ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) //<S2SV> { //<S2SV> if ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_slice_x = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_slice_y = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_slice_x = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_slice_y = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( 0 == ps_codec -> s_parse . i4_ctb_y ) && //<S2SV> ( 0 == ps_codec -> s_parse . i4_ctb_x ) ) //<S2SV> { //<S2SV> ret = ihevcd_parse_pic_init ( ps_codec ) ; //<S2SV> RETURN_IF ( ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) , ret ) ; //<S2SV> ps_codec -> s_parse . pu4_pic_tu_idx [ 0 ] = 0 ; //<S2SV> ps_codec -> s_parse . pu4_pic_pu_idx [ 0 ] = 0 ; //<S2SV> ps_codec -> s_parse . i4_cur_independent_slice_idx = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_tile_x = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_tile_y = 0 ; //<S2SV> } //<S2SV> { //<S2SV> mv_buf_t * ps_mv_buf = ps_codec -> s_parse . ps_cur_mv_buf ; //<S2SV> if ( ps_slice_hdr -> i1_num_ref_idx_l1_active != 0 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l1_active ; i ++ ) //<S2SV> { //<S2SV> ps_mv_buf -> ai4_l1_collocated_poc [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_pic_buf ) -> i4_abs_poc ; //<S2SV> ps_mv_buf -> ai1_l1_collocated_poc_lt [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_pic_buf ) -> u1_used_as_ref ; //<S2SV> } //<S2SV> } //<S2SV> if ( ps_slice_hdr -> i1_num_ref_idx_l0_active != 0 ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l0_active ; i ++ ) //<S2SV> { //<S2SV> ps_mv_buf -> ai4_l0_collocated_poc [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_pic_buf ) -> i4_abs_poc ; //<S2SV> ps_mv_buf -> ai1_l0_collocated_poc_lt [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_pic_buf ) -> u1_used_as_ref ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) || ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) ) //<S2SV> { //<S2SV> WORD32 cur_poc , ref_list_poc , flag = 1 ; //<S2SV> cur_poc = ps_slice_hdr -> i4_abs_pic_order_cnt ; //<S2SV> for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l0_active ; i ++ ) //<S2SV> { //<S2SV> ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_mv_buf ) -> i4_abs_poc ; //<S2SV> if ( ref_list_poc > cur_poc ) //<S2SV> { //<S2SV> flag = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( flag && ( ps_slice_hdr -> i1_slice_type == BSLICE ) ) //<S2SV> { //<S2SV> for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l1_active ; i ++ ) //<S2SV> { //<S2SV> ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_mv_buf ) -> i4_abs_poc ; //<S2SV> if ( ref_list_poc > cur_poc ) //<S2SV> { //<S2SV> flag = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ps_slice_hdr -> i1_low_delay_flag = flag ; //<S2SV> } //<S2SV> if ( ps_slice_hdr -> i1_slice_type == ISLICE ) //<S2SV> { //<S2SV> cabac_init_idc = 0 ; //<S2SV> } //<S2SV> else if ( ps_slice_hdr -> i1_slice_type == PSLICE ) //<S2SV> { //<S2SV> cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 2 : 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 1 : 2 ; //<S2SV> } //<S2SV> slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ; //<S2SV> slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ; //<S2SV> if ( ( 0 == ps_slice_hdr -> i1_dependent_slice_flag ) || //<S2SV> ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) ) ) //<S2SV> { //<S2SV> ps_codec -> s_parse . u4_qp = slice_qp ; //<S2SV> } //<S2SV> if ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ! ( ( ps_codec -> s_parse . i4_ctb_tile_x == 0 ) && ( ps_codec -> s_parse . i4_ctb_tile_y == 0 ) ) ) ) //<S2SV> { //<S2SV> if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) //<S2SV> { //<S2SV> ihevcd_cabac_reset ( & ps_codec -> s_parse . s_cabac , //<S2SV> & ps_codec -> s_parse . s_bitstrm ) ; //<S2SV> } //<S2SV> } //<S2SV> else if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) //<S2SV> { //<S2SV> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , //<S2SV> & ps_codec -> s_parse . s_bitstrm , //<S2SV> slice_qp , //<S2SV> cabac_init_idc , //<S2SV> & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; //<S2SV> } //<S2SV> do //<S2SV> { //<S2SV> { //<S2SV> WORD32 cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x //<S2SV> + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> if ( 1 == ps_codec -> i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB ) //<S2SV> { //<S2SV> ps_codec -> s_parse . ps_tu = ps_codec -> s_parse . ps_pic_tu ; //<S2SV> ps_codec -> s_parse . i4_pic_tu_idx = 0 ; //<S2SV> } //<S2SV> } //<S2SV> end_of_pic = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_num_pcm_blks = 0 ; //<S2SV> if ( ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) //<S2SV> && ( ! ( ( ps_tile -> u1_pos_x == 0 ) && ( ps_tile -> u1_pos_y == 0 ) ) ) //<S2SV> && ( ! ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) ) ) ) //<S2SV> { //<S2SV> slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ; //<S2SV> slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ; //<S2SV> ps_codec -> s_parse . u4_qp = slice_qp ; //<S2SV> ihevcd_get_tile_pos ( ps_pps , ps_sps , ps_codec -> s_parse . i4_ctb_x , //<S2SV> ps_codec -> s_parse . i4_ctb_y , //<S2SV> & ps_codec -> s_parse . i4_ctb_tile_x , //<S2SV> & ps_codec -> s_parse . i4_ctb_tile_y , //<S2SV> & tile_idx ) ; //<S2SV> ps_codec -> s_parse . ps_tile = ps_pps -> ps_tile + tile_idx ; //<S2SV> ps_codec -> s_parse . i4_cur_tile_idx = tile_idx ; //<S2SV> ps_tile_prev = ps_tile - 1 ; //<S2SV> tile_start_ctb_idx = ps_tile -> u1_pos_x //<S2SV> + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x //<S2SV> + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> if ( slice_start_ctb_idx < tile_start_ctb_idx ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_slice_y = ps_tile -> u1_pos_y - ps_slice_hdr -> i2_ctb_y ; //<S2SV> if ( ! ( ( ( ps_slice_hdr -> i2_ctb_x + ps_tile_prev -> u2_wd ) % ps_sps -> i2_pic_wd_in_ctb ) == ps_tile -> u1_pos_x ) ) //<S2SV> { //<S2SV> if ( ps_slice_hdr -> i2_ctb_y <= ps_tile -> u1_pos_y ) //<S2SV> { //<S2SV> if ( ps_slice_hdr -> i2_ctb_x > ps_tile -> u1_pos_x ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_slice_y -= 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , //<S2SV> & ps_codec -> s_parse . s_bitstrm , //<S2SV> slice_qp , //<S2SV> cabac_init_idc , //<S2SV> & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) //<S2SV> { //<S2SV> if ( 1 < ps_codec -> i4_num_cores ) //<S2SV> { //<S2SV> proc_job_t s_job ; //<S2SV> IHEVCD_ERROR_T ret ; //<S2SV> s_job . i4_cmd = CMD_PROCESS ; //<S2SV> s_job . i2_ctb_cnt = ( WORD16 ) ps_tile -> u2_wd ; //<S2SV> s_job . i2_ctb_x = ( WORD16 ) ps_codec -> s_parse . i4_ctb_x ; //<S2SV> s_job . i2_ctb_y = ( WORD16 ) ps_codec -> s_parse . i4_ctb_y ; //<S2SV> s_job . i2_slice_idx = ( WORD16 ) ps_codec -> s_parse . i4_cur_slice_idx ; //<S2SV> s_job . i4_tu_coeff_data_ofst = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - //<S2SV> ( UWORD8 * ) ps_codec -> s_parse . pv_pic_tu_coeff_data ; //<S2SV> ret = ihevcd_jobq_queue ( ( jobq_t * ) ps_codec -> s_parse . pv_proc_jobq , & s_job , sizeof ( proc_job_t ) , 1 ) ; //<S2SV> if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) //<S2SV> return ret ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> process_ctxt_t * ps_proc = & ps_codec -> as_process [ 0 ] ; //<S2SV> WORD32 tu_coeff_data_ofst = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - //<S2SV> ( UWORD8 * ) ps_codec -> s_parse . pv_pic_tu_coeff_data ; //<S2SV> ps_proc -> i4_ctb_cnt = ps_tile -> u2_wd ; //<S2SV> ps_proc -> i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; //<S2SV> ps_proc -> i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; //<S2SV> ps_proc -> i4_cur_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx ; //<S2SV> ihevcd_init_proc_ctxt ( ps_proc , tu_coeff_data_ofst ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) //<S2SV> { //<S2SV> if ( 0 == ps_codec -> s_parse . i4_ctb_x ) //<S2SV> { //<S2SV> WORD32 default_ctxt = 0 ; //<S2SV> if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) && ( ! ps_slice_hdr -> i1_dependent_slice_flag ) ) //<S2SV> default_ctxt = 1 ; //<S2SV> if ( 1 == ps_sps -> i2_pic_wd_in_ctb ) //<S2SV> default_ctxt = 1 ; //<S2SV> ps_codec -> s_parse . u4_qp = slice_qp ; //<S2SV> if ( default_ctxt ) //<S2SV> { //<S2SV> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , //<S2SV> & ps_codec -> s_parse . s_bitstrm , //<S2SV> slice_qp , //<S2SV> cabac_init_idc , //<S2SV> & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , //<S2SV> & ps_codec -> s_parse . s_bitstrm , //<S2SV> slice_qp , //<S2SV> cabac_init_idc , //<S2SV> ( const UWORD8 * ) & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( 0 == ps_codec -> i4_slice_error ) //<S2SV> { //<S2SV> if ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag ) //<S2SV> ihevcd_parse_sao ( ps_codec ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> sao_t * ps_sao = ps_codec -> s_parse . ps_pic_sao + //<S2SV> ps_codec -> s_parse . i4_ctb_x + //<S2SV> ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> ps_sao -> b3_y_type_idx = 0 ; //<S2SV> ps_sao -> b3_cb_type_idx = 0 ; //<S2SV> ps_sao -> b3_cr_type_idx = 0 ; //<S2SV> } //<S2SV> { //<S2SV> WORD32 ctb_indx ; //<S2SV> ctb_indx = ps_codec -> s_parse . i4_ctb_x + ps_sps -> i2_pic_wd_in_ctb * ps_codec -> s_parse . i4_ctb_y ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . pu1_pic_qp_const_in_ctb [ ctb_indx >> 3 ] |= ( 1 << ( ctb_indx & 7 ) ) ; //<S2SV> { //<S2SV> UWORD16 * pu1_slice_idx = ps_codec -> s_parse . pu1_slice_idx ; //<S2SV> pu1_slice_idx [ ctb_indx ] = ps_codec -> s_parse . i4_cur_independent_slice_idx ; //<S2SV> } //<S2SV> } //<S2SV> if ( 0 == ps_codec -> i4_slice_error ) //<S2SV> { //<S2SV> ihevcd_parse_coding_quadtree ( ps_codec , //<S2SV> ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) , //<S2SV> ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) , //<S2SV> ps_sps -> i1_log2_ctb_size , //<S2SV> 0 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; //<S2SV> pu_t * ps_pu = ps_codec -> s_parse . ps_pu ; //<S2SV> ps_tu -> b1_cb_cbf = 0 ; //<S2SV> ps_tu -> b1_cr_cbf = 0 ; //<S2SV> ps_tu -> b1_y_cbf = 0 ; //<S2SV> ps_tu -> b4_pos_x = 0 ; //<S2SV> ps_tu -> b4_pos_y = 0 ; //<S2SV> ps_tu -> b1_transquant_bypass = 0 ; //<S2SV> ps_tu -> b3_size = ( ps_sps -> i1_log2_ctb_size - 2 ) ; //<S2SV> ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; //<S2SV> ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; //<S2SV> ps_tu -> b6_luma_intra_mode = INTRA_PRED_NONE ; //<S2SV> ps_tu -> b1_first_tu_in_cu = 1 ; //<S2SV> ps_codec -> s_parse . ps_tu ++ ; //<S2SV> ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; //<S2SV> ps_codec -> s_parse . i4_pic_tu_idx ++ ; //<S2SV> ps_codec -> s_parse . s_cu . i4_pred_mode = PRED_MODE_SKIP ; //<S2SV> ps_codec -> s_parse . s_cu . i4_part_mode = PART_2Nx2N ; //<S2SV> ps_pu -> b2_part_idx = 0 ; //<S2SV> ps_pu -> b4_pos_x = 0 ; //<S2SV> ps_pu -> b4_pos_y = 0 ; //<S2SV> ps_pu -> b4_wd = ( ctb_size >> 2 ) - 1 ; //<S2SV> ps_pu -> b4_ht = ( ctb_size >> 2 ) - 1 ; //<S2SV> ps_pu -> b1_intra_flag = 0 ; //<S2SV> ps_pu -> b3_part_mode = ps_codec -> s_parse . s_cu . i4_part_mode ; //<S2SV> ps_pu -> b1_merge_flag = 1 ; //<S2SV> ps_pu -> b3_merge_idx = 0 ; //<S2SV> ps_codec -> s_parse . ps_pu ++ ; //<S2SV> ps_codec -> s_parse . i4_pic_pu_idx ++ ; //<S2SV> } //<S2SV> if ( 0 == ps_codec -> i4_slice_error ) //<S2SV> end_of_slice_flag = ihevcd_cabac_decode_terminate ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; //<S2SV> else //<S2SV> end_of_slice_flag = 0 ; //<S2SV> AEV_TRACE ( "end_of_slice_flag" , end_of_slice_flag , ps_codec -> s_parse . s_cabac . u4_range ) ; //<S2SV> if ( ps_pps -> i1_tiles_enabled_flag || ps_pps -> i1_entropy_coding_sync_enabled_flag ) //<S2SV> { //<S2SV> WORD32 end_of_tile = 0 ; //<S2SV> WORD32 end_of_tile_row = 0 ; //<S2SV> if ( ps_pps -> i1_entropy_coding_sync_enabled_flag || ps_pps -> i1_tiles_enabled_flag ) //<S2SV> { //<S2SV> if ( 1 == ps_codec -> s_parse . i4_ctb_x ) //<S2SV> { //<S2SV> WORD32 size = sizeof ( ps_codec -> s_parse . s_cabac . au1_ctxt_models ) ; //<S2SV> memcpy ( & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync , & ps_codec -> s_parse . s_cabac . au1_ctxt_models , size ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) == ( ps_tile -> u2_wd ) ) //<S2SV> { //<S2SV> end_of_tile_row = 1 ; //<S2SV> if ( ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) == ps_tile -> u2_ht ) //<S2SV> end_of_tile = 1 ; //<S2SV> } //<S2SV> if ( ( 0 == end_of_slice_flag ) && //<S2SV> ( ( ps_pps -> i1_tiles_enabled_flag && end_of_tile ) || //<S2SV> ( ps_pps -> i1_entropy_coding_sync_enabled_flag && end_of_tile_row ) ) ) //<S2SV> { //<S2SV> WORD32 end_of_sub_stream_one_bit ; //<S2SV> end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; //<S2SV> AEV_TRACE ( "end_of_sub_stream_one_bit" , end_of_sub_stream_one_bit , ps_codec -> s_parse . s_cabac . u4_range ) ; //<S2SV> if ( ps_codec -> s_parse . s_bitstrm . u4_bit_ofst % 8 ) //<S2SV> ihevcd_bits_flush_to_byte_boundary ( & ps_codec -> s_parse . s_bitstrm ) ; //<S2SV> UNUSED ( end_of_sub_stream_one_bit ) ; //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> WORD32 ctb_indx ; //<S2SV> ctb_addr = ps_codec -> s_parse . i4_ctb_y * num_ctb_in_row + ps_codec -> s_parse . i4_ctb_x ; //<S2SV> ctb_indx = ++ ctb_addr ; //<S2SV> if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) //<S2SV> { //<S2SV> ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; //<S2SV> if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) //<S2SV> { //<S2SV> if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) //<S2SV> { //<S2SV> ctb_indx = ctb_addr ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; //<S2SV> ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ps_codec -> s_parse . pu4_pic_pu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_pu_idx ; //<S2SV> ps_codec -> s_parse . i4_next_pu_ctb_cnt = ctb_indx ; //<S2SV> ps_codec -> s_parse . pu1_pu_map += num_min4x4_in_ctb ; //<S2SV> if ( 1 == ps_codec -> i4_num_cores ) //<S2SV> { //<S2SV> ctb_indx = ( 0 == ctb_addr % RESET_TU_BUF_NCTB ) ? //<S2SV> RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB ; //<S2SV> if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) //<S2SV> { //<S2SV> ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; //<S2SV> if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) //<S2SV> { //<S2SV> if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) //<S2SV> { //<S2SV> ctb_indx = ( 0 == ctb_addr % RESET_TU_BUF_NCTB ) ? //<S2SV> RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; //<S2SV> ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ps_codec -> s_parse . i4_next_tu_ctb_cnt = ctb_indx ; //<S2SV> ps_codec -> s_parse . pu4_pic_tu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_tu_idx ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ctb_indx = ctb_addr ; //<S2SV> if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) //<S2SV> { //<S2SV> ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; //<S2SV> if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) //<S2SV> { //<S2SV> if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) //<S2SV> { //<S2SV> ctb_indx = ctb_addr ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; //<S2SV> ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ps_codec -> s_parse . i4_next_tu_ctb_cnt = ctb_indx ; //<S2SV> ps_codec -> s_parse . pu4_pic_tu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_tu_idx ; //<S2SV> } //<S2SV> ps_codec -> s_parse . pu1_tu_map += num_min4x4_in_ctb ; //<S2SV> } //<S2SV> if ( ( 0 != ps_codec -> i4_disable_deblk_pic ) && //<S2SV> ( 1 == ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) ) //<S2SV> { //<S2SV> bs_ctxt_t * ps_bs_ctxt = & ps_codec -> s_parse . s_bs_ctxt ; //<S2SV> WORD32 log2_ctb_size = ps_sps -> i1_log2_ctb_size ; //<S2SV> UWORD8 * pu1_qp ; //<S2SV> WORD32 qp_strd ; //<S2SV> WORD32 u4_qp_const_in_ctb ; //<S2SV> WORD32 cur_ctb_idx ; //<S2SV> WORD32 next_ctb_idx ; //<S2SV> WORD32 cur_tu_idx ; //<S2SV> WORD32 i4_ctb_tu_cnt ; //<S2SV> tu_t * ps_tu ; //<S2SV> cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_sps -> i2_pic_wd_in_ctb * ps_codec -> s_parse . i4_ctb_y ; //<S2SV> qp_strd = ps_sps -> i2_pic_wd_in_ctb << ( log2_ctb_size - 3 ) ; //<S2SV> pu1_qp = ps_bs_ctxt -> pu1_pic_qp + ( ( ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * qp_strd ) << ( log2_ctb_size - 3 ) ) ; //<S2SV> u4_qp_const_in_ctb = ps_bs_ctxt -> pu1_pic_qp_const_in_ctb [ cur_ctb_idx >> 3 ] & ( 1 << ( cur_ctb_idx & 7 ) ) ; //<S2SV> next_ctb_idx = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; //<S2SV> if ( 1 == ps_codec -> i4_num_cores ) //<S2SV> { //<S2SV> i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - //<S2SV> ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; //<S2SV> cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - //<S2SV> ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; //<S2SV> cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; //<S2SV> } //<S2SV> ps_tu = & ps_codec -> s_parse . ps_pic_tu [ cur_tu_idx ] ; //<S2SV> if ( u4_qp_const_in_ctb ) //<S2SV> { //<S2SV> pu1_qp [ 0 ] = ps_tu -> b7_qp ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> for ( i = 0 ; i < i4_ctb_tu_cnt ; i ++ , ps_tu ++ ) //<S2SV> { //<S2SV> WORD32 start_pos_x ; //<S2SV> WORD32 start_pos_y ; //<S2SV> WORD32 tu_size ; //<S2SV> start_pos_x = ps_tu -> b4_pos_x ; //<S2SV> start_pos_y = ps_tu -> b4_pos_y ; //<S2SV> tu_size = 1 << ( ps_tu -> b3_size + 2 ) ; //<S2SV> tu_size >>= 2 ; //<S2SV> if ( 0 == ( start_pos_x & 1 ) && 0 == ( start_pos_y & 1 ) ) //<S2SV> { //<S2SV> WORD32 row , col ; //<S2SV> for ( row = start_pos_y ; row < start_pos_y + tu_size ; row += 2 ) //<S2SV> { //<S2SV> for ( col = start_pos_x ; col < start_pos_x + tu_size ; col += 2 ) //<S2SV> { //<S2SV> pu1_qp [ ( row >> 1 ) * qp_strd + ( col >> 1 ) ] = ps_tu -> b7_qp ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ps_codec -> i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD ) //<S2SV> { //<S2SV> WORD8 u1_top_ctb_avail = 1 ; //<S2SV> WORD8 u1_left_ctb_avail = 1 ; //<S2SV> WORD8 u1_top_lt_ctb_avail = 1 ; //<S2SV> WORD8 u1_top_rt_ctb_avail = 1 ; //<S2SV> WORD16 i2_wd_in_ctb ; //<S2SV> tile_start_ctb_idx = ps_tile -> u1_pos_x //<S2SV> + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x //<S2SV> + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> if ( ( slice_start_ctb_idx < tile_start_ctb_idx ) ) //<S2SV> { //<S2SV> i2_wd_in_ctb = ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> i2_wd_in_ctb = ps_tile -> u2_wd ; //<S2SV> } //<S2SV> if ( ( 0 == ps_codec -> s_parse . i4_ctb_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) //<S2SV> { //<S2SV> u1_top_ctb_avail = 0 ; //<S2SV> u1_top_lt_ctb_avail = 0 ; //<S2SV> u1_top_rt_ctb_avail = 0 ; //<S2SV> } //<S2SV> if ( ( 0 == ps_codec -> s_parse . i4_ctb_x ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) ) //<S2SV> { //<S2SV> u1_left_ctb_avail = 0 ; //<S2SV> u1_top_lt_ctb_avail = 0 ; //<S2SV> if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) //<S2SV> { //<S2SV> u1_top_ctb_avail = 0 ; //<S2SV> if ( ( i2_wd_in_ctb - 1 ) != ps_codec -> s_parse . i4_ctb_slice_x ) //<S2SV> { //<S2SV> u1_top_rt_ctb_avail = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else if ( ps_codec -> s_parse . i4_ctb_x > 0 ) //<S2SV> { //<S2SV> if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) //<S2SV> { //<S2SV> u1_top_ctb_avail = 0 ; //<S2SV> u1_top_lt_ctb_avail = 0 ; //<S2SV> if ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) //<S2SV> { //<S2SV> u1_left_ctb_avail = 0 ; //<S2SV> } //<S2SV> if ( ( i2_wd_in_ctb - 1 ) != ps_codec -> s_parse . i4_ctb_slice_x ) //<S2SV> { //<S2SV> u1_top_rt_ctb_avail = 0 ; //<S2SV> } //<S2SV> } //<S2SV> else if ( ( 1 == ps_codec -> s_parse . i4_ctb_slice_y ) && ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) ) //<S2SV> { //<S2SV> u1_top_lt_ctb_avail = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ( ps_sps -> i2_pic_wd_in_ctb - 1 ) == ps_codec -> s_parse . i4_ctb_x ) || ( ( ps_tile -> u2_wd - 1 ) == ps_codec -> s_parse . i4_ctb_tile_x ) ) //<S2SV> { //<S2SV> u1_top_rt_ctb_avail = 0 ; //<S2SV> } //<S2SV> if ( PSLICE == ps_slice_hdr -> i1_slice_type //<S2SV> || BSLICE == ps_slice_hdr -> i1_slice_type ) //<S2SV> { //<S2SV> mv_ctxt_t s_mv_ctxt ; //<S2SV> process_ctxt_t * ps_proc ; //<S2SV> UWORD32 * pu4_ctb_top_pu_idx ; //<S2SV> UWORD32 * pu4_ctb_left_pu_idx ; //<S2SV> UWORD32 * pu4_ctb_top_left_pu_idx ; //<S2SV> WORD32 i4_ctb_pu_cnt ; //<S2SV> WORD32 cur_ctb_idx ; //<S2SV> WORD32 next_ctb_idx ; //<S2SV> WORD32 cur_pu_idx ; //<S2SV> ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; //<S2SV> cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x //<S2SV> + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> next_ctb_idx = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; //<S2SV> i4_ctb_pu_cnt = ps_codec -> s_parse . pu4_pic_pu_idx [ next_ctb_idx ] //<S2SV> - ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; //<S2SV> cur_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; //<S2SV> pu4_ctb_top_pu_idx = ps_proc -> pu4_pic_pu_idx_top //<S2SV> + ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) ; //<S2SV> pu4_ctb_left_pu_idx = ps_proc -> pu4_pic_pu_idx_left ; //<S2SV> pu4_ctb_top_left_pu_idx = & ps_proc -> u4_ctb_top_left_pu_idx ; //<S2SV> { //<S2SV> s_mv_ctxt . ps_pps = ps_pps ; //<S2SV> s_mv_ctxt . ps_sps = ps_sps ; //<S2SV> s_mv_ctxt . ps_slice_hdr = ps_slice_hdr ; //<S2SV> s_mv_ctxt . i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; //<S2SV> s_mv_ctxt . i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; //<S2SV> s_mv_ctxt . ps_pu = & ps_codec -> s_parse . ps_pic_pu [ cur_pu_idx ] ; //<S2SV> s_mv_ctxt . ps_pic_pu = ps_codec -> s_parse . ps_pic_pu ; //<S2SV> s_mv_ctxt . ps_tile = ps_tile ; //<S2SV> s_mv_ctxt . pu4_pic_pu_idx_map = ps_proc -> pu4_pic_pu_idx_map ; //<S2SV> s_mv_ctxt . pu4_pic_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx ; //<S2SV> s_mv_ctxt . pu1_pic_pu_map = ps_codec -> s_parse . pu1_pic_pu_map ; //<S2SV> s_mv_ctxt . i4_ctb_pu_cnt = i4_ctb_pu_cnt ; //<S2SV> s_mv_ctxt . i4_ctb_start_pu_idx = cur_pu_idx ; //<S2SV> s_mv_ctxt . u1_top_ctb_avail = u1_top_ctb_avail ; //<S2SV> s_mv_ctxt . u1_top_rt_ctb_avail = u1_top_rt_ctb_avail ; //<S2SV> s_mv_ctxt . u1_top_lt_ctb_avail = u1_top_lt_ctb_avail ; //<S2SV> s_mv_ctxt . u1_left_ctb_avail = u1_left_ctb_avail ; //<S2SV> } //<S2SV> ihevcd_get_mv_ctb ( & s_mv_ctxt , pu4_ctb_top_pu_idx , //<S2SV> pu4_ctb_left_pu_idx , pu4_ctb_top_left_pu_idx ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> WORD32 num_minpu_in_ctb = ( ctb_size / MIN_PU_SIZE ) * ( ctb_size / MIN_PU_SIZE ) ; //<S2SV> UWORD8 * pu1_pic_pu_map_ctb = ps_codec -> s_parse . pu1_pic_pu_map + //<S2SV> ( ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ) * num_minpu_in_ctb ; //<S2SV> process_ctxt_t * ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; //<S2SV> WORD32 row , col ; //<S2SV> WORD32 pu_cnt ; //<S2SV> WORD32 num_pu_per_ctb ; //<S2SV> WORD32 cur_ctb_idx ; //<S2SV> WORD32 next_ctb_idx ; //<S2SV> WORD32 ctb_start_pu_idx ; //<S2SV> UWORD32 * pu4_nbr_pu_idx = ps_proc -> pu4_pic_pu_idx_map ; //<S2SV> WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2 ; //<S2SV> pu_t * ps_pu ; //<S2SV> for ( row = 0 ; row < ctb_size / MIN_PU_SIZE ; row ++ ) //<S2SV> { //<S2SV> for ( col = 0 ; col < ctb_size / MIN_PU_SIZE ; col ++ ) //<S2SV> { //<S2SV> pu1_pic_pu_map_ctb [ row * ctb_size / MIN_PU_SIZE + col ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x //<S2SV> + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> next_ctb_idx = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; //<S2SV> num_pu_per_ctb = ps_codec -> s_parse . pu4_pic_pu_idx [ next_ctb_idx ] //<S2SV> - ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; //<S2SV> ctb_start_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; //<S2SV> ps_pu = & ps_codec -> s_parse . ps_pic_pu [ ctb_start_pu_idx ] ; //<S2SV> for ( pu_cnt = 0 ; pu_cnt < num_pu_per_ctb ; pu_cnt ++ , ps_pu ++ ) //<S2SV> { //<S2SV> UWORD32 cur_pu_idx ; //<S2SV> WORD32 pu_ht = ( ps_pu -> b4_ht + 1 ) << 2 ; //<S2SV> WORD32 pu_wd = ( ps_pu -> b4_wd + 1 ) << 2 ; //<S2SV> cur_pu_idx = ctb_start_pu_idx + pu_cnt ; //<S2SV> for ( row = 0 ; row < pu_ht / MIN_PU_SIZE ; row ++ ) //<S2SV> for ( col = 0 ; col < pu_wd / MIN_PU_SIZE ; col ++ ) //<S2SV> pu4_nbr_pu_idx [ ( 1 + ps_pu -> b4_pos_x + col ) //<S2SV> + ( 1 + ps_pu -> b4_pos_y + row ) //<S2SV> * nbr_pu_idx_strd ] = //<S2SV> cur_pu_idx ; //<S2SV> } //<S2SV> { //<S2SV> WORD32 rows_remaining = ps_sps -> i2_pic_height_in_luma_samples //<S2SV> - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ; //<S2SV> WORD32 ctb_size_left = MIN ( ctb_size , rows_remaining ) ; //<S2SV> ps_proc -> u4_ctb_top_left_pu_idx = ps_proc -> pu4_pic_pu_idx_top [ ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) + ctb_size / MIN_PU_SIZE - 1 ] ; //<S2SV> for ( i = 0 ; i < ctb_size / MIN_PU_SIZE ; i ++ ) //<S2SV> { //<S2SV> ps_proc -> pu4_pic_pu_idx_left [ i ] = pu4_nbr_pu_idx [ ( ctb_size / MIN_PU_SIZE ) //<S2SV> + ( i + 1 ) * nbr_pu_idx_strd ] ; //<S2SV> ps_proc -> pu4_pic_pu_idx_top [ ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) + i ] = //<S2SV> pu4_nbr_pu_idx [ ( ctb_size_left / MIN_PU_SIZE ) * nbr_pu_idx_strd + i + 1 ] ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( 0 == ps_codec -> i4_disable_deblk_pic ) //<S2SV> { //<S2SV> if ( ( 0 == ps_codec -> i4_slice_error ) ) //<S2SV> { //<S2SV> WORD32 i4_ctb_tu_cnt ; //<S2SV> WORD32 cur_ctb_idx , next_ctb_idx ; //<S2SV> WORD32 cur_pu_idx ; //<S2SV> WORD32 cur_tu_idx ; //<S2SV> process_ctxt_t * ps_proc ; //<S2SV> ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; //<S2SV> cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x //<S2SV> + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> cur_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; //<S2SV> next_ctb_idx = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; //<S2SV> if ( 1 == ps_codec -> i4_num_cores ) //<S2SV> { //<S2SV> i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - //<S2SV> ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; //<S2SV> cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - //<S2SV> ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; //<S2SV> cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; //<S2SV> } //<S2SV> ps_codec -> s_parse . s_bs_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . ps_codec = ps_codec ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tu_cnt = i4_ctb_tu_cnt ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tile_x = ps_codec -> s_parse . i4_ctb_tile_x ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tile_y = ps_codec -> s_parse . i4_ctb_tile_y ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_ctb_slice_x = ps_codec -> s_parse . i4_ctb_slice_x ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_ctb_slice_y = ps_codec -> s_parse . i4_ctb_slice_y ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . ps_tu = & ps_codec -> s_parse . ps_pic_tu [ cur_tu_idx ] ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . ps_pu = & ps_codec -> s_parse . ps_pic_pu [ cur_pu_idx ] ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . pu4_pic_pu_idx_map = ps_proc -> pu4_pic_pu_idx_map ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_next_pu_ctb_cnt = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . i4_next_tu_ctb_cnt = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . pu1_slice_idx = ps_codec -> s_parse . pu1_slice_idx ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; //<S2SV> ps_codec -> s_parse . s_bs_ctxt . ps_tile = ps_codec -> s_parse . ps_tile ; //<S2SV> if ( ISLICE == ps_slice_hdr -> i1_slice_type ) //<S2SV> { //<S2SV> ihevcd_ctb_boundary_strength_islice ( & ps_codec -> s_parse . s_bs_ctxt ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ihevcd_ctb_boundary_strength_pbslice ( & ps_codec -> s_parse . s_bs_ctxt ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( 0 != ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) //<S2SV> { //<S2SV> WORD32 bs_strd = ( ps_sps -> i2_pic_wd_in_ctb + 1 ) * ( ctb_size * ctb_size / 8 / 16 ) ; //<S2SV> UWORD32 * pu4_vert_bs = ( UWORD32 * ) ( ( UWORD8 * ) ps_codec -> s_parse . s_bs_ctxt . pu4_pic_vert_bs + //<S2SV> ps_codec -> s_parse . i4_ctb_x * ( ctb_size * ctb_size / 8 / 16 ) + //<S2SV> ps_codec -> s_parse . i4_ctb_y * bs_strd ) ; //<S2SV> UWORD32 * pu4_horz_bs = ( UWORD32 * ) ( ( UWORD8 * ) ps_codec -> s_parse . s_bs_ctxt . pu4_pic_horz_bs + //<S2SV> ps_codec -> s_parse . i4_ctb_x * ( ctb_size * ctb_size / 8 / 16 ) + //<S2SV> ps_codec -> s_parse . i4_ctb_y * bs_strd ) ; //<S2SV> memset ( pu4_vert_bs , 0 , ( ctb_size / 8 ) * ( ctb_size / 4 ) / 8 * 2 ) ; //<S2SV> memset ( pu4_horz_bs , 0 , ( ctb_size / 8 ) * ( ctb_size / 4 ) / 8 * 2 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> DATA_SYNC ( ) ; //<S2SV> { //<S2SV> sps_t * ps_sps = ps_codec -> s_parse . ps_sps ; //<S2SV> UWORD8 * pu1_buf ; //<S2SV> WORD32 idx ; //<S2SV> idx = ( ps_codec -> s_parse . i4_ctb_x ) ; //<S2SV> idx += ( ( ps_codec -> s_parse . i4_ctb_y ) * ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> pu1_buf = ( ps_codec -> pu1_parse_map + idx ) ; //<S2SV> * pu1_buf = 1 ; //<S2SV> } //<S2SV> ps_codec -> s_parse . i4_ctb_tile_x ++ ; //<S2SV> ps_codec -> s_parse . i4_ctb_x ++ ; //<S2SV> ps_codec -> s_parse . i4_ctb_slice_x ++ ; //<S2SV> if ( ps_pps -> i1_tiles_enabled_flag ) //<S2SV> { //<S2SV> tile_start_ctb_idx = ps_tile -> u1_pos_x //<S2SV> + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x //<S2SV> + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; //<S2SV> if ( ( slice_start_ctb_idx < tile_start_ctb_idx ) ) //<S2SV> { //<S2SV> if ( ps_codec -> s_parse . i4_ctb_slice_x == ( ps_tile -> u1_pos_x + ps_tile -> u2_wd ) ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_slice_y ++ ; //<S2SV> ps_codec -> s_parse . i4_ctb_slice_x = ps_tile -> u1_pos_x ; //<S2SV> } //<S2SV> } //<S2SV> else if ( ps_codec -> s_parse . i4_ctb_slice_x == ( ps_tile -> u2_wd ) ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_slice_y ++ ; //<S2SV> ps_codec -> s_parse . i4_ctb_slice_x = 0 ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ps_codec -> s_parse . i4_ctb_slice_x == ps_tile -> u2_wd ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_slice_y ++ ; //<S2SV> ps_codec -> s_parse . i4_ctb_slice_x = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ps_codec -> s_parse . i4_ctb_tile_x == ( ps_tile -> u2_wd ) ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_tile_x = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_x = ps_tile -> u1_pos_x ; //<S2SV> ps_codec -> s_parse . i4_ctb_tile_y ++ ; //<S2SV> ps_codec -> s_parse . i4_ctb_y ++ ; //<S2SV> if ( ps_codec -> s_parse . i4_ctb_tile_y == ( ps_tile -> u2_ht ) ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_ctb_tile_y = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_tile_x = 0 ; //<S2SV> ps_codec -> s_parse . ps_tile ++ ; //<S2SV> if ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) && ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) ) //<S2SV> { //<S2SV> end_of_pic = 1 ; //<S2SV> ps_codec -> s_parse . i4_ctb_x = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_y = ps_sps -> i2_pic_ht_in_ctb ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> ps_tile = ps_codec -> s_parse . ps_tile ; //<S2SV> ps_codec -> s_parse . i4_ctb_x = ps_tile -> u1_pos_x ; //<S2SV> ps_codec -> s_parse . i4_ctb_y = ps_tile -> u1_pos_y ; //<S2SV> ps_codec -> s_parse . i4_ctb_tile_y = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_tile_x = 0 ; //<S2SV> ps_codec -> s_parse . i4_ctb_slice_x = ps_tile -> u1_pos_x ; //<S2SV> ps_codec -> s_parse . i4_ctb_slice_y = ps_tile -> u1_pos_y ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> ps_codec -> s_parse . i4_next_ctb_indx = ps_codec -> s_parse . i4_ctb_x + //<S2SV> ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> if ( ps_codec -> i4_slice_error ) //<S2SV> { //<S2SV> slice_header_t * ps_slice_hdr_next = ps_slice_hdr + 1 ; //<S2SV> WORD32 next_slice_addr = ps_slice_hdr_next -> i2_ctb_x + //<S2SV> ps_slice_hdr_next -> i2_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; //<S2SV> if ( ps_codec -> s_parse . i4_next_ctb_indx == next_slice_addr ) //<S2SV> end_of_slice_flag = 1 ; //<S2SV> } //<S2SV> if ( ( 1 == ps_codec -> i4_num_cores ) && ( ps_codec -> s_parse . i4_ctb_tile_x == 0 ) ) //<S2SV> { //<S2SV> process_ctxt_t * ps_proc = & ps_codec -> as_process [ 0 ] ; //<S2SV> ps_proc -> i4_ctb_cnt = ps_proc -> ps_tile -> u2_wd ; //<S2SV> ihevcd_process ( ps_proc ) ; //<S2SV> } //<S2SV> if ( ( UWORD8 * ) ps_codec -> s_parse . s_bitstrm . pu1_buf_max + BITSTRM_OFF_THRS < //<S2SV> ( ( UWORD8 * ) ps_codec -> s_parse . s_bitstrm . pu4_buf + ( ps_codec -> s_parse . s_bitstrm . u4_bit_ofst / 8 ) ) ) //<S2SV> { //<S2SV> if ( 0 == ps_codec -> i4_slice_error ) //<S2SV> end_of_slice_flag = 1 ; //<S2SV> } //<S2SV> if ( end_of_pic ) //<S2SV> break ; //<S2SV> } while ( ! end_of_slice_flag ) ; //<S2SV> if ( 0 == end_of_pic ) //<S2SV> { //<S2SV> while ( 1 ) //<S2SV> { //<S2SV> WORD32 parse_slice_idx ; //<S2SV> parse_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx ; //<S2SV> parse_slice_idx ++ ; //<S2SV> { //<S2SV> if ( ( 1 == ps_codec -> i4_num_cores ) || ( 0 != ( parse_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ) //<S2SV> { //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx = parse_slice_idx ; //<S2SV> break ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> WORD32 ctb_indx = 0 ; //<S2SV> while ( ctb_indx != ps_sps -> i4_pic_size_in_ctb ) //<S2SV> { //<S2SV> WORD32 parse_status = * ( ps_codec -> pu1_parse_map + ctb_indx ) ; //<S2SV> volatile WORD32 proc_status = * ( ps_codec -> pu1_proc_map + ctb_indx ) & 1 ; //<S2SV> if ( parse_status == proc_status ) //<S2SV> ctb_indx ++ ; //<S2SV> } //<S2SV> ps_codec -> s_parse . i4_cur_slice_idx = parse_slice_idx ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> # if FRAME_ILF_PAD //<S2SV> if ( FRAME_ILF_PAD && 1 == ps_codec -> i4_num_cores ) //<S2SV> { //<S2SV> if ( ps_slice_hdr -> i4_abs_pic_order_cnt == 0 ) //<S2SV> { //<S2SV> DUMP_PRE_ILF ( ps_codec -> as_process [ 0 ] . pu1_cur_pic_luma , //<S2SV> ps_codec -> as_process [ 0 ] . pu1_cur_pic_chroma , //<S2SV> ps_sps -> i2_pic_width_in_luma_samples , //<S2SV> ps_sps -> i2_pic_height_in_luma_samples , //<S2SV> ps_codec -> i4_strd ) ; //<S2SV> DUMP_BS ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu4_pic_vert_bs , //<S2SV> ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu4_pic_horz_bs , //<S2SV> ps_sps -> i2_pic_wd_in_ctb * ( ctb_size * ctb_size / 8 / 16 ) * ps_sps -> i2_pic_ht_in_ctb , //<S2SV> ( ps_sps -> i2_pic_wd_in_ctb + 1 ) * ( ctb_size * ctb_size / 8 / 16 ) * ps_sps -> i2_pic_ht_in_ctb ) ; //<S2SV> DUMP_QP ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu1_pic_qp , //<S2SV> ( ps_sps -> i2_pic_height_in_luma_samples * ps_sps -> i2_pic_width_in_luma_samples ) / ( MIN_CU_SIZE * MIN_CU_SIZE ) ) ; //<S2SV> DUMP_QP_CONST_IN_CTB ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu1_pic_qp_const_in_ctb , //<S2SV> ( ps_sps -> i2_pic_height_in_luma_samples * ps_sps -> i2_pic_width_in_luma_samples ) / ( MIN_CTB_SIZE * MIN_CTB_SIZE ) / 8 ) ; //<S2SV> DUMP_NO_LOOP_FILTER ( ps_codec -> as_process [ 0 ] . pu1_pic_no_loop_filter_flag , //<S2SV> ( ps_sps -> i2_pic_width_in_luma_samples / MIN_CU_SIZE ) * ( ps_sps -> i2_pic_height_in_luma_samples / MIN_CU_SIZE ) / 8 ) ; //<S2SV> DUMP_OFFSETS ( ps_slice_hdr -> i1_beta_offset_div2 , //<S2SV> ps_slice_hdr -> i1_tc_offset_div2 , //<S2SV> ps_pps -> i1_pic_cb_qp_offset , //<S2SV> ps_pps -> i1_pic_cr_qp_offset ) ; //<S2SV> } //<S2SV> ps_codec -> s_parse . s_deblk_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; //<S2SV> ps_codec -> s_parse . s_deblk_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; //<S2SV> ps_codec -> s_parse . s_deblk_ctxt . ps_codec = ps_codec ; //<S2SV> ps_codec -> s_parse . s_deblk_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; //<S2SV> ps_codec -> s_parse . s_deblk_ctxt . is_chroma_yuv420sp_vu = ( ps_codec -> e_ref_chroma_fmt == IV_YUV_420SP_VU ) ; //<S2SV> ps_codec -> s_parse . s_sao_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; //<S2SV> ps_codec -> s_parse . s_sao_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; //<S2SV> ps_codec -> s_parse . s_sao_ctxt . ps_codec = ps_codec ; //<S2SV> ps_codec -> s_parse . s_sao_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; //<S2SV> ihevcd_ilf_pad_frame ( & ps_codec -> s_parse . s_deblk_ctxt , & ps_codec -> s_parse . s_sao_ctxt ) ; //<S2SV> } //<S2SV> # endif //<S2SV> ps_codec -> s_parse . i4_end_of_frame = 1 ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> 