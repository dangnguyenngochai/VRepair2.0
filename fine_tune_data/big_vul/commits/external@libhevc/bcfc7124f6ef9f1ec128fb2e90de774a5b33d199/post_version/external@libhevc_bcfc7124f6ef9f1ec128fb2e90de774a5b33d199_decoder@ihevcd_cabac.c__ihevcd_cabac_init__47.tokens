IHEVCD_ERROR_T ihevcd_cabac_init ( cab_ctxt_t * ps_cabac , //<S2SV> bitstrm_t * ps_bitstrm , //<S2SV> WORD32 qp , //<S2SV> WORD32 cabac_init_idc , //<S2SV> const UWORD8 * pu1_init_ctxt ) //<S2SV> { //<S2SV> ASSERT ( ps_cabac != NULL ) ; //<S2SV> ASSERT ( ps_bitstrm != NULL ) ; //<S2SV> ASSERT ( ( qp >= 0 ) && ( qp < 52 ) ) ; //<S2SV> ASSERT ( ( cabac_init_idc >= 0 ) && ( cabac_init_idc < 3 ) ) ; //<S2SV> UNUSED ( qp ) ; //<S2SV> UNUSED ( cabac_init_idc ) ; //<S2SV> # if FULLRANGE //<S2SV> ps_cabac -> u4_range = ( UWORD32 ) 510 << RANGE_SHIFT ; //<S2SV> BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , //<S2SV> ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , ( 9 + RANGE_SHIFT ) ) ; //<S2SV> # else //<S2SV> ps_cabac -> u4_range = ( UWORD32 ) 510 ; //<S2SV> BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , //<S2SV> ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , 9 ) ; //<S2SV> # endif //<S2SV> memcpy ( ps_cabac -> au1_ctxt_models , //<S2SV> pu1_init_ctxt , //<S2SV> IHEVC_CAB_CTXT_END ) ; //<S2SV> DEBUG_RANGE_OFST ( "init" , ps_cabac -> u4_range , ps_cabac -> u4_ofst ) ; //<S2SV> if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) //<S2SV> { //<S2SV> return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; //<S2SV> } //<S2SV> return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ; //<S2SV> } //<S2SV> 