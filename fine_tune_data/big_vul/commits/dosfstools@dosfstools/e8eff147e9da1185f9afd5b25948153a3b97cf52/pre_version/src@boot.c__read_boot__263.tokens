void read_boot ( DOS_FS * fs ) //<S2SV> { //<S2SV> struct boot_sector b ; //<S2SV> unsigned total_sectors ; //<S2SV> unsigned short logical_sector_size , sectors ; //<S2SV> unsigned fat_length ; //<S2SV> unsigned total_fat_entries ; //<S2SV> off_t data_size ; //<S2SV> fs_read ( 0 , sizeof ( b ) , & b ) ; //<S2SV> logical_sector_size = GET_UNALIGNED_W ( b . sector_size ) ; //<S2SV> if ( ! logical_sector_size ) //<S2SV> die ( "Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero." ) ; //<S2SV> if ( logical_sector_size & ( SECTOR_SIZE - 1 ) ) //<S2SV> die ( "Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>physical<S2SV_blank>" //<S2SV> "sector<S2SV_blank>size." , logical_sector_size ) ; //<S2SV> fs -> cluster_size = b . cluster_size * logical_sector_size ; //<S2SV> if ( ! fs -> cluster_size ) //<S2SV> die ( "Cluster<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero." ) ; //<S2SV> if ( b . fats != 2 && b . fats != 1 ) //<S2SV> die ( "Currently,<S2SV_blank>only<S2SV_blank>1<S2SV_blank>or<S2SV_blank>2<S2SV_blank>FATs<S2SV_blank>are<S2SV_blank>supported,<S2SV_blank>not<S2SV_blank>%d.\\n" , b . fats ) ; //<S2SV> fs -> nfats = b . fats ; //<S2SV> sectors = GET_UNALIGNED_W ( b . sectors ) ; //<S2SV> total_sectors = sectors ? sectors : le32toh ( b . total_sect ) ; //<S2SV> if ( verbose ) //<S2SV> printf ( "Checking<S2SV_blank>we<S2SV_blank>can<S2SV_blank>access<S2SV_blank>the<S2SV_blank>last<S2SV_blank>sector<S2SV_blank>of<S2SV_blank>the<S2SV_blank>filesystem\\n" ) ; //<S2SV> fs_test ( ( off_t ) ( ( total_sectors & ~ 1 ) - 1 ) * logical_sector_size , //<S2SV> logical_sector_size ) ; //<S2SV> fat_length = le16toh ( b . fat_length ) ? //<S2SV> le16toh ( b . fat_length ) : le32toh ( b . fat32_length ) ; //<S2SV> fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ; //<S2SV> fs -> root_start = ( ( off_t ) le16toh ( b . reserved ) + b . fats * fat_length ) * //<S2SV> logical_sector_size ; //<S2SV> fs -> root_entries = GET_UNALIGNED_W ( b . dir_entries ) ; //<S2SV> fs -> data_start = fs -> root_start + ROUND_TO_MULTIPLE ( fs -> root_entries << //<S2SV> MSDOS_DIR_BITS , //<S2SV> logical_sector_size ) ; //<S2SV> data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ; //<S2SV> fs -> data_clusters = data_size / fs -> cluster_size ; //<S2SV> fs -> root_cluster = 0 ; //<S2SV> fs -> fsinfo_start = 0 ; //<S2SV> fs -> free_clusters = - 1 ; //<S2SV> if ( ! b . fat_length && b . fat32_length ) { //<S2SV> fs -> fat_bits = 32 ; //<S2SV> fs -> root_cluster = le32toh ( b . root_cluster ) ; //<S2SV> if ( ! fs -> root_cluster && fs -> root_entries ) //<S2SV> printf ( "Warning:<S2SV_blank>FAT32<S2SV_blank>root<S2SV_blank>dir<S2SV_blank>not<S2SV_blank>in<S2SV_blank>cluster<S2SV_blank>chain!<S2SV_blank>" //<S2SV> "Compatibility<S2SV_blank>mode...\\n" ) ; //<S2SV> else if ( ! fs -> root_cluster && ! fs -> root_entries ) //<S2SV> die ( "No<S2SV_blank>root<S2SV_blank>directory!" ) ; //<S2SV> else if ( fs -> root_cluster && fs -> root_entries ) //<S2SV> printf ( "Warning:<S2SV_blank>FAT32<S2SV_blank>root<S2SV_blank>dir<S2SV_blank>is<S2SV_blank>in<S2SV_blank>a<S2SV_blank>cluster<S2SV_blank>chain,<S2SV_blank>but<S2SV_blank>" //<S2SV> "a<S2SV_blank>separate<S2SV_blank>root<S2SV_blank>dir\\n" //<S2SV> "<S2SV_blank><S2SV_blank>area<S2SV_blank>is<S2SV_blank>defined.<S2SV_blank>Cannot<S2SV_blank>fix<S2SV_blank>this<S2SV_blank>easily.\\n" ) ; //<S2SV> if ( fs -> data_clusters < FAT16_THRESHOLD ) //<S2SV> printf ( "Warning:<S2SV_blank>Filesystem<S2SV_blank>is<S2SV_blank>FAT32<S2SV_blank>according<S2SV_blank>to<S2SV_blank>fat_length<S2SV_blank>" //<S2SV> "and<S2SV_blank>fat32_length<S2SV_blank>fields,\\n" //<S2SV> "<S2SV_blank><S2SV_blank>but<S2SV_blank>has<S2SV_blank>only<S2SV_blank>%lu<S2SV_blank>clusters,<S2SV_blank>less<S2SV_blank>than<S2SV_blank>the<S2SV_blank>required<S2SV_blank>" //<S2SV> "minimum<S2SV_blank>of<S2SV_blank>%d.\\n" //<S2SV> "<S2SV_blank><S2SV_blank>This<S2SV_blank>may<S2SV_blank>lead<S2SV_blank>to<S2SV_blank>problems<S2SV_blank>on<S2SV_blank>some<S2SV_blank>systems.\\n" , //<S2SV> ( unsigned long ) fs -> data_clusters , FAT16_THRESHOLD ) ; //<S2SV> check_fat_state_bit ( fs , & b ) ; //<S2SV> fs -> backupboot_start = le16toh ( b . backup_boot ) * logical_sector_size ; //<S2SV> check_backup_boot ( fs , & b , logical_sector_size ) ; //<S2SV> read_fsinfo ( fs , & b , logical_sector_size ) ; //<S2SV> } else if ( ! atari_format ) { //<S2SV> fs -> fat_bits = ( fs -> data_clusters >= FAT12_THRESHOLD ) ? 16 : 12 ; //<S2SV> if ( fs -> data_clusters >= FAT16_THRESHOLD ) //<S2SV> die ( "Too<S2SV_blank>many<S2SV_blank>clusters<S2SV_blank>(%lu)<S2SV_blank>for<S2SV_blank>FAT16<S2SV_blank>filesystem." , fs -> data_clusters ) ; //<S2SV> check_fat_state_bit ( fs , & b ) ; //<S2SV> } else { //<S2SV> fs -> fat_bits = 16 ; //<S2SV> if ( fs -> data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 || //<S2SV> ( total_sectors == 720 || total_sectors == 1440 || //<S2SV> total_sectors == 2880 ) ) //<S2SV> fs -> fat_bits = 12 ; //<S2SV> } //<S2SV> fs -> eff_fat_bits = ( fs -> fat_bits == 32 ) ? 28 : fs -> fat_bits ; //<S2SV> fs -> fat_size = fat_length * logical_sector_size ; //<S2SV> fs -> label = calloc ( 12 , sizeof ( uint8_t ) ) ; //<S2SV> if ( fs -> fat_bits == 12 || fs -> fat_bits == 16 ) { //<S2SV> struct boot_sector_16 * b16 = ( struct boot_sector_16 * ) & b ; //<S2SV> if ( b16 -> extended_sig == 0x29 ) //<S2SV> memmove ( fs -> label , b16 -> label , 11 ) ; //<S2SV> else //<S2SV> fs -> label = NULL ; //<S2SV> } else if ( fs -> fat_bits == 32 ) { //<S2SV> if ( b . extended_sig == 0x29 ) //<S2SV> memmove ( fs -> label , & b . label , 11 ) ; //<S2SV> else //<S2SV> fs -> label = NULL ; //<S2SV> } //<S2SV> total_fat_entries = ( uint64_t ) fs -> fat_size * 8 / fs -> fat_bits ; //<S2SV> if ( fs -> data_clusters > total_fat_entries - 2 ) //<S2SV> die ( "Filesystem<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>clusters<S2SV_blank>but<S2SV_blank>only<S2SV_blank>space<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>FAT<S2SV_blank>entries." , //<S2SV> fs -> data_clusters , total_fat_entries - 2 ) ; //<S2SV> if ( ! fs -> root_entries && ! fs -> root_cluster ) //<S2SV> die ( "Root<S2SV_blank>directory<S2SV_blank>has<S2SV_blank>zero<S2SV_blank>size." ) ; //<S2SV> if ( fs -> root_entries & ( MSDOS_DPS - 1 ) ) //<S2SV> die ( "Root<S2SV_blank>directory<S2SV_blank>(%d<S2SV_blank>entries)<S2SV_blank>doesn\'t<S2SV_blank>span<S2SV_blank>an<S2SV_blank>integral<S2SV_blank>number<S2SV_blank>of<S2SV_blank>" //<S2SV> "sectors." , fs -> root_entries ) ; //<S2SV> if ( logical_sector_size & ( SECTOR_SIZE - 1 ) ) //<S2SV> die ( "Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>physical<S2SV_blank>" //<S2SV> "sector<S2SV_blank>size." , logical_sector_size ) ; //<S2SV> # if 0 //<S2SV> if ( ! atari_format && ( ! b . secs_track || ! b . heads ) ) //<S2SV> die ( "Invalid<S2SV_blank>disk<S2SV_blank>format<S2SV_blank>in<S2SV_blank>boot<S2SV_blank>sector." ) ; //<S2SV> # endif //<S2SV> if ( verbose ) //<S2SV> dump_boot ( fs , & b , logical_sector_size ) ; //<S2SV> } //<S2SV> 