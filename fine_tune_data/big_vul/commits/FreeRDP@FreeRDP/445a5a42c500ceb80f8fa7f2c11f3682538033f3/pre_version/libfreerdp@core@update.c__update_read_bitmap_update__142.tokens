BITMAP_UPDATE * update_read_bitmap_update ( rdpUpdate * update , wStream * s ) //<S2SV> { //<S2SV> UINT32 i ; //<S2SV> BITMAP_UPDATE * bitmapUpdate = calloc ( 1 , sizeof ( BITMAP_UPDATE ) ) ; //<S2SV> if ( ! bitmapUpdate ) //<S2SV> goto fail ; //<S2SV> if ( Stream_GetRemainingLength ( s ) < 2 ) //<S2SV> goto fail ; //<S2SV> Stream_Read_UINT16 ( s , bitmapUpdate -> number ) ; //<S2SV> WLog_Print ( update -> log , WLOG_TRACE , "BitmapUpdate:<S2SV_blank>%" PRIu32 "" , bitmapUpdate -> number ) ; //<S2SV> if ( bitmapUpdate -> number > bitmapUpdate -> count ) //<S2SV> { //<S2SV> UINT16 count ; //<S2SV> BITMAP_DATA * newdata ; //<S2SV> count = bitmapUpdate -> number * 2 ; //<S2SV> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , //<S2SV> sizeof ( BITMAP_DATA ) * count ) ; //<S2SV> if ( ! newdata ) //<S2SV> goto fail ; //<S2SV> bitmapUpdate -> rectangles = newdata ; //<S2SV> ZeroMemory ( & bitmapUpdate -> rectangles [ bitmapUpdate -> count ] , //<S2SV> sizeof ( BITMAP_DATA ) * ( count - bitmapUpdate -> count ) ) ; //<S2SV> bitmapUpdate -> count = count ; //<S2SV> } //<S2SV> for ( i = 0 ; i < bitmapUpdate -> number ; i ++ ) //<S2SV> { //<S2SV> if ( ! update_read_bitmap_data ( update , s , & bitmapUpdate -> rectangles [ i ] ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> return bitmapUpdate ; //<S2SV> fail : //<S2SV> free_bitmap_update ( update -> context , bitmapUpdate ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 