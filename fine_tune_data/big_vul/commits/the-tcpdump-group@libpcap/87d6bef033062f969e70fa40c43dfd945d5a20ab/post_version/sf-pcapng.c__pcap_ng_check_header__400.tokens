pcap_t * //<S2SV> pcap_ng_check_header ( const uint8_t * magic , FILE * fp , u_int precision , //<S2SV> char * errbuf , int * err ) //<S2SV> { //<S2SV> bpf_u_int32 magic_int ; //<S2SV> size_t amt_read ; //<S2SV> bpf_u_int32 total_length ; //<S2SV> bpf_u_int32 byte_order_magic ; //<S2SV> struct block_header * bhdrp ; //<S2SV> struct section_header_block * shbp ; //<S2SV> pcap_t * p ; //<S2SV> int swapped = 0 ; //<S2SV> struct pcap_ng_sf * ps ; //<S2SV> int status ; //<S2SV> struct block_cursor cursor ; //<S2SV> struct interface_description_block * idbp ; //<S2SV> * err = 0 ; //<S2SV> memcpy ( & magic_int , magic , sizeof ( magic_int ) ) ; //<S2SV> if ( magic_int != BT_SHB ) { //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> amt_read = fread ( & total_length , 1 , sizeof ( total_length ) , fp ) ; //<S2SV> if ( amt_read < sizeof ( total_length ) ) { //<S2SV> if ( ferror ( fp ) ) { //<S2SV> pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , //<S2SV> errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; //<S2SV> * err = 1 ; //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> amt_read = fread ( & byte_order_magic , 1 , sizeof ( byte_order_magic ) , fp ) ; //<S2SV> if ( amt_read < sizeof ( byte_order_magic ) ) { //<S2SV> if ( ferror ( fp ) ) { //<S2SV> pcap_fmt_errmsg_for_errno ( errbuf , PCAP_ERRBUF_SIZE , //<S2SV> errno , "error<S2SV_blank>reading<S2SV_blank>dump<S2SV_blank>file" ) ; //<S2SV> * err = 1 ; //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> if ( byte_order_magic != BYTE_ORDER_MAGIC ) { //<S2SV> byte_order_magic = SWAPLONG ( byte_order_magic ) ; //<S2SV> if ( byte_order_magic != BYTE_ORDER_MAGIC ) { //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> swapped = 1 ; //<S2SV> total_length = SWAPLONG ( total_length ) ; //<S2SV> } //<S2SV> if ( total_length < sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) || //<S2SV> ( total_length > BT_SHB_INSANE_MAX ) ) { //<S2SV> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , //<S2SV> "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)" , //<S2SV> sizeof ( * bhdrp ) + sizeof ( * shbp ) + sizeof ( struct block_trailer ) , //<S2SV> total_length , //<S2SV> BT_SHB_INSANE_MAX ) ; //<S2SV> * err = 1 ; //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> p = pcap_open_offline_common ( errbuf , sizeof ( struct pcap_ng_sf ) ) ; //<S2SV> if ( p == NULL ) { //<S2SV> * err = 1 ; //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> p -> swapped = swapped ; //<S2SV> ps = p -> priv ; //<S2SV> switch ( precision ) { //<S2SV> case PCAP_TSTAMP_PRECISION_MICRO : //<S2SV> ps -> user_tsresol = 1000000 ; //<S2SV> break ; //<S2SV> case PCAP_TSTAMP_PRECISION_NANO : //<S2SV> ps -> user_tsresol = 1000000000 ; //<S2SV> break ; //<S2SV> default : //<S2SV> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , //<S2SV> "unknown<S2SV_blank>time<S2SV_blank>stamp<S2SV_blank>resolution<S2SV_blank>%u" , precision ) ; //<S2SV> free ( p ) ; //<S2SV> * err = 1 ; //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> p -> opt . tstamp_precision = precision ; //<S2SV> p -> bufsize = 2048 ; //<S2SV> if ( p -> bufsize < total_length ) //<S2SV> p -> bufsize = total_length ; //<S2SV> p -> buffer = malloc ( p -> bufsize ) ; //<S2SV> if ( p -> buffer == NULL ) { //<S2SV> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "out<S2SV_blank>of<S2SV_blank>memory" ) ; //<S2SV> free ( p ) ; //<S2SV> * err = 1 ; //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> ps -> max_blocksize = INITIAL_MAX_BLOCKSIZE ; //<S2SV> bhdrp = ( struct block_header * ) p -> buffer ; //<S2SV> shbp = ( struct section_header_block * ) ( ( u_char * ) p -> buffer + sizeof ( struct block_header ) ) ; //<S2SV> bhdrp -> block_type = magic_int ; //<S2SV> bhdrp -> total_length = total_length ; //<S2SV> shbp -> byte_order_magic = byte_order_magic ; //<S2SV> if ( read_bytes ( fp , //<S2SV> ( u_char * ) p -> buffer + ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , //<S2SV> total_length - ( sizeof ( magic_int ) + sizeof ( total_length ) + sizeof ( byte_order_magic ) ) , //<S2SV> 1 , errbuf ) == - 1 ) //<S2SV> goto fail ; //<S2SV> if ( p -> swapped ) { //<S2SV> shbp -> major_version = SWAPSHORT ( shbp -> major_version ) ; //<S2SV> shbp -> minor_version = SWAPSHORT ( shbp -> minor_version ) ; //<S2SV> } //<S2SV> if ( ! ( shbp -> major_version == PCAP_NG_VERSION_MAJOR && //<S2SV> shbp -> minor_version == PCAP_NG_VERSION_MINOR ) ) { //<S2SV> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , //<S2SV> "unsupported<S2SV_blank>pcapng<S2SV_blank>savefile<S2SV_blank>version<S2SV_blank>%u.%u" , //<S2SV> shbp -> major_version , shbp -> minor_version ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> p -> version_major = shbp -> major_version ; //<S2SV> p -> version_minor = shbp -> minor_version ; //<S2SV> p -> opt . tstamp_precision = precision ; //<S2SV> for ( ; ; ) { //<S2SV> status = read_block ( fp , p , & cursor , errbuf ) ; //<S2SV> if ( status == 0 ) { //<S2SV> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , //<S2SV> "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( status == - 1 ) //<S2SV> goto fail ; //<S2SV> switch ( cursor . block_type ) { //<S2SV> case BT_IDB : //<S2SV> idbp = get_from_block_data ( & cursor , sizeof ( * idbp ) , //<S2SV> errbuf ) ; //<S2SV> if ( idbp == NULL ) //<S2SV> goto fail ; //<S2SV> if ( p -> swapped ) { //<S2SV> idbp -> linktype = SWAPSHORT ( idbp -> linktype ) ; //<S2SV> idbp -> snaplen = SWAPLONG ( idbp -> snaplen ) ; //<S2SV> } //<S2SV> if ( ! add_interface ( p , & cursor , errbuf ) ) //<S2SV> goto fail ; //<S2SV> goto done ; //<S2SV> case BT_EPB : //<S2SV> case BT_SPB : //<S2SV> case BT_PB : //<S2SV> pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , //<S2SV> "the<S2SV_blank>capture<S2SV_blank>file<S2SV_blank>has<S2SV_blank>a<S2SV_blank>packet<S2SV_blank>block<S2SV_blank>before<S2SV_blank>any<S2SV_blank>Interface<S2SV_blank>Description<S2SV_blank>Blocks" ) ; //<S2SV> goto fail ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> done : //<S2SV> p -> tzoff = 0 ; //<S2SV> p -> linktype = linktype_to_dlt ( idbp -> linktype ) ; //<S2SV> p -> snapshot = pcap_adjust_snapshot ( p -> linktype , idbp -> snaplen ) ; //<S2SV> p -> linktype_ext = 0 ; //<S2SV> if ( MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) > ps -> max_blocksize ) //<S2SV> ps -> max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN ( max_snaplen_for_dlt ( p -> linktype ) ) ; //<S2SV> p -> next_packet_op = pcap_ng_next_packet ; //<S2SV> p -> cleanup_op = pcap_ng_cleanup ; //<S2SV> return ( p ) ; //<S2SV> fail : //<S2SV> free ( ps -> ifaces ) ; //<S2SV> free ( p -> buffer ) ; //<S2SV> free ( p ) ; //<S2SV> * err = 1 ; //<S2SV> return ( NULL ) ; //<S2SV> } //<S2SV> 