static int //<S2SV> daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) //<S2SV> { //<S2SV> char errbuf [ PCAP_ERRBUF_SIZE ] ; //<S2SV> char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; //<S2SV> char sendbuf [ RPCAP_NETBUF_SIZE ] ; //<S2SV> int sendbufidx = 0 ; //<S2SV> pcap_if_t * alldevs = NULL ; //<S2SV> pcap_if_t * d ; //<S2SV> struct pcap_addr * address ; //<S2SV> struct rpcap_findalldevs_if * findalldevs_if ; //<S2SV> uint16 nif = 0 ; //<S2SV> if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) //<S2SV> { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) //<S2SV> goto error ; //<S2SV> if ( alldevs == NULL ) //<S2SV> { //<S2SV> if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , //<S2SV> "No<S2SV_blank>interfaces<S2SV_blank>found!<S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>libpcap/WinPcap<S2SV_blank>is<S2SV_blank>properly<S2SV_blank>installed" //<S2SV> "<S2SV_blank>and<S2SV_blank>you<S2SV_blank>have<S2SV_blank>the<S2SV_blank>right<S2SV_blank>to<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>remote<S2SV_blank>device." , //<S2SV> errbuf ) == - 1 ) //<S2SV> { //<S2SV> rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> for ( d = alldevs ; d != NULL ; d = d -> next ) //<S2SV> { //<S2SV> nif ++ ; //<S2SV> if ( d -> description ) //<S2SV> plen += strlen ( d -> description ) ; //<S2SV> if ( d -> name ) //<S2SV> plen += strlen ( d -> name ) ; //<S2SV> plen += sizeof ( struct rpcap_findalldevs_if ) ; //<S2SV> for ( address = d -> addresses ; address != NULL ; address = address -> next ) //<S2SV> { //<S2SV> switch ( address -> addr -> sa_family ) //<S2SV> { //<S2SV> case AF_INET : //<S2SV> # ifdef AF_INET6 //<S2SV> case AF_INET6 : //<S2SV> # endif //<S2SV> plen += ( sizeof ( struct rpcap_sockaddr ) * 4 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , //<S2SV> & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , //<S2SV> PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> goto error ; //<S2SV> rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , //<S2SV> RPCAP_MSG_FINDALLIF_REPLY , nif , plen ) ; //<S2SV> for ( d = alldevs ; d != NULL ; d = d -> next ) //<S2SV> { //<S2SV> uint16 lname , ldescr ; //<S2SV> findalldevs_if = ( struct rpcap_findalldevs_if * ) & sendbuf [ sendbufidx ] ; //<S2SV> if ( sock_bufferize ( NULL , sizeof ( struct rpcap_findalldevs_if ) , NULL , //<S2SV> & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> goto error ; //<S2SV> memset ( findalldevs_if , 0 , sizeof ( struct rpcap_findalldevs_if ) ) ; //<S2SV> if ( d -> description ) ldescr = ( short ) strlen ( d -> description ) ; //<S2SV> else ldescr = 0 ; //<S2SV> if ( d -> name ) lname = ( short ) strlen ( d -> name ) ; //<S2SV> else lname = 0 ; //<S2SV> findalldevs_if -> desclen = htons ( ldescr ) ; //<S2SV> findalldevs_if -> namelen = htons ( lname ) ; //<S2SV> findalldevs_if -> flags = htonl ( d -> flags ) ; //<S2SV> for ( address = d -> addresses ; address != NULL ; address = address -> next ) //<S2SV> { //<S2SV> switch ( address -> addr -> sa_family ) //<S2SV> { //<S2SV> case AF_INET : //<S2SV> # ifdef AF_INET6 //<S2SV> case AF_INET6 : //<S2SV> # endif //<S2SV> findalldevs_if -> naddr ++ ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> findalldevs_if -> naddr = htons ( findalldevs_if -> naddr ) ; //<S2SV> if ( sock_bufferize ( d -> name , lname , sendbuf , & sendbufidx , //<S2SV> RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , //<S2SV> PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> goto error ; //<S2SV> if ( sock_bufferize ( d -> description , ldescr , sendbuf , & sendbufidx , //<S2SV> RPCAP_NETBUF_SIZE , SOCKBUF_BUFFERIZE , errmsgbuf , //<S2SV> PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> goto error ; //<S2SV> for ( address = d -> addresses ; address != NULL ; address = address -> next ) //<S2SV> { //<S2SV> struct rpcap_sockaddr * sockaddr ; //<S2SV> switch ( address -> addr -> sa_family ) //<S2SV> { //<S2SV> case AF_INET : //<S2SV> # ifdef AF_INET6 //<S2SV> case AF_INET6 : //<S2SV> # endif //<S2SV> sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; //<S2SV> if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , //<S2SV> & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> goto error ; //<S2SV> daemon_seraddr ( ( struct sockaddr_storage * ) address -> addr , sockaddr ) ; //<S2SV> sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; //<S2SV> if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , //<S2SV> & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> goto error ; //<S2SV> daemon_seraddr ( ( struct sockaddr_storage * ) address -> netmask , sockaddr ) ; //<S2SV> sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; //<S2SV> if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , //<S2SV> & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> goto error ; //<S2SV> daemon_seraddr ( ( struct sockaddr_storage * ) address -> broadaddr , sockaddr ) ; //<S2SV> sockaddr = ( struct rpcap_sockaddr * ) & sendbuf [ sendbufidx ] ; //<S2SV> if ( sock_bufferize ( NULL , sizeof ( struct rpcap_sockaddr ) , NULL , //<S2SV> & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> goto error ; //<S2SV> daemon_seraddr ( ( struct sockaddr_storage * ) address -> dstaddr , sockaddr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> pcap_freealldevs ( alldevs ) ; //<S2SV> if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) //<S2SV> { //<S2SV> rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> error : //<S2SV> if ( alldevs ) //<S2SV> pcap_freealldevs ( alldevs ) ; //<S2SV> if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_FINDALLIF , //<S2SV> errmsgbuf , errbuf ) == - 1 ) //<S2SV> { //<S2SV> rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 