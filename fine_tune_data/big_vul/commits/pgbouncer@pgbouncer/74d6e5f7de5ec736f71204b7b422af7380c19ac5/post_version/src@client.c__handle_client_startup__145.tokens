static bool handle_client_startup ( PgSocket * client , PktHdr * pkt ) //<S2SV> { //<S2SV> const char * passwd ; //<S2SV> const uint8_t * key ; //<S2SV> bool ok ; //<S2SV> SBuf * sbuf = & client -> sbuf ; //<S2SV> if ( incomplete_pkt ( pkt ) ) { //<S2SV> disconnect_client ( client , true , "client<S2SV_blank>sent<S2SV_blank>partial<S2SV_blank>pkt<S2SV_blank>in<S2SV_blank>startup<S2SV_blank>phase" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( client -> wait_for_welcome ) { //<S2SV> if ( finish_client_login ( client ) ) { //<S2SV> sbuf_prepare_skip ( sbuf , pkt -> len ) ; //<S2SV> return true ; //<S2SV> } else //<S2SV> return false ; //<S2SV> } //<S2SV> switch ( pkt -> type ) { //<S2SV> case PKT_SSLREQ : //<S2SV> slog_noise ( client , "C:<S2SV_blank>req<S2SV_blank>SSL" ) ; //<S2SV> slog_noise ( client , "P:<S2SV_blank>nak" ) ; //<S2SV> if ( ! sbuf_answer ( & client -> sbuf , "N" , 1 ) ) { //<S2SV> disconnect_client ( client , false , "failed<S2SV_blank>to<S2SV_blank>nak<S2SV_blank>SSL" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> break ; //<S2SV> case PKT_STARTUP_V2 : //<S2SV> disconnect_client ( client , true , "Old<S2SV_blank>V2<S2SV_blank>protocol<S2SV_blank>not<S2SV_blank>supported" ) ; //<S2SV> return false ; //<S2SV> case PKT_STARTUP : //<S2SV> if ( client -> pool ) { //<S2SV> disconnect_client ( client , true , "client<S2SV_blank>re-sent<S2SV_blank>startup<S2SV_blank>pkt" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( ! decide_startup_pool ( client , pkt ) ) //<S2SV> return false ; //<S2SV> if ( client -> pool -> db -> admin ) { //<S2SV> if ( ! admin_pre_login ( client ) ) //<S2SV> return false ; //<S2SV> } //<S2SV> if ( cf_auth_type <= AUTH_TRUST || client -> own_user ) { //<S2SV> if ( ! finish_client_login ( client ) ) //<S2SV> return false ; //<S2SV> } else { //<S2SV> if ( ! send_client_authreq ( client ) ) { //<S2SV> disconnect_client ( client , false , "failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>auth<S2SV_blank>req" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case 'p' : //<S2SV> if ( ! client -> auth_user ) { //<S2SV> disconnect_client ( client , true , "client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> if ( cf_auth_type <= AUTH_TRUST ) { //<S2SV> disconnect_client ( client , true , "unrequested<S2SV_blank>passwd<S2SV_blank>pkt" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> ok = mbuf_get_string ( & pkt -> data , & passwd ) ; //<S2SV> if ( ok && check_client_passwd ( client , passwd ) ) { //<S2SV> if ( ! finish_client_login ( client ) ) //<S2SV> return false ; //<S2SV> } else { //<S2SV> disconnect_client ( client , true , "Auth<S2SV_blank>failed" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> break ; //<S2SV> case PKT_CANCEL : //<S2SV> if ( mbuf_avail_for_read ( & pkt -> data ) == BACKENDKEY_LEN //<S2SV> && mbuf_get_bytes ( & pkt -> data , BACKENDKEY_LEN , & key ) ) //<S2SV> { //<S2SV> memcpy ( client -> cancel_key , key , BACKENDKEY_LEN ) ; //<S2SV> accept_cancel_request ( client ) ; //<S2SV> } else //<S2SV> disconnect_client ( client , false , "bad<S2SV_blank>cancel<S2SV_blank>request" ) ; //<S2SV> return false ; //<S2SV> default : //<S2SV> disconnect_client ( client , false , "bad<S2SV_blank>packet" ) ; //<S2SV> return false ; //<S2SV> } //<S2SV> sbuf_prepare_skip ( sbuf , pkt -> len ) ; //<S2SV> client -> request_time = get_cached_time ( ) ; //<S2SV> return true ; //<S2SV> } //<S2SV> 