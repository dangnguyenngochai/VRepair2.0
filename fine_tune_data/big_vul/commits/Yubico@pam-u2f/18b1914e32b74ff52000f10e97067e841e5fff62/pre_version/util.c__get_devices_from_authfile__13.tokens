int get_devices_from_authfile ( const char * authfile , const char * username , //<S2SV> unsigned max_devs , int verbose , FILE * debug_file , //<S2SV> device_t * devices , unsigned * n_devs ) { //<S2SV> char * buf = NULL ; //<S2SV> char * s_user , * s_token ; //<S2SV> int retval = 0 ; //<S2SV> int fd = - 1 ; //<S2SV> struct stat st ; //<S2SV> struct passwd * pw = NULL , pw_s ; //<S2SV> char buffer [ BUFSIZE ] ; //<S2SV> int gpu_ret ; //<S2SV> FILE * opwfile = NULL ; //<S2SV> unsigned i , j ; //<S2SV> * n_devs = 0 ; //<S2SV> fd = open ( authfile , O_RDONLY , 0 ) ; //<S2SV> if ( fd < 0 ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( fstat ( fd , & st ) < 0 ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)" , authfile , strerror ( errno ) ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( ! S_ISREG ( st . st_mode ) ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file" , authfile ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( st . st_size == 0 ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "File<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>empty" , authfile ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> gpu_ret = getpwuid_r ( st . st_uid , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; //<S2SV> if ( gpu_ret != 0 || pw == NULL ) { //<S2SV> D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%u,<S2SV_blank>(%s)" , st . st_uid , //<S2SV> strerror ( errno ) ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( strcmp ( pw -> pw_name , username ) != 0 && strcmp ( pw -> pw_name , "root" ) != 0 ) { //<S2SV> if ( strcmp ( username , "root" ) != 0 ) { //<S2SV> D ( debug_file , "The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>%s<S2SV_blank>nor<S2SV_blank>root" , //<S2SV> username ) ; //<S2SV> } else { //<S2SV> D ( debug_file , "The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>root" ) ; //<S2SV> } //<S2SV> goto err ; //<S2SV> } //<S2SV> opwfile = fdopen ( fd , "r" ) ; //<S2SV> if ( opwfile == NULL ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "fdopen:<S2SV_blank>%s" , strerror ( errno ) ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> buf = malloc ( sizeof ( char ) * ( DEVSIZE * max_devs ) ) ; //<S2SV> if ( ! buf ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory" ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> retval = - 2 ; //<S2SV> while ( fgets ( buf , ( int ) ( DEVSIZE * ( max_devs - 1 ) ) , opwfile ) ) { //<S2SV> char * saveptr = NULL ; //<S2SV> if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) //<S2SV> buf [ strlen ( buf ) - 1 ] = '\\0' ; //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Authorization<S2SV_blank>line:<S2SV_blank>%s" , buf ) ; //<S2SV> s_user = strtok_r ( buf , ":" , & saveptr ) ; //<S2SV> if ( s_user && strcmp ( username , s_user ) == 0 ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Matched<S2SV_blank>user:<S2SV_blank>%s" , s_user ) ; //<S2SV> retval = - 1 ; //<S2SV> for ( i = 0 ; i < * n_devs ; i ++ ) { //<S2SV> free ( devices [ i ] . keyHandle ) ; //<S2SV> free ( devices [ i ] . publicKey ) ; //<S2SV> devices [ i ] . keyHandle = NULL ; //<S2SV> devices [ i ] . publicKey = NULL ; //<S2SV> } //<S2SV> * n_devs = 0 ; //<S2SV> i = 0 ; //<S2SV> while ( ( s_token = strtok_r ( NULL , "," , & saveptr ) ) ) { //<S2SV> devices [ i ] . keyHandle = NULL ; //<S2SV> devices [ i ] . publicKey = NULL ; //<S2SV> if ( ( * n_devs ) ++ > MAX_DEVS - 1 ) { //<S2SV> * n_devs = MAX_DEVS ; //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Found<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>devices,<S2SV_blank>ignoring<S2SV_blank>the<S2SV_blank>remaining<S2SV_blank>ones" , //<S2SV> MAX_DEVS ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "KeyHandle<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s" , i + 1 , s_token ) ; //<S2SV> devices [ i ] . keyHandle = strdup ( s_token ) ; //<S2SV> if ( ! devices [ i ] . keyHandle ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>keyHandle<S2SV_blank>number<S2SV_blank>%d" , i ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> s_token = strtok_r ( NULL , ":" , & saveptr ) ; //<S2SV> if ( ! s_token ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d" , i + 1 ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "publicKey<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s" , i + 1 , s_token ) ; //<S2SV> if ( strlen ( s_token ) % 2 != 0 ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>even" , i + 1 ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> devices [ i ] . key_len = strlen ( s_token ) / 2 ; //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>%zu" , i + 1 , devices [ i ] . key_len ) ; //<S2SV> devices [ i ] . publicKey = //<S2SV> malloc ( ( sizeof ( unsigned char ) * devices [ i ] . key_len ) ) ; //<S2SV> if ( ! devices [ i ] . publicKey ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d" , i ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> for ( j = 0 ; j < devices [ i ] . key_len ; j ++ ) { //<S2SV> unsigned int x ; //<S2SV> if ( sscanf ( & s_token [ 2 * j ] , "%2x" , & x ) != 1 ) { //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Invalid<S2SV_blank>hex<S2SV_blank>number<S2SV_blank>in<S2SV_blank>key" ) ; //<S2SV> goto err ; //<S2SV> } //<S2SV> devices [ i ] . publicKey [ j ] = ( unsigned char ) x ; //<S2SV> } //<S2SV> i ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( verbose ) //<S2SV> D ( debug_file , "Found<S2SV_blank>%d<S2SV_blank>device(s)<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s" , * n_devs , username ) ; //<S2SV> retval = 1 ; //<S2SV> goto out ; //<S2SV> err : //<S2SV> for ( i = 0 ; i < * n_devs ; i ++ ) { //<S2SV> free ( devices [ i ] . keyHandle ) ; //<S2SV> free ( devices [ i ] . publicKey ) ; //<S2SV> devices [ i ] . keyHandle = NULL ; //<S2SV> devices [ i ] . publicKey = NULL ; //<S2SV> } //<S2SV> * n_devs = 0 ; //<S2SV> out : //<S2SV> if ( buf ) { //<S2SV> free ( buf ) ; //<S2SV> buf = NULL ; //<S2SV> } //<S2SV> if ( opwfile ) //<S2SV> fclose ( opwfile ) ; //<S2SV> else if ( fd >= 0 ) //<S2SV> close ( fd ) ; //<S2SV> return retval ; //<S2SV> } //<S2SV> 