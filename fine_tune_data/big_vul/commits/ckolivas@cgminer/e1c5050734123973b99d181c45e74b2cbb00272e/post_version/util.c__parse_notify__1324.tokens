static bool parse_notify ( struct pool * pool , json_t * val ) //<S2SV> { //<S2SV> char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , //<S2SV> * ntime , header [ 228 ] ; //<S2SV> unsigned char * cb1 = NULL , * cb2 = NULL ; //<S2SV> size_t cb1_len , cb2_len , alloc_len ; //<S2SV> bool clean , ret = false ; //<S2SV> int merkles , i ; //<S2SV> json_t * arr ; //<S2SV> arr = json_array_get ( val , 4 ) ; //<S2SV> if ( ! arr || ! json_is_array ( arr ) ) //<S2SV> goto out ; //<S2SV> merkles = json_array_size ( arr ) ; //<S2SV> job_id = json_array_string ( val , 0 ) ; //<S2SV> prev_hash = __json_array_string ( val , 1 ) ; //<S2SV> coinbase1 = json_array_string ( val , 2 ) ; //<S2SV> coinbase2 = json_array_string ( val , 3 ) ; //<S2SV> bbversion = __json_array_string ( val , 5 ) ; //<S2SV> nbit = __json_array_string ( val , 6 ) ; //<S2SV> ntime = __json_array_string ( val , 7 ) ; //<S2SV> clean = json_is_true ( json_array_get ( val , 8 ) ) ; //<S2SV> if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || //<S2SV> ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || //<S2SV> ! valid_hex ( ntime ) ) { //<S2SV> free ( job_id ) ; //<S2SV> free ( coinbase1 ) ; //<S2SV> free ( coinbase2 ) ; //<S2SV> goto out ; //<S2SV> } //<S2SV> cg_wlock ( & pool -> data_lock ) ; //<S2SV> free ( pool -> swork . job_id ) ; //<S2SV> pool -> swork . job_id = job_id ; //<S2SV> snprintf ( pool -> prev_hash , 65 , "%s" , prev_hash ) ; //<S2SV> cb1_len = strlen ( coinbase1 ) / 2 ; //<S2SV> cb2_len = strlen ( coinbase2 ) / 2 ; //<S2SV> snprintf ( pool -> bbversion , 9 , "%s" , bbversion ) ; //<S2SV> snprintf ( pool -> nbit , 9 , "%s" , nbit ) ; //<S2SV> snprintf ( pool -> ntime , 9 , "%s" , ntime ) ; //<S2SV> pool -> swork . clean = clean ; //<S2SV> alloc_len = pool -> coinbase_len = cb1_len + pool -> n1_len + pool -> n2size + cb2_len ; //<S2SV> pool -> nonce2_offset = cb1_len + pool -> n1_len ; //<S2SV> for ( i = 0 ; i < pool -> merkles ; i ++ ) //<S2SV> free ( pool -> swork . merkle_bin [ i ] ) ; //<S2SV> if ( merkles ) { //<S2SV> pool -> swork . merkle_bin = realloc ( pool -> swork . merkle_bin , //<S2SV> sizeof ( char * ) * merkles + 1 ) ; //<S2SV> for ( i = 0 ; i < merkles ; i ++ ) { //<S2SV> char * merkle = json_array_string ( arr , i ) ; //<S2SV> pool -> swork . merkle_bin [ i ] = malloc ( 32 ) ; //<S2SV> if ( unlikely ( ! pool -> swork . merkle_bin [ i ] ) ) //<S2SV> quit ( 1 , "Failed<S2SV_blank>to<S2SV_blank>malloc<S2SV_blank>pool<S2SV_blank>swork<S2SV_blank>merkle_bin" ) ; //<S2SV> if ( opt_protocol ) //<S2SV> applog ( LOG_DEBUG , "merkle<S2SV_blank>%d:<S2SV_blank>%s" , i , merkle ) ; //<S2SV> ret = hex2bin ( pool -> swork . merkle_bin [ i ] , merkle , 32 ) ; //<S2SV> free ( merkle ) ; //<S2SV> if ( unlikely ( ! ret ) ) { //<S2SV> applog ( LOG_ERR , "Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>merkle<S2SV_blank>to<S2SV_blank>merkle_bin<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> pool -> merkles = merkles ; //<S2SV> if ( clean ) //<S2SV> pool -> nonce2 = 0 ; //<S2SV> # if 0 //<S2SV> header_len = strlen ( pool -> bbversion ) + //<S2SV> strlen ( pool -> prev_hash ) ; //<S2SV> 32 + //<S2SV> strlen ( pool -> ntime ) + //<S2SV> strlen ( pool -> nbit ) + //<S2SV> 8 + //<S2SV> 96 ; //<S2SV> # endif //<S2SV> snprintf ( header , 225 , //<S2SV> "%s%s%s%s%s%s%s" , //<S2SV> pool -> bbversion , //<S2SV> pool -> prev_hash , //<S2SV> blank_merkle , //<S2SV> pool -> ntime , //<S2SV> pool -> nbit , //<S2SV> "00000000" , //<S2SV> workpadding ) ; //<S2SV> ret = hex2bin ( pool -> header_bin , header , 112 ) ; //<S2SV> if ( unlikely ( ! ret ) ) { //<S2SV> applog ( LOG_ERR , "Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> cb1 = alloca ( cb1_len ) ; //<S2SV> ret = hex2bin ( cb1 , coinbase1 , cb1_len ) ; //<S2SV> if ( unlikely ( ! ret ) ) { //<S2SV> applog ( LOG_ERR , "Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>cb1<S2SV_blank>to<S2SV_blank>cb1_bin<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> cb2 = alloca ( cb2_len ) ; //<S2SV> ret = hex2bin ( cb2 , coinbase2 , cb2_len ) ; //<S2SV> if ( unlikely ( ! ret ) ) { //<S2SV> applog ( LOG_ERR , "Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>cb2<S2SV_blank>to<S2SV_blank>cb2_bin<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> goto out_unlock ; //<S2SV> } //<S2SV> free ( pool -> coinbase ) ; //<S2SV> align_len ( & alloc_len ) ; //<S2SV> pool -> coinbase = calloc ( alloc_len , 1 ) ; //<S2SV> if ( unlikely ( ! pool -> coinbase ) ) //<S2SV> quit ( 1 , "Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool<S2SV_blank>coinbase<S2SV_blank>in<S2SV_blank>parse_notify" ) ; //<S2SV> memcpy ( pool -> coinbase , cb1 , cb1_len ) ; //<S2SV> memcpy ( pool -> coinbase + cb1_len , pool -> nonce1bin , pool -> n1_len ) ; //<S2SV> memcpy ( pool -> coinbase + cb1_len + pool -> n1_len + pool -> n2size , cb2 , cb2_len ) ; //<S2SV> if ( opt_debug ) { //<S2SV> char * cb = bin2hex ( pool -> coinbase , pool -> coinbase_len ) ; //<S2SV> applog ( LOG_DEBUG , "Pool<S2SV_blank>%d<S2SV_blank>coinbase<S2SV_blank>%s" , pool -> pool_no , cb ) ; //<S2SV> free ( cb ) ; //<S2SV> } //<S2SV> out_unlock : //<S2SV> cg_wunlock ( & pool -> data_lock ) ; //<S2SV> if ( opt_protocol ) { //<S2SV> applog ( LOG_DEBUG , "job_id:<S2SV_blank>%s" , job_id ) ; //<S2SV> applog ( LOG_DEBUG , "prev_hash:<S2SV_blank>%s" , prev_hash ) ; //<S2SV> applog ( LOG_DEBUG , "coinbase1:<S2SV_blank>%s" , coinbase1 ) ; //<S2SV> applog ( LOG_DEBUG , "coinbase2:<S2SV_blank>%s" , coinbase2 ) ; //<S2SV> applog ( LOG_DEBUG , "bbversion:<S2SV_blank>%s" , bbversion ) ; //<S2SV> applog ( LOG_DEBUG , "nbit:<S2SV_blank>%s" , nbit ) ; //<S2SV> applog ( LOG_DEBUG , "ntime:<S2SV_blank>%s" , ntime ) ; //<S2SV> applog ( LOG_DEBUG , "clean:<S2SV_blank>%s" , clean ? "yes" : "no" ) ; //<S2SV> } //<S2SV> free ( coinbase1 ) ; //<S2SV> free ( coinbase2 ) ; //<S2SV> pool -> getwork_requested ++ ; //<S2SV> total_getworks ++ ; //<S2SV> if ( pool == current_pool ( ) ) //<S2SV> opt_work_update = true ; //<S2SV> out : //<S2SV> return ret ; //<S2SV> } //<S2SV> 