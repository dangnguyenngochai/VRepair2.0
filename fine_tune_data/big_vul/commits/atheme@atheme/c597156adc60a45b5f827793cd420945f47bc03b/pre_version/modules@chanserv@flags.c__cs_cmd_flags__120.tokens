static void cs_cmd_flags ( sourceinfo_t * si , int parc , char * parv [ ] ) //<S2SV> { //<S2SV> chanacs_t * ca ; //<S2SV> mowgli_node_t * n ; //<S2SV> char * channel = parv [ 0 ] ; //<S2SV> char * target = sstrdup ( parv [ 1 ] ) ; //<S2SV> char * flagstr = parv [ 2 ] ; //<S2SV> const char * str1 ; //<S2SV> unsigned int addflags , removeflags , restrictflags ; //<S2SV> hook_channel_acl_req_t req ; //<S2SV> mychan_t * mc ; //<S2SV> if ( parc < 1 ) //<S2SV> { //<S2SV> command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , "FLAGS" ) ; //<S2SV> command_fail ( si , fault_needmoreparams , _ ( "Syntax:<S2SV_blank>FLAGS<S2SV_blank><channel><S2SV_blank>[target]<S2SV_blank>[flags]" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> mc = mychan_find ( channel ) ; //<S2SV> if ( ! mc ) //<S2SV> { //<S2SV> command_fail ( si , fault_nosuch_target , _ ( "Channel<S2SV_blank>\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered." ) , channel ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( metadata_find ( mc , "private:close:closer" ) && ( target || ! has_priv ( si , PRIV_CHAN_AUSPEX ) ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "\\2%s\\2<S2SV_blank>is<S2SV_blank>closed." ) , channel ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! target || ( target && target [ 0 ] == '+' && flagstr == NULL ) ) //<S2SV> { //<S2SV> unsigned int flags = ( target != NULL ) ? flags_to_bitmask ( target , 0 ) : 0 ; //<S2SV> do_list ( si , mc , flags ) ; //<S2SV> return ; //<S2SV> } //<S2SV> else if ( ! strcasecmp ( target , "LIST" ) && myentity_find_ext ( target ) == NULL ) //<S2SV> { //<S2SV> do_list ( si , mc , 0 ) ; //<S2SV> free ( target ) ; //<S2SV> return ; //<S2SV> } //<S2SV> else if ( ! strcasecmp ( target , "CLEAR" ) && myentity_find_ext ( target ) == NULL ) //<S2SV> { //<S2SV> free ( target ) ; //<S2SV> if ( ! chanacs_source_has_flag ( mc , si , CA_FOUNDER ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , "You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>perform<S2SV_blank>this<S2SV_blank>operation." ) ; //<S2SV> return ; //<S2SV> } //<S2SV> mowgli_node_t * tn ; //<S2SV> MOWGLI_ITER_FOREACH_SAFE ( n , tn , mc -> chanacs . head ) //<S2SV> { //<S2SV> ca = n -> data ; //<S2SV> if ( ca -> level & CA_FOUNDER ) //<S2SV> continue ; //<S2SV> object_unref ( ca ) ; //<S2SV> } //<S2SV> logcommand ( si , CMDLOG_DO , "CLEAR:FLAGS:<S2SV_blank>\\2%s\\2" , mc -> name ) ; //<S2SV> command_success_nodata ( si , _ ( "Cleared<S2SV_blank>flags<S2SV_blank>in<S2SV_blank>\\2%s\\2." ) , mc -> name ) ; //<S2SV> return ; //<S2SV> } //<S2SV> else if ( ! strcasecmp ( target , "MODIFY" ) && myentity_find_ext ( target ) == NULL ) //<S2SV> { //<S2SV> free ( target ) ; //<S2SV> if ( parc < 3 ) //<S2SV> { //<S2SV> command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , "FLAGS" ) ; //<S2SV> command_fail ( si , fault_needmoreparams , _ ( "Syntax:<S2SV_blank>FLAGS<S2SV_blank><#channel><S2SV_blank>MODIFY<S2SV_blank>[target]<S2SV_blank><flags>" ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> flagstr = strchr ( parv [ 2 ] , '<S2SV_blank>' ) ; //<S2SV> if ( flagstr ) //<S2SV> * flagstr ++ = '\\0' ; //<S2SV> target = strdup ( parv [ 2 ] ) ; //<S2SV> } //<S2SV> { //<S2SV> myentity_t * mt ; //<S2SV> if ( ! si -> smu ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>logged<S2SV_blank>in." ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! flagstr ) //<S2SV> { //<S2SV> if ( ! ( mc -> flags & MC_PUBACL ) && ! chanacs_source_has_flag ( mc , si , CA_ACLVIEW ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>this<S2SV_blank>command." ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( validhostmask ( target ) ) //<S2SV> ca = chanacs_find_host_literal ( mc , target , 0 ) ; //<S2SV> else //<S2SV> { //<S2SV> if ( ! ( mt = myentity_find_ext ( target ) ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_nosuch_target , _ ( "\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered." ) , target ) ; //<S2SV> return ; //<S2SV> } //<S2SV> free ( target ) ; //<S2SV> target = sstrdup ( mt -> name ) ; //<S2SV> ca = chanacs_find_literal ( mc , mt , 0 ) ; //<S2SV> } //<S2SV> if ( ca != NULL ) //<S2SV> { //<S2SV> str1 = bitmask_to_flags2 ( ca -> level , 0 ) ; //<S2SV> command_success_string ( si , str1 , _ ( "Flags<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2<S2SV_blank>are<S2SV_blank>\\2%s\\2." ) , //<S2SV> target , channel , //<S2SV> str1 ) ; //<S2SV> } //<S2SV> else //<S2SV> command_success_string ( si , "" , _ ( "No<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2." ) , //<S2SV> target , channel ) ; //<S2SV> logcommand ( si , CMDLOG_GET , "FLAGS:<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2" , mc -> name , target ) ; //<S2SV> return ; //<S2SV> } //<S2SV> restrictflags = chanacs_source_flags ( mc , si ) ; //<S2SV> if ( restrictflags & CA_FOUNDER ) //<S2SV> restrictflags = ca_all ; //<S2SV> else //<S2SV> { //<S2SV> if ( ! ( restrictflags & CA_FLAGS ) ) //<S2SV> { //<S2SV> if ( restrictflags & CA_AKICK || //<S2SV> si -> smu == NULL || //<S2SV> irccasecmp ( target , entity ( si -> smu ) -> name ) || //<S2SV> strcmp ( flagstr , "-*" ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>this<S2SV_blank>command." ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> if ( irccasecmp ( target , entity ( si -> smu ) -> name ) ) //<S2SV> restrictflags = allow_flags ( mc , restrictflags ) ; //<S2SV> else //<S2SV> restrictflags |= allow_flags ( mc , restrictflags ) ; //<S2SV> } //<S2SV> if ( * flagstr == '+' || * flagstr == '-' || * flagstr == '=' ) //<S2SV> { //<S2SV> flags_make_bitmasks ( flagstr , & addflags , & removeflags ) ; //<S2SV> if ( addflags == 0 && removeflags == 0 ) //<S2SV> { //<S2SV> command_fail ( si , fault_badparams , _ ( "No<S2SV_blank>valid<S2SV_blank>flags<S2SV_blank>given,<S2SV_blank>use<S2SV_blank>/%s%s<S2SV_blank>HELP<S2SV_blank>FLAGS<S2SV_blank>for<S2SV_blank>a<S2SV_blank>list" ) , ircd -> uses_rcommand ? "" : "msg<S2SV_blank>" , chansvs . me -> disp ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> addflags = get_template_flags ( mc , flagstr ) ; //<S2SV> if ( addflags == 0 ) //<S2SV> { //<S2SV> if ( * target == '+' || * target == '-' || * target == '=' ) //<S2SV> command_fail ( si , fault_badparams , _ ( "Usage:<S2SV_blank>FLAGS<S2SV_blank>%s<S2SV_blank>[target]<S2SV_blank>[flags]" ) , mc -> name ) ; //<S2SV> else //<S2SV> command_fail ( si , fault_badparams , _ ( "Invalid<S2SV_blank>template<S2SV_blank>name<S2SV_blank>given,<S2SV_blank>use<S2SV_blank>/%s%s<S2SV_blank>TEMPLATE<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>a<S2SV_blank>list" ) , ircd -> uses_rcommand ? "" : "msg<S2SV_blank>" , chansvs . me -> disp , mc -> name ) ; //<S2SV> return ; //<S2SV> } //<S2SV> removeflags = ca_all & ~ addflags ; //<S2SV> } //<S2SV> if ( ! validhostmask ( target ) ) //<S2SV> { //<S2SV> if ( ! ( mt = myentity_find_ext ( target ) ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_nosuch_target , _ ( "\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered." ) , target ) ; //<S2SV> return ; //<S2SV> } //<S2SV> free ( target ) ; //<S2SV> target = sstrdup ( mt -> name ) ; //<S2SV> ca = chanacs_open ( mc , mt , NULL , true , entity ( si -> smu ) ) ; //<S2SV> if ( ca -> level & CA_FOUNDER && removeflags & CA_FLAGS && ! ( removeflags & CA_FOUNDER ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>a<S2SV_blank>founder\'s<S2SV_blank>+f<S2SV_blank>access." ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ca -> level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders ( mc ) == 1 ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>the<S2SV_blank>last<S2SV_blank>founder." ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! ( ca -> level & CA_FOUNDER ) && addflags & CA_FOUNDER ) //<S2SV> { //<S2SV> if ( mychan_num_founders ( mc ) >= chansvs . maxfounders ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "Only<S2SV_blank>%d<S2SV_blank>founders<S2SV_blank>allowed<S2SV_blank>per<S2SV_blank>channel." ) , chansvs . maxfounders ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! myentity_can_register_channel ( mt ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_toomany , _ ( "\\2%s\\2<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>channels<S2SV_blank>registered." ) , mt -> name ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! myentity_allow_foundership ( mt ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_toomany , _ ( "\\2%s\\2<S2SV_blank>cannot<S2SV_blank>take<S2SV_blank>foundership<S2SV_blank>of<S2SV_blank>a<S2SV_blank>channel." ) , mt -> name ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> if ( addflags & CA_FOUNDER ) //<S2SV> addflags |= CA_FLAGS , removeflags &= ~ CA_FLAGS ; //<S2SV> if ( isuser ( mt ) && ( MU_NEVEROP & user ( mt ) -> flags && addflags != CA_AKICK && addflags != 0 && ( ca -> level == 0 || ca -> level == CA_AKICK ) ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "\\2%s\\2<S2SV_blank>does<S2SV_blank>not<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>be<S2SV_blank>added<S2SV_blank>to<S2SV_blank>channel<S2SV_blank>access<S2SV_blank>lists<S2SV_blank>(NEVEROP<S2SV_blank>set)." ) , mt -> name ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ca -> level == 0 && chanacs_is_table_full ( ca ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_toomany , _ ( "Channel<S2SV_blank>%s<S2SV_blank>access<S2SV_blank>list<S2SV_blank>is<S2SV_blank>full." ) , mc -> name ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> return ; //<S2SV> } //<S2SV> req . ca = ca ; //<S2SV> req . oldlevel = ca -> level ; //<S2SV> if ( ! chanacs_modify ( ca , & addflags , & removeflags , restrictflags ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2." ) , bitmask_to_flags2 ( addflags , removeflags ) , mt -> name , mc -> name ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> return ; //<S2SV> } //<S2SV> req . newlevel = ca -> level ; //<S2SV> hook_call_channel_acl_change ( & req ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( addflags & CA_FOUNDER ) //<S2SV> { //<S2SV> command_fail ( si , fault_badparams , _ ( "You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>set<S2SV_blank>founder<S2SV_blank>status<S2SV_blank>on<S2SV_blank>a<S2SV_blank>hostmask." ) ) ; //<S2SV> return ; //<S2SV> } //<S2SV> ca = chanacs_open ( mc , NULL , target , true , entity ( si -> smu ) ) ; //<S2SV> if ( ca -> level == 0 && chanacs_is_table_full ( ca ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_toomany , _ ( "Channel<S2SV_blank>%s<S2SV_blank>access<S2SV_blank>list<S2SV_blank>is<S2SV_blank>full." ) , mc -> name ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> return ; //<S2SV> } //<S2SV> req . ca = ca ; //<S2SV> req . oldlevel = ca -> level ; //<S2SV> if ( ! chanacs_modify ( ca , & addflags , & removeflags , restrictflags ) ) //<S2SV> { //<S2SV> command_fail ( si , fault_noprivs , _ ( "You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2." ) , bitmask_to_flags2 ( addflags , removeflags ) , target , mc -> name ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> return ; //<S2SV> } //<S2SV> req . newlevel = ca -> level ; //<S2SV> hook_call_channel_acl_change ( & req ) ; //<S2SV> chanacs_close ( ca ) ; //<S2SV> } //<S2SV> if ( ( addflags | removeflags ) == 0 ) //<S2SV> { //<S2SV> command_fail ( si , fault_nochange , _ ( "Channel<S2SV_blank>access<S2SV_blank>to<S2SV_blank>\\2%s\\2<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>unchanged." ) , channel , target ) ; //<S2SV> return ; //<S2SV> } //<S2SV> flagstr = bitmask_to_flags2 ( addflags , removeflags ) ; //<S2SV> command_success_nodata ( si , _ ( "Flags<S2SV_blank>\\2%s\\2<S2SV_blank>were<S2SV_blank>set<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2." ) , flagstr , target , channel ) ; //<S2SV> logcommand ( si , CMDLOG_SET , "FLAGS:<S2SV_blank>\\2%s\\2<S2SV_blank>\\2%s\\2<S2SV_blank>\\2%s\\2" , mc -> name , target , flagstr ) ; //<S2SV> verbose ( mc , "\\2%s\\2<S2SV_blank>set<S2SV_blank>flags<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2" , get_source_name ( si ) , flagstr , target ) ; //<S2SV> } //<S2SV> free ( target ) ; //<S2SV> } //<S2SV> 