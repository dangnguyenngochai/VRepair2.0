static int //<S2SV> zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , //<S2SV> struct zip_entry * rsrc ) //<S2SV> { //<S2SV> struct zip * zip = ( struct zip * ) a -> format -> data ; //<S2SV> unsigned char * metadata , * mp ; //<S2SV> int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; //<S2SV> size_t remaining_bytes , metadata_bytes ; //<S2SV> ssize_t hsize ; //<S2SV> int ret = ARCHIVE_OK , eof ; //<S2SV> switch ( rsrc -> compression ) { //<S2SV> case 0 : //<S2SV> if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> # ifdef HAVE_ZLIB_H //<S2SV> case 8 : //<S2SV> # endif //<S2SV> break ; //<S2SV> default : //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Unsupported<S2SV_blank>ZIP<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(%s)" , //<S2SV> compression_name ( rsrc -> compression ) ) ; //<S2SV> return ( ARCHIVE_WARN ) ; //<S2SV> } //<S2SV> if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes" , //<S2SV> ( intmax_t ) rsrc -> uncompressed_size ) ; //<S2SV> return ( ARCHIVE_WARN ) ; //<S2SV> } //<S2SV> if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes" , //<S2SV> ( intmax_t ) rsrc -> compressed_size ) ; //<S2SV> return ( ARCHIVE_WARN ) ; //<S2SV> } //<S2SV> metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; //<S2SV> if ( metadata == NULL ) { //<S2SV> archive_set_error ( & a -> archive , ENOMEM , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Mac<S2SV_blank>metadata" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> if ( offset < rsrc -> local_header_offset ) //<S2SV> __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; //<S2SV> else if ( offset != rsrc -> local_header_offset ) { //<S2SV> __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; //<S2SV> } //<S2SV> hsize = zip_get_local_file_header_size ( a , 0 ) ; //<S2SV> __archive_read_consume ( a , hsize ) ; //<S2SV> remaining_bytes = ( size_t ) rsrc -> compressed_size ; //<S2SV> metadata_bytes = ( size_t ) rsrc -> uncompressed_size ; //<S2SV> mp = metadata ; //<S2SV> eof = 0 ; //<S2SV> while ( ! eof && remaining_bytes ) { //<S2SV> const unsigned char * p ; //<S2SV> ssize_t bytes_avail ; //<S2SV> size_t bytes_used ; //<S2SV> p = __archive_read_ahead ( a , 1 , & bytes_avail ) ; //<S2SV> if ( p == NULL ) { //<S2SV> archive_set_error ( & a -> archive , //<S2SV> ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Truncated<S2SV_blank>ZIP<S2SV_blank>file<S2SV_blank>header" ) ; //<S2SV> ret = ARCHIVE_WARN ; //<S2SV> goto exit_mac_metadata ; //<S2SV> } //<S2SV> if ( ( size_t ) bytes_avail > remaining_bytes ) //<S2SV> bytes_avail = remaining_bytes ; //<S2SV> switch ( rsrc -> compression ) { //<S2SV> case 0 : //<S2SV> if ( ( size_t ) bytes_avail > metadata_bytes ) //<S2SV> bytes_avail = metadata_bytes ; //<S2SV> memcpy ( mp , p , bytes_avail ) ; //<S2SV> bytes_used = ( size_t ) bytes_avail ; //<S2SV> metadata_bytes -= bytes_used ; //<S2SV> mp += bytes_used ; //<S2SV> if ( metadata_bytes == 0 ) //<S2SV> eof = 1 ; //<S2SV> break ; //<S2SV> # ifdef HAVE_ZLIB_H //<S2SV> case 8 : //<S2SV> { //<S2SV> int r ; //<S2SV> ret = zip_deflate_init ( a , zip ) ; //<S2SV> if ( ret != ARCHIVE_OK ) //<S2SV> goto exit_mac_metadata ; //<S2SV> zip -> stream . next_in = //<S2SV> ( Bytef * ) ( uintptr_t ) ( const void * ) p ; //<S2SV> zip -> stream . avail_in = ( uInt ) bytes_avail ; //<S2SV> zip -> stream . total_in = 0 ; //<S2SV> zip -> stream . next_out = mp ; //<S2SV> zip -> stream . avail_out = ( uInt ) metadata_bytes ; //<S2SV> zip -> stream . total_out = 0 ; //<S2SV> r = inflate ( & zip -> stream , 0 ) ; //<S2SV> switch ( r ) { //<S2SV> case Z_OK : //<S2SV> break ; //<S2SV> case Z_STREAM_END : //<S2SV> eof = 1 ; //<S2SV> break ; //<S2SV> case Z_MEM_ERROR : //<S2SV> archive_set_error ( & a -> archive , ENOMEM , //<S2SV> "Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>ZIP<S2SV_blank>decompression" ) ; //<S2SV> ret = ARCHIVE_FATAL ; //<S2SV> goto exit_mac_metadata ; //<S2SV> default : //<S2SV> archive_set_error ( & a -> archive , //<S2SV> ARCHIVE_ERRNO_MISC , //<S2SV> "ZIP<S2SV_blank>decompression<S2SV_blank>failed<S2SV_blank>(%d)" , r ) ; //<S2SV> ret = ARCHIVE_FATAL ; //<S2SV> goto exit_mac_metadata ; //<S2SV> } //<S2SV> bytes_used = zip -> stream . total_in ; //<S2SV> metadata_bytes -= zip -> stream . total_out ; //<S2SV> mp += zip -> stream . total_out ; //<S2SV> break ; //<S2SV> } //<S2SV> # endif //<S2SV> default : //<S2SV> bytes_used = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> __archive_read_consume ( a , bytes_used ) ; //<S2SV> remaining_bytes -= bytes_used ; //<S2SV> } //<S2SV> archive_entry_copy_mac_metadata ( entry , metadata , //<S2SV> ( size_t ) rsrc -> uncompressed_size - metadata_bytes ) ; //<S2SV> exit_mac_metadata : //<S2SV> __archive_read_seek ( a , offset , SEEK_SET ) ; //<S2SV> zip -> decompress_init = 0 ; //<S2SV> free ( metadata ) ; //<S2SV> return ( ret ) ; //<S2SV> } //<S2SV> 