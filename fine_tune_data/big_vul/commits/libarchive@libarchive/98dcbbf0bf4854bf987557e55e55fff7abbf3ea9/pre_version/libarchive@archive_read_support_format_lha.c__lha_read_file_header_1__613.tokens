static int //<S2SV> lha_read_file_header_1 ( struct archive_read * a , struct lha * lha ) //<S2SV> { //<S2SV> const unsigned char * p ; //<S2SV> size_t extdsize ; //<S2SV> int i , err , err2 ; //<S2SV> int namelen , padding ; //<S2SV> unsigned char headersum , sum_calculated ; //<S2SV> err = ARCHIVE_OK ; //<S2SV> if ( ( p = __archive_read_ahead ( a , H1_FIXED_SIZE , NULL ) ) == NULL ) //<S2SV> return ( truncated_error ( a ) ) ; //<S2SV> lha -> header_size = p [ H1_HEADER_SIZE_OFFSET ] + 2 ; //<S2SV> headersum = p [ H1_HEADER_SUM_OFFSET ] ; //<S2SV> lha -> compsize = archive_le32dec ( p + H1_COMP_SIZE_OFFSET ) ; //<S2SV> lha -> origsize = archive_le32dec ( p + H1_ORIG_SIZE_OFFSET ) ; //<S2SV> lha -> mtime = lha_dos_time ( p + H1_DOS_TIME_OFFSET ) ; //<S2SV> namelen = p [ H1_NAME_LEN_OFFSET ] ; //<S2SV> padding = ( ( int ) lha -> header_size ) - H1_FIXED_SIZE - namelen ; //<S2SV> if ( namelen > 230 || padding < 0 ) //<S2SV> goto invalid ; //<S2SV> if ( ( p = __archive_read_ahead ( a , lha -> header_size , NULL ) ) == NULL ) //<S2SV> return ( truncated_error ( a ) ) ; //<S2SV> for ( i = 0 ; i < namelen ; i ++ ) { //<S2SV> if ( p [ i + H1_FILE_NAME_OFFSET ] == 0xff ) //<S2SV> goto invalid ; //<S2SV> } //<S2SV> archive_strncpy ( & lha -> filename , p + H1_FILE_NAME_OFFSET , namelen ) ; //<S2SV> lha -> crc = archive_le16dec ( p + H1_FILE_NAME_OFFSET + namelen ) ; //<S2SV> lha -> setflag |= CRC_IS_SET ; //<S2SV> sum_calculated = lha_calcsum ( 0 , p , 2 , lha -> header_size - 2 ) ; //<S2SV> __archive_read_consume ( a , lha -> header_size - 2 ) ; //<S2SV> err2 = lha_read_file_extended_header ( a , lha , NULL , 2 , //<S2SV> ( size_t ) ( lha -> compsize + 2 ) , & extdsize ) ; //<S2SV> if ( err2 < ARCHIVE_WARN ) //<S2SV> return ( err2 ) ; //<S2SV> if ( err2 < err ) //<S2SV> err = err2 ; //<S2SV> lha -> compsize -= extdsize - 2 ; //<S2SV> if ( sum_calculated != headersum ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , //<S2SV> "LHa<S2SV_blank>header<S2SV_blank>sum<S2SV_blank>error" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> return ( err ) ; //<S2SV> invalid : //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>LHa<S2SV_blank>header" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> 