static int //<S2SV> read_Header ( struct archive_read * a , struct _7z_header_info * h , //<S2SV> int check_header_id ) //<S2SV> { //<S2SV> struct _7zip * zip = ( struct _7zip * ) a -> format -> data ; //<S2SV> const unsigned char * p ; //<S2SV> struct _7z_folder * folders ; //<S2SV> struct _7z_stream_info * si = & ( zip -> si ) ; //<S2SV> struct _7zip_entry * entries ; //<S2SV> uint32_t folderIndex , indexInFolder ; //<S2SV> unsigned i ; //<S2SV> int eindex , empty_streams , sindex ; //<S2SV> if ( check_header_id ) { //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( * p != kHeader ) //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( * p == kArchiveProperties ) { //<S2SV> for ( ; ; ) { //<S2SV> uint64_t size ; //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( * p == 0 ) //<S2SV> break ; //<S2SV> if ( parse_7zip_uint64 ( a , & size ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> if ( * p == kMainStreamsInfo ) { //<S2SV> if ( read_StreamsInfo ( a , & ( zip -> si ) ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> if ( * p == kEnd ) //<S2SV> return ( 0 ) ; //<S2SV> if ( * p != kFilesInfo ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( parse_7zip_uint64 ( a , & ( zip -> numFiles ) ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( UMAX_ENTRY < zip -> numFiles ) //<S2SV> return ( - 1 ) ; //<S2SV> zip -> entries = calloc ( ( size_t ) zip -> numFiles , sizeof ( * zip -> entries ) ) ; //<S2SV> if ( zip -> entries == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> entries = zip -> entries ; //<S2SV> empty_streams = 0 ; //<S2SV> for ( ; ; ) { //<S2SV> int type ; //<S2SV> uint64_t size ; //<S2SV> size_t ll ; //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> type = * p ; //<S2SV> if ( type == kEnd ) //<S2SV> break ; //<S2SV> if ( parse_7zip_uint64 ( a , & size ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( zip -> header_bytes_remaining < size ) //<S2SV> return ( - 1 ) ; //<S2SV> ll = ( size_t ) size ; //<S2SV> switch ( type ) { //<S2SV> case kEmptyStream : //<S2SV> h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , //<S2SV> sizeof ( * h -> emptyStreamBools ) ) ; //<S2SV> if ( h -> emptyStreamBools == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( read_Bools ( //<S2SV> a , h -> emptyStreamBools , ( size_t ) zip -> numFiles ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> empty_streams = 0 ; //<S2SV> for ( i = 0 ; i < zip -> numFiles ; i ++ ) { //<S2SV> if ( h -> emptyStreamBools [ i ] ) //<S2SV> empty_streams ++ ; //<S2SV> } //<S2SV> break ; //<S2SV> case kEmptyFile : //<S2SV> if ( empty_streams <= 0 ) { //<S2SV> if ( header_bytes ( a , ll ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> h -> emptyFileBools = calloc ( empty_streams , //<S2SV> sizeof ( * h -> emptyFileBools ) ) ; //<S2SV> if ( h -> emptyFileBools == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( read_Bools ( a , h -> emptyFileBools , empty_streams ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> break ; //<S2SV> case kAnti : //<S2SV> if ( empty_streams <= 0 ) { //<S2SV> if ( header_bytes ( a , ll ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> h -> antiBools = calloc ( empty_streams , //<S2SV> sizeof ( * h -> antiBools ) ) ; //<S2SV> if ( h -> antiBools == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( read_Bools ( a , h -> antiBools , empty_streams ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> break ; //<S2SV> case kCTime : //<S2SV> case kATime : //<S2SV> case kMTime : //<S2SV> if ( read_Times ( a , h , type ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> break ; //<S2SV> case kName : //<S2SV> { //<S2SV> unsigned char * np ; //<S2SV> size_t nl , nb ; //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> ll -- ; //<S2SV> if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) //<S2SV> return ( - 1 ) ; //<S2SV> zip -> entry_names = malloc ( ll ) ; //<S2SV> if ( zip -> entry_names == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> np = zip -> entry_names ; //<S2SV> nb = ll ; //<S2SV> while ( nb ) { //<S2SV> size_t b ; //<S2SV> if ( nb > UBUFF_SIZE ) //<S2SV> b = UBUFF_SIZE ; //<S2SV> else //<S2SV> b = nb ; //<S2SV> if ( ( p = header_bytes ( a , b ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> memcpy ( np , p , b ) ; //<S2SV> np += b ; //<S2SV> nb -= b ; //<S2SV> } //<S2SV> np = zip -> entry_names ; //<S2SV> nl = ll ; //<S2SV> for ( i = 0 ; i < zip -> numFiles ; i ++ ) { //<S2SV> entries [ i ] . utf16name = np ; //<S2SV> # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) && defined ( _DEBUG ) //<S2SV> entries [ i ] . wname = ( wchar_t * ) np ; //<S2SV> # endif //<S2SV> while ( nl >= 2 && ( np [ 0 ] || np [ 1 ] ) ) { //<S2SV> np += 2 ; //<S2SV> nl -= 2 ; //<S2SV> } //<S2SV> if ( nl < 2 ) //<S2SV> return ( - 1 ) ; //<S2SV> entries [ i ] . name_len = np - entries [ i ] . utf16name ; //<S2SV> np += 2 ; //<S2SV> nl -= 2 ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case kAttributes : //<S2SV> { //<S2SV> int allAreDefined ; //<S2SV> if ( ( p = header_bytes ( a , 2 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> allAreDefined = * p ; //<S2SV> h -> attrBools = calloc ( ( size_t ) zip -> numFiles , //<S2SV> sizeof ( * h -> attrBools ) ) ; //<S2SV> if ( h -> attrBools == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( allAreDefined ) //<S2SV> memset ( h -> attrBools , 1 , ( size_t ) zip -> numFiles ) ; //<S2SV> else { //<S2SV> if ( read_Bools ( a , h -> attrBools , //<S2SV> ( size_t ) zip -> numFiles ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < zip -> numFiles ; i ++ ) { //<S2SV> if ( h -> attrBools [ i ] ) { //<S2SV> if ( ( p = header_bytes ( a , 4 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> entries [ i ] . attr = archive_le32dec ( p ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case kDummy : //<S2SV> if ( ll == 0 ) //<S2SV> break ; //<S2SV> default : //<S2SV> if ( header_bytes ( a , ll ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> folders = si -> ci . folders ; //<S2SV> eindex = sindex = 0 ; //<S2SV> folderIndex = indexInFolder = 0 ; //<S2SV> for ( i = 0 ; i < zip -> numFiles ; i ++ ) { //<S2SV> if ( h -> emptyStreamBools == NULL || h -> emptyStreamBools [ i ] == 0 ) //<S2SV> entries [ i ] . flg |= HAS_STREAM ; //<S2SV> entries [ i ] . mode = entries [ i ] . attr >> 16 ; //<S2SV> if ( entries [ i ] . flg & HAS_STREAM ) { //<S2SV> if ( ( size_t ) sindex >= si -> ss . unpack_streams ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( entries [ i ] . mode == 0 ) //<S2SV> entries [ i ] . mode = AE_IFREG | 0666 ; //<S2SV> if ( si -> ss . digestsDefined [ sindex ] ) //<S2SV> entries [ i ] . flg |= CRC32_IS_SET ; //<S2SV> entries [ i ] . ssIndex = sindex ; //<S2SV> sindex ++ ; //<S2SV> } else { //<S2SV> int dir ; //<S2SV> if ( h -> emptyFileBools == NULL ) //<S2SV> dir = 1 ; //<S2SV> else { //<S2SV> if ( h -> emptyFileBools [ eindex ] ) //<S2SV> dir = 0 ; //<S2SV> else //<S2SV> dir = 1 ; //<S2SV> eindex ++ ; //<S2SV> } //<S2SV> if ( entries [ i ] . mode == 0 ) { //<S2SV> if ( dir ) //<S2SV> entries [ i ] . mode = AE_IFDIR | 0777 ; //<S2SV> else //<S2SV> entries [ i ] . mode = AE_IFREG | 0666 ; //<S2SV> } else if ( dir && //<S2SV> ( entries [ i ] . mode & AE_IFMT ) != AE_IFDIR ) { //<S2SV> entries [ i ] . mode &= ~ AE_IFMT ; //<S2SV> entries [ i ] . mode |= AE_IFDIR ; //<S2SV> } //<S2SV> if ( ( entries [ i ] . mode & AE_IFMT ) == AE_IFDIR && //<S2SV> entries [ i ] . name_len >= 2 && //<S2SV> ( entries [ i ] . utf16name [ entries [ i ] . name_len - 2 ] != '/' || //<S2SV> entries [ i ] . utf16name [ entries [ i ] . name_len - 1 ] != 0 ) ) { //<S2SV> entries [ i ] . utf16name [ entries [ i ] . name_len ] = '/' ; //<S2SV> entries [ i ] . utf16name [ entries [ i ] . name_len + 1 ] = 0 ; //<S2SV> entries [ i ] . name_len += 2 ; //<S2SV> } //<S2SV> entries [ i ] . ssIndex = - 1 ; //<S2SV> } //<S2SV> if ( entries [ i ] . attr & 0x01 ) //<S2SV> entries [ i ] . mode &= ~ 0222 ; //<S2SV> if ( ( entries [ i ] . flg & HAS_STREAM ) == 0 && indexInFolder == 0 ) { //<S2SV> entries [ i ] . folderIndex = - 1 ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( indexInFolder == 0 ) { //<S2SV> for ( ; ; ) { //<S2SV> if ( folderIndex >= si -> ci . numFolders ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( folders [ folderIndex ] . numUnpackStreams ) //<S2SV> break ; //<S2SV> folderIndex ++ ; //<S2SV> } //<S2SV> } //<S2SV> entries [ i ] . folderIndex = folderIndex ; //<S2SV> if ( ( entries [ i ] . flg & HAS_STREAM ) == 0 ) //<S2SV> continue ; //<S2SV> indexInFolder ++ ; //<S2SV> if ( indexInFolder >= folders [ folderIndex ] . numUnpackStreams ) { //<S2SV> folderIndex ++ ; //<S2SV> indexInFolder = 0 ; //<S2SV> } //<S2SV> } //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> 