static int //<S2SV> archive_read_format_zip_cleanup ( struct archive_read * a ) //<S2SV> { //<S2SV> struct zip * zip ; //<S2SV> struct zip_entry * zip_entry , * next_zip_entry ; //<S2SV> zip = ( struct zip * ) ( a -> format -> data ) ; //<S2SV> # ifdef HAVE_ZLIB_H //<S2SV> if ( zip -> stream_valid ) //<S2SV> inflateEnd ( & zip -> stream ) ; //<S2SV> # endif //<S2SV> # if HAVA_LZMA_H && HAVE_LIBLZMA //<S2SV> if ( zip -> zipx_lzma_valid ) { //<S2SV> lzma_end ( & zip -> zipx_lzma_stream ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef HAVE_BZLIB_H //<S2SV> if ( zip -> bzstream_valid ) { //<S2SV> BZ2_bzDecompressEnd ( & zip -> bzstream ) ; //<S2SV> } //<S2SV> # endif //<S2SV> free ( zip -> uncompressed_buffer ) ; //<S2SV> if ( zip -> ppmd8_valid ) //<S2SV> __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; //<S2SV> if ( zip -> zip_entries ) { //<S2SV> zip_entry = zip -> zip_entries ; //<S2SV> while ( zip_entry != NULL ) { //<S2SV> next_zip_entry = zip_entry -> next ; //<S2SV> archive_string_free ( & zip_entry -> rsrcname ) ; //<S2SV> free ( zip_entry ) ; //<S2SV> zip_entry = next_zip_entry ; //<S2SV> } //<S2SV> } //<S2SV> free ( zip -> decrypted_buffer ) ; //<S2SV> if ( zip -> cctx_valid ) //<S2SV> archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; //<S2SV> if ( zip -> hctx_valid ) //<S2SV> archive_hmac_sha1_cleanup ( & zip -> hctx ) ; //<S2SV> free ( zip -> iv ) ; //<S2SV> free ( zip -> erd ) ; //<S2SV> free ( zip -> v_data ) ; //<S2SV> archive_string_free ( & zip -> format_name ) ; //<S2SV> free ( zip ) ; //<S2SV> ( a -> format -> data ) = NULL ; //<S2SV> return ( ARCHIVE_OK ) ; //<S2SV> } //<S2SV> 