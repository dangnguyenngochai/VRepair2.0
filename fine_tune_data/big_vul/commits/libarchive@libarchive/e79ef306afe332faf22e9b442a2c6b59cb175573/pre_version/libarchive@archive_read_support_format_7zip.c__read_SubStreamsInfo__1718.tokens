static int //<S2SV> read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , //<S2SV> struct _7z_folder * f , size_t numFolders ) //<S2SV> { //<S2SV> const unsigned char * p ; //<S2SV> uint64_t * usizes ; //<S2SV> size_t unpack_streams ; //<S2SV> int type ; //<S2SV> unsigned i ; //<S2SV> uint32_t numDigests ; //<S2SV> memset ( ss , 0 , sizeof ( * ss ) ) ; //<S2SV> for ( i = 0 ; i < numFolders ; i ++ ) //<S2SV> f [ i ] . numUnpackStreams = 1 ; //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> type = * p ; //<S2SV> if ( type == kNumUnPackStream ) { //<S2SV> unpack_streams = 0 ; //<S2SV> for ( i = 0 ; i < numFolders ; i ++ ) { //<S2SV> if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) //<S2SV> return ( - 1 ) ; //<S2SV> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; //<S2SV> } //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> type = * p ; //<S2SV> } else //<S2SV> unpack_streams = numFolders ; //<S2SV> ss -> unpack_streams = unpack_streams ; //<S2SV> if ( unpack_streams ) { //<S2SV> ss -> unpackSizes = calloc ( unpack_streams , //<S2SV> sizeof ( * ss -> unpackSizes ) ) ; //<S2SV> ss -> digestsDefined = calloc ( unpack_streams , //<S2SV> sizeof ( * ss -> digestsDefined ) ) ; //<S2SV> ss -> digests = calloc ( unpack_streams , //<S2SV> sizeof ( * ss -> digests ) ) ; //<S2SV> if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || //<S2SV> ss -> digests == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> usizes = ss -> unpackSizes ; //<S2SV> for ( i = 0 ; i < numFolders ; i ++ ) { //<S2SV> unsigned pack ; //<S2SV> uint64_t sum ; //<S2SV> if ( f [ i ] . numUnpackStreams == 0 ) //<S2SV> continue ; //<S2SV> sum = 0 ; //<S2SV> if ( type == kSize ) { //<S2SV> for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { //<S2SV> if ( parse_7zip_uint64 ( a , usizes ) < 0 ) //<S2SV> return ( - 1 ) ; //<S2SV> sum += * usizes ++ ; //<S2SV> } //<S2SV> } //<S2SV> * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; //<S2SV> } //<S2SV> if ( type == kSize ) { //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> type = * p ; //<S2SV> } //<S2SV> for ( i = 0 ; i < unpack_streams ; i ++ ) { //<S2SV> ss -> digestsDefined [ i ] = 0 ; //<S2SV> ss -> digests [ i ] = 0 ; //<S2SV> } //<S2SV> numDigests = 0 ; //<S2SV> for ( i = 0 ; i < numFolders ; i ++ ) { //<S2SV> if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) //<S2SV> numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; //<S2SV> } //<S2SV> if ( type == kCRC ) { //<S2SV> struct _7z_digests tmpDigests ; //<S2SV> unsigned char * digestsDefined = ss -> digestsDefined ; //<S2SV> uint32_t * digests = ss -> digests ; //<S2SV> int di = 0 ; //<S2SV> memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; //<S2SV> if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { //<S2SV> free_Digest ( & tmpDigests ) ; //<S2SV> return ( - 1 ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < numFolders ; i ++ ) { //<S2SV> if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { //<S2SV> * digestsDefined ++ = 1 ; //<S2SV> * digests ++ = f [ i ] . digest ; //<S2SV> } else { //<S2SV> unsigned j ; //<S2SV> for ( j = 0 ; j < f [ i ] . numUnpackStreams ; //<S2SV> j ++ , di ++ ) { //<S2SV> * digestsDefined ++ = //<S2SV> tmpDigests . defineds [ di ] ; //<S2SV> * digests ++ = //<S2SV> tmpDigests . digests [ di ] ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> free_Digest ( & tmpDigests ) ; //<S2SV> if ( ( p = header_bytes ( a , 1 ) ) == NULL ) //<S2SV> return ( - 1 ) ; //<S2SV> type = * p ; //<S2SV> } //<S2SV> if ( type != kEnd ) //<S2SV> return ( - 1 ) ; //<S2SV> return ( 0 ) ; //<S2SV> } //<S2SV> 