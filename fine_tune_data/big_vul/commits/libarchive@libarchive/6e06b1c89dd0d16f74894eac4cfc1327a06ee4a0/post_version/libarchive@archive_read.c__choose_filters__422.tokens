static int //<S2SV> choose_filters ( struct archive_read * a ) //<S2SV> { //<S2SV> int number_bidders , i , bid , best_bid , n ; //<S2SV> struct archive_read_filter_bidder * bidder , * best_bidder ; //<S2SV> struct archive_read_filter * filter ; //<S2SV> ssize_t avail ; //<S2SV> int r ; //<S2SV> for ( n = 0 ; n < 25 ; ++ n ) { //<S2SV> number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ; //<S2SV> best_bid = 0 ; //<S2SV> best_bidder = NULL ; //<S2SV> bidder = a -> bidders ; //<S2SV> for ( i = 0 ; i < number_bidders ; i ++ , bidder ++ ) { //<S2SV> if ( bidder -> bid != NULL ) { //<S2SV> bid = ( bidder -> bid ) ( bidder , a -> filter ) ; //<S2SV> if ( bid > best_bid ) { //<S2SV> best_bid = bid ; //<S2SV> best_bidder = bidder ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( best_bidder == NULL ) { //<S2SV> __archive_read_filter_ahead ( a -> filter , 1 , & avail ) ; //<S2SV> if ( avail < 0 ) { //<S2SV> __archive_read_close_filters ( a ) ; //<S2SV> __archive_read_free_filters ( a ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> a -> archive . compression_name = a -> filter -> name ; //<S2SV> a -> archive . compression_code = a -> filter -> code ; //<S2SV> return ( ARCHIVE_OK ) ; //<S2SV> } //<S2SV> filter //<S2SV> = ( struct archive_read_filter * ) calloc ( 1 , sizeof ( * filter ) ) ; //<S2SV> if ( filter == NULL ) //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> filter -> bidder = best_bidder ; //<S2SV> filter -> archive = a ; //<S2SV> filter -> upstream = a -> filter ; //<S2SV> a -> filter = filter ; //<S2SV> r = ( best_bidder -> init ) ( a -> filter ) ; //<S2SV> if ( r != ARCHIVE_OK ) { //<S2SV> __archive_read_close_filters ( a ) ; //<S2SV> __archive_read_free_filters ( a ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> } //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> 