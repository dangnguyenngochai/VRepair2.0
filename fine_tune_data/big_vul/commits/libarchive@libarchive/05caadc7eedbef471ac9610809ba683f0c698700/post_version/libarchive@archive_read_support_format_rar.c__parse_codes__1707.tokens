static int //<S2SV> parse_codes ( struct archive_read * a ) //<S2SV> { //<S2SV> int i , j , val , n , r ; //<S2SV> unsigned char bitlengths [ MAX_SYMBOLS ] , zerocount , ppmd_flags ; //<S2SV> unsigned int maxorder ; //<S2SV> struct huffman_code precode ; //<S2SV> struct rar * rar = ( struct rar * ) ( a -> format -> data ) ; //<S2SV> struct rar_br * br = & ( rar -> br ) ; //<S2SV> free_codes ( a ) ; //<S2SV> rar_br_consume_unalined_bits ( br ) ; //<S2SV> if ( ! rar_br_read_ahead ( a , br , 1 ) ) //<S2SV> goto truncated_data ; //<S2SV> if ( ( rar -> is_ppmd_block = rar_br_bits ( br , 1 ) ) != 0 ) //<S2SV> { //<S2SV> rar_br_consume ( br , 1 ) ; //<S2SV> if ( ! rar_br_read_ahead ( a , br , 7 ) ) //<S2SV> goto truncated_data ; //<S2SV> ppmd_flags = rar_br_bits ( br , 7 ) ; //<S2SV> rar_br_consume ( br , 7 ) ; //<S2SV> if ( ppmd_flags & 0x20 ) //<S2SV> { //<S2SV> if ( ! rar_br_read_ahead ( a , br , 8 ) ) //<S2SV> goto truncated_data ; //<S2SV> rar -> dictionary_size = ( rar_br_bits ( br , 8 ) + 1 ) << 20 ; //<S2SV> rar_br_consume ( br , 8 ) ; //<S2SV> } //<S2SV> if ( ppmd_flags & 0x40 ) //<S2SV> { //<S2SV> if ( ! rar_br_read_ahead ( a , br , 8 ) ) //<S2SV> goto truncated_data ; //<S2SV> rar -> ppmd_escape = rar -> ppmd7_context . InitEsc = rar_br_bits ( br , 8 ) ; //<S2SV> rar_br_consume ( br , 8 ) ; //<S2SV> } //<S2SV> else //<S2SV> rar -> ppmd_escape = 2 ; //<S2SV> if ( ppmd_flags & 0x20 ) //<S2SV> { //<S2SV> maxorder = ( ppmd_flags & 0x1F ) + 1 ; //<S2SV> if ( maxorder > 16 ) //<S2SV> maxorder = 16 + ( maxorder - 16 ) * 3 ; //<S2SV> if ( maxorder == 1 ) //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Truncated<S2SV_blank>RAR<S2SV_blank>file<S2SV_blank>data" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; //<S2SV> rar -> bytein . a = a ; //<S2SV> rar -> bytein . Read = & ppmd_read ; //<S2SV> __archive_ppmd7_functions . PpmdRAR_RangeDec_CreateVTable ( & rar -> range_dec ) ; //<S2SV> rar -> range_dec . Stream = & rar -> bytein ; //<S2SV> __archive_ppmd7_functions . Ppmd7_Construct ( & rar -> ppmd7_context ) ; //<S2SV> if ( rar -> dictionary_size == 0 ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> if ( ! __archive_ppmd7_functions . Ppmd7_Alloc ( & rar -> ppmd7_context , //<S2SV> rar -> dictionary_size , & g_szalloc ) ) //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ENOMEM , //<S2SV> "Out<S2SV_blank>of<S2SV_blank>memory" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> if ( ! __archive_ppmd7_functions . PpmdRAR_RangeDec_Init ( & rar -> range_dec ) ) //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PPMd<S2SV_blank>range<S2SV_blank>decoder" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> __archive_ppmd7_functions . Ppmd7_Init ( & rar -> ppmd7_context , maxorder ) ; //<S2SV> rar -> ppmd_valid = 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( ! rar -> ppmd_valid ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>PPMd<S2SV_blank>sequence" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> if ( ! __archive_ppmd7_functions . PpmdRAR_RangeDec_Init ( & rar -> range_dec ) ) //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PPMd<S2SV_blank>range<S2SV_blank>decoder" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> rar_br_consume ( br , 1 ) ; //<S2SV> if ( ! rar_br_read_ahead ( a , br , 1 ) ) //<S2SV> goto truncated_data ; //<S2SV> if ( ! rar_br_bits ( br , 1 ) ) //<S2SV> memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; //<S2SV> rar_br_consume ( br , 1 ) ; //<S2SV> memset ( & bitlengths , 0 , sizeof ( bitlengths ) ) ; //<S2SV> for ( i = 0 ; i < MAX_SYMBOLS ; ) //<S2SV> { //<S2SV> if ( ! rar_br_read_ahead ( a , br , 4 ) ) //<S2SV> goto truncated_data ; //<S2SV> bitlengths [ i ++ ] = rar_br_bits ( br , 4 ) ; //<S2SV> rar_br_consume ( br , 4 ) ; //<S2SV> if ( bitlengths [ i - 1 ] == 0xF ) //<S2SV> { //<S2SV> if ( ! rar_br_read_ahead ( a , br , 4 ) ) //<S2SV> goto truncated_data ; //<S2SV> zerocount = rar_br_bits ( br , 4 ) ; //<S2SV> rar_br_consume ( br , 4 ) ; //<S2SV> if ( zerocount ) //<S2SV> { //<S2SV> i -- ; //<S2SV> for ( j = 0 ; j < zerocount + 2 && i < MAX_SYMBOLS ; j ++ ) //<S2SV> bitlengths [ i ++ ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> memset ( & precode , 0 , sizeof ( precode ) ) ; //<S2SV> r = create_code ( a , & precode , bitlengths , MAX_SYMBOLS , MAX_SYMBOL_LENGTH ) ; //<S2SV> if ( r != ARCHIVE_OK ) { //<S2SV> free ( precode . tree ) ; //<S2SV> free ( precode . table ) ; //<S2SV> return ( r ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < HUFFMAN_TABLE_SIZE ; ) //<S2SV> { //<S2SV> if ( ( val = read_next_symbol ( a , & precode ) ) < 0 ) { //<S2SV> free ( precode . tree ) ; //<S2SV> free ( precode . table ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> if ( val < 16 ) //<S2SV> { //<S2SV> rar -> lengthtable [ i ] = ( rar -> lengthtable [ i ] + val ) & 0xF ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> else if ( val < 18 ) //<S2SV> { //<S2SV> if ( i == 0 ) //<S2SV> { //<S2SV> free ( precode . tree ) ; //<S2SV> free ( precode . table ) ; //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Internal<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>RAR<S2SV_blank>file." ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> if ( val == 16 ) { //<S2SV> if ( ! rar_br_read_ahead ( a , br , 3 ) ) { //<S2SV> free ( precode . tree ) ; //<S2SV> free ( precode . table ) ; //<S2SV> goto truncated_data ; //<S2SV> } //<S2SV> n = rar_br_bits ( br , 3 ) + 3 ; //<S2SV> rar_br_consume ( br , 3 ) ; //<S2SV> } else { //<S2SV> if ( ! rar_br_read_ahead ( a , br , 7 ) ) { //<S2SV> free ( precode . tree ) ; //<S2SV> free ( precode . table ) ; //<S2SV> goto truncated_data ; //<S2SV> } //<S2SV> n = rar_br_bits ( br , 7 ) + 11 ; //<S2SV> rar_br_consume ( br , 7 ) ; //<S2SV> } //<S2SV> for ( j = 0 ; j < n && i < HUFFMAN_TABLE_SIZE ; j ++ ) //<S2SV> { //<S2SV> rar -> lengthtable [ i ] = rar -> lengthtable [ i - 1 ] ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( val == 18 ) { //<S2SV> if ( ! rar_br_read_ahead ( a , br , 3 ) ) { //<S2SV> free ( precode . tree ) ; //<S2SV> free ( precode . table ) ; //<S2SV> goto truncated_data ; //<S2SV> } //<S2SV> n = rar_br_bits ( br , 3 ) + 3 ; //<S2SV> rar_br_consume ( br , 3 ) ; //<S2SV> } else { //<S2SV> if ( ! rar_br_read_ahead ( a , br , 7 ) ) { //<S2SV> free ( precode . tree ) ; //<S2SV> free ( precode . table ) ; //<S2SV> goto truncated_data ; //<S2SV> } //<S2SV> n = rar_br_bits ( br , 7 ) + 11 ; //<S2SV> rar_br_consume ( br , 7 ) ; //<S2SV> } //<S2SV> for ( j = 0 ; j < n && i < HUFFMAN_TABLE_SIZE ; j ++ ) //<S2SV> rar -> lengthtable [ i ++ ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> free ( precode . tree ) ; //<S2SV> free ( precode . table ) ; //<S2SV> r = create_code ( a , & rar -> maincode , & rar -> lengthtable [ 0 ] , MAINCODE_SIZE , //<S2SV> MAX_SYMBOL_LENGTH ) ; //<S2SV> if ( r != ARCHIVE_OK ) //<S2SV> return ( r ) ; //<S2SV> r = create_code ( a , & rar -> offsetcode , & rar -> lengthtable [ MAINCODE_SIZE ] , //<S2SV> OFFSETCODE_SIZE , MAX_SYMBOL_LENGTH ) ; //<S2SV> if ( r != ARCHIVE_OK ) //<S2SV> return ( r ) ; //<S2SV> r = create_code ( a , & rar -> lowoffsetcode , //<S2SV> & rar -> lengthtable [ MAINCODE_SIZE + OFFSETCODE_SIZE ] , //<S2SV> LOWOFFSETCODE_SIZE , MAX_SYMBOL_LENGTH ) ; //<S2SV> if ( r != ARCHIVE_OK ) //<S2SV> return ( r ) ; //<S2SV> r = create_code ( a , & rar -> lengthcode , //<S2SV> & rar -> lengthtable [ MAINCODE_SIZE + OFFSETCODE_SIZE + //<S2SV> LOWOFFSETCODE_SIZE ] , LENGTHCODE_SIZE , MAX_SYMBOL_LENGTH ) ; //<S2SV> if ( r != ARCHIVE_OK ) //<S2SV> return ( r ) ; //<S2SV> } //<S2SV> if ( ! rar -> dictionary_size || ! rar -> lzss . window ) //<S2SV> { //<S2SV> void * new_window ; //<S2SV> unsigned int new_size ; //<S2SV> if ( rar -> unp_size >= DICTIONARY_MAX_SIZE ) //<S2SV> new_size = DICTIONARY_MAX_SIZE ; //<S2SV> else //<S2SV> new_size = rar_fls ( ( unsigned int ) rar -> unp_size ) << 1 ; //<S2SV> new_window = realloc ( rar -> lzss . window , new_size ) ; //<S2SV> if ( new_window == NULL ) { //<S2SV> archive_set_error ( & a -> archive , ENOMEM , //<S2SV> "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>uncompressed<S2SV_blank>data." ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> rar -> lzss . window = ( unsigned char * ) new_window ; //<S2SV> rar -> dictionary_size = new_size ; //<S2SV> memset ( rar -> lzss . window , 0 , rar -> dictionary_size ) ; //<S2SV> rar -> lzss . mask = rar -> dictionary_size - 1 ; //<S2SV> } //<S2SV> rar -> start_new_table = 0 ; //<S2SV> return ( ARCHIVE_OK ) ; //<S2SV> truncated_data : //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Truncated<S2SV_blank>RAR<S2SV_blank>file<S2SV_blank>data" ) ; //<S2SV> rar -> valid = 0 ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> 