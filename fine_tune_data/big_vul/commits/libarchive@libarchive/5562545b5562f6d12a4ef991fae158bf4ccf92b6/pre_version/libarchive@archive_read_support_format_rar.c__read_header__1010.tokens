static int //<S2SV> read_header ( struct archive_read * a , struct archive_entry * entry , //<S2SV> char head_type ) //<S2SV> { //<S2SV> const void * h ; //<S2SV> const char * p , * endp ; //<S2SV> struct rar * rar ; //<S2SV> struct rar_header rar_header ; //<S2SV> struct rar_file_header file_header ; //<S2SV> int64_t header_size ; //<S2SV> unsigned filename_size , end ; //<S2SV> char * filename ; //<S2SV> char * strp ; //<S2SV> char packed_size [ 8 ] ; //<S2SV> char unp_size [ 8 ] ; //<S2SV> int ttime ; //<S2SV> struct archive_string_conv * sconv , * fn_sconv ; //<S2SV> unsigned long crc32_val ; //<S2SV> int ret = ( ARCHIVE_OK ) , ret2 ; //<S2SV> rar = ( struct rar * ) ( a -> format -> data ) ; //<S2SV> sconv = rar -> opt_sconv ; //<S2SV> if ( sconv == NULL ) { //<S2SV> if ( ! rar -> init_default_conversion ) { //<S2SV> rar -> sconv_default = //<S2SV> archive_string_default_conversion_for_read ( //<S2SV> & ( a -> archive ) ) ; //<S2SV> rar -> init_default_conversion = 1 ; //<S2SV> } //<S2SV> sconv = rar -> sconv_default ; //<S2SV> } //<S2SV> if ( ( h = __archive_read_ahead ( a , 7 , NULL ) ) == NULL ) //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> p = h ; //<S2SV> memcpy ( & rar_header , p , sizeof ( rar_header ) ) ; //<S2SV> rar -> file_flags = archive_le16dec ( rar_header . flags ) ; //<S2SV> header_size = archive_le16dec ( rar_header . size ) ; //<S2SV> if ( header_size < ( int64_t ) sizeof ( file_header ) + 7 ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>header<S2SV_blank>size" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> crc32_val = crc32 ( 0 , ( const unsigned char * ) p + 2 , 7 - 2 ) ; //<S2SV> __archive_read_consume ( a , 7 ) ; //<S2SV> if ( ! ( rar -> file_flags & FHD_SOLID ) ) //<S2SV> { //<S2SV> rar -> compression_method = 0 ; //<S2SV> rar -> packed_size = 0 ; //<S2SV> rar -> unp_size = 0 ; //<S2SV> rar -> mtime = 0 ; //<S2SV> rar -> ctime = 0 ; //<S2SV> rar -> atime = 0 ; //<S2SV> rar -> arctime = 0 ; //<S2SV> rar -> mode = 0 ; //<S2SV> memset ( & rar -> salt , 0 , sizeof ( rar -> salt ) ) ; //<S2SV> rar -> atime = 0 ; //<S2SV> rar -> ansec = 0 ; //<S2SV> rar -> ctime = 0 ; //<S2SV> rar -> cnsec = 0 ; //<S2SV> rar -> mtime = 0 ; //<S2SV> rar -> mnsec = 0 ; //<S2SV> rar -> arctime = 0 ; //<S2SV> rar -> arcnsec = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "RAR<S2SV_blank>solid<S2SV_blank>archive<S2SV_blank>support<S2SV_blank>unavailable." ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> crc32_val = crc32 ( crc32_val , h , ( unsigned ) ( header_size - 7 ) ) ; //<S2SV> if ( ( crc32_val & 0xffff ) != archive_le16dec ( rar_header . crc ) ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Header<S2SV_blank>CRC<S2SV_blank>error" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> p = h ; //<S2SV> endp = p + header_size - 7 ; //<S2SV> memcpy ( & file_header , p , sizeof ( file_header ) ) ; //<S2SV> p += sizeof ( file_header ) ; //<S2SV> rar -> compression_method = file_header . method ; //<S2SV> ttime = archive_le32dec ( file_header . file_time ) ; //<S2SV> rar -> mtime = get_time ( ttime ) ; //<S2SV> rar -> file_crc = archive_le32dec ( file_header . file_crc ) ; //<S2SV> if ( rar -> file_flags & FHD_PASSWORD ) //<S2SV> { //<S2SV> archive_entry_set_is_data_encrypted ( entry , 1 ) ; //<S2SV> rar -> has_encrypted_entries = 1 ; //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "RAR<S2SV_blank>encryption<S2SV_blank>support<S2SV_blank>unavailable." ) ; //<S2SV> } //<S2SV> if ( rar -> file_flags & FHD_LARGE ) //<S2SV> { //<S2SV> memcpy ( packed_size , file_header . pack_size , 4 ) ; //<S2SV> memcpy ( packed_size + 4 , p , 4 ) ; //<S2SV> p += 4 ; //<S2SV> memcpy ( unp_size , file_header . unp_size , 4 ) ; //<S2SV> memcpy ( unp_size + 4 , p , 4 ) ; //<S2SV> p += 4 ; //<S2SV> rar -> packed_size = archive_le64dec ( & packed_size ) ; //<S2SV> rar -> unp_size = archive_le64dec ( & unp_size ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> rar -> packed_size = archive_le32dec ( file_header . pack_size ) ; //<S2SV> rar -> unp_size = archive_le32dec ( file_header . unp_size ) ; //<S2SV> } //<S2SV> if ( rar -> packed_size < 0 || rar -> unp_size < 0 ) //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>sizes<S2SV_blank>specified." ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> rar -> bytes_remaining = rar -> packed_size ; //<S2SV> if ( head_type == NEWSUB_HEAD ) { //<S2SV> size_t distance = p - ( const char * ) h ; //<S2SV> header_size += rar -> packed_size ; //<S2SV> if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> p = h ; //<S2SV> endp = p + header_size - 7 ; //<S2SV> p += distance ; //<S2SV> } //<S2SV> filename_size = archive_le16dec ( file_header . name_size ) ; //<S2SV> if ( p + filename_size > endp ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>filename<S2SV_blank>size" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> if ( rar -> filename_allocated < filename_size * 2 + 2 ) { //<S2SV> char * newptr ; //<S2SV> size_t newsize = filename_size * 2 + 2 ; //<S2SV> newptr = realloc ( rar -> filename , newsize ) ; //<S2SV> if ( newptr == NULL ) { //<S2SV> archive_set_error ( & a -> archive , ENOMEM , //<S2SV> "Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory." ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> rar -> filename = newptr ; //<S2SV> rar -> filename_allocated = newsize ; //<S2SV> } //<S2SV> filename = rar -> filename ; //<S2SV> memcpy ( filename , p , filename_size ) ; //<S2SV> filename [ filename_size ] = '\\0' ; //<S2SV> if ( rar -> file_flags & FHD_UNICODE ) //<S2SV> { //<S2SV> if ( filename_size != strlen ( filename ) ) //<S2SV> { //<S2SV> unsigned char highbyte , flagbits , flagbyte ; //<S2SV> unsigned fn_end , offset ; //<S2SV> end = filename_size ; //<S2SV> fn_end = filename_size * 2 ; //<S2SV> filename_size = 0 ; //<S2SV> offset = ( unsigned ) strlen ( filename ) + 1 ; //<S2SV> highbyte = * ( p + offset ++ ) ; //<S2SV> flagbits = 0 ; //<S2SV> flagbyte = 0 ; //<S2SV> while ( offset < end && filename_size < fn_end ) //<S2SV> { //<S2SV> if ( ! flagbits ) //<S2SV> { //<S2SV> flagbyte = * ( p + offset ++ ) ; //<S2SV> flagbits = 8 ; //<S2SV> } //<S2SV> flagbits -= 2 ; //<S2SV> switch ( ( flagbyte >> flagbits ) & 3 ) //<S2SV> { //<S2SV> case 0 : //<S2SV> filename [ filename_size ++ ] = '\\0' ; //<S2SV> filename [ filename_size ++ ] = * ( p + offset ++ ) ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> filename [ filename_size ++ ] = highbyte ; //<S2SV> filename [ filename_size ++ ] = * ( p + offset ++ ) ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> filename [ filename_size ++ ] = * ( p + offset + 1 ) ; //<S2SV> filename [ filename_size ++ ] = * ( p + offset ) ; //<S2SV> offset += 2 ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> { //<S2SV> char extra , high ; //<S2SV> uint8_t length = * ( p + offset ++ ) ; //<S2SV> if ( length & 0x80 ) { //<S2SV> extra = * ( p + offset ++ ) ; //<S2SV> high = ( char ) highbyte ; //<S2SV> } else //<S2SV> extra = high = 0 ; //<S2SV> length = ( length & 0x7f ) + 2 ; //<S2SV> while ( length && filename_size < fn_end ) { //<S2SV> unsigned cp = filename_size >> 1 ; //<S2SV> filename [ filename_size ++ ] = high ; //<S2SV> filename [ filename_size ++ ] = p [ cp ] + extra ; //<S2SV> length -- ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( filename_size > fn_end ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>filename" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> filename [ filename_size ++ ] = '\\0' ; //<S2SV> filename [ filename_size ++ ] = '\\0' ; //<S2SV> if ( rar -> sconv_utf16be == NULL ) { //<S2SV> rar -> sconv_utf16be = archive_string_conversion_from_charset ( //<S2SV> & a -> archive , "UTF-16BE" , 1 ) ; //<S2SV> if ( rar -> sconv_utf16be == NULL ) //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> fn_sconv = rar -> sconv_utf16be ; //<S2SV> strp = filename ; //<S2SV> while ( memcmp ( strp , "\\x00\\x00" , 2 ) ) //<S2SV> { //<S2SV> if ( ! memcmp ( strp , "\\x00\\\\" , 2 ) ) //<S2SV> * ( strp + 1 ) = '/' ; //<S2SV> strp += 2 ; //<S2SV> } //<S2SV> p += offset ; //<S2SV> } else { //<S2SV> if ( rar -> sconv_utf8 == NULL ) { //<S2SV> rar -> sconv_utf8 = archive_string_conversion_from_charset ( //<S2SV> & a -> archive , "UTF-8" , 1 ) ; //<S2SV> if ( rar -> sconv_utf8 == NULL ) //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> fn_sconv = rar -> sconv_utf8 ; //<S2SV> while ( ( strp = strchr ( filename , '\\\\' ) ) != NULL ) //<S2SV> * strp = '/' ; //<S2SV> p += filename_size ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> fn_sconv = sconv ; //<S2SV> while ( ( strp = strchr ( filename , '\\\\' ) ) != NULL ) //<S2SV> * strp = '/' ; //<S2SV> p += filename_size ; //<S2SV> } //<S2SV> if ( rar -> filename_save && //<S2SV> filename_size == rar -> filename_save_size && //<S2SV> ! memcmp ( rar -> filename , rar -> filename_save , filename_size + 1 ) ) //<S2SV> { //<S2SV> __archive_read_consume ( a , header_size - 7 ) ; //<S2SV> rar -> cursor ++ ; //<S2SV> if ( rar -> cursor >= rar -> nodes ) //<S2SV> { //<S2SV> rar -> nodes ++ ; //<S2SV> if ( ( rar -> dbo = //<S2SV> realloc ( rar -> dbo , sizeof ( * rar -> dbo ) * rar -> nodes ) ) == NULL ) //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ENOMEM , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory." ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> rar -> dbo [ rar -> cursor ] . header_size = header_size ; //<S2SV> rar -> dbo [ rar -> cursor ] . start_offset = - 1 ; //<S2SV> rar -> dbo [ rar -> cursor ] . end_offset = - 1 ; //<S2SV> } //<S2SV> if ( rar -> dbo [ rar -> cursor ] . start_offset < 0 ) //<S2SV> { //<S2SV> rar -> dbo [ rar -> cursor ] . start_offset = a -> filter -> position ; //<S2SV> rar -> dbo [ rar -> cursor ] . end_offset = rar -> dbo [ rar -> cursor ] . start_offset + //<S2SV> rar -> packed_size ; //<S2SV> } //<S2SV> return ret ; //<S2SV> } //<S2SV> rar -> filename_save = ( char * ) realloc ( rar -> filename_save , //<S2SV> filename_size + 1 ) ; //<S2SV> memcpy ( rar -> filename_save , rar -> filename , filename_size + 1 ) ; //<S2SV> rar -> filename_save_size = filename_size ; //<S2SV> free ( rar -> dbo ) ; //<S2SV> if ( ( rar -> dbo = calloc ( 1 , sizeof ( * rar -> dbo ) ) ) == NULL ) //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ENOMEM , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory." ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> rar -> dbo [ 0 ] . header_size = header_size ; //<S2SV> rar -> dbo [ 0 ] . start_offset = - 1 ; //<S2SV> rar -> dbo [ 0 ] . end_offset = - 1 ; //<S2SV> rar -> cursor = 0 ; //<S2SV> rar -> nodes = 1 ; //<S2SV> if ( rar -> file_flags & FHD_SALT ) //<S2SV> { //<S2SV> if ( p + 8 > endp ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>header<S2SV_blank>size" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> memcpy ( rar -> salt , p , 8 ) ; //<S2SV> p += 8 ; //<S2SV> } //<S2SV> if ( rar -> file_flags & FHD_EXTTIME ) { //<S2SV> if ( read_exttime ( p , rar , endp ) < 0 ) { //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Invalid<S2SV_blank>header<S2SV_blank>size" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> } //<S2SV> __archive_read_consume ( a , header_size - 7 ) ; //<S2SV> rar -> dbo [ 0 ] . start_offset = a -> filter -> position ; //<S2SV> rar -> dbo [ 0 ] . end_offset = rar -> dbo [ 0 ] . start_offset + rar -> packed_size ; //<S2SV> switch ( file_header . host_os ) //<S2SV> { //<S2SV> case OS_MSDOS : //<S2SV> case OS_OS2 : //<S2SV> case OS_WIN32 : //<S2SV> rar -> mode = archive_le32dec ( file_header . file_attr ) ; //<S2SV> if ( rar -> mode & FILE_ATTRIBUTE_DIRECTORY ) //<S2SV> rar -> mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH ; //<S2SV> else //<S2SV> rar -> mode = AE_IFREG ; //<S2SV> rar -> mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ; //<S2SV> break ; //<S2SV> case OS_UNIX : //<S2SV> case OS_MAC_OS : //<S2SV> case OS_BEOS : //<S2SV> rar -> mode = archive_le32dec ( file_header . file_attr ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Unknown<S2SV_blank>file<S2SV_blank>attributes<S2SV_blank>from<S2SV_blank>RAR<S2SV_blank>file\'s<S2SV_blank>host<S2SV_blank>OS" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> rar -> bytes_uncopied = rar -> bytes_unconsumed = 0 ; //<S2SV> rar -> lzss . position = rar -> offset = 0 ; //<S2SV> rar -> offset_seek = 0 ; //<S2SV> rar -> dictionary_size = 0 ; //<S2SV> rar -> offset_outgoing = 0 ; //<S2SV> rar -> br . cache_avail = 0 ; //<S2SV> rar -> br . avail_in = 0 ; //<S2SV> rar -> crc_calculated = 0 ; //<S2SV> rar -> entry_eof = 0 ; //<S2SV> rar -> valid = 1 ; //<S2SV> rar -> is_ppmd_block = 0 ; //<S2SV> rar -> start_new_table = 1 ; //<S2SV> free ( rar -> unp_buffer ) ; //<S2SV> rar -> unp_buffer = NULL ; //<S2SV> rar -> unp_offset = 0 ; //<S2SV> rar -> unp_buffer_size = UNP_BUFFER_SIZE ; //<S2SV> memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; //<S2SV> __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; //<S2SV> rar -> ppmd_valid = rar -> ppmd_eod = 0 ; //<S2SV> if ( head_type == NEWSUB_HEAD ) //<S2SV> return ret ; //<S2SV> archive_entry_set_mtime ( entry , rar -> mtime , rar -> mnsec ) ; //<S2SV> archive_entry_set_ctime ( entry , rar -> ctime , rar -> cnsec ) ; //<S2SV> archive_entry_set_atime ( entry , rar -> atime , rar -> ansec ) ; //<S2SV> archive_entry_set_size ( entry , rar -> unp_size ) ; //<S2SV> archive_entry_set_mode ( entry , rar -> mode ) ; //<S2SV> if ( archive_entry_copy_pathname_l ( entry , filename , filename_size , fn_sconv ) ) //<S2SV> { //<S2SV> if ( errno == ENOMEM ) //<S2SV> { //<S2SV> archive_set_error ( & a -> archive , ENOMEM , //<S2SV> "Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname" ) ; //<S2SV> return ( ARCHIVE_FATAL ) ; //<S2SV> } //<S2SV> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , //<S2SV> "Pathname<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale." , //<S2SV> archive_string_conversion_charset_name ( fn_sconv ) ) ; //<S2SV> ret = ( ARCHIVE_WARN ) ; //<S2SV> } //<S2SV> if ( ( ( rar -> mode ) & AE_IFMT ) == AE_IFLNK ) //<S2SV> { //<S2SV> rar -> bytes_remaining = 0 ; //<S2SV> archive_entry_set_size ( entry , 0 ) ; //<S2SV> if ( ( ret2 = read_symlink_stored ( a , entry , sconv ) ) < ( ARCHIVE_WARN ) ) //<S2SV> return ret2 ; //<S2SV> if ( ret > ret2 ) //<S2SV> ret = ret2 ; //<S2SV> } //<S2SV> if ( rar -> bytes_remaining == 0 ) //<S2SV> rar -> entry_eof = 1 ; //<S2SV> return ret ; //<S2SV> } //<S2SV> 