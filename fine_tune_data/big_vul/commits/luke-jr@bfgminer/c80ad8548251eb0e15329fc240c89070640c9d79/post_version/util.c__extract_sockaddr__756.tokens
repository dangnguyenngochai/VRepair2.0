bool extract_sockaddr ( struct pool * pool , char * url ) //<S2SV> { //<S2SV> char * url_begin , * url_end , * ipv6_begin , * ipv6_end , * port_start = NULL ; //<S2SV> char url_address [ 256 ] , port [ 6 ] ; //<S2SV> int url_len , port_len = 0 ; //<S2SV> url_begin = strstr ( url , "//" ) ; //<S2SV> if ( ! url_begin ) //<S2SV> url_begin = url ; //<S2SV> else //<S2SV> url_begin += 2 ; //<S2SV> ipv6_begin = strstr ( url_begin , "[" ) ; //<S2SV> ipv6_end = strstr ( url_begin , "]" ) ; //<S2SV> if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin ) //<S2SV> url_end = strstr ( ipv6_end , ":" ) ; //<S2SV> else //<S2SV> url_end = strstr ( url_begin , ":" ) ; //<S2SV> if ( url_end ) { //<S2SV> url_len = url_end - url_begin ; //<S2SV> port_len = strlen ( url_begin ) - url_len - 1 ; //<S2SV> if ( port_len < 1 ) //<S2SV> return false ; //<S2SV> port_start = url_end + 1 ; //<S2SV> } else //<S2SV> url_len = strlen ( url_begin ) ; //<S2SV> if ( url_len < 1 ) //<S2SV> return false ; //<S2SV> if ( url_len >= sizeof ( url_address ) ) //<S2SV> { //<S2SV> applog ( LOG_WARNING , "%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\'%.*s\'" , //<S2SV> __func__ , url_len , url_begin ) ; //<S2SV> url_len = sizeof ( url_address ) - 1 ; //<S2SV> } //<S2SV> sprintf ( url_address , "%.*s" , url_len , url_begin ) ; //<S2SV> if ( port_len ) //<S2SV> snprintf ( port , 6 , "%.*s" , port_len , port_start ) ; //<S2SV> else //<S2SV> strcpy ( port , "80" ) ; //<S2SV> free ( pool -> stratum_port ) ; //<S2SV> pool -> stratum_port = strdup ( port ) ; //<S2SV> free ( pool -> sockaddr_url ) ; //<S2SV> pool -> sockaddr_url = strdup ( url_address ) ; //<S2SV> return true ; //<S2SV> } //<S2SV> 