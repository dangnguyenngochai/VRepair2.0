static INT //<S2SV> AirPDcapDecryptWPABroadcastKey ( const EAPOL_RSN_KEY * pEAPKey , guint8 * decryption_key , PAIRPDCAP_SEC_ASSOCIATION sa , guint eapol_len ) //<S2SV> { //<S2SV> guint8 key_version ; //<S2SV> guint8 * key_data ; //<S2SV> guint8 * szEncryptedKey ; //<S2SV> guint16 key_bytes_len = 0 ; //<S2SV> guint16 key_len ; //<S2SV> static AIRPDCAP_KEY_ITEM dummy_key ; //<S2SV> AIRPDCAP_SEC_ASSOCIATION * tmp_sa ; //<S2SV> key_version = AIRPDCAP_EAP_KEY_DESCR_VER ( pEAPKey -> key_information [ 1 ] ) ; //<S2SV> if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { //<S2SV> key_bytes_len = pntoh16 ( pEAPKey -> key_length ) ; //<S2SV> } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { //<S2SV> key_bytes_len = pntoh16 ( pEAPKey -> key_data_len ) ; //<S2SV> if ( key_bytes_len < 16 ) { //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( key_bytes_len < GROUP_KEY_MIN_LEN ) || //<S2SV> ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || //<S2SV> ( key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) ) { //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> key_data = ( guint8 * ) pEAPKey + sizeof ( EAPOL_RSN_KEY ) ; //<S2SV> szEncryptedKey = ( guint8 * ) g_memdup ( key_data , key_bytes_len ) ; //<S2SV> DEBUG_DUMP ( "Encrypted<S2SV_blank>Broadcast<S2SV_blank>key:" , szEncryptedKey , key_bytes_len ) ; //<S2SV> DEBUG_DUMP ( "KeyIV:" , pEAPKey -> key_iv , 16 ) ; //<S2SV> DEBUG_DUMP ( "decryption_key:" , decryption_key , 16 ) ; //<S2SV> tmp_sa = ( AIRPDCAP_SEC_ASSOCIATION * ) g_malloc ( sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; //<S2SV> memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; //<S2SV> sa -> next = tmp_sa ; //<S2SV> if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { //<S2SV> guint8 new_key [ 32 ] ; //<S2SV> guint8 dummy [ 256 ] ; //<S2SV> rc4_state_struct rc4_state ; //<S2SV> sa -> wpa . key_ver = ( key_bytes_len >= TKIP_GROUP_KEY_LEN ) ? AIRPDCAP_WPA_KEY_VER_NOT_CCMP : AIRPDCAP_WPA_KEY_VER_AES_CCMP ; //<S2SV> memcpy ( new_key , pEAPKey -> key_iv , 16 ) ; //<S2SV> memcpy ( new_key + 16 , decryption_key , 16 ) ; //<S2SV> DEBUG_DUMP ( "FullDecrKey:" , new_key , 32 ) ; //<S2SV> crypt_rc4_init ( & rc4_state , new_key , sizeof ( new_key ) ) ; //<S2SV> crypt_rc4 ( & rc4_state , dummy , 256 ) ; //<S2SV> crypt_rc4 ( & rc4_state , szEncryptedKey , key_bytes_len ) ; //<S2SV> } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { //<S2SV> guint8 key_found ; //<S2SV> guint8 key_length ; //<S2SV> guint16 key_index ; //<S2SV> guint8 * decrypted_data ; //<S2SV> decrypted_data = AES_unwrap ( decryption_key , 16 , szEncryptedKey , key_bytes_len ) ; //<S2SV> key_found = FALSE ; //<S2SV> key_index = 0 ; //<S2SV> while ( key_index < ( key_bytes_len - 6 ) && ! key_found ) { //<S2SV> guint8 rsn_id ; //<S2SV> guint32 type ; //<S2SV> rsn_id = decrypted_data [ key_index ] ; //<S2SV> type = ( ( decrypted_data [ key_index + 2 ] << 24 ) + //<S2SV> ( decrypted_data [ key_index + 3 ] << 16 ) + //<S2SV> ( decrypted_data [ key_index + 4 ] << 8 ) + //<S2SV> ( decrypted_data [ key_index + 5 ] ) ) ; //<S2SV> if ( rsn_id == 0xdd && type == 0x000fac01 ) { //<S2SV> key_found = TRUE ; //<S2SV> } else { //<S2SV> key_index += decrypted_data [ key_index + 1 ] + 2 ; //<S2SV> } //<S2SV> } //<S2SV> if ( key_found ) { //<S2SV> key_length = decrypted_data [ key_index + 1 ] - 6 ; //<S2SV> if ( key_index + 8 >= key_bytes_len || //<S2SV> key_length > key_bytes_len - key_index - 8 ) { //<S2SV> g_free ( decrypted_data ) ; //<S2SV> g_free ( szEncryptedKey ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> memcpy ( szEncryptedKey , decrypted_data + key_index + 8 , key_length ) ; //<S2SV> } else { //<S2SV> g_free ( decrypted_data ) ; //<S2SV> g_free ( szEncryptedKey ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> if ( key_length == TKIP_GROUP_KEY_LEN ) //<S2SV> sa -> wpa . key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP ; //<S2SV> else //<S2SV> sa -> wpa . key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP ; //<S2SV> g_free ( decrypted_data ) ; //<S2SV> } //<S2SV> key_len = ( sa -> wpa . key_ver == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) ? TKIP_GROUP_KEY_LEN : CCMP_GROUP_KEY_LEN ; //<S2SV> if ( key_len > key_bytes_len ) { //<S2SV> g_free ( szEncryptedKey ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> DEBUG_DUMP ( "Broadcast<S2SV_blank>key:" , szEncryptedKey , key_len ) ; //<S2SV> sa -> key = & dummy_key ; //<S2SV> sa -> validKey = TRUE ; //<S2SV> memset ( sa -> wpa . ptk , 0 , sizeof ( sa -> wpa . ptk ) ) ; //<S2SV> memcpy ( sa -> wpa . ptk + 32 , szEncryptedKey , key_len ) ; //<S2SV> g_free ( szEncryptedKey ) ; //<S2SV> return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; //<S2SV> } //<S2SV> 