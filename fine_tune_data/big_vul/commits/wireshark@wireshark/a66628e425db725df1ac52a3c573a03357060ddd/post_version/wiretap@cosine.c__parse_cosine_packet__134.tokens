static gboolean //<S2SV> parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , //<S2SV> char * line , int * err , gchar * * err_info ) //<S2SV> { //<S2SV> union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; //<S2SV> int num_items_scanned ; //<S2SV> int yy , mm , dd , hr , min , sec , csec , pkt_len ; //<S2SV> int pro , off , pri , rm , error ; //<S2SV> guint code1 , code2 ; //<S2SV> char if_name [ COSINE_MAX_IF_NAME_LEN ] = "" , direction [ 6 ] = "" ; //<S2SV> struct tm tm ; //<S2SV> guint8 * pd ; //<S2SV> int i , hex_lines , n , caplen = 0 ; //<S2SV> if ( sscanf ( line , "%4d-%2d-%2d,%2d:%2d:%2d.%9d:" , //<S2SV> & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { //<S2SV> num_items_scanned = sscanf ( line , //<S2SV> "%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" , //<S2SV> & yy , & mm , & dd , & hr , & min , & sec , & csec , //<S2SV> direction , if_name , & pkt_len , //<S2SV> & pro , & off , & pri , & rm , & error , //<S2SV> & code1 , & code2 ) ; //<S2SV> if ( num_items_scanned != 17 ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup ( "cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> } else { //<S2SV> num_items_scanned = sscanf ( line , //<S2SV> "%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" , //<S2SV> direction , if_name , & pkt_len , //<S2SV> & pro , & off , & pri , & rm , & error , //<S2SV> & code1 , & code2 ) ; //<S2SV> if ( num_items_scanned != 10 ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup ( "cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> yy = mm = dd = hr = min = sec = csec = 0 ; //<S2SV> } //<S2SV> if ( pkt_len < 0 ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup ( "cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup_printf ( "cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , //<S2SV> pkt_len , WTAP_MAX_PACKET_SIZE ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> phdr -> rec_type = REC_TYPE_PACKET ; //<S2SV> phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; //<S2SV> tm . tm_year = yy - 1900 ; //<S2SV> tm . tm_mon = mm - 1 ; //<S2SV> tm . tm_mday = dd ; //<S2SV> tm . tm_hour = hr ; //<S2SV> tm . tm_min = min ; //<S2SV> tm . tm_sec = sec ; //<S2SV> tm . tm_isdst = - 1 ; //<S2SV> phdr -> ts . secs = mktime ( & tm ) ; //<S2SV> phdr -> ts . nsecs = csec * 10000000 ; //<S2SV> phdr -> len = pkt_len ; //<S2SV> if ( strncmp ( if_name , "TEST:" , 5 ) == 0 ) { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; //<S2SV> } else if ( strncmp ( if_name , "PPoATM:" , 7 ) == 0 ) { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; //<S2SV> } else if ( strncmp ( if_name , "PPoFR:" , 6 ) == 0 ) { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; //<S2SV> } else if ( strncmp ( if_name , "ATM:" , 4 ) == 0 ) { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; //<S2SV> } else if ( strncmp ( if_name , "FR:" , 3 ) == 0 ) { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; //<S2SV> } else if ( strncmp ( if_name , "HDLC:" , 5 ) == 0 ) { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; //<S2SV> } else if ( strncmp ( if_name , "PPP:" , 4 ) == 0 ) { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; //<S2SV> } else if ( strncmp ( if_name , "ETH:" , 4 ) == 0 ) { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; //<S2SV> } else { //<S2SV> pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; //<S2SV> } //<S2SV> if ( strncmp ( direction , "l2-tx" , 5 ) == 0 ) { //<S2SV> pseudo_header -> cosine . direction = COSINE_DIR_TX ; //<S2SV> } else if ( strncmp ( direction , "l2-rx" , 5 ) == 0 ) { //<S2SV> pseudo_header -> cosine . direction = COSINE_DIR_RX ; //<S2SV> } //<S2SV> g_strlcpy ( pseudo_header -> cosine . if_name , if_name , //<S2SV> COSINE_MAX_IF_NAME_LEN ) ; //<S2SV> pseudo_header -> cosine . pro = pro ; //<S2SV> pseudo_header -> cosine . off = off ; //<S2SV> pseudo_header -> cosine . pri = pri ; //<S2SV> pseudo_header -> cosine . rm = rm ; //<S2SV> pseudo_header -> cosine . err = error ; //<S2SV> ws_buffer_assure_space ( buf , pkt_len ) ; //<S2SV> pd = ws_buffer_start_ptr ( buf ) ; //<S2SV> hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; //<S2SV> for ( i = 0 ; i < hex_lines ; i ++ ) { //<S2SV> if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { //<S2SV> * err = file_error ( fh , err_info ) ; //<S2SV> if ( * err == 0 ) { //<S2SV> * err = WTAP_ERR_SHORT_READ ; //<S2SV> } //<S2SV> return FALSE ; //<S2SV> } //<S2SV> if ( empty_line ( line ) ) { //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup ( "cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> caplen += n ; //<S2SV> } //<S2SV> phdr -> caplen = caplen ; //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 