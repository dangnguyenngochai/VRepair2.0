static int //<S2SV> dissect_u3v ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) //<S2SV> { //<S2SV> gint offset = 0 ; //<S2SV> proto_tree * u3v_tree = NULL , * ccd_tree_flag , * u3v_telegram_tree = NULL , * ccd_tree = NULL ; //<S2SV> gint data_length = 0 ; //<S2SV> gint req_id = 0 ; //<S2SV> gint command_id = - 1 ; //<S2SV> gint status = 0 ; //<S2SV> guint prefix = 0 ; //<S2SV> proto_item * ti = NULL ; //<S2SV> proto_item * item = NULL ; //<S2SV> const char * command_string ; //<S2SV> usb_conv_info_t * usb_conv_info ; //<S2SV> gint stream_detected = FALSE ; //<S2SV> gint control_detected = FALSE ; //<S2SV> u3v_conv_info_t * u3v_conv_info = NULL ; //<S2SV> gencp_transaction_t * gencp_trans = NULL ; //<S2SV> usb_conv_info = ( usb_conv_info_t * ) data ; //<S2SV> u3v_conv_info = ( u3v_conv_info_t * ) usb_conv_info -> class_data ; //<S2SV> if ( ! u3v_conv_info ) { //<S2SV> u3v_conv_info = wmem_new0 ( wmem_file_scope ( ) , u3v_conv_info_t ) ; //<S2SV> usb_conv_info -> class_data = u3v_conv_info ; //<S2SV> } //<S2SV> prefix = tvb_get_letohl ( tvb , 0 ) ; //<S2SV> if ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) { //<S2SV> control_detected = TRUE ; //<S2SV> } //<S2SV> if ( ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix ) ) ) //<S2SV> || ( usb_conv_info -> endpoint == u3v_conv_info -> ep_stream ) ) { //<S2SV> stream_detected = TRUE ; //<S2SV> } //<S2SV> if ( control_detected || stream_detected ) { //<S2SV> if ( usb_conv_info -> interfaceClass == IF_CLASS_UNKNOWN && //<S2SV> usb_conv_info -> interfaceSubclass == IF_SUBCLASS_UNKNOWN ) { //<S2SV> usb_conv_info -> interfaceClass = IF_CLASS_MISCELLANEOUS ; //<S2SV> usb_conv_info -> interfaceSubclass = IF_SUBCLASS_MISC_U3V ; //<S2SV> } //<S2SV> } //<S2SV> if ( control_detected ) { //<S2SV> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "U3V" ) ; //<S2SV> col_clear ( pinfo -> cinfo , COL_INFO ) ; //<S2SV> ti = proto_tree_add_item ( tree , proto_u3v , tvb , offset , - 1 , ENC_NA ) ; //<S2SV> u3v_tree = proto_item_add_subtree ( ti , ett_u3v ) ; //<S2SV> prefix = tvb_get_letohl ( tvb , offset ) ; //<S2SV> command_id = tvb_get_letohs ( tvb , offset + 6 ) ; //<S2SV> if ( ( prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX ) && ( ( command_id % 2 ) == 0 ) ) { //<S2SV> command_string = val_to_str ( command_id , command_names , "Unknown<S2SV_blank>Command<S2SV_blank>(0x%x)" ) ; //<S2SV> item = proto_tree_add_item ( u3v_tree , hf_u3v_ccd_cmd , tvb , offset , 8 , ENC_NA ) ; //<S2SV> proto_item_append_text ( item , ":<S2SV_blank>%s" , command_string ) ; //<S2SV> ccd_tree = proto_item_add_subtree ( item , ett_u3v_cmd ) ; //<S2SV> proto_tree_add_item ( ccd_tree , hf_u3v_gencp_prefix , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> item = proto_tree_add_item ( ccd_tree , hf_u3v_flag , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; //<S2SV> ccd_tree_flag = proto_item_add_subtree ( item , ett_u3v_flags ) ; //<S2SV> proto_tree_add_item ( ccd_tree_flag , hf_u3v_acknowledge_required_flag , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 2 ; //<S2SV> col_append_fstr ( pinfo -> cinfo , COL_INFO , "><S2SV_blank>%s<S2SV_blank>" , command_string ) ; //<S2SV> } else if ( prefix == U3V_CONTROL_PREFIX && ( ( command_id % 2 ) == 1 ) ) { //<S2SV> command_string = val_to_str ( command_id , command_names , "Unknown<S2SV_blank>Acknowledge<S2SV_blank>(0x%x)" ) ; //<S2SV> item = proto_tree_add_item ( u3v_tree , hf_u3v_ccd_ack , tvb , offset , 8 , ENC_NA ) ; //<S2SV> proto_item_append_text ( item , ":<S2SV_blank>%s" , command_string ) ; //<S2SV> ccd_tree = proto_item_add_subtree ( item , ett_u3v_ack ) ; //<S2SV> proto_tree_add_item ( ccd_tree , hf_u3v_gencp_prefix , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( ccd_tree , hf_u3v_status , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; //<S2SV> status = tvb_get_letohs ( tvb , offset ) ; //<S2SV> offset += 2 ; //<S2SV> col_append_fstr ( pinfo -> cinfo , COL_INFO , "<<S2SV_blank>%s<S2SV_blank>%s" , //<S2SV> command_string , //<S2SV> val_to_str ( status , status_names_short , "Unknown<S2SV_blank>status<S2SV_blank>(0x%04X)" ) ) ; //<S2SV> } else { //<S2SV> return 0 ; //<S2SV> } //<S2SV> proto_tree_add_item ( ccd_tree , hf_u3v_command_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 2 ; //<S2SV> proto_tree_add_item ( ccd_tree , hf_u3v_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; //<S2SV> data_length = tvb_get_letohs ( tvb , offset ) ; //<S2SV> offset += 2 ; //<S2SV> proto_tree_add_item ( ccd_tree , hf_u3v_request_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; //<S2SV> req_id = tvb_get_letohs ( tvb , offset ) ; //<S2SV> offset += 2 ; //<S2SV> u3v_telegram_tree = proto_item_add_subtree ( u3v_tree , ett_u3v ) ; //<S2SV> if ( ! PINFO_FD_VISITED ( pinfo ) ) { //<S2SV> if ( ( command_id % 2 ) == 0 ) { //<S2SV> gencp_trans = wmem_new ( wmem_file_scope ( ) , gencp_transaction_t ) ; //<S2SV> gencp_trans -> cmd_frame = pinfo -> fd -> num ; //<S2SV> gencp_trans -> ack_frame = 0 ; //<S2SV> gencp_trans -> cmd_time = pinfo -> fd -> abs_ts ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id , gencp_trans ) ; //<S2SV> u3v_conv_info -> trans_info = gencp_trans ; //<S2SV> } else { //<S2SV> gencp_trans = u3v_conv_info -> trans_info ; //<S2SV> if ( gencp_trans ) { //<S2SV> gencp_trans -> ack_frame = pinfo -> fd -> num ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id , gencp_trans ) ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> gencp_trans = ( gencp_transaction_t * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id ) ; //<S2SV> } //<S2SV> if ( ! gencp_trans ) { //<S2SV> gencp_trans = wmem_new ( wmem_packet_scope ( ) , gencp_transaction_t ) ; //<S2SV> gencp_trans -> cmd_frame = 0 ; //<S2SV> gencp_trans -> ack_frame = 0 ; //<S2SV> gencp_trans -> cmd_time = pinfo -> fd -> abs_ts ; //<S2SV> } //<S2SV> switch ( command_id ) { //<S2SV> case U3V_READMEM_CMD : //<S2SV> dissect_u3v_read_mem_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; //<S2SV> break ; //<S2SV> case U3V_WRITEMEM_CMD : //<S2SV> dissect_u3v_write_mem_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; //<S2SV> break ; //<S2SV> case U3V_EVENT_CMD : //<S2SV> dissect_u3v_event_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length ) ; //<S2SV> break ; //<S2SV> case U3V_READMEM_ACK : //<S2SV> if ( U3V_STATUS_GENCP_SUCCESS == status ) { //<S2SV> dissect_u3v_read_mem_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case U3V_WRITEMEM_ACK : //<S2SV> dissect_u3v_write_mem_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; //<S2SV> break ; //<S2SV> case U3V_PENDING_ACK : //<S2SV> dissect_u3v_pending_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> proto_tree_add_item ( u3v_telegram_tree , hf_u3v_payloaddata , tvb , offset , data_length , ENC_NA ) ; //<S2SV> break ; //<S2SV> } //<S2SV> return data_length + 12 ; //<S2SV> } else if ( stream_detected ) { //<S2SV> u3v_conv_info = ( u3v_conv_info_t * ) usb_conv_info -> class_data ; //<S2SV> u3v_conv_info -> ep_stream = usb_conv_info -> endpoint ; //<S2SV> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "U3V" ) ; //<S2SV> col_clear ( pinfo -> cinfo , COL_INFO ) ; //<S2SV> ti = proto_tree_add_item ( tree , proto_u3v , tvb , offset , - 1 , ENC_NA ) ; //<S2SV> u3v_tree = proto_item_add_subtree ( ti , ett_u3v ) ; //<S2SV> if ( tvb_captured_length ( tvb ) >= 4 ) { //<S2SV> prefix = tvb_get_letohl ( tvb , offset ) ; //<S2SV> switch ( prefix ) { //<S2SV> case U3V_STREAM_LEADER_PREFIX : //<S2SV> dissect_u3v_stream_leader ( u3v_tree , tvb , pinfo , usb_conv_info ) ; //<S2SV> break ; //<S2SV> case U3V_STREAM_TRAILER_PREFIX : //<S2SV> dissect_u3v_stream_trailer ( u3v_tree , tvb , pinfo , usb_conv_info ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> dissect_u3v_stream_payload ( u3v_tree , tvb , pinfo , usb_conv_info ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> return tvb_captured_length ( tvb ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 