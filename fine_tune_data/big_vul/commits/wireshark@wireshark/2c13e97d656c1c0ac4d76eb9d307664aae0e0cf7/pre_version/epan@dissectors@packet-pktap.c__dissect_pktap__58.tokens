static void //<S2SV> dissect_pktap ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) //<S2SV> { //<S2SV> proto_tree * pktap_tree = NULL ; //<S2SV> proto_item * ti = NULL ; //<S2SV> tvbuff_t * next_tvb ; //<S2SV> int offset = 0 ; //<S2SV> guint32 pkt_len , rectype , dlt ; //<S2SV> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "PKTAP" ) ; //<S2SV> col_clear ( pinfo -> cinfo , COL_INFO ) ; //<S2SV> pkt_len = tvb_get_letohl ( tvb , offset ) ; //<S2SV> col_add_fstr ( pinfo -> cinfo , COL_INFO , "PKTAP,<S2SV_blank>%u<S2SV_blank>byte<S2SV_blank>header" , pkt_len ) ; //<S2SV> ti = proto_tree_add_item ( tree , proto_pktap , tvb , offset , pkt_len , ENC_NA ) ; //<S2SV> pktap_tree = proto_item_add_subtree ( ti , ett_pktap ) ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_hdrlen , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> if ( pkt_len < MIN_PKTAP_HDR_LEN ) { //<S2SV> proto_tree_add_expert ( tree , pinfo , & ei_pktap_hdrlen_too_short , //<S2SV> tvb , offset , 4 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_rectype , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> rectype = tvb_get_letohl ( tvb , offset ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_dlt , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> dlt = tvb_get_letohl ( tvb , offset ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_ifname , tvb , offset , 24 , //<S2SV> ENC_ASCII | ENC_NA ) ; //<S2SV> offset += 24 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_flags , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_pfamily , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_llhdrlen , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_lltrlrlen , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_pid , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_cmdname , tvb , offset , 20 , //<S2SV> ENC_UTF_8 | ENC_NA ) ; //<S2SV> offset += 20 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_svc_class , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_iftype , tvb , offset , 2 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 2 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_ifunit , tvb , offset , 2 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 2 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_epid , tvb , offset , 4 , //<S2SV> ENC_LITTLE_ENDIAN ) ; //<S2SV> offset += 4 ; //<S2SV> proto_tree_add_item ( pktap_tree , hf_pktap_ecmdname , tvb , offset , 20 , //<S2SV> ENC_UTF_8 | ENC_NA ) ; //<S2SV> if ( rectype == PKT_REC_PACKET ) { //<S2SV> next_tvb = tvb_new_subset_remaining ( tvb , pkt_len ) ; //<S2SV> dissector_try_uint ( wtap_encap_dissector_table , //<S2SV> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; //<S2SV> } //<S2SV> } //<S2SV> 