static void //<S2SV> dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) //<S2SV> { //<S2SV> proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; //<S2SV> proto_tree * agg_tree = NULL ; //<S2SV> proto_item * ti = NULL ; //<S2SV> tvbuff_t * next_tvb ; //<S2SV> int offset = 0 ; //<S2SV> guint version , flags ; //<S2SV> gint tot_len , data_len ; //<S2SV> guint data_type ; //<S2SV> guint32 dlt ; //<S2SV> guint32 n_ext_flags = 0 ; //<S2SV> guint32 ampdu_id = 0 ; //<S2SV> fragment_head * fd_head = NULL ; //<S2SV> fragment_item * ft_fdh = NULL ; //<S2SV> gint mpdu_count = 0 ; //<S2SV> gchar * mpdu_str ; //<S2SV> gboolean first_mpdu = TRUE ; //<S2SV> guint last_frame = 0 ; //<S2SV> gint len_remain , ampdu_len = 0 ; //<S2SV> struct ieee_802_11_phdr phdr ; //<S2SV> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "PPI" ) ; //<S2SV> col_clear ( pinfo -> cinfo , COL_INFO ) ; //<S2SV> version = tvb_get_guint8 ( tvb , offset ) ; //<S2SV> flags = tvb_get_guint8 ( tvb , offset + 1 ) ; //<S2SV> tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; //<S2SV> dlt = tvb_get_letohl ( tvb , offset + 4 ) ; //<S2SV> col_add_fstr ( pinfo -> cinfo , COL_INFO , "PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes" , //<S2SV> version , tot_len ) ; //<S2SV> if ( tree ) { //<S2SV> ti = proto_tree_add_protocol_format ( tree , proto_ppi , //<S2SV> tvb , 0 , tot_len , "PPI<S2SV_blank>version<S2SV_blank>%u,<S2SV_blank>%u<S2SV_blank>bytes" , version , tot_len ) ; //<S2SV> ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_head_version , //<S2SV> tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; //<S2SV> ti = proto_tree_add_item ( ppi_tree , hf_ppi_head_flags , //<S2SV> tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; //<S2SV> ppi_flags_tree = proto_item_add_subtree ( ti , ett_ppi_flags ) ; //<S2SV> proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_alignment , //<S2SV> tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; //<S2SV> proto_tree_add_item ( ppi_flags_tree , hf_ppi_head_flag_reserved , //<S2SV> tvb , offset + 1 , 1 , ENC_LITTLE_ENDIAN ) ; //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_head_len , //<S2SV> tvb , offset + 2 , 2 , ENC_LITTLE_ENDIAN ) ; //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_head_dlt , //<S2SV> tvb , offset + 4 , 4 , ENC_LITTLE_ENDIAN ) ; //<S2SV> } //<S2SV> tot_len -= PPI_V0_HEADER_LEN ; //<S2SV> offset += 8 ; //<S2SV> memset ( & phdr , 0 , sizeof ( phdr ) ) ; //<S2SV> phdr . fcs_len = - 1 ; //<S2SV> phdr . decrypted = FALSE ; //<S2SV> phdr . datapad = FALSE ; //<S2SV> phdr . phy = PHDR_802_11_PHY_UNKNOWN ; //<S2SV> phdr . presence_flags = 0 ; //<S2SV> while ( tot_len > 0 ) { //<S2SV> data_type = tvb_get_letohs ( tvb , offset ) ; //<S2SV> data_len = tvb_get_letohs ( tvb , offset + 2 ) + 4 ; //<S2SV> tot_len -= data_len ; //<S2SV> switch ( data_type ) { //<S2SV> case PPI_80211_COMMON : //<S2SV> dissect_80211_common ( tvb , pinfo , ppi_tree , offset , data_len , & phdr ) ; //<S2SV> break ; //<S2SV> case PPI_80211N_MAC : //<S2SV> dissect_80211n_mac ( tvb , pinfo , ppi_tree , offset , data_len , //<S2SV> TRUE , & n_ext_flags , & ampdu_id , & phdr ) ; //<S2SV> break ; //<S2SV> case PPI_80211N_MAC_PHY : //<S2SV> dissect_80211n_mac_phy ( tvb , pinfo , ppi_tree , offset , //<S2SV> data_len , & n_ext_flags , & ampdu_id , & phdr ) ; //<S2SV> break ; //<S2SV> case PPI_SPECTRUM_MAP : //<S2SV> ADD_BASIC_TAG ( hf_spectrum_map ) ; //<S2SV> break ; //<S2SV> case PPI_PROCESS_INFO : //<S2SV> ADD_BASIC_TAG ( hf_process_info ) ; //<S2SV> break ; //<S2SV> case PPI_CAPTURE_INFO : //<S2SV> ADD_BASIC_TAG ( hf_capture_info ) ; //<S2SV> break ; //<S2SV> case PPI_AGGREGATION_EXTENSION : //<S2SV> dissect_aggregation_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; //<S2SV> break ; //<S2SV> case PPI_8023_EXTENSION : //<S2SV> dissect_8023_extension ( tvb , pinfo , ppi_tree , offset , data_len ) ; //<S2SV> break ; //<S2SV> case PPI_GPS_INFO : //<S2SV> if ( ppi_gps_handle == NULL ) //<S2SV> { //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_gps , tvb , offset , data_len , ENC_NA ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; //<S2SV> call_dissector ( ppi_gps_handle , next_tvb , pinfo , ppi_tree ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PPI_VECTOR_INFO : //<S2SV> if ( ppi_vector_handle == NULL ) //<S2SV> { //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_vector , tvb , offset , data_len , ENC_NA ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; //<S2SV> call_dissector ( ppi_vector_handle , next_tvb , pinfo , ppi_tree ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PPI_SENSOR_INFO : //<S2SV> if ( ppi_sensor_handle == NULL ) //<S2SV> { //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_harris , tvb , offset , data_len , ENC_NA ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; //<S2SV> call_dissector ( ppi_sensor_handle , next_tvb , pinfo , ppi_tree ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PPI_ANTENNA_INFO : //<S2SV> if ( ppi_antenna_handle == NULL ) //<S2SV> { //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_antenna , tvb , offset , data_len , ENC_NA ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; //<S2SV> call_dissector ( ppi_antenna_handle , next_tvb , pinfo , ppi_tree ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case FNET_PRIVATE : //<S2SV> if ( ppi_fnet_handle == NULL ) //<S2SV> { //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_fnet , tvb , offset , data_len , ENC_NA ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> next_tvb = tvb_new_subset ( tvb , offset + 4 , data_len - 4 , - 1 ) ; //<S2SV> call_dissector ( ppi_fnet_handle , next_tvb , pinfo , ppi_tree ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> proto_tree_add_item ( ppi_tree , hf_ppi_reserved , tvb , offset , data_len , ENC_NA ) ; //<S2SV> } //<S2SV> offset += data_len ; //<S2SV> if ( IS_PPI_FLAG_ALIGN ( flags ) ) { //<S2SV> offset += PADDING4 ( offset ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE ( n_ext_flags ) ) { //<S2SV> len_remain = tvb_captured_length_remaining ( tvb , offset ) ; //<S2SV> # if 0 //<S2SV> if ( DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { //<S2SV> pad_len = PADDING4 ( len_remain ) ; //<S2SV> } //<S2SV> # endif //<S2SV> pinfo -> fragmented = TRUE ; //<S2SV> fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; //<S2SV> while ( fd_head ) { //<S2SV> ampdu_len += fd_head -> len + PADDING4 ( fd_head -> len ) + 4 ; //<S2SV> fd_head = fd_head -> next ; //<S2SV> } //<S2SV> if ( ampdu_len > AGGREGATE_MAX ) { //<S2SV> if ( tree ) { //<S2SV> proto_tree_add_expert_format ( ppi_tree , pinfo , & ei_ppi_invalid_length , tvb , offset , - 1 , "Aggregate<S2SV_blank>length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>(%u)" , AGGREGATE_MAX ) ; //<S2SV> THROW ( ReportedBoundsError ) ; //<S2SV> } else { //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> fragment_add_seq_next ( & ampdu_reassembly_table , //<S2SV> tvb , offset , pinfo , ampdu_id , NULL , len_remain , TRUE ) ; //<S2SV> pinfo -> fragmented = TRUE ; //<S2SV> fd_head = fragment_get ( & ampdu_reassembly_table , pinfo , ampdu_id , NULL ) ; //<S2SV> if ( fd_head && tree ) { //<S2SV> ft_fdh = fd_head ; //<S2SV> seg_tree = proto_tree_add_subtree_format ( ppi_tree , tvb , offset , - 1 , //<S2SV> ett_ampdu_segments , & ti , "A-MPDU<S2SV_blank>(%u<S2SV_blank>bytes<S2SV_blank>w/hdrs):" , ampdu_len ) ; //<S2SV> PROTO_ITEM_SET_GENERATED ( ti ) ; //<S2SV> while ( ft_fdh ) { //<S2SV> if ( ft_fdh -> tvb_data && ft_fdh -> len ) { //<S2SV> last_frame = ft_fdh -> frame ; //<S2SV> if ( ! first_mpdu ) //<S2SV> proto_item_append_text ( ti , "," ) ; //<S2SV> first_mpdu = FALSE ; //<S2SV> proto_item_append_text ( ti , "<S2SV_blank>#%u(%u)" , //<S2SV> ft_fdh -> frame , ft_fdh -> len ) ; //<S2SV> proto_tree_add_uint_format ( seg_tree , hf_ampdu_segment , //<S2SV> tvb , 0 , 0 , last_frame , //<S2SV> "Frame:<S2SV_blank>%u<S2SV_blank>(%u<S2SV_blank>byte%s)" , //<S2SV> last_frame , //<S2SV> ft_fdh -> len , //<S2SV> plurality ( ft_fdh -> len , "" , "s" ) ) ; //<S2SV> } //<S2SV> ft_fdh = ft_fdh -> next ; //<S2SV> } //<S2SV> if ( last_frame && last_frame != pinfo -> fd -> num ) //<S2SV> proto_tree_add_uint ( seg_tree , hf_ampdu_reassembled_in , //<S2SV> tvb , 0 , 0 , last_frame ) ; //<S2SV> } //<S2SV> if ( fd_head && ! DOT11N_MORE_AGGREGATES ( n_ext_flags ) ) { //<S2SV> if ( tree ) { //<S2SV> ti = proto_tree_add_protocol_format ( tree , //<S2SV> proto_get_id_by_filter_name ( "wlan_aggregate" ) , //<S2SV> tvb , 0 , tot_len , "IEEE<S2SV_blank>802.11<S2SV_blank>Aggregate<S2SV_blank>MPDU" ) ; //<S2SV> agg_tree = proto_item_add_subtree ( ti , ett_ampdu ) ; //<S2SV> } //<S2SV> while ( fd_head ) { //<S2SV> if ( fd_head -> tvb_data && fd_head -> len ) { //<S2SV> mpdu_count ++ ; //<S2SV> mpdu_str = wmem_strdup_printf ( wmem_packet_scope ( ) , "MPDU<S2SV_blank>#%d" , mpdu_count ) ; //<S2SV> next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ; //<S2SV> add_new_data_source ( pinfo , next_tvb , mpdu_str ) ; //<S2SV> ampdu_tree = proto_tree_add_subtree ( agg_tree , next_tvb , 0 , - 1 , ett_ampdu_segment , NULL , mpdu_str ) ; //<S2SV> call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , ampdu_tree , & phdr ) ; //<S2SV> } //<S2SV> fd_head = fd_head -> next ; //<S2SV> } //<S2SV> proto_tree_add_uint ( seg_tree , hf_ampdu_count , tvb , 0 , 0 , mpdu_count ) ; //<S2SV> pinfo -> fragmented = FALSE ; //<S2SV> } else { //<S2SV> next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; //<S2SV> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , "IEEE<S2SV_blank>802.11n" ) ; //<S2SV> col_set_str ( pinfo -> cinfo , COL_INFO , "Unreassembled<S2SV_blank>A-MPDU<S2SV_blank>data" ) ; //<S2SV> call_dissector ( data_handle , next_tvb , pinfo , tree ) ; //<S2SV> } //<S2SV> return ; //<S2SV> } //<S2SV> next_tvb = tvb_new_subset_remaining ( tvb , offset ) ; //<S2SV> if ( dlt == 105 ) { //<S2SV> call_dissector_with_data ( ieee80211_radio_handle , next_tvb , pinfo , tree , & phdr ) ; //<S2SV> } else { //<S2SV> dissector_try_uint ( wtap_encap_dissector_table , //<S2SV> wtap_pcap_encap_to_wtap_encap ( dlt ) , next_tvb , pinfo , tree ) ; //<S2SV> } //<S2SV> } //<S2SV> 