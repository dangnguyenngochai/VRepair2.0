static INT AirPDcapScanForKeys ( //<S2SV> PAIRPDCAP_CONTEXT ctx , //<S2SV> const guint8 * data , //<S2SV> const guint mac_header_len , //<S2SV> const guint tot_len , //<S2SV> AIRPDCAP_SEC_ASSOCIATION_ID id //<S2SV> ) //<S2SV> { //<S2SV> const UCHAR * addr ; //<S2SV> guint bodyLength ; //<S2SV> PAIRPDCAP_SEC_ASSOCIATION sta_sa ; //<S2SV> PAIRPDCAP_SEC_ASSOCIATION sa ; //<S2SV> guint offset = 0 ; //<S2SV> const guint8 dot1x_header [ ] = { //<S2SV> 0xAA , //<S2SV> 0xAA , //<S2SV> 0x03 , //<S2SV> 0x00 , 0x00 , 0x00 , //<S2SV> 0x88 , 0x8E //<S2SV> } ; //<S2SV> const guint8 bt_dot1x_header [ ] = { //<S2SV> 0xAA , //<S2SV> 0xAA , //<S2SV> 0x03 , //<S2SV> 0x00 , 0x19 , 0x58 , //<S2SV> 0x00 , 0x03 //<S2SV> } ; //<S2SV> const guint8 tdls_header [ ] = { //<S2SV> 0xAA , //<S2SV> 0xAA , //<S2SV> 0x03 , //<S2SV> 0x00 , 0x00 , 0x00 , //<S2SV> 0x89 , 0x0D , //<S2SV> 0x02 , //<S2SV> 0X0C //<S2SV> } ; //<S2SV> const EAPOL_RSN_KEY * pEAPKey ; //<S2SV> # ifdef _DEBUG //<S2SV> # define MSGBUF_LEN 255 //<S2SV> CHAR msgbuf [ MSGBUF_LEN ] ; //<S2SV> # endif //<S2SV> AIRPDCAP_DEBUG_TRACE_START ( "AirPDcapScanForKeys" ) ; //<S2SV> offset = mac_header_len ; //<S2SV> if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Authentication:<S2SV_blank>EAPOL<S2SV_blank>packet" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> offset += 8 ; //<S2SV> if ( data [ offset + 1 ] != 3 ) { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Not<S2SV_blank>EAPOL-Key" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> bodyLength = pntoh16 ( data + offset + 2 ) ; //<S2SV> if ( ( ( tot_len - offset - 4 ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) ) ) { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "EAPOL<S2SV_blank>body<S2SV_blank>too<S2SV_blank>short" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> offset += 4 ; //<S2SV> pEAPKey = ( const EAPOL_RSN_KEY * ) ( data + offset ) ; //<S2SV> if ( //<S2SV> pEAPKey -> type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR && //<S2SV> pEAPKey -> type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR ) //<S2SV> { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Not<S2SV_blank>valid<S2SV_blank>key<S2SV_blank>descriptor<S2SV_blank>type" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> offset += 1 ; //<S2SV> sa = AirPDcapGetSaPtr ( ctx , & id ) ; //<S2SV> if ( sa == NULL ) { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "No<S2SV_blank>SA<S2SV_blank>for<S2SV_blank>BSSID<S2SV_blank>found" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_REQ_DATA ; //<S2SV> } //<S2SV> if ( AirPDcapRsna4WHandshake ( ctx , data , sa , offset , tot_len ) == AIRPDCAP_RET_SUCCESS_HANDSHAKE ) //<S2SV> return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; //<S2SV> if ( mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len ) { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Message<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> if ( AIRPDCAP_EAP_KEY ( data [ offset + 1 ] ) != 0 || //<S2SV> AIRPDCAP_EAP_ACK ( data [ offset + 1 ] ) != 1 || //<S2SV> AIRPDCAP_EAP_MIC ( data [ offset ] ) != 1 || //<S2SV> AIRPDCAP_EAP_SEC ( data [ offset ] ) != 1 ) { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Key<S2SV_blank>bitfields<S2SV_blank>not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>Group<S2SV_blank>Key" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> memcpy ( id . sta , broadcast_mac , AIRPDCAP_MAC_LEN ) ; //<S2SV> sa = AirPDcapGetSaPtr ( ctx , & id ) ; //<S2SV> if ( sa == NULL ) { //<S2SV> return AIRPDCAP_RET_REQ_DATA ; //<S2SV> } //<S2SV> if ( ( addr = AirPDcapGetStaAddress ( ( const AIRPDCAP_MAC_FRAME_ADDR4 * ) ( data ) ) ) != NULL ) { //<S2SV> memcpy ( id . sta , addr , AIRPDCAP_MAC_LEN ) ; //<S2SV> # ifdef _DEBUG //<S2SV> g_snprintf ( msgbuf , MSGBUF_LEN , "ST_MAC:<S2SV_blank>%2X.%2X.%2X.%2X.%2X.%2X\\t" , id . sta [ 0 ] , id . sta [ 1 ] , id . sta [ 2 ] , id . sta [ 3 ] , id . sta [ 4 ] , id . sta [ 5 ] ) ; //<S2SV> # endif //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , msgbuf , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> } else { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "SA<S2SV_blank>not<S2SV_blank>found" , AIRPDCAP_DEBUG_LEVEL_5 ) ; //<S2SV> return AIRPDCAP_RET_REQ_DATA ; //<S2SV> } //<S2SV> sta_sa = AirPDcapGetSaPtr ( ctx , & id ) ; //<S2SV> if ( sta_sa == NULL ) { //<S2SV> return AIRPDCAP_RET_REQ_DATA ; //<S2SV> } //<S2SV> return ( AirPDcapDecryptWPABroadcastKey ( pEAPKey , sta_sa -> wpa . ptk + 16 , sa , tot_len - offset + 1 ) ) ; //<S2SV> } else if ( memcmp ( data + offset , tdls_header , 10 ) == 0 ) { //<S2SV> const guint8 * initiator , * responder ; //<S2SV> guint8 action ; //<S2SV> guint status , offset_rsne = 0 , offset_fte = 0 , offset_link = 0 , offset_timeout = 0 ; //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Authentication:<S2SV_blank>TDLS<S2SV_blank>Action<S2SV_blank>Frame" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> offset += 10 ; //<S2SV> action = data [ offset ] ; //<S2SV> if ( action != 1 && action != 2 ) { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Not<S2SV_blank>Response<S2SV_blank>nor<S2SV_blank>confirm" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> offset ++ ; //<S2SV> status = pntoh16 ( data + offset ) ; //<S2SV> if ( status != 0 ) { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "TDLS<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>successfull" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> offset += 5 ; //<S2SV> while ( offset < ( tot_len - 2 ) ) { //<S2SV> if ( data [ offset ] == 48 ) { //<S2SV> offset_rsne = offset ; //<S2SV> } else if ( data [ offset ] == 55 ) { //<S2SV> offset_fte = offset ; //<S2SV> } else if ( data [ offset ] == 56 ) { //<S2SV> offset_timeout = offset ; //<S2SV> } else if ( data [ offset ] == 101 ) { //<S2SV> offset_link = offset ; //<S2SV> } //<S2SV> if ( tot_len < offset + data [ offset + 1 ] + 2 ) { //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> offset += data [ offset + 1 ] + 2 ; //<S2SV> } //<S2SV> if ( offset_rsne == 0 || offset_fte == 0 || //<S2SV> offset_timeout == 0 || offset_link == 0 ) //<S2SV> { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Cannot<S2SV_blank>Find<S2SV_blank>all<S2SV_blank>necessary<S2SV_blank>IEs" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Found<S2SV_blank>RSNE/Fast<S2SV_blank>BSS/Timeout<S2SV_blank>Interval/Link<S2SV_blank>IEs" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> initiator = & data [ offset_link + 8 ] ; //<S2SV> responder = & data [ offset_link + 14 ] ; //<S2SV> if ( memcmp ( initiator , responder , AIRPDCAP_MAC_LEN ) < 0 ) { //<S2SV> memcpy ( id . sta , initiator , AIRPDCAP_MAC_LEN ) ; //<S2SV> memcpy ( id . bssid , responder , AIRPDCAP_MAC_LEN ) ; //<S2SV> } else { //<S2SV> memcpy ( id . sta , responder , AIRPDCAP_MAC_LEN ) ; //<S2SV> memcpy ( id . bssid , initiator , AIRPDCAP_MAC_LEN ) ; //<S2SV> } //<S2SV> sa = AirPDcapGetSaPtr ( ctx , & id ) ; //<S2SV> if ( sa == NULL ) { //<S2SV> return AIRPDCAP_RET_REQ_DATA ; //<S2SV> } //<S2SV> if ( sa -> validKey ) { //<S2SV> if ( memcmp ( sa -> wpa . nonce , data + offset_fte + 52 , AIRPDCAP_WPA_NONCE_LEN ) == 0 ) { //<S2SV> return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; //<S2SV> } else { //<S2SV> AIRPDCAP_SEC_ASSOCIATION * tmp_sa = g_new ( AIRPDCAP_SEC_ASSOCIATION , 1 ) ; //<S2SV> memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; //<S2SV> sa -> next = tmp_sa ; //<S2SV> sa -> validKey = FALSE ; //<S2SV> } //<S2SV> } //<S2SV> if ( AirPDcapTDLSDeriveKey ( sa , data , offset_rsne , offset_fte , offset_timeout , offset_link , action ) //<S2SV> == AIRPDCAP_RET_SUCCESS ) { //<S2SV> AIRPDCAP_DEBUG_TRACE_END ( "AirPDcapScanForKeys" ) ; //<S2SV> return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; //<S2SV> } //<S2SV> } else { //<S2SV> AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapScanForKeys" , "Skipping:<S2SV_blank>not<S2SV_blank>an<S2SV_blank>EAPOL<S2SV_blank>packet" , AIRPDCAP_DEBUG_LEVEL_3 ) ; //<S2SV> } //<S2SV> AIRPDCAP_DEBUG_TRACE_END ( "AirPDcapScanForKeys" ) ; //<S2SV> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; //<S2SV> } //<S2SV> 