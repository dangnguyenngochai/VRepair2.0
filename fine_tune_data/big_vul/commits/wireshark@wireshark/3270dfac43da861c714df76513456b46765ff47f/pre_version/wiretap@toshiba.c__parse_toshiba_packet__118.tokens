static gboolean //<S2SV> parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , //<S2SV> int * err , gchar * * err_info ) //<S2SV> { //<S2SV> union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; //<S2SV> char line [ TOSHIBA_LINE_LENGTH ] ; //<S2SV> int num_items_scanned ; //<S2SV> guint pkt_len ; //<S2SV> int pktnum , hr , min , sec , csec ; //<S2SV> char channel [ 10 ] , direction [ 10 ] ; //<S2SV> int i , hex_lines ; //<S2SV> guint8 * pd ; //<S2SV> if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { //<S2SV> * err = file_error ( fh , err_info ) ; //<S2SV> if ( * err == 0 ) { //<S2SV> * err = WTAP_ERR_SHORT_READ ; //<S2SV> } //<S2SV> return FALSE ; //<S2SV> } //<S2SV> num_items_scanned = sscanf ( line , "%9d]<S2SV_blank>%2d:%2d:%2d.%9d<S2SV_blank>%9s<S2SV_blank>%9s" , //<S2SV> & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; //<S2SV> if ( num_items_scanned != 7 ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup ( "toshiba:<S2SV_blank>record<S2SV_blank>header<S2SV_blank>isn\'t<S2SV_blank>valid" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> do { //<S2SV> if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { //<S2SV> * err = file_error ( fh , err_info ) ; //<S2SV> if ( * err == 0 ) { //<S2SV> * err = WTAP_ERR_SHORT_READ ; //<S2SV> } //<S2SV> return FALSE ; //<S2SV> } //<S2SV> line [ 16 ] = '\\0' ; //<S2SV> } while ( strcmp ( line , "OFFSET<S2SV_blank>0001-0203" ) != 0 ) ; //<S2SV> num_items_scanned = sscanf ( line + 64 , "LEN=%9u" , & pkt_len ) ; //<S2SV> if ( num_items_scanned != 1 ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup ( "toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup_printf ( "toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , //<S2SV> pkt_len , WTAP_MAX_PACKET_SIZE ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> phdr -> rec_type = REC_TYPE_PACKET ; //<S2SV> phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; //<S2SV> phdr -> ts . secs = hr * 3600 + min * 60 + sec ; //<S2SV> phdr -> ts . nsecs = csec * 10000000 ; //<S2SV> phdr -> caplen = pkt_len ; //<S2SV> phdr -> len = pkt_len ; //<S2SV> switch ( channel [ 0 ] ) { //<S2SV> case 'B' : //<S2SV> phdr -> pkt_encap = WTAP_ENCAP_ISDN ; //<S2SV> pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; //<S2SV> pseudo_header -> isdn . channel = ( guint8 ) //<S2SV> strtol ( & channel [ 1 ] , NULL , 10 ) ; //<S2SV> break ; //<S2SV> case 'D' : //<S2SV> phdr -> pkt_encap = WTAP_ENCAP_ISDN ; //<S2SV> pseudo_header -> isdn . uton = ( direction [ 0 ] == 'T' ) ; //<S2SV> pseudo_header -> isdn . channel = 0 ; //<S2SV> break ; //<S2SV> default : //<S2SV> phdr -> pkt_encap = WTAP_ENCAP_ETHERNET ; //<S2SV> pseudo_header -> eth . fcs_len = - 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> ws_buffer_assure_space ( buf , pkt_len ) ; //<S2SV> pd = ws_buffer_start_ptr ( buf ) ; //<S2SV> hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; //<S2SV> for ( i = 0 ; i < hex_lines ; i ++ ) { //<S2SV> if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { //<S2SV> * err = file_error ( fh , err_info ) ; //<S2SV> if ( * err == 0 ) { //<S2SV> * err = WTAP_ERR_SHORT_READ ; //<S2SV> } //<S2SV> return FALSE ; //<S2SV> } //<S2SV> if ( ! parse_single_hex_dump_line ( line , pd , i * 16 ) ) { //<S2SV> * err = WTAP_ERR_BAD_FILE ; //<S2SV> * err_info = g_strdup ( "toshiba:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>not<S2SV_blank>valid" ) ; //<S2SV> return FALSE ; //<S2SV> } //<S2SV> } //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 