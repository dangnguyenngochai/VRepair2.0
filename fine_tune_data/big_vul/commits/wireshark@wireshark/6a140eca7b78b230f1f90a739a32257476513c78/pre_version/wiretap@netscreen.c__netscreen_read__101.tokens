static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , //<S2SV> gint64 * data_offset ) //<S2SV> { //<S2SV> gint64 offset ; //<S2SV> int pkt_len ; //<S2SV> char line [ NETSCREEN_LINE_LENGTH ] ; //<S2SV> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; //<S2SV> gboolean cap_dir ; //<S2SV> char cap_dst [ 13 ] ; //<S2SV> offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; //<S2SV> if ( offset < 0 ) //<S2SV> return FALSE ; //<S2SV> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , //<S2SV> cap_dst , err , err_info ) ; //<S2SV> if ( pkt_len == - 1 ) //<S2SV> return FALSE ; //<S2SV> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , //<S2SV> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) //<S2SV> return FALSE ; //<S2SV> if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) //<S2SV> wth -> file_encap = wth -> phdr . pkt_encap ; //<S2SV> else { //<S2SV> if ( wth -> file_encap != wth -> phdr . pkt_encap ) //<S2SV> wth -> file_encap = WTAP_ENCAP_PER_PACKET ; //<S2SV> } //<S2SV> * data_offset = offset ; //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 