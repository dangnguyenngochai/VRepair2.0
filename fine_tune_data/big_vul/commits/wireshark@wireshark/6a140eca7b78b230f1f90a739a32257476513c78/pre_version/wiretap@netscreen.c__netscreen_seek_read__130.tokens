static gboolean //<S2SV> netscreen_seek_read ( wtap * wth , gint64 seek_off , //<S2SV> struct wtap_pkthdr * phdr , Buffer * buf , //<S2SV> int * err , gchar * * err_info ) //<S2SV> { //<S2SV> int pkt_len ; //<S2SV> char line [ NETSCREEN_LINE_LENGTH ] ; //<S2SV> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; //<S2SV> gboolean cap_dir ; //<S2SV> char cap_dst [ 13 ] ; //<S2SV> if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) { //<S2SV> return FALSE ; //<S2SV> } //<S2SV> if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) { //<S2SV> * err = file_error ( wth -> random_fh , err_info ) ; //<S2SV> if ( * err == 0 ) { //<S2SV> * err = WTAP_ERR_SHORT_READ ; //<S2SV> } //<S2SV> return FALSE ; //<S2SV> } //<S2SV> pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , //<S2SV> cap_dst , err , err_info ) ; //<S2SV> if ( pkt_len == - 1 ) //<S2SV> return FALSE ; //<S2SV> if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , //<S2SV> cap_dst , phdr , buf , err , err_info ) ) //<S2SV> return FALSE ; //<S2SV> return TRUE ; //<S2SV> } //<S2SV> 