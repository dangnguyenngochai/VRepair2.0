static fp_info * //<S2SV> fp_set_per_packet_inf_from_conv ( umts_fp_conversation_info_t * p_conv_data , //<S2SV> tvbuff_t * tvb , packet_info * pinfo , //<S2SV> proto_tree * tree _U_ ) //<S2SV> { //<S2SV> fp_info * fpi ; //<S2SV> guint8 tfi , c_t ; //<S2SV> int offset = 0 , i = 0 , j = 0 , num_tbs , chan , tb_size , tb_bit_off ; //<S2SV> gboolean is_control_frame ; //<S2SV> umts_mac_info * macinf ; //<S2SV> rlc_info * rlcinf ; //<S2SV> guint8 fake_lchid = 0 ; //<S2SV> gint * cur_val = NULL ; //<S2SV> fpi = wmem_new0 ( wmem_file_scope ( ) , fp_info ) ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 , fpi ) ; //<S2SV> fpi -> iface_type = p_conv_data -> iface_type ; //<S2SV> fpi -> division = p_conv_data -> division ; //<S2SV> fpi -> release = 7 ; //<S2SV> fpi -> release_year = 2006 ; //<S2SV> fpi -> release_month = 12 ; //<S2SV> fpi -> channel = p_conv_data -> channel ; //<S2SV> fpi -> dch_crc_present = p_conv_data -> dch_crc_present ; //<S2SV> fpi -> link_type = FP_Link_Ethernet ; //<S2SV> # if 0 //<S2SV> if ( ! pinfo -> fd -> flags . visited && p_conv_data -> reset_frag ) { //<S2SV> fpi -> reset_frag = p_conv_data -> reset_frag ; //<S2SV> p_conv_data -> reset_frag = FALSE ; //<S2SV> } //<S2SV> # endif //<S2SV> fpi -> srcport = pinfo -> srcport ; //<S2SV> fpi -> destport = pinfo -> destport ; //<S2SV> fpi -> com_context_id = p_conv_data -> com_context_id ; //<S2SV> if ( pinfo -> link_dir == P2P_DIR_UL ) { //<S2SV> fpi -> is_uplink = TRUE ; //<S2SV> } else { //<S2SV> fpi -> is_uplink = FALSE ; //<S2SV> } //<S2SV> is_control_frame = tvb_get_guint8 ( tvb , offset ) & 0x01 ; //<S2SV> switch ( fpi -> channel ) { //<S2SV> case CHANNEL_HSDSCH : //<S2SV> fpi -> hsdsch_entity = p_conv_data -> hsdsch_entity ; //<S2SV> macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; //<S2SV> fpi -> hsdsch_macflowd_id = p_conv_data -> hsdsch_macdflow_id ; //<S2SV> macinf -> content [ 0 ] = hsdsch_macdflow_id_mac_content_map [ p_conv_data -> hsdsch_macdflow_id ] ; //<S2SV> macinf -> lchid [ 0 ] = p_conv_data -> hsdsch_macdflow_id ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; //<S2SV> rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; //<S2SV> rlcinf -> mode [ 0 ] = hsdsch_macdflow_id_rlc_map [ p_conv_data -> hsdsch_macdflow_id ] ; //<S2SV> if ( fpi -> hsdsch_entity == hs ) { //<S2SV> for ( i = 0 ; i < MAX_NUM_HSDHSCH_MACDFLOW ; i ++ ) { //<S2SV> if ( ( cur_val = ( gint * ) g_tree_lookup ( hsdsch_muxed_flows , GINT_TO_POINTER ( ( gint ) p_conv_data -> hrnti ) ) ) != NULL ) { //<S2SV> j = 1 << i ; //<S2SV> fpi -> hsdhsch_macfdlow_is_mux [ i ] = j & * cur_val ; //<S2SV> } else { //<S2SV> fpi -> hsdhsch_macfdlow_is_mux [ i ] = FALSE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> rlcinf -> urnti [ 0 ] = fpi -> com_context_id ; //<S2SV> rlcinf -> li_size [ 0 ] = RLC_LI_7BITS ; //<S2SV> rlcinf -> ciphered [ 0 ] = FALSE ; //<S2SV> rlcinf -> deciphered [ 0 ] = FALSE ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; //<S2SV> return fpi ; //<S2SV> case CHANNEL_EDCH : //<S2SV> macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; //<S2SV> rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; //<S2SV> fpi -> no_ddi_entries = p_conv_data -> no_ddi_entries ; //<S2SV> for ( i = 0 ; i < fpi -> no_ddi_entries ; i ++ ) { //<S2SV> fpi -> edch_ddi [ i ] = p_conv_data -> edch_ddi [ i ] ; //<S2SV> fpi -> edch_macd_pdu_size [ i ] = p_conv_data -> edch_macd_pdu_size [ i ] ; //<S2SV> fpi -> edch_lchId [ i ] = p_conv_data -> edch_lchId [ i ] ; //<S2SV> } //<S2SV> fpi -> edch_type = p_conv_data -> edch_type ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; //<S2SV> rlcinf -> urnti [ 0 ] = fpi -> com_context_id ; //<S2SV> rlcinf -> li_size [ 0 ] = RLC_LI_7BITS ; //<S2SV> rlcinf -> ciphered [ 0 ] = FALSE ; //<S2SV> rlcinf -> deciphered [ 0 ] = FALSE ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; //<S2SV> return fpi ; //<S2SV> case CHANNEL_PCH : //<S2SV> fpi -> paging_indications = p_conv_data -> paging_indications ; //<S2SV> fpi -> num_chans = p_conv_data -> num_dch_in_flow ; //<S2SV> if ( is_control_frame ) { //<S2SV> return fpi ; //<S2SV> } //<S2SV> offset = 3 ; //<S2SV> break ; //<S2SV> case CHANNEL_DCH : //<S2SV> fpi -> num_chans = p_conv_data -> num_dch_in_flow ; //<S2SV> if ( is_control_frame ) { //<S2SV> return fpi ; //<S2SV> } //<S2SV> rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; //<S2SV> macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; //<S2SV> offset = 2 ; //<S2SV> fakes = 5 ; //<S2SV> for ( chan = 0 ; chan < fpi -> num_chans ; chan ++ ) { //<S2SV> tfi = tvb_get_bits8 ( tvb , 3 + offset * 8 , 5 ) ; //<S2SV> num_tbs = ( fpi -> is_uplink ) ? p_conv_data -> fp_dch_channel_info [ chan ] . ul_chan_num_tbs [ tfi ] : p_conv_data -> fp_dch_channel_info [ chan ] . dl_chan_num_tbs [ tfi ] ; //<S2SV> tb_size = ( fpi -> is_uplink ) ? p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_tf_size [ tfi ] : p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_tf_size [ tfi ] ; //<S2SV> if ( p_conv_data -> dchs_in_flow_list [ chan ] != 31 && ( p_conv_data -> dchs_in_flow_list [ chan ] == 24 && //<S2SV> tb_size != 340 ) ) { //<S2SV> fake_lchid = make_fake_lchid ( pinfo , p_conv_data -> dchs_in_flow_list [ chan ] ) ; //<S2SV> } //<S2SV> tb_bit_off = ( 2 + p_conv_data -> num_dch_in_flow ) * 8 ; //<S2SV> for ( j = 0 ; j < num_tbs && j + chan < MAX_MAC_FRAMES ; j ++ ) { //<S2SV> macinf -> trchid [ j + chan ] = p_conv_data -> dchs_in_flow_list [ chan ] ; //<S2SV> if ( p_conv_data -> dchs_in_flow_list [ chan ] == 31 || p_conv_data -> dchs_in_flow_list [ chan ] == 24 ) { //<S2SV> if ( 0 ) { //<S2SV> macinf -> ctmux [ j + chan ] = FALSE ; //<S2SV> macinf -> lchid [ j + chan ] = 1 ; //<S2SV> macinf -> content [ j + chan ] = lchId_type_table [ 1 ] ; //<S2SV> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ 1 ] ; //<S2SV> } //<S2SV> else if ( p_conv_data -> dchs_in_flow_list [ chan ] == 24 && tb_size != 340 ) { //<S2SV> macinf -> ctmux [ j + chan ] = FALSE ; //<S2SV> macinf -> lchid [ j + chan ] = fake_lchid ; //<S2SV> macinf -> fake_chid [ j + chan ] = TRUE ; //<S2SV> macinf -> content [ j + chan ] = MAC_CONTENT_PS_DTCH ; //<S2SV> rlcinf -> mode [ j + chan ] = RLC_AM ; //<S2SV> } //<S2SV> else { //<S2SV> macinf -> ctmux [ j + chan ] = TRUE ; //<S2SV> c_t = tvb_get_bits8 ( tvb , tb_bit_off , 4 ) ; //<S2SV> macinf -> lchid [ j + chan ] = c_t + 1 ; //<S2SV> macinf -> content [ j + chan ] = lchId_type_table [ c_t + 1 ] ; //<S2SV> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ c_t + 1 ] ; //<S2SV> } //<S2SV> } else { //<S2SV> fake_lchid = make_fake_lchid ( pinfo , p_conv_data -> dchs_in_flow_list [ chan ] ) ; //<S2SV> macinf -> ctmux [ j + chan ] = FALSE ; //<S2SV> macinf -> content [ j + chan ] = lchId_type_table [ fake_lchid ] ; //<S2SV> rlcinf -> mode [ j + chan ] = lchId_rlc_map [ fake_lchid ] ; //<S2SV> macinf -> fake_chid [ j + chan ] = TRUE ; //<S2SV> macinf -> lchid [ j + chan ] = fake_lchid ; //<S2SV> } //<S2SV> rlcinf -> urnti [ j + chan ] = p_conv_data -> com_context_id ; //<S2SV> rlcinf -> li_size [ j + chan ] = RLC_LI_7BITS ; //<S2SV> # if 0 //<S2SV> if ( rrc_ciph_inf && g_tree_lookup ( rrc_ciph_inf , GINT_TO_POINTER ( ( gint ) p_conv_data -> com_context_id ) ) != NULL ) { //<S2SV> rlcinf -> ciphered [ j + chan ] = TRUE ; //<S2SV> } else { //<S2SV> rlcinf -> ciphered [ j + chan ] = FALSE ; //<S2SV> } //<S2SV> # endif //<S2SV> rlcinf -> ciphered [ j + chan ] = FALSE ; //<S2SV> rlcinf -> deciphered [ j + chan ] = FALSE ; //<S2SV> rlcinf -> rbid [ j + chan ] = macinf -> lchid [ j + chan ] ; //<S2SV> tb_bit_off += tb_size + 4 ; //<S2SV> } //<S2SV> offset ++ ; //<S2SV> } //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; //<S2SV> offset = 2 ; //<S2SV> break ; //<S2SV> case CHANNEL_FACH_FDD : //<S2SV> fpi -> num_chans = p_conv_data -> num_dch_in_flow ; //<S2SV> if ( is_control_frame ) { //<S2SV> return fpi ; //<S2SV> } //<S2SV> offset = 2 ; //<S2SV> macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; //<S2SV> macinf -> ctmux [ 0 ] = 1 ; //<S2SV> macinf -> content [ 0 ] = MAC_CONTENT_DCCH ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; //<S2SV> rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; //<S2SV> rlcinf -> urnti [ 0 ] = fpi -> channel ; //<S2SV> rlcinf -> mode [ 0 ] = RLC_AM ; //<S2SV> rlcinf -> li_size [ 0 ] = RLC_LI_7BITS ; //<S2SV> rlcinf -> ciphered [ 0 ] = FALSE ; //<S2SV> rlcinf -> deciphered [ 0 ] = FALSE ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; //<S2SV> break ; //<S2SV> case CHANNEL_RACH_FDD : //<S2SV> fpi -> num_chans = p_conv_data -> num_dch_in_flow ; //<S2SV> if ( is_control_frame ) { //<S2SV> return fpi ; //<S2SV> } //<S2SV> offset = 2 ; //<S2SV> macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; //<S2SV> rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; //<S2SV> for ( chan = 0 ; chan < fpi -> num_chans ; chan ++ ) { //<S2SV> macinf -> ctmux [ chan ] = 1 ; //<S2SV> macinf -> content [ chan ] = MAC_CONTENT_DCCH ; //<S2SV> rlcinf -> urnti [ chan ] = fpi -> com_context_id ; //<S2SV> } //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; //<S2SV> break ; //<S2SV> case CHANNEL_HSDSCH_COMMON : //<S2SV> rlcinf = wmem_new0 ( wmem_file_scope ( ) , rlc_info ) ; //<S2SV> macinf = wmem_new0 ( wmem_file_scope ( ) , umts_mac_info ) ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_umts_mac , 0 , macinf ) ; //<S2SV> p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 , rlcinf ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> expert_add_info ( pinfo , NULL , & ei_fp_transport_channel_type_unknown ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> for ( i = 0 ; i < fpi -> num_chans ; i ++ ) { //<S2SV> tfi = tvb_get_guint8 ( tvb , offset ) ; //<S2SV> if ( pinfo -> link_dir == P2P_DIR_UL ) { //<S2SV> fpi -> chan_tf_size [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_tf_size [ tfi ] ; //<S2SV> fpi -> chan_num_tbs [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . ul_chan_num_tbs [ tfi ] ; //<S2SV> } else { //<S2SV> fpi -> chan_tf_size [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_tf_size [ tfi ] ; //<S2SV> fpi -> chan_num_tbs [ i ] = p_conv_data -> fp_dch_channel_info [ i ] . dl_chan_num_tbs [ tfi ] ; //<S2SV> } //<S2SV> offset ++ ; //<S2SV> } //<S2SV> return fpi ; //<S2SV> } //<S2SV> 