WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { //<S2SV> WORD32 idx ; //<S2SV> WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; //<S2SV> WORD32 N = ( 10 * anal_size ) ; //<S2SV> for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { //<S2SV> WORD32 i , j , k , l ; //<S2SV> FLOAT32 window_output [ 640 ] ; //<S2SV> FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; //<S2SV> FLOAT32 accu_r , accu_i ; //<S2SV> const FLOAT32 * inp_signal ; //<S2SV> FLOAT32 * anal_buf ; //<S2SV> FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; //<S2SV> const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; //<S2SV> FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; //<S2SV> memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , //<S2SV> TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; //<S2SV> inp_signal = ptr_hbe_txposer -> ptr_input_buf + //<S2SV> idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; //<S2SV> anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] //<S2SV> [ 4 * ptr_hbe_txposer -> k_start ] ; //<S2SV> for ( i = N - 1 ; i >= anal_size ; i -- ) { //<S2SV> x [ i ] = x [ i - anal_size ] ; //<S2SV> } //<S2SV> for ( i = anal_size - 1 ; i >= 0 ; i -- ) { //<S2SV> x [ i ] = inp_signal [ anal_size - 1 - i ] ; //<S2SV> } //<S2SV> for ( i = 0 ; i < N ; i ++ ) { //<S2SV> window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; //<S2SV> } //<S2SV> for ( i = 0 ; i < 2 * anal_size ; i ++ ) { //<S2SV> accu_r = 0.0 ; //<S2SV> for ( j = 0 ; j < 5 ; j ++ ) { //<S2SV> accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; //<S2SV> } //<S2SV> u [ i ] = accu_r ; //<S2SV> } //<S2SV> if ( anal_size == 40 ) { //<S2SV> for ( i = 1 ; i < anal_size ; i ++ ) { //<S2SV> FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; //<S2SV> FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; //<S2SV> u [ i ] = temp1 ; //<S2SV> u [ 2 * anal_size - i ] = temp2 ; //<S2SV> } //<S2SV> for ( k = 0 ; k < anal_size ; k ++ ) { //<S2SV> accu_r = u [ anal_size ] ; //<S2SV> if ( k & 1 ) //<S2SV> accu_i = u [ 0 ] ; //<S2SV> else //<S2SV> accu_i = - u [ 0 ] ; //<S2SV> for ( l = 1 ; l < anal_size ; l ++ ) { //<S2SV> accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; //<S2SV> accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; //<S2SV> } //<S2SV> analy_cos_sin_tab += ( 2 * anal_size ) ; //<S2SV> * anal_buf ++ = ( FLOAT32 ) accu_r ; //<S2SV> * anal_buf ++ = ( FLOAT32 ) accu_i ; //<S2SV> } //<S2SV> } else { //<S2SV> FLOAT32 * ptr_u = u_in ; //<S2SV> FLOAT32 * ptr_v = u_out ; //<S2SV> for ( k = 0 ; k < anal_size * 2 ; k ++ ) { //<S2SV> * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; //<S2SV> * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; //<S2SV> } //<S2SV> if ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft != NULL ) //<S2SV> ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) ( u_in , u_out , //<S2SV> anal_size * 2 ) ; //<S2SV> else //<S2SV> return - 1 ; //<S2SV> for ( k = 0 ; k < anal_size / 2 ; k ++ ) { //<S2SV> * ( anal_buf + 1 ) = - * ptr_v ++ ; //<S2SV> * anal_buf = * ptr_v ++ ; //<S2SV> anal_buf += 2 ; //<S2SV> * ( anal_buf + 1 ) = * ptr_v ++ ; //<S2SV> * anal_buf = - * ptr_v ++ ; //<S2SV> anal_buf += 2 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 