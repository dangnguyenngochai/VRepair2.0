WORD32 ixheaacd_real_synth_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , //<S2SV> WORD32 num_columns , FLOAT32 qmf_buf_real [ ] [ 64 ] , //<S2SV> FLOAT32 qmf_buf_imag [ ] [ 64 ] ) { //<S2SV> WORD32 i , j , k , l , idx ; //<S2SV> FLOAT32 g [ 640 ] ; //<S2SV> FLOAT32 w [ 640 ] ; //<S2SV> FLOAT32 synth_out [ 128 ] ; //<S2SV> FLOAT32 accu_r ; //<S2SV> WORD32 synth_size = ptr_hbe_txposer -> synth_size ; //<S2SV> FLOAT32 * ptr_cos_tab_trans_qmf = //<S2SV> ( FLOAT32 * ) & ixheaacd_cos_table_trans_qmf [ 0 ] [ 0 ] + //<S2SV> ptr_hbe_txposer -> k_start * 32 ; //<S2SV> FLOAT32 * buffer = ptr_hbe_txposer -> synth_buf ; //<S2SV> for ( idx = 0 ; idx < num_columns ; idx ++ ) { //<S2SV> FLOAT32 loc_qmf_buf [ 64 ] ; //<S2SV> FLOAT32 * synth_buf_r = loc_qmf_buf ; //<S2SV> FLOAT32 * out_buf = ptr_hbe_txposer -> ptr_input_buf + //<S2SV> ( idx + 1 ) * ptr_hbe_txposer -> synth_size ; //<S2SV> FLOAT32 * synth_cos_tab = ptr_hbe_txposer -> synth_cos_tab ; //<S2SV> const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> synth_wind_coeff ; //<S2SV> if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ; //<S2SV> for ( k = 0 ; k < synth_size ; k ++ ) { //<S2SV> WORD32 ki = ptr_hbe_txposer -> k_start + k ; //<S2SV> synth_buf_r [ k ] = ( FLOAT32 ) ( //<S2SV> ptr_cos_tab_trans_qmf [ ( k << 1 ) + 0 ] * qmf_buf_real [ idx ] [ ki ] + //<S2SV> ptr_cos_tab_trans_qmf [ ( k << 1 ) + 1 ] * qmf_buf_imag [ idx ] [ ki ] ) ; //<S2SV> synth_buf_r [ k + ptr_hbe_txposer -> synth_size ] = 0 ; //<S2SV> } //<S2SV> for ( l = ( 20 * synth_size - 1 ) ; l >= 2 * synth_size ; l -- ) { //<S2SV> buffer [ l ] = buffer [ l - 2 * synth_size ] ; //<S2SV> } //<S2SV> if ( synth_size == 20 ) { //<S2SV> FLOAT32 * psynth_cos_tab = synth_cos_tab ; //<S2SV> for ( l = 0 ; l < ( synth_size + 1 ) ; l ++ ) { //<S2SV> accu_r = 0.0 ; //<S2SV> for ( k = 0 ; k < synth_size ; k ++ ) { //<S2SV> accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; //<S2SV> } //<S2SV> buffer [ 0 + l ] = accu_r ; //<S2SV> buffer [ synth_size - l ] = accu_r ; //<S2SV> psynth_cos_tab = psynth_cos_tab + synth_size ; //<S2SV> } //<S2SV> for ( l = ( synth_size + 1 ) ; l < ( 2 * synth_size - synth_size / 2 ) ; l ++ ) { //<S2SV> accu_r = 0.0 ; //<S2SV> for ( k = 0 ; k < synth_size ; k ++ ) { //<S2SV> accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; //<S2SV> } //<S2SV> buffer [ 0 + l ] = accu_r ; //<S2SV> buffer [ 3 * synth_size - l ] = - accu_r ; //<S2SV> psynth_cos_tab = psynth_cos_tab + synth_size ; //<S2SV> } //<S2SV> accu_r = 0.0 ; //<S2SV> for ( k = 0 ; k < synth_size ; k ++ ) { //<S2SV> accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; //<S2SV> } //<S2SV> buffer [ 3 * synth_size >> 1 ] = accu_r ; //<S2SV> } else { //<S2SV> FLOAT32 tmp ; //<S2SV> FLOAT32 * ptr_u = synth_out ; //<S2SV> WORD32 kmax = ( synth_size >> 1 ) ; //<S2SV> FLOAT32 * syn_buf = & buffer [ kmax ] ; //<S2SV> kmax += synth_size ; //<S2SV> if ( ptr_hbe_txposer -> ixheaacd_real_synth_fft != NULL ) //<S2SV> ( * ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) ( synth_buf_r , synth_out , //<S2SV> synth_size * 2 ) ; //<S2SV> else //<S2SV> return - 1 ; //<S2SV> for ( k = 0 ; k < kmax ; k ++ ) { //<S2SV> tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; //<S2SV> tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; //<S2SV> * syn_buf ++ = tmp ; //<S2SV> } //<S2SV> syn_buf = & buffer [ 0 ] ; //<S2SV> kmax -= synth_size ; //<S2SV> for ( k = 0 ; k < kmax ; k ++ ) { //<S2SV> tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; //<S2SV> tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; //<S2SV> * syn_buf ++ = tmp ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < 5 ; i ++ ) { //<S2SV> memcpy ( & g [ ( 2 * i + 0 ) * synth_size ] , & buffer [ ( 4 * i + 0 ) * synth_size ] , //<S2SV> sizeof ( FLOAT32 ) * synth_size ) ; //<S2SV> memcpy ( & g [ ( 2 * i + 1 ) * synth_size ] , & buffer [ ( 4 * i + 3 ) * synth_size ] , //<S2SV> sizeof ( FLOAT32 ) * synth_size ) ; //<S2SV> } //<S2SV> for ( k = 0 ; k < 10 * synth_size ; k ++ ) { //<S2SV> w [ k ] = g [ k ] * interp_window_coeff [ k ] ; //<S2SV> } //<S2SV> for ( i = 0 ; i < synth_size ; i ++ ) { //<S2SV> accu_r = 0.0 ; //<S2SV> for ( j = 0 ; j < 10 ; j ++ ) { //<S2SV> accu_r = accu_r + w [ synth_size * j + i ] ; //<S2SV> } //<S2SV> out_buf [ i ] = ( FLOAT32 ) accu_r ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 