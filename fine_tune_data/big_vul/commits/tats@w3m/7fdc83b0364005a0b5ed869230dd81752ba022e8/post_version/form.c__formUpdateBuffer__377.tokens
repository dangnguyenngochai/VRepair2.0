void //<S2SV> formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) //<S2SV> { //<S2SV> Buffer save ; //<S2SV> char * p ; //<S2SV> int spos , epos , rows , c_rows , pos , col = 0 ; //<S2SV> Line * l ; //<S2SV> copyBuffer ( & save , buf ) ; //<S2SV> gotoLine ( buf , a -> start . line ) ; //<S2SV> switch ( form -> type ) { //<S2SV> case FORM_TEXTAREA : //<S2SV> case FORM_INPUT_TEXT : //<S2SV> case FORM_INPUT_FILE : //<S2SV> case FORM_INPUT_PASSWORD : //<S2SV> case FORM_INPUT_CHECKBOX : //<S2SV> case FORM_INPUT_RADIO : //<S2SV> # ifdef MENU_SELECT //<S2SV> case FORM_SELECT : //<S2SV> # endif //<S2SV> spos = a -> start . pos ; //<S2SV> epos = a -> end . pos ; //<S2SV> break ; //<S2SV> default : //<S2SV> spos = a -> start . pos + 1 ; //<S2SV> epos = a -> end . pos - 1 ; //<S2SV> } //<S2SV> switch ( form -> type ) { //<S2SV> case FORM_INPUT_CHECKBOX : //<S2SV> case FORM_INPUT_RADIO : //<S2SV> if ( buf -> currentLine == NULL || //<S2SV> spos >= buf -> currentLine -> len || spos < 0 ) //<S2SV> break ; //<S2SV> if ( form -> checked ) //<S2SV> buf -> currentLine -> lineBuf [ spos ] = '*' ; //<S2SV> else //<S2SV> buf -> currentLine -> lineBuf [ spos ] = '<S2SV_blank>' ; //<S2SV> break ; //<S2SV> case FORM_INPUT_TEXT : //<S2SV> case FORM_INPUT_FILE : //<S2SV> case FORM_INPUT_PASSWORD : //<S2SV> case FORM_TEXTAREA : //<S2SV> # ifdef MENU_SELECT //<S2SV> case FORM_SELECT : //<S2SV> if ( form -> type == FORM_SELECT ) { //<S2SV> p = form -> label -> ptr ; //<S2SV> updateSelectOption ( form , form -> select_option ) ; //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> { //<S2SV> if ( ! form -> value ) //<S2SV> break ; //<S2SV> p = form -> value -> ptr ; //<S2SV> } //<S2SV> l = buf -> currentLine ; //<S2SV> if ( ! l ) //<S2SV> break ; //<S2SV> if ( form -> type == FORM_TEXTAREA ) { //<S2SV> int n = a -> y - buf -> currentLine -> linenumber ; //<S2SV> if ( n > 0 ) //<S2SV> for ( ; l && n ; l = l -> prev , n -- ) ; //<S2SV> else if ( n < 0 ) //<S2SV> for ( ; l && n ; l = l -> prev , n ++ ) ; //<S2SV> if ( ! l ) //<S2SV> break ; //<S2SV> } //<S2SV> rows = form -> rows ? form -> rows : 1 ; //<S2SV> col = COLPOS ( l , a -> start . pos ) ; //<S2SV> for ( c_rows = 0 ; c_rows < rows ; c_rows ++ , l = l -> next ) { //<S2SV> if ( l == NULL ) //<S2SV> break ; //<S2SV> if ( rows > 1 ) { //<S2SV> pos = columnPos ( l , col ) ; //<S2SV> a = retrieveAnchor ( buf -> formitem , l -> linenumber , pos ) ; //<S2SV> if ( a == NULL ) //<S2SV> break ; //<S2SV> spos = a -> start . pos ; //<S2SV> epos = a -> end . pos ; //<S2SV> } //<S2SV> if ( a -> start . line != a -> end . line || spos > epos || epos >= l -> len || //<S2SV> spos < 0 || epos < 0 || COLPOS ( l , epos ) < col ) //<S2SV> break ; //<S2SV> pos = form_update_line ( l , & p , spos , epos , COLPOS ( l , epos ) - col , //<S2SV> rows > 1 , //<S2SV> form -> type == FORM_INPUT_PASSWORD ) ; //<S2SV> if ( pos != epos ) { //<S2SV> shiftAnchorPosition ( buf -> href , buf -> hmarklist , //<S2SV> a -> start . line , spos , pos - epos ) ; //<S2SV> shiftAnchorPosition ( buf -> name , buf -> hmarklist , //<S2SV> a -> start . line , spos , pos - epos ) ; //<S2SV> shiftAnchorPosition ( buf -> img , buf -> hmarklist , //<S2SV> a -> start . line , spos , pos - epos ) ; //<S2SV> shiftAnchorPosition ( buf -> formitem , buf -> hmarklist , //<S2SV> a -> start . line , spos , pos - epos ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> copyBuffer ( buf , & save ) ; //<S2SV> arrangeLine ( buf ) ; //<S2SV> } //<S2SV> 