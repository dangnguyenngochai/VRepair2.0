int //<S2SV> HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) //<S2SV> { //<S2SV> char * p , * q , * r ; //<S2SV> int i , w , x , y , z , count , width ; //<S2SV> struct readbuffer * obuf = h_env -> obuf ; //<S2SV> struct environment * envs = h_env -> envs ; //<S2SV> Str tmp ; //<S2SV> int hseq ; //<S2SV> int cmd ; //<S2SV> # ifdef ID_EXT //<S2SV> char * id = NULL ; //<S2SV> # endif //<S2SV> cmd = tag -> tagid ; //<S2SV> if ( obuf -> flag & RB_PRE ) { //<S2SV> switch ( cmd ) { //<S2SV> case HTML_NOBR : //<S2SV> case HTML_N_NOBR : //<S2SV> case HTML_PRE_INT : //<S2SV> case HTML_N_PRE_INT : //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> switch ( cmd ) { //<S2SV> case HTML_B : //<S2SV> obuf -> in_bold ++ ; //<S2SV> if ( obuf -> in_bold > 1 ) //<S2SV> return 1 ; //<S2SV> return 0 ; //<S2SV> case HTML_N_B : //<S2SV> if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) //<S2SV> obuf -> in_bold = 0 ; //<S2SV> if ( obuf -> in_bold > 0 ) { //<S2SV> obuf -> in_bold -- ; //<S2SV> if ( obuf -> in_bold == 0 ) //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_I : //<S2SV> obuf -> in_italic ++ ; //<S2SV> if ( obuf -> in_italic > 1 ) //<S2SV> return 1 ; //<S2SV> return 0 ; //<S2SV> case HTML_N_I : //<S2SV> if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) //<S2SV> obuf -> in_italic = 0 ; //<S2SV> if ( obuf -> in_italic > 0 ) { //<S2SV> obuf -> in_italic -- ; //<S2SV> if ( obuf -> in_italic == 0 ) //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_U : //<S2SV> obuf -> in_under ++ ; //<S2SV> if ( obuf -> in_under > 1 ) //<S2SV> return 1 ; //<S2SV> return 0 ; //<S2SV> case HTML_N_U : //<S2SV> if ( obuf -> in_under == 1 && close_effect0 ( obuf , HTML_U ) ) //<S2SV> obuf -> in_under = 0 ; //<S2SV> if ( obuf -> in_under > 0 ) { //<S2SV> obuf -> in_under -- ; //<S2SV> if ( obuf -> in_under == 0 ) //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_EM : //<S2SV> HTMLlineproc1 ( "<i>" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_EM : //<S2SV> HTMLlineproc1 ( "</i>" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_STRONG : //<S2SV> HTMLlineproc1 ( "<b>" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_STRONG : //<S2SV> HTMLlineproc1 ( "</b>" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_Q : //<S2SV> HTMLlineproc1 ( "`" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_Q : //<S2SV> HTMLlineproc1 ( "\'" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_P : //<S2SV> case HTML_N_P : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> } //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> if ( cmd == HTML_P ) { //<S2SV> set_alignment ( obuf , tag ) ; //<S2SV> obuf -> flag |= RB_P ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_BR : //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 1 , h_env -> limit ) ; //<S2SV> h_env -> blank_lines = 0 ; //<S2SV> return 1 ; //<S2SV> case HTML_H : //<S2SV> if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> } //<S2SV> HTMLlineproc1 ( "<b>" , h_env ) ; //<S2SV> set_alignment ( obuf , tag ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_H : //<S2SV> HTMLlineproc1 ( "</b>" , h_env ) ; //<S2SV> if ( ! ( obuf -> flag & RB_PREMODE ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> } //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> RB_RESTORE_FLAG ( obuf ) ; //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> return 1 ; //<S2SV> case HTML_UL : //<S2SV> case HTML_OL : //<S2SV> case HTML_BLQ : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> if ( ! ( obuf -> flag & RB_PREMODE ) && //<S2SV> ( h_env -> envc == 0 || cmd == HTML_BLQ ) ) //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> } //<S2SV> PUSH_ENV ( cmd ) ; //<S2SV> if ( cmd == HTML_UL || cmd == HTML_OL ) { //<S2SV> if ( parsedtag_get_value ( tag , ATTR_START , & count ) ) { //<S2SV> envs [ h_env -> envc ] . count = count - 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( cmd == HTML_OL ) { //<S2SV> envs [ h_env -> envc ] . type = '1' ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { //<S2SV> envs [ h_env -> envc ] . type = ( int ) * p ; //<S2SV> } //<S2SV> } //<S2SV> if ( cmd == HTML_UL ) //<S2SV> envs [ h_env -> envc ] . type = ul_type ( tag , 0 ) ; //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_UL : //<S2SV> case HTML_N_OL : //<S2SV> case HTML_N_DL : //<S2SV> case HTML_N_BLQ : //<S2SV> CLOSE_DT ; //<S2SV> CLOSE_A ; //<S2SV> if ( h_env -> envc > 0 ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc - 1 ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> POP_ENV ; //<S2SV> if ( ! ( obuf -> flag & RB_PREMODE ) && //<S2SV> ( h_env -> envc == 0 || cmd == HTML_N_DL || cmd == HTML_N_BLQ ) ) { //<S2SV> do_blankline ( h_env , obuf , //<S2SV> envs [ h_env -> envc ] . indent , //<S2SV> INDENT_INCR , h_env -> limit ) ; //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> } //<S2SV> } //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> return 1 ; //<S2SV> case HTML_DL : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> if ( ! ( obuf -> flag & RB_PREMODE ) ) //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> } //<S2SV> PUSH_ENV ( cmd ) ; //<S2SV> if ( parsedtag_exists ( tag , ATTR_COMPACT ) ) //<S2SV> envs [ h_env -> envc ] . env = HTML_DL_COMPACT ; //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> return 1 ; //<S2SV> case HTML_LI : //<S2SV> CLOSE_A ; //<S2SV> CLOSE_DT ; //<S2SV> if ( h_env -> envc > 0 ) { //<S2SV> Str num ; //<S2SV> flushline ( h_env , obuf , //<S2SV> envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; //<S2SV> envs [ h_env -> envc ] . count ++ ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { //<S2SV> count = atoi ( p ) ; //<S2SV> if ( count > 0 ) //<S2SV> envs [ h_env -> envc ] . count = count ; //<S2SV> else //<S2SV> envs [ h_env -> envc ] . count = 0 ; //<S2SV> } //<S2SV> switch ( envs [ h_env -> envc ] . env ) { //<S2SV> case HTML_UL : //<S2SV> envs [ h_env -> envc ] . type = ul_type ( tag , envs [ h_env -> envc ] . type ) ; //<S2SV> for ( i = 0 ; i < INDENT_INCR - 3 ; i ++ ) //<S2SV> push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; //<S2SV> tmp = Strnew ( ) ; //<S2SV> switch ( envs [ h_env -> envc ] . type ) { //<S2SV> case 'd' : //<S2SV> push_symbol ( tmp , UL_SYMBOL_DISC , symbol_width , 1 ) ; //<S2SV> break ; //<S2SV> case 'c' : //<S2SV> push_symbol ( tmp , UL_SYMBOL_CIRCLE , symbol_width , 1 ) ; //<S2SV> break ; //<S2SV> case 's' : //<S2SV> push_symbol ( tmp , UL_SYMBOL_SQUARE , symbol_width , 1 ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> push_symbol ( tmp , //<S2SV> UL_SYMBOL ( ( h_env -> envc_real - //<S2SV> 1 ) % MAX_UL_LEVEL ) , symbol_width , //<S2SV> 1 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( symbol_width == 1 ) //<S2SV> push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; //<S2SV> push_str ( obuf , symbol_width , tmp , PC_ASCII ) ; //<S2SV> push_charp ( obuf , 1 , NBSP , PC_ASCII ) ; //<S2SV> set_space_to_prevchar ( obuf -> prevchar ) ; //<S2SV> break ; //<S2SV> case HTML_OL : //<S2SV> if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) //<S2SV> envs [ h_env -> envc ] . type = ( int ) * p ; //<S2SV> switch ( ( envs [ h_env -> envc ] . count > 0 ) ? envs [ h_env -> envc ] . type : '1' ) { //<S2SV> case 'i' : //<S2SV> num = romanNumeral ( envs [ h_env -> envc ] . count ) ; //<S2SV> break ; //<S2SV> case 'I' : //<S2SV> num = romanNumeral ( envs [ h_env -> envc ] . count ) ; //<S2SV> Strupper ( num ) ; //<S2SV> break ; //<S2SV> case 'a' : //<S2SV> num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; //<S2SV> break ; //<S2SV> case 'A' : //<S2SV> num = romanAlphabet ( envs [ h_env -> envc ] . count ) ; //<S2SV> Strupper ( num ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> num = Sprintf ( "%d" , envs [ h_env -> envc ] . count ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( INDENT_INCR >= 4 ) //<S2SV> Strcat_charp ( num , ".<S2SV_blank>" ) ; //<S2SV> else //<S2SV> Strcat_char ( num , '.' ) ; //<S2SV> push_spaces ( obuf , 1 , INDENT_INCR - num -> length ) ; //<S2SV> push_str ( obuf , num -> length , num , PC_ASCII ) ; //<S2SV> if ( INDENT_INCR >= 4 ) //<S2SV> set_space_to_prevchar ( obuf -> prevchar ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> push_spaces ( obuf , 1 , INDENT_INCR ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> else { //<S2SV> flushline ( h_env , obuf , 0 , 0 , h_env -> limit ) ; //<S2SV> } //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> return 1 ; //<S2SV> case HTML_DT : //<S2SV> CLOSE_A ; //<S2SV> if ( h_env -> envc == 0 || //<S2SV> ( h_env -> envc_real < h_env -> nenv && //<S2SV> envs [ h_env -> envc ] . env != HTML_DL && //<S2SV> envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { //<S2SV> PUSH_ENV ( HTML_DL ) ; //<S2SV> } //<S2SV> if ( h_env -> envc > 0 ) { //<S2SV> flushline ( h_env , obuf , //<S2SV> envs [ h_env -> envc - 1 ] . indent , 0 , h_env -> limit ) ; //<S2SV> } //<S2SV> if ( ! ( obuf -> flag & RB_IN_DT ) ) { //<S2SV> HTMLlineproc1 ( "<b>" , h_env ) ; //<S2SV> obuf -> flag |= RB_IN_DT ; //<S2SV> } //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> return 1 ; //<S2SV> case HTML_DD : //<S2SV> CLOSE_A ; //<S2SV> CLOSE_DT ; //<S2SV> if ( h_env -> envc == 0 || //<S2SV> ( h_env -> envc_real < h_env -> nenv && //<S2SV> envs [ h_env -> envc ] . env != HTML_DL && //<S2SV> envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { //<S2SV> PUSH_ENV ( HTML_DL ) ; //<S2SV> } //<S2SV> if ( envs [ h_env -> envc ] . env == HTML_DL_COMPACT ) { //<S2SV> if ( obuf -> pos > envs [ h_env -> envc ] . indent ) //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> else //<S2SV> push_spaces ( obuf , 1 , envs [ h_env -> envc ] . indent - obuf -> pos ) ; //<S2SV> } //<S2SV> else //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> return 1 ; //<S2SV> case HTML_TITLE : //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> process_title ( tag ) ; //<S2SV> obuf -> flag |= RB_TITLE ; //<S2SV> obuf -> end_tag = HTML_N_TITLE ; //<S2SV> return 1 ; //<S2SV> case HTML_N_TITLE : //<S2SV> if ( ! ( obuf -> flag & RB_TITLE ) ) //<S2SV> return 1 ; //<S2SV> obuf -> flag &= ~ RB_TITLE ; //<S2SV> obuf -> end_tag = 0 ; //<S2SV> tmp = process_n_title ( tag ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_TITLE_ALT : //<S2SV> if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) //<S2SV> h_env -> title = html_unquote ( p ) ; //<S2SV> return 0 ; //<S2SV> case HTML_FRAMESET : //<S2SV> PUSH_ENV ( cmd ) ; //<S2SV> push_charp ( obuf , 9 , "--FRAME--" , PC_ASCII ) ; //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> return 0 ; //<S2SV> case HTML_N_FRAMESET : //<S2SV> if ( h_env -> envc > 0 ) { //<S2SV> POP_ENV ; //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case HTML_NOFRAMES : //<S2SV> CLOSE_A ; //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> obuf -> flag |= ( RB_NOFRAMES | RB_IGNORE_P ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_NOFRAMES : //<S2SV> CLOSE_A ; //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> obuf -> flag &= ~ RB_NOFRAMES ; //<S2SV> return 1 ; //<S2SV> case HTML_FRAME : //<S2SV> q = r = NULL ; //<S2SV> parsedtag_get_value ( tag , ATTR_SRC , & q ) ; //<S2SV> parsedtag_get_value ( tag , ATTR_NAME , & r ) ; //<S2SV> if ( q ) { //<S2SV> q = html_quote ( q ) ; //<S2SV> push_tag ( obuf , Sprintf ( "<a<S2SV_blank>hseq=\\"%d\\"<S2SV_blank>href=\\"%s\\">" , //<S2SV> cur_hseq ++ , q ) -> ptr , HTML_A ) ; //<S2SV> if ( r ) //<S2SV> q = html_quote ( r ) ; //<S2SV> push_charp ( obuf , get_strwidth ( q ) , q , PC_ASCII ) ; //<S2SV> push_tag ( obuf , "</a>" , HTML_N_A ) ; //<S2SV> } //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> return 0 ; //<S2SV> case HTML_HR : //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> tmp = process_hr ( tag , h_env -> limit , envs [ h_env -> envc ] . indent ) ; //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> set_space_to_prevchar ( obuf -> prevchar ) ; //<S2SV> return 1 ; //<S2SV> case HTML_PRE : //<S2SV> x = parsedtag_exists ( tag , ATTR_FOR_TABLE ) ; //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> if ( ! x ) //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> } //<S2SV> else //<S2SV> fillline ( obuf , envs [ h_env -> envc ] . indent ) ; //<S2SV> obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_PRE : //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> h_env -> blank_lines ++ ; //<S2SV> } //<S2SV> obuf -> flag &= ~ RB_PRE ; //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> return 1 ; //<S2SV> case HTML_PRE_INT : //<S2SV> i = obuf -> line -> length ; //<S2SV> append_tags ( obuf ) ; //<S2SV> if ( ! ( obuf -> flag & RB_SPECIAL ) ) { //<S2SV> set_breakpoint ( obuf , obuf -> line -> length - i ) ; //<S2SV> } //<S2SV> obuf -> flag |= RB_PRE_INT ; //<S2SV> return 0 ; //<S2SV> case HTML_N_PRE_INT : //<S2SV> push_tag ( obuf , "</pre_int>" , HTML_N_PRE_INT ) ; //<S2SV> obuf -> flag &= ~ RB_PRE_INT ; //<S2SV> if ( ! ( obuf -> flag & RB_SPECIAL ) && obuf -> pos > obuf -> bp . pos ) { //<S2SV> set_prevchar ( obuf -> prevchar , "" , 0 ) ; //<S2SV> obuf -> prev_ctype = PC_CTRL ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_NOBR : //<S2SV> obuf -> flag |= RB_NOBR ; //<S2SV> obuf -> nobr_level ++ ; //<S2SV> return 0 ; //<S2SV> case HTML_N_NOBR : //<S2SV> if ( obuf -> nobr_level > 0 ) //<S2SV> obuf -> nobr_level -- ; //<S2SV> if ( obuf -> nobr_level == 0 ) //<S2SV> obuf -> flag &= ~ RB_NOBR ; //<S2SV> return 0 ; //<S2SV> case HTML_PRE_PLAIN : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> } //<S2SV> obuf -> flag |= ( RB_PRE | RB_IGNORE_P ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_PRE_PLAIN : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> } //<S2SV> obuf -> flag &= ~ RB_PRE ; //<S2SV> return 1 ; //<S2SV> case HTML_LISTING : //<S2SV> case HTML_XMP : //<S2SV> case HTML_PLAINTEXT : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> } //<S2SV> obuf -> flag |= ( RB_PLAIN | RB_IGNORE_P ) ; //<S2SV> switch ( cmd ) { //<S2SV> case HTML_LISTING : //<S2SV> obuf -> end_tag = HTML_N_LISTING ; //<S2SV> break ; //<S2SV> case HTML_XMP : //<S2SV> obuf -> end_tag = HTML_N_XMP ; //<S2SV> break ; //<S2SV> case HTML_PLAINTEXT : //<S2SV> obuf -> end_tag = MAX_HTMLTAG ; //<S2SV> break ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_N_LISTING : //<S2SV> case HTML_N_XMP : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) { //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> } //<S2SV> obuf -> flag &= ~ RB_PLAIN ; //<S2SV> obuf -> end_tag = 0 ; //<S2SV> return 1 ; //<S2SV> case HTML_SCRIPT : //<S2SV> obuf -> flag |= RB_SCRIPT ; //<S2SV> obuf -> end_tag = HTML_N_SCRIPT ; //<S2SV> return 1 ; //<S2SV> case HTML_STYLE : //<S2SV> obuf -> flag |= RB_STYLE ; //<S2SV> obuf -> end_tag = HTML_N_STYLE ; //<S2SV> return 1 ; //<S2SV> case HTML_N_SCRIPT : //<S2SV> obuf -> flag &= ~ RB_SCRIPT ; //<S2SV> obuf -> end_tag = 0 ; //<S2SV> return 1 ; //<S2SV> case HTML_N_STYLE : //<S2SV> obuf -> flag &= ~ RB_STYLE ; //<S2SV> obuf -> end_tag = 0 ; //<S2SV> return 1 ; //<S2SV> case HTML_A : //<S2SV> if ( obuf -> anchor . url ) //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> hseq = 0 ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) //<S2SV> obuf -> anchor . url = Strnew_charp ( p ) -> ptr ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_TARGET , & p ) ) //<S2SV> obuf -> anchor . target = Strnew_charp ( p ) -> ptr ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_REFERER , & p ) ) //<S2SV> obuf -> anchor . referer = Strnew_charp ( p ) -> ptr ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_TITLE , & p ) ) //<S2SV> obuf -> anchor . title = Strnew_charp ( p ) -> ptr ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_ACCESSKEY , & p ) ) //<S2SV> obuf -> anchor . accesskey = ( unsigned char ) * p ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) //<S2SV> obuf -> anchor . hseq = hseq ; //<S2SV> if ( hseq == 0 && obuf -> anchor . url ) { //<S2SV> obuf -> anchor . hseq = cur_hseq ; //<S2SV> tmp = process_anchor ( tag , h_env -> tagbuf -> ptr ) ; //<S2SV> push_tag ( obuf , tmp -> ptr , HTML_A ) ; //<S2SV> if ( displayLinkNumber ) //<S2SV> HTMLlineproc1 ( getLinkNumberStr ( - 1 ) -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> case HTML_N_A : //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> return 1 ; //<S2SV> case HTML_IMG : //<S2SV> tmp = process_img ( tag , h_env -> limit ) ; //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_IMG_ALT : //<S2SV> if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) //<S2SV> obuf -> img_alt = Strnew_charp ( p ) ; //<S2SV> # ifdef USE_IMAGE //<S2SV> i = 0 ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { //<S2SV> if ( i > obuf -> top_margin ) //<S2SV> obuf -> top_margin = i ; //<S2SV> } //<S2SV> i = 0 ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { //<S2SV> if ( i > obuf -> bottom_margin ) //<S2SV> obuf -> bottom_margin = i ; //<S2SV> } //<S2SV> # endif //<S2SV> return 0 ; //<S2SV> case HTML_N_IMG_ALT : //<S2SV> if ( obuf -> img_alt ) { //<S2SV> if ( ! close_effect0 ( obuf , HTML_IMG_ALT ) ) //<S2SV> push_tag ( obuf , "</img_alt>" , HTML_N_IMG_ALT ) ; //<S2SV> obuf -> img_alt = NULL ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_INPUT_ALT : //<S2SV> i = 0 ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_TOP_MARGIN , & i ) ) { //<S2SV> if ( i > obuf -> top_margin ) //<S2SV> obuf -> top_margin = i ; //<S2SV> } //<S2SV> i = 0 ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_BOTTOM_MARGIN , & i ) ) { //<S2SV> if ( i > obuf -> bottom_margin ) //<S2SV> obuf -> bottom_margin = i ; //<S2SV> } //<S2SV> if ( parsedtag_get_value ( tag , ATTR_HSEQ , & hseq ) ) { //<S2SV> obuf -> input_alt . hseq = hseq ; //<S2SV> } //<S2SV> if ( parsedtag_get_value ( tag , ATTR_FID , & i ) ) { //<S2SV> obuf -> input_alt . fid = i ; //<S2SV> } //<S2SV> if ( parsedtag_get_value ( tag , ATTR_TYPE , & p ) ) { //<S2SV> obuf -> input_alt . type = Strnew_charp ( p ) ; //<S2SV> } //<S2SV> if ( parsedtag_get_value ( tag , ATTR_VALUE , & p ) ) { //<S2SV> obuf -> input_alt . value = Strnew_charp ( p ) ; //<S2SV> } //<S2SV> if ( parsedtag_get_value ( tag , ATTR_NAME , & p ) ) { //<S2SV> obuf -> input_alt . name = Strnew_charp ( p ) ; //<S2SV> } //<S2SV> obuf -> input_alt . in = 1 ; //<S2SV> return 0 ; //<S2SV> case HTML_N_INPUT_ALT : //<S2SV> if ( obuf -> input_alt . in ) { //<S2SV> if ( ! close_effect0 ( obuf , HTML_INPUT_ALT ) ) //<S2SV> push_tag ( obuf , "</input_alt>" , HTML_N_INPUT_ALT ) ; //<S2SV> obuf -> input_alt . hseq = 0 ; //<S2SV> obuf -> input_alt . fid = - 1 ; //<S2SV> obuf -> input_alt . in = 0 ; //<S2SV> obuf -> input_alt . type = NULL ; //<S2SV> obuf -> input_alt . name = NULL ; //<S2SV> obuf -> input_alt . value = NULL ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_TABLE : //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> obuf -> table_level ++ ; //<S2SV> if ( obuf -> table_level >= MAX_TABLE ) //<S2SV> break ; //<S2SV> w = BORDER_NONE ; //<S2SV> x = 2 ; //<S2SV> y = 1 ; //<S2SV> z = 0 ; //<S2SV> width = 0 ; //<S2SV> if ( parsedtag_exists ( tag , ATTR_BORDER ) ) { //<S2SV> if ( parsedtag_get_value ( tag , ATTR_BORDER , & w ) ) { //<S2SV> if ( w > 2 ) //<S2SV> w = BORDER_THICK ; //<S2SV> else if ( w < 0 ) { //<S2SV> w = BORDER_THIN ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> w = BORDER_THIN ; //<S2SV> } //<S2SV> if ( DisplayBorders && w == BORDER_NONE ) //<S2SV> w = BORDER_THIN ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_WIDTH , & i ) ) { //<S2SV> if ( obuf -> table_level == 0 ) //<S2SV> width = REAL_WIDTH ( i , h_env -> limit - envs [ h_env -> envc ] . indent ) ; //<S2SV> else //<S2SV> width = RELATIVE_WIDTH ( i ) ; //<S2SV> } //<S2SV> if ( parsedtag_exists ( tag , ATTR_HBORDER ) ) //<S2SV> w = BORDER_NOWIN ; //<S2SV> # define MAX_CELLSPACING 1000 //<S2SV> # define MAX_CELLPADDING 1000 //<S2SV> # define MAX_VSPACE 1000 //<S2SV> parsedtag_get_value ( tag , ATTR_CELLSPACING , & x ) ; //<S2SV> parsedtag_get_value ( tag , ATTR_CELLPADDING , & y ) ; //<S2SV> parsedtag_get_value ( tag , ATTR_VSPACE , & z ) ; //<S2SV> if ( x > MAX_CELLSPACING ) //<S2SV> x = MAX_CELLSPACING ; //<S2SV> if ( y > MAX_CELLPADDING ) //<S2SV> y = MAX_CELLPADDING ; //<S2SV> if ( z > MAX_VSPACE ) //<S2SV> z = MAX_VSPACE ; //<S2SV> # ifdef ID_EXT //<S2SV> parsedtag_get_value ( tag , ATTR_ID , & id ) ; //<S2SV> # endif //<S2SV> tables [ obuf -> table_level ] = begin_table ( w , x , y , z ) ; //<S2SV> # ifdef ID_EXT //<S2SV> if ( id != NULL ) //<S2SV> tables [ obuf -> table_level ] -> id = Strnew_charp ( id ) ; //<S2SV> # endif //<S2SV> table_mode [ obuf -> table_level ] . pre_mode = 0 ; //<S2SV> table_mode [ obuf -> table_level ] . indent_level = 0 ; //<S2SV> table_mode [ obuf -> table_level ] . nobr_level = 0 ; //<S2SV> table_mode [ obuf -> table_level ] . caption = 0 ; //<S2SV> table_mode [ obuf -> table_level ] . end_tag = 0 ; //<S2SV> # ifndef TABLE_EXPAND //<S2SV> tables [ obuf -> table_level ] -> total_width = width ; //<S2SV> # else //<S2SV> tables [ obuf -> table_level ] -> real_width = width ; //<S2SV> tables [ obuf -> table_level ] -> total_width = 0 ; //<S2SV> # endif //<S2SV> return 1 ; //<S2SV> case HTML_N_TABLE : //<S2SV> return 1 ; //<S2SV> case HTML_CENTER : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & ( RB_PREMODE | RB_IGNORE_P ) ) ) //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> RB_SAVE_FLAG ( obuf ) ; //<S2SV> RB_SET_ALIGN ( obuf , RB_CENTER ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_CENTER : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_PREMODE ) ) //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> RB_RESTORE_FLAG ( obuf ) ; //<S2SV> return 1 ; //<S2SV> case HTML_DIV : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> set_alignment ( obuf , tag ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_DIV : //<S2SV> CLOSE_A ; //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> RB_RESTORE_FLAG ( obuf ) ; //<S2SV> return 1 ; //<S2SV> case HTML_DIV_INT : //<S2SV> CLOSE_P ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> set_alignment ( obuf , tag ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_DIV_INT : //<S2SV> CLOSE_P ; //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> RB_RESTORE_FLAG ( obuf ) ; //<S2SV> return 1 ; //<S2SV> case HTML_FORM : //<S2SV> CLOSE_A ; //<S2SV> if ( ! ( obuf -> flag & RB_IGNORE_P ) ) //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> tmp = process_form ( tag ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_FORM : //<S2SV> CLOSE_A ; //<S2SV> flushline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , h_env -> limit ) ; //<S2SV> obuf -> flag |= RB_IGNORE_P ; //<S2SV> process_n_form ( ) ; //<S2SV> return 1 ; //<S2SV> case HTML_INPUT : //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> tmp = process_input ( tag ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_BUTTON : //<S2SV> tmp = process_button ( tag ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_BUTTON : //<S2SV> tmp = process_n_button ( ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_SELECT : //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> tmp = process_select ( tag ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> obuf -> flag |= RB_INSELECT ; //<S2SV> obuf -> end_tag = HTML_N_SELECT ; //<S2SV> return 1 ; //<S2SV> case HTML_N_SELECT : //<S2SV> obuf -> flag &= ~ RB_INSELECT ; //<S2SV> obuf -> end_tag = 0 ; //<S2SV> tmp = process_n_select ( ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_OPTION : //<S2SV> return 1 ; //<S2SV> case HTML_TEXTAREA : //<S2SV> close_anchor ( h_env , obuf ) ; //<S2SV> tmp = process_textarea ( tag , h_env -> limit ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> obuf -> flag |= RB_INTXTA ; //<S2SV> obuf -> end_tag = HTML_N_TEXTAREA ; //<S2SV> return 1 ; //<S2SV> case HTML_N_TEXTAREA : //<S2SV> obuf -> flag &= ~ RB_INTXTA ; //<S2SV> obuf -> end_tag = 0 ; //<S2SV> tmp = process_n_textarea ( ) ; //<S2SV> if ( tmp ) //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_ISINDEX : //<S2SV> p = "" ; //<S2SV> q = "!CURRENT_URL!" ; //<S2SV> parsedtag_get_value ( tag , ATTR_PROMPT , & p ) ; //<S2SV> parsedtag_get_value ( tag , ATTR_ACTION , & q ) ; //<S2SV> tmp = Strnew_m_charp ( "<form<S2SV_blank>method=get<S2SV_blank>action=\\"" , //<S2SV> html_quote ( q ) , //<S2SV> "\\">" , //<S2SV> html_quote ( p ) , //<S2SV> "<input<S2SV_blank>type=text<S2SV_blank>name=\\"\\"<S2SV_blank>accept></form>" , //<S2SV> NULL ) ; //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_META : //<S2SV> p = q = r = NULL ; //<S2SV> parsedtag_get_value ( tag , ATTR_HTTP_EQUIV , & p ) ; //<S2SV> parsedtag_get_value ( tag , ATTR_CONTENT , & q ) ; //<S2SV> # ifdef USE_M17N //<S2SV> parsedtag_get_value ( tag , ATTR_CHARSET , & r ) ; //<S2SV> if ( r ) { //<S2SV> SKIP_BLANKS ( r ) ; //<S2SV> meta_charset = wc_guess_charset ( r , 0 ) ; //<S2SV> } //<S2SV> else //<S2SV> if ( p && q && ! strcasecmp ( p , "Content-Type" ) && //<S2SV> ( q = strcasestr ( q , "charset" ) ) != NULL ) { //<S2SV> q += 7 ; //<S2SV> SKIP_BLANKS ( q ) ; //<S2SV> if ( * q == '=' ) { //<S2SV> q ++ ; //<S2SV> SKIP_BLANKS ( q ) ; //<S2SV> meta_charset = wc_guess_charset ( q , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> if ( p && q && ! strcasecmp ( p , "refresh" ) ) { //<S2SV> int refresh_interval ; //<S2SV> tmp = NULL ; //<S2SV> refresh_interval = getMetaRefreshParam ( q , & tmp ) ; //<S2SV> if ( tmp ) { //<S2SV> q = html_quote ( tmp -> ptr ) ; //<S2SV> tmp = Sprintf ( "Refresh<S2SV_blank>(%d<S2SV_blank>sec)<S2SV_blank><a<S2SV_blank>href=\\"%s\\">%s</a>" , //<S2SV> refresh_interval , q , q ) ; //<S2SV> } //<S2SV> else if ( refresh_interval > 0 ) //<S2SV> tmp = Sprintf ( "Refresh<S2SV_blank>(%d<S2SV_blank>sec)" , refresh_interval ) ; //<S2SV> if ( tmp ) { //<S2SV> HTMLlineproc1 ( tmp -> ptr , h_env ) ; //<S2SV> do_blankline ( h_env , obuf , envs [ h_env -> envc ] . indent , 0 , //<S2SV> h_env -> limit ) ; //<S2SV> if ( ! is_redisplay && //<S2SV> ! ( ( obuf -> flag & RB_NOFRAMES ) && RenderFrame ) ) { //<S2SV> tag -> need_reconstruct = TRUE ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_BASE : //<S2SV> # if defined ( USE_M17N ) || defined ( USE_IMAGE ) //<S2SV> p = NULL ; //<S2SV> if ( parsedtag_get_value ( tag , ATTR_HREF , & p ) ) { //<S2SV> cur_baseURL = New ( ParsedURL ) ; //<S2SV> parseURL ( p , cur_baseURL , NULL ) ; //<S2SV> } //<S2SV> # endif //<S2SV> case HTML_MAP : //<S2SV> case HTML_N_MAP : //<S2SV> case HTML_AREA : //<S2SV> return 0 ; //<S2SV> case HTML_DEL : //<S2SV> switch ( displayInsDel ) { //<S2SV> case DISPLAY_INS_DEL_SIMPLE : //<S2SV> obuf -> flag |= RB_DEL ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_NORMAL : //<S2SV> HTMLlineproc1 ( "<U>[DEL:</U>" , h_env ) ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_FONTIFY : //<S2SV> obuf -> in_strike ++ ; //<S2SV> if ( obuf -> in_strike == 1 ) { //<S2SV> push_tag ( obuf , "<s>" , HTML_S ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_N_DEL : //<S2SV> switch ( displayInsDel ) { //<S2SV> case DISPLAY_INS_DEL_SIMPLE : //<S2SV> obuf -> flag &= ~ RB_DEL ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_NORMAL : //<S2SV> HTMLlineproc1 ( "<U>:DEL]</U>" , h_env ) ; //<S2SV> case DISPLAY_INS_DEL_FONTIFY : //<S2SV> if ( obuf -> in_strike == 0 ) //<S2SV> return 1 ; //<S2SV> if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) //<S2SV> obuf -> in_strike = 0 ; //<S2SV> if ( obuf -> in_strike > 0 ) { //<S2SV> obuf -> in_strike -- ; //<S2SV> if ( obuf -> in_strike == 0 ) { //<S2SV> push_tag ( obuf , "</s>" , HTML_N_S ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_S : //<S2SV> switch ( displayInsDel ) { //<S2SV> case DISPLAY_INS_DEL_SIMPLE : //<S2SV> obuf -> flag |= RB_S ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_NORMAL : //<S2SV> HTMLlineproc1 ( "<U>[S:</U>" , h_env ) ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_FONTIFY : //<S2SV> obuf -> in_strike ++ ; //<S2SV> if ( obuf -> in_strike == 1 ) { //<S2SV> push_tag ( obuf , "<s>" , HTML_S ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_N_S : //<S2SV> switch ( displayInsDel ) { //<S2SV> case DISPLAY_INS_DEL_SIMPLE : //<S2SV> obuf -> flag &= ~ RB_S ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_NORMAL : //<S2SV> HTMLlineproc1 ( "<U>:S]</U>" , h_env ) ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_FONTIFY : //<S2SV> if ( obuf -> in_strike == 0 ) //<S2SV> return 1 ; //<S2SV> if ( obuf -> in_strike == 1 && close_effect0 ( obuf , HTML_S ) ) //<S2SV> obuf -> in_strike = 0 ; //<S2SV> if ( obuf -> in_strike > 0 ) { //<S2SV> obuf -> in_strike -- ; //<S2SV> if ( obuf -> in_strike == 0 ) { //<S2SV> push_tag ( obuf , "</s>" , HTML_N_S ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_INS : //<S2SV> switch ( displayInsDel ) { //<S2SV> case DISPLAY_INS_DEL_SIMPLE : //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_NORMAL : //<S2SV> HTMLlineproc1 ( "<U>[INS:</U>" , h_env ) ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_FONTIFY : //<S2SV> obuf -> in_ins ++ ; //<S2SV> if ( obuf -> in_ins == 1 ) { //<S2SV> push_tag ( obuf , "<ins>" , HTML_INS ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_N_INS : //<S2SV> switch ( displayInsDel ) { //<S2SV> case DISPLAY_INS_DEL_SIMPLE : //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_NORMAL : //<S2SV> HTMLlineproc1 ( "<U>:INS]</U>" , h_env ) ; //<S2SV> break ; //<S2SV> case DISPLAY_INS_DEL_FONTIFY : //<S2SV> if ( obuf -> in_ins == 0 ) //<S2SV> return 1 ; //<S2SV> if ( obuf -> in_ins == 1 && close_effect0 ( obuf , HTML_INS ) ) //<S2SV> obuf -> in_ins = 0 ; //<S2SV> if ( obuf -> in_ins > 0 ) { //<S2SV> obuf -> in_ins -- ; //<S2SV> if ( obuf -> in_ins == 0 ) { //<S2SV> push_tag ( obuf , "</ins>" , HTML_N_INS ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_SUP : //<S2SV> if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) //<S2SV> HTMLlineproc1 ( "^" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_SUP : //<S2SV> return 1 ; //<S2SV> case HTML_SUB : //<S2SV> if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) //<S2SV> HTMLlineproc1 ( "[" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_N_SUB : //<S2SV> if ( ! ( obuf -> flag & ( RB_DEL | RB_S ) ) ) //<S2SV> HTMLlineproc1 ( "]" , h_env ) ; //<S2SV> return 1 ; //<S2SV> case HTML_FONT : //<S2SV> case HTML_N_FONT : //<S2SV> case HTML_NOP : //<S2SV> return 1 ; //<S2SV> case HTML_BGSOUND : //<S2SV> if ( view_unseenobject ) { //<S2SV> if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { //<S2SV> Str s ; //<S2SV> q = html_quote ( p ) ; //<S2SV> s = Sprintf ( "<A<S2SV_blank>HREF=\\"%s\\">bgsound(%s)</A>" , q , q ) ; //<S2SV> HTMLlineproc1 ( s -> ptr , h_env ) ; //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_EMBED : //<S2SV> if ( view_unseenobject ) { //<S2SV> if ( parsedtag_get_value ( tag , ATTR_SRC , & p ) ) { //<S2SV> Str s ; //<S2SV> q = html_quote ( p ) ; //<S2SV> s = Sprintf ( "<A<S2SV_blank>HREF=\\"%s\\">embed(%s)</A>" , q , q ) ; //<S2SV> HTMLlineproc1 ( s -> ptr , h_env ) ; //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_APPLET : //<S2SV> if ( view_unseenobject ) { //<S2SV> if ( parsedtag_get_value ( tag , ATTR_ARCHIVE , & p ) ) { //<S2SV> Str s ; //<S2SV> q = html_quote ( p ) ; //<S2SV> s = Sprintf ( "<A<S2SV_blank>HREF=\\"%s\\">applet<S2SV_blank>archive(%s)</A>" , q , q ) ; //<S2SV> HTMLlineproc1 ( s -> ptr , h_env ) ; //<S2SV> } //<S2SV> } //<S2SV> return 1 ; //<S2SV> case HTML_BODY : //<S2SV> if ( view_unseenobject ) { //<S2SV> if ( parsedtag_get_value ( tag , ATTR_BACKGROUND , & p ) ) { //<S2SV> Str s ; //<S2SV> q = html_quote ( p ) ; //<S2SV> s = Sprintf ( "<IMG<S2SV_blank>SRC=\\"%s\\"<S2SV_blank>ALT=\\"bg<S2SV_blank>image(%s)\\"><BR>" , q , q ) ; //<S2SV> HTMLlineproc1 ( s -> ptr , h_env ) ; //<S2SV> } //<S2SV> } //<S2SV> case HTML_N_HEAD : //<S2SV> if ( obuf -> flag & RB_TITLE ) //<S2SV> HTMLlineproc1 ( "</title>" , h_env ) ; //<S2SV> case HTML_HEAD : //<S2SV> case HTML_N_BODY : //<S2SV> return 1 ; //<S2SV> default : //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 