err_t verify_signed_hash ( const struct RSA_public_key * k //<S2SV> , u_char * s , unsigned int s_max_octets //<S2SV> , u_char * * psig //<S2SV> , size_t hash_len //<S2SV> , const u_char * sig_val , size_t sig_len ) //<S2SV> { //<S2SV> unsigned int padlen ; //<S2SV> { //<S2SV> chunk_t temp_s ; //<S2SV> MP_INT c ; //<S2SV> n_to_mpz ( & c , sig_val , sig_len ) ; //<S2SV> oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; //<S2SV> temp_s = mpz_to_n ( & c , sig_len ) ; //<S2SV> if ( s_max_octets < sig_len ) { //<S2SV> return "2" "exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets" ; //<S2SV> } //<S2SV> memcpy ( s , temp_s . ptr , sig_len ) ; //<S2SV> pfree ( temp_s . ptr ) ; //<S2SV> mpz_clear ( & c ) ; //<S2SV> } //<S2SV> padlen = sig_len - 3 - hash_len ; //<S2SV> DBG ( DBG_CRYPT , //<S2SV> DBG_dump ( "verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:" , s , sig_len ) ) ; //<S2SV> DBG ( DBG_CRYPT , DBG_log ( "pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d" , padlen , ( int ) hash_len ) ) ; //<S2SV> if ( s [ 0 ] != 0x00 //<S2SV> || s [ 1 ] != 0x01 //<S2SV> || s [ padlen + 2 ] != 0x00 ) { //<S2SV> return "3" "SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out" ; //<S2SV> } //<S2SV> s += padlen + 3 ; //<S2SV> ( * psig ) = s ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 