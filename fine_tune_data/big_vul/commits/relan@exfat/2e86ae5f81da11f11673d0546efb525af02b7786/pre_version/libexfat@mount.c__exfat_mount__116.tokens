int exfat_mount ( struct exfat * ef , const char * spec , const char * options ) //<S2SV> { //<S2SV> int rc ; //<S2SV> enum exfat_mode mode ; //<S2SV> exfat_tzset ( ) ; //<S2SV> memset ( ef , 0 , sizeof ( struct exfat ) ) ; //<S2SV> parse_options ( ef , options ) ; //<S2SV> if ( match_option ( options , "ro" ) ) //<S2SV> mode = EXFAT_MODE_RO ; //<S2SV> else if ( match_option ( options , "ro_fallback" ) ) //<S2SV> mode = EXFAT_MODE_ANY ; //<S2SV> else //<S2SV> mode = EXFAT_MODE_RW ; //<S2SV> ef -> dev = exfat_open ( spec , mode ) ; //<S2SV> if ( ef -> dev == NULL ) //<S2SV> return - EIO ; //<S2SV> if ( exfat_get_mode ( ef -> dev ) == EXFAT_MODE_RO ) //<S2SV> { //<S2SV> if ( mode == EXFAT_MODE_ANY ) //<S2SV> ef -> ro = - 1 ; //<S2SV> else //<S2SV> ef -> ro = 1 ; //<S2SV> } //<S2SV> ef -> sb = malloc ( sizeof ( struct exfat_super_block ) ) ; //<S2SV> if ( ef -> sb == NULL ) //<S2SV> { //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> exfat_error ( "failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>super<S2SV_blank>block" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> memset ( ef -> sb , 0 , sizeof ( struct exfat_super_block ) ) ; //<S2SV> if ( exfat_pread ( ef -> dev , ef -> sb , sizeof ( struct exfat_super_block ) , 0 ) < 0 ) //<S2SV> { //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> exfat_error ( "failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>boot<S2SV_blank>sector" ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> if ( memcmp ( ef -> sb -> oem_name , "EXFAT<S2SV_blank><S2SV_blank><S2SV_blank>" , 8 ) != 0 ) //<S2SV> { //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> exfat_error ( "exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found" ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> ef -> zero_cluster = malloc ( CLUSTER_SIZE ( * ef -> sb ) ) ; //<S2SV> if ( ef -> zero_cluster == NULL ) //<S2SV> { //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> exfat_error ( "failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>zero<S2SV_blank>sector" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> if ( ! verify_vbr_checksum ( ef -> dev , ef -> zero_cluster , SECTOR_SIZE ( * ef -> sb ) ) ) //<S2SV> { //<S2SV> free ( ef -> zero_cluster ) ; //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> memset ( ef -> zero_cluster , 0 , CLUSTER_SIZE ( * ef -> sb ) ) ; //<S2SV> if ( ef -> sb -> version . major != 1 || ef -> sb -> version . minor != 0 ) //<S2SV> { //<S2SV> free ( ef -> zero_cluster ) ; //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> exfat_error ( "unsupported<S2SV_blank>exFAT<S2SV_blank>version:<S2SV_blank>%hhu.%hhu" , //<S2SV> ef -> sb -> version . major , ef -> sb -> version . minor ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> if ( ef -> sb -> fat_count != 1 ) //<S2SV> { //<S2SV> free ( ef -> zero_cluster ) ; //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> exfat_error ( "unsupported<S2SV_blank>FAT<S2SV_blank>count:<S2SV_blank>%hhu" , ef -> sb -> fat_count ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) //<S2SV> { //<S2SV> free ( ef -> zero_cluster ) ; //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> exfat_error ( "too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^%d" , //<S2SV> ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> if ( le64_to_cpu ( ef -> sb -> sector_count ) * SECTOR_SIZE ( * ef -> sb ) > //<S2SV> exfat_get_size ( ef -> dev ) ) //<S2SV> { //<S2SV> exfat_warn ( "file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>underlying<S2SV_blank>device:<S2SV_blank>" //<S2SV> "%" PRIu64 "<S2SV_blank>><S2SV_blank>%" PRIu64 , //<S2SV> le64_to_cpu ( ef -> sb -> sector_count ) * SECTOR_SIZE ( * ef -> sb ) , //<S2SV> exfat_get_size ( ef -> dev ) ) ; //<S2SV> } //<S2SV> ef -> root = malloc ( sizeof ( struct exfat_node ) ) ; //<S2SV> if ( ef -> root == NULL ) //<S2SV> { //<S2SV> free ( ef -> zero_cluster ) ; //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> exfat_error ( "failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>root<S2SV_blank>node" ) ; //<S2SV> return - ENOMEM ; //<S2SV> } //<S2SV> memset ( ef -> root , 0 , sizeof ( struct exfat_node ) ) ; //<S2SV> ef -> root -> flags = EXFAT_ATTRIB_DIR ; //<S2SV> ef -> root -> start_cluster = le32_to_cpu ( ef -> sb -> rootdir_cluster ) ; //<S2SV> ef -> root -> fptr_cluster = ef -> root -> start_cluster ; //<S2SV> ef -> root -> name [ 0 ] = cpu_to_le16 ( '\\0' ) ; //<S2SV> ef -> root -> size = rootdir_size ( ef ) ; //<S2SV> if ( ef -> root -> size == 0 ) //<S2SV> { //<S2SV> free ( ef -> root ) ; //<S2SV> free ( ef -> zero_cluster ) ; //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> ef -> root -> mtime = 0 ; //<S2SV> ef -> root -> atime = 0 ; //<S2SV> exfat_get_node ( ef -> root ) ; //<S2SV> rc = exfat_cache_directory ( ef , ef -> root ) ; //<S2SV> if ( rc != 0 ) //<S2SV> goto error ; //<S2SV> if ( ef -> upcase == NULL ) //<S2SV> { //<S2SV> exfat_error ( "upcase<S2SV_blank>table<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( ef -> cmap . chunk == NULL ) //<S2SV> { //<S2SV> exfat_error ( "clusters<S2SV_blank>bitmap<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found" ) ; //<S2SV> goto error ; //<S2SV> } //<S2SV> if ( prepare_super_block ( ef ) != 0 ) //<S2SV> goto error ; //<S2SV> return 0 ; //<S2SV> error : //<S2SV> exfat_put_node ( ef , ef -> root ) ; //<S2SV> exfat_reset_cache ( ef ) ; //<S2SV> free ( ef -> root ) ; //<S2SV> free ( ef -> zero_cluster ) ; //<S2SV> exfat_close ( ef -> dev ) ; //<S2SV> free ( ef -> sb ) ; //<S2SV> return - EIO ; //<S2SV> } //<S2SV> 