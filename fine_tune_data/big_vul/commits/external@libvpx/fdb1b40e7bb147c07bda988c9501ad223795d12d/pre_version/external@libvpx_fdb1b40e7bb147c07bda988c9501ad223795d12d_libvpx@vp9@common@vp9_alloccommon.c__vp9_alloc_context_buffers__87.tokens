int vp9_alloc_context_buffers ( VP9_COMMON * cm , int width , int height ) { //<S2SV> int new_mi_size ; //<S2SV> vp9_set_mb_mi ( cm , width , height ) ; //<S2SV> new_mi_size = cm -> mi_stride * calc_mi_size ( cm -> mi_rows ) ; //<S2SV> if ( cm -> mi_alloc_size < new_mi_size ) { //<S2SV> cm -> free_mi ( cm ) ; //<S2SV> if ( cm -> alloc_mi ( cm , new_mi_size ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( cm -> seg_map_alloc_size < cm -> mi_rows * cm -> mi_cols ) { //<S2SV> free_seg_map ( cm ) ; //<S2SV> if ( alloc_seg_map ( cm , cm -> mi_rows * cm -> mi_cols ) ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( cm -> above_context_alloc_cols < cm -> mi_cols ) { //<S2SV> vpx_free ( cm -> above_context ) ; //<S2SV> cm -> above_context = ( ENTROPY_CONTEXT * ) vpx_calloc ( //<S2SV> 2 * mi_cols_aligned_to_sb ( cm -> mi_cols ) * MAX_MB_PLANE , //<S2SV> sizeof ( * cm -> above_context ) ) ; //<S2SV> if ( ! cm -> above_context ) goto fail ; //<S2SV> vpx_free ( cm -> above_seg_context ) ; //<S2SV> cm -> above_seg_context = ( PARTITION_CONTEXT * ) vpx_calloc ( //<S2SV> mi_cols_aligned_to_sb ( cm -> mi_cols ) , sizeof ( * cm -> above_seg_context ) ) ; //<S2SV> if ( ! cm -> above_seg_context ) goto fail ; //<S2SV> cm -> above_context_alloc_cols = cm -> mi_cols ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> fail : //<S2SV> vp9_free_context_buffers ( cm ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> 