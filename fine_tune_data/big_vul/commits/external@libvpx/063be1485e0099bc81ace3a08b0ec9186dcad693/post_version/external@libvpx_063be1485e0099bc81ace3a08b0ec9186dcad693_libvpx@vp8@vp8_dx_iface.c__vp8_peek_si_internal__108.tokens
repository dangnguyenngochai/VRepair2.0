static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , //<S2SV> unsigned int data_sz , //<S2SV> vpx_codec_stream_info_t * si , //<S2SV> vpx_decrypt_cb decrypt_cb , //<S2SV> void * decrypt_state ) //<S2SV> { //<S2SV> vpx_codec_err_t res = VPX_CODEC_OK ; //<S2SV> if ( data + data_sz <= data ) //<S2SV> { //<S2SV> res = VPX_CODEC_INVALID_PARAM ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> uint8_t clear_buffer [ 10 ] ; //<S2SV> const uint8_t * clear = data ; //<S2SV> if ( decrypt_cb ) //<S2SV> { //<S2SV> int n = MIN ( sizeof ( clear_buffer ) , data_sz ) ; //<S2SV> decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; //<S2SV> clear = clear_buffer ; //<S2SV> } //<S2SV> si -> is_kf = 0 ; //<S2SV> if ( data_sz >= 10 && ! ( clear [ 0 ] & 0x01 ) ) //<S2SV> { //<S2SV> si -> is_kf = 1 ; //<S2SV> if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; //<S2SV> si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ; //<S2SV> if ( ! ( si -> h && si -> w ) ) //<S2SV> res = VPX_CODEC_CORRUPT_FRAME ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> res = VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> } //<S2SV> } //<S2SV> return res ; //<S2SV> } //<S2SV> 