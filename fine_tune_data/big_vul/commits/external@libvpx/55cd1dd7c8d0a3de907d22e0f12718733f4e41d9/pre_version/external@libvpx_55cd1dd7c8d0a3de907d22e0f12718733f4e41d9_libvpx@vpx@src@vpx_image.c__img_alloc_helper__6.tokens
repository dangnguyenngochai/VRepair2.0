static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , //<S2SV> unsigned int d_w , unsigned int d_h , //<S2SV> unsigned int buf_align , //<S2SV> unsigned int stride_align , //<S2SV> unsigned char * img_data ) { //<S2SV> unsigned int h , w , s , xcs , ycs , bps ; //<S2SV> unsigned int stride_in_bytes ; //<S2SV> int align ; //<S2SV> if ( ! buf_align ) buf_align = 1 ; //<S2SV> if ( buf_align & ( buf_align - 1 ) ) goto fail ; //<S2SV> if ( ! stride_align ) stride_align = 1 ; //<S2SV> if ( stride_align & ( stride_align - 1 ) ) goto fail ; //<S2SV> switch ( fmt ) { //<S2SV> case VPX_IMG_FMT_RGB32 : //<S2SV> case VPX_IMG_FMT_RGB32_LE : //<S2SV> case VPX_IMG_FMT_ARGB : //<S2SV> case VPX_IMG_FMT_ARGB_LE : bps = 32 ; break ; //<S2SV> case VPX_IMG_FMT_RGB24 : //<S2SV> case VPX_IMG_FMT_BGR24 : bps = 24 ; break ; //<S2SV> case VPX_IMG_FMT_RGB565 : //<S2SV> case VPX_IMG_FMT_RGB565_LE : //<S2SV> case VPX_IMG_FMT_RGB555 : //<S2SV> case VPX_IMG_FMT_RGB555_LE : //<S2SV> case VPX_IMG_FMT_UYVY : //<S2SV> case VPX_IMG_FMT_YUY2 : //<S2SV> case VPX_IMG_FMT_YVYU : bps = 16 ; break ; //<S2SV> case VPX_IMG_FMT_I420 : //<S2SV> case VPX_IMG_FMT_YV12 : //<S2SV> case VPX_IMG_FMT_VPXI420 : //<S2SV> case VPX_IMG_FMT_VPXYV12 : bps = 12 ; break ; //<S2SV> case VPX_IMG_FMT_I422 : //<S2SV> case VPX_IMG_FMT_I440 : bps = 16 ; break ; //<S2SV> case VPX_IMG_FMT_I444 : bps = 24 ; break ; //<S2SV> case VPX_IMG_FMT_I42016 : bps = 24 ; break ; //<S2SV> case VPX_IMG_FMT_I42216 : //<S2SV> case VPX_IMG_FMT_I44016 : bps = 32 ; break ; //<S2SV> case VPX_IMG_FMT_I44416 : bps = 48 ; break ; //<S2SV> default : bps = 16 ; break ; //<S2SV> } //<S2SV> switch ( fmt ) { //<S2SV> case VPX_IMG_FMT_I420 : //<S2SV> case VPX_IMG_FMT_YV12 : //<S2SV> case VPX_IMG_FMT_VPXI420 : //<S2SV> case VPX_IMG_FMT_VPXYV12 : //<S2SV> case VPX_IMG_FMT_I422 : //<S2SV> case VPX_IMG_FMT_I42016 : //<S2SV> case VPX_IMG_FMT_I42216 : xcs = 1 ; break ; //<S2SV> default : xcs = 0 ; break ; //<S2SV> } //<S2SV> switch ( fmt ) { //<S2SV> case VPX_IMG_FMT_I420 : //<S2SV> case VPX_IMG_FMT_I440 : //<S2SV> case VPX_IMG_FMT_YV12 : //<S2SV> case VPX_IMG_FMT_VPXI420 : //<S2SV> case VPX_IMG_FMT_VPXYV12 : //<S2SV> case VPX_IMG_FMT_I42016 : //<S2SV> case VPX_IMG_FMT_I44016 : ycs = 1 ; break ; //<S2SV> default : ycs = 0 ; break ; //<S2SV> } //<S2SV> align = ( 1 << xcs ) - 1 ; //<S2SV> w = ( d_w + align ) & ~ align ; //<S2SV> align = ( 1 << ycs ) - 1 ; //<S2SV> h = ( d_h + align ) & ~ align ; //<S2SV> s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; //<S2SV> s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; //<S2SV> stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; //<S2SV> if ( ! img ) { //<S2SV> img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; //<S2SV> if ( ! img ) goto fail ; //<S2SV> img -> self_allocd = 1 ; //<S2SV> } else { //<S2SV> memset ( img , 0 , sizeof ( vpx_image_t ) ) ; //<S2SV> } //<S2SV> img -> img_data = img_data ; //<S2SV> if ( ! img_data ) { //<S2SV> const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) //<S2SV> ? ( uint64_t ) h * s * bps / 8 //<S2SV> : ( uint64_t ) h * s ; //<S2SV> if ( alloc_size != ( size_t ) alloc_size ) goto fail ; //<S2SV> img -> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; //<S2SV> img -> img_data_owner = 1 ; //<S2SV> } //<S2SV> if ( ! img -> img_data ) goto fail ; //<S2SV> img -> fmt = fmt ; //<S2SV> img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 16 : 8 ; //<S2SV> img -> w = w ; //<S2SV> img -> h = h ; //<S2SV> img -> x_chroma_shift = xcs ; //<S2SV> img -> y_chroma_shift = ycs ; //<S2SV> img -> bps = bps ; //<S2SV> img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = stride_in_bytes ; //<S2SV> img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = stride_in_bytes >> xcs ; //<S2SV> if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ; //<S2SV> fail : //<S2SV> vpx_img_free ( img ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 