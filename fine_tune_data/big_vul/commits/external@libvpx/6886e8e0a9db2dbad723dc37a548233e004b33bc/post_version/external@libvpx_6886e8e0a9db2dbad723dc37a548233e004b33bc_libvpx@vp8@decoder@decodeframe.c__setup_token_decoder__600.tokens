static void setup_token_decoder ( VP8D_COMP * pbi , //<S2SV> const unsigned char * token_part_sizes ) //<S2SV> { //<S2SV> vp8_reader * bool_decoder = & pbi -> mbc [ 0 ] ; //<S2SV> unsigned int partition_idx ; //<S2SV> unsigned int fragment_idx ; //<S2SV> unsigned int num_token_partitions ; //<S2SV> const unsigned char * first_fragment_end = pbi -> fragments . ptrs [ 0 ] + //<S2SV> pbi -> fragments . sizes [ 0 ] ; //<S2SV> TOKEN_PARTITION multi_token_partition = //<S2SV> ( TOKEN_PARTITION ) vp8_read_literal ( & pbi -> mbc [ 8 ] , 2 ) ; //<S2SV> if ( ! vp8dx_bool_error ( & pbi -> mbc [ 8 ] ) ) //<S2SV> pbi -> common . multi_token_partition = multi_token_partition ; //<S2SV> num_token_partitions = 1 << pbi -> common . multi_token_partition ; //<S2SV> for ( fragment_idx = 0 ; fragment_idx < pbi -> fragments . count ; ++ fragment_idx ) //<S2SV> { //<S2SV> unsigned int fragment_size = pbi -> fragments . sizes [ fragment_idx ] ; //<S2SV> const unsigned char * fragment_end = pbi -> fragments . ptrs [ fragment_idx ] + //<S2SV> fragment_size ; //<S2SV> if ( fragment_idx == 0 ) //<S2SV> { //<S2SV> ptrdiff_t ext_first_part_size = token_part_sizes - //<S2SV> pbi -> fragments . ptrs [ 0 ] + 3 * ( num_token_partitions - 1 ) ; //<S2SV> fragment_size -= ( unsigned int ) ext_first_part_size ; //<S2SV> if ( fragment_size > 0 ) //<S2SV> { //<S2SV> pbi -> fragments . sizes [ 0 ] = ( unsigned int ) ext_first_part_size ; //<S2SV> fragment_idx ++ ; //<S2SV> pbi -> fragments . ptrs [ fragment_idx ] = pbi -> fragments . ptrs [ 0 ] + //<S2SV> pbi -> fragments . sizes [ 0 ] ; //<S2SV> } //<S2SV> } //<S2SV> while ( fragment_size > 0 ) //<S2SV> { //<S2SV> ptrdiff_t partition_size = read_available_partition_size ( //<S2SV> pbi , //<S2SV> token_part_sizes , //<S2SV> pbi -> fragments . ptrs [ fragment_idx ] , //<S2SV> first_fragment_end , //<S2SV> fragment_end , //<S2SV> fragment_idx - 1 , //<S2SV> num_token_partitions ) ; //<S2SV> pbi -> fragments . sizes [ fragment_idx ] = ( unsigned int ) partition_size ; //<S2SV> fragment_size -= ( unsigned int ) partition_size ; //<S2SV> assert ( fragment_idx <= num_token_partitions ) ; //<S2SV> if ( fragment_size > 0 ) //<S2SV> { //<S2SV> fragment_idx ++ ; //<S2SV> pbi -> fragments . ptrs [ fragment_idx ] = //<S2SV> pbi -> fragments . ptrs [ fragment_idx - 1 ] + partition_size ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> pbi -> fragments . count = num_token_partitions + 1 ; //<S2SV> for ( partition_idx = 1 ; partition_idx < pbi -> fragments . count ; ++ partition_idx ) //<S2SV> { //<S2SV> if ( vp8dx_start_decode ( bool_decoder , //<S2SV> pbi -> fragments . ptrs [ partition_idx ] , //<S2SV> pbi -> fragments . sizes [ partition_idx ] , //<S2SV> pbi -> decrypt_cb , pbi -> decrypt_state ) ) //<S2SV> vpx_internal_error ( & pbi -> common . error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>%d" , //<S2SV> partition_idx ) ; //<S2SV> bool_decoder ++ ; //<S2SV> } //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( pbi -> decoding_thread_count > num_token_partitions - 1 ) { //<S2SV> pbi -> decoding_thread_count = num_token_partitions - 1 ; //<S2SV> } //<S2SV> if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { //<S2SV> pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> 