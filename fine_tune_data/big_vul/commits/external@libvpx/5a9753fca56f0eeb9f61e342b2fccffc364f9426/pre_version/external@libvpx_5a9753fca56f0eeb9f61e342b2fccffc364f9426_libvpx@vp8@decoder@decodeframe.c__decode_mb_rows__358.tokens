static void decode_mb_rows ( VP8D_COMP * pbi ) //<S2SV> { //<S2SV> VP8_COMMON * const pc = & pbi -> common ; //<S2SV> MACROBLOCKD * const xd = & pbi -> mb ; //<S2SV> MODE_INFO * lf_mic = xd -> mode_info_context ; //<S2SV> int ibc = 0 ; //<S2SV> int num_part = 1 << pc -> multi_token_partition ; //<S2SV> int recon_yoffset , recon_uvoffset ; //<S2SV> int mb_row , mb_col ; //<S2SV> int mb_idx = 0 ; //<S2SV> YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; //<S2SV> int recon_y_stride = yv12_fb_new -> y_stride ; //<S2SV> int recon_uv_stride = yv12_fb_new -> uv_stride ; //<S2SV> unsigned char * ref_buffer [ MAX_REF_FRAMES ] [ 3 ] ; //<S2SV> unsigned char * dst_buffer [ 3 ] ; //<S2SV> unsigned char * lf_dst [ 3 ] ; //<S2SV> unsigned char * eb_dst [ 3 ] ; //<S2SV> int i ; //<S2SV> int ref_fb_corrupted [ MAX_REF_FRAMES ] ; //<S2SV> ref_fb_corrupted [ INTRA_FRAME ] = 0 ; //<S2SV> for ( i = 1 ; i < MAX_REF_FRAMES ; i ++ ) //<S2SV> { //<S2SV> YV12_BUFFER_CONFIG * this_fb = pbi -> dec_fb_ref [ i ] ; //<S2SV> ref_buffer [ i ] [ 0 ] = this_fb -> y_buffer ; //<S2SV> ref_buffer [ i ] [ 1 ] = this_fb -> u_buffer ; //<S2SV> ref_buffer [ i ] [ 2 ] = this_fb -> v_buffer ; //<S2SV> ref_fb_corrupted [ i ] = this_fb -> corrupted ; //<S2SV> } //<S2SV> eb_dst [ 0 ] = lf_dst [ 0 ] = dst_buffer [ 0 ] = yv12_fb_new -> y_buffer ; //<S2SV> eb_dst [ 1 ] = lf_dst [ 1 ] = dst_buffer [ 1 ] = yv12_fb_new -> u_buffer ; //<S2SV> eb_dst [ 2 ] = lf_dst [ 2 ] = dst_buffer [ 2 ] = yv12_fb_new -> v_buffer ; //<S2SV> xd -> up_available = 0 ; //<S2SV> if ( pc -> filter_level ) //<S2SV> vp8_loop_filter_frame_init ( pc , xd , pc -> filter_level ) ; //<S2SV> vp8_setup_intra_recon_top_line ( yv12_fb_new ) ; //<S2SV> for ( mb_row = 0 ; mb_row < pc -> mb_rows ; mb_row ++ ) //<S2SV> { //<S2SV> if ( num_part > 1 ) //<S2SV> { //<S2SV> xd -> current_bc = & pbi -> mbc [ ibc ] ; //<S2SV> ibc ++ ; //<S2SV> if ( ibc == num_part ) //<S2SV> ibc = 0 ; //<S2SV> } //<S2SV> recon_yoffset = mb_row * recon_y_stride * 16 ; //<S2SV> recon_uvoffset = mb_row * recon_uv_stride * 8 ; //<S2SV> xd -> above_context = pc -> above_context ; //<S2SV> vpx_memset ( xd -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> xd -> left_available = 0 ; //<S2SV> xd -> mb_to_top_edge = - ( ( mb_row * 16 ) << 3 ) ; //<S2SV> xd -> mb_to_bottom_edge = ( ( pc -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; //<S2SV> xd -> recon_above [ 0 ] = dst_buffer [ 0 ] + recon_yoffset ; //<S2SV> xd -> recon_above [ 1 ] = dst_buffer [ 1 ] + recon_uvoffset ; //<S2SV> xd -> recon_above [ 2 ] = dst_buffer [ 2 ] + recon_uvoffset ; //<S2SV> xd -> recon_left [ 0 ] = xd -> recon_above [ 0 ] - 1 ; //<S2SV> xd -> recon_left [ 1 ] = xd -> recon_above [ 1 ] - 1 ; //<S2SV> xd -> recon_left [ 2 ] = xd -> recon_above [ 2 ] - 1 ; //<S2SV> xd -> recon_above [ 0 ] -= xd -> dst . y_stride ; //<S2SV> xd -> recon_above [ 1 ] -= xd -> dst . uv_stride ; //<S2SV> xd -> recon_above [ 2 ] -= xd -> dst . uv_stride ; //<S2SV> xd -> recon_left_stride [ 0 ] = xd -> dst . y_stride ; //<S2SV> xd -> recon_left_stride [ 1 ] = xd -> dst . uv_stride ; //<S2SV> setup_intra_recon_left ( xd -> recon_left [ 0 ] , xd -> recon_left [ 1 ] , //<S2SV> xd -> recon_left [ 2 ] , xd -> dst . y_stride , //<S2SV> xd -> dst . uv_stride ) ; //<S2SV> for ( mb_col = 0 ; mb_col < pc -> mb_cols ; mb_col ++ ) //<S2SV> { //<S2SV> xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; //<S2SV> xd -> mb_to_right_edge = ( ( pc -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> { //<S2SV> int corrupt_residual = ( ! pbi -> independent_partitions && //<S2SV> pbi -> frame_corrupt_residual ) || //<S2SV> vp8dx_bool_error ( xd -> current_bc ) ; //<S2SV> if ( pbi -> ec_active && //<S2SV> xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME && //<S2SV> corrupt_residual ) //<S2SV> { //<S2SV> vp8_interpolate_motion ( xd , //<S2SV> mb_row , mb_col , //<S2SV> pc -> mb_rows , pc -> mb_cols , //<S2SV> pc -> mode_info_stride ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> xd -> dst . y_buffer = dst_buffer [ 0 ] + recon_yoffset ; //<S2SV> xd -> dst . u_buffer = dst_buffer [ 1 ] + recon_uvoffset ; //<S2SV> xd -> dst . v_buffer = dst_buffer [ 2 ] + recon_uvoffset ; //<S2SV> xd -> pre . y_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 0 ] + recon_yoffset ; //<S2SV> xd -> pre . u_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 1 ] + recon_uvoffset ; //<S2SV> xd -> pre . v_buffer = ref_buffer [ xd -> mode_info_context -> mbmi . ref_frame ] [ 2 ] + recon_uvoffset ; //<S2SV> xd -> corrupted |= ref_fb_corrupted [ xd -> mode_info_context -> mbmi . ref_frame ] ; //<S2SV> decode_macroblock ( pbi , xd , mb_idx ) ; //<S2SV> mb_idx ++ ; //<S2SV> xd -> left_available = 1 ; //<S2SV> xd -> corrupted |= vp8dx_bool_error ( xd -> current_bc ) ; //<S2SV> xd -> recon_above [ 0 ] += 16 ; //<S2SV> xd -> recon_above [ 1 ] += 8 ; //<S2SV> xd -> recon_above [ 2 ] += 8 ; //<S2SV> xd -> recon_left [ 0 ] += 16 ; //<S2SV> xd -> recon_left [ 1 ] += 8 ; //<S2SV> xd -> recon_left [ 2 ] += 8 ; //<S2SV> recon_yoffset += 16 ; //<S2SV> recon_uvoffset += 8 ; //<S2SV> ++ xd -> mode_info_context ; //<S2SV> xd -> above_context ++ ; //<S2SV> } //<S2SV> vp8_extend_mb_row ( yv12_fb_new , xd -> dst . y_buffer + 16 , //<S2SV> xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; //<S2SV> ++ xd -> mode_info_context ; //<S2SV> xd -> up_available = 1 ; //<S2SV> if ( pc -> filter_level ) //<S2SV> { //<S2SV> if ( mb_row > 0 ) //<S2SV> { //<S2SV> if ( pc -> filter_type == NORMAL_LOOPFILTER ) //<S2SV> vp8_loop_filter_row_normal ( pc , lf_mic , mb_row - 1 , //<S2SV> recon_y_stride , recon_uv_stride , //<S2SV> lf_dst [ 0 ] , lf_dst [ 1 ] , lf_dst [ 2 ] ) ; //<S2SV> else //<S2SV> vp8_loop_filter_row_simple ( pc , lf_mic , mb_row - 1 , //<S2SV> recon_y_stride , recon_uv_stride , //<S2SV> lf_dst [ 0 ] , lf_dst [ 1 ] , lf_dst [ 2 ] ) ; //<S2SV> if ( mb_row > 1 ) //<S2SV> { //<S2SV> yv12_extend_frame_left_right_c ( yv12_fb_new , //<S2SV> eb_dst [ 0 ] , //<S2SV> eb_dst [ 1 ] , //<S2SV> eb_dst [ 2 ] ) ; //<S2SV> eb_dst [ 0 ] += recon_y_stride * 16 ; //<S2SV> eb_dst [ 1 ] += recon_uv_stride * 8 ; //<S2SV> eb_dst [ 2 ] += recon_uv_stride * 8 ; //<S2SV> } //<S2SV> lf_dst [ 0 ] += recon_y_stride * 16 ; //<S2SV> lf_dst [ 1 ] += recon_uv_stride * 8 ; //<S2SV> lf_dst [ 2 ] += recon_uv_stride * 8 ; //<S2SV> lf_mic += pc -> mb_cols ; //<S2SV> lf_mic ++ ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( mb_row > 0 ) //<S2SV> { //<S2SV> yv12_extend_frame_left_right_c ( yv12_fb_new , //<S2SV> eb_dst [ 0 ] , //<S2SV> eb_dst [ 1 ] , //<S2SV> eb_dst [ 2 ] ) ; //<S2SV> eb_dst [ 0 ] += recon_y_stride * 16 ; //<S2SV> eb_dst [ 1 ] += recon_uv_stride * 8 ; //<S2SV> eb_dst [ 2 ] += recon_uv_stride * 8 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( pc -> filter_level ) //<S2SV> { //<S2SV> if ( pc -> filter_type == NORMAL_LOOPFILTER ) //<S2SV> vp8_loop_filter_row_normal ( pc , lf_mic , mb_row - 1 , recon_y_stride , //<S2SV> recon_uv_stride , lf_dst [ 0 ] , lf_dst [ 1 ] , //<S2SV> lf_dst [ 2 ] ) ; //<S2SV> else //<S2SV> vp8_loop_filter_row_simple ( pc , lf_mic , mb_row - 1 , recon_y_stride , //<S2SV> recon_uv_stride , lf_dst [ 0 ] , lf_dst [ 1 ] , //<S2SV> lf_dst [ 2 ] ) ; //<S2SV> yv12_extend_frame_left_right_c ( yv12_fb_new , //<S2SV> eb_dst [ 0 ] , //<S2SV> eb_dst [ 1 ] , //<S2SV> eb_dst [ 2 ] ) ; //<S2SV> eb_dst [ 0 ] += recon_y_stride * 16 ; //<S2SV> eb_dst [ 1 ] += recon_uv_stride * 8 ; //<S2SV> eb_dst [ 2 ] += recon_uv_stride * 8 ; //<S2SV> } //<S2SV> yv12_extend_frame_left_right_c ( yv12_fb_new , //<S2SV> eb_dst [ 0 ] , //<S2SV> eb_dst [ 1 ] , //<S2SV> eb_dst [ 2 ] ) ; //<S2SV> yv12_extend_frame_top_c ( yv12_fb_new ) ; //<S2SV> yv12_extend_frame_bottom_c ( yv12_fb_new ) ; //<S2SV> } //<S2SV> 