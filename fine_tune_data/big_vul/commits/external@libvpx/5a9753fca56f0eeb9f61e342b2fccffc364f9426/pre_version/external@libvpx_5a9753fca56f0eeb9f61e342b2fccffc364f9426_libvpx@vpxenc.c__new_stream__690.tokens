static struct stream_state * new_stream ( struct VpxEncoderConfig * global , //<S2SV> struct stream_state * prev ) { //<S2SV> struct stream_state * stream ; //<S2SV> stream = calloc ( 1 , sizeof ( * stream ) ) ; //<S2SV> if ( ! stream ) //<S2SV> fatal ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream." ) ; //<S2SV> if ( prev ) { //<S2SV> memcpy ( stream , prev , sizeof ( * stream ) ) ; //<S2SV> stream -> index ++ ; //<S2SV> prev -> next = stream ; //<S2SV> } else { //<S2SV> vpx_codec_err_t res ; //<S2SV> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , //<S2SV> & stream -> config . cfg , //<S2SV> global -> usage ) ; //<S2SV> if ( res ) //<S2SV> fatal ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n" , vpx_codec_err_to_string ( res ) ) ; //<S2SV> stream -> config . cfg . g_timebase . den = 1000 ; //<S2SV> stream -> config . cfg . g_w = 0 ; //<S2SV> stream -> config . cfg . g_h = 0 ; //<S2SV> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; //<S2SV> stream -> config . write_webm = 1 ; //<S2SV> # if CONFIG_WEBM_IO //<S2SV> stream -> ebml . last_pts_ms = - 1 ; //<S2SV> # endif //<S2SV> stream -> ebml . debug = global -> debug ; //<S2SV> if ( global -> deadline == VPX_DL_REALTIME ) //<S2SV> stream -> config . cfg . g_lag_in_frames = 0 ; //<S2SV> } //<S2SV> stream -> config . out_fn = NULL ; //<S2SV> stream -> next = NULL ; //<S2SV> return stream ; //<S2SV> } //<S2SV> 