static vpx_codec_err_t decoder_peek_si ( const uint8_t * data , //<S2SV> unsigned int data_sz , //<S2SV> vpx_codec_stream_info_t * si ) { //<S2SV> if ( data_sz <= 8 ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( data + data_sz <= data ) //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> si -> is_kf = 0 ; //<S2SV> si -> w = si -> h = 0 ; //<S2SV> { //<S2SV> struct vp9_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; //<S2SV> const int frame_marker = vp9_rb_read_literal ( & rb , 2 ) ; //<S2SV> const int version = vp9_rb_read_bit ( & rb ) ; //<S2SV> ( void ) vp9_rb_read_bit ( & rb ) ; //<S2SV> if ( frame_marker != VP9_FRAME_MARKER ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( version > 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( vp9_rb_read_bit ( & rb ) ) { //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> si -> is_kf = ! vp9_rb_read_bit ( & rb ) ; //<S2SV> if ( si -> is_kf ) { //<S2SV> const int sRGB = 7 ; //<S2SV> int colorspace ; //<S2SV> rb . bit_offset += 1 ; //<S2SV> rb . bit_offset += 1 ; //<S2SV> if ( vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_0 || //<S2SV> vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_1 || //<S2SV> vp9_rb_read_literal ( & rb , 8 ) != VP9_SYNC_CODE_2 ) { //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> } //<S2SV> colorspace = vp9_rb_read_literal ( & rb , 3 ) ; //<S2SV> if ( colorspace != sRGB ) { //<S2SV> rb . bit_offset += 1 ; //<S2SV> if ( version == 1 ) { //<S2SV> rb . bit_offset += 2 ; //<S2SV> rb . bit_offset += 1 ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( version == 1 ) { //<S2SV> rb . bit_offset += 1 ; //<S2SV> } else { //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> } //<S2SV> } //<S2SV> si -> w = vp9_rb_read_literal ( & rb , 16 ) + 1 ; //<S2SV> si -> h = vp9_rb_read_literal ( & rb , 16 ) + 1 ; //<S2SV> } //<S2SV> } //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 