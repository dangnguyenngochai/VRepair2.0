static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , //<S2SV> const TileInfo * const tile , //<S2SV> BLOCK_SIZE bsize , //<S2SV> int mi_row , int mi_col , //<S2SV> int_mv * tmp_mv , int * rate_mv ) { //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> VP9_COMMON * cm = & cpi -> common ; //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; //<S2SV> int bestsme = INT_MAX ; //<S2SV> int further_steps , step_param ; //<S2SV> int sadpb = x -> sadperbit16 ; //<S2SV> MV mvp_full ; //<S2SV> int ref = mbmi -> ref_frame [ 0 ] ; //<S2SV> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; //<S2SV> int tmp_col_min = x -> mv_col_min ; //<S2SV> int tmp_col_max = x -> mv_col_max ; //<S2SV> int tmp_row_min = x -> mv_row_min ; //<S2SV> int tmp_row_max = x -> mv_row_max ; //<S2SV> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , //<S2SV> ref ) ; //<S2SV> MV pred_mv [ 3 ] ; //<S2SV> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; //<S2SV> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; //<S2SV> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; //<S2SV> if ( scaled_ref_frame ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) //<S2SV> backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ; //<S2SV> vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ; //<S2SV> } //<S2SV> vp9_set_mv_search_range ( x , & ref_mv ) ; //<S2SV> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { //<S2SV> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + //<S2SV> cpi -> mv_step_param ) >> 1 ; //<S2SV> } else { //<S2SV> step_param = cpi -> mv_step_param ; //<S2SV> } //<S2SV> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && //<S2SV> cpi -> common . show_frame ) { //<S2SV> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , //<S2SV> b_width_log2 ( bsize ) ) ) ; //<S2SV> step_param = MAX ( step_param , boffset ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . adaptive_motion_search ) { //<S2SV> int bwl = b_width_log2_lookup [ bsize ] ; //<S2SV> int bhl = b_height_log2_lookup [ bsize ] ; //<S2SV> int i ; //<S2SV> int tlevel = x -> pred_mv_sad [ ref ] >> ( bwl + bhl + 4 ) ; //<S2SV> if ( tlevel < 5 ) //<S2SV> step_param += 2 ; //<S2SV> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { //<S2SV> if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) { //<S2SV> x -> pred_mv [ ref ] . as_int = 0 ; //<S2SV> tmp_mv -> as_int = INVALID_MV ; //<S2SV> if ( scaled_ref_frame ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) //<S2SV> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; //<S2SV> } //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; //<S2SV> mvp_full . col >>= 3 ; //<S2SV> mvp_full . row >>= 3 ; //<S2SV> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; //<S2SV> if ( cpi -> sf . search_method == FAST_DIAMOND ) { //<S2SV> bestsme = vp9_fast_dia_search ( x , & mvp_full , step_param , sadpb , 0 , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 , //<S2SV> & ref_mv , & tmp_mv -> as_mv ) ; //<S2SV> if ( bestsme < INT_MAX ) //<S2SV> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 ) ; //<S2SV> } else if ( cpi -> sf . search_method == FAST_HEX ) { //<S2SV> bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 , //<S2SV> & ref_mv , & tmp_mv -> as_mv ) ; //<S2SV> if ( bestsme < INT_MAX ) //<S2SV> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 ) ; //<S2SV> } else if ( cpi -> sf . search_method == HEX ) { //<S2SV> bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 , //<S2SV> & ref_mv , & tmp_mv -> as_mv ) ; //<S2SV> if ( bestsme < INT_MAX ) //<S2SV> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 ) ; //<S2SV> } else if ( cpi -> sf . search_method == SQUARE ) { //<S2SV> bestsme = vp9_square_search ( x , & mvp_full , step_param , sadpb , 1 , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 , //<S2SV> & ref_mv , & tmp_mv -> as_mv ) ; //<S2SV> if ( bestsme < INT_MAX ) //<S2SV> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 ) ; //<S2SV> } else if ( cpi -> sf . search_method == BIGDIA ) { //<S2SV> bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 , //<S2SV> & ref_mv , & tmp_mv -> as_mv ) ; //<S2SV> if ( bestsme < INT_MAX ) //<S2SV> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , //<S2SV> & cpi -> fn_ptr [ bsize ] , 1 ) ; //<S2SV> } else { //<S2SV> bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , //<S2SV> sadpb , further_steps , 1 , //<S2SV> & cpi -> fn_ptr [ bsize ] , //<S2SV> & ref_mv , & tmp_mv -> as_mv ) ; //<S2SV> } //<S2SV> x -> mv_col_min = tmp_col_min ; //<S2SV> x -> mv_col_max = tmp_col_max ; //<S2SV> x -> mv_row_min = tmp_row_min ; //<S2SV> x -> mv_row_max = tmp_row_max ; //<S2SV> if ( bestsme < INT_MAX ) { //<S2SV> int dis ; //<S2SV> cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , //<S2SV> cm -> allow_high_precision_mv , //<S2SV> x -> errorperbit , //<S2SV> & cpi -> fn_ptr [ bsize ] , //<S2SV> cpi -> sf . subpel_force_stop , //<S2SV> cpi -> sf . subpel_iters_per_step , //<S2SV> x -> nmvjointcost , x -> mvcost , //<S2SV> & dis , & x -> pred_sse [ ref ] ) ; //<S2SV> } //<S2SV> * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , //<S2SV> x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; //<S2SV> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) //<S2SV> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; //<S2SV> if ( scaled_ref_frame ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) //<S2SV> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> 