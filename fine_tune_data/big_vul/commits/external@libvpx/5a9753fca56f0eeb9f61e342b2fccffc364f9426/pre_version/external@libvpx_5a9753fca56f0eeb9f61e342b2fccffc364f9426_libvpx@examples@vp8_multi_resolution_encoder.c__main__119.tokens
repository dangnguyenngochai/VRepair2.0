int main ( int argc , char * * argv ) //<S2SV> { //<S2SV> FILE * infile , * outfile [ NUM_ENCODERS ] ; //<S2SV> vpx_codec_ctx_t codec [ NUM_ENCODERS ] ; //<S2SV> vpx_codec_enc_cfg_t cfg [ NUM_ENCODERS ] ; //<S2SV> vpx_codec_pts_t frame_cnt = 0 ; //<S2SV> vpx_image_t raw [ NUM_ENCODERS ] ; //<S2SV> vpx_codec_err_t res [ NUM_ENCODERS ] ; //<S2SV> int i ; //<S2SV> long width ; //<S2SV> long height ; //<S2SV> int frame_avail ; //<S2SV> int got_data ; //<S2SV> int flags = 0 ; //<S2SV> int arg_deadline = VPX_DL_REALTIME ; //<S2SV> int show_psnr = 0 ; //<S2SV> uint64_t psnr_sse_total [ NUM_ENCODERS ] = { 0 } ; //<S2SV> uint64_t psnr_samples_total [ NUM_ENCODERS ] = { 0 } ; //<S2SV> double psnr_totals [ NUM_ENCODERS ] [ 4 ] = { { 0 , 0 } } ; //<S2SV> int psnr_count [ NUM_ENCODERS ] = { 0 } ; //<S2SV> unsigned int target_bitrate [ NUM_ENCODERS ] = { 1000 , 500 , 100 } ; //<S2SV> int framerate = 30 ; //<S2SV> vpx_rational_t dsf [ NUM_ENCODERS ] = { { 2 , 1 } , { 2 , 1 } , { 1 , 1 } } ; //<S2SV> if ( argc != ( 5 + NUM_ENCODERS ) ) //<S2SV> die ( "Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank><output<S2SV_blank>psnr?>\\n" , //<S2SV> argv [ 0 ] ) ; //<S2SV> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( interface ) ) ; //<S2SV> width = strtol ( argv [ 1 ] , NULL , 0 ) ; //<S2SV> height = strtol ( argv [ 2 ] , NULL , 0 ) ; //<S2SV> if ( width < 16 || width % 2 || height < 16 || height % 2 ) //<S2SV> die ( "Invalid<S2SV_blank>resolution:<S2SV_blank>%ldx%ld" , width , height ) ; //<S2SV> if ( ! ( infile = fopen ( argv [ 3 ] , "rb" ) ) ) //<S2SV> die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading" , argv [ 3 ] ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> if ( ! target_bitrate [ i ] ) //<S2SV> { //<S2SV> outfile [ i ] = NULL ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! ( outfile [ i ] = fopen ( argv [ i + 4 ] , "wb" ) ) ) //<S2SV> die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing" , argv [ i + 4 ] ) ; //<S2SV> } //<S2SV> show_psnr = strtol ( argv [ NUM_ENCODERS + 4 ] , NULL , 0 ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; //<S2SV> if ( res [ i ] ) { //<S2SV> printf ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n" , vpx_codec_err_to_string ( res [ i ] ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> cfg [ 0 ] . g_w = width ; //<S2SV> cfg [ 0 ] . g_h = height ; //<S2SV> cfg [ 0 ] . g_threads = 1 ; //<S2SV> cfg [ 0 ] . rc_dropframe_thresh = 30 ; //<S2SV> cfg [ 0 ] . rc_end_usage = VPX_CBR ; //<S2SV> cfg [ 0 ] . rc_resize_allowed = 0 ; //<S2SV> cfg [ 0 ] . rc_min_quantizer = 4 ; //<S2SV> cfg [ 0 ] . rc_max_quantizer = 56 ; //<S2SV> cfg [ 0 ] . rc_undershoot_pct = 98 ; //<S2SV> cfg [ 0 ] . rc_overshoot_pct = 100 ; //<S2SV> cfg [ 0 ] . rc_buf_initial_sz = 500 ; //<S2SV> cfg [ 0 ] . rc_buf_optimal_sz = 600 ; //<S2SV> cfg [ 0 ] . rc_buf_sz = 1000 ; //<S2SV> cfg [ 0 ] . g_error_resilient = 1 ; //<S2SV> cfg [ 0 ] . g_lag_in_frames = 0 ; //<S2SV> cfg [ 0 ] . kf_mode = VPX_KF_AUTO ; //<S2SV> cfg [ 0 ] . kf_min_dist = 3000 ; //<S2SV> cfg [ 0 ] . kf_max_dist = 3000 ; //<S2SV> cfg [ 0 ] . rc_target_bitrate = target_bitrate [ 0 ] ; //<S2SV> cfg [ 0 ] . g_timebase . num = 1 ; //<S2SV> cfg [ 0 ] . g_timebase . den = framerate ; //<S2SV> for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> memcpy ( & cfg [ i ] , & cfg [ 0 ] , sizeof ( vpx_codec_enc_cfg_t ) ) ; //<S2SV> cfg [ i ] . g_threads = 1 ; //<S2SV> cfg [ i ] . rc_target_bitrate = target_bitrate [ i ] ; //<S2SV> { //<S2SV> unsigned int iw = cfg [ i - 1 ] . g_w * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ; //<S2SV> unsigned int ih = cfg [ i - 1 ] . g_h * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ; //<S2SV> cfg [ i ] . g_w = iw / dsf [ i - 1 ] . num ; //<S2SV> cfg [ i ] . g_h = ih / dsf [ i - 1 ] . num ; //<S2SV> } //<S2SV> if ( ( cfg [ i ] . g_w ) % 2 ) cfg [ i ] . g_w ++ ; //<S2SV> if ( ( cfg [ i ] . g_h ) % 2 ) cfg [ i ] . g_h ++ ; //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> if ( ! vpx_img_alloc ( & raw [ i ] , VPX_IMG_FMT_I420 , cfg [ i ] . g_w , cfg [ i ] . g_h , 32 ) ) //<S2SV> die ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image" , cfg [ i ] . g_w , cfg [ i ] . g_h ) ; //<S2SV> if ( raw [ 0 ] . stride [ VPX_PLANE_Y ] == raw [ 0 ] . d_w ) //<S2SV> read_frame_p = read_frame ; //<S2SV> else //<S2SV> read_frame_p = read_frame_by_row ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> if ( outfile [ i ] ) //<S2SV> write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , 0 ) ; //<S2SV> if ( vpx_codec_enc_init_multi ( & codec [ 0 ] , interface , & cfg [ 0 ] , NUM_ENCODERS , //<S2SV> ( show_psnr ? VPX_CODEC_USE_PSNR : 0 ) , & dsf [ 0 ] ) ) //<S2SV> die_codec ( & codec [ 0 ] , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder" ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> int speed = - 6 ; //<S2SV> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_CPUUSED , speed ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>cpu_used" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> unsigned int static_thresh = 1 ; //<S2SV> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , static_thresh ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold" ) ; //<S2SV> } //<S2SV> if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) //<S2SV> die_codec ( & codec [ 0 ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity" ) ; //<S2SV> for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity" ) ; //<S2SV> } //<S2SV> frame_avail = 1 ; //<S2SV> got_data = 0 ; //<S2SV> while ( frame_avail || got_data ) //<S2SV> { //<S2SV> vpx_codec_iter_t iter [ NUM_ENCODERS ] = { NULL } ; //<S2SV> const vpx_codec_cx_pkt_t * pkt [ NUM_ENCODERS ] ; //<S2SV> flags = 0 ; //<S2SV> frame_avail = read_frame_p ( infile , & raw [ 0 ] ) ; //<S2SV> if ( frame_avail ) //<S2SV> { //<S2SV> for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> I420Scale ( raw [ i - 1 ] . planes [ VPX_PLANE_Y ] , raw [ i - 1 ] . stride [ VPX_PLANE_Y ] , //<S2SV> raw [ i - 1 ] . planes [ VPX_PLANE_U ] , raw [ i - 1 ] . stride [ VPX_PLANE_U ] , //<S2SV> raw [ i - 1 ] . planes [ VPX_PLANE_V ] , raw [ i - 1 ] . stride [ VPX_PLANE_V ] , //<S2SV> raw [ i - 1 ] . d_w , raw [ i - 1 ] . d_h , //<S2SV> raw [ i ] . planes [ VPX_PLANE_Y ] , raw [ i ] . stride [ VPX_PLANE_Y ] , //<S2SV> raw [ i ] . planes [ VPX_PLANE_U ] , raw [ i ] . stride [ VPX_PLANE_U ] , //<S2SV> raw [ i ] . planes [ VPX_PLANE_V ] , raw [ i ] . stride [ VPX_PLANE_V ] , //<S2SV> raw [ i ] . d_w , raw [ i ] . d_h , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( vpx_codec_encode ( & codec [ 0 ] , frame_avail ? & raw [ 0 ] : NULL , //<S2SV> frame_cnt , 1 , flags , arg_deadline ) ) //<S2SV> die_codec ( & codec [ 0 ] , "Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame" ) ; //<S2SV> for ( i = NUM_ENCODERS - 1 ; i >= 0 ; i -- ) //<S2SV> { //<S2SV> got_data = 0 ; //<S2SV> while ( ( pkt [ i ] = vpx_codec_get_cx_data ( & codec [ i ] , & iter [ i ] ) ) ) //<S2SV> { //<S2SV> got_data = 1 ; //<S2SV> switch ( pkt [ i ] -> kind ) { //<S2SV> case VPX_CODEC_CX_FRAME_PKT : //<S2SV> write_ivf_frame_header ( outfile [ i ] , pkt [ i ] ) ; //<S2SV> ( void ) fwrite ( pkt [ i ] -> data . frame . buf , 1 , //<S2SV> pkt [ i ] -> data . frame . sz , outfile [ i ] ) ; //<S2SV> break ; //<S2SV> case VPX_CODEC_PSNR_PKT : //<S2SV> if ( show_psnr ) //<S2SV> { //<S2SV> int j ; //<S2SV> psnr_sse_total [ i ] += pkt [ i ] -> data . psnr . sse [ 0 ] ; //<S2SV> psnr_samples_total [ i ] += pkt [ i ] -> data . psnr . samples [ 0 ] ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) //<S2SV> { //<S2SV> psnr_totals [ i ] [ j ] += pkt [ i ] -> data . psnr . psnr [ j ] ; //<S2SV> } //<S2SV> psnr_count [ i ] ++ ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> printf ( pkt [ i ] -> kind == VPX_CODEC_CX_FRAME_PKT //<S2SV> && ( pkt [ i ] -> data . frame . flags & VPX_FRAME_IS_KEY ) ? "K" : "." ) ; //<S2SV> fflush ( stdout ) ; //<S2SV> } //<S2SV> } //<S2SV> frame_cnt ++ ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> fclose ( infile ) ; //<S2SV> printf ( "Processed<S2SV_blank>%ld<S2SV_blank>frames.\\n" , ( long int ) frame_cnt - 1 ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> if ( ( show_psnr ) && ( psnr_count [ i ] > 0 ) ) //<S2SV> { //<S2SV> int j ; //<S2SV> double ovpsnr = sse_to_psnr ( psnr_samples_total [ i ] , 255.0 , //<S2SV> psnr_sse_total [ i ] ) ; //<S2SV> fprintf ( stderr , "\\n<S2SV_blank>ENC%d<S2SV_blank>PSNR<S2SV_blank>(Overall/Avg/Y/U/V)" , i ) ; //<S2SV> fprintf ( stderr , "<S2SV_blank>%.3lf" , ovpsnr ) ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) //<S2SV> { //<S2SV> fprintf ( stderr , "<S2SV_blank>%.3lf" , psnr_totals [ i ] [ j ] / psnr_count [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( vpx_codec_destroy ( & codec [ i ] ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec" ) ; //<S2SV> vpx_img_free ( & raw [ i ] ) ; //<S2SV> if ( ! outfile [ i ] ) //<S2SV> continue ; //<S2SV> if ( ! fseek ( outfile [ i ] , 0 , SEEK_SET ) ) //<S2SV> write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , frame_cnt - 1 ) ; //<S2SV> fclose ( outfile [ i ] ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> return EXIT_SUCCESS ; //<S2SV> } //<S2SV> 