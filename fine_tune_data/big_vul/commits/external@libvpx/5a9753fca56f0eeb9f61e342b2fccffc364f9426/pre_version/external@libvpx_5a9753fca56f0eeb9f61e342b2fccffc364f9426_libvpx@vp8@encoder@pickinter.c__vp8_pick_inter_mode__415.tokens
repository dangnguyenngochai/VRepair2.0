void vp8_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , //<S2SV> int recon_uvoffset , int * returnrate , //<S2SV> int * returndistortion , int * returnintra , int mb_row , //<S2SV> int mb_col ) //<S2SV> { //<S2SV> BLOCK * b = & x -> block [ 0 ] ; //<S2SV> BLOCKD * d = & x -> e_mbd . block [ 0 ] ; //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO best_mbmode ; //<S2SV> int_mv best_ref_mv_sb [ 2 ] ; //<S2SV> int_mv mode_mv_sb [ 2 ] [ MB_MODE_COUNT ] ; //<S2SV> int_mv best_ref_mv ; //<S2SV> int_mv * mode_mv ; //<S2SV> MB_PREDICTION_MODE this_mode ; //<S2SV> int num00 ; //<S2SV> int mdcounts [ 4 ] ; //<S2SV> int best_rd = INT_MAX ; //<S2SV> int rd_adjustment = 100 ; //<S2SV> int best_intra_rd = INT_MAX ; //<S2SV> int mode_index ; //<S2SV> int rate ; //<S2SV> int rate2 ; //<S2SV> int distortion2 ; //<S2SV> int bestsme = INT_MAX ; //<S2SV> int best_mode_index = 0 ; //<S2SV> unsigned int sse = INT_MAX , best_rd_sse = INT_MAX ; //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ; //<S2SV> # endif //<S2SV> int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ; //<S2SV> int_mv mvp ; //<S2SV> int near_sadidx [ 8 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; //<S2SV> int saddone = 0 ; //<S2SV> int sr = 0 ; //<S2SV> unsigned char * plane [ 4 ] [ 3 ] ; //<S2SV> int ref_frame_map [ 4 ] ; //<S2SV> int sign_bias = 0 ; //<S2SV> # if CONFIG_MULTI_RES_ENCODING //<S2SV> int dissim = INT_MAX ; //<S2SV> int parent_ref_frame = 0 ; //<S2SV> int parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail ; //<S2SV> int_mv parent_ref_mv ; //<S2SV> MB_PREDICTION_MODE parent_mode = 0 ; //<S2SV> if ( parent_ref_valid ) //<S2SV> { //<S2SV> int parent_ref_flag ; //<S2SV> get_lower_res_motion_info ( cpi , xd , & dissim , & parent_ref_frame , //<S2SV> & parent_mode , & parent_ref_mv , mb_row , mb_col ) ; //<S2SV> parent_ref_flag = 0 ; //<S2SV> if ( parent_ref_frame == LAST_FRAME ) //<S2SV> parent_ref_flag = ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ; //<S2SV> else if ( parent_ref_frame == GOLDEN_FRAME ) //<S2SV> parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ; //<S2SV> else if ( parent_ref_frame == ALTREF_FRAME ) //<S2SV> parent_ref_flag = ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ; //<S2SV> if ( parent_ref_frame && ! parent_ref_flag ) //<S2SV> parent_ref_valid = 0 ; //<S2SV> } //<S2SV> # endif //<S2SV> mode_mv = mode_mv_sb [ sign_bias ] ; //<S2SV> best_ref_mv . as_int = 0 ; //<S2SV> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; //<S2SV> vpx_memset ( & best_mbmode , 0 , sizeof ( best_mbmode ) ) ; //<S2SV> # if CONFIG_MULTI_RES_ENCODING //<S2SV> if ( parent_ref_valid && parent_ref_frame && dissim < 8 ) //<S2SV> { //<S2SV> ref_frame_map [ 0 ] = - 1 ; //<S2SV> ref_frame_map [ 1 ] = parent_ref_frame ; //<S2SV> ref_frame_map [ 2 ] = - 1 ; //<S2SV> ref_frame_map [ 3 ] = - 1 ; //<S2SV> } else //<S2SV> # endif //<S2SV> get_reference_search_order ( cpi , ref_frame_map ) ; //<S2SV> if ( ref_frame_map [ 1 ] > 0 ) //<S2SV> { //<S2SV> sign_bias = vp8_find_near_mvs_bias ( & x -> e_mbd , //<S2SV> x -> e_mbd . mode_info_context , //<S2SV> mode_mv_sb , //<S2SV> best_ref_mv_sb , //<S2SV> mdcounts , //<S2SV> ref_frame_map [ 1 ] , //<S2SV> cpi -> common . ref_frame_sign_bias ) ; //<S2SV> mode_mv = mode_mv_sb [ sign_bias ] ; //<S2SV> best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; //<S2SV> } //<S2SV> get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; //<S2SV> x -> mbs_tested_so_far ++ ; //<S2SV> * returnintra = INT_MAX ; //<S2SV> x -> skip = 0 ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; //<S2SV> calculate_zeromv_rd_adjustment ( cpi , x , & rd_adjustment ) ; //<S2SV> for ( mode_index = 0 ; mode_index < MAX_MODES ; mode_index ++ ) //<S2SV> { //<S2SV> int frame_cost ; //<S2SV> int this_rd = INT_MAX ; //<S2SV> int this_ref_frame = ref_frame_map [ vp8_ref_frame_order [ mode_index ] ] ; //<S2SV> if ( best_rd <= x -> rd_threshes [ mode_index ] ) //<S2SV> continue ; //<S2SV> if ( this_ref_frame < 0 ) //<S2SV> continue ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; //<S2SV> if ( x -> e_mbd . mode_info_context -> mbmi . ref_frame ) //<S2SV> { //<S2SV> x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; //<S2SV> x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; //<S2SV> x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; //<S2SV> if ( sign_bias != cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ) //<S2SV> { //<S2SV> sign_bias = cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ; //<S2SV> mode_mv = mode_mv_sb [ sign_bias ] ; //<S2SV> best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; //<S2SV> } //<S2SV> # if CONFIG_MULTI_RES_ENCODING //<S2SV> if ( parent_ref_valid ) //<S2SV> { //<S2SV> if ( vp8_mode_order [ mode_index ] == NEARESTMV && //<S2SV> mode_mv [ NEARESTMV ] . as_int == 0 ) //<S2SV> continue ; //<S2SV> if ( vp8_mode_order [ mode_index ] == NEARMV && //<S2SV> mode_mv [ NEARMV ] . as_int == 0 ) //<S2SV> continue ; //<S2SV> if ( vp8_mode_order [ mode_index ] == NEWMV && parent_mode == ZEROMV //<S2SV> && best_ref_mv . as_int == 0 ) //<S2SV> continue ; //<S2SV> else if ( vp8_mode_order [ mode_index ] == NEWMV && dissim == 0 //<S2SV> && best_ref_mv . as_int == parent_ref_mv . as_int ) //<S2SV> continue ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> if ( x -> mode_test_hit_counts [ mode_index ] && //<S2SV> ( cpi -> mode_check_freq [ mode_index ] > 1 ) ) //<S2SV> { //<S2SV> if ( x -> mbs_tested_so_far <= ( cpi -> mode_check_freq [ mode_index ] * //<S2SV> x -> mode_test_hit_counts [ mode_index ] ) ) //<S2SV> { //<S2SV> x -> rd_thresh_mult [ mode_index ] += 4 ; //<S2SV> if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) //<S2SV> x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; //<S2SV> x -> rd_threshes [ mode_index ] = //<S2SV> ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * //<S2SV> x -> rd_thresh_mult [ mode_index ] ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> x -> mode_test_hit_counts [ mode_index ] ++ ; //<S2SV> rate2 = 0 ; //<S2SV> distortion2 = 0 ; //<S2SV> this_mode = vp8_mode_order [ mode_index ] ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mode = this_mode ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; //<S2SV> frame_cost = //<S2SV> x -> ref_frame_cost [ x -> e_mbd . mode_info_context -> mbmi . ref_frame ] ; //<S2SV> rate2 += frame_cost ; //<S2SV> if ( cpi -> is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) //<S2SV> { //<S2SV> if ( this_mode != ZEROMV || //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame != ALTREF_FRAME ) //<S2SV> continue ; //<S2SV> } //<S2SV> switch ( this_mode ) //<S2SV> { //<S2SV> case B_PRED : //<S2SV> distortion2 = best_rd_sse ; //<S2SV> pick_intra4x4mby_modes ( x , & rate , & distortion2 ) ; //<S2SV> if ( distortion2 == INT_MAX ) //<S2SV> { //<S2SV> this_rd = INT_MAX ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> rate2 += rate ; //<S2SV> distortion2 = vp8_variance16x16 ( //<S2SV> * ( b -> base_src ) , b -> src_stride , //<S2SV> x -> e_mbd . predictor , 16 , & sse ) ; //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; //<S2SV> if ( this_rd < best_intra_rd ) //<S2SV> { //<S2SV> best_intra_rd = this_rd ; //<S2SV> * returnintra = distortion2 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case SPLITMV : //<S2SV> break ; //<S2SV> case DC_PRED : //<S2SV> case V_PRED : //<S2SV> case H_PRED : //<S2SV> case TM_PRED : //<S2SV> vp8_build_intra_predictors_mby_s ( xd , //<S2SV> xd -> dst . y_buffer - xd -> dst . y_stride , //<S2SV> xd -> dst . y_buffer - 1 , //<S2SV> xd -> dst . y_stride , //<S2SV> xd -> predictor , //<S2SV> 16 ) ; //<S2SV> distortion2 = vp8_variance16x16 //<S2SV> ( * ( b -> base_src ) , b -> src_stride , //<S2SV> x -> e_mbd . predictor , 16 , & sse ) ; //<S2SV> rate2 += x -> mbmode_cost [ x -> e_mbd . frame_type ] [ x -> e_mbd . mode_info_context -> mbmi . mode ] ; //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; //<S2SV> if ( this_rd < best_intra_rd ) //<S2SV> { //<S2SV> best_intra_rd = this_rd ; //<S2SV> * returnintra = distortion2 ; //<S2SV> } //<S2SV> break ; //<S2SV> case NEWMV : //<S2SV> { //<S2SV> int thissme ; //<S2SV> int step_param ; //<S2SV> int further_steps ; //<S2SV> int n = 0 ; //<S2SV> int sadpb = x -> sadperbit16 ; //<S2SV> int_mv mvp_full ; //<S2SV> int col_min = ( ( best_ref_mv . as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; //<S2SV> int row_min = ( ( best_ref_mv . as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; //<S2SV> int col_max = ( best_ref_mv . as_mv . col >> 3 ) //<S2SV> + MAX_FULL_PEL_VAL ; //<S2SV> int row_max = ( best_ref_mv . as_mv . row >> 3 ) //<S2SV> + MAX_FULL_PEL_VAL ; //<S2SV> int tmp_col_min = x -> mv_col_min ; //<S2SV> int tmp_col_max = x -> mv_col_max ; //<S2SV> int tmp_row_min = x -> mv_row_min ; //<S2SV> int tmp_row_max = x -> mv_row_max ; //<S2SV> int speed_adjust = ( cpi -> Speed > 5 ) ? ( ( cpi -> Speed >= 8 ) ? 3 : 2 ) : 1 ; //<S2SV> step_param = cpi -> sf . first_step + speed_adjust ; //<S2SV> # if CONFIG_MULTI_RES_ENCODING //<S2SV> if ( cpi -> oxcf . mr_encoder_id && ! parent_ref_valid ) //<S2SV> sf_improved_mv_pred = 0 ; //<S2SV> if ( parent_ref_valid && parent_ref_frame ) //<S2SV> { //<S2SV> mvp . as_int = parent_ref_mv . as_int ; //<S2SV> mvp_full . as_mv . col = parent_ref_mv . as_mv . col >> 3 ; //<S2SV> mvp_full . as_mv . row = parent_ref_mv . as_mv . row >> 3 ; //<S2SV> if ( dissim <= 32 ) step_param += 3 ; //<S2SV> else if ( dissim <= 128 ) step_param += 2 ; //<S2SV> else step_param += 1 ; //<S2SV> } else //<S2SV> # endif //<S2SV> { //<S2SV> if ( sf_improved_mv_pred ) //<S2SV> { //<S2SV> if ( ! saddone ) //<S2SV> { //<S2SV> vp8_cal_sad ( cpi , xd , x , recon_yoffset , & near_sadidx [ 0 ] ) ; //<S2SV> saddone = 1 ; //<S2SV> } //<S2SV> vp8_mv_pred ( cpi , & x -> e_mbd , x -> e_mbd . mode_info_context , //<S2SV> & mvp , x -> e_mbd . mode_info_context -> mbmi . ref_frame , //<S2SV> cpi -> common . ref_frame_sign_bias , & sr , //<S2SV> & near_sadidx [ 0 ] ) ; //<S2SV> sr += speed_adjust ; //<S2SV> if ( sr > step_param ) //<S2SV> step_param = sr ; //<S2SV> mvp_full . as_mv . col = mvp . as_mv . col >> 3 ; //<S2SV> mvp_full . as_mv . row = mvp . as_mv . row >> 3 ; //<S2SV> } else //<S2SV> { //<S2SV> mvp . as_int = best_ref_mv . as_int ; //<S2SV> mvp_full . as_mv . col = best_ref_mv . as_mv . col >> 3 ; //<S2SV> mvp_full . as_mv . row = best_ref_mv . as_mv . row >> 3 ; //<S2SV> } //<S2SV> } //<S2SV> # if CONFIG_MULTI_RES_ENCODING //<S2SV> if ( parent_ref_valid && parent_ref_frame && dissim <= 2 && //<S2SV> MAX ( abs ( best_ref_mv . as_mv . row - parent_ref_mv . as_mv . row ) , //<S2SV> abs ( best_ref_mv . as_mv . col - parent_ref_mv . as_mv . col ) ) <= 4 ) //<S2SV> { //<S2SV> d -> bmi . mv . as_int = mvp_full . as_int ; //<S2SV> mode_mv [ NEWMV ] . as_int = mvp_full . as_int ; //<S2SV> cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , //<S2SV> x -> errorperbit , //<S2SV> & cpi -> fn_ptr [ BLOCK_16X16 ] , //<S2SV> cpi -> mb . mvcost , //<S2SV> & distortion2 , & sse ) ; //<S2SV> } else //<S2SV> # endif //<S2SV> { //<S2SV> if ( x -> mv_col_min < col_min ) //<S2SV> x -> mv_col_min = col_min ; //<S2SV> if ( x -> mv_col_max > col_max ) //<S2SV> x -> mv_col_max = col_max ; //<S2SV> if ( x -> mv_row_min < row_min ) //<S2SV> x -> mv_row_min = row_min ; //<S2SV> if ( x -> mv_row_max > row_max ) //<S2SV> x -> mv_row_max = row_max ; //<S2SV> further_steps = ( cpi -> Speed >= 8 ) ? //<S2SV> 0 : ( cpi -> sf . max_step_search_steps - 1 - step_param ) ; //<S2SV> if ( cpi -> sf . search_method == HEX ) //<S2SV> { //<S2SV> # if CONFIG_MULTI_RES_ENCODING //<S2SV> if ( ! parent_ref_valid ) //<S2SV> step_param = 0 ; //<S2SV> # endif //<S2SV> bestsme = vp8_hex_search ( x , b , d , & mvp_full , & d -> bmi . mv , //<S2SV> step_param , sadpb , //<S2SV> & cpi -> fn_ptr [ BLOCK_16X16 ] , //<S2SV> x -> mvsadcost , x -> mvcost , & best_ref_mv ) ; //<S2SV> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> bestsme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , //<S2SV> & d -> bmi . mv , step_param , sadpb , & num00 , //<S2SV> & cpi -> fn_ptr [ BLOCK_16X16 ] , //<S2SV> x -> mvcost , & best_ref_mv ) ; //<S2SV> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; //<S2SV> n = num00 ; //<S2SV> num00 = 0 ; //<S2SV> while ( n < further_steps ) //<S2SV> { //<S2SV> n ++ ; //<S2SV> if ( num00 ) //<S2SV> num00 -- ; //<S2SV> else //<S2SV> { //<S2SV> thissme = //<S2SV> cpi -> diamond_search_sad ( x , b , d , & mvp_full , //<S2SV> & d -> bmi . mv , //<S2SV> step_param + n , //<S2SV> sadpb , & num00 , //<S2SV> & cpi -> fn_ptr [ BLOCK_16X16 ] , //<S2SV> x -> mvcost , & best_ref_mv ) ; //<S2SV> if ( thissme < bestsme ) //<S2SV> { //<S2SV> bestsme = thissme ; //<S2SV> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> x -> mv_col_min = tmp_col_min ; //<S2SV> x -> mv_col_max = tmp_col_max ; //<S2SV> x -> mv_row_min = tmp_row_min ; //<S2SV> x -> mv_row_max = tmp_row_max ; //<S2SV> if ( bestsme < INT_MAX ) //<S2SV> cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , //<S2SV> & best_ref_mv , x -> errorperbit , //<S2SV> & cpi -> fn_ptr [ BLOCK_16X16 ] , //<S2SV> cpi -> mb . mvcost , //<S2SV> & distortion2 , & sse ) ; //<S2SV> } //<S2SV> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; //<S2SV> rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , //<S2SV> cpi -> mb . mvcost , 128 ) ; //<S2SV> } //<S2SV> case NEARESTMV : //<S2SV> case NEARMV : //<S2SV> if ( mode_mv [ this_mode ] . as_int == 0 ) //<S2SV> continue ; //<S2SV> case ZEROMV : //<S2SV> if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || //<S2SV> ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || //<S2SV> ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || //<S2SV> ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) //<S2SV> continue ; //<S2SV> rate2 += vp8_cost_mv_ref ( this_mode , mdcounts ) ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = //<S2SV> mode_mv [ this_mode ] . as_int ; //<S2SV> this_rd = evaluate_inter_mode ( & sse , rate2 , & distortion2 , cpi , x , //<S2SV> rd_adjustment ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> if ( cpi -> oxcf . noise_sensitivity ) //<S2SV> { //<S2SV> if ( this_mode == ZEROMV && sse < zero_mv_sse ) //<S2SV> { //<S2SV> zero_mv_sse = sse ; //<S2SV> x -> best_zeromv_reference_frame = //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame ; //<S2SV> } //<S2SV> if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && //<S2SV> sse < best_sse ) //<S2SV> { //<S2SV> best_sse = sse ; //<S2SV> x -> best_sse_inter_mode = NEWMV ; //<S2SV> x -> best_sse_mv = x -> e_mbd . mode_info_context -> mbmi . mv ; //<S2SV> x -> need_to_clamp_best_mvs = //<S2SV> x -> e_mbd . mode_info_context -> mbmi . need_to_clamp_mvs ; //<S2SV> x -> best_reference_frame = //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( this_rd < best_rd || x -> skip ) //<S2SV> { //<S2SV> best_mode_index = mode_index ; //<S2SV> * returnrate = rate2 ; //<S2SV> * returndistortion = distortion2 ; //<S2SV> best_rd_sse = sse ; //<S2SV> best_rd = this_rd ; //<S2SV> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , //<S2SV> sizeof ( MB_MODE_INFO ) ) ; //<S2SV> x -> rd_thresh_mult [ mode_index ] = //<S2SV> ( x -> rd_thresh_mult [ mode_index ] >= ( MIN_THRESHMULT + 2 ) ) ? //<S2SV> x -> rd_thresh_mult [ mode_index ] - 2 : MIN_THRESHMULT ; //<S2SV> x -> rd_threshes [ mode_index ] = //<S2SV> ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * //<S2SV> x -> rd_thresh_mult [ mode_index ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> x -> rd_thresh_mult [ mode_index ] += 4 ; //<S2SV> if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) //<S2SV> x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; //<S2SV> x -> rd_threshes [ mode_index ] = //<S2SV> ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * //<S2SV> x -> rd_thresh_mult [ mode_index ] ; //<S2SV> } //<S2SV> if ( x -> skip ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( cpi -> rd_baseline_thresh [ best_mode_index ] > 0 ) && ( cpi -> rd_baseline_thresh [ best_mode_index ] < ( INT_MAX >> 2 ) ) ) //<S2SV> { //<S2SV> int best_adjustment = ( x -> rd_thresh_mult [ best_mode_index ] >> 3 ) ; //<S2SV> x -> rd_thresh_mult [ best_mode_index ] = //<S2SV> ( x -> rd_thresh_mult [ best_mode_index ] //<S2SV> >= ( MIN_THRESHMULT + best_adjustment ) ) ? //<S2SV> x -> rd_thresh_mult [ best_mode_index ] - best_adjustment : //<S2SV> MIN_THRESHMULT ; //<S2SV> x -> rd_threshes [ best_mode_index ] = //<S2SV> ( cpi -> rd_baseline_thresh [ best_mode_index ] >> 7 ) * //<S2SV> x -> rd_thresh_mult [ best_mode_index ] ; //<S2SV> } //<S2SV> { //<S2SV> int this_rdbin = ( * returndistortion >> 7 ) ; //<S2SV> if ( this_rdbin >= 1024 ) //<S2SV> { //<S2SV> this_rdbin = 1023 ; //<S2SV> } //<S2SV> x -> error_bins [ this_rdbin ] ++ ; //<S2SV> } //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> if ( cpi -> oxcf . noise_sensitivity ) //<S2SV> { //<S2SV> if ( x -> best_sse_inter_mode == DC_PRED ) //<S2SV> { //<S2SV> x -> best_sse_inter_mode = best_mbmode . mode ; //<S2SV> x -> best_sse_mv = best_mbmode . mv ; //<S2SV> x -> need_to_clamp_best_mvs = best_mbmode . need_to_clamp_mvs ; //<S2SV> x -> best_reference_frame = best_mbmode . ref_frame ; //<S2SV> best_sse = best_rd_sse ; //<S2SV> } //<S2SV> vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , //<S2SV> recon_yoffset , recon_uvoffset ) ; //<S2SV> if ( best_mbmode . ref_frame == INTRA_FRAME && //<S2SV> x -> best_zeromv_reference_frame != INTRA_FRAME ) //<S2SV> { //<S2SV> int this_rd = 0 ; //<S2SV> int this_ref_frame = x -> best_zeromv_reference_frame ; //<S2SV> rate2 = x -> ref_frame_cost [ this_ref_frame ] + //<S2SV> vp8_cost_mv_ref ( ZEROMV , mdcounts ) ; //<S2SV> distortion2 = 0 ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; //<S2SV> x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; //<S2SV> x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; //<S2SV> x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; //<S2SV> this_rd = evaluate_inter_mode ( & sse , rate2 , & distortion2 , cpi , x , //<S2SV> rd_adjustment ) ; //<S2SV> if ( this_rd < best_rd ) //<S2SV> { //<S2SV> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , //<S2SV> sizeof ( MB_MODE_INFO ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( cpi -> is_src_frame_alt_ref && //<S2SV> ( best_mbmode . mode != ZEROMV || best_mbmode . ref_frame != ALTREF_FRAME ) ) //<S2SV> { //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame = ALTREF_FRAME ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mb_skip_coeff = //<S2SV> ( cpi -> common . mb_no_coeff_skip ) ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . partitioning = 0 ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! x -> skip ) //<S2SV> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , //<S2SV> sizeof ( MB_MODE_INFO ) ) ; //<S2SV> if ( best_mbmode . mode <= B_PRED ) //<S2SV> { //<S2SV> pick_intra_mbuv_mode ( x ) ; //<S2SV> } //<S2SV> if ( sign_bias //<S2SV> != cpi -> common . ref_frame_sign_bias [ xd -> mode_info_context -> mbmi . ref_frame ] ) //<S2SV> best_ref_mv . as_int = best_ref_mv_sb [ ! sign_bias ] . as_int ; //<S2SV> update_mvcount ( x , & best_ref_mv ) ; //<S2SV> } //<S2SV> 