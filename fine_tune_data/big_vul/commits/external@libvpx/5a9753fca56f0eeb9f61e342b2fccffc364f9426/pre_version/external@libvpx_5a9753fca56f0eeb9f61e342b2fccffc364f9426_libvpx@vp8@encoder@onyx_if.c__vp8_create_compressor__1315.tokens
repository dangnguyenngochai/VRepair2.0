struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) //<S2SV> { //<S2SV> int i ; //<S2SV> VP8_COMP * cpi ; //<S2SV> VP8_COMMON * cm ; //<S2SV> cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; //<S2SV> if ( ! cpi ) //<S2SV> return 0 ; //<S2SV> cm = & cpi -> common ; //<S2SV> vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; //<S2SV> if ( setjmp ( cm -> error . jmp ) ) //<S2SV> { //<S2SV> cpi -> common . error . setjmp = 0 ; //<S2SV> vp8_remove_compressor ( & cpi ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> cpi -> common . error . setjmp = 1 ; //<S2SV> CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; //<S2SV> vp8_create_common ( & cpi -> common ) ; //<S2SV> init_config ( cpi , oxcf ) ; //<S2SV> memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; //<S2SV> cpi -> common . current_video_frame = 0 ; //<S2SV> cpi -> temporal_pattern_counter = 0 ; //<S2SV> cpi -> kf_overspend_bits = 0 ; //<S2SV> cpi -> kf_bitrate_adjustment = 0 ; //<S2SV> cpi -> frames_till_gf_update_due = 0 ; //<S2SV> cpi -> gf_overspend_bits = 0 ; //<S2SV> cpi -> non_gf_bitrate_adjustment = 0 ; //<S2SV> cpi -> prob_last_coded = 128 ; //<S2SV> cpi -> prob_gf_coded = 128 ; //<S2SV> cpi -> prob_intra_coded = 63 ; //<S2SV> cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; //<S2SV> cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; //<S2SV> cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; //<S2SV> cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; //<S2SV> cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; //<S2SV> cpi -> twopass . gf_decay_rate = 0 ; //<S2SV> cpi -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; //<S2SV> cpi -> gold_is_last = 0 ; //<S2SV> cpi -> alt_is_last = 0 ; //<S2SV> cpi -> gold_is_alt = 0 ; //<S2SV> cpi -> active_map_enabled = 0 ; //<S2SV> # if 0 //<S2SV> if ( cpi -> pass == 0 ) //<S2SV> { //<S2SV> cpi -> one_pass_frame_index = 0 ; //<S2SV> for ( i = 0 ; i < MAX_LAG_BUFFERS ; i ++ ) //<S2SV> { //<S2SV> cpi -> one_pass_frame_stats [ i ] . frames_so_far = 0 ; //<S2SV> cpi -> one_pass_frame_stats [ i ] . frame_intra_error = 0.0 ; //<S2SV> cpi -> one_pass_frame_stats [ i ] . frame_coded_error = 0.0 ; //<S2SV> cpi -> one_pass_frame_stats [ i ] . frame_pcnt_inter = 0.0 ; //<S2SV> cpi -> one_pass_frame_stats [ i ] . frame_pcnt_motion = 0.0 ; //<S2SV> cpi -> one_pass_frame_stats [ i ] . frame_mvr = 0.0 ; //<S2SV> cpi -> one_pass_frame_stats [ i ] . frame_mvr_abs = 0.0 ; //<S2SV> cpi -> one_pass_frame_stats [ i ] . frame_mvc = 0.0 ; //<S2SV> cpi -> one_pass_frame_stats [ i ] . frame_mvc_abs = 0.0 ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> cpi -> cyclic_refresh_mode_enabled = cpi -> oxcf . error_resilient_mode ; //<S2SV> cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 5 ; //<S2SV> cpi -> cyclic_refresh_mode_index = 0 ; //<S2SV> cpi -> cyclic_refresh_q = 32 ; //<S2SV> if ( cpi -> cyclic_refresh_mode_enabled ) //<S2SV> { //<S2SV> CHECK_MEM_ERROR ( cpi -> cyclic_refresh_map , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; //<S2SV> } //<S2SV> else //<S2SV> cpi -> cyclic_refresh_map = ( signed char * ) NULL ; //<S2SV> # ifdef VP8_ENTROPY_STATS //<S2SV> init_context_counters ( ) ; //<S2SV> # endif //<S2SV> cpi -> activity_avg = 90 << 12 ; //<S2SV> cpi -> frames_since_key = 8 ; //<S2SV> cpi -> key_frame_frequency = cpi -> oxcf . key_freq ; //<S2SV> cpi -> this_key_frame_forced = 0 ; //<S2SV> cpi -> next_key_frame_forced = 0 ; //<S2SV> cpi -> source_alt_ref_pending = 0 ; //<S2SV> cpi -> source_alt_ref_active = 0 ; //<S2SV> cpi -> common . refresh_alt_ref_frame = 0 ; //<S2SV> cpi -> b_calculate_psnr = CONFIG_INTERNAL_STATS ; //<S2SV> # if CONFIG_INTERNAL_STATS //<S2SV> cpi -> b_calculate_ssimg = 0 ; //<S2SV> cpi -> count = 0 ; //<S2SV> cpi -> bytes = 0 ; //<S2SV> if ( cpi -> b_calculate_psnr ) //<S2SV> { //<S2SV> cpi -> total_sq_error = 0.0 ; //<S2SV> cpi -> total_sq_error2 = 0.0 ; //<S2SV> cpi -> total_y = 0.0 ; //<S2SV> cpi -> total_u = 0.0 ; //<S2SV> cpi -> total_v = 0.0 ; //<S2SV> cpi -> total = 0.0 ; //<S2SV> cpi -> totalp_y = 0.0 ; //<S2SV> cpi -> totalp_u = 0.0 ; //<S2SV> cpi -> totalp_v = 0.0 ; //<S2SV> cpi -> totalp = 0.0 ; //<S2SV> cpi -> tot_recode_hits = 0 ; //<S2SV> cpi -> summed_quality = 0 ; //<S2SV> cpi -> summed_weights = 0 ; //<S2SV> } //<S2SV> if ( cpi -> b_calculate_ssimg ) //<S2SV> { //<S2SV> cpi -> total_ssimg_y = 0 ; //<S2SV> cpi -> total_ssimg_u = 0 ; //<S2SV> cpi -> total_ssimg_v = 0 ; //<S2SV> cpi -> total_ssimg_all = 0 ; //<S2SV> } //<S2SV> # endif //<S2SV> cpi -> first_time_stamp_ever = 0x7FFFFFFF ; //<S2SV> cpi -> frames_till_gf_update_due = 0 ; //<S2SV> cpi -> key_frame_count = 1 ; //<S2SV> cpi -> ni_av_qi = cpi -> oxcf . worst_allowed_q ; //<S2SV> cpi -> ni_tot_qi = 0 ; //<S2SV> cpi -> ni_frames = 0 ; //<S2SV> cpi -> total_byte_count = 0 ; //<S2SV> cpi -> drop_frame = 0 ; //<S2SV> cpi -> rate_correction_factor = 1.0 ; //<S2SV> cpi -> key_frame_rate_correction_factor = 1.0 ; //<S2SV> cpi -> gf_rate_correction_factor = 1.0 ; //<S2SV> cpi -> twopass . est_max_qcorrection_factor = 1.0 ; //<S2SV> for ( i = 0 ; i < KEY_FRAME_CONTEXT ; i ++ ) //<S2SV> { //<S2SV> cpi -> prior_key_frame_distance [ i ] = ( int ) cpi -> output_framerate ; //<S2SV> } //<S2SV> # ifdef OUTPUT_YUV_SRC //<S2SV> yuv_file = fopen ( "bd.yuv" , "ab" ) ; //<S2SV> # endif //<S2SV> # if 0 //<S2SV> framepsnr = fopen ( "framepsnr.stt" , "a" ) ; //<S2SV> kf_list = fopen ( "kf_list.stt" , "w" ) ; //<S2SV> # endif //<S2SV> cpi -> output_pkt_list = oxcf -> output_pkt_list ; //<S2SV> # if ! ( CONFIG_REALTIME_ONLY ) //<S2SV> if ( cpi -> pass == 1 ) //<S2SV> { //<S2SV> vp8_init_first_pass ( cpi ) ; //<S2SV> } //<S2SV> else if ( cpi -> pass == 2 ) //<S2SV> { //<S2SV> size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; //<S2SV> int packets = ( int ) ( oxcf -> two_pass_stats_in . sz / packet_sz ) ; //<S2SV> cpi -> twopass . stats_in_start = oxcf -> two_pass_stats_in . buf ; //<S2SV> cpi -> twopass . stats_in = cpi -> twopass . stats_in_start ; //<S2SV> cpi -> twopass . stats_in_end = ( void * ) ( ( char * ) cpi -> twopass . stats_in //<S2SV> + ( packets - 1 ) * packet_sz ) ; //<S2SV> vp8_init_second_pass ( cpi ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( cpi -> compressor_speed == 2 ) //<S2SV> { //<S2SV> cpi -> avg_encode_time = 0 ; //<S2SV> cpi -> avg_pick_mode_time = 0 ; //<S2SV> } //<S2SV> vp8_set_speed_features ( cpi ) ; //<S2SV> for ( i = 0 ; i < MAX_MODES ; i ++ ) //<S2SV> { //<S2SV> cpi -> mb . rd_thresh_mult [ i ] = 128 ; //<S2SV> } //<S2SV> # ifdef VP8_ENTROPY_STATS //<S2SV> init_mv_ref_counts ( ) ; //<S2SV> # endif //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( vp8cx_create_encoder_threads ( cpi ) ) //<S2SV> { //<S2SV> vp8_remove_compressor ( & cpi ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> # endif //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . sdf = vp8_sad16x16 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . vf = vp8_variance16x16 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . svf = vp8_sub_pixel_variance16x16 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_h = vp8_variance_halfpixvar16x16_h ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_v = vp8_variance_halfpixvar16x16_v ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . svf_halfpix_hv = vp8_variance_halfpixvar16x16_hv ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx3f = vp8_sad16x16x3 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx8f = vp8_sad16x16x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . sdx4df = vp8_sad16x16x4d ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . sdf = vp8_sad16x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . vf = vp8_variance16x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . svf = vp8_sub_pixel_variance16x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_h = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_v = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . svf_halfpix_hv = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx3f = vp8_sad16x8x3 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx8f = vp8_sad16x8x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . sdx4df = vp8_sad16x8x4d ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . sdf = vp8_sad8x16 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . vf = vp8_variance8x16 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . svf = vp8_sub_pixel_variance8x16 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_h = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_v = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . svf_halfpix_hv = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx3f = vp8_sad8x16x3 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx8f = vp8_sad8x16x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . sdx4df = vp8_sad8x16x4d ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . sdf = vp8_sad8x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . vf = vp8_variance8x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . svf = vp8_sub_pixel_variance8x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_h = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_v = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . svf_halfpix_hv = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx3f = vp8_sad8x8x3 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx8f = vp8_sad8x8x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . sdx4df = vp8_sad8x8x4d ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . sdf = vp8_sad4x4 ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . vf = vp8_variance4x4 ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . svf = vp8_sub_pixel_variance4x4 ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_h = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_v = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . svf_halfpix_hv = NULL ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx3f = vp8_sad4x4x3 ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx8f = vp8_sad4x4x8 ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . sdx4df = vp8_sad4x4x4d ; //<S2SV> # if ARCH_X86 || ARCH_X86_64 //<S2SV> cpi -> fn_ptr [ BLOCK_16X16 ] . copymem = vp8_copy32xn ; //<S2SV> cpi -> fn_ptr [ BLOCK_16X8 ] . copymem = vp8_copy32xn ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X16 ] . copymem = vp8_copy32xn ; //<S2SV> cpi -> fn_ptr [ BLOCK_8X8 ] . copymem = vp8_copy32xn ; //<S2SV> cpi -> fn_ptr [ BLOCK_4X4 ] . copymem = vp8_copy32xn ; //<S2SV> # endif //<S2SV> cpi -> full_search_sad = vp8_full_search_sad ; //<S2SV> cpi -> diamond_search_sad = vp8_diamond_search_sad ; //<S2SV> cpi -> refining_search_sad = vp8_refining_search_sad ; //<S2SV> cpi -> mb . error_bins [ 0 ] = cpi -> common . MBs ; //<S2SV> vp8cx_init_quantizer ( cpi ) ; //<S2SV> vp8_loop_filter_init ( cm ) ; //<S2SV> cpi -> common . error . setjmp = 0 ; //<S2SV> # if CONFIG_MULTI_RES_ENCODING //<S2SV> if ( cpi -> oxcf . mr_encoder_id > 0 ) //<S2SV> vp8_cal_low_res_mb_cols ( cpi ) ; //<S2SV> # endif //<S2SV> cpi -> mb . mvcost [ 0 ] = & cpi -> rd_costs . mvcosts [ 0 ] [ mv_max + 1 ] ; //<S2SV> cpi -> mb . mvcost [ 1 ] = & cpi -> rd_costs . mvcosts [ 1 ] [ mv_max + 1 ] ; //<S2SV> cpi -> mb . mvsadcost [ 0 ] = & cpi -> rd_costs . mvsadcosts [ 0 ] [ mvfp_max + 1 ] ; //<S2SV> cpi -> mb . mvsadcost [ 1 ] = & cpi -> rd_costs . mvsadcosts [ 1 ] [ mvfp_max + 1 ] ; //<S2SV> cal_mvsadcosts ( cpi -> mb . mvsadcost ) ; //<S2SV> cpi -> mb . mbmode_cost = cpi -> rd_costs . mbmode_cost ; //<S2SV> cpi -> mb . intra_uv_mode_cost = cpi -> rd_costs . intra_uv_mode_cost ; //<S2SV> cpi -> mb . bmode_costs = cpi -> rd_costs . bmode_costs ; //<S2SV> cpi -> mb . inter_bmode_costs = cpi -> rd_costs . inter_bmode_costs ; //<S2SV> cpi -> mb . token_costs = cpi -> rd_costs . token_costs ; //<S2SV> vp8_setup_block_ptrs ( & cpi -> mb ) ; //<S2SV> vp8_setup_block_dptrs ( & cpi -> mb . e_mbd ) ; //<S2SV> return cpi ; //<S2SV> } //<S2SV> 