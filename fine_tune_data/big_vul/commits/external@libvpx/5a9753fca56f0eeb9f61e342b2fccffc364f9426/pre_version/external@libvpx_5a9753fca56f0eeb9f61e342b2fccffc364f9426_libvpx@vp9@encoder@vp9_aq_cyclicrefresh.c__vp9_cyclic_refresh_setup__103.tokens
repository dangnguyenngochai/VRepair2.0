void vp9_cyclic_refresh_setup ( VP9_COMP * const cpi ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> const RATE_CONTROL * const rc = & cpi -> rc ; //<S2SV> CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; //<S2SV> struct segmentation * const seg = & cm -> seg ; //<S2SV> unsigned char * const seg_map = cpi -> segmentation_map ; //<S2SV> const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ; //<S2SV> if ( ! apply_cyclic_refresh || //<S2SV> ( cm -> frame_type == KEY_FRAME ) || //<S2SV> ( cpi -> svc . temporal_layer_id > 0 ) ) { //<S2SV> vpx_memset ( seg_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; //<S2SV> vp9_disable_segmentation ( & cm -> seg ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) //<S2SV> cr -> sb_index = 0 ; //<S2SV> return ; //<S2SV> } else { //<S2SV> int qindex_delta = 0 ; //<S2SV> int i , block_count , bl_index , sb_rows , sb_cols , sbs_in_frame ; //<S2SV> int xmis , ymis , x , y , qindex2 ; //<S2SV> const float rate_ratio_qdelta = 2.0 ; //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> cr -> max_sbs_perframe = 10 ; //<S2SV> cr -> max_qdelta_perc = 50 ; //<S2SV> cr -> min_block_size = BLOCK_8X8 ; //<S2SV> cr -> time_for_refresh = 1 ; //<S2SV> cr -> thresh_rate_sb = ( rc -> sb64_target_rate * 256 ) >> 2 ; //<S2SV> cr -> thresh_dist_sb = 8 * ( int ) ( vp9_convert_qindex_to_q ( cm -> base_qindex ) * //<S2SV> vp9_convert_qindex_to_q ( cm -> base_qindex ) ) ; //<S2SV> if ( cpi -> sf . use_nonrd_pick_mode ) { //<S2SV> cr -> thresh_rate_sb = ( rc -> sb64_target_rate * 256 ) >> 3 ; //<S2SV> cr -> thresh_dist_sb = 4 * ( int ) ( vp9_convert_qindex_to_q ( cm -> base_qindex ) * //<S2SV> vp9_convert_qindex_to_q ( cm -> base_qindex ) ) ; //<S2SV> } //<S2SV> cr -> num_seg_blocks = 0 ; //<S2SV> vpx_memset ( seg_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; //<S2SV> vp9_enable_segmentation ( & cm -> seg ) ; //<S2SV> vp9_clearall_segfeatures ( seg ) ; //<S2SV> seg -> abs_delta = SEGMENT_DELTADATA ; //<S2SV> vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ; //<S2SV> vp9_enable_segfeature ( seg , 1 , SEG_LVL_ALT_Q ) ; //<S2SV> qindex_delta = vp9_compute_qdelta_by_rate ( rc , cm -> frame_type , //<S2SV> cm -> base_qindex , //<S2SV> rate_ratio_qdelta ) ; //<S2SV> if ( - qindex_delta > cr -> max_qdelta_perc * cm -> base_qindex / 100 ) //<S2SV> qindex_delta = - cr -> max_qdelta_perc * cm -> base_qindex / 100 ; //<S2SV> qindex2 = clamp ( cm -> base_qindex + cm -> y_dc_delta_q + qindex_delta , 0 , MAXQ ) ; //<S2SV> cr -> rdmult = vp9_compute_rd_mult ( cpi , qindex2 ) ; //<S2SV> vp9_set_segdata ( seg , 1 , SEG_LVL_ALT_Q , qindex_delta ) ; //<S2SV> sb_cols = ( cm -> mi_cols + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ; //<S2SV> sb_rows = ( cm -> mi_rows + MI_BLOCK_SIZE - 1 ) / MI_BLOCK_SIZE ; //<S2SV> sbs_in_frame = sb_cols * sb_rows ; //<S2SV> block_count = cr -> max_sbs_perframe * sbs_in_frame / 100 ; //<S2SV> assert ( cr -> sb_index < sbs_in_frame ) ; //<S2SV> i = cr -> sb_index ; //<S2SV> do { //<S2SV> int sum_map = 0 ; //<S2SV> int sb_row_index = ( i / sb_cols ) ; //<S2SV> int sb_col_index = i - sb_row_index * sb_cols ; //<S2SV> int mi_row = sb_row_index * MI_BLOCK_SIZE ; //<S2SV> int mi_col = sb_col_index * MI_BLOCK_SIZE ; //<S2SV> assert ( mi_row >= 0 && mi_row < cm -> mi_rows ) ; //<S2SV> assert ( mi_col >= 0 && mi_col < cm -> mi_cols ) ; //<S2SV> bl_index = mi_row * cm -> mi_cols + mi_col ; //<S2SV> xmis = MIN ( cm -> mi_cols - mi_col , //<S2SV> num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ) ; //<S2SV> ymis = MIN ( cm -> mi_rows - mi_row , //<S2SV> num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ) ; //<S2SV> for ( y = 0 ; y < ymis ; y ++ ) { //<S2SV> for ( x = 0 ; x < xmis ; x ++ ) { //<S2SV> const int bl_index2 = bl_index + y * cm -> mi_cols + x ; //<S2SV> if ( cr -> map [ bl_index2 ] == 0 ) { //<S2SV> seg_map [ bl_index2 ] = 1 ; //<S2SV> sum_map ++ ; //<S2SV> } else if ( cr -> map [ bl_index2 ] < 0 ) { //<S2SV> cr -> map [ bl_index2 ] ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( sum_map > 0 && sum_map < xmis * ymis ) { //<S2SV> const int new_value = ( sum_map >= xmis * ymis / 2 ) ; //<S2SV> for ( y = 0 ; y < ymis ; y ++ ) //<S2SV> for ( x = 0 ; x < xmis ; x ++ ) //<S2SV> seg_map [ bl_index + y * cm -> mi_cols + x ] = new_value ; //<S2SV> } //<S2SV> i ++ ; //<S2SV> if ( i == sbs_in_frame ) { //<S2SV> i = 0 ; //<S2SV> } //<S2SV> if ( sum_map >= xmis * ymis / 2 ) //<S2SV> block_count -- ; //<S2SV> } while ( block_count && i != cr -> sb_index ) ; //<S2SV> cr -> sb_index = i ; //<S2SV> } //<S2SV> } //<S2SV> 