void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run , //<S2SV> BLOCK_SIZE bsize ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> TOKENEXTRA * t_backup = * t ; //<S2SV> const int ctx = vp9_get_skip_context ( xd ) ; //<S2SV> const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , //<S2SV> SEG_LVL_SKIP ) ; //<S2SV> struct tokenize_b_args arg = { cpi , xd , t } ; //<S2SV> if ( mbmi -> skip ) { //<S2SV> if ( ! dry_run ) //<S2SV> cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ; //<S2SV> reset_skip_context ( xd , bsize ) ; //<S2SV> if ( dry_run ) //<S2SV> * t = t_backup ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( ! dry_run ) { //<S2SV> cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ; //<S2SV> vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ; //<S2SV> } else { //<S2SV> vp9_foreach_transformed_block ( xd , bsize , set_entropy_context_b , & arg ) ; //<S2SV> * t = t_backup ; //<S2SV> } //<S2SV> } //<S2SV> 