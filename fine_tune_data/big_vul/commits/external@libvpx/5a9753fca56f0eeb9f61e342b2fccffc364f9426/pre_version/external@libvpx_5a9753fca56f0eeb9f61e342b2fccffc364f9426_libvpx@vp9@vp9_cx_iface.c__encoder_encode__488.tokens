static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , //<S2SV> const vpx_image_t * img , //<S2SV> vpx_codec_pts_t pts , //<S2SV> unsigned long duration , //<S2SV> vpx_enc_frame_flags_t flags , //<S2SV> unsigned long deadline ) { //<S2SV> vpx_codec_err_t res = VPX_CODEC_OK ; //<S2SV> if ( img ) //<S2SV> res = validate_img ( ctx , img ) ; //<S2SV> pick_quickcompress_mode ( ctx , duration , deadline ) ; //<S2SV> vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; //<S2SV> if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || //<S2SV> ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { //<S2SV> ctx -> base . err_detail = "Conflicting<S2SV_blank>flags." ; //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> } //<S2SV> if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | //<S2SV> VP8_EFLAG_NO_REF_ARF ) ) { //<S2SV> int ref = 7 ; //<S2SV> if ( flags & VP8_EFLAG_NO_REF_LAST ) //<S2SV> ref ^= VP9_LAST_FLAG ; //<S2SV> if ( flags & VP8_EFLAG_NO_REF_GF ) //<S2SV> ref ^= VP9_GOLD_FLAG ; //<S2SV> if ( flags & VP8_EFLAG_NO_REF_ARF ) //<S2SV> ref ^= VP9_ALT_FLAG ; //<S2SV> vp9_use_as_reference ( ctx -> cpi , ref ) ; //<S2SV> } //<S2SV> if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | //<S2SV> VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | //<S2SV> VP8_EFLAG_FORCE_ARF ) ) { //<S2SV> int upd = 7 ; //<S2SV> if ( flags & VP8_EFLAG_NO_UPD_LAST ) //<S2SV> upd ^= VP9_LAST_FLAG ; //<S2SV> if ( flags & VP8_EFLAG_NO_UPD_GF ) //<S2SV> upd ^= VP9_GOLD_FLAG ; //<S2SV> if ( flags & VP8_EFLAG_NO_UPD_ARF ) //<S2SV> upd ^= VP9_ALT_FLAG ; //<S2SV> vp9_update_reference ( ctx -> cpi , upd ) ; //<S2SV> } //<S2SV> if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { //<S2SV> vp9_update_entropy ( ctx -> cpi , 0 ) ; //<S2SV> } //<S2SV> if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && //<S2SV> ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { //<S2SV> if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { //<S2SV> flags |= VPX_EFLAG_FORCE_KF ; //<S2SV> ctx -> fixed_kf_cntr = 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( res == VPX_CODEC_OK && ctx -> cpi != NULL ) { //<S2SV> unsigned int lib_flags ; //<S2SV> YV12_BUFFER_CONFIG sd ; //<S2SV> int64_t dst_time_stamp , dst_end_time_stamp ; //<S2SV> size_t size , cx_data_sz ; //<S2SV> unsigned char * cx_data ; //<S2SV> if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) //<S2SV> ( ( VP9_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; //<S2SV> lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; //<S2SV> dst_time_stamp = ( pts * 10000000 * ctx -> cfg . g_timebase . num ) //<S2SV> / ctx -> cfg . g_timebase . den ; //<S2SV> dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / //<S2SV> ctx -> cfg . g_timebase . den ; //<S2SV> if ( img != NULL ) { //<S2SV> res = image2yuvconfig ( img , & sd ) ; //<S2SV> if ( vp9_receive_raw_frame ( ctx -> cpi , lib_flags , //<S2SV> & sd , dst_time_stamp , dst_end_time_stamp ) ) { //<S2SV> VP9_COMP * cpi = ( VP9_COMP * ) ctx -> cpi ; //<S2SV> res = update_error_state ( ctx , & cpi -> common . error ) ; //<S2SV> } //<S2SV> } //<S2SV> cx_data = ctx -> cx_data ; //<S2SV> cx_data_sz = ctx -> cx_data_sz ; //<S2SV> lib_flags = 0 ; //<S2SV> if ( ctx -> pending_cx_data ) { //<S2SV> memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ; //<S2SV> ctx -> pending_cx_data = cx_data ; //<S2SV> cx_data += ctx -> pending_cx_data_sz ; //<S2SV> cx_data_sz -= ctx -> pending_cx_data_sz ; //<S2SV> if ( cx_data_sz < ctx -> cx_data_sz / 2 ) { //<S2SV> ctx -> base . err_detail = "Compressed<S2SV_blank>data<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small" ; //<S2SV> return VPX_CODEC_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> while ( cx_data_sz >= ctx -> cx_data_sz / 2 && //<S2SV> - 1 != vp9_get_compressed_data ( ctx -> cpi , & lib_flags , & size , //<S2SV> cx_data , & dst_time_stamp , //<S2SV> & dst_end_time_stamp , ! img ) ) { //<S2SV> if ( size ) { //<S2SV> vpx_codec_pts_t round , delta ; //<S2SV> vpx_codec_cx_pkt_t pkt ; //<S2SV> VP9_COMP * const cpi = ( VP9_COMP * ) ctx -> cpi ; //<S2SV> if ( cpi -> common . show_frame == 0 ) { //<S2SV> if ( ctx -> pending_cx_data == 0 ) //<S2SV> ctx -> pending_cx_data = cx_data ; //<S2SV> ctx -> pending_cx_data_sz += size ; //<S2SV> ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; //<S2SV> ctx -> pending_frame_magnitude |= size ; //<S2SV> cx_data += size ; //<S2SV> cx_data_sz -= size ; //<S2SV> continue ; //<S2SV> } //<S2SV> round = ( vpx_codec_pts_t ) 1000000 * ctx -> cfg . g_timebase . num / 2 - 1 ; //<S2SV> delta = ( dst_end_time_stamp - dst_time_stamp ) ; //<S2SV> pkt . kind = VPX_CODEC_CX_FRAME_PKT ; //<S2SV> pkt . data . frame . pts = //<S2SV> ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) //<S2SV> / ctx -> cfg . g_timebase . num / 10000000 ; //<S2SV> pkt . data . frame . duration = ( unsigned long ) //<S2SV> ( ( delta * ctx -> cfg . g_timebase . den + round ) //<S2SV> / ctx -> cfg . g_timebase . num / 10000000 ) ; //<S2SV> pkt . data . frame . flags = lib_flags << 16 ; //<S2SV> if ( lib_flags & FRAMEFLAGS_KEY ) //<S2SV> pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; //<S2SV> if ( cpi -> common . show_frame == 0 ) { //<S2SV> pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; //<S2SV> pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen //<S2SV> * ctx -> cfg . g_timebase . den + round ) //<S2SV> / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; //<S2SV> pkt . data . frame . duration = 0 ; //<S2SV> } //<S2SV> if ( cpi -> droppable ) //<S2SV> pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; //<S2SV> if ( ctx -> pending_cx_data ) { //<S2SV> ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; //<S2SV> ctx -> pending_frame_magnitude |= size ; //<S2SV> ctx -> pending_cx_data_sz += size ; //<S2SV> size += write_superframe_index ( ctx ) ; //<S2SV> pkt . data . frame . buf = ctx -> pending_cx_data ; //<S2SV> pkt . data . frame . sz = ctx -> pending_cx_data_sz ; //<S2SV> ctx -> pending_cx_data = NULL ; //<S2SV> ctx -> pending_cx_data_sz = 0 ; //<S2SV> ctx -> pending_frame_count = 0 ; //<S2SV> ctx -> pending_frame_magnitude = 0 ; //<S2SV> } else { //<S2SV> pkt . data . frame . buf = cx_data ; //<S2SV> pkt . data . frame . sz = size ; //<S2SV> } //<S2SV> pkt . data . frame . partition_id = - 1 ; //<S2SV> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; //<S2SV> cx_data += size ; //<S2SV> cx_data_sz -= size ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return res ; //<S2SV> } //<S2SV> 