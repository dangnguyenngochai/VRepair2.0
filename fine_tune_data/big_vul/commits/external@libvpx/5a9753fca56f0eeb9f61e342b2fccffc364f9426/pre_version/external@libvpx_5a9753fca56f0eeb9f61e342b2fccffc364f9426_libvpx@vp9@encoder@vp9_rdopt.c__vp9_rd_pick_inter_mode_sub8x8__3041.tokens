int64_t vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , MACROBLOCK * x , //<S2SV> const TileInfo * const tile , //<S2SV> int mi_row , int mi_col , //<S2SV> int * returnrate , //<S2SV> int64_t * returndistortion , //<S2SV> BLOCK_SIZE bsize , //<S2SV> PICK_MODE_CONTEXT * ctx , //<S2SV> int64_t best_rd_so_far ) { //<S2SV> VP9_COMMON * cm = & cpi -> common ; //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> const struct segmentation * seg = & cm -> seg ; //<S2SV> MV_REFERENCE_FRAME ref_frame , second_ref_frame ; //<S2SV> unsigned char segment_id = mbmi -> segment_id ; //<S2SV> int comp_pred , i ; //<S2SV> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; //<S2SV> struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; //<S2SV> static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , //<S2SV> VP9_ALT_FLAG } ; //<S2SV> int64_t best_rd = best_rd_so_far ; //<S2SV> int64_t best_yrd = best_rd_so_far ; //<S2SV> int64_t best_tx_rd [ TX_MODES ] ; //<S2SV> int64_t best_tx_diff [ TX_MODES ] ; //<S2SV> int64_t best_pred_diff [ REFERENCE_MODES ] ; //<S2SV> int64_t best_pred_rd [ REFERENCE_MODES ] ; //<S2SV> int64_t best_filter_rd [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> MB_MODE_INFO best_mbmode = { 0 } ; //<S2SV> int mode_index , best_mode_index = 0 ; //<S2SV> unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ; //<S2SV> vp9_prob comp_mode_p ; //<S2SV> int64_t best_inter_rd = INT64_MAX ; //<S2SV> MV_REFERENCE_FRAME best_inter_ref_frame = LAST_FRAME ; //<S2SV> INTERP_FILTER tmp_best_filter = SWITCHABLE ; //<S2SV> int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ; //<S2SV> int64_t dist_uv [ TX_SIZES ] ; //<S2SV> int skip_uv [ TX_SIZES ] ; //<S2SV> MB_PREDICTION_MODE mode_uv [ TX_SIZES ] = { 0 } ; //<S2SV> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; //<S2SV> int_mv seg_mvs [ 4 ] [ MAX_REF_FRAMES ] ; //<S2SV> b_mode_info best_bmodes [ 4 ] ; //<S2SV> int best_skip2 = 0 ; //<S2SV> int ref_frame_mask = 0 ; //<S2SV> int mode_skip_mask = 0 ; //<S2SV> x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; //<S2SV> vpx_memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> int j ; //<S2SV> for ( j = 0 ; j < MAX_REF_FRAMES ; j ++ ) //<S2SV> seg_mvs [ i ] [ j ] . as_int = INVALID_MV ; //<S2SV> } //<S2SV> estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp , //<S2SV> & comp_mode_p ) ; //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) //<S2SV> best_pred_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < TX_MODES ; i ++ ) //<S2SV> best_tx_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) //<S2SV> best_filter_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < TX_SIZES ; i ++ ) //<S2SV> rate_uv_intra [ i ] = INT_MAX ; //<S2SV> * returnrate = INT_MAX ; //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ref_frame ++ ) { //<S2SV> if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) { //<S2SV> vp9_setup_buffer_inter ( cpi , x , tile , //<S2SV> ref_frame , bsize , mi_row , mi_col , //<S2SV> frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , //<S2SV> yv12_mb ) ; //<S2SV> } //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; //<S2SV> frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; //<S2SV> } //<S2SV> for ( ref_frame = LAST_FRAME ; //<S2SV> ref_frame <= ALTREF_FRAME && cpi -> sf . reference_masking ; ++ ref_frame ) { //<S2SV> int i ; //<S2SV> for ( i = LAST_FRAME ; i <= ALTREF_FRAME ; ++ i ) { //<S2SV> if ( ( x -> pred_mv_sad [ ref_frame ] >> 1 ) > x -> pred_mv_sad [ i ] ) { //<S2SV> ref_frame_mask |= ( 1 << ref_frame ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( mode_index = 0 ; mode_index < MAX_REFS ; ++ mode_index ) { //<S2SV> int mode_excluded = 0 ; //<S2SV> int64_t this_rd = INT64_MAX ; //<S2SV> int disable_skip = 0 ; //<S2SV> int compmode_cost = 0 ; //<S2SV> int rate2 = 0 , rate_y = 0 , rate_uv = 0 ; //<S2SV> int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ; //<S2SV> int skippable = 0 ; //<S2SV> int64_t tx_cache [ TX_MODES ] ; //<S2SV> int i ; //<S2SV> int this_skip2 = 0 ; //<S2SV> int64_t total_sse = INT_MAX ; //<S2SV> int early_term = 0 ; //<S2SV> for ( i = 0 ; i < TX_MODES ; ++ i ) //<S2SV> tx_cache [ i ] = INT64_MAX ; //<S2SV> x -> skip = 0 ; //<S2SV> ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 0 ] ; //<S2SV> second_ref_frame = vp9_ref_order [ mode_index ] . ref_frame [ 1 ] ; //<S2SV> if ( mode_index > 2 && cpi -> sf . mode_skip_start < MAX_MODES ) { //<S2SV> if ( mode_index == 3 ) { //<S2SV> switch ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] ) { //<S2SV> case INTRA_FRAME : //<S2SV> mode_skip_mask = 0 ; //<S2SV> break ; //<S2SV> case LAST_FRAME : //<S2SV> mode_skip_mask = 0x0010 ; //<S2SV> break ; //<S2SV> case GOLDEN_FRAME : //<S2SV> mode_skip_mask = 0x0008 ; //<S2SV> break ; //<S2SV> case ALTREF_FRAME : //<S2SV> mode_skip_mask = 0x0000 ; //<S2SV> break ; //<S2SV> case NONE : //<S2SV> case MAX_REF_FRAMES : //<S2SV> assert ( 0 && "Invalid<S2SV_blank>Reference<S2SV_blank>frame" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( mode_skip_mask & ( 1 << mode_index ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ( best_rd < //<S2SV> ( ( int64_t ) cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] * //<S2SV> cpi -> rd_thresh_freq_sub8x8 [ bsize ] [ mode_index ] >> 5 ) ) || //<S2SV> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ mode_index ] == INT_MAX ) //<S2SV> continue ; //<S2SV> if ( ( second_ref_frame > INTRA_FRAME ) && //<S2SV> vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) //<S2SV> continue ; //<S2SV> mbmi -> ref_frame [ 0 ] = ref_frame ; //<S2SV> mbmi -> ref_frame [ 1 ] = second_ref_frame ; //<S2SV> if ( ! ( ref_frame == INTRA_FRAME //<S2SV> || ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! ( second_ref_frame == NONE //<S2SV> || ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> comp_pred = second_ref_frame > INTRA_FRAME ; //<S2SV> if ( comp_pred ) { //<S2SV> if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) //<S2SV> if ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) //<S2SV> continue ; //<S2SV> if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_COMP_REFMISMATCH ) //<S2SV> if ( ref_frame != best_inter_ref_frame && //<S2SV> second_ref_frame != best_inter_ref_frame ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ref_frame > 0 && vp9_is_scaled ( & cm -> frame_refs [ ref_frame - 1 ] . sf ) ) //<S2SV> continue ; //<S2SV> if ( second_ref_frame > 0 && //<S2SV> vp9_is_scaled ( & cm -> frame_refs [ second_ref_frame - 1 ] . sf ) ) //<S2SV> continue ; //<S2SV> set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; //<S2SV> mbmi -> uv_mode = DC_PRED ; //<S2SV> mbmi -> interp_filter = cm -> interp_filter == SWITCHABLE ? EIGHTTAP //<S2SV> : cm -> interp_filter ; //<S2SV> if ( comp_pred ) { //<S2SV> if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) //<S2SV> continue ; //<S2SV> mode_excluded = mode_excluded ? mode_excluded //<S2SV> : cm -> reference_mode == SINGLE_REFERENCE ; //<S2SV> } else { //<S2SV> if ( ref_frame != INTRA_FRAME && second_ref_frame != INTRA_FRAME ) { //<S2SV> mode_excluded = mode_excluded ? //<S2SV> mode_excluded : cm -> reference_mode == COMPOUND_REFERENCE ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { //<S2SV> xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; //<S2SV> if ( comp_pred ) //<S2SV> xd -> plane [ i ] . pre [ 1 ] = yv12_mb [ second_ref_frame ] [ i ] ; //<S2SV> } //<S2SV> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && //<S2SV> vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != //<S2SV> ( int ) ref_frame ) { //<S2SV> continue ; //<S2SV> } else if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) && //<S2SV> ref_frame != INTRA_FRAME ) { //<S2SV> continue ; //<S2SV> } else if ( ! vp9_segfeature_active ( seg , segment_id , //<S2SV> SEG_LVL_REF_FRAME ) ) { //<S2SV> if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> # ifdef MODE_TEST_HIT_STATS //<S2SV> cpi -> mode_test_hits [ bsize ] ++ ; //<S2SV> # endif //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> int rate ; //<S2SV> mbmi -> tx_size = TX_4X4 ; //<S2SV> if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate , & rate_y , //<S2SV> & distortion_y , best_rd ) >= best_rd ) //<S2SV> continue ; //<S2SV> rate2 += rate ; //<S2SV> rate2 += intra_cost_penalty ; //<S2SV> distortion2 += distortion_y ; //<S2SV> if ( rate_uv_intra [ TX_4X4 ] == INT_MAX ) { //<S2SV> choose_intra_uv_mode ( cpi , ctx , bsize , TX_4X4 , //<S2SV> & rate_uv_intra [ TX_4X4 ] , //<S2SV> & rate_uv_tokenonly [ TX_4X4 ] , //<S2SV> & dist_uv [ TX_4X4 ] , & skip_uv [ TX_4X4 ] , //<S2SV> & mode_uv [ TX_4X4 ] ) ; //<S2SV> } //<S2SV> rate2 += rate_uv_intra [ TX_4X4 ] ; //<S2SV> rate_uv = rate_uv_tokenonly [ TX_4X4 ] ; //<S2SV> distortion2 += dist_uv [ TX_4X4 ] ; //<S2SV> distortion_uv = dist_uv [ TX_4X4 ] ; //<S2SV> mbmi -> uv_mode = mode_uv [ TX_4X4 ] ; //<S2SV> tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; //<S2SV> for ( i = 0 ; i < TX_MODES ; ++ i ) //<S2SV> tx_cache [ i ] = tx_cache [ ONLY_4X4 ] ; //<S2SV> } else { //<S2SV> int rate ; //<S2SV> int64_t distortion ; //<S2SV> int64_t this_rd_thresh ; //<S2SV> int64_t tmp_rd , tmp_best_rd = INT64_MAX , tmp_best_rdu = INT64_MAX ; //<S2SV> int tmp_best_rate = INT_MAX , tmp_best_ratey = INT_MAX ; //<S2SV> int64_t tmp_best_distortion = INT_MAX , tmp_best_sse , uv_sse ; //<S2SV> int tmp_best_skippable = 0 ; //<S2SV> int switchable_filter_index ; //<S2SV> int_mv * second_ref = comp_pred ? //<S2SV> & mbmi -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ; //<S2SV> b_mode_info tmp_best_bmodes [ 16 ] ; //<S2SV> MB_MODE_INFO tmp_best_mbmode ; //<S2SV> BEST_SEG_INFO bsi [ SWITCHABLE_FILTERS ] ; //<S2SV> int pred_exists = 0 ; //<S2SV> int uv_skippable ; //<S2SV> this_rd_thresh = ( ref_frame == LAST_FRAME ) ? //<S2SV> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_LAST ] : //<S2SV> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_ALTR ] ; //<S2SV> this_rd_thresh = ( ref_frame == GOLDEN_FRAME ) ? //<S2SV> cpi -> rd_thresh_sub8x8 [ segment_id ] [ bsize ] [ THR_GOLD ] : this_rd_thresh ; //<S2SV> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; //<S2SV> cpi -> mask_filter_rd = 0 ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) //<S2SV> cpi -> rd_filter_cache [ i ] = INT64_MAX ; //<S2SV> if ( cm -> interp_filter != BILINEAR ) { //<S2SV> tmp_best_filter = EIGHTTAP ; //<S2SV> if ( x -> source_variance < //<S2SV> cpi -> sf . disable_filter_search_var_thresh ) { //<S2SV> tmp_best_filter = EIGHTTAP ; //<S2SV> } else if ( cpi -> sf . adaptive_pred_interp_filter == 1 && //<S2SV> ctx -> pred_interp_filter < SWITCHABLE ) { //<S2SV> tmp_best_filter = ctx -> pred_interp_filter ; //<S2SV> } else if ( cpi -> sf . adaptive_pred_interp_filter == 2 ) { //<S2SV> tmp_best_filter = ctx -> pred_interp_filter < SWITCHABLE ? //<S2SV> ctx -> pred_interp_filter : 0 ; //<S2SV> } else { //<S2SV> for ( switchable_filter_index = 0 ; //<S2SV> switchable_filter_index < SWITCHABLE_FILTERS ; //<S2SV> ++ switchable_filter_index ) { //<S2SV> int newbest , rs ; //<S2SV> int64_t rs_rd ; //<S2SV> mbmi -> interp_filter = switchable_filter_index ; //<S2SV> tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile , //<S2SV> & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , //<S2SV> second_ref , //<S2SV> best_yrd , //<S2SV> & rate , & rate_y , & distortion , //<S2SV> & skippable , & total_sse , //<S2SV> ( int ) this_rd_thresh , seg_mvs , //<S2SV> bsi , switchable_filter_index , //<S2SV> mi_row , mi_col ) ; //<S2SV> if ( tmp_rd == INT64_MAX ) //<S2SV> continue ; //<S2SV> rs = vp9_get_switchable_rate ( x ) ; //<S2SV> rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; //<S2SV> cpi -> rd_filter_cache [ switchable_filter_index ] = tmp_rd ; //<S2SV> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = //<S2SV> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , //<S2SV> tmp_rd + rs_rd ) ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> tmp_rd += rs_rd ; //<S2SV> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , tmp_rd ) ; //<S2SV> newbest = ( tmp_rd < tmp_best_rd ) ; //<S2SV> if ( newbest ) { //<S2SV> tmp_best_filter = mbmi -> interp_filter ; //<S2SV> tmp_best_rd = tmp_rd ; //<S2SV> } //<S2SV> if ( ( newbest && cm -> interp_filter == SWITCHABLE ) || //<S2SV> ( mbmi -> interp_filter == cm -> interp_filter && //<S2SV> cm -> interp_filter != SWITCHABLE ) ) { //<S2SV> tmp_best_rdu = tmp_rd ; //<S2SV> tmp_best_rate = rate ; //<S2SV> tmp_best_ratey = rate_y ; //<S2SV> tmp_best_distortion = distortion ; //<S2SV> tmp_best_sse = total_sse ; //<S2SV> tmp_best_skippable = skippable ; //<S2SV> tmp_best_mbmode = * mbmi ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> tmp_best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ; //<S2SV> x -> zcoeff_blk [ TX_4X4 ] [ i ] = ! x -> plane [ 0 ] . eobs [ i ] ; //<S2SV> } //<S2SV> pred_exists = 1 ; //<S2SV> if ( switchable_filter_index == 0 && //<S2SV> cpi -> sf . use_rd_breakout && //<S2SV> best_rd < INT64_MAX ) { //<S2SV> if ( tmp_best_rdu / 2 > best_rd ) { //<S2SV> tmp_best_filter = mbmi -> interp_filter ; //<S2SV> tmp_best_rdu = INT64_MAX ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( tmp_best_rdu == INT64_MAX && pred_exists ) //<S2SV> continue ; //<S2SV> mbmi -> interp_filter = ( cm -> interp_filter == SWITCHABLE ? //<S2SV> tmp_best_filter : cm -> interp_filter ) ; //<S2SV> if ( ! pred_exists ) { //<S2SV> tmp_rd = rd_pick_best_mbsegmentation ( cpi , x , tile , //<S2SV> & mbmi -> ref_mvs [ ref_frame ] [ 0 ] , //<S2SV> second_ref , //<S2SV> best_yrd , //<S2SV> & rate , & rate_y , & distortion , //<S2SV> & skippable , & total_sse , //<S2SV> ( int ) this_rd_thresh , seg_mvs , //<S2SV> bsi , 0 , //<S2SV> mi_row , mi_col ) ; //<S2SV> if ( tmp_rd == INT64_MAX ) //<S2SV> continue ; //<S2SV> } else { //<S2SV> total_sse = tmp_best_sse ; //<S2SV> rate = tmp_best_rate ; //<S2SV> rate_y = tmp_best_ratey ; //<S2SV> distortion = tmp_best_distortion ; //<S2SV> skippable = tmp_best_skippable ; //<S2SV> * mbmi = tmp_best_mbmode ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> xd -> mi [ 0 ] -> bmi [ i ] = tmp_best_bmodes [ i ] ; //<S2SV> } //<S2SV> rate2 += rate ; //<S2SV> distortion2 += distortion ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> rate2 += vp9_get_switchable_rate ( x ) ; //<S2SV> if ( ! mode_excluded ) //<S2SV> mode_excluded = comp_pred ? cm -> reference_mode == SINGLE_REFERENCE //<S2SV> : cm -> reference_mode == COMPOUND_REFERENCE ; //<S2SV> compmode_cost = vp9_cost_bit ( comp_mode_p , comp_pred ) ; //<S2SV> tmp_best_rdu = best_rd - //<S2SV> MIN ( RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) , //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) ; //<S2SV> if ( tmp_best_rdu > 0 ) { //<S2SV> vp9_build_inter_predictors_sbuv ( & x -> e_mbd , mi_row , mi_col , //<S2SV> BLOCK_8X8 ) ; //<S2SV> super_block_uvrd ( cpi , x , & rate_uv , & distortion_uv , & uv_skippable , //<S2SV> & uv_sse , BLOCK_8X8 , tmp_best_rdu ) ; //<S2SV> if ( rate_uv == INT_MAX ) //<S2SV> continue ; //<S2SV> rate2 += rate_uv ; //<S2SV> distortion2 += distortion_uv ; //<S2SV> skippable = skippable && uv_skippable ; //<S2SV> total_sse += uv_sse ; //<S2SV> tx_cache [ ONLY_4X4 ] = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; //<S2SV> for ( i = 0 ; i < TX_MODES ; ++ i ) //<S2SV> tx_cache [ i ] = tx_cache [ ONLY_4X4 ] ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) //<S2SV> rate2 += compmode_cost ; //<S2SV> if ( second_ref_frame > INTRA_FRAME ) { //<S2SV> rate2 += ref_costs_comp [ ref_frame ] ; //<S2SV> } else { //<S2SV> rate2 += ref_costs_single [ ref_frame ] ; //<S2SV> } //<S2SV> if ( ! disable_skip ) { //<S2SV> const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id , //<S2SV> SEG_LVL_SKIP ) ; //<S2SV> if ( mb_skip_allowed && ref_frame != INTRA_FRAME && ! xd -> lossless ) { //<S2SV> if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } else { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> distortion2 = total_sse ; //<S2SV> assert ( total_sse >= 0 ) ; //<S2SV> rate2 -= ( rate_y + rate_uv ) ; //<S2SV> rate_y = 0 ; //<S2SV> rate_uv = 0 ; //<S2SV> this_skip2 = 1 ; //<S2SV> } //<S2SV> } else if ( mb_skip_allowed ) { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; //<S2SV> } //<S2SV> if ( is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) && //<S2SV> ! has_second_ref ( & xd -> mi [ 0 ] -> mbmi ) && //<S2SV> ! mode_excluded && //<S2SV> this_rd < best_inter_rd ) { //<S2SV> best_inter_rd = this_rd ; //<S2SV> best_inter_ref_frame = ref_frame ; //<S2SV> } //<S2SV> if ( ! disable_skip && ref_frame == INTRA_FRAME ) { //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) //<S2SV> best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) //<S2SV> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ; //<S2SV> } //<S2SV> if ( this_rd < best_rd || x -> skip ) { //<S2SV> if ( ! mode_excluded ) { //<S2SV> int max_plane = MAX_MB_PLANE ; //<S2SV> best_mode_index = mode_index ; //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> mbmi -> mv [ 0 ] . as_int = 0 ; //<S2SV> max_plane = 1 ; //<S2SV> } //<S2SV> * returnrate = rate2 ; //<S2SV> * returndistortion = distortion2 ; //<S2SV> best_rd = this_rd ; //<S2SV> best_yrd = best_rd - //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , rate_uv , distortion_uv ) ; //<S2SV> best_mbmode = * mbmi ; //<S2SV> best_skip2 = this_skip2 ; //<S2SV> if ( ! x -> select_txfm_size ) //<S2SV> swap_block_ptr ( x , ctx , max_plane ) ; //<S2SV> vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] , //<S2SV> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ; //<S2SV> if ( ( cpi -> sf . mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && //<S2SV> ( mode_index > MIN_EARLY_TERM_INDEX ) ) { //<S2SV> const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ; //<S2SV> int scale = 4 ; //<S2SV> if ( x -> source_variance < UINT_MAX ) { //<S2SV> const int var_adjust = ( x -> source_variance < 16 ) ; //<S2SV> scale -= var_adjust ; //<S2SV> } //<S2SV> if ( ref_frame > INTRA_FRAME && //<S2SV> distortion2 * scale < qstep * qstep ) { //<S2SV> early_term = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! disable_skip && ref_frame != INTRA_FRAME ) { //<S2SV> int64_t single_rd , hybrid_rd , single_rate , hybrid_rate ; //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { //<S2SV> single_rate = rate2 - compmode_cost ; //<S2SV> hybrid_rate = rate2 ; //<S2SV> } else { //<S2SV> single_rate = rate2 ; //<S2SV> hybrid_rate = rate2 + compmode_cost ; //<S2SV> } //<S2SV> single_rd = RDCOST ( x -> rdmult , x -> rddiv , single_rate , distortion2 ) ; //<S2SV> hybrid_rd = RDCOST ( x -> rdmult , x -> rddiv , hybrid_rate , distortion2 ) ; //<S2SV> if ( second_ref_frame <= INTRA_FRAME && //<S2SV> single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) { //<S2SV> best_pred_rd [ SINGLE_REFERENCE ] = single_rd ; //<S2SV> } else if ( second_ref_frame > INTRA_FRAME && //<S2SV> single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) { //<S2SV> best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ; //<S2SV> } //<S2SV> if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] ) //<S2SV> best_pred_rd [ REFERENCE_MODE_SELECT ] = hybrid_rd ; //<S2SV> } //<S2SV> if ( ! mode_excluded && ! disable_skip && ref_frame != INTRA_FRAME && //<S2SV> cm -> interp_filter != BILINEAR ) { //<S2SV> int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ? //<S2SV> SWITCHABLE_FILTERS : cm -> interp_filter ] ; //<S2SV> int64_t adj_rd ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { //<S2SV> if ( ref == INT64_MAX ) //<S2SV> adj_rd = 0 ; //<S2SV> else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX ) //<S2SV> adj_rd = cpi -> mask_filter_rd - ref + 10 ; //<S2SV> else //<S2SV> adj_rd = cpi -> rd_filter_cache [ i ] - ref ; //<S2SV> adj_rd += this_rd ; //<S2SV> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( bsize < BLOCK_32X32 ) { //<S2SV> if ( bsize < BLOCK_16X16 ) { //<S2SV> tx_cache [ ALLOW_8X8 ] = tx_cache [ ONLY_4X4 ] ; //<S2SV> tx_cache [ ALLOW_16X16 ] = tx_cache [ ALLOW_8X8 ] ; //<S2SV> } //<S2SV> tx_cache [ ALLOW_32X32 ] = tx_cache [ ALLOW_16X16 ] ; //<S2SV> } //<S2SV> if ( ! mode_excluded && this_rd != INT64_MAX ) { //<S2SV> for ( i = 0 ; i < TX_MODES && tx_cache [ i ] < INT64_MAX ; i ++ ) { //<S2SV> int64_t adj_rd = INT64_MAX ; //<S2SV> if ( ref_frame > INTRA_FRAME ) //<S2SV> adj_rd = this_rd + tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ; //<S2SV> else //<S2SV> adj_rd = this_rd ; //<S2SV> if ( adj_rd < best_tx_rd [ i ] ) //<S2SV> best_tx_rd [ i ] = adj_rd ; //<S2SV> } //<S2SV> } //<S2SV> if ( early_term ) //<S2SV> break ; //<S2SV> if ( x -> skip && ! comp_pred ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( best_rd >= best_rd_so_far ) //<S2SV> return INT64_MAX ; //<S2SV> if ( cpi -> sf . use_uv_intra_rd_estimate ) { //<S2SV> if ( vp9_ref_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) { //<S2SV> TX_SIZE uv_tx_size ; //<S2SV> * mbmi = best_mbmode ; //<S2SV> uv_tx_size = get_uv_tx_size ( mbmi ) ; //<S2SV> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] , //<S2SV> & rate_uv_tokenonly [ uv_tx_size ] , //<S2SV> & dist_uv [ uv_tx_size ] , //<S2SV> & skip_uv [ uv_tx_size ] , //<S2SV> BLOCK_8X8 , uv_tx_size ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( best_rd == INT64_MAX && bsize < BLOCK_8X8 ) { //<S2SV> * returnrate = INT_MAX ; //<S2SV> * returndistortion = INT64_MAX ; //<S2SV> return best_rd ; //<S2SV> } //<S2SV> assert ( ( cm -> interp_filter == SWITCHABLE ) || //<S2SV> ( cm -> interp_filter == best_mbmode . interp_filter ) || //<S2SV> ! is_inter_block ( & best_mbmode ) ) ; //<S2SV> if ( cpi -> sf . adaptive_rd_thresh ) { //<S2SV> for ( mode_index = 0 ; mode_index < MAX_REFS ; ++ mode_index ) { //<S2SV> int * const fact = & cpi -> rd_thresh_freq_sub8x8 [ bsize ] [ mode_index ] ; //<S2SV> if ( mode_index == best_mode_index ) { //<S2SV> * fact -= ( * fact >> 3 ) ; //<S2SV> } else { //<S2SV> * fact = MIN ( * fact + RD_THRESH_INC , //<S2SV> cpi -> sf . adaptive_rd_thresh * RD_THRESH_MAX_FACT ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> * mbmi = best_mbmode ; //<S2SV> x -> skip |= best_skip2 ; //<S2SV> if ( ! is_inter_block ( & best_mbmode ) ) { //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> xd -> mi [ 0 ] -> bmi [ i ] . as_mode = best_bmodes [ i ] . as_mode ; //<S2SV> } else { //<S2SV> for ( i = 0 ; i < 4 ; ++ i ) //<S2SV> vpx_memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ; //<S2SV> mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; //<S2SV> mbmi -> mv [ 1 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 1 ] . as_int ; //<S2SV> } //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { //<S2SV> if ( best_pred_rd [ i ] == INT64_MAX ) //<S2SV> best_pred_diff [ i ] = INT_MIN ; //<S2SV> else //<S2SV> best_pred_diff [ i ] = best_rd - best_pred_rd [ i ] ; //<S2SV> } //<S2SV> if ( ! x -> skip ) { //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { //<S2SV> if ( best_filter_rd [ i ] == INT64_MAX ) //<S2SV> best_filter_diff [ i ] = 0 ; //<S2SV> else //<S2SV> best_filter_diff [ i ] = best_rd - best_filter_rd [ i ] ; //<S2SV> } //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> assert ( best_filter_diff [ SWITCHABLE_FILTERS ] == 0 ) ; //<S2SV> } else { //<S2SV> vp9_zero ( best_filter_diff ) ; //<S2SV> } //<S2SV> if ( ! x -> skip ) { //<S2SV> for ( i = 0 ; i < TX_MODES ; i ++ ) { //<S2SV> if ( best_tx_rd [ i ] == INT64_MAX ) //<S2SV> best_tx_diff [ i ] = 0 ; //<S2SV> else //<S2SV> best_tx_diff [ i ] = best_rd - best_tx_rd [ i ] ; //<S2SV> } //<S2SV> } else { //<S2SV> vp9_zero ( best_tx_diff ) ; //<S2SV> } //<S2SV> set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; //<S2SV> store_coding_context ( x , ctx , best_mode_index , //<S2SV> & mbmi -> ref_mvs [ mbmi -> ref_frame [ 0 ] ] [ 0 ] , //<S2SV> & mbmi -> ref_mvs [ mbmi -> ref_frame [ 1 ] < 0 ? 0 : //<S2SV> mbmi -> ref_frame [ 1 ] ] [ 0 ] , //<S2SV> best_pred_diff , best_tx_diff , best_filter_diff ) ; //<S2SV> return best_rd ; //<S2SV> } //<S2SV> 