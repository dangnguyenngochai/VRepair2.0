int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , //<S2SV> const vp9_prob * oldp , //<S2SV> vp9_prob * bestp , //<S2SV> vp9_prob upd ) { //<S2SV> int i , old_b , new_b , update_b , savings , bestsavings , step ; //<S2SV> int newp ; //<S2SV> vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ; //<S2SV> vp9_model_to_full_probs ( oldp , oldplist ) ; //<S2SV> vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; //<S2SV> for ( i = UNCONSTRAINED_NODES , old_b = 0 ; i < ENTROPY_NODES ; ++ i ) //<S2SV> old_b += cost_branch256 ( ct + 2 * i , oldplist [ i ] ) ; //<S2SV> old_b += cost_branch256 ( ct + 2 * PIVOT_NODE , oldplist [ PIVOT_NODE ] ) ; //<S2SV> bestsavings = 0 ; //<S2SV> bestnewp = oldp [ PIVOT_NODE ] ; //<S2SV> step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ; //<S2SV> for ( newp = * bestp ; newp != oldp [ PIVOT_NODE ] ; newp += step ) { //<S2SV> if ( newp < 1 || newp > 255 ) //<S2SV> continue ; //<S2SV> newplist [ PIVOT_NODE ] = newp ; //<S2SV> vp9_model_to_full_probs ( newplist , newplist ) ; //<S2SV> for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) //<S2SV> new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; //<S2SV> new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; //<S2SV> update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + //<S2SV> vp9_cost_upd256 ; //<S2SV> savings = old_b - new_b - update_b ; //<S2SV> if ( savings > bestsavings ) { //<S2SV> bestsavings = savings ; //<S2SV> bestnewp = newp ; //<S2SV> } //<S2SV> } //<S2SV> * bestp = bestnewp ; //<S2SV> return bestsavings ; //<S2SV> } //<S2SV> 