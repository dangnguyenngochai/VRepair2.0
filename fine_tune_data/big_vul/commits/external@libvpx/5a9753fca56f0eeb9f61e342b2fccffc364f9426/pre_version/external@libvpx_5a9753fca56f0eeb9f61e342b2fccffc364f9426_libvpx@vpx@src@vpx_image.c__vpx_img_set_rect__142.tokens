int vpx_img_set_rect ( vpx_image_t * img , //<S2SV> unsigned int x , //<S2SV> unsigned int y , //<S2SV> unsigned int w , //<S2SV> unsigned int h ) { //<S2SV> unsigned char * data ; //<S2SV> if ( x + w <= img -> w && y + h <= img -> h ) { //<S2SV> img -> d_w = w ; //<S2SV> img -> d_h = h ; //<S2SV> if ( ! ( img -> fmt & VPX_IMG_FMT_PLANAR ) ) { //<S2SV> img -> planes [ VPX_PLANE_PACKED ] = //<S2SV> img -> img_data + x * img -> bps / 8 + y * img -> stride [ VPX_PLANE_PACKED ] ; //<S2SV> } else { //<S2SV> data = img -> img_data ; //<S2SV> if ( img -> fmt & VPX_IMG_FMT_HAS_ALPHA ) { //<S2SV> img -> planes [ VPX_PLANE_ALPHA ] = //<S2SV> data + x + y * img -> stride [ VPX_PLANE_ALPHA ] ; //<S2SV> data += img -> h * img -> stride [ VPX_PLANE_ALPHA ] ; //<S2SV> } //<S2SV> img -> planes [ VPX_PLANE_Y ] = data + x + y * img -> stride [ VPX_PLANE_Y ] ; //<S2SV> data += img -> h * img -> stride [ VPX_PLANE_Y ] ; //<S2SV> if ( ! ( img -> fmt & VPX_IMG_FMT_UV_FLIP ) ) { //<S2SV> img -> planes [ VPX_PLANE_U ] = data //<S2SV> + ( x >> img -> x_chroma_shift ) //<S2SV> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; //<S2SV> data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; //<S2SV> img -> planes [ VPX_PLANE_V ] = data //<S2SV> + ( x >> img -> x_chroma_shift ) //<S2SV> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; //<S2SV> } else { //<S2SV> img -> planes [ VPX_PLANE_V ] = data //<S2SV> + ( x >> img -> x_chroma_shift ) //<S2SV> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; //<S2SV> data += ( img -> h >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_V ] ; //<S2SV> img -> planes [ VPX_PLANE_U ] = data //<S2SV> + ( x >> img -> x_chroma_shift ) //<S2SV> + ( y >> img -> y_chroma_shift ) * img -> stride [ VPX_PLANE_U ] ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> return - 1 ; //<S2SV> } //<S2SV> 