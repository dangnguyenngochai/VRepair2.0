static void nonrd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> TOKENEXTRA * * tp , int mi_row , //<S2SV> int mi_col , BLOCK_SIZE bsize , int * rate , //<S2SV> int64_t * dist , int do_recon , int64_t best_rd ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const int ms = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; //<S2SV> TOKENEXTRA * tp_orig = * tp ; //<S2SV> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; //<S2SV> int i ; //<S2SV> BLOCK_SIZE subsize ; //<S2SV> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; //<S2SV> int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; //<S2SV> int64_t sum_rd = 0 ; //<S2SV> int do_split = bsize >= BLOCK_8X8 ; //<S2SV> int do_rect = 1 ; //<S2SV> const int force_horz_split = ( mi_row + ms >= cm -> mi_rows ) ; //<S2SV> const int force_vert_split = ( mi_col + ms >= cm -> mi_cols ) ; //<S2SV> const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; //<S2SV> const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; //<S2SV> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; //<S2SV> int partition_horz_allowed = ! force_vert_split && yss <= xss && //<S2SV> bsize >= BLOCK_8X8 ; //<S2SV> int partition_vert_allowed = ! force_horz_split && xss <= yss && //<S2SV> bsize >= BLOCK_8X8 ; //<S2SV> ( void ) * tp_orig ; //<S2SV> if ( bsize < BLOCK_8X8 ) { //<S2SV> if ( x -> ab_index != 0 ) { //<S2SV> * rate = 0 ; //<S2SV> * dist = 0 ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> assert ( num_8x8_blocks_wide_lookup [ bsize ] == //<S2SV> num_8x8_blocks_high_lookup [ bsize ] ) ; //<S2SV> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; //<S2SV> if ( cpi -> sf . auto_min_max_partition_size ) { //<S2SV> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && //<S2SV> bsize >= cpi -> sf . min_partition_size ) ; //<S2SV> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && //<S2SV> bsize > cpi -> sf . min_partition_size ) || //<S2SV> force_horz_split ) ; //<S2SV> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && //<S2SV> bsize > cpi -> sf . min_partition_size ) || //<S2SV> force_vert_split ) ; //<S2SV> do_split &= bsize > cpi -> sf . min_partition_size ; //<S2SV> } //<S2SV> if ( cpi -> sf . use_square_partition_only ) { //<S2SV> partition_horz_allowed &= force_horz_split ; //<S2SV> partition_vert_allowed &= force_vert_split ; //<S2SV> } //<S2SV> if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) //<S2SV> do_split = 0 ; //<S2SV> if ( partition_none_allowed ) { //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , //<S2SV> & this_rate , & this_dist , bsize ) ; //<S2SV> ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> if ( this_rate != INT_MAX ) { //<S2SV> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> int64_t stop_thresh = 4096 ; //<S2SV> int64_t stop_thresh_rd ; //<S2SV> best_rate = this_rate ; //<S2SV> best_dist = this_dist ; //<S2SV> best_rd = sum_rd ; //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; //<S2SV> stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + //<S2SV> b_height_log2_lookup [ bsize ] ) ; //<S2SV> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; //<S2SV> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { //<S2SV> do_split = 0 ; //<S2SV> do_rect = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! x -> in_active_map ) { //<S2SV> do_split = 0 ; //<S2SV> do_rect = 0 ; //<S2SV> } //<S2SV> } //<S2SV> store_pred_mv ( x , ctx ) ; //<S2SV> sum_rd = 0 ; //<S2SV> if ( do_split ) { //<S2SV> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; //<S2SV> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; //<S2SV> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { //<S2SV> const int x_idx = ( i & 1 ) * ms ; //<S2SV> const int y_idx = ( i >> 1 ) * ms ; //<S2SV> if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) //<S2SV> continue ; //<S2SV> * get_sb_index ( x , subsize ) = i ; //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> nonrd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , //<S2SV> subsize , & this_rate , & this_dist , 0 , //<S2SV> best_rd - sum_rd ) ; //<S2SV> if ( this_rate == INT_MAX ) { //<S2SV> sum_rd = INT64_MAX ; //<S2SV> } else { //<S2SV> sum_rate += this_rate ; //<S2SV> sum_dist += this_dist ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> best_rate = sum_rate ; //<S2SV> best_dist = sum_dist ; //<S2SV> best_rd = sum_rd ; //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> } else { //<S2SV> if ( cpi -> sf . less_rectangular_check ) //<S2SV> do_rect &= ! partition_none_allowed ; //<S2SV> } //<S2SV> } //<S2SV> if ( partition_horz_allowed && do_rect ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , //<S2SV> & this_rate , & this_dist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> if ( sum_rd < best_rd && mi_row + ms < cm -> mi_rows ) { //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row + ms , mi_col , //<S2SV> & this_rate , & this_dist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> if ( this_rate == INT_MAX ) { //<S2SV> sum_rd = INT64_MAX ; //<S2SV> } else { //<S2SV> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> this_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ; //<S2SV> sum_rate += this_rate ; //<S2SV> sum_dist += this_dist ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> best_rd = sum_rd ; //<S2SV> best_rate = sum_rate ; //<S2SV> best_dist = sum_dist ; //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> } //<S2SV> } //<S2SV> if ( partition_vert_allowed && do_rect ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_VERT ) ; //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , //<S2SV> & this_rate , & this_dist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> if ( sum_rd < best_rd && mi_col + ms < cm -> mi_cols ) { //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ms , //<S2SV> & this_rate , & this_dist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> if ( this_rate == INT_MAX ) { //<S2SV> sum_rd = INT64_MAX ; //<S2SV> } else { //<S2SV> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> this_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ; //<S2SV> sum_rate += this_rate ; //<S2SV> sum_dist += this_dist ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> best_rate = sum_rate ; //<S2SV> best_dist = sum_dist ; //<S2SV> best_rd = sum_rd ; //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> } //<S2SV> } //<S2SV> * rate = best_rate ; //<S2SV> * dist = best_dist ; //<S2SV> if ( best_rate == INT_MAX ) //<S2SV> return ; //<S2SV> fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize , //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) ) ; //<S2SV> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { //<S2SV> int output_enabled = ( bsize == BLOCK_64X64 ) ; //<S2SV> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { //<S2SV> vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , //<S2SV> best_rate ) ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) //<S2SV> vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , //<S2SV> best_rate , best_dist ) ; //<S2SV> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; //<S2SV> } //<S2SV> if ( bsize == BLOCK_64X64 ) { //<S2SV> assert ( tp_orig < * tp ) ; //<S2SV> assert ( best_rate < INT_MAX ) ; //<S2SV> assert ( best_dist < INT64_MAX ) ; //<S2SV> } else { //<S2SV> assert ( tp_orig == * tp ) ; //<S2SV> } //<S2SV> } //<S2SV> 