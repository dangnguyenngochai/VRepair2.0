void vp9_first_pass ( VP9_COMP * cpi ) { //<S2SV> int mb_row , mb_col ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> TileInfo tile ; //<S2SV> struct macroblock_plane * const p = x -> plane ; //<S2SV> struct macroblockd_plane * const pd = xd -> plane ; //<S2SV> const PICK_MODE_CONTEXT * ctx = & x -> sb64_context ; //<S2SV> int i ; //<S2SV> int recon_yoffset , recon_uvoffset ; //<S2SV> YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; //<S2SV> YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; //<S2SV> YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ; //<S2SV> int recon_y_stride = lst_yv12 -> y_stride ; //<S2SV> int recon_uv_stride = lst_yv12 -> uv_stride ; //<S2SV> int uv_mb_height = 16 >> ( lst_yv12 -> y_height > lst_yv12 -> uv_height ) ; //<S2SV> int64_t intra_error = 0 ; //<S2SV> int64_t coded_error = 0 ; //<S2SV> int64_t sr_coded_error = 0 ; //<S2SV> int sum_mvr = 0 , sum_mvc = 0 ; //<S2SV> int sum_mvr_abs = 0 , sum_mvc_abs = 0 ; //<S2SV> int64_t sum_mvrs = 0 , sum_mvcs = 0 ; //<S2SV> int mvcount = 0 ; //<S2SV> int intercount = 0 ; //<S2SV> int second_ref_count = 0 ; //<S2SV> int intrapenalty = 256 ; //<S2SV> int neutral_count = 0 ; //<S2SV> int new_mv_count = 0 ; //<S2SV> int sum_in_vectors = 0 ; //<S2SV> uint32_t lastmv_as_int = 0 ; //<S2SV> struct twopass_rc * twopass = & cpi -> twopass ; //<S2SV> const MV zero_mv = { 0 , 0 } ; //<S2SV> const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ; //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { //<S2SV> MV_REFERENCE_FRAME ref_frame = LAST_FRAME ; //<S2SV> const YV12_BUFFER_CONFIG * scaled_ref_buf = NULL ; //<S2SV> twopass = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . twopass ; //<S2SV> vp9_scale_references ( cpi ) ; //<S2SV> if ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) { //<S2SV> scaled_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ; //<S2SV> ref_frame = LAST_FRAME ; //<S2SV> } else if ( cpi -> ref_frame_flags & VP9_ALT_FLAG ) { //<S2SV> scaled_ref_buf = vp9_get_scaled_ref_frame ( cpi , ALTREF_FRAME ) ; //<S2SV> ref_frame = ALTREF_FRAME ; //<S2SV> } //<S2SV> if ( scaled_ref_buf != NULL ) { //<S2SV> first_ref_buf = scaled_ref_buf ; //<S2SV> recon_y_stride = first_ref_buf -> y_stride ; //<S2SV> recon_uv_stride = first_ref_buf -> uv_stride ; //<S2SV> uv_mb_height = 16 >> ( first_ref_buf -> y_height > first_ref_buf -> uv_height ) ; //<S2SV> } //<S2SV> gld_yv12 = NULL ; //<S2SV> set_ref_ptrs ( cm , xd , ref_frame , NONE ) ; //<S2SV> } //<S2SV> vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; //<S2SV> vp9_setup_pre_planes ( xd , 0 , first_ref_buf , 0 , 0 , NULL ) ; //<S2SV> vp9_setup_dst_planes ( xd , new_yv12 , 0 , 0 ) ; //<S2SV> xd -> mi = cm -> mi_grid_visible ; //<S2SV> xd -> mi [ 0 ] = cm -> mi ; //<S2SV> vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; //<S2SV> vp9_frame_init_quantizer ( cpi ) ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ; //<S2SV> } //<S2SV> x -> skip_recode = 0 ; //<S2SV> vp9_init_mv_probs ( cm ) ; //<S2SV> vp9_initialize_rd_consts ( cpi ) ; //<S2SV> vp9_tile_init ( & tile , cm , 0 , 0 ) ; //<S2SV> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; ++ mb_row ) { //<S2SV> int_mv best_ref_mv ; //<S2SV> best_ref_mv . as_int = 0 ; //<S2SV> xd -> up_available = ( mb_row != 0 ) ; //<S2SV> recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; //<S2SV> recon_uvoffset = ( mb_row * recon_uv_stride * uv_mb_height ) ; //<S2SV> x -> mv_row_min = - ( ( mb_row * 16 ) + BORDER_MV_PIXELS_B16 ) ; //<S2SV> x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) //<S2SV> + BORDER_MV_PIXELS_B16 ; //<S2SV> for ( mb_col = 0 ; mb_col < cm -> mb_cols ; ++ mb_col ) { //<S2SV> int this_error ; //<S2SV> const int use_dc_pred = ( mb_col || mb_row ) && ( ! mb_col || ! mb_row ) ; //<S2SV> double error_weight = 1.0 ; //<S2SV> const BLOCK_SIZE bsize = get_bsize ( cm , mb_row , mb_col ) ; //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> xd -> plane [ 0 ] . dst . buf = new_yv12 -> y_buffer + recon_yoffset ; //<S2SV> xd -> plane [ 1 ] . dst . buf = new_yv12 -> u_buffer + recon_uvoffset ; //<S2SV> xd -> plane [ 2 ] . dst . buf = new_yv12 -> v_buffer + recon_uvoffset ; //<S2SV> xd -> left_available = ( mb_col != 0 ) ; //<S2SV> xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; //<S2SV> xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = INTRA_FRAME ; //<S2SV> set_mi_row_col ( xd , & tile , //<S2SV> mb_row << 1 , num_8x8_blocks_high_lookup [ bsize ] , //<S2SV> mb_col << 1 , num_8x8_blocks_wide_lookup [ bsize ] , //<S2SV> cm -> mi_rows , cm -> mi_cols ) ; //<S2SV> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { //<S2SV> const int energy = vp9_block_energy ( cpi , x , bsize ) ; //<S2SV> error_weight = vp9_vaq_inv_q_ratio ( energy ) ; //<S2SV> } //<S2SV> this_error = vp9_encode_intra ( x , use_dc_pred ) ; //<S2SV> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> this_error = ( int ) ( this_error * error_weight ) ; //<S2SV> } //<S2SV> this_error += intrapenalty ; //<S2SV> intra_error += ( int64_t ) this_error ; //<S2SV> x -> mv_col_min = - ( ( mb_col * 16 ) + BORDER_MV_PIXELS_B16 ) ; //<S2SV> x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + BORDER_MV_PIXELS_B16 ; //<S2SV> if ( cm -> current_video_frame > 0 ) { //<S2SV> int tmp_err , motion_error ; //<S2SV> int_mv mv , tmp_mv ; //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] . buf = first_ref_buf -> y_buffer + recon_yoffset ; //<S2SV> motion_error = zz_motion_search ( x ) ; //<S2SV> mv . as_int = tmp_mv . as_int = 0 ; //<S2SV> first_pass_motion_search ( cpi , x , & best_ref_mv . as_mv , & mv . as_mv , //<S2SV> & motion_error ) ; //<S2SV> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> motion_error = ( int ) ( motion_error * error_weight ) ; //<S2SV> } //<S2SV> if ( best_ref_mv . as_int ) { //<S2SV> tmp_err = INT_MAX ; //<S2SV> first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv , //<S2SV> & tmp_err ) ; //<S2SV> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> tmp_err = ( int ) ( tmp_err * error_weight ) ; //<S2SV> } //<S2SV> if ( tmp_err < motion_error ) { //<S2SV> motion_error = tmp_err ; //<S2SV> mv . as_int = tmp_mv . as_int ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> current_video_frame > 1 && gld_yv12 != NULL ) { //<S2SV> int gf_motion_error ; //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] . buf = gld_yv12 -> y_buffer + recon_yoffset ; //<S2SV> gf_motion_error = zz_motion_search ( x ) ; //<S2SV> first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv , //<S2SV> & gf_motion_error ) ; //<S2SV> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> gf_motion_error = ( int ) ( gf_motion_error * error_weight ) ; //<S2SV> } //<S2SV> if ( gf_motion_error < motion_error && gf_motion_error < this_error ) //<S2SV> ++ second_ref_count ; //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] . buf = first_ref_buf -> y_buffer + recon_yoffset ; //<S2SV> xd -> plane [ 1 ] . pre [ 0 ] . buf = first_ref_buf -> u_buffer + recon_uvoffset ; //<S2SV> xd -> plane [ 2 ] . pre [ 0 ] . buf = first_ref_buf -> v_buffer + recon_uvoffset ; //<S2SV> if ( gf_motion_error < this_error ) //<S2SV> sr_coded_error += gf_motion_error ; //<S2SV> else //<S2SV> sr_coded_error += this_error ; //<S2SV> } else { //<S2SV> sr_coded_error += motion_error ; //<S2SV> } //<S2SV> best_ref_mv . as_int = 0 ; //<S2SV> if ( motion_error <= this_error ) { //<S2SV> if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) && //<S2SV> this_error < 2 * intrapenalty ) //<S2SV> ++ neutral_count ; //<S2SV> mv . as_mv . row *= 8 ; //<S2SV> mv . as_mv . col *= 8 ; //<S2SV> this_error = motion_error ; //<S2SV> xd -> mi [ 0 ] -> mbmi . mode = NEWMV ; //<S2SV> xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = mv ; //<S2SV> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; //<S2SV> xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ; //<S2SV> xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mb_row << 1 , mb_col << 1 , bsize ) ; //<S2SV> vp9_encode_sby_pass1 ( x , bsize ) ; //<S2SV> sum_mvr += mv . as_mv . row ; //<S2SV> sum_mvr_abs += abs ( mv . as_mv . row ) ; //<S2SV> sum_mvc += mv . as_mv . col ; //<S2SV> sum_mvc_abs += abs ( mv . as_mv . col ) ; //<S2SV> sum_mvrs += mv . as_mv . row * mv . as_mv . row ; //<S2SV> sum_mvcs += mv . as_mv . col * mv . as_mv . col ; //<S2SV> ++ intercount ; //<S2SV> best_ref_mv . as_int = mv . as_int ; //<S2SV> if ( mv . as_int ) { //<S2SV> ++ mvcount ; //<S2SV> if ( mv . as_int != lastmv_as_int ) //<S2SV> ++ new_mv_count ; //<S2SV> lastmv_as_int = mv . as_int ; //<S2SV> if ( mb_row < cm -> mb_rows / 2 ) { //<S2SV> if ( mv . as_mv . row > 0 ) //<S2SV> -- sum_in_vectors ; //<S2SV> else if ( mv . as_mv . row < 0 ) //<S2SV> ++ sum_in_vectors ; //<S2SV> } else if ( mb_row > cm -> mb_rows / 2 ) { //<S2SV> if ( mv . as_mv . row > 0 ) //<S2SV> ++ sum_in_vectors ; //<S2SV> else if ( mv . as_mv . row < 0 ) //<S2SV> -- sum_in_vectors ; //<S2SV> } //<S2SV> if ( mb_col < cm -> mb_cols / 2 ) { //<S2SV> if ( mv . as_mv . col > 0 ) //<S2SV> -- sum_in_vectors ; //<S2SV> else if ( mv . as_mv . col < 0 ) //<S2SV> ++ sum_in_vectors ; //<S2SV> } else if ( mb_col > cm -> mb_cols / 2 ) { //<S2SV> if ( mv . as_mv . col > 0 ) //<S2SV> ++ sum_in_vectors ; //<S2SV> else if ( mv . as_mv . col < 0 ) //<S2SV> -- sum_in_vectors ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> sr_coded_error += ( int64_t ) this_error ; //<S2SV> } //<S2SV> coded_error += ( int64_t ) this_error ; //<S2SV> x -> plane [ 0 ] . src . buf += 16 ; //<S2SV> x -> plane [ 1 ] . src . buf += uv_mb_height ; //<S2SV> x -> plane [ 2 ] . src . buf += uv_mb_height ; //<S2SV> recon_yoffset += 16 ; //<S2SV> recon_uvoffset += uv_mb_height ; //<S2SV> } //<S2SV> x -> plane [ 0 ] . src . buf += 16 * x -> plane [ 0 ] . src . stride - 16 * cm -> mb_cols ; //<S2SV> x -> plane [ 1 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - //<S2SV> uv_mb_height * cm -> mb_cols ; //<S2SV> x -> plane [ 2 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - //<S2SV> uv_mb_height * cm -> mb_cols ; //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> } //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> { //<S2SV> FIRSTPASS_STATS fps ; //<S2SV> fps . frame = cm -> current_video_frame ; //<S2SV> fps . spatial_layer_id = cpi -> svc . spatial_layer_id ; //<S2SV> fps . intra_error = ( double ) ( intra_error >> 8 ) ; //<S2SV> fps . coded_error = ( double ) ( coded_error >> 8 ) ; //<S2SV> fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) ; //<S2SV> fps . ssim_weighted_pred_err = fps . coded_error * simple_weight ( cpi -> Source ) ; //<S2SV> fps . count = 1.0 ; //<S2SV> fps . pcnt_inter = ( double ) intercount / cm -> MBs ; //<S2SV> fps . pcnt_second_ref = ( double ) second_ref_count / cm -> MBs ; //<S2SV> fps . pcnt_neutral = ( double ) neutral_count / cm -> MBs ; //<S2SV> if ( mvcount > 0 ) { //<S2SV> fps . MVr = ( double ) sum_mvr / mvcount ; //<S2SV> fps . mvr_abs = ( double ) sum_mvr_abs / mvcount ; //<S2SV> fps . MVc = ( double ) sum_mvc / mvcount ; //<S2SV> fps . mvc_abs = ( double ) sum_mvc_abs / mvcount ; //<S2SV> fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / mvcount ) ) / mvcount ; //<S2SV> fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / mvcount ) ) / mvcount ; //<S2SV> fps . mv_in_out_count = ( double ) sum_in_vectors / ( mvcount * 2 ) ; //<S2SV> fps . new_mv_count = new_mv_count ; //<S2SV> fps . pcnt_motion = ( double ) mvcount / cm -> MBs ; //<S2SV> } else { //<S2SV> fps . MVr = 0.0 ; //<S2SV> fps . mvr_abs = 0.0 ; //<S2SV> fps . MVc = 0.0 ; //<S2SV> fps . mvc_abs = 0.0 ; //<S2SV> fps . MVrv = 0.0 ; //<S2SV> fps . MVcv = 0.0 ; //<S2SV> fps . mv_in_out_count = 0.0 ; //<S2SV> fps . new_mv_count = 0.0 ; //<S2SV> fps . pcnt_motion = 0.0 ; //<S2SV> } //<S2SV> fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ; //<S2SV> twopass -> this_frame_stats = fps ; //<S2SV> output_stats ( & twopass -> this_frame_stats , cpi -> output_pkt_list ) ; //<S2SV> accumulate_stats ( & twopass -> total_stats , & fps ) ; //<S2SV> } //<S2SV> if ( ( twopass -> sr_update_lag > 3 ) || //<S2SV> ( ( cm -> current_video_frame > 0 ) && //<S2SV> ( twopass -> this_frame_stats . pcnt_inter > 0.20 ) && //<S2SV> ( ( twopass -> this_frame_stats . intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( twopass -> this_frame_stats . coded_error ) ) > 2.0 ) ) ) { //<S2SV> if ( gld_yv12 != NULL ) { //<S2SV> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; //<S2SV> } //<S2SV> twopass -> sr_update_lag = 1 ; //<S2SV> } else { //<S2SV> ++ twopass -> sr_update_lag ; //<S2SV> } //<S2SV> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { //<S2SV> vp9_update_reference_frames ( cpi ) ; //<S2SV> } else { //<S2SV> swap_yv12 ( lst_yv12 , new_yv12 ) ; //<S2SV> } //<S2SV> vp9_extend_frame_borders ( lst_yv12 ) ; //<S2SV> if ( cm -> current_video_frame == 0 && gld_yv12 != NULL ) { //<S2SV> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; //<S2SV> } //<S2SV> if ( 0 ) { //<S2SV> char filename [ 512 ] ; //<S2SV> FILE * recon_file ; //<S2SV> snprintf ( filename , sizeof ( filename ) , "enc%04d.yuv" , //<S2SV> ( int ) cm -> current_video_frame ) ; //<S2SV> if ( cm -> current_video_frame == 0 ) //<S2SV> recon_file = fopen ( filename , "wb" ) ; //<S2SV> else //<S2SV> recon_file = fopen ( filename , "ab" ) ; //<S2SV> ( void ) fwrite ( lst_yv12 -> buffer_alloc , lst_yv12 -> frame_size , 1 , recon_file ) ; //<S2SV> fclose ( recon_file ) ; //<S2SV> } //<S2SV> ++ cm -> current_video_frame ; //<S2SV> } //<S2SV> 