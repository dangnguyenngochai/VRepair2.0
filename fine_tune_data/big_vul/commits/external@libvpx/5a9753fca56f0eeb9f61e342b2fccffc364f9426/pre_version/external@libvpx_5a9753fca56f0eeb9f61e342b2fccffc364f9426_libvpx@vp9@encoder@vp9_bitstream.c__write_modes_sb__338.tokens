static void write_modes_sb ( VP9_COMP * cpi , //<S2SV> const TileInfo * const tile , //<S2SV> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , //<S2SV> int mi_row , int mi_col , BLOCK_SIZE bsize ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; //<S2SV> const int bsl = b_width_log2 ( bsize ) ; //<S2SV> const int bs = ( 1 << bsl ) / 4 ; //<S2SV> PARTITION_TYPE partition ; //<S2SV> BLOCK_SIZE subsize ; //<S2SV> MODE_INFO * m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ; //<S2SV> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) //<S2SV> return ; //<S2SV> partition = partition_lookup [ bsl ] [ m -> mbmi . sb_type ] ; //<S2SV> write_partition ( cm , xd , bs , mi_row , mi_col , partition , bsize , w ) ; //<S2SV> subsize = get_subsize ( bsize , partition ) ; //<S2SV> if ( subsize < BLOCK_8X8 ) { //<S2SV> write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; //<S2SV> } else { //<S2SV> switch ( partition ) { //<S2SV> case PARTITION_NONE : //<S2SV> write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; //<S2SV> break ; //<S2SV> case PARTITION_HORZ : //<S2SV> write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; //<S2SV> if ( mi_row + bs < cm -> mi_rows ) //<S2SV> write_modes_b ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col ) ; //<S2SV> break ; //<S2SV> case PARTITION_VERT : //<S2SV> write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; //<S2SV> if ( mi_col + bs < cm -> mi_cols ) //<S2SV> write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs ) ; //<S2SV> break ; //<S2SV> case PARTITION_SPLIT : //<S2SV> write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col , subsize ) ; //<S2SV> write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs , //<S2SV> subsize ) ; //<S2SV> write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col , //<S2SV> subsize ) ; //<S2SV> write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col + bs , //<S2SV> subsize ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( bsize >= BLOCK_8X8 && //<S2SV> ( bsize == BLOCK_8X8 || partition != PARTITION_SPLIT ) ) //<S2SV> update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; //<S2SV> } //<S2SV> 