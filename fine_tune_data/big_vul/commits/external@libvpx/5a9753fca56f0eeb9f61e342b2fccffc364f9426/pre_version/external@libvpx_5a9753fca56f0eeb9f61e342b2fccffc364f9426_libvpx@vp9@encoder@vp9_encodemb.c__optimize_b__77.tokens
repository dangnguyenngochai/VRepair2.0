static void optimize_b ( int plane , int block , BLOCK_SIZE plane_bsize , //<S2SV> TX_SIZE tx_size , MACROBLOCK * mb , //<S2SV> ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) { //<S2SV> MACROBLOCKD * const xd = & mb -> e_mbd ; //<S2SV> struct macroblock_plane * p = & mb -> plane [ plane ] ; //<S2SV> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; //<S2SV> const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ; //<S2SV> vp9_token_state tokens [ 1025 ] [ 2 ] ; //<S2SV> unsigned best_index [ 1025 ] [ 2 ] ; //<S2SV> const int16_t * coeff = BLOCK_OFFSET ( mb -> plane [ plane ] . coeff , block ) ; //<S2SV> int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; //<S2SV> int16_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; //<S2SV> int eob = p -> eobs [ block ] , final_eob , sz = 0 ; //<S2SV> const int i0 = 0 ; //<S2SV> int rc , x , next , i ; //<S2SV> int64_t rdmult , rddiv , rd_cost0 , rd_cost1 ; //<S2SV> int rate0 , rate1 , error0 , error1 , t0 , t1 ; //<S2SV> int best , band , pt ; //<S2SV> PLANE_TYPE type = pd -> plane_type ; //<S2SV> int err_mult = plane_rd_mult [ type ] ; //<S2SV> const int default_eob = 16 << ( tx_size << 1 ) ; //<S2SV> const int mul = 1 + ( tx_size == TX_32X32 ) ; //<S2SV> uint8_t token_cache [ 1024 ] ; //<S2SV> const int16_t * dequant_ptr = pd -> dequant ; //<S2SV> const uint8_t * const band_translate = get_band_translate ( tx_size ) ; //<S2SV> const scan_order * so = get_scan ( xd , tx_size , type , block ) ; //<S2SV> const int16_t * scan = so -> scan ; //<S2SV> const int16_t * nb = so -> neighbors ; //<S2SV> assert ( ( ! type && ! plane ) || ( type && plane ) ) ; //<S2SV> assert ( eob <= default_eob ) ; //<S2SV> rdmult = mb -> rdmult * err_mult ; //<S2SV> if ( ! is_inter_block ( & mb -> e_mbd . mi [ 0 ] -> mbmi ) ) //<S2SV> rdmult = ( rdmult * 9 ) >> 4 ; //<S2SV> rddiv = mb -> rddiv ; //<S2SV> tokens [ eob ] [ 0 ] . rate = 0 ; //<S2SV> tokens [ eob ] [ 0 ] . error = 0 ; //<S2SV> tokens [ eob ] [ 0 ] . next = default_eob ; //<S2SV> tokens [ eob ] [ 0 ] . token = EOB_TOKEN ; //<S2SV> tokens [ eob ] [ 0 ] . qc = 0 ; //<S2SV> * ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ; //<S2SV> next = eob ; //<S2SV> for ( i = 0 ; i < eob ; i ++ ) //<S2SV> token_cache [ scan [ i ] ] = vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ //<S2SV> qcoeff [ scan [ i ] ] ] . token ] ; //<S2SV> for ( i = eob ; i -- > i0 ; ) { //<S2SV> int base_bits , d2 , dx ; //<S2SV> rc = scan [ i ] ; //<S2SV> x = qcoeff [ rc ] ; //<S2SV> if ( x ) { //<S2SV> int shortcut = 0 ; //<S2SV> error0 = tokens [ next ] [ 0 ] . error ; //<S2SV> error1 = tokens [ next ] [ 1 ] . error ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> t0 = ( vp9_dct_value_tokens_ptr + x ) -> token ; //<S2SV> if ( next < default_eob ) { //<S2SV> band = band_translate [ i + 1 ] ; //<S2SV> pt = trellis_get_coeff_context ( scan , nb , i , t0 , token_cache ) ; //<S2SV> rate0 += //<S2SV> mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] //<S2SV> [ tokens [ next ] [ 0 ] . token ] ; //<S2SV> rate1 += //<S2SV> mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] //<S2SV> [ tokens [ next ] [ 1 ] . token ] ; //<S2SV> } //<S2SV> UPDATE_RD_COST ( ) ; //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> base_bits = * ( vp9_dct_value_cost_ptr + x ) ; //<S2SV> dx = mul * ( dqcoeff [ rc ] - coeff [ rc ] ) ; //<S2SV> d2 = dx * dx ; //<S2SV> tokens [ i ] [ 0 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; //<S2SV> tokens [ i ] [ 0 ] . error = d2 + ( best ? error1 : error0 ) ; //<S2SV> tokens [ i ] [ 0 ] . next = next ; //<S2SV> tokens [ i ] [ 0 ] . token = t0 ; //<S2SV> tokens [ i ] [ 0 ] . qc = x ; //<S2SV> best_index [ i ] [ 0 ] = best ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> if ( ( abs ( x ) * dequant_ptr [ rc != 0 ] > abs ( coeff [ rc ] ) * mul ) && //<S2SV> ( abs ( x ) * dequant_ptr [ rc != 0 ] < abs ( coeff [ rc ] ) * mul + //<S2SV> dequant_ptr [ rc != 0 ] ) ) //<S2SV> shortcut = 1 ; //<S2SV> else //<S2SV> shortcut = 0 ; //<S2SV> if ( shortcut ) { //<S2SV> sz = - ( x < 0 ) ; //<S2SV> x -= 2 * sz + 1 ; //<S2SV> } //<S2SV> if ( ! x ) { //<S2SV> t0 = tokens [ next ] [ 0 ] . token == EOB_TOKEN ? EOB_TOKEN : ZERO_TOKEN ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token == EOB_TOKEN ? EOB_TOKEN : ZERO_TOKEN ; //<S2SV> } else { //<S2SV> t0 = t1 = ( vp9_dct_value_tokens_ptr + x ) -> token ; //<S2SV> } //<S2SV> if ( next < default_eob ) { //<S2SV> band = band_translate [ i + 1 ] ; //<S2SV> if ( t0 != EOB_TOKEN ) { //<S2SV> pt = trellis_get_coeff_context ( scan , nb , i , t0 , token_cache ) ; //<S2SV> rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ ! x ] [ pt ] //<S2SV> [ tokens [ next ] [ 0 ] . token ] ; //<S2SV> } //<S2SV> if ( t1 != EOB_TOKEN ) { //<S2SV> pt = trellis_get_coeff_context ( scan , nb , i , t1 , token_cache ) ; //<S2SV> rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ ! x ] [ pt ] //<S2SV> [ tokens [ next ] [ 1 ] . token ] ; //<S2SV> } //<S2SV> } //<S2SV> UPDATE_RD_COST ( ) ; //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> base_bits = * ( vp9_dct_value_cost_ptr + x ) ; //<S2SV> if ( shortcut ) { //<S2SV> dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; //<S2SV> d2 = dx * dx ; //<S2SV> } //<S2SV> tokens [ i ] [ 1 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; //<S2SV> tokens [ i ] [ 1 ] . error = d2 + ( best ? error1 : error0 ) ; //<S2SV> tokens [ i ] [ 1 ] . next = next ; //<S2SV> tokens [ i ] [ 1 ] . token = best ? t1 : t0 ; //<S2SV> tokens [ i ] [ 1 ] . qc = x ; //<S2SV> best_index [ i ] [ 1 ] = best ; //<S2SV> next = i ; //<S2SV> } else { //<S2SV> band = band_translate [ i + 1 ] ; //<S2SV> t0 = tokens [ next ] [ 0 ] . token ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token ; //<S2SV> if ( t0 != EOB_TOKEN ) { //<S2SV> tokens [ next ] [ 0 ] . rate += //<S2SV> mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 1 ] [ 0 ] [ t0 ] ; //<S2SV> tokens [ next ] [ 0 ] . token = ZERO_TOKEN ; //<S2SV> } //<S2SV> if ( t1 != EOB_TOKEN ) { //<S2SV> tokens [ next ] [ 1 ] . rate += //<S2SV> mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 1 ] [ 0 ] [ t1 ] ; //<S2SV> tokens [ next ] [ 1 ] . token = ZERO_TOKEN ; //<S2SV> } //<S2SV> best_index [ i ] [ 0 ] = best_index [ i ] [ 1 ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> band = band_translate [ i + 1 ] ; //<S2SV> pt = combine_entropy_contexts ( * a , * l ) ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> error0 = tokens [ next ] [ 0 ] . error ; //<S2SV> error1 = tokens [ next ] [ 1 ] . error ; //<S2SV> t0 = tokens [ next ] [ 0 ] . token ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token ; //<S2SV> rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t0 ] ; //<S2SV> rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] [ t1 ] ; //<S2SV> UPDATE_RD_COST ( ) ; //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> final_eob = i0 - 1 ; //<S2SV> vpx_memset ( qcoeff , 0 , sizeof ( * qcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ; //<S2SV> vpx_memset ( dqcoeff , 0 , sizeof ( * dqcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ; //<S2SV> for ( i = next ; i < eob ; i = next ) { //<S2SV> x = tokens [ i ] [ best ] . qc ; //<S2SV> if ( x ) { //<S2SV> final_eob = i ; //<S2SV> } //<S2SV> rc = scan [ i ] ; //<S2SV> qcoeff [ rc ] = x ; //<S2SV> dqcoeff [ rc ] = ( x * dequant_ptr [ rc != 0 ] ) / mul ; //<S2SV> next = tokens [ i ] [ best ] . next ; //<S2SV> best = best_index [ i ] [ best ] ; //<S2SV> } //<S2SV> final_eob ++ ; //<S2SV> mb -> plane [ plane ] . eobs [ block ] = final_eob ; //<S2SV> * a = * l = ( final_eob > 0 ) ; //<S2SV> } //<S2SV> 