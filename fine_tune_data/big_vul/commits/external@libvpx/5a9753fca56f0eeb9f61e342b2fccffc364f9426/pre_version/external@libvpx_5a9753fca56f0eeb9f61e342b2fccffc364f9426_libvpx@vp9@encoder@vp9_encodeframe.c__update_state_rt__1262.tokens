static void update_state_rt ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , //<S2SV> int mi_row , int mi_col , int bsize ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> * ( xd -> mi [ 0 ] ) = ctx -> mic ; //<S2SV> if ( ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) && seg -> enabled ) { //<S2SV> vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , //<S2SV> mi_row , mi_col , bsize , 1 ) ; //<S2SV> vp9_init_plane_quantizers ( cpi , x ) ; //<S2SV> } //<S2SV> if ( is_inter_block ( mbmi ) ) { //<S2SV> vp9_update_mv_count ( cm , xd ) ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) { //<S2SV> const int pred_ctx = vp9_get_pred_context_switchable_interp ( xd ) ; //<S2SV> ++ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ; //<S2SV> } //<S2SV> } //<S2SV> x -> skip = ctx -> skip ; //<S2SV> } //<S2SV> 