static vpx_codec_err_t decoder_decode ( vpx_codec_alg_priv_t * ctx , //<S2SV> const uint8_t * data , unsigned int data_sz , //<S2SV> void * user_priv , long deadline ) { //<S2SV> const uint8_t * data_start = data ; //<S2SV> const uint8_t * data_end = data + data_sz ; //<S2SV> vpx_codec_err_t res = VPX_CODEC_OK ; //<S2SV> uint32_t sizes [ 8 ] ; //<S2SV> int frames_this_pts , frame_count = 0 ; //<S2SV> if ( data == NULL || data_sz == 0 ) //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> parse_superframe_index ( data , data_sz , sizes , & frames_this_pts ) ; //<S2SV> do { //<S2SV> if ( data_sz && ( * data_start & 0xe0 ) == 0xc0 ) { //<S2SV> const uint8_t marker = * data_start ; //<S2SV> const uint32_t frames = ( marker & 0x7 ) + 1 ; //<S2SV> const uint32_t mag = ( ( marker >> 3 ) & 0x3 ) + 1 ; //<S2SV> const uint32_t index_sz = 2 + mag * frames ; //<S2SV> if ( data_sz >= index_sz && data_start [ index_sz - 1 ] == marker ) { //<S2SV> data_start += index_sz ; //<S2SV> data_sz -= index_sz ; //<S2SV> if ( data_start < data_end ) //<S2SV> continue ; //<S2SV> else //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( frames_this_pts ) { //<S2SV> uint32_t this_sz = sizes [ frame_count ] ; //<S2SV> if ( data_sz < this_sz ) { //<S2SV> ctx -> base . err_detail = "Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index" ; //<S2SV> return VPX_CODEC_CORRUPT_FRAME ; //<S2SV> } //<S2SV> data_sz = this_sz ; //<S2SV> frame_count ++ ; //<S2SV> } //<S2SV> res = decode_one ( ctx , & data_start , data_sz , user_priv , deadline ) ; //<S2SV> assert ( data_start >= data ) ; //<S2SV> assert ( data_start <= data_end ) ; //<S2SV> if ( res ) //<S2SV> break ; //<S2SV> while ( data_start < data_end && * data_start == 0 ) //<S2SV> data_start ++ ; //<S2SV> data_sz = ( unsigned int ) ( data_end - data_start ) ; //<S2SV> } while ( data_start < data_end ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> 