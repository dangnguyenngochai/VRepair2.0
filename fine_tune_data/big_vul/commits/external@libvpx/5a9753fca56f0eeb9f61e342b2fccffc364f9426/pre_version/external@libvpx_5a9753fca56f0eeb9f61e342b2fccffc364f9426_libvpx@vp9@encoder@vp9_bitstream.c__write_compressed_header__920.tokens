static size_t write_compressed_header ( VP9_COMP * cpi , uint8_t * data ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; //<S2SV> FRAME_CONTEXT * const fc = & cm -> fc ; //<S2SV> vp9_writer header_bc ; //<S2SV> vp9_start_encode ( & header_bc , data ) ; //<S2SV> if ( xd -> lossless ) //<S2SV> cm -> tx_mode = ONLY_4X4 ; //<S2SV> else //<S2SV> encode_txfm_probs ( cm , & header_bc ) ; //<S2SV> update_coef_probs ( cpi , & header_bc ) ; //<S2SV> update_skip_probs ( cm , & header_bc ) ; //<S2SV> if ( ! frame_is_intra_only ( cm ) ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < INTER_MODE_CONTEXTS ; ++ i ) //<S2SV> prob_diff_update ( vp9_inter_mode_tree , cm -> fc . inter_mode_probs [ i ] , //<S2SV> cm -> counts . inter_mode [ i ] , INTER_MODES , & header_bc ) ; //<S2SV> vp9_zero ( cm -> counts . inter_mode ) ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> update_switchable_interp_probs ( cm , & header_bc ) ; //<S2SV> for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) //<S2SV> vp9_cond_prob_diff_update ( & header_bc , & fc -> intra_inter_prob [ i ] , //<S2SV> cm -> counts . intra_inter [ i ] ) ; //<S2SV> if ( cm -> allow_comp_inter_inter ) { //<S2SV> const int use_compound_pred = cm -> reference_mode != SINGLE_REFERENCE ; //<S2SV> const int use_hybrid_pred = cm -> reference_mode == REFERENCE_MODE_SELECT ; //<S2SV> vp9_write_bit ( & header_bc , use_compound_pred ) ; //<S2SV> if ( use_compound_pred ) { //<S2SV> vp9_write_bit ( & header_bc , use_hybrid_pred ) ; //<S2SV> if ( use_hybrid_pred ) //<S2SV> for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) //<S2SV> vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_inter_prob [ i ] , //<S2SV> cm -> counts . comp_inter [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> reference_mode != COMPOUND_REFERENCE ) { //<S2SV> for ( i = 0 ; i < REF_CONTEXTS ; i ++ ) { //<S2SV> vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 0 ] , //<S2SV> cm -> counts . single_ref [ i ] [ 0 ] ) ; //<S2SV> vp9_cond_prob_diff_update ( & header_bc , & fc -> single_ref_prob [ i ] [ 1 ] , //<S2SV> cm -> counts . single_ref [ i ] [ 1 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> reference_mode != SINGLE_REFERENCE ) //<S2SV> for ( i = 0 ; i < REF_CONTEXTS ; i ++ ) //<S2SV> vp9_cond_prob_diff_update ( & header_bc , & fc -> comp_ref_prob [ i ] , //<S2SV> cm -> counts . comp_ref [ i ] ) ; //<S2SV> for ( i = 0 ; i < BLOCK_SIZE_GROUPS ; ++ i ) //<S2SV> prob_diff_update ( vp9_intra_mode_tree , cm -> fc . y_mode_prob [ i ] , //<S2SV> cm -> counts . y_mode [ i ] , INTRA_MODES , & header_bc ) ; //<S2SV> for ( i = 0 ; i < PARTITION_CONTEXTS ; ++ i ) //<S2SV> prob_diff_update ( vp9_partition_tree , fc -> partition_prob [ i ] , //<S2SV> cm -> counts . partition [ i ] , PARTITION_TYPES , & header_bc ) ; //<S2SV> vp9_write_nmv_probs ( cm , cm -> allow_high_precision_mv , & header_bc ) ; //<S2SV> } //<S2SV> vp9_stop_encode ( & header_bc ) ; //<S2SV> assert ( header_bc . pos <= 0xffff ) ; //<S2SV> return header_bc . pos ; //<S2SV> } //<S2SV> 