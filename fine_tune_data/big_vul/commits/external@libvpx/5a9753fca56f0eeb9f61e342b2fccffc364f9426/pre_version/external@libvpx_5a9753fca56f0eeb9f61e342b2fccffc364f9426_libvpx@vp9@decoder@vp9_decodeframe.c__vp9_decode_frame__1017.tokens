int vp9_decode_frame ( VP9Decoder * pbi , //<S2SV> const uint8_t * data , const uint8_t * data_end , //<S2SV> const uint8_t * * p_data_end ) { //<S2SV> VP9_COMMON * const cm = & pbi -> common ; //<S2SV> MACROBLOCKD * const xd = & pbi -> mb ; //<S2SV> struct vp9_read_bit_buffer rb = { data , data_end , 0 , cm , error_handler } ; //<S2SV> const size_t first_partition_size = read_uncompressed_header ( pbi , & rb ) ; //<S2SV> const int keyframe = cm -> frame_type == KEY_FRAME ; //<S2SV> const int tile_rows = 1 << cm -> log2_tile_rows ; //<S2SV> const int tile_cols = 1 << cm -> log2_tile_cols ; //<S2SV> YV12_BUFFER_CONFIG * const new_fb = get_frame_new_buffer ( cm ) ; //<S2SV> xd -> cur_buf = new_fb ; //<S2SV> if ( ! first_partition_size ) { //<S2SV> * p_data_end = data + 1 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( ! pbi -> decoded_key_frame && ! keyframe ) //<S2SV> return - 1 ; //<S2SV> data += vp9_rb_bytes_read ( & rb ) ; //<S2SV> if ( ! read_is_valid ( data , first_partition_size , data_end ) ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Truncated<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>corrupt<S2SV_blank>header<S2SV_blank>length" ) ; //<S2SV> pbi -> do_loopfilter_inline = //<S2SV> ( cm -> log2_tile_rows | cm -> log2_tile_cols ) == 0 && cm -> lf . filter_level ; //<S2SV> if ( pbi -> do_loopfilter_inline && pbi -> lf_worker . data1 == NULL ) { //<S2SV> CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , //<S2SV> vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; //<S2SV> pbi -> lf_worker . hook = ( VP9WorkerHook ) vp9_loop_filter_worker ; //<S2SV> if ( pbi -> oxcf . max_threads > 1 && ! vp9_worker_reset ( & pbi -> lf_worker ) ) { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , //<S2SV> "Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> } //<S2SV> init_macroblockd ( cm , & pbi -> mb ) ; //<S2SV> cm -> prev_mi = get_prev_mi ( cm ) ; //<S2SV> setup_plane_dequants ( cm , xd , cm -> base_qindex ) ; //<S2SV> vp9_setup_block_planes ( xd , cm -> subsampling_x , cm -> subsampling_y ) ; //<S2SV> cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ; //<S2SV> vp9_zero ( cm -> counts ) ; //<S2SV> vp9_zero ( xd -> dqcoeff ) ; //<S2SV> xd -> corrupted = 0 ; //<S2SV> new_fb -> corrupted = read_compressed_header ( pbi , data , first_partition_size ) ; //<S2SV> if ( pbi -> oxcf . max_threads > 1 && tile_rows == 1 && tile_cols > 1 && //<S2SV> cm -> frame_parallel_decoding_mode ) { //<S2SV> * p_data_end = decode_tiles_mt ( pbi , data + first_partition_size , data_end ) ; //<S2SV> } else { //<S2SV> * p_data_end = decode_tiles ( pbi , data + first_partition_size , data_end ) ; //<S2SV> } //<S2SV> new_fb -> corrupted |= xd -> corrupted ; //<S2SV> if ( ! pbi -> decoded_key_frame ) { //<S2SV> if ( keyframe && ! new_fb -> corrupted ) //<S2SV> pbi -> decoded_key_frame = 1 ; //<S2SV> else //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame" ) ; //<S2SV> } //<S2SV> if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) { //<S2SV> vp9_adapt_coef_probs ( cm ) ; //<S2SV> if ( ! frame_is_intra_only ( cm ) ) { //<S2SV> vp9_adapt_mode_probs ( cm ) ; //<S2SV> vp9_adapt_mv_probs ( cm , cm -> allow_high_precision_mv ) ; //<S2SV> } //<S2SV> } else { //<S2SV> debug_check_frame_counts ( cm ) ; //<S2SV> } //<S2SV> if ( cm -> refresh_frame_context ) //<S2SV> cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 