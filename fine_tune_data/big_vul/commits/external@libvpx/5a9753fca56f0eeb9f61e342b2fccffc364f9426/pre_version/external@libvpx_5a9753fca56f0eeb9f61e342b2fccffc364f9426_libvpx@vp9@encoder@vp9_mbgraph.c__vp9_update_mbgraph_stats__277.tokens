void vp9_update_mbgraph_stats ( VP9_COMP * cpi ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> int i , n_frames = vp9_lookahead_depth ( cpi -> lookahead ) ; //<S2SV> YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; //<S2SV> if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) //<S2SV> return ; //<S2SV> if ( n_frames > MAX_LAG_BUFFERS ) //<S2SV> n_frames = MAX_LAG_BUFFERS ; //<S2SV> cpi -> mbgraph_n_frames = n_frames ; //<S2SV> for ( i = 0 ; i < n_frames ; i ++ ) { //<S2SV> MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; //<S2SV> vpx_memset ( frame_stats -> mb_stats , 0 , //<S2SV> cm -> mb_rows * cm -> mb_cols * //<S2SV> sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < n_frames ; i ++ ) { //<S2SV> MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; //<S2SV> struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ; //<S2SV> assert ( q_cur != NULL ) ; //<S2SV> update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , //<S2SV> golden_ref , cpi -> Source ) ; //<S2SV> } //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> separate_arf_mbs ( cpi ) ; //<S2SV> } //<S2SV> 