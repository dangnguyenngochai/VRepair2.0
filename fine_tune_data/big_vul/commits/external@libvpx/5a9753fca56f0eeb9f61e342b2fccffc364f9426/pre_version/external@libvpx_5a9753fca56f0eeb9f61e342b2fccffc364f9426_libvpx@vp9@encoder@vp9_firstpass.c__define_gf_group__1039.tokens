static void define_gf_group ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) { //<S2SV> RATE_CONTROL * const rc = & cpi -> rc ; //<S2SV> VP9_CONFIG * const oxcf = & cpi -> oxcf ; //<S2SV> struct twopass_rc * const twopass = & cpi -> twopass ; //<S2SV> FIRSTPASS_STATS next_frame = { 0 } ; //<S2SV> const FIRSTPASS_STATS * start_pos ; //<S2SV> int i ; //<S2SV> double boost_score = 0.0 ; //<S2SV> double old_boost_score = 0.0 ; //<S2SV> double gf_group_err = 0.0 ; //<S2SV> double gf_first_frame_err = 0.0 ; //<S2SV> double mod_frame_err = 0.0 ; //<S2SV> double mv_ratio_accumulator = 0.0 ; //<S2SV> double decay_accumulator = 1.0 ; //<S2SV> double zero_motion_accumulator = 1.0 ; //<S2SV> double loop_decay_rate = 1.00 ; //<S2SV> double last_loop_decay_rate = 1.00 ; //<S2SV> double this_frame_mv_in_out = 0.0 ; //<S2SV> double mv_in_out_accumulator = 0.0 ; //<S2SV> double abs_mv_in_out_accumulator = 0.0 ; //<S2SV> double mv_ratio_accumulator_thresh ; //<S2SV> const int max_bits = frame_max_bits ( rc , oxcf ) ; //<S2SV> unsigned int allow_alt_ref = oxcf -> play_alternate && oxcf -> lag_in_frames ; //<S2SV> int f_boost = 0 ; //<S2SV> int b_boost = 0 ; //<S2SV> int flash_detected ; //<S2SV> int active_max_gf_interval ; //<S2SV> twopass -> gf_group_bits = 0 ; //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> start_pos = twopass -> stats_in ; //<S2SV> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; //<S2SV> gf_first_frame_err = mod_frame_err ; //<S2SV> if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) //<S2SV> gf_group_err -= gf_first_frame_err ; //<S2SV> mv_ratio_accumulator_thresh = ( cpi -> common . width + cpi -> common . height ) / 10.0 ; //<S2SV> active_max_gf_interval = //<S2SV> 12 + ( ( int ) vp9_convert_qindex_to_q ( rc -> last_q [ INTER_FRAME ] ) >> 5 ) ; //<S2SV> if ( active_max_gf_interval > rc -> max_gf_interval ) //<S2SV> active_max_gf_interval = rc -> max_gf_interval ; //<S2SV> i = 0 ; //<S2SV> while ( i < rc -> static_scene_max_gf_interval && i < rc -> frames_to_key ) { //<S2SV> ++ i ; //<S2SV> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; //<S2SV> gf_group_err += mod_frame_err ; //<S2SV> if ( EOF == input_stats ( twopass , & next_frame ) ) //<S2SV> break ; //<S2SV> flash_detected = detect_flash ( twopass , 0 ) ; //<S2SV> accumulate_frame_motion_stats ( & next_frame , //<S2SV> & this_frame_mv_in_out , & mv_in_out_accumulator , //<S2SV> & abs_mv_in_out_accumulator , //<S2SV> & mv_ratio_accumulator ) ; //<S2SV> if ( ! flash_detected ) { //<S2SV> last_loop_decay_rate = loop_decay_rate ; //<S2SV> loop_decay_rate = get_prediction_decay_rate ( & cpi -> common , & next_frame ) ; //<S2SV> decay_accumulator = decay_accumulator * loop_decay_rate ; //<S2SV> if ( ( next_frame . pcnt_inter - next_frame . pcnt_motion ) < //<S2SV> zero_motion_accumulator ) { //<S2SV> zero_motion_accumulator = next_frame . pcnt_inter - //<S2SV> next_frame . pcnt_motion ; //<S2SV> } //<S2SV> if ( detect_transition_to_still ( twopass , i , 5 , loop_decay_rate , //<S2SV> last_loop_decay_rate ) ) { //<S2SV> allow_alt_ref = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> boost_score += ( decay_accumulator * //<S2SV> calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ) ; //<S2SV> if ( //<S2SV> ( i >= active_max_gf_interval && ( zero_motion_accumulator < 0.995 ) ) || //<S2SV> ( //<S2SV> ( i > MIN_GF_INTERVAL ) && //<S2SV> ( ( boost_score > 125.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && //<S2SV> ( ! flash_detected ) && //<S2SV> ( ( mv_ratio_accumulator > mv_ratio_accumulator_thresh ) || //<S2SV> ( abs_mv_in_out_accumulator > 3.0 ) || //<S2SV> ( mv_in_out_accumulator < - 2.0 ) || //<S2SV> ( ( boost_score - old_boost_score ) < IIFACTOR ) ) ) ) { //<S2SV> boost_score = old_boost_score ; //<S2SV> break ; //<S2SV> } //<S2SV> * this_frame = next_frame ; //<S2SV> old_boost_score = boost_score ; //<S2SV> } //<S2SV> twopass -> gf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 1000.0 ) ; //<S2SV> if ( ( rc -> frames_to_key - i ) < MIN_GF_INTERVAL ) { //<S2SV> while ( i < ( rc -> frames_to_key + ! rc -> next_key_frame_forced ) ) { //<S2SV> ++ i ; //<S2SV> if ( EOF == input_stats ( twopass , this_frame ) ) //<S2SV> break ; //<S2SV> if ( i < rc -> frames_to_key ) { //<S2SV> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; //<S2SV> gf_group_err += mod_frame_err ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # if CONFIG_MULTIPLE_ARF //<S2SV> if ( cpi -> multi_arf_enabled ) { //<S2SV> cpi -> new_frame_coding_order_period = 0 ; //<S2SV> cpi -> next_frame_in_order = 0 ; //<S2SV> cpi -> arf_buffered = 0 ; //<S2SV> vp9_zero ( cpi -> frame_coding_order ) ; //<S2SV> vp9_zero ( cpi -> arf_buffer_idx ) ; //<S2SV> vpx_memset ( cpi -> arf_weight , - 1 , sizeof ( cpi -> arf_weight ) ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( cpi -> common . frame_type == KEY_FRAME || rc -> source_alt_ref_active ) //<S2SV> rc -> baseline_gf_interval = i - 1 ; //<S2SV> else //<S2SV> rc -> baseline_gf_interval = i ; //<S2SV> if ( allow_alt_ref && //<S2SV> ( i < cpi -> oxcf . lag_in_frames ) && //<S2SV> ( i >= MIN_GF_INTERVAL ) && //<S2SV> ( rc -> next_key_frame_forced || //<S2SV> ( i <= ( rc -> frames_to_key - MIN_GF_INTERVAL ) ) ) ) { //<S2SV> rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , //<S2SV> & b_boost ) ; //<S2SV> rc -> source_alt_ref_pending = 1 ; //<S2SV> # if CONFIG_MULTIPLE_ARF //<S2SV> if ( cpi -> multi_arf_enabled ) { //<S2SV> schedule_frames ( cpi , 0 , - ( rc -> baseline_gf_interval - 1 ) , 2 , 1 , 0 ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } else { //<S2SV> rc -> gfu_boost = ( int ) boost_score ; //<S2SV> rc -> source_alt_ref_pending = 0 ; //<S2SV> # if CONFIG_MULTIPLE_ARF //<S2SV> if ( cpi -> multi_arf_enabled ) { //<S2SV> schedule_frames ( cpi , 0 , rc -> baseline_gf_interval - 1 , 2 , 0 , 0 ) ; //<S2SV> assert ( cpi -> new_frame_coding_order_period == //<S2SV> rc -> baseline_gf_interval ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> # if CONFIG_MULTIPLE_ARF //<S2SV> if ( cpi -> multi_arf_enabled && ( cpi -> common . frame_type != KEY_FRAME ) ) { //<S2SV> int max_level = INT_MIN ; //<S2SV> for ( i = 0 ; i < cpi -> frame_coding_order_period ; ++ i ) { //<S2SV> if ( cpi -> arf_weight [ i ] > max_level ) { //<S2SV> max_level = cpi -> arf_weight [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> ++ max_level ; //<S2SV> for ( i = 0 ; i < cpi -> frame_coding_order_period ; ++ i ) { //<S2SV> if ( cpi -> arf_weight [ i ] == - 1 ) { //<S2SV> cpi -> arf_weight [ i ] = max_level ; //<S2SV> } //<S2SV> } //<S2SV> cpi -> max_arf_level = max_level ; //<S2SV> } //<S2SV> # if 0 //<S2SV> if ( cpi -> multi_arf_enabled ) { //<S2SV> printf ( "\\nSchedule:<S2SV_blank>" ) ; //<S2SV> for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { //<S2SV> printf ( "%4d<S2SV_blank>" , cpi -> frame_coding_order [ i ] ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "ARFref:<S2SV_blank><S2SV_blank><S2SV_blank>" ) ; //<S2SV> for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { //<S2SV> printf ( "%4d<S2SV_blank>" , cpi -> arf_buffer_idx [ i ] ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "Weight:<S2SV_blank><S2SV_blank><S2SV_blank>" ) ; //<S2SV> for ( i = 0 ; i < cpi -> new_frame_coding_order_period ; ++ i ) { //<S2SV> printf ( "%4d<S2SV_blank>" , cpi -> arf_weight [ i ] ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # endif //<S2SV> if ( twopass -> kf_group_bits > 0 && twopass -> kf_group_error_left > 0 ) { //<S2SV> twopass -> gf_group_bits = ( int64_t ) ( twopass -> kf_group_bits * //<S2SV> ( gf_group_err / twopass -> kf_group_error_left ) ) ; //<S2SV> } else { //<S2SV> twopass -> gf_group_bits = 0 ; //<S2SV> } //<S2SV> twopass -> gf_group_bits = ( twopass -> gf_group_bits < 0 ) ? //<S2SV> 0 : ( twopass -> gf_group_bits > twopass -> kf_group_bits ) ? //<S2SV> twopass -> kf_group_bits : twopass -> gf_group_bits ; //<S2SV> if ( twopass -> gf_group_bits > ( int64_t ) max_bits * rc -> baseline_gf_interval ) //<S2SV> twopass -> gf_group_bits = ( int64_t ) max_bits * rc -> baseline_gf_interval ; //<S2SV> reset_fpf_position ( twopass , start_pos ) ; //<S2SV> for ( i = 0 ; i <= ( rc -> source_alt_ref_pending && //<S2SV> cpi -> common . frame_type != KEY_FRAME ) ; ++ i ) { //<S2SV> int allocation_chunks ; //<S2SV> int q = rc -> last_q [ INTER_FRAME ] ; //<S2SV> int gf_bits ; //<S2SV> int boost = ( rc -> gfu_boost * gfboost_qadjust ( q ) ) / 100 ; //<S2SV> boost = clamp ( boost , 125 , ( rc -> baseline_gf_interval + 1 ) * 200 ) ; //<S2SV> if ( rc -> source_alt_ref_pending && i == 0 ) //<S2SV> allocation_chunks = ( ( rc -> baseline_gf_interval + 1 ) * 100 ) + boost ; //<S2SV> else //<S2SV> allocation_chunks = ( rc -> baseline_gf_interval * 100 ) + ( boost - 100 ) ; //<S2SV> if ( boost > 1023 ) { //<S2SV> int divisor = boost >> 10 ; //<S2SV> boost /= divisor ; //<S2SV> allocation_chunks /= divisor ; //<S2SV> } //<S2SV> gf_bits = ( int ) ( ( double ) boost * ( twopass -> gf_group_bits / //<S2SV> ( double ) allocation_chunks ) ) ; //<S2SV> if ( rc -> baseline_gf_interval < 1 || //<S2SV> mod_frame_err < gf_group_err / ( double ) rc -> baseline_gf_interval ) { //<S2SV> double alt_gf_grp_bits = ( double ) twopass -> kf_group_bits * //<S2SV> ( mod_frame_err * ( double ) rc -> baseline_gf_interval ) / //<S2SV> DOUBLE_DIVIDE_CHECK ( twopass -> kf_group_error_left ) ; //<S2SV> int alt_gf_bits = ( int ) ( ( double ) boost * ( alt_gf_grp_bits / //<S2SV> ( double ) allocation_chunks ) ) ; //<S2SV> if ( gf_bits > alt_gf_bits ) //<S2SV> gf_bits = alt_gf_bits ; //<S2SV> } else { //<S2SV> int alt_gf_bits = ( int ) ( ( double ) twopass -> kf_group_bits * //<S2SV> mod_frame_err / //<S2SV> DOUBLE_DIVIDE_CHECK ( twopass -> kf_group_error_left ) ) ; //<S2SV> if ( alt_gf_bits > gf_bits ) //<S2SV> gf_bits = alt_gf_bits ; //<S2SV> } //<S2SV> if ( gf_bits < 0 ) //<S2SV> gf_bits = 0 ; //<S2SV> if ( i == 0 ) { //<S2SV> twopass -> gf_bits = gf_bits ; //<S2SV> } //<S2SV> if ( i == 1 || //<S2SV> ( ! rc -> source_alt_ref_pending && //<S2SV> cpi -> common . frame_type != KEY_FRAME ) ) { //<S2SV> vp9_rc_set_frame_target ( cpi , gf_bits ) ; //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; //<S2SV> if ( rc -> source_alt_ref_pending ) { //<S2SV> twopass -> gf_group_error_left = ( int64_t ) ( gf_group_err - mod_frame_err ) ; //<S2SV> } else if ( cpi -> common . frame_type != KEY_FRAME ) { //<S2SV> twopass -> gf_group_error_left = ( int64_t ) ( gf_group_err //<S2SV> - gf_first_frame_err ) ; //<S2SV> } else { //<S2SV> twopass -> gf_group_error_left = ( int64_t ) gf_group_err ; //<S2SV> } //<S2SV> if ( rc -> baseline_gf_interval >= 3 ) { //<S2SV> const int boost = rc -> source_alt_ref_pending ? b_boost : rc -> gfu_boost ; //<S2SV> if ( boost >= 150 ) { //<S2SV> const int pct_extra = MIN ( 20 , ( boost - 100 ) / 50 ) ; //<S2SV> const int alt_extra_bits = ( int ) ( ( //<S2SV> MAX ( twopass -> gf_group_bits - twopass -> gf_bits , 0 ) * //<S2SV> pct_extra ) / 100 ) ; //<S2SV> twopass -> gf_group_bits -= alt_extra_bits ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> common . frame_type != KEY_FRAME ) { //<S2SV> FIRSTPASS_STATS sectionstats ; //<S2SV> zero_stats ( & sectionstats ) ; //<S2SV> reset_fpf_position ( twopass , start_pos ) ; //<S2SV> for ( i = 0 ; i < rc -> baseline_gf_interval ; ++ i ) { //<S2SV> input_stats ( twopass , & next_frame ) ; //<S2SV> accumulate_stats ( & sectionstats , & next_frame ) ; //<S2SV> } //<S2SV> avg_stats ( & sectionstats ) ; //<S2SV> twopass -> section_intra_rating = ( int ) //<S2SV> ( sectionstats . intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; //<S2SV> reset_fpf_position ( twopass , start_pos ) ; //<S2SV> } //<S2SV> } //<S2SV> 