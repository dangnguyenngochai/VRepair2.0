static void estimate_missing_mvs ( MB_OVERLAP * overlaps , //<S2SV> MODE_INFO * mi , MODE_INFO * prev_mi , //<S2SV> int mb_rows , int mb_cols , //<S2SV> unsigned int first_corrupt ) //<S2SV> { //<S2SV> int mb_row , mb_col ; //<S2SV> vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; //<S2SV> for ( mb_row = 0 ; mb_row < mb_rows ; ++ mb_row ) //<S2SV> { //<S2SV> for ( mb_col = 0 ; mb_col < mb_cols ; ++ mb_col ) //<S2SV> { //<S2SV> if ( prev_mi -> mbmi . ref_frame == LAST_FRAME ) //<S2SV> { //<S2SV> calc_prev_mb_overlaps ( overlaps , prev_mi , //<S2SV> mb_row , mb_col , //<S2SV> mb_rows , mb_cols ) ; //<S2SV> } //<S2SV> ++ prev_mi ; //<S2SV> } //<S2SV> ++ prev_mi ; //<S2SV> } //<S2SV> mb_row = first_corrupt / mb_cols ; //<S2SV> mb_col = first_corrupt - mb_row * mb_cols ; //<S2SV> mi += mb_row * ( mb_cols + 1 ) + mb_col ; //<S2SV> for ( ; mb_row < mb_rows ; ++ mb_row ) //<S2SV> { //<S2SV> int mb_to_top_edge = - ( ( mb_row * 16 ) ) << 3 ; //<S2SV> int mb_to_bottom_edge = ( ( mb_rows - 1 - mb_row ) * 16 ) << 3 ; //<S2SV> for ( ; mb_col < mb_cols ; ++ mb_col ) //<S2SV> { //<S2SV> int mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; //<S2SV> int mb_to_right_edge = ( ( mb_cols - 1 - mb_col ) * 16 ) << 3 ; //<S2SV> const B_OVERLAP * block_overlaps = //<S2SV> overlaps [ mb_row * mb_cols + mb_col ] . overlaps ; //<S2SV> mi -> mbmi . ref_frame = LAST_FRAME ; //<S2SV> mi -> mbmi . mode = SPLITMV ; //<S2SV> mi -> mbmi . uv_mode = DC_PRED ; //<S2SV> mi -> mbmi . partitioning = 3 ; //<S2SV> mi -> mbmi . segment_id = 0 ; //<S2SV> estimate_mb_mvs ( block_overlaps , //<S2SV> mi , //<S2SV> mb_to_left_edge , //<S2SV> mb_to_right_edge , //<S2SV> mb_to_top_edge , //<S2SV> mb_to_bottom_edge ) ; //<S2SV> ++ mi ; //<S2SV> } //<S2SV> mb_col = 0 ; //<S2SV> ++ mi ; //<S2SV> } //<S2SV> } //<S2SV> 