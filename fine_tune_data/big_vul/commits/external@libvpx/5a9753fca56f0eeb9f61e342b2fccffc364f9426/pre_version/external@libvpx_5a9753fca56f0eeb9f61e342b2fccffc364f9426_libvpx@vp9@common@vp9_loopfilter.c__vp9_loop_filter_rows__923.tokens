void vp9_loop_filter_rows ( const YV12_BUFFER_CONFIG * frame_buffer , //<S2SV> VP9_COMMON * cm , MACROBLOCKD * xd , //<S2SV> int start , int stop , int y_only ) { //<S2SV> const int num_planes = y_only ? 1 : MAX_MB_PLANE ; //<S2SV> int mi_row , mi_col ; //<S2SV> LOOP_FILTER_MASK lfm ; //<S2SV> int use_420 = y_only || ( xd -> plane [ 1 ] . subsampling_y == 1 && //<S2SV> xd -> plane [ 1 ] . subsampling_x == 1 ) ; //<S2SV> for ( mi_row = start ; mi_row < stop ; mi_row += MI_BLOCK_SIZE ) { //<S2SV> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + mi_row * cm -> mi_stride ; //<S2SV> for ( mi_col = 0 ; mi_col < cm -> mi_cols ; mi_col += MI_BLOCK_SIZE ) { //<S2SV> int plane ; //<S2SV> vp9_setup_dst_planes ( xd , frame_buffer , mi_row , mi_col ) ; //<S2SV> if ( use_420 ) //<S2SV> vp9_setup_mask ( cm , mi_row , mi_col , mi_8x8 + mi_col , cm -> mi_stride , //<S2SV> & lfm ) ; //<S2SV> for ( plane = 0 ; plane < num_planes ; ++ plane ) { //<S2SV> if ( use_420 ) //<S2SV> vp9_filter_block_plane ( cm , & xd -> plane [ plane ] , mi_row , & lfm ) ; //<S2SV> else //<S2SV> filter_block_plane_non420 ( cm , & xd -> plane [ plane ] , mi_8x8 + mi_col , //<S2SV> mi_row , mi_col ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 