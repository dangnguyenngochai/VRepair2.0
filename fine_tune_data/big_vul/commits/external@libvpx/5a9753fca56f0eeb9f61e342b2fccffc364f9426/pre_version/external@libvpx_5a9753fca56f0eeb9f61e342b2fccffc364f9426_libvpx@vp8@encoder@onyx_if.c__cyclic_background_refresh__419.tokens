static void cyclic_background_refresh ( VP8_COMP * cpi , int Q , int lf_adjustment ) //<S2SV> { //<S2SV> unsigned char * seg_map = cpi -> segmentation_map ; //<S2SV> signed char feature_data [ MB_LVL_MAX ] [ MAX_MB_SEGMENTS ] ; //<S2SV> int i ; //<S2SV> int block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; //<S2SV> int mbs_in_frame = cpi -> common . mb_rows * cpi -> common . mb_cols ; //<S2SV> cpi -> cyclic_refresh_q = Q / 2 ; //<S2SV> vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ; //<S2SV> if ( cpi -> common . frame_type != KEY_FRAME ) //<S2SV> { //<S2SV> i = cpi -> cyclic_refresh_mode_index ; //<S2SV> assert ( i < mbs_in_frame ) ; //<S2SV> do //<S2SV> { //<S2SV> if ( cpi -> cyclic_refresh_map [ i ] == 0 ) //<S2SV> { //<S2SV> seg_map [ i ] = 1 ; //<S2SV> block_count -- ; //<S2SV> } //<S2SV> else if ( cpi -> cyclic_refresh_map [ i ] < 0 ) //<S2SV> cpi -> cyclic_refresh_map [ i ] ++ ; //<S2SV> i ++ ; //<S2SV> if ( i == mbs_in_frame ) //<S2SV> i = 0 ; //<S2SV> } //<S2SV> while ( block_count && i != cpi -> cyclic_refresh_mode_index ) ; //<S2SV> cpi -> cyclic_refresh_mode_index = i ; //<S2SV> } //<S2SV> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; //<S2SV> cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; //<S2SV> enable_segmentation ( cpi ) ; //<S2SV> feature_data [ MB_LVL_ALT_Q ] [ 0 ] = 0 ; //<S2SV> feature_data [ MB_LVL_ALT_Q ] [ 1 ] = ( cpi -> cyclic_refresh_q - Q ) ; //<S2SV> feature_data [ MB_LVL_ALT_Q ] [ 2 ] = 0 ; //<S2SV> feature_data [ MB_LVL_ALT_Q ] [ 3 ] = 0 ; //<S2SV> feature_data [ MB_LVL_ALT_LF ] [ 0 ] = 0 ; //<S2SV> feature_data [ MB_LVL_ALT_LF ] [ 1 ] = lf_adjustment ; //<S2SV> feature_data [ MB_LVL_ALT_LF ] [ 2 ] = 0 ; //<S2SV> feature_data [ MB_LVL_ALT_LF ] [ 3 ] = 0 ; //<S2SV> set_segment_data ( cpi , & feature_data [ 0 ] [ 0 ] , SEGMENT_DELTADATA ) ; //<S2SV> } //<S2SV> 