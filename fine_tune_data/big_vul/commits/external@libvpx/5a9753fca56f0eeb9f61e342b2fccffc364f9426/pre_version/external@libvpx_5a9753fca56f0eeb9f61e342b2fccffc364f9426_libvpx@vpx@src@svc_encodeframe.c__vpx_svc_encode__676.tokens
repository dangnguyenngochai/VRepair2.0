vpx_codec_err_t vpx_svc_encode ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , //<S2SV> struct vpx_image * rawimg , vpx_codec_pts_t pts , //<S2SV> int64_t duration , int deadline ) { //<S2SV> vpx_codec_err_t res ; //<S2SV> vpx_codec_iter_t iter ; //<S2SV> const vpx_codec_cx_pkt_t * cx_pkt ; //<S2SV> struct LayerData * cx_layer_list = NULL ; //<S2SV> struct LayerData * layer_data ; //<S2SV> struct Superframe superframe ; //<S2SV> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; //<S2SV> if ( svc_ctx == NULL || codec_ctx == NULL || si == NULL ) { //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> } //<S2SV> memset ( & superframe , 0 , sizeof ( superframe ) ) ; //<S2SV> svc_log_reset ( svc_ctx ) ; //<S2SV> si -> rc_stats_buf_used = 0 ; //<S2SV> si -> layers = svc_ctx -> spatial_layers ; //<S2SV> if ( si -> frame_within_gop >= si -> kf_dist || //<S2SV> si -> encode_frame_count == 0 ) { //<S2SV> si -> frame_within_gop = 0 ; //<S2SV> } //<S2SV> si -> is_keyframe = ( si -> frame_within_gop == 0 ) ; //<S2SV> si -> frame_size = 0 ; //<S2SV> if ( rawimg != NULL ) { //<S2SV> svc_log ( svc_ctx , SVC_LOG_DEBUG , //<S2SV> "vpx_svc_encode<S2SV_blank><S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>frame_count:<S2SV_blank>%d,<S2SV_blank>" //<S2SV> "frame_within_gop:<S2SV_blank>%d\\n" , si -> layers , si -> encode_frame_count , //<S2SV> si -> frame_within_gop ) ; //<S2SV> } //<S2SV> for ( si -> layer = 0 ; si -> layer < si -> layers ; ++ si -> layer ) { //<S2SV> if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && //<S2SV> si -> is_keyframe && ( si -> layer == 1 || si -> layer == 3 ) ) { //<S2SV> svc_log ( svc_ctx , SVC_LOG_DEBUG , "Skip<S2SV_blank>encoding<S2SV_blank>layer<S2SV_blank>%d\\n" , si -> layer ) ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( rawimg != NULL ) { //<S2SV> calculate_enc_frame_flags ( svc_ctx ) ; //<S2SV> set_svc_parameters ( svc_ctx , codec_ctx ) ; //<S2SV> } //<S2SV> res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration , //<S2SV> si -> enc_frame_flags , deadline ) ; //<S2SV> if ( res != VPX_CODEC_OK ) { //<S2SV> return res ; //<S2SV> } //<S2SV> iter = NULL ; //<S2SV> while ( ( cx_pkt = vpx_codec_get_cx_data ( codec_ctx , & iter ) ) ) { //<S2SV> switch ( cx_pkt -> kind ) { //<S2SV> case VPX_CODEC_CX_FRAME_PKT : { //<S2SV> const uint32_t frame_pkt_size = ( uint32_t ) ( cx_pkt -> data . frame . sz ) ; //<S2SV> si -> bytes_sum [ si -> layer ] += frame_pkt_size ; //<S2SV> svc_log ( svc_ctx , SVC_LOG_DEBUG , //<S2SV> "SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%u\\n" , //<S2SV> si -> encode_frame_count , si -> layer , frame_pkt_size ) ; //<S2SV> layer_data = //<S2SV> ld_create ( cx_pkt -> data . frame . buf , ( size_t ) frame_pkt_size ) ; //<S2SV> if ( layer_data == NULL ) { //<S2SV> svc_log ( svc_ctx , SVC_LOG_ERROR , "Error<S2SV_blank>allocating<S2SV_blank>LayerData\\n" ) ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> ld_list_add ( & cx_layer_list , layer_data ) ; //<S2SV> superframe . sizes [ superframe . count ++ ] = frame_pkt_size ; //<S2SV> superframe . magnitude |= frame_pkt_size ; //<S2SV> break ; //<S2SV> } //<S2SV> case VPX_CODEC_PSNR_PKT : { //<S2SV> int i ; //<S2SV> svc_log ( svc_ctx , SVC_LOG_DEBUG , //<S2SV> "SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>" //<S2SV> "%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n" , //<S2SV> si -> encode_frame_count , si -> layer , //<S2SV> cx_pkt -> data . psnr . psnr [ 0 ] , cx_pkt -> data . psnr . psnr [ 1 ] , //<S2SV> cx_pkt -> data . psnr . psnr [ 2 ] , cx_pkt -> data . psnr . psnr [ 3 ] ) ; //<S2SV> svc_log ( svc_ctx , SVC_LOG_DEBUG , //<S2SV> "SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>" //<S2SV> "%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n" , //<S2SV> si -> encode_frame_count , si -> layer , //<S2SV> cx_pkt -> data . psnr . sse [ 0 ] , cx_pkt -> data . psnr . sse [ 1 ] , //<S2SV> cx_pkt -> data . psnr . sse [ 2 ] , cx_pkt -> data . psnr . sse [ 3 ] ) ; //<S2SV> for ( i = 0 ; i < COMPONENTS ; i ++ ) { //<S2SV> si -> psnr_sum [ si -> layer ] [ i ] += cx_pkt -> data . psnr . psnr [ i ] ; //<S2SV> si -> sse_sum [ si -> layer ] [ i ] += cx_pkt -> data . psnr . sse [ i ] ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> case VPX_CODEC_STATS_PKT : { //<S2SV> size_t new_size = si -> rc_stats_buf_used + //<S2SV> cx_pkt -> data . twopass_stats . sz ; //<S2SV> if ( new_size > si -> rc_stats_buf_size ) { //<S2SV> char * p = ( char * ) realloc ( si -> rc_stats_buf , new_size ) ; //<S2SV> if ( p == NULL ) { //<S2SV> svc_log ( svc_ctx , SVC_LOG_ERROR , "Error<S2SV_blank>allocating<S2SV_blank>stats<S2SV_blank>buf\\n" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> si -> rc_stats_buf = p ; //<S2SV> si -> rc_stats_buf_size = new_size ; //<S2SV> } //<S2SV> memcpy ( si -> rc_stats_buf + si -> rc_stats_buf_used , //<S2SV> cx_pkt -> data . twopass_stats . buf , cx_pkt -> data . twopass_stats . sz ) ; //<S2SV> si -> rc_stats_buf_used += cx_pkt -> data . twopass_stats . sz ; //<S2SV> break ; //<S2SV> } //<S2SV> default : { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( rawimg == NULL ) { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( codec_ctx -> config . enc -> g_pass != VPX_RC_FIRST_PASS ) { //<S2SV> sf_create_index ( & superframe ) ; //<S2SV> layer_data = ld_create ( superframe . buffer , superframe . index_size ) ; //<S2SV> ld_list_add ( & cx_layer_list , layer_data ) ; //<S2SV> si -> frame_size = ld_list_get_buffer_size ( cx_layer_list ) ; //<S2SV> if ( si -> frame_size > 0 ) { //<S2SV> if ( si -> frame_size > si -> buffer_size ) { //<S2SV> free ( si -> buffer ) ; //<S2SV> si -> buffer = malloc ( si -> frame_size ) ; //<S2SV> if ( si -> buffer == NULL ) { //<S2SV> ld_list_free ( cx_layer_list ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> si -> buffer_size = si -> frame_size ; //<S2SV> } //<S2SV> ld_list_copy_to_buffer ( cx_layer_list , ( uint8_t * ) si -> buffer ) ; //<S2SV> ld_list_free ( cx_layer_list ) ; //<S2SV> svc_log ( svc_ctx , SVC_LOG_DEBUG , "SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>kf:<S2SV_blank>%d,<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>" //<S2SV> "pts:<S2SV_blank>%d\\n" , si -> encode_frame_count , si -> is_keyframe , //<S2SV> ( int ) si -> frame_size , ( int ) pts ) ; //<S2SV> } //<S2SV> } //<S2SV> ++ si -> frame_within_gop ; //<S2SV> ++ si -> encode_frame_count ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 