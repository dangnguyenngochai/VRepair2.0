static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , //<S2SV> int mi_row , int mi_col , //<S2SV> BLOCK_SIZE bsize , BLOCK_SIZE subsize ) { //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; //<S2SV> PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ; //<S2SV> assert ( bsize >= BLOCK_8X8 ) ; //<S2SV> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) //<S2SV> return ; //<S2SV> switch ( partition ) { //<S2SV> case PARTITION_NONE : //<S2SV> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; //<S2SV> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; //<S2SV> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; //<S2SV> break ; //<S2SV> case PARTITION_VERT : //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; //<S2SV> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; //<S2SV> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( mi_col + hbs < cm -> mi_cols ) { //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ; //<S2SV> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; //<S2SV> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col + hbs , bsize ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_HORZ : //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; //<S2SV> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; //<S2SV> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( mi_row + hbs < cm -> mi_rows ) { //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> set_modeinfo_offsets ( cm , xd , mi_row + hbs , mi_col ) ; //<S2SV> * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; //<S2SV> duplicate_mode_info_in_sb ( cm , xd , mi_row + hbs , mi_col , bsize ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_SPLIT : //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> fill_mode_info_sb ( cm , x , mi_row , mi_col , subsize , //<S2SV> * ( get_sb_partitioning ( x , subsize ) ) ) ; //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , //<S2SV> * ( get_sb_partitioning ( x , subsize ) ) ) ; //<S2SV> * get_sb_index ( x , subsize ) = 2 ; //<S2SV> fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col , subsize , //<S2SV> * ( get_sb_partitioning ( x , subsize ) ) ) ; //<S2SV> * get_sb_index ( x , subsize ) = 3 ; //<S2SV> fill_mode_info_sb ( cm , x , mi_row + hbs , mi_col + hbs , subsize , //<S2SV> * ( get_sb_partitioning ( x , subsize ) ) ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> 