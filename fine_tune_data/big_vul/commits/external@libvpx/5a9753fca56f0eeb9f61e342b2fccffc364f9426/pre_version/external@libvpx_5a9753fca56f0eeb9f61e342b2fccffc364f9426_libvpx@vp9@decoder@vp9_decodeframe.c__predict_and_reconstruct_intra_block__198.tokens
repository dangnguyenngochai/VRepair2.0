static void predict_and_reconstruct_intra_block ( int plane , int block , //<S2SV> BLOCK_SIZE plane_bsize , //<S2SV> TX_SIZE tx_size , void * arg ) { //<S2SV> struct intra_args * const args = ( struct intra_args * ) arg ; //<S2SV> VP9_COMMON * const cm = args -> cm ; //<S2SV> MACROBLOCKD * const xd = args -> xd ; //<S2SV> struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; //<S2SV> MODE_INFO * const mi = xd -> mi [ 0 ] ; //<S2SV> const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) //<S2SV> : mi -> mbmi . uv_mode ; //<S2SV> int x , y ; //<S2SV> uint8_t * dst ; //<S2SV> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ; //<S2SV> dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ; //<S2SV> vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , //<S2SV> b_width_log2 ( plane_bsize ) , tx_size , mode , //<S2SV> dst , pd -> dst . stride , dst , pd -> dst . stride , //<S2SV> x , y , plane ) ; //<S2SV> if ( ! mi -> mbmi . skip ) { //<S2SV> const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , //<S2SV> plane_bsize , x , y , tx_size , //<S2SV> args -> r ) ; //<S2SV> inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , //<S2SV> eob ) ; //<S2SV> } //<S2SV> } //<S2SV> 