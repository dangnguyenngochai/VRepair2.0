static int rd_pick_intra4x4block ( //<S2SV> MACROBLOCK * x , //<S2SV> BLOCK * be , //<S2SV> BLOCKD * b , //<S2SV> B_PREDICTION_MODE * best_mode , //<S2SV> const int * bmode_costs , //<S2SV> ENTROPY_CONTEXT * a , //<S2SV> ENTROPY_CONTEXT * l , //<S2SV> int * bestrate , //<S2SV> int * bestratey , //<S2SV> int * bestdistortion ) //<S2SV> { //<S2SV> B_PREDICTION_MODE mode ; //<S2SV> int best_rd = INT_MAX ; //<S2SV> int rate = 0 ; //<S2SV> int distortion ; //<S2SV> ENTROPY_CONTEXT ta = * a , tempa = * a ; //<S2SV> ENTROPY_CONTEXT tl = * l , templ = * l ; //<S2SV> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ; //<S2SV> DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ; //<S2SV> int dst_stride = x -> e_mbd . dst . y_stride ; //<S2SV> unsigned char * dst = x -> e_mbd . dst . y_buffer + b -> offset ; //<S2SV> unsigned char * Above = dst - dst_stride ; //<S2SV> unsigned char * yleft = dst - 1 ; //<S2SV> unsigned char top_left = Above [ - 1 ] ; //<S2SV> for ( mode = B_DC_PRED ; mode <= B_HU_PRED ; mode ++ ) //<S2SV> { //<S2SV> int this_rd ; //<S2SV> int ratey ; //<S2SV> rate = bmode_costs [ mode ] ; //<S2SV> vp8_intra4x4_predict ( Above , yleft , dst_stride , mode , //<S2SV> b -> predictor , 16 , top_left ) ; //<S2SV> vp8_subtract_b ( be , b , 16 ) ; //<S2SV> x -> short_fdct4x4 ( be -> src_diff , be -> coeff , 32 ) ; //<S2SV> x -> quantize_b ( be , b ) ; //<S2SV> tempa = ta ; //<S2SV> templ = tl ; //<S2SV> ratey = cost_coeffs ( x , b , PLANE_TYPE_Y_WITH_DC , & tempa , & templ ) ; //<S2SV> rate += ratey ; //<S2SV> distortion = vp8_block_error ( be -> coeff , b -> dqcoeff ) >> 2 ; //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; //<S2SV> if ( this_rd < best_rd ) //<S2SV> { //<S2SV> * bestrate = rate ; //<S2SV> * bestratey = ratey ; //<S2SV> * bestdistortion = distortion ; //<S2SV> best_rd = this_rd ; //<S2SV> * best_mode = mode ; //<S2SV> * a = tempa ; //<S2SV> * l = templ ; //<S2SV> copy_predictor ( best_predictor , b -> predictor ) ; //<S2SV> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; //<S2SV> } //<S2SV> } //<S2SV> b -> bmi . as_mode = * best_mode ; //<S2SV> vp8_short_idct4x4llm ( best_dqcoeff , best_predictor , 16 , dst , dst_stride ) ; //<S2SV> return best_rd ; //<S2SV> } //<S2SV> 