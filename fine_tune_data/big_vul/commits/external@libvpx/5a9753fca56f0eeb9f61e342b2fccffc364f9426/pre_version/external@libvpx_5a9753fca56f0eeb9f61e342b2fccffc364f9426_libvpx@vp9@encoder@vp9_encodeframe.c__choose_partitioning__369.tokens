static void choose_partitioning ( VP9_COMP * cpi , //<S2SV> const TileInfo * const tile , //<S2SV> int mi_row , int mi_col ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * x = & cpi -> mb ; //<S2SV> MACROBLOCKD * xd = & cpi -> mb . e_mbd ; //<S2SV> int i , j , k ; //<S2SV> v64x64 vt ; //<S2SV> uint8_t * s ; //<S2SV> const uint8_t * d ; //<S2SV> int sp ; //<S2SV> int dp ; //<S2SV> int pixels_wide = 64 , pixels_high = 64 ; //<S2SV> int_mv nearest_mv , near_mv ; //<S2SV> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; //<S2SV> const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ; //<S2SV> vp9_zero ( vt ) ; //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> if ( xd -> mb_to_right_edge < 0 ) //<S2SV> pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; //<S2SV> if ( xd -> mb_to_bottom_edge < 0 ) //<S2SV> pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; //<S2SV> s = x -> plane [ 0 ] . src . buf ; //<S2SV> sp = x -> plane [ 0 ] . src . stride ; //<S2SV> if ( cm -> frame_type != KEY_FRAME ) { //<S2SV> vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ; //<S2SV> xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ; //<S2SV> xd -> mi [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; //<S2SV> vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , //<S2SV> xd -> mi [ 0 ] -> mbmi . ref_mvs [ LAST_FRAME ] , //<S2SV> & nearest_mv , & near_mv ) ; //<S2SV> xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = nearest_mv ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> d = xd -> plane [ 0 ] . dst . buf ; //<S2SV> dp = xd -> plane [ 0 ] . dst . stride ; //<S2SV> } else { //<S2SV> d = VP9_VAR_OFFS ; //<S2SV> dp = 0 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> const int x32_idx = ( ( i & 1 ) << 5 ) ; //<S2SV> const int y32_idx = ( ( i >> 1 ) << 5 ) ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) { //<S2SV> const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ; //<S2SV> const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ; //<S2SV> v16x16 * vst = & vt . split [ i ] . split [ j ] ; //<S2SV> for ( k = 0 ; k < 4 ; k ++ ) { //<S2SV> int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ; //<S2SV> int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ; //<S2SV> unsigned int sse = 0 ; //<S2SV> int sum = 0 ; //<S2SV> if ( x_idx < pixels_wide && y_idx < pixels_high ) //<S2SV> vp9_get_sse_sum_8x8 ( s + y_idx * sp + x_idx , sp , //<S2SV> d + y_idx * dp + x_idx , dp , & sse , & sum ) ; //<S2SV> fill_variance ( sse , sum , 64 , & vst -> split [ k ] . part_variances . none ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) { //<S2SV> fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; //<S2SV> } //<S2SV> fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ; //<S2SV> } //<S2SV> fill_variance_tree ( & vt , BLOCK_64X64 ) ; //<S2SV> if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 , //<S2SV> mi_row , mi_col , 8 ) ) { //<S2SV> for ( i = 0 ; i < 4 ; ++ i ) { //<S2SV> const int x32_idx = ( ( i & 1 ) << 2 ) ; //<S2SV> const int y32_idx = ( ( i >> 1 ) << 2 ) ; //<S2SV> if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 , //<S2SV> ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) { //<S2SV> for ( j = 0 ; j < 4 ; ++ j ) { //<S2SV> const int x16_idx = ( ( j & 1 ) << 1 ) ; //<S2SV> const int y16_idx = ( ( j >> 1 ) << 1 ) ; //<S2SV> # define DISABLE_8X8_VAR_BASED_PARTITION //<S2SV> # ifdef DISABLE_8X8_VAR_BASED_PARTITION //<S2SV> if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows && //<S2SV> mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) { //<S2SV> set_block_size ( cpi , tile , //<S2SV> ( mi_row + y32_idx + y16_idx ) , //<S2SV> ( mi_col + x32_idx + x16_idx ) , //<S2SV> BLOCK_16X16 ) ; //<S2SV> } else { //<S2SV> for ( k = 0 ; k < 4 ; ++ k ) { //<S2SV> const int x8_idx = ( k & 1 ) ; //<S2SV> const int y8_idx = ( k >> 1 ) ; //<S2SV> set_block_size ( cpi , tile , //<S2SV> ( mi_row + y32_idx + y16_idx + y8_idx ) , //<S2SV> ( mi_col + x32_idx + x16_idx + x8_idx ) , //<S2SV> BLOCK_8X8 ) ; //<S2SV> } //<S2SV> } //<S2SV> # else //<S2SV> if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile , //<S2SV> BLOCK_16X16 , //<S2SV> ( mi_row + y32_idx + y16_idx ) , //<S2SV> ( mi_col + x32_idx + x16_idx ) , 2 ) ) { //<S2SV> for ( k = 0 ; k < 4 ; ++ k ) { //<S2SV> const int x8_idx = ( k & 1 ) ; //<S2SV> const int y8_idx = ( k >> 1 ) ; //<S2SV> set_block_size ( cpi , tile , //<S2SV> ( mi_row + y32_idx + y16_idx + y8_idx ) , //<S2SV> ( mi_col + x32_idx + x16_idx + x8_idx ) , //<S2SV> BLOCK_8X8 ) ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 