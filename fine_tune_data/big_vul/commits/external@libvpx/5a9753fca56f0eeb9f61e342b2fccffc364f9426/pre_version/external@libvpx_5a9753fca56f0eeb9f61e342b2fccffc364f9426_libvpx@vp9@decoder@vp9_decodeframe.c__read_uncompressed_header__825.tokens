static size_t read_uncompressed_header ( VP9Decoder * pbi , //<S2SV> struct vp9_read_bit_buffer * rb ) { //<S2SV> VP9_COMMON * const cm = & pbi -> common ; //<S2SV> size_t sz ; //<S2SV> int i ; //<S2SV> cm -> last_frame_type = cm -> frame_type ; //<S2SV> if ( vp9_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Invalid<S2SV_blank>frame<S2SV_blank>marker" ) ; //<S2SV> cm -> profile = read_profile ( rb ) ; //<S2SV> if ( cm -> profile >= MAX_PROFILES ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Unsupported<S2SV_blank>bitstream<S2SV_blank>profile" ) ; //<S2SV> cm -> show_existing_frame = vp9_rb_read_bit ( rb ) ; //<S2SV> if ( cm -> show_existing_frame ) { //<S2SV> const int frame_to_show = cm -> ref_frame_map [ vp9_rb_read_literal ( rb , 3 ) ] ; //<S2SV> if ( cm -> frame_bufs [ frame_to_show ] . ref_count < 1 ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Buffer<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>decoded<S2SV_blank>frame" , //<S2SV> frame_to_show ) ; //<S2SV> ref_cnt_fb ( cm -> frame_bufs , & cm -> new_fb_idx , frame_to_show ) ; //<S2SV> pbi -> refresh_frame_flags = 0 ; //<S2SV> cm -> lf . filter_level = 0 ; //<S2SV> cm -> show_frame = 1 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> cm -> frame_type = ( FRAME_TYPE ) vp9_rb_read_bit ( rb ) ; //<S2SV> cm -> show_frame = vp9_rb_read_bit ( rb ) ; //<S2SV> cm -> error_resilient_mode = vp9_rb_read_bit ( rb ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) { //<S2SV> check_sync_code ( cm , rb ) ; //<S2SV> if ( cm -> profile > PROFILE_1 ) //<S2SV> cm -> bit_depth = vp9_rb_read_bit ( rb ) ? BITS_12 : BITS_10 ; //<S2SV> cm -> color_space = ( COLOR_SPACE ) vp9_rb_read_literal ( rb , 3 ) ; //<S2SV> if ( cm -> color_space != SRGB ) { //<S2SV> vp9_rb_read_bit ( rb ) ; //<S2SV> if ( cm -> profile >= PROFILE_1 ) { //<S2SV> cm -> subsampling_x = vp9_rb_read_bit ( rb ) ; //<S2SV> cm -> subsampling_y = vp9_rb_read_bit ( rb ) ; //<S2SV> vp9_rb_read_bit ( rb ) ; //<S2SV> } else { //<S2SV> cm -> subsampling_y = cm -> subsampling_x = 1 ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( cm -> profile >= PROFILE_1 ) { //<S2SV> cm -> subsampling_y = cm -> subsampling_x = 0 ; //<S2SV> vp9_rb_read_bit ( rb ) ; //<S2SV> } else { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "RGB<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>0" ) ; //<S2SV> } //<S2SV> } //<S2SV> pbi -> refresh_frame_flags = ( 1 << REF_FRAMES ) - 1 ; //<S2SV> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { //<S2SV> cm -> frame_refs [ i ] . idx = cm -> new_fb_idx ; //<S2SV> cm -> frame_refs [ i ] . buf = get_frame_new_buffer ( cm ) ; //<S2SV> } //<S2SV> setup_frame_size ( cm , rb ) ; //<S2SV> } else { //<S2SV> cm -> intra_only = cm -> show_frame ? 0 : vp9_rb_read_bit ( rb ) ; //<S2SV> cm -> reset_frame_context = cm -> error_resilient_mode ? //<S2SV> 0 : vp9_rb_read_literal ( rb , 2 ) ; //<S2SV> if ( cm -> intra_only ) { //<S2SV> check_sync_code ( cm , rb ) ; //<S2SV> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; //<S2SV> setup_frame_size ( cm , rb ) ; //<S2SV> } else { //<S2SV> pbi -> refresh_frame_flags = vp9_rb_read_literal ( rb , REF_FRAMES ) ; //<S2SV> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { //<S2SV> const int ref = vp9_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ; //<S2SV> const int idx = cm -> ref_frame_map [ ref ] ; //<S2SV> cm -> frame_refs [ i ] . idx = idx ; //<S2SV> cm -> frame_refs [ i ] . buf = & cm -> frame_bufs [ idx ] . buf ; //<S2SV> cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vp9_rb_read_bit ( rb ) ; //<S2SV> } //<S2SV> setup_frame_size_with_refs ( cm , rb ) ; //<S2SV> cm -> allow_high_precision_mv = vp9_rb_read_bit ( rb ) ; //<S2SV> cm -> interp_filter = read_interp_filter ( rb ) ; //<S2SV> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { //<S2SV> RefBuffer * const ref_buf = & cm -> frame_refs [ i ] ; //<S2SV> vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , //<S2SV> ref_buf -> buf -> y_crop_width , //<S2SV> ref_buf -> buf -> y_crop_height , //<S2SV> cm -> width , cm -> height ) ; //<S2SV> if ( vp9_is_scaled ( & ref_buf -> sf ) ) //<S2SV> vp9_extend_frame_borders ( ref_buf -> buf ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! cm -> error_resilient_mode ) { //<S2SV> cm -> coding_use_prev_mi = 1 ; //<S2SV> cm -> refresh_frame_context = vp9_rb_read_bit ( rb ) ; //<S2SV> cm -> frame_parallel_decoding_mode = vp9_rb_read_bit ( rb ) ; //<S2SV> } else { //<S2SV> cm -> coding_use_prev_mi = 0 ; //<S2SV> cm -> refresh_frame_context = 0 ; //<S2SV> cm -> frame_parallel_decoding_mode = 1 ; //<S2SV> } //<S2SV> cm -> frame_context_idx = vp9_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; //<S2SV> if ( frame_is_intra_only ( cm ) || cm -> error_resilient_mode ) //<S2SV> vp9_setup_past_independence ( cm ) ; //<S2SV> setup_loopfilter ( & cm -> lf , rb ) ; //<S2SV> setup_quantization ( cm , & pbi -> mb , rb ) ; //<S2SV> setup_segmentation ( & cm -> seg , rb ) ; //<S2SV> setup_tile_info ( cm , rb ) ; //<S2SV> sz = vp9_rb_read_literal ( rb , 16 ) ; //<S2SV> if ( sz == 0 ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Invalid<S2SV_blank>header<S2SV_blank>size" ) ; //<S2SV> return sz ; //<S2SV> } //<S2SV> 