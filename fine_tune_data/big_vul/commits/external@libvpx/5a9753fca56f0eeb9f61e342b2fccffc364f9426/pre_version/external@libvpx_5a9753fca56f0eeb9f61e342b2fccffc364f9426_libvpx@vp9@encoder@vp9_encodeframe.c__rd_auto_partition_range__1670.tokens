static void rd_auto_partition_range ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> int mi_row , int mi_col , //<S2SV> BLOCK_SIZE * min_block_size , //<S2SV> BLOCK_SIZE * max_block_size ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; //<S2SV> MODE_INFO * * mi_8x8 = xd -> mi ; //<S2SV> const int left_in_image = xd -> left_available && mi_8x8 [ - 1 ] ; //<S2SV> const int above_in_image = xd -> up_available && //<S2SV> mi_8x8 [ - xd -> mi_stride ] ; //<S2SV> MODE_INFO * * above_sb64_mi_8x8 ; //<S2SV> MODE_INFO * * left_sb64_mi_8x8 ; //<S2SV> int row8x8_remaining = tile -> mi_row_end - mi_row ; //<S2SV> int col8x8_remaining = tile -> mi_col_end - mi_col ; //<S2SV> int bh , bw ; //<S2SV> BLOCK_SIZE min_size = BLOCK_4X4 ; //<S2SV> BLOCK_SIZE max_size = BLOCK_64X64 ; //<S2SV> if ( left_in_image || above_in_image || cm -> frame_type != KEY_FRAME ) { //<S2SV> min_size = BLOCK_64X64 ; //<S2SV> max_size = BLOCK_4X4 ; //<S2SV> if ( cm -> frame_type != KEY_FRAME ) { //<S2SV> MODE_INFO * * const prev_mi = //<S2SV> & cm -> prev_mi_grid_visible [ mi_row * xd -> mi_stride + mi_col ] ; //<S2SV> get_sb_partition_size_range ( cpi , prev_mi , & min_size , & max_size ) ; //<S2SV> } //<S2SV> if ( left_in_image ) { //<S2SV> left_sb64_mi_8x8 = & mi_8x8 [ - MI_BLOCK_SIZE ] ; //<S2SV> get_sb_partition_size_range ( cpi , left_sb64_mi_8x8 , //<S2SV> & min_size , & max_size ) ; //<S2SV> } //<S2SV> if ( above_in_image ) { //<S2SV> above_sb64_mi_8x8 = & mi_8x8 [ - xd -> mi_stride * MI_BLOCK_SIZE ] ; //<S2SV> get_sb_partition_size_range ( cpi , above_sb64_mi_8x8 , //<S2SV> & min_size , & max_size ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . auto_min_max_partition_size == RELAXED_NEIGHBORING_MIN_MAX ) { //<S2SV> min_size = min_partition_size [ min_size ] ; //<S2SV> max_size = max_partition_size [ max_size ] ; //<S2SV> } //<S2SV> } //<S2SV> max_size = find_partition_size ( max_size , //<S2SV> row8x8_remaining , col8x8_remaining , //<S2SV> & bh , & bw ) ; //<S2SV> min_size = MIN ( min_size , max_size ) ; //<S2SV> if ( cpi -> sf . use_square_partition_only && //<S2SV> next_square_size [ max_size ] < min_size ) { //<S2SV> min_size = next_square_size [ max_size ] ; //<S2SV> } //<S2SV> * min_block_size = min_size ; //<S2SV> * max_block_size = max_size ; //<S2SV> } //<S2SV> 