void vp8_build_intra_predictors_mby_s_c ( MACROBLOCKD * x , //<S2SV> unsigned char * yabove_row , //<S2SV> unsigned char * yleft , //<S2SV> int left_stride , //<S2SV> unsigned char * ypred_ptr , //<S2SV> int y_stride ) //<S2SV> { //<S2SV> unsigned char yleft_col [ 16 ] ; //<S2SV> unsigned char ytop_left = yabove_row [ - 1 ] ; //<S2SV> int r , c , i ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> { //<S2SV> yleft_col [ i ] = yleft [ i * left_stride ] ; //<S2SV> } //<S2SV> switch ( x -> mode_info_context -> mbmi . mode ) //<S2SV> { //<S2SV> case DC_PRED : //<S2SV> { //<S2SV> int expected_dc ; //<S2SV> int shift ; //<S2SV> int average = 0 ; //<S2SV> if ( x -> up_available || x -> left_available ) //<S2SV> { //<S2SV> if ( x -> up_available ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> { //<S2SV> average += yabove_row [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> if ( x -> left_available ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> { //<S2SV> average += yleft_col [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> shift = 3 + x -> up_available + x -> left_available ; //<S2SV> expected_dc = ( average + ( 1 << ( shift - 1 ) ) ) >> shift ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> expected_dc = 128 ; //<S2SV> } //<S2SV> for ( r = 0 ; r < 16 ; r ++ ) //<S2SV> { //<S2SV> vpx_memset ( ypred_ptr , expected_dc , 16 ) ; //<S2SV> ypred_ptr += y_stride ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case V_PRED : //<S2SV> { //<S2SV> for ( r = 0 ; r < 16 ; r ++ ) //<S2SV> { //<S2SV> ( ( int * ) ypred_ptr ) [ 0 ] = ( ( int * ) yabove_row ) [ 0 ] ; //<S2SV> ( ( int * ) ypred_ptr ) [ 1 ] = ( ( int * ) yabove_row ) [ 1 ] ; //<S2SV> ( ( int * ) ypred_ptr ) [ 2 ] = ( ( int * ) yabove_row ) [ 2 ] ; //<S2SV> ( ( int * ) ypred_ptr ) [ 3 ] = ( ( int * ) yabove_row ) [ 3 ] ; //<S2SV> ypred_ptr += y_stride ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case H_PRED : //<S2SV> { //<S2SV> for ( r = 0 ; r < 16 ; r ++ ) //<S2SV> { //<S2SV> vpx_memset ( ypred_ptr , yleft_col [ r ] , 16 ) ; //<S2SV> ypred_ptr += y_stride ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TM_PRED : //<S2SV> { //<S2SV> for ( r = 0 ; r < 16 ; r ++ ) //<S2SV> { //<S2SV> for ( c = 0 ; c < 16 ; c ++ ) //<S2SV> { //<S2SV> int pred = yleft_col [ r ] + yabove_row [ c ] - ytop_left ; //<S2SV> if ( pred < 0 ) //<S2SV> pred = 0 ; //<S2SV> if ( pred > 255 ) //<S2SV> pred = 255 ; //<S2SV> ypred_ptr [ c ] = pred ; //<S2SV> } //<S2SV> ypred_ptr += y_stride ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case B_PRED : //<S2SV> case NEARESTMV : //<S2SV> case NEARMV : //<S2SV> case ZEROMV : //<S2SV> case NEWMV : //<S2SV> case SPLITMV : //<S2SV> case MB_MODE_COUNT : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> 