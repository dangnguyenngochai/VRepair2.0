static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> TOKENEXTRA * * tp , int mi_row , //<S2SV> int mi_col , BLOCK_SIZE bsize , int * rate , //<S2SV> int64_t * dist , int do_recon , int64_t best_rd ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; //<S2SV> ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; //<S2SV> PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; //<S2SV> TOKENEXTRA * tp_orig = * tp ; //<S2SV> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; //<S2SV> int i , pl ; //<S2SV> BLOCK_SIZE subsize ; //<S2SV> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; //<S2SV> int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; //<S2SV> int64_t sum_rd = 0 ; //<S2SV> int do_split = bsize >= BLOCK_8X8 ; //<S2SV> int do_rect = 1 ; //<S2SV> const int force_horz_split = ( mi_row + mi_step >= cm -> mi_rows ) ; //<S2SV> const int force_vert_split = ( mi_col + mi_step >= cm -> mi_cols ) ; //<S2SV> const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; //<S2SV> const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; //<S2SV> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; //<S2SV> int partition_horz_allowed = ! force_vert_split && yss <= xss && //<S2SV> bsize >= BLOCK_8X8 ; //<S2SV> int partition_vert_allowed = ! force_horz_split && xss <= yss && //<S2SV> bsize >= BLOCK_8X8 ; //<S2SV> ( void ) * tp_orig ; //<S2SV> if ( bsize < BLOCK_8X8 ) { //<S2SV> if ( x -> ab_index != 0 ) { //<S2SV> * rate = 0 ; //<S2SV> * dist = 0 ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> assert ( num_8x8_blocks_wide_lookup [ bsize ] == //<S2SV> num_8x8_blocks_high_lookup [ bsize ] ) ; //<S2SV> if ( bsize == BLOCK_16X16 ) { //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; //<S2SV> x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ; //<S2SV> } else { //<S2SV> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . auto_min_max_partition_size ) { //<S2SV> partition_none_allowed &= ( bsize <= cpi -> sf . max_partition_size && //<S2SV> bsize >= cpi -> sf . min_partition_size ) ; //<S2SV> partition_horz_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && //<S2SV> bsize > cpi -> sf . min_partition_size ) || //<S2SV> force_horz_split ) ; //<S2SV> partition_vert_allowed &= ( ( bsize <= cpi -> sf . max_partition_size && //<S2SV> bsize > cpi -> sf . min_partition_size ) || //<S2SV> force_vert_split ) ; //<S2SV> do_split &= bsize > cpi -> sf . min_partition_size ; //<S2SV> } //<S2SV> if ( cpi -> sf . use_square_partition_only ) { //<S2SV> partition_horz_allowed &= force_horz_split ; //<S2SV> partition_vert_allowed &= force_vert_split ; //<S2SV> } //<S2SV> save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> if ( cpi -> sf . disable_split_var_thresh && partition_none_allowed ) { //<S2SV> unsigned int source_variancey ; //<S2SV> vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; //<S2SV> source_variancey = get_sby_perpixel_variance ( cpi , x , bsize ) ; //<S2SV> if ( source_variancey < cpi -> sf . disable_split_var_thresh ) { //<S2SV> do_split = 0 ; //<S2SV> if ( source_variancey < cpi -> sf . disable_split_var_thresh / 2 ) //<S2SV> do_rect = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! x -> in_active_map && ( partition_horz_allowed || partition_vert_allowed ) ) //<S2SV> do_split = 0 ; //<S2SV> if ( partition_none_allowed ) { //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & this_rate , & this_dist , bsize , //<S2SV> ctx , best_rd ) ; //<S2SV> if ( this_rate != INT_MAX ) { //<S2SV> if ( bsize >= BLOCK_8X8 ) { //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> this_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; //<S2SV> } //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_dist ) ; //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> int64_t stop_thresh = 4096 ; //<S2SV> int64_t stop_thresh_rd ; //<S2SV> best_rate = this_rate ; //<S2SV> best_dist = this_dist ; //<S2SV> best_rd = sum_rd ; //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; //<S2SV> stop_thresh >>= 8 - ( b_width_log2_lookup [ bsize ] + //<S2SV> b_height_log2_lookup [ bsize ] ) ; //<S2SV> stop_thresh_rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , stop_thresh ) ; //<S2SV> if ( ! x -> e_mbd . lossless && best_rd < stop_thresh_rd ) { //<S2SV> do_split = 0 ; //<S2SV> do_rect = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! x -> in_active_map ) { //<S2SV> do_split = 0 ; //<S2SV> do_rect = 0 ; //<S2SV> } //<S2SV> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> store_pred_mv ( x , ctx ) ; //<S2SV> sum_rd = 0 ; //<S2SV> if ( do_split ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; //<S2SV> for ( i = 0 ; i < 4 && sum_rd < best_rd ; ++ i ) { //<S2SV> const int x_idx = ( i & 1 ) * mi_step ; //<S2SV> const int y_idx = ( i >> 1 ) * mi_step ; //<S2SV> if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) //<S2SV> continue ; //<S2SV> * get_sb_index ( x , subsize ) = i ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> get_block_context ( x , subsize ) -> pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_partition ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , subsize , //<S2SV> & this_rate , & this_dist , i != 3 , best_rd - sum_rd ) ; //<S2SV> if ( this_rate == INT_MAX ) { //<S2SV> sum_rd = INT64_MAX ; //<S2SV> } else { //<S2SV> sum_rate += this_rate ; //<S2SV> sum_dist += this_dist ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rd < best_rd && i == 4 ) { //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> best_rate = sum_rate ; //<S2SV> best_dist = sum_dist ; //<S2SV> best_rd = sum_rd ; //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( cpi -> sf . less_rectangular_check ) //<S2SV> do_rect &= ! partition_none_allowed ; //<S2SV> } //<S2SV> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> } //<S2SV> if ( partition_horz_allowed && do_rect ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> get_block_context ( x , subsize ) -> pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , //<S2SV> get_block_context ( x , subsize ) , best_rd ) ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> if ( sum_rd < best_rd && mi_row + mi_step < cm -> mi_rows ) { //<S2SV> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , //<S2SV> subsize , 0 ) ; //<S2SV> encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> get_block_context ( x , subsize ) -> pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row + mi_step , mi_col , & this_rate , //<S2SV> & this_dist , subsize , get_block_context ( x , subsize ) , //<S2SV> best_rd - sum_rd ) ; //<S2SV> if ( this_rate == INT_MAX ) { //<S2SV> sum_rd = INT64_MAX ; //<S2SV> } else { //<S2SV> sum_rate += this_rate ; //<S2SV> sum_dist += this_dist ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rate += x -> partition_cost [ pl ] [ PARTITION_HORZ ] ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> best_rd = sum_rd ; //<S2SV> best_rate = sum_rate ; //<S2SV> best_dist = sum_dist ; //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> } //<S2SV> } //<S2SV> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> } //<S2SV> if ( partition_vert_allowed && do_rect ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_VERT ) ; //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> get_block_context ( x , subsize ) -> pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & sum_rate , & sum_dist , subsize , //<S2SV> get_block_context ( x , subsize ) , best_rd ) ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> if ( sum_rd < best_rd && mi_col + mi_step < cm -> mi_cols ) { //<S2SV> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , //<S2SV> subsize , 0 ) ; //<S2SV> encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> get_block_context ( x , subsize ) -> pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + mi_step , & this_rate , //<S2SV> & this_dist , subsize , get_block_context ( x , subsize ) , //<S2SV> best_rd - sum_rd ) ; //<S2SV> if ( this_rate == INT_MAX ) { //<S2SV> sum_rd = INT64_MAX ; //<S2SV> } else { //<S2SV> sum_rate += this_rate ; //<S2SV> sum_dist += this_dist ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rate += x -> partition_cost [ pl ] [ PARTITION_VERT ] ; //<S2SV> sum_rd = RDCOST ( x -> rdmult , x -> rddiv , sum_rate , sum_dist ) ; //<S2SV> if ( sum_rd < best_rd ) { //<S2SV> best_rate = sum_rate ; //<S2SV> best_dist = sum_dist ; //<S2SV> best_rd = sum_rd ; //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> } //<S2SV> } //<S2SV> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> } //<S2SV> ( void ) best_rd ; //<S2SV> * rate = best_rate ; //<S2SV> * dist = best_dist ; //<S2SV> if ( best_rate < INT_MAX && best_dist < INT64_MAX && do_recon ) { //<S2SV> int output_enabled = ( bsize == BLOCK_64X64 ) ; //<S2SV> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { //<S2SV> vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , output_enabled , //<S2SV> best_rate ) ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) //<S2SV> vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , //<S2SV> best_rate , best_dist ) ; //<S2SV> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; //<S2SV> } //<S2SV> if ( bsize == BLOCK_64X64 ) { //<S2SV> assert ( tp_orig < * tp ) ; //<S2SV> assert ( best_rate < INT_MAX ) ; //<S2SV> assert ( best_dist < INT64_MAX ) ; //<S2SV> } else { //<S2SV> assert ( tp_orig == * tp ) ; //<S2SV> } //<S2SV> } //<S2SV> 