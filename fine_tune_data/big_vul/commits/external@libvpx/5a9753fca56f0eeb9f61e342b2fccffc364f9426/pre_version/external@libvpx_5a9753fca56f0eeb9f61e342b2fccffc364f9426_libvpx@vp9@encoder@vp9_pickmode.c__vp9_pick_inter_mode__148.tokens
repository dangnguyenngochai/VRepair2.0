int64_t vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , //<S2SV> const TileInfo * const tile , //<S2SV> int mi_row , int mi_col , //<S2SV> int * returnrate , //<S2SV> int64_t * returndistortion , //<S2SV> BLOCK_SIZE bsize ) { //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> struct macroblock_plane * const p = & x -> plane [ 0 ] ; //<S2SV> struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; //<S2SV> MB_PREDICTION_MODE this_mode , best_mode = ZEROMV ; //<S2SV> MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ; //<S2SV> INTERP_FILTER best_pred_filter = EIGHTTAP ; //<S2SV> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; //<S2SV> struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; //<S2SV> static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , //<S2SV> VP9_ALT_FLAG } ; //<S2SV> int64_t best_rd = INT64_MAX ; //<S2SV> int64_t this_rd = INT64_MAX ; //<S2SV> int rate = INT_MAX ; //<S2SV> int64_t dist = INT64_MAX ; //<S2SV> VP9_COMMON * cm = & cpi -> common ; //<S2SV> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; //<S2SV> const int64_t inter_mode_thresh = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> intra_cost_penalty , 0 ) ; //<S2SV> const int64_t intra_mode_cost = 50 ; //<S2SV> unsigned char segment_id = mbmi -> segment_id ; //<S2SV> const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ; //<S2SV> const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [ bsize ] ; //<S2SV> int mode_idx [ MB_MODE_COUNT ] = { 0 } ; //<S2SV> INTERP_FILTER filter_ref = SWITCHABLE ; //<S2SV> x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; //<S2SV> x -> skip = 0 ; //<S2SV> if ( ! x -> in_active_map ) //<S2SV> x -> skip = 1 ; //<S2SV> * returnrate = INT_MAX ; //<S2SV> * returndistortion = INT64_MAX ; //<S2SV> vpx_memset ( mbmi , 0 , sizeof ( MB_MODE_INFO ) ) ; //<S2SV> mbmi -> sb_type = bsize ; //<S2SV> mbmi -> ref_frame [ 0 ] = NONE ; //<S2SV> mbmi -> ref_frame [ 1 ] = NONE ; //<S2SV> mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , //<S2SV> tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; //<S2SV> mbmi -> interp_filter = cpi -> common . interp_filter == SWITCHABLE ? //<S2SV> EIGHTTAP : cpi -> common . interp_filter ; //<S2SV> mbmi -> skip = 0 ; //<S2SV> mbmi -> segment_id = segment_id ; //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= LAST_FRAME ; ++ ref_frame ) { //<S2SV> x -> pred_mv_sad [ ref_frame ] = INT_MAX ; //<S2SV> if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) { //<S2SV> vp9_setup_buffer_inter ( cpi , x , tile , //<S2SV> ref_frame , bsize , mi_row , mi_col , //<S2SV> frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ; //<S2SV> } //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; //<S2SV> frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; //<S2SV> } //<S2SV> if ( xd -> up_available ) //<S2SV> filter_ref = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ; //<S2SV> else if ( xd -> left_available ) //<S2SV> filter_ref = xd -> mi [ - 1 ] -> mbmi . interp_filter ; //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= LAST_FRAME ; ++ ref_frame ) { //<S2SV> if ( ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) ) //<S2SV> continue ; //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ 0 ] ; //<S2SV> clamp_mv2 ( & frame_mv [ NEARESTMV ] [ ref_frame ] . as_mv , xd ) ; //<S2SV> clamp_mv2 ( & frame_mv [ NEARMV ] [ ref_frame ] . as_mv , xd ) ; //<S2SV> mbmi -> ref_frame [ 0 ] = ref_frame ; //<S2SV> if ( ref_frame == LAST_FRAME ) { //<S2SV> mode_idx [ NEARESTMV ] = THR_NEARESTMV ; //<S2SV> mode_idx [ NEARMV ] = THR_NEARMV ; //<S2SV> mode_idx [ ZEROMV ] = THR_ZEROMV ; //<S2SV> mode_idx [ NEWMV ] = THR_NEWMV ; //<S2SV> } //<S2SV> for ( this_mode = NEARESTMV ; this_mode <= NEWMV ; ++ this_mode ) { //<S2SV> int rate_mv = 0 ; //<S2SV> if ( cpi -> sf . disable_inter_mode_mask [ bsize ] & //<S2SV> ( 1 << INTER_OFFSET ( this_mode ) ) ) //<S2SV> continue ; //<S2SV> if ( best_rd < ( ( int64_t ) rd_threshes [ mode_idx [ this_mode ] ] * //<S2SV> rd_thresh_freq_fact [ this_mode ] >> 5 ) || //<S2SV> rd_threshes [ mode_idx [ this_mode ] ] == INT_MAX ) //<S2SV> continue ; //<S2SV> if ( this_mode == NEWMV ) { //<S2SV> int rate_mode = 0 ; //<S2SV> if ( this_rd < ( int64_t ) ( 1 << num_pels_log2_lookup [ bsize ] ) ) //<S2SV> continue ; //<S2SV> full_pixel_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , //<S2SV> & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv ) ; //<S2SV> if ( frame_mv [ NEWMV ] [ ref_frame ] . as_int == INVALID_MV ) //<S2SV> continue ; //<S2SV> rate_mode = x -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ] //<S2SV> [ INTER_OFFSET ( this_mode ) ] ; //<S2SV> if ( RDCOST ( x -> rdmult , x -> rddiv , rate_mv + rate_mode , 0 ) > best_rd ) //<S2SV> continue ; //<S2SV> sub_pixel_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , //<S2SV> & frame_mv [ NEWMV ] [ ref_frame ] . as_mv ) ; //<S2SV> } //<S2SV> if ( this_mode != NEARESTMV ) //<S2SV> if ( frame_mv [ this_mode ] [ ref_frame ] . as_int == //<S2SV> frame_mv [ NEARESTMV ] [ ref_frame ] . as_int ) //<S2SV> continue ; //<S2SV> mbmi -> mode = this_mode ; //<S2SV> mbmi -> mv [ 0 ] . as_int = frame_mv [ this_mode ] [ ref_frame ] . as_int ; //<S2SV> if ( ( this_mode == NEWMV || filter_ref == SWITCHABLE ) && //<S2SV> ( ( mbmi -> mv [ 0 ] . as_mv . row & 0x07 ) != 0 || //<S2SV> ( mbmi -> mv [ 0 ] . as_mv . col & 0x07 ) != 0 ) ) { //<S2SV> int64_t tmp_rdcost1 = INT64_MAX ; //<S2SV> int64_t tmp_rdcost2 = INT64_MAX ; //<S2SV> int64_t tmp_rdcost3 = INT64_MAX ; //<S2SV> int pf_rate [ 3 ] ; //<S2SV> int64_t pf_dist [ 3 ] ; //<S2SV> mbmi -> interp_filter = EIGHTTAP ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ; //<S2SV> model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP ] , //<S2SV> & pf_dist [ EIGHTTAP ] ) ; //<S2SV> tmp_rdcost1 = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP ] , //<S2SV> pf_dist [ EIGHTTAP ] ) ; //<S2SV> mbmi -> interp_filter = EIGHTTAP_SHARP ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ; //<S2SV> model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP_SHARP ] , //<S2SV> & pf_dist [ EIGHTTAP_SHARP ] ) ; //<S2SV> tmp_rdcost2 = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP_SHARP ] , //<S2SV> pf_dist [ EIGHTTAP_SHARP ] ) ; //<S2SV> mbmi -> interp_filter = EIGHTTAP_SMOOTH ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ; //<S2SV> model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ EIGHTTAP_SMOOTH ] , //<S2SV> & pf_dist [ EIGHTTAP_SMOOTH ] ) ; //<S2SV> tmp_rdcost3 = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> vp9_get_switchable_rate ( x ) + pf_rate [ EIGHTTAP_SMOOTH ] , //<S2SV> pf_dist [ EIGHTTAP_SMOOTH ] ) ; //<S2SV> if ( tmp_rdcost2 < tmp_rdcost1 ) { //<S2SV> if ( tmp_rdcost2 < tmp_rdcost3 ) //<S2SV> mbmi -> interp_filter = EIGHTTAP_SHARP ; //<S2SV> else //<S2SV> mbmi -> interp_filter = EIGHTTAP_SMOOTH ; //<S2SV> } else { //<S2SV> if ( tmp_rdcost1 < tmp_rdcost3 ) //<S2SV> mbmi -> interp_filter = EIGHTTAP ; //<S2SV> else //<S2SV> mbmi -> interp_filter = EIGHTTAP_SMOOTH ; //<S2SV> } //<S2SV> rate = pf_rate [ mbmi -> interp_filter ] ; //<S2SV> dist = pf_dist [ mbmi -> interp_filter ] ; //<S2SV> } else { //<S2SV> mbmi -> interp_filter = ( filter_ref == SWITCHABLE ) ? EIGHTTAP : filter_ref ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ; //<S2SV> model_rd_for_sb_y ( cpi , bsize , x , xd , & rate , & dist ) ; //<S2SV> } //<S2SV> rate += rate_mv ; //<S2SV> rate += x -> inter_mode_cost [ mbmi -> mode_context [ ref_frame ] ] //<S2SV> [ INTER_OFFSET ( this_mode ) ] ; //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ; //<S2SV> if ( this_rd < best_rd ) { //<S2SV> best_rd = this_rd ; //<S2SV> * returnrate = rate ; //<S2SV> * returndistortion = dist ; //<S2SV> best_mode = this_mode ; //<S2SV> best_pred_filter = mbmi -> interp_filter ; //<S2SV> best_ref_frame = ref_frame ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> mbmi -> mode = best_mode ; //<S2SV> mbmi -> interp_filter = best_pred_filter ; //<S2SV> mbmi -> ref_frame [ 0 ] = best_ref_frame ; //<S2SV> mbmi -> mv [ 0 ] . as_int = frame_mv [ best_mode ] [ best_ref_frame ] . as_int ; //<S2SV> xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = mbmi -> mv [ 0 ] . as_int ; //<S2SV> if ( best_rd > inter_mode_thresh ) { //<S2SV> for ( this_mode = DC_PRED ; this_mode <= DC_PRED ; ++ this_mode ) { //<S2SV> vp9_predict_intra_block ( xd , 0 , b_width_log2 ( bsize ) , //<S2SV> mbmi -> tx_size , this_mode , //<S2SV> & p -> src . buf [ 0 ] , p -> src . stride , //<S2SV> & pd -> dst . buf [ 0 ] , pd -> dst . stride , 0 , 0 , 0 ) ; //<S2SV> model_rd_for_sb_y ( cpi , bsize , x , xd , & rate , & dist ) ; //<S2SV> rate += x -> mbmode_cost [ this_mode ] ; //<S2SV> rate += intra_cost_penalty ; //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ; //<S2SV> if ( this_rd + intra_mode_cost < best_rd ) { //<S2SV> best_rd = this_rd ; //<S2SV> * returnrate = rate ; //<S2SV> * returndistortion = dist ; //<S2SV> mbmi -> mode = this_mode ; //<S2SV> mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; //<S2SV> mbmi -> uv_mode = this_mode ; //<S2SV> mbmi -> mv [ 0 ] . as_int = INVALID_MV ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return INT64_MAX ; //<S2SV> } //<S2SV> 