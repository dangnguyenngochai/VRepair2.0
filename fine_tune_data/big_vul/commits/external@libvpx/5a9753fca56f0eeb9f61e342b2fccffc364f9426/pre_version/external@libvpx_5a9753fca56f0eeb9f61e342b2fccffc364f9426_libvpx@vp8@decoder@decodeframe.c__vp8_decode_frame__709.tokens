int vp8_decode_frame ( VP8D_COMP * pbi ) //<S2SV> { //<S2SV> vp8_reader * const bc = & pbi -> mbc [ 8 ] ; //<S2SV> VP8_COMMON * const pc = & pbi -> common ; //<S2SV> MACROBLOCKD * const xd = & pbi -> mb ; //<S2SV> const unsigned char * data = pbi -> fragments . ptrs [ 0 ] ; //<S2SV> const unsigned char * data_end = data + pbi -> fragments . sizes [ 0 ] ; //<S2SV> ptrdiff_t first_partition_length_in_bytes ; //<S2SV> int i , j , k , l ; //<S2SV> const int * const mb_feature_data_bits = vp8_mb_feature_data_bits ; //<S2SV> int corrupt_tokens = 0 ; //<S2SV> int prev_independent_partitions = pbi -> independent_partitions ; //<S2SV> YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; //<S2SV> xd -> corrupted = 0 ; //<S2SV> yv12_fb_new -> corrupted = 0 ; //<S2SV> if ( data_end - data < 3 ) //<S2SV> { //<S2SV> if ( ! pbi -> ec_active ) //<S2SV> { //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Truncated<S2SV_blank>packet" ) ; //<S2SV> } //<S2SV> pc -> frame_type = INTER_FRAME ; //<S2SV> pc -> version = 0 ; //<S2SV> pc -> show_frame = 1 ; //<S2SV> first_partition_length_in_bytes = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> unsigned char clear_buffer [ 10 ] ; //<S2SV> const unsigned char * clear = data ; //<S2SV> if ( pbi -> decrypt_cb ) //<S2SV> { //<S2SV> int n = ( int ) ( data_end - data ) ; //<S2SV> if ( n > 10 ) n = 10 ; //<S2SV> pbi -> decrypt_cb ( pbi -> decrypt_state , data , clear_buffer , n ) ; //<S2SV> clear = clear_buffer ; //<S2SV> } //<S2SV> pc -> frame_type = ( FRAME_TYPE ) ( clear [ 0 ] & 1 ) ; //<S2SV> pc -> version = ( clear [ 0 ] >> 1 ) & 7 ; //<S2SV> pc -> show_frame = ( clear [ 0 ] >> 4 ) & 1 ; //<S2SV> first_partition_length_in_bytes = //<S2SV> ( clear [ 0 ] | ( clear [ 1 ] << 8 ) | ( clear [ 2 ] << 16 ) ) >> 5 ; //<S2SV> if ( ! pbi -> ec_active && //<S2SV> ( data + first_partition_length_in_bytes > data_end //<S2SV> || data + first_partition_length_in_bytes < data ) ) //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Truncated<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>corrupt<S2SV_blank>partition<S2SV_blank>0<S2SV_blank>length" ) ; //<S2SV> data += 3 ; //<S2SV> clear += 3 ; //<S2SV> vp8_setup_version ( pc ) ; //<S2SV> if ( pc -> frame_type == KEY_FRAME ) //<S2SV> { //<S2SV> if ( ! pbi -> ec_active || data + 3 < data_end ) //<S2SV> { //<S2SV> if ( clear [ 0 ] != 0x9d || clear [ 1 ] != 0x01 || clear [ 2 ] != 0x2a ) //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code" ) ; //<S2SV> } //<S2SV> if ( ! pbi -> ec_active || data + 6 < data_end ) //<S2SV> { //<S2SV> pc -> Width = ( clear [ 3 ] | ( clear [ 4 ] << 8 ) ) & 0x3fff ; //<S2SV> pc -> horiz_scale = clear [ 4 ] >> 6 ; //<S2SV> pc -> Height = ( clear [ 5 ] | ( clear [ 6 ] << 8 ) ) & 0x3fff ; //<S2SV> pc -> vert_scale = clear [ 6 ] >> 6 ; //<S2SV> } //<S2SV> data += 7 ; //<S2SV> clear += 7 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> vpx_memcpy ( & xd -> pre , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; //<S2SV> vpx_memcpy ( & xd -> dst , yv12_fb_new , sizeof ( YV12_BUFFER_CONFIG ) ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ! pbi -> decoded_key_frame && pc -> frame_type != KEY_FRAME ) ) //<S2SV> { //<S2SV> return - 1 ; //<S2SV> } //<S2SV> init_frame ( pbi ) ; //<S2SV> if ( vp8dx_start_decode ( bc , data , ( unsigned int ) ( data_end - data ) , //<S2SV> pbi -> decrypt_cb , pbi -> decrypt_state ) ) //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0" ) ; //<S2SV> if ( pc -> frame_type == KEY_FRAME ) { //<S2SV> ( void ) vp8_read_bit ( bc ) ; //<S2SV> pc -> clamp_type = ( CLAMP_TYPE ) vp8_read_bit ( bc ) ; //<S2SV> } //<S2SV> xd -> segmentation_enabled = ( unsigned char ) vp8_read_bit ( bc ) ; //<S2SV> if ( xd -> segmentation_enabled ) //<S2SV> { //<S2SV> xd -> update_mb_segmentation_map = ( unsigned char ) vp8_read_bit ( bc ) ; //<S2SV> xd -> update_mb_segmentation_data = ( unsigned char ) vp8_read_bit ( bc ) ; //<S2SV> if ( xd -> update_mb_segmentation_data ) //<S2SV> { //<S2SV> xd -> mb_segement_abs_delta = ( unsigned char ) vp8_read_bit ( bc ) ; //<S2SV> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; //<S2SV> for ( i = 0 ; i < MB_LVL_MAX ; i ++ ) //<S2SV> { //<S2SV> for ( j = 0 ; j < MAX_MB_SEGMENTS ; j ++ ) //<S2SV> { //<S2SV> if ( vp8_read_bit ( bc ) ) //<S2SV> { //<S2SV> xd -> segment_feature_data [ i ] [ j ] = ( signed char ) vp8_read_literal ( bc , mb_feature_data_bits [ i ] ) ; //<S2SV> if ( vp8_read_bit ( bc ) ) //<S2SV> xd -> segment_feature_data [ i ] [ j ] = - xd -> segment_feature_data [ i ] [ j ] ; //<S2SV> } //<S2SV> else //<S2SV> xd -> segment_feature_data [ i ] [ j ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( xd -> update_mb_segmentation_map ) //<S2SV> { //<S2SV> vpx_memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; //<S2SV> for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ ) //<S2SV> { //<S2SV> if ( vp8_read_bit ( bc ) ) //<S2SV> xd -> mb_segment_tree_probs [ i ] = ( vp8_prob ) vp8_read_literal ( bc , 8 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> xd -> update_mb_segmentation_map = 0 ; //<S2SV> xd -> update_mb_segmentation_data = 0 ; //<S2SV> } //<S2SV> pc -> filter_type = ( LOOPFILTERTYPE ) vp8_read_bit ( bc ) ; //<S2SV> pc -> filter_level = vp8_read_literal ( bc , 6 ) ; //<S2SV> pc -> sharpness_level = vp8_read_literal ( bc , 3 ) ; //<S2SV> xd -> mode_ref_lf_delta_update = 0 ; //<S2SV> xd -> mode_ref_lf_delta_enabled = ( unsigned char ) vp8_read_bit ( bc ) ; //<S2SV> if ( xd -> mode_ref_lf_delta_enabled ) //<S2SV> { //<S2SV> xd -> mode_ref_lf_delta_update = ( unsigned char ) vp8_read_bit ( bc ) ; //<S2SV> if ( xd -> mode_ref_lf_delta_update ) //<S2SV> { //<S2SV> for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) //<S2SV> { //<S2SV> if ( vp8_read_bit ( bc ) ) //<S2SV> { //<S2SV> xd -> ref_lf_deltas [ i ] = ( signed char ) vp8_read_literal ( bc , 6 ) ; //<S2SV> if ( vp8_read_bit ( bc ) ) //<S2SV> xd -> ref_lf_deltas [ i ] = xd -> ref_lf_deltas [ i ] * - 1 ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) //<S2SV> { //<S2SV> if ( vp8_read_bit ( bc ) ) //<S2SV> { //<S2SV> xd -> mode_lf_deltas [ i ] = ( signed char ) vp8_read_literal ( bc , 6 ) ; //<S2SV> if ( vp8_read_bit ( bc ) ) //<S2SV> xd -> mode_lf_deltas [ i ] = xd -> mode_lf_deltas [ i ] * - 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> setup_token_decoder ( pbi , data + first_partition_length_in_bytes ) ; //<S2SV> xd -> current_bc = & pbi -> mbc [ 0 ] ; //<S2SV> { //<S2SV> int Q , q_update ; //<S2SV> Q = vp8_read_literal ( bc , 7 ) ; //<S2SV> pc -> base_qindex = Q ; //<S2SV> q_update = 0 ; //<S2SV> pc -> y1dc_delta_q = get_delta_q ( bc , pc -> y1dc_delta_q , & q_update ) ; //<S2SV> pc -> y2dc_delta_q = get_delta_q ( bc , pc -> y2dc_delta_q , & q_update ) ; //<S2SV> pc -> y2ac_delta_q = get_delta_q ( bc , pc -> y2ac_delta_q , & q_update ) ; //<S2SV> pc -> uvdc_delta_q = get_delta_q ( bc , pc -> uvdc_delta_q , & q_update ) ; //<S2SV> pc -> uvac_delta_q = get_delta_q ( bc , pc -> uvac_delta_q , & q_update ) ; //<S2SV> if ( q_update ) //<S2SV> vp8cx_init_de_quantizer ( pbi ) ; //<S2SV> vp8_mb_init_dequantizer ( pbi , & pbi -> mb ) ; //<S2SV> } //<S2SV> if ( pc -> frame_type != KEY_FRAME ) //<S2SV> { //<S2SV> pc -> refresh_golden_frame = vp8_read_bit ( bc ) ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> xd -> corrupted |= vp8dx_bool_error ( bc ) ; //<S2SV> if ( pbi -> ec_active && xd -> corrupted ) //<S2SV> pc -> refresh_golden_frame = 0 ; //<S2SV> # endif //<S2SV> pc -> refresh_alt_ref_frame = vp8_read_bit ( bc ) ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> xd -> corrupted |= vp8dx_bool_error ( bc ) ; //<S2SV> if ( pbi -> ec_active && xd -> corrupted ) //<S2SV> pc -> refresh_alt_ref_frame = 0 ; //<S2SV> # endif //<S2SV> pc -> copy_buffer_to_gf = 0 ; //<S2SV> if ( ! pc -> refresh_golden_frame ) //<S2SV> pc -> copy_buffer_to_gf = vp8_read_literal ( bc , 2 ) ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> xd -> corrupted |= vp8dx_bool_error ( bc ) ; //<S2SV> if ( pbi -> ec_active && xd -> corrupted ) //<S2SV> pc -> copy_buffer_to_gf = 0 ; //<S2SV> # endif //<S2SV> pc -> copy_buffer_to_arf = 0 ; //<S2SV> if ( ! pc -> refresh_alt_ref_frame ) //<S2SV> pc -> copy_buffer_to_arf = vp8_read_literal ( bc , 2 ) ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> xd -> corrupted |= vp8dx_bool_error ( bc ) ; //<S2SV> if ( pbi -> ec_active && xd -> corrupted ) //<S2SV> pc -> copy_buffer_to_arf = 0 ; //<S2SV> # endif //<S2SV> pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = vp8_read_bit ( bc ) ; //<S2SV> pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = vp8_read_bit ( bc ) ; //<S2SV> } //<S2SV> pc -> refresh_entropy_probs = vp8_read_bit ( bc ) ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> xd -> corrupted |= vp8dx_bool_error ( bc ) ; //<S2SV> if ( pbi -> ec_active && xd -> corrupted ) //<S2SV> pc -> refresh_entropy_probs = 0 ; //<S2SV> # endif //<S2SV> if ( pc -> refresh_entropy_probs == 0 ) //<S2SV> { //<S2SV> vpx_memcpy ( & pc -> lfc , & pc -> fc , sizeof ( pc -> fc ) ) ; //<S2SV> } //<S2SV> pc -> refresh_last_frame = pc -> frame_type == KEY_FRAME || vp8_read_bit ( bc ) ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> xd -> corrupted |= vp8dx_bool_error ( bc ) ; //<S2SV> if ( pbi -> ec_active && xd -> corrupted ) //<S2SV> pc -> refresh_last_frame = 1 ; //<S2SV> # endif //<S2SV> if ( 0 ) //<S2SV> { //<S2SV> FILE * z = fopen ( "decodestats.stt" , "a" ) ; //<S2SV> fprintf ( z , "%6d<S2SV_blank>F:%d,G:%d,A:%d,L:%d,Q:%d\\n" , //<S2SV> pc -> current_video_frame , //<S2SV> pc -> frame_type , //<S2SV> pc -> refresh_golden_frame , //<S2SV> pc -> refresh_alt_ref_frame , //<S2SV> pc -> refresh_last_frame , //<S2SV> pc -> base_qindex ) ; //<S2SV> fclose ( z ) ; //<S2SV> } //<S2SV> { //<S2SV> pbi -> independent_partitions = 1 ; //<S2SV> for ( i = 0 ; i < BLOCK_TYPES ; i ++ ) //<S2SV> for ( j = 0 ; j < COEF_BANDS ; j ++ ) //<S2SV> for ( k = 0 ; k < PREV_COEF_CONTEXTS ; k ++ ) //<S2SV> for ( l = 0 ; l < ENTROPY_NODES ; l ++ ) //<S2SV> { //<S2SV> vp8_prob * const p = pc -> fc . coef_probs [ i ] [ j ] [ k ] + l ; //<S2SV> if ( vp8_read ( bc , vp8_coef_update_probs [ i ] [ j ] [ k ] [ l ] ) ) //<S2SV> { //<S2SV> * p = ( vp8_prob ) vp8_read_literal ( bc , 8 ) ; //<S2SV> } //<S2SV> if ( k > 0 && * p != pc -> fc . coef_probs [ i ] [ j ] [ k - 1 ] [ l ] ) //<S2SV> pbi -> independent_partitions = 0 ; //<S2SV> } //<S2SV> } //<S2SV> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; //<S2SV> vp8_decode_mode_mvs ( pbi ) ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> if ( pbi -> ec_active && //<S2SV> pbi -> mvs_corrupt_from_mb < ( unsigned int ) pc -> mb_cols * pc -> mb_rows ) //<S2SV> { //<S2SV> vp8_estimate_missing_mvs ( pbi ) ; //<S2SV> } //<S2SV> # endif //<S2SV> vpx_memset ( pc -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) * pc -> mb_cols ) ; //<S2SV> pbi -> frame_corrupt_residual = 0 ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( pbi -> b_multithreaded_rd && pc -> multi_token_partition != ONE_PARTITION ) //<S2SV> { //<S2SV> unsigned int thread ; //<S2SV> vp8mt_decode_mb_rows ( pbi , xd ) ; //<S2SV> vp8_yv12_extend_frame_borders ( yv12_fb_new ) ; //<S2SV> for ( thread = 0 ; thread < pbi -> decoding_thread_count ; ++ thread ) //<S2SV> corrupt_tokens |= pbi -> mb_row_di [ thread ] . mbd . corrupted ; //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> { //<S2SV> decode_mb_rows ( pbi ) ; //<S2SV> corrupt_tokens |= xd -> corrupted ; //<S2SV> } //<S2SV> yv12_fb_new -> corrupted = vp8dx_bool_error ( bc ) ; //<S2SV> yv12_fb_new -> corrupted |= corrupt_tokens ; //<S2SV> if ( ! pbi -> decoded_key_frame ) //<S2SV> { //<S2SV> if ( pc -> frame_type == KEY_FRAME && //<S2SV> ! yv12_fb_new -> corrupted ) //<S2SV> pbi -> decoded_key_frame = 1 ; //<S2SV> else //<S2SV> vpx_internal_error ( & pbi -> common . error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "A<S2SV_blank>stream<S2SV_blank>must<S2SV_blank>start<S2SV_blank>with<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>key<S2SV_blank>frame" ) ; //<S2SV> } //<S2SV> if ( pc -> refresh_entropy_probs == 0 ) //<S2SV> { //<S2SV> vpx_memcpy ( & pc -> fc , & pc -> lfc , sizeof ( pc -> fc ) ) ; //<S2SV> pbi -> independent_partitions = prev_independent_partitions ; //<S2SV> } //<S2SV> # ifdef PACKET_TESTING //<S2SV> { //<S2SV> FILE * f = fopen ( "decompressor.VP8" , "ab" ) ; //<S2SV> unsigned int size = pbi -> bc2 . pos + pbi -> bc . pos + 8 ; //<S2SV> fwrite ( ( void * ) & size , 4 , 1 , f ) ; //<S2SV> fwrite ( ( void * ) pbi -> Source , size , 1 , f ) ; //<S2SV> fclose ( f ) ; //<S2SV> } //<S2SV> # endif //<S2SV> return 0 ; //<S2SV> } //<S2SV> 