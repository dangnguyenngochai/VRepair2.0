static int decode_coefs ( VP9_COMMON * cm , const MACROBLOCKD * xd , PLANE_TYPE type , //<S2SV> int16_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq , //<S2SV> int ctx , const int16_t * scan , const int16_t * nb , //<S2SV> vp9_reader * r ) { //<S2SV> const int max_eob = 16 << ( tx_size << 1 ) ; //<S2SV> const FRAME_CONTEXT * const fc = & cm -> fc ; //<S2SV> FRAME_COUNTS * const counts = & cm -> counts ; //<S2SV> const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ; //<S2SV> int band , c = 0 ; //<S2SV> const vp9_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = //<S2SV> fc -> coef_probs [ tx_size ] [ type ] [ ref ] ; //<S2SV> const vp9_prob * prob ; //<S2SV> unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] = //<S2SV> counts -> coef [ tx_size ] [ type ] [ ref ] ; //<S2SV> unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] = //<S2SV> counts -> eob_branch [ tx_size ] [ type ] [ ref ] ; //<S2SV> uint8_t token_cache [ 32 * 32 ] ; //<S2SV> const uint8_t * cat6 ; //<S2SV> const uint8_t * band_translate = get_band_translate ( tx_size ) ; //<S2SV> const int dq_shift = ( tx_size == TX_32X32 ) ; //<S2SV> int v ; //<S2SV> int16_t dqv = dq [ 0 ] ; //<S2SV> while ( c < max_eob ) { //<S2SV> int val ; //<S2SV> band = * band_translate ++ ; //<S2SV> prob = coef_probs [ band ] [ ctx ] ; //<S2SV> if ( ! cm -> frame_parallel_decoding_mode ) //<S2SV> ++ eob_branch_count [ band ] [ ctx ] ; //<S2SV> if ( ! vp9_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) { //<S2SV> INCREMENT_COUNT ( EOB_MODEL_TOKEN ) ; //<S2SV> break ; //<S2SV> } //<S2SV> while ( ! vp9_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) { //<S2SV> INCREMENT_COUNT ( ZERO_TOKEN ) ; //<S2SV> dqv = dq [ 1 ] ; //<S2SV> token_cache [ scan [ c ] ] = 0 ; //<S2SV> ++ c ; //<S2SV> if ( c >= max_eob ) //<S2SV> return c ; //<S2SV> ctx = get_coef_context ( nb , token_cache , c ) ; //<S2SV> band = * band_translate ++ ; //<S2SV> prob = coef_probs [ band ] [ ctx ] ; //<S2SV> } //<S2SV> if ( ! vp9_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) { //<S2SV> INCREMENT_COUNT ( ONE_TOKEN ) ; //<S2SV> WRITE_COEF_CONTINUE ( 1 , ONE_TOKEN ) ; //<S2SV> } //<S2SV> INCREMENT_COUNT ( TWO_TOKEN ) ; //<S2SV> prob = vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ; //<S2SV> if ( ! vp9_read ( r , prob [ LOW_VAL_CONTEXT_NODE ] ) ) { //<S2SV> if ( ! vp9_read ( r , prob [ TWO_CONTEXT_NODE ] ) ) { //<S2SV> WRITE_COEF_CONTINUE ( 2 , TWO_TOKEN ) ; //<S2SV> } //<S2SV> if ( ! vp9_read ( r , prob [ THREE_CONTEXT_NODE ] ) ) { //<S2SV> WRITE_COEF_CONTINUE ( 3 , THREE_TOKEN ) ; //<S2SV> } //<S2SV> WRITE_COEF_CONTINUE ( 4 , FOUR_TOKEN ) ; //<S2SV> } //<S2SV> if ( ! vp9_read ( r , prob [ HIGH_LOW_CONTEXT_NODE ] ) ) { //<S2SV> if ( ! vp9_read ( r , prob [ CAT_ONE_CONTEXT_NODE ] ) ) { //<S2SV> val = CAT1_MIN_VAL ; //<S2SV> ADJUST_COEF ( CAT1_PROB0 , 0 ) ; //<S2SV> WRITE_COEF_CONTINUE ( val , CATEGORY1_TOKEN ) ; //<S2SV> } //<S2SV> val = CAT2_MIN_VAL ; //<S2SV> ADJUST_COEF ( CAT2_PROB1 , 1 ) ; //<S2SV> ADJUST_COEF ( CAT2_PROB0 , 0 ) ; //<S2SV> WRITE_COEF_CONTINUE ( val , CATEGORY2_TOKEN ) ; //<S2SV> } //<S2SV> if ( ! vp9_read ( r , prob [ CAT_THREEFOUR_CONTEXT_NODE ] ) ) { //<S2SV> if ( ! vp9_read ( r , prob [ CAT_THREE_CONTEXT_NODE ] ) ) { //<S2SV> val = CAT3_MIN_VAL ; //<S2SV> ADJUST_COEF ( CAT3_PROB2 , 2 ) ; //<S2SV> ADJUST_COEF ( CAT3_PROB1 , 1 ) ; //<S2SV> ADJUST_COEF ( CAT3_PROB0 , 0 ) ; //<S2SV> WRITE_COEF_CONTINUE ( val , CATEGORY3_TOKEN ) ; //<S2SV> } //<S2SV> val = CAT4_MIN_VAL ; //<S2SV> ADJUST_COEF ( CAT4_PROB3 , 3 ) ; //<S2SV> ADJUST_COEF ( CAT4_PROB2 , 2 ) ; //<S2SV> ADJUST_COEF ( CAT4_PROB1 , 1 ) ; //<S2SV> ADJUST_COEF ( CAT4_PROB0 , 0 ) ; //<S2SV> WRITE_COEF_CONTINUE ( val , CATEGORY4_TOKEN ) ; //<S2SV> } //<S2SV> if ( ! vp9_read ( r , prob [ CAT_FIVE_CONTEXT_NODE ] ) ) { //<S2SV> val = CAT5_MIN_VAL ; //<S2SV> ADJUST_COEF ( CAT5_PROB4 , 4 ) ; //<S2SV> ADJUST_COEF ( CAT5_PROB3 , 3 ) ; //<S2SV> ADJUST_COEF ( CAT5_PROB2 , 2 ) ; //<S2SV> ADJUST_COEF ( CAT5_PROB1 , 1 ) ; //<S2SV> ADJUST_COEF ( CAT5_PROB0 , 0 ) ; //<S2SV> WRITE_COEF_CONTINUE ( val , CATEGORY5_TOKEN ) ; //<S2SV> } //<S2SV> val = 0 ; //<S2SV> cat6 = cat6_prob ; //<S2SV> while ( * cat6 ) //<S2SV> val = ( val << 1 ) | vp9_read ( r , * cat6 ++ ) ; //<S2SV> val += CAT6_MIN_VAL ; //<S2SV> WRITE_COEF_CONTINUE ( val , CATEGORY6_TOKEN ) ; //<S2SV> } //<S2SV> return c ; //<S2SV> } //<S2SV> 