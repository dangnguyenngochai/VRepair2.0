static void encode_rd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> int mi_row , TOKENEXTRA * * tp ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; //<S2SV> SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> int mi_col ; //<S2SV> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; //<S2SV> vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; //<S2SV> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; //<S2SV> mi_col += MI_BLOCK_SIZE ) { //<S2SV> int dummy_rate ; //<S2SV> int64_t dummy_dist ; //<S2SV> BLOCK_SIZE i ; //<S2SV> MACROBLOCK * x = & cpi -> mb ; //<S2SV> if ( sf -> adaptive_pred_interp_filter ) { //<S2SV> for ( i = BLOCK_4X4 ; i < BLOCK_8X8 ; ++ i ) { //<S2SV> const int num_4x4_w = num_4x4_blocks_wide_lookup [ i ] ; //<S2SV> const int num_4x4_h = num_4x4_blocks_high_lookup [ i ] ; //<S2SV> const int num_4x4_blk = MAX ( 4 , num_4x4_w * num_4x4_h ) ; //<S2SV> for ( x -> sb_index = 0 ; x -> sb_index < 4 ; ++ x -> sb_index ) //<S2SV> for ( x -> mb_index = 0 ; x -> mb_index < 4 ; ++ x -> mb_index ) //<S2SV> for ( x -> b_index = 0 ; x -> b_index < 16 / num_4x4_blk ; ++ x -> b_index ) //<S2SV> get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ; //<S2SV> } //<S2SV> } //<S2SV> vp9_zero ( cpi -> mb . pred_mv ) ; //<S2SV> if ( ( sf -> partition_search_type == SEARCH_PARTITION && //<S2SV> sf -> use_lastframe_partitioning ) || //<S2SV> sf -> partition_search_type == FIXED_PARTITION || //<S2SV> sf -> partition_search_type == VAR_BASED_PARTITION || //<S2SV> sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) { //<S2SV> const int idx_str = cm -> mi_stride * mi_row + mi_col ; //<S2SV> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; //<S2SV> MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; //<S2SV> cpi -> mb . source_variance = UINT_MAX ; //<S2SV> if ( sf -> partition_search_type == FIXED_PARTITION ) { //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , //<S2SV> sf -> always_this_block_size ) ; //<S2SV> rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> & dummy_rate , & dummy_dist , 1 ) ; //<S2SV> } else if ( sf -> partition_search_type == VAR_BASED_FIXED_PARTITION ) { //<S2SV> BLOCK_SIZE bsize ; //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> bsize = get_rd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ; //<S2SV> set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; //<S2SV> rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> & dummy_rate , & dummy_dist , 1 ) ; //<S2SV> } else if ( sf -> partition_search_type == VAR_BASED_PARTITION ) { //<S2SV> choose_partitioning ( cpi , tile , mi_row , mi_col ) ; //<S2SV> rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> & dummy_rate , & dummy_dist , 1 ) ; //<S2SV> } else { //<S2SV> if ( ( cm -> current_video_frame //<S2SV> % sf -> last_partitioning_redo_frequency ) == 0 //<S2SV> || cm -> prev_mi == 0 //<S2SV> || cm -> show_frame == 0 //<S2SV> || cm -> frame_type == KEY_FRAME //<S2SV> || cpi -> rc . is_src_frame_alt_ref //<S2SV> || ( ( sf -> use_lastframe_partitioning == //<S2SV> LAST_FRAME_PARTITION_LOW_MOTION ) && //<S2SV> sb_has_motion ( cm , prev_mi_8x8 ) ) ) { //<S2SV> if ( sf -> auto_min_max_partition_size ) { //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> rd_auto_partition_range ( cpi , tile , mi_row , mi_col , //<S2SV> & sf -> min_partition_size , //<S2SV> & sf -> max_partition_size ) ; //<S2SV> } //<S2SV> rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; //<S2SV> } else { //<S2SV> if ( sf -> constrain_copy_partition && //<S2SV> sb_has_motion ( cm , prev_mi_8x8 ) ) //<S2SV> constrain_copy_partitioning ( cpi , tile , mi_8x8 , prev_mi_8x8 , //<S2SV> mi_row , mi_col , BLOCK_16X16 ) ; //<S2SV> else //<S2SV> copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; //<S2SV> rd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> & dummy_rate , & dummy_dist , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> if ( sf -> auto_min_max_partition_size ) { //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> rd_auto_partition_range ( cpi , tile , mi_row , mi_col , //<S2SV> & sf -> min_partition_size , //<S2SV> & sf -> max_partition_size ) ; //<S2SV> } //<S2SV> rd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 