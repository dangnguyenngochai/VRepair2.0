static int64_t handle_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , //<S2SV> const TileInfo * const tile , //<S2SV> BLOCK_SIZE bsize , //<S2SV> int64_t txfm_cache [ ] , //<S2SV> int * rate2 , int64_t * distortion , //<S2SV> int * skippable , //<S2SV> int * rate_y , int64_t * distortion_y , //<S2SV> int * rate_uv , int64_t * distortion_uv , //<S2SV> int * mode_excluded , int * disable_skip , //<S2SV> INTERP_FILTER * best_filter , //<S2SV> int_mv ( * mode_mv ) [ MAX_REF_FRAMES ] , //<S2SV> int mi_row , int mi_col , //<S2SV> int_mv single_newmv [ MAX_REF_FRAMES ] , //<S2SV> int64_t * psse , //<S2SV> const int64_t ref_best_rd ) { //<S2SV> VP9_COMMON * cm = & cpi -> common ; //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> const int is_comp_pred = has_second_ref ( mbmi ) ; //<S2SV> const int num_refs = is_comp_pred ? 2 : 1 ; //<S2SV> const int this_mode = mbmi -> mode ; //<S2SV> int_mv * frame_mv = mode_mv [ this_mode ] ; //<S2SV> int i ; //<S2SV> int refs [ 2 ] = { mbmi -> ref_frame [ 0 ] , //<S2SV> ( mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ) } ; //<S2SV> int_mv cur_mv [ 2 ] ; //<S2SV> int64_t this_rd = 0 ; //<S2SV> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , tmp_buf , MAX_MB_PLANE * 64 * 64 ) ; //<S2SV> int pred_exists = 0 ; //<S2SV> int intpel_mv ; //<S2SV> int64_t rd , best_rd = INT64_MAX ; //<S2SV> int best_needs_copy = 0 ; //<S2SV> uint8_t * orig_dst [ MAX_MB_PLANE ] ; //<S2SV> int orig_dst_stride [ MAX_MB_PLANE ] ; //<S2SV> int rs = 0 ; //<S2SV> if ( is_comp_pred ) { //<S2SV> if ( frame_mv [ refs [ 0 ] ] . as_int == INVALID_MV || //<S2SV> frame_mv [ refs [ 1 ] ] . as_int == INVALID_MV ) //<S2SV> return INT64_MAX ; //<S2SV> } //<S2SV> if ( this_mode == NEWMV ) { //<S2SV> int rate_mv ; //<S2SV> if ( is_comp_pred ) { //<S2SV> frame_mv [ refs [ 0 ] ] . as_int = single_newmv [ refs [ 0 ] ] . as_int ; //<S2SV> frame_mv [ refs [ 1 ] ] . as_int = single_newmv [ refs [ 1 ] ] . as_int ; //<S2SV> if ( cpi -> sf . comp_inter_joint_search_thresh <= bsize ) { //<S2SV> joint_motion_search ( cpi , x , bsize , frame_mv , //<S2SV> mi_row , mi_col , single_newmv , & rate_mv ) ; //<S2SV> } else { //<S2SV> rate_mv = vp9_mv_bit_cost ( & frame_mv [ refs [ 0 ] ] . as_mv , //<S2SV> & mbmi -> ref_mvs [ refs [ 0 ] ] [ 0 ] . as_mv , //<S2SV> x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; //<S2SV> rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ 1 ] ] . as_mv , //<S2SV> & mbmi -> ref_mvs [ refs [ 1 ] ] [ 0 ] . as_mv , //<S2SV> x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; //<S2SV> } //<S2SV> * rate2 += rate_mv ; //<S2SV> } else { //<S2SV> int_mv tmp_mv ; //<S2SV> single_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , //<S2SV> & tmp_mv , & rate_mv ) ; //<S2SV> if ( tmp_mv . as_int == INVALID_MV ) //<S2SV> return INT64_MAX ; //<S2SV> * rate2 += rate_mv ; //<S2SV> frame_mv [ refs [ 0 ] ] . as_int = //<S2SV> xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ; //<S2SV> single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < num_refs ; ++ i ) { //<S2SV> cur_mv [ i ] = frame_mv [ refs [ i ] ] ; //<S2SV> if ( this_mode != NEWMV ) //<S2SV> clamp_mv2 ( & cur_mv [ i ] . as_mv , xd ) ; //<S2SV> if ( mv_check_bounds ( x , & cur_mv [ i ] . as_mv ) ) //<S2SV> return INT64_MAX ; //<S2SV> mbmi -> mv [ i ] . as_int = cur_mv [ i ] . as_int ; //<S2SV> } //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { //<S2SV> orig_dst [ i ] = xd -> plane [ i ] . dst . buf ; //<S2SV> orig_dst_stride [ i ] = xd -> plane [ i ] . dst . stride ; //<S2SV> } //<S2SV> * rate2 += cost_mv_ref ( cpi , this_mode , mbmi -> mode_context [ refs [ 0 ] ] ) ; //<S2SV> if ( ! ( * mode_excluded ) ) //<S2SV> * mode_excluded = is_comp_pred ? cm -> reference_mode == SINGLE_REFERENCE //<S2SV> : cm -> reference_mode == COMPOUND_REFERENCE ; //<S2SV> pred_exists = 0 ; //<S2SV> intpel_mv = ! mv_has_subpel ( & mbmi -> mv [ 0 ] . as_mv ) ; //<S2SV> if ( is_comp_pred ) //<S2SV> intpel_mv &= ! mv_has_subpel ( & mbmi -> mv [ 1 ] . as_mv ) ; //<S2SV> cpi -> mask_filter_rd = 0 ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) //<S2SV> cpi -> rd_filter_cache [ i ] = INT64_MAX ; //<S2SV> if ( cm -> interp_filter != BILINEAR ) { //<S2SV> * best_filter = EIGHTTAP ; //<S2SV> if ( x -> source_variance < //<S2SV> cpi -> sf . disable_filter_search_var_thresh ) { //<S2SV> * best_filter = EIGHTTAP ; //<S2SV> } else { //<S2SV> int newbest ; //<S2SV> int tmp_rate_sum = 0 ; //<S2SV> int64_t tmp_dist_sum = 0 ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { //<S2SV> int j ; //<S2SV> int64_t rs_rd ; //<S2SV> mbmi -> interp_filter = i ; //<S2SV> rs = vp9_get_switchable_rate ( x ) ; //<S2SV> rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; //<S2SV> if ( i > 0 && intpel_mv ) { //<S2SV> rd = RDCOST ( x -> rdmult , x -> rddiv , tmp_rate_sum , tmp_dist_sum ) ; //<S2SV> cpi -> rd_filter_cache [ i ] = rd ; //<S2SV> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = //<S2SV> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> rd += rs_rd ; //<S2SV> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; //<S2SV> } else { //<S2SV> int rate_sum = 0 ; //<S2SV> int64_t dist_sum = 0 ; //<S2SV> if ( ( cm -> interp_filter == SWITCHABLE && //<S2SV> ( ! i || best_needs_copy ) ) || //<S2SV> ( cm -> interp_filter != SWITCHABLE && //<S2SV> ( cm -> interp_filter == mbmi -> interp_filter || //<S2SV> ( i == 0 && intpel_mv ) ) ) ) { //<S2SV> restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; //<S2SV> } else { //<S2SV> for ( j = 0 ; j < MAX_MB_PLANE ; j ++ ) { //<S2SV> xd -> plane [ j ] . dst . buf = tmp_buf + j * 64 * 64 ; //<S2SV> xd -> plane [ j ] . dst . stride = 64 ; //<S2SV> } //<S2SV> } //<S2SV> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ; //<S2SV> model_rd_for_sb ( cpi , bsize , x , xd , & rate_sum , & dist_sum ) ; //<S2SV> rd = RDCOST ( x -> rdmult , x -> rddiv , rate_sum , dist_sum ) ; //<S2SV> cpi -> rd_filter_cache [ i ] = rd ; //<S2SV> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = //<S2SV> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> rd += rs_rd ; //<S2SV> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; //<S2SV> if ( i == 0 && intpel_mv ) { //<S2SV> tmp_rate_sum = rate_sum ; //<S2SV> tmp_dist_sum = dist_sum ; //<S2SV> } //<S2SV> } //<S2SV> if ( i == 0 && cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) { //<S2SV> if ( rd / 2 > ref_best_rd ) { //<S2SV> restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; //<S2SV> return INT64_MAX ; //<S2SV> } //<S2SV> } //<S2SV> newbest = i == 0 || rd < best_rd ; //<S2SV> if ( newbest ) { //<S2SV> best_rd = rd ; //<S2SV> * best_filter = mbmi -> interp_filter ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE && i && ! intpel_mv ) //<S2SV> best_needs_copy = ! best_needs_copy ; //<S2SV> } //<S2SV> if ( ( cm -> interp_filter == SWITCHABLE && newbest ) || //<S2SV> ( cm -> interp_filter != SWITCHABLE && //<S2SV> cm -> interp_filter == mbmi -> interp_filter ) ) { //<S2SV> pred_exists = 1 ; //<S2SV> } //<S2SV> } //<S2SV> restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; //<S2SV> } //<S2SV> } //<S2SV> mbmi -> interp_filter = cm -> interp_filter != SWITCHABLE ? //<S2SV> cm -> interp_filter : * best_filter ; //<S2SV> rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( x ) : 0 ; //<S2SV> if ( pred_exists ) { //<S2SV> if ( best_needs_copy ) { //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { //<S2SV> xd -> plane [ i ] . dst . buf = tmp_buf + i * 64 * 64 ; //<S2SV> xd -> plane [ i ] . dst . stride = 64 ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) { //<S2SV> int tmp_rate ; //<S2SV> int64_t tmp_dist ; //<S2SV> model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist ) ; //<S2SV> rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ; //<S2SV> if ( rd / 2 > ref_best_rd ) { //<S2SV> restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; //<S2SV> return INT64_MAX ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> * rate2 += vp9_get_switchable_rate ( x ) ; //<S2SV> if ( ! is_comp_pred ) { //<S2SV> if ( ! x -> in_active_map ) { //<S2SV> if ( psse ) //<S2SV> * psse = 0 ; //<S2SV> * distortion = 0 ; //<S2SV> x -> skip = 1 ; //<S2SV> } else if ( cpi -> allow_encode_breakout && x -> encode_breakout ) { //<S2SV> const BLOCK_SIZE y_size = get_plane_block_size ( bsize , & xd -> plane [ 0 ] ) ; //<S2SV> const BLOCK_SIZE uv_size = get_plane_block_size ( bsize , & xd -> plane [ 1 ] ) ; //<S2SV> unsigned int var , sse ; //<S2SV> unsigned int thresh_ac ; //<S2SV> const unsigned int max_thresh = ( cpi -> allow_encode_breakout == //<S2SV> ENCODE_BREAKOUT_LIMITED ) ? 128 : 36000 ; //<S2SV> const unsigned int min_thresh = //<S2SV> MIN ( ( ( unsigned int ) x -> encode_breakout << 4 ) , max_thresh ) ; //<S2SV> thresh_ac = ( xd -> plane [ 0 ] . dequant [ 1 ] * xd -> plane [ 0 ] . dequant [ 1 ] ) / 9 ; //<S2SV> thresh_ac = clamp ( thresh_ac , min_thresh , max_thresh ) ; //<S2SV> var = cpi -> fn_ptr [ y_size ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , //<S2SV> xd -> plane [ 0 ] . dst . buf , //<S2SV> xd -> plane [ 0 ] . dst . stride , & sse ) ; //<S2SV> thresh_ac >>= 8 - ( b_width_log2_lookup [ bsize ] + //<S2SV> b_height_log2_lookup [ bsize ] ) ; //<S2SV> if ( sse < thresh_ac || sse == 0 ) { //<S2SV> unsigned int thresh_dc ; //<S2SV> thresh_dc = ( xd -> plane [ 0 ] . dequant [ 0 ] * xd -> plane [ 0 ] . dequant [ 0 ] >> 6 ) ; //<S2SV> if ( ( sse - var ) < thresh_dc || sse == var ) { //<S2SV> unsigned int sse_u , sse_v ; //<S2SV> unsigned int var_u , var_v ; //<S2SV> var_u = cpi -> fn_ptr [ uv_size ] . vf ( x -> plane [ 1 ] . src . buf , //<S2SV> x -> plane [ 1 ] . src . stride , //<S2SV> xd -> plane [ 1 ] . dst . buf , //<S2SV> xd -> plane [ 1 ] . dst . stride , & sse_u ) ; //<S2SV> if ( ( sse_u * 4 < thresh_ac || sse_u == 0 ) && //<S2SV> ( sse_u - var_u < thresh_dc || sse_u == var_u ) ) { //<S2SV> var_v = cpi -> fn_ptr [ uv_size ] . vf ( x -> plane [ 2 ] . src . buf , //<S2SV> x -> plane [ 2 ] . src . stride , //<S2SV> xd -> plane [ 2 ] . dst . buf , //<S2SV> xd -> plane [ 2 ] . dst . stride , & sse_v ) ; //<S2SV> if ( ( sse_v * 4 < thresh_ac || sse_v == 0 ) && //<S2SV> ( sse_v - var_v < thresh_dc || sse_v == var_v ) ) { //<S2SV> x -> skip = 1 ; //<S2SV> * rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> * distortion_uv = ( sse_u + sse_v ) << 4 ; //<S2SV> * distortion = ( sse << 4 ) + * distortion_uv ; //<S2SV> * disable_skip = 1 ; //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! x -> skip ) { //<S2SV> int skippable_y , skippable_uv ; //<S2SV> int64_t sseuv = INT64_MAX ; //<S2SV> int64_t rdcosty = INT64_MAX ; //<S2SV> inter_super_block_yrd ( cpi , x , rate_y , distortion_y , & skippable_y , psse , //<S2SV> bsize , txfm_cache , ref_best_rd ) ; //<S2SV> if ( * rate_y == INT_MAX ) { //<S2SV> * rate2 = INT_MAX ; //<S2SV> * distortion = INT64_MAX ; //<S2SV> restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; //<S2SV> return INT64_MAX ; //<S2SV> } //<S2SV> * rate2 += * rate_y ; //<S2SV> * distortion += * distortion_y ; //<S2SV> rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; //<S2SV> rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ; //<S2SV> super_block_uvrd ( cpi , x , rate_uv , distortion_uv , & skippable_uv , & sseuv , //<S2SV> bsize , ref_best_rd - rdcosty ) ; //<S2SV> if ( * rate_uv == INT_MAX ) { //<S2SV> * rate2 = INT_MAX ; //<S2SV> * distortion = INT64_MAX ; //<S2SV> restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; //<S2SV> return INT64_MAX ; //<S2SV> } //<S2SV> * psse += sseuv ; //<S2SV> * rate2 += * rate_uv ; //<S2SV> * distortion += * distortion_uv ; //<S2SV> * skippable = skippable_y && skippable_uv ; //<S2SV> } //<S2SV> restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; //<S2SV> return this_rd ; //<S2SV> } //<S2SV> 