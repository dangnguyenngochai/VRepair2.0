static vpx_codec_err_t vp8_decode ( vpx_codec_alg_priv_t * ctx , //<S2SV> const uint8_t * data , //<S2SV> unsigned int data_sz , //<S2SV> void * user_priv , //<S2SV> long deadline ) //<S2SV> { //<S2SV> vpx_codec_err_t res = VPX_CODEC_OK ; //<S2SV> unsigned int resolution_change = 0 ; //<S2SV> unsigned int w , h ; //<S2SV> if ( update_fragments ( ctx , data , data_sz , & res ) <= 0 ) //<S2SV> return res ; //<S2SV> w = ctx -> si . w ; //<S2SV> h = ctx -> si . h ; //<S2SV> res = vp8_peek_si_internal ( ctx -> fragments . ptrs [ 0 ] , ctx -> fragments . sizes [ 0 ] , //<S2SV> & ctx -> si , ctx -> decrypt_cb , ctx -> decrypt_state ) ; //<S2SV> if ( ( res == VPX_CODEC_UNSUP_BITSTREAM ) && ! ctx -> si . is_kf ) //<S2SV> { //<S2SV> res = VPX_CODEC_OK ; //<S2SV> } //<S2SV> if ( ! ctx -> decoder_init && ! ctx -> si . is_kf ) //<S2SV> res = VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( ( ctx -> si . h != h ) || ( ctx -> si . w != w ) ) //<S2SV> resolution_change = 1 ; //<S2SV> if ( ! res && ctx -> defer_alloc ) //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 1 ; ! res && i < NELEMENTS ( ctx -> mmaps ) ; i ++ ) //<S2SV> { //<S2SV> vpx_codec_dec_cfg_t cfg ; //<S2SV> cfg . w = ctx -> si . w ; //<S2SV> cfg . h = ctx -> si . h ; //<S2SV> ctx -> mmaps [ i ] . id = vp8_mem_req_segs [ i ] . id ; //<S2SV> ctx -> mmaps [ i ] . sz = vp8_mem_req_segs [ i ] . sz ; //<S2SV> ctx -> mmaps [ i ] . align = vp8_mem_req_segs [ i ] . align ; //<S2SV> ctx -> mmaps [ i ] . flags = vp8_mem_req_segs [ i ] . flags ; //<S2SV> if ( ! ctx -> mmaps [ i ] . sz ) //<S2SV> ctx -> mmaps [ i ] . sz = vp8_mem_req_segs [ i ] . calc_sz ( & cfg , //<S2SV> ctx -> base . init_flags ) ; //<S2SV> res = vpx_mmap_alloc ( & ctx -> mmaps [ i ] ) ; //<S2SV> } //<S2SV> if ( ! res ) //<S2SV> vp8_finalize_mmaps ( ctx ) ; //<S2SV> ctx -> defer_alloc = 0 ; //<S2SV> } //<S2SV> if ( ! res && ! ctx -> decoder_init ) //<S2SV> { //<S2SV> res = vpx_validate_mmaps ( & ctx -> si , ctx -> mmaps , //<S2SV> vp8_mem_req_segs , NELEMENTS ( vp8_mem_req_segs ) , //<S2SV> ctx -> base . init_flags ) ; //<S2SV> if ( ! res ) //<S2SV> { //<S2SV> VP8D_CONFIG oxcf ; //<S2SV> oxcf . Width = ctx -> si . w ; //<S2SV> oxcf . Height = ctx -> si . h ; //<S2SV> oxcf . Version = 9 ; //<S2SV> oxcf . postprocess = 0 ; //<S2SV> oxcf . max_threads = ctx -> cfg . threads ; //<S2SV> oxcf . error_concealment = //<S2SV> ( ctx -> base . init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) ; //<S2SV> if ( ! ctx -> postproc_cfg_set //<S2SV> && ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) ) //<S2SV> { //<S2SV> ctx -> postproc_cfg . post_proc_flag = //<S2SV> VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE ; //<S2SV> ctx -> postproc_cfg . deblocking_level = 4 ; //<S2SV> ctx -> postproc_cfg . noise_level = 0 ; //<S2SV> } //<S2SV> res = vp8_create_decoder_instances ( & ctx -> yv12_frame_buffers , & oxcf ) ; //<S2SV> ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_cb = ctx -> decrypt_cb ; //<S2SV> ctx -> yv12_frame_buffers . pbi [ 0 ] -> decrypt_state = ctx -> decrypt_state ; //<S2SV> } //<S2SV> ctx -> decoder_init = 1 ; //<S2SV> } //<S2SV> if ( ! res ) //<S2SV> { //<S2SV> VP8D_COMP * pbi = ctx -> yv12_frame_buffers . pbi [ 0 ] ; //<S2SV> if ( resolution_change ) //<S2SV> { //<S2SV> VP8_COMMON * const pc = & pbi -> common ; //<S2SV> MACROBLOCKD * const xd = & pbi -> mb ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> int i ; //<S2SV> # endif //<S2SV> pc -> Width = ctx -> si . w ; //<S2SV> pc -> Height = ctx -> si . h ; //<S2SV> { //<S2SV> int prev_mb_rows = pc -> mb_rows ; //<S2SV> if ( setjmp ( pbi -> common . error . jmp ) ) //<S2SV> { //<S2SV> pbi -> common . error . setjmp = 0 ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> pbi -> common . error . setjmp = 1 ; //<S2SV> if ( pc -> Width <= 0 ) //<S2SV> { //<S2SV> pc -> Width = w ; //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Invalid<S2SV_blank>frame<S2SV_blank>width" ) ; //<S2SV> } //<S2SV> if ( pc -> Height <= 0 ) //<S2SV> { //<S2SV> pc -> Height = h ; //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Invalid<S2SV_blank>frame<S2SV_blank>height" ) ; //<S2SV> } //<S2SV> if ( vp8_alloc_frame_buffers ( pc , pc -> Width , pc -> Height ) ) //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame<S2SV_blank>buffers" ) ; //<S2SV> xd -> pre = pc -> yv12_fb [ pc -> lst_fb_idx ] ; //<S2SV> xd -> dst = pc -> yv12_fb [ pc -> new_fb_idx ] ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) //<S2SV> { //<S2SV> pbi -> mb_row_di [ i ] . mbd . dst = pc -> yv12_fb [ pc -> new_fb_idx ] ; //<S2SV> vp8_build_block_doffsets ( & pbi -> mb_row_di [ i ] . mbd ) ; //<S2SV> } //<S2SV> # endif //<S2SV> vp8_build_block_doffsets ( & pbi -> mb ) ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> if ( pbi -> ec_enabled ) //<S2SV> { //<S2SV> pc -> prev_mip = vpx_calloc ( //<S2SV> ( pc -> mb_cols + 1 ) * ( pc -> mb_rows + 1 ) , //<S2SV> sizeof ( MODE_INFO ) ) ; //<S2SV> if ( ! pc -> prev_mip ) //<S2SV> { //<S2SV> vp8_de_alloc_frame_buffers ( pc ) ; //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate" //<S2SV> "last<S2SV_blank>frame<S2SV_blank>MODE_INFO<S2SV_blank>array" ) ; //<S2SV> } //<S2SV> pc -> prev_mi = pc -> prev_mip + pc -> mode_info_stride + 1 ; //<S2SV> if ( vp8_alloc_overlap_lists ( pbi ) ) //<S2SV> vpx_internal_error ( & pc -> error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>overlap<S2SV_blank>lists<S2SV_blank>" //<S2SV> "for<S2SV_blank>error<S2SV_blank>concealment" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( pbi -> b_multithreaded_rd ) //<S2SV> vp8mt_alloc_temp_buffers ( pbi , pc -> Width , prev_mb_rows ) ; //<S2SV> # else //<S2SV> ( void ) prev_mb_rows ; //<S2SV> # endif //<S2SV> } //<S2SV> pbi -> common . error . setjmp = 0 ; //<S2SV> pbi -> common . fb_idx_ref_cnt [ 0 ] = 0 ; //<S2SV> } //<S2SV> pbi -> fragments = ctx -> fragments ; //<S2SV> ctx -> user_priv = user_priv ; //<S2SV> if ( vp8dx_receive_compressed_data ( pbi , data_sz , data , deadline ) ) //<S2SV> { //<S2SV> res = update_error_state ( ctx , & pbi -> common . error ) ; //<S2SV> } //<S2SV> ctx -> fragments . count = 0 ; //<S2SV> } //<S2SV> return res ; //<S2SV> } //<S2SV> 