static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , //<S2SV> TX_SIZE tx_size , void * arg ) { //<S2SV> struct tokenize_b_args * const args = arg ; //<S2SV> VP9_COMP * cpi = args -> cpi ; //<S2SV> MACROBLOCKD * xd = args -> xd ; //<S2SV> TOKENEXTRA * * tp = args -> tp ; //<S2SV> uint8_t token_cache [ 32 * 32 ] ; //<S2SV> struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ; //<S2SV> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> int pt ; //<S2SV> int c ; //<S2SV> TOKENEXTRA * t = * tp ; //<S2SV> int eob = p -> eobs [ block ] ; //<S2SV> const PLANE_TYPE type = pd -> plane_type ; //<S2SV> const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; //<S2SV> const int segment_id = mbmi -> segment_id ; //<S2SV> const int16_t * scan , * nb ; //<S2SV> const scan_order * so ; //<S2SV> const int ref = is_inter_block ( mbmi ) ; //<S2SV> unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = //<S2SV> cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ; //<S2SV> vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = //<S2SV> cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ; //<S2SV> unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = //<S2SV> cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ; //<S2SV> const uint8_t * const band = get_band_translate ( tx_size ) ; //<S2SV> const int seg_eob = get_tx_eob ( & cpi -> common . seg , segment_id , tx_size ) ; //<S2SV> int aoff , loff ; //<S2SV> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & aoff , & loff ) ; //<S2SV> pt = get_entropy_context ( tx_size , pd -> above_context + aoff , //<S2SV> pd -> left_context + loff ) ; //<S2SV> so = get_scan ( xd , tx_size , type , block ) ; //<S2SV> scan = so -> scan ; //<S2SV> nb = so -> neighbors ; //<S2SV> c = 0 ; //<S2SV> while ( c < eob ) { //<S2SV> int v = 0 ; //<S2SV> int skip_eob = 0 ; //<S2SV> v = qcoeff [ scan [ c ] ] ; //<S2SV> while ( ! v ) { //<S2SV> add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , ZERO_TOKEN , skip_eob , //<S2SV> counts [ band [ c ] ] [ pt ] ) ; //<S2SV> eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; //<S2SV> skip_eob = 1 ; //<S2SV> token_cache [ scan [ c ] ] = 0 ; //<S2SV> ++ c ; //<S2SV> pt = get_coef_context ( nb , token_cache , c ) ; //<S2SV> v = qcoeff [ scan [ c ] ] ; //<S2SV> } //<S2SV> add_token ( & t , coef_probs [ band [ c ] ] [ pt ] , //<S2SV> vp9_dct_value_tokens_ptr [ v ] . extra , //<S2SV> ( uint8_t ) vp9_dct_value_tokens_ptr [ v ] . token , //<S2SV> ( uint8_t ) skip_eob , //<S2SV> counts [ band [ c ] ] [ pt ] ) ; //<S2SV> eob_branch [ band [ c ] ] [ pt ] += ! skip_eob ; //<S2SV> token_cache [ scan [ c ] ] = //<S2SV> vp9_pt_energy_class [ vp9_dct_value_tokens_ptr [ v ] . token ] ; //<S2SV> ++ c ; //<S2SV> pt = get_coef_context ( nb , token_cache , c ) ; //<S2SV> } //<S2SV> if ( c < seg_eob ) { //<S2SV> add_token_no_extra ( & t , coef_probs [ band [ c ] ] [ pt ] , EOB_TOKEN , 0 , //<S2SV> counts [ band [ c ] ] [ pt ] ) ; //<S2SV> ++ eob_branch [ band [ c ] ] [ pt ] ; //<S2SV> } //<S2SV> * tp = t ; //<S2SV> vp9_set_contexts ( xd , pd , plane_bsize , tx_size , c > 0 , aoff , loff ) ; //<S2SV> } //<S2SV> 