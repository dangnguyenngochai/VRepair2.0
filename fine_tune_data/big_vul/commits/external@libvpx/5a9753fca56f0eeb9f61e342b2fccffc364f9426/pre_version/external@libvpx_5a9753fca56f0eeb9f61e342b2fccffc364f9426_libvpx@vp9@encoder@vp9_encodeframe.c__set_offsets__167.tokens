static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> int mi_row , int mi_col , BLOCK_SIZE bsize ) { //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi ; //<S2SV> const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> const int mb_row = mi_row >> 1 ; //<S2SV> const int mb_col = mi_col >> 1 ; //<S2SV> const int idx_map = mb_row * cm -> mb_cols + mb_col ; //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> set_skip_context ( xd , mi_row , mi_col ) ; //<S2SV> x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ; //<S2SV> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; //<S2SV> set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; //<S2SV> mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ; //<S2SV> x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; //<S2SV> x -> mv_col_min = - ( ( ( mi_col + mi_width ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; //<S2SV> x -> mv_row_max = ( cm -> mi_rows - mi_row ) * MI_SIZE + VP9_INTERP_EXTEND ; //<S2SV> x -> mv_col_max = ( cm -> mi_cols - mi_col ) * MI_SIZE + VP9_INTERP_EXTEND ; //<S2SV> assert ( ! ( mi_col & ( mi_width - 1 ) ) && ! ( mi_row & ( mi_height - 1 ) ) ) ; //<S2SV> set_mi_row_col ( xd , tile , mi_row , mi_height , mi_col , mi_width , //<S2SV> cm -> mi_rows , cm -> mi_cols ) ; //<S2SV> vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; //<S2SV> x -> rddiv = cpi -> RDDIV ; //<S2SV> x -> rdmult = cpi -> RDMULT ; //<S2SV> if ( seg -> enabled ) { //<S2SV> if ( cpi -> oxcf . aq_mode != VARIANCE_AQ ) { //<S2SV> const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map //<S2SV> : cm -> last_frame_seg_map ; //<S2SV> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; //<S2SV> } //<S2SV> vp9_init_plane_quantizers ( cpi , x ) ; //<S2SV> x -> encode_breakout = cpi -> segment_encode_breakout [ mbmi -> segment_id ] ; //<S2SV> } else { //<S2SV> mbmi -> segment_id = 0 ; //<S2SV> x -> encode_breakout = cpi -> encode_breakout ; //<S2SV> } //<S2SV> } //<S2SV> 