static void encode_nonrd_sb_row ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> int mi_row , TOKENEXTRA * * tp ) { //<S2SV> VP9_COMMON * cm = & cpi -> common ; //<S2SV> MACROBLOCKD * xd = & cpi -> mb . e_mbd ; //<S2SV> int mi_col ; //<S2SV> vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; //<S2SV> vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; //<S2SV> for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; //<S2SV> mi_col += MI_BLOCK_SIZE ) { //<S2SV> int dummy_rate = 0 ; //<S2SV> int64_t dummy_dist = 0 ; //<S2SV> const int idx_str = cm -> mi_stride * mi_row + mi_col ; //<S2SV> MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; //<S2SV> MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; //<S2SV> BLOCK_SIZE bsize ; //<S2SV> cpi -> mb . source_variance = UINT_MAX ; //<S2SV> vp9_zero ( cpi -> mb . pred_mv ) ; //<S2SV> switch ( cpi -> sf . partition_search_type ) { //<S2SV> case VAR_BASED_PARTITION : //<S2SV> choose_partitioning ( cpi , tile , mi_row , mi_col ) ; //<S2SV> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> 1 , & dummy_rate , & dummy_dist ) ; //<S2SV> break ; //<S2SV> case SOURCE_VAR_BASED_PARTITION : //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> set_source_var_based_partition ( cpi , tile , mi_8x8 , mi_row , mi_col ) ; //<S2SV> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> 1 , & dummy_rate , & dummy_dist ) ; //<S2SV> break ; //<S2SV> case VAR_BASED_FIXED_PARTITION : //<S2SV> case FIXED_PARTITION : //<S2SV> bsize = cpi -> sf . partition_search_type == FIXED_PARTITION ? //<S2SV> cpi -> sf . always_this_block_size : //<S2SV> get_nonrd_var_based_fixed_partition ( cpi , mi_row , mi_col ) ; //<S2SV> set_fixed_partitioning ( cpi , tile , mi_8x8 , mi_row , mi_col , bsize ) ; //<S2SV> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> 1 , & dummy_rate , & dummy_dist ) ; //<S2SV> break ; //<S2SV> case REFERENCE_PARTITION : //<S2SV> if ( cpi -> sf . partition_check || sb_has_motion ( cm , prev_mi_8x8 ) ) { //<S2SV> nonrd_pick_partition ( cpi , tile , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> & dummy_rate , & dummy_dist , 1 , INT64_MAX ) ; //<S2SV> } else { //<S2SV> copy_partitioning ( cm , mi_8x8 , prev_mi_8x8 ) ; //<S2SV> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , 1 , & dummy_rate , & dummy_dist ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 