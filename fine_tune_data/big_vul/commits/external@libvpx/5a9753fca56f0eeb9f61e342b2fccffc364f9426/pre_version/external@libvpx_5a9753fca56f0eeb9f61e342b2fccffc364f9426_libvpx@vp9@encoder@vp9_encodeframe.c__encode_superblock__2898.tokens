static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled , //<S2SV> int mi_row , int mi_col , BLOCK_SIZE bsize ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MODE_INFO * * mi_8x8 = xd -> mi ; //<S2SV> MODE_INFO * mi = mi_8x8 [ 0 ] ; //<S2SV> MB_MODE_INFO * mbmi = & mi -> mbmi ; //<S2SV> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; //<S2SV> unsigned int segment_id = mbmi -> segment_id ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 && //<S2SV> cpi -> oxcf . aq_mode != COMPLEXITY_AQ && //<S2SV> cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && //<S2SV> cpi -> sf . allow_skip_recode ; //<S2SV> x -> skip_optimize = ctx -> is_coded ; //<S2SV> ctx -> is_coded = 1 ; //<S2SV> x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; //<S2SV> x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && //<S2SV> x -> q_index < QIDX_SKIP_THRESH ) ; //<S2SV> if ( x -> skip_encode ) //<S2SV> return ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) { //<S2SV> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { //<S2SV> adjust_act_zbin ( cpi , x ) ; //<S2SV> vp9_update_zbin_extra ( cpi , x ) ; //<S2SV> } //<S2SV> } else { //<S2SV> set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; //<S2SV> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { //<S2SV> adjust_act_zbin ( cpi , x ) ; //<S2SV> } //<S2SV> cpi -> zbin_mode_boost = get_zbin_mode_boost ( mbmi , //<S2SV> cpi -> zbin_mode_boost_enabled ) ; //<S2SV> vp9_update_zbin_extra ( cpi , x ) ; //<S2SV> } //<S2SV> if ( ! is_inter_block ( mbmi ) ) { //<S2SV> int plane ; //<S2SV> mbmi -> skip = 1 ; //<S2SV> for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) //<S2SV> vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; //<S2SV> if ( output_enabled ) //<S2SV> sum_intra_stats ( & cm -> counts , mi ) ; //<S2SV> vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> } else { //<S2SV> int ref ; //<S2SV> const int is_compound = has_second_ref ( mbmi ) ; //<S2SV> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { //<S2SV> YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , //<S2SV> mbmi -> ref_frame [ ref ] ) ; //<S2SV> vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col , //<S2SV> & xd -> block_refs [ ref ] -> sf ) ; //<S2SV> } //<S2SV> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> if ( ! x -> skip ) { //<S2SV> mbmi -> skip = 1 ; //<S2SV> vp9_encode_sb ( x , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> vp9_tokenize_sb ( cpi , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> } else { //<S2SV> mbmi -> skip = 1 ; //<S2SV> if ( output_enabled ) //<S2SV> cm -> counts . skip [ vp9_get_skip_context ( xd ) ] [ 1 ] ++ ; //<S2SV> reset_skip_context ( xd , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( output_enabled ) { //<S2SV> if ( cm -> tx_mode == TX_MODE_SELECT && //<S2SV> mbmi -> sb_type >= BLOCK_8X8 && //<S2SV> ! ( is_inter_block ( mbmi ) && //<S2SV> ( mbmi -> skip || //<S2SV> vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_SKIP ) ) ) ) { //<S2SV> ++ get_tx_counts ( max_txsize_lookup [ bsize ] , vp9_get_tx_size_context ( xd ) , //<S2SV> & cm -> counts . tx ) [ mbmi -> tx_size ] ; //<S2SV> } else { //<S2SV> int x , y ; //<S2SV> TX_SIZE tx_size ; //<S2SV> if ( is_inter_block ( & mi -> mbmi ) ) { //<S2SV> tx_size = MIN ( tx_mode_to_biggest_tx_size [ cm -> tx_mode ] , //<S2SV> max_txsize_lookup [ bsize ] ) ; //<S2SV> } else { //<S2SV> tx_size = ( bsize >= BLOCK_8X8 ) ? mbmi -> tx_size : TX_4X4 ; //<S2SV> } //<S2SV> for ( y = 0 ; y < mi_height ; y ++ ) //<S2SV> for ( x = 0 ; x < mi_width ; x ++ ) //<S2SV> if ( mi_col + x < cm -> mi_cols && mi_row + y < cm -> mi_rows ) //<S2SV> mi_8x8 [ mis * y + x ] -> mbmi . tx_size = tx_size ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 