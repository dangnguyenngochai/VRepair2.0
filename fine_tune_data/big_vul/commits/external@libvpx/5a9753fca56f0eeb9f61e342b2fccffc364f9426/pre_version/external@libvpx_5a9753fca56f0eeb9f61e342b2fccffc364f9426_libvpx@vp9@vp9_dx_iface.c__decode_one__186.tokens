static vpx_codec_err_t decode_one ( vpx_codec_alg_priv_t * ctx , //<S2SV> const uint8_t * * data , unsigned int data_sz , //<S2SV> void * user_priv , int64_t deadline ) { //<S2SV> YV12_BUFFER_CONFIG sd = { 0 } ; //<S2SV> int64_t time_stamp = 0 , time_end_stamp = 0 ; //<S2SV> vp9_ppflags_t flags = { 0 } ; //<S2SV> VP9_COMMON * cm = NULL ; //<S2SV> ctx -> img_avail = 0 ; //<S2SV> if ( ! ctx -> si . h ) { //<S2SV> const vpx_codec_err_t res = //<S2SV> ctx -> base . iface -> dec . peek_si ( * data , data_sz , & ctx -> si ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> return res ; //<S2SV> } //<S2SV> if ( ! ctx -> decoder_init ) { //<S2SV> init_decoder ( ctx ) ; //<S2SV> if ( ctx -> pbi == NULL ) //<S2SV> return VPX_CODEC_ERROR ; //<S2SV> ctx -> decoder_init = 1 ; //<S2SV> } //<S2SV> cm = & ctx -> pbi -> common ; //<S2SV> if ( vp9_receive_compressed_data ( ctx -> pbi , data_sz , data , deadline ) ) //<S2SV> return update_error_state ( ctx , & cm -> error ) ; //<S2SV> if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) //<S2SV> set_ppflags ( ctx , & flags ) ; //<S2SV> if ( vp9_get_raw_frame ( ctx -> pbi , & sd , & time_stamp , & time_end_stamp , & flags ) ) //<S2SV> return update_error_state ( ctx , & cm -> error ) ; //<S2SV> yuvconfig2image ( & ctx -> img , & sd , user_priv ) ; //<S2SV> ctx -> img . fb_priv = cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ; //<S2SV> ctx -> img_avail = 1 ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 