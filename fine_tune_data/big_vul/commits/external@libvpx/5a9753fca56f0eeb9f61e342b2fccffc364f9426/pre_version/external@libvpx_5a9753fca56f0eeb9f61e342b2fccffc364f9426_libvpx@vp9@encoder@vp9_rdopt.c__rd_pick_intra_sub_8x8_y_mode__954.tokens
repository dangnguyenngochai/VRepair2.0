static int64_t rd_pick_intra_sub_8x8_y_mode ( VP9_COMP * cpi , MACROBLOCK * mb , //<S2SV> int * rate , int * rate_y , //<S2SV> int64_t * distortion , //<S2SV> int64_t best_rd ) { //<S2SV> int i , j ; //<S2SV> const MACROBLOCKD * const xd = & mb -> e_mbd ; //<S2SV> MODE_INFO * const mic = xd -> mi [ 0 ] ; //<S2SV> const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ; //<S2SV> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; //<S2SV> const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; //<S2SV> const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; //<S2SV> const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; //<S2SV> int idx , idy ; //<S2SV> int cost = 0 ; //<S2SV> int64_t total_distortion = 0 ; //<S2SV> int tot_rate_y = 0 ; //<S2SV> int64_t total_rd = 0 ; //<S2SV> ENTROPY_CONTEXT t_above [ 4 ] , t_left [ 4 ] ; //<S2SV> const int * bmode_costs = mb -> mbmode_cost ; //<S2SV> vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ; //<S2SV> vpx_memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ; //<S2SV> for ( idy = 0 ; idy < 2 ; idy += num_4x4_blocks_high ) { //<S2SV> for ( idx = 0 ; idx < 2 ; idx += num_4x4_blocks_wide ) { //<S2SV> MB_PREDICTION_MODE best_mode = DC_PRED ; //<S2SV> int r = INT_MAX , ry = INT_MAX ; //<S2SV> int64_t d = INT64_MAX , this_rd = INT64_MAX ; //<S2SV> i = idy * 2 + idx ; //<S2SV> if ( cpi -> common . frame_type == KEY_FRAME ) { //<S2SV> const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , i ) ; //<S2SV> const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , i ) ; //<S2SV> bmode_costs = mb -> y_mode_costs [ A ] [ L ] ; //<S2SV> } //<S2SV> this_rd = rd_pick_intra4x4block ( cpi , mb , i , & best_mode , bmode_costs , //<S2SV> t_above + idx , t_left + idy , & r , & ry , & d , //<S2SV> bsize , best_rd - total_rd ) ; //<S2SV> if ( this_rd >= best_rd - total_rd ) //<S2SV> return INT64_MAX ; //<S2SV> total_rd += this_rd ; //<S2SV> cost += r ; //<S2SV> total_distortion += d ; //<S2SV> tot_rate_y += ry ; //<S2SV> mic -> bmi [ i ] . as_mode = best_mode ; //<S2SV> for ( j = 1 ; j < num_4x4_blocks_high ; ++ j ) //<S2SV> mic -> bmi [ i + j * 2 ] . as_mode = best_mode ; //<S2SV> for ( j = 1 ; j < num_4x4_blocks_wide ; ++ j ) //<S2SV> mic -> bmi [ i + j ] . as_mode = best_mode ; //<S2SV> if ( total_rd >= best_rd ) //<S2SV> return INT64_MAX ; //<S2SV> } //<S2SV> } //<S2SV> * rate = cost ; //<S2SV> * rate_y = tot_rate_y ; //<S2SV> * distortion = total_distortion ; //<S2SV> mic -> mbmi . mode = mic -> bmi [ 3 ] . as_mode ; //<S2SV> return RDCOST ( mb -> rdmult , mb -> rddiv , cost , total_distortion ) ; //<S2SV> } //<S2SV> 