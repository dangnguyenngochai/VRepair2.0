void vp8_denoiser_denoise_mb ( VP8_DENOISER * denoiser , //<S2SV> MACROBLOCK * x , //<S2SV> unsigned int best_sse , //<S2SV> unsigned int zero_mv_sse , //<S2SV> int recon_yoffset , //<S2SV> int recon_uvoffset ) //<S2SV> { //<S2SV> int mv_row ; //<S2SV> int mv_col ; //<S2SV> unsigned int motion_magnitude2 ; //<S2SV> MV_REFERENCE_FRAME frame = x -> best_reference_frame ; //<S2SV> MV_REFERENCE_FRAME zero_frame = x -> best_zeromv_reference_frame ; //<S2SV> enum vp8_denoiser_decision decision = FILTER_BLOCK ; //<S2SV> if ( zero_frame ) //<S2SV> { //<S2SV> YV12_BUFFER_CONFIG * src = & denoiser -> yv12_running_avg [ frame ] ; //<S2SV> YV12_BUFFER_CONFIG * dst = & denoiser -> yv12_mc_running_avg ; //<S2SV> YV12_BUFFER_CONFIG saved_pre , saved_dst ; //<S2SV> MB_MODE_INFO saved_mbmi ; //<S2SV> MACROBLOCKD * filter_xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi = & filter_xd -> mode_info_context -> mbmi ; //<S2SV> int sse_diff = zero_mv_sse - best_sse ; //<S2SV> saved_mbmi = * mbmi ; //<S2SV> mbmi -> ref_frame = x -> best_reference_frame ; //<S2SV> mbmi -> mode = x -> best_sse_inter_mode ; //<S2SV> mbmi -> mv = x -> best_sse_mv ; //<S2SV> mbmi -> need_to_clamp_mvs = x -> need_to_clamp_best_mvs ; //<S2SV> mv_col = x -> best_sse_mv . as_mv . col ; //<S2SV> mv_row = x -> best_sse_mv . as_mv . row ; //<S2SV> if ( frame == INTRA_FRAME || //<S2SV> ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) //<S2SV> <= NOISE_MOTION_THRESHOLD && //<S2SV> sse_diff < ( int ) SSE_DIFF_THRESHOLD ) ) //<S2SV> { //<S2SV> mbmi -> ref_frame = //<S2SV> x -> best_zeromv_reference_frame ; //<S2SV> src = & denoiser -> yv12_running_avg [ zero_frame ] ; //<S2SV> mbmi -> mode = ZEROMV ; //<S2SV> mbmi -> mv . as_int = 0 ; //<S2SV> x -> best_sse_inter_mode = ZEROMV ; //<S2SV> x -> best_sse_mv . as_int = 0 ; //<S2SV> best_sse = zero_mv_sse ; //<S2SV> } //<S2SV> saved_pre = filter_xd -> pre ; //<S2SV> saved_dst = filter_xd -> dst ; //<S2SV> filter_xd -> pre . y_buffer = src -> y_buffer + recon_yoffset ; //<S2SV> filter_xd -> pre . u_buffer = src -> u_buffer + recon_uvoffset ; //<S2SV> filter_xd -> pre . v_buffer = src -> v_buffer + recon_uvoffset ; //<S2SV> filter_xd -> dst . y_buffer = dst -> y_buffer + recon_yoffset ; //<S2SV> filter_xd -> dst . u_buffer = dst -> u_buffer + recon_uvoffset ; //<S2SV> filter_xd -> dst . v_buffer = dst -> v_buffer + recon_uvoffset ; //<S2SV> if ( ! x -> skip ) //<S2SV> { //<S2SV> vp8_build_inter_predictors_mb ( filter_xd ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> vp8_build_inter16x16_predictors_mb ( filter_xd , //<S2SV> filter_xd -> dst . y_buffer , //<S2SV> filter_xd -> dst . u_buffer , //<S2SV> filter_xd -> dst . v_buffer , //<S2SV> filter_xd -> dst . y_stride , //<S2SV> filter_xd -> dst . uv_stride ) ; //<S2SV> } //<S2SV> filter_xd -> pre = saved_pre ; //<S2SV> filter_xd -> dst = saved_dst ; //<S2SV> * mbmi = saved_mbmi ; //<S2SV> } //<S2SV> mv_row = x -> best_sse_mv . as_mv . row ; //<S2SV> mv_col = x -> best_sse_mv . as_mv . col ; //<S2SV> motion_magnitude2 = mv_row * mv_row + mv_col * mv_col ; //<S2SV> if ( best_sse > SSE_THRESHOLD || motion_magnitude2 //<S2SV> > 8 * NOISE_MOTION_THRESHOLD ) //<S2SV> { //<S2SV> decision = COPY_BLOCK ; //<S2SV> } //<S2SV> if ( decision == FILTER_BLOCK ) //<S2SV> { //<S2SV> decision = vp8_denoiser_filter ( & denoiser -> yv12_mc_running_avg , //<S2SV> & denoiser -> yv12_running_avg [ INTRA_FRAME ] , //<S2SV> x , //<S2SV> motion_magnitude2 , //<S2SV> recon_yoffset , recon_uvoffset ) ; //<S2SV> } //<S2SV> if ( decision == COPY_BLOCK ) //<S2SV> { //<S2SV> vp8_copy_mem16x16 ( //<S2SV> x -> thismb , 16 , //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ) ; //<S2SV> } //<S2SV> } //<S2SV> 