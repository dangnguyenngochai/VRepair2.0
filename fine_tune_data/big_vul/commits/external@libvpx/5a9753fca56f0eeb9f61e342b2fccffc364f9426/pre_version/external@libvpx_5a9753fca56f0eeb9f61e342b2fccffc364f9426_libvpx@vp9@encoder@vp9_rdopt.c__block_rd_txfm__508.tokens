static void block_rd_txfm ( int plane , int block , BLOCK_SIZE plane_bsize , //<S2SV> TX_SIZE tx_size , void * arg ) { //<S2SV> struct rdcost_block_args * args = arg ; //<S2SV> MACROBLOCK * const x = args -> x ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> int64_t rd1 , rd2 , rd ; //<S2SV> if ( args -> skip ) //<S2SV> return ; //<S2SV> if ( ! is_inter_block ( mbmi ) ) //<S2SV> vp9_encode_block_intra ( x , plane , block , plane_bsize , tx_size , & mbmi -> skip ) ; //<S2SV> else //<S2SV> vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; //<S2SV> dist_block ( plane , block , tx_size , args ) ; //<S2SV> rate_block ( plane , block , plane_bsize , tx_size , args ) ; //<S2SV> rd1 = RDCOST ( x -> rdmult , x -> rddiv , args -> rate , args -> dist ) ; //<S2SV> rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , args -> sse ) ; //<S2SV> rd = MIN ( rd1 , rd2 ) ; //<S2SV> if ( plane == 0 ) //<S2SV> x -> zcoeff_blk [ tx_size ] [ block ] = ! x -> plane [ plane ] . eobs [ block ] || //<S2SV> ( rd1 > rd2 && ! xd -> lossless ) ; //<S2SV> args -> this_rate += args -> rate ; //<S2SV> args -> this_dist += args -> dist ; //<S2SV> args -> this_sse += args -> sse ; //<S2SV> args -> this_rd += rd ; //<S2SV> if ( args -> this_rd > args -> best_rd ) { //<S2SV> args -> skip = 1 ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> 