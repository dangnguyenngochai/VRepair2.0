int64_t vp9_rd_pick_inter_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x , //<S2SV> const TileInfo * const tile , //<S2SV> int mi_row , int mi_col , //<S2SV> int * returnrate , //<S2SV> int64_t * returndistortion , //<S2SV> BLOCK_SIZE bsize , //<S2SV> PICK_MODE_CONTEXT * ctx , //<S2SV> int64_t best_rd_so_far ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> MB_PREDICTION_MODE this_mode ; //<S2SV> MV_REFERENCE_FRAME ref_frame , second_ref_frame ; //<S2SV> unsigned char segment_id = mbmi -> segment_id ; //<S2SV> int comp_pred , i ; //<S2SV> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; //<S2SV> struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; //<S2SV> int_mv single_newmv [ MAX_REF_FRAMES ] = { { 0 } } ; //<S2SV> static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , //<S2SV> VP9_ALT_FLAG } ; //<S2SV> int64_t best_rd = best_rd_so_far ; //<S2SV> int64_t best_tx_rd [ TX_MODES ] ; //<S2SV> int64_t best_tx_diff [ TX_MODES ] ; //<S2SV> int64_t best_pred_diff [ REFERENCE_MODES ] ; //<S2SV> int64_t best_pred_rd [ REFERENCE_MODES ] ; //<S2SV> int64_t best_filter_rd [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> MB_MODE_INFO best_mbmode = { 0 } ; //<S2SV> int mode_index , best_mode_index = 0 ; //<S2SV> unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ; //<S2SV> vp9_prob comp_mode_p ; //<S2SV> int64_t best_intra_rd = INT64_MAX ; //<S2SV> int64_t best_inter_rd = INT64_MAX ; //<S2SV> MB_PREDICTION_MODE best_intra_mode = DC_PRED ; //<S2SV> MV_REFERENCE_FRAME best_inter_ref_frame = LAST_FRAME ; //<S2SV> INTERP_FILTER tmp_best_filter = SWITCHABLE ; //<S2SV> int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ; //<S2SV> int64_t dist_uv [ TX_SIZES ] ; //<S2SV> int skip_uv [ TX_SIZES ] ; //<S2SV> MB_PREDICTION_MODE mode_uv [ TX_SIZES ] ; //<S2SV> int64_t mode_distortions [ MB_MODE_COUNT ] = { - 1 } ; //<S2SV> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; //<S2SV> const int bws = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; //<S2SV> const int bhs = num_8x8_blocks_high_lookup [ bsize ] / 2 ; //<S2SV> int best_skip2 = 0 ; //<S2SV> int mode_skip_mask = 0 ; //<S2SV> int mode_skip_start = cpi -> sf . mode_skip_start + 1 ; //<S2SV> const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ; //<S2SV> const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [ bsize ] ; //<S2SV> const int mode_search_skip_flags = cpi -> sf . mode_search_skip_flags ; //<S2SV> const int intra_y_mode_mask = //<S2SV> cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] ; //<S2SV> int disable_inter_mode_mask = cpi -> sf . disable_inter_mode_mask [ bsize ] ; //<S2SV> x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; //<S2SV> estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp , //<S2SV> & comp_mode_p ) ; //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) //<S2SV> best_pred_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < TX_MODES ; i ++ ) //<S2SV> best_tx_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) //<S2SV> best_filter_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < TX_SIZES ; i ++ ) //<S2SV> rate_uv_intra [ i ] = INT_MAX ; //<S2SV> for ( i = 0 ; i < MAX_REF_FRAMES ; ++ i ) //<S2SV> x -> pred_sse [ i ] = INT_MAX ; //<S2SV> * returnrate = INT_MAX ; //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { //<S2SV> x -> pred_mv_sad [ ref_frame ] = INT_MAX ; //<S2SV> if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) { //<S2SV> vp9_setup_buffer_inter ( cpi , x , tile , //<S2SV> ref_frame , bsize , mi_row , mi_col , //<S2SV> frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ; //<S2SV> } //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; //<S2SV> frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; //<S2SV> } //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { //<S2SV> static const int ref_frame_mask_all [ ] = { //<S2SV> 0x0 , 0x123291 , 0x25c444 , 0x39b722 //<S2SV> } ; //<S2SV> static const int ref_frame_mask_fixedmv [ ] = { //<S2SV> 0x0 , 0x121281 , 0x24c404 , 0x080102 //<S2SV> } ; //<S2SV> if ( ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) ) { //<S2SV> mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ; //<S2SV> } else if ( cpi -> sf . reference_masking ) { //<S2SV> for ( i = LAST_FRAME ; i <= ALTREF_FRAME ; ++ i ) { //<S2SV> if ( ( x -> pred_mv_sad [ ref_frame ] >> 2 ) > x -> pred_mv_sad [ i ] ) { //<S2SV> mode_skip_mask |= ref_frame_mask_fixedmv [ ref_frame ] ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && //<S2SV> vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { //<S2SV> mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ; //<S2SV> } //<S2SV> } //<S2SV> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) { //<S2SV> const int inter_non_zero_mode_mask = 0x1F7F7 ; //<S2SV> mode_skip_mask |= inter_non_zero_mode_mask ; //<S2SV> } //<S2SV> if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { //<S2SV> if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) { //<S2SV> const int altref_zero_mask = //<S2SV> ~ ( ( 1 << THR_NEARESTA ) | ( 1 << THR_NEARA ) | ( 1 << THR_ZEROA ) ) ; //<S2SV> mode_skip_mask |= altref_zero_mask ; //<S2SV> if ( frame_mv [ NEARMV ] [ ALTREF_FRAME ] . as_int != 0 ) //<S2SV> mode_skip_mask |= ( 1 << THR_NEARA ) ; //<S2SV> if ( frame_mv [ NEARESTMV ] [ ALTREF_FRAME ] . as_int != 0 ) //<S2SV> mode_skip_mask |= ( 1 << THR_NEARESTA ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( mi_row + bhs ) > cm -> mi_rows || ( mi_col + bws ) > cm -> mi_cols ) { //<S2SV> const int new_modes_mask = //<S2SV> ( 1 << THR_NEWMV ) | ( 1 << THR_NEWG ) | ( 1 << THR_NEWA ) | //<S2SV> ( 1 << THR_COMP_NEWLA ) | ( 1 << THR_COMP_NEWGA ) ; //<S2SV> mode_skip_mask |= new_modes_mask ; //<S2SV> } //<S2SV> if ( bsize > cpi -> sf . max_intra_bsize ) { //<S2SV> mode_skip_mask |= 0xFF30808 ; //<S2SV> } //<S2SV> if ( ! x -> in_active_map ) { //<S2SV> int mode_index ; //<S2SV> assert ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ; //<S2SV> if ( frame_mv [ NEARESTMV ] [ LAST_FRAME ] . as_int == 0 ) //<S2SV> mode_index = THR_NEARESTMV ; //<S2SV> else if ( frame_mv [ NEARMV ] [ LAST_FRAME ] . as_int == 0 ) //<S2SV> mode_index = THR_NEARMV ; //<S2SV> else //<S2SV> mode_index = THR_ZEROMV ; //<S2SV> mode_skip_mask = ~ ( 1 << mode_index ) ; //<S2SV> mode_skip_start = MAX_MODES ; //<S2SV> disable_inter_mode_mask = 0 ; //<S2SV> } //<S2SV> for ( mode_index = 0 ; mode_index < MAX_MODES ; ++ mode_index ) { //<S2SV> int mode_excluded = 0 ; //<S2SV> int64_t this_rd = INT64_MAX ; //<S2SV> int disable_skip = 0 ; //<S2SV> int compmode_cost = 0 ; //<S2SV> int rate2 = 0 , rate_y = 0 , rate_uv = 0 ; //<S2SV> int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ; //<S2SV> int skippable = 0 ; //<S2SV> int64_t tx_cache [ TX_MODES ] ; //<S2SV> int i ; //<S2SV> int this_skip2 = 0 ; //<S2SV> int64_t total_sse = INT64_MAX ; //<S2SV> int early_term = 0 ; //<S2SV> if ( mode_index == mode_skip_start ) { //<S2SV> switch ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] ) { //<S2SV> case INTRA_FRAME : //<S2SV> break ; //<S2SV> case LAST_FRAME : //<S2SV> mode_skip_mask |= LAST_FRAME_MODE_MASK ; //<S2SV> break ; //<S2SV> case GOLDEN_FRAME : //<S2SV> mode_skip_mask |= GOLDEN_FRAME_MODE_MASK ; //<S2SV> break ; //<S2SV> case ALTREF_FRAME : //<S2SV> mode_skip_mask |= ALT_REF_MODE_MASK ; //<S2SV> break ; //<S2SV> case NONE : //<S2SV> case MAX_REF_FRAMES : //<S2SV> assert ( 0 && "Invalid<S2SV_blank>Reference<S2SV_blank>frame" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( mode_skip_mask & ( 1 << mode_index ) ) //<S2SV> continue ; //<S2SV> if ( best_rd < ( ( int64_t ) rd_threshes [ mode_index ] * //<S2SV> rd_thresh_freq_fact [ mode_index ] >> 5 ) || //<S2SV> rd_threshes [ mode_index ] == INT_MAX ) //<S2SV> continue ; //<S2SV> this_mode = vp9_mode_order [ mode_index ] . mode ; //<S2SV> ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 0 ] ; //<S2SV> if ( ref_frame != INTRA_FRAME && //<S2SV> disable_inter_mode_mask & ( 1 << INTER_OFFSET ( this_mode ) ) ) //<S2SV> continue ; //<S2SV> second_ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 1 ] ; //<S2SV> comp_pred = second_ref_frame > INTRA_FRAME ; //<S2SV> if ( comp_pred ) { //<S2SV> if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && //<S2SV> vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) //<S2SV> continue ; //<S2SV> if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_REFMISMATCH ) && //<S2SV> ref_frame != best_inter_ref_frame && //<S2SV> second_ref_frame != best_inter_ref_frame ) //<S2SV> continue ; //<S2SV> mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ; //<S2SV> } else { //<S2SV> if ( ref_frame != INTRA_FRAME ) //<S2SV> mode_excluded = cm -> reference_mode == COMPOUND_REFERENCE ; //<S2SV> } //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> if ( ! ( intra_y_mode_mask & ( 1 << this_mode ) ) ) //<S2SV> continue ; //<S2SV> if ( this_mode != DC_PRED ) { //<S2SV> const unsigned int skip_intra_var_thresh = 64 ; //<S2SV> if ( ( mode_search_skip_flags & FLAG_SKIP_INTRA_LOWVAR ) && //<S2SV> x -> source_variance < skip_intra_var_thresh ) //<S2SV> continue ; //<S2SV> if ( ( mode_search_skip_flags & FLAG_SKIP_INTRA_BESTINTER ) && //<S2SV> ( this_mode >= D45_PRED && this_mode <= TM_PRED ) ) { //<S2SV> if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] > INTRA_FRAME ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { //<S2SV> if ( conditional_skipintra ( this_mode , best_intra_mode ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> if ( x -> in_active_map && //<S2SV> ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) //<S2SV> if ( ! check_best_zero_mv ( cpi , mbmi -> mode_context , frame_mv , //<S2SV> disable_inter_mode_mask , this_mode , ref_frame , //<S2SV> second_ref_frame ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> mbmi -> mode = this_mode ; //<S2SV> mbmi -> uv_mode = x -> in_active_map ? DC_PRED : this_mode ; //<S2SV> mbmi -> ref_frame [ 0 ] = ref_frame ; //<S2SV> mbmi -> ref_frame [ 1 ] = second_ref_frame ; //<S2SV> mbmi -> interp_filter = cm -> interp_filter == SWITCHABLE ? EIGHTTAP //<S2SV> : cm -> interp_filter ; //<S2SV> x -> skip = 0 ; //<S2SV> set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { //<S2SV> xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; //<S2SV> if ( comp_pred ) //<S2SV> xd -> plane [ i ] . pre [ 1 ] = yv12_mb [ second_ref_frame ] [ i ] ; //<S2SV> } //<S2SV> for ( i = 0 ; i < TX_MODES ; ++ i ) //<S2SV> tx_cache [ i ] = INT64_MAX ; //<S2SV> # ifdef MODE_TEST_HIT_STATS //<S2SV> cpi -> mode_test_hits [ bsize ] ++ ; //<S2SV> # endif //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> TX_SIZE uv_tx ; //<S2SV> intra_super_block_yrd ( cpi , x , & rate_y , & distortion_y , & skippable , NULL , //<S2SV> bsize , tx_cache , best_rd ) ; //<S2SV> if ( rate_y == INT_MAX ) //<S2SV> continue ; //<S2SV> uv_tx = get_uv_tx_size_impl ( mbmi -> tx_size , bsize ) ; //<S2SV> if ( rate_uv_intra [ uv_tx ] == INT_MAX ) { //<S2SV> choose_intra_uv_mode ( cpi , ctx , bsize , uv_tx , //<S2SV> & rate_uv_intra [ uv_tx ] , & rate_uv_tokenonly [ uv_tx ] , //<S2SV> & dist_uv [ uv_tx ] , & skip_uv [ uv_tx ] , & mode_uv [ uv_tx ] ) ; //<S2SV> } //<S2SV> rate_uv = rate_uv_tokenonly [ uv_tx ] ; //<S2SV> distortion_uv = dist_uv [ uv_tx ] ; //<S2SV> skippable = skippable && skip_uv [ uv_tx ] ; //<S2SV> mbmi -> uv_mode = mode_uv [ uv_tx ] ; //<S2SV> rate2 = rate_y + x -> mbmode_cost [ mbmi -> mode ] + rate_uv_intra [ uv_tx ] ; //<S2SV> if ( this_mode != DC_PRED && this_mode != TM_PRED ) //<S2SV> rate2 += intra_cost_penalty ; //<S2SV> distortion2 = distortion_y + distortion_uv ; //<S2SV> } else { //<S2SV> this_rd = handle_inter_mode ( cpi , x , tile , bsize , //<S2SV> tx_cache , //<S2SV> & rate2 , & distortion2 , & skippable , //<S2SV> & rate_y , & distortion_y , //<S2SV> & rate_uv , & distortion_uv , //<S2SV> & mode_excluded , & disable_skip , //<S2SV> & tmp_best_filter , frame_mv , //<S2SV> mi_row , mi_col , //<S2SV> single_newmv , & total_sse , best_rd ) ; //<S2SV> if ( this_rd == INT64_MAX ) //<S2SV> continue ; //<S2SV> compmode_cost = vp9_cost_bit ( comp_mode_p , comp_pred ) ; //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) //<S2SV> rate2 += compmode_cost ; //<S2SV> } //<S2SV> if ( comp_pred ) { //<S2SV> rate2 += ref_costs_comp [ ref_frame ] ; //<S2SV> } else { //<S2SV> rate2 += ref_costs_single [ ref_frame ] ; //<S2SV> } //<S2SV> if ( ! disable_skip ) { //<S2SV> const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id , //<S2SV> SEG_LVL_SKIP ) ; //<S2SV> if ( skippable ) { //<S2SV> rate2 -= ( rate_y + rate_uv ) ; //<S2SV> rate_uv = 0 ; //<S2SV> if ( mb_skip_allowed ) { //<S2SV> int prob_skip_cost ; //<S2SV> vp9_prob skip_prob = vp9_get_skip_prob ( cm , xd ) ; //<S2SV> if ( skip_prob ) { //<S2SV> prob_skip_cost = vp9_cost_bit ( skip_prob , 1 ) ; //<S2SV> rate2 += prob_skip_cost ; //<S2SV> } //<S2SV> } //<S2SV> } else if ( mb_skip_allowed && ref_frame != INTRA_FRAME && ! xd -> lossless ) { //<S2SV> if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } else { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> distortion2 = total_sse ; //<S2SV> assert ( total_sse >= 0 ) ; //<S2SV> rate2 -= ( rate_y + rate_uv ) ; //<S2SV> rate_y = 0 ; //<S2SV> rate_uv = 0 ; //<S2SV> this_skip2 = 1 ; //<S2SV> } //<S2SV> } else if ( mb_skip_allowed ) { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; //<S2SV> } //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> if ( this_rd < best_intra_rd ) { //<S2SV> best_intra_rd = this_rd ; //<S2SV> best_intra_mode = mbmi -> mode ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( ! comp_pred && ! mode_excluded && this_rd < best_inter_rd ) { //<S2SV> best_inter_rd = this_rd ; //<S2SV> best_inter_ref_frame = ref_frame ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! disable_skip && ref_frame == INTRA_FRAME ) { //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) //<S2SV> best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) //<S2SV> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ; //<S2SV> } //<S2SV> if ( mode_distortions [ this_mode ] == - 1 //<S2SV> || distortion2 < mode_distortions [ this_mode ] ) { //<S2SV> mode_distortions [ this_mode ] = distortion2 ; //<S2SV> } //<S2SV> if ( this_rd < best_rd || x -> skip ) { //<S2SV> int max_plane = MAX_MB_PLANE ; //<S2SV> if ( ! mode_excluded ) { //<S2SV> best_mode_index = mode_index ; //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> mbmi -> mv [ 0 ] . as_int = 0 ; //<S2SV> max_plane = 1 ; //<S2SV> } //<S2SV> * returnrate = rate2 ; //<S2SV> * returndistortion = distortion2 ; //<S2SV> best_rd = this_rd ; //<S2SV> best_mbmode = * mbmi ; //<S2SV> best_skip2 = this_skip2 ; //<S2SV> if ( ! x -> select_txfm_size ) //<S2SV> swap_block_ptr ( x , ctx , max_plane ) ; //<S2SV> vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] , //<S2SV> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; //<S2SV> if ( ( mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && //<S2SV> ( mode_index > MIN_EARLY_TERM_INDEX ) ) { //<S2SV> const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ; //<S2SV> int scale = 4 ; //<S2SV> if ( x -> source_variance < UINT_MAX ) { //<S2SV> const int var_adjust = ( x -> source_variance < 16 ) ; //<S2SV> scale -= var_adjust ; //<S2SV> } //<S2SV> if ( ref_frame > INTRA_FRAME && //<S2SV> distortion2 * scale < qstep * qstep ) { //<S2SV> early_term = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! disable_skip && ref_frame != INTRA_FRAME ) { //<S2SV> int64_t single_rd , hybrid_rd , single_rate , hybrid_rate ; //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { //<S2SV> single_rate = rate2 - compmode_cost ; //<S2SV> hybrid_rate = rate2 ; //<S2SV> } else { //<S2SV> single_rate = rate2 ; //<S2SV> hybrid_rate = rate2 + compmode_cost ; //<S2SV> } //<S2SV> single_rd = RDCOST ( x -> rdmult , x -> rddiv , single_rate , distortion2 ) ; //<S2SV> hybrid_rd = RDCOST ( x -> rdmult , x -> rddiv , hybrid_rate , distortion2 ) ; //<S2SV> if ( ! comp_pred ) { //<S2SV> if ( single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) { //<S2SV> best_pred_rd [ SINGLE_REFERENCE ] = single_rd ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) { //<S2SV> best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ; //<S2SV> } //<S2SV> } //<S2SV> if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] ) //<S2SV> best_pred_rd [ REFERENCE_MODE_SELECT ] = hybrid_rd ; //<S2SV> if ( ! mode_excluded && cm -> interp_filter != BILINEAR ) { //<S2SV> int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ? //<S2SV> SWITCHABLE_FILTERS : cm -> interp_filter ] ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { //<S2SV> int64_t adj_rd ; //<S2SV> if ( ref == INT64_MAX ) //<S2SV> adj_rd = 0 ; //<S2SV> else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX ) //<S2SV> adj_rd = cpi -> mask_filter_rd - ref + 10 ; //<S2SV> else //<S2SV> adj_rd = cpi -> rd_filter_cache [ i ] - ref ; //<S2SV> adj_rd += this_rd ; //<S2SV> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( bsize < BLOCK_32X32 ) { //<S2SV> if ( bsize < BLOCK_16X16 ) //<S2SV> tx_cache [ ALLOW_16X16 ] = tx_cache [ ALLOW_8X8 ] ; //<S2SV> tx_cache [ ALLOW_32X32 ] = tx_cache [ ALLOW_16X16 ] ; //<S2SV> } //<S2SV> if ( ! mode_excluded && this_rd != INT64_MAX ) { //<S2SV> for ( i = 0 ; i < TX_MODES && tx_cache [ i ] < INT64_MAX ; i ++ ) { //<S2SV> int64_t adj_rd = INT64_MAX ; //<S2SV> adj_rd = this_rd + tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ; //<S2SV> if ( adj_rd < best_tx_rd [ i ] ) //<S2SV> best_tx_rd [ i ] = adj_rd ; //<S2SV> } //<S2SV> } //<S2SV> if ( early_term ) //<S2SV> break ; //<S2SV> if ( x -> skip && ! comp_pred ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( best_rd >= best_rd_so_far ) //<S2SV> return INT64_MAX ; //<S2SV> if ( cpi -> sf . use_uv_intra_rd_estimate ) { //<S2SV> if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) { //<S2SV> TX_SIZE uv_tx_size ; //<S2SV> * mbmi = best_mbmode ; //<S2SV> uv_tx_size = get_uv_tx_size ( mbmi ) ; //<S2SV> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] , //<S2SV> & rate_uv_tokenonly [ uv_tx_size ] , //<S2SV> & dist_uv [ uv_tx_size ] , //<S2SV> & skip_uv [ uv_tx_size ] , //<S2SV> bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , //<S2SV> uv_tx_size ) ; //<S2SV> } //<S2SV> } //<S2SV> assert ( ( cm -> interp_filter == SWITCHABLE ) || //<S2SV> ( cm -> interp_filter == best_mbmode . interp_filter ) || //<S2SV> ! is_inter_block ( & best_mbmode ) ) ; //<S2SV> if ( cpi -> sf . adaptive_rd_thresh ) { //<S2SV> for ( mode_index = 0 ; mode_index < MAX_MODES ; ++ mode_index ) { //<S2SV> int * const fact = & cpi -> rd_thresh_freq_fact [ bsize ] [ mode_index ] ; //<S2SV> if ( mode_index == best_mode_index ) { //<S2SV> * fact -= ( * fact >> 3 ) ; //<S2SV> } else { //<S2SV> * fact = MIN ( * fact + RD_THRESH_INC , //<S2SV> cpi -> sf . adaptive_rd_thresh * RD_THRESH_MAX_FACT ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> * mbmi = best_mbmode ; //<S2SV> x -> skip |= best_skip2 ; //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { //<S2SV> if ( best_pred_rd [ i ] == INT64_MAX ) //<S2SV> best_pred_diff [ i ] = INT_MIN ; //<S2SV> else //<S2SV> best_pred_diff [ i ] = best_rd - best_pred_rd [ i ] ; //<S2SV> } //<S2SV> if ( ! x -> skip ) { //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { //<S2SV> if ( best_filter_rd [ i ] == INT64_MAX ) //<S2SV> best_filter_diff [ i ] = 0 ; //<S2SV> else //<S2SV> best_filter_diff [ i ] = best_rd - best_filter_rd [ i ] ; //<S2SV> } //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> assert ( best_filter_diff [ SWITCHABLE_FILTERS ] == 0 ) ; //<S2SV> for ( i = 0 ; i < TX_MODES ; i ++ ) { //<S2SV> if ( best_tx_rd [ i ] == INT64_MAX ) //<S2SV> best_tx_diff [ i ] = 0 ; //<S2SV> else //<S2SV> best_tx_diff [ i ] = best_rd - best_tx_rd [ i ] ; //<S2SV> } //<S2SV> } else { //<S2SV> vp9_zero ( best_filter_diff ) ; //<S2SV> vp9_zero ( best_tx_diff ) ; //<S2SV> } //<S2SV> if ( ! x -> in_active_map ) { //<S2SV> assert ( mbmi -> ref_frame [ 0 ] == LAST_FRAME ) ; //<S2SV> assert ( mbmi -> ref_frame [ 1 ] == NONE ) ; //<S2SV> assert ( mbmi -> mode == NEARESTMV || //<S2SV> mbmi -> mode == NEARMV || //<S2SV> mbmi -> mode == ZEROMV ) ; //<S2SV> assert ( frame_mv [ mbmi -> mode ] [ LAST_FRAME ] . as_int == 0 ) ; //<S2SV> assert ( mbmi -> mode == mbmi -> uv_mode ) ; //<S2SV> } //<S2SV> set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; //<S2SV> store_coding_context ( x , ctx , best_mode_index , //<S2SV> & mbmi -> ref_mvs [ mbmi -> ref_frame [ 0 ] ] [ 0 ] , //<S2SV> & mbmi -> ref_mvs [ mbmi -> ref_frame [ 1 ] < 0 ? 0 : //<S2SV> mbmi -> ref_frame [ 1 ] ] [ 0 ] , //<S2SV> best_pred_diff , best_tx_diff , best_filter_diff ) ; //<S2SV> return best_rd ; //<S2SV> } //<S2SV> 