static void rd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> int mi_row , int mi_col , //<S2SV> int * totalrate , int64_t * totaldist , //<S2SV> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , //<S2SV> int64_t best_rd ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi ; //<S2SV> struct macroblock_plane * const p = x -> plane ; //<S2SV> struct macroblockd_plane * const pd = xd -> plane ; //<S2SV> const AQ_MODE aq_mode = cpi -> oxcf . aq_mode ; //<S2SV> int i , orig_rdmult ; //<S2SV> double rdmult_ratio ; //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> rdmult_ratio = 1.0 ; //<S2SV> x -> use_lp32x32fdct = 1 ; //<S2SV> if ( bsize < BLOCK_8X8 ) { //<S2SV> if ( x -> ab_index != 0 ) { //<S2SV> * totalrate = 0 ; //<S2SV> * totaldist = 0 ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; //<S2SV> mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> mbmi -> sb_type = bsize ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 0 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 0 ] ; //<S2SV> } //<S2SV> ctx -> is_coded = 0 ; //<S2SV> x -> skip_recode = 0 ; //<S2SV> mbmi -> skip = 0 ; //<S2SV> x -> source_variance = get_sby_perpixel_variance ( cpi , x , bsize ) ; //<S2SV> if ( aq_mode == VARIANCE_AQ ) { //<S2SV> const int energy = bsize <= BLOCK_16X16 ? x -> mb_energy //<S2SV> : vp9_block_energy ( cpi , x , bsize ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME || //<S2SV> cpi -> refresh_alt_ref_frame || //<S2SV> ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { //<S2SV> mbmi -> segment_id = vp9_vaq_segment_id ( energy ) ; //<S2SV> } else { //<S2SV> const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map //<S2SV> : cm -> last_frame_seg_map ; //<S2SV> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; //<S2SV> } //<S2SV> rdmult_ratio = vp9_vaq_rdmult_ratio ( energy ) ; //<S2SV> vp9_init_plane_quantizers ( cpi , x ) ; //<S2SV> } //<S2SV> orig_rdmult = x -> rdmult ; //<S2SV> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) //<S2SV> activity_masking ( cpi , x ) ; //<S2SV> if ( aq_mode == VARIANCE_AQ ) { //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> x -> rdmult = ( int ) round ( x -> rdmult * rdmult_ratio ) ; //<S2SV> } else if ( aq_mode == COMPLEXITY_AQ ) { //<S2SV> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; //<S2SV> unsigned char complexity = cpi -> complexity_map [ mi_offset ] ; //<S2SV> const int is_edge = ( mi_row <= 1 ) || ( mi_row >= ( cm -> mi_rows - 2 ) ) || //<S2SV> ( mi_col <= 1 ) || ( mi_col >= ( cm -> mi_cols - 2 ) ) ; //<S2SV> if ( ! is_edge && ( complexity > 128 ) ) //<S2SV> x -> rdmult += ( ( x -> rdmult * ( complexity - 128 ) ) / 256 ) ; //<S2SV> } else if ( aq_mode == CYCLIC_REFRESH_AQ ) { //<S2SV> const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map //<S2SV> : cm -> last_frame_seg_map ; //<S2SV> if ( vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ) //<S2SV> x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; //<S2SV> } //<S2SV> if ( frame_is_intra_only ( cm ) ) { //<S2SV> vp9_rd_pick_intra_mode_sb ( cpi , x , totalrate , totaldist , bsize , ctx , //<S2SV> best_rd ) ; //<S2SV> } else { //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> vp9_rd_pick_inter_mode_sb ( cpi , x , tile , mi_row , mi_col , //<S2SV> totalrate , totaldist , bsize , ctx , best_rd ) ; //<S2SV> else //<S2SV> vp9_rd_pick_inter_mode_sub8x8 ( cpi , x , tile , mi_row , mi_col , totalrate , //<S2SV> totaldist , bsize , ctx , best_rd ) ; //<S2SV> } //<S2SV> if ( aq_mode == VARIANCE_AQ ) { //<S2SV> x -> rdmult = orig_rdmult ; //<S2SV> if ( * totalrate != INT_MAX ) { //<S2SV> vp9_clear_system_state ( ) ; //<S2SV> * totalrate = ( int ) round ( * totalrate * rdmult_ratio ) ; //<S2SV> } //<S2SV> } else if ( aq_mode == COMPLEXITY_AQ || aq_mode == CYCLIC_REFRESH_AQ ) { //<S2SV> x -> rdmult = orig_rdmult ; //<S2SV> } //<S2SV> } //<S2SV> 