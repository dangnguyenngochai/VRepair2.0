static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , //<S2SV> const uint8_t * data , //<S2SV> const uint8_t * data_end ) { //<S2SV> VP9_COMMON * const cm = & pbi -> common ; //<S2SV> const uint8_t * bit_reader_end = NULL ; //<S2SV> const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; //<S2SV> const int tile_cols = 1 << cm -> log2_tile_cols ; //<S2SV> const int tile_rows = 1 << cm -> log2_tile_rows ; //<S2SV> const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ; //<S2SV> TileBuffer tile_buffers [ 1 << 6 ] ; //<S2SV> int n ; //<S2SV> int final_worker = - 1 ; //<S2SV> assert ( tile_cols <= ( 1 << 6 ) ) ; //<S2SV> assert ( tile_rows == 1 ) ; //<S2SV> ( void ) tile_rows ; //<S2SV> if ( pbi -> num_tile_workers == 0 ) { //<S2SV> const int num_threads = pbi -> oxcf . max_threads & ~ 1 ; //<S2SV> int i ; //<S2SV> CHECK_MEM_ERROR ( cm , pbi -> tile_workers , //<S2SV> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; //<S2SV> for ( i = 0 ; i < num_threads ; ++ i ) { //<S2SV> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; //<S2SV> ++ pbi -> num_tile_workers ; //<S2SV> vp9_worker_init ( worker ) ; //<S2SV> CHECK_MEM_ERROR ( cm , worker -> data1 , //<S2SV> vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ; //<S2SV> CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ; //<S2SV> if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , //<S2SV> "Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( n = 0 ; n < num_workers ; ++ n ) { //<S2SV> pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ; //<S2SV> } //<S2SV> vpx_memset ( cm -> above_context , 0 , //<S2SV> sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ; //<S2SV> vpx_memset ( cm -> above_seg_context , 0 , //<S2SV> sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ; //<S2SV> for ( n = 0 ; n < tile_cols ; ++ n ) { //<S2SV> const size_t size = //<S2SV> get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ; //<S2SV> TileBuffer * const buf = & tile_buffers [ n ] ; //<S2SV> buf -> data = data ; //<S2SV> buf -> size = size ; //<S2SV> buf -> col = n ; //<S2SV> data += size ; //<S2SV> } //<S2SV> qsort ( tile_buffers , tile_cols , sizeof ( tile_buffers [ 0 ] ) , compare_tile_buffers ) ; //<S2SV> { //<S2SV> int group_start = 0 ; //<S2SV> while ( group_start < tile_cols ) { //<S2SV> const TileBuffer largest = tile_buffers [ group_start ] ; //<S2SV> const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; //<S2SV> memmove ( tile_buffers + group_start , tile_buffers + group_start + 1 , //<S2SV> ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] ) ) ; //<S2SV> tile_buffers [ group_end ] = largest ; //<S2SV> group_start = group_end + 1 ; //<S2SV> } //<S2SV> } //<S2SV> n = 0 ; //<S2SV> while ( n < tile_cols ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { //<S2SV> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; //<S2SV> TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; //<S2SV> TileInfo * const tile = ( TileInfo * ) worker -> data2 ; //<S2SV> TileBuffer * const buf = & tile_buffers [ n ] ; //<S2SV> tile_data -> cm = cm ; //<S2SV> tile_data -> xd = pbi -> mb ; //<S2SV> tile_data -> xd . corrupted = 0 ; //<S2SV> vp9_tile_init ( tile , tile_data -> cm , 0 , buf -> col ) ; //<S2SV> setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , //<S2SV> & tile_data -> bit_reader ) ; //<S2SV> init_macroblockd ( cm , & tile_data -> xd ) ; //<S2SV> vp9_zero ( tile_data -> xd . dqcoeff ) ; //<S2SV> worker -> had_error = 0 ; //<S2SV> if ( i == num_workers - 1 || n == tile_cols - 1 ) { //<S2SV> vp9_worker_execute ( worker ) ; //<S2SV> } else { //<S2SV> vp9_worker_launch ( worker ) ; //<S2SV> } //<S2SV> if ( buf -> col == tile_cols - 1 ) { //<S2SV> final_worker = i ; //<S2SV> } //<S2SV> ++ n ; //<S2SV> } //<S2SV> for ( ; i > 0 ; -- i ) { //<S2SV> VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ; //<S2SV> pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ; //<S2SV> } //<S2SV> if ( final_worker > - 1 ) { //<S2SV> TileWorkerData * const tile_data = //<S2SV> ( TileWorkerData * ) pbi -> tile_workers [ final_worker ] . data1 ; //<S2SV> bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ; //<S2SV> final_worker = - 1 ; //<S2SV> } //<S2SV> } //<S2SV> return bit_reader_end ; //<S2SV> } //<S2SV> 