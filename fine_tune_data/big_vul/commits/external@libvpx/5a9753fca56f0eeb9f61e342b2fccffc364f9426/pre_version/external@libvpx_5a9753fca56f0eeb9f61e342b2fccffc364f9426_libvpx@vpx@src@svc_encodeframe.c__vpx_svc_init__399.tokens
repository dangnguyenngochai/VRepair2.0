vpx_codec_err_t vpx_svc_init ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , //<S2SV> vpx_codec_iface_t * iface , //<S2SV> vpx_codec_enc_cfg_t * enc_cfg ) { //<S2SV> int max_intra_size_pct ; //<S2SV> vpx_codec_err_t res ; //<S2SV> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; //<S2SV> if ( svc_ctx == NULL || codec_ctx == NULL || iface == NULL || //<S2SV> enc_cfg == NULL ) { //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> } //<S2SV> if ( si == NULL ) return VPX_CODEC_MEM_ERROR ; //<S2SV> si -> codec_ctx = codec_ctx ; //<S2SV> si -> width = enc_cfg -> g_w ; //<S2SV> si -> height = enc_cfg -> g_h ; //<S2SV> if ( enc_cfg -> kf_max_dist < 2 ) { //<S2SV> svc_log ( svc_ctx , SVC_LOG_ERROR , "key<S2SV_blank>frame<S2SV_blank>distance<S2SV_blank>too<S2SV_blank>small:<S2SV_blank>%d\\n" , //<S2SV> enc_cfg -> kf_max_dist ) ; //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> } //<S2SV> si -> kf_dist = enc_cfg -> kf_max_dist ; //<S2SV> if ( svc_ctx -> spatial_layers == 0 ) //<S2SV> svc_ctx -> spatial_layers = VPX_SS_DEFAULT_LAYERS ; //<S2SV> if ( svc_ctx -> spatial_layers < 1 || //<S2SV> svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) { //<S2SV> svc_log ( svc_ctx , SVC_LOG_ERROR , "spatial<S2SV_blank>layers:<S2SV_blank>invalid<S2SV_blank>value:<S2SV_blank>%d\\n" , //<S2SV> svc_ctx -> spatial_layers ) ; //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> } //<S2SV> res = parse_quantizer_values ( svc_ctx , si -> quantizers , 0 ) ; //<S2SV> if ( res != VPX_CODEC_OK ) return res ; //<S2SV> res = parse_quantizer_values ( svc_ctx , si -> quantizers_keyframe , 1 ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> memcpy ( si -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; //<S2SV> res = parse_scale_factors ( svc_ctx , si -> scale_factors ) ; //<S2SV> if ( res != VPX_CODEC_OK ) return res ; //<S2SV> res = parse_options ( svc_ctx , si -> options ) ; //<S2SV> if ( res != VPX_CODEC_OK ) return res ; //<S2SV> si -> layers = svc_ctx -> spatial_layers ; //<S2SV> if ( si -> layers > 1 ) { //<S2SV> int i ; //<S2SV> float total = 0 ; //<S2SV> float alloc_ratio [ VPX_SS_MAX_LAYERS ] = { 0 } ; //<S2SV> assert ( si -> layers <= VPX_SS_MAX_LAYERS ) ; //<S2SV> for ( i = 0 ; i < si -> layers ; ++ i ) { //<S2SV> int pos = i + VPX_SS_MAX_LAYERS - svc_ctx -> spatial_layers ; //<S2SV> if ( pos < VPX_SS_MAX_LAYERS && si -> scaling_factor_den [ pos ] > 0 ) { //<S2SV> alloc_ratio [ i ] = ( float ) ( si -> scaling_factor_num [ pos ] * 1.0 / //<S2SV> si -> scaling_factor_den [ pos ] ) ; //<S2SV> alloc_ratio [ i ] *= alloc_ratio [ i ] ; //<S2SV> total += alloc_ratio [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < si -> layers ; ++ i ) { //<S2SV> if ( total > 0 ) { //<S2SV> enc_cfg -> ss_target_bitrate [ i ] = ( unsigned int ) //<S2SV> ( enc_cfg -> rc_target_bitrate * alloc_ratio [ i ] / total ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> enc_cfg -> ss_number_layers = si -> layers ; //<S2SV> enc_cfg -> ts_number_layers = 1 ; //<S2SV> enc_cfg -> kf_mode = VPX_KF_DISABLED ; //<S2SV> enc_cfg -> g_lag_in_frames = 0 ; //<S2SV> enc_cfg -> rc_dropframe_thresh = 0 ; //<S2SV> enc_cfg -> rc_end_usage = VPX_CBR ; //<S2SV> enc_cfg -> rc_resize_allowed = 0 ; //<S2SV> if ( enc_cfg -> g_pass == VPX_RC_ONE_PASS ) { //<S2SV> enc_cfg -> rc_min_quantizer = 33 ; //<S2SV> enc_cfg -> rc_max_quantizer = 33 ; //<S2SV> } //<S2SV> enc_cfg -> rc_undershoot_pct = 100 ; //<S2SV> enc_cfg -> rc_overshoot_pct = 15 ; //<S2SV> enc_cfg -> rc_buf_initial_sz = 500 ; //<S2SV> enc_cfg -> rc_buf_optimal_sz = 600 ; //<S2SV> enc_cfg -> rc_buf_sz = 1000 ; //<S2SV> enc_cfg -> g_error_resilient = 1 ; //<S2SV> res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR ) ; //<S2SV> if ( res != VPX_CODEC_OK ) { //<S2SV> svc_log ( svc_ctx , SVC_LOG_ERROR , "svc_enc_init<S2SV_blank>error\\n" ) ; //<S2SV> return res ; //<S2SV> } //<S2SV> vpx_codec_control ( codec_ctx , VP9E_SET_SVC , 1 ) ; //<S2SV> vpx_codec_control ( codec_ctx , VP8E_SET_CPUUSED , 1 ) ; //<S2SV> vpx_codec_control ( codec_ctx , VP8E_SET_STATIC_THRESHOLD , 1 ) ; //<S2SV> vpx_codec_control ( codec_ctx , VP8E_SET_NOISE_SENSITIVITY , 1 ) ; //<S2SV> vpx_codec_control ( codec_ctx , VP8E_SET_TOKEN_PARTITIONS , 1 ) ; //<S2SV> max_intra_size_pct = //<S2SV> ( int ) ( ( ( double ) enc_cfg -> rc_buf_optimal_sz * 0.5 ) * //<S2SV> ( ( double ) enc_cfg -> g_timebase . den / enc_cfg -> g_timebase . num ) / 10.0 ) ; //<S2SV> vpx_codec_control ( codec_ctx , VP8E_SET_MAX_INTRA_BITRATE_PCT , //<S2SV> max_intra_size_pct ) ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 