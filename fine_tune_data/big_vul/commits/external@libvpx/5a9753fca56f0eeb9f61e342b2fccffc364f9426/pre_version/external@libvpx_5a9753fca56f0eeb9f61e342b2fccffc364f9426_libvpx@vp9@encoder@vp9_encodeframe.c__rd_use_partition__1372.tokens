static void rd_use_partition ( VP9_COMP * cpi , //<S2SV> const TileInfo * const tile , //<S2SV> MODE_INFO * * mi_8x8 , //<S2SV> TOKENEXTRA * * tp , int mi_row , int mi_col , //<S2SV> BLOCK_SIZE bsize , int * rate , int64_t * dist , //<S2SV> int do_recon ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> const int bsl = b_width_log2 ( bsize ) ; //<S2SV> const int mi_step = num_4x4_blocks_wide_lookup [ bsize ] / 2 ; //<S2SV> const int bss = ( 1 << bsl ) / 4 ; //<S2SV> int i , pl ; //<S2SV> PARTITION_TYPE partition = PARTITION_NONE ; //<S2SV> BLOCK_SIZE subsize ; //<S2SV> ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; //<S2SV> PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; //<S2SV> int last_part_rate = INT_MAX ; //<S2SV> int64_t last_part_dist = INT64_MAX ; //<S2SV> int64_t last_part_rd = INT64_MAX ; //<S2SV> int none_rate = INT_MAX ; //<S2SV> int64_t none_dist = INT64_MAX ; //<S2SV> int64_t none_rd = INT64_MAX ; //<S2SV> int chosen_rate = INT_MAX ; //<S2SV> int64_t chosen_dist = INT64_MAX ; //<S2SV> int64_t chosen_rd = INT64_MAX ; //<S2SV> BLOCK_SIZE sub_subsize = BLOCK_4X4 ; //<S2SV> int splits_below = 0 ; //<S2SV> BLOCK_SIZE bs_type = mi_8x8 [ 0 ] -> mbmi . sb_type ; //<S2SV> int do_partition_search = 1 ; //<S2SV> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) //<S2SV> return ; //<S2SV> assert ( num_4x4_blocks_wide_lookup [ bsize ] == //<S2SV> num_4x4_blocks_high_lookup [ bsize ] ) ; //<S2SV> partition = partition_lookup [ bsl ] [ bs_type ] ; //<S2SV> subsize = get_subsize ( bsize , partition ) ; //<S2SV> if ( bsize < BLOCK_8X8 ) { //<S2SV> if ( x -> ab_index != 0 ) { //<S2SV> * rate = 0 ; //<S2SV> * dist = 0 ; //<S2SV> return ; //<S2SV> } //<S2SV> } else { //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> } //<S2SV> save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> if ( bsize == BLOCK_16X16 ) { //<S2SV> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; //<S2SV> x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ; //<S2SV> } else { //<S2SV> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; //<S2SV> } //<S2SV> if ( ! x -> in_active_map ) { //<S2SV> do_partition_search = 0 ; //<S2SV> if ( mi_row + ( mi_step >> 1 ) < cm -> mi_rows && //<S2SV> mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; //<S2SV> bs_type = mi_8x8 [ 0 ] -> mbmi . sb_type = bsize ; //<S2SV> subsize = bsize ; //<S2SV> partition = PARTITION_NONE ; //<S2SV> } //<S2SV> } //<S2SV> if ( do_partition_search && //<S2SV> cpi -> sf . partition_search_type == SEARCH_PARTITION && //<S2SV> cpi -> sf . adjust_partitioning_from_last_frame ) { //<S2SV> if ( partition == PARTITION_SPLIT && subsize > BLOCK_8X8 ) { //<S2SV> sub_subsize = get_subsize ( subsize , PARTITION_SPLIT ) ; //<S2SV> splits_below = 1 ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> int jj = i >> 1 , ii = i & 0x01 ; //<S2SV> MODE_INFO * this_mi = mi_8x8 [ jj * bss * mis + ii * bss ] ; //<S2SV> if ( this_mi && this_mi -> mbmi . sb_type >= sub_subsize ) { //<S2SV> splits_below = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( partition != PARTITION_NONE && ! splits_below && //<S2SV> mi_row + ( mi_step >> 1 ) < cm -> mi_rows && //<S2SV> mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & none_rate , & none_dist , bsize , //<S2SV> get_block_context ( x , bsize ) , INT64_MAX ) ; //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( none_rate < INT_MAX ) { //<S2SV> none_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; //<S2SV> none_rd = RDCOST ( x -> rdmult , x -> rddiv , none_rate , none_dist ) ; //<S2SV> } //<S2SV> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> mi_8x8 [ 0 ] -> mbmi . sb_type = bs_type ; //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> } //<S2SV> } //<S2SV> switch ( partition ) { //<S2SV> case PARTITION_NONE : //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , //<S2SV> & last_part_dist , bsize , //<S2SV> get_block_context ( x , bsize ) , INT64_MAX ) ; //<S2SV> break ; //<S2SV> case PARTITION_HORZ : //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , //<S2SV> & last_part_dist , subsize , //<S2SV> get_block_context ( x , subsize ) , INT64_MAX ) ; //<S2SV> if ( last_part_rate != INT_MAX && //<S2SV> bsize >= BLOCK_8X8 && mi_row + ( mi_step >> 1 ) < cm -> mi_rows ) { //<S2SV> int rt = 0 ; //<S2SV> int64_t dt = 0 ; //<S2SV> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , //<S2SV> subsize , 0 ) ; //<S2SV> encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row + ( mi_step >> 1 ) , mi_col , & rt , & dt , //<S2SV> subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; //<S2SV> if ( rt == INT_MAX || dt == INT64_MAX ) { //<S2SV> last_part_rate = INT_MAX ; //<S2SV> last_part_dist = INT64_MAX ; //<S2SV> break ; //<S2SV> } //<S2SV> last_part_rate += rt ; //<S2SV> last_part_dist += dt ; //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_VERT : //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col , & last_part_rate , //<S2SV> & last_part_dist , subsize , //<S2SV> get_block_context ( x , subsize ) , INT64_MAX ) ; //<S2SV> if ( last_part_rate != INT_MAX && //<S2SV> bsize >= BLOCK_8X8 && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { //<S2SV> int rt = 0 ; //<S2SV> int64_t dt = 0 ; //<S2SV> update_state ( cpi , get_block_context ( x , subsize ) , mi_row , mi_col , //<S2SV> subsize , 0 ) ; //<S2SV> encode_superblock ( cpi , tp , 0 , mi_row , mi_col , subsize ) ; //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row , mi_col + ( mi_step >> 1 ) , & rt , & dt , //<S2SV> subsize , get_block_context ( x , subsize ) , INT64_MAX ) ; //<S2SV> if ( rt == INT_MAX || dt == INT64_MAX ) { //<S2SV> last_part_rate = INT_MAX ; //<S2SV> last_part_dist = INT64_MAX ; //<S2SV> break ; //<S2SV> } //<S2SV> last_part_rate += rt ; //<S2SV> last_part_dist += dt ; //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_SPLIT : //<S2SV> last_part_rate = 0 ; //<S2SV> last_part_dist = 0 ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ; //<S2SV> int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ; //<S2SV> int jj = i >> 1 , ii = i & 0x01 ; //<S2SV> int rt ; //<S2SV> int64_t dt ; //<S2SV> if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) //<S2SV> continue ; //<S2SV> * get_sb_index ( x , subsize ) = i ; //<S2SV> rd_use_partition ( cpi , tile , mi_8x8 + jj * bss * mis + ii * bss , tp , //<S2SV> mi_row + y_idx , mi_col + x_idx , subsize , & rt , & dt , //<S2SV> i != 3 ) ; //<S2SV> if ( rt == INT_MAX || dt == INT64_MAX ) { //<S2SV> last_part_rate = INT_MAX ; //<S2SV> last_part_dist = INT64_MAX ; //<S2SV> break ; //<S2SV> } //<S2SV> last_part_rate += rt ; //<S2SV> last_part_dist += dt ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> } //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( last_part_rate < INT_MAX ) { //<S2SV> last_part_rate += x -> partition_cost [ pl ] [ partition ] ; //<S2SV> last_part_rd = RDCOST ( x -> rdmult , x -> rddiv , last_part_rate , last_part_dist ) ; //<S2SV> } //<S2SV> if ( do_partition_search //<S2SV> && cpi -> sf . adjust_partitioning_from_last_frame //<S2SV> && cpi -> sf . partition_search_type == SEARCH_PARTITION //<S2SV> && partition != PARTITION_SPLIT && bsize > BLOCK_8X8 //<S2SV> && ( mi_row + mi_step < cm -> mi_rows || //<S2SV> mi_row + ( mi_step >> 1 ) == cm -> mi_rows ) //<S2SV> && ( mi_col + mi_step < cm -> mi_cols || //<S2SV> mi_col + ( mi_step >> 1 ) == cm -> mi_cols ) ) { //<S2SV> BLOCK_SIZE split_subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; //<S2SV> chosen_rate = 0 ; //<S2SV> chosen_dist = 0 ; //<S2SV> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ; //<S2SV> int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ; //<S2SV> int rt = 0 ; //<S2SV> int64_t dt = 0 ; //<S2SV> ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; //<S2SV> PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; //<S2SV> if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) //<S2SV> continue ; //<S2SV> * get_sb_index ( x , split_subsize ) = i ; //<S2SV> * get_sb_partitioning ( x , bsize ) = split_subsize ; //<S2SV> * get_sb_partitioning ( x , split_subsize ) = split_subsize ; //<S2SV> save_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> rd_pick_sb_modes ( cpi , tile , mi_row + y_idx , mi_col + x_idx , & rt , & dt , //<S2SV> split_subsize , get_block_context ( x , split_subsize ) , //<S2SV> INT64_MAX ) ; //<S2SV> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> if ( rt == INT_MAX || dt == INT64_MAX ) { //<S2SV> chosen_rate = INT_MAX ; //<S2SV> chosen_dist = INT64_MAX ; //<S2SV> break ; //<S2SV> } //<S2SV> chosen_rate += rt ; //<S2SV> chosen_dist += dt ; //<S2SV> if ( i != 3 ) //<S2SV> encode_sb ( cpi , tile , tp , mi_row + y_idx , mi_col + x_idx , 0 , //<S2SV> split_subsize ) ; //<S2SV> pl = partition_plane_context ( xd , mi_row + y_idx , mi_col + x_idx , //<S2SV> split_subsize ) ; //<S2SV> chosen_rate += x -> partition_cost [ pl ] [ PARTITION_NONE ] ; //<S2SV> } //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( chosen_rate < INT_MAX ) { //<S2SV> chosen_rate += x -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; //<S2SV> chosen_rd = RDCOST ( x -> rdmult , x -> rddiv , chosen_rate , chosen_dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( last_part_rd < chosen_rd ) { //<S2SV> mi_8x8 [ 0 ] -> mbmi . sb_type = bsize ; //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = subsize ; //<S2SV> chosen_rate = last_part_rate ; //<S2SV> chosen_dist = last_part_dist ; //<S2SV> chosen_rd = last_part_rd ; //<S2SV> } //<S2SV> if ( none_rd < chosen_rd ) { //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> * ( get_sb_partitioning ( x , bsize ) ) = bsize ; //<S2SV> chosen_rate = none_rate ; //<S2SV> chosen_dist = none_dist ; //<S2SV> } //<S2SV> restore_context ( cpi , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> if ( bsize == BLOCK_64X64 ) //<S2SV> assert ( chosen_rate < INT_MAX && chosen_dist < INT64_MAX ) ; //<S2SV> if ( do_recon ) { //<S2SV> int output_enabled = ( bsize == BLOCK_64X64 ) ; //<S2SV> if ( ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) && cm -> seg . update_map ) { //<S2SV> vp9_select_in_frame_q_segment ( cpi , mi_row , mi_col , //<S2SV> output_enabled , chosen_rate ) ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) //<S2SV> vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , //<S2SV> chosen_rate , chosen_dist ) ; //<S2SV> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , bsize ) ; //<S2SV> } //<S2SV> * rate = chosen_rate ; //<S2SV> * dist = chosen_dist ; //<S2SV> } //<S2SV> 