static void encode_frame_internal ( VP9_COMP * cpi ) { //<S2SV> SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> xd -> mi = cm -> mi_grid_visible ; //<S2SV> xd -> mi [ 0 ] = cm -> mi ; //<S2SV> vp9_zero ( cm -> counts ) ; //<S2SV> vp9_zero ( cpi -> coef_counts ) ; //<S2SV> vp9_zero ( cpi -> tx_stepdown_count ) ; //<S2SV> vp9_zero ( cpi -> rd_comp_pred_diff ) ; //<S2SV> vp9_zero ( cpi -> rd_filter_diff ) ; //<S2SV> vp9_zero ( cpi -> rd_tx_select_diff ) ; //<S2SV> vp9_zero ( cpi -> rd_tx_select_threshes ) ; //<S2SV> cm -> tx_mode = select_tx_mode ( cpi ) ; //<S2SV> cpi -> mb . e_mbd . lossless = cm -> base_qindex == 0 && //<S2SV> cm -> y_dc_delta_q == 0 && //<S2SV> cm -> uv_dc_delta_q == 0 && //<S2SV> cm -> uv_ac_delta_q == 0 ; //<S2SV> switch_lossless_mode ( cpi , cpi -> mb . e_mbd . lossless ) ; //<S2SV> vp9_frame_init_quantizer ( cpi ) ; //<S2SV> vp9_initialize_rd_consts ( cpi ) ; //<S2SV> vp9_initialize_me_consts ( cpi , cm -> base_qindex ) ; //<S2SV> init_encode_frame_mb_context ( cpi ) ; //<S2SV> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) //<S2SV> build_activity_map ( cpi ) ; //<S2SV> cm -> prev_mi = get_prev_mi ( cm ) ; //<S2SV> if ( sf -> use_nonrd_pick_mode ) { //<S2SV> int i ; //<S2SV> struct macroblock_plane * const p = x -> plane ; //<S2SV> struct macroblockd_plane * const pd = xd -> plane ; //<S2SV> PICK_MODE_CONTEXT * ctx = & cpi -> mb . sb64_context ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 0 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 0 ] ; //<S2SV> } //<S2SV> vp9_zero ( x -> zcoeff_blk ) ; //<S2SV> if ( cpi -> sf . partition_search_type == SOURCE_VAR_BASED_PARTITION && //<S2SV> cm -> current_video_frame > 0 ) { //<S2SV> int check_freq = cpi -> sf . search_type_check_frequency ; //<S2SV> if ( ( cm -> current_video_frame - 1 ) % check_freq == 0 ) { //<S2SV> cpi -> use_large_partition_rate = 0 ; //<S2SV> } //<S2SV> if ( ( cm -> current_video_frame - 1 ) % check_freq == 1 ) { //<S2SV> const int mbs_in_b32x32 = 1 << ( ( b_width_log2_lookup [ BLOCK_32X32 ] - //<S2SV> b_width_log2_lookup [ BLOCK_16X16 ] ) + //<S2SV> ( b_height_log2_lookup [ BLOCK_32X32 ] - //<S2SV> b_height_log2_lookup [ BLOCK_16X16 ] ) ) ; //<S2SV> cpi -> use_large_partition_rate = cpi -> use_large_partition_rate * 100 * //<S2SV> mbs_in_b32x32 / cm -> MBs ; //<S2SV> } //<S2SV> if ( ( cm -> current_video_frame - 1 ) % check_freq >= 1 ) { //<S2SV> if ( cpi -> use_large_partition_rate < 15 ) //<S2SV> cpi -> sf . partition_search_type = FIXED_PARTITION ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> struct vpx_usec_timer emr_timer ; //<S2SV> vpx_usec_timer_start ( & emr_timer ) ; //<S2SV> { //<S2SV> int tile_col , tile_row ; //<S2SV> TOKENEXTRA * tp = cpi -> tok ; //<S2SV> const int tile_cols = 1 << cm -> log2_tile_cols ; //<S2SV> const int tile_rows = 1 << cm -> log2_tile_rows ; //<S2SV> for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { //<S2SV> for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { //<S2SV> TileInfo tile ; //<S2SV> TOKENEXTRA * tp_old = tp ; //<S2SV> int mi_row ; //<S2SV> vp9_tile_init ( & tile , cm , tile_row , tile_col ) ; //<S2SV> for ( mi_row = tile . mi_row_start ; //<S2SV> mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { //<S2SV> if ( sf -> use_nonrd_pick_mode && cm -> frame_type != KEY_FRAME ) //<S2SV> encode_nonrd_sb_row ( cpi , & tile , mi_row , & tp ) ; //<S2SV> else //<S2SV> encode_rd_sb_row ( cpi , & tile , mi_row , & tp ) ; //<S2SV> } //<S2SV> cpi -> tok_count [ tile_row ] [ tile_col ] = ( unsigned int ) ( tp - tp_old ) ; //<S2SV> assert ( tp - cpi -> tok <= get_token_alloc ( cm -> mb_rows , cm -> mb_cols ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> vpx_usec_timer_mark ( & emr_timer ) ; //<S2SV> cpi -> time_encode_sb_row += vpx_usec_timer_elapsed ( & emr_timer ) ; //<S2SV> } //<S2SV> if ( sf -> skip_encode_sb ) { //<S2SV> int j ; //<S2SV> unsigned int intra_count = 0 , inter_count = 0 ; //<S2SV> for ( j = 0 ; j < INTRA_INTER_CONTEXTS ; ++ j ) { //<S2SV> intra_count += cm -> counts . intra_inter [ j ] [ 0 ] ; //<S2SV> inter_count += cm -> counts . intra_inter [ j ] [ 1 ] ; //<S2SV> } //<S2SV> sf -> skip_encode_frame = ( intra_count << 2 ) < inter_count && //<S2SV> cm -> frame_type != KEY_FRAME && //<S2SV> cm -> show_frame ; //<S2SV> } else { //<S2SV> sf -> skip_encode_frame = 0 ; //<S2SV> } //<S2SV> # if 0 //<S2SV> cpi -> last_frame_distortion = cpi -> frame_distortion ; //<S2SV> # endif //<S2SV> } //<S2SV> 